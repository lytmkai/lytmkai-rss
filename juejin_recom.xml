<?xml version="1.0" encoding="UTF-8"?><rss version="2.0">  <channel>      <title>掘金文章推荐</title>      <link>https://juejin.cn/recommended?sort=newest</link>      <description>一个帮助开发者成长的社区</description>      <generator>python juejin_recom.py @Pi20</generator>      <item>    <title><![CDATA[Vue 父子组件双向绑定的终极指南：告别数据同步烦恼！]]></title>    <link>https://juejin.cn/post/7590469811408830491</link>    <guid>https://juejin.cn/post/7590469811408830491</guid>    <pubDate>2026-01-03T05:08:27.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7590469811408830491" data-draft-id="7590292138347069450" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Vue 父子组件双向绑定的终极指南：告别数据同步烦恼！"/> <meta itemprop="keywords" content="Vue.js"/> <meta itemprop="datePublished" content="2026-01-03T05:08:27.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="北辰alk"/> <meta itemprop="url" content="https://juejin.cn/user/1772855673241352"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Vue 父子组件双向绑定的终极指南：告别数据同步烦恼！
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1772855673241352/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    北辰alk
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-03T05:08:27.000Z" title="Sat Jan 03 2026 05:08:27 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">Vue 父子组件双向绑定的终极指南：告别数据同步烦恼！</h2>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/530c134e2a6a486b912cc273e384633f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YyX6L6wYWxr:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768021707&amp;x-signature=JU8Tp9StTfefsHjDR3UkZpXWCso%3D" alt="Vue父子组件绑定头图" loading="lazy"/></p>
<h3 data-id="heading-1">引言</h3>
<p>在Vue开发中，父子组件之间的数据通信是每个开发者都会遇到的挑战。当父组件需要控制子组件状态，同时子组件也需要更新父组件数据时，如何优雅地实现双向绑定就成了关键问题。</p>
<p>今天，我将为你详细介绍Vue中实现父子组件双向绑定的4种核心方法，从基础到高级，让你彻底掌握这一重要技能！</p>
<h3 data-id="heading-2">一、基础知识：单向数据流原则</h3>
<p>在深入解决方案之前，我们先理解Vue的核心设计原则——单向数据流：</p>
<pre><code class="hljs">父组件 → Props → 子组件
子组件 → Events → 父组件
</code></pre>
<p>这种设计保证了数据流向的可预测性，但当我们确实需要双向绑定时，就需要一些技巧来实现。</p>
<h3 data-id="heading-3">二、方法一：Props + $emit（基础方法）</h3>
<p>这是Vue官方推荐的"单向数据流"实现双向绑定的标准方式。</p>
<h4 data-id="heading-4">实现原理</h4>
<ol>
<li>父组件通过props向子组件传递数据</li>
<li>子组件通过$emit触发事件通知父组件更新数据</li>
</ol>
<h4 data-id="heading-5">代码实现</h4>
<p><strong>子组件 ChildComponent.vue</strong></p>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;div class="child"&gt;
    &lt;h3&gt;子组件&lt;/h3&gt;
    &lt;input 
      :value="value" 
      @input="$emit('update:value', $event.target.value)"
      placeholder="输入内容..."
    /&gt;
    &lt;p&gt;当前值: {{ value }}&lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: 'ChildComponent',
  props: {
    value: {
      type: String,
      required: true
    }
  }
}
&lt;/script&gt;
</code></pre>
<p><strong>父组件 ParentComponent.vue</strong></p>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;div class="parent"&gt;
    &lt;h2&gt;父组件&lt;/h2&gt;
    &lt;p&gt;父组件中的值: {{ parentValue }}&lt;/p&gt;
    
    &lt;ChildComponent 
      :value="parentValue" 
      @update:value="parentValue = $event"
    /&gt;
    
    &lt;button @click="resetValue"&gt;重置为默认值&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import ChildComponent from './ChildComponent.vue'

export default {
  name: 'ParentComponent',
  components: {
    ChildComponent
  },
  data() {
    return {
      parentValue: '初始值'
    }
  },
  methods: {
    resetValue() {
      this.parentValue = '默认值'
    }
  }
}
&lt;/script&gt;
</code></pre>
<h4 data-id="heading-6">流程图解</h4>
<pre><code class="hljs language-mermaid" lang="mermaid">graph TD
    A[父组件数据变更] --&gt; B[Props传递给子组件]
    B --&gt; C[子组件接收数据]
    D[子组件用户输入] --&gt; E[$emit触发更新事件]
    E --&gt; F[父组件监听并更新数据]
    F --&gt; A
    
    style A fill:#e1f5fe
    style C fill:#f3e5f5
    style F fill:#e8f5e8
</code></pre>
<h4 data-id="heading-7">优缺点分析</h4>
<p><strong>优点：</strong></p>
<ul>
<li>符合Vue设计哲学</li>
<li>代码清晰，数据流向明确</li>
<li>易于调试和维护</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>需要编写较多样板代码</li>
<li>对于深层嵌套组件略显繁琐</li>
</ul>
<h3 data-id="heading-8">三、方法二：v-model指令（语法糖）</h3>
<p>Vue 2.2.0+ 提供了<code>.sync</code>修饰符的替代方案，使用自定义组件的<code>v-model</code>。</p>
<h4 data-id="heading-9">实现原理</h4>
<p><code>v-model</code>在组件上实际上是以下写法的语法糖：</p>
<pre><code class="hljs language-vue" lang="vue">&lt;ChildComponent 
  :value="parentValue"
  @input="parentValue = $event"
/&gt;
</code></pre>
<h4 data-id="heading-10">代码实现</h4>
<p><strong>子组件 ChildComponent.vue</strong></p>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;div class="child"&gt;
    &lt;h3&gt;子组件 (v-model)&lt;/h3&gt;
    &lt;select :value="value" @change="$emit('input', $event.target.value)"&gt;
      &lt;option value="vue"&gt;Vue.js&lt;/option&gt;
      &lt;option value="react"&gt;React&lt;/option&gt;
      &lt;option value="angular"&gt;Angular&lt;/option&gt;
    &lt;/select&gt;
    &lt;p&gt;选中的框架: {{ value }}&lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: 'ChildComponent',
  props: {
    value: {
      type: String,
      required: true
    }
  },
  model: {
    prop: 'value',    // 指定v-model绑定的prop名
    event: 'input'    // 指定v-model监听的事件名
  }
}
&lt;/script&gt;
</code></pre>
<p><strong>父组件 ParentComponent.vue</strong></p>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;div class="parent"&gt;
    &lt;h2&gt;父组件 (v-model示例)&lt;/h2&gt;
    &lt;p&gt;选择的框架: {{ selectedFramework }}&lt;/p&gt;
    
    &lt;!-- 使用v-model语法糖 --&gt;
    &lt;ChildComponent v-model="selectedFramework" /&gt;
    
    &lt;!-- 等价于 --&gt;
    &lt;!-- &lt;ChildComponent :value="selectedFramework" @input="selectedFramework = $event" /&gt; --&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import ChildComponent from './ChildComponent.vue'

export default {
  name: 'ParentComponent',
  components: {
    ChildComponent
  },
  data() {
    return {
      selectedFramework: 'vue'
    }
  }
}
&lt;/script&gt;
</code></pre>
<h4 data-id="heading-11">多个v-model绑定（Vue 2.3.0+）</h4>
<p>从Vue 2.3.0开始，可以通过<code>model</code>选项配置不同的prop和event，但在Vue 3中更加简化：</p>
<p><strong>Vue 3中的多个v-model</strong></p>
<pre><code class="hljs language-vue" lang="vue">&lt;!-- 父组件 --&gt;
&lt;UserName
  v-model:first-name="firstName"
  v-model:last-name="lastName"
/&gt;

&lt;!-- 子组件 --&gt;
&lt;script setup&gt;
defineProps({
  firstName: String,
  lastName: String
})

defineEmits(['update:firstName', 'update:lastName'])
&lt;/script&gt;
</code></pre>
<h3 data-id="heading-12">四、方法三：.sync修饰符（Vue 2.3.0+）</h3>
<p><code>.sync</code>修饰符是另一种语法糖，用于实现prop的"双向绑定"。</p>
<h4 data-id="heading-13">实现原理</h4>
<pre><code class="hljs language-vue" lang="vue">&lt;!-- 使用.sync --&gt;
&lt;ChildComponent :title.sync="pageTitle" /&gt;

&lt;!-- 等价于 --&gt;
&lt;ChildComponent 
  :title="pageTitle" 
  @update:title="pageTitle = $event"
/&gt;
</code></pre>
<h4 data-id="heading-14">代码实现</h4>
<p><strong>子组件 ChildComponent.vue</strong></p>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;div class="child"&gt;
    &lt;h3&gt;子组件 (.sync修饰符)&lt;/h3&gt;
    &lt;div class="counter"&gt;
      &lt;button @click="decrement"&gt;-&lt;/button&gt;
      &lt;span&gt;{{ count }}&lt;/span&gt;
      &lt;button @click="increment"&gt;+&lt;/button&gt;
    &lt;/div&gt;
    &lt;p&gt;当前计数: {{ count }}&lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: 'ChildComponent',
  props: {
    count: {
      type: Number,
      required: true
    }
  },
  methods: {
    increment() {
      this.$emit('update:count', this.count + 1)
    },
    decrement() {
      this.$emit('update:count', this.count - 1)
    }
  }
}
&lt;/script&gt;

&lt;style scoped&gt;
.counter {
  display: flex;
  align-items: center;
  gap: 10px;
  margin: 10px 0;
}
.counter button {
  padding: 5px 15px;
  font-size: 16px;
}
&lt;/style&gt;
</code></pre>
<p><strong>父组件 ParentComponent.vue</strong></p>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;div class="parent"&gt;
    &lt;h2&gt;父组件 (.sync示例)&lt;/h2&gt;
    &lt;p&gt;当前计数: {{ counter }}&lt;/p&gt;
    
    &lt;!-- 使用.sync修饰符 --&gt;
    &lt;ChildComponent :count.sync="counter" /&gt;
    
    &lt;!-- 可以同时绑定多个prop --&gt;
    &lt;!-- &lt;ChildComponent :count.sync="counter" :title.sync="pageTitle" /&gt; --&gt;
    
    &lt;button @click="counter = 0"&gt;重置计数&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import ChildComponent from './ChildComponent.vue'

export default {
  name: 'ParentComponent',
  components: {
    ChildComponent
  },
  data() {
    return {
      counter: 0
    }
  }
}
&lt;/script&gt;
</code></pre>
<h4 data-id="heading-15">.sync与v-model的区别</h4>






























<table><thead><tr><th>特性</th><th>v-model</th><th>.sync修饰符</th></tr></thead><tbody><tr><td>绑定数量</td><td>一个组件通常一个</td><td>可以多个</td></tr><tr><td>事件名</td><td>默认<code>input</code></td><td><code>update:propName</code></td></tr><tr><td>Prop名</td><td>默认<code>value</code></td><td>任意prop名</td></tr><tr><td>Vue 3支持</td><td>有变化</td><td>已移除，用v-model代替</td></tr></tbody></table>
<h3 data-id="heading-16">五、方法四：Vuex状态管理（复杂场景）</h3>
<p>对于大型应用或深层嵌套组件，使用Vuex进行状态管理是最佳选择。</p>
<h4 data-id="heading-17">实现架构</h4>
<pre><code class="hljs language-mermaid" lang="mermaid">graph TB
    A[组件] --&gt; B[触发Action]
    B --&gt; C[提交Mutation]
    C --&gt; D[更新State]
    D --&gt; E[响应式更新所有组件]
    
    subgraph "Vuex Store"
        C
        D
    end
    
    style D fill:#fff3e0
    style E fill:#e8f5e8
</code></pre>
<h4 data-id="heading-18">代码实现</h4>
<p><strong>store/index.js</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Vuex</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'vuex'</span>

<span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Vuex</span>)

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>({
  <span class="hljs-attr">state</span>: {
    <span class="hljs-attr">userSettings</span>: {
      <span class="hljs-attr">theme</span>: <span class="hljs-string">'light'</span>,
      <span class="hljs-attr">fontSize</span>: <span class="hljs-number">14</span>,
      <span class="hljs-attr">notifications</span>: <span class="hljs-literal">true</span>
    }
  },
  <span class="hljs-attr">mutations</span>: {
    <span class="hljs-title function_">UPDATE_SETTING</span>(<span class="hljs-params">state, { key, value }</span>) {
      <span class="hljs-keyword">if</span> (key <span class="hljs-keyword">in</span> state.<span class="hljs-property">userSettings</span>) {
        state.<span class="hljs-property">userSettings</span>[key] = value
      }
    },
    <span class="hljs-title function_">UPDATE_SETTINGS</span>(<span class="hljs-params">state, settings</span>) {
      state.<span class="hljs-property">userSettings</span> = { ...state.<span class="hljs-property">userSettings</span>, ...settings }
    }
  },
  <span class="hljs-attr">actions</span>: {
    <span class="hljs-title function_">updateSetting</span>(<span class="hljs-params">{ commit }, payload</span>) {
      <span class="hljs-title function_">commit</span>(<span class="hljs-string">'UPDATE_SETTING'</span>, payload)
    },
    <span class="hljs-title function_">resetSettings</span>(<span class="hljs-params">{ commit }</span>) {
      <span class="hljs-title function_">commit</span>(<span class="hljs-string">'UPDATE_SETTINGS'</span>, {
        <span class="hljs-attr">theme</span>: <span class="hljs-string">'light'</span>,
        <span class="hljs-attr">fontSize</span>: <span class="hljs-number">14</span>,
        <span class="hljs-attr">notifications</span>: <span class="hljs-literal">true</span>
      })
    }
  },
  <span class="hljs-attr">getters</span>: {
    <span class="hljs-attr">userSettings</span>: <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> state.<span class="hljs-property">userSettings</span>,
    <span class="hljs-attr">darkMode</span>: <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> state.<span class="hljs-property">userSettings</span>.<span class="hljs-property">theme</span> === <span class="hljs-string">'dark'</span>
  }
})
</code></pre>
<p><strong>子组件 SettingsEditor.vue</strong></p>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;div class="settings-editor" :class="settings.theme"&gt;
    &lt;h3&gt;设置编辑器 (Vuex)&lt;/h3&gt;
    
    &lt;div class="setting-item"&gt;
      &lt;label&gt;主题模式：&lt;/label&gt;
      &lt;select :value="settings.theme" @change="updateSetting('theme', $event.target.value)"&gt;
        &lt;option value="light"&gt;浅色&lt;/option&gt;
        &lt;option value="dark"&gt;深色&lt;/option&gt;
      &lt;/select&gt;
    &lt;/div&gt;
    
    &lt;div class="setting-item"&gt;
      &lt;label&gt;字体大小：&lt;/label&gt;
      &lt;input 
        type="range" 
        min="10" 
        max="24" 
        :value="settings.fontSize"
        @input="updateSetting('fontSize', parseInt($event.target.value))"
      /&gt;
      &lt;span&gt;{{ settings.fontSize }}px&lt;/span&gt;
    &lt;/div&gt;
    
    &lt;div class="setting-item"&gt;
      &lt;label&gt;
        &lt;input 
          type="checkbox" 
          :checked="settings.notifications"
          @change="updateSetting('notifications', $event.target.checked)"
        /&gt;
        启用通知
      &lt;/label&gt;
    &lt;/div&gt;
    
    &lt;p&gt;当前主题: {{ settings.theme }} | 字体大小: {{ settings.fontSize }}px&lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import { mapState, mapActions } from 'vuex'

export default {
  name: 'SettingsEditor',
  computed: {
    ...mapState(['userSettings']),
    settings() {
      return this.userSettings
    }
  },
  methods: {
    ...mapActions(['updateSetting'])
  }
}
&lt;/script&gt;

&lt;style scoped&gt;
.settings-editor {
  padding: 20px;
  border-radius: 8px;
  transition: all 0.3s;
}
.settings-editor.light {
  background-color: #ffffff;
  color: #333333;
}
.settings-editor.dark {
  background-color: #333333;
  color: #ffffff;
}
.setting-item {
  margin: 15px 0;
}
.setting-item label {
  margin-right: 10px;
}
&lt;/style&gt;
</code></pre>
<p><strong>父组件 ParentComponent.vue</strong></p>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;div class="parent"&gt;
    &lt;h2&gt;父组件 (Vuex示例)&lt;/h2&gt;
    
    &lt;div class="settings-display"&gt;
      &lt;h3&gt;当前设置&lt;/h3&gt;
      &lt;ul&gt;
        &lt;li&gt;主题: {{ userSettings.theme }}&lt;/li&gt;
        &lt;li&gt;字体大小: {{ userSettings.fontSize }}px&lt;/li&gt;
        &lt;li&gt;通知: {{ userSettings.notifications ? '开启' : '关闭' }}&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/div&gt;
    
    &lt;SettingsEditor /&gt;
    
    &lt;div class="actions"&gt;
      &lt;button @click="resetSettings"&gt;恢复默认设置&lt;/button&gt;
      &lt;button @click="toggleTheme"&gt;切换主题&lt;/button&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import { mapState, mapActions, mapGetters } from 'vuex'
import SettingsEditor from './SettingsEditor.vue'

export default {
  name: 'ParentComponent',
  components: {
    SettingsEditor
  },
  computed: {
    ...mapState(['userSettings']),
    ...mapGetters(['darkMode'])
  },
  methods: {
    ...mapActions(['updateSetting', 'resetSettings']),
    toggleTheme() {
      const newTheme = this.darkMode ? 'light' : 'dark'
      this.updateSetting({ key: 'theme', value: newTheme })
    }
  }
}
&lt;/script&gt;
</code></pre>
<h3 data-id="heading-19">六、方法对比与选择指南</h3>
<h4 data-id="heading-20">方法对比表</h4>













































<table><thead><tr><th>方法</th><th>适用场景</th><th>优点</th><th>缺点</th><th>Vue 2支持</th><th>Vue 3支持</th></tr></thead><tbody><tr><td>Props + $emit</td><td>简单父子通信</td><td>官方推荐，清晰易懂</td><td>代码量多</td><td>✓</td><td>✓</td></tr><tr><td>v-model</td><td>表单类组件</td><td>语法简洁，使用广泛</td><td>单个绑定有限制</td><td>✓</td><td>✓ (增强)</td></tr><tr><td>.sync修饰符</td><td>多个prop需要双向绑定</td><td>支持多个绑定</td><td>Vue 3已移除</td><td>✓</td><td>✗</td></tr><tr><td>Vuex</td><td>复杂应用/多组件共享</td><td>集中管理，响应式</td><td>增加复杂度</td><td>✓</td><td>✓</td></tr></tbody></table>
<h4 data-id="heading-21">选择流程图</h4>
<pre><code class="hljs language-mermaid" lang="mermaid">graph TD
    A[开始选择双向绑定方案] --&gt; B{数据共享范围}
    
    B --&gt;|父子组件| C{绑定复杂度}
    B --&gt;|多个组件共享| D[使用Vuex/Pinia]
    
    C --&gt;|简单绑定| E{vue版本?}
    C --&gt;|多个prop绑定| F{Vue版本?}
    
    E --&gt;|Vue 2| G[Props + $emit 或 v-model]
    E --&gt;|Vue 3| H[v-model]
    
    F --&gt;|Vue 2| I[.sync修饰符]
    F --&gt;|Vue 3| J[多个v-model]
    
    G --&gt; K[完成选择]
    H --&gt; K
    I --&gt; K
    J --&gt; K
    D --&gt; K
</code></pre>
<h3 data-id="heading-22">七、实战技巧与最佳实践</h3>
<h4 data-id="heading-23">1. 使用计算属性优化</h4>
<pre><code class="hljs language-vue" lang="vue">&lt;script&gt;
export default {
  props: ['value'],
  computed: {
    internalValue: {
      get() {
        return this.value
      },
      set(newValue) {
        this.$emit('input', newValue)
      }
    }
  }
}
&lt;/script&gt;

&lt;template&gt;
  &lt;input v-model="internalValue" /&gt;
&lt;/template&gt;
</code></pre>
<h4 data-id="heading-24">2. 深度监听对象变化</h4>
<pre><code class="hljs language-vue" lang="vue">&lt;script&gt;
export default {
  props: {
    config: {
      type: Object,
      required: true
    }
  },
  watch: {
    config: {
      handler(newVal) {
        // 处理对象变化
        this.$emit('update:config', { ...newVal })
      },
      deep: true
    }
  }
}
&lt;/script&gt;
</code></pre>
<h4 data-id="heading-25">3. 使用Provide/Inject处理深层嵌套</h4>
<pre><code class="hljs language-vue" lang="vue">&lt;!-- 祖先组件 --&gt;
&lt;script&gt;
export default {
  provide() {
    return {
      sharedState: this.sharedState,
      updateSharedState: this.updateSharedState
    }
  },
  data() {
    return {
      sharedState: {
        theme: 'light',
        language: 'zh'
      }
    }
  },
  methods: {
    updateSharedState(key, value) {
      this.sharedState[key] = value
    }
  }
}
&lt;/script&gt;

&lt;!-- 深层子组件 --&gt;
&lt;script&gt;
export default {
  inject: ['sharedState', 'updateSharedState'],
  methods: {
    changeTheme(theme) {
      this.updateSharedState('theme', theme)
    }
  }
}
&lt;/script&gt;
</code></pre>
<h3 data-id="heading-26">八、Vue 3的Composition API新玩法</h3>
<p>Vue 3的Composition API为双向绑定带来了更灵活的解决方案：</p>
<pre><code class="hljs language-vue" lang="vue">&lt;!-- 子组件 --&gt;
&lt;script setup&gt;
import { computed } from 'vue'

const props = defineProps(['modelValue'])
const emit = defineEmits(['update:modelValue'])

const value = computed({
  get: () =&gt; props.modelValue,
  set: (newValue) =&gt; emit('update:modelValue', newValue)
})
&lt;/script&gt;

&lt;template&gt;
  &lt;input v-model="value" /&gt;
&lt;/template&gt;
</code></pre>
<h3 data-id="heading-27">总结</h3>
<p>掌握Vue父子组件双向绑定的多种方法，能让你在不同场景下选择最合适的解决方案：</p>
<ol>
<li><strong>简单场景</strong>：使用Props + $emit，保持代码清晰</li>
<li><strong>表单组件</strong>：使用v-model，提高开发效率</li>
<li><strong>多个绑定</strong>：Vue 2用.sync，Vue 3用多个v-model</li>
<li><strong>复杂应用</strong>：使用Vuex/Pinia，集中管理状态</li>
</ol>
<p>记住，没有绝对的最佳方案，只有最适合当前场景的选择。希望这篇文章能帮助你在Vue开发中游刃有余地处理组件通信问题！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[AI设计类产品分析：Lovart]]></title>    <link>https://juejin.cn/post/7590213554798313507</link>    <guid>https://juejin.cn/post/7590213554798313507</guid>    <pubDate>2026-01-03T06:14:37.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7590213554798313507" data-draft-id="7590159073989787700" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="AI设计类产品分析：Lovart"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2026-01-03T06:14:37.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="听风说图"/> <meta itemprop="url" content="https://juejin.cn/user/198345371681864"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            AI设计类产品分析：Lovart
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/198345371681864/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    听风说图
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-03T06:14:37.000Z" title="Sat Jan 03 2026 06:14:37 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    3
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><strong>核心观点</strong>：AI 设计类产品的两大核心壁垒——<strong>矢量渲染引擎是底座，结构化转换是灵魂</strong>。AI 大模型本身不是护城河。</p>
<hr/>
<h2 data-id="heading-0">1. 核心结论（先说结论）</h2>
<pre><code class="hljs language-arduino" lang="arduino">┌─────────────────────────────────────────────────────┐
│           用户感知层（产品体验）                      │
├─────────────────────────────────────────────────────┤
│     结构化转换层（灵魂）                             │  ← 决定<span class="hljs-string">"好不好用"</span>
│     - 混沌 AI 输出 → 语义化图层树                   │
│     - 静态布局 → 响应式约束                         │
│     - 位图 → 可编辑矢量                             │
├─────────────────────────────────────────────────────┤
│     矢量渲染引擎（底座）                             │  ← 决定<span class="hljs-string">"能不能做"</span>
│     - 路径渲染 / 图层混合 / <span class="hljs-number">60f</span>ps 性能              │
│     - 所有上层能力的物理承载                         │
├─────────────────────────────────────────────────────┤
│     AI 生成模型（水电煤）                            │  ← 可购买，非壁垒
│     - Sora / Midjourney / Veo 等                   │
└─────────────────────────────────────────────────────┘
</code></pre>
<p><strong>一句话总结</strong>：</p>
<p><strong>铁打的引擎，流水的模型。</strong> 用户住的是房子（渲染引擎），不是水电煤（AI 模型）。而结构化转换层决定了房子住得舒不舒服。</p>
<hr/>
<h2 data-id="heading-1">2. Lovart 简介</h2>
<p><strong>Lovart</strong> 是一款定位为「AI 设计智能体（Design Agent）」的产品，由 Resonate International INC 开发。其核心能力是将用户的自然语言需求，自动转化为专业级的设计产出（图像、视频、3D 等）。</p>
<ul>
<li><strong>官网</strong>：<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.lovart.ai" target="_blank" title="https://www.lovart.ai" ref="nofollow noopener noreferrer">www.lovart.ai</a></li>
<li><strong>定位</strong>：全球首个 AI 设计智能体</li>
<li><strong>Slogan</strong>：「让设计更加智能，让交付更加高效」</li>
</ul>
<hr/>
<h2 data-id="heading-2">3. 产品架构分析</h2>
<p>Lovart 的产品架构可以分为三层：</p>
<pre><code class="hljs language-scss" lang="scss">┌─────────────────────────────────────────────────────────────┐
│                    用户交互层 (UI)                           │
│         自然语言输入 → 实时画布渲染 → 可视化编辑              │
├─────────────────────────────────────────────────────────────┤
│                  结构化转换层 (灵魂)                         │
│       AI 输出解析 | 图层分离 | 布局推断 | 语义理解            │
├─────────────────────────────────────────────────────────────┤
│                   AI 模型聚合层 (水电煤)                     │
│   Sora2 | Veo3<span class="hljs-selector-class">.1</span> | Midjourney | Kling | Hailuo | Seedream  │
├─────────────────────────────────────────────────────────────┤
│                   矢量渲染引擎层 (底座)                      │
│         矢量渲染 | 图层管理 | 实时预览 | 导出交付             │
└─────────────────────────────────────────────────────────────┘
</code></pre>
<h3 data-id="heading-3">关键洞察</h3>
<p><strong>Lovart 并没有自研大部分 AI 生成模型</strong>——它聚合了市面上几乎所有顶级的图像/视频生成模型（Sora、Veo、Midjourney、Kling、Hailuo 等），通过统一的 API 调用提供给用户。</p>
<p>这意味着：<strong>AI 生成能力是「可购买」的标准化服务，不是 Lovart 的护城河。</strong></p>
<hr/>
<h2 data-id="heading-4">4. 壁垒一：矢量渲染引擎（底座）</h2>
<p><strong>没有渲染引擎，一切都是空中楼阁。</strong></p>
<h3 data-id="heading-5">4.1 为什么是「底座」？</h3>





























<table><thead><tr><th>挑战</th><th>说明</th></tr></thead><tbody><tr><td><strong>工程复杂度</strong></td><td>专业级设计软件需要处理矢量路径、布局约束、图层混合、渐变/阴影等，工程量巨大</td></tr><tr><td><strong>性能要求</strong></td><td>实时预览需要 60fps 流畅渲染，对 WebGL/WebGPU 有极高要求</td></tr><tr><td><strong>交互体验</strong></td><td>拖拽、缩放、对齐等交互需要毫秒级响应，前端优化深度决定用户体验</td></tr><tr><td><strong>格式兼容</strong></td><td>需要支持与 Figma、Sketch、Adobe 等工具的格式互通</td></tr><tr><td><strong>长期积累</strong></td><td>这类技术无法靠资金快速堆积，需要团队长期沉淀</td></tr></tbody></table>
<h3 data-id="heading-6">4.2 可替代性分析</h3>



































<table><thead><tr><th>环节</th><th>技术实现</th><th>可替代性</th></tr></thead><tbody><tr><td>AI 生成</td><td>调用第三方 API（Sora、Midjourney 等）</td><td><strong>极高</strong>，任何人都可以接入</td></tr><tr><td>自然语言理解</td><td>LLM（GPT 等）</td><td><strong>极高</strong>，标准化 API</td></tr><tr><td><strong>实时画布渲染</strong></td><td>自研前端矢量引擎</td><td><strong>极低</strong>，需要大量工程投入</td></tr><tr><td><strong>图层编辑系统</strong></td><td>自研图层管理</td><td><strong>极低</strong>，专业级设计软件门槛</td></tr><tr><td><strong>设计元素组合</strong></td><td>布局/对齐/变换系统</td><td><strong>极低</strong>，Figma 级的工程复杂度</td></tr></tbody></table>
<hr/>
<h2 data-id="heading-7">5. 壁垒二：结构化转换层（灵魂）</h2>
<p><strong>渲染引擎决定「能不能做」，结构化转换决定「好不好用」。</strong></p>
<h3 data-id="heading-8">5.1 核心问题：AI 输出 ≠ 可编辑设计稿</h3>
<p>很多人假设 AI 生成的内容可以直接进入引擎编辑，但实际上：</p>





















<table><thead><tr><th>AI 输出</th><th>渲染引擎需要</th></tr></thead><tbody><tr><td>位图（Pixels）</td><td>结构化矢量路径</td></tr><tr><td>杂乱的 SVG</td><td>清晰的图层树</td></tr><tr><td>无语义的像素块</td><td>带命名的组件/约束</td></tr></tbody></table>
<h3 data-id="heading-9">5.2 真正的技术深水区</h3>
<p><strong>不仅仅是「渲染」，而是「如何将 AI 的混沌输出瞬间转化为有序的图层结构」</strong>：</p>
<pre><code class="hljs language-css" lang="css">AI 生成结果 → <span class="hljs-selector-attr">[结构化转换层]</span> → 可编辑的设计稿
                    ↑
              这里才是灵魂
</code></pre>
<p>核心能力包括：</p>
<ul>
<li><strong>自动矢量化</strong>：位图 → 可编辑矢量路径</li>
<li><strong>自动图层分离</strong>：混沌像素 → 语义化图层树</li>
<li><strong>自动建立约束</strong>：静态布局 → AutoLayout 响应式结构</li>
<li><strong>自动命名/分组</strong>：无序元素 → 符合设计规范的组件</li>
</ul>
<p><strong>这才是让设计师觉得「好用」的关键</strong>——用户不是想要一张图，而是想要一个<strong>可以继续编辑的设计稿</strong>。</p>
<hr/>
<h2 data-id="heading-10">6. 为什么 AI 模型不是壁垒？</h2>
<ol>
<li><strong>模型同质化</strong>：Sora、Veo、Midjourney 等模型的 API 对所有人开放，成本差异仅在于规模效应。</li>
<li><strong>模型迭代快</strong>：今天的最强模型，3 个月后可能被新模型超越。押注单一模型是高风险策略。</li>
<li><strong>用户无感知</strong>：用户不关心后端用的是 Sora 还是 Veo，只关心最终产出的质量和可用性。</li>
</ol>
<p>Lovart 的聪明之处在于：<strong>做模型的「聚合者」而非「自研者」</strong>，将精力聚焦在用户真正能感知到的前端体验上。</p>
<hr/>
<h2 data-id="heading-11">7. 商业模式验证</h2>
<p>Lovart 的订阅定价印证了上述分析：</p>






























<table><thead><tr><th>套餐</th><th>月费</th><th>核心卖点</th></tr></thead><tbody><tr><td>Starter</td><td>$16/月</td><td>2000 积分，2 并发</td></tr><tr><td>Basic</td><td>$27/月</td><td>3500 积分，4 并发</td></tr><tr><td>Pro</td><td>$45/月</td><td>11000 积分，8 并发</td></tr><tr><td>Ultimate</td><td>$99/月</td><td>27000 积分，10 并发</td></tr></tbody></table>
<p><strong>注意</strong>：Lovart 的积分是用来消耗 AI 模型调用的（即可变成本），而订阅费用的核心是为了支撑其<strong>前端产品体验的持续迭代</strong>。</p>
<hr/>
<h2 data-id="heading-12">8. 对 FigDev 的启示</h2>
<h3 data-id="heading-13">8.1 我们的优势</h3>
<p>FigDev 的技术路线与「底座 + 灵魂」的成功逻辑高度契合：</p>









































<table><thead><tr><th>壁垒类型</th><th>FigDev 的对应能力</th></tr></thead><tbody><tr><td><strong>矢量渲染引擎（底座）</strong></td><td>WebGPU 自研矢量渲染引擎</td></tr><tr><td>实时画布渲染</td><td><code>flare/ecs</code> + ECS 架构</td></tr><tr><td>图层编辑系统</td><td>Figma 视图层实现</td></tr><tr><td>设计元素组合</td><td>AutoLayout (yoga-layout)</td></tr><tr><td><strong>结构化转换层（灵魂）</strong></td><td><code>dataTransformation</code> 模块</td></tr><tr><td>Figma JSON → ECS 节点</td><td>已实现</td></tr><tr><td>矢量路径解析</td><td><code>svgPathParser</code></td></tr><tr><td>自动布局约束</td><td><code>AutoLayoutSys</code></td></tr></tbody></table>
<h3 data-id="heading-14">8.2 战略建议</h3>






























<table><thead><tr><th>优先级</th><th>策略</th><th>说明</th></tr></thead><tbody><tr><td>⭐⭐⭐</td><td><strong>深耕渲染引擎</strong></td><td>60fps、复杂路径、渐变填充等「难啃的骨头」才是真正的壁垒</td></tr><tr><td>⭐⭐⭐</td><td><strong>扩展转换层</strong></td><td>将 <code>dataTransformation</code> 能力扩展到「AI 输出 → 结构化设计稿」场景</td></tr><tr><td>⭐⭐</td><td><strong>自研专用小模型</strong></td><td>训练「最懂设计编辑」的专用模型（见下文）</td></tr><tr><td>⭐</td><td><strong>聚合 AI 模型</strong></td><td>不做大模型军备竞赛，直接聚合 Sora、Midjourney 等</td></tr></tbody></table>
<h3 data-id="heading-15">8.3 差异化定位</h3>
<pre><code class="hljs">Lovart：AI 生成 → 静态内容（2D/3D/视频）
FigDev：AI 生成 → 静态或带交互的内容（2D/3D/视频/网页）
</code></pre>
<hr/>
<h2 data-id="heading-16">9. AI 小模型策略：建立独特壁垒</h2>
<p>虽然不做大模型军备竞赛，但<strong>自研专用小模型</strong>是必要的。</p>
<h3 data-id="heading-17">9.1 为什么需要小模型？</h3>
<p>结构化转换层的「灵魂」能力，需要 AI 来增强：</p>





















<table><thead><tr><th>小模型类型</th><th>核心作用</th></tr></thead><tbody><tr><td><strong>结构化识别模型</strong></td><td>将 AI 生成的位图/SVG 转化为语义化图层结构</td></tr><tr><td><strong>布局推断模型</strong></td><td>自动识别元素关系，建立 AutoLayout 约束</td></tr><tr><td><strong>设计修正模型</strong></td><td>根据设计规范自动优化间距、对齐、配色</td></tr></tbody></table>
<h3 data-id="heading-18">9.2 数据飞轮：用户行为反哺模型</h3>
<p><strong>核心洞察</strong>：用户在编辑器中的每一次修改，都是最高质量的标注数据。</p>
<pre><code class="hljs language-markdown" lang="markdown">AI 生成 → 用户在编辑器中修改 → 修改记录作为训练数据 → 反哺小模型 → AI 生成更准确
<span class="hljs-code">              ↑                                                    ↓
              └──────────────────────────────────────────────────────┘
</span></code></pre>

























<table><thead><tr><th>用户行为</th><th>数据价值</th></tr></thead><tbody><tr><td>调整图层层级</td><td>训练「图层分离模型」</td></tr><tr><td>修改布局约束</td><td>训练「布局推断模型」</td></tr><tr><td>重命名组件</td><td>训练「语义理解模型」</td></tr><tr><td>修正颜色/间距</td><td>训练「设计修正模型」</td></tr></tbody></table>
<hr/>
<h2 data-id="heading-19">10. 总结</h2>
<h3 data-id="heading-20">核心框架</h3>






























<table><thead><tr><th>层级</th><th>定位</th><th>战略优先级</th></tr></thead><tbody><tr><td><strong>矢量渲染引擎</strong></td><td>底座 — 决定「能不能做」</td><td>⭐⭐⭐</td></tr><tr><td><strong>结构化转换层</strong></td><td>灵魂 — 决定「好不好用」</td><td>⭐⭐⭐</td></tr><tr><td><strong>AI 小模型</strong></td><td>增强 — 形成独特壁垒</td><td>⭐⭐</td></tr><tr><td><strong>AI 大模型</strong></td><td>水电煤 — 聚合即可</td><td>⭐</td></tr></tbody></table>
<h3 data-id="heading-21">一句话总结</h3>
<p><strong>渲染是底座，转换是灵魂。</strong> FigDev 的核心竞争力不在于生成了什么，而在于<strong>如何承接、编辑、组织和交付</strong>这些生成的内容。</p>
<p><em>更多精彩内容可关注</em><a href="https://link.juejin.cn?target=https%3A%2F%2F01joy.com%2F" target="_blank" title="https://01joy.com/" ref="nofollow noopener noreferrer">风起的博客</a> <em>，微信公众号：听风说图</em></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[npm包开发及私有仓库配置使用]]></title>    <link>https://juejin.cn/post/7590457413347803163</link>    <guid>https://juejin.cn/post/7590457413347803163</guid>    <pubDate>2026-01-03T06:32:47.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7590457413347803163" data-draft-id="7590011643296366630" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="npm包开发及私有仓库配置使用"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2026-01-03T06:32:47.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="想要一辆洒水车"/> <meta itemprop="url" content="https://juejin.cn/user/52378148281933"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            npm包开发及私有仓库配置使用
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/52378148281933/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    想要一辆洒水车
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-03T06:32:47.000Z" title="Sat Jan 03 2026 06:32:47 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读2分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>原因：一个项目多个系统之间存在可复用的代码，重复的复制粘贴及修改，偶尔也会遗漏。集中管理和维护，提升代码复用率和维护效率</p>
<h2 data-id="heading-0">开发npm包</h2>
<h3 data-id="heading-1">初始化项目</h3>
<p>生成package.json文件</p>
<pre><code class="hljs language-csharp" lang="csharp">npm <span class="hljs-keyword">init</span> -y
</code></pre>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"product-npm"</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 包名称</span>
  <span class="hljs-attr">"version"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"1.0.0"</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 包版本信息</span>
  <span class="hljs-attr">"description"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">""</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"main"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"dist/index.js"</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 包的入口文件</span>
  <span class="hljs-attr">"scripts"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"test"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"build"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"rollup --config"</span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"keywords"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"author"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">""</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"license"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"ISC"</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<h3 data-id="heading-2">编写代码内容及打包</h3>
<p>安装 rollupjs 进行打包，生成dist文件夹，内容存放在该文件夹下。 <code>main</code>的值也需根据输出地址进行变更</p>
<h2 data-id="heading-3">选择 verdaccio 进行私有仓库管理</h2>
<h3 data-id="heading-4">全局安装verdaccio</h3>
<pre><code class="hljs language-cmd" lang="cmd">npm i verdaccio -g
</code></pre>
<h3 data-id="heading-5">检查是否安装成功</h3>
<p>显示版本号即为成功</p>
<pre><code class="hljs language-cmd" lang="cmd">verdaccio -v
</code></pre>
<h3 data-id="heading-6">运行 verdaccio</h3>
<pre><code class="hljs language-cmd" lang="cmd">verdaccio
</code></pre>
<p>终端会显示 config file 和 http address</p>
<p>config file - 配置文件的地址</p>
<p>htpp address - 仓库的管理界面</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/468bca1334c14425896d2fe2c615535a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oOz6KaB5LiA6L6G5rSS5rC06L2m:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768026766&amp;x-signature=g268jLvS1VUwgx0tOM5RTkAwObw%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-7">添加用户</h3>
<p>执行命令后，根据终端的提示设置用户名、密码、邮箱</p>
<pre><code class="hljs language-cmd" lang="cmd">npm add user --registry http://localhost:4873/
# --registry http://localhost:4873/ 指定仓库源
</code></pre>
<p>如出现报错需要检查配置文件中<code>max_users</code>是否有设置（默认被注释了）且值不能为1</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">auth:</span>
  <span class="hljs-attr">htpasswd:</span>
    <span class="hljs-attr">file:</span> <span class="hljs-string">./htpasswd</span>
    <span class="hljs-comment"># Maximum amount of users allowed to register, defaults to "+inf".</span>
    <span class="hljs-comment"># You can set this to -1 to disable registration. 如果为-1禁止注册</span>
    <span class="hljs-attr">max_users:</span> <span class="hljs-number">1000</span>
    <span class="hljs-comment"># Hash algorithm, possible options are: "bcrypt", "md5", "sha1", "crypt".</span>
    <span class="hljs-comment"># algorithm: bcrypt # by default is crypt, but is recommended use bcrypt for new installations</span>
    <span class="hljs-comment"># Rounds number for "bcrypt", will be ignored for other algorithms.</span>
    <span class="hljs-comment"># rounds: 10</span>
</code></pre>
<h3 data-id="heading-8">登录用户</h3>
<pre><code class="hljs language-arduino" lang="arduino">npm login --registry http:<span class="hljs-comment">//localhost:4873/</span>
</code></pre>
<h3 data-id="heading-9">发布\更新包</h3>
<p>在包根目录执行</p>
<pre><code class="hljs language-arduino" lang="arduino">npm publish --registry http:<span class="hljs-comment">//localhost:4873/</span>
</code></pre>
<p>如出现报错需要检查<code>package.json</code>文件下<code>version</code>是否有变更</p>
<h3 data-id="heading-10">删除包</h3>
<pre><code class="hljs language-css" lang="css">npm unpublish product-npm<span class="hljs-selector-attr">[包名]</span> <span class="hljs-attr">--registry</span> http://localhost:<span class="hljs-number">4873</span>/
</code></pre>
<h2 data-id="heading-11">使用</h2>
<p>由于verdaccio部署在自己的电脑下，所以在项目里直接 install 即可</p>
<pre><code class="hljs language-css" lang="css">npm <span class="hljs-selector-tag">i</span> product-npm <span class="hljs-attr">--registry</span> http://localhost:<span class="hljs-number">4873</span>/
</code></pre>
<p>同事需要使用时，则将localhost变为对应的我的电脑的ip</p>
<pre><code class="hljs language-css" lang="css">npm <span class="hljs-selector-tag">i</span> product-npm <span class="hljs-attr">--registry</span> http://<span class="hljs-number">192.168</span>.<span class="hljs-number">1.6</span>:<span class="hljs-number">4873</span>/
</code></pre>
<p>如出现无法安装需要检查配置文件中<code>listen</code>参数，开启0.0.0.0，以致可通过ip访问</p>
<pre><code class="hljs language-shell" lang="shell"><span class="hljs-meta prompt_"># </span><span class="bash">https://verdaccio.org/docs/configuration<span class="hljs-comment">#listen-port</span></span>
listen:
<span class="hljs-meta prompt_">  # </span><span class="bash">- localhost:4873            <span class="hljs-comment"># default value</span></span>
<span class="hljs-meta prompt_">  # </span><span class="bash">- http://localhost:4873     <span class="hljs-comment"># same thing</span></span>
  - 0.0.0.0:4873              # listen on all addresses (INADDR_ANY)
<span class="hljs-meta prompt_"># </span><span class="bash">  - https://example.org:4873  <span class="hljs-comment"># if you want to use https</span></span>
<span class="hljs-meta prompt_"># </span><span class="bash">  - <span class="hljs-string">"[::1]:4873"</span>              <span class="hljs-comment"># ipv6</span></span>
<span class="hljs-meta prompt_"># </span><span class="bash">  - unix:/tmp/verdaccio.sock  <span class="hljs-comment"># unix socket</span></span>
</code></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Vue源码分析 - 从入口到构造函数的整体流程]]></title>    <link>https://juejin.cn/post/7590159073989886004</link>    <guid>https://juejin.cn/post/7590159073989886004</guid>    <pubDate>2026-01-03T07:26:53.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7590159073989886004" data-draft-id="7588445332773126198" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Vue源码分析 - 从入口到构造函数的整体流程"/> <meta itemprop="keywords" content="Vue.js,前端"/> <meta itemprop="datePublished" content="2026-01-03T07:26:53.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="luckyCover"/> <meta itemprop="url" content="https://juejin.cn/user/2546933393272872"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Vue源码分析 - 从入口到构造函数的整体流程
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2546933393272872/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    luckyCover
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-03T07:26:53.000Z" title="Sat Jan 03 2026 07:26:53 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读13分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>Vue 中的核心源码主要放在了 <code>src/core</code> 目录下，我们先来看下面这段代码</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5547650397e9419f91d1043f53fd34b8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbHVja3lDb3Zlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768030013&amp;x-signature=gO%2BSP6wepCGjj%2BtTwqKBhJS4KfA%3D" alt="image.png" loading="lazy"/></p>
<p>上面这段代码是我们平常创建一个 Vue 项目中 main.js 入口文件里的原始代码，这也是 Vue 创建应用的起点，接下来我们就来分析从 <code>new Vue()</code> 到 <code>$mount</code> 这一过程 Vue 都做了哪些事，也就是做了哪些初始化。</p>
<p>首先是 <code>src/core/index.ts</code> 文件</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a2ba5c038ee94252a573ee0b895a4467~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbHVja3lDb3Zlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768030013&amp;x-signature=B8tdzJoHVqL7Ek%2BMlCv4vVmzX88%3D" alt="image.png" loading="lazy"/></p>
<p>我们看到它调用 <code>initGlobalAPI</code> 函数，并把 Vue 作为参数传进去，我们先不着急看 <code>initGlobalAPI</code> 内部逻辑，因为我们连它传入的这个参数 <code>Vue</code> 是啥都不知道，工欲善其事，必先利其器。我们看到文件最顶上 <code>Vue</code> 是从同目录下 <code>instance/index</code> 文件中导出的。
我们打开文件看一下：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/afe4a7ff77ff4bf589397460c7849410~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbHVja3lDb3Zlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768030013&amp;x-signature=ht%2BscmkNJrC59VyT5gjJRrYk%2F80%3D" alt="image.png" loading="lazy"/></p>
<p>哦，原来导出的 Vue 是一个函数，而且函数名称还是大写的，所以可以当作构造函数使用，除此之外，我们还看到在函数下方还有一系列以 <code>xxxMixin</code> 为首的函数调用，而且也把 Vue 这个函数当作参数传入，我们可以猜测这些函数调用就是执行各种初始化操作，而且在我们 new Vue 的时候，其实下面的那些 xxxMixin 都已经执行过了，new Vue 时调用的 _init 方法实际上是在 initMixin 中的，所以我们把它归类到 initMixin 中，可以初步得到以下初始化流程图：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cf93b4c31888493fa87306a3ddec0320~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbHVja3lDb3Zlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768030013&amp;x-signature=yzyG9jSiHjQClKRinPrgqElyo2I%3D" alt="image.png" loading="lazy"/></p>
<p>具体每个函数都干了哪些事，我们接下来就按照上边流程图的顺序来逐个进行分析。</p>
<h3 data-id="heading-0">initMixin</h3>
<p><code>_init</code> 方法所在文件（src/core/instance/init.ts）</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8c802a95cde14d0b899a562cdf780cb6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbHVja3lDb3Zlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768030013&amp;x-signature=RRc4bvVxIQnfLRhD6vbAwqTde4k%3D" alt="image.png" loading="lazy"/></p>
<p>它是 Vue 原型上的一个方法，接收一个 options 参数，我们主要分析它的核心逻辑：
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d973b5125285495ab398ec29aa1798b1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbHVja3lDb3Zlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768030013&amp;x-signature=loSzaXb6erD4PFZ4CAFu7J06Hjo%3D" alt="image.png" loading="lazy"/></p>
<p>1、首先将 this 赋值给 vm</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/271f310c5e3b4b59acff67a4d4ca079e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbHVja3lDb3Zlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768030013&amp;x-signature=kPx5mw3lSfcZRZnDUpzRrPlTMTY%3D" alt="image.png" loading="lazy"/></p>
<p>这里的 this 就是 new Vue 时构造出来的实例对象，所以 vm 特指 Vue 实例对象。</p>
<p>函数外部有一个 uid 变量，默认从 0 开始</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a023d7499b094ba8b809debef055981b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbHVja3lDb3Zlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768030013&amp;x-signature=iI54c7RQvqEdnSin3JJVraZ1oHs%3D" alt="image.png" loading="lazy"/></p>
<p>接着往 Vue 实例对象上添加一个 <code>_uid</code> 属性作为唯一标识，值默认是 0，赋值完后 uid 自增（这样下一个 new Vue 构造的实例，它的 _uid 就是 1，以此类推）</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/20187da5d7464e00bf3c43cfa19a1681~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbHVja3lDb3Zlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768030013&amp;x-signature=3S2DBVmj%2FKKHENX7QpxlerSX%2FoU%3D" alt="image.png" loading="lazy"/></p>
<p>vm 上添加 <code>_isVue</code> 属性，值设为 true，这个属性用来标记当前 vm 是一个 Vue 的实例（也就是通过 new Vue 构造出来的）</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/db8c3987c8e945549c8a04268677015a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbHVja3lDb3Zlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768030013&amp;x-signature=Fj4aL92VPNa571onT2nbUC0vfiE%3D" alt="image.png" loading="lazy"/></p>
<p>后边还设置了其他的一些属性，咱们先不用管，后边有出现会提到的。</p>
<p>然后我们来看关键方法 <code>mergeOptions</code>，从名字上我们就可以知道它是用于合并选项的，调用 mergeOptions 并将返回结果赋值给 vm.$options
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0a22776c09bd4030b18b61ee6992f71c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbHVja3lDb3Zlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768030013&amp;x-signature=OrjlVO9bJUE7WDwTcLpqHHCZ7t8%3D" alt="image.png" loading="lazy"/></p>
<p>我们先来分析它的传参，第一个参数是调用 resolveConstructorOptions 函数的返回值
那么调用 resolveConstructor 函数传了 vm.constructor（实例对象的 constructor），这里通过原型相关的知识可以得知，实例的 constructor 指向实例化它的构造函数，那这里就是 Vue 构造函数了，所以就是：</p>
<pre><code class="hljs language-js" lang="js">vm.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Vue</span> <span class="hljs-comment">// true</span>
</code></pre>
<p>我们来看下 resolveConstructor 函数内部逻辑：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/23c5117878354cc9b3072b2ae3f0c43e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbHVja3lDb3Zlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768030013&amp;x-signature=l994vD3mq%2BKxLLPfgK%2FiCVd5yoQ%3D" alt="image.png" loading="lazy"/></p>
<ul>
<li>接收一个参数 Ctor，我们刚才传了 vm.constructor（相当于 Vue 构造函数）</li>
<li>取得 options 选项</li>
<li>判断 Ctor.super 有没有（super 关键字会指向其父类的构造函数，即判断有无父类），这一般在子组件通过 extend 继承父组件时会存在这种情况，我们目前没有父子继承关系，所以不进入判断内部</li>
<li>直接返回 options</li>
</ul>
<p>mergeOptions 的第二个参数是 _init 接收的参数 options，也就是 new Vue 时传给构造函数中的对象，第三个参数是当前组件实例 vm。传给 mergeOptions 的三个参数都分析完后，来看下 mergeOptions 函数</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/dac197fd3be641cd8bc194ef0dda1277~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbHVja3lDb3Zlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768030013&amp;x-signature=Jq1DT0VX%2Fb5AMe6nIdatH2g875M%3D" alt="image.png" loading="lazy"/></p>
<p>通过官方注释得知，就是将两个选项合并成一个，parent 就是 Vue 构造函数的默认 options，child 是我们 new Vue 时传给构造函数的，vm 就是当前实例</p>
<ul>
<li>调用 checkComponent</li>
</ul>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/93d10b6f4c5b4b07812738fee25e0ac8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbHVja3lDb3Zlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768030013&amp;x-signature=KPdntXYry3OysP4%2FR%2F%2B0m17dowY%3D" alt="image.png" loading="lazy"/>
checkComponent 用于检测组件的名称，前提是传入的 options 上的 components 不为空，枚举 options.components 上的组件名，调用 validateComponentName 函数校验</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/23795421012345f1bea4139969f37984~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbHVja3lDb3Zlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768030013&amp;x-signature=uqgXCbf8mH1uUiTF2scKz8%2FO6C4%3D" alt="image.png" loading="lazy"/>
validateComponentName 接收参数 name（即组件名称），采用正则表达式校验 name 是否符合要求，不符合就调用 warn 函数，提示错误信息。
通过正则表达式校验，下边还需要校验是不是和 Vue 中一些内置名称冲突
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/83f9d01445da4727b7f12fa3a866155a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbHVja3lDb3Zlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768030013&amp;x-signature=RMnVwpijCS9Vib5hXdV4k3rep60%3D" alt="image.png" loading="lazy"/>
调用 isBuiltInTag 和 isReservedAttribute 函数相当于是调用了 makeMap 返回的函数，我们看看 makeMap 函数</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8718beba31b54ede8b0d4c99c89b30bb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbHVja3lDb3Zlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768030013&amp;x-signature=PB%2BUIiI8yBku2Qo5tj1X5ybw08I%3D" alt="image.png" loading="lazy"/>
接收 str 字符串参数，expectsLowerCase 布尔值是否期望小写。makeMap 函数内部逻辑：</p>
<ul>
<li>构建一个空 map</li>
<li>分割传入的 str 放到 list 数组</li>
<li>遍历数组，将数组中的元素放到 map 中作为键，其值默认为 true</li>
<li>返回值：如果 expectsLowerCase 为 true，返回一个函数，这个函数接口一个 val 参数，将 val 转为小写后去 map 中找到这个键对应的值，如果 expectsLowerCase 为 false，返回一个接收 val 参数的函数，函数直接返回 map 中 val 这个键对应的值。</li>
</ul>
<p>总结：isBuiltInTag 函数对应的 makeMap 返回的函数内部的 map 为：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-attr">map</span>: {
    <span class="hljs-string">'slot'</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-string">'component'</span>: <span class="hljs-literal">true</span>
}
</code></pre>
<p>这些是 Vue 中内置的标签</p>
<p>isReservedAttribute 函数对应 makeMap 内的 map 也是：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-attr">map</span>: {
    <span class="hljs-string">'key'</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-string">'ref'</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-string">'slot'</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-string">'slot-scope'</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-string">'is'</span>: <span class="hljs-literal">true</span>
}
</code></pre>
<p>这些是 Vue 中预定义的属性</p>
<p>默认调用 makeMap 时第二个参数是 true，也就是我们组件名称传进去会先转为小写，然后再去 map 中匹配，说白了，我们写的组件名称中不管大小写，统一转为小写后匹配上边的 map，只要匹配上键（属性名），它们的值刚好是 true，那就进入判断抛出错误提示信息。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3169e91f7c6b4e05bf2c835815366b3b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbHVja3lDb3Zlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768030013&amp;x-signature=PQnqFs0I7OXQV3XNhVQq12aPJx4%3D" alt="image.png" loading="lazy"/></p>
<ul>
<li>
<p>校验完组件名后，接着调用 normalizeProps 规范化 props
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9ef3a3655b154e5daeb619354b9277f6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbHVja3lDb3Zlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768030013&amp;x-signature=pbD%2BVZi2D2jLIyQw2WMcyoxveXQ%3D" alt="image.png" loading="lazy"/>
接收 options 选项以及 vm 实例对象</p>
<ul>
<li>
<p>获取 options 上的 props，为空直接返回</p>
</li>
<li>
<p>情况一：props 如果是数组形式</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ea70bddbe9434a62852603f8f67d4c61~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbHVja3lDb3Zlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768030013&amp;x-signature=F%2Ff3c%2F74J7zo7Lr%2FmQWrxluPGJo%3D" alt="image.png" loading="lazy"/></p>
<p>遍历数组元素，进行类型判断，数组中的元素必须是字符串类型，否则抛出错误信息，随后调用 camelize 将元素 val 传进去做处理，camelize 就是将传入的字符串转为驼峰命名的形式并返回
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e9854a1823054fde93ed673443ba18a4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbHVja3lDb3Zlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768030013&amp;x-signature=Ab%2FEgNrWKkBNMY8HUvt0JFUik0o%3D" alt="image.png" loading="lazy"/>
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/078435c479ce4ca78171c4f439b7a48c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbHVja3lDb3Zlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768030013&amp;x-signature=aZZzNPwAZS6uBeJOSHRbT4M2NdE%3D" alt="image.png" loading="lazy"/>
camelizeRE 是要匹配的正则表达式，括号内是捕获组，(\W) 就是捕获一个英文单词，对传入的字符串使用 replace 方法，就是将正则表达式匹配的部分替换为第二个参数指定的部分。举个例子，假设我们传入的 str 如下：</p>
<pre><code class="hljs language-js" lang="js">my-component
</code></pre>
<p>那么 camelizeRE 正则匹配到的就是 <code>-c</code>，捕获组捕获到的就是 <code>c</code>，replace 第二个参数是回调，回调第一个参数是匹配到的完整字符串，第二个参数是捕获到的字符，这里是小写 <code>c</code>，将其转为大写（调用 toUpperCase()），那这里就是将正则匹配到的 <code>-c</code>，替换成大写 <code>C</code>，替换后的字符如下：</p>
<pre><code class="hljs language-js" lang="js">myComponent
</code></pre>
<p>这个 name 就是驼峰式的了，然后放到 res 对象中作为属性，值是一个对象，对象中默认有一个 type: null 的属性，放到 res 中就是</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-attr">res</span>: {
    <span class="hljs-string">'xxx'</span>: {
        <span class="hljs-attr">type</span>: <span class="hljs-literal">null</span>
    }
}
</code></pre>
<ul>
<li>情况二：props 是对象形式
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/941bbb56cb83494d8b039c6524166e59~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbHVja3lDb3Zlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768030013&amp;x-signature=RLJ5eiEzFvjqsQWaAQG89cFJGdE%3D" alt="image.png" loading="lazy"/>
对象处理也很简单，枚举对象上的属性，拿到属性值 val，同样对属性名进行处理，转为驼峰命名形式，接着往 res 上放这个属性，如果 val 本身是一个对象，那就直接将这个对象作为属性值，反之就将 type 放到一个对象中，属性值设为这个 val。分别对应下边两种情况</li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-attr">props</span>: {
    <span class="hljs-attr">name</span>: <span class="hljs-title class_">String</span>,
    <span class="hljs-attr">age</span>: {
        <span class="hljs-attr">type</span>: <span class="hljs-title class_">Number</span>
    }
}
</code></pre>
<p>name 属性值不是一个对象，将 name 属性值（String）作为新对象中 type 的属性值，放到 res 中就是</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-attr">res</span>: {
    <span class="hljs-attr">name</span>: {
        <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>
    }
}
</code></pre>
<p>age 属性值本身是一个对象，放到 res 中是</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-attr">res</span>: {
    <span class="hljs-attr">age</span>: {
        <span class="hljs-attr">type</span>: <span class="hljs-title class_">Number</span>
    }
}
</code></pre>
<ul>
<li>
<p>props 不是数组也不是对象
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0dd2da1fcd6d4803a0236eb1f5fa3715~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbHVja3lDb3Zlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768030013&amp;x-signature=93tM1U4OHJxkhHChxjJAabWIoGE%3D" alt="image.png" loading="lazy"/>
抛出错误信息，提示 props 必须是一个数组或对象</p>
</li>
<li>
<p>处理好的 res 覆盖 options.props</p>
</li>
</ul>
<p>可以看到上边就是对用户传的 props 进行归一化，所谓归一化就是将不同的形式转为相同的形式，上边归一化后的形式就是：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-attr">props</span>: {
    <span class="hljs-attr">key1</span>: {
        <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>
    },
    <span class="hljs-attr">key2</span>: {
        <span class="hljs-attr">type</span>: <span class="hljs-title class_">Number</span>
    },
    <span class="hljs-attr">key3</span>: {
        <span class="hljs-attr">type</span>: <span class="hljs-literal">null</span>
    }
}
</code></pre>
<ul>
<li>调用 normalizeInject 规范化 inject</li>
</ul>
<p>normalizeInject 内部处理逻辑和 normalizeProps 很相似，都是分为数组和对象两种情况处理，如果两者都不是就抛出错误信息。只是 props 中是处理 type，injects 是 from。这里对象的处理中，如果枚举的属性其属性值是一个对象，会调用 extend 进行处理，传入两个参数，第一个是一个对象，有 from 属性，属性值是这个枚举属性，第二个参数是枚举属性对应的值，这个值是个对象，看看 extend 函数。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/51c90db2168d4db9b3939718f18ea8e3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbHVja3lDb3Zlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768030013&amp;x-signature=ZIM9Hflgc32%2BsFE%2FctSC3Y%2BeeBc%3D" alt="image.png" loading="lazy"/></p>
<p>就是往第一个参数也就是目标对象上混入属性，枚举第二个参数传入的 val 对象，往第一个参数（{from: key}）混入第二个参数中的属性（如果第二个参数 val 对象上也存在 from 属性，则 val 对象上的 from 属性值覆盖源对象上的 from 属性值，混入后，源对象上就不仅只有 from 属性了，还可能有其他的一些属性）。</p>
<p>最后归一化后的格式就是：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-attr">injects</span>: {
    <span class="hljs-attr">key1</span>: {
        <span class="hljs-attr">from</span>: xxx,
        ..., <span class="hljs-comment">// 其他一些属性</span>
    }
}
</code></pre>
<ul>
<li>
<p>调用 normalizeDirectives 规范化 directives
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/540a24d1e43a4b0f9de5f8426fe31be2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbHVja3lDb3Zlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768030013&amp;x-signature=9VT60FOhEw%2BQju97r40nV4zBpTw%3D" alt="image.png" loading="lazy"/></p>
<ul>
<li>获取 directives 选项</li>
<li>枚举选项上的属性，获取属性值</li>
<li>判断属性值是不是一个函数，是的话就将选项上当前属性的属性值重新赋值为一个对象，对象上的 bind 和 update 属性为这个源函数</li>
</ul>
</li>
<li>
<p>枚举 parent（Vue 构造函数的 options 选项），调用 mergeField 将属性作为实参传入</p>
</li>
<li>
<p>枚举 child（用户传入的 options 选项），如果属性在 parent（Vue 构造函数中的 options）中不存在，调用 mergeField 函数，将 key 属性作为实参传入</p>
</li>
</ul>
<p>接着看看这个核心的 mergeField 函数
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d7e4431a35444602a46b279fa9d081a4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbHVja3lDb3Zlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768030013&amp;x-signature=zd3KjHHqze2iWi%2F0zDqEtZwB3Dw%3D" alt="image.png" loading="lazy"/></p>
<p>strat 是一个函数，会先从 strats 中取，strats 在文件顶部声明</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9adcd1abd99048f483fc3a99900e19cd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbHVja3lDb3Zlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768030013&amp;x-signature=aqFo0V0wAlk0S4%2FHVbLB%2Fjx0Clk%3D" alt="image.png" loading="lazy"/></p>
<p>默认值为 config.optionMergeStrategies， 这个 config 在（<code>src/core/config.ts</code>）文件中，默认是个空对象</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2408d93f401e44b8bbdaf909e0756807~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbHVja3lDb3Zlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768030013&amp;x-signature=NeE34TXcrw%2FD9jsYJo4r40CwC%2Bg%3D" alt="image.png" loading="lazy"/></p>
<p>从上边的接口类型声明来看，这个对象上的属性是字符串类型，属性值是个函数</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/994c19bdf21e4a9f9334884e0ab23dfd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbHVja3lDb3Zlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768030013&amp;x-signature=m65dvvvyNVcQ2YoO4oAuDx2PyNM%3D" alt="image.png" loading="lazy"/></p>
<p>那么如果 strats 上没有这个属性对应值，就会使用默认的策略 defaultStrat</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2fab5287e5c14c28b4dee8dc76495f7c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbHVja3lDb3Zlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768030013&amp;x-signature=PYppVubbFPlQ26VxtX9gEEm2IIQ%3D" alt="image.png" loading="lazy"/>
默认策略接收父属性值和子属性值作为参数，如果子属性值不为 undefined 的话优先返回它，否则再取父属性值，这个返回值就作为最后合并好的 options 上该属性对应的值。</p>
<p>那么上边先枚举 Vue 构造函数的 options 上的属性，如果用户传的 options 也存在该属性，优先使用用户传的，这样后边枚举用户传的 options 时就仅需要处理 Vue 构造函数 options 上没有的属性了。</p>
<ul>
<li>最后返回合并好的终极 options</li>
</ul>
<p>至此，mergeOptions 函数就分析完了，主要流程就是<code>组件名校验</code>、<code>归一化 props</code>、<code>injects</code>、<code>directives</code>，然后将 Vue 构造函数及用户的 <code>options 进行一个合并</code>，最后返回。</p>
<p>继续往下看：
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d02aaa2d904746c1b4b84dbacd9777bf~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbHVja3lDb3Zlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768030013&amp;x-signature=t%2B24oFRwn9aytpcirEOs1P7q3go%3D" alt="image.png" loading="lazy"/></p>
<ul>
<li>initProxy
所在文件（src/core/instance/proxy.ts），在文件顶部声明了一个 initProxy 变量，然后赋值为一个函数：
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/804bdc2dc6864f3295fcb2b857b1cfc5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbHVja3lDb3Zlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768030013&amp;x-signature=jsUhZP2f%2Fhc1a5ykbqIenX8EzH8%3D" alt="image.png" loading="lazy"/>
接收 vm 实例作为参数，首先判断 hasProxy 值，hasProxy 判断浏览器是否支持 Proxy 这个 API，即不为 undefined，且调用 isNative 要返回 true，isNative 会判断传入参数是一个函数，且是 JavaScript 内置的函数（内置函数调用 toString 方法会返回包含 [native code] 的字符串）
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7f53b344d4774de6a023e6e90331e31d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbHVja3lDb3Zlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768030013&amp;x-signature=mXUdPpk%2BND5qwW8LaOgtPHaVk8s%3D" alt="image.png" loading="lazy"/>
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/dbd0297103c1494da56fba387d50e403~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbHVja3lDb3Zlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768030013&amp;x-signature=MH8COudt2ghA8JbDX62VAfwVrHc%3D" alt="image.png" loading="lazy"/></li>
</ul>
<p>进入判断后先获取 vm 上的 options，然后定义 handlers 配置项，然后创建一个代理实例赋值给 vm 上的 _renderProxy 属性，如果 hasProxy 为 false， _renderProxy 属性就赋值为 vm 实例本身，接着我们看下代理配置项 handlers 取值，有 getHandler 和 hasHandler 两种：</p>
<p>getHandler 中定义了一个 get 函数，参数是 target（这里是 vm 实例） 和 key（属性）
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d667f450fc544286a3ce8768942b7c1b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbHVja3lDb3Zlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768030013&amp;x-signature=ayywi7RA%2BXCec%2Bwzg8CVUmjRXWM%3D" alt="image.png" loading="lazy"/></p>
<p>也就是我们读取 vm 上的某个属性时，会触发 get 函数拦截，首先判断这个 key 属性是字符串且不在 target（vm 实例）上，接着继续判断 key 属性在不在 vm 实例的 <code>$data</code>（也就是我们组件中写的 data 对象里）上，如果在就调用 <code>warnReservedPrefix</code> 函数抛出错误提示，如果不在 vm 实例上也不在 <code>vm.$data</code> 属性上，调用 <code>warnNonPresent</code> 函数抛出另一个错误信息</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7da367e64574444ba6b7300756fe87d4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbHVja3lDb3Zlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768030013&amp;x-signature=xJSvMSRK3w0qH8%2BnAUJlweSdNmw%3D" alt="image.png" loading="lazy"/>
因为属性 key 它不在 vm 上，但在 <code>vm.$data</code> 上，所以这里提示信息意思就是这个 key 属性必须访问 <code>$data.key</code> 上的</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/93e644517cbf498793e8a9ae3e50b228~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbHVja3lDb3Zlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768030013&amp;x-signature=P2LeKQliJYNJAuUAF4yVp4%2FbQlI%3D" alt="image.png" loading="lazy"/>
这种情况就是 key 属性即不在 vm 上也不在 <code>vm.$data</code> 上，抛出错误信息表示属性或方法在实例上未定义但是存在引用</p>
<p>再看下 hasHandler 函数的 has 函数，has 代理方法是针对 in 操作符的，比如我们这里判断一个属性:</p>
<pre><code class="hljs language-js" lang="js">name <span class="hljs-keyword">in</span> obj
</code></pre>
<p>这就会触发代理对象 obj 的 has 拦截方法，同理上边代理对象是 vm，使用 in 操作符判断某个属性是否在 vm 上时就会触发 has 函数拦截。
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/11062bbabdda4eb281db5e7e19d78a68~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbHVja3lDb3Zlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768030013&amp;x-signature=GKjoWL%2BEZbmK1E6OW6dWxmCT59g%3D" alt="image.png" loading="lazy"/>
has 常量取值取决于 key 属性在不在 target（vm）上</p>
<p>isAllowed 常量取值满足以下其中一种就是 true，都不满足就为 false：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-title function_">allowedGlobals</span>(key) ||
<span class="hljs-keyword">typeof</span> key === <span class="hljs-string">'string'</span> &amp;&amp;
          key.<span class="hljs-title function_">charAt</span>(<span class="hljs-number">0</span>) === <span class="hljs-string">'_'</span> &amp;&amp;
          !(key <span class="hljs-keyword">in</span> target.<span class="hljs-property">$data</span>)
</code></pre>
<p>allowGlobals 函数也很简单，有我们熟悉的 makeMap 函数，第二个参数不传，就是内部匹配名称时不会转为小写去匹配，内部 map 的组成由每个逗号分割的关键字作为属性，其属性值默认为 true，调用这个函数时，如果当前 key 和 map 中某个属性名称匹配，那么取值就是 true
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b5cd3c1421014925810fc7a583de595f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbHVja3lDb3Zlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768030013&amp;x-signature=Xa97j9egUoVzoAZRBg9zL1PlB9M%3D" alt="image.png" loading="lazy"/>
下面就是判断 has 取值为 false（即属性不在 vm 上） 且 isAllowed 也为 false，内部逻辑和 getHandler 中的 get 函数相似。最后返回 has || !isAllowed 逻辑或的取值。
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1171414bcd804169aa188e42a0f4f91f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbHVja3lDb3Zlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768030013&amp;x-signature=xYn49vWH58zs80C7G3jMUykks4M%3D" alt="image.png" loading="lazy"/></p>
<p>在 initLifecycle 调用前，还有一句赋值语句，将自身引用保持在了自身的 _self 属性上
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6cc9bec014c84dbca95551e046e1566a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbHVja3lDb3Zlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768030013&amp;x-signature=3Ec9Wo3ixMM6ae6ucWjbcEXTAe8%3D" alt="image.png" loading="lazy"/></p>
<ul>
<li>initLifecycle</li>
</ul>
<p>initLifecycle 的初始化，就是往 vm 实例上添加一些属性，并赋予默认值，比如我们熟悉且常用的 <code>$refs</code>、<code>$parent</code>、<code>$root</code>、<code>$children</code> 对象，
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7abc37a1a1e045cb929d68041f1f8bb2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbHVja3lDb3Zlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768030013&amp;x-signature=13ZGn3ynujGoDl%2FkBLYab9yBAUI%3D" alt="image.png" loading="lazy"/></p>
<ul>
<li>initEvents
事件初始化</li>
</ul>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4af7275427ac47df8c4877b542b0bbf4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbHVja3lDb3Zlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768030013&amp;x-signature=HWIjuvx%2B8AUZy33QbtTretDOUVs%3D" alt="image.png" loading="lazy"/></p>
<p>核心就是 updateComponentListeners 方法，这个方法内部又调用了 updateListeners 方法</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9fd22bb446724c41a2ed626d0e80746f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbHVja3lDb3Zlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768030013&amp;x-signature=g4W6kuXqgpCjuqDEADLEdNBVDLs%3D" alt="image.png" loading="lazy"/></p>
<p>updateListeners 方法内部就是对新老事件进行处理（更新事件 on 监听，包括 add 新增事件和 remove 移除事件）</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/34cea4c085b3494298ebce6949077a9a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbHVja3lDb3Zlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768030013&amp;x-signature=S5lg1SVqgyFk4CA6O5IqUlxO8eQ%3D" alt="image.png" loading="lazy"/></p>
<ul>
<li>initRender</li>
</ul>
<p>内部定义了 <code>$slots</code>、<code>$createElement</code>、<code>$attrs</code>、<code>$listeners</code></p>
<ul>
<li>beforeCreate</li>
</ul>
<p>调用了 <code>beforeCreate</code> 生命周期钩子</p>
<ul>
<li>initInjections</li>
</ul>
<p>处理 injects 信息，将 injects 对象中的每个属性转为响应式的，这样就能和在 data 中声明的属性一样使用了，这里的关键点就是 injects 比 data 和 props 先初始化。
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/331058e95c1d4312ad64db6c8a40876d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbHVja3lDb3Zlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768030013&amp;x-signature=Wc1GSfzOz9WzJSHdGJ%2B4hz1Apwg%3D" alt="image.png" loading="lazy"/></p>
<ul>
<li>initState</li>
</ul>
<p>初始化 props、setup（vue3 语法糖）、methods、data、computed、watch（这边的初始化逻辑留到响应式系统篇章再来分析）
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/aa78c6f3193c46498b2e484b0bdbc0bc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbHVja3lDb3Zlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768030013&amp;x-signature=FBNUWTWKIhlT3yM1Y33J08Li1w8%3D" alt="image.png" loading="lazy"/></p>
<ul>
<li>initProvide</li>
</ul>
<p>处理 provide 信息，将 provide 对象内的每个属性转为响应式，provide 的初始化在 data、methods 初始化之后
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/90275fd3423f4f40851be2ab8e3b5ec7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbHVja3lDb3Zlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768030013&amp;x-signature=Jkf0eK4K%2FrBZBiu7oVPFlFASvnk%3D" alt="image.png" loading="lazy"/></p>
<ul>
<li>created</li>
</ul>
<p>调用 created 生命周期钩子</p>
<ul>
<li>$mount</li>
</ul>
<p>判断选项中如果有 el 节点，那就作为实参传入 vm.$mount 函数中
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/47c35b6f81cd4fa6beb7808c41099428~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbHVja3lDb3Zlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768030013&amp;x-signature=rthd6KSeWOe9V6hlo%2F7NIaRnZrk%3D" alt="image.png" loading="lazy"/></p>
<p>这里的 el 就是我们常说的挂载的根容器 app</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8de68d94a4d14b888caa395d621c6ae1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbHVja3lDb3Zlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768030013&amp;x-signature=8RH2M8ZcjCnyjB1QqHjRQE7tjkQ%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-1">stateMixin</h3>
<p>所在文件：<code>src/core/instance/state.ts</code>，内部逻辑也很简单
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f4776e65dcdd4ec69cace1b15fc5ffdb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbHVja3lDb3Zlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768030013&amp;x-signature=LMbUBDxzy9eJCuN4C3wyndW0t4w%3D" alt="image.png" loading="lazy"/></p>
<ul>
<li>拦截 Vue 原型上的 <code>$data</code> 和 <code>$props</code></li>
<li>Vue 原型上添加 <code>$set</code> 方法</li>
<li>Vue 原型上添加 <code>$delete</code> 方法</li>
<li>Vue 原型上添加 <code>$watch</code> 方法</li>
</ul>
<p>看看是怎么拦截的</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/20f09f9e392340f5882bbbf9e1d3e5d4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbHVja3lDb3Zlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768030013&amp;x-signature=6yDgyk%2FV3DP73%2FTVAtsClh9eAxQ%3D" alt="image.png" loading="lazy"/></p>
<p>访问 <code>Vue.prototype.$data</code> 时实际上是这样访问 <code>vm._data</code>（当前 vm 实例上的 _data 对象）</p>
<p>访问 <code>Vue.prototype.$props</code> 时实际上是这样访问 <code>vm._props</code>（当前 vm 实例上的 _props 对象）</p>
<p>如果是修改 <code>Vue.prototype.$data</code> 或者 <code>Vue.prototype.$props</code>，会走 set 拦截方法抛出错误信息</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b45b594a0c7343359757017d5bc1ca3f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbHVja3lDb3Zlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768030013&amp;x-signature=1iu1TZgeIdcTq2T%2F%2B%2BzizFdWsuo%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-2">eventsMixin</h3>
<p>eventsMixin 函数接收 Vue 构造函数作为参数，往构造函数原型上添加四个方法：</p>
<ul>
<li><code>$on</code></li>
<li><code>$once</code></li>
<li><code>$off</code></li>
<li><code>$emit</code>
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f5e4e6d61e4e47b8907b8dfaf002fa88~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbHVja3lDb3Zlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768030013&amp;x-signature=eXLwWjgAd%2FErdUAd6SULo4TDIR0%3D" alt="image.png" loading="lazy"/></li>
</ul>
<h3 data-id="heading-3">lifecycleMixin</h3>
<p>lifecycleMixin 函数接收 Vue 构造函数作为参数，往 Vue 原型添加三个方法：</p>
<ul>
<li><code>_update</code></li>
<li><code>$forceUpdate</code></li>
<li><code>$destroy</code>
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7ab0d62adf5c4f9aae41cd5070290317~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbHVja3lDb3Zlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768030013&amp;x-signature=KVIwi7BbM58JLKzY00ZmFXV%2FFkg%3D" alt="image.png" loading="lazy"/></li>
</ul>
<h3 data-id="heading-4">renderMixin</h3>
<p>renderMixin 函数接收 Vue 构造函数作为参数，往 Vue 原型添加两个方法：</p>
<ul>
<li><code>$nextTick</code></li>
<li><code>_render</code></li>
</ul>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9eb10357ca304bf6839feaa96822fb9c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbHVja3lDb3Zlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768030013&amp;x-signature=XF52qsOckee80AuEP5WQzY95aw8%3D" alt="image.png" loading="lazy"/></p>
<p>调用 installRenderHelpers 函数时将 Vue.prototype 作为实参传入
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ce2f6cb3e84a4be08caaf2cf26074cb6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbHVja3lDb3Zlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768030013&amp;x-signature=u6DWSz%2BEaQY2326L%2Faa6YbYAlWQ%3D" alt="image.png" loading="lazy"/></p>
<p>target 就是 Vue.prototype，往 Vue 原型上添加各种以 <code>_</code> 开头的方法</p>
<h3 data-id="heading-5">initGlobalAPI</h3>
<p>接收 Vue 构造函数作为形参</p>
<p>先代理 Vue 上的 config 属性（是个对象），属性描述符项是 configDef，提供 get 和 set 函数，当你尝试修改 Vue.config 时会被 configDef 的 set 函数拦截，抛出错误信息，意思就是不能替换 Vue.config 对象。如果是读取 Vue.config，就被 configDef 的 get 函数拦截，直接返回了 config，这个 config 是个对象（所在文件：<code>core/config.ts</code>）中，就是暴露了一堆全局属性（比如 async、devtools 等）
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/142c43d0b66d465188d500b948dc299f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbHVja3lDb3Zlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768030013&amp;x-signature=eczaE5ISgEh5oINu2VbCiMGScPk%3D" alt="image.png" loading="lazy"/></p>
<p>接着往 Vue.util 对象上添加一些方法
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d01dd050407941758f531a2841e8b2db~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbHVja3lDb3Zlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768030013&amp;x-signature=%2B%2FddFKRFYVnmIyzAe09fYncgeZc%3D" alt="image.png" loading="lazy"/>
Vue 官方也提供了注释，意思就是这些不被认为是公共的 API，虽然暴露出去你能用，但是不建议用，因为这几个 API 其实是 Vue 内部自己在用的。</p>
<p>再下边就往 Vue 上添加了几个方法，在之后文章会详细介绍</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/41c3c5ed68584ad38a027c5721376fb3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbHVja3lDb3Zlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768030013&amp;x-signature=qgidkvYY6RRnaB5D4yZd2Jbi4ss%3D" alt="image.png" loading="lazy"/></p>
<p>下边初始化 Vue.options 为一个空对象，遍历 ASSETS_TYPE 数组中的元素然后追加到 options 上
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e5940b7440924040a0be83f1fe4593b8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbHVja3lDb3Zlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768030013&amp;x-signature=lsoEkV0RfiA1ahfECYlBJUCtgoM%3D" alt="image.png" loading="lazy"/></p>
<p>ASSETS_TYPE 所在文件（<code>src/shared/constants.ts</code>）
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/98e921e6a7854c909cb0f810b0b636d3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbHVja3lDb3Zlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768030013&amp;x-signature=RdHn38M7jOsT0N4UwuIuAAYPCo4%3D" alt="image.png" loading="lazy"/>
数组中每个元素就是遍历时的 type，是字符串类型，往 type 对应元素名称后边拼上 s 后作为属性名，属性值默认是空对象，遍历追加完后 Vue.options 上就有如下属性：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-title class_">Vue</span>.<span class="hljs-property">options</span> = {
    <span class="hljs-attr">components</span>: {},
    <span class="hljs-attr">directives</span>: {},
    <span class="hljs-attr">filters</span>: {}
}
</code></pre>
<p>接着往 Vue.options 追加 _base 属性，属性值是 Vue 本身
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a87b4a7bedbb48d6bbf02498d8edb872~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbHVja3lDb3Zlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768030013&amp;x-signature=JbtPgfZneHd7nQq7XAHGyzWC1xw%3D" alt="image.png" loading="lazy"/>
现在 Vue.options 就多了一个属性</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-title class_">Vue</span>.<span class="hljs-property">options</span> = {
    <span class="hljs-attr">_base</span>: <span class="hljs-title class_">Vue</span>,
    <span class="hljs-attr">components</span>: {},
    <span class="hljs-attr">directives</span>: {},
    <span class="hljs-attr">filters</span>: {}
}
</code></pre>
<p>然后是 extend 函数，将 Vue.options.components 作为第一个参数（是一个对象），builtInComponent 作为第二个参数</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/108a5894607a4953bee6cbb77bbcad1c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbHVja3lDb3Zlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768030013&amp;x-signature=dXXdDgRKSLg5tTolqUhE1woj540%3D" alt="image.png" loading="lazy"/></p>
<p>builtInComponent（所在文件：<code>src/core/components/index.ts）</code>，其实就是暴露了一个 KeepAlive 组件</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/616c4ccd6ee540088a30632855c75b91~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbHVja3lDb3Zlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768030013&amp;x-signature=Q%2BVvsZdV7pH1cucc3SCM2mRGvfc%3D" alt="image.png" loading="lazy"/></p>
<p>那看下 extend 函数（所在文件：<code>src/shared/utils.ts</code>）</p>
<p>其实很简单，就是往目标对象混合属性，目标对象就是传的第一个参数（Vue.options.components），混合的属性在第二个参数里，刚才看了是一个对象，对象里边有 <code>KeepAlive</code> 属性（组件）</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8e54af6708444229983923c4470058e4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbHVja3lDb3Zlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768030013&amp;x-signature=Qo7A%2FxWQn1rv1zQBwVYFA2szM9M%3D" alt="image.png" loading="lazy"/></p>
<p>混合后就是</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-title class_">Vue</span>.<span class="hljs-property">options</span> = {
    <span class="hljs-attr">_base</span>: <span class="hljs-title class_">Vue</span>,
    <span class="hljs-attr">components</span>: {
        <span class="hljs-title class_">KeepAlive</span>
    },
    <span class="hljs-attr">directives</span>: {},
    <span class="hljs-attr">filters</span>: {}
}
</code></pre>
<p>接着下边又往 Vue 上添加了一系列方法：</p>
<p><code>initUse</code>，往 Vue 上添加了 <code>use</code> 方法
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/57900429f71c406b8f0914c0c2249b06~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbHVja3lDb3Zlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768030013&amp;x-signature=uH5ZHpz%2BxC8NglvoSBUXTPNzkwo%3D" alt="image.png" loading="lazy"/></p>
<p><code>initMixin</code>，往 Vue 上添加 <code>mixin</code> 方法
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4a004fc9c9ee4d919bdb9e0bf4d82a85~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbHVja3lDb3Zlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768030013&amp;x-signature=euXqzf%2Fk%2FUm5S9xjYl6m%2FoK7NlE%3D" alt="image.png" loading="lazy"/></p>
<p><code>initExtend</code>，往 Vue 上 添加 <code>extend</code> 方法</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/85cb80ca539c414fa14af71406d48e64~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbHVja3lDb3Zlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768030013&amp;x-signature=u%2FtwAbfhKOBmz35tYUGueC38ezc%3D" alt="image.png" loading="lazy"/></p>
<p><code>initAssetRegisters</code>，往 Vue 上添加 <code>component</code>、<code>directive</code>、<code>filter</code> 方法，<code>ASSET_TYPES</code> 刚才看过了是个数组，数组中每个元素作为函数名，在 Vue 上注册成了函数。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/251ab6556d9b47ac9e8b6205422e11eb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbHVja3lDb3Zlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768030013&amp;x-signature=d6DGjEmJ5shTbnbn9VsxwqZUU2Q%3D" alt="image.png" loading="lazy"/></p>
<p>至此，从 new Vue() 到 $mount 期间的一系列初始化操作我们就看完了，上边为了先分析传给 initGlobalAPI 的参数 Vue，所以就先分析了 initMixin 等函数，实际上 initGlobalAPI 作为核心入口文件是最先执行的。下边再来看看流程图，这会就清晰多了</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1df0cc9407e2448c847b2765c7ad1830~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbHVja3lDb3Zlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768030013&amp;x-signature=5tO0XIl4piA4WKpim2DSOitJ5%2BE%3D" alt="无标题-2025-12-18-2128.png" loading="lazy"/></p>
<p>Vue 初始化流程，每一步都做了哪些初始化，现在看就一目了然了，下篇文章我们就进击 Vue 的响应式系统~</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[OkHttp3 内部工作原理时序图]]></title>    <link>https://juejin.cn/post/7590592594674253834</link>    <guid>https://juejin.cn/post/7590592594674253834</guid>    <pubDate>2026-01-03T07:10:15.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7590592594674253834" data-draft-id="7590292138347216906" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="OkHttp3 内部工作原理时序图"/> <meta itemprop="keywords" content="Android"/> <meta itemprop="datePublished" content="2026-01-03T07:10:15.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="乾坤一气杀"/> <meta itemprop="url" content="https://juejin.cn/user/4212984289955431"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            OkHttp3 内部工作原理时序图
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4212984289955431/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    乾坤一气杀
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-03T07:10:15.000Z" title="Sat Jan 03 2026 07:10:15 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">OkHttp3 内部工作原理时序图</h2>
<p>本文档深入剖析OkHttp3框架的内部工作机制，展示其核心组件的交互流程。</p>
<h3 data-id="heading-1">1. OkHttpClient 构建流程</h3>
<pre><code class="hljs language-mermaid" lang="mermaid">sequenceDiagram
    participant Client as 开发者代码
    participant Builder as OkHttpClient.Builder
    participant Dispatcher as Dispatcher
    participant ConnectionPool as ConnectionPool
    participant OkHttpClient as OkHttpClient

    Client-&gt;&gt;Builder: new OkHttpClient.Builder()
    activate Builder

    Note over Builder: 配置网络参数
    Client-&gt;&gt;Builder: connectTimeout(duration)
    Builder-&gt;&gt;Builder: 设置连接超时
    Client-&gt;&gt;Builder: readTimeout(duration)
    Builder-&gt;&gt;Builder: 设置读超时
    Client-&gt;&gt;Builder: writeTimeout(duration)
    Builder-&gt;&gt;Builder: 设置写超时

    Note over Builder: 配置拦截器
    Client-&gt;&gt;Builder: addInterceptor(interceptor)
    Builder-&gt;&gt;Builder: interceptors.add()
    Client-&gt;&gt;Builder: addNetworkInterceptor(interceptor)
    Builder-&gt;&gt;Builder: networkInterceptors.add()

    Note over Builder: 配置连接池
    Client-&gt;&gt;Builder: connectionPool(pool)
    alt 未指定连接池
        Builder-&gt;&gt;ConnectionPool: new ConnectionPool()
        activate ConnectionPool
        ConnectionPool-&gt;&gt;ConnectionPool: 最大空闲连接: 5
        ConnectionPool-&gt;&gt;ConnectionPool: 保活时间: 5分钟
        ConnectionPool--&gt;&gt;Builder: 返回默认连接池
        deactivate ConnectionPool
    end

    Note over Builder: 配置调度器
    Client-&gt;&gt;Builder: dispatcher(dispatcher)
    alt 未指定调度器
        Builder-&gt;&gt;Dispatcher: new Dispatcher()
        activate Dispatcher
        Dispatcher-&gt;&gt;Dispatcher: 最大并发请求: 64
        Dispatcher-&gt;&gt;Dispatcher: 单Host最大请求: 5
        Dispatcher-&gt;&gt;Dispatcher: 创建线程池ExecutorService
        Dispatcher--&gt;&gt;Builder: 返回调度器
        deactivate Dispatcher
    end

    Client-&gt;&gt;Builder: build()
    Builder-&gt;&gt;OkHttpClient: new OkHttpClient(builder)
    activate OkHttpClient
    OkHttpClient-&gt;&gt;OkHttpClient: 复制所有配置
    OkHttpClient--&gt;&gt;Builder: 返回OkHttpClient实例
    deactivate OkHttpClient

    Builder--&gt;&gt;Client: 返回配置好的client
    deactivate Builder
</code></pre>
<h3 data-id="heading-2">2. 同步请求执行流程</h3>
<pre><code class="hljs language-mermaid" lang="mermaid">sequenceDiagram
    participant Client as 开发者代码
    participant OkHttpClient as OkHttpClient
    participant RealCall as RealCall
    participant Dispatcher as Dispatcher
    participant Chain as RealInterceptorChain
    participant Interceptors as 拦截器链
    participant Network as 网络服务器

    Client-&gt;&gt;OkHttpClient: newCall(request)
    activate OkHttpClient
    OkHttpClient-&gt;&gt;RealCall: new RealCall(client, request)
    activate RealCall
    RealCall-&gt;&gt;RealCall: 初始化Call对象
    RealCall--&gt;&gt;OkHttpClient: 返回Call实例
    deactivate RealCall
    OkHttpClient--&gt;&gt;Client: 返回Call
    deactivate OkHttpClient

    Note over Client,RealCall: 执行同步请求
    Client-&gt;&gt;RealCall: execute()
    activate RealCall

    RealCall-&gt;&gt;RealCall: 检查是否已执行
    alt 已执行
        RealCall--&gt;&gt;Client: throw IllegalStateException
    end

    RealCall-&gt;&gt;RealCall: executed = true
    RealCall-&gt;&gt;Dispatcher: executed(call)
    activate Dispatcher
    Dispatcher-&gt;&gt;Dispatcher: runningSyncCalls.add(call)
    Dispatcher--&gt;&gt;RealCall: 记录同步调用
    deactivate Dispatcher

    RealCall-&gt;&gt;RealCall: getResponseWithInterceptorChain()
    activate RealCall

    RealCall-&gt;&gt;Chain: new RealInterceptorChain()
    activate Chain
    Chain-&gt;&gt;Chain: 构建拦截器链
    Chain--&gt;&gt;RealCall: 返回Chain
    deactivate Chain

    RealCall-&gt;&gt;Chain: proceed(request)
    activate Chain
    Chain-&gt;&gt;Interceptors: 执行拦截器链
    activate Interceptors
    Note over Interceptors: 依次执行所有拦截器
    Interceptors-&gt;&gt;Network: 发送网络请求
    activate Network
    Network--&gt;&gt;Interceptors: 返回响应
    deactivate Network
    Interceptors--&gt;&gt;Chain: 返回Response
    deactivate Interceptors
    Chain--&gt;&gt;RealCall: 返回Response
    deactivate Chain

    RealCall--&gt;&gt;RealCall: 返回Response
    deactivate RealCall

    RealCall-&gt;&gt;Dispatcher: finished(call)
    activate Dispatcher
    Dispatcher-&gt;&gt;Dispatcher: runningSyncCalls.remove(call)
    Dispatcher--&gt;&gt;RealCall: 完成
    deactivate Dispatcher

    RealCall--&gt;&gt;Client: 返回Response
    deactivate RealCall
</code></pre>
<h3 data-id="heading-3">3. 异步请求执行流程</h3>
<pre><code class="hljs language-mermaid" lang="mermaid">sequenceDiagram
    participant Client as 开发者代码
    participant RealCall as RealCall
    participant Dispatcher as Dispatcher
    participant ExecutorService as 线程池
    participant AsyncCall as AsyncCall
    participant Chain as 拦截器链
    participant Callback as Callback

    Client-&gt;&gt;RealCall: enqueue(callback)
    activate RealCall

    RealCall-&gt;&gt;AsyncCall: new AsyncCall(callback)
    activate AsyncCall
    AsyncCall-&gt;&gt;AsyncCall: 封装回调
    AsyncCall--&gt;&gt;RealCall: 返回AsyncCall
    deactivate AsyncCall

    RealCall-&gt;&gt;Dispatcher: enqueue(asyncCall)
    activate Dispatcher

    Dispatcher-&gt;&gt;Dispatcher: 检查并发限制

    alt 可以立即执行
        Note over Dispatcher: runningAsyncCalls &lt; 64&lt;br/&gt;且单Host请求 &lt; 5
        Dispatcher-&gt;&gt;Dispatcher: runningAsyncCalls.add(call)
        Dispatcher-&gt;&gt;ExecutorService: execute(asyncCall)
        activate ExecutorService
        ExecutorService--&gt;&gt;Dispatcher: 提交成功
        deactivate ExecutorService
    else 需要等待
        Dispatcher-&gt;&gt;Dispatcher: readyAsyncCalls.add(call)
        Note over Dispatcher: 加入等待队列
    end

    Dispatcher--&gt;&gt;RealCall: 入队成功
    deactivate Dispatcher
    RealCall--&gt;&gt;Client: 立即返回
    deactivate RealCall

    Note over ExecutorService,AsyncCall: 在线程池中异步执行
    ExecutorService-&gt;&gt;AsyncCall: run()
    activate AsyncCall

    AsyncCall-&gt;&gt;Chain: getResponseWithInterceptorChain()
    activate Chain

    Note over Chain: 执行拦截器链
    Chain-&gt;&gt;Chain: 依次执行所有拦截器
    Chain-&gt;&gt;Chain: 发送网络请求
    Chain-&gt;&gt;Chain: 接收响应
    Chain--&gt;&gt;AsyncCall: 返回Response或抛出异常
    deactivate Chain

    alt 请求成功
        AsyncCall-&gt;&gt;Callback: onResponse(call, response)
        activate Callback
        Callback--&gt;&gt;AsyncCall: 处理成功响应
        deactivate Callback
    else 请求失败
        AsyncCall-&gt;&gt;Callback: onFailure(call, exception)
        activate Callback
        Callback--&gt;&gt;AsyncCall: 处理失败
        deactivate Callback
    end

    AsyncCall-&gt;&gt;Dispatcher: finished(asyncCall)
    activate Dispatcher
    Dispatcher-&gt;&gt;Dispatcher: runningAsyncCalls.remove(call)
    Dispatcher-&gt;&gt;Dispatcher: promoteAndExecute()

    Note over Dispatcher: 提升等待队列中的请求
    Dispatcher-&gt;&gt;Dispatcher: 遍历readyAsyncCalls
    Dispatcher-&gt;&gt;Dispatcher: 移动符合条件的到runningAsyncCalls
    Dispatcher-&gt;&gt;ExecutorService: 执行新的AsyncCall
    activate ExecutorService
    ExecutorService--&gt;&gt;Dispatcher: 提交成功
    deactivate ExecutorService

    Dispatcher--&gt;&gt;AsyncCall: 完成
    deactivate Dispatcher
    deactivate AsyncCall
</code></pre>
<h3 data-id="heading-4">4. 拦截器链执行流程</h3>
<pre><code class="hljs language-mermaid" lang="mermaid">sequenceDiagram
    participant RealCall as RealCall
    participant RetryInterceptor as 1.RetryAndFollowUp
    participant BridgeInterceptor as 2.Bridge
    participant CacheInterceptor as 3.Cache
    participant ConnectInterceptor as 4.Connect
    participant CallServerInterceptor as 5.CallServer
    participant Network as 网络

    RealCall-&gt;&gt;RetryInterceptor: chain.proceed(request)
    activate RetryInterceptor
    Note over RetryInterceptor: 重试和重定向拦截器
    RetryInterceptor-&gt;&gt;RetryInterceptor: 创建StreamAllocation

    RetryInterceptor-&gt;&gt;BridgeInterceptor: chain.proceed(request)
    activate BridgeInterceptor
    Note over BridgeInterceptor: 桥接拦截器-添加Headers
    BridgeInterceptor-&gt;&gt;BridgeInterceptor: 添加Content-Type/Host&lt;br/&gt;Connection/Accept-Encoding&lt;br/&gt;Cookie/User-Agent

    BridgeInterceptor-&gt;&gt;CacheInterceptor: chain.proceed(request)
    activate CacheInterceptor
    Note over CacheInterceptor: 缓存拦截器
    CacheInterceptor-&gt;&gt;CacheInterceptor: 读取缓存

    alt 使用缓存
        Note over CacheInterceptor: 缓存有效，直接返回
        CacheInterceptor--&gt;&gt;BridgeInterceptor: 返回缓存Response
    else 需要网络请求
        CacheInterceptor-&gt;&gt;ConnectInterceptor: chain.proceed(request)
        activate ConnectInterceptor
        Note over ConnectInterceptor: 连接拦截器
        ConnectInterceptor-&gt;&gt;ConnectInterceptor: 获取/创建连接
        ConnectInterceptor-&gt;&gt;ConnectInterceptor: 建立TCP连接
        ConnectInterceptor-&gt;&gt;ConnectInterceptor: TLS握手(HTTPS)

        ConnectInterceptor-&gt;&gt;CallServerInterceptor: chain.proceed(request)
        activate CallServerInterceptor
        Note over CallServerInterceptor: 请求服务器拦截器

        CallServerInterceptor-&gt;&gt;Network: 写入请求
        activate Network
        Network-&gt;&gt;Network: 处理请求
        Network--&gt;&gt;CallServerInterceptor: 返回响应
        deactivate Network

        CallServerInterceptor--&gt;&gt;ConnectInterceptor: Response
        deactivate CallServerInterceptor

        ConnectInterceptor--&gt;&gt;CacheInterceptor: Response
        deactivate ConnectInterceptor

        CacheInterceptor-&gt;&gt;CacheInterceptor: 写入缓存(如果可缓存)
        CacheInterceptor--&gt;&gt;BridgeInterceptor: Response
    end
    deactivate CacheInterceptor

    BridgeInterceptor-&gt;&gt;BridgeInterceptor: 解压gzip/保存Cookie
    BridgeInterceptor--&gt;&gt;RetryInterceptor: Response
    deactivate BridgeInterceptor

    alt 需要重试或重定向
        Note over RetryInterceptor: 3xx/408/503状态码
        RetryInterceptor-&gt;&gt;RetryInterceptor: 构建新请求
        RetryInterceptor-&gt;&gt;BridgeInterceptor: 重新执行拦截器链
        Note over RetryInterceptor: 最多重试20次
    else 成功响应
        RetryInterceptor--&gt;&gt;RealCall: 返回最终Response
    end
    deactivate RetryInterceptor
</code></pre>
<h3 data-id="heading-5">5. 连接池管理机制</h3>
<pre><code class="hljs language-mermaid" lang="mermaid">sequenceDiagram
    participant Call as RealCall
    participant Interceptor as ConnectInterceptor
    participant Finder as ExchangeFinder
    participant Pool as ConnectionPool
    participant Connection as RealConnection
    participant Socket as Socket

    Note over Call,Pool: 阶段1：从连接池获取连接
    Call-&gt;&gt;Interceptor: intercept(chain)
    activate Interceptor
    Interceptor-&gt;&gt;Finder: find()
    activate Finder

    Finder-&gt;&gt;Pool: get(address, call)
    activate Pool
    Pool-&gt;&gt;Pool: 遍历connections查找匹配
    Pool-&gt;&gt;Connection: isEligible(address)
    activate Connection
    Connection-&gt;&gt;Connection: 检查Host/端口/协议
    Connection--&gt;&gt;Pool: 匹配结果
    deactivate Connection

    alt 找到匹配的连接
        Pool-&gt;&gt;Connection: acquire(call)
        activate Connection
        Connection-&gt;&gt;Connection: calls.add(call)
        Connection--&gt;&gt;Pool: 分配成功
        deactivate Connection
        Pool--&gt;&gt;Finder: 返回可用连接
        Finder--&gt;&gt;Interceptor: 返回连接
        Interceptor--&gt;&gt;Call: 使用已有连接
        Note over Call: 复用连接，流程结束
    else 未找到可用连接
        Pool--&gt;&gt;Finder: 返回null
        Note over Finder,Socket: 阶段2：创建新连接
        Finder-&gt;&gt;Connection: new RealConnection()
        activate Connection
        Connection-&gt;&gt;Socket: 建立TCP连接
        activate Socket
        Socket-&gt;&gt;Socket: connect(address, timeout)
        Socket--&gt;&gt;Connection: 连接建立
        deactivate Socket

        Connection-&gt;&gt;Connection: TLS握手(如果HTTPS)
        Connection--&gt;&gt;Finder: 返回新连接
        deactivate Connection

        Finder-&gt;&gt;Pool: put(connection)
        Pool-&gt;&gt;Pool: connections.add()
        Pool-&gt;&gt;Pool: 触发清理任务
        Pool--&gt;&gt;Finder: 加入成功
        Finder--&gt;&gt;Interceptor: 返回新连接
        Interceptor--&gt;&gt;Call: 使用新连接
        Note over Call: 新连接已就绪
    end
    deactivate Pool
    deactivate Finder
    deactivate Interceptor

    Note over Pool: 阶段3：后台清理任务
    Pool-&gt;&gt;Pool: cleanup()定期执行
    activate Pool
    Pool-&gt;&gt;Pool: 遍历所有连接
    Pool-&gt;&gt;Connection: 检查空闲时间和数量
    activate Connection

    Connection-&gt;&gt;Connection: 判断清理条件
    Note over Connection: 空闲&gt;5分钟 或 超过最大数5
    Connection--&gt;&gt;Pool: 返回是否需要清理
    deactivate Connection

    Pool-&gt;&gt;Pool: 移除过期连接
    Pool-&gt;&gt;Connection: close()
    activate Connection
    Connection-&gt;&gt;Connection: 关闭Socket
    deactivate Connection
    Pool-&gt;&gt;Pool: 计算下次清理时间
    deactivate Pool
</code></pre>
<h3 data-id="heading-6">6. HTTP/2 多路复用机制</h3>
<pre><code class="hljs language-mermaid" lang="mermaid">sequenceDiagram
    participant Call1 as Request1
    participant Call2 as Request2
    participant Connection as RealConnection
    participant Http2 as Http2Connection
    participant Stream1 as Http2Stream(id=1)
    participant Stream2 as Http2Stream(id=3)
    participant Socket as TCP Socket
    participant Server as 服务器

    Note over Call1,Connection: 第一个请求建立HTTP/2连接
    Call1-&gt;&gt;Connection: connect()
    activate Connection
    Connection-&gt;&gt;Socket: 建立TCP连接
    activate Socket
    Socket--&gt;&gt;Connection: 连接成功
    Connection-&gt;&gt;Http2: new Http2Connection()
    activate Http2
    Http2-&gt;&gt;Socket: 发送连接前言(Preface)
    Socket-&gt;&gt;Server: PRI * HTTP/2.0
    activate Server
    Server--&gt;&gt;Socket: 返回SETTINGS帧
    Socket-&gt;&gt;Http2: 接收SETTINGS帧
    Http2-&gt;&gt;Http2: 初始化连接参数
    Http2--&gt;&gt;Connection: HTTP/2连接就绪
    deactivate Http2
    deactivate Socket
    deactivate Connection

    Note over Call1,Stream1: 第一个请求使用Stream1
    Call1-&gt;&gt;Http2: newStream()
    activate Http2
    Http2-&gt;&gt;Stream1: new Http2Stream(streamId=1)
    activate Stream1
    Stream1--&gt;&gt;Http2: 返回Stream1
    Http2--&gt;&gt;Call1: 返回Stream1
    deactivate Http2

    Call1-&gt;&gt;Stream1: writeRequestHeaders()
    Stream1-&gt;&gt;Socket: 发送HEADERS帧(streamId=1)
    activate Socket
    Socket-&gt;&gt;Server: HEADERS帧
    Stream1-&gt;&gt;Socket: 发送DATA帧(streamId=1)
    Socket-&gt;&gt;Server: DATA帧
    deactivate Socket

    Note over Call2,Stream2: 第二个请求复用同一连接
    Call2-&gt;&gt;Connection: 获取已有连接
    activate Connection
    Connection--&gt;&gt;Call2: 返回相同的Http2Connection
    deactivate Connection

    Call2-&gt;&gt;Http2: newStream()
    activate Http2
    Http2-&gt;&gt;Stream2: new Http2Stream(streamId=3)
    activate Stream2
    Stream2--&gt;&gt;Http2: 返回Stream2
    Http2--&gt;&gt;Call2: 返回Stream2
    deactivate Http2

    Note over Stream1,Stream2: 两个流在同一TCP连接上并发

    Call2-&gt;&gt;Stream2: writeRequestHeaders()
    Stream2-&gt;&gt;Socket: 发送HEADERS帧(streamId=3)
    activate Socket
    Socket-&gt;&gt;Server: HEADERS帧
    Stream2-&gt;&gt;Socket: 发送DATA帧(streamId=3)
    Socket-&gt;&gt;Server: DATA帧

    Note over Server: 服务器并发处理两个请求

    Server-&gt;&gt;Socket: HEADERS帧(streamId=1)
    Socket-&gt;&gt;Stream1: 接收HEADERS帧
    Stream1-&gt;&gt;Call1: onResponse()
    activate Call1

    Server-&gt;&gt;Socket: DATA帧(streamId=3)
    Socket-&gt;&gt;Stream2: 接收DATA帧
    Stream2-&gt;&gt;Call2: onResponse()
    activate Call2

    Server-&gt;&gt;Socket: DATA帧(streamId=1)
    Socket-&gt;&gt;Stream1: 接收DATA帧
    Stream1--&gt;&gt;Call1: 响应体
    deactivate Call1

    Server-&gt;&gt;Socket: DATA帧(streamId=3, END_STREAM)
    Socket-&gt;&gt;Stream2: 接收DATA帧
    Stream2--&gt;&gt;Call2: 响应体
    deactivate Socket
    deactivate Server
    deactivate Call2

    Stream1-&gt;&gt;Stream1: 流关闭
    deactivate Stream1
    Stream2-&gt;&gt;Stream2: 流关闭
    deactivate Stream2
</code></pre>
<h3 data-id="heading-7">7. 缓存机制详解</h3>
<pre><code class="hljs language-mermaid" lang="mermaid">sequenceDiagram
    participant Call as RealCall
    participant CacheInterceptor as CacheInterceptor
    participant Cache as Cache
    participant DiskLruCache as DiskLruCache
    participant CacheStrategy as CacheStrategy
    participant Network as 网络

    Call-&gt;&gt;CacheInterceptor: intercept(chain)
    activate CacheInterceptor

    Note over CacheInterceptor,Cache: 阶段1：读取缓存
    CacheInterceptor-&gt;&gt;Cache: get(request)
    activate Cache
    Cache-&gt;&gt;Cache: 计算key = hash(url)
    Cache-&gt;&gt;DiskLruCache: get(key)
    activate DiskLruCache
    DiskLruCache-&gt;&gt;DiskLruCache: 读取缓存文件
    DiskLruCache--&gt;&gt;Cache: 返回缓存条目或null
    deactivate DiskLruCache
    Cache-&gt;&gt;Cache: 解析响应头和响应体
    Cache--&gt;&gt;CacheInterceptor: 返回Response或null
    deactivate Cache

    Note over CacheInterceptor,CacheStrategy: 阶段2：确定缓存策略
    CacheInterceptor-&gt;&gt;CacheStrategy: get(request, cacheResponse)
    activate CacheStrategy
    CacheStrategy-&gt;&gt;CacheStrategy: 分析Cache-Control
    CacheStrategy-&gt;&gt;CacheStrategy: 检查max-age/Expires
    CacheStrategy-&gt;&gt;CacheStrategy: 检查ETag/Last-Modified
    CacheStrategy--&gt;&gt;CacheInterceptor: 返回策略(networkRequest, cacheResponse)
    deactivate CacheStrategy

    Note over CacheInterceptor: 阶段3：执行策略

    alt 策略1：仅使用缓存
        Note over CacheInterceptor: networkRequest==null
        CacheInterceptor--&gt;&gt;Call: 返回缓存Response
    else 策略2：发送网络请求
        CacheInterceptor-&gt;&gt;Network: chain.proceed(request)
        activate Network
        Network--&gt;&gt;CacheInterceptor: 返回networkResponse
        deactivate Network

        alt 响应304 Not Modified
            CacheInterceptor-&gt;&gt;CacheInterceptor: 合并缓存和网络响应
            CacheInterceptor-&gt;&gt;Cache: update(cacheResponse)
            activate Cache
            Cache-&gt;&gt;DiskLruCache: 更新响应头
            activate DiskLruCache
            DiskLruCache--&gt;&gt;Cache: 更新成功
            deactivate DiskLruCache
            Cache--&gt;&gt;CacheInterceptor: 完成
            deactivate Cache
            CacheInterceptor--&gt;&gt;Call: 返回更新后的缓存
        else 响应200 OK
            CacheInterceptor-&gt;&gt;CacheInterceptor: 检查是否可缓存
            CacheInterceptor-&gt;&gt;Cache: put(response)
            activate Cache
            Cache-&gt;&gt;Cache: 验证Cache-Control
            Cache-&gt;&gt;Cache: 验证响应码
            Cache-&gt;&gt;DiskLruCache: put(key, response)
            activate DiskLruCache
            DiskLruCache-&gt;&gt;DiskLruCache: 写入响应头
            DiskLruCache-&gt;&gt;DiskLruCache: 写入响应体
            DiskLruCache--&gt;&gt;Cache: 写入成功
            deactivate DiskLruCache
            Cache--&gt;&gt;CacheInterceptor: 缓存成功
            deactivate Cache
            CacheInterceptor--&gt;&gt;Call: 返回网络Response
        end
    end

    deactivate CacheInterceptor
</code></pre>
<h3 data-id="heading-8">8. WebSocket 连接机制</h3>
<pre><code class="hljs language-mermaid" lang="mermaid">sequenceDiagram
    participant Client as 开发者代码
    participant OkHttpClient as OkHttpClient
    participant RealWebSocket as RealWebSocket
    participant WebSocketWriter as WebSocketWriter
    participant WebSocketReader as WebSocketReader
    participant RealCall as RealCall
    participant Server as WebSocket服务器

    Client-&gt;&gt;OkHttpClient: newWebSocket(request, listener)
    activate OkHttpClient

    OkHttpClient-&gt;&gt;RealWebSocket: new RealWebSocket()
    activate RealWebSocket
    RealWebSocket-&gt;&gt;RealWebSocket: 初始化WebSocket
    RealWebSocket--&gt;&gt;OkHttpClient: 返回WebSocket实例
    OkHttpClient--&gt;&gt;Client: 返回WebSocket
    deactivate OkHttpClient

    Note over RealWebSocket: 发起WebSocket握手
    RealWebSocket-&gt;&gt;RealCall: 创建HTTP升级请求
    activate RealCall
    RealCall-&gt;&gt;RealCall: 添加升级Headers&lt;br/&gt;Upgrade: websocket&lt;br/&gt;Connection: Upgrade&lt;br/&gt;Sec-WebSocket-Key&lt;br/&gt;Sec-WebSocket-Version: 13

    RealCall-&gt;&gt;Server: 发送HTTP请求
    activate Server
    Server-&gt;&gt;Server: 验证WebSocket握手
    Server--&gt;&gt;RealCall: 101 Switching Protocols
    deactivate Server

    RealCall-&gt;&gt;RealCall: 验证响应&lt;br/&gt;Sec-WebSocket-Accept
    RealCall--&gt;&gt;RealWebSocket: 握手成功
    deactivate RealCall

    Note over RealWebSocket: 初始化读写
    RealWebSocket-&gt;&gt;WebSocketWriter: initWriter(streams)
    activate WebSocketWriter
    WebSocketWriter-&gt;&gt;WebSocketWriter: 初始化输出流
    WebSocketWriter--&gt;&gt;RealWebSocket: Writer就绪
    deactivate WebSocketWriter

    RealWebSocket-&gt;&gt;WebSocketReader: initReader(streams)
    activate WebSocketReader
    WebSocketReader-&gt;&gt;WebSocketReader: 初始化输入流
    WebSocketReader--&gt;&gt;RealWebSocket: Reader就绪
    deactivate WebSocketReader

    RealWebSocket-&gt;&gt;Client: onOpen(webSocket, response)
    activate Client
    Client--&gt;&gt;RealWebSocket: 连接已打开
    deactivate Client

    Note over Client,Server: 双向通信阶段

    Client-&gt;&gt;RealWebSocket: send(text)
    activate RealWebSocket
    RealWebSocket-&gt;&gt;WebSocketWriter: writeMessageFrame(TEXT, text)
    activate WebSocketWriter
    WebSocketWriter-&gt;&gt;WebSocketWriter: 添加掩码(Mask)
    WebSocketWriter-&gt;&gt;WebSocketWriter: 构建WebSocket帧
    WebSocketWriter-&gt;&gt;Server: 发送TEXT帧
    activate Server
    WebSocketWriter--&gt;&gt;RealWebSocket: 发送成功
    deactivate WebSocketWriter
    RealWebSocket--&gt;&gt;Client: 返回true
    deactivate RealWebSocket

    Server-&gt;&gt;WebSocketReader: 接收TEXT帧
    activate WebSocketReader
    WebSocketReader-&gt;&gt;WebSocketReader: 读取帧头
    WebSocketReader-&gt;&gt;WebSocketReader: 读取Payload
    WebSocketReader-&gt;&gt;RealWebSocket: processFrame(TEXT, payload)
    deactivate WebSocketReader
    activate RealWebSocket
    RealWebSocket-&gt;&gt;Client: onMessage(text)
    activate Client
    Client--&gt;&gt;RealWebSocket: 处理消息
    deactivate Client
    deactivate RealWebSocket

    Note over RealWebSocket,Server: Ping/Pong心跳

    RealWebSocket-&gt;&gt;WebSocketWriter: writePing()
    activate WebSocketWriter
    WebSocketWriter-&gt;&gt;Server: 发送PING帧
    Server--&gt;&gt;WebSocketWriter: 返回PONG帧
    deactivate Server
    deactivate WebSocketWriter

    WebSocketReader-&gt;&gt;RealWebSocket: processPong()
    activate WebSocketReader
    activate RealWebSocket
    RealWebSocket-&gt;&gt;RealWebSocket: 更新最后Pong时间
    deactivate RealWebSocket
    deactivate WebSocketReader

    Note over Client,Server: 关闭连接

    Client-&gt;&gt;RealWebSocket: close(code, reason)
    activate RealWebSocket
    RealWebSocket-&gt;&gt;WebSocketWriter: writeClose(code, reason)
    activate WebSocketWriter
    WebSocketWriter-&gt;&gt;Server: 发送CLOSE帧
    activate Server
    WebSocketWriter--&gt;&gt;RealWebSocket: 发送成功
    deactivate WebSocketWriter

    Server-&gt;&gt;WebSocketReader: 接收CLOSE帧
    activate WebSocketReader
    WebSocketReader-&gt;&gt;RealWebSocket: processClose()
    deactivate WebSocketReader
    RealWebSocket-&gt;&gt;Client: onClosing(code, reason)
    activate Client
    Client--&gt;&gt;RealWebSocket: 确认关闭
    deactivate Client

    Server--&gt;&gt;RealWebSocket: 关闭连接
    deactivate Server

    RealWebSocket-&gt;&gt;Client: onClosed(code, reason)
    activate Client
    Client--&gt;&gt;RealWebSocket: 连接已关闭
    deactivate Client
    deactivate RealWebSocket
</code></pre>
<h3 data-id="heading-9">9. 完整请求生命周期流程图</h3>
<pre><code class="hljs language-mermaid" lang="mermaid">flowchart TD
    Start([创建Request]) --&gt; NewCall[OkHttpClient.newCall]
    NewCall --&gt; ChooseSync{同步还是异步?}

    ChooseSync --&gt;|execute| SyncExec[同步执行]
    ChooseSync --&gt;|enqueue| AsyncExec[异步执行]

    SyncExec --&gt; CheckExecuted{是否已执行?}
    CheckExecuted --&gt;|是| ThrowError[抛出异常]
    CheckExecuted --&gt;|否| MarkExecuted[标记已执行]

    AsyncExec --&gt; EnqueueAsync[加入Dispatcher队列]
    EnqueueAsync --&gt; CheckLimit{检查并发限制}
    CheckLimit --&gt;|达到上限| AddToReady[加入就绪队列]
    CheckLimit --&gt;|未达上限| AddToRunning[加入运行队列]
    AddToRunning --&gt; ExecuteInPool[线程池执行]

    MarkExecuted --&gt; BuildChain[构建拦截器链]
    ExecuteInPool --&gt; BuildChain

    BuildChain --&gt; Interceptor1[RetryAndFollowUp&lt;br/&gt;重试和重定向]
    Interceptor1 --&gt; Interceptor2[BridgeInterceptor&lt;br/&gt;桥接拦截器]
    Interceptor2 --&gt; Interceptor3[CacheInterceptor&lt;br/&gt;缓存拦截器]

    Interceptor3 --&gt; CheckCache{检查缓存}
    CheckCache --&gt;|有效缓存| ReturnCache[返回缓存响应]
    CheckCache --&gt;|无缓存/失效| Interceptor4[ConnectInterceptor&lt;br/&gt;连接拦截器]

    Interceptor4 --&gt; FindConnection{查找连接}
    FindConnection --&gt;|池中有可用连接| ReuseConnection[复用连接]
    FindConnection --&gt;|无可用连接| CreateConnection[创建新连接]

    CreateConnection --&gt; TCPConnect[建立TCP连接]
    TCPConnect --&gt; CheckProtocol{协议类型?}
    CheckProtocol --&gt;|HTTP| HTTP1[HTTP/1.1]
    CheckProtocol --&gt;|HTTPS| TLSHandshake[TLS握手]
    TLSHandshake --&gt; CheckHTTP2{是否支持HTTP/2?}
    CheckHTTP2 --&gt;|是| HTTP2[HTTP/2]
    CheckHTTP2 --&gt;|否| HTTP1

    ReuseConnection --&gt; AddToPool[加入连接池]
    HTTP1 --&gt; AddToPool
    HTTP2 --&gt; AddToPool

    AddToPool --&gt; Interceptor5[CallServerInterceptor&lt;br/&gt;请求服务器]

    Interceptor5 --&gt; WriteRequest[写入请求]
    WriteRequest --&gt; WriteHeaders[写入请求头]
    WriteHeaders --&gt; CheckBody{有请求体?}
    CheckBody --&gt;|是| WriteBody[写入请求体]
    CheckBody --&gt;|否| ReadResponse[读取响应]
    WriteBody --&gt; ReadResponse

    ReadResponse --&gt; ReadHeaders[读取响应头]
    ReadHeaders --&gt; ReadBody[读取响应体]

    ReadBody --&gt; CheckStatus{检查状态码}
    CheckStatus --&gt;|3xx| CheckRedirect{是否重定向?}
    CheckRedirect --&gt;|是| Interceptor1
    CheckRedirect --&gt;|否| ProcessResponse

    CheckStatus --&gt;|2xx/4xx/5xx| ProcessResponse[处理响应]

    ReturnCache --&gt; ProcessResponse
    ProcessResponse --&gt; SaveCache{是否可缓存?}
    SaveCache --&gt;|是| WriteCache[写入缓存]
    SaveCache --&gt;|否| ReturnResponse

    WriteCache --&gt; ReturnResponse[返回Response]

    ReturnResponse --&gt; FinishCall{执行类型?}
    FinishCall --&gt;|同步| RemoveSync[从同步队列移除]
    FinishCall --&gt;|异步| RemoveAsync[从异步队列移除]

    RemoveAsync --&gt; PromoteWaiting[提升等待队列]
    PromoteWaiting --&gt; ExecuteNext[执行下一个请求]

    RemoveSync --&gt; End([请求完成])
    ExecuteNext --&gt; End

    style Start fill:#e1f5e1
    style End fill:#ffe1e1
    style CheckCache fill:#fff4e1
    style FindConnection fill:#e1f0ff
    style CheckStatus fill:#ffe1f0
</code></pre>
<h3 data-id="heading-10">核心类关系说明</h3>
<h4 data-id="heading-11">1. OkHttpClient</h4>
<ul>
<li><strong>职责</strong>: 框架入口，管理全局配置</li>
<li><strong>核心成员</strong>:
<ul>
<li><code>Dispatcher</code>: 调度器，管理异步请求队列</li>
<li><code>ConnectionPool</code>: 连接池，管理连接复用</li>
<li><code>List&lt;Interceptor&gt;</code>: 应用拦截器列表</li>
<li><code>List&lt;Interceptor&gt;</code>: 网络拦截器列表</li>
<li><code>Cache</code>: 缓存管理器</li>
</ul>
</li>
<li><strong>配置项</strong>:
<ul>
<li>超时时间(连接、读、写)</li>
<li>代理设置</li>
<li>SSL配置</li>
<li>Cookie管理器</li>
<li>DNS解析器</li>
</ul>
</li>
</ul>
<h4 data-id="heading-12">2. RealCall</h4>
<ul>
<li><strong>职责</strong>: 真正的Call实现，封装单个HTTP请求</li>
<li><strong>核心方法</strong>:
<ul>
<li><code>execute()</code>: 同步执行</li>
<li><code>enqueue(Callback)</code>: 异步执行</li>
<li><code>cancel()</code>: 取消请求</li>
<li><code>getResponseWithInterceptorChain()</code>: 执行拦截器链</li>
</ul>
</li>
<li><strong>状态管理</strong>:
<ul>
<li><code>executed</code>: 是否已执行</li>
<li><code>canceled</code>: 是否已取消</li>
</ul>
</li>
</ul>
<h4 data-id="heading-13">3. Dispatcher</h4>
<ul>
<li><strong>职责</strong>: 请求调度器，管理并发策略</li>
<li><strong>核心成员</strong>:
<ul>
<li><code>ExecutorService</code>: 线程池</li>
<li><code>Deque&lt;AsyncCall&gt; readyAsyncCalls</code>: 等待队列</li>
<li><code>Deque&lt;AsyncCall&gt; runningAsyncCalls</code>: 运行队列</li>
<li><code>Deque&lt;RealCall&gt; runningSyncCalls</code>: 同步调用队列</li>
</ul>
</li>
<li><strong>并发控制</strong>:
<ul>
<li>最大并发请求数: 64</li>
<li>单Host最大并发: 5</li>
<li><code>promoteAndExecute()</code>: 提升等待队列中的请求</li>
</ul>
</li>
</ul>
<h4 data-id="heading-14">4. RealInterceptorChain</h4>
<ul>
<li><strong>职责</strong>: 拦截器链的实现，责任链模式</li>
<li><strong>核心成员</strong>:
<ul>
<li><code>List&lt;Interceptor&gt; interceptors</code>: 拦截器列表</li>
<li><code>int index</code>: 当前拦截器索引</li>
<li><code>Request request</code>: 当前请求</li>
<li><code>Call call</code>: 关联的Call对象</li>
</ul>
</li>
<li><strong>核心方法</strong>:
<ul>
<li><code>proceed(Request)</code>: 继续执行下一个拦截器</li>
</ul>
</li>
</ul>
<h4 data-id="heading-15">5. 内置拦截器</h4>
<h5 data-id="heading-16">RetryAndFollowUpInterceptor</h5>
<ul>
<li><strong>职责</strong>: 重试和重定向</li>
<li><strong>功能</strong>:
<ul>
<li>创建StreamAllocation</li>
<li>处理连接失败重试</li>
<li>处理重定向(3xx状态码)</li>
<li>最大重定向次数: 20</li>
</ul>
</li>
</ul>
<h5 data-id="heading-17">BridgeInterceptor</h5>
<ul>
<li><strong>职责</strong>: 桥接应用层和网络层</li>
<li><strong>功能</strong>:
<ul>
<li>添加必要的请求头(Host、Content-Type等)</li>
<li>处理Cookie</li>
<li>处理gzip压缩</li>
<li>保存响应Cookie</li>
</ul>
</li>
</ul>
<h5 data-id="heading-18">CacheInterceptor</h5>
<ul>
<li><strong>职责</strong>: 缓存管理</li>
<li><strong>功能</strong>:
<ul>
<li>读取缓存</li>
<li>缓存策略(CacheStrategy)</li>
<li>处理304 Not Modified</li>
<li>写入缓存</li>
</ul>
</li>
</ul>
<h5 data-id="heading-19">ConnectInterceptor</h5>
<ul>
<li><strong>职责</strong>: 建立连接</li>
<li><strong>功能</strong>:
<ul>
<li>从连接池获取连接</li>
<li>创建新连接(TCP、TLS)</li>
<li>HTTP/2协商</li>
<li>将连接加入连接池</li>
</ul>
</li>
</ul>
<h5 data-id="heading-20">CallServerInterceptor</h5>
<ul>
<li><strong>职责</strong>: 发送请求和接收响应</li>
<li><strong>功能</strong>:
<ul>
<li>写入请求头和请求体</li>
<li>读取响应头和响应体</li>
<li>处理100-continue</li>
<li>处理分块传输编码</li>
</ul>
</li>
</ul>
<h4 data-id="heading-21">6. ConnectionPool</h4>
<ul>
<li><strong>职责</strong>: HTTP连接池管理</li>
<li><strong>核心配置</strong>:
<ul>
<li>最大空闲连接数: 5</li>
<li>连接保活时间: 5分钟</li>
</ul>
</li>
<li><strong>核心方法</strong>:
<ul>
<li><code>get(Address, Call)</code>: 获取可用连接</li>
<li><code>put(RealConnection)</code>: 添加连接到池</li>
<li><code>cleanup()</code>: 清理过期连接</li>
</ul>
</li>
<li><strong>清理策略</strong>:
<ul>
<li>后台线程定期清理</li>
<li>清理空闲超时的连接</li>
<li>清理超过最大空闲数的连接</li>
</ul>
</li>
</ul>
<h4 data-id="heading-22">7. RealConnection</h4>
<ul>
<li><strong>职责</strong>: 真正的物理连接</li>
<li><strong>核心成员</strong>:
<ul>
<li><code>Socket rawSocket</code>: TCP Socket</li>
<li><code>Socket socket</code>: 可能是TLS包装的Socket</li>
<li><code>Protocol protocol</code>: HTTP/1.1 或 HTTP/2</li>
<li><code>Http2Connection http2Connection</code>: HTTP/2连接</li>
</ul>
</li>
<li><strong>生命周期</strong>:
<ul>
<li>建立连接(connect)</li>
<li>执行请求(可复用)</li>
<li>空闲回收</li>
</ul>
</li>
</ul>
<h4 data-id="heading-23">8. Cache</h4>
<ul>
<li><strong>职责</strong>: HTTP缓存实现</li>
<li><strong>底层实现</strong>: DiskLruCache</li>
<li><strong>缓存键</strong>: URL的MD5哈希</li>
<li><strong>缓存内容</strong>:
<ul>
<li>响应头(Journal文件)</li>
<li>响应体(单独的缓存文件)</li>
</ul>
</li>
<li><strong>缓存策略</strong>:
<ul>
<li>遵循HTTP缓存规范</li>
<li>Cache-Control、Expires、ETag、Last-Modified</li>
</ul>
</li>
</ul>
<h4 data-id="heading-24">9. Http2Connection</h4>
<ul>
<li><strong>职责</strong>: HTTP/2连接管理</li>
<li><strong>核心特性</strong>:
<ul>
<li>多路复用: 单个连接支持多个流</li>
<li>流量控制: Window size管理</li>
<li>服务器推送</li>
<li>头部压缩(HPACK)</li>
</ul>
</li>
<li><strong>核心成员</strong>:
<ul>
<li><code>Map&lt;Integer, Http2Stream&gt; streams</code>: 流映射表</li>
<li><code>Settings peerSettings</code>: 对端配置</li>
<li><code>Settings okHttpSettings</code>: 本地配置</li>
</ul>
</li>
</ul>
<h4 data-id="heading-25">10. WebSocket</h4>
<ul>
<li><strong>职责</strong>: WebSocket协议支持</li>
<li><strong>核心组件</strong>:
<ul>
<li><code>RealWebSocket</code>: WebSocket实现</li>
<li><code>WebSocketReader</code>: 读取WebSocket帧</li>
<li><code>WebSocketWriter</code>: 写入WebSocket帧</li>
</ul>
</li>
<li><strong>帧类型</strong>:
<ul>
<li>TEXT: 文本消息</li>
<li>BINARY: 二进制消息</li>
<li>PING/PONG: 心跳</li>
<li>CLOSE: 关闭连接</li>
</ul>
</li>
</ul>
<h3 data-id="heading-26">OkHttp 特性总结</h3>
<h4 data-id="heading-27">并发策略</h4>
<ul>
<li><strong>异步请求</strong>: 通过Dispatcher管理线程池</li>
<li><strong>最大并发</strong>: 全局64个，单Host 5个</li>
<li><strong>队列管理</strong>: 等待队列自动提升到运行队列</li>
</ul>
<h4 data-id="heading-28">连接管理</h4>
<ul>
<li><strong>连接复用</strong>: ConnectionPool管理连接池</li>
<li><strong>HTTP/1.1</strong>: Keep-Alive保持连接</li>
<li><strong>HTTP/2</strong>: 多路复用，单连接多流</li>
<li><strong>自动清理</strong>: 后台线程定期清理过期连接</li>
</ul>
<h4 data-id="heading-29">缓存策略</h4>
<ul>
<li><strong>DiskLruCache</strong>: 基于磁盘的LRU缓存</li>
<li><strong>HTTP规范</strong>: 遵循RFC 7234缓存规范</li>
<li><strong>条件请求</strong>: 支持If-None-Match、If-Modified-Since</li>
<li><strong>透明压缩</strong>: 自动处理gzip压缩</li>
</ul>
<h4 data-id="heading-30">协议支持</h4>
<ul>
<li><strong>HTTP/1.1</strong>: 基础协议</li>
<li><strong>HTTP/2</strong>: 多路复用、服务器推送</li>
<li><strong>HTTPS</strong>: TLS/SSL支持</li>
<li><strong>WebSocket</strong>: 全双工通信</li>
</ul>
<h4 data-id="heading-31">拦截器机制</h4>
<ul>
<li><strong>责任链模式</strong>: 灵活的请求/响应处理</li>
<li><strong>应用拦截器</strong>: 最外层，看到的是应用层的请求/响应</li>
<li><strong>网络拦截器</strong>: 网络层，看到的是实际网络传输的请求/响应</li>
<li><strong>内置拦截器</strong>: 重试、桥接、缓存、连接、请求服务器</li>
</ul>
<hr/>
<blockquote>
<p>本文档深入剖析了OkHttp3框架的内部工作机制，涵盖了从客户端创建到请求执行的完整流程，包括连接池、缓存、HTTP/2、WebSocket等高级特性。</p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[构建AI智能体：七十二、交叉验证：从模型评估的基石到大模型时代的演进]]></title>    <link>https://juejin.cn/post/7590469811408584731</link>    <guid>https://juejin.cn/post/7590469811408584731</guid>    <pubDate>2026-01-03T03:13:17.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7590469811408584731" data-draft-id="7590452143016247334" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="构建AI智能体：七十二、交叉验证：从模型评估的基石到大模型时代的演进"/> <meta itemprop="keywords" content="人工智能,Python,LLM"/> <meta itemprop="datePublished" content="2026-01-03T03:13:17.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="彼岸花开了吗"/> <meta itemprop="url" content="https://juejin.cn/user/4153315734334538"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            构建AI智能体：七十二、交叉验证：从模型评估的基石到大模型时代的演进
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4153315734334538/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    彼岸花开了吗
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-03T03:13:17.000Z" title="Sat Jan 03 2026 03:13:17 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">一. 前言</h2>
<p>在机器学习的核心工作流中，模型评估与选择是确保最终模型泛化能力的关键。当数据有限时，如何准确评估模型性能、避免过拟合成为核心挑战。交叉验证作为一种强大而经典的统计方法，通过最大限度地利用有限数据，为我们提供了对模型性能更稳健、更无偏的估计。它不仅是传统机器学习中模型选择与超参数调优的黄金标准，更以其“重复利用与平均验证”的核心理念，深刻影响了现代机器学习的工作范式。</p>
<p>今天我们将深入浅出地解析交叉验证的思想起源与数学基础，详细剖析k折交叉验证等主流变体的工作机制与实现细节，并系统展示其如何科学地指导模型比较与超参数优化。随着我们进入大模型时代，面对千亿参数与海量数据，交叉验证的传统形式正经历深刻演变。我们将探讨其在大规模预训练、指令微调等新场景下面临的挑战与适应性调整，揭示这一经典方法在现代AI实践中的全新定位与价值延续。从基础原理到前沿应用，构建交叉验证的完整知识体系。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/84828a7b43e54c0fb95979f4fb4a7ebb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5b285bK46Iqx5byA5LqG5ZCX:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768014881&amp;x-signature=WlxahjtF6%2BJj9Y2wGQws%2FpGxfQI%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-1">二、什么是交叉验证</h2>
<p>当我们开发一个预测模型时，最大的挑战是如何准确判断这个模型在未知数据上的表现。如果仅仅使用单次的数据划分，比如用70%数据训练、30%数据测试，评估结果往往会受到具体划分方式的强烈影响。这种划分可能恰好让模型碰上好运，也可能让模型遭遇不测，从而导致我们对模型性能产生过于乐观或悲观的误判。</p>
<p>交叉验证的精妙之处就在于它采用了一种轮换验证的机制。以最常用的5折交叉验证为例，它将原始数据随机均匀分成5个互斥的子集。在每一轮验证中，其中一个子集扮演验证集的角色，用来测试模型性能，而其余四个子集则共同组成训练集，用于模型构建。这个过程重复进行5次，确保每个数据子集都有机会被用作验证集，最终将5次验证结果进行平均，得到模型的综合性能评分。</p>
<p><strong>这种方法带来了两个关键优势：</strong></p>
<ul>
<li>首先，它极大地降低了评估结果的随机性，使得性能估计更加稳定和可靠。无论数据如何分布，通过这种轮换测试得到的平均成绩都能够更真实地反映模型的泛化能力。</li>
<li>其次，它最大限度地利用了有限的数据资源，让几乎所有的样本都既参与了训练又参与了验证，这对于数据稀缺的场景尤其宝贵。</li>
</ul>
<p>用一个更生活化的例子来通俗的解释交叉验证，如果我们想判断一位家教老师的教学水平如何：</p>
<p><strong>1. 普通的方法，单次测试：</strong></p>
<ul>
<li>假设我们有10套真题，一般我们会让这位老师只用8套真题辅导学生，然后用剩下的2套真题来测试学生成绩。</li>
<li>问题：如果测试用的2套题恰好是老师重点讲过的题型，成绩就会虚高；反之，如果全是没讲过的冷门题，成绩就会偏低，这种评估方式非常依赖运气。</li>
</ul>
<p><strong>2. 交叉验证的方法，轮换测试：</strong></p>
<p>我们可以采用更科学的方式来评估：</p>
<ul>
<li>第一步：准备5套难度相近的测试卷（A、B、C、D、E）。</li>
<li>第二步：进行5轮教学测试：
<ul>
<li>第1轮：老师用 B、C、D、E 卷辅导学生，然后用 A卷 测试，记录分数。</li>
<li>第2轮：老师用 A、C、D、E 卷辅导学生，然后用 B卷 测试，记录分数。</li>
<li>重复这个过程，直到每套试卷都当过一次测试卷。</li>
</ul>
</li>
<li>第三步：计算这5个分数的平均值。</li>
</ul>
<p>这个平均分就能客观、稳定地反映出老师的真实教学水平。</p>
<p><strong>交叉验证体现的价值：</strong></p>
<ul>
<li>评估更公平：不依赖某一次特定的考试运气，结果更具代表性。</li>
<li>数据利用更高效：所有试卷都既用于教学又用于测试，物尽其用。</li>
</ul>
<p>综上所诉，交叉验证就像一套严谨的教师评估体系，通过轮换测试取平均分的方式，确保评估结果的客观性和可靠性，帮助我们做出最佳决策。</p>
<h2 data-id="heading-2">三、交叉验证的特点</h2>
<p>在理想情况下，我们拥有无限的数据。我们可以将数据分为三部分：</p>
<ul>
<li>训练集：用于构建模型。</li>
<li>验证集：用于在训练过程中评估模型，指导模型选择和调参。</li>
<li>测试集：用于最终、一次性地评估模型的泛化性能，模拟真实世界应用。</li>
</ul>
<p>然而，现实是数据通常有限。如果我们简单地使用一个固定的“训练-验证”分割，会引入两个主要问题：</p>
<ul>
<li>**1. 评估结果方差高：**模型性能对数据如何分割非常敏感。一次幸运或不幸的分割可能导致我们对模型性能产生过于乐观或悲观的估计。</li>
<li>**2. 数据利用不充分：**特别是当数据集较小时，留出一部分作为验证集意味着模型无法从这些宝贵的数据中学习，这本身就会导致模型性能下降。</li>
</ul>
<p>**交叉验证的核心理念：**通过多次、有组织地划分训练集和验证集，让每一份数据都有机会充当训练集和验证集，从而得到多个性能评估值。最终，我们取这些评估值的平均值作为模型性能的最终估计。这种方法显著降低了评估结果的方差，并更充分地利用了数据。</p>
<h2 data-id="heading-3">四、k折交叉验证</h2>
<p>在众多交叉验证方法中，k折交叉验证 无疑是最常用、最经典的一种。</p>
<p><strong>工作原理：</strong></p>
<ul>
<li>**1. 分割：**将原始训练数据集随机、均匀地分割成k个大小相似的互斥子集，称为“折”，通常k取5或10。</li>
<li>**2. 迭代训练与验证：**进行k次迭代。在每一次迭代 i (i=1, 2, ..., k) 中：
<ul>
<li>将第 i 折数据作为验证集。</li>
<li>将剩余的 k-1 折数据合并，作为训练集。</li>
<li>在训练集上训练模型，并在验证集上评估模型，得到一个性能得分 S_i（如准确率、F1分数等）。</li>
</ul>
</li>
<li>**3. 性能汇总：**完成k次迭代后，我们会得到k个性能得分 S_1, S_2, ..., S_k。</li>
<li>**4. 计算最终性能：**将这k个得分取平均值，作为该模型泛化性能的最终估计：
<ul>
<li>最终性能 = (S_1 + S_2 + ... + S_k) / k</li>
</ul>
</li>
<li>**5. 报告不确定性：**同时，我们还可以计算这k个得分的标准差，以衡量模型性能的稳定性。标准差越小，说明模型对数据分割不敏感，越稳定。</li>
</ul>
<p><strong>执行过程：</strong></p>
<p>假设 k=5，过程如下所示：</p>
<blockquote>
<p>初始数据集: [------------------------------------]<br/>
分割为5折: [折1][折2][折3][折4][折5]</p>
<p>迭代1: 训练集:[折2][折3][折4][折5] 验证集:[折1] -&gt; 得分S1<br/>
迭代2: 训练集:[折1][折3][折4][折5] 验证集:[折2] -&gt; 得分S2<br/>
迭代3: 训练集:[折1][折2][折4][折5] 验证集:[折3] -&gt; 得分S3<br/>
迭代4: 训练集:[折1][折2][折3][折5] 验证集:[折4] -&gt; 得分S4<br/>
迭代5: 训练集:[折1][折2][折3][折4] 验证集:[折5] -&gt; 得分S5</p>
</blockquote>
<p><strong>k值的选择：</strong></p>
<ul>
<li>k较小（如k=5）：训练成本低，但评估结果的偏差可能略高，因为训练集相对较小。</li>
<li>k较大（如k=10）：评估结果的偏差更低，更接近真实泛化性能，但训练成本是k=5的两倍。</li>
<li>留一法交叉验证：k等于样本数N，这是k折交叉验证的极端情况，它能最无偏地估计性能，但计算成本极高，通常只用于极小型数据集。</li>
</ul>
<h2 data-id="heading-4">五、交叉验证在模型选择中的作用</h2>
<p>交叉验证本身是一个评估方法，但其威力在模型比较和超参数优化中得以真正体现。</p>
<h3 data-id="heading-5">1. 模型选择</h3>
<p>假设我们需要在逻辑回归、支持向量机和随机森林中选择一个最佳模型。我们不能直接在测试集上测试并选择最好的，因为这会导致信息泄露，使测试集失去其最终评估的意义。</p>
<p>**正确做法：**对每个候选模型，独立进行一次k折交叉验证，得到各自的平均性能得分，然后选择平均得分最高的模型，这个过程完全在原始训练集内完成，没有动用测试集。</p>
<h3 data-id="heading-6">2. 超参数调优</h3>
<p>超参数不是从数据中学到的，需要手动设定，寻找最佳超参数组合的过程就是调参，超参数详细内容可参考《<a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fminhuan%2Farticle%2Fdetails%2F153531971%3Fspm%3D1001.2014.3001.5502" title="https://blog.csdn.net/minhuan/article/details/153531971?spm=1001.2014.3001.5502" target="_blank" ref="nofollow noopener noreferrer">六十七、超参数如何影响大模型？通俗讲解原理、作用与实战示例</a>》。</p>
<ul>
<li>网格搜索交叉验证：
<ul>
<li>为每个超参数定义一个候选值列表。</li>
<li>这些候选值会组成一个“网格”，每个网格点是一组特定的超参数组合。</li>
<li>对网格中的每一组超参数组合，执行一次完整的k折交叉验证，计算其平均性能。</li>
<li>最终，选择平均性能最高的那组超参数作为最优解。</li>
</ul>
</li>
<li>随机搜索交叉验证：
<ul>
<li>与网格搜索不同，它不在一个定义好的网格上搜索，而是从一个指定的概率分布中随机采样一定数量的超参数组合。</li>
<li>对每个随机采样的组合执行k折交叉验证。</li>
<li>实践证明，随机搜索通常比网格搜索更高效，能以更少的尝试次数找到优秀的超参数。</li>
</ul>
</li>
</ul>
<p>通过交叉验证选出的最佳模型或最佳参数，其性能是那个平均性能。在完成所有模型选择和调参后，我们通常会用这组最佳参数在整个原始训练集上重新训练一个最终模型，然后用从未参与过任何过程的测试集来报告其最终的、无偏的性能。</p>
<h2 data-id="heading-7">六、 使用交叉验证评估分类模型</h2>
<p>下面我们演示一个基础示例，使用Scikit-learn库实现k折交叉验证。用交叉验证科学地判断一个模型的好坏，并把它调整到最佳状态。</p>
<h3 data-id="heading-8">1. 执行流程</h3>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/50fa4f227610439988fb505545b0bc2a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5b285bK46Iqx5byA5LqG5ZCX:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768014881&amp;x-signature=dXt3bV%2Fp4UZVJ1BzxIzBmNNjbz4%3D" alt="" loading="lazy"/>​</p>
<h3 data-id="heading-9">2. 流程概述</h3>
<ul>
<li>核心评估环节
<ul>
<li>K折交叉验证：通过数据轮换使用，获得稳健的性能评估</li>
<li>模型比较与选择：基于交叉验证结果客观选择最佳模型</li>
<li>超参数调优：使用交叉验证寻找最优参数组合</li>
</ul>
</li>
<li>诊断与分析环节
<ul>
<li>学习曲线分析：诊断模型是否过拟合或欠拟合</li>
<li>最终模型评估：在独立测试集上全面检验模型表现</li>
</ul>
</li>
</ul>
<h3 data-id="heading-10">3. 示例分解</h3>
<h4 data-id="heading-11">3.1 准备环境和数据可视化</h4>
<p>示例采用的是scikit-learn库的鸢尾花数据集，数据集包含150个样本，每个样本有4个特征和1个标签，在前期我们讲决策树时我们专门讲解过，这里简单概述一下，需要深入了解请参考《<a href="https://juejin.cn/post/7576861477267374099" title="https://juejin.cn/post/7576861477267374099" target="_blank">三十五、决策树的核心机制（一）：刨根问底鸢尾花分类中的参数推理计算</a>》。</p>
<p><strong>数据集合包含三种鸢尾花：</strong></p>
<ul>
<li>**Iris Setosa：**山鸢尾，最容易识别，花瓣短而宽，花萼较大。</li>
<li>**Iris Versicolor：**变色鸢尾，介于另外两种之间，颜色多变。</li>
<li>**Iris Virginica：**维吉尼亚鸢尾，最大最壮观，花瓣和花萼尺寸都最大。</li>
</ul>
<p><strong>4个特征（预测依据）：</strong></p>
<ul>
<li>sepal length (cm) - 花萼长度</li>
<li>sepal width (cm) - 花萼宽度</li>
<li>petal length (cm) - 花瓣长度</li>
<li>petal width (cm) - 花瓣宽度</li>
</ul>
<p><strong>1个标签（预测目标）：</strong></p>
<ul>
<li>species - 品种（0: Setosa, 1: Versicolor, 2: Virginica）</li>
</ul>
<p><strong>数据集的构成：</strong></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8a0173b1b7634622b8b960c2e84e06da~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5b285bK46Iqx5byA5LqG5ZCX:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768014881&amp;x-signature=tDqWcAB8%2FdgV0J9M6U5i1nw8idI%3D" alt="" loading="lazy"/></p>
<p>整个数据集就是一个大表格，有150行（代表150朵不同的花）和5列。</p>
<p>品种 (标签)  花萼长度   花萼宽度   花瓣长度   花瓣宽度<br/>
Iris-setosa          5.1       3.5            1.4          0.2<br/>
Iris-versicolor     7.0       3.2            4.7          1.4<br/>
Iris-virginica       6.3       3.3            6.0          2.5</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt
<span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> sns
<span class="hljs-keyword">from</span> sklearn.datasets <span class="hljs-keyword">import</span> load_iris
<span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> cross_val_score, KFold, train_test_split, GridSearchCV
<span class="hljs-keyword">from</span> sklearn.ensemble <span class="hljs-keyword">import</span> RandomForestClassifier
<span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> LogisticRegression
<span class="hljs-keyword">from</span> sklearn.svm <span class="hljs-keyword">import</span> SVC
<span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> classification_report, confusion_matrix
<span class="hljs-keyword">import</span> warnings
warnings.filterwarnings(<span class="hljs-string">'ignore'</span>)

<span class="hljs-comment"># 设置中文字体和图形样式</span>
plt.rcParams[<span class="hljs-string">'font.sans-serif'</span>] = [<span class="hljs-string">'SimHei'</span>, <span class="hljs-string">'DejaVu Sans'</span>]
plt.rcParams[<span class="hljs-string">'axes.unicode_minus'</span>] = <span class="hljs-literal">False</span>
sns.set_style(<span class="hljs-string">"whitegrid"</span>)

<span class="hljs-comment"># 加载数据</span>
iris = load_iris()
X = iris.data
y = iris.target
feature_names = iris.feature_names
target_names = iris.target_names

<span class="hljs-built_in">print</span>(<span class="hljs-string">"数据集探索"</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"数据集形状: <span class="hljs-subst">{X.shape}</span>"</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"特征: <span class="hljs-subst">{feature_names}</span>"</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"类别: <span class="hljs-subst">{target_names}</span>"</span>)
</code></pre>
<p><strong>输出结果：</strong></p>
<blockquote>
<p>数据集探索<br/>
数据集形状: (150, 4)<br/>
特征: ['sepal length (cm)', 'sepal width (cm)', 'petal length (cm)', 'petal width (cm)']<br/>
类别: ['setosa' 'versicolor' 'virginica']</p>
</blockquote>
<h4 data-id="heading-12">3.2 数据分布可视化</h4>
<p>在建模之前，先了解我们要处理的数据，通过绘制特征的分布直方图，判断数据质量、特征区分度以及不同类别的分离情况，为后续的模型选择提供初步依据。</p>
<pre><code class="hljs language-scss" lang="scss"># 创建数据分布可视化
def <span class="hljs-built_in">plot_data_distribution</span>(X, y, feature_names, target_names):
    fig, axes = plt.<span class="hljs-built_in">subplots</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, figsize=(<span class="hljs-number">15</span>, <span class="hljs-number">10</span>))
    axes = axes.<span class="hljs-built_in">ravel</span>()
    
    # 特征分布
    for i in <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):
        for class_id in <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):
            axes[i].<span class="hljs-built_in">hist</span>(X[y == class_id, i], alpha=<span class="hljs-number">0.7</span>, label=target_names[class_id])
        axes[i].<span class="hljs-built_in">set_title</span>(f<span class="hljs-string">'{feature_names[i]} 分布'</span>)
        axes[i].<span class="hljs-built_in">set_xlabel</span>(<span class="hljs-string">'值'</span>)
        axes[i].<span class="hljs-built_in">set_ylabel</span>(<span class="hljs-string">'频数'</span>)
        axes[i].<span class="hljs-built_in">legend</span>()
    
    plt.<span class="hljs-built_in">tight_layout</span>()
    plt.<span class="hljs-built_in">show</span>()

<span class="hljs-built_in">plot_data_distribution</span>(X, y, feature_names, target_names)
</code></pre>
<p><strong>输出结果：</strong></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/73ff3100f5ab492c965103114b4a56a1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5b285bK46Iqx5byA5LqG5ZCX:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768014881&amp;x-signature=Rx7EQcb%2BNbDcxaEOesZiLVNr8K4%3D" alt="" loading="lazy"/></p>
<p><strong>图示内容：</strong></p>
<ul>
<li>显示4个特征（花萼长度、花萼宽度、花瓣长度、花瓣宽度）在3个类别间的分布直方图</li>
<li>每个子图展示一个特征，不同类别用不同颜色区分</li>
</ul>
<h4 data-id="heading-13">3.3 k折交叉验证过程可视化</h4>
<p>直观演示交叉验证的核心原理，通过图表清晰地展示每一折中，哪些样本用于训练（蓝色），哪些用于验证（红色），并实时显示该折的验证得分，最后使用柱状图汇总对比各折的准确率，使结果一目了然，这可以让我们彻底理解轮“换考试”和“平均分”的概念。</p>
<pre><code class="hljs language-ini" lang="ini">def visualize_kfold_process(X, y, <span class="hljs-attr">k</span>=<span class="hljs-number">5</span>):
    """可视化k折交叉验证的数据分割过程"""
    <span class="hljs-attr">kf</span> = KFold(n_splits=k, shuffle=<span class="hljs-literal">True</span>, random_state=<span class="hljs-number">42</span>)
    
    fig, <span class="hljs-attr">axes</span> = plt.subplots(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, figsize=(<span class="hljs-number">15</span>, <span class="hljs-number">10</span>))
    <span class="hljs-attr">axes</span> = axes.ravel()
    
    <span class="hljs-attr">fold_scores</span> = []
    
    for fold, (train_idx, val_idx) in enumerate(kf.split(X)):
        if fold &lt; 6:  <span class="hljs-comment"># 只显示前6个图</span>
            <span class="hljs-attr">ax</span> = axes[fold]
            
            <span class="hljs-comment"># 创建分割可视化</span>
            <span class="hljs-attr">split_diagram</span> = np.zeros(len(X))
            split_diagram<span class="hljs-section">[train_idx]</span> = 1  <span class="hljs-comment"># 训练集</span>
            split_diagram<span class="hljs-section">[val_idx]</span> = 2    <span class="hljs-comment"># 验证集</span>
            
            <span class="hljs-comment"># 绘制分割图</span>
            <span class="hljs-attr">colors</span> = [<span class="hljs-string">'lightgray'</span>, <span class="hljs-string">'blue'</span>, <span class="hljs-string">'red'</span>]
            <span class="hljs-attr">labels</span> = [<span class="hljs-string">'未使用'</span>, <span class="hljs-string">'训练集'</span>, <span class="hljs-string">'验证集'</span>]
            
            for i, color in enumerate(colors):
                ax.bar(range(len(split_diagram)), 
                      <span class="hljs-section">[1 if x == i else 0 for x in split_diagram]</span>,
                      <span class="hljs-attr">color</span>=color, label=labels[i])
            
            ax.set_title(f'第 {fold+1} 折数据分割\n训练集: {len(train_idx)}样本, 验证集: {len(val_idx)}样本')
            ax.set_xlabel('样本索引')
            ax.set_ylabel('数据用途')
            ax.legend()
            
            <span class="hljs-comment"># 训练模型并计算分数</span>
            <span class="hljs-attr">model</span> = RandomForestClassifier(random_state=<span class="hljs-number">42</span>)
            model.fit(X<span class="hljs-section">[train_idx]</span>, y<span class="hljs-section">[train_idx]</span>)
            <span class="hljs-attr">score</span> = model.score(X[val_idx], y[val_idx])
            fold_scores.append(score)
            
            <span class="hljs-comment"># 在图中添加准确率</span>
            ax.text(0.5, 0.9, f'准确率: {score:.3f}', 
                   <span class="hljs-attr">transform</span>=ax.transAxes, ha=<span class="hljs-string">'center'</span>, 
                   <span class="hljs-attr">bbox</span>=dict(boxstyle=<span class="hljs-string">"round,pad=0.3"</span>, facecolor=<span class="hljs-string">"yellow"</span>, alpha=<span class="hljs-number">0.7</span>))
    
    <span class="hljs-comment"># 在右下角子图绘制各折准确率条形图，并隐藏其他多余子图</span>
    <span class="hljs-attr">summary_ax_index</span> = len(axes) - <span class="hljs-number">1</span>  <span class="hljs-comment"># 右下角子图索引（2x3 网格中的最后一个）</span>
    for i in range(len(axes)):
        if i &gt;= k and i != summary_ax_index:
            axes<span class="hljs-section">[i]</span>.set_visible(False)
    
    <span class="hljs-comment"># 绘制各折准确率条形图</span>
    <span class="hljs-attr">ax_summary</span> = axes[summary_ax_index]
    ax_summary.set_visible(True)
    <span class="hljs-attr">bars</span> = ax_summary.bar([f<span class="hljs-string">'折{i+1}'</span> for i in range(len(fold_scores))], fold_scores, color=<span class="hljs-string">'teal'</span>, alpha=<span class="hljs-number">0.8</span>)
    ax_summary.set_title('各折准确率')
    ax_summary.set_ylabel('准确率')
    ax_summary.set_ylim(0, 1.05)
    for bar, score in zip(bars, fold_scores):
        <span class="hljs-attr">height</span> = bar.get_height()
        ax_summary.text(bar.get_x() + bar.get_width()/2., height + 0.02, f'{score:.3f}', <span class="hljs-attr">ha</span>=<span class="hljs-string">'center'</span>, va=<span class="hljs-string">'bottom'</span>)
    
    plt.tight_layout()
    plt.show()
    
    return fold_scores

print(" k折交叉验证过程可视化")
<span class="hljs-attr">fold_scores</span> = visualize_kfold_process(X, y, k=<span class="hljs-number">5</span>)
</code></pre>
<p><strong>输出结果：</strong></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/795da5c422d543eea157e25e9b523687~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5b285bK46Iqx5byA5LqG5ZCX:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768014881&amp;x-signature=CGZJF4hDYmwq1t%2BQshEP%2B0jYMqc%3D" alt="" loading="lazy"/></p>
<p><strong>图示内容：</strong></p>
<ul>
<li>展示5折交叉验证中每折的数据分割情况</li>
<li>训练集（蓝色）、验证集（红色）的样本分配</li>
<li>每折的验证准确率显示</li>
<li>各折的准确率综合对比显示</li>
</ul>
<p><strong>k折交叉验证公式</strong>：</p>
<blockquote>
<p>设数据集 D = {(x₁,y₁), (x₂,y₂), ..., (x_N,y_N)}<br/>
将 D 分割为 k 个互斥子集：D₁, D₂, ..., D_k</p>
<p>对于每个折 i = 1, 2, ..., k：<br/>
训练集：D_train⁽ⁱ⁾ = D \ D_i<br/>
验证集：D_val⁽ⁱ⁾ = D_i</p>
<p>模型训练：f⁽ⁱ⁾ = train(D_train⁽ⁱ⁾)<br/>
性能评估：score⁽ⁱ⁾ = evaluate(f⁽ⁱ⁾, D_val⁽ⁱ⁾)</p>
<p>最终性能：CV_score = (1/k) * Σ_{i=1}^k score⁽ⁱ⁾<br/>
性能标准差：CV_std = √[ (1/(k-1)) * Σ_{i=1}^k (score⁽ⁱ⁾ - CV_score)² ]</p>
</blockquote>
<p><strong>体现的价值：</strong></p>
<ul>
<li>数据利用最大化：每个样本都参与训练和验证</li>
<li>性能估计无偏性：减少单次分割的随机性影响</li>
<li>模型稳定性评估：通过标准差衡量模型鲁棒性</li>
</ul>
<h4 data-id="heading-14">3.4 模型比较可视化</h4>
<p>科学地回答“哪个模型更好？”，通过柱状图（带误差棒）和箱线图，同时比较多个模型（如随机森林、逻辑回归、SVM）的平均性能和稳定性，这不仅看谁的平均分高，还要看谁的表现更稳定（方差小），从而做出稳健的选择。</p>
<pre><code class="hljs language-ini" lang="ini">def compare_models_cv(X, y, models, <span class="hljs-attr">cv</span>=<span class="hljs-number">5</span>):
    """比较不同模型的交叉验证性能并可视化"""
    <span class="hljs-attr">model_names</span> = []
    <span class="hljs-attr">mean_scores</span> = []
    <span class="hljs-attr">std_scores</span> = []
    <span class="hljs-attr">all_scores</span> = []
    
    print(" 模型性能比较")
    
    for name, model in models.items():
        <span class="hljs-comment"># 执行交叉验证</span>
        <span class="hljs-attr">cv_scores</span> = cross_val_score(model, X, y, cv=cv, scoring=<span class="hljs-string">'accuracy'</span>)
        
        model_names.append(name)
        mean_scores.append(cv_scores.mean())
        std_scores.append(cv_scores.std())
        all_scores.append(cv_scores)
        
        print(f"{name:15} | 平均准确率: {cv_scores.mean():.4f} (±{cv_scores.std():.4f})")
    
    <span class="hljs-comment"># 创建性能比较图</span>
    fig, (ax1, ax2) = plt.subplots(1, 2, <span class="hljs-attr">figsize</span>=(<span class="hljs-number">15</span>, <span class="hljs-number">6</span>))
    
    <span class="hljs-comment"># 柱状图比较平均性能</span>
    <span class="hljs-attr">bars</span> = ax1.bar(model_names, mean_scores, yerr=std_scores, 
                   <span class="hljs-attr">capsize</span>=<span class="hljs-number">5</span>, alpha=<span class="hljs-number">0.7</span>, color=[<span class="hljs-string">'skyblue'</span>, <span class="hljs-string">'lightgreen'</span>, <span class="hljs-string">'lightcoral'</span>])
    ax1.set_title('模型交叉验证性能比较')
    ax1.set_ylabel('平均准确率')
    ax1.set_ylim(0.8, 1.0)
    
    <span class="hljs-comment"># 在柱子上添加数值</span>
    for bar, score in zip(bars, mean_scores):
        <span class="hljs-attr">height</span> = bar.get_height()
        ax1.text(bar.get_x() + bar.get_width()/2., height + 0.01,
                f'{score:.4f}', <span class="hljs-attr">ha</span>=<span class="hljs-string">'center'</span>, va=<span class="hljs-string">'bottom'</span>)
    
    <span class="hljs-comment"># 箱线图显示分布</span>
    ax2.boxplot(all_scores, <span class="hljs-attr">labels</span>=model_names)
    ax2.set_title('各折准确率分布')
    ax2.set_ylabel('准确率')
    
    plt.tight_layout()
    plt.show()
    
    <span class="hljs-comment"># 选择最佳模型</span>
    <span class="hljs-attr">best_idx</span> = np.argmax(mean_scores)
    <span class="hljs-attr">best_model_name</span> = model_names[best_idx]
    <span class="hljs-attr">best_model</span> = models[best_model_name]
    
    print(f"\n 最佳模型: {best_model_name} (准确率: {mean_scores<span class="hljs-section">[best_idx]</span>:.4f})")
    
    return best_model_name, best_model, all_scores

<span class="hljs-comment"># 定义要比较的模型</span>
<span class="hljs-attr">models</span> = {
    '随机森林': RandomForestClassifier(<span class="hljs-attr">random_state</span>=<span class="hljs-number">42</span>),
    '逻辑回归': LogisticRegression(<span class="hljs-attr">random_state</span>=<span class="hljs-number">42</span>, max_iter=<span class="hljs-number">1000</span>),
    '支持向量机': SVC(<span class="hljs-attr">random_state</span>=<span class="hljs-number">42</span>)
}

best_model_name, best_model, <span class="hljs-attr">all_scores</span> = compare_models_cv(X, y, models)
</code></pre>
<p><strong>输出结果：</strong></p>
<blockquote>
<p>模型性能比较<br/>
随机森林 | 平均准确率: 0.9667 (±0.0211)<br/>
逻辑回归 | 平均准确率: 0.9733 (±0.0249)<br/>
支持向量机 | 平均准确率: 0.9667 (±0.0211)</p>
<p>最佳模型: 逻辑回归 (准确率: 0.9733)</p>
</blockquote>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1f19ef9c311144ffbd78aba4b17432bd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5b285bK46Iqx5byA5LqG5ZCX:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768014881&amp;x-signature=j8AyzU8VUMJnpbnPZOqmF0JArRs%3D" alt="" loading="lazy"/></p>
<p><strong>图示内容：</strong></p>
<ul>
<li>左侧柱状图：各模型平均准确率及误差棒（标准差）</li>
<li>右侧箱线图：各模型5折交叉验证得分的分布</li>
</ul>
<p><strong>模型性能比较的统计检验</strong>：</p>
<blockquote>
<p>设两个模型 A 和 B 的k折得分分别为：<br/>
scores_A = [s_A¹, s_A², ..., s_Aᵏ]<br/>
scores_B = [s_B¹, s_B², ..., s_Bᵏ]</p>
<p>配对t检验统计量：<br/>
t = (mean(scores_A) - mean(scores_B)) / √[ (var(scores_A - scores_B) / k) ]</p>
<p>其中：<br/>
var(scores_A - scores_B) = (1/(k-1)) * Σ_{i=1}^k [(s_Aⁱ - s_Bⁱ) - mean(scores_A - scores_B)]²</p>
</blockquote>
<p><strong>体现的价值：</strong></p>
<ul>
<li>模型选择依据：基于统计性能选择最佳模型</li>
<li>性能稳定性分析：通过分布了解模型鲁棒性</li>
<li>统计显著性判断：确定性能差异是否显著</li>
</ul>
<h4 data-id="heading-15">3.5 学习曲线可视化</h4>
<p>诊断模型状态的关键工具，通过绘制模型随训练数据量增加时，训练得分和验证得分的变化曲线，可以清晰地判断模型是处于过拟合（训练得分远高于验证得分）还是欠拟合（两者都低）状态，并指导是否需要收集更多数据。</p>
<pre><code class="hljs language-scss" lang="scss">def <span class="hljs-built_in">plot_learning_curve</span>(model, X, y, model_name):
    <span class="hljs-string">""</span><span class="hljs-string">"绘制学习曲线来观察模型表现"</span><span class="hljs-string">""</span>
    from sklearn.model_selection import learning_curve
    
    train_sizes, train_scores, test_scores = <span class="hljs-built_in">learning_curve</span>(
        model, X, y, cv=<span class="hljs-number">5</span>, n_jobs=-<span class="hljs-number">1</span>,
        train_sizes=np.<span class="hljs-built_in">linspace</span>(<span class="hljs-number">0.1</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">10</span>),
        scoring=<span class="hljs-string">'accuracy'</span>
    )
    
    train_scores_mean = np.<span class="hljs-built_in">mean</span>(train_scores, axis=<span class="hljs-number">1</span>)
    train_scores_std = np.<span class="hljs-built_in">std</span>(train_scores, axis=<span class="hljs-number">1</span>)
    test_scores_mean = np.<span class="hljs-built_in">mean</span>(test_scores, axis=<span class="hljs-number">1</span>)
    test_scores_std = np.<span class="hljs-built_in">std</span>(test_scores, axis=<span class="hljs-number">1</span>)
    
    plt.<span class="hljs-built_in">figure</span>(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">6</span>))
    plt.<span class="hljs-built_in">fill_between</span>(train_sizes, train_scores_mean - train_scores_std,
                     train_scores_mean + train_scores_std, alpha=<span class="hljs-number">0.1</span>, color=<span class="hljs-string">"r"</span>)
    plt.<span class="hljs-built_in">fill_between</span>(train_sizes, test_scores_mean - test_scores_std,
                     test_scores_mean + test_scores_std, alpha=<span class="hljs-number">0.1</span>, color=<span class="hljs-string">"g"</span>)
    plt.<span class="hljs-built_in">plot</span>(train_sizes, train_scores_mean, <span class="hljs-string">'o-'</span>, color=<span class="hljs-string">"r"</span>, label=<span class="hljs-string">"训练得分"</span>)
    plt.<span class="hljs-built_in">plot</span>(train_sizes, test_scores_mean, <span class="hljs-string">'o-'</span>, color=<span class="hljs-string">"g"</span>, label=<span class="hljs-string">"交叉验证得分"</span>)
    
    plt.<span class="hljs-built_in">title</span>(f<span class="hljs-string">'{model_name} 学习曲线'</span>)
    plt.<span class="hljs-built_in">xlabel</span>(<span class="hljs-string">'训练样本数'</span>)
    plt.<span class="hljs-built_in">ylabel</span>(<span class="hljs-string">'准确率'</span>)
    plt.<span class="hljs-built_in">legend</span>(loc=<span class="hljs-string">"best"</span>)
    plt.<span class="hljs-built_in">grid</span>(True)
    
    plt.<span class="hljs-built_in">show</span>()

<span class="hljs-built_in">print</span>(<span class="hljs-string">"\n 学习曲线分析"</span>)
for name, model in models.<span class="hljs-built_in">items</span>():
    <span class="hljs-built_in">plot_learning_curve</span>(model, X, y, name)
</code></pre>
<p><strong>输出结果：</strong></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/80f6aea81003426ba8ca8da76764f333~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5b285bK46Iqx5byA5LqG5ZCX:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768014881&amp;x-signature=L0VjWiZMR5FcoU3xP40TUhQBbAk%3D" alt="" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/58053809ac2c4148aa500cd0d36d7552~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5b285bK46Iqx5byA5LqG5ZCX:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768014881&amp;x-signature=m3%2F29nBlHZ0lZlSjgI6Au9y77mM%3D" alt="" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0748b93186fa4c50b3da9a979ccc29bc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5b285bK46Iqx5byA5LqG5ZCX:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768014881&amp;x-signature=Wk3nwN1qoOmzjuftvODEt%2FD2Ee4%3D" alt="" loading="lazy"/></p>
<p><strong>图示内容：</strong></p>
<ul>
<li>训练得分和验证得分随训练样本数量增加的变化</li>
<li>阴影区域表示得分的标准差范围</li>
</ul>
<p><strong>学习曲线理论</strong>：</p>
<blockquote>
<p>设训练集大小为 m，模型复杂度为 h<br/>
训练误差：J_train(m) = (1/m) * Σ_{i=1}^m L(f(x_i), y_i)<br/>
验证误差：J_val(m) = (1/k) * Σ_{j=1}^k L(f(x_j), y_j)</p>
<p>随着 m → ∞：<br/>
J_train(m) → 模型偏差 + 方差项<br/>
J_val(m) → 模型偏差 + 方差项 + 噪声项</p>
<p>其中偏差-方差分解：<br/>
E[(y - f(x))²] = Bias[f(x)]² + Var[f(x)] + σ²</p>
</blockquote>
<p><strong>体现的价值：</strong></p>
<ul>
<li>过拟合/欠拟合诊断：判断模型是否合适</li>
<li>数据量需求评估：确定需要多少训练数据</li>
<li>模型容量分析：观察模型的学习能力</li>
</ul>
<h4 data-id="heading-16">3.6 网格搜索调参可视化</h4>
<p>科学的调参方式，通过网格搜索交叉验证，系统性地遍历不同的参数组合，并用热力图等形式展示参数如何影响性能。这帮助我们找到真正的最佳参数组合，并理解参数之间的相互作用。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">visualize_grid_search</span>(<span class="hljs-params">X, y</span>):
    <span class="hljs-string">"""可视化网格搜索过程"""</span>
    <span class="hljs-comment"># 定义参数网格</span>
    param_grid = {
        <span class="hljs-string">'n_estimators'</span>: [<span class="hljs-number">50</span>, <span class="hljs-number">100</span>, <span class="hljs-number">200</span>],
        <span class="hljs-string">'max_depth'</span>: [<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-literal">None</span>],
        <span class="hljs-string">'min_samples_split'</span>: [<span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>]
    }
    
    rf = RandomForestClassifier(random_state=<span class="hljs-number">42</span>)
    grid_search = GridSearchCV(rf, param_grid, cv=<span class="hljs-number">5</span>, scoring=<span class="hljs-string">'accuracy'</span>, n_jobs=-<span class="hljs-number">1</span>)
    grid_search.fit(X, y)
    
    <span class="hljs-comment"># 可视化结果</span>
    results = pd.DataFrame(grid_search.cv_results_)
    
    <span class="hljs-comment"># 选择部分参数进行可视化</span>
    fig, axes = plt.subplots(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, figsize=(<span class="hljs-number">15</span>, <span class="hljs-number">10</span>))
    
    <span class="hljs-comment"># 1. n_estimators 的影响</span>
    param1_data = results[results[<span class="hljs-string">'param_max_depth'</span>].isna() &amp; results[<span class="hljs-string">'param_min_samples_split'</span>] == <span class="hljs-number">2</span>]
    axes[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>].plot(param1_data[<span class="hljs-string">'param_n_estimators'</span>], param1_data[<span class="hljs-string">'mean_test_score'</span>], <span class="hljs-string">'o-'</span>)
    axes[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>].set_title(<span class="hljs-string">'n_estimators 对性能的影响\n(max_depth=None, min_samples_split=2)'</span>)
    axes[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>].set_xlabel(<span class="hljs-string">'n_estimators'</span>)
    axes[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>].set_ylabel(<span class="hljs-string">'平均准确率'</span>)
    
    <span class="hljs-comment"># 2. max_depth 的影响</span>
    param2_data = results[results[<span class="hljs-string">'param_n_estimators'</span>] == <span class="hljs-number">100</span> &amp; results[<span class="hljs-string">'param_min_samples_split'</span>] == <span class="hljs-number">2</span>]
    axes[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>].plot([<span class="hljs-built_in">str</span>(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> param2_data[<span class="hljs-string">'param_max_depth'</span>]], param2_data[<span class="hljs-string">'mean_test_score'</span>], <span class="hljs-string">'o-'</span>)
    axes[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>].set_title(<span class="hljs-string">'max_depth 对性能的影响\n(n_estimators=100, min_samples_split=2)'</span>)
    axes[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>].set_xlabel(<span class="hljs-string">'max_depth'</span>)
    axes[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>].set_ylabel(<span class="hljs-string">'平均准确率'</span>)
    
    <span class="hljs-comment"># 3. 热力图：n_estimators vs max_depth</span>
    heatmap_data = results.pivot_table(
        values=<span class="hljs-string">'mean_test_score'</span>, 
        index=<span class="hljs-string">'param_n_estimators'</span>, 
        columns=<span class="hljs-string">'param_max_depth'</span>,
        aggfunc=<span class="hljs-string">'mean'</span>
    )
    sns.heatmap(heatmap_data, annot=<span class="hljs-literal">True</span>, fmt=<span class="hljs-string">'.3f'</span>, cmap=<span class="hljs-string">'YlOrRd'</span>, ax=axes[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>])
    axes[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>].set_title(<span class="hljs-string">'参数组合热力图\n(平均准确率)'</span>)
    
    <span class="hljs-comment"># 4. 最佳参数组合</span>
    best_params = grid_search.best_params_
    best_score = grid_search.best_score_
    
    axes[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>].text(<span class="hljs-number">0.1</span>, <span class="hljs-number">0.8</span>, <span class="hljs-string">f'最佳参数组合:'</span>, fontsize=<span class="hljs-number">14</span>, weight=<span class="hljs-string">'bold'</span>)
    axes[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>].text(<span class="hljs-number">0.1</span>, <span class="hljs-number">0.6</span>, <span class="hljs-string">f'n_estimators: <span class="hljs-subst">{best_params[<span class="hljs-string">"n_estimators"</span>]}</span>'</span>, fontsize=<span class="hljs-number">12</span>)
    axes[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>].text(<span class="hljs-number">0.1</span>, <span class="hljs-number">0.5</span>, <span class="hljs-string">f'max_depth: <span class="hljs-subst">{best_params[<span class="hljs-string">"max_depth"</span>]}</span>'</span>, fontsize=<span class="hljs-number">12</span>)
    axes[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>].text(<span class="hljs-number">0.1</span>, <span class="hljs-number">0.4</span>, <span class="hljs-string">f'min_samples_split: <span class="hljs-subst">{best_params[<span class="hljs-string">"min_samples_split"</span>]}</span>'</span>, fontsize=<span class="hljs-number">12</span>)
    axes[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>].text(<span class="hljs-number">0.1</span>, <span class="hljs-number">0.2</span>, <span class="hljs-string">f'最佳准确率: <span class="hljs-subst">{best_score:<span class="hljs-number">.4</span>f}</span>'</span>, fontsize=<span class="hljs-number">14</span>, weight=<span class="hljs-string">'bold'</span>, color=<span class="hljs-string">'red'</span>)
    axes[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>].set_xlim(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)
    axes[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>].set_ylim(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)
    axes[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>].set_title(<span class="hljs-string">'最佳参数结果'</span>, fontsize=<span class="hljs-number">14</span>)
    axes[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>].axis(<span class="hljs-string">'off'</span>)
    
    plt.tight_layout()
    plt.show()
    
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"\n 网格搜索最佳参数: <span class="hljs-subst">{grid_search.best_params_}</span>"</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"最佳交叉验证得分: <span class="hljs-subst">{grid_search.best_score_:<span class="hljs-number">.4</span>f}</span>"</span>)
    
    <span class="hljs-keyword">return</span> grid_search.best_estimator_

<span class="hljs-built_in">print</span>(<span class="hljs-string">"\n 网格搜索调参可视化"</span>)
best_tuned_model = visualize_grid_search(X, y)
</code></pre>
<p><strong>输出结果：</strong></p>
<blockquote>
<p>网格搜索调参可视化</p>
<p>网格搜索最佳参数: {'max_depth': 3, 'min_samples_split': 2, 'n_estimators': 50}<br/>
最佳交叉验证得分: 0.9667</p>
</blockquote>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/08032a01dbc64e30afbc786105c4ff47~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5b285bK46Iqx5byA5LqG5ZCX:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768014881&amp;x-signature=XrW6%2Be4Bq0tniHhpW9QTgeeOCAg%3D" alt="" loading="lazy"/></p>
<p><strong>图示内容：</strong></p>
<ul>
<li>不同超参数组合对模型性能的影响</li>
<li>参数热力图显示最佳组合</li>
<li>最佳参数结果总结</li>
</ul>
<p><strong>超参数优化目标</strong>：</p>
<blockquote>
<p>设超参数空间为 Θ，性能度量函数为 P<br/>
网格搜索目标：找到 θ* ∈ Θ 使得<br/>
θ* = argmax_{θ∈Θ} CV_score(θ)</p>
<p>其中：<br/>
CV_score(θ) = (1/k) * Σ_{i=1}^k P(f_θ⁽ⁱ⁾, D_val⁽ⁱ⁾)<br/>
f_θ⁽ⁱ⁾ 是在超参数 θ 下，在第 i 折训练集上训练的模型</p>
</blockquote>
<p><strong>体现的价值：</strong></p>
<ul>
<li>超参数敏感性分析：了解各参数对性能的影响</li>
<li>最优配置确定：找到最佳超参数组合</li>
<li>参数交互作用：观察参数间的相互影响</li>
</ul>
<h4 data-id="heading-17">3.7 最终模型评估可视化</h4>
<p>对最佳模型进行全面的毕业答辩，在独立的测试集上，通过混淆矩阵、特征重要性、分类报告等多种工具，从各个角度评估模型的最终表现，了解其错误类型和决策依据，确保其泛化能力。</p>
<pre><code class="hljs language-ini" lang="ini">def final_evaluation_visualization(model, X, y, model_name):
    """最终模型评估可视化"""
    <span class="hljs-comment"># 分割数据</span>
    X_train, X_test, y_train, <span class="hljs-attr">y_test</span> = train_test_split(
        X, y, <span class="hljs-attr">test_size</span>=<span class="hljs-number">0.2</span>, random_state=<span class="hljs-number">42</span>, stratify=y
    )
    
    <span class="hljs-comment"># 训练最终模型</span>
    model.fit(X_train, y_train)
    <span class="hljs-attr">y_pred</span> = model.predict(X_test)
    
    <span class="hljs-comment"># 创建评估图表</span>
    fig, <span class="hljs-attr">axes</span> = plt.subplots(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, figsize=(<span class="hljs-number">15</span>, <span class="hljs-number">12</span>))
    
    <span class="hljs-comment"># 1. 混淆矩阵</span>
    <span class="hljs-attr">cm</span> = confusion_matrix(y_test, y_pred)
    sns.heatmap(cm, <span class="hljs-attr">annot</span>=<span class="hljs-literal">True</span>, fmt=<span class="hljs-string">'d'</span>, cmap=<span class="hljs-string">'Blues'</span>, 
                <span class="hljs-attr">xticklabels</span>=target_names, yticklabels=target_names, ax=axes[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>])
    axes<span class="hljs-section">[0,0]</span>.set_title('混淆矩阵')
    axes<span class="hljs-section">[0,0]</span>.set_xlabel('预测标签')
    axes<span class="hljs-section">[0,0]</span>.set_ylabel('真实标签')
    
    <span class="hljs-comment"># 2. 特征重要性（如果是树模型）</span>
    if hasattr(model, 'feature_importances_'):
        <span class="hljs-attr">importances</span> = model.feature_importances_
        <span class="hljs-attr">indices</span> = np.argsort(importances)[::-<span class="hljs-number">1</span>]
        
        axes<span class="hljs-section">[0,1]</span>.bar(range(len(importances)), importances<span class="hljs-section">[indices]</span>)
        axes<span class="hljs-section">[0,1]</span>.set_title('特征重要性')
        axes<span class="hljs-section">[0,1]</span>.set_xlabel('特征')
        axes<span class="hljs-section">[0,1]</span>.set_ylabel('重要性')
        axes<span class="hljs-section">[0,1]</span>.set_xticks(range(len(importances)))
        axes<span class="hljs-section">[0,1]</span>.set_xticklabels(<span class="hljs-section">[feature_names[i]</span> for i in indices], <span class="hljs-attr">rotation</span>=<span class="hljs-number">45</span>)
    
    <span class="hljs-comment"># 3. 测试集性能</span>
    <span class="hljs-attr">test_score</span> = model.score(X_test, y_test)
    <span class="hljs-attr">train_score</span> = model.score(X_train, y_train)
    
    <span class="hljs-attr">scores</span> = [train_score, test_score]
    <span class="hljs-attr">labels</span> = [<span class="hljs-string">'训练集'</span>, <span class="hljs-string">'测试集'</span>]
    
    <span class="hljs-attr">bars</span> = axes[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>].bar(labels, scores, color=[<span class="hljs-string">'lightblue'</span>, <span class="hljs-string">'lightcoral'</span>])
    axes<span class="hljs-section">[1,0]</span>.set_title('训练集 vs 测试集 性能')
    axes<span class="hljs-section">[1,0]</span>.set_ylabel('准确率')
    axes<span class="hljs-section">[1,0]</span>.set_ylim(0, 1.1)
    
    <span class="hljs-comment"># 在柱子上添加数值</span>
    for bar, score in zip(bars, scores):
        <span class="hljs-attr">height</span> = bar.get_height()
        axes<span class="hljs-section">[1,0]</span>.text(bar.get_x() + bar.get_width()/2., height + 0.02,
                      f'{score:.4f}', <span class="hljs-attr">ha</span>=<span class="hljs-string">'center'</span>, va=<span class="hljs-string">'bottom'</span>)
    
    <span class="hljs-comment"># 4. 分类报告摘要</span>
    <span class="hljs-attr">report</span> = classification_report(y_test, y_pred, target_names=target_names, output_dict=<span class="hljs-literal">True</span>)
    <span class="hljs-attr">report_df</span> = pd.DataFrame(report).transpose()
    
    <span class="hljs-comment"># 简化显示主要指标</span>
    axes<span class="hljs-section">[1,1]</span>.axis('off')
    axes<span class="hljs-section">[1,1]</span>.text(0.1, 0.9, '分类报告摘要', <span class="hljs-attr">fontsize</span>=<span class="hljs-number">16</span>, weight=<span class="hljs-string">'bold'</span>)
    
    <span class="hljs-attr">y_pos</span> = <span class="hljs-number">0.7</span>
    for class_name in target_names:
        <span class="hljs-attr">prec</span> = report[class_name][<span class="hljs-string">'precision'</span>]
        <span class="hljs-attr">rec</span> = report[class_name][<span class="hljs-string">'recall'</span>]
        <span class="hljs-attr">f1</span> = report[class_name][<span class="hljs-string">'f1-score'</span>]
        axes<span class="hljs-section">[1,1]</span>.text(0.1, y_pos, f'{class_name}:', <span class="hljs-attr">fontsize</span>=<span class="hljs-number">12</span>, weight=<span class="hljs-string">'bold'</span>)
        axes<span class="hljs-section">[1,1]</span>.text(0.4, y_pos, f'精确率: {prec:.3f}, 召回率: {rec:.3f}, F1: {f1:.3f}', <span class="hljs-attr">fontsize</span>=<span class="hljs-number">10</span>)
        y_pos <span class="hljs-attr">-</span>= <span class="hljs-number">0.1</span>
    
    axes<span class="hljs-section">[1,1]</span>.text(0.1, y_pos-0.1, f'总体准确率: {test_score:.4f}', 
                   <span class="hljs-attr">fontsize</span>=<span class="hljs-number">14</span>, weight=<span class="hljs-string">'bold'</span>, color=<span class="hljs-string">'red'</span>)
    
    plt.tight_layout()
    plt.show()
    
    print(f"\n 最终模型评估完成!")
    print(f"测试集准确率: {test_score:.4f}")
    
    return test_score

print("\n 最终模型评估可视化")
<span class="hljs-attr">final_score</span> = final_evaluation_visualization(best_tuned_model, X, y, best_model_name)
</code></pre>
<p><strong>输出结果：</strong></p>
<blockquote>
<p>最终模型评估可视化</p>
<p>最终模型评估完成!<br/>
测试集准确率: 0.9667</p>
</blockquote>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c05b1abd716a4d66853f972a20929ad3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5b285bK46Iqx5byA5LqG5ZCX:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768014881&amp;x-signature=PKfslZ%2FHnGwp5CjfLbDqbLP8FIs%3D" alt="" loading="lazy"/></p>
<p><strong>图示内容：</strong></p>
<ul>
<li>混淆矩阵：真实vs预测类别分布</li>
<li>特征重要性：各特征对预测的贡献度</li>
<li>训练vs测试性能比较</li>
<li>详细分类报告</li>
</ul>
<p><strong>模型评估指标</strong>：</p>
<blockquote>
<p>对于多分类问题，每个类别 k 的指标：<br/>
精确率：Precision_k = TP_k / (TP_k + FP_k)<br/>
召回率：Recall_k = TP_k / (TP_k + FN_k)<br/>
F1分数：F1_k = 2 * (Precision_k * Recall_k) / (Precision_k + Recall_k)</p>
<p>准确率：Accuracy = (Σ_k TP_k) / N</p>
<p>其中：<br/>
TP_k = 真阳性（类别k被正确预测）<br/>
FP_k = 假阳性（其他类别被预测为k）<br/>
FN_k = 假阴性（类别k被预测为其他）</p>
</blockquote>
<p><strong>体现的价值：</strong></p>
<ul>
<li>全面性能评估：多角度评估模型表现</li>
<li>错误模式分析：通过混淆矩阵识别常见错误</li>
<li>特征贡献度：理解模型决策依据</li>
<li>泛化能力验证：比较训练和测试性能</li>
</ul>
<h4 data-id="heading-18">3.8 完整流程总结图</h4>
<p>梳理全局，形成方法论，通过一张总结图，将整个流程串联起来，强调每一步的目的和衔接，让我们建立起一个完整、规范的机器学习项目开发观念。</p>
<pre><code class="hljs language-ini" lang="ini">def create_workflow_summary():
    """创建完整的工作流程总结图"""
    fig, <span class="hljs-attr">ax</span> = plt.subplots(figsize=(<span class="hljs-number">12</span>, <span class="hljs-number">8</span>))
    
    <span class="hljs-comment"># 定义流程步骤</span>
    <span class="hljs-attr">steps</span> = [
        (<span class="hljs-string">"1. 数据准备"</span>, <span class="hljs-string">"加载和探索数据\n数据可视化"</span>),
        (<span class="hljs-string">"2. 交叉验证"</span>, <span class="hljs-string">"k折数据分割\n模型性能评估"</span>),
        (<span class="hljs-string">"3. 模型比较"</span>, <span class="hljs-string">"多个模型对比\n选择最佳模型"</span>),
        (<span class="hljs-string">"4. 超参数调优"</span>, <span class="hljs-string">"网格搜索\n寻找最优参数"</span>),
        (<span class="hljs-string">"5. 最终评估"</span>, <span class="hljs-string">"测试集验证\n性能可视化"</span>),
        (<span class="hljs-string">"6. 模型部署"</span>, <span class="hljs-string">"训练最终模型\n投入实际使用"</span>)
    ]
    
    <span class="hljs-comment"># 绘制流程图</span>
    <span class="hljs-attr">y_positions</span> = [<span class="hljs-number">7</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>]
    
    for i, (title, description) in enumerate(steps):
        <span class="hljs-comment"># 绘制方框</span>
        <span class="hljs-attr">box</span> = plt.Rectangle((<span class="hljs-number">0.1</span>, y_positions[i]), <span class="hljs-number">0.8</span>, <span class="hljs-number">0.8</span>, 
                           <span class="hljs-attr">fill</span>=<span class="hljs-literal">True</span>, color=<span class="hljs-string">'lightblue'</span>, alpha=<span class="hljs-number">0.7</span>, 
                           <span class="hljs-attr">edgecolor</span>=<span class="hljs-string">'black'</span>, linewidth=<span class="hljs-number">2</span>)
        ax.add_patch(box)
        
        <span class="hljs-comment"># 添加文本</span>
        ax.text(0.5, y_positions<span class="hljs-section">[i]</span> + 0.5, title, 
               <span class="hljs-attr">ha</span>=<span class="hljs-string">'center'</span>, va=<span class="hljs-string">'center'</span>, fontsize=<span class="hljs-number">14</span>, weight=<span class="hljs-string">'bold'</span>)
        ax.text(0.5, y_positions<span class="hljs-section">[i]</span> + 0.3, description, 
               <span class="hljs-attr">ha</span>=<span class="hljs-string">'center'</span>, va=<span class="hljs-string">'center'</span>, fontsize=<span class="hljs-number">10</span>)
        
        <span class="hljs-comment"># 绘制连接箭头</span>
        if i &lt; len(steps) - 1:
            ax.arrow(0.5, y_positions<span class="hljs-section">[i]</span> + 0.1, 0, -0.3, 
                    <span class="hljs-attr">head_width</span>=<span class="hljs-number">0.03</span>, head_length=<span class="hljs-number">0.1</span>, fc=<span class="hljs-string">'black'</span>, ec=<span class="hljs-string">'black'</span>)
    
    ax.set_xlim(0, 1)
    ax.set_ylim(1, 8)
    ax.set_title('机器学习模型开发完整工作流程', <span class="hljs-attr">fontsize</span>=<span class="hljs-number">16</span>, weight=<span class="hljs-string">'bold'</span>, pad=<span class="hljs-number">20</span>)
    ax.axis('off')
    
    <span class="hljs-comment"># 添加交叉验证重点说明</span>
    ax.text(0.5, 0.8, ' 交叉验证是整个流程的核心环节！', 
           <span class="hljs-attr">ha</span>=<span class="hljs-string">'center'</span>, va=<span class="hljs-string">'center'</span>, fontsize=<span class="hljs-number">12</span>, weight=<span class="hljs-string">'bold'</span>,
           <span class="hljs-attr">bbox</span>=dict(boxstyle=<span class="hljs-string">"round,pad=0.3"</span>, facecolor=<span class="hljs-string">"yellow"</span>, alpha=<span class="hljs-number">0.7</span>))
    
    plt.tight_layout()
    plt.show()

print("\n 完整工作流程总结")
create_workflow_summary()
</code></pre>
<p><strong>输出结果：</strong></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/13521af15a1d4435aafa5f2688f4212f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5b285bK46Iqx5byA5LqG5ZCX:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768014881&amp;x-signature=RXVo1LNLsmJjbFXkf1qrtLZ%2FpuM%3D" alt="" loading="lazy"/></p>
<p><strong>完整工作流的数学框架：</strong></p>
<blockquote>
<p>完整流程可形式化为：<br/>
1. 数据准备：D = {(x_i, y_i)} ∼ P_data<br/>
2. 模型选择：M = {m₁, m₂, ..., m_p}<br/>
3. 交叉验证：m* = argmax_{m∈M} CV_score(m)<br/>
4. 超参数调优：θ* = argmax_{θ} CV_score(m*_θ)<br/>
5. 最终评估：Performance = P(m*_θ*, D_test)<br/>
6. 部署：f_final = train(m*_θ*, D_all)</p>
</blockquote>
<p>这些可视化图表共同构成了一个完整的模型评估和选择框架，每个图表都基于严格的数学原理，提供了从数据理解到模型部署的全方位理解。</p>
<h2 data-id="heading-19">七、大模型时代的突破与演进</h2>
<p>随着以大语言模型为代表的、参数巨量、训练成本极高的模型出现，经典的k折交叉验证实践面临着严峻挑战：</p>
<ul>
<li>**计算成本无法承受：**训练一个大规模的模型需要数月时间和数百万美元的计算资源。进行k次（比如10次）这样的训练来进行交叉验证，在经济和时间上都是不现实的。</li>
<li>**数据规模巨大：**大模型的训练数据集往往达到TB甚至PB级别。在这种情况下，简单的留出法（例如98%训练，1%验证，1%测试）已经能提供非常稳定和低方差的性能估计。k折交叉验证带来的方差降低收益，与其巨大的计算成本相比，性价比极低。</li>
<li>**动态训练过程：**大模型的训练不是一次性的，而是涉及复杂的多阶段指令微调、人类反馈强化学习等。验证集在其中扮演着动态监控的角色，用于在单个训练周期内早停、选择检查点等，而非用于多次重新训练。</li>
</ul>
<p><strong>演进与应对策略：</strong></p>
<ul>
<li>**大规模留出法成为主流：**对于预训练和基础模型开发，单一、大规模、高质量的留出验证集是事实上的标准，其规模足以保证评估的稳定性。</li>
<li>**交叉验证的降级应用：**交叉验证并未完全消失，而是转移到了大模型工作流的下游任务中。
<ul>
<li>提示工程：当为特定任务设计提示时，研究人员可能会在一个较小的示例数据集上使用k折交叉验证来比较不同提示模板的稳定性。</li>
<li>超参数微调：在对大模型进行轻量级微调时，学习率、LoRA秩等超参数仍然需要调整。此时，可以在微调数据集上使用交叉验证来寻找最优设置。</li>
<li>小样本/少样本学习：在数据极其稀缺的场景下，交叉验证仍然是评估小样本学习策略有效性的重要工具。</li>
</ul>
</li>
<li>**从“重训练”到“重评估”：**理念从“通过多次训练来评估”转向“通过一次训练、在多个维度/数据集上深入评估”。大模型的评估重点不再是单一的准确率，而是涵盖了真实性、毒性、偏见、推理能力、指令遵循能力等更广泛的维度，这需要构建庞大且多样化的评估基准。</li>
</ul>
<p><strong>扩展说明：</strong></p>
<ul>
<li>**大规模留出法：**就像一所拥有数万学生的大学。学校要评估一位教授的教学水平，不需要让所有学生都参加考试。他们只需要随机抽取一个几百人的大班进行统一考试，因为这个班的成绩已经足以稳定、可靠地反映出教授的普遍教学效果。这种方法高效且成本可控。</li>
</ul>
<h2 data-id="heading-20">八、总结</h2>
<p>交叉验证作为机器学习模型评估的经典方法，其数学理论基础坚实，实践应用价值显著。它为我们在数据有限的常态下，进行可靠的模型评估、选择和调参提供了坚实的基础。通过系统的可视化分析，我们展示了交叉验证在数据理解、模型比较、超参数优化和最终评估等各个环节的核心作用。</p>
<p>进入大模型时代，虽然其应用场景因计算瓶颈而收缩，但其思想精髓已内化为机器学习工作流的基本逻辑。在资源允许的传统机器学习任务和中下游微调中，它依然是不可或缺的黄金标准；而在大规模基础模型研发中，我们则采用了更符合其经济性的评估范式。理解交叉验证的原理与局限，并能根据具体场景（数据规模、模型复杂度、计算预算）灵活选择最合适的评估策略，是每一位AI从业者必备的核心能力。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[你真的搞懂了LLM性能压测的各项指标吗？]]></title>    <link>https://juejin.cn/post/7590601860299505691</link>    <guid>https://juejin.cn/post/7590601860299505691</guid>    <pubDate>2026-01-03T03:25:36.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7590601860299505691" data-draft-id="7589386219449925647" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="你真的搞懂了LLM性能压测的各项指标吗？"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-01-03T03:25:36.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="吃果冻不吐果冻皮"/> <meta itemprop="url" content="https://juejin.cn/user/3642056016410728"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            你真的搞懂了LLM性能压测的各项指标吗？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3642056016410728/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    吃果冻不吐果冻皮
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-03T03:25:36.000Z" title="Sat Jan 03 2026 03:25:36 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读19分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>之前发现不同框架的性能差异有出入，当时并没有太在意。最近，对社区开源的LLM性能压测工具做了一个深度体验。发现各个框架对于各指标（如：ILT/TPOT）的定义真的是五花八门，稍微不注意可能就会用错里面的指标。本文梳理了各性能压测工具的计算公式，试图对齐各压测工具的性能指标。</p>
<blockquote>
<p>我撰写的<strong>大模型相关的博客及配套代码</strong>均整理放置在Github：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fliguodongiot%2Fllm-action%2Ftree%2Fmain" target="_blank" title="https://github.com/liguodongiot/llm-action/tree/main" ref="nofollow noopener noreferrer">llm-action</a>，有需要的朋友自取。</p>
</blockquote>
<h2 data-id="heading-0">各框架概述</h2>
<h3 data-id="heading-1">GuideLLM</h3>
<p>GuideLLM 是一个用于评估语言模型在真实工作负载和配置下性能表现的平台。它模拟与 OpenAI 和 vLLM 原生服务兼容的端到端交互，生成反映生产使用情况的工作负载模式，并生成详细报告，帮助团队理解系统行为、资源需求和运营限制。GuideLLM 支持真实和合成数据集、多模态输入以及灵活的执行配置文件，为工程师和机器学习团队提供了一个一致的框架，用于评估模型行为、调整部署和规划容量，以应对系统演进。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8191f4c464e74da492854f46064332cd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZCD5p6c5Ya75LiN5ZCQ5p6c5Ya755qu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768015536&amp;x-signature=cTFBNI9NiE%2Bafmd8npS5icr27f4%3D" alt="" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/38fcc2bb188545aa9d5a99d3fc211852~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZCD5p6c5Ya75LiN5ZCQ5p6c5Ya755qu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768015536&amp;x-signature=WJ4rHvJep2Fbjh8zIk2yeDY7Bmw%3D" alt="" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/798adedd44bb400fb882c86a3c4345a5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZCD5p6c5Ya75LiN5ZCQ5p6c5Ya755qu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768015536&amp;x-signature=O3lSsjeIkm62QyDyYf%2BnAq7TMSU%3D" alt="" loading="lazy"/></p>
<p><strong>GuideLLM特性</strong>：</p>
<p>GuideLLM 为团队在类生产环境中部署 LLM 时，清晰地展示了性能、效率和可靠性。</p>
<ul>
<li>捕捉完整的延迟和token级统计数据，用于 SLO 驱动的评估 ，包括 TTFT、ITL 和端到端行为的完整分布。</li>
<li>生成跨同步、并发和基于速率模式的真实、可配置的流量模式 ，包括可重复的扫描以识别安全运行范围。</li>
<li>支持真实和合成多模态数据集 ，支持一个框架内的受控实验和生产式评估。</li>
<li>生成标准化、可导出的报告，用于仪表盘、分析和回归跟踪 ，确保团队和工作流程间的一致性。</li>
<li>提供高吞吐量、可扩展的基准测试，支持多处理、线程、异步执行，以及灵活的 CLI/API用于支持自定义或快速启动。</li>
</ul>
<p><strong>安装</strong>：</p>
<pre><code class="hljs">pip install guidellm
</code></pre>
<p>或者直接使用镜像：</p>
<pre><code class="hljs language-sql" lang="sql">docker run <span class="hljs-operator">-</span>dt <span class="hljs-comment">--name guidellm-lgd \</span>
<span class="hljs-comment">--gpus all \</span>
<span class="hljs-comment">--network=host \</span>
<span class="hljs-comment">--shm-size=256g \</span>
<span class="hljs-comment">--env LANG=C.UTF-8 \</span>
<span class="hljs-operator">-</span>v <span class="hljs-operator">/</span>share<span class="hljs-operator">/</span><span class="hljs-keyword">global</span>:<span class="hljs-operator">/</span><span class="hljs-keyword">global</span> \
<span class="hljs-comment">--entrypoint /bin/bash \</span>
ghcr.io<span class="hljs-operator">/</span>vllm<span class="hljs-operator">-</span>project<span class="hljs-operator">/</span>guidellm:latest

docker <span class="hljs-keyword">exec</span> <span class="hljs-operator">-</span>it guidellm<span class="hljs-operator">-</span>lgd <span class="hljs-operator">/</span>bin<span class="hljs-operator">/</span>bash
</code></pre>
<p><strong>示例</strong>：</p>
<pre><code class="hljs language-diff" lang="diff">BASE_PATH=/workspace/outputs/genai-bench-eval
NAME=qwen3-8b-bf16-parallel20

rm -rf $BASE_PATH/$NAME

genai-bench benchmark \
<span class="hljs-deletion">--api-backend sglang \</span>
<span class="hljs-deletion">--api-base "http://localhost:8000" \</span>
<span class="hljs-deletion">--api-model-name "Qwen3-8B" \</span>
<span class="hljs-deletion">--api-key "xxx" \</span>
<span class="hljs-deletion">--model-tokenizer "/global/models/Qwen3-8B" \</span>
<span class="hljs-deletion">--server-engine "SGLang" \</span>
<span class="hljs-deletion">--server-gpu-type "H200" \</span>
<span class="hljs-deletion">--server-version "v0.5.6" \</span>
<span class="hljs-deletion">--server-gpu-count 1 \</span>
<span class="hljs-deletion">--task text-to-text \</span>
<span class="hljs-deletion">--max-time-per-run 10 \</span>
<span class="hljs-deletion">--max-requests-per-run 500 \</span>
<span class="hljs-deletion">--num-concurrency 20 \</span>
<span class="hljs-deletion">--traffic-scenario "D(1024,128)" \</span>
<span class="hljs-deletion">--experiment-base-dir $BASE_PATH \</span>
<span class="hljs-deletion">--experiment-folder-name $NAME</span>
</code></pre>
<p>关键参数：</p>
<ul>
<li>--profile：定义流量模式，选项包括 synchronous （顺序请求）、 concurrent （并行用户）、 throughput（最大容量）、 constant（每秒固定请求数）、 poisson（每秒随机请求数）或 sweep（自动速率探索）。</li>
<li>--rate：速率值，其含义取决于<code>--profile</code>，sweep 时是基准测试数量，concurrent 时是同时请求， constant / poisson 时是每秒请求数。</li>
<li>--max-seconds：每次基准测试的最大持续时间（秒数）（也可以用 --max-requests 来限制请求数）。</li>
</ul>
<p><strong>常用指标计算公式</strong>：</p>
<ul>
<li>平均ITL = (last_token - first_token) / (output_tokens - 1) , 不包括第一个token</li>
<li>平均TPOT = (last_token - request_start) / output_tokens , 包括第一个token</li>
<li>e2e latency = request_end - request_start</li>
<li>输出吞吐量 = output_tokens / e2e latency</li>
</ul>
<p>参考：</p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fvllm-project%2Fguidellm" target="_blank" title="https://github.com/vllm-project/guidellm" ref="nofollow noopener noreferrer">github.com/vllm-projec…</a></li>
</ul>
<h3 data-id="heading-2">Genai-Bench</h3>
<p>Genai-bench 是一款强大的基准工具，旨在全面评估大语言模型服务系统的token级性能评估。它提供了模型服务性能的详细洞察，还有用户友好的 CLI 和实时进度监控的实时 UI。</p>
<p><strong>特征</strong>：</p>
<ul>
<li>🛠️ CLI 工具 ：无缝验证用户输入并启动基准测试。</li>
<li>📊 实时界面仪表盘 ：显示当前进度、日志和实时指标。</li>
<li>📝 丰富的日志 ：实验完成后自动写入终端和文件。</li>
<li>📈 实验分析器 ：生成包含原始指标数据的全面 Excel 报告，以及灵活的图表配置（默认 2x4 网格），可视化关键性能指标，包括吞吐量、延迟（TTFT、端对端、TPOT）、错误率和 RPS，适用于不同流量场景和并发水平。支持自定义绘制布局和多行比较。</li>
</ul>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2cffc32791874fa2b67ea1cb61c6eff5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZCD5p6c5Ya75LiN5ZCQ5p6c5Ya755qu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768015536&amp;x-signature=8rRdXTX7R86IkJxF6%2F1TvW%2BUZT4%3D" alt="" loading="lazy"/></p>
<p><strong>安装</strong>：</p>
<pre><code class="hljs">pip install genai-bench
</code></pre>
<p><strong>示例</strong>：</p>
<pre><code class="hljs language-diff" lang="diff">BASE_PATH=/workspace/outputs/genai-bench-eval
NAME=qwen3-8b-bf16-parallel20

rm -rf $BASE_PATH/$NAME

genai-bench benchmark \
<span class="hljs-deletion">--api-backend sglang \</span>
<span class="hljs-deletion">--api-base "http://localhost:8000" \</span>
<span class="hljs-deletion">--api-model-name "Qwen3-8B" \</span>
<span class="hljs-deletion">--api-key "xxx" \</span>
<span class="hljs-deletion">--model-tokenizer "/global/models/Qwen3-8B" \</span>
<span class="hljs-deletion">--server-engine "SGLang" \</span>
<span class="hljs-deletion">--server-gpu-type "H200" \</span>
<span class="hljs-deletion">--server-version "v0.5.6" \</span>
<span class="hljs-deletion">--server-gpu-count 1 \</span>
<span class="hljs-deletion">--task text-to-text \</span>
<span class="hljs-deletion">--max-time-per-run 10 \</span>
<span class="hljs-deletion">--max-requests-per-run 500 \</span>
<span class="hljs-deletion">--num-concurrency 20 \</span>
<span class="hljs-deletion">--traffic-scenario "D(1024,128)" \</span>
<span class="hljs-deletion">--experiment-base-dir $BASE_PATH \</span>
<span class="hljs-deletion">--experiment-folder-name $NAME</span>
</code></pre>
<p>参数说明：</p>
<ul>
<li>--task：指定任务类型，支持文本生成、文生图、文本嵌入、图像嵌入。</li>
<li>--traffic-scenario：接受一种或多种场景。每次运行都会迭代所提供的场景和所选迭代参数（并发或批处理大小）。文本分布类型：
<ul>
<li>确定性输入输出：<code>D(num_input_tokens,num_output_tokens)</code>，比如：<code>D(100,1000)</code></li>
<li>正态分布‌：<code>N(mean_input_tokens,stddev_input_tokens)/(mean_output_tokens,stddev_output_tokens)</code>，例如：<code>N(480,240)/(300,150)</code></li>
<li>均匀分布：<code>U(min_input_tokens,max_input_tokens)/(min_output_tokens,max_output_tokens)</code>，例如：<code>U(50,100)/(200,250)</code></li>
</ul>
</li>
</ul>
<p>从结果生成 Excel 报告：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">BASE_PATH</span>=/workspace/outputs/genai-bench-eval
<span class="hljs-attr">NAME</span>=qwen3-<span class="hljs-number">8</span>b-bf16-parallel20

genai-bench excel --experiment-folder $BASE_PATH/$NAME \
  --excel-name results \
  --metric-percentile mean
</code></pre>
<p><strong>常见指标计算公式</strong>：</p>
<ul>
<li>metrics.<strong>e2e_latency</strong> = response.end_time - response.start_time</li>
<li>metrics.<strong>num_input_tokens</strong> = response.num_prefill_tokens</li>
<li>metrics.total_tokens = metrics.num_input_tokens</li>
<li>metrics.<strong>num_output_tokens</strong> = response.tokens_received</li>
<li>metrics.<strong>total_tokens</strong> += metrics.num_output_tokens</li>
<li>metrics.<strong>ttft</strong> = response.time_at_first_token - response.start_time</li>
<li>metrics.output_latency = metrics.e2e_latency - metrics.ttft</li>
<li>metrics.<strong>tpot</strong> = metrics.output_latency / (metrics.num_output_tokens - 1)，相当于GuideLLM中的ITL</li>
<li>metrics.<strong>output_throughput</strong> = metrics.num_output_tokens - 1) / metrics.output_latency</li>
</ul>
<p>参考：</p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsgl-project%2Fgenai-bench" target="_blank" title="https://github.com/sgl-project/genai-bench" ref="nofollow noopener noreferrer">github.com/sgl-project…</a></li>
</ul>
<h3 data-id="heading-3">AIPerf</h3>
<p>AIPerf 是一款全面的基准测试工具，用于衡量生成式 AI 模型的性能。它通过命令行展示详细的指标以及详尽的基准性能报告。</p>
<p>AIPerf 之前，英伟达开源的大模型性能工具为GenAI-Perf，目前已经逐步淘汰。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d87a06df9d974ee9b313d9bd9b84fb1e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZCD5p6c5Ya75LiN5ZCQ5p6c5Ya755qu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768015536&amp;x-signature=f%2FvB7ZF%2BRL%2B8b1HZHChvi0CzdH8%3D" alt="" loading="lazy"/></p>
<p><strong>特性</strong>：</p>
<ul>
<li>通过多进程支持可扩展</li>
<li>模块化设计便于用户修改</li>
<li>支持多种基准测试模式：
<ul>
<li>并发</li>
<li>请求率</li>
<li>最大并发量的请求率</li>
<li>追踪回放用于重现性能基准测试结果</li>
</ul>
</li>
<li>支持公开数据集</li>
</ul>
<p><strong>支持的 API</strong>：</p>
<ul>
<li>OpenAI chat completions</li>
<li>OpenAI completions</li>
<li>OpenAI embeddings</li>
<li>OpenAI audio: request throughput and latency</li>
<li>OpenAI images: request throughput and latency</li>
<li>NIM rankings</li>
</ul>
<p><strong>安装</strong>：</p>
<pre><code class="hljs">pip install aiperf
</code></pre>
<p><strong>示例</strong>：</p>
<pre><code class="hljs language-diff" lang="diff">aiperf profile \
<span class="hljs-deletion">--model qwen3 \</span>
<span class="hljs-deletion">--tokenizer /global/models/Qwen3-8B \</span>
<span class="hljs-deletion">--url localhost:8000 \</span>
<span class="hljs-deletion">--endpoint-type chat \</span>
<span class="hljs-deletion">--endpoint /v1/chat/completions \</span>
<span class="hljs-deletion">--streaming \</span>
<span class="hljs-deletion">--synthetic-input-tokens-mean 1024 \</span>
<span class="hljs-deletion">--synthetic-input-tokens-stddev 0 \</span>
<span class="hljs-deletion">--output-tokens-mean 128 \</span>
<span class="hljs-deletion">--output-tokens-stddev 0 \</span>
<span class="hljs-deletion">--extra-inputs ignore_eos:true \</span>
<span class="hljs-deletion">--concurrency 20 \</span>
<span class="hljs-deletion">--request-count 500 \</span>
<span class="hljs-deletion">--warmup-request-count 0 \</span>
<span class="hljs-deletion">--num-dataset-entries 1000 \</span>
<span class="hljs-deletion">--random-seed 100    </span>
</code></pre>
<p><strong>生成基准测试结果</strong>：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/04689647972645dea053dd8f5b55f73c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZCD5p6c5Ya75LiN5ZCQ5p6c5Ya755qu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768015536&amp;x-signature=5geHI2BFqiW9hLOPpq%2B1Hrs8Yhs%3D" alt="" loading="lazy"/></p>
<p><strong>常用指标计算公式</strong>：</p>
<ul>
<li><strong>TTFT</strong> = First Response Timestamp - Request Start Timestamp</li>
<li>TTST = Second Response Timestamp - First Response Timestamp</li>
<li>Inter Token Latency(<strong>ITL</strong>) = (Request Latency - Time to First Token) / (Output Sequence Length - 1)</li>
<li><strong>ICL</strong> = <code>[timestamps[i] - timestamps[i-1] for i in range(1, len(timestamps))]</code> ，比如：对于块在 [100ms, 150ms, 210ms] 时间到达的流响应。ICL = [50ms, 60ms]（连续时间戳之间的差异）</li>
</ul>
<p>参考：</p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fai-dynamo%2Faiperf" target="_blank" title="https://github.com/ai-dynamo/aiperf" ref="nofollow noopener noreferrer">github.com/ai-dynamo/a…</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ftriton-inference-server%2Fperf_analyzer%2Ftree%2Fmain%2Fgenai-perf" target="_blank" title="https://github.com/triton-inference-server/perf_analyzer/tree/main/genai-perf" ref="nofollow noopener noreferrer">github.com/triton-infe…</a></li>
</ul>
<h3 data-id="heading-4">EvalScope</h3>
<p>EvalScope 是魔搭社区倾力打造的模型评测与性能基准测试框架，为您的模型评估需求提供一站式解决方案。支持的模型类型如下：</p>
<ul>
<li>🧠 大语言模型</li>
<li>🎨 多模态模型</li>
<li>🔍 Embedding 模型</li>
<li>🏆 Reranker 模型</li>
<li>🖼️ CLIP 模型</li>
<li>🎭 AIGC模型（图生文/视频）</li>
</ul>
<p>EvalScope 不仅仅是一个评测工具，它还内置多个业界认可的测试基准和评测指标：MMLU、CMMLU、C-Eval、GSM8K 等。同时，支持模型推理性能压测，确保您的模型在实际应用中表现出色。</p>
<p>EvalScope 整体架构如下图所示，包括以下模块：</p>
<ol>
<li>输入层</li>
</ol>
<ul>
<li>模型来源：API模型（OpenAI API）、本地模型（ModelScope）</li>
<li>数据集：标准评测基准（MMLU/GSM8k等）、自定义数据（MCQ/QA）</li>
</ul>
<ol start="2">
<li>核心功能</li>
</ol>
<p>多后端评估</p>
<ul>
<li>原生后端：LLM/VLM/Embedding/T2I模型统一评估</li>
<li>集成框架：OpenCompass/MTEB/VLMEvalKit/RAGAS</li>
</ul>
<p>性能监控</p>
<ul>
<li>模型插件：支持多种模型服务API</li>
<li>数据插件：支持多种数据格式</li>
<li>指标追踪：TTFT/TPOP/稳定性 等指标</li>
</ul>
<p>工具扩展</p>
<ul>
<li>集成：Tool-Bench/Needle-in-a-Haystack/BFCL-v3</li>
</ul>
<ol start="3">
<li>输出层</li>
</ol>
<ul>
<li>结构化报告: 支持JSON/Table/Logs</li>
<li>可视化平台：支持Gradio/Wandb/SwanLab</li>
</ul>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5f442ea528144788a5bc7979c035185c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZCD5p6c5Ya75LiN5ZCQ5p6c5Ya755qu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768015536&amp;x-signature=GuDFzyGxA0p%2BmDRobMwnns8pJOg%3D" alt="" loading="lazy"/></p>
<p><strong>框架特点</strong>：</p>
<ul>
<li>基准数据集：预置了多个常用测试基准，包括：MMLU、CMMLU、C-Eval、GSM8K、ARC、HellaSwag、TruthfulQA、MATH、HumanEval等。</li>
<li>评测指标：实现了多种常用评测指标。</li>
<li>模型接入：统一的模型接入机制，兼容多个系列模型的Generate、Chat接口。</li>
<li>自动评测：包括客观题自动评测和使用专家模型进行的复杂任务评测。</li>
<li>评测报告：自动生成评测报告。</li>
<li>竞技场(Arena)模式：用于模型间的比较以及模型的客观评测，支持多种评测模式，包括：
<ul>
<li>Single mode：对单个模型进行评分。</li>
<li>Pairwise-baseline mode：与基线模型进行对比。</li>
<li>Pairwise (all) mode：所有模型间的两两对比。</li>
</ul>
</li>
<li>可视化工具：提供直观的评测结果展示。</li>
<li>模型性能评测：提供模型推理服务压测工具和详细统计。</li>
<li>OpenCompass集成：支持OpenCompass作为评测后端，对其进行了高级封装和任务简化，您可以更轻松地提交任务进行评测。</li>
<li>VLMEvalKit集成：支持VLMEvalKit作为评测后端，轻松发起多模态评测任务，支持多种多模态模型和数据集。</li>
<li>全链路支持：通过与ms-swift训练框架的无缝集成，实现模型训练、模型部署、模型评测、评测报告查看的一站式开发流程，提升用户的开发效率。</li>
</ul>
<p>EvalScope 支持OpenAI API格式模型服务以及多种数据集格式，方便用户进行性能评测。具体使用如下：</p>
<p><strong>安装</strong>：</p>
<pre><code class="hljs language-css" lang="css">pip install evalscope<span class="hljs-selector-attr">[perf]</span> -U
</code></pre>
<p><strong>示例</strong>：</p>
<pre><code class="hljs language-lua" lang="lua">evalscope perf \
  <span class="hljs-comment">--parallel 20 \</span>
  <span class="hljs-comment">--number 500  \</span>
  <span class="hljs-comment">--model Qwen-bf16-isl1k-osl128-056post1 \</span>
  <span class="hljs-comment">--url http://localhost:8000/v1/chat/completions \</span>
  <span class="hljs-comment">--api openai \</span>
  <span class="hljs-comment">--dataset random \</span>
  <span class="hljs-comment">--max-tokens 128 \</span>
  <span class="hljs-comment">--min-tokens 128 \</span>
  <span class="hljs-comment">--prefix-length 0 \</span>
  <span class="hljs-comment">--min-prompt-length 1024 \</span>
  <span class="hljs-comment">--max-prompt-length 1024 \</span>
  <span class="hljs-comment">--tokenizer-path /global/models/Qwen3-8B \</span>
  <span class="hljs-comment">--extra-args '{"ignore_eos": true}' \</span>
  <span class="hljs-comment">--outputs-dir /workspace/outputs/evalscope-perf-qwen3-8b</span>
</code></pre>
<p>参数说明：</p>
<ul>
<li>parallel: 请求的并发数，可以传入多个值，用空格隔开</li>
<li>number: 发出的请求的总数量，可以传入多个值，用空格隔开（与parallel一一对应）</li>
<li>url: 请求的URL地址</li>
<li>model: 使用的模型名称</li>
<li>api: 使用的API服务，默认为openai</li>
<li>dataset: 数据集名称，此处为random，表示随机生成数据集。</li>
<li>tokenizer-path: 模型的tokenizer路径，用于计算token数量（在random数据集中是必须的）</li>
<li>extra-args: 请求中的额外的参数，传入json格式的字符串，例如：{"ignore_eos": true} 表示忽略结束token</li>
</ul>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d9da7867f8f24d5c9e64ffd629063984~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZCD5p6c5Ya75LiN5ZCQ5p6c5Ya755qu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768015536&amp;x-signature=VF3FNqn5ec4niVhkTKlslYTy1Wk%3D" alt="" loading="lazy"/></p>
<p><strong>常见指标计算公式</strong>：</p>
<ul>
<li><strong>time_per_output_token</strong> (TPOT) = (query_latency - first_chunk_latency) / (completion_tokens - 1)，注意：AIPerf和GuideLLM中的itl实际上和EvalsSope的计算公式一致。</li>
<li>n_time_per_output_token += benchmark_data.time_per_output_token</li>
<li><strong>avg_time_per_token</strong> (平均TPOT) = n_time_per_output_token / n_succeed_queries</li>
<li>total_first_chunk_latency += benchmark_data.first_chunk_latency</li>
<li><strong>avg_first_chunk_latency</strong>（平均TTFT） = total_first_chunk_latency / n_succeed_queries</li>
<li>inter_chunk_latency = <code>[t2 - t1 for t1, t2 in zip(chunk_times[:-1], chunk_times[1:])]</code></li>
<li>n_total_inter_token_latency += benchmark_data.inter_chunk_latency</li>
<li><strong>avg_inter_token_latency</strong>（平均ITL） = sum(n_total_inter_token_latency) / len(n_total_inter_token_latency)</li>
<li><strong>qps</strong> = n_succeed_queries / total_time</li>
<li>avg_output_token_per_seconds（输出token吞吐量） = n_total_completion_tokens / total_time</li>
</ul>
<p><strong>参考</strong>：</p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fevalscope.readthedocs.io%2Fzh-cn%2Flatest%2Fuser_guides%2Fstress_test%2Fquick_start.html" target="_blank" title="https://evalscope.readthedocs.io/zh-cn/latest/user_guides/stress_test/quick_start.html" ref="nofollow noopener noreferrer">evalscope.readthedocs.io/zh-cn/lates…</a></li>
</ul>
<h3 data-id="heading-5">Inference Perf</h3>
<p>Inference Perf 是一款生成式 AI 推理性能基准工具，允许您对部署的推理模型的性能进行基准测试和分析。它不受模型服务影响，可用于<strong>性能测量</strong>和<strong>对不同系统进行全面比较</strong>。它是推理基准测试和指标标准化工作的一部分，旨在标准化 Kubernetes 和模型服务社区中用于衡量推理性能的基准工具和指标 。</p>
<p><strong>架构</strong>：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4b98ffc0ed704095aaefede01b825606~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZCD5p6c5Ya75LiN5ZCQ5p6c5Ya755qu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768015536&amp;x-signature=sxSdIS7oV4N1dchtAoOGQbJ3Wpg%3D" alt="" loading="lazy"/></p>
<p><strong>主要特点</strong>：</p>
<ul>
<li>高度可扩展，并支持大规模模型推理生产部署的基准测试。</li>
<li>报告衡量 LLM 性能的关键指标。</li>
<li>支持不同的真实世界和合成数据集。</li>
<li>支持不同的 API，并支持多个具增强指标的模型服务，如 vLLM、SGLang 和 TGI。</li>
<li>支持使用 LLM-d、Dynamo 和 Inference Gateway 等框架进行大型部署基准测试。</li>
<li>支持指定精确的输入和输出分布以模拟不同场景——支持高斯分布、固定长度、最小最大场景。</li>
<li>生成不同的负载模式，并能对特定场景进行基准测试，如突发流量、扩展至饱和以及其他自动扩展/路由场景。</li>
<li>支持多轮聊天对话，可以保持一系列消息的上下文，模拟对话。每轮聊天中的请求将保留前置消息作为前缀。</li>
</ul>
<p><strong>安装</strong>：</p>
<pre><code class="hljs">pip install inference-perf
</code></pre>
<p><strong>示例</strong>：</p>
<pre><code class="hljs language-arduino" lang="arduino">inference-perf --config_file config.yml
</code></pre>
<p>其中，config.yml内容如下所示：</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">load:</span>
  <span class="hljs-attr">type:</span> <span class="hljs-string">constant</span>
  <span class="hljs-attr">interval:</span> <span class="hljs-number">15</span>
  <span class="hljs-attr">stages:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">rate:</span> <span class="hljs-number">1</span>
    <span class="hljs-attr">duration:</span> <span class="hljs-number">30</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">rate:</span> <span class="hljs-number">2</span>
    <span class="hljs-attr">duration:</span> <span class="hljs-number">30</span>
<span class="hljs-attr">api:</span>
  <span class="hljs-attr">type:</span> <span class="hljs-string">completion</span>
<span class="hljs-attr">server:</span>
  <span class="hljs-attr">type:</span> <span class="hljs-string">sglang</span>
  <span class="hljs-attr">model_name:</span> <span class="hljs-string">HuggingFaceTB/SmolLM2-135M-Instruct</span>
  <span class="hljs-attr">base_url:</span> <span class="hljs-string">http://0.0.0.0:8000</span>
<span class="hljs-attr">tokenizer:</span>
  <span class="hljs-attr">pretrained_model_name_or_path:</span> <span class="hljs-string">HuggingFaceTB/SmolLM2-135M-Instruct</span>
<span class="hljs-attr">data:</span>
  <span class="hljs-attr">type:</span> <span class="hljs-string">synthetic</span>
  <span class="hljs-attr">input_distribution:</span>
    <span class="hljs-attr">min:</span> <span class="hljs-number">10</span>             <span class="hljs-comment"># min length of the synthetic prompts</span>
    <span class="hljs-attr">max:</span> <span class="hljs-number">100</span>            <span class="hljs-comment"># max length of the synthetic prompts</span>
    <span class="hljs-attr">mean:</span> <span class="hljs-number">50</span>            <span class="hljs-comment"># mean length of the synthetic prompts</span>
    <span class="hljs-attr">std:</span> <span class="hljs-number">10</span>             <span class="hljs-comment"># standard deviation of the length of the synthetic prompts</span>
  <span class="hljs-attr">output_distribution:</span>
    <span class="hljs-attr">min:</span> <span class="hljs-number">10</span>             <span class="hljs-comment"># min length of the output to be generated</span>
    <span class="hljs-attr">max:</span> <span class="hljs-number">100</span>            <span class="hljs-comment"># max length of the output to be generated</span>
    <span class="hljs-attr">mean:</span> <span class="hljs-number">50</span>            <span class="hljs-comment"># mean length of the output to be generated</span>
    <span class="hljs-attr">std:</span> <span class="hljs-number">10</span>             <span class="hljs-comment"># standard deviation of the length of the output to be generated</span>
<span class="hljs-attr">metrics:</span>
  <span class="hljs-attr">type:</span> <span class="hljs-string">prometheus</span>
  <span class="hljs-attr">prometheus:</span>
    <span class="hljs-attr">url:</span> <span class="hljs-string">http://localhost:9090</span>
    <span class="hljs-attr">scrape_interval:</span> <span class="hljs-number">15</span>
<span class="hljs-attr">report:</span>
  <span class="hljs-attr">request_lifecycle:</span>
    <span class="hljs-attr">summary:</span> <span class="hljs-literal">true</span>
    <span class="hljs-attr">per_stage:</span> <span class="hljs-literal">true</span>
    <span class="hljs-attr">per_request:</span> <span class="hljs-literal">true</span>
</code></pre>
<p><strong>常见指标计算公式</strong>：</p>
<ul>
<li><strong>time_per_output_token</strong>（TPOT）= <code>(x.info.output_token_times[-1] - x.info.output_token_times[0]) / (len(x.info.output_token_times) - 1)</code> ，该指标相当于GuideLLM的ITL</li>
<li>normalized_time_per_output_token（标准TPOT） = (metric.end_time - metric.start_time) / metric.info.output_tokens ，该指标相当于GuideLLM的TPOT</li>
<li><strong>TTFT</strong> = x.info.output_token_times[0] - x.start_time</li>
<li><strong>平均ITL</strong> = <code>mean([t2 - t1   for x in streamable   for t1, t2 in zip(x.info.output_token_times, x.info.output_token_times[1:], strict=False)])</code></li>
<li>total_time = max(x.end_time for x in metrics) - min(x.start_time for x in metrics)` ，相当于AIPerf中的ICL求平均。</li>
<li><strong>output_tokens_per_sec</strong> (输出token吞吐量) = sum(x.info.output_tokens for x in all_successful) / total_time</li>
<li><strong>requests_per_sec</strong>（RPS） = len(all_successful) / total_time</li>
</ul>
<p>参考：</p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fkubernetes-sigs%2Finference-perf" target="_blank" title="https://github.com/kubernetes-sigs/inference-perf" ref="nofollow noopener noreferrer">github.com/kubernetes-…</a></li>
</ul>
<h3 data-id="heading-6">LLMPerf</h3>
<p>LLMPerf 是一个用于评估 LLM API 性能的工具。目前已停止更新。实现了两种评估大型语言模型的测试：一个是用于测试性能的负载测试，另一个是用于检测正确性的正确性测试。</p>
<p><strong>安装</strong>：</p>
<pre><code class="hljs language-bash" lang="bash">git <span class="hljs-built_in">clone</span> https://github.com/ray-project/llmperf.git
<span class="hljs-built_in">cd</span> llmperf
pip install -e .
</code></pre>
<p><strong>负载测试</strong>：</p>
<p>负载测试会向 LLM API 生成多个并发请求，并测量tiken间延迟和每次请求及跨并发请求的生成吞吐量。每个请求中发送的提示词格式如下：</p>
<pre><code class="hljs language-vbnet" lang="vbnet">Randomly stream lines <span class="hljs-keyword">from</span> the following <span class="hljs-keyword">text</span>. Don<span class="hljs-comment">'t generate eos tokens:</span>
LINE <span class="hljs-number">1</span>,
LINE <span class="hljs-number">2</span>,
LINE <span class="hljs-number">3</span>,
...
</code></pre>
<p>诗句是从莎士比亚十四行诗中的一组诗句中随机抽取的。无论测试的是哪个 LLM API，LlamaTokenizer 都会统计 token 数。这是为了确保提示在不同 LLM API 上保持一致。</p>
<p>OpenAI Compatible APIs 示例如下：</p>
<pre><code class="hljs language-dart" lang="dart"><span class="hljs-keyword">export</span> OPENAI_API_KEY=secret_abcdefg
<span class="hljs-keyword">export</span> OPENAI_API_BASE=https:<span class="hljs-comment">//console.endpoints.anyscale.com/m/v1</span>

python llm_correctness.py \
--model <span class="hljs-string">"meta-llama/Llama-2-7b-chat-hf"</span> \
--max-<span class="hljs-built_in">num</span>-completed-requests <span class="hljs-number">150</span> \
--timeout <span class="hljs-number">600</span> \
--<span class="hljs-built_in">num</span>-concurrent-requests <span class="hljs-number">10</span> \
--results-dir <span class="hljs-string">"result_outputs"</span>
</code></pre>
<p>注意事项与免责声明：</p>
<ul>
<li>终端提供商的后端可能差异很大，因此这并不代表软件在特定硬件上的运行方式。</li>
<li>结果可能会因一天中的时间而异。</li>
<li><strong>结果可能会因负载不同而有所变化</strong>。</li>
<li><strong>结果可能与用户的工作量不相关</strong>。</li>
</ul>
<p><strong>正确性测试</strong>：</p>
<p>正确性测试会以以下格式向 LLM API 生成多个并发请求：</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">Convert</span> the following sequence <span class="hljs-keyword">of</span> words <span class="hljs-keyword">into</span> a number: {random_number_in_word_format}. Output just your <span class="hljs-keyword">final</span> answer.
</code></pre>
<p>其中：random_number_in_word_format 可以是 “one hundred and twenty three”。测试检查回答中是否包含该数字格式，在此例中为 123。</p>
<p>该检验对随机生成的数字进行此操作，并报告包含不匹配的回答数量。</p>
<p>OpenAI Compatible APIs 示例：</p>
<pre><code class="hljs language-dart" lang="dart"><span class="hljs-keyword">export</span> OPENAI_API_KEY=secret_abcdefg
<span class="hljs-keyword">export</span> OPENAI_API_BASE=https:<span class="hljs-comment">//console.endpoints.anyscale.com/m/v1</span>

python llm_correctness.py \
--model <span class="hljs-string">"meta-llama/Llama-2-7b-chat-hf"</span> \
--max-<span class="hljs-built_in">num</span>-completed-requests <span class="hljs-number">150</span> \
--timeout <span class="hljs-number">600</span> \
--<span class="hljs-built_in">num</span>-concurrent-requests <span class="hljs-number">10</span> \
--results-dir <span class="hljs-string">"result_outputs"</span>
</code></pre>
<p>参考：</p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fray-project%2Fllmperf" target="_blank" title="https://github.com/ray-project/llmperf" ref="nofollow noopener noreferrer">github.com/ray-project…</a></li>
</ul>
<h3 data-id="heading-7">llm-benchmark</h3>
<p>llm-benchmark 通过 Ollama 进行本地 LLM 吞吐量基准测试。</p>
<p>llm-benchmark 在 Windows、Linux 和 macOS 上，它会检测内存大小以优先下载所需的 LLM 模型。</p>
<p>当内存内存大小大于或等于 4GB 但小于 7GB 时，它会检查是否存在 gemma:2b。程序隐式地拉取这些模型。</p>
<pre><code class="hljs">ollama pull deepseek-r1:1.5b
ollama pull gemma:2b
ollama pull phi:2.7b
ollama pull phi3:3.8b
</code></pre>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fa13a1705ff54872920428714f49e5d5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZCD5p6c5Ya75LiN5ZCQ5p6c5Ya755qu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768015536&amp;x-signature=RtPRa7T%2FJLUGteBt6FR4GbIJm%2BQ%3D" alt="" loading="lazy"/></p>
<p><strong>安装</strong>：</p>
<pre><code class="hljs">pip install llm-benchmark
</code></pre>
<p><strong>运行</strong>：</p>
<p>#1 将系统信息和基准测试结果发送到远程服务器</p>
<pre><code class="hljs language-arduino" lang="arduino">llm_benchmark run
</code></pre>
<p>#2 不要将系统信息和基准测试结果发送到远程服务器</p>
<pre><code class="hljs language-arduino" lang="arduino">llm_benchmark run --no-sendinfo
</code></pre>
<p>#3 明确指定 ollama 可执行文件路径时运行（当你构建了自己的 ollama 开发者版本时）</p>
<pre><code class="hljs language-css" lang="css">llm_benchmark run <span class="hljs-attr">--ollamabin</span>=~/<span class="hljs-selector-tag">code</span>/ollama/ollama
</code></pre>
<p>#4 运行自定义基准模型</p>
<pre><code class="hljs language-css" lang="css">llm_benchmark run <span class="hljs-attr">--custombenchmark</span>=path/<span class="hljs-selector-tag">to</span>/custombenchmarkmodels<span class="hljs-selector-class">.yml</span>
</code></pre>
<p>其中，custombenchmarkmodels.yml文件内容如下：</p>
<pre><code class="hljs language-vbnet" lang="vbnet"><span class="hljs-symbol">file_name:</span> <span class="hljs-string">"custombenchmarkmodels.yml"</span>
<span class="hljs-symbol">version:</span> <span class="hljs-number">2.0</span>.<span class="hljs-keyword">custom</span>
<span class="hljs-symbol">models:</span>
  - model: <span class="hljs-string">"deepseek-r1:1.5b"</span>
  - model: <span class="hljs-string">"qwen:0.5b"</span>
</code></pre>
<p>参考：</p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Faidatatools%2Follama-benchmark" target="_blank" title="https://github.com/aidatatools/ollama-benchmark" ref="nofollow noopener noreferrer">github.com/aidatatools…</a></li>
</ul>
<h2 data-id="heading-8">常见的性能延迟指标</h2>
<p>上面在各框架概述，我梳理了各框架的性能压测指标，但是有一些指标在各框架里面计算方式不一，下面我综合主流的大模型框架的评估指标的计算方式，根据自己的主观判断给一点标准定义，以便使用各框架进行性能压测时能够对齐。：</p>
<ul>
<li><strong>首Token生成时间</strong>（Time To First Token，简称TTFT）：即用户输入提示后，模型生成第一个输出词元（Token）所需的时间。在实时交互中，低时延获取响应非常重要，但在离线工作任务中则不太重要。此指标受处理提示信息并生成首个输出词元所需的时间所驱动。通常，不仅对平均TTFT感兴趣，还包括其分布，如P50、P90、P95和P99等。计算公式为：<code>ttft = first_token_time - request_start_time</code>。</li>
<li><strong>Token间延迟</strong>（Inter Token Latency，简称ITL）：计算公式：<code>ITL = (last_token_time - first_token_time) / (output_tokens - 1) , 不包括第一个token</code>。</li>
<li><strong>块间延迟</strong>（Inter Chunk Latency，简称ICL）：特指在<strong>流式传输场景</strong>下，模型服务器返回的两个连续数据块（Chunk）之间的时间间隔。在流式传输中，LLM生成的文本不是一次性全部返回，而是以“块”为单位逐步返回。一个“块”通常包含若干个Token。因此，它衡量的是客户端接收到第N个数据块与接收到第N+1个数据块之间的时间差。它主要出现在服务器以 “text/event-stream” 等流式协议返回数据的场景中，是评估流式响应流畅度的核心指标。计算公式：<code>Inter Chunk Latency (Chunk_N) = Timestamp(收到 Chunk_{N+1}) - Timestamp(收到 Chunk_N)</code>。</li>
<li><strong>每个输出Token的生成时间</strong>（Time Per Output Token，简称TPOT）：即为每个用户的查询生成一个输出词元所需的时间。这一指标与每个用户对模型“速度”的感知相关。例如，TPOT为100ms/token表示每个用户每秒可处理10个token，或者每分钟处理约450个token，那么这一速度远超普通人的阅读速度。计算公式：<code>TPOT = (last_token_time - request_start_time) / output_tokens , 包括第一个token</code>。</li>
<li><strong>端到端时延（E2E）</strong>：模型为用户生成完整响应所需的总时间。整体响应时延可使用前两个指标计算得出：<code>e2e latency = request_end_time - request_start_time</code>。</li>
<li><strong>每分钟完成的请求数（RPS）</strong>：通常情况下，我们都希望系统能够处理并发请求。可能是因为你正在处理来自多个用户的输入或者可能有一个批量推理任务。</li>
<li><strong>生成Token吞吐量</strong>：推理服务在所有用户请求中每秒可生成的输出词元(Token)数。考虑到无法测量预加载时间，并且总推理时延所花时间更多地取决于生成的Token数量，而不是输入的Token数量，因此，将注意力集中在输出Token上通常是正确的抉择。计算公式：<code>输出Token吞吐量 = output_tokens / e2e latency</code></li>
<li><strong>总吞吐量</strong>：包括输入的Token和生成的Token。</li>
</ul>
<h2 data-id="heading-9">各框架之间的指标差异</h2>
<p>下面是针对qwen3-8b在h200上进行各框架性能指标对齐的结果（主要是ICL/ITL/TPOT指标差异较大）。即针对上面汇总之后定义的指标，在各个框架中的对应值。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3037daa7b997422aa1a5660565724bd6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZCD5p6c5Ya75LiN5ZCQ5p6c5Ya755qu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768015536&amp;x-signature=mm4uhE33JdS1QpgC2%2Fk9rjd%2FBAg%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-10">结语</h2>
<p>最后，在GuideLLM针对各LLM性能压测进行综合对比的基础上，下表进一步汇总了各个LLM性能压测框架的特性差异，大家在选择性能测试工具时可以根据自己的偏好进行选择。如果需要对比各种框架和特性的性能，最好统一使用同一个工具进行比较，以免出现结论性错误。</p>


























































































































<table><thead><tr><th>工具</th><th>CLI</th><th>API</th><th>High Perf</th><th>Full Metrics</th><th>数据模态</th><th>数据源</th><th>Profiles</th><th>Backends</th><th>Endpoints</th><th>输出类型</th></tr></thead><tbody><tr><td><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fvllm-project%2Fguidellm" target="_blank" title="https://github.com/vllm-project/guidellm" ref="nofollow noopener noreferrer">GuideLLM</a></td><td>✅</td><td>✅</td><td>✅</td><td>✅</td><td>文本, 图像, 音频, 视频</td><td>HuggingFace, Files, 合成, 自定义数据集</td><td>Synchronous, Concurrent, Throughput, Constant, Poisson, Sweep</td><td>OpenAI-compatible</td><td>/completions, /chat/completions, /audio/translation, /audio/transcription</td><td>console, json, csv, html</td></tr><tr><td><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fkubernetes-sigs%2Finference-perf" target="_blank" title="https://github.com/kubernetes-sigs/inference-perf" ref="nofollow noopener noreferrer">inference-perf</a></td><td>✅</td><td>❌</td><td>✅</td><td>❌</td><td>文本</td><td>合成, 指定数据集</td><td>Concurrent, Constant, Poisson, Sweep</td><td>OpenAI-compatible</td><td>/completions, /chat/completions</td><td>json, png</td></tr><tr><td><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsgl-project%2Fgenai-bench" target="_blank" title="https://github.com/sgl-project/genai-bench" ref="nofollow noopener noreferrer">genai-bench</a></td><td>✅</td><td>❌</td><td>❌</td><td>❌</td><td>文本, 图像, Embedding, ReRank</td><td>合成, File</td><td>Concurrent</td><td>OpenAI-compatible, Hosted Cloud</td><td>/chat/completions, /embeddings</td><td>console, xlsx, png</td></tr><tr><td><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fray-project%2Fllmperf" target="_blank" title="https://github.com/ray-project/llmperf" ref="nofollow noopener noreferrer">llm-perf</a></td><td>❌</td><td>❌</td><td>✅</td><td>❌</td><td>文本</td><td>合成</td><td>Concurrent</td><td>OpenAI-compatible, Hosted Cloud</td><td>/chat/completions</td><td>json</td></tr><tr><td><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Faidatatools%2Follama-benchmark" target="_blank" title="https://github.com/aidatatools/ollama-benchmark" ref="nofollow noopener noreferrer">ollama-benchmark</a></td><td>✅</td><td>❌</td><td>❌</td><td>❌</td><td>文本</td><td>合成</td><td>同步</td><td>Ollama</td><td>/completions</td><td>console, json</td></tr><tr><td><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fvllm-project%2Fvllm%2Ftree%2Fmain%2Fbenchmarks" target="_blank" title="https://github.com/vllm-project/vllm/tree/main/benchmarks" ref="nofollow noopener noreferrer">vllm/benchmarks</a></td><td>✅</td><td>❌</td><td>❌</td><td>❌</td><td>文本</td><td>合成, 指定数据集</td><td>Synchronous, Throughput, Constant, Sweep</td><td>OpenAI-compatible, vLLM API</td><td>/completions, /chat/completions</td><td>console, png</td></tr><tr><td><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fai-dynamo%2Faiperf" target="_blank" title="https://github.com/ai-dynamo/aiperf" ref="nofollow noopener noreferrer">AIPerf</a></td><td>✅</td><td>-</td><td>-</td><td>-</td><td>文本、图像、视频</td><td>合成、自定义以及公开数据集</td><td>Concurrent</td><td>OpenAI-compatible</td><td>/completions, /chat/completions</td><td>console, json, csv</td></tr><tr><td><a href="https://link.juejin.cn?target=https%3A%2F%2Fevalscope.readthedocs.io%2Fzh-cn%2Flatest%2Fuser_guides%2Fstress_test%2Fquick_start.html" target="_blank" title="https://evalscope.readthedocs.io/zh-cn/latest/user_guides/stress_test/quick_start.html" ref="nofollow noopener noreferrer">EvalScope Perf</a></td><td>✅</td><td>-</td><td>-</td><td>❌</td><td>文本、图像</td><td>合成、自定义以及公开数据集</td><td>Concurrent</td><td>OpenAI-compatible</td><td>/completions, /chat/completions</td><td>console, json</td></tr></tbody></table></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Electron 中的 “preload” 与 “invoke”]]></title>    <link>https://juejin.cn/post/7590421489997578259</link>    <guid>https://juejin.cn/post/7590421489997578259</guid>    <pubDate>2026-01-03T06:19:16.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7590421489997578259" data-draft-id="7590421489997561875" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Electron 中的 “preload” 与 “invoke”"/> <meta itemprop="keywords" content="Electron"/> <meta itemprop="datePublished" content="2026-01-03T06:19:16.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="梦鱼"/> <meta itemprop="url" content="https://juejin.cn/user/1099167360628462"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Electron 中的 “preload” 与 “invoke”
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1099167360628462/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    梦鱼
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-03T06:19:16.000Z" title="Sat Jan 03 2026 06:19:16 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    1
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">🎯 前言</h2>
<p>Electron 作为使用 Web 技术构建跨平台桌面应用的框架，其核心挑战之一是如何<strong>安全地实现主进程与渲染进程之间的通信</strong>。随着 Electron 12+ 版本默认启用上下文隔离（<code>contextIsolation: true</code>），传统的通信方式已经不再安全可靠electronjs.org。本文将深入探讨现代 Electron 应用中的安全通信方案——Preload 脚本与 Invoke 模式，帮助你构建更加安全可靠的应用。</p>
<h2 data-id="heading-1">🔍 核心概念解析</h2>
<h3 data-id="heading-2">什么是 Preload 脚本？</h3>
<p>Preload 脚本是一种在网页加载前执行的 JavaScript 文件，它具有访问 Node.js 和 Electron API 的特权权限csdn.net。更重要的是，它运行在一个独立的、与渲染进程隔离的上下文中，充当了<strong>安全桥梁</strong>的角色 。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// preload.js</span>
<span class="hljs-keyword">const</span> { contextBridge, ipcRenderer } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'electron'</span>)

<span class="hljs-comment">// 使用 contextBridge 安全地暴露 API</span>
contextBridge.<span class="hljs-title function_">exposeInMainWorld</span>(<span class="hljs-string">'electronAPI'</span>, {
  <span class="hljs-comment">// 暴露一个控制窗口的函数，使用 invoke 模式</span>
  <span class="hljs-attr">controlWindow</span>: <span class="hljs-function">(<span class="hljs-params">action</span>) =&gt;</span> ipcRenderer.<span class="hljs-title function_">invoke</span>(<span class="hljs-string">'window-control'</span>, action),
  <span class="hljs-comment">// 可以暴露其他经过精心设计的API</span>
  <span class="hljs-attr">getVersion</span>: <span class="hljs-function">() =&gt;</span> ipcRenderer.<span class="hljs-title function_">invoke</span>(<span class="hljs-string">'app:get-version'</span>)
})
</code></pre>
<h3 data-id="heading-3">什么是 Invoke 模式？</h3>
<p>Invoke 模式是 Electron 提供的一种异步双向通信机制，通过 <code>ipcRenderer.invoke</code> 和 <code>ipcMain.handle</code> 配合使用electronjs.org+1。渲染进程可以发起请求并等待响应，主进程则处理请求并返回结果，整个过程基于 Promise，避免了回调地狱。</p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-comment">// 主进程 (main.js)</span>
<span class="hljs-keyword">const</span> { ipcMain } = require(<span class="hljs-string">'electron'</span>)

ipcMain.handle(<span class="hljs-string">'window-control'</span>, <span class="hljs-keyword">async</span> (<span class="hljs-keyword">event</span>, action) =&gt; {
  <span class="hljs-keyword">const</span> win = BrowserWindow.fromWebContents(<span class="hljs-keyword">event</span>.sender)
  <span class="hljs-keyword">if</span> (!win) <span class="hljs-keyword">return</span> { success: <span class="hljs-literal">false</span> }
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">if</span> (action === <span class="hljs-string">'minimize'</span>) win.minimize()
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (action === <span class="hljs-string">'maximize'</span>) win.isMaximized() ? win.restore() : win.maximize()
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (action === <span class="hljs-string">'close'</span>) win.close()
    <span class="hljs-keyword">return</span> { success: <span class="hljs-literal">true</span> }
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-keyword">return</span> { success: <span class="hljs-literal">false</span>, error: error.message }
  }
})
</code></pre>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 渲染进程 (renderer.js)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">minimizeWindow</span>(<span class="hljs-params"/>) {
  <span class="hljs-comment">// 调用Preload暴露的API，就像调用普通函数一样</span>
  <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">window</span>.<span class="hljs-property">electronAPI</span>.<span class="hljs-title function_">controlWindow</span>(<span class="hljs-string">'minimize'</span>)
  <span class="hljs-keyword">if</span> (result.<span class="hljs-property">success</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'窗口最小化成功'</span>)
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'操作失败:'</span>, result.<span class="hljs-property">error</span>)
  }
}
</code></pre>
<h3 data-id="heading-4">🆚 Preload vs. Invoke 快速对比</h3>









































<table><thead><tr><th>特性维度</th><th>Preload (预加载脚本)</th><th>Invoke (<code>ipcRenderer.invoke</code> / <code>ipcMain.handle</code>)</th><th>协同工作关系</th></tr></thead><tbody><tr><td><strong>是什么</strong></td><td><strong>一个特殊的脚本文件</strong>（通常叫 <code>preload.js</code>），在网页加载前执行csdn.net。它拥有访问Node.js和Electron API的权限csdn.net 。</td><td><strong>一套通信方法</strong>。<code>ipcRenderer.invoke</code> 用于渲染进程发起<strong>请求并等待响应</strong>，<code>ipcMain.handle</code> 用于主进程<strong>处理该请求并返回结果</strong>csdn.net+1 。</td><td><strong>Preload脚本是“桥梁”和“安全通道”，Invoke是桥上走的“车”</strong> 。Preload通常使用Invoke来实现具体的通信功能。</td></tr><tr><td><strong>核心目的</strong></td><td><strong>安全隔离</strong>：在启用上下文隔离（<code>contextIsolation: true</code>）时，它作为<strong>唯一安全</strong>的方式，将精心挑选的API暴露给网页electronjs.org+1 。</td><td><strong>异步双向通信</strong>：让渲染进程能像调用本地函数一样，<strong>同步地请求主进程执行操作并获取结果</strong>，避免“回调地狱”csdn.net+1 。</td><td>Preload通过Invoke模式，将主进程的功能<strong>安全地封装</strong>后提供给渲染进程。</td></tr><tr><td><strong>工作位置</strong></td><td>运行在<strong>独立的、隔离的上下文</strong>中，与网页的<code>window</code>对象是分离的electronjs.org+1 。</td><td><strong>渲染进程</strong>调用<code>invoke</code>，<strong>主进程</strong>调用<code>handle</code>。它们通过IPC通道通信。</td><td>Preload脚本在隔离的上下文中接收渲染进程的请求，并通过<code>ipcRenderer.invoke</code>转发给主进程。</td></tr><tr><td><strong>是否替代品</strong></td><td><strong>否</strong>。Preload是实现安全通信的<strong>基础设施和最佳实践</strong>。</td><td><strong>否</strong>。Invoke是多种IPC通信模式之一（还有<code>send</code>/<code>on</code>等），但因其<strong>简洁性</strong>，在需要返回结果时被<strong>强烈推荐</strong>csdn.net+1 。</td><td><strong>最佳实践是：在Preload脚本中使用Invoke模式来暴露API</strong>。</td></tr><tr><td><strong>代码示例</strong></td><td><code>contextBridge.exposeInMainWorld('myAPI', { ... })</code>electronjs.org</td><td>渲染进程: <code>await window.myAPI.someFunction()</code> Preload: <code>ipcRenderer.invoke('some-channel')</code> 主进程: <code>ipcMain.handle('some-channel', handler)</code></td><td>见下方详细流程图。</td></tr></tbody></table>
<h3 data-id="heading-5">🔍 深入理解 Preload (预加载脚本)</h3>
<p>Preload脚本是Electron安全模型的核心。</p>
<ul>
<li>
<p><strong>它为什么重要？</strong><br/>
Electron默认启用<strong>上下文隔离（Context Isolation）</strong> electronjs.org+1。这意味着 ：</p>
<ul>
<li>网页的<code>window</code>对象和Preload脚本的<code>window</code>对象是<strong>完全不同</strong>的两个世界electronjs.org 。</li>
<li>网页无法直接访问Node.js或Electron的API（如<code>ipcRenderer</code>, <code>fs</code>等），这是巨大的安全提升，防止恶意代码（如通过XSS漏洞）直接操作系统csdn.net+1 。</li>
<li><strong>Preload脚本就是唯一有权限跨越这两个世界的“桥梁”</strong> 。它运行在一个<strong>特权上下文</strong>中，可以访问Node.js API，同时也能访问网页的DOM（<code>document</code>, <code>window</code>）csdn.net 。</li>
</ul>
</li>
<li>
<p><strong>它的核心任务是什么？</strong><br/>
通过 <code>contextBridge.exposeInMainWorld</code> 方法，<strong>安全地、有选择地</strong>将某些特权API暴露给网页electronjs.org+1。这就像是给一个完全隔离的房间开一扇受控的小门，只传递必要的物品 。</p>
</li>
<li>
<p><strong>一个安全的Preload示例</strong>：</p>
</li>
</ul>
<pre><code class="hljs language-javascript" lang="javascript">    <span class="hljs-comment">// preload.js</span>
    <span class="hljs-keyword">const</span> { contextBridge, ipcRenderer } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'electron'</span>)

    <span class="hljs-comment">// ✅ 安全的做法：只暴露特定、封装好的函数</span>
    contextBridge.<span class="hljs-title function_">exposeInMainWorld</span>(<span class="hljs-string">'myApp'</span>, {
        <span class="hljs-comment">// 暴露一个函数，内部使用 invoke 模式通信</span>
        <span class="hljs-attr">openFile</span>: <span class="hljs-function">() =&gt;</span> ipcRenderer.<span class="hljs-title function_">invoke</span>(<span class="hljs-string">'dialog:openFile'</span>),
        <span class="hljs-comment">// 可以暴露其他经过精心设计的API</span>
        <span class="hljs-attr">getVersion</span>: <span class="hljs-function">() =&gt;</span> ipcRenderer.<span class="hljs-title function_">invoke</span>(<span class="hljs-string">'app:get-version'</span>)
    })
</code></pre>
<h3 data-id="heading-6">🚀 深入理解 Invoke (通信模式)</h3>
<p><code>invoke</code>/<code>handle</code> 是Electron提供的一种<strong>异步的、基于Promise的</strong>进程间通信模式。</p>
<ul>
<li>
<p><strong>它为什么好用？</strong></p>
<ul>
<li><strong>避免回调地狱</strong>：传统的 <code>ipcRenderer.send</code> + <code>ipcRenderer.on</code> 模式在处理双向通信时，需要手动管理回调，容易导致代码嵌套过深csdn.net。<code>invoke</code> 让代码像写同步函数一样清晰。</li>
<li><strong>内置错误处理</strong>：可以直接用 <code>try/catch</code> 捕获主进程返回的错误。</li>
<li><strong>语义清晰</strong>：<code>invoke</code> 本身就暗示了这是一个“调用并等待返回”的操作。</li>
</ul>
</li>
<li>
<p><strong>它的工作流程</strong>：</p>
</li>
</ul>
<pre><code class="hljs language-dart" lang="dart">    <span class="hljs-comment">// 渲染进程 (renderer.js)</span>
    <span class="hljs-keyword">const</span> filePath = <span class="hljs-keyword">await</span> <span class="hljs-built_in">window</span>.myApp.openFile() <span class="hljs-comment">// 调用Preload暴露的函数</span>

    <span class="hljs-comment">// Preload脚本 (preload.js)</span>
    openFile: () =&gt; ipcRenderer.invoke(<span class="hljs-string">'dialog:openFile'</span>) <span class="hljs-comment">// 转发IPC调用</span>

    <span class="hljs-comment">// 主进程 (main.js)</span>
    ipcMain.handle(<span class="hljs-string">'dialog:openFile'</span>, <span class="hljs-keyword">async</span> () =&gt; {
        <span class="hljs-keyword">const</span> { canceled, filePaths } = <span class="hljs-keyword">await</span> dialog.showOpenDialog()
        <span class="hljs-keyword">if</span> (canceled) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>
        <span class="hljs-keyword">return</span> filePaths[<span class="hljs-number">0</span>] <span class="hljs-comment">// 返回结果会自动被Promise包装</span>
    })
</code></pre>
<h2 data-id="heading-7">📊 通信模式对比</h2>
<p>下表对比了不同通信模式的优缺点，帮助你选择最合适的方案：</p>









































<table><thead><tr><th>特性维度</th><th><code>send</code>/<code>on</code> (单向)</th><th><code>invoke</code>/<code>handle</code> (双向)</th><th>不安全的直接访问</th></tr></thead><tbody><tr><td><strong>代码简洁性</strong></td><td>需手动管理回调，易陷入回调地狱</td><td>像本地函数调用一样简洁，支持 async/await</td><td>代码最简洁，但极不安全</td></tr><tr><td><strong>错误处理</strong></td><td>手动传递错误对象</td><td>内置错误处理，可用 try/catch 捕获</td><td>错误处理难以统一</td></tr><tr><td><strong>安全性</strong></td><td>相对安全，但仍需谨慎</td><td><strong>最安全</strong>，配合 Preload 使用</td><td><strong>极不安全</strong>，应避免使用</td></tr><tr><td><strong>返回值</strong></td><td>需要手动发送回复消息</td><td>自动返回 Promise 对象</td><td>直接访问，无通信过程</td></tr><tr><td><strong>推荐场景</strong></td><td>简单通知、无需返回值的操作</td><td>需要返回结果的复杂操作</td><td><strong>永不推荐</strong></td></tr></tbody></table>
<blockquote>
<p>⚠️ <strong>安全警告</strong>：<strong>永远不要</strong>在渲染进程中直接使用 <code>require('electron').ipcRenderer</code> 或启用 <code>nodeIntegration: true</code>。这会破坏上下文隔离，带来巨大的安全风险csdn.net+1 。</p>
</blockquote>
<h3 data-id="heading-8">进一步学习资源</h3>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.electronjs.org%2Fdocs%2Flatest%2Ftutorial%2Fsecurity" target="_blank" title="https://www.electronjs.org/docs/latest/tutorial/security" ref="nofollow noopener noreferrer">Electron 官方安全指南</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.electronjs.org%2Fdocs%2Flatest%2Fapi%2Fcontext-bridge" target="_blank" title="https://www.electronjs.org/docs/latest/api/context-bridge" ref="nofollow noopener noreferrer">contextBridge API 文档</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.electronjs.org%2Fdocs%2Flatest%2Ftutorial%2Fipc" target="_blank" title="https://www.electronjs.org/docs/latest/tutorial/ipc" ref="nofollow noopener noreferrer">进程间通信 (IPC) 指南</a></li>
</ul>
<blockquote>
<p>🌟 <strong>最后建议</strong>：构建安全的 Electron 应用需要从一开始就考虑安全因素，而不是事后添加安全措施。遵循本文介绍的最佳实践，将帮助你构建更加安全可靠的桌面应用。</p>
</blockquote>
<p>希望这篇文章能够帮助你更好地理解 Electron 的安全通信机制。如果你有任何问题或需要进一步的帮助，请随时在评论区留言。<strong>别忘了点赞和收藏</strong>，以便日后查阅！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[React 自定义 Hook 实战：从鼠标追踪到待办事项管理]]></title>    <link>https://juejin.cn/post/7590128405351743488</link>    <guid>https://juejin.cn/post/7590128405351743488</guid>    <pubDate>2026-01-03T06:46:32.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7590128405351743488" data-draft-id="7590213554798362659" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="React 自定义 Hook 实战：从鼠标追踪到待办事项管理"/> <meta itemprop="keywords" content="前端,React.js"/> <meta itemprop="datePublished" content="2026-01-03T06:46:32.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="ohyeah"/> <meta itemprop="url" content="https://juejin.cn/user/740446536480618"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            React 自定义 Hook 实战：从鼠标追踪到待办事项管理
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/740446536480618/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    ohyeah
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-03T06:46:32.000Z" title="Sat Jan 03 2026 06:46:32 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在现代前端开发中，React 的自定义 Hook 已成为提升代码复用性、逻辑抽象能力和可维护性的核心手段。本文将通过两个典型示例——<strong>鼠标位置追踪</strong>与<strong>本地存储的待办事项管理</strong>，深入剖析如何利用自定义 Hook 将复杂业务逻辑封装为可复用、可测试、高内聚的模块，并探讨其背后的 React 响应式编程思想。</p>
<hr/>
<h2 data-id="heading-0">一、Demo 1：使用 <code>useMouse</code> 封装鼠标位置追踪</h2>
<h3 data-id="heading-1">1.1 初始实现的问题</h3>
<p>最初，开发者可能直接在组件内部使用 <code>useState</code> 和 <code>useEffect</code> 来监听鼠标移动事件：</p>
<pre><code class="hljs language-scss" lang="scss">function <span class="hljs-built_in">MouseMove</span>() {
  const <span class="hljs-selector-attr">[x, setX]</span> = <span class="hljs-built_in">useState</span>(<span class="hljs-number">0</span>);
  const <span class="hljs-selector-attr">[y, setY]</span> = <span class="hljs-built_in">useState</span>(<span class="hljs-number">0</span>);

  <span class="hljs-built_in">useEffect</span>(() =&gt; {
    const update = (event) =&gt; {
      <span class="hljs-built_in">setX</span>(event.pageX);
      <span class="hljs-built_in">setY</span>(event.pageY);
    };
    window<span class="hljs-selector-class">.addEventListener</span>('mousemove', update);
    return () =&gt; {
      window<span class="hljs-selector-class">.removeEventListener</span>('mousemove', update);
    };
  }, <span class="hljs-selector-attr">[]</span>);

  return &lt;<span class="hljs-selector-tag">div</span>&gt;鼠标位置: {x} {y}&lt;/<span class="hljs-selector-tag">div</span>&gt;;
}
</code></pre>
<p>这种写法虽然功能完整，但存在明显缺陷：</p>
<ul>
<li><strong>逻辑耦合</strong>：UI 渲染与事件监听混杂，组件职责不清；</li>
<li><strong>难以复用</strong>：若其他组件也需要获取鼠标坐标，需重复编写相同逻辑；</li>
<li><strong>潜在内存泄漏风险</strong>：若未正确清理事件监听器（如忘记返回清理函数），组件卸载后仍会执行回调，<strong>事件监听/定时器 不会因为函数组件卸载而自动销毁</strong>，当卸载组件后又开启组件，相当于是又进行了一次事件监听，多次重复导致内存泄漏。</li>
</ul>
<h3 data-id="heading-2">1.2 提炼为自定义 Hook：<code>useMouse</code></h3>
<p>为解决上述问题，我们将鼠标追踪逻辑提取至独立的 <code>useMouse</code> Hook：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// src/hooks/useMouse.js</span>
<span class="hljs-keyword">import</span> { useState, useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">useMouse</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-keyword">const</span> [x, setX] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);
  <span class="hljs-keyword">const</span> [y, setY] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">update</span> = (<span class="hljs-params">event</span>) =&gt; {
      <span class="hljs-title function_">setX</span>(event.<span class="hljs-property">pageX</span>);
      <span class="hljs-title function_">setY</span>(event.<span class="hljs-property">pageY</span>);
    };
    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'mousemove'</span>, update);
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'mousemove'</span>, update);
    };
  }, []);
   
  <span class="hljs-keyword">return</span> { x, y };
  <span class="hljs-comment">// 把要向外暴露的状态和方法返回</span>
};
</code></pre>
<h4 data-id="heading-3">关键设计点解析：</h4>
<ol>
<li><strong>状态封装</strong><br/>
使用 <code>useState</code> 管理 <code>x</code> 和 <code>y</code> 坐标，对外仅暴露只读值，避免外部直接修改状态。</li>
<li><strong>副作用隔离</strong><br/>
<code>useEffect</code> 负责添加/移除全局事件监听器。依赖数组为空（<code>[]</code>），确保仅在组件挂载时注册一次监听器，并在卸载时自动清理，彻底规避内存泄漏。</li>
<li><strong>单一职责原则</strong><br/>
<code>useMouse</code> 只关注“获取鼠标位置”这一核心能力，不涉及任何 UI 渲染或业务判断，高度内聚。</li>
<li><strong>可组合性</strong><br/>
返回对象 <code>{ x, y }</code>，便于在任意组件中解构使用，符合 React 的声明式风格。</li>
</ol>
<h3 data-id="heading-4">1.3 在组件中使用</h3>
<p>在 <code>App.jsx</code> 中，只需一行代码即可接入鼠标位置数据：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">MouseMove</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> { x, y } = <span class="hljs-title function_">useMouse</span>();
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>鼠标位置: {x} {y}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
}
</code></pre>
<p>此时 <code>MouseMove</code> 组件完全退化为纯展示层，逻辑与视图分离，极大提升了可读性和可维护性。</p>
<hr/>
<h2 data-id="heading-5">二、Demo 2：构建完整的待办事项系统 —— <code>useTodos</code></h2>
<p>相比鼠标追踪，待办事项管理涉及<strong>状态管理、持久化存储</strong>等多个维度，是检验自定义 Hook 能力的绝佳场景。</p>
<h3 data-id="heading-6">2.1 整体架构拆解</h3>
<p>整个系统由以下部分组成：</p>
<ul>
<li>
<p><strong>Hook 层</strong>：<code>useTodos</code> —— 核心逻辑容器</p>
</li>
<li>
<p><strong>组件层</strong>：</p>
<ul>
<li><code>TodoInput</code>：输入新任务</li>
<li><code>TodoList</code>：渲染任务列表</li>
<li><code>TodoItem</code>：单个任务项（含完成状态切换与删除）</li>
</ul>
</li>
</ul>
<p>这种分层结构体现了典型的“<strong>逻辑下沉，UI 上浮</strong>”原则：复杂状态流转由 Hook 处理，组件仅负责调用方法与展示数据。</p>
<h3 data-id="heading-7">2.2 <code>useTodos</code> Hook 深度解析</h3>
<pre><code class="hljs language-ini" lang="ini">// src/hooks/useTodos.js
import { useState, useEffect } from 'react'<span class="hljs-comment">;</span>

const <span class="hljs-attr">STORAGE_KEY</span> = <span class="hljs-string">'todos'</span><span class="hljs-comment">;</span>

function loadFromStorage() {
  const <span class="hljs-attr">stored</span> = localStorage.getItem(STORAGE_KEY)<span class="hljs-comment">;</span>
  return stored ? JSON.parse(stored) : <span class="hljs-section">[]</span><span class="hljs-comment">;</span>
}

function saveToStorage(todos) {
  localStorage.setItem(STORAGE_KEY, JSON.stringify(todos))<span class="hljs-comment">;</span>
}

export const <span class="hljs-attr">useTodos</span> = () =&gt; {
  const <span class="hljs-section">[todos, setTodos]</span> = useState(loadFromStorage)<span class="hljs-comment">;</span>

  useEffect(() =&gt; {
    saveToStorage(todos)<span class="hljs-comment">;</span>
  }, <span class="hljs-section">[todos]</span>)<span class="hljs-comment">;</span>
  // todos改变 进行本地存储

  const <span class="hljs-attr">addTodo</span> = (text) =&gt; {
    setTodos(<span class="hljs-section">[
      ...todos,
      { id: Date.now(), text, completed: false }
    ]</span>)<span class="hljs-comment">;</span>
  }<span class="hljs-comment">;</span>

  const <span class="hljs-attr">toggleTodo</span> = (id) =&gt; {
    setTodos(
      todos.map(<span class="hljs-attr">todo</span> =&gt;
        <span class="hljs-attr">todo.id</span> === id ? { ...todo, completed: !todo.completed } : todo
      )
    )<span class="hljs-comment">;</span>
  }<span class="hljs-comment">;</span>

  const <span class="hljs-attr">deleteTodo</span> = (id) =&gt; {
    setTodos(todos.filter(<span class="hljs-attr">todo</span> =&gt; todo.id !== id))<span class="hljs-comment">;</span>
  }<span class="hljs-comment">;</span>

  return { todos, addTodo, toggleTodo, deleteTodo }<span class="hljs-comment">;</span>
}<span class="hljs-comment">;</span>
</code></pre>
<h4 data-id="heading-8">核心机制详解：</h4>
<h5 data-id="heading-9">（1）初始化与持久化同步</h5>
<ul>
<li><strong>延迟初始化</strong>：<code>useState(loadFromStorage)</code> 利用函数式初始化，避免每次渲染都读取 localStorage，提升性能。</li>
<li><strong>自动持久化</strong>：<code>useEffect</code> 监听 <code>todos</code> 变化，一旦状态更新立即写入 localStorage，实现“状态即存储”的无缝体验。</li>
</ul>
<blockquote>
<p>注意：此处使用 <code>Date.now()</code> 作为 ID 虽简便，但在高频操作下可能冲突。</p>
</blockquote>
<h5 data-id="heading-10">（2）不可变更新原则</h5>
<p>所有状态变更均通过<strong>创建新数组</strong>实现：</p>
<ul>
<li><code>addTodo</code>：使用展开运算符 <code>[...todos, newTodo]</code></li>
<li><code>toggleTodo</code>：<code>map</code> 返回新数组，仅修改目标项</li>
<li><code>deleteTodo</code>：<code>filter</code> 排除指定 ID 项</li>
</ul>
<p>这保证了 React 能正确触发重渲染，同时避免意外修改原始状态。</p>
<h5 data-id="heading-11">（3）API 设计清晰</h5>
<p>返回对象包含：</p>
<ul>
<li><strong>状态</strong>：<code>todos</code>（当前任务列表）</li>
<li><strong>行为</strong>：<code>addTodo</code>, <code>toggleTodo</code>, <code>deleteTodo</code>（纯函数，无副作用）</li>
</ul>
<p>调用者无需关心内部实现，只需按约定传参即可操作状态。</p>
<h3 data-id="heading-12">2.3 组件层协作流程</h3>
<h4 data-id="heading-13"><code>TodoInput</code>：任务创建入口</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// src/components/TodoInput.jsx</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">TodoInput</span>(<span class="hljs-params">{ onAddTodo }</span>) {
  <span class="hljs-keyword">const</span> [text, setText] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">''</span>);
  
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleSubmit</span> = (<span class="hljs-params">e</span>) =&gt; {
    e.<span class="hljs-title function_">preventDefault</span>();
    <span class="hljs-keyword">if</span> (!text.<span class="hljs-title function_">trim</span>()) <span class="hljs-keyword">return</span>;
    <span class="hljs-title function_">onAddTodo</span>(text.<span class="hljs-title function_">trim</span>());
    <span class="hljs-title function_">setText</span>(<span class="hljs-string">''</span>);
  };

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">onSubmit</span>=<span class="hljs-string">{handleSubmit}</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> 
        <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span>
        <span class="hljs-attr">value</span>=<span class="hljs-string">{text}</span>
        <span class="hljs-attr">onChange</span>=<span class="hljs-string">{e</span> =&gt;</span> setText(e.target.value)}
      /&gt;
    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span>
  );
}
</code></pre>
<ul>
<li>通过 <code>onAddTodo</code> 回调将新任务文本传递给父组件（即 <code>useTodos.addTodo</code>）</li>
<li>表单提交后清空输入框，提供良好 UX</li>
</ul>
<h4 data-id="heading-14"><code>TodoList</code> 与 <code>TodoItem</code>：状态展示与交互</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// TodoList.jsx</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">TodoList</span>(<span class="hljs-params">{ todos, onDelete, onToggle }</span>) {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
      {todos.map(todo =&gt; (
        <span class="hljs-tag">&lt;<span class="hljs-name">TodoItem</span> 
          <span class="hljs-attr">key</span>=<span class="hljs-string">{todo.id}</span>
          <span class="hljs-attr">todo</span>=<span class="hljs-string">{todo}</span>
          <span class="hljs-attr">onDelete</span>=<span class="hljs-string">{onDelete}</span>
          <span class="hljs-attr">onToggle</span>=<span class="hljs-string">{onToggle}</span>
        /&gt;</span>
      ))}
    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span>
  );
}

<span class="hljs-comment">// TodoItem.jsx</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">TodoItem</span>(<span class="hljs-params">{ todo, onDelete, onToggle }</span>) {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> 
        <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span>
        <span class="hljs-attr">checked</span>=<span class="hljs-string">{todo.completed}</span>
        <span class="hljs-attr">onChange</span>=<span class="hljs-string">{()</span> =&gt;</span> onToggle(todo.id)}
      /&gt;
      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{todo.completed</span> ? '<span class="hljs-attr">completed</span>' <span class="hljs-attr">:</span> ''}&gt;</span>
        {todo.text}
      <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> onDelete(todo.id)}&gt;Delete<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>
  );
}
</code></pre>
<ul>
<li><strong>单向数据流</strong>：<code>todos</code> 由 <code>App</code> 传入，<code>TodoItem</code> 仅消费数据</li>
<li><strong>事件委托</strong>：点击复选框或删除按钮时，调用 <code>onToggle</code> / <code>onDelete</code>，最终触发 <code>useTodos</code> 内部状态更新</li>
<li><strong>Key 唯一性</strong>：使用 <code>todo.id</code> 作为 <code>key</code>，确保 React Diff 算法高效更新列表</li>
</ul>
<h3 data-id="heading-15">2.4 App 组件：胶水层整合</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// App.jsx</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> { todos, addTodo, deleteTodo, toggleTodo } = <span class="hljs-title function_">useTodos</span>();

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">TodoInput</span> <span class="hljs-attr">onAddTodo</span>=<span class="hljs-string">{addTodo}</span> /&gt;</span>
      {todos.length &gt; 0 ? (
        <span class="hljs-tag">&lt;<span class="hljs-name">TodoList</span> 
          <span class="hljs-attr">todos</span>=<span class="hljs-string">{todos}</span> 
          <span class="hljs-attr">onDelete</span>=<span class="hljs-string">{deleteTodo}</span> 
          <span class="hljs-attr">onToggle</span>=<span class="hljs-string">{toggleTodo}</span> 
        /&gt;</span>
      ) : (
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>暂无待办事项<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      )}
    <span class="hljs-tag">&lt;/&gt;</span></span>
  );
}
</code></pre>
<p><code>App</code> 组件几乎不包含业务逻辑，仅负责：</p>
<ol>
<li>调用 <code>useTodos</code> 获取状态与方法</li>
<li>将方法作为 props 传递给子组件</li>
<li>根据 <code>todos.length</code> 控制空状态显示</li>
</ol>
<p>这种“瘦容器”模式使应用结构清晰，易于扩展（例如未来加入筛选、编辑等功能）。</p>
<hr/>
<h2 data-id="heading-16">三、自定义 Hook 的价值与最佳实践</h2>
<h3 data-id="heading-17">3.1 为什么需要自定义 Hook？</h3>
<ul>
<li><strong>逻辑复用</strong>：跨组件共享状态逻辑</li>
<li><strong>关注点分离</strong>：将副作用、数据获取、状态管理从 UI 组件中剥离</li>
<li><strong>测试友好</strong>：Hook 可独立于组件进行单元测试</li>
<li><strong>团队协作</strong>：形成可沉淀的“前端资产库”，新人可快速接入</li>
</ul>
<h3 data-id="heading-18">3.2 编写高质量 Hook 的准则</h3>
<ol>
<li><strong>命名规范</strong>：以 <code>use</code> 开头（如 <code>useTodos</code>），这是 React 的约定，也是 ESLint 规则的要求。</li>
<li><strong>返回结构清晰</strong>：通常返回对象，便于按需解构；避免返回数组导致顺序依赖。</li>
<li><strong>避免副作用外泄</strong>：Hook 内部处理所有订阅/清理，调用者无需关心生命周期。</li>
<li><strong>考虑性能优化</strong>：对返回的函数使用 <code>useCallback</code> 包裹（本例因简单省略，复杂场景需注意）。</li>
</ol>
<hr/>
<h2 data-id="heading-19">结语</h2>
<p>通过 <code>useMouse</code> 与 <code>useTodos</code> 两个案例，我们见证了自定义 Hook 如何将“面条式代码”转化为模块化、可维护的现代 React 应用。它不仅是语法糖，更是一种<strong>架构思维</strong>——鼓励开发者将复杂问题分解为独立、可组合的逻辑单元。</p>
<p>在实际项目中，你可以继续延伸这一模式：封装网络请求（<code>useFetch</code>）、表单验证（<code>useForm</code>）、主题切换（<code>useTheme</code>）等通用能力。当你的 Hook 库逐渐丰富，你会发现：<strong>优秀的前端工程，始于对逻辑的敬畏，成于对复用的追求</strong>。</p>
<blockquote>
<p>本文所有代码均可直接运行，建议读者动手实践，尝试为 <code>useTodos</code> 添加“编辑任务”或“按状态筛选”功能，进一步巩固自定义 Hook 的设计能力。</p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[MiniMax × Cursor：Taro小程序开发终极指南]]></title>    <link>https://juejin.cn/post/7590421489997611027</link>    <guid>https://juejin.cn/post/7590421489997611027</guid>    <pubDate>2026-01-03T06:46:49.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7590421489997611027" data-draft-id="7589919989039775807" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="MiniMax × Cursor：Taro小程序开发终极指南"/> <meta itemprop="keywords" content="小程序·云开发,Cursor,LLM"/> <meta itemprop="datePublished" content="2026-01-03T06:46:49.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="土豆1250"/> <meta itemprop="url" content="https://juejin.cn/user/3280598428302727"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            MiniMax × Cursor：Taro小程序开发终极指南
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3280598428302727/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    土豆1250
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-03T06:46:49.000Z" title="Sat Jan 03 2026 06:46:49 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读17分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>从"这是什么玩意"到"哇这也太丝滑了吧" —— 一个 AI 辅助开发的成长日记</p>
</blockquote>
<h2 data-id="heading-0">🎯 开篇：为什么你需要这套组合拳</h2>
<h3 data-id="heading-1">Why：三个让你心动的理由</h3>
<p><strong>痛点一：Bug 调试像在迷宫里找钥匙</strong> 🔑<br/>
传统开发中,遇到问题只能疯狂翻文档、搜 Stack Overflow、问 GPT 然后复制粘贴。问题是——你怎么知道搜到的答案是不是最新的?适不适合你的项目?</p>
<p><strong>痛点二:设计稿还原度全靠"盲猜"</strong> 🎨<br/>
UI 给了设计图,你左看右看上看下看,这个间距是 16px 还是 18px?这个颜色是#333 还是#444?来回切屏,眼睛都快瞎了。</p>
<p><strong>痛点三:云函数调试像开盲盒</strong> 📦<br/>
云函数报错了?先登录控制台,找到函数,点开日志,翻半天...等等,这个 error 是哪次调用的来着?</p>
<h3 data-id="heading-2">What：这套组合拳能给你什么</h3>
<ul>
<li><strong>MiniMax Coding Plan MCP</strong>: 内置<code>web_search</code>和<code>understand_image</code>工具</li>
<li><strong>CloudBase MCP</strong>: 直接在 IDE 里查询云函数日志、管理数据库</li>
<li><strong>Cursor + MCP</strong>: AI 助手拥有"千里眼"和"顺风耳"</li>
<li><strong>Taro + Tailwind CSS</strong>: 所见即所得的 UI 开发</li>
</ul>
<p>简单来说:<strong>让 AI 真正懂你的项目,而不是瞎猫碰死耗子。</strong></p>
<h2 data-id="heading-3">🚀 基础配置：先把装备配齐</h2>
<h3 data-id="heading-4">第一步:安装 Cursor</h3>
<p>如果你还在用 VS Code,是时候升级了。<a href="https://link.juejin.cn?target=https%3A%2F%2Fcursor.com" title="https://cursor.com" target="_blank" ref="nofollow noopener noreferrer">Cursor</a> 是专为 AI 编程优化的 IDE,原生支持 MCP 协议。</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># macOS/Linux</span>
<span class="hljs-comment"># 直接去官网下载即可: https://cursor.com</span>

<span class="hljs-comment"># 下载后首次启动,会提示你导入VS Code设置</span>
<span class="hljs-comment"># 强烈建议导入,无缝迁移</span>
</code></pre>
<h3 data-id="heading-5">第二步:配置 MiniMax Coding Plan MCP</h3>
<p><strong>什么是 Coding Plan?</strong><br/>
这是 MiniMax 专门为开发者提供的订阅服务,包含 web 搜索和图片理解能力。简单说就是给 AI 装上了"网络搜索"和"看图说话"两个技能。</p>
<h4 data-id="heading-6">获取 API Key</h4>
<ol>
<li>访问 <a href="https://link.juejin.cn?target=https%3A%2F%2Fplatform.minimax.io" title="https://platform.minimax.io" target="_blank" ref="nofollow noopener noreferrer">MiniMax 开发者平台</a></li>
<li>注册/登录账号</li>
<li>在"Coding Plan"页面订阅套餐</li>
<li>获取你的 API Key</li>
</ol>
<h4 data-id="heading-7">配置到 Cursor</h4>
<p>打开 Cursor 的 MCP 配置文件:</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># macOS/Linux</span>
~/.cursor/mcp.json

<span class="hljs-comment"># Windows</span>
%USERPROFILE%\.cursor\mcp.json
</code></pre>
<p>添加 MiniMax 配置:</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"mcpServers"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"MiniMax"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"command"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"uvx"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"args"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">"minimax-coding-plan-mcp"</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"-y"</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"env"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">"MINIMAX_API_KEY"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"你的API_KEY"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"MINIMAX_API_HOST"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"https://api.minimax.io"</span>
      <span class="hljs-punctuation">}</span>
    <span class="hljs-punctuation">}</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p><strong>注意事项</strong> ⚠️</p>
<ul>
<li>国内用户使用 <code>https://api.minimax.io</code></li>
<li>国际用户使用 <code>https://api.minimaxi.chat</code></li>
<li>API Key 必须和 Host 区域匹配,否则会报错</li>
</ul>
<p>重启 Cursor,打开 Composer (Cmd/Ctrl+I),输入<code>/mcp</code>,如果看到<code>web_search</code>和<code>understand_image</code>就说明配置成功了!</p>
<h3 data-id="heading-8">第三步:配置 CloudBase MCP</h3>
<p>CloudBase 是腾讯云开发的 MCP 工具,专门用于管理云开发资源。</p>
<h4 data-id="heading-9">安装 CloudBase CLI</h4>
<pre><code class="hljs language-bash" lang="bash">npm install -g @cloudbase/cli@latest
</code></pre>
<h4 data-id="heading-10">登录 CloudBase</h4>
<pre><code class="hljs language-bash" lang="bash">tcb login
<span class="hljs-comment"># 会打开浏览器进行授权登录</span>
</code></pre>
<h4 data-id="heading-11">配置到 Cursor</h4>
<p>在<code>~/.cursor/mcp.json</code>中添加:</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"mcpServers"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"MiniMax"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
      <span class="hljs-comment">// ...前面的配置</span>
    <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"cloudbase"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"command"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"npx"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"args"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">"@cloudbase/cloudbase-mcp@latest"</span><span class="hljs-punctuation">]</span>
    <span class="hljs-punctuation">}</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<h3 data-id="heading-12">第四步:创建 Taro 项目并集成 Tailwind CSS</h3>
<h4 data-id="heading-13">初始化 Taro 项目</h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 安装Taro CLI</span>
npm install -g @tarojs/cli

<span class="hljs-comment"># 创建项目</span>
taro init myapp

<span class="hljs-comment"># 选择模板时推荐:</span>
<span class="hljs-comment"># - React (更成熟的生态)</span>
<span class="hljs-comment"># - TypeScript (类型安全)</span>
<span class="hljs-comment"># - 微信小程序</span>
</code></pre>
<h4 data-id="heading-14">集成 Tailwind CSS</h4>
<p>Tailwind CSS 是目前最受欢迎的原子化 CSS 框架,而且特别适合 AI 编程——AI 能直接"说人话"生成样式。</p>
<p><strong>安装依赖:</strong></p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-built_in">cd</span> myapp
npm install -D tailwindcss postcss autoprefixer
npm install -D weapp-tailwindcss
</code></pre>
<p><strong>初始化配置:</strong></p>
<pre><code class="hljs language-bash" lang="bash">npx tailwindcss init
</code></pre>
<p><strong>配置<code>tailwind.config.js</code>:</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">content</span>: [
    <span class="hljs-string">"./src/**/*.{js,jsx,ts,tsx}"</span>,
  ],
  <span class="hljs-comment">// 小程序不支持某些特殊字符,需要自定义分隔符</span>
  <span class="hljs-attr">separator</span>: <span class="hljs-string">'_'</span>,
  <span class="hljs-attr">corePlugins</span>: {
    <span class="hljs-comment">// 关闭preflight,避免样式冲突</span>
    <span class="hljs-attr">preflight</span>: <span class="hljs-literal">false</span>
  }
}
</code></pre>
<p><strong>配置 Taro:</strong></p>
<p>在<code>config/index.js</code>中添加:</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> config = {
  <span class="hljs-comment">// ...其他配置</span>
  <span class="hljs-attr">plugins</span>: [
    [<span class="hljs-string">'@tarojs/plugin-html'</span>],
    [<span class="hljs-string">'weapp-tailwindcss/webpack'</span>, {
      <span class="hljs-comment">// 配置选项</span>
    }]
  ],
  <span class="hljs-attr">mini</span>: {
    <span class="hljs-attr">postcss</span>: {
      <span class="hljs-attr">pxtransform</span>: {
        <span class="hljs-attr">enable</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">config</span>: {}
      }
    }
  }
}
</code></pre>
<p><strong>在<code>app.css</code>中引入 Tailwind:</strong></p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-keyword">@tailwind</span> base;
<span class="hljs-keyword">@tailwind</span> components;
<span class="hljs-keyword">@tailwind</span> utilities;
</code></pre>
<p><strong>验证安装:</strong></p>
<p>在任意页面组件中测试:</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">View</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@tarojs/components'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Index</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"flex items-center justify-center h-screen bg-blue-500"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"text-white text-2xl"</span>&gt;</span>Hello Tailwind!<span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span></span>
  )
}
</code></pre>
<p>运行<code>npm run dev:weapp</code>,如果看到蓝色背景和白色文字,说明配置成功!</p>
<h2 data-id="heading-15">💡 实战技巧：让 AI 成为你的超级助手</h2>
<h3 data-id="heading-16">技巧 1：用 web_search 解决疑难杂症</h3>
<p><strong>场景:</strong> Taro 项目中遇到一个奇怪的 API 报错。</p>
<p><strong>传统做法:</strong></p>
<ol>
<li>复制错误信息</li>
<li>打开浏览器搜索</li>
<li>翻阅 5-10 个页面</li>
<li>尝试每个解决方案</li>
<li>祈祷有一个能 work</li>
</ol>
<p><strong>使用 MiniMax MCP:</strong></p>
<p>直接在 Cursor 的 Composer 中告诉 AI:</p>
<pre><code class="hljs language-vbnet" lang="vbnet">这个错误信息是什么意思?帮我用web_search搜索一下Taro社区有没有类似问题的解决方案:

[<span class="hljs-keyword">ERROR</span>] <span class="hljs-keyword">Error</span>: miniprogram-api-typings: <span class="hljs-keyword">Module</span> <span class="hljs-built_in">not</span> found
</code></pre>
<p>AI 会自动调用<code>web_search</code>工具,搜索最新的解决方案,并给你总结:</p>
<pre><code class="hljs language-markdown" lang="markdown">根据搜索结果,这个问题是因为...

解决方案:

<span class="hljs-bullet">1.</span> 升级 Taro 版本到 3.6+
<span class="hljs-bullet">2.</span> 或者安装缺失的类型定义: npm install -D miniprogram-api-typings

相关讨论:

<span class="hljs-bullet">-</span> https://github.com/NervJS/taro/issues/...
<span class="hljs-bullet">-</span> https://taro-docs.jd.com/...
</code></pre>
<p><strong>为什么这么厉害?</strong></p>
<ul>
<li>搜索的是<strong>实时信息</strong>,不是训练数据</li>
<li>AI 会帮你<strong>筛选和总结</strong>,不是直接扔一堆链接</li>
<li>还会给出<strong>相关搜索建议</strong></li>
</ul>
<h3 data-id="heading-17">技巧 2：用 understand_image 快速还原设计稿</h3>
<p><strong>场景:</strong> UI 给了一张设计稿,要求 100%还原。</p>
<p><strong>传统做法:</strong></p>
<ol>
<li>切换到设计工具</li>
<li>测量每个元素的位置、大小</li>
<li>记录颜色值</li>
<li>回到代码一点点写</li>
<li>来回对比调整</li>
</ol>
<p><strong>使用 MiniMax MCP:</strong></p>
<ol>
<li>把设计稿截图保存</li>
<li>在 Cursor 中粘贴图片</li>
<li>告诉 AI:</li>
</ol>
<pre><code class="hljs language-diff" lang="diff">帮我分析这张设计稿,用Taro + Tailwind CSS实现。
重点关注:
<span class="hljs-deletion">- 布局结构</span>
<span class="hljs-deletion">- 间距和对齐</span>
<span class="hljs-deletion">- 颜色和字号</span>
<span class="hljs-deletion">- 组件层次</span>
</code></pre>
<p>AI 会分析图片,然后生成:</p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">View</span>, <span class="hljs-title class_">Text</span>, <span class="hljs-title class_">Image</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@tarojs/components'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">ProductCard</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"bg-white rounded-2xl p-4 shadow-lg"</span>&gt;</span>
      {/* 商品图片 */}
      <span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"relative mb-4"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">Image</span>
          <span class="hljs-attr">src</span>=<span class="hljs-string">"xxx"</span>
          <span class="hljs-attr">className</span>=<span class="hljs-string">"w-full h-48 rounded-xl object-cover"</span>
        /&gt;</span>
        {/* 右上角标签 */}
        <span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"absolute top-2 right-2 bg-red-500 text-white px-3 py-1 rounded-full text-xs"</span>&gt;</span>
          热卖
        <span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span>

      {/* 商品信息 */}
      <span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"space-y-2"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">Text</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"text-lg font-bold text-gray-800"</span>&gt;</span>
          商品名称
        <span class="hljs-tag">&lt;/<span class="hljs-name">Text</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"flex items-center justify-between"</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">Text</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"text-2xl font-bold text-red-500"</span>&gt;</span>
            ¥199
          <span class="hljs-tag">&lt;/<span class="hljs-name">Text</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">Text</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"text-sm text-gray-400 line-through"</span>&gt;</span>
            ¥299
          <span class="hljs-tag">&lt;/<span class="hljs-name">Text</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span></span>
  )
}
</code></pre>
<p><strong>Pro Tips:</strong></p>
<ul>
<li>可以同时上传多张图片对比分析</li>
<li>让 AI 解释为什么使用某个 Tailwind 类</li>
<li>要求 AI 生成不同屏幕尺寸的响应式版本</li>
</ul>
<h3 data-id="heading-18">技巧 3：用 CloudBase MCP 调试云函数</h3>
<p><strong>场景:</strong> 云函数返回了错误,需要查看日志排查问题。</p>
<p><strong>传统做法:</strong></p>
<ol>
<li>打开腾讯云控制台</li>
<li>找到云开发环境</li>
<li>进入云函数管理</li>
<li>找到对应函数</li>
<li>查看日志</li>
<li>分析问题</li>
<li>修改代码</li>
<li>重新部署</li>
<li>再次测试</li>
</ol>
<p><strong>使用 CloudBase MCP:</strong></p>
<p>直接在 Cursor 中告诉 AI:</p>
<pre><code class="hljs">我的getUserInfo云函数返回500错误,帮我查看最近的日志,找出问题原因并修复
</code></pre>
<p>AI 会:</p>
<ol>
<li>自动调用 CloudBase MCP 查询日志</li>
<li>分析错误堆栈</li>
<li>定位问题代码</li>
<li>给出修复方案</li>
<li>甚至直接帮你修改代码</li>
</ol>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// AI发现的问题:</span>
<span class="hljs-comment">// 原代码:</span>
<span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> db.<span class="hljs-title function_">collection</span>(<span class="hljs-string">'users'</span>).<span class="hljs-title function_">doc</span>(userId).<span class="hljs-title function_">get</span>()
<span class="hljs-keyword">return</span> user.<span class="hljs-property">data</span>.<span class="hljs-property">name</span> <span class="hljs-comment">// ❌ 当用户不存在时,data是undefined</span>

<span class="hljs-comment">// AI的修复:</span>
<span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> db.<span class="hljs-title function_">collection</span>(<span class="hljs-string">'users'</span>).<span class="hljs-title function_">doc</span>(userId).<span class="hljs-title function_">get</span>()
<span class="hljs-keyword">if</span> (!user.<span class="hljs-property">data</span>) {
  <span class="hljs-keyword">return</span> { <span class="hljs-attr">error</span>: <span class="hljs-string">'用户不存在'</span> }
}
<span class="hljs-keyword">return</span> user.<span class="hljs-property">data</span>.<span class="hljs-property">name</span> <span class="hljs-comment">// ✅ 增加了错误处理</span>
</code></pre>
<p><strong>CloudBase MCP 的其他神器功能:</strong></p>
<ul>
<li>查询数据库记录</li>
<li>部署新的云函数</li>
<li>管理静态网站托管</li>
<li>配置安全规则</li>
</ul>
<h3 data-id="heading-19">技巧 4：在.cursorrules 中定义项目规范</h3>
<p><strong>为什么需要.cursorrules?</strong></p>
<p>想象一下,你有一个 10 人的开发团队,每个人的代码风格都不一样:</p>
<ul>
<li>张三喜欢用 class 组件</li>
<li>李四全用 function 组件</li>
<li>王五样式写在 CSS 文件里</li>
<li>赵六全部 inline style</li>
</ul>
<p>项目代码看起来像"垃圾场"。</p>
<p><strong>解决方案:</strong></p>
<p>在项目根目录创建<code>.cursorrules</code>或<code>.cursorrules.md</code>文件:</p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section"># Taro 小程序开发规范</span>

<span class="hljs-section">## 技术栈</span>

<span class="hljs-bullet">-</span> Taro 3.x
<span class="hljs-bullet">-</span> React 18+ (function 组件 + Hooks)
<span class="hljs-bullet">-</span> TypeScript
<span class="hljs-bullet">-</span> Tailwind CSS

<span class="hljs-section">## 代码风格</span>

<span class="hljs-section">### 组件规范</span>

<span class="hljs-bullet">-</span> 所有组件必须使用 Function Component
<span class="hljs-bullet">-</span> 必须使用 TypeScript,定义完整的 Props 类型
<span class="hljs-bullet">-</span> 组件文件名使用 PascalCase: <span class="hljs-code">`UserProfile.tsx`</span>

<span class="hljs-section">### 样式规范</span>

<span class="hljs-bullet">-</span> 优先使用 Tailwind CSS utility 类
<span class="hljs-bullet">-</span> 禁止使用 inline style
<span class="hljs-bullet">-</span> 自定义样式使用 CSS Modules
<span class="hljs-bullet">-</span> 响应式设计使用 Tailwind 的断点系统

示例:

<span class="hljs-code">```jsx
import { View, Text } from '@tarojs/components'
import { FC } from 'react'

interface UserCardProps {
  name: string
  avatar: string
}

const UserCard: FC&lt;UserCardProps&gt; = ({ name, avatar }) =&gt; {
  return (
    &lt;View className="flex items-center p-4 bg-white rounded-lg shadow"&gt;
      &lt;Image src={avatar} className="w-12 h-12 rounded-full" /&gt;
      &lt;Text className="ml-3 text-base font-medium"&gt;{name}&lt;/Text&gt;
    &lt;/View&gt;
  )
}

export default UserCard
```</span>
</code></pre>
<h3 data-id="heading-20">云函数规范</h3>
<ul>
<li>统一使用 async/await</li>
<li>必须有完整的错误处理</li>
<li>返回值格式统一: <code>{ code, message, data }</code></li>
</ul>
<p>示例:</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-built_in">exports</span>.<span class="hljs-property">main</span> = <span class="hljs-keyword">async</span> (event) =&gt; {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> { userId } = event

    <span class="hljs-keyword">if</span> (!userId) {
      <span class="hljs-keyword">return</span> { <span class="hljs-attr">code</span>: <span class="hljs-number">400</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">'缺少userId参数'</span> }
    }

    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> db.<span class="hljs-title function_">collection</span>(<span class="hljs-string">'users'</span>)
      .<span class="hljs-title function_">doc</span>(userId)
      .<span class="hljs-title function_">get</span>()

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">code</span>: <span class="hljs-number">0</span>,
      <span class="hljs-attr">message</span>: <span class="hljs-string">'success'</span>,
      <span class="hljs-attr">data</span>: result.<span class="hljs-property">data</span>
    }
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'getUserInfo error:'</span>, error)
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">code</span>: <span class="hljs-number">500</span>,
      <span class="hljs-attr">message</span>: <span class="hljs-string">'服务器错误'</span>,
      <span class="hljs-attr">error</span>: error.<span class="hljs-property">message</span>
    }
  }
}
</code></pre>
<h2 data-id="heading-21">常见问题解决方案</h2>
<h3 data-id="heading-22">Taro API 调用问题</h3>
<ul>
<li>优先查阅 Taro 官方文档: <a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.taro.zone" target="_blank" title="https://docs.taro.zone" ref="nofollow noopener noreferrer">docs.taro.zone</a></li>
<li>使用 web_search 搜索 GitHub Issues</li>
</ul>
<h3 data-id="heading-23">云函数调试</h3>
<ul>
<li>使用 CloudBase MCP 直接查看日志</li>
<li>不要在代码里加 console.log 后重新部署</li>
</ul>
<h3 data-id="heading-24">样式问题</h3>
<ul>
<li>使用 understand_image 分析设计稿</li>
<li>记住小程序不支持某些 CSS 特性</li>
</ul>
<p><strong>配置好后的效果:</strong></p>
<p>当你让AI写代码时,它会严格遵守这些规范:</p>
<pre><code class="hljs language-text" lang="text">
你: 帮我写一个用户列表页面

AI: 好的,我会按照项目规范,使用 Function Component + TypeScript + Tailwind CSS 来实现...

[生成的代码自动符合规范]

</code></pre>
<h3 data-id="heading-25">技巧5：善用Tailwind的"AI友好"特性</h3>
<p><strong>为什么说Tailwind CSS是AI友好的?</strong></p>
<p>因为Tailwind的类名就是**"人类语言"**:</p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-comment">// 传统CSS: AI需要理解复杂的样式规则</span>
&lt;<span class="hljs-title class_">View</span> style={{
  <span class="hljs-attr">display</span>: <span class="hljs-string">'flex'</span>,
  <span class="hljs-attr">alignItems</span>: <span class="hljs-string">'center'</span>,
  <span class="hljs-attr">justifyContent</span>: <span class="hljs-string">'space-between'</span>,
  <span class="hljs-attr">padding</span>: <span class="hljs-string">'16px'</span>,
  <span class="hljs-attr">backgroundColor</span>: <span class="hljs-string">'#ffffff'</span>,
  <span class="hljs-attr">borderRadius</span>: <span class="hljs-string">'8px'</span>,
  <span class="hljs-attr">boxShadow</span>: <span class="hljs-string">'0 2px 8px rgba(0,0,0,0.1)'</span>
}}&gt;

<span class="hljs-comment">// Tailwind CSS: AI直接"说人话"</span>
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"flex items-center justify-between p-4 bg-white rounded-lg shadow-md"</span>&gt;</span>
</span></code></pre>
<p><strong>实战案例:</strong></p>
<p>你可以这样和 AI 交流:</p>
<pre><code class="hljs language-makefile" lang="makefile"><span class="hljs-section">你: 做一个卡片组件,要有圆角、阴影、内边距16px,flex布局,上面是图片,下面是文字</span>

<span class="hljs-section">AI: 明白了!</span>
[直接生成Tailwind代码]
</code></pre>
<p><strong>常用的 Tailwind 组合:</strong></p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-comment">// 1. 水平居中的容器</span>
&lt;<span class="hljs-title class_">View</span> className=<span class="hljs-string">"flex items-center justify-center"</span>&gt;

<span class="hljs-comment">// 2. 垂直布局,间距16px</span>
&lt;View className="flex flex-col space-y-4"&gt;

// 3. 卡片样式
&lt;View className="bg-white rounded-xl shadow-lg p-4"&gt;

// 4. 响应式文字
&lt;Text className="text-base md:text-lg lg:text-xl"&gt;

// 5. 按钮样式
&lt;View className="bg-blue-500 hover:bg-blue-600 text-white py-2 px-4 rounded-full"&gt;
</code></pre>
<p><strong>⚠️ 小程序特殊限制:</strong></p>
<p>小程序不支持某些特殊字符作为类名,所以:</p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-comment">// ❌ 错误写法</span>
&lt;<span class="hljs-title class_">View</span> className=<span class="hljs-string">"w-1/2"</span>&gt;  <span class="hljs-comment">// 小程序不支持 /</span>
&lt;View className="hover:bg-blue"&gt;  // 小程序不支持 :

// ✅ 正确写法 (配置separator: '_')
&lt;View className="w-1_2"&gt;
&lt;View className="hover_bg-blue"&gt;
</code></pre>
<h2 data-id="heading-26">🎨 最佳实践：从入门到精通</h2>
<h3 data-id="heading-27">实践 1：构建一个完整的功能模块</h3>
<p><strong>需求:</strong> 开发一个"待办事项"功能,包含:</p>
<ul>
<li>列表展示</li>
<li>添加待办</li>
<li>标记完成</li>
<li>删除待办</li>
<li>云端同步</li>
</ul>
<p><strong>开发流程:</strong></p>
<h4 data-id="heading-28">Step 1: 需求分析(让 AI 帮你规划)</h4>
<pre><code class="hljs language-diff" lang="diff">你: 我要做一个待办事项功能,帮我规划一下技术方案

AI: 好的!我建议:

前端:
<span class="hljs-deletion">- 页面组件: TodoList.tsx, TodoItem.tsx, AddTodo.tsx</span>
<span class="hljs-deletion">- 状态管理: 使用React Hooks (useState, useEffect)</span>
<span class="hljs-deletion">- 样式: Tailwind CSS</span>

后端:
<span class="hljs-deletion">- 云数据库集合: todos</span>
  - _id: 自动生成
  - content: string (待办内容)
  - completed: boolean
  - createdAt: timestamp
<span class="hljs-deletion">- 云函数: getTodos, addTodo, updateTodo, deleteTodo</span>

需要我帮你实现吗?
</code></pre>
<h4 data-id="heading-29">Step 2: UI 设计(用 understand_image)</h4>
<p>如果你有设计稿:</p>
<pre><code class="hljs language-diff" lang="diff">你: [粘贴设计稿截图] 帮我分析这个待办列表的设计,用Taro + Tailwind实现

AI: 我看到的设计包括:
<span class="hljs-deletion">- 顶部有一个输入框和添加按钮</span>
<span class="hljs-deletion">- 列表项左边是圆形checkbox</span>
<span class="hljs-deletion">- 中间是待办文字,完成的文字有删除线</span>
<span class="hljs-deletion">- 右边是删除按钮</span>
<span class="hljs-deletion">- 整体使用卡片布局,圆角+阴影</span>

[生成代码...]
</code></pre>
<p>如果没有设计稿:</p>
<pre><code class="hljs language-diff" lang="diff">你: 帮我设计一个现代风格的待办列表UI,使用Tailwind CSS

AI: 好的,我会采用:
<span class="hljs-deletion">- 渐变背景</span>
<span class="hljs-deletion">- 毛玻璃效果的卡片</span>
<span class="hljs-deletion">- 动画过渡效果</span>
<span class="hljs-deletion">- 微交互反馈</span>

[生成代码...]
</code></pre>
<h4 data-id="heading-30">Step 3: 实现前端</h4>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-comment">// components/TodoList.tsx</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">View</span>, <span class="hljs-title class_">Text</span>, <span class="hljs-title class_">Input</span>, <span class="hljs-title class_">Button</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@tarojs/components'</span>
<span class="hljs-keyword">import</span> { useState, useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Taro</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'@tarojs/taro'</span>

interface <span class="hljs-title class_">Todo</span> {
  <span class="hljs-attr">_id</span>: string
  <span class="hljs-attr">content</span>: string
  <span class="hljs-attr">completed</span>: boolean
  <span class="hljs-attr">createdAt</span>: number
}

<span class="hljs-keyword">const</span> <span class="hljs-title function_">TodoList</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-keyword">const</span> [todos, setTodos] = useState&lt;<span class="hljs-title class_">Todo</span>[]&gt;([])
  <span class="hljs-keyword">const</span> [input, setInput] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">''</span>)
  <span class="hljs-keyword">const</span> [loading, setLoading] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>)

  <span class="hljs-comment">// 加载待办列表</span>
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-title function_">loadTodos</span>()
  }, [])

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">loadTodos</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"/>) =&gt; {
    <span class="hljs-title function_">setLoading</span>(<span class="hljs-literal">true</span>)
    <span class="hljs-keyword">try</span> {
      <span class="hljs-comment">// 调用云函数</span>
      <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Taro</span>.<span class="hljs-property">cloud</span>.<span class="hljs-title function_">callFunction</span>({
        <span class="hljs-attr">name</span>: <span class="hljs-string">'getTodos'</span>
      })
      <span class="hljs-title function_">setTodos</span>(res.<span class="hljs-property">result</span>.<span class="hljs-property">data</span>)
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-title class_">Taro</span>.<span class="hljs-title function_">showToast</span>({
        <span class="hljs-attr">title</span>: <span class="hljs-string">'加载失败'</span>,
        <span class="hljs-attr">icon</span>: <span class="hljs-string">'none'</span>
      })
    } <span class="hljs-keyword">finally</span> {
      <span class="hljs-title function_">setLoading</span>(<span class="hljs-literal">false</span>)
    }
  }

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">addTodo</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"/>) =&gt; {
    <span class="hljs-keyword">if</span> (!input.<span class="hljs-title function_">trim</span>()) <span class="hljs-keyword">return</span>

    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">await</span> <span class="hljs-title class_">Taro</span>.<span class="hljs-property">cloud</span>.<span class="hljs-title function_">callFunction</span>({
        <span class="hljs-attr">name</span>: <span class="hljs-string">'addTodo'</span>,
        <span class="hljs-attr">data</span>: { <span class="hljs-attr">content</span>: input }
      })
      <span class="hljs-title function_">setInput</span>(<span class="hljs-string">''</span>)
      <span class="hljs-title function_">loadTodos</span>()
      <span class="hljs-title class_">Taro</span>.<span class="hljs-title function_">showToast</span>({
        <span class="hljs-attr">title</span>: <span class="hljs-string">'添加成功'</span>,
        <span class="hljs-attr">icon</span>: <span class="hljs-string">'success'</span>
      })
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-title class_">Taro</span>.<span class="hljs-title function_">showToast</span>({
        <span class="hljs-attr">title</span>: <span class="hljs-string">'添加失败'</span>,
        <span class="hljs-attr">icon</span>: <span class="hljs-string">'none'</span>
      })
    }
  }

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">toggleTodo</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">id: string, completed: boolean</span>) =&gt; {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">await</span> <span class="hljs-title class_">Taro</span>.<span class="hljs-property">cloud</span>.<span class="hljs-title function_">callFunction</span>({
        <span class="hljs-attr">name</span>: <span class="hljs-string">'updateTodo'</span>,
        <span class="hljs-attr">data</span>: { id, <span class="hljs-attr">completed</span>: !completed }
      })
      <span class="hljs-title function_">loadTodos</span>()
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-title class_">Taro</span>.<span class="hljs-title function_">showToast</span>({
        <span class="hljs-attr">title</span>: <span class="hljs-string">'更新失败'</span>,
        <span class="hljs-attr">icon</span>: <span class="hljs-string">'none'</span>
      })
    }
  }

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">deleteTodo</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">id: string</span>) =&gt; {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">await</span> <span class="hljs-title class_">Taro</span>.<span class="hljs-title function_">showModal</span>({
        <span class="hljs-attr">title</span>: <span class="hljs-string">'确认删除'</span>,
        <span class="hljs-attr">content</span>: <span class="hljs-string">'确定要删除这条待办吗?'</span>
      })

      <span class="hljs-keyword">await</span> <span class="hljs-title class_">Taro</span>.<span class="hljs-property">cloud</span>.<span class="hljs-title function_">callFunction</span>({
        <span class="hljs-attr">name</span>: <span class="hljs-string">'deleteTodo'</span>,
        <span class="hljs-attr">data</span>: { id }
      })
      <span class="hljs-title function_">loadTodos</span>()
      <span class="hljs-title class_">Taro</span>.<span class="hljs-title function_">showToast</span>({
        <span class="hljs-attr">title</span>: <span class="hljs-string">'删除成功'</span>,
        <span class="hljs-attr">icon</span>: <span class="hljs-string">'success'</span>
      })
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-comment">// 用户取消或删除失败</span>
    }
  }

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"min-h-screen bg-gradient-to-br from-blue-50 to-purple-50 p-4"</span>&gt;</span>
      {/* 标题 */}
      <span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"text-center mb-6"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">Text</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"text-3xl font-bold bg-gradient-to-r from-blue-600 to-purple-600 bg-clip-text text-transparent"</span>&gt;</span>
          我的待办
        <span class="hljs-tag">&lt;/<span class="hljs-name">Text</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span>

      {/* 添加待办 */}
      <span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"bg-white rounded-2xl shadow-lg p-4 mb-4"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"flex items-center space-x-2"</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">Input</span>
            <span class="hljs-attr">className</span>=<span class="hljs-string">"flex-1 px-4 py-2 bg-gray-100 rounded-full"</span>
            <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"添加新待办..."</span>
            <span class="hljs-attr">value</span>=<span class="hljs-string">{input}</span>
            <span class="hljs-attr">onInput</span>=<span class="hljs-string">{(e)</span> =&gt;</span> setInput(e.detail.value)}
          /&gt;
          <span class="hljs-tag">&lt;<span class="hljs-name">Button</span>
            <span class="hljs-attr">className</span>=<span class="hljs-string">"bg-blue-500 text-white px-6 py-2 rounded-full"</span>
            <span class="hljs-attr">onClick</span>=<span class="hljs-string">{addTodo}</span>
          &gt;</span>
            添加
          <span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span>

      {/* 待办列表 */}
      {loading ? (
        <span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"text-center py-8"</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">Text</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"text-gray-500"</span>&gt;</span>加载中...<span class="hljs-tag">&lt;/<span class="hljs-name">Text</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span>
      ) : todos.length === 0 ? (
        <span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"text-center py-8"</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">Text</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"text-gray-500"</span>&gt;</span>暂无待办事项<span class="hljs-tag">&lt;/<span class="hljs-name">Text</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span>
      ) : (
        <span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"space-y-2"</span>&gt;</span>
          {todos.map(todo =&gt; (
            <span class="hljs-tag">&lt;<span class="hljs-name">View</span>
              <span class="hljs-attr">key</span>=<span class="hljs-string">{todo._id}</span>
              <span class="hljs-attr">className</span>=<span class="hljs-string">"bg-white rounded-xl shadow p-4 flex items-center"</span>
            &gt;</span>
              {/* Checkbox */}
              <span class="hljs-tag">&lt;<span class="hljs-name">View</span>
                <span class="hljs-attr">className</span>=<span class="hljs-string">{</span>`<span class="hljs-attr">w-6</span> <span class="hljs-attr">h-6</span> <span class="hljs-attr">rounded-full</span> <span class="hljs-attr">border-2</span> <span class="hljs-attr">mr-3</span> <span class="hljs-attr">flex</span> <span class="hljs-attr">items-center</span> <span class="hljs-attr">justify-center</span> ${
                  <span class="hljs-attr">todo.completed</span>
                    ? '<span class="hljs-attr">bg-blue-500</span> <span class="hljs-attr">border-blue-500</span>'
                    <span class="hljs-attr">:</span> '<span class="hljs-attr">border-gray-300</span>'
                }`}
                <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> toggleTodo(todo._id, todo.completed)}
              &gt;
                {todo.completed &amp;&amp; (
                  <span class="hljs-tag">&lt;<span class="hljs-name">Text</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"text-white text-sm"</span>&gt;</span>✓<span class="hljs-tag">&lt;/<span class="hljs-name">Text</span>&gt;</span>
                )}
              <span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span>

              {/* 内容 */}
              <span class="hljs-tag">&lt;<span class="hljs-name">Text</span>
                <span class="hljs-attr">className</span>=<span class="hljs-string">{</span>`<span class="hljs-attr">flex-1</span> ${
                  <span class="hljs-attr">todo.completed</span>
                    ? '<span class="hljs-attr">line-through</span> <span class="hljs-attr">text-gray-400</span>'
                    <span class="hljs-attr">:</span> '<span class="hljs-attr">text-gray-800</span>'
                }`}
              &gt;</span>
                {todo.content}
              <span class="hljs-tag">&lt;/<span class="hljs-name">Text</span>&gt;</span>

              {/* 删除按钮 */}
              <span class="hljs-tag">&lt;<span class="hljs-name">View</span>
                <span class="hljs-attr">className</span>=<span class="hljs-string">"w-8 h-8 bg-red-100 rounded-full flex items-center justify-center"</span>
                <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> deleteTodo(todo._id)}
              &gt;
                <span class="hljs-tag">&lt;<span class="hljs-name">Text</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"text-red-500 text-sm"</span>&gt;</span>✕<span class="hljs-tag">&lt;/<span class="hljs-name">Text</span>&gt;</span>
              <span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span>
          ))}
        <span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span>
      )}
    <span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span></span>
  )
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">TodoList</span>
</code></pre>
<h4 data-id="heading-31">Step 4: 实现云函数(让 CloudBase MCP 帮你)</h4>
<pre><code class="hljs language-ini" lang="ini">你: 帮我创建云函数getTodos,查询todos集合的所有数据,按创建时间倒序排列

AI: <span class="hljs-section">[自动调用CloudBase MCP创建云函数]</span>

云函数已创建! 代码如下:

<span class="hljs-section">[云函数代码...]</span>

需要我帮你部署吗?
</code></pre>
<h4 data-id="heading-32">Step 5: 调试问题</h4>
<p>如果遇到错误:</p>
<pre><code class="hljs language-makefile" lang="makefile"><span class="hljs-section">你: 调用addTodo云函数时报错: permission denied</span>

<span class="hljs-section">AI: 让我查看一下日志... [调用CloudBase MCP]</span>

<span class="hljs-section">分析结果:</span>
- 错误原因: 云数据库安全规则限制了写入权限
- 解决方案: 需要在云开发控制台配置安全规则

<span class="hljs-section">我可以帮你生成安全规则配置:</span>

{
  <span class="hljs-string">"read"</span>: true,
  <span class="hljs-string">"write"</span>: <span class="hljs-string">"auth.uid != null"</span>  // 仅登录用户可写入
}

<span class="hljs-section">或者如果是开发测试阶段,可以临时设置为:</span>

{
  <span class="hljs-string">"read"</span>: true,
  <span class="hljs-string">"write"</span>: true
}
</code></pre>
<h3 data-id="heading-33">实践 2：避免常见误区</h3>
<h4 data-id="heading-34">误区 1：过度依赖 AI,不理解原理</h4>
<p><strong>❌ 错误做法:</strong></p>
<pre><code class="hljs language-makefile" lang="makefile"><span class="hljs-section">你: 帮我写一个商城小程序</span>
<span class="hljs-section">AI: [生成2000行代码]</span>
<span class="hljs-section">你: [直接复制粘贴]</span>
</code></pre>
<p><strong>✅ 正确做法:</strong></p>
<pre><code class="hljs language-makefile" lang="makefile"><span class="hljs-section">你: 我要做一个商城小程序,先帮我规划架构</span>

<span class="hljs-section">AI: [给出技术方案]</span>

<span class="hljs-section">你: 为什么选择这个方案?有什么优缺点?</span>

<span class="hljs-section">AI: [详细解释]</span>

<span class="hljs-section">你: 好的,那我们先从首页开始,你能给我讲解一下首页的实现思路吗?</span>

<span class="hljs-section">AI: [讲解思路]</span>

<span class="hljs-section">你: 明白了,那现在帮我实现首页</span>
</code></pre>
<p><strong>关键点:</strong></p>
<ul>
<li>先理解,后实现</li>
<li>分模块开发,不要一次生成所有代码</li>
<li>让 AI 解释为什么这样写</li>
</ul>
<h4 data-id="heading-35">误区 2：忽略项目规范</h4>
<p><strong>❌ 错误做法:</strong></p>
<p>每个功能都是独立开发,没有统一规范:</p>
<ul>
<li>A 功能用 class 组件</li>
<li>B 功能用 function 组件</li>
<li>C 功能样式写在 style 里</li>
<li>D 功能使用 Tailwind</li>
</ul>
<p><strong>✅ 正确做法:</strong></p>
<p>建立<code>.cursorrules</code>规范,所有代码风格统一:</p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section"># 必须使用 Function Component + Hooks</span>

<span class="hljs-section"># 必须使用 TypeScript</span>

<span class="hljs-section"># 样式优先使用 Tailwind CSS</span>

<span class="hljs-section"># 组件命名使用 PascalCase</span>

<span class="hljs-section"># 文件命名使用 camelCase</span>
</code></pre>
<h4 data-id="heading-36">误区 3：不做代码审查</h4>
<p><strong>❌ 错误做法:</strong></p>
<p>AI 生成代码后直接使用,不检查:</p>
<ul>
<li>可能有性能问题</li>
<li>可能有安全隐患</li>
<li>可能不符合最佳实践</li>
</ul>
<p><strong>✅ 正确做法:</strong></p>
<p>让 AI 做代码审查:</p>
<pre><code class="hljs language-markdown" lang="markdown">你: 帮我审查这段代码,重点关注:
<span class="hljs-bullet">1.</span> 性能问题
<span class="hljs-bullet">2.</span> 安全隐患
<span class="hljs-bullet">3.</span> 最佳实践
<span class="hljs-bullet">4.</span> 可维护性

[粘贴代码]

AI: 发现以下问题:

<span class="hljs-bullet">1.</span> 性能问题:
<span class="hljs-bullet">   -</span> useEffect没有依赖项,会导致无限循环
<span class="hljs-bullet">   -</span> 建议添加依赖数组

<span class="hljs-bullet">2.</span> 安全问题:
<span class="hljs-bullet">   -</span> 用户输入没有做XSS防护
<span class="hljs-bullet">   -</span> 建议使用DOMPurify库

<span class="hljs-bullet">3.</span> 最佳实践:
<span class="hljs-bullet">   -</span> 建议使用useCallback优化函数
<span class="hljs-bullet">   -</span> 建议使用useMemo优化计算

改进后的代码:
[给出改进方案]
</code></pre>
<h4 data-id="heading-37">误区 4：滥用 MCP 工具</h4>
<p><strong>❌ 错误做法:</strong></p>
<p>每次都让 AI 搜索,即使是已知问题:</p>
<pre><code class="hljs language-ini" lang="ini">你: Taro怎么调用微信API?
<span class="hljs-section">[触发web_search]</span>

你: Taro怎么配置路由?
<span class="hljs-section">[又触发web_search]</span>

你: Taro怎么使用生命周期?
<span class="hljs-section">[再次web_search]</span>
</code></pre>
<p>这样做的问题:</p>
<ul>
<li>浪费搜索次数(可能有配额限制)</li>
<li>增加响应时间</li>
<li>降低开发效率</li>
</ul>
<p><strong>✅ 正确做法:</strong></p>
<p>建立知识库,把常用信息整理到<code>.cursorrules</code>:</p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section"># Taro 常用 API 速查</span>

<span class="hljs-section">## 页面导航</span>

Taro.navigateTo({ url: '/pages/index/index' })

<span class="hljs-section">## 微信 API 调用</span>

Taro.getUserInfo()
Taro.chooseImage()
Taro.uploadFile()

<span class="hljs-section">## 生命周期</span>

useEffect(() =&gt; {}, []) // componentDidMount
useEffect(() =&gt; () =&gt; {}, []) // componentWillUnmount
</code></pre>
<p><strong>什么时候使用 web_search:</strong></p>
<ul>
<li>遇到新的 bug 或错误</li>
<li>查询最新的 API 变化</li>
<li>寻找特定问题的社区解决方案</li>
</ul>
<p><strong>什么时候不需要:</strong></p>
<ul>
<li>基础概念和语法</li>
<li>项目已有的代码模式</li>
<li>文档中明确说明的内容</li>
</ul>
<h3 data-id="heading-38">实践 3：建立高效的开发流程</h3>
<p><strong>标准开发流程:</strong></p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-bullet">1.</span> 需求分析 (5分钟)
   └─ 让AI帮你分析需求,拆分任务

<span class="hljs-bullet">2.</span> 技术设计 (10分钟)
   └─ 确定技术方案,数据结构,接口定义

<span class="hljs-bullet">3.</span> UI设计/还原 (15分钟)
   ├─ 有设计稿: 用understand<span class="hljs-emphasis">_image分析
   └─ 无设计稿: 让AI生成现代化UI

4. 前端开发 (30分钟)
   ├─ 让AI生成组件骨架
   ├─ 补充业务逻辑
   └─ 添加交互效果

5. 后端开发 (20分钟)
   ├─ 用CloudBase MCP创建云函数
   ├─ 配置数据库规则
   └─ 部署并测试

6. 联调测试 (15分钟)
   ├─ 发现问题用web_</span>search搜索
   ├─ 用CloudBase MCP查看日志
   └─ 快速定位和修复

<span class="hljs-bullet">7.</span> 代码审查 (10分钟)
   ├─ 让AI审查代码质量
   ├─ 优化性能和安全
   └─ 统一代码风格

总计: 约1-2小时完成一个完整功能
</code></pre>
<p><strong>对比传统开发:</strong></p>
<pre><code class="hljs language-markdown" lang="markdown">传统开发流程:

<span class="hljs-bullet">1.</span> 需求分析 (30分钟)
<span class="hljs-bullet">2.</span> 查阅文档 (1小时)
<span class="hljs-bullet">3.</span> UI设计/还原 (2小时)
<span class="hljs-bullet">4.</span> 前端开发 (3小时)
<span class="hljs-bullet">5.</span> 后端开发 (2小时)
<span class="hljs-bullet">6.</span> 联调测试 (2小时)
   └─ 遇到问题反复搜索,试错
<span class="hljs-bullet">7.</span> 代码审查 (1小时)

总计: 1-2天
</code></pre>
<p><strong>效率提升:</strong> 10-15 倍 🚀</p>
<h2 data-id="heading-39">🔥 进阶技巧：成为高手的秘诀</h2>
<h3 data-id="heading-40">高手技巧 1：自定义 MCP 工具</h3>
<p>如果你的项目有特殊需求,可以开发自己的 MCP 服务器。</p>
<p><strong>示例场景:</strong> 你有一个内部 API 文档系统,希望 AI 能直接查询。</p>
<p><strong>解决方案:</strong> 创建一个 MCP 服务器,暴露<code>query_docs</code>工具:</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// docs-mcp-server.js</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Server</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@modelcontextprotocol/sdk/server/index.js'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">StdioServerTransport</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@modelcontextprotocol/sdk/server/stdio.js'</span>;

<span class="hljs-keyword">const</span> server = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>({
  <span class="hljs-attr">name</span>: <span class="hljs-string">'docs-server'</span>,
  <span class="hljs-attr">version</span>: <span class="hljs-string">'1.0.0'</span>
}, {
  <span class="hljs-attr">capabilities</span>: {
    <span class="hljs-attr">tools</span>: {}
  }
});

<span class="hljs-comment">// 注册工具</span>
server.<span class="hljs-title function_">setRequestHandler</span>(<span class="hljs-string">'tools/list'</span>, <span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">tools</span>: [{
      <span class="hljs-attr">name</span>: <span class="hljs-string">'query_docs'</span>,
      <span class="hljs-attr">description</span>: <span class="hljs-string">'查询内部API文档'</span>,
      <span class="hljs-attr">inputSchema</span>: {
        <span class="hljs-attr">type</span>: <span class="hljs-string">'object'</span>,
        <span class="hljs-attr">properties</span>: {
          <span class="hljs-attr">keyword</span>: {
            <span class="hljs-attr">type</span>: <span class="hljs-string">'string'</span>,
            <span class="hljs-attr">description</span>: <span class="hljs-string">'搜索关键词'</span>
          }
        }
      }
    }]
  };
});

<span class="hljs-comment">// 实现工具逻辑</span>
server.<span class="hljs-title function_">setRequestHandler</span>(<span class="hljs-string">'tools/call'</span>, <span class="hljs-keyword">async</span> (request) =&gt; {
  <span class="hljs-keyword">if</span> (request.<span class="hljs-property">params</span>.<span class="hljs-property">name</span> === <span class="hljs-string">'query_docs'</span>) {
    <span class="hljs-keyword">const</span> { keyword } = request.<span class="hljs-property">params</span>.<span class="hljs-property">arguments</span>;
    <span class="hljs-comment">// 查询你的文档系统</span>
    <span class="hljs-keyword">const</span> results = <span class="hljs-keyword">await</span> <span class="hljs-title function_">queryInternalDocs</span>(keyword);
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">content</span>: [{
        <span class="hljs-attr">type</span>: <span class="hljs-string">'text'</span>,
        <span class="hljs-attr">text</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(results)
      }]
    };
  }
});

<span class="hljs-comment">// 启动服务器</span>
<span class="hljs-keyword">const</span> transport = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StdioServerTransport</span>();
<span class="hljs-keyword">await</span> server.<span class="hljs-title function_">connect</span>(transport);
</code></pre>
<p><strong>配置到 Cursor:</strong></p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"mcpServers"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"docs"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"command"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"node"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"args"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">"/path/to/docs-mcp-server.js"</span><span class="hljs-punctuation">]</span>
    <span class="hljs-punctuation">}</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<h3 data-id="heading-41">高手技巧 2：批量生成页面</h3>
<p>如果你的项目有大量相似页面,可以让 AI 批量生成:</p>
<pre><code class="hljs language-markdown" lang="markdown">你: 我有一个商城项目,需要生成这些页面:
<span class="hljs-bullet">-</span> 商品列表
<span class="hljs-bullet">-</span> 商品详情
<span class="hljs-bullet">-</span> 购物车
<span class="hljs-bullet">-</span> 订单列表
<span class="hljs-bullet">-</span> 订单详情
<span class="hljs-bullet">-</span> 个人中心

它们的UI风格相似,都使用卡片布局+Tailwind CSS。
帮我生成页面骨架和路由配置。

AI: 好的,我会为你生成:
<span class="hljs-bullet">1.</span> 6个页面组件
<span class="hljs-bullet">2.</span> 统一的路由配置
<span class="hljs-bullet">3.</span> 通用的布局组件
<span class="hljs-bullet">4.</span> 共享的样式定义

[开始生成...]
</code></pre>
<h3 data-id="heading-42">高手技巧 3：自动化测试</h3>
<p>让 AI 帮你写测试用例:</p>
<pre><code class="hljs language-javascript" lang="javascript">你: 为<span class="hljs-title class_">TodoList</span>组件写单元测试,覆盖:
<span class="hljs-number">1.</span> 渲染测试
<span class="hljs-number">2.</span> 添加待办
<span class="hljs-number">3.</span> 完成待办
<span class="hljs-number">4.</span> 删除待办
<span class="hljs-number">5.</span> 边界情况(空输入,网络错误等)

<span class="hljs-attr">AI</span>: [生成测试代码]

<span class="hljs-keyword">import</span> { render, fireEvent, waitFor } <span class="hljs-keyword">from</span> <span class="hljs-string">'@testing-library/react'</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">TodoList</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./TodoList'</span>

<span class="hljs-title function_">describe</span>(<span class="hljs-string">'TodoList'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-title function_">it</span>(<span class="hljs-string">'应该正确渲染'</span>, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> { getByText } = <span class="hljs-title function_">render</span>(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">TodoList</span> /&gt;</span></span>)
    <span class="hljs-title function_">expect</span>(<span class="hljs-title function_">getByText</span>(<span class="hljs-string">'我的待办'</span>)).<span class="hljs-title function_">toBeInTheDocument</span>()
  })

  <span class="hljs-title function_">it</span>(<span class="hljs-string">'应该能添加待办'</span>, <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-comment">// ... 测试代码</span>
  })

  <span class="hljs-comment">// ... 更多测试</span>
})
</code></pre>
<h3 data-id="heading-43">高手技巧 4：性能优化</h3>
<p>让 AI 分析性能瓶颈:</p>
<pre><code class="hljs language-makefile" lang="makefile"><span class="hljs-section">你: 我的待办列表页面加载很慢,帮我分析性能问题</span>

<span class="hljs-section">AI: 让我看看代码...</span>

<span class="hljs-section">发现以下问题:</span>

1. useEffect依赖项设置不当,导致频繁重新渲染
2. 列表项没有使用React.memo优化
3. 云函数查询没有做缓存

<span class="hljs-section">建议优化方案:</span>
[给出详细的优化代码]
</code></pre>
<h2 data-id="heading-44">📚 资源推荐</h2>
<h3 data-id="heading-45">必读文档</h3>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.taro.zone" title="https://docs.taro.zone" target="_blank" ref="nofollow noopener noreferrer">Taro 官方文档</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Ftailwindcss.com" title="https://tailwindcss.com" target="_blank" ref="nofollow noopener noreferrer">Tailwind CSS 文档</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fmodelcontextprotocol.io" title="https://modelcontextprotocol.io" target="_blank" ref="nofollow noopener noreferrer">MCP 官方文档</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.cloudbase.net" title="https://docs.cloudbase.net" target="_blank" ref="nofollow noopener noreferrer">CloudBase 文档</a></li>
</ul>
<h3 data-id="heading-46">社区资源</h3>
<ul>
<li>Taro GitHub: <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FNervJS%2Ftaro" target="_blank" title="https://github.com/NervJS/taro" ref="nofollow noopener noreferrer">github.com/NervJS/taro</a></li>
<li>Taro 物料市场: <a href="https://link.juejin.cn?target=https%3A%2F%2Ftaro-ext.jd.com" target="_blank" title="https://taro-ext.jd.com" ref="nofollow noopener noreferrer">taro-ext.jd.com</a></li>
<li>MCP Servers: <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmodelcontextprotocol%2Fservers" target="_blank" title="https://github.com/modelcontextprotocol/servers" ref="nofollow noopener noreferrer">github.com/modelcontex…</a></li>
</ul>
<h3 data-id="heading-47">推荐工具</h3>
<ul>
<li><strong>Cursor</strong>: AI 编程 IDE</li>
<li><strong>MiniMax Coding Plan</strong>: web_search + understand_image</li>
<li><strong>CloudBase</strong>: 腾讯云开发平台</li>
<li><strong>Tailwind CSS IntelliSense</strong>: VS Code/Cursor 插件</li>
</ul>
<h2 data-id="heading-48">🎉 结语</h2>
<p>使用 MiniMax + Cursor + Taro 的组合,你会发现开发小程序不再是痛苦的过程,而是充满创造力的旅程:</p>
<ul>
<li><strong>不再害怕遇到 bug</strong> - web_search 帮你找到解决方案</li>
<li><strong>不再担心还原设计稿</strong> - understand_image 一键分析</li>
<li><strong>不再头疼调试云函数</strong> - CloudBase MCP 直接查看日志</li>
<li><strong>不再纠结样式实现</strong> - Tailwind CSS 所见即所得</li>
</ul>
<p>记住:<strong>AI 是你的助手,不是替代品。</strong></p>
<p>最好的开发模式是:<strong>AI 处理重复劳动,你专注创造价值。</strong></p>
<p>现在,打开 Cursor,开始你的 AI 辅助开发之旅吧! 🚀</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[第3章 Nest.js拦截器]]></title>    <link>https://juejin.cn/post/7589935326782898210</link>    <guid>https://juejin.cn/post/7589935326782898210</guid>    <pubDate>2026-01-02T04:30:04.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7589935326782898210" data-draft-id="7590071125397995560" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="第3章 Nest.js拦截器"/> <meta itemprop="keywords" content="前端,NestJS,AI编程"/> <meta itemprop="datePublished" content="2026-01-02T04:30:04.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="XiaoYu2002"/> <meta itemprop="url" content="https://juejin.cn/user/251124329220663"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            第3章 Nest.js拦截器
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/251124329220663/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    XiaoYu2002
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-02T04:30:04.000Z" title="Fri Jan 02 2026 04:30:04 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-02
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读13分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;color:rgba(46,36,36,.87);overflow-x:hidden}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{margin-bottom:5px;font-size:30px;font-weight:500}.markdown-body h1:before{content:"#";margin-right:10px;color:#1976d2}.markdown-body h2{font-size:28px;font-weight:400;border-left:5px solid #454545;margin-top:20px;padding-left:10px;transition:all .3s ease-in-out}.markdown-body h2:hover{border-color:#1976d2}.markdown-body h3{font-size:24px;font-weight:400;margin-top:15px;padding-bottom:0}.markdown-body h4{font-size:20px;font-weight:500}.markdown-body h5{font-size:16px}.markdown-body h6{margin-top:5px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body h2:first-letter,.markdown-body h3:first-letter,.markdown-body p:first-letter{text-transform:capitalize}.markdown-body em{text-emphasis:dot;text-emphasis-position:under}.markdown-body img{display:block;margin:0 auto!important;max-width:100%;border-radius:2px;box-shadow:0 2px 4px -1px rgba(0,0,0,.2),0 4px 5px 0 rgba(0,0,0,.14),0 1px 10px 0 rgba(0,0,0,.12)!important}.markdown-body hr{position:relative;width:98%;height:1px;border:none;margin-top:32px;margin-bottom:32px;background-image:linear-gradient(90deg,#ddd,#999,#ddd);overflow:visible}.markdown-body hr:after{content:"";position:absolute;margin:auto;left:0;right:0;bottom:0;top:0;display:inline-block;width:60px;height:20px;background:#fff;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAgCAYAAABgrToAAAADoklEQVRYR82XTYgcRRTHf2933Q1RjAa9eFO8JHoJ8RQVBQ2iBwXBET0YEUTXNVmNQtTpmeqaWV0XNRq/o4KoECSCEPSg4CF+BYUkIIiCoCJCPIhC/Ihh2Z0nVV27VnZnenumW9i6ddV7//frV69fVQurfMgq56NawFTPAU6QyomqXrw6wIZeyhCPebA5buNR+akKyGoAjd6BshthnYdSjqNcRVuOlIUsD2j0SuA94IwuMHdh5ZUykOUBXfSGbmKI54EtAeYIHSZoy5dl4JxvNYBOKdW1KE8BQ8AkVk6WhasWsAiN0TX9gveXQaPP+Aytpc4u+bMI06JNohsYYYYOR2lJWtS3OKDRfcAtQfgDoI6Vo4UCGb0OmAEuDvZvYmVbEd/igC3dzDz7gQu8sPA9kJDK27mBmjqBeLjTg90PDFOjWawFFQd06kZHEfaj3LAIpTRpSXsZ5E06zEYP9sDimnAApYaV2SLZG/wjMeqAkijwW4xQJ5Gf/ZzRC8OW3hiBTGGlURRswW55Bh/Ssxljrwew8l1PQaM14GngvGDzBUKdDsMeTtgU5o8B92PFlUf3YXUrHa7Fys6lBqcCGnX15YQ2A18FyPd7Crd1A3M8C1wdbH4DD3hWeP6IEXbQkG97ajR1HPFnuPP5jFFq1OWX7hl8WM9l1AO648uNfwLk7tytMeogty+xeQ4rO3r6bdcx1nuwOGsHmaXGtPzae4uzGnLH1kQkvpdZGrHjssBZJrL+pqS05KWc8tgITAPXRzYvYOXe/C2OV43eDcRBDtIhoS2f9wzc0Cv8Wls+zoFzUC5zF0U241h5uZtPfptp6OUM8wbK+cH5GEpCS17P3fJei0Z3+npTxryJ8CPzbKMtn/ZyWbkPGl0PuFPkmkjkcb4h4R2ZLwRq1H0ALmvjkf2HwK1Y+T1PY2XABe/sHJ6MxN5lnoSpnC/UGbsTaI5phK2R7x6s3Ffk5YoDOrWm3onwJHBmEP86bPmBrsGaenNoIdnxCH+gPEhLXi0Cl1VBvyPVLSh7gEuC62yAfOIUqabWEaaiucMIk6RyqJ+Q/QM69V26jjW86Gvov/EaoyT8zRCn+Xq7PVrbx0nuYUaO9wM3WAbjCE1NEUw09Um4UV+2OKfYfu5/S19gsAzGKqm6LE5FrShbdS0ku465DjDwKA/oQht19ejqbaEVuRbiLhuHByYLjtUAZpDutzP7cYdHsPJXWbjyNVgFwQoa1WXwf4Jd9YD/Ap80+yE7+u9aAAAAAElFTkSuQmCC);background-repeat:no-repeat;background-size:auto 100%;background-position-x:center}.markdown-body code{font-weight:900;word-break:break-word;border-radius:2px;overflow-x:auto;font-size:.87em;padding:.065em .4em;background-color:#fbe5e1;color:#c0341d}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75;border-radius:0 4px}.markdown-body pre&gt;code{font-weight:400;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{margin:0 4px;text-decoration:none;color:#027fff;transition:all .3s ease-in-out;padding-bottom:4px;border-bottom:2px solid transparent}.markdown-body a:after{content:"";display:inline-block;width:18px;height:18px;margin-left:4px;vertical-align:middle;background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMiIgaGVpZ2h0PSIyMiI+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIiBzdHJva2U9IiMwMjdGRkYiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCI+PHBhdGggZD0iTTkuODE1IDYuNDQ4bDEuOTM2LTEuOTM2YzEuMzM3LTEuMzM2IDMuNTgtMS4yNTkgNS4wMTMuMTczIDEuNDMyIDEuNDMyIDEuNTEgMy42NzYuMTczIDUuMDEzbC0xLjQ1MiAxLjQ1Mi0uOTY4Ljk2OGMtMS4zMzcgMS4zMzYtMy41ODEgMS4yNTktNS4wMTMtLjE3MyIvPjxwYXRoIGQ9Ik0xMS4yNjcgMTUuMzY3bC0xLjkzNiAxLjkzNmMtMS4zMzYgMS4zMzctMy41OCAxLjI2LTUuMDEyLS4xNzMtMS40MzItMS40MzItMS41MS0zLjY3Ni0uMTczLTUuMDEybDEuNDUyLTEuNDUyLjk2OC0uOTY4YzEuMzM2LTEuMzM3IDMuNTgtMS4yNiA1LjAxMi4xNzMiLz48L2c+PC9zdmc+);background-size:cover;background-repeat:no-repeat}.markdown-body a:hover{border-color:#027fff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body a.footnote-backref:after,.markdown-body a.footnote-ref:after,.markdown-body sup a:after{display:none!important}.markdown-body table{margin:0 auto 10px;font-size:12px;width:auto;max-width:100%;overflow:auto;border:2px solid #c6c6c6}.markdown-body table img{box-shadow:none!important}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body del{color:rgba(0,0,0,.6)}.markdown-body blockquote{position:relative;color:#666;padding:5px 23px 1px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:hsla(0,0%,78.4%,.12);transition:all .2s ease-in-out}.markdown-body blockquote:hover{border-color:#1976d2}.markdown-body blockquote:after,.markdown-body blockquote:before{position:absolute;font-size:24px;font-weight:800;line-height:24px;color:#cbcbcb;opacity:.6}.markdown-body blockquote:before{content:"“";top:4px;left:6px}.markdown-body blockquote:after{content:"”";right:8px;bottom:-8px}.markdown-body blockquote&gt;p,.markdown-body blockquote blockquote{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body details{outline:none;border:none;border-left:4px solid #1976d2;padding-left:10px;margin-left:4px}.markdown-body details summary{cursor:pointer;border:none;outline:none;background:#fff;margin:0 -17px}.markdown-body details summary:hover::-webkit-details-marker{color:#1976d2}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">3.1 拦截器介绍</h2>
<p>Nest.js的拦截器和axios的拦截器是类似的，可以在网络请求处理的前后去执行额外的逻辑。拦截器从字面意思理解就是拦截，假设有流程A-&gt;B，拦截器要做的是A到B的过程中，将内容拦截下来处理后再丢给B，变成了A-&gt;拦截器-&gt;B。</p>
<p>在网络请求的逻辑中，拦截器的拦截位置如下：</p>
<ul>
<li>客户端请求-&gt;拦截器（前置逻辑）-&gt;路由处理器-&gt;拦截器（后置逻辑）-&gt;客户端响应。</li>
</ul>
<p>Nest.js拦截器效果如图3-1所示。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e5f748da79494b1698a97dc2ba327487~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgWGlhb1l1MjAwMg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767933209&amp;x-signature=rjGaBE%2FMUQcYB2xG72DMqOKYs8Q%3D" alt="image-20251212195404071" loading="lazy"/></p>
<p align="center">
 <b> 图3-1 Nest.js拦截器</b>
</p>
<p>Nest.js拦截器主要的用途有以下5点：</p>
<p>（1）统一响应格式：将返回数据包装成统一格式。</p>
<p>（2）日志记录：记录请求耗时、请求参数等信息。</p>
<p>（3）缓存处理：对响应数据进行缓存。</p>
<p>（4）异常映射：转换异常类型。</p>
<p>（5）数据转换：对响应数据进行序列化/转换。</p>
<p>在英语AI项目中，主要使用到第5点数据转换，因此我们主要学习这一点。</p>
<h2 data-id="heading-1">3.2 拦截器创建</h2>
<p>如表1-2所示，可以通过nest g itc interceptor快速创建一个拦截器（interceptor可以替换为任何你想取的拦截器名称）。通过该命令会在src文件夹下创建interceptor文件夹，而interceptor文件夹下存放interceptor.interceptor.ts文件。</p>
<p>根据命令的生成规则，我们知道文件夹和文件的名称取决于我们命令对拦截器的名称，从而生成xxx文件夹和xxx.interceptor.ts文件。并且在这唯一的文件中，会提前生成好对应的Demo示例。</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">//src/interceptor/interceptor.interceptor.ts</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">CallHandler</span>, <span class="hljs-title class_">ExecutionContext</span>, <span class="hljs-title class_">Injectable</span>, <span class="hljs-title class_">NestInterceptor</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Observable</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>;

<span class="hljs-meta">@Injectable</span>()
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InterceptorInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">NestInterceptor</span> {
  <span class="hljs-title function_">intercept</span>(<span class="hljs-attr">context</span>: <span class="hljs-title class_">ExecutionContext</span>, <span class="hljs-attr">next</span>: <span class="hljs-title class_">CallHandler</span>): <span class="hljs-title class_">Observable</span>&lt;<span class="hljs-built_in">any</span>&gt; {
    <span class="hljs-keyword">return</span> next.<span class="hljs-title function_">handle</span>();
  }
}
</code></pre>
<p>拦截器有两种使用方式：</p>
<p>（1）局部使用。</p>
<p>（2）全局使用。</p>
<p>当想局部使用时，例如只想在src文件夹下的user模块使用，我们只需要注册到user模块中。那怎么注册？有3种注册方式，在user.module.ts、user.controller.ts以及user.controller.ts都可以注册，最主要的区别在于局部作用范围不同。Nest.js拦截器局部注册如表3-1所示。</p>
<p align="center">
 <b> 表3-1 Nest.js拦截器局部注册</b>
</p>

































<table><thead><tr><th align="left">注册方式</th><th align="left">作用范围</th><th align="left">代码位置</th><th align="left">优点</th><th align="left">缺点</th></tr></thead><tbody><tr><td align="left"><strong>模块级别</strong></td><td align="left">整个模块所有控制器</td><td align="left">user.module.ts</td><td align="left">统一管理，自动应用到所有路由</td><td align="left">无法灵活排除某些路由</td></tr><tr><td align="left"><strong>控制器级别</strong></td><td align="left">单个控制器所有路由</td><td align="left">user.controller.ts</td><td align="left">控制器粒度控制</td><td align="left">需在每个控制器添加装饰器</td></tr><tr><td align="left"><strong>路由级别</strong></td><td align="left">单个路由方法</td><td align="left">user.controller.ts</td><td align="left">最精细的控制</td><td align="left">代码重复，管理复杂</td></tr></tbody></table>
<p>局部使用的具体代码不演示，可通过AI或者官方文档学习使用。</p>
<h2 data-id="heading-2">3.3 全局拦截器使用</h2>
<p>在英语AI项目中会使用到全局使用，我们这里学习具体如何全局使用。步骤为以下2步：</p>
<p>（1）使用nest g itc &lt;拦截器名称&gt;快速创建一个拦截器。</p>
<p>（2）将拦截器注册到main.ts文件中，即在main.ts文件中导入刚创建的拦截器，并且使用Nest应用程序实例方法useGlobalInterceptors()。</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// main.ts文件</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">NestFactory</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/core'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">AppModule</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./app.module'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">InterceptorInterceptor</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./interceptor/interceptor.interceptor'</span>;
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">bootstrap</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> app = <span class="hljs-keyword">await</span> <span class="hljs-title class_">NestFactory</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">AppModule</span>);
  app.<span class="hljs-title function_">useGlobalInterceptors</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InterceptorInterceptor</span>());
  <span class="hljs-keyword">await</span> app.<span class="hljs-title function_">listen</span>(process.<span class="hljs-property">env</span>.<span class="hljs-property">PORT</span> ?? <span class="hljs-number">3000</span>);
}

<span class="hljs-title function_">bootstrap</span>();
</code></pre>
<p>当然由于InterceptorInterceptor拦截器是一个类，所以我们需要使用new运算符创建拦截器的实例以供使用。到这里，InterceptorInterceptor拦截器就是全局使用，即每一个接口都会经过该拦截器。Nest.js全局注册的官方文档如图3-2所示。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9bd57295aa934803bcb0c3d51f4cb44a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgWGlhb1l1MjAwMg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767933209&amp;x-signature=QeA6K9gERm5GkZoDFg%2B%2Bjw%2BDDQM%3D" alt="image-20251212212343423" loading="lazy"/></p>
<p align="center">
 <b> 图3-2 Nest.js拦截器全局注册</b>
</p>
<p>此时来编写InterceptorInterceptor拦截器内的逻辑，可见引入了来自rxjs的Observable类，rxjs是Nest.js内部自带的，主要用于处理流的，使用频率不高。通常获取数据需要区分同步与异步，同步直接获取，而异步通过Promise的then或者catch方法获取。如果此时有rxjs，就不需要我们去关注获取的数据是同步或者异步的问题，减少心智负担。rxjs会将这些数据统一转成一个数据流，然后通过管道（pipe）去接收，接收到之后可由我们处理该数据格式，无论是通过map遍历处理还是filter过滤等等，最终将处理好的数据格式返回就行。</p>
<p>以上是rxjs的核心理念，除此之外，它还可以同时处理多个异步，而then或者catch方法每次只能处理一个。</p>
<p>像InterceptorInterceptor拦截器中的所返回的next.handle()就是一个Observable（数据流），所以我们需要通过pipe（管道）去接收数据然后使用rxjs的map方法对数据处理之后再返回数据。</p>
<p>我们将原始数据包裹在一个标准响应结构中，添加了时间戳、请求路径、业务状态码、成功标志和自定义消息。这样确保了所有经过此拦截器的HTTP响应都遵循统一的JSON格式，包括 { timestamp, data, path, message, code, success } 等标准化字段，前端可以统一处理和错误追踪。</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// src/interceptor/interceptor.interceptor.ts文件</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">CallHandler</span>, <span class="hljs-title class_">ExecutionContext</span>, <span class="hljs-title class_">Injectable</span>, <span class="hljs-title class_">NestInterceptor</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Observable</span>, map } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Request</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'express'</span>;

<span class="hljs-meta">@Injectable</span>()
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InterceptorInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">NestInterceptor</span> {
  <span class="hljs-title function_">intercept</span>(<span class="hljs-attr">context</span>: <span class="hljs-title class_">ExecutionContext</span>, <span class="hljs-attr">next</span>: <span class="hljs-title class_">CallHandler</span>): <span class="hljs-title class_">Observable</span>&lt;<span class="hljs-built_in">any</span>&gt; {
    <span class="hljs-comment">// 将通用的执行上下文切换到HTTP特定的上下文</span>
    <span class="hljs-keyword">const</span> ctx = context.<span class="hljs-title function_">switchToHttp</span>();
    <span class="hljs-comment">// 获取当前HTTP请求的详细对象，包含了请求方法、URL、请求头、参数、主体等所有信息。</span>
    <span class="hljs-keyword">const</span> request = ctx.<span class="hljs-property">getRequest</span>&lt;<span class="hljs-title class_">Request</span>&gt;();
    <span class="hljs-keyword">return</span> next.<span class="hljs-title function_">handle</span>().<span class="hljs-title function_">pipe</span>(<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> {
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">timestmap</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">toISOString</span>(),
        <span class="hljs-attr">data</span>: data,
        <span class="hljs-attr">path</span>: request.<span class="hljs-property">url</span>,
        <span class="hljs-attr">message</span>: <span class="hljs-string">'success'</span>,<span class="hljs-comment">//业务逻辑自定义</span>
        <span class="hljs-attr">code</span>: <span class="hljs-number">200</span>,<span class="hljs-comment">//业务逻辑自定义</span>
        <span class="hljs-attr">success</span>: <span class="hljs-literal">true</span>,
      };
    }));
  }
}
</code></pre>
<p>此时在浏览器的URL输入<a href="https://link.juejin.cn?target=http%3A%2F%2Flocalhost%3A3000%2Fuser%2F123%25EF%25BC%258C%25E8%25AE%25BF%25E9%2597%25AE%25E5%25B8%25A6%25E5%258F%2582%25E6%2595%25B0%25E7%259A%2584get%25E8%25AF%25B7%25E6%25B1%2582%25EF%25BC%258Cget%25E8%25AF%25B7%25E6%25B1%2582%25E6%258B%25A6%25E6%2588%25AA%25E6%2595%2588%25E6%259E%259C%25E5%25A6%2582%25E5%259B%25BE3-3%25E6%2589%2580%25E7%25A4%25BA%25E3%2580%2582%25E5%259C%25A8%25E8%25BF%2599%25E9%2587%258C%25E4%25BD%2593%25E7%258E%25B0%25E7%259A%2584%25E6%2598%25AF%25EF%25BC%259A%25E8%25B7%25AF%25E7%2594%25B1%25E5%25A4%2584%25E7%2590%2586%25E5%2599%25A8-%253E%25E6%258B%25A6%25E6%2588%25AA%25E5%2599%25A8%25EF%25BC%2588%25E5%2590%258E%25E7%25BD%25AE%25E9%2580%25BB%25E8%25BE%2591%25EF%25BC%2589-%253E%25E5%25AE%25A2%25E6%2588%25B7%25E7%25AB%25AF%25E5%2593%258D%25E5%25BA%2594%25E3%2580%2582" target="_blank" title="http://localhost:3000/user/123%EF%BC%8C%E8%AE%BF%E9%97%AE%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84get%E8%AF%B7%E6%B1%82%EF%BC%8Cget%E8%AF%B7%E6%B1%82%E6%8B%A6%E6%88%AA%E6%95%88%E6%9E%9C%E5%A6%82%E5%9B%BE3-3%E6%89%80%E7%A4%BA%E3%80%82%E5%9C%A8%E8%BF%99%E9%87%8C%E4%BD%93%E7%8E%B0%E7%9A%84%E6%98%AF%EF%BC%9A%E8%B7%AF%E7%94%B1%E5%A4%84%E7%90%86%E5%99%A8-%3E%E6%8B%A6%E6%88%AA%E5%99%A8%EF%BC%88%E5%90%8E%E7%BD%AE%E9%80%BB%E8%BE%91%EF%BC%89-%3E%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%93%8D%E5%BA%94%E3%80%82" ref="nofollow noopener noreferrer">http://localhost:3000/user/123，访问带参数的get请求，get请求拦截效果如图3-3所示。在这里体现的是：路由处理器-&gt;拦截器（后置逻辑）-&gt;客户端响应。</a></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7af11efb75754b48af28e286cbeef74f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgWGlhb1l1MjAwMg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767933209&amp;x-signature=WI8xUv6J%2FmOMBPfLI2WMlHpGmSQ%3D" alt="image-20251212220853053" loading="lazy"/></p>
<p align="center">
 <b> 图3-3 Nest.js全局拦截器-get请求拦截效果</b>
</p>
<p>message和code字段属于业务逻辑的部分，后续完成英语AI项目时，会根据业务实际逻辑去自定义设置。</p>
<h2 data-id="heading-3">3.4 优化全局拦截器</h2>
<p>但此时全局拦截器还有一个很大的Bug，假如接口返回一个很大的数据，我们通过BigInt数据类型去处理返回，那么在通过全局拦截器时就会出现报错情况，全局拦截器处理BigInt类型报错如图3-4所示。</p>
<p><img src="http://tuchuang.xiaoyu2002.cn/picture/image-20251212222211323.png" alt="image-20251212222211323" loading="lazy"/></p>
<p align="center">
 <b> 图3-4 全局拦截器处理BigInt类型报错</b>
</p>
<p>报错是error TS2322: Type 'bigint' is not assignable to type 'string'。即bigint类型无法赋值给string类型，这是很正常的。因为全局拦截器的这些参数都是通过JavaScript标准内置对象JSON.stringify()进行格式化的，而JSON.stringify()是没办法处理BigInt值的。在MDN文档中是这样表述这一异常情况：当尝试去转换 BigInt类型的值会抛出TypeError("BigInt value can't be serialized in JSON")（BigInt 值不能 JSON 序列化）。</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// src/app.service.ts文件</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Injectable</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;

<span class="hljs-meta">@Injectable</span>()
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppService</span> {
  <span class="hljs-title function_">getHello</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">BigInt</span>(<span class="hljs-number">123456789123456789123456789</span>)
  }
}
</code></pre>
<p>所以我们需要针对BigInt类型的值去处理，通过编写transformBigInt方法去单独处理这一情况，主要处理的事情是当遇到BigInt类型的值就将它转成一个字符串。</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">const</span> <span class="hljs-title function_">transformBigInt</span> = (<span class="hljs-params">data: <span class="hljs-built_in">any</span></span>) =&gt; {
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> data === <span class="hljs-string">'bigint'</span>) {
    <span class="hljs-keyword">return</span> data.<span class="hljs-title function_">toString</span>();
  }
  <span class="hljs-keyword">return</span> data;
};
</code></pre>
<p>此时将接口（get请求）返回给用户的data数据放入transformBigInt方法中即可。</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// src/interceptor/interceptor.interceptor.ts文件</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">CallHandler</span>, <span class="hljs-title class_">ExecutionContext</span>, <span class="hljs-title class_">Injectable</span>, <span class="hljs-title class_">NestInterceptor</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Observable</span>, map } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Request</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'express'</span>;

<span class="hljs-keyword">const</span> <span class="hljs-title function_">transformBigInt</span> = (<span class="hljs-params">data: <span class="hljs-built_in">any</span></span>) =&gt; {
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> data === <span class="hljs-string">'bigint'</span>) {
    <span class="hljs-keyword">return</span> data.<span class="hljs-title function_">toString</span>();
  }
  <span class="hljs-keyword">return</span> data;
};

<span class="hljs-meta">@Injectable</span>()
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InterceptorInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">NestInterceptor</span> {
  <span class="hljs-title function_">intercept</span>(<span class="hljs-attr">context</span>: <span class="hljs-title class_">ExecutionContext</span>, <span class="hljs-attr">next</span>: <span class="hljs-title class_">CallHandler</span>): <span class="hljs-title class_">Observable</span>&lt;<span class="hljs-built_in">any</span>&gt; {
    <span class="hljs-keyword">const</span> ctx = context.<span class="hljs-title function_">switchToHttp</span>();
    <span class="hljs-keyword">const</span> request = ctx.<span class="hljs-property">getRequest</span>&lt;<span class="hljs-title class_">Request</span>&gt;();
    <span class="hljs-keyword">return</span> next.<span class="hljs-title function_">handle</span>().<span class="hljs-title function_">pipe</span>(<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> {
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">timestmap</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">toISOString</span>(),
        <span class="hljs-attr">data</span>: <span class="hljs-title function_">transformBigInt</span>(data),
        <span class="hljs-attr">path</span>: request.<span class="hljs-property">url</span>,
        <span class="hljs-attr">message</span>: <span class="hljs-string">'success'</span>,<span class="hljs-comment">//业务逻辑自定义</span>
        <span class="hljs-attr">code</span>: <span class="hljs-number">200</span>,<span class="hljs-comment">//业务逻辑自定义</span>
        <span class="hljs-attr">success</span>: <span class="hljs-literal">true</span>,
      };
    }));
  }
}
</code></pre>
<p>但此时还会报错同样的问题（Type 'bigint' is not assignable to type 'string'），这是很正常的。我们来梳理下流程：</p>
<p>（1）接口返回数据给前端。</p>
<p>（2）全局拦截器拦截接口返回的数据进行处理。</p>
<p>（3）全局处理后的数据返回给前端。</p>
<p>我们已经在全局拦截器中处理好类型转换问题（BigInt转String），如果还有问题，就只能在第一步的接口返回数据给前端的步骤中。前端访问的是接口，而接口是体现形式是路由，路由层从业务层获取数据返回给前端。因此在业务层的数据是BigInt类型，则路由层所拿到的数据也会是BigInt类型。由于Nest.js是强制使用TypeScript的，所以我们需要到app.controller.ts文件中将get默认请求所返回的类型限制从string改成any类型或者string和bigint的联合类型。此时就能正常运行代码。</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// src/app.controller.ts</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Controller</span>, <span class="hljs-title class_">Get</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">AppService</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./app.service'</span>;

<span class="hljs-meta">@Controller</span>()
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppController</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> appService: AppService</span>) { }

  <span class="hljs-meta">@Get</span>()
  <span class="hljs-title function_">getHello</span>(): <span class="hljs-built_in">string</span> | <span class="hljs-built_in">bigint</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">appService</span>.<span class="hljs-title function_">getHello</span>();
  }
}
</code></pre>
<p>出于严谨的考虑，我们需要处理相应的边界判断，假如BigInt类型在数组里，在对象里呢？原有的处理方式就又解析不了了。</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">return</span> [<span class="hljs-title class_">BigInt</span>(<span class="hljs-number">123456789123456789123456789</span>)];
<span class="hljs-keyword">return</span> { <span class="hljs-attr">a</span>: <span class="hljs-title class_">BigInt</span>(<span class="hljs-number">123456789123456789123456789</span>) };
</code></pre>
<p>所以需要进一步强化transformBigInt方法，对数组遍历处理内部可能存在的BigInt类型，而对象则通过Object.entries()静态方法将对象切换成保存键值对的二维数组后，遍历键值对并针对其中的value值处理可能存在的BigInt类型，最后通过Object.fromEntries()静态方法将键值对形式的二维数组重新转换回原始对象。</p>
<ul>
<li>
<p>对象打印效果：{ foo: "bar", baz: 42 }。</p>
</li>
<li>
<p>将可迭代对象切成二维数组：[ ['foo', 'bar'], ['baz', 42] ]。</p>
</li>
</ul>
<p>将对象切成二维数组更方便找到键值对的值并进行遍历操作。</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">const</span> <span class="hljs-title function_">transformBigInt</span> = (<span class="hljs-params">data: <span class="hljs-built_in">any</span></span>) =&gt; {
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> data === <span class="hljs-string">'bigint'</span>) {
    <span class="hljs-keyword">return</span> data.<span class="hljs-title function_">toString</span>();
  }
  <span class="hljs-keyword">if</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(data)){
    <span class="hljs-keyword">return</span> data.<span class="hljs-title function_">map</span>(transformBigInt);
  }
  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> data === <span class="hljs-string">'object'</span> &amp;&amp; data !== <span class="hljs-literal">null</span>){
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">fromEntries</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(data).<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">[key, value]</span>) =&gt;</span> [key, <span class="hljs-title function_">transformBigInt</span>(value)]));
  }
  <span class="hljs-keyword">return</span> data;
};
</code></pre>
<p>做完以上的优化后，我们会发现接口要返回Date日期没办法正常返回给前端了，因为我们把对象全部都处理了，而JavaScript标准内置对象Date的使用是通过new运算符调用的实例对象，实例对象也是对象，也会被transformBigInt方法一并处理，所以在判断对象的内部逻辑中还需要判断是否是Date类型，若为Date类型则直接原路返回，不处理。</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> data === <span class="hljs-string">'object'</span> &amp;&amp; data !== <span class="hljs-literal">null</span>){
  <span class="hljs-keyword">if</span>(data <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Date</span>){
    <span class="hljs-keyword">return</span> data
  }
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">fromEntries</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(data).<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">[key, value]</span>) =&gt;</span> [key, <span class="hljs-title function_">transformBigInt</span>(value)]));
}
</code></pre>
<p>完整的全局拦截器如下代码所示，后续英语AI项目中，会将该全局拦截器直接拿过去使用。</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// src/interceptor/interceptor.interceptor.ts文件</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">CallHandler</span>, <span class="hljs-title class_">ExecutionContext</span>, <span class="hljs-title class_">Injectable</span>, <span class="hljs-title class_">NestInterceptor</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Observable</span>, map } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Request</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'express'</span>;
<span class="hljs-comment">//同步 异步 then catch -&gt;数据流-&gt;pipe -&gt; map filter -&gt; 返回</span>



<span class="hljs-keyword">const</span> <span class="hljs-title function_">transformBigInt</span> = (<span class="hljs-params">data: <span class="hljs-built_in">any</span></span>) =&gt; {
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> data === <span class="hljs-string">'bigint'</span>) {
    <span class="hljs-keyword">return</span> data.<span class="hljs-title function_">toString</span>();
  }
  <span class="hljs-keyword">if</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(data)){
    <span class="hljs-keyword">return</span> data.<span class="hljs-title function_">map</span>(transformBigInt);
  }
  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> data === <span class="hljs-string">'object'</span> &amp;&amp; data !== <span class="hljs-literal">null</span>){
    <span class="hljs-keyword">if</span>(data <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Date</span>){
      <span class="hljs-keyword">return</span> data
    }
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">fromEntries</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(data).<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">[key, value]</span>) =&gt;</span> [key, <span class="hljs-title function_">transformBigInt</span>(value)]));
  }
  <span class="hljs-keyword">return</span> data;
};

<span class="hljs-meta">@Injectable</span>()
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InterceptorInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">NestInterceptor</span> {
  <span class="hljs-title function_">intercept</span>(<span class="hljs-attr">context</span>: <span class="hljs-title class_">ExecutionContext</span>, <span class="hljs-attr">next</span>: <span class="hljs-title class_">CallHandler</span>): <span class="hljs-title class_">Observable</span>&lt;<span class="hljs-built_in">any</span>&gt; {
    <span class="hljs-keyword">const</span> ctx = context.<span class="hljs-title function_">switchToHttp</span>();
    <span class="hljs-keyword">const</span> request = ctx.<span class="hljs-property">getRequest</span>&lt;<span class="hljs-title class_">Request</span>&gt;();
    <span class="hljs-keyword">return</span> next.<span class="hljs-title function_">handle</span>().<span class="hljs-title function_">pipe</span>(<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> {
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">timestmap</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">toISOString</span>(),
        <span class="hljs-attr">data</span>: <span class="hljs-title function_">transformBigInt</span>(data),
        <span class="hljs-attr">path</span>: request.<span class="hljs-property">url</span>,
        <span class="hljs-attr">message</span>: <span class="hljs-string">'success'</span>,<span class="hljs-comment">//业务逻辑自定义</span>
        <span class="hljs-attr">code</span>: <span class="hljs-number">200</span>,<span class="hljs-comment">//业务逻辑自定义</span>
        <span class="hljs-attr">success</span>: <span class="hljs-literal">true</span>,
      };
    }));
  }
}
</code></pre>
<p>接下来对异常也格式化统一处理一下，逻辑思路与全局拦截器类似。当前端发起不符合规范和要求的网络请求，后端就会返回异常信息，方便前端去统一处理。</p>
<p><img src="http://tuchuang.xiaoyu2002.cn/picture/image-20251212235546507.png" alt="image-20251212235546507" loading="lazy"/></p>
<p align="center">
 <b> 图3-5 异常情况的处理</b>
</p>
<p>此时我们需要总结nest命令的表1-2，找到filter命令来生成一个过滤器。命令是：nest g f &lt;过滤器名称&gt;，我们就通过nest g f exceptionFilter来生成一份过滤器吧。成功在src文件夹下创建exception-filter文件夹和exception-filter文件夹下的exception-filter.filter.ts文件，这些生成文件的命名规则都是一致的，不再赘述。</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// src/exception-filter/exception-filter.filter.ts</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">ArgumentsHost</span>, <span class="hljs-title class_">Catch</span>, <span class="hljs-title class_">ExceptionFilter</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;

<span class="hljs-meta">@Catch</span>()
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExceptionFilterFilter</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ExceptionFilter</span> {
  <span class="hljs-keyword">catch</span>(<span class="hljs-attr">exception</span>: T, <span class="hljs-attr">host</span>: <span class="hljs-title class_">ArgumentsHost</span>) {}
}
</code></pre>
<p>通过以上exception-filter.filter.ts文件的代码，我们发现异常处理@Catch()装饰器是空的，空的表示处理所有的异常操作，包括非HTTP请求都会处理，但我希望这个业务只处理和HTTP相关的异常就可以了。所以我们需要从@nestjs/common中引入一个HttpException类，然后让@Catch()装饰器去继承HttpException类就可以了。</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// src/exception-filter/exception-filter.filter.ts</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">ArgumentsHost</span>, <span class="hljs-title class_">Catch</span>, <span class="hljs-title class_">ExceptionFilter</span>, <span class="hljs-title class_">HttpException</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;

<span class="hljs-meta">@Catch</span>(<span class="hljs-title class_">HttpException</span>)
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExceptionFilterFilter</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpException</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ExceptionFilter</span> {
  <span class="hljs-keyword">catch</span>(<span class="hljs-attr">exception</span>: T, <span class="hljs-attr">host</span>: <span class="hljs-title class_">ArgumentsHost</span>) {}
}
</code></pre>
<p>在这里我们可以看到这个很有意思的设计理念，通过Nest命令生成的内容，它希望我们都能用得上，这种思想和TypeScript所想表达的含义是一致的，只写用得上且必要的部分。因此在通过Nest CLI 在生成过滤器模板时，会会默认使用 @Catch()（不带任何参数），示例性地展示如何捕获所有异常。但它只是一个类模板，需要我们手动把它注册为全局过滤器，或者在控制器上使用。</p>
<p>只有当我们明确在@Catch()中指定具体的异常类型（如 @Catch(HttpException) 或 @Catch(WsException)），过滤器才会从“捕获所有异常”转变为“仅处理特定类型的异常”。如图3-6所示的官方文档也说明了不同协议层（HTTP 与 WebSocket）对应的异常类型不同，因此需要在 @Catch() 中明确指定对应的异常类型。</p>
<p><img src="http://tuchuang.xiaoyu2002.cn/picture/image-20251212235819873.png" alt="image-20251212235819873" loading="lazy"/></p>
<p align="center">
 <b> 图3-6 HTTP异常过滤层的说明</b>
</p>
<p>接下来我们来对异常处理情况进行统一的格式化处理。这里的code（异常状态码）就不采用我们自定义的，而是使用exception内部定义的状态码，因为Nest内置的HttpException已经为所有常见错误定义了标准化的状态码（如 400、401、403、404、500 等），这些状态码符合 HTTP 协议本身的语义。直接使用exception.getStatus()可以确保服务端返回的错误信息在网络层面是可预测和通用的。Nest.js内置异常处理层说明如图3-7所示。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/33e5d0ba58c245529af9984810ac5730~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgWGlhb1l1MjAwMg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767933209&amp;x-signature=7aohKbCto4B%2FWcfA6y%2BcV3QWauY%3D" alt="image-20251213000123007" loading="lazy"/></p>
<p align="center">
 <b> 图3-7 Nest.js内置异常处理层说明</b>
</p>
<p>当token过期了，exception.getStatus()会自动识别并设置成401状态码，没有权限则403状态码。因此exception.getStatus()会自动化的根据实际情况去调整，非常方便。对应的详细讲解可阅读Nest.js的官方文档：<a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.nestjs.com%2Fexception-filters" target="_blank" title="https://docs.nestjs.com/exception-filters" ref="nofollow noopener noreferrer">Exception filters | NestJS - A progressive Node.js framework</a>。</p>
<p>如果再自定义一套error code，就等于需要维护两套错误体系：HTTP 状态码 + 我们自己额外设计的业务错误码，这会造成重复劳动、文档负担加重以及维护难度上升。而直接使用 HttpException 内部的状态码可以保持异常捕获逻辑与框架一致，不需要额外重复造轮子。</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// src/exception-filter/exception-filter.filter.ts文件</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">ArgumentsHost</span>, <span class="hljs-title class_">Catch</span>, <span class="hljs-title class_">ExceptionFilter</span>,<span class="hljs-title class_">HttpException</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Request</span>, <span class="hljs-title class_">Response</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'express'</span>;
<span class="hljs-meta">@Catch</span>(<span class="hljs-title class_">HttpException</span>)
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExceptionFilterFilter</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpException</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ExceptionFilter</span> {
  <span class="hljs-keyword">catch</span>(<span class="hljs-attr">exception</span>: T, <span class="hljs-attr">host</span>: <span class="hljs-title class_">ArgumentsHost</span>) {
    <span class="hljs-keyword">const</span> ctx = host.<span class="hljs-title function_">switchToHttp</span>()
    <span class="hljs-keyword">const</span> request = ctx.<span class="hljs-property">getRequest</span>&lt;<span class="hljs-title class_">Request</span>&gt;()
    <span class="hljs-keyword">const</span> response = ctx.<span class="hljs-property">getResponse</span>&lt;<span class="hljs-title class_">Response</span>&gt;()
    <span class="hljs-keyword">return</span> response.<span class="hljs-title function_">status</span>(exception.<span class="hljs-title function_">getStatus</span>()).<span class="hljs-title function_">json</span>({
      <span class="hljs-attr">timestamp</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">toISOString</span>(),
      <span class="hljs-attr">path</span>: request.<span class="hljs-property">url</span>,
      <span class="hljs-attr">message</span>: exception.<span class="hljs-property">message</span>,
      <span class="hljs-attr">code</span>: exception.<span class="hljs-title function_">getStatus</span>(),
      <span class="hljs-attr">success</span>: <span class="hljs-literal">false</span>,
    })
  }
}
</code></pre>
<p>最后，过滤器和拦截器一样，在main.ts文件中全局注册一下，则可以作用于整个项目的异常情况处理。</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// src/main.ts</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">NestFactory</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/core'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">AppModule</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./app.module'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">InterceptorInterceptor</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./interceptor/interceptor.interceptor'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">ExceptionFilterFilter</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./exception-filter/exception-filter.filter'</span>;
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">bootstrap</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> app = <span class="hljs-keyword">await</span> <span class="hljs-title class_">NestFactory</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">AppModule</span>);
  app.<span class="hljs-title function_">useGlobalInterceptors</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InterceptorInterceptor</span>());
  app.<span class="hljs-title function_">useGlobalFilters</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ExceptionFilterFilter</span>());
  <span class="hljs-keyword">await</span> app.<span class="hljs-title function_">listen</span>(process.<span class="hljs-property">env</span>.<span class="hljs-property">PORT</span> ?? <span class="hljs-number">3000</span>);
}

<span class="hljs-title function_">bootstrap</span>();
</code></pre>
<p>全局异常情况的过滤处理效果如图3-8所示。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3f3f288ad5fc45efaf825369e0d7199d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgWGlhb1l1MjAwMg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767933209&amp;x-signature=boCAIoPtCAlPryNFQN9ZKYtuxC8%3D" alt="image-20251212235417767" loading="lazy"/></p>
<p align="center">
 <b> 图3-8 全局异常情况的过滤处理效果</b>
</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[第4章 Nest.js业务合并]]></title>    <link>https://juejin.cn/post/7590128405351596032</link>    <guid>https://juejin.cn/post/7590128405351596032</guid>    <pubDate>2026-01-03T05:40:08.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7590128405351596032" data-draft-id="7590128405351579648" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="第4章 Nest.js业务合并"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2026-01-03T05:40:08.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="XiaoYu2002"/> <meta itemprop="url" content="https://juejin.cn/user/251124329220663"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            第4章 Nest.js业务合并
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/251124329220663/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    XiaoYu2002
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-03T05:40:08.000Z" title="Sat Jan 03 2026 05:40:08 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;color:rgba(46,36,36,.87);overflow-x:hidden}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{margin-bottom:5px;font-size:30px;font-weight:500}.markdown-body h1:before{content:"#";margin-right:10px;color:#1976d2}.markdown-body h2{font-size:28px;font-weight:400;border-left:5px solid #454545;margin-top:20px;padding-left:10px;transition:all .3s ease-in-out}.markdown-body h2:hover{border-color:#1976d2}.markdown-body h3{font-size:24px;font-weight:400;margin-top:15px;padding-bottom:0}.markdown-body h4{font-size:20px;font-weight:500}.markdown-body h5{font-size:16px}.markdown-body h6{margin-top:5px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body h2:first-letter,.markdown-body h3:first-letter,.markdown-body p:first-letter{text-transform:capitalize}.markdown-body em{text-emphasis:dot;text-emphasis-position:under}.markdown-body img{display:block;margin:0 auto!important;max-width:100%;border-radius:2px;box-shadow:0 2px 4px -1px rgba(0,0,0,.2),0 4px 5px 0 rgba(0,0,0,.14),0 1px 10px 0 rgba(0,0,0,.12)!important}.markdown-body hr{position:relative;width:98%;height:1px;border:none;margin-top:32px;margin-bottom:32px;background-image:linear-gradient(90deg,#ddd,#999,#ddd);overflow:visible}.markdown-body hr:after{content:"";position:absolute;margin:auto;left:0;right:0;bottom:0;top:0;display:inline-block;width:60px;height:20px;background:#fff;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAgCAYAAABgrToAAAADoklEQVRYR82XTYgcRRTHf2933Q1RjAa9eFO8JHoJ8RQVBQ2iBwXBET0YEUTXNVmNQtTpmeqaWV0XNRq/o4KoECSCEPSg4CF+BYUkIIiCoCJCPIhC/Ihh2Z0nVV27VnZnenumW9i6ddV7//frV69fVQurfMgq56NawFTPAU6QyomqXrw6wIZeyhCPebA5buNR+akKyGoAjd6BshthnYdSjqNcRVuOlIUsD2j0SuA94IwuMHdh5ZUykOUBXfSGbmKI54EtAeYIHSZoy5dl4JxvNYBOKdW1KE8BQ8AkVk6WhasWsAiN0TX9gveXQaPP+Aytpc4u+bMI06JNohsYYYYOR2lJWtS3OKDRfcAtQfgDoI6Vo4UCGb0OmAEuDvZvYmVbEd/igC3dzDz7gQu8sPA9kJDK27mBmjqBeLjTg90PDFOjWawFFQd06kZHEfaj3LAIpTRpSXsZ5E06zEYP9sDimnAApYaV2SLZG/wjMeqAkijwW4xQJ5Gf/ZzRC8OW3hiBTGGlURRswW55Bh/Ssxljrwew8l1PQaM14GngvGDzBUKdDsMeTtgU5o8B92PFlUf3YXUrHa7Fys6lBqcCGnX15YQ2A18FyPd7Crd1A3M8C1wdbH4DD3hWeP6IEXbQkG97ajR1HPFnuPP5jFFq1OWX7hl8WM9l1AO648uNfwLk7tytMeogty+xeQ4rO3r6bdcx1nuwOGsHmaXGtPzae4uzGnLH1kQkvpdZGrHjssBZJrL+pqS05KWc8tgITAPXRzYvYOXe/C2OV43eDcRBDtIhoS2f9wzc0Cv8Wls+zoFzUC5zF0U241h5uZtPfptp6OUM8wbK+cH5GEpCS17P3fJei0Z3+npTxryJ8CPzbKMtn/ZyWbkPGl0PuFPkmkjkcb4h4R2ZLwRq1H0ALmvjkf2HwK1Y+T1PY2XABe/sHJ6MxN5lnoSpnC/UGbsTaI5phK2R7x6s3Ffk5YoDOrWm3onwJHBmEP86bPmBrsGaenNoIdnxCH+gPEhLXi0Cl1VBvyPVLSh7gEuC62yAfOIUqabWEaaiucMIk6RyqJ+Q/QM69V26jjW86Gvov/EaoyT8zRCn+Xq7PVrbx0nuYUaO9wM3WAbjCE1NEUw09Um4UV+2OKfYfu5/S19gsAzGKqm6LE5FrShbdS0ku465DjDwKA/oQht19ejqbaEVuRbiLhuHByYLjtUAZpDutzP7cYdHsPJXWbjyNVgFwQoa1WXwf4Jd9YD/Ap80+yE7+u9aAAAAAElFTkSuQmCC);background-repeat:no-repeat;background-size:auto 100%;background-position-x:center}.markdown-body code{font-weight:900;word-break:break-word;border-radius:2px;overflow-x:auto;font-size:.87em;padding:.065em .4em;background-color:#fbe5e1;color:#c0341d}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75;border-radius:0 4px}.markdown-body pre&gt;code{font-weight:400;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{margin:0 4px;text-decoration:none;color:#027fff;transition:all .3s ease-in-out;padding-bottom:4px;border-bottom:2px solid transparent}.markdown-body a:after{content:"";display:inline-block;width:18px;height:18px;margin-left:4px;vertical-align:middle;background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMiIgaGVpZ2h0PSIyMiI+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIiBzdHJva2U9IiMwMjdGRkYiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCI+PHBhdGggZD0iTTkuODE1IDYuNDQ4bDEuOTM2LTEuOTM2YzEuMzM3LTEuMzM2IDMuNTgtMS4yNTkgNS4wMTMuMTczIDEuNDMyIDEuNDMyIDEuNTEgMy42NzYuMTczIDUuMDEzbC0xLjQ1MiAxLjQ1Mi0uOTY4Ljk2OGMtMS4zMzcgMS4zMzYtMy41ODEgMS4yNTktNS4wMTMtLjE3MyIvPjxwYXRoIGQ9Ik0xMS4yNjcgMTUuMzY3bC0xLjkzNiAxLjkzNmMtMS4zMzYgMS4zMzctMy41OCAxLjI2LTUuMDEyLS4xNzMtMS40MzItMS40MzItMS41MS0zLjY3Ni0uMTczLTUuMDEybDEuNDUyLTEuNDUyLjk2OC0uOTY4YzEuMzM2LTEuMzM3IDMuNTgtMS4yNiA1LjAxMi4xNzMiLz48L2c+PC9zdmc+);background-size:cover;background-repeat:no-repeat}.markdown-body a:hover{border-color:#027fff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body a.footnote-backref:after,.markdown-body a.footnote-ref:after,.markdown-body sup a:after{display:none!important}.markdown-body table{margin:0 auto 10px;font-size:12px;width:auto;max-width:100%;overflow:auto;border:2px solid #c6c6c6}.markdown-body table img{box-shadow:none!important}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body del{color:rgba(0,0,0,.6)}.markdown-body blockquote{position:relative;color:#666;padding:5px 23px 1px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:hsla(0,0%,78.4%,.12);transition:all .2s ease-in-out}.markdown-body blockquote:hover{border-color:#1976d2}.markdown-body blockquote:after,.markdown-body blockquote:before{position:absolute;font-size:24px;font-weight:800;line-height:24px;color:#cbcbcb;opacity:.6}.markdown-body blockquote:before{content:"“";top:4px;left:6px}.markdown-body blockquote:after{content:"”";right:8px;bottom:-8px}.markdown-body blockquote&gt;p,.markdown-body blockquote blockquote{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body details{outline:none;border:none;border-left:4px solid #1976d2;padding-left:10px;margin-left:4px}.markdown-body details summary{cursor:pointer;border:none;outline:none;background:#fff;margin:0 -17px}.markdown-body details summary:hover::-webkit-details-marker{color:#1976d2}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">第4章 Nest.js业务合并</h2>
<p>在实际项目中，不同的业务操作需要明确的反馈信息。例如：</p>
<ul>
<li>登录操作返回消息为「登录成功」，状态码为 1。</li>
<li>注册操作返回消息为「注册成功」，状态码为 2。</li>
</ul>
<p><strong>状态码</strong> 作为业务逻辑判断的操作标识，是一个数字或字符串标识符。不同数值代表不同的业务含义（如1表示登录成功、2表示注册成功），前端或调用方可根据具体数值执行相应的逻辑分支。<strong>业务描述</strong> 则面向用户或开发者，用自然语言清晰传达操作结果，提供直观的反馈信息，辅助理解状态码对应的具体业务场景。</p>
<p>在全局拦截器的使用中，message 和 code 这两个参数需要根据业务需求进行自定义。下面将介绍如何在 Nest.js 中对这两个参数，以及更多同类参数进行规范化管理。</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// src/interceptor/interceptor.interceptor.ts</span>
<span class="hljs-keyword">return</span> {
  <span class="hljs-attr">timestmap</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">toISOString</span>(),
  <span class="hljs-attr">data</span>: <span class="hljs-title function_">transformBigInt</span>(data),
  <span class="hljs-attr">path</span>: request.<span class="hljs-property">url</span>,
  <span class="hljs-attr">message</span>: <span class="hljs-string">'success'</span>,<span class="hljs-comment">//业务逻辑自定义</span>
  <span class="hljs-attr">code</span>: <span class="hljs-number">200</span>,<span class="hljs-comment">//业务逻辑自定义</span>
  <span class="hljs-attr">success</span>: <span class="hljs-literal">true</span>,
};
</code></pre>
<p>要对全局拦截器的统一返回数据格式中的 message 和 code 进行自定义，应从专门的业务定义文件中引入自定义的业务状态码和描述信息，然后传递给 message 和 code 参数。</p>
<p>在自定义参数时，有一个重要原则：message 和 code 的自定义数据需要与业务逻辑层分离。这些数据应作为纯粹的配置信息使用，类似于 JSON 配置文件。业务层则建立在统一的业务规范基础上进行进一步封装。</p>
<p>首先创建一个响应格式模块（response module）和服务（response service），用于统一处理业务响应。通过 Nest CLI 命令生成的 response.service.ts 文件会自动关联到 response.module.ts 文件中。</p>
<pre><code class="hljs language-ts" lang="ts">nest g mo response
nest g s response
</code></pre>
<p>在 src 目录下创建 business 文件夹，并在其中创建 index.ts 文件。该文件专门存放自定义的业务状态码和描述信息，我们只关心每个业务操作对应的状态码和消息内容。后续新增业务需求时，只需在此文件中添加相应的状态码和消息。</p>
<p>注意：业务字段命名通常采用大写字母和下划线组合的格式，即「功能_状态」的表达方式，如 LOGIN_SUCCESS。</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// src/business/index.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> business = {
  <span class="hljs-attr">LOGIN_SUCCESS</span>: {
    <span class="hljs-attr">code</span>: <span class="hljs-number">1</span>,
    <span class="hljs-attr">message</span>: <span class="hljs-string">'登录成功'</span>
  },
  <span class="hljs-attr">LOGIN_ERROR</span>: {
    <span class="hljs-attr">code</span>: <span class="hljs-number">2</span>,
    <span class="hljs-attr">message</span>: <span class="hljs-string">'登录失败'</span>
  },
  <span class="hljs-attr">REGISTER_SUCCESS</span>: {
    <span class="hljs-attr">code</span>: <span class="hljs-number">2</span>,
    <span class="hljs-attr">message</span>: <span class="hljs-string">'注册成功'</span>
  },
}
</code></pre>
<p>在 response 目录的 response.service.ts 文件中编写具体的响应格式逻辑，定义操作成功和操作失败时需要返回的数据结构。</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// src/response/response.service.ts</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Injectable</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;

<span class="hljs-meta">@Injectable</span>()
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ResponseService</span> {
  <span class="hljs-title function_">success</span>(<span class="hljs-params">data: <span class="hljs-built_in">any</span> = <span class="hljs-literal">null</span>, message: <span class="hljs-built_in">string</span> = <span class="hljs-string">'操作成功'</span>, code: <span class="hljs-built_in">number</span> = <span class="hljs-number">200</span></span>) {
    <span class="hljs-keyword">return</span> {
      data,
      message,
      code
    }
  }
  <span class="hljs-title function_">error</span>(<span class="hljs-params">message: <span class="hljs-built_in">string</span> = <span class="hljs-string">'操作失败'</span>, code: <span class="hljs-built_in">number</span> = <span class="hljs-number">500</span></span>) {
    <span class="hljs-keyword">return</span> {
      message,
      code
    }
  }
}
</code></pre>
<p>如果我们想要使用自定义的业务状态码，要如何使用？假设要在user模块的业务层中使用。</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// src/user/user.service.ts（业务层）</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Injectable</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">CreateUserDto</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./dto/create-user.dto'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">UpdateUserDto</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./dto/update-user.dto'</span>;

<span class="hljs-meta">@Injectable</span>()
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> {
  <span class="hljs-title function_">create</span>(<span class="hljs-params">createUserDto: CreateUserDto</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">'This action adds a new user'</span>;
  }

  <span class="hljs-title function_">findAll</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`This action returns all user`</span>;
  }
 	<span class="hljs-comment">// 省略...</span>
}
</code></pre>
<p>假设需要在 user 模块的业务层中使用自定义业务状态码，操作步骤如下：</p>
<p>（1）引入依赖文件：同时引入业务定义文件和响应格式文件。</p>
<p>（2）依赖注入：在 UserService 类中注入 ResponseService 类。</p>
<p>（3）使用响应格式：在 findAll() 方法中使用 ResponseService 类，按照 data、message 和 code 的顺序传入数据。</p>
<p>（4）引用业务定义：message 和 code 从 business 业务文件中读取，本次「登录成功操作」使用业务字段 LOGIN_SUCCESS。</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// src/user/user.service.ts（业务层）</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Injectable</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">CreateUserDto</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./dto/create-user.dto'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">ResponseService</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'src/response/response.service'</span>;
<span class="hljs-keyword">import</span> { business } <span class="hljs-keyword">from</span> <span class="hljs-string">'src/business'</span>;
<span class="hljs-meta">@Injectable</span>()
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> responseService: ResponseService</span>) { }
  <span class="hljs-title function_">create</span>(<span class="hljs-params">createUserDto: CreateUserDto</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">'This action adds a new user'</span>;
  }

  <span class="hljs-title function_">findAll</span>(<span class="hljs-params"/>) {
    <span class="hljs-comment">// 登录成功的消息内容和业务码</span>
    <span class="hljs-keyword">const</span> message = business.<span class="hljs-property">LOGIN_SUCCESS</span>.<span class="hljs-property">message</span>;
    <span class="hljs-keyword">const</span> code = business.<span class="hljs-property">LOGIN_SUCCESS</span>.<span class="hljs-property">code</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">responseService</span>.<span class="hljs-title function_">success</span>(<span class="hljs-string">'This action returns all user'</span>, message, code);
  }
}
</code></pre>
<p>此时启动项目，访问 localhost:3000/user 路由应返回登录成功的业务状态码。但可能出现以下错误：</p>
<p>RROR [ExceptionHandler] UnknownDependenciesException [Error]: Nest can't resolve dependencies of the UserService (?). Please make sure that the argument ResponseService at index [0] is available in the UserModule context.</p>
<p>错误信息表明 Nest 无法解析 UserService 的依赖，需要确保 ResponseService 在 UserModule 上下文中可用。这是因为 ResponseService 未被正确导出和导入。</p>
<p>解决上述问题需要如下3个步骤：</p>
<p>（1）导出服务：在 response.module.ts 文件中将 ResponseService 添加到 exports 数组中。</p>
<p>（2）导入模块：在 user.module.ts 文件中导入 ResponseModule 模块。</p>
<p>（3）完成注入：此时 UserModule 可以读取到 ResponseModule 导出的 ResponseService，UserService 才能正常使用 ResponseService。</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// src/response/response.module.ts</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Module</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">ResponseService</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./response.service'</span>;

<span class="hljs-meta">@Module</span>({
  <span class="hljs-attr">providers</span>: [<span class="hljs-title class_">ResponseService</span>],
  <span class="hljs-attr">exports</span>: [<span class="hljs-title class_">ResponseService</span>]
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ResponseModule</span> { }
</code></pre>
<p>在user.module.ts 文件中导入 ResponseModule 模块，完成导入模块。</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// src/user/user.module.ts</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Module</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">UserService</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./user.service'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">UserController</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./user.controller'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">ResponseModule</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'src/response/response.module'</span>;
<span class="hljs-meta">@Module</span>({
  <span class="hljs-attr">imports</span>: [<span class="hljs-title class_">ResponseModule</span>],
  <span class="hljs-attr">controllers</span>: [<span class="hljs-title class_">UserController</span>],
  <span class="hljs-attr">providers</span>: [<span class="hljs-title class_">UserService</span>],
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserModule</span> {}
</code></pre>
<p>完成以上配置后，重新启动项目访问 <a href="https://link.juejin.cn?target=http%3A%2F%2Flocalhost%3A3000%2Fuser%25EF%25BC%258C%25E5%258F%25AF%25E8%25A7%2581" target="_blank" title="http://localhost:3000/user%EF%BC%8C%E5%8F%AF%E8%A7%81" ref="nofollow noopener noreferrer">http://localhost:3000/user，可见</a> data、message 和 code 三个业务字段的信息都成功输出。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e493da6ae5644f4fb8f16e816d7ab870~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgWGlhb1l1MjAwMg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768023608&amp;x-signature=w%2F7WSxTj0An%2BQq3PDYrLHbWmsGQ%3D" alt="image-20251213233534395" loading="lazy"/></p>
<p align="center">
 <b> 图4-1 业务字段信息插入</b>
</p>
<p>接下来只需从全局拦截器中重新统一数据格式即可。</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// src/interceptor/interceptor.interceptor.ts</span>
<span class="hljs-keyword">return</span> {
  <span class="hljs-attr">timestmap</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">toISOString</span>(),
  <span class="hljs-attr">data</span>: <span class="hljs-title function_">transformBigInt</span>(data.<span class="hljs-property">data</span>) ?? <span class="hljs-literal">null</span>,
  <span class="hljs-attr">path</span>: request.<span class="hljs-property">url</span>,
  <span class="hljs-attr">message</span>: data.<span class="hljs-property">message</span> ?? <span class="hljs-string">'success'</span>,<span class="hljs-comment">//业务逻辑自定义</span>
  <span class="hljs-attr">code</span>: data.<span class="hljs-property">code</span> ?? <span class="hljs-number">200</span>,<span class="hljs-comment">//业务逻辑自定义</span>
  <span class="hljs-attr">success</span>: <span class="hljs-literal">true</span>,
};
</code></pre>
<p>统一业务字段格式如图4-2所示。</p>
<p><img src="http://tuchuang.xiaoyu2002.cn/picture/image-20251213234031967.png" alt="image-20251213234031967" loading="lazy"/></p>
<p align="center">
 <b> 图4-2 统一业务字段格式</b>
</p>
<p>通过以上步骤，Nest.js 的业务状态码和业务状态描述已成功应用到对应的 user 模块接口中。但在实现过程中，我们发现每个使用 ResponseService 的模块都需要：</p>
<p>（1）在提供模块中导出服务。</p>
<p>（2）在使用模块中导入模块。</p>
<p>如果项目有十几个模块都需要使用，这种重复导入导出的操作会变得繁琐。为此，可以将 response 模块注册为全局模块，这样在整个项目中都可以直接使用，无需在每个使用模块的 module.ts 文件中重复导入。</p>
<p>将 response 模块注册为全局模块的方法为以下2步：</p>
<p>（1）从 @nestjs/common 中导入 Global 装饰器</p>
<p>（2）将 @Global() 装饰器应用到 ResponseModule 上</p>
<p>注册为全局模块后，ResponseService 可以在任何模块中直接使用，无需在各使用模块中导入 ResponseModule。</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// src/response/response.module.ts</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Module</span>, <span class="hljs-title class_">Global</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">ResponseService</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./response.service'</span>;

<span class="hljs-meta">@Global</span>()
<span class="hljs-meta">@Module</span>({
  <span class="hljs-attr">providers</span>: [<span class="hljs-title class_">ResponseService</span>],
  <span class="hljs-attr">exports</span>: [<span class="hljs-title class_">ResponseService</span>]
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ResponseModule</span> { }
</code></pre>
<p>此时如果我们回到user.module.ts文件中，将刚才注册的ResponseModule删除，项目也不会报错。</p>
<p>对于全局模块的使用，若我想在xiaoyu模块中使用ResponseService，主要步骤如下，无需在XiaoyuModule中导入ResponseModule：</p>
<p>（1）在 xiaoyu.service.ts 文件中导入 ResponseService 服务类和 business 业务常量。</p>
<p>（2）在 XiaoyuService 的构造函数中注入 ResponseService，并使用其方法按照业务数据格式规范处理数据。</p>
<p>（3）在 xiaoyu.controller.ts 文件的控制器中注入 XiaoyuService，并在路由处理器中调用其业务方法返回处理结果。</p>
<p>注意：虽然 ResponseService 是全局模块无需导入，但 XiaoyuModule 仍需要在自身的 providers 中注册 XiaoyuService，在 controllers 中注册 XiaoyuController。</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// src/xiaoyu/xiaoyu.service.ts</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Injectable</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">ResponseService</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'src/response/response.service'</span>;
<span class="hljs-keyword">import</span> { business } <span class="hljs-keyword">from</span> <span class="hljs-string">'src/business'</span>;
<span class="hljs-meta">@Injectable</span>()
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">XiaoyuService</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> responseService: ResponseService</span>) {}
  <span class="hljs-title function_">getHello</span>(): <span class="hljs-built_in">any</span> {
    <span class="hljs-keyword">const</span> message = business.<span class="hljs-property">LOGIN_SUCCESS</span>.<span class="hljs-property">message</span>;
    <span class="hljs-keyword">const</span> code = business.<span class="hljs-property">LOGIN_SUCCESS</span>.<span class="hljs-property">code</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">responseService</span>.<span class="hljs-title function_">success</span>(<span class="hljs-string">'This action returns all user'</span>, message, code);
  }
}
</code></pre>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// src/xiaoyu/xiaoyu.controller.ts</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Controller</span>, <span class="hljs-title class_">Get</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">XiaoyuService</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./xiaoyu.service'</span>;

<span class="hljs-meta">@Controller</span>(<span class="hljs-string">'xiaoyu'</span>)
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">XiaoyuController</span> {
  <span class="hljs-comment">// 依赖注入</span>
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> xiaoyuService: XiaoyuService</span>) {}
  <span class="hljs-meta">@Get</span>()
  <span class="hljs-title function_">getHello</span>(): <span class="hljs-built_in">any</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">xiaoyuService</span>.<span class="hljs-title function_">getHello</span>();
  }
}
</code></pre>
<p>xiaoyu模块业务合并如图4-3所示。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/645775c74ffc435c948ff37e77723d1a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgWGlhb1l1MjAwMg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768023608&amp;x-signature=q5Re8lEqcDI%2BLazzUOvZRW0vCuo%3D" alt="image-20251214004117303" loading="lazy"/></p>
<p align="center">
 <b> 图4-3 xiaoyu模块业务合并</b>
</p>
<p>以上就是Nest.js业务层的所有内容，我们回顾一下，Nest.js 的业务处理分为 business 和 response 两个部分：</p>
<p>（1）business 文件夹：集中管理业务状态码和描述信息。</p>
<p>（2）response 模块：专门用于构建统一的响应格式。</p>
<p>在实际项目中，这两者的变化频率不同：响应格式通常保持稳定，而业务状态码会随着业务发展不断新增或调整。因此需要将两者分离管理。response 模块的功能与全局拦截器中统一返回客户端响应格式的功能是一致的，区别在于我们将自定义部分拆分出来，提高了灵活性和可维护性，更符合实际项目的需求变化。</p>
<p>这种架构设计的优势在于：业务状态定义与响应格式构建职责明确（单一职责）；业务状态变化不影响响应格式，响应格式调整不影响业务逻辑；统一的响应格式可跨模块、跨项目使用；新增业务状态只需在 business 文件中添加，不影响现有结构。通过这种规范化管理，可以构建出清晰、可维护、可扩展的业务层架构，适应各种复杂的业务场景需求。</p>
<p>除了message和code这两个字段，我们还可以有权限与安全控制（例如IP白名单、频率限制、黑白名单）、数据持久化（创建、读取、更新、删除业务数据）、业务流程（多级审批、会签、或签逻辑）、第三方集成（支付宝、微信支付回调处理）、监控与统计（接口响应时间、成功率）等多方面基于实际业务需求去增添。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[SpringBoot性能翻倍秘籍：5个被低估的配置项让我QPS提升200%]]></title>    <link>https://juejin.cn/post/7590303618428633123</link>    <guid>https://juejin.cn/post/7590303618428633123</guid>    <pubDate>2026-01-03T04:16:38.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7590303618428633123" data-draft-id="7590303618428616739" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="SpringBoot性能翻倍秘籍：5个被低估的配置项让我QPS提升200%"/> <meta itemprop="keywords" content="后端,前端,人工智能"/> <meta itemprop="datePublished" content="2026-01-03T04:16:38.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="阿橙的百宝箱"/> <meta itemprop="url" content="https://juejin.cn/user/1638743356481367"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            SpringBoot性能翻倍秘籍：5个被低估的配置项让我QPS提升200%
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1638743356481367/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    阿橙的百宝箱
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-03T04:16:38.000Z" title="Sat Jan 03 2026 04:16:38 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0"><strong>SpringBoot性能翻倍秘籍：5个被低估的配置项让我QPS提升200%</strong></h2>
<h2 data-id="heading-1">引言</h2>
<p>在当今高并发的互联网环境下，微服务架构的性能优化成为了开发者必须面对的挑战。SpringBoot作为Java生态中最流行的微服务框架之一，其默认配置虽然能满足大多数场景需求，但在极端性能要求下往往显得力不从心。本文将揭示5个常被开发者忽略的SpringBoot配置项，通过合理调整这些参数，我们的线上服务实现了QPS（每秒查询率）从1000到3000的惊人提升。</p>
<h2 data-id="heading-2">主体</h2>
<h3 data-id="heading-3">1. Tomcat线程池调优：突破默认并发瓶颈</h3>
<p><strong>问题背景</strong>：
SpringBoot内嵌Tomcat默认使用200个线程的最大连接数（server.tomcat.max-threads），这在中等流量下尚可应付，但对于突发高并发场景会成为明显瓶颈。</p>
<p><strong>优化方案</strong>：</p>
<pre><code class="hljs language-properties" lang="properties">server.tomcat.max-threads=500
server.tomcat.min-spare-threads=50
server.tomcat.accept-count=100
</code></pre>
<p><strong>深度解析</strong>：</p>
<ul>
<li><code>max-threads</code>应根据服务器CPU核心数调整（建议公式：核心数 * (1 + 平均等待时间/平均服务时间)）</li>
<li><code>min-spare-threads</code>预热线程池避免冷启动延迟</li>
<li><code>accept-count</code>设置合理的等待队列防止直接拒绝请求</li>
</ul>
<p><strong>实测效果</strong>：
在4核8G的服务器上，将max-threads从200提升到500后，持续10分钟的压测结果显示99线延迟降低了37%。</p>
<h3 data-id="heading-4">2. Undertow替代Tomcat：异步IO的性能红利</h3>
<p><strong>问题背景</strong>：
虽然Tomcat是默认选择，但Undertow基于NIO2的实现在高并发场景下表现更优异。</p>
<p><strong>优化方案</strong>：</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-undertow<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<pre><code class="hljs language-properties" lang="properties">server.undertow.worker-threads=16
server.undertow.io-threads=4
</code></pre>
<p><strong>深度解析</strong>：</p>
<ul>
<li>Undertow采用X.NIO工作模式，I/O与Worker线程分离</li>
<li>worker-threads建议设置为CPU核心数的8倍</li>
<li>io-threads通常设为CPU核心数即可</li>
</ul>
<p><strong>实测效果</strong>：
相同硬件条件下切换至Undertow后，长连接场景下的内存消耗降低40%，吞吐量提升22%。</p>
<h3 data-id="heading-5">3. JVM参数精细化配置：告别OOM的噩梦</h3>
<p><strong>问题背景</strong>：
SpringBoot应用的默认JVM参数往往不适合生产环境，容易引发GC风暴或内存溢出。</p>
<p><strong>优化方案（application.properties）</strong>：</p>
<pre><code class="hljs language-properties" lang="properties">spring.jvmargs=-XX:+UseG1GC -Xms2048m -Xmx2048m -XX:MaxGCPauseMillis=200 
-XX:G1ReservePercent=25 -XX:InitiatingHeapOccupancyPercent=35
</code></pre>
<p>或者通过启动命令：</p>
<pre><code class="hljs language-bash" lang="bash">java -jar -XX:+UseG1GC -Xms2048m -Xmx2048m your-app.jar
</code></pre>
<p><strong>深度解析</strong>：</p>
<ul>
<li>G1垃圾收集器适合多核大内存机器（JDK9+默认）</li>
<li>Xms与Xmx必须相同以避免运行时调整带来的性能波动</li>
<li>MaxGCPauseMillis设置合理的GC停顿目标（100-200ms）</li>
</ul>
<h3 data-id="heading-6">4. Redis连接池优化：解决高频访问的性能黑洞</h3>
<p>当使用Spring Data Redis时：</p>
<pre><code class="hljs language-properties" lang="properties">spring.redis.lettuce.pool.enabled=true
spring.redis.lettuce.pool.max-active=32
spring.redis.lettuce.pool.max-idle=16
spring.redis.lettuce.pool.min-idle=8
spring.redis.timeout=5000ms
</code></pre>
<p>当使用Jedis时：</p>
<pre><code class="hljs language-properties" lang="properties">spring.redis.jedis.pool.max-active=50 
spring.redis.jedis.pool.max-idle=20 
spring redis.jedis.pool.min-idle=10 
spring redis.jedis pool max-wait=-1ms 
</code></pre>
<h3 data-id="heading-7">5. Jackson序列化黑科技：JSON处理的极致优化</h3>
<p><code>properties spring.jackson.generator.write-numbers-as-strings=false spring jackson parser allow unquoted field names=false spring jackson default property inclusion=none spring jackson serialization write dates as timestamps=true spring jackson deserialization fail on unknown properties=true </code></p>
<h2 data-id="heading-8">总结</h2></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[若依AI项目专属域名ruoyiai.cn限时出售，打造AI开发领域品牌标杆]]></title>    <link>https://juejin.cn/post/7590292138347036682</link>    <guid>https://juejin.cn/post/7590292138347036682</guid>    <pubDate>2026-01-03T04:47:38.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7590292138347036682" data-draft-id="7590292138347003914" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="若依AI项目专属域名ruoyiai.cn限时出售，打造AI开发领域品牌标杆"/> <meta itemprop="keywords" content="面试"/> <meta itemprop="datePublished" content="2026-01-03T04:47:38.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="代码次位面"/> <meta itemprop="url" content="https://juejin.cn/user/1535333867720295"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            若依AI项目专属域名ruoyiai.cn限时出售，打造AI开发领域品牌标杆
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1535333867720295/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    代码次位面
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-03T04:47:38.000Z" title="Sat Jan 03 2026 04:47:38 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">引言</h2>
<p>在人工智能技术蓬勃发展的今天，一个优秀的品牌域名已成为项目成功的关键要素。ruoyiai.cn——这个与若依AI项目完美契合的域名，现正式对外出售，为AI开发领域的品牌建设提供绝佳机会。</p>
<h2 data-id="heading-1">域名价值分析</h2>
<h3 data-id="heading-2">品牌一致性优势</h3>
<p>ruoyiai.cn与若依AI项目<a href="https://link.juejin.cn?target=https%3A%2F%2Fgitee.com%2Fruoyi-ai%2Fruoyi-ai" target="_blank" title="https://gitee.com/ruoyi-ai/ruoyi-ai" ref="nofollow noopener noreferrer">gitee.com/ruoyi-ai/ru…</a>
名称完全一致，这种高度匹配的域名具有不可替代的品牌价值。对于开发者而言，ruoyiai.cn不仅是一个访问入口，更是项目品牌形象的重要组成部分。当用户在浏览器中输入"ruoyiai.cn"，直接就能联想到若依AI项目，这种品牌记忆的强化效果是其他域名无法比拟的。</p>
<h3 data-id="heading-3">SEO优化潜力</h3>
<p>从搜索引擎优化角度看，ruoyiai.cn包含"ruoyi"和"ai"两个核心关键词，这对提升项目在搜索结果中的排名极为有利。无论是百度、谷歌还是其他搜索引擎，都会给予包含关键词的域名更高的权重。这意味着，拥有ruoyiai.cn后，项目在"若依AI"、"ruoyi ai"等关键词的搜索排名将获得天然优势，为项目带来持续的流量和曝光。</p>
<h3 data-id="heading-4">技术定位明确</h3>
<p>"AI"作为人工智能的缩写，在域名中明确标识了项目的技术属性。对于目标用户群体——开发者、技术决策者而言，这种技术定位的清晰表达能够快速吸引目标受众。同时，.cn域名表明其中国本土化属性，符合若依项目在国内开发社区的广泛影响力，便于国内用户访问和记忆。</p>
<h2 data-id="heading-5">项目背景与潜力</h2>
<p>若依AI项目是基于著名的RuoYi开源项目的AI增强版本，致力于为开发者提供集成人工智能能力的快速开发平台。该项目结合传统开发框架与AI能力，集成智能代码生成、自动化测试等先进功能，适用于多种企业级应用开发场景。</p>
<p>随着人工智能技术的快速发展，若依AI项目具有巨大的成长潜力。作为项目的专属域名，ruoyiai.cn将成为项目品牌资产的重要组成部分，为项目未来的商业化、产品化发展预留充足的品牌扩展空间。</p>
<h2 data-id="heading-6">限时优惠信息</h2>
<p>为回馈若依AI项目社区，ruoyiai.cn现推出限时优惠活动：</p>
<p><strong>原价：¥5,000</strong></p>
<p><strong>限时优惠价：¥3,800</strong></p>
<p><strong>节省：24%</strong></p>
<p>此价格包含域名所有权完全转移及相关协助服务。购买后，我们将协助完成域名过户、DNS解析等所有技术操作，确保您能够顺利使用该域名。</p>
<h2 data-id="heading-7">适用人群</h2>
<ul>
<li><strong>若依AI项目核心开发者</strong>：保护项目品牌，防止域名被抢注</li>
<li><strong>若依项目贡献者</strong>：为项目发展贡献力量，获得品牌资产</li>
<li><strong>AI开发领域创业者</strong>：抢占优质域名资源，布局AI赛道</li>
<li><strong>域名投资者</strong>：投资具有明确项目背景的优质域名</li>
</ul>
<h2 data-id="heading-8">购买方式</h2>
<p><strong>网站加客服</strong>：<a href="https://link.juejin.cn?target=http%3A%2F%2Fwww.ruoyiai.cn" target="_blank" title="http://www.ruoyiai.cn" ref="nofollow noopener noreferrer">www.ruoyiai.cn</a></p>
<h2 data-id="heading-9">结语</h2>
<p>ruoyiai.cn不仅是一个域名，更是若依AI项目品牌建设的重要一步。在AI技术快速发展的时代，拥有一个与项目完美契合的域名，将为项目带来持续的流量、品牌价值和商业机会。限时优惠仅此一次，机会不容错过！</p>
<p><strong>立即行动，让ruoyiai.cn成为您AI开发之路的起点！</strong></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[【n8n教程】：Switch节点，实现工作流多路由控制]]></title>    <link>https://juejin.cn/post/7590292138346807306</link>    <guid>https://juejin.cn/post/7590292138346807306</guid>    <pubDate>2026-01-03T03:06:12.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7590292138346807306" data-draft-id="7581412054902734857" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="【n8n教程】：Switch节点，实现工作流多路由控制"/> <meta itemprop="keywords" content="AIGC,AI编程"/> <meta itemprop="datePublished" content="2026-01-03T03:06:12.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="undsky"/> <meta itemprop="url" content="https://juejin.cn/user/3368559354850206"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            【n8n教程】：Switch节点，实现工作流多路由控制
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3368559354850206/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    undsky
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-03T03:06:12.000Z" title="Sat Jan 03 2026 03:06:12 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读9分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">【n8n教程】：Switch节点，实现工作流多路由控制</h2>
<p>在n8n自动化流程中，最常见的需求之一就是<strong>根据数据的不同条件，将其分发到不同的处理路径</strong>。如果你只需要处理"是"或"否"两种情况，可以用<strong>If节点</strong>；但当你需要根据多个条件创建3条、5条甚至更多的处理路径时，<strong>Switch节点</strong>就是你的最佳选择。</p>
<p>Switch节点就像是一个<strong>交通指挥官</strong>，它根据你设定的条件规则，将传入的数据准确地引导到对应的输出分支，让复杂的工作流变得清晰有序。</p>
<hr/>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fcdn.undsky.com%2Fimg%2Fghss.png" target="_blank" title="https://cdn.undsky.com/img/ghss.png" ref="nofollow noopener noreferrer">点击获取最新AI资讯、n8n工作流、开发经验分享</a></p>
<h3 data-id="heading-1">什么是Switch节点？</h3>
<p>Switch节点是n8n中的<strong>条件路由节点</strong>，它允许你根据数据的属性值进行多路由决策。与If节点只能分出两条路（真/假）不同，<strong>Switch节点可以创建无限个输出分支</strong>，每个分支对应一组特定的条件。</p>
<p><strong>核心特性：</strong></p>
<ul>
<li><strong>多路由支持</strong>：不限制输出分支数量，想要多少就创建多少</li>
<li><strong>灵活的条件系统</strong>：支持字符串、数字、日期、布尔值、数组、对象等多种数据类型</li>
<li><strong>两种工作模式</strong>：Rules模式（可视化条件构建）和Expression模式（编程表达式）</li>
<li><strong>智能降级处理</strong>：为不匹配任何条件的数据提供备选输出</li>
<li><strong>高效的数据流</strong>：一条数据一旦匹配到某个输出，默认不会重复匹配其他规则</li>
</ul>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b83b6461623d46e6b543fa398dcad239~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdW5kc2t5:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768014372&amp;x-signature=8Ir9kP%2FsZdX%2BNumYmk918oG6zyw%3D" alt="" loading="lazy"/></p>
<hr/>
<h3 data-id="heading-2">Switch节点的两种工作模式</h3>
<h4 data-id="heading-3">模式一：Rules模式（推荐初学者）</h4>
<p>Rules模式是<strong>可视化条件构建方式</strong>，你无需编写任何代码，只需通过下拉菜单和输入框配置条件。</p>
<p><strong>支持的数据类型和比较操作：</strong></p>








































<table><thead><tr><th>数据类型</th><th>支持的比较操作</th><th>使用场景</th></tr></thead><tbody><tr><td><strong>字符串</strong></td><td>等于、不等于、包含、不包含、以...开始、以...结束、正则匹配</td><td>邮箱地址、分类标签、部门名称</td></tr><tr><td><strong>数字</strong></td><td>等于、不等于、大于、小于、大于等于、小于等于</td><td>订单金额、优先级数值、计数器</td></tr><tr><td><strong>日期&amp;时间</strong></td><td>等于、不等于、之后、之前、之后或等于、之前或等于</td><td>截止日期、创建时间、过期判断</td></tr><tr><td><strong>布尔值</strong></td><td>为真、为假、等于、不等于</td><td>开关状态、验证结果</td></tr><tr><td><strong>数组</strong></td><td>存在/不存在、为空/非空、包含、长度比较</td><td>标签列表、多选项</td></tr><tr><td><strong>对象</strong></td><td>存在/不存在、为空/非空</td><td>嵌套数据结构</td></tr></tbody></table>
<h4 data-id="heading-4">模式二：Expression模式（高级用户）</h4>
<p>Expression模式使用<strong>JavaScript表达式</strong>来定义路由逻辑，适合需要复杂条件判断的高级场景。</p>
<p>例如：<code>{{ $json.status === 'urgent' &amp;&amp; $json.amount &gt; 1000 }}</code></p>
<hr/>
<h3 data-id="heading-5">快速上手：3步配置Switch节点</h3>
<h4 data-id="heading-6">第1步：添加Switch节点</h4>
<ol>
<li>在工作流画布上点击"<strong>添加节点</strong>"（或按Tab键）</li>
<li>搜索"<strong>Switch</strong>"</li>
<li>选择Switch节点添加到工作流</li>
</ol>
<h4 data-id="heading-7">第2步：配置路由规则</h4>
<ol>
<li>打开Switch节点的配置面板</li>
<li>确保"<strong>Mode</strong>"选择为"<strong>Rules</strong>"</li>
<li>点击"<strong>Add Routing Rule</strong>"添加第一条规则</li>
<li>根据你的数据，配置规则：
<ul>
<li><strong>左侧字段</strong>：选择你要检查的数据字段（例如 <code>priority</code>）</li>
<li><strong>中间操作符</strong>：选择比较方式（例如 "等于"）</li>
<li><strong>右侧值</strong>：输入要比较的值（例如 "high"）</li>
</ul>
</li>
</ol>
<p><strong>示例配置：</strong></p>
<pre><code class="hljs language-arduino" lang="arduino">规则<span class="hljs-number">1</span>：priority 等于 <span class="hljs-string">"high"</span> → 输出到第<span class="hljs-number">1</span>条分支
规则<span class="hljs-number">2</span>：priority 等于 <span class="hljs-string">"medium"</span> → 输出到第<span class="hljs-number">2</span>条分支
规则<span class="hljs-number">3</span>：priority 等于 <span class="hljs-string">"low"</span> → 输出到第<span class="hljs-number">3</span>条分支
</code></pre>
<h4 data-id="heading-8">第3步：连接后续节点</h4>
<ol>
<li>Switch节点会自动为每条规则创建一个输出端口</li>
<li>从这些输出端口拖拽连线到你的后续处理节点</li>
<li>为每个输出分支配置不同的业务逻辑</li>
</ol>
<hr/>
<h3 data-id="heading-9">5个关键配置选项详解</h3>
<h4 data-id="heading-10">1. 重命名输出（Rename Output）</h4>
<p><strong>默认情况下</strong>，Switch的输出被标记为"Output 0"、"Output 1"等数字标签。这容易混淆，特别是在复杂流程中。</p>
<p><strong>最佳实践</strong>：启用"<strong>Rename Output</strong>"，给每条分支取个有意义的名字：</p>
<ul>
<li>✅ 好：<code>高优先级处理</code>、<code>待审核</code>、<code>已完成</code></li>
<li>❌ 差：<code>Output 0</code>、<code>Output 1</code></li>
</ul>
<p><strong>配置步骤：</strong>
在配置规则时，勾选"Rename Output"，输入自定义名称。</p>
<h4 data-id="heading-11">2. 降级输出（Fallback Output）</h4>
<p>当数据<strong>不匹配任何路由规则</strong>时，降级输出决定该数据的去向。</p>
<p><strong>三种选项：</strong></p>

























<table><thead><tr><th>选项</th><th>说明</th><th>场景</th></tr></thead><tbody><tr><td><strong>None</strong></td><td>忽略不匹配的数据，不输出</td><td>只关心已知数据类型</td></tr><tr><td><strong>Extra Output</strong></td><td>创建单独的输出分支接收未匹配数据</td><td>需要单独处理异常情况</td></tr><tr><td><strong>Output 0</strong></td><td>将未匹配数据发送到第一条规则的输出</td><td>快速处理，无需额外分支</td></tr></tbody></table>
<p><strong>示例：</strong> 如果优先级字段出现意外值"urgent"，但你的规则中没有定义它，这条数据就会按照降级设置进行处理。</p>
<h4 data-id="heading-12">3. 忽略大小写（Ignore Case）</h4>
<p>对于字符串比较，启用此选项后，<code>"HIGH"</code>、<code>"High"</code>、<code>"high"</code>会被视为相同。</p>
<p><strong>建议</strong>：大多数场景下启用，避免因大小写不一致导致路由失败。</p>
<h4 data-id="heading-13">4. 严格类型验证（Less Strict Type Validation）</h4>
<p>启用后，n8n会<strong>自动尝试类型转换</strong>。例如，字符串"123"可以与数字123比较。</p>
<p><strong>默认建议</strong>：关闭。这样可以捕获潜在的数据类型错误。</p>
<h4 data-id="heading-14">5. 发送数据到所有匹配输出（Send data to all matching outputs）</h4>
<p><strong>默认行为</strong>：一条数据只要匹配到第一个规则，就停止检查其他规则。</p>
<p><strong>启用后</strong>：同时匹配多个规则的数据会被<strong>复制到所有匹配的输出分支</strong>。</p>
<p><strong>场景</strong>：标签系统中，一条数据可能同时属于多个标签，需要被发送到所有相关的处理流程。</p>
<hr/>
<h3 data-id="heading-15">Switch vs If：何时选择哪个？</h3>



































<table><thead><tr><th>对比维度</th><th>If节点</th><th>Switch节点</th></tr></thead><tbody><tr><td><strong>输出分支数</strong></td><td>固定2个（真/假）</td><td>无限制</td></tr><tr><td><strong>条件复杂性</strong></td><td>简单（单一真假判断）</td><td>复杂（多分支选择）</td></tr><tr><td><strong>最适用场景</strong></td><td>二元决策：发送或不发送、通过或阻止</td><td>多路由：优先级划分、类型分类、状态判断</td></tr><tr><td><strong>易用性</strong></td><td>直观简洁</td><td>功能更强大</td></tr><tr><td><strong>性能</strong></td><td>略快</td><td>略慢（但差异微乎其微）</td></tr></tbody></table>
<p><strong>实际建议：</strong></p>
<ul>
<li>问自己："我需要2个还是更多个处理分支？"</li>
<li>如果≤2个，用If</li>
<li>如果&gt;2个，用Switch</li>
</ul>
<hr/>
<h3 data-id="heading-16">实战案例：客户反馈优先级路由工作流</h3>
<p>现在让我们用一个完整的、可执行的案例来演示Switch节点的强大功能。</p>
<h4 data-id="heading-17">业务场景</h4>
<p>你的公司收到多渠道客户反馈，需要根据<strong>优先级</strong>进行分发：</p>
<ul>
<li><strong>高优先级（high）</strong>：立即通知管理员，通过紧急Slack频道</li>
<li><strong>中优先级（medium）</strong>：记录到数据库，定期处理</li>
<li><strong>低优先级（low）</strong>：存档，月度回顾</li>
<li><strong>未知优先级</strong>：人工审核队列</li>
</ul>
<h4 data-id="heading-18">工作流架构</h4>
<pre><code class="hljs language-scss" lang="scss">┌─────────────────┐
│   Webhook触发   │ (接收客户反馈数据)
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│  Switch节点     │ (根据priority字段路由)
└────────┬────────┘
    ┌────┼────┬─────┐
    │    │    │     │
    ▼    ▼    ▼     ▼
  高优   中优  低优  未知
  先级   先级  先级  优先级
</code></pre>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f960ba70a3eb465f835b535d7cfac633~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdW5kc2t5:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768014372&amp;x-signature=1bHH3QwSmF2yp9gi13spEvnQUMk%3D" alt="" loading="lazy"/></p>
<h4 data-id="heading-19">完整工作流JSON代码</h4>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"客户反馈优先级路由 - Switch节点教程"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"nodes"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
    <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"parameters"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">"method"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"POST"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"url"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"https://webhook.site/your-unique-id"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"options"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><span class="hljs-punctuation">}</span>
      <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"id"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"1"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Webhook"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"n8n-nodes-base.webhook"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"typeVersion"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"position"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-number">100</span><span class="hljs-punctuation">,</span> <span class="hljs-number">300</span><span class="hljs-punctuation">]</span>
    <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
    <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"parameters"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">"options"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><span class="hljs-punctuation">}</span>
      <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"id"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"2"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Switch"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"n8n-nodes-base.switch"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"typeVersion"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"position"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-number">400</span><span class="hljs-punctuation">,</span> <span class="hljs-number">300</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"mode"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"rules"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"rules"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
        <span class="hljs-punctuation">{</span>
          <span class="hljs-attr">"condition"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"string"</span><span class="hljs-punctuation">,</span>
          <span class="hljs-attr">"value1"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"={{ $json.priority }}"</span><span class="hljs-punctuation">,</span>
          <span class="hljs-attr">"value2"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"high"</span><span class="hljs-punctuation">,</span>
          <span class="hljs-attr">"operator"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"equal"</span><span class="hljs-punctuation">,</span>
          <span class="hljs-attr">"output"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span>
        <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
        <span class="hljs-punctuation">{</span>
          <span class="hljs-attr">"condition"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"string"</span><span class="hljs-punctuation">,</span>
          <span class="hljs-attr">"value1"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"={{ $json.priority }}"</span><span class="hljs-punctuation">,</span>
          <span class="hljs-attr">"value2"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"medium"</span><span class="hljs-punctuation">,</span>
          <span class="hljs-attr">"operator"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"equal"</span><span class="hljs-punctuation">,</span>
          <span class="hljs-attr">"output"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span>
        <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
        <span class="hljs-punctuation">{</span>
          <span class="hljs-attr">"condition"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"string"</span><span class="hljs-punctuation">,</span>
          <span class="hljs-attr">"value1"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"={{ $json.priority }}"</span><span class="hljs-punctuation">,</span>
          <span class="hljs-attr">"value2"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"low"</span><span class="hljs-punctuation">,</span>
          <span class="hljs-attr">"operator"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"equal"</span><span class="hljs-punctuation">,</span>
          <span class="hljs-attr">"output"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span>
        <span class="hljs-punctuation">}</span>
      <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"options"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">"fallbackOutput"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"ignoreCaseInStringComparison"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span>
      <span class="hljs-punctuation">}</span>
    <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
    <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"parameters"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">"content"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"🔴 高优先级反馈\n来自: {{ $json.sender }}\n内容: {{ $json.message }}"</span>
      <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"id"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"3"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"高优先级处理"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"n8n-nodes-base.noOp"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"typeVersion"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"position"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-number">700</span><span class="hljs-punctuation">,</span> <span class="hljs-number">100</span><span class="hljs-punctuation">]</span>
    <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
    <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"parameters"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">"content"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"🟡 中优先级反馈\n来自: {{ $json.sender }}\n内容: {{ $json.message }}"</span>
      <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"id"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"4"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"中优先级处理"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"n8n-nodes-base.noOp"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"typeVersion"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"position"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-number">700</span><span class="hljs-punctuation">,</span> <span class="hljs-number">300</span><span class="hljs-punctuation">]</span>
    <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
    <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"parameters"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">"content"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"🟢 低优先级反馈\n来自: {{ $json.sender }}\n内容: {{ $json.message }}"</span>
      <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"id"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"5"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"低优先级处理"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"n8n-nodes-base.noOp"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"typeVersion"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"position"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-number">700</span><span class="hljs-punctuation">,</span> <span class="hljs-number">500</span><span class="hljs-punctuation">]</span>
    <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
    <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"parameters"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">"content"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"⚪ 未知优先级 - 需要人工审核\n来自: {{ $json.sender }}\n内容: {{ $json.message }}\n优先级值: {{ $json.priority }}"</span>
      <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"id"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"6"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"降级处理"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"n8n-nodes-base.noOp"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"typeVersion"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"position"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-number">700</span><span class="hljs-punctuation">,</span> <span class="hljs-number">700</span><span class="hljs-punctuation">]</span>
    <span class="hljs-punctuation">}</span>
  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"connections"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"Webhook"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"main"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
        <span class="hljs-punctuation">[</span>
          <span class="hljs-punctuation">{</span>
            <span class="hljs-attr">"node"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Switch"</span><span class="hljs-punctuation">,</span>
            <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"main"</span><span class="hljs-punctuation">,</span>
            <span class="hljs-attr">"index"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span>
          <span class="hljs-punctuation">}</span>
        <span class="hljs-punctuation">]</span>
      <span class="hljs-punctuation">]</span>
    <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"Switch"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"main"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
        <span class="hljs-punctuation">[</span>
          <span class="hljs-punctuation">{</span>
            <span class="hljs-attr">"node"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"高优先级处理"</span><span class="hljs-punctuation">,</span>
            <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"main"</span><span class="hljs-punctuation">,</span>
            <span class="hljs-attr">"index"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span>
          <span class="hljs-punctuation">}</span>
        <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
        <span class="hljs-punctuation">[</span>
          <span class="hljs-punctuation">{</span>
            <span class="hljs-attr">"node"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"中优先级处理"</span><span class="hljs-punctuation">,</span>
            <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"main"</span><span class="hljs-punctuation">,</span>
            <span class="hljs-attr">"index"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span>
          <span class="hljs-punctuation">}</span>
        <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
        <span class="hljs-punctuation">[</span>
          <span class="hljs-punctuation">{</span>
            <span class="hljs-attr">"node"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"低优先级处理"</span><span class="hljs-punctuation">,</span>
            <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"main"</span><span class="hljs-punctuation">,</span>
            <span class="hljs-attr">"index"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span>
          <span class="hljs-punctuation">}</span>
        <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
        <span class="hljs-punctuation">[</span>
          <span class="hljs-punctuation">{</span>
            <span class="hljs-attr">"node"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"降级处理"</span><span class="hljs-punctuation">,</span>
            <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"main"</span><span class="hljs-punctuation">,</span>
            <span class="hljs-attr">"index"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span>
          <span class="hljs-punctuation">}</span>
        <span class="hljs-punctuation">]</span>
      <span class="hljs-punctuation">]</span>
    <span class="hljs-punctuation">}</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<h4 data-id="heading-20">如何使用这个工作流</h4>
<p><strong>第1步：导入工作流</strong></p>
<ol>
<li>复制上述JSON代码</li>
<li>进入你的n8n仪表板，点击"新建工作流"</li>
<li>点击右上角"..."菜单，选择"从文件导入"</li>
<li>粘贴JSON代码并导入</li>
</ol>
<p><strong>第2步：配置Webhook</strong></p>
<ol>
<li>打开Webhook节点</li>
<li>复制显示的Webhook URL</li>
<li>使用任何HTTP工具（如Postman或curl）向该URL发送测试数据</li>
</ol>
<p><strong>第3步：发送测试数据</strong></p>
<p>使用cURL命令：</p>
<pre><code class="hljs language-bash" lang="bash">curl -X POST https://your-webhook-url \
  -H <span class="hljs-string">"Content-Type: application/json"</span> \
  -d <span class="hljs-string">'{
    "sender": "customer@example.com",
    "message": "我的订单出现了问题",
    "priority": "high"
  }'</span>
</code></pre>
<p><strong>第4步：检查执行结果</strong></p>
<ol>
<li>运行工作流</li>
<li>查看"执行历史"</li>
<li>观察数据是否被正确路由到对应的优先级分支</li>
</ol>
<hr/>
<h3 data-id="heading-21">常见错误与解决方案</h3>
<h4 data-id="heading-22">❌ 错误1：数据没有被路由到任何输出</h4>
<p><strong>原因：</strong> 数据不匹配任何配置的规则</p>
<p><strong>解决：</strong></p>
<ol>
<li>检查字段名称是否正确（区分大小写）</li>
<li>使用"执行单个节点"来查看前一个节点的实际输出</li>
<li>检查比较值是否包含多余空格</li>
</ol>
<h4 data-id="heading-23">❌ 错误2：大小写导致的匹配失败</h4>
<p><strong>原因：</strong> 数据中是"HIGH"，但规则中写的是"high"</p>
<p><strong>解决：</strong></p>
<ol>
<li>启用"<strong>Ignore Case</strong>"选项</li>
<li>或在前一个节点中使用<code>.toLowerCase()</code>规范化数据</li>
</ol>
<h4 data-id="heading-24">❌ 错误3：Expression模式返回NaN或undefined</h4>
<p><strong>原因：</strong> 表达式语法错误</p>
<p><strong>解决：</strong></p>
<ol>
<li>检查变量引用是否正确：<code>$json.fieldName</code></li>
<li>使用JavaScript控制台测试表达式</li>
<li>参考n8n表达式文档：<a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.n8n.io%2Fcode-examples%2Fexpressions%2F" target="_blank" title="https://docs.n8n.io/code-examples/expressions/" ref="nofollow noopener noreferrer">docs.n8n.io/code-exampl…</a></li>
</ol>
<h4 data-id="heading-25">❌ 错误4：多条规则都匹配，数据只输出到第一个</h4>
<p><strong>原因：</strong> 没有启用"Send data to all matching outputs"</p>
<p><strong>解决：</strong></p>
<ol>
<li>打开Switch节点的Options</li>
<li>启用"<strong>Send data to all matching outputs</strong>"</li>
<li>此时匹配多个规则的数据会被复制到所有对应的输出</li>
</ol>
<hr/>
<h3 data-id="heading-26">进阶技巧</h3>
<h4 data-id="heading-27">技巧1：使用表达式实现复杂条件</h4>
<p>在Rules模式下，虽然界面有限制，但你可以<strong>在比较值中使用表达式</strong>：</p>
<p>配置示例：</p>
<pre><code class="hljs language-bash" lang="bash">value1: {{ <span class="hljs-variable">$json</span>.amount }}
operator: 大于
value2: {{ <span class="hljs-variable">$json</span>.<span class="hljs-built_in">limit</span> + 100 }}
</code></pre>
<h4 data-id="heading-28">技巧2：根据数组长度进行路由</h4>
<pre><code class="hljs language-makefile" lang="makefile"><span class="hljs-section">condition: Array</span>
<span class="hljs-section">value1: {{ $json.tags }}</span>
<span class="hljs-section">operator: length greater than</span>
<span class="hljs-section">value2: 5</span>
</code></pre>
<p>这样，只有标签数大于5的数据才会被路由到这条分支。</p>
<h4 data-id="heading-29">技巧3：使用正则表达式进行高级文本匹配</h4>
<pre><code class="hljs language-vbnet" lang="vbnet"><span class="hljs-symbol">condition:</span> <span class="hljs-type">String</span>
<span class="hljs-symbol">value1:</span> {{ $json.email }}
<span class="hljs-symbol">operator:</span> matches regex
<span class="hljs-symbol">value2:</span> ^[a-zA-Z0-<span class="hljs-number">9._</span>%+-]+@(gmail|yahoo|outlook)\.com$
</code></pre>
<p>这样只会匹配特定邮箱域名的用户。</p>
<h4 data-id="heading-30">技巧4：先排序再Switch，优化性能</h4>
<p>如果你的数据量很大，先用<strong>Sort节点</strong>对数据进行分组，再用Switch处理，能显著提升性能。</p>
<hr/>
<h3 data-id="heading-31">调试技巧</h3>
<h4 data-id="heading-32">1. 单步执行</h4>
<p>点击Switch节点，选择"<strong>Execute node</strong>"（执行此节点），只执行到这里停止，查看各分支的输出。</p>
<h4 data-id="heading-33">2. 使用日志节点（Logger Node）</h4>
<p>在Switch前后各添加一个Logger节点，记录数据内容：</p>
<pre><code class="hljs language-json" lang="json">前置日志<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><span class="hljs-punctuation">{</span> JSON.stringify($json) <span class="hljs-punctuation">}</span><span class="hljs-punctuation">}</span>
后置日志<span class="hljs-punctuation">:</span> 进入分支 <span class="hljs-punctuation">{</span><span class="hljs-punctuation">{</span> $node<span class="hljs-punctuation">[</span><span class="hljs-string">"Switch"</span><span class="hljs-punctuation">]</span>.json.output <span class="hljs-punctuation">}</span><span class="hljs-punctuation">}</span>
</code></pre>
<h4 data-id="heading-34">3. 检查表达式错误</h4>
<p>在Expression模式下，若有错误，会显示红色警告。鼠标悬停可看错误详情。</p>
<h4 data-id="heading-35">4. 测试数据</h4>
<p>使用"测试数据"功能注入虚拟数据：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"sender"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"test@example.com"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"message"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Test message"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"priority"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"high"</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<hr/>
<h3 data-id="heading-36">总结要点</h3>

































<table><thead><tr><th>要点</th><th>说明</th></tr></thead><tbody><tr><td><strong>适用场景</strong></td><td>需要根据条件将数据分发到多个处理分支</td></tr><tr><td><strong>配置方式</strong></td><td>Rules（可视化）或Expression（编程）</td></tr><tr><td><strong>核心优势</strong></td><td>无限制分支、易于维护、无需编码</td></tr><tr><td><strong>关键参数</strong></td><td>条件、数据类型、比较操作符、降级输出</td></tr><tr><td><strong>常见问题</strong></td><td>大小写、字段名、降级处理</td></tr><tr><td><strong>最佳实践</strong></td><td>使用有意义的输出名称、启用Ignore Case、正确配置降级输出</td></tr></tbody></table>
<hr/>
<h3 data-id="heading-37">下一步学习路径</h3>
<p>掌握Switch节点后，你可以进一步学习：</p>
<ol>
<li><strong>与If节点结合</strong> - 构建更复杂的条件逻辑</li>
<li><strong>Filter节点</strong> - 过滤不需要的数据</li>
<li><strong>Loop Over Items</strong> - 对集合中的每个元素运行Switch</li>
<li><strong>错误处理</strong> - 使用Switch处理异常情况</li>
<li><strong>性能优化</strong> - 在大数据量场景下优化Switch逻辑</li>
</ol>
<hr/>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.n8n.io%2Fintegrations%2Fbuiltin%2Fcore-nodes%2Fn8n-nodes-base.switch%2F" target="_blank" title="https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.switch/" ref="nofollow noopener noreferrer">官方文档</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.undsky.com%2Fblog%2F%3Fcategory%3Dn8n%25E6%2595%2599%25E7%25A8%258B%23" target="_blank" title="https://www.undsky.com/blog/?category=n8n%E6%95%99%E7%A8%8B#" ref="nofollow noopener noreferrer">n8n系列教程</a></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[25-客服工单系统实战（二）：RAG检索与智能问答]]></title>    <link>https://juejin.cn/post/7589919989039087679</link>    <guid>https://juejin.cn/post/7589919989039087679</guid>    <pubDate>2026-01-02T12:17:37.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7589919989039087679" data-draft-id="7589940210832130091" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="25-客服工单系统实战（二）：RAG检索与智能问答"/> <meta itemprop="keywords" content="人工智能"/> <meta itemprop="datePublished" content="2026-01-02T12:17:37.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="kevin_kang"/> <meta itemprop="url" content="https://juejin.cn/user/3034307824720670"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            25-客服工单系统实战（二）：RAG检索与智能问答
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3034307824720670/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    kevin_kang
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-02T12:17:37.000Z" title="Fri Jan 02 2026 12:17:37 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-02
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">客服工单系统实战（二）：RAG检索与智能问答</h2>
<h3 data-id="heading-1">前言</h3>
<p>在上一篇文章中，我们完成了工单数据的导入和向量化存储。本文将介绍如何基于这些向量数据，实现智能检索和问答功能，让AI能够根据历史工单自动推荐解决方案。</p>
<p><strong>本文基于真实项目代码</strong>，所有示例均可在GitHub仓库中找到对应实现。</p>
<p><strong>适合读者：</strong> AI工程师、后端开发者、全栈工程师</p>
<hr/>
<h3 data-id="heading-2">一、RAG工作原理</h3>
<h4 data-id="heading-3">1.1 传统LLM vs RAG</h4>
<pre><code class="hljs">传统LLM：
用户问题 → LLM → 答案
问题：知识有限、可能过时、容易幻觉

RAG（检索增强生成）：
用户问题 → 向量检索 → 相关工单 → 组装Prompt → LLM → 答案
优势：知识可更新、答案更准确、有据可查
</code></pre>
<h4 data-id="heading-4">1.2 完整流程</h4>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-bullet">1.</span> 用户提问："物流信息5天没更新怎么办？"
   ↓
<span class="hljs-bullet">2.</span> 向量化问题 → [0.23, -0.45, 0.67, ...]
   ↓
<span class="hljs-bullet">3.</span> Weaviate检索 → Top-5相似工单
   ↓
<span class="hljs-bullet">4.</span> 组装Prompt（问题 + 历史工单）
   ↓
<span class="hljs-bullet">5.</span> LLM生成答案
   ↓
<span class="hljs-bullet">6.</span> 返回答案 + 来源工单
</code></pre>
<hr/>
<h3 data-id="heading-5">二、向量检索实现</h3>
<h4 data-id="heading-6">2.1 相似度搜索</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># agent/ticket_agent.py</span>
<span class="hljs-keyword">from</span> langchain_core.documents <span class="hljs-keyword">import</span> Document
<span class="hljs-keyword">import</span> weaviate.classes <span class="hljs-keyword">as</span> wvc

<span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceTicketAgent</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_search_similar_documents</span>(<span class="hljs-params">self, query: <span class="hljs-built_in">str</span>, k: <span class="hljs-built_in">int</span> = <span class="hljs-number">5</span></span>) -&gt; <span class="hljs-type">List</span>[Document]:
        <span class="hljs-string">"""搜索相似工单"""</span>
        <span class="hljs-comment"># 1. 生成查询向量</span>
        query_vector = self.embeddings.embed_query(query)
        
        <span class="hljs-comment"># 2. 在Weaviate中搜索</span>
        response = self.collection.query.near_vector(
            near_vector=query_vector,
            limit=k,
            return_metadata=wvc.query.MetadataQuery(distance=<span class="hljs-literal">True</span>)
        )
        
        <span class="hljs-comment"># 3. 转换为Document格式</span>
        documents = []
        <span class="hljs-keyword">for</span> obj <span class="hljs-keyword">in</span> response.objects:
            doc = Document(
                page_content=obj.properties[<span class="hljs-string">'content'</span>],
                metadata={
                    <span class="hljs-string">'ticket_id'</span>: obj.properties.get(<span class="hljs-string">'ticket_id'</span>, <span class="hljs-string">''</span>),
                    <span class="hljs-string">'issue_type'</span>: obj.properties.get(<span class="hljs-string">'issue_type'</span>, <span class="hljs-string">''</span>),
                    <span class="hljs-string">'priority'</span>: obj.properties.get(<span class="hljs-string">'priority'</span>, <span class="hljs-string">''</span>),
                    <span class="hljs-string">'status'</span>: obj.properties.get(<span class="hljs-string">'status'</span>, <span class="hljs-string">''</span>),
                    <span class="hljs-string">'distance'</span>: obj.metadata.distance <span class="hljs-keyword">if</span> obj.metadata <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span>
                }
            )
            documents.append(doc)
        
        <span class="hljs-keyword">return</span> documents
</code></pre>
<h4 data-id="heading-7">2.2 检索测试</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 测试检索功能</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">test_search</span>():
    agent = ServiceTicketAgent()
    
    <span class="hljs-comment"># 测试问题</span>
    question = <span class="hljs-string">"物流信息5天没更新，怎么处理？"</span>
    
    <span class="hljs-comment"># 检索相似工单</span>
    docs = agent._search_similar_documents(question, k=<span class="hljs-number">5</span>)
    
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"检索到 <span class="hljs-subst">{<span class="hljs-built_in">len</span>(docs)}</span> 条相关工单：\n"</span>)
    <span class="hljs-keyword">for</span> i, doc <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(docs, <span class="hljs-number">1</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"工单 <span class="hljs-subst">{i}</span>:"</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"  ID: <span class="hljs-subst">{doc.metadata[<span class="hljs-string">'ticket_id'</span>]}</span>"</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"  类型: <span class="hljs-subst">{doc.metadata[<span class="hljs-string">'issue_type'</span>]}</span>"</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"  距离: <span class="hljs-subst">{doc.metadata[<span class="hljs-string">'distance'</span>]:<span class="hljs-number">.4</span>f}</span>"</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"  内容: <span class="hljs-subst">{doc.page_content[:<span class="hljs-number">100</span>]}</span>..."</span>)
        <span class="hljs-built_in">print</span>()

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    test_search()
</code></pre>
<p><strong>输出示例：</strong></p>
<pre><code class="hljs language-makefile" lang="makefile">检索到 5 条相关工单：

工单 1:
  ID: TK011
  类型: 订单查询
  距离: 0.1234
  内容: 工单编号: TK011
<span class="hljs-section">问题类型: 订单查询</span>
<span class="hljs-section">问题描述: 订单已发货5天但物流信息未更新，担心包裹丢失...</span>

工单 2:
  ID: TK006
  类型: 物流问题
  距离: 0.2456
  内容: 工单编号: TK006
<span class="hljs-section">问题类型: 物流问题</span>
<span class="hljs-section">问题描述: 快递显示已签收但本人未收到货物...</span>
</code></pre>
<hr/>
<h3 data-id="heading-8">三、Prompt工程</h3>
<h4 data-id="heading-9">3.1 Prompt模板设计</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># agent/config.py</span>
QA_PROMPT_TEMPLATE = <span class="hljs-string">"""你是一个专业的客服助手，擅长根据历史工单提供解决方案。

以下是相关的历史工单记录：

{context}

客户问题：{question}

请基于以上历史工单，为客户提供专业的解决方案。要求：
1. 如果找到相关解决方案，请详细说明处理步骤
2. 如果历史工单中没有完全匹配的案例，可以综合多个相似案例给出建议
3. 保持友好、专业的语气
4. 如果确实无法解决，建议客户联系人工客服

回答："""</span>
</code></pre>
<h4 data-id="heading-10">3.2 动态Prompt组装</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> langchain_core.prompts <span class="hljs-keyword">import</span> PromptTemplate

<span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceTicketAgent</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_setup_components</span>(<span class="hljs-params">self</span>):
        <span class="hljs-comment"># 初始化Prompt模板</span>
        self.prompt_template = PromptTemplate(
            input_variables=[<span class="hljs-string">"context"</span>, <span class="hljs-string">"question"</span>],
            template=config.QA_PROMPT_TEMPLATE
        )
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_format_context</span>(<span class="hljs-params">self, docs: <span class="hljs-type">List</span>[Document]</span>) -&gt; <span class="hljs-built_in">str</span>:
        <span class="hljs-string">"""格式化上下文"""</span>
        context_parts = []
        
        <span class="hljs-keyword">for</span> i, doc <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(docs, <span class="hljs-number">1</span>):
            context_parts.append(<span class="hljs-string">f"【历史工单 <span class="hljs-subst">{i}</span>】\n<span class="hljs-subst">{doc.page_content}</span>"</span>)
        
        <span class="hljs-keyword">return</span> <span class="hljs-string">"\n\n"</span>.join(context_parts)
</code></pre>
<hr/>
<h3 data-id="heading-11">四、LCEL问答链</h3>
<h4 data-id="heading-12">4.1 构建问答链</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> langchain_core.runnables <span class="hljs-keyword">import</span> RunnablePassthrough
<span class="hljs-keyword">from</span> langchain_core.output_parsers <span class="hljs-keyword">import</span> StrOutputParser

<span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceTicketAgent</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_setup_qa_chain</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">"""设置问答链（LCEL）"""</span>
        
        <span class="hljs-comment"># 定义格式化函数</span>
        <span class="hljs-keyword">def</span> <span class="hljs-title function_">format_docs</span>(<span class="hljs-params">docs</span>):
            <span class="hljs-keyword">return</span> <span class="hljs-string">"\n\n"</span>.join(doc.page_content <span class="hljs-keyword">for</span> doc <span class="hljs-keyword">in</span> docs)
        
        <span class="hljs-comment"># 定义检索和格式化函数</span>
        <span class="hljs-keyword">def</span> <span class="hljs-title function_">retrieve_and_format</span>(<span class="hljs-params">question</span>):
            docs = self._search_similar_documents(question)
            <span class="hljs-keyword">return</span> format_docs(docs)
        
        <span class="hljs-comment"># 使用LCEL构建链</span>
        self.qa_chain = (
            {
                <span class="hljs-string">"context"</span>: retrieve_and_format,
                <span class="hljs-string">"question"</span>: RunnablePassthrough()
            }
            | self.prompt_template
            | self.llm
            | StrOutputParser()
        )
        
        <span class="hljs-keyword">return</span> self.qa_chain
</code></pre>
<h4 data-id="heading-13">4.2 LCEL优势</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># LCEL的优势：</span>
<span class="hljs-comment"># 1. 简洁优雅 - 使用管道操作符 |</span>
<span class="hljs-comment"># 2. 类型安全 - 自动类型检查</span>
<span class="hljs-comment"># 3. 流式支持 - 天然支持stream</span>
<span class="hljs-comment"># 4. 并行执行 - 自动优化执行顺序</span>

<span class="hljs-comment"># 传统方式（复杂）</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">old_way</span>(<span class="hljs-params">question</span>):
    docs = search(question)
    context = <span class="hljs-built_in">format</span>(docs)
    prompt = template.<span class="hljs-built_in">format</span>(context=context, question=question)
    answer = llm.invoke(prompt)
    <span class="hljs-keyword">return</span> parse(answer)

<span class="hljs-comment"># LCEL方式（简洁）</span>
chain = retriever | <span class="hljs-built_in">format</span> | prompt | llm | parser
answer = chain.invoke(question)
</code></pre>
<hr/>
<h3 data-id="heading-14">五、非流式问答</h3>
<h4 data-id="heading-15">5.1 完整实现</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># agent/ticket_agent.py</span>
<span class="hljs-keyword">import</span> time
<span class="hljs-keyword">from</span> .response <span class="hljs-keyword">import</span> success_response, error_response, AgentErrorCode

<span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceTicketAgent</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">ask</span>(<span class="hljs-params">self, question: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-type">Dict</span>:
        <span class="hljs-string">"""
        完整的智能问答流程
        
        返回格式:
        {
            "code": 0,
            "msg": "success",
            "data": {
                "answer": "答案文本",
                "sources": [...],
                "metadata": {...}
            }
        }
        """</span>
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"\n"</span> + <span class="hljs-string">"="</span> * <span class="hljs-number">60</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"客服问题: <span class="hljs-subst">{question}</span>"</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"="</span> * <span class="hljs-number">60</span>)
        
        start_time = time.time()
        
        <span class="hljs-keyword">try</span>:
            <span class="hljs-comment"># 1. 参数验证</span>
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> question <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> question.strip():
                <span class="hljs-keyword">return</span> error_response(
                    code=AgentErrorCode.QUESTION_FORMAT_ERROR,
                    msg=<span class="hljs-string">"问题不能为空"</span>
                )
            
            <span class="hljs-comment"># 2. 设置问答链</span>
            qa_chain = self._setup_qa_chain()
            
            <span class="hljs-comment"># 3. 检索相关工单</span>
            <span class="hljs-keyword">try</span>:
                source_docs = self._search_similar_documents(question)
            <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
                <span class="hljs-keyword">return</span> error_response(
                    code=AgentErrorCode.RAG_RETRIEVAL_ERROR,
                    msg=<span class="hljs-string">"向量检索失败"</span>,
                    error_detail=<span class="hljs-built_in">str</span>(e)
                )
            
            <span class="hljs-comment"># 4. 检查是否有相关结果</span>
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> source_docs:
                <span class="hljs-keyword">return</span> error_response(
                    code=AgentErrorCode.NO_RELEVANT_RESULTS,
                    msg=<span class="hljs-string">"未找到相关工单记录"</span>
                )
            
            <span class="hljs-comment"># 5. 显示检索到的工单</span>
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"检索到 <span class="hljs-subst">{<span class="hljs-built_in">len</span>(source_docs)}</span> 条相关工单:"</span>)
            sources = []
            <span class="hljs-keyword">for</span> i, doc <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(source_docs, <span class="hljs-number">1</span>):
                metadata = doc.metadata
                ticket_id = metadata.get(<span class="hljs-string">'ticket_id'</span>, <span class="hljs-string">'Unknown'</span>)
                issue_type = metadata.get(<span class="hljs-string">'issue_type'</span>, <span class="hljs-string">'Unknown'</span>)
                priority = metadata.get(<span class="hljs-string">'priority'</span>, <span class="hljs-string">'Unknown'</span>)
                distance = metadata.get(<span class="hljs-string">'distance'</span>)
                
                <span class="hljs-built_in">print</span>(<span class="hljs-string">f"  - <span class="hljs-subst">{ticket_id}</span> (<span class="hljs-subst">{issue_type}</span>) [优先级: <span class="hljs-subst">{priority}</span>]"</span>)
                
                sources.append({
                    <span class="hljs-string">"ticket_id"</span>: ticket_id,
                    <span class="hljs-string">"issue_type"</span>: issue_type,
                    <span class="hljs-string">"priority"</span>: priority,
                    <span class="hljs-string">"status"</span>: metadata.get(<span class="hljs-string">'status'</span>, <span class="hljs-string">'Unknown'</span>),
                    <span class="hljs-string">"score"</span>: <span class="hljs-number">1</span> - distance <span class="hljs-keyword">if</span> distance <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span>
                })
            
            <span class="hljs-comment"># 6. 执行问答</span>
            <span class="hljs-keyword">try</span>:
                answer = qa_chain.invoke(question)
            <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
                <span class="hljs-keyword">return</span> error_response(
                    code=AgentErrorCode.LLM_CALL_ERROR,
                    msg=<span class="hljs-string">"AI 模型调用失败"</span>,
                    error_detail=<span class="hljs-built_in">str</span>(e)
                )
            
            <span class="hljs-comment"># 7. 计算处理时间</span>
            query_time = <span class="hljs-built_in">round</span>(time.time() - start_time, <span class="hljs-number">2</span>)
            
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"="</span> * <span class="hljs-number">60</span>)
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"AI 回答: <span class="hljs-subst">{answer}</span>"</span>)
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"处理时间: <span class="hljs-subst">{query_time}</span>秒"</span>)
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"="</span> * <span class="hljs-number">60</span>)
            
            <span class="hljs-comment"># 8. 返回成功响应</span>
            <span class="hljs-keyword">return</span> success_response(
                answer=answer,
                sources=sources[:<span class="hljs-number">5</span>],
                metadata={
                    <span class="hljs-string">"query_time"</span>: query_time,
                    <span class="hljs-string">"retrieved_docs"</span>: <span class="hljs-built_in">len</span>(source_docs),
                    <span class="hljs-string">"model"</span>: self.chat_model,
                    <span class="hljs-string">"embed_model"</span>: self.embed_model
                }
            )
            
        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
            <span class="hljs-keyword">return</span> error_response(
                code=AgentErrorCode.AGENT_ERROR,
                msg=<span class="hljs-string">"Agent 服务错误"</span>,
                error_detail=<span class="hljs-built_in">str</span>(e)
            )
</code></pre>
<h4 data-id="heading-16">5.2 测试问答</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># test_qa.py</span>
<span class="hljs-keyword">from</span> agent <span class="hljs-keyword">import</span> ServiceTicketAgent

<span class="hljs-keyword">def</span> <span class="hljs-title function_">test_qa</span>():
    agent = ServiceTicketAgent()
    
    <span class="hljs-comment"># 测试问题列表</span>
    questions = [
        <span class="hljs-string">"物流信息5天没更新，怎么处理？"</span>,
        <span class="hljs-string">"客户想退货，如何操作？"</span>,
        <span class="hljs-string">"忘记密码怎么办？"</span>,
        <span class="hljs-string">"笔记本电脑可以升级内存吗？"</span>
    ]
    
    <span class="hljs-keyword">for</span> question <span class="hljs-keyword">in</span> questions:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"\n<span class="hljs-subst">{<span class="hljs-string">'='</span>*<span class="hljs-number">60</span>}</span>"</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"问题: <span class="hljs-subst">{question}</span>"</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'='</span>*<span class="hljs-number">60</span>)
        
        result = agent.ask(question)
        
        <span class="hljs-keyword">if</span> result[<span class="hljs-string">'code'</span>] == <span class="hljs-number">0</span>:
            data = result[<span class="hljs-string">'data'</span>]
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"\n答案:\n<span class="hljs-subst">{data[<span class="hljs-string">'answer'</span>]}</span>"</span>)
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"\n参考工单: <span class="hljs-subst">{<span class="hljs-built_in">len</span>(data[<span class="hljs-string">'sources'</span>])}</span>条"</span>)
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"处理时间: <span class="hljs-subst">{data[<span class="hljs-string">'metadata'</span>][<span class="hljs-string">'query_time'</span>]}</span>秒"</span>)
        <span class="hljs-keyword">else</span>:
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"错误: <span class="hljs-subst">{result[<span class="hljs-string">'msg'</span>]}</span>"</span>)

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    test_qa()
</code></pre>
<hr/>
<h3 data-id="heading-17">六、流式问答</h3>
<h4 data-id="heading-18">6.1 流式实现</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceTicketAgent</span>:
    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">ask_stream</span>(<span class="hljs-params">self, question: <span class="hljs-built_in">str</span></span>):
        <span class="hljs-string">"""
        流式问答，逐token返回答案
        
        Yields:
            dict: 流式事件
            {
                "type": "thinking" | "sources" | "token" | "done" | "error",
                "data": {...}
            }
        """</span>
        start_time = time.time()
        
        <span class="hljs-keyword">try</span>:
            <span class="hljs-comment"># 1. 发送思考状态</span>
            <span class="hljs-keyword">yield</span> {
                <span class="hljs-string">"type"</span>: <span class="hljs-string">"thinking"</span>,
                <span class="hljs-string">"data"</span>: {<span class="hljs-string">"status"</span>: <span class="hljs-string">"retrieving"</span>, <span class="hljs-string">"message"</span>: <span class="hljs-string">"正在检索相关工单..."</span>}
            }
            
            <span class="hljs-comment"># 2. 检索相关工单</span>
            source_docs = self._search_similar_documents(question)
            
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> source_docs:
                <span class="hljs-keyword">yield</span> {
                    <span class="hljs-string">"type"</span>: <span class="hljs-string">"error"</span>,
                    <span class="hljs-string">"data"</span>: {<span class="hljs-string">"code"</span>: <span class="hljs-number">2001</span>, <span class="hljs-string">"msg"</span>: <span class="hljs-string">"未找到相关工单记录"</span>}
                }
                <span class="hljs-keyword">return</span>
            
            <span class="hljs-comment"># 3. 发送检索结果</span>
            sources = []
            <span class="hljs-keyword">for</span> doc <span class="hljs-keyword">in</span> source_docs:
                metadata = doc.metadata
                sources.append({
                    <span class="hljs-string">"ticket_id"</span>: metadata.get(<span class="hljs-string">'ticket_id'</span>, <span class="hljs-string">'Unknown'</span>),
                    <span class="hljs-string">"issue_type"</span>: metadata.get(<span class="hljs-string">'issue_type'</span>, <span class="hljs-string">'Unknown'</span>),
                    <span class="hljs-string">"priority"</span>: metadata.get(<span class="hljs-string">'priority'</span>, <span class="hljs-string">'Unknown'</span>),
                    <span class="hljs-string">"score"</span>: <span class="hljs-number">1</span> - metadata.get(<span class="hljs-string">'distance'</span>, <span class="hljs-number">0</span>)
                })
            
            <span class="hljs-keyword">yield</span> {
                <span class="hljs-string">"type"</span>: <span class="hljs-string">"sources"</span>,
                <span class="hljs-string">"data"</span>: {<span class="hljs-string">"sources"</span>: sources[:<span class="hljs-number">5</span>], <span class="hljs-string">"count"</span>: <span class="hljs-built_in">len</span>(source_docs)}
            }
            
            <span class="hljs-comment"># 4. 发送生成状态</span>
            <span class="hljs-keyword">yield</span> {
                <span class="hljs-string">"type"</span>: <span class="hljs-string">"thinking"</span>,
                <span class="hljs-string">"data"</span>: {<span class="hljs-string">"status"</span>: <span class="hljs-string">"generating"</span>, <span class="hljs-string">"message"</span>: <span class="hljs-string">"正在生成解决方案..."</span>}
            }
            
            <span class="hljs-comment"># 5. 设置问答链</span>
            qa_chain = self._setup_qa_chain()
            
            <span class="hljs-comment"># 6. 流式执行问答</span>
            full_answer = <span class="hljs-string">""</span>
            <span class="hljs-keyword">async</span> <span class="hljs-keyword">for</span> chunk <span class="hljs-keyword">in</span> qa_chain.astream(question):
                token = <span class="hljs-built_in">str</span>(chunk) <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(chunk, <span class="hljs-built_in">str</span>) <span class="hljs-keyword">else</span> chunk
                full_answer += token
                
                <span class="hljs-comment"># 发送token</span>
                <span class="hljs-keyword">yield</span> {
                    <span class="hljs-string">"type"</span>: <span class="hljs-string">"token"</span>,
                    <span class="hljs-string">"data"</span>: {<span class="hljs-string">"token"</span>: token}
                }
            
            <span class="hljs-comment"># 7. 发送完成事件</span>
            query_time = <span class="hljs-built_in">round</span>(time.time() - start_time, <span class="hljs-number">2</span>)
            
            <span class="hljs-keyword">yield</span> {
                <span class="hljs-string">"type"</span>: <span class="hljs-string">"done"</span>,
                <span class="hljs-string">"data"</span>: {
                    <span class="hljs-string">"answer"</span>: full_answer,
                    <span class="hljs-string">"metadata"</span>: {
                        <span class="hljs-string">"query_time"</span>: query_time,
                        <span class="hljs-string">"retrieved_docs"</span>: <span class="hljs-built_in">len</span>(source_docs),
                        <span class="hljs-string">"model"</span>: self.chat_model
                    }
                }
            }
            
        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
            <span class="hljs-keyword">yield</span> {
                <span class="hljs-string">"type"</span>: <span class="hljs-string">"error"</span>,
                <span class="hljs-string">"data"</span>: {<span class="hljs-string">"code"</span>: <span class="hljs-number">2000</span>, <span class="hljs-string">"msg"</span>: <span class="hljs-string">"Agent服务错误"</span>, <span class="hljs-string">"error_detail"</span>: <span class="hljs-built_in">str</span>(e)}
            }
</code></pre>
<h4 data-id="heading-19">6.2 测试流式问答</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># test_stream.py</span>
<span class="hljs-keyword">import</span> asyncio

<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_stream</span>():
    agent = ServiceTicketAgent()
    question = <span class="hljs-string">"物流信息5天没更新，怎么处理？"</span>
    
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"问题: <span class="hljs-subst">{question}</span>\n"</span>)
    
    <span class="hljs-keyword">async</span> <span class="hljs-keyword">for</span> event <span class="hljs-keyword">in</span> agent.ask_stream(question):
        event_type = event[<span class="hljs-string">'type'</span>]
        data = event[<span class="hljs-string">'data'</span>]
        
        <span class="hljs-keyword">if</span> event_type == <span class="hljs-string">'thinking'</span>:
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"💭 <span class="hljs-subst">{data[<span class="hljs-string">'message'</span>]}</span>"</span>)
        
        <span class="hljs-keyword">elif</span> event_type == <span class="hljs-string">'sources'</span>:
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"📚 检索到 <span class="hljs-subst">{data[<span class="hljs-string">'count'</span>]}</span> 条相关工单"</span>)
            <span class="hljs-keyword">for</span> i, source <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(data[<span class="hljs-string">'sources'</span>], <span class="hljs-number">1</span>):
                <span class="hljs-built_in">print</span>(<span class="hljs-string">f"   <span class="hljs-subst">{i}</span>. <span class="hljs-subst">{source[<span class="hljs-string">'ticket_id'</span>]}</span> - <span class="hljs-subst">{source[<span class="hljs-string">'issue_type'</span>]}</span>"</span>)
        
        <span class="hljs-keyword">elif</span> event_type == <span class="hljs-string">'token'</span>:
            <span class="hljs-built_in">print</span>(data[<span class="hljs-string">'token'</span>], end=<span class="hljs-string">''</span>, flush=<span class="hljs-literal">True</span>)
        
        <span class="hljs-keyword">elif</span> event_type == <span class="hljs-string">'done'</span>:
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"\n\n⏱️ 处理时间: <span class="hljs-subst">{data[<span class="hljs-string">'metadata'</span>][<span class="hljs-string">'query_time'</span>]}</span>秒"</span>)
        
        <span class="hljs-keyword">elif</span> event_type == <span class="hljs-string">'error'</span>:
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"❌ 错误: <span class="hljs-subst">{data[<span class="hljs-string">'msg'</span>]}</span>"</span>)

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    asyncio.run(test_stream())
</code></pre>
<hr/>
<h3 data-id="heading-20">七、响应格式设计</h3>
<h4 data-id="heading-21">7.1 统一响应格式</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># agent/response.py</span>
<span class="hljs-keyword">from</span> enum <span class="hljs-keyword">import</span> IntEnum

<span class="hljs-keyword">class</span> <span class="hljs-title class_">AgentErrorCode</span>(<span class="hljs-title class_ inherited__">IntEnum</span>):
    <span class="hljs-string">"""Agent错误码"""</span>
    SUCCESS = <span class="hljs-number">0</span>
    QUESTION_FORMAT_ERROR = <span class="hljs-number">2001</span>
    RAG_RETRIEVAL_ERROR = <span class="hljs-number">2002</span>
    NO_RELEVANT_RESULTS = <span class="hljs-number">2003</span>
    LLM_CALL_ERROR = <span class="hljs-number">2004</span>
    AGENT_ERROR = <span class="hljs-number">2000</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">success_response</span>(<span class="hljs-params">answer: <span class="hljs-built_in">str</span>, sources: <span class="hljs-built_in">list</span>, metadata: <span class="hljs-built_in">dict</span></span>) -&gt; <span class="hljs-built_in">dict</span>:
    <span class="hljs-string">"""成功响应"""</span>
    <span class="hljs-keyword">return</span> {
        <span class="hljs-string">"code"</span>: AgentErrorCode.SUCCESS,
        <span class="hljs-string">"msg"</span>: <span class="hljs-string">"success"</span>,
        <span class="hljs-string">"data"</span>: {
            <span class="hljs-string">"answer"</span>: answer,
            <span class="hljs-string">"sources"</span>: sources,
            <span class="hljs-string">"metadata"</span>: metadata
        }
    }

<span class="hljs-keyword">def</span> <span class="hljs-title function_">error_response</span>(<span class="hljs-params">code: <span class="hljs-built_in">int</span>, msg: <span class="hljs-built_in">str</span>, error_detail: <span class="hljs-built_in">str</span> = <span class="hljs-literal">None</span></span>) -&gt; <span class="hljs-built_in">dict</span>:
    <span class="hljs-string">"""错误响应"""</span>
    response = {
        <span class="hljs-string">"code"</span>: code,
        <span class="hljs-string">"msg"</span>: msg,
        <span class="hljs-string">"data"</span>: <span class="hljs-literal">None</span>
    }
    <span class="hljs-keyword">if</span> error_detail:
        response[<span class="hljs-string">"error_detail"</span>] = error_detail
    <span class="hljs-keyword">return</span> response
</code></pre>
<hr/>
<h3 data-id="heading-22">八、性能优化</h3>
<h4 data-id="heading-23">8.1 缓存检索结果</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> lru_cache

<span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceTicketAgent</span>:
<span class="hljs-meta">    @lru_cache(<span class="hljs-params">maxsize=<span class="hljs-number">100</span></span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_cached_search</span>(<span class="hljs-params">self, question: <span class="hljs-built_in">str</span>, k: <span class="hljs-built_in">int</span> = <span class="hljs-number">5</span></span>):
        <span class="hljs-string">"""缓存检索结果"""</span>
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">tuple</span>(self._search_similar_documents(question, k))
</code></pre>
<h4 data-id="heading-24">8.2 批量问答</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">batch_ask</span>(<span class="hljs-params">self, questions: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">Dict</span>]:
    <span class="hljs-string">"""批量问答"""</span>
    tasks = [self.ask(q) <span class="hljs-keyword">for</span> q <span class="hljs-keyword">in</span> questions]
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> asyncio.gather(*tasks)
</code></pre>
<hr/>
<h3 data-id="heading-25">九、评估指标</h3>
<h4 data-id="heading-26">9.1 检索质量评估</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">evaluate_retrieval</span>(<span class="hljs-params">test_cases: <span class="hljs-type">List</span>[<span class="hljs-type">Dict</span>]</span>):
    <span class="hljs-string">"""评估检索质量"""</span>
    agent = ServiceTicketAgent()
    
    metrics = {
        <span class="hljs-string">"precision"</span>: [],
        <span class="hljs-string">"recall"</span>: [],
        <span class="hljs-string">"mrr"</span>: []  <span class="hljs-comment"># Mean Reciprocal Rank</span>
    }
    
    <span class="hljs-keyword">for</span> <span class="hljs-keyword">case</span> <span class="hljs-keyword">in</span> test_cases:
        question = <span class="hljs-keyword">case</span>[<span class="hljs-string">'question'</span>]
        expected_tickets = <span class="hljs-built_in">set</span>(<span class="hljs-keyword">case</span>[<span class="hljs-string">'expected_tickets'</span>])
        
        <span class="hljs-comment"># 检索</span>
        docs = agent._search_similar_documents(question, k=<span class="hljs-number">5</span>)
        retrieved_tickets = <span class="hljs-built_in">set</span>([doc.metadata[<span class="hljs-string">'ticket_id'</span>] <span class="hljs-keyword">for</span> doc <span class="hljs-keyword">in</span> docs])
        
        <span class="hljs-comment"># 计算指标</span>
        tp = <span class="hljs-built_in">len</span>(expected_tickets &amp; retrieved_tickets)
        precision = tp / <span class="hljs-built_in">len</span>(retrieved_tickets) <span class="hljs-keyword">if</span> retrieved_tickets <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>
        recall = tp / <span class="hljs-built_in">len</span>(expected_tickets) <span class="hljs-keyword">if</span> expected_tickets <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>
        
        metrics[<span class="hljs-string">'precision'</span>].append(precision)
        metrics[<span class="hljs-string">'recall'</span>].append(recall)
    
    <span class="hljs-comment"># 平均值</span>
    <span class="hljs-keyword">return</span> {
        <span class="hljs-string">"avg_precision"</span>: <span class="hljs-built_in">sum</span>(metrics[<span class="hljs-string">'precision'</span>]) / <span class="hljs-built_in">len</span>(metrics[<span class="hljs-string">'precision'</span>]),
        <span class="hljs-string">"avg_recall"</span>: <span class="hljs-built_in">sum</span>(metrics[<span class="hljs-string">'recall'</span>]) / <span class="hljs-built_in">len</span>(metrics[<span class="hljs-string">'recall'</span>])
    }
</code></pre>
<hr/>
<h3 data-id="heading-27">十、总结</h3>
<p>本文介绍了客服工单系统的RAG检索和问答实现：</p>
<p>✅ <strong>向量检索</strong> - Weaviate相似度搜索<br/>
✅ <strong>Prompt工程</strong> - 动态组装上下文<br/>
✅ <strong>LCEL问答链</strong> - 优雅的链式调用<br/>
✅ <strong>流式问答</strong> - 实时打字机效果<br/>
✅ <strong>响应格式</strong> - 统一的错误处理</p>
<p><strong>下一篇预告：</strong> 《客服工单系统实战（三）：前后端集成与生产部署》</p>
<p>我们将介绍如何将Agent服务集成到完整的前后端系统中，并部署到生产环境。</p>
<hr/>
<p><strong>作者简介：</strong> 资深开发者，创业者。专注于视频通讯技术领域。国内首本Flutter著作《Flutter技术入门与实战》作者,另著有《Dart语言实战》及《WebRTC音视频开发》等书籍。多年从事视频会议、远程教育等技术研发，对于Android、iOS以及跨平台开发技术有比较深入的研究和应用，作为主要程序员开发了多个应用项目，涉及医疗、交通、银行等领域。</p>
<p><strong>学习资料：</strong></p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fkangshaojun%2Fai-agent-framework" target="_blank" title="https://github.com/kangshaojun/ai-agent-framework" ref="nofollow noopener noreferrer">项目地址</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fkangshaojun" target="_blank" title="https://github.com/kangshaojun" ref="nofollow noopener noreferrer">作者GitHub</a></li>
</ul>
<p><strong>欢迎交流：</strong> 如有问题欢迎在评论区讨论 🚀</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[3天速成 使用AI《从零开发一款 AI 面试作弊助手》一]]></title>    <link>https://juejin.cn/post/7590213554797805603</link>    <guid>https://juejin.cn/post/7590213554797805603</guid>    <pubDate>2026-01-02T15:31:19.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7590213554797805603" data-draft-id="7590071125398749224" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="3天速成 使用AI《从零开发一款 AI 面试作弊助手》一"/> <meta itemprop="keywords" content="React.js,Next.js"/> <meta itemprop="datePublished" content="2026-01-02T15:31:19.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="无敌暴龙战士通关前端"/> <meta itemprop="url" content="https://juejin.cn/user/3373747481880926"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            3天速成 使用AI《从零开发一款 AI 面试作弊助手》一
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3373747481880926/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    无敌暴龙战士通关前端
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-02T15:31:19.000Z" title="Fri Jan 02 2026 15:31:19 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-02
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">一、别焦虑了，先把“外挂”做出来</h2>
<p>最近技术圈充满了“前端已死”、“AI 取代程序员”的论调。焦虑是真实的，但大部分焦虑来自“看别人做”，而不是“自己做”。</p>
<p>当你真正动手用 AI 开发一个复杂的<strong>实时交互产品</strong>时，你会发现：AI 很强，但某些细节需要调试和把控。</p>
<p>用AI，三天从 0 开始打造一款<strong>AI 面试作弊助手</strong>。不是 Demo，是能实时听懂面试官提问、能看懂笔试题屏幕、并即时推送答案的“硬核外挂”。</p>
<p>这篇文章，就是这次前端架构的完整复盘。</p>
<p>项目地址:<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.offercar.cn%2F" target="_blank" title="https://www.offercar.cn/" ref="nofollow noopener noreferrer">OfferCar AI - AI 面试笔试助手 | 智能面试模拟平台</a></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/80f3241172974993b612b350ae10131c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5peg5pWM5pq06b6Z5oiY5aOr6YCa5YWz5YmN56uv:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767972678&amp;x-signature=rgMMyztaeioZEVFm5mR%2B9OlePn4%3D" alt="image.png" loading="lazy"/></p>
<h2 data-id="heading-1">二、架构美学：不做通用，做场景</h2>
<p>市面上的 AI 聊天 Demo 满天飞，大多是 <code>useChat</code> 一把梭。但在“面试作弊”这个高压场景下，通用型架构根本扛不住。</p>
<p>我们需要的是<strong>极致的解耦</strong>。</p>
<h3 data-id="heading-2">1. UI 与逻辑的物理隔离</h3>
<p><strong>UI 组件不持有业务状态</strong>。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a81417d75f3b4bc98c7b2e2a224035f7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5peg5pWM5pq06b6Z5oiY5aOr6YCa5YWz5YmN56uv:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767972678&amp;x-signature=KyaGB7so9sPOvDY3dtD6p4ZZBPs%3D" alt="image.png" loading="lazy"/></p>
<p>为此抽象了 <code>SessionMainContent</code> —— 它是整个系统的“显示器”。它只负责一件事：<strong>渲染</strong>。</p>
<ul>
<li>它不关心是“面试”还是“笔试”。</li>
<li>它不关心消息是 Socket 推送的还是 HTTP 拉取的。</li>
<li>它只接收 <code>messages</code> 数组和回调函数。</li>
</ul>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 纯粹的 UI 定义，没有杂乱的 useEffect</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">SessionMainContentProps</span> {
  <span class="hljs-attr">messages</span>: <span class="hljs-title class_">ChatMessage</span>[];        <span class="hljs-comment">// 数据源</span>
  <span class="hljs-attr">streamingContent</span>: <span class="hljs-built_in">string</span>;       <span class="hljs-comment">// 流式缓冲区</span>
  <span class="hljs-attr">isStreaming</span>: <span class="hljs-built_in">boolean</span>;           <span class="hljs-comment">// 状态位</span>
  <span class="hljs-attr">sendPendingMessagesToAI</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>; <span class="hljs-comment">// 动作指令</span>
  <span class="hljs-comment">// ...</span>
}
</code></pre>
<h3 data-id="heading-3">2. 业务容器：Controller 的诞生</h3>
<p><code>ExamSession</code> 和 <code>InterviewSession</code>。这两个组件是真正的<strong>业务容器</strong>。</p>
<ul>
<li><strong>InterviewSession</strong>：初始化 <code>useInterviewSession</code>，建立语音识别通道，挂载 <code>DeviceStatusPanel</code>（音量监控）。</li>
<li><strong>ExamSession</strong>：初始化 <code>useExamSession</code>，监听全局截图指令，挂载简化版状态栏。</li>
</ul>
<p>这种设计让 MVP 阶段的代码极易维护：改 UI 不动逻辑，改逻辑不崩 UI。</p>
<h2 data-id="heading-4">三、核心大脑：<code>useChatSession</code> 的炼成</h2>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c5016cafdf8e4a39b5a76f25d943ed24~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5peg5pWM5pq06b6Z5oiY5aOr6YCa5YWz5YmN56uv:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767972678&amp;x-signature=C8LN%2BiMI%2FdcWCs1HfhYAeIIJ%2Fvg%3D" alt="image.png" loading="lazy"/>
这是整个前端最“重”的 Hook，也是与 LLM 搏斗的修罗场。在 MVP 阶段，我砍掉了所有花哨功能，只保留<strong>付费闭环</strong>所需的逻辑。</p>
<h3 data-id="heading-5">1. 思考链（CoT）的 60fps 渲染</h3>
<p>现在的 DeepSeek 等推理模型会输出 <code>&lt;think&gt;</code> 标签。如果直接渲染，用户会看到一堆乱码；如果等思考完再显示，用户会以为网断了。</p>
<p>我的解法：<strong>流式解析 + 渲染节流</strong>。</p>
<p>我们实现了一个 <code>thinkTagProcessor</code>，实时将 <code>&lt;think&gt;</code> 转换为 Markdown 的引用块 <code>&gt; </code>。同时，为了防止高频 <code>setState</code> 导致 React 掉帧（尤其在低端笔记本上），我加入了 <code>requestAnimationFrame</code> 节流。</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 节流阀：让 AI 的思考过程如丝般顺滑，而不是卡顿的打印机</span>
<span class="hljs-keyword">const</span> tickThinkThrottle = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">if</span> (!isThinkRafRunningRef.<span class="hljs-property">current</span>) <span class="hljs-keyword">return</span>;
  <span class="hljs-title function_">setStreamingContent</span>(remainTextRef.<span class="hljs-property">current</span>); <span class="hljs-comment">// 只有这里才会触发重绘</span>
  thinkRafIdRef.<span class="hljs-property">current</span> = <span class="hljs-title function_">requestAnimationFrame</span>(tickThinkThrottle);
}, []);
</code></pre>
<h3 data-id="heading-6">2. 消息围栏：只听面试官的话</h3>
<p>面试场景有一个痛点：面试者的废话太多。如果全发给 AI，上下文瞬间爆炸。</p>
<p>我在 <code>sendPendingMessagesToAI</code> 中加入了一层<strong>过滤器</strong>：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">const</span> sendPendingMessagesToAI = <span class="hljs-title function_">useCallback</span>(<span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">const</span> pendingMessages = messages.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">msg</span>) =&gt;</span> {
    <span class="hljs-comment">// 开启 scopeCharacter 后，AI 自动屏蔽面试者发言，只聚焦面试官的问题</span>
    <span class="hljs-keyword">if</span> (scopeCharacter) {
      <span class="hljs-keyword">return</span> msg.<span class="hljs-property">speaker</span> === <span class="hljs-string">'interviewer'</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  });
  <span class="hljs-comment">// ...</span>
}, [<span class="hljs-comment">/*...*/</span>]);
</code></pre>
<p>这不仅仅是省 Token，更是为了<strong>提高回答的信噪比</strong>。</p>
<h2 data-id="heading-7">四、降维打击：WebRTC 的另类用法</h2>
<p>提到 WebRTC，大家第一反应是视频通话。但在我的架构里，WebRTC 是<strong>跨端通信的高速公路</strong>。</p>
<p>这是典型的“技术降维打击”。我们不需要视频流，我们需要的是<strong>低延迟的指令通道</strong>。</p>
<h3 data-id="heading-8">1. DataChannel：不传视频传指令</h3>
<p>我利用 WebRTC 的 <code>DataChannel</code> 建立了两个核心管道：</p>
<ul>
<li><strong><code>exam-commands</code></strong>：传输控制指令。Electron 截图后，通过此通道直接将 Base64 推送到 Web 端，速度毫秒级。</li>
<li><strong><code>recognition-text</code></strong>：传输实时语音转写文本。</li>
</ul>
<p>这种设计避开了传统 HTTP 轮询的延迟，也比 WebSocket 更轻量（P2P 直连）。</p>
<pre><code class="hljs language-typescript:hooks.ts" lang="typescript:hooks.ts">// 监听来自 Electron 的“量子纠缠”信号
channel.onmessage = (event) =&gt; {
  const message = JSON.parse(event.data);
  if (message.type === 'screenshot') {
    // 瞬间上屏，无感知传输
    addImageToPendingMessages(message.data);
  }
};
</code></pre>
<h2 data-id="heading-9">五、体验微操：Redux 配置中心</h2>
<p>UI/UX 的作用是什么？是**“显得值钱”**。</p>
<p>为了让用户觉得“这个外挂很专业”，我用 Redux Toolkit (<code>settingsSlice</code>) 管理了全局偏好：</p>
<ul>
<li><strong>字号微调</strong>：AI 回答字号、面试官字号独立控制。</li>
<li><strong>双语开关</strong>：一键切换中英对照，瞬间提升逼格。</li>
</ul>
<p>这些配置在 <code>SessionMainContent</code> 中被实时订阅。用户拖动滑块，界面即时响应。这种<strong>掌控感</strong>，是付费意愿的来源之一。</p>
<h2 data-id="heading-10">六、结语：AI 时代，拿回你的生产资料</h2>
<p>写到这里，我想说：代码只是工具，是连接现实与数字世界的铲子。AI 让这把铲子变成了挖掘机，但挖掘机本身不会决定去哪里挖掘宝藏。</p>
<p>在这个项目里，AI 帮我生成了100% 的 业务逻辑。
别焦虑，去创造。打开编辑器，去想一个你真正想解决的问题。
项目地址:<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.offercar.cn%2F" target="_blank" title="https://www.offercar.cn/" ref="nofollow noopener noreferrer">OfferCar AI - AI 面试笔试助手 | 智能面试模拟平台</a></p>
<p>下一篇，我们将深入 Electron 客户端，看看如何进入系统音频流，实现无感采集。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[十分钟入门SpringAI]]></title>    <link>https://juejin.cn/post/7590654280899592235</link>    <guid>https://juejin.cn/post/7590654280899592235</guid>    <pubDate>2026-01-02T15:52:07.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7590654280899592235" data-draft-id="7590020026395410486" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="十分钟入门SpringAI"/> <meta itemprop="keywords" content="AI编程"/> <meta itemprop="datePublished" content="2026-01-02T15:52:07.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="天道佩恩"/> <meta itemprop="url" content="https://juejin.cn/user/536217406931069"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            十分钟入门SpringAI
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/536217406931069/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    天道佩恩
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-02T15:52:07.000Z" title="Fri Jan 02 2026 15:52:07 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-02
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读2分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">前言</h2>
<p>SpringAI，Make Java great again</p>
<p>还得是Spring啊，Java开发一辈子都得熟练掌握的框架，SpringAI帮你对接多个AI模型，屏蔽底层复杂的处理，使用抽象、统一的接口，切换模型只需更改配置，无需改代码，十分钟入门 Java-AI开发，接下来开始上课！上一篇介绍了本地下载Ollama，本期不再赘述，但是需要开启本地Ollama</p>
<p>众所周知，Spring框架开发三部曲，导入依赖，编写配置，编写业务代码， SpringAI也是如此</p>
<h2 data-id="heading-1">导入依赖</h2>
<p>SpringAI支持的jdk最低版本为17，spring-boot最低版本3.x</p>
<p><strong>PS：以下的 dependencyManagement 是帮忙管理 spring-ai 相关依赖的，非常重要，一定要带上</strong></p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.9<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>
</code></pre>

<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>17<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">spring-ai.version</span>&gt;</span>1.1.2<span class="hljs-tag">&lt;/<span class="hljs-name">spring-ai.version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.ai<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-ai-starter-model-ollama<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
​
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.22<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>
</code></pre>

<pre><code class="hljs language-xml" lang="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.ai<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-ai-bom<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>${spring-ai.version}<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span>
</code></pre>
<h2 data-id="heading-2">编写配置</h2>
<p>有2个配置，application.yml 和 Configuration</p>
<h3 data-id="heading-3">application.yml</h3>
<p>主要是模型，访问地址，日志输出;</p>
<p>1.11434 是 Ollama 默认端口</p>
<p>2.model 就是本地启动的 AI 模型，模型名称大小写敏感，注意别写错</p>
<p>3.设置日志输出级别，还要在 Bean 上配置 Advisor，设置 level 最好是精确到包，否则日志太多</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">application:</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">springai</span>
  <span class="hljs-attr">ai:</span>
    <span class="hljs-attr">ollama:</span>
      <span class="hljs-attr">base-url:</span> <span class="hljs-string">http://localhost:11434</span>
      <span class="hljs-attr">chat:</span>
        <span class="hljs-attr">model:</span> <span class="hljs-string">deepseek-r1:8b</span>
<span class="hljs-attr">logging:</span>
  <span class="hljs-attr">level:</span>
    <span class="hljs-attr">org.springframework.ai.chat.client.advisor:</span> <span class="hljs-string">debug</span>
    <span class="hljs-attr">com.pain.springai:</span> <span class="hljs-string">debug</span>
</code></pre>
<h2 data-id="heading-4">配置Configuration</h2>
<p>defaultSystem：系统配置，可以设定角色</p>
<p>defaultAdvisor：日志增强器</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">import</span> org.springframework.ai.chat.client.ChatClient;
<span class="hljs-keyword">import</span> org.springframework.ai.chat.client.advisor.SimpleLoggerAdvisor;
<span class="hljs-keyword">import</span> org.springframework.ai.ollama.OllamaChatModel;
<span class="hljs-keyword">import</span> org.springframework.context.<span class="hljs-keyword">annotation</span>.Bean;
<span class="hljs-keyword">import</span> org.springframework.context.<span class="hljs-keyword">annotation</span>.Configuration;
​
<span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CommonConfig</span> {
​
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-keyword">public</span> ChatClient  chatClient(OllamaChatModel model){
        <span class="hljs-keyword">return</span> ChatClient.builder(model)
                .defaultSystem(<span class="hljs-string">"你是高傲冷酷的天道佩恩，请以天道佩恩的身份和语气回答问题"</span>)
                .defaultAdvisors(new SimpleLoggerAdvisor())
                .build();
    }
}
</code></pre>
<h2 data-id="heading-5">业务代码</h2>
<p>写一个Controller，注入ChatClient，然后就可以对话了</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">import</span> lombok.RequiredArgsConstructor;
<span class="hljs-keyword">import</span> org.springframework.ai.chat.client.ChatClient;
<span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.RequestMapping;
<span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.RestController;
<span class="hljs-keyword">import</span> reactor.core.publisher.Flux;
​
<span class="hljs-meta">@RestController</span>
<span class="hljs-meta">@RequestMapping(<span class="hljs-string">"/ai"</span>)</span>
<span class="hljs-meta">@RequiredArgsConstructor</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChatController</span> {
​
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ChatClient chatClient;
​
    <span class="hljs-meta">@RequestMapping(<span class="hljs-string">"/chat"</span>)</span>
    <span class="hljs-keyword">public</span> String chat(String prompt) {
        <span class="hljs-keyword">return</span> chatClient.prompt()
                .user(prompt)
                .call()
                .content();
    }
​
    <span class="hljs-meta">@RequestMapping(value = <span class="hljs-string">"/chat/flux"</span>, produces = <span class="hljs-string">"text/html;charset=utf-8"</span>)</span>
    <span class="hljs-keyword">public</span> Flux&lt;String&gt; fluxChat(String prompt) {
        <span class="hljs-keyword">return</span> chatClient.prompt()
                .user(prompt)
                .stream()
                .content();
    }
}
</code></pre>
<p>默认服务器的端口是8080，拼接一下端口访问：<a href="https://link.juejin.cn?target=url" target="_blank" title="url" ref="nofollow noopener noreferrer">http:localhost:8080/ai/chat </a><br/>
访问服务器</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/73521af68408461ca09b41f42cce47bc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSp6YGT5L2p5oGp:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767973927&amp;x-signature=wvo2mzej%2B7X9ivNXu%2Btr4CLZzU8%3D" alt="图片" loading="lazy"/><br/>
日志输出</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3edf7b2ae40746cd9439faca68fa6174~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSp6YGT5L2p5oGp:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767973927&amp;x-signature=G8HZukCE3%2BT9XFRtoh0MIRXhW5c%3D" alt="图片" loading="lazy"/></p>
<p>下一篇带你们更深入的了解SpringAI强大的功能</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Git 仓库过滤敏感信息，通过配置 clean/smudge 过滤器的方式]]></title>    <link>https://juejin.cn/post/7590654280899526699</link>    <guid>https://juejin.cn/post/7590654280899526699</guid>    <pubDate>2026-01-02T13:28:38.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7590654280899526699" data-draft-id="7590011643297251366" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Git 仓库过滤敏感信息，通过配置 clean/smudge 过滤器的方式"/> <meta itemprop="keywords" content="后端,前端,GitHub"/> <meta itemprop="datePublished" content="2026-01-02T13:28:38.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="GentlyBeing"/> <meta itemprop="url" content="https://juejin.cn/user/543573892409056"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Git 仓库过滤敏感信息，通过配置 clean/smudge 过滤器的方式
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/543573892409056/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    GentlyBeing
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-02T13:28:38.000Z" title="Fri Jan 02 2026 13:28:38 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-02
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    7
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读10分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:14px;overflow-x:hidden;color:var(--cyanosis-base-color);transition:color .35s;--cyanosis-base-color:#353535;--cyanosis-title-color:#005bb7;--cyanosis-strong-color:#2196f3;--cyanosis-em-color:#4fc3f7;--cyanosis-del-color:#ccc;--cyanosis-link-color:#3da8f5;--cyanosis-linkh-color:#007fff;--cyanosis-border-color:#bedcff;--cyanosis-border-color-2:#ececec;--cyanosis-bg-color:#fff;--cyanosis-blockquote-color:#8c8c8c;--cyanosis-blockquote-bg-color:#f0fdff;--cyanosis-code-color:#c2185b;--cyanosis-code-bg-color:#fff4f4;--cyanosis-code-pre-color:#f8f8f8;--cyanosis-table-border-color:#c3e0fd;--cyanosis-table-th-color:#dff0ff;--cyanosis-table-tht-color:#005bb7;--cyanosis-table-tr-nc-color:#f7fbff;--cyanosis-table-trh-color:#e0edf7;--cyanosis-slct-title-color:#005bb7;--cyanosis-slct-titlebg-color:rgba(175,207,247,0.25);--cyanosis-slct-text-color:#c80000;--cyanosis-slct-bg-color:rgba(175,207,247,0.25);--cyanosis-slct-del-color:#999;--cyanosis-slct-elbg-color:#e8ebec;--cyanosis-slct-codebg-color:#ffeaeb;--cyanosis-slct-prebg-color:rgba(160,200,255,0.25)}.markdown-body.__dark{--cyanosis-base-color:#cacaca;--cyanosis-title-color:#ddd;--cyanosis-strong-color:#fe9900;--cyanosis-em-color:#ffd28e;--cyanosis-del-color:#ccc;--cyanosis-link-color:#ffb648;--cyanosis-linkh-color:#fe9900;--cyanosis-border-color:#ffe3ba;--cyanosis-border-color-2:#ffcb7b;--cyanosis-bg-color:#2f2f2f;--cyanosis-blockquote-color:#c7c7c7;--cyanosis-blockquote-bg-color:rgba(255,199,116,0.1);--cyanosis-code-color:#000;--cyanosis-code-bg-color:#ffcb7b;--cyanosis-code-pre-color:rgba(255,227,185,0.5);--cyanosis-table-border-color:#fe9900;--cyanosis-table-th-color:#ffb648;--cyanosis-table-tht-color:#000;--cyanosis-table-tr-nc-color:#6d5736;--cyanosis-table-trh-color:#947443;--cyanosis-slct-title-color:#000;--cyanosis-slct-titlebg-color:#fe9900;--cyanosis-slct-text-color:#00c888;--cyanosis-slct-bg-color:rgba(175,207,247,0.25);--cyanosis-slct-del-color:#999;--cyanosis-slct-elbg-color:#000;--cyanosis-slct-codebg-color:#ffcb7b;--cyanosis-slct-prebg-color:rgba(160,200,255,0.25)}.markdown-body h1{padding-bottom:4px;font-size:30px}.markdown-body h1,.markdown-body h2{margin-top:36px;margin-bottom:10px;line-height:1.5;color:var(--cyanosis-title-color);transition:color .35s}.markdown-body h2{position:relative;padding-left:10px;padding-right:10px;padding-bottom:10px;font-size:24px;border-bottom:1px solid var(--cyanosis-border-color-2)}.markdown-body h2:before{content:"「";position:absolute;top:-6px;left:-14px}.markdown-body h2:after{content:"」";position:relative;top:6px;right:auto}.markdown-body h3{position:relative;padding-bottom:0;margin-top:30px;margin-bottom:10px;font-size:20px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body h3:before{content:"»";padding-right:6px;color:var(--cyanosis-strong-color)}.markdown-body h4{margin-top:24px;font-size:16px}.markdown-body h4,.markdown-body h5{padding-bottom:0;margin-bottom:10px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body h5{margin-top:18px;font-size:14px}.markdown-body h6{padding-bottom:0;margin-top:12px;margin-bottom:10px;font-size:12px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body p{line-height:inherit;margin-top:16px;margin-bottom:16px}.markdown-body img{max-width:100%}.markdown-body hr{position:relative;width:98%;height:1px;margin-top:32px;margin-bottom:32px;background-image:linear-gradient(90deg,var(--cyanosis-link-color),rgba(255,0,0,.3),hsla(0,0%,100%,.1),rgba(255,0,0,.3),var(--cyanosis-link-color));border-width:0;overflow:visible}.markdown-body hr:after{content:"";position:absolute;margin:auto;left:0;right:0;bottom:0;top:0;display:inline-block;width:60px;height:20px;background-color:var(--cyanosis-bg-color);background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAgCAYAAABgrToAAAADoklEQVRYR82XTYgcRRTHf2933Q1RjAa9eFO8JHoJ8RQVBQ2iBwXBET0YEUTXNVmNQtTpmeqaWV0XNRq/o4KoECSCEPSg4CF+BYUkIIiCoCJCPIhC/Ihh2Z0nVV27VnZnenumW9i6ddV7//frV69fVQurfMgq56NawFTPAU6QyomqXrw6wIZeyhCPebA5buNR+akKyGoAjd6BshthnYdSjqNcRVuOlIUsD2j0SuA94IwuMHdh5ZUykOUBXfSGbmKI54EtAeYIHSZoy5dl4JxvNYBOKdW1KE8BQ8AkVk6WhasWsAiN0TX9gveXQaPP+Aytpc4u+bMI06JNohsYYYYOR2lJWtS3OKDRfcAtQfgDoI6Vo4UCGb0OmAEuDvZvYmVbEd/igC3dzDz7gQu8sPA9kJDK27mBmjqBeLjTg90PDFOjWawFFQd06kZHEfaj3LAIpTRpSXsZ5E06zEYP9sDimnAApYaV2SLZG/wjMeqAkijwW4xQJ5Gf/ZzRC8OW3hiBTGGlURRswW55Bh/Ssxljrwew8l1PQaM14GngvGDzBUKdDsMeTtgU5o8B92PFlUf3YXUrHa7Fys6lBqcCGnX15YQ2A18FyPd7Crd1A3M8C1wdbH4DD3hWeP6IEXbQkG97ajR1HPFnuPP5jFFq1OWX7hl8WM9l1AO648uNfwLk7tytMeogty+xeQ4rO3r6bdcx1nuwOGsHmaXGtPzae4uzGnLH1kQkvpdZGrHjssBZJrL+pqS05KWc8tgITAPXRzYvYOXe/C2OV43eDcRBDtIhoS2f9wzc0Cv8Wls+zoFzUC5zF0U241h5uZtPfptp6OUM8wbK+cH5GEpCS17P3fJei0Z3+npTxryJ8CPzbKMtn/ZyWbkPGl0PuFPkmkjkcb4h4R2ZLwRq1H0ALmvjkf2HwK1Y+T1PY2XABe/sHJ6MxN5lnoSpnC/UGbsTaI5phK2R7x6s3Ffk5YoDOrWm3onwJHBmEP86bPmBrsGaenNoIdnxCH+gPEhLXi0Cl1VBvyPVLSh7gEuC62yAfOIUqabWEaaiucMIk6RyqJ+Q/QM69V26jjW86Gvov/EaoyT8zRCn+Xq7PVrbx0nuYUaO9wM3WAbjCE1NEUw09Um4UV+2OKfYfu5/S19gsAzGKqm6LE5FrShbdS0ku465DjDwKA/oQht19ejqbaEVuRbiLhuHByYLjtUAZpDutzP7cYdHsPJXWbjyNVgFwQoa1WXwf4Jd9YD/Ap80+yE7+u9aAAAAAElFTkSuQmCC);background-repeat:no-repeat;background-size:auto 100%;background-position-x:center;transition:background-color .5s}.markdown-body code{padding:.065em .4em;font-size:.87em;color:var(--cyanosis-code-color);word-break:break-word;overflow-x:auto;background-color:var(--cyanosis-code-bg-color);border-radius:2px}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{display:block;padding:16px 12px;margin:0;font-size:12px;color:#333;word-break:normal;overflow-x:auto;background:var(--cyanosis-code-pre-color)}.markdown-body pre&gt;code::-webkit-scrollbar{width:4px;height:4px}.markdown-body pre&gt;code::-webkit-scrollbar-track{background-color:var(--cyanosis-border-color)}.markdown-body pre&gt;code::-webkit-scrollbar-thumb{background-color:var(--cyanosis-strong-color);border-radius:10px}.markdown-body a{position:relative;text-decoration:none;color:var(--cyanosis-link-color);border-bottom:1px solid var(--cyanosis-border-color)}.markdown-body a:hover{border-bottom-color:var(--cyanosis-linkh-color)}.markdown-body a:active,.markdown-body a:hover{color:var(--cyanosis-linkh-color)}.markdown-body a:after{position:absolute;content:"";top:100%;left:0;width:100%;opacity:0;border-bottom:1px solid var(--cyanosis-border-color);transition:top .3s,opacity .3s;transform:translateZ(0)}.markdown-body a:hover:after{top:0;opacity:1;border-bottom-color:var(--cyanosis-linkh-color)}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid var(--cyanosis-table-border-color);border-spacing:0;border-collapse:collapse}.markdown-body table thead{color:#000;text-align:left;font-size:14px;background:#f6f6f6}.markdown-body table tr:nth-child(2n){background-color:var(--cyanosis-table-tr-nc-color)}.markdown-body table tr:hover{background-color:var(--cyanosis-table-trh-color)}.markdown-body table td,.markdown-body table th{padding:12px 8px;line-height:24px;border:1px solid var(--cyanosis-table-border-color)}.markdown-body table th{color:var(--cyanosis-table-tht-color);background-color:var(--cyanosis-table-th-color)}.markdown-body table td{min-width:120px}.markdown-body blockquote{color:var(--cyanosis-blockquote-color);border-left:4px solid var(--cyanosis-strong-color);background-color:var(--cyanosis-blockquote-bg-color);padding:1px 20px;margin:22px 0;transition:color .35s}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body b,.markdown-body blockquote&gt;b,.markdown-body blockquote&gt;strong,.markdown-body strong{color:var(--cyanosis-strong-color)}.markdown-body em,.markdown-body i{color:var(--cyanosis-em-color)}.markdown-body del{color:var(--cyanosis-del-color)}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:4px}.markdown-body ol li{padding-left:6px}.markdown-body details&gt;summary{outline:none;color:var(--cyanosis-title-color);font-size:20px;font-weight:bolder;border-bottom:1px solid var(--cyanosis-border-color);cursor:pointer}.markdown-body details&gt;p{padding:10px 20px;margin:10px 0 0;color:#666;background-color:var(--cyanosis-blockquote-bg-color);border:2px dashed var(--cyanosis-strong-color)}.markdown-body h1::selection,.markdown-body h2::selection,.markdown-body h3::selection,.markdown-body h4::selection,.markdown-body h5::selection,.markdown-body h6::selection{color:var(--cyanosis-slct-title-color);background-color:var(--cyanosis-slct-titlebg-color)}.markdown-body ol li::selection,.markdown-body p::selection,.markdown-body ul li::selection{color:var(--cyanosis-slct-text-color);background-color:var(--cyanosis-slct-bg-color)}.markdown-body a::selection,.markdown-body b::selection,.markdown-body em::selection,.markdown-body i::selection,.markdown-body strong::selection{background-color:var(--cyanosis-slct-elbg-color)}.markdown-body del::selection{color:var(--cyanosis-slct-del-color);background-color:var(--cyanosis-slct-elbg-color)}.markdown-body table thead th::selection{background-color:transparent}.markdown-body table tbody td::selection{background-color:var(--cyanosis-slct-bg-color)}.markdown-body code::selection{background-color:var(--cyanosis-slct-codebg-color)}.markdown-body pre&gt;code::selection{background-color:var(--cyanosis-slct-prebg-color)}.markdown-body .contains-task-list{padding-left:14px;list-style:none}.markdown-body .contains-task-list input[type=checkbox]{position:relative}.markdown-body .contains-task-list input[type=checkbox]:before{content:"";position:absolute;top:0;left:0;right:0;bottom:0;width:inherit;height:inherit;background:#f0f8ff;border:1px solid #add6ff;border-radius:2px;box-sizing:border-box;z-index:1}.markdown-body .contains-task-list input[type=checkbox]:checked:after{content:"✓";position:absolute;top:-12px;left:0;right:0;bottom:0;width:0;height:0;color:#f55;font-size:20px;font-weight:700;z-index:2}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="a11y-dark">.hljs-comment,.hljs-quote{color:#d4d0ab}.hljs-deletion,.hljs-name,.hljs-regexp,.hljs-selector-class,.hljs-selector-id,.hljs-tag,.hljs-template-variable,.hljs-variable{color:#ffa07a}.hljs-built_in,.hljs-builtin-name,.hljs-link,.hljs-literal,.hljs-meta,.hljs-number,.hljs-params,.hljs-type{color:#f5ab35}.hljs-attribute{color:gold}.hljs-addition,.hljs-bullet,.hljs-string,.hljs-symbol{color:#abe338}.hljs-section,.hljs-title{color:#00e0e0}.hljs-keyword,.hljs-selector-tag{color:#dcc6e0}.markdown-body pre,.markdown-body pre&gt;code.hljs{background:#2b2b2b;color:#f8f8f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}@media screen and (-ms-high-contrast:active){.hljs-addition,.hljs-attribute,.hljs-built_in,.hljs-builtin-name,.hljs-bullet,.hljs-comment,.hljs-link,.hljs-literal,.hljs-meta,.hljs-number,.hljs-params,.hljs-quote,.hljs-string,.hljs-symbol,.hljs-type{color:highlight}.hljs-keyword,.hljs-selector-tag{font-weight:700}}</style><hr/>
<p>有没有遇到过这种困扰？本地配置文件里藏着数据库密码、密钥等敏感信息，一不小心就提交到 Git 仓库了，既不安全又容易泄露隐私。</p>
<p>今天就给大家分享 Git 仓库脱敏方法，重点讲在开发过程中最实用的「Git 内置过滤器」方案——不用改代码、不用手动改配置，提交自动脱敏、拉取自动还原，全程无感操作。</p>
<h2 data-id="heading-0">一、先搞懂核心需求：本地能用，仓库安全</h2>
<p><strong>目标</strong>很简单：</p>
<ul>
<li>本地开发时，能用到完整的配置（含敏感信息），不影响正常开发；</li>
<li>提交到 Git 仓库时，敏感信息自动变成占位符，不会泄露；</li>
<li>最好自动化，不用每次提交前手动改配置，省事。</li>
</ul>
<blockquote>
<p>💡<strong>提前划重点</strong>：</p>
<p>下面 3 种方法里，优先选「方法 3：Git 内置过滤器」。前两种适合已开发完的项目，过滤器方案适合正在开发的项目，零侵入还省心。</p>
</blockquote>
<h3 data-id="heading-1">3 种脱敏方法对比</h3>
<h4 data-id="heading-2">方法 1：创建配置模板文件（简单但繁琐）</h4>
<p>比如，有个配置文件叫 <code>settings.yaml</code>，里面有敏感信息。做法很简单：</p>
<ol>
<li>复制一份 <code>settings.yaml</code>，改名叫 <code>settings_example.yaml</code>；</li>
<li>手动把 <code>settings_example.yaml</code> 里的敏感信息删掉（比如把密码改成 <code>xxxxxx</code>），作为模板给团队参考；</li>
<li>在 <code>.gitignore</code> 里加一行<code>settings.yaml</code>，让 Git 忽略这个真实配置文件，避免提交。</li>
</ol>
<p>缺点：每次新增配置项，都要手动同步模板文件，团队协作时容易漏更。</p>
<h4 data-id="heading-3">方法 2：把敏感信息存到环境变量（脱离项目但需额外配置）</h4>
<p>核心思路：把密码、密钥这些敏感信息，存到电脑的「环境变量」里（和项目分开），项目里只留“占位符”。</p>
<p>举个例子， <code>settings.yaml</code> 可以写成这样：</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">database:</span>
  <span class="hljs-attr">host:</span> <span class="hljs-string">${DB_HOST}</span>  <span class="hljs-comment"># 占位符：本地环境变量里找 DB_HOST</span>
  <span class="hljs-attr">username:</span> <span class="hljs-string">${DB_USER}</span>  <span class="hljs-comment"># 占位符：本地环境变量里找 DB_USER</span>
  <span class="hljs-attr">password:</span> <span class="hljs-string">${DB_PASSWORD}</span>  <span class="hljs-comment"># 敏感密码：从环境变量读取</span>
<span class="hljs-attr">secret:</span>
  <span class="hljs-attr">token_key:</span> <span class="hljs-string">${TOKEN_SECRET}</span>  <span class="hljs-comment"># 密钥：从环境变量读取</span>
</code></pre>
<p>缺点：每个开发者都要手动在自己电脑上配置环境变量，新成员加入时步骤多，容易配错。</p>
<h4 data-id="heading-4">方法 3：Git 内置过滤器（自动化首选）</h4>
<p>这是 Git 自带的功能，相当于给配置文件加了“自动开关”：</p>
<ul>
<li>提交代码时（git add）：触发 <code>clean</code> 过滤器，自动把敏感信息换成占位符；</li>
<li>拉取代码时（git pull）：触发<code>smudge</code> 过滤器，自动把占位符换回本地的真实敏感信息。</li>
</ul>
<p>优点：不用改项目代码、不用装额外工具，开发者完全不用管，提交/拉取全程自动处理，不影响开发效率。</p>
<h2 data-id="heading-5">二、自动化配置过滤器脚本（直接用）</h2>
<p>手动配置过滤器步骤有点多，我写了个脚本，一键就能搞定所有配置。不想看手动步骤的朋友，直接用这个脚本就行！</p>
<p>当然，若读者对手动配置感兴趣，又或想了解脚本的工作原理，可跳过此部分，往后阅读：。</p>
<h3 data-id="heading-6">使用步骤（超简单）</h3>
<ol>
<li>打开你的 Git 项目根目录（就是和 <code>.git</code> 文件夹同级的目录）；</li>
<li>新建一个文件，命名为 <code>git_desensitize.sh</code>；</li>
<li>把下面的代码复制粘贴进去；</li>
<li>执行命令：<code>bash git_desensitize.sh</code>，等待脚本执行完成。</li>
</ol>
<p>后续在其他地方拉取项目，只需把原项目的 <code>.git/config</code> 文件复制过去，删除要复原的「需脱敏文件」（如之前的 settings.yaml），再执行 <code>git checkout-index --all --force</code> 就能恢复本地配置。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/17adf1a16c234d11aba536f5eccf1e4d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgR2VudGx5QmVpbmc=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767974024&amp;x-signature=It1bS9Din%2FKZKvZ7kOgN%2BfJjvt0%3D" alt="image.png" loading="lazy"/></p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-meta">#!/bin/bash</span>
<span class="hljs-comment"># ==============================================================</span>
<span class="hljs-comment"># Git 配置文件全自动脱敏脚本</span>
<span class="hljs-comment"># 使用说明：1.修改顶部【配置区】的files和fields </span>
<span class="hljs-comment">#          2.执行脚本：bash git_desensitize.sh</span>
<span class="hljs-comment"># 核心特性：一键生成clean/smudge过滤器 + 绑定.gitattributes</span>
<span class="hljs-comment"># ==============================================================</span>
​
<span class="hljs-comment"># ========== 【唯一配置区】 ==========</span>
<span class="hljs-comment"># 要脱敏的文件列表</span>
files=(
  <span class="hljs-string">"settings.yaml"</span>
  <span class="hljs-comment"># "src/config/.env"</span>
  <span class="hljs-comment"># "application.yml"</span>
)
​
<span class="hljs-comment"># 要脱敏的字段名列表</span>
fields=(
  <span class="hljs-string">"password"</span>
  <span class="hljs-string">"secret"</span>
  <span class="hljs-string">"issuer"</span>
  <span class="hljs-string">"addr"</span>
  <span class="hljs-string">"host"</span>
  <span class="hljs-string">"port"</span>
  <span class="hljs-string">"ip"</span>
  <span class="hljs-string">"domain"</span>
  <span class="hljs-string">"send_email"</span>
  <span class="hljs-string">"app_key"</span>
  <span class="hljs-string">"access_key"</span>
  <span class="hljs-string">"secret_key"</span>
)
​
<span class="hljs-comment"># ========== 【常量定义】 ==========</span>
FILTER_NAME=<span class="hljs-string">"auto_sensitive_filter"</span>          <span class="hljs-comment"># Git过滤器名称</span>
GIT_ATTRIBUTES=<span class="hljs-string">".gitattributes"</span>              <span class="hljs-comment"># 绑定文件名称</span>
BASE_PLACEHOLDER=<span class="hljs-string">"******"</span>                    <span class="hljs-comment"># 占位符基础前缀</span>
​
<span class="hljs-comment"># ========== 【0.前置一键校验】 ==========</span>
<span class="hljs-function"><span class="hljs-title">check_env</span></span>(){
  [ ! -d <span class="hljs-string">".git"</span> ] &amp;&amp; <span class="hljs-built_in">echo</span> -e <span class="hljs-string">"\033[31m请在Git项目根目录执行！\033[0m"</span> &amp;&amp; <span class="hljs-built_in">exit</span> 1
  [ ! $(<span class="hljs-built_in">command</span> -v git) ] &amp;&amp; <span class="hljs-built_in">echo</span> -e <span class="hljs-string">"\033[31m未检测到Git环境！\033[0m"</span> &amp;&amp; <span class="hljs-built_in">exit</span> 1
  [ ! $(<span class="hljs-built_in">command</span> -v sed) ] &amp;&amp; <span class="hljs-built_in">echo</span> -e <span class="hljs-string">"\033[31m未检测到sed命令！\033[0m"</span> &amp;&amp; <span class="hljs-built_in">exit</span> 1
} &amp;&amp; check_env
​
<span class="hljs-comment"># ========== 【1.扫描提取敏感值+去重+生成映射】 ==========</span>
<span class="hljs-built_in">echo</span> -e <span class="hljs-string">"\n\033[36m===== 扫描目标文件，提取敏感值 =====\033[0m"</span>
<span class="hljs-built_in">declare</span> -A FIELD_COUNTER                     <span class="hljs-comment"># 字段计数器：记录每个字段有效序号</span>
<span class="hljs-built_in">declare</span> -a VALUE_MAPPING                     <span class="hljs-comment"># 核心映射表：存储 原始值|字段名|序号</span>
<span class="hljs-built_in">declare</span> -A DUPLICATE_CHECK_MAP               <span class="hljs-comment"># 去重校验MAP：key=字段名_原始值，实现双重去重</span>
​
<span class="hljs-comment"># 初始化字段计数器</span>
<span class="hljs-keyword">for</span> field <span class="hljs-keyword">in</span> <span class="hljs-string">"<span class="hljs-variable">${fields[@]}</span>"</span>; <span class="hljs-keyword">do</span>
  FIELD_COUNTER[<span class="hljs-variable">$field</span>]=0
<span class="hljs-keyword">done</span>
​
<span class="hljs-comment"># 遍历所有目标文件</span>
<span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> <span class="hljs-string">"<span class="hljs-variable">${files[@]}</span>"</span>; <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">if</span> [ ! -f <span class="hljs-string">"<span class="hljs-variable">$file</span>"</span> ]; <span class="hljs-keyword">then</span>
    <span class="hljs-built_in">echo</span> -e <span class="hljs-string">"\033[33m文件 <span class="hljs-variable">$file</span> 不存在，跳过\033[0m"</span>
    <span class="hljs-built_in">continue</span>
  <span class="hljs-keyword">fi</span>
​
  <span class="hljs-comment"># 遍历所有脱敏字段</span>
  <span class="hljs-keyword">for</span> field <span class="hljs-keyword">in</span> <span class="hljs-string">"<span class="hljs-variable">${fields[@]}</span>"</span>; <span class="hljs-keyword">do</span>
    all_origin_values=$(sed -n <span class="hljs-string">"s/^[[:space:]]*<span class="hljs-variable">${field}</span>[[:space:]]*[:=][[:space:]]*["</span><span class="hljs-string">']*(.*)["'</span>]*[[:space:]]*$/\1/p<span class="hljs-string">" "</span><span class="hljs-variable">$file</span><span class="hljs-string">")
    
    # 遍历所有提取到的原始值
    while IFS= read -r origin_value; do
      if [ -z "</span><span class="hljs-variable">$origin_value</span><span class="hljs-string">" ]; then
        continue
      fi
      
      # 去重：字段名+原始值 作为KEY，完全一致则判定为重复
      unique_check_key="</span><span class="hljs-variable">${field}</span>_<span class="hljs-variable">${origin_value}</span><span class="hljs-string">"
      if [[ -n "</span><span class="hljs-variable">${DUPLICATE_CHECK_MAP[$unique_check_key]}</span><span class="hljs-string">" ]]; then
        echo -e "</span>\033[33m重复：<span class="hljs-variable">$file</span> -&gt; <span class="hljs-variable">$field</span> = <span class="hljs-variable">$origin_value</span>\033[0m<span class="hljs-string">"
        continue
      fi
​
      # 非重复数据：序号自增 + 标记去重KEY + 存入映射表
      ((FIELD_COUNTER[<span class="hljs-variable">$field</span>]++))
      seq_num=<span class="hljs-variable">${FIELD_COUNTER[$field]}</span>
      DUPLICATE_CHECK_MAP[<span class="hljs-variable">$unique_check_key</span>]=1
      VALUE_MAPPING+=("</span><span class="hljs-variable">$origin_value</span>|<span class="hljs-variable">$field</span>|<span class="hljs-variable">$seq_num</span><span class="hljs-string">")
      echo -e "</span>\033[32m提取：<span class="hljs-variable">$file</span> -&gt; $field<span class="hljs-variable">$seq_num</span> = <span class="hljs-variable">$origin_value</span>\033[0m<span class="hljs-string">"
    done &lt;&lt;&lt; "</span><span class="hljs-variable">$all_origin_values</span><span class="hljs-string">"
  done
done
​
# 校验是否成功获取到原始值
if [ <span class="hljs-variable">${#VALUE_MAPPING[@]}</span> -eq 0 ]; then
  echo -e "</span>\033[31m错误：未扫描到任何有效字段值\033[0m<span class="hljs-string">"
  exit 1
fi
​
# ========== 【2.生成clean/smudge规则】 ==========
echo -e "</span>\n\033[36m===== 生成clean/smudge规则 =====\033[0m<span class="hljs-string">"
CLEAN_RULE="</span><span class="hljs-string">"
SMUDGE_RULE="</span><span class="hljs-string">"
​
for item in "</span><span class="hljs-variable">${VALUE_MAPPING[@]}</span><span class="hljs-string">"; do
  # 解析映射项：原始值|字段名|序号
  val=<span class="hljs-subst">$(echo <span class="hljs-string">"<span class="hljs-variable">$item</span>"</span> | cut -d'|' -f1)</span>
  field=<span class="hljs-subst">$(echo <span class="hljs-string">"<span class="hljs-variable">$item</span>"</span> | cut -d'|' -f2)</span>
  num=<span class="hljs-subst">$(echo <span class="hljs-string">"<span class="hljs-variable">$item</span>"</span> | cut -d'|' -f3)</span>
  placeholder="</span><span class="hljs-variable">${BASE_PLACEHOLDER}</span>_<span class="hljs-variable">${field}</span><span class="hljs-variable">${num}</span><span class="hljs-string">"
  
  # 转义所有特殊字符
  val_esc=<span class="hljs-subst">$(echo <span class="hljs-string">"<span class="hljs-variable">$val</span>"</span> | sed 's/[/*$&amp;|]/\&amp;/g')</span>
  ph_esc=<span class="hljs-subst">$(echo <span class="hljs-string">"<span class="hljs-variable">$placeholder</span>"</span> | sed 's/[/*$&amp;|]/\&amp;/g')</span>
  
  # 生成sed规则：将原始值替换为占位符
  CLEAN_RULE+="</span> -e <span class="hljs-string">'s/${val_esc}/${ph_esc}/g'</span><span class="hljs-string">"
  SMUDGE_RULE+="</span> -e <span class="hljs-string">'s/${ph_esc}/${val_esc}/g'</span><span class="hljs-string">"
done
​
echo -e "</span>\033[32m生成<span class="hljs-variable">${#VALUE_MAPPING[@]}</span>条\033[0m<span class="hljs-string">"
​
# ========== 【3.配置Git全局过滤器】 ==========
echo -e "</span>\n\033[36m===== 配置Git全局过滤器 =====\033[0m<span class="hljs-string">"
# 发起配置命令
git config filter.<span class="hljs-variable">$FILTER_NAME</span>.clean "</span>sed <span class="hljs-variable">$CLEAN_RULE</span><span class="hljs-string">"
git config filter.<span class="hljs-variable">$FILTER_NAME</span>.smudge "</span>sed <span class="hljs-variable">$SMUDGE_RULE</span><span class="hljs-string">"
git config filter.<span class="hljs-variable">$FILTER_NAME</span>.required true
​
# 检查配置是否成功
filter_check=<span class="hljs-subst">$(git config --get filter.$FILTER_NAME.clean)</span>
smudge_check=<span class="hljs-subst">$(git config --get filter.$FILTER_NAME.smudge)</span>
required_check=<span class="hljs-subst">$(git config --get filter.$FILTER_NAME.required)</span>
if [ -n "</span><span class="hljs-variable">$filter_check</span><span class="hljs-string">" ] &amp;&amp; [ -n "</span><span class="hljs-variable">$smudge_check</span><span class="hljs-string">" ] &amp;&amp; [ "</span><span class="hljs-variable">$required_check</span><span class="hljs-string">" = "</span><span class="hljs-literal">true</span><span class="hljs-string">" ]; then
  echo -e "</span>\033[32m配置成功\033[0m<span class="hljs-string">"
else
  echo -e "</span>\033[31m过滤器配置失败，请手动执行脚本内命令\033[0m<span class="hljs-string">"
  exit 1
fi
​
# ========== 【4.绑定文件到.gitattributes】 ==========
echo -e "</span>\n\033[36m===== 绑定文件过滤规则 =====\033[0m<span class="hljs-string">"
for file in "</span><span class="hljs-variable">${files[@]}</span><span class="hljs-string">"; do
  if ! grep -q "</span>^<span class="hljs-variable">${file}</span>[[:space:]]*filter=<span class="hljs-variable">${FILTER_NAME}</span>$<span class="hljs-string">" <span class="hljs-variable">$GIT_ATTRIBUTES</span> 2&gt;/dev/null; then
    echo "</span><span class="hljs-variable">${file}</span> filter=<span class="hljs-variable">${FILTER_NAME}</span><span class="hljs-string">" &gt;&gt; <span class="hljs-variable">$GIT_ATTRIBUTES</span>
    echo -e "</span>\033[32m绑定：<span class="hljs-variable">$file</span> -&gt; <span class="hljs-variable">$FILTER_NAME</span>\033[0m<span class="hljs-string">"
  else
    echo -e "</span>\033[33m提示：<span class="hljs-variable">$file</span> 已存在过滤规则\033[0m<span class="hljs-string">"
  fi
done
​
git add <span class="hljs-variable">$GIT_ATTRIBUTES</span>
echo -e "</span>\033[32m修改成功：<span class="hljs-variable">$GIT_ATTRIBUTES</span>\033[0m<span class="hljs-string">"
​
​
# ========== 【5.重新追踪应用】 ==========
echo -e "</span>\n\033[36m===== 重新追踪文件 =====\033[0m<span class="hljs-string">"
for file in "</span><span class="hljs-variable">${files[@]}</span><span class="hljs-string">"; do
  if [ -f "</span><span class="hljs-variable">$file</span><span class="hljs-string">" ]; then
  if git diff --cached --quiet "</span><span class="hljs-variable">$file</span><span class="hljs-string">" &gt;/dev/null 2&gt;&amp;1; then
     git rm -r --cached "</span><span class="hljs-variable">$file</span><span class="hljs-string">"
  fi
    git add "</span><span class="hljs-variable">$file</span><span class="hljs-string">"
  fi
done
​
echo -e "</span>\033[32m完成\033[0m<span class="hljs-string">"
exit 0
</span></code></pre>
<h2 data-id="heading-7">三、想了解原理？手动配置步骤</h2>
<p>如果想搞懂背后的原理，或者需要自定义配置，可以跟着下面的步骤手动操作。</p>
<p>其实核心就 3 步：配置过滤器、绑定文件、验证效果。</p>
<h3 data-id="heading-8">第一步：配置过滤器</h3>
<p>推荐只让过滤器在当前项目生效（避免影响其他项目），操作很简单：</p>
<ol>
<li>打开项目里的<code>.git</code> 文件夹（这个文件夹是隐藏的，需要显示隐藏文件）；</li>
<li>找到 <code>config</code> 文件，用记事本或编辑器打开；</li>
<li>在文件末尾添加下面的内容：</li>
</ol>

<pre><code class="hljs language-ini" lang="ini"><span class="hljs-section">[filter "sensitive_filter"]</span>  <span class="hljs-comment"># 过滤器名字，自己随便起，后面要用到</span>
    <span class="hljs-attr">clean</span> = sed -e <span class="hljs-string">'s/123456/****_pwd1/g'</span> -e <span class="hljs-string">'s/666123/****_pwd2/g'</span>
    <span class="hljs-attr">smudge</span> = sed -e <span class="hljs-string">'s/****_pwd1/123456/g'</span> -e <span class="hljs-string">'s/****_pwd2/666123/g'</span>
    <span class="hljs-attr">required</span> = <span class="hljs-literal">true</span>
</code></pre>
<p>解释下这几行的意思（理解就行）：</p>
<ul>
<li><code>s/原内容/替换内容/g</code>：sed 的替换语法，<code>s</code> 表示文本替换，<code>g</code> 表示全局匹配替换（出现多次全都替换）；</li>
<li><code>clean = ...</code>：提交时执行的命令，把真实密码（比如 <code>123456</code>）换成占位符（比如 <code>****_pwd1</code>）；</li>
<li><code>smudge = ...</code>：拉取时执行的命令，把占位符（<code>****_pwd1</code>）换回真实值（<code>123456</code>）；</li>
<li><code>-e</code>：可以拼接多个替换规则，比如同时替换密码和密钥（支持正则表达式）；</li>
</ul>
<blockquote>
<p>💡<strong>注意</strong>：</p>
<p><code>.git/config</code> 是本地文件，不会提交到远程仓库！</p>
<p>团队其他成员需要在自己的本地项目里，也配置这个文件（可以把你的 config 文件发给他们复制）。</p>
</blockquote>
<blockquote>
<p>👀<strong>细心的你有没有发现？</strong></p>
<p>这样写配置，如果要脱敏的字段很多，那就要重复写很长的一串规则啊！</p>
<p>还是用我写的自动脚本吧~~！</p>
</blockquote>
<h4 data-id="heading-9">补充做法</h4>
<ol>
<li>
<p>想让 git 全局项目都生效，那就要修改 Git 全局配置文件 <code>.gitconfig</code>；一般windows 的 git 全局配置文件位置为 <code>C:\Users\你的用户名.gitconfig</code>；</p>
</li>
<li>
<p>也可以用命令行进行配置</p>
<ul>
<li>
<p>全局配置生效：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 配置 clean 过滤器</span>
git config --<span class="hljs-keyword">global</span> <span class="hljs-built_in">filter</span>.sensitive_filter.clean <span class="hljs-string">"sed -e 's/123456/****_pwd1/g' -e 's/666123/****_pwd2/g'"</span>
​
<span class="hljs-comment"># 配置 smudge 过滤器</span>
git config --<span class="hljs-keyword">global</span> <span class="hljs-built_in">filter</span>.sensitive_filter.smudge <span class="hljs-string">"sed -e 's/****_pwd1/123456/g' -e 's/****_pwd2/666123/g'"</span>
​
<span class="hljs-comment"># 强制生效：无过滤规则则拒绝提交/拉取</span>
git config --<span class="hljs-keyword">global</span> <span class="hljs-built_in">filter</span>.sensitive_filter.required true
</code></pre>
<ul>
<li><code>filter.sensitive_filter.clean</code>：此处第二段的 <code>sensitive_filter</code> 是自定义过滤器名称。</li>
</ul>
</li>
<li>
<p>仅当前项目配置生效：去掉参数 <code>--global</code> 即可。</p>
</li>
</ul>
</li>
</ol>
<h3 data-id="heading-10">第二步：创建 .gitattributes 文件（告诉Git哪些文件要过滤）</h3>
<p>我们需要创建一个 <code>.gitattributes</code> 文件，告诉 Git“哪些文件需要用上面配置的过滤器”。这个文件要提交到仓库，让团队所有人都能用同样的规则。</p>
<ol>
<li>在项目根目录新建文件，命名为 <code>.gitattributes</code>；</li>
<li>写入下面的内容（根据你的配置文件调整）：</li>
</ol>

<pre><code class="hljs language-ini" lang="ini"><span class="hljs-comment"># 格式：【需要过滤的文件】 filter=过滤器名称</span>
​
<span class="hljs-comment"># 单文件精准匹配（推荐，精准脱敏）</span>
settings.yaml <span class="hljs-attr">filter</span>=sensitive_filter
​
<span class="hljs-comment"># 通配符匹配（批量脱敏，适合同类型配置文件）</span>
*.yml <span class="hljs-attr">filter</span>=sensitive_filter
​
<span class="hljs-comment"># 排除不需要过滤的文件（可选）</span>
README.md !filter
​
<span class="hljs-comment"># 注意：过滤器名称 `sensitive_filter` 必须和步骤 1 中配置的完全一致（大小写敏感）</span>
</code></pre>
<p>写完后，执行下面的命令提交这个文件：</p>
<pre><code class="hljs language-sql" lang="sql">git <span class="hljs-keyword">add</span> .gitattributes
git <span class="hljs-keyword">commit</span> <span class="hljs-operator">-</span>m "添加敏感文件过滤规则"
</code></pre>
<h3 data-id="heading-11">第三步：验证配置是否成功</h3>
<p>查看已配置的过滤规则，执行以下命令查看：</p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-meta"># 查看全局过滤器配置</span>
git config --<span class="hljs-keyword">global</span> --<span class="hljs-keyword">get</span>-regexp filter
​
<span class="hljs-meta"># 查看当前项目过滤器配置</span>
git config --<span class="hljs-keyword">get</span>-regexp filter
​
<span class="hljs-meta"># 查看所有 Git 配置（含过滤器）</span>
git config --list
</code></pre>
<h3 data-id="heading-12">第四步：使用验证</h3>
<p>如果你的配置文件之前已经被 Git 追踪过（比如已经提交过），需要先把它从 Git 暂存区移除（不会删除本地文件）：</p>
<pre><code class="hljs language-bash" lang="bash">git <span class="hljs-built_in">rm</span> --cached <span class="hljs-string">"被脱敏文件的地址"</span>
</code></pre>
<p>然后验证脱敏效果：</p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-meta"># 将文件加入暂存区（触发 clean 脱敏）</span>
git <span class="hljs-keyword">add</span> <span class="hljs-string">"被脱敏文件的地址"</span>
​
<span class="hljs-meta"># 查看暂存区中文件的脱敏效果</span>
git diff --cached <span class="hljs-string">"被脱敏文件的地址"</span>
​
<span class="hljs-meta"># 提交到本地仓库</span>
git commit -m <span class="hljs-string">"feat: 提交脱敏后的配置文件"</span>
</code></pre>
<h3 data-id="heading-13">补充：用正则实现“任意敏感值自动脱敏”</h3>
<p>如果你的配置文件里敏感值经常变，不想每次都手动加替换规则，可以用正则表达式写 clean 规则，实现“只要是某个字段，就自动替换成占位符”。</p>
<p>比如这样配置过滤器：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-section">[filter "sensitive_filter"]</span>
    <span class="hljs-attr">clean</span> = sed -e <span class="hljs-string">'s/(password:\s*).*/\1******/g'</span> -e <span class="hljs-string">'s/(secret:\s*).*/\2******/g'</span> -e <span class="hljs-string">'s/(token:\s*).*/\1******/g'</span>
    <span class="hljs-attr">smudge</span> = sed -e <span class="hljs-string">'s/password: 1******/password: my_db_pass_123/g'</span> -e <span class="hljs-string">'s/secret: 2******/secret: my_jwt_7890/g'</span>
    <span class="hljs-attr">required</span> = <span class="hljs-literal">true</span>
</code></pre>
<p>说明：这种方式适合敏感字段固定，但值经常变的场景，不过 smudge 规则还是要手动维护真实值，不如自动化脚本省心。</p>
<h2 data-id="heading-14">四、总结一下</h2>
<p>如果是正在开发的项目，优先用「Git 内置过滤器」+「自动化脚本」，一键配置，全程自动脱敏/还原，不影响开发；如果是已开发完的项目，用模板文件或环境变量的方式更简单。</p>
<p>核心原则就是：敏感信息只留在本地，仓库里只存脱敏后的内容，既安全又省心！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Elasticsearch：在 Streams 中使用 ML 自动化 log 解析]]></title>    <link>https://juejin.cn/post/7589940210832506923</link>    <guid>https://juejin.cn/post/7589940210832506923</guid>    <pubDate>2026-01-03T01:51:28.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7589940210832506923" data-draft-id="7590020026395492406" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Elasticsearch：在 Streams 中使用 ML 自动化 log 解析"/> <meta itemprop="keywords" content="Elasticsearch"/> <meta itemprop="datePublished" content="2026-01-03T01:51:28.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Elasticsearch"/> <meta itemprop="url" content="https://juejin.cn/user/2612095360441448"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Elasticsearch：在 Streams 中使用 ML 自动化 log 解析
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2612095360441448/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Elasticsearch
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-03T01:51:28.000Z" title="Sat Jan 03 2026 01:51:28 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读12分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>作者：来自 Elastic <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.elastic.co%2Fsearch-labs%2Fauthor%2Fnastia-havriushenko" title="https://www.elastic.co/search-labs/author/nastia-havriushenko" target="_blank" ref="nofollow noopener noreferrer">Nastia Havriushenko</a></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e843b17925e242e185dd66e6eedecd4e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWxhc3RpY3NlYXJjaA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768009888&amp;x-signature=S0dr2cF7VlTFkkPYi%2Fa0Xj73PEk%3D" alt="" loading="lazy"/></p>
<p>了解一种混合 ML 方法如何通过在 Streams 中使用 log 格式指纹识别的自动化实验，实现 94% 的 log 解析准确率和 91% 的 log 分区准确率。</p>
<p>无缝连接领先的 AI 和 machine learning 平台。开始一个<a href="https://link.juejin.cn?target=https%3A%2F%2Fcloud.elastic.co%2Fregistration" title="https://cloud.elastic.co/registration" target="_blank" ref="nofollow noopener noreferrer">免费的 cloud 试用</a>来探索 Elastic 的 gen AI 能力，或者现在就在你的<a href="https://link.juejin.cn?target=https%3A%2F%2Felasticstack.blog.csdn.net%2Farticle%2Fdetails%2F143747798" title="https://elasticstack.blog.csdn.net/article/details/143747798" target="_blank" ref="nofollow noopener noreferrer">机器</a>上试用。</p>
<p>在现代可观测性技术栈中，将来自不同数据提供方的非结构化 log 摄取到像 Elasticsearch 这样的平台仍然是一个挑战。依赖手工编写的解析规则会产生脆弱的管道，即使上游代码的轻微更新也会导致解析失败和数据无法被索引。这种脆弱性还因可扩展性问题而加剧：在动态的 microservices 环境中，不断新增的新服务使得手动维护规则变成一场运维噩梦。</p>
<p>我们的目标是转向一种自动化、可自适应的方法，能够同时处理 log 解析（字段提取）和 log 分区（来源识别）。我们假设，大语言模型 LLMs 凭借其对代码语法和语义模式的内在理解，可以在几乎不需要人工干预的情况下自动完成这些任务。</p>
<h2 data-id="heading-0">数据集描述</h2>
<p>我们选择了 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Flogpai%2Floghub" title="https://github.com/logpai/loghub" target="_blank" ref="nofollow noopener noreferrer">Loghub</a> 的 log 集合作为 PoC 的数据来源。在本次研究中，我们从以下关键领域选择了具有代表性的样本：</p>
<ul>
<li><strong>分布式系统</strong>：我们使用了 HDFS（Hadoop Distributed File System）和 Spark 数据集。这些数据集包含了典型的大数据平台中的 info、debug 和 error 消息。</li>
<li><strong>服务器和 web 应用</strong>：来自 Apache web 服务器和 OpenSSH 的 logs 提供了大量访问、错误以及与安全相关的事件。这些对于监控 web 流量和检测潜在威胁至关重要。</li>
<li><strong>操作系统</strong>：我们包含了 Linux 和 Windows 的 logs。这些数据集代表了运维团队日常遇到的常见、半结构化的系统级事件。</li>
<li><strong>移动系统</strong>：为了确保我们的模型能够处理来自移动环境的 logs，我们加入了 Android 数据集。这些 logs 通常非常冗长，记录了移动设备上大量应用级和系统级活动。</li>
<li><strong>超级计算机</strong>：为了测试在高性能计算 HPC 环境下的表现，我们引入了 BGL（Blue Gene/L）数据集。该数据集包含高度结构化的 logs，并带有特定领域的术语。</li>
</ul>
<p>Loghub 集合的一个关键优势在于，这些 logs 大多是未清洗、未标注的，真实地模拟了具有 microservice 架构的嘈杂生产环境。</p>
<p>Log 示例：</p>
<pre><code class="hljs language-scss" lang="scss">`

<span class="hljs-number">1</span>.  <span class="hljs-selector-attr">[Sun Dec 04 20:34:21 2005]</span> <span class="hljs-selector-attr">[notice]</span> <span class="hljs-built_in">jk2_init</span>() Found child <span class="hljs-number">2008</span> in scoreboard slot <span class="hljs-number">6</span>
<span class="hljs-number">2</span>.  <span class="hljs-selector-attr">[Sun Dec 04 20:34:25 2005]</span> <span class="hljs-selector-attr">[notice]</span> workerEnv<span class="hljs-selector-class">.init</span>() ok /etc/httpd/conf/workers2<span class="hljs-selector-class">.properties</span>
<span class="hljs-number">3</span>.  <span class="hljs-selector-attr">[Mon Dec 05 11:06:51 2005]</span> <span class="hljs-selector-attr">[notice]</span> workerEnv<span class="hljs-selector-class">.init</span>() ok /etc/httpd/conf/workers2<span class="hljs-selector-class">.properties</span>
<span class="hljs-number">4</span>.  <span class="hljs-number">17</span>/<span class="hljs-number">06</span>/<span class="hljs-number">09</span> <span class="hljs-number">20</span>:<span class="hljs-number">10</span>:<span class="hljs-number">58</span> INFO output.FileOutputCommitter: Saved output of task <span class="hljs-string">'attempt_201706092018_0024_m_000083_1138'</span> to hdfs://<span class="hljs-number">10.10</span>.<span class="hljs-number">34.11</span>:<span class="hljs-number">9000</span>/pjhe/test/<span class="hljs-number">1</span>/_temporary/<span class="hljs-number">0</span>/task_201706092018_0024_m_000083
<span class="hljs-number">5</span>.  <span class="hljs-number">17</span>/<span class="hljs-number">06</span>/<span class="hljs-number">09</span> <span class="hljs-number">20</span>:<span class="hljs-number">10</span>:<span class="hljs-number">58</span> INFO mapred.SparkHadoopMapRedUtil: attempt_201706092018_0024_m_000083_1138: Committed

`AI写代码
</code></pre>
<p>此外，我们还创建了一个 Kubernetes 集群，采用典型的 web 应用 + 数据库 的设置，在最常见的领域中挖掘额外的 logs。</p>
<p>常见 log 字段示例：timestamp、log level（INFO、WARN、ERROR）、source、message。</p>
<h2 data-id="heading-1">使用 LLM 进行 few-shot log 解析</h2>
<p>我们的第一组实验聚焦于一个基础问题：<strong>LLM 是否能够可靠地识别关键字段，并生成一致的解析规则来提取它们？</strong></p>
<p>我们让模型分析原始 log 样本，并生成 regular expression（regex）和 <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.elastic.co%2Fdocs%2Fexplore-analyze%2Fscripting%2Fgrok" title="https://www.elastic.co/docs/explore-analyze/scripting/grok" target="_blank" ref="nofollow noopener noreferrer">Grok</a> 格式的 log 解析规则。结果表明，这种方法具有很大潜力，但在实现层面也存在显著挑战。</p>
<h3 data-id="heading-2">高置信度与上下文感知</h3>
<p>初步结果令人鼓舞。LLM 展现了很强的能力，能够以高置信度生成与提供的 few-shot 示例相匹配的解析规则。除了简单的模式匹配之外，模型还表现出对 log 的理解能力 —— 它可以正确识别并命名 log 来源（例如 健康追踪 app、Nginx web app、Mongo 数据库）。</p>
<h3 data-id="heading-3">输入样本的 “Goldilocks（恰到好处困境）” 困境</h3>
<p>我们的实验很快暴露出一个显著的鲁棒性不足问题，即模型对输入样本极度敏感。模型的表现会随着 prompt 中包含的具体 log 示例而剧烈波动。我们观察到一个 log 相似性问题：log 样本需要 <strong>恰到好处</strong> 地多样化：</p>
<ul>
<li><strong>过于同质（overfitting）</strong>：如果输入的 logs 过于相似，LLM 往往会过度具体化。它会把可变数据 —— 例如 stack trace 中的特定 Java class 名称 —— 当作模板中的静态部分。这会导致生成的规则非常脆弱，只能覆盖极少比例的 logs，并且提取出的字段不可用。</li>
<li><strong>过于异质（confusion）：相反</strong>，如果样本中包含明显的格式差异 —— 或者更糟的是，包含诸如 progress bars、memory tables、ASCII art 等 “trash logs” —— 模型就很难找到共同点。它往往会生成复杂但有问题的 regex，或者干脆过度泛化，把整行都解析成一个单一的 message blob 字段。</li>
</ul>
<h3 data-id="heading-4">上下文窗口限制</h3>
<p>我们还遇到了 context window 的瓶颈。当输入的 logs 很长、差异很大，或者包含大量可提取字段时，模型的输出质量往往会下降，变得 “杂乱”，或者长度过长而无法放入输出的 context window。自然地，chunking 在这种情况下会有所帮助。通过使用基于字符和基于实体的分隔符来拆分 logs，我们可以帮助模型专注于提取主要字段，而不会被噪声淹没。</p>
<h3 data-id="heading-5">一致性与标准化差距</h3>
<p>即使模型成功生成了解析规则，我们仍然注意到一些细微的不一致性：</p>
<ul>
<li><strong>服务命名差异</strong>：模型在不同运行中会为同一实体提出不同名称（例如，将 source 标注为 “Spark”、 “Apache Spark” 和 “Spark Log Analytics”）。</li>
<li><strong>字段命名差异</strong>：字段名称缺乏标准化（例如 id、 service.id、 device.id）。我们使用标准化的 <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.elastic.co%2Fdocs%2Freference%2Fecs%2Fecs-field-reference" title="https://www.elastic.co/docs/reference/ecs/ecs-field-reference" target="_blank" ref="nofollow noopener noreferrer">Elastic 字段命名</a>对名称进行了归一化。</li>
<li><strong>解析粒度差异</strong>：字段提取的解析粒度会根据输入日志彼此之间的相似程度而变化。</li>
</ul>
<h2 data-id="heading-6">日志格式指纹</h2>
<p>为了解决日志相似性的问题，我们引入了一种高性能的启发式方法：日志格式指纹（ <strong>log format fingerprint, LFF</strong> ）。</p>
<p>我们不再直接把原始、嘈杂的日志输入到 LLM 中，而是先对每条日志应用一个确定性的转换，以揭示其底层结构。这个预处理步骤会抽象掉可变数据，生成一个简化的 “指纹”，从而让我们可以对相关日志进行分组。</p>
<p>映射逻辑被设计得非常简单，以保证速度和一致性：</p>
<ul>
<li><strong>数字抽象</strong>：任何由数字（ 0–9 ）组成的序列都会被替换为一个 ‘0’。</li>
<li><strong>文本抽象</strong>：任何由字母字符组成并包含空格的序列都会被替换为一个 ‘a’。</li>
<li><strong>空白规范化</strong>：所有连续的空白（空格、制表符、换行符）都会折叠为一个空格。</li>
<li><strong>符号保留</strong>：标点符号和特殊字符（例如 : 、 [ 、 ] 、 / ）会被保留下来，因为它们通常是日志结构中最强的指示信号。</li>
</ul>
<p>我们引入了这种日志映射方法。基础的映射规则包括以下内容：</p>
<ul>
<li>任意长度的数字 0–9 → 替换为 ‘0’。</li>
<li>任意长度的文本（带空格的字母字符） → 替换为 ‘a’。</li>
<li>空格、制表符和换行符 → 合并为一个空格。</li>
</ul>
<p>下面来看一个示例，展示这种映射是如何帮助我们转换日志的。</p>
<pre><code class="hljs language-less" lang="less">`<span class="hljs-number">1</span>.  <span class="hljs-number">17</span>/<span class="hljs-number">06</span>/<span class="hljs-number">09</span>	<span class="hljs-number">20</span>:<span class="hljs-number">10</span>:<span class="hljs-number">56</span>	<span class="hljs-selector-tag">INFO</span>	<span class="hljs-selector-tag">executor</span><span class="hljs-selector-class">.CoarseGrainedExecutorBackend</span>:	<span class="hljs-selector-tag">Got</span> <span class="hljs-selector-tag">assigned</span> <span class="hljs-selector-tag">task</span> <span class="hljs-number">912</span>
<span class="hljs-number">2</span>.  <span class="hljs-number">0</span>/<span class="hljs-number">0</span>/<span class="hljs-number">0</span>		<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>		<span class="hljs-selector-tag">a</span>	<span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.a</span>: 							<span class="hljs-selector-tag">a</span> <span class="hljs-number">0</span>
<span class="hljs-number">3</span>.  <span class="hljs-number">17</span>/<span class="hljs-number">06</span>/<span class="hljs-number">09</span>	<span class="hljs-number">20</span>:<span class="hljs-number">10</span>:<span class="hljs-number">58</span>	<span class="hljs-selector-tag">INFO</span>	<span class="hljs-selector-tag">mapred</span><span class="hljs-selector-class">.SparkHadoopMapRedUtil</span>:	<span class="hljs-selector-tag">attempt_</span> <span class="hljs-number">2017060920</span><span class="hljs-selector-tag">_081_136</span>: <span class="hljs-selector-tag">Committed</span>
<span class="hljs-number">4</span>.  <span class="hljs-number">0</span>/<span class="hljs-number">0</span>/<span class="hljs-number">0</span>	 	<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span> 	  	<span class="hljs-selector-tag">a</span>  	<span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.a</span>: 							<span class="hljs-selector-tag">a_0_0_0</span>: <span class="hljs-selector-tag">a</span>
<span class="hljs-number">5</span>.  <span class="hljs-number">2015</span><span class="hljs-selector-tag">-07-29</span>	<span class="hljs-number">19</span>:<span class="hljs-number">23</span>:<span class="hljs-number">30</span>,<span class="hljs-number">320</span>	<span class="hljs-selector-tag">-</span> <span class="hljs-selector-tag">WARN</span>  <span class="hljs-selector-attr">[RecvWorker:18861024:$RecvWorker@765]</span> <span class="hljs-selector-tag">-</span> <span class="hljs-selector-tag">Interrupting</span> <span class="hljs-selector-tag">SendWorker</span>
<span class="hljs-number">6</span>.  <span class="hljs-number">0</span><span class="hljs-selector-tag">-0-0</span>		<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>,<span class="hljs-number">0</span> 	<span class="hljs-selector-tag">-</span> <span class="hljs-selector-tag">a</span>	<span class="hljs-selector-attr">[a:0:a$a@0]</span>` <span class="hljs-selector-tag">AI</span>写代码
</code></pre>
<p>因此，我们得到如下的日志掩码：</p>
<pre><code class="hljs language-less" lang="less">`

<span class="hljs-number">1</span>.  <span class="hljs-number">0</span>/<span class="hljs-number">0</span>/<span class="hljs-number">0</span>		<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>		<span class="hljs-selector-tag">a</span>	<span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.a</span>: 			<span class="hljs-selector-tag">a</span> <span class="hljs-number">0</span>
<span class="hljs-number">2</span>.  <span class="hljs-number">0</span>/<span class="hljs-number">0</span>/<span class="hljs-number">0</span>	 	<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span> 	  	<span class="hljs-selector-tag">a</span>  	<span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.a</span>: 			<span class="hljs-selector-tag">a_0_0_0</span>: <span class="hljs-selector-tag">a</span>
<span class="hljs-number">3</span>.  <span class="hljs-number">0</span><span class="hljs-selector-tag">-0-0</span>		<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>,<span class="hljs-number">0</span> 	<span class="hljs-selector-tag">-</span> <span class="hljs-selector-tag">a</span>	<span class="hljs-selector-attr">[a:0:a$a@0]</span>		<span class="hljs-selector-tag">a</span>

`<span class="hljs-selector-tag">AI</span>写代码
</code></pre>
<p>注意前两条日志的指纹。尽管它们的 timestamp、source class 和 message 内容不同，但它们的前缀（0/0/0 0:0:0 a a.a:）是相同的。这种结构上的一致性使我们能够自动将这些日志归入同一个簇。</p>
<p>然而，第三条日志生成了完全不同的指纹（0-0-0…），这使我们能够在调用 LLM 之前，通过算法将其从第一组中分离出来。</p>
<h3 data-id="heading-7">额外部分：使用 ES|QL 即刻实现</h3>
<p>只需在 Discover 中传入以下查询即可。</p>
<pre><code class="hljs language-sql" lang="sql">`

<span class="hljs-number">1.</span>  <span class="hljs-keyword">FROM</span> loghub <span class="hljs-operator">|</span>
<span class="hljs-number">2.</span>  EVAL <span class="hljs-keyword">pattern</span> <span class="hljs-operator">=</span> REPLACE(REPLACE(REPLACE(REPLACE(raw_message, "[ \t\n]+", " "), "[A-Za-z]+", "a"), "[0-9]+", "0"), "a( a)+", "a") <span class="hljs-operator">|</span>
<span class="hljs-number">3.</span>  STATS total_count <span class="hljs-operator">=</span> <span class="hljs-built_in">COUNT</span>(), ratio <span class="hljs-operator">=</span> <span class="hljs-built_in">COUNT</span>() <span class="hljs-operator">/</span> <span class="hljs-number">2000.0</span>, datasources<span class="hljs-operator">=</span><span class="hljs-keyword">VALUES</span>(filename), example<span class="hljs-operator">=</span>TOP(raw_message, <span class="hljs-number">3</span>, "desc") <span class="hljs-keyword">BY</span> <span class="hljs-built_in">SUBSTRING</span>(<span class="hljs-keyword">pattern</span>, <span class="hljs-number">0</span>, <span class="hljs-number">15</span>) <span class="hljs-operator">|</span>
<span class="hljs-number">4.</span>  SORT total_count <span class="hljs-keyword">DESC</span> <span class="hljs-operator">|</span>
<span class="hljs-number">5.</span>  LIMIT <span class="hljs-number">100</span>

`AI写代码
</code></pre>
<p>查询解析：</p>
<pre><code class="hljs language-sql" lang="sql">`

<span class="hljs-number">1.</span>  <span class="hljs-keyword">FROM</span> loghub:Targets our index containing the raw log data.
<span class="hljs-number">2.</span>  EVAL <span class="hljs-keyword">pattern</span> <span class="hljs-operator">=</span> …:  The core mapping logic. We chain REPLACE functions <span class="hljs-keyword">to</span> perform the abstraction (e.g. digits <span class="hljs-keyword">to</span> <span class="hljs-string">'0'</span>, text <span class="hljs-keyword">to</span> <span class="hljs-string">'a'</span>, etc.) <span class="hljs-keyword">and</span> save the <span class="hljs-keyword">result</span> <span class="hljs-keyword">in</span> a “<span class="hljs-keyword">pattern</span>” field. 
<span class="hljs-number">3.</span>  STATS [column1 <span class="hljs-operator">=</span>] expression1, … <span class="hljs-keyword">BY</span> <span class="hljs-built_in">SUBSTRING</span>(<span class="hljs-keyword">pattern</span>, <span class="hljs-number">0</span>, <span class="hljs-number">15</span>): 
<span class="hljs-number">4.</span>  This <span class="hljs-keyword">is</span> a clustering step. We <span class="hljs-keyword">group</span> logs that share the <span class="hljs-keyword">first</span> <span class="hljs-number">15</span> characters <span class="hljs-keyword">of</span> their <span class="hljs-keyword">pattern</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">create</span> aggregated fields such <span class="hljs-keyword">as</span> total log count <span class="hljs-keyword">per</span> <span class="hljs-keyword">group</span>, list <span class="hljs-keyword">of</span> log datasources, <span class="hljs-keyword">pattern</span> prefix, <span class="hljs-number">3</span> log examples  
<span class="hljs-number">5.</span>  SORT total_count <span class="hljs-keyword">DESC</span> <span class="hljs-operator">|</span> LIMIT <span class="hljs-number">100</span> : Surfaces the top <span class="hljs-number">100</span> most frequent log patterns

`AI写代码
</code></pre>
<p>LogHub 上的查询结果如下所示：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ff76dcf06f0d4d67b91ff582127fe56a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWxhc3RpY3NlYXJjaA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768009888&amp;x-signature=YMZg5EFaJZ9cyhO2gx6OVWoU16I%3D" alt="" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2b14fdc2d69546c18394e4526ddf1bec~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWxhc3RpY3NlYXJjaA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768009888&amp;x-signature=LRSEI%2FkipAINv4C4I71EpiUGEc0%3D" alt="" loading="lazy"/></p>
<p>如可视化所示，这种 “LLM-free” 方法能够高精度地对日志进行分区。它成功地将 16 个数据源中的 10 个完全聚类（&gt;90%，基于 LogHub 标签），并在 16 个数据源中有 13 个实现多数聚类（&gt;60%）——全部无需额外清洗、预处理或微调。</p>
<p>日志格式指纹（ log format fingerprint, LFF）为复杂的 ML 解决方案（如<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.elastic.co%2Fdocs%2Freference%2Faggregations%2Fsearch-aggregations-bucket-categorize-text-aggregation" title="https://www.elastic.co/docs/reference/aggregations/search-aggregations-bucket-categorize-text-aggregation" target="_blank" ref="nofollow noopener noreferrer">日志模式分析</a>）提供了一个务实且高效的替代方案和补充。它能够立即洞察日志之间的关系，并有效管理大规模日志簇。</p>
<p>作为基础工具的多用途性<br/>
得益于 <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.elastic.co%2Fblog%2Fgetting-started-elasticsearch-query-language" title="https://www.elastic.co/blog/getting-started-elasticsearch-query-language" target="_blank" ref="nofollow noopener noreferrer">ES|QL</a> 的实现，LFF 既可作为快速数据诊断/可视化的独立工具，也可作为高吞吐量日志分析管道中的构建模块。</p>
<p>灵活性<br/>
LFF 易于自定义和扩展，以捕获特定模式，例如十六进制数字和 IP 地址。</p>
<p>确定性稳定性<br/>
与基于 ML 的聚类算法不同，LFF 的逻辑简单且确定性。新进入的日志不会对已有日志簇产生回溯影响。</p>
<p>性能与内存<br/>
它占用最少的内存，无需训练或 GPU，非常适合实时高吞吐量环境。</p>
<h2 data-id="heading-8">将日志格式指纹与 LLM 结合</h2>
<p>为了验证所提出的混合架构，每次实验都包含来自每个数据源的随机 20% 日志子集。这个限制模拟了真实生产环境中日志按批处理而非作为单一历史数据块处理的情况。</p>
<p>目标是证明 LFF 作为有效压缩层的作用。我们旨在证明可以从小型、精心挑选的样本生成高覆盖率的解析规则，并成功推广到整个数据集。</p>
<h2 data-id="heading-9">执行流程</h2>
<p>我们实现了一个多阶段管道，在数据到达 LLM 之前进行过滤、聚类，并应用分层采样。</p>
<p>1）两阶段分层聚类</p>
<ul>
<li><strong>子类（精确匹配）</strong>：日志按完全相同的指纹聚合。每个子类中的日志共享完全相同的格式结构。</li>
<li><strong>异常清理</strong>：我们丢弃占总日志量不足 5% 的子类。这确保 LLM 专注于主导信号，而不会被噪声或格式错误的日志分散注意力。</li>
<li><strong>元类（前缀匹配）</strong>：剩余子类按指纹匹配的前 N 个字符分组到元类中。这种分组策略有效地将词汇相似的格式归入同一类。对于未知数据源，我们在日志解析中选择 N=5，日志分区中选择 N=15。分层采样</li>
</ul>
<p>2）一旦构建好分层树，我们就为 LLM 构建日志样本。战略目标是最大化方差覆盖，同时最小化 token 使用量。</p>
<ul>
<li>我们从每个元类中每个有效子类选择代表性日志。</li>
<li>为处理子类过多的极端情况，我们应用随机下采样以适应目标窗口大小。</li>
</ul>
<p>3）规则生成</p>
<ul>
<li>最后，我们提示 LLM 为每个元类提供的样本生成适配所有日志的 regex 解析规则。在我们的 PoC 中，我们使用了 GPT-4o mini 模型。</li>
</ul>
<h2 data-id="heading-10">实验结果与观察</h2>
<p>在 Loghub 数据集上，我们实现了 94% 的解析准确率和 91% 的分区准确率。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cf5062a044464beaab09e23a1a70d745~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWxhc3RpY3NlYXJjaA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768009888&amp;x-signature=%2FZAAPBKCbPxvtThwrmZeWCGXP20%3D" alt="" loading="lazy"/></p>
<p>上图的混淆矩阵展示了日志分区结果。纵轴表示实际数据源，横轴表示预测数据源。热力图的颜色深浅对应日志数量，颜色越浅表示数量越多。对角线的对齐显示模型在源归属上的高准确性，散布最小。</p>
<h2 data-id="heading-11">我们的性能基准洞察：</h2>
<ul>
<li><strong>最优基线</strong>：每类 30–40 条日志样本的上下文窗口被证明是“最佳区间”，能够稳定生成可靠的 Regex 和 Grok 解析模式。</li>
<li><strong>输入最小化</strong>：我们将每类的输入规模压缩到 10 条日志用于 Regex 模式，解析性能仅下降 2%，确认基于多样性的采样比原始数量更关键。</li>
</ul>
<p>原文：<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.elastic.co%2Fsearch-labs%2Fblog%2Flog-parsing-partitioning-automation-experiments-streams" title="https://www.elastic.co/search-labs/blog/log-parsing-partitioning-automation-experiments-streams" target="_blank" ref="nofollow noopener noreferrer">www.elastic.co/search-labs…</a></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[使用 json-server 快速创建一个完整的 REST API]]></title>    <link>https://juejin.cn/post/7589932422654902308</link>    <guid>https://juejin.cn/post/7589932422654902308</guid>    <pubDate>2026-01-02T17:12:30.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7589932422654902308" data-draft-id="7589919989039267903" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="使用 json-server 快速创建一个完整的 REST API"/> <meta itemprop="keywords" content="JavaScript,前端"/> <meta itemprop="datePublished" content="2026-01-02T17:12:30.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="左Python右Java"/> <meta itemprop="url" content="https://juejin.cn/user/4107431173952525"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            使用 json-server 快速创建一个完整的 REST API
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4107431173952525/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    左Python右Java
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-02T17:12:30.000Z" title="Fri Jan 02 2026 17:12:30 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-02
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">json-server 使用教程</h2>
<h3 data-id="heading-1">什么是 json-server</h3>
<p>json-server 是一个基于 Node.js 的工具，可以快速创建一个完整的 REST API，使用 JSON 文件作为数据源。非常适合前端开发、原型设计和测试。</p>
<h3 data-id="heading-2">安装</h3>
<h4 data-id="heading-3">全局安装</h4>
<pre><code class="hljs language-bash" lang="bash">npm install -g json-server
</code></pre>
<h4 data-id="heading-4">本地安装</h4>
<pre><code class="hljs language-bash" lang="bash">npm install json-server --save-dev
</code></pre>
<h4 data-id="heading-5">使用 npx（推荐）</h4>
<pre><code class="hljs language-bash" lang="bash">npx json-server
</code></pre>
<h3 data-id="heading-6">快速开始</h3>
<h4 data-id="heading-7">1. 创建数据文件</h4>
<p>创建一个 <code>db.json</code> 文件：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"posts"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
    <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"id"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"title"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"第一篇文章"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"author"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"张三"</span>
    <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
    <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"id"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"title"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"第二篇文章"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"author"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"李四"</span>
    <span class="hljs-punctuation">}</span>
  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"comments"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
    <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"id"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"body"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"很好的文章"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"postId"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span>
    <span class="hljs-punctuation">}</span>
  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"profile"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"typicode"</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<h4 data-id="heading-8">2. 启动服务器</h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 默认端口 3000</span>
json-server db.json

<span class="hljs-comment"># 指定端口</span>
json-server db.json --port 4000

<span class="hljs-comment"># 指定主机</span>
json-server db.json --host 0.0.0.0

<span class="hljs-comment"># 静默模式</span>
json-server db.json --quiet

<span class="hljs-comment"># 监视文件变化</span>
json-server db.json --watch
</code></pre>
<h4 data-id="heading-9">3. 访问 API</h4>
<p>启动后，服务器会提供以下端点：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 资源端点</span>
GET    /posts
GET    /posts/1
POST   /posts
PUT    /posts/1
PATCH  /posts/1
DELETE /posts/1

<span class="hljs-comment"># 其他资源</span>
GET    /comments
GET    /profile
</code></pre>
<h3 data-id="heading-10">REST API 操作</h3>
<h4 data-id="heading-11">GET - 获取数据</h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 获取所有文章</span>
curl http://localhost:3000/posts

<span class="hljs-comment"># 获取指定 ID 的文章</span>
curl http://localhost:3000/posts/1

<span class="hljs-comment"># 获取个人资料</span>
curl http://localhost:3000/profile
</code></pre>
<h4 data-id="heading-12">POST - 创建数据</h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 创建新文章</span>
curl -X POST http://localhost:3000/posts \
  -H <span class="hljs-string">"Content-Type: application/json"</span> \
  -d <span class="hljs-string">'{
    "title": "新文章",
    "author": "王五"
  }'</span>

<span class="hljs-comment"># 使用 JavaScript fetch</span>
fetch(<span class="hljs-string">'http://localhost:3000/posts'</span>, {
  method: <span class="hljs-string">'POST'</span>,
  headers: {
    <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json'</span>
  },
  body: JSON.stringify({
    title: <span class="hljs-string">'新文章'</span>,
    author: <span class="hljs-string">'王五'</span>
  })
})
</code></pre>
<h4 data-id="heading-13">PUT - 完整更新</h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 完整更新文章（必须包含所有字段）</span>
curl -X PUT http://localhost:3000/posts/1 \
  -H <span class="hljs-string">"Content-Type: application/json"</span> \
  -d <span class="hljs-string">'{
    "id": 1,
    "title": "更新后的标题",
    "author": "张三"
  }'</span>
</code></pre>
<h4 data-id="heading-14">PATCH - 部分更新</h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 部分更新文章（只更新指定字段）</span>
curl -X PATCH http://localhost:3000/posts/1 \
  -H <span class="hljs-string">"Content-Type: application/json"</span> \
  -d <span class="hljs-string">'{
    "title": "只更新标题"
  }'</span>
</code></pre>
<h4 data-id="heading-15">DELETE - 删除数据</h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 删除文章</span>
curl -X DELETE http://localhost:3000/posts/1
</code></pre>
<h3 data-id="heading-16">高级查询</h3>
<h4 data-id="heading-17">过滤</h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 按字段过滤</span>
GET /posts?author=张三

<span class="hljs-comment"># 多条件过滤</span>
GET /posts?author=张三&amp;<span class="hljs-built_in">id</span>=1

<span class="hljs-comment"># 嵌套属性过滤</span>
GET /comments?postId=1
</code></pre>
<h4 data-id="heading-18">分页</h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 分页查询</span>
GET /posts?_page=1&amp;_limit=10

<span class="hljs-comment"># 获取总数（在响应头 X-Total-Count 中）</span>
</code></pre>
<h4 data-id="heading-19">排序</h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 升序排序</span>
GET /posts?_sort=<span class="hljs-built_in">id</span>&amp;_order=asc

<span class="hljs-comment"># 降序排序</span>
GET /posts?_sort=<span class="hljs-built_in">id</span>&amp;_order=desc

<span class="hljs-comment"># 多字段排序</span>
GET /posts?_sort=author,<span class="hljs-built_in">id</span>&amp;_order=asc,desc
</code></pre>
<h4 data-id="heading-20">切片</h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 范围查询</span>
GET /posts?_start=0&amp;_end=10

<span class="hljs-comment"># 限制数量</span>
GET /posts?_limit=5

<span class="hljs-comment"># 跳过数量</span>
GET /posts?_start=5
</code></pre>
<h4 data-id="heading-21">操作符</h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 大于</span>
GET /posts?id_gte=1

<span class="hljs-comment"># 小于</span>
GET /posts?id_lte=10

<span class="hljs-comment"># 不等于</span>
GET /posts?id_ne=1

<span class="hljs-comment"># 包含</span>
GET /posts?q=关键词

<span class="hljs-comment"># 正则表达式</span>
GET /posts?id_like=1
</code></pre>
<h4 data-id="heading-22">全文搜索</h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 搜索包含关键词的记录</span>
GET /posts?q=文章

<span class="hljs-comment"># 搜索会在所有字段中查找</span>
</code></pre>
<h4 data-id="heading-23">关联查询</h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 获取文章及其评论</span>
GET /posts/1?_embed=comments

<span class="hljs-comment"># 获取评论及其所属文章</span>
GET /comments?_expand=post

<span class="hljs-comment"># 嵌套多个关系</span>
GET /posts/1?_embed=comments&amp;_embed=likes
</code></pre>
<h3 data-id="heading-24">配置选项</h3>
<h4 data-id="heading-25">命令行选项</h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 完整命令示例</span>
json-server db.json \
  --port 4000 \
  --host 0.0.0.0 \
  --watch \
  --routes routes.json \
  --middlewares middleware.js \
  --static ./public \
  --read-only \
  --no-cors
</code></pre>
<h4 data-id="heading-26">选项说明</h4>













































<table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>--port</code></td><td>指定端口号（默认 3000）</td></tr><tr><td><code>--host</code></td><td>指定主机地址（默认 localhost）</td></tr><tr><td><code>--watch</code></td><td>监视文件变化</td></tr><tr><td><code>--routes</code></td><td>自定义路由文件</td></tr><tr><td><code>--middlewares</code></td><td>中间件文件</td></tr><tr><td><code>--static</code></td><td>静态文件目录</td></tr><tr><td><code>--read-only</code></td><td>只读模式（禁用 POST/PUT/DELETE）</td></tr><tr><td><code>--no-cors</code></td><td>禁用 CORS</td></tr><tr><td><code>--quiet</code></td><td>静默模式</td></tr></tbody></table>
<h3 data-id="heading-27">自定义路由</h3>
<h4 data-id="heading-28">创建路由文件</h4>
<p>创建 <code>routes.json</code>：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"/api/*"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"/$1"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"/:resource/:id/show"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"/:resource/:id"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"/posts/:category"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"/posts?category=:category"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"/articles\\?id=:id"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"/posts/:id"</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<h4 data-id="heading-29">使用自定义路由</h4>
<pre><code class="hljs language-bash" lang="bash">json-server db.json --routes routes.json
</code></pre>
<h4 data-id="heading-30">路由示例</h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 原始路由</span>
GET /posts/1

<span class="hljs-comment"># 自定义路由</span>
GET /api/posts/1        <span class="hljs-comment"># 映射到 /posts/1</span>
GET /posts/1/show       <span class="hljs-comment"># 映射到 /posts/1</span>
GET /posts/tech         <span class="hljs-comment"># 映射到 /posts?category=tech</span>
</code></pre>
<h3 data-id="heading-31">中间件</h3>
<h4 data-id="heading-32">创建中间件</h4>
<p>创建 <code>middleware.js</code>：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> {
  <span class="hljs-comment">// 添加响应头</span>
  res.<span class="hljs-title function_">header</span>(<span class="hljs-string">'X-Custom-Header'</span>, <span class="hljs-string">'Custom Value'</span>)
  
  <span class="hljs-comment">// 记录请求</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${req.method}</span> <span class="hljs-subst">${req.url}</span>`</span>)
  
  <span class="hljs-comment">// 模拟延迟</span>
  <span class="hljs-keyword">if</span> (req.<span class="hljs-property">url</span>.<span class="hljs-title function_">includes</span>(<span class="hljs-string">'delay'</span>)) {
    <span class="hljs-built_in">setTimeout</span>(next, <span class="hljs-number">2000</span>)
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-title function_">next</span>()
  }
}
</code></pre>
<h4 data-id="heading-33">使用中间件</h4>
<pre><code class="hljs language-bash" lang="bash">json-server db.json --middlewares middleware.js
</code></pre>
<h4 data-id="heading-34">高级中间件示例</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> {
  <span class="hljs-comment">// 身份验证模拟</span>
  <span class="hljs-keyword">if</span> (req.<span class="hljs-property">method</span> === <span class="hljs-string">'POST'</span> &amp;&amp; !req.<span class="hljs-property">headers</span>.<span class="hljs-property">authorization</span>) {
    <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">status</span>(<span class="hljs-number">401</span>).<span class="hljs-title function_">json</span>({ <span class="hljs-attr">error</span>: <span class="hljs-string">'Unauthorized'</span> })
  }
  
  <span class="hljs-comment">// 请求日志</span>
  <span class="hljs-keyword">const</span> timestamp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">toISOString</span>()
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`[<span class="hljs-subst">${timestamp}</span>] <span class="hljs-subst">${req.method}</span> <span class="hljs-subst">${req.url}</span>`</span>)
  
  <span class="hljs-comment">// 修改响应</span>
  <span class="hljs-keyword">const</span> originalSend = res.<span class="hljs-property">send</span>
  res.<span class="hljs-property">send</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) {
    <span class="hljs-keyword">const</span> modifiedData = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(data)
    modifiedData.<span class="hljs-property">timestamp</span> = timestamp
    originalSend.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(modifiedData))
  }
  
  <span class="hljs-title function_">next</span>()
}
</code></pre>
<h3 data-id="heading-35">数据生成</h3>
<h4 data-id="heading-36">使用 Faker.js 生成测试数据</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> faker = <span class="hljs-built_in">require</span>(<span class="hljs-string">'faker'</span>)
<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>)

<span class="hljs-keyword">const</span> <span class="hljs-title function_">generateData</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-keyword">const</span> users = []
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100</span>; i++) {
    users.<span class="hljs-title function_">push</span>({
      <span class="hljs-attr">id</span>: i,
      <span class="hljs-attr">name</span>: faker.<span class="hljs-property">name</span>.<span class="hljs-title function_">findName</span>(),
      <span class="hljs-attr">email</span>: faker.<span class="hljs-property">internet</span>.<span class="hljs-title function_">email</span>(),
      <span class="hljs-attr">phone</span>: faker.<span class="hljs-property">phone</span>.<span class="hljs-title function_">phoneNumber</span>(),
      <span class="hljs-attr">address</span>: {
        <span class="hljs-attr">street</span>: faker.<span class="hljs-property">address</span>.<span class="hljs-title function_">streetAddress</span>(),
        <span class="hljs-attr">city</span>: faker.<span class="hljs-property">address</span>.<span class="hljs-title function_">city</span>(),
        <span class="hljs-attr">country</span>: faker.<span class="hljs-property">address</span>.<span class="hljs-title function_">country</span>()
      },
      <span class="hljs-attr">company</span>: faker.<span class="hljs-property">company</span>.<span class="hljs-title function_">companyName</span>()
    })
  }
  
  <span class="hljs-keyword">const</span> db = { users }
  fs.<span class="hljs-title function_">writeFileSync</span>(<span class="hljs-string">'db.json'</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(db, <span class="hljs-literal">null</span>, <span class="hljs-number">2</span>))
}

<span class="hljs-title function_">generateData</span>()
</code></pre>
<h4 data-id="heading-37">运行生成器</h4>
<pre><code class="hljs language-bash" lang="bash">node generate-data.js
json-server db.json
</code></pre>
<h3 data-id="heading-38">与前端框架集成</h3>
<h4 data-id="heading-39">React 示例</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">'axios'</span>

<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">API_URL</span> = <span class="hljs-string">'http://localhost:3000'</span>

<span class="hljs-comment">// 获取所有文章</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">getPosts</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">`<span class="hljs-subst">${API_URL}</span>/posts`</span>)
  <span class="hljs-keyword">return</span> response.<span class="hljs-property">data</span>
}

<span class="hljs-comment">// 创建文章</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">createPost</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">post</span>) =&gt; {
  <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> axios.<span class="hljs-title function_">post</span>(<span class="hljs-string">`<span class="hljs-subst">${API_URL}</span>/posts`</span>, post)
  <span class="hljs-keyword">return</span> response.<span class="hljs-property">data</span>
}

<span class="hljs-comment">// 更新文章</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">updatePost</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">id, post</span>) =&gt; {
  <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> axios.<span class="hljs-title function_">put</span>(<span class="hljs-string">`<span class="hljs-subst">${API_URL}</span>/posts/<span class="hljs-subst">${id}</span>`</span>, post)
  <span class="hljs-keyword">return</span> response.<span class="hljs-property">data</span>
}

<span class="hljs-comment">// 删除文章</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">deletePost</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">id</span>) =&gt; {
  <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> axios.<span class="hljs-title function_">delete</span>(<span class="hljs-string">`<span class="hljs-subst">${API_URL}</span>/posts/<span class="hljs-subst">${id}</span>`</span>)
  <span class="hljs-keyword">return</span> response.<span class="hljs-property">data</span>
}
</code></pre>
<h4 data-id="heading-40">Vue 示例</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">'axios'</span>

<span class="hljs-keyword">const</span> api = axios.<span class="hljs-title function_">create</span>({
  <span class="hljs-attr">baseURL</span>: <span class="hljs-string">'http://localhost:3000'</span>
})

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">getPosts</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> api.<span class="hljs-title function_">get</span>(<span class="hljs-string">'/posts'</span>)
    <span class="hljs-keyword">return</span> response.<span class="hljs-property">data</span>
  },
  
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">createPost</span>(<span class="hljs-params">post</span>) {
    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> api.<span class="hljs-title function_">post</span>(<span class="hljs-string">'/posts'</span>, post)
    <span class="hljs-keyword">return</span> response.<span class="hljs-property">data</span>
  },
  
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">updatePost</span>(<span class="hljs-params">id, post</span>) {
    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> api.<span class="hljs-title function_">put</span>(<span class="hljs-string">`/posts/<span class="hljs-subst">${id}</span>`</span>, post)
    <span class="hljs-keyword">return</span> response.<span class="hljs-property">data</span>
  },
  
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">deletePost</span>(<span class="hljs-params">id</span>) {
    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> api.<span class="hljs-title function_">delete</span>(<span class="hljs-string">`/posts/<span class="hljs-subst">${id}</span>`</span>)
    <span class="hljs-keyword">return</span> response.<span class="hljs-property">data</span>
  }
}
</code></pre>
<h3 data-id="heading-41">package.json 配置</h3>
<h4 data-id="heading-42">添加脚本</h4>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"my-project"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"version"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"1.0.0"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"scripts"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"json-server"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"json-server --watch db.json --port 4000"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"dev"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"npm run json-server"</span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"devDependencies"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"json-server"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"^0.17.3"</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<h4 data-id="heading-43">运行脚本</h4>
<pre><code class="hljs language-bash" lang="bash">npm run dev
</code></pre>
<h3 data-id="heading-44">常见问题</h3>
<h4 data-id="heading-45">1. 端口被占用</h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 使用其他端口</span>
json-server db.json --port 4000
</code></pre>
<h4 data-id="heading-46">2. CORS 问题</h4>
<p>json-server 默认启用 CORS，如果遇到问题：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 确保没有禁用 CORS</span>
json-server db.json
</code></pre>
<h4 data-id="heading-47">3. 数据持久化</h4>
<p>json-server 会将修改保存到 <code>db.json</code> 文件中，确保文件有写入权限。</p>
<h4 data-id="heading-48">4. 重置数据</h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 删除 db.json 或恢复备份</span>
<span class="hljs-built_in">rm</span> db.json
<span class="hljs-built_in">cp</span> db.json.backup db.json
</code></pre>
<h3 data-id="heading-49">最佳实践</h3>
<h4 data-id="heading-50">1. 版本控制</h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 添加到 .gitignore</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"db.json"</span> &gt;&gt; .gitignore

<span class="hljs-comment"># 创建示例数据文件</span>
<span class="hljs-built_in">cp</span> db.json db.example.json
</code></pre>
<h4 data-id="heading-51">2. 环境配置</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// config.js</span>
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">port</span>: process.<span class="hljs-property">env</span>.<span class="hljs-property">JSON_SERVER_PORT</span> || <span class="hljs-number">3000</span>,
  <span class="hljs-attr">host</span>: process.<span class="hljs-property">env</span>.<span class="hljs-property">JSON_SERVER_HOST</span> || <span class="hljs-string">'localhost'</span>,
  <span class="hljs-attr">watch</span>: process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> !== <span class="hljs-string">'production'</span>
}
</code></pre>
<h4 data-id="heading-52">3. 数据验证</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// middleware.js</span>
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (req.<span class="hljs-property">method</span> === <span class="hljs-string">'POST'</span> || req.<span class="hljs-property">method</span> === <span class="hljs-string">'PUT'</span>) {
    <span class="hljs-keyword">const</span> body = req.<span class="hljs-property">body</span>
    
    <span class="hljs-comment">// 验证必填字段</span>
    <span class="hljs-keyword">if</span> (!body.<span class="hljs-property">title</span>) {
      <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">status</span>(<span class="hljs-number">400</span>).<span class="hljs-title function_">json</span>({ <span class="hljs-attr">error</span>: <span class="hljs-string">'Title is required'</span> })
    }
  }
  <span class="hljs-title function_">next</span>()
}
</code></pre>
<h4 data-id="heading-53">4. 性能优化</h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 使用静态文件服务</span>
json-server db.json --static ./public

<span class="hljs-comment"># 禁用日志（生产环境）</span>
json-server db.json --quiet
</code></pre>
<h3 data-id="heading-54">总结</h3>
<p>json-server 是一个强大且易于使用的工具，适合：</p>
<ul>
<li>✅ 前端开发和原型设计</li>
<li>✅ API 测试和调试</li>
<li>✅ 快速搭建演示项目</li>
<li>✅ 学习 REST API 概念</li>
</ul>
<p>通过本教程，你应该能够：</p>
<ul>
<li>安装和启动 json-server</li>
<li>执行 CRUD 操作</li>
<li>使用高级查询功能</li>
<li>自定义路由和中间件</li>
<li>与前端框架集成</li>
</ul>
<p>开始使用 json-server，快速构建你的 REST API 吧！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[VS Code 终端崩溃问题分析与解决方案]]></title>    <link>https://juejin.cn/post/7590020026395574326</link>    <guid>https://juejin.cn/post/7590020026395574326</guid>    <pubDate>2026-01-03T02:35:40.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7590020026395574326" data-draft-id="7589919989039480895" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="VS Code 终端崩溃问题分析与解决方案"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-01-03T02:35:40.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="凯哥1970"/> <meta itemprop="url" content="https://juejin.cn/user/3954283342211335"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            VS Code 终端崩溃问题分析与解决方案
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3954283342211335/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    凯哥1970
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-03T02:35:40.000Z" title="Sat Jan 03 2026 02:35:40 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">VS Code 终端崩溃问题分析与解决方案</h2>
<h3 data-id="heading-1">错误代码：<code>-2147023895 (0x800703E9)</code></h3>
<p>显示如下</p>
<pre><code class="hljs language-shell" lang="shell">终端进程“C:\WINDOWS\System32\WindowsPowerShell\v1.0\powershell.exe”已终止，退出代码: -2147023895。
</code></pre>
<h4 data-id="heading-2">问题描述</h4>
<p>在 VS Code 中打开终端时，PowerShell 进程异常退出，返回错误代码 <code>-2147023895</code>。该错误会导致终端无法正常启动或使用，影响开发效率。</p>
<hr/>
<h4 data-id="heading-3">错误原因分析</h4>
<p>错误代码 <code>-2147023895</code> 对应十六进制值 <code>0x800703E9</code>，是一个标准的 <strong>HRESULT 错误码</strong>，其结构解析如下：</p>
<ul>
<li><strong>严重性位（Bit 31）</strong> ：1，表示失败。</li>
<li><strong>设备代码（Bits 16-26）</strong> ：7（<code>FACILITY_WIN32</code>），表示错误源自 Windows API 调用。</li>
<li><strong>低位代码（Bits 0-15）</strong> ：<code>0x03E9</code>（十进制 1001）。</li>
</ul>
<h5 data-id="heading-4">可能的原因：</h5>
<ol>
<li><strong>栈溢出（Stack Overflow）</strong><br/>
PowerShell 启动时脚本陷入无限递归，耗尽线程栈空间，触发系统异常。</li>
<li><strong>文件完整性校验失败（Invalid Image Hash）</strong><br/>
Windows 代码完整性机制或安全软件（如 AppLocker）检测到脚本文件签名无效、文件损坏或哈希不匹配，导致加载被拒绝。</li>
<li><strong>环境变量冲突</strong><br/>
脚本执行过程中展开的环境变量（如 <code>PATH</code>）过长，引发内存或栈溢出。</li>
</ol>
<h4 data-id="heading-5">根本原因定位</h4>
<p>多数情况下，该错误与 <strong>VS Code 终端 Shell 集成脚本</strong> <code>shellIntegration.ps1</code> 有关。该脚本在终端启动时被自动加载，若文件损坏或与用户配置冲突，即会触发上述错误。</p>
<hr/>
<h4 data-id="heading-6">解决方案：手动替换脚本文件（治本）</h4>
<p>无需禁用终端功能，直接替换损坏的脚本文件即可根治问题。</p>
<h5 data-id="heading-7">操作步骤：</h5>
<ol>
<li>
<p><strong>定位脚本文件</strong><br/>
根据 VS Code 安装方式，找到目标目录：</p>
<ul>
<li><strong>用户安装</strong>：<br/>
<code>%LOCALAPPDATA%\Programs&lt;EditorName&gt;\resources\app\out\vs\workbench\contrib\terminal\common\scripts</code></li>
<li><strong>系统安装</strong>：<br/>
<code>C:\Program Files\Microsoft VS Code\resources\app\out\vs\workbench\contrib\terminal\common\scripts</code></li>
</ul>
</li>
<li>
<p><strong>备份原文件</strong><br/>
将目录中的 <code>shellIntegration.ps1</code> 重命名为 <code>shellIntegration.ps1.bak</code>，作为备份。</p>
</li>
<li>
<p><strong>下载官方脚本</strong><br/>
访问 VS Code 官方 GitHub 仓库，下载最新版本的脚本文件：<br/>
<a href="https://link.juejin.cn?target=https%3A%2F%2Fraw.githubusercontent.com%2Fmicrosoft%2Fvscode%2Fmain%2Fsrc%2Fvs%2Fworkbench%2Fcontrib%255Cterminal%255Ccommon%255Cscripts%255CshellIntegration.ps1" target="_blank" title="https://raw.githubusercontent.com/microsoft/vscode/main/src/vs/workbench/contrib%5Cterminal%5Ccommon%5Cscripts%5CshellIntegration.ps1" ref="nofollow noopener noreferrer">raw.githubusercontent.com/microsoft/v…</a></p>
</li>
<li>
<p><strong>替换文件</strong><br/>
将下载的 <code>shellIntegration.ps1</code> 复制到步骤 1 的目录中，确保当前用户有读取权限。</p>
</li>
<li>
<p><strong>重启验证</strong><br/>
完全关闭 VS Code（包括后台进程），重新启动并打开终端，检查是否恢复正常。</p>
</li>
</ol>
<hr/>
<h4 data-id="heading-8">方案原理</h4>
<p>通过替换为官方完好的脚本文件，确保：</p>
<ul>
<li>PowerShell 解析器能正常解析语法，避免因文件损坏导致的崩溃。</li>
<li>脚本与用户环境兼容，避免递归冲突或安全校验失败。</li>
<li>保留完整的终端 Shell 集成功能（如命令装饰、状态提示等）。</li>
</ul>
<hr/>
<h4 data-id="heading-9">注意事项</h4>
<ul>
<li>若问题仍然存在，可检查用户 PowerShell 配置文件（<code>$PROFILE</code>）中是否存在与 Shell 集成冲突的自定义代码。</li>
<li>建议定期更新 VS Code，以获取官方修复的脚本版本。</li>
</ul>
<hr/>
<p>通过以上步骤，可从根本上解决终端崩溃问题，无需临时禁用功能或修改启动命令，确保开发环境稳定可用。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Kotlin extensions是什么？]]></title>    <link>https://juejin.cn/post/7590503651141419034</link>    <guid>https://juejin.cn/post/7590503651141419034</guid>    <pubDate>2026-01-03T02:24:20.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7590503651141419034" data-draft-id="7590292138346610698" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Kotlin extensions是什么？"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2026-01-03T02:24:20.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Poorguy9527"/> <meta itemprop="url" content="https://juejin.cn/user/1746465251931063"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Kotlin extensions是什么？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1746465251931063/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Poorguy9527
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-03T02:24:20.000Z" title="Sat Jan 03 2026 02:24:20 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>扩展是怎么做到的</p>
</blockquote>
<p>Kotlin扩展（Extensions）的实现原理主要基于<strong>编译时的静态分派</strong>和<strong>语法糖</strong>。</p>
<blockquote>
<p>从编译后的字节码层面看</p>
</blockquote>
<p>扩展函数被编译为：</p>
<ul>
<li>静态方法（static method）</li>
<li>第一个参数是接收者类型（receiver type）</li>
<li>方法名包含接收者类型信息（避免冲突）</li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// Kotlin代码</span>
fun <span class="hljs-title class_">String</span>.<span class="hljs-title function_">addExclamation</span>(): <span class="hljs-title class_">String</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-string">"$this!"</span>
}

<span class="hljs-comment">// 编译后等价于Java</span>
public <span class="hljs-keyword">static</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">addExclamation</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> receiver</span>) {
    <span class="hljs-keyword">return</span> receiver + <span class="hljs-string">"!"</span>;
}


<span class="hljs-comment">// 反编译后的Java代码示例</span>
public final <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringExtensionsKt</span> {
    public <span class="hljs-keyword">static</span> final <span class="hljs-title class_">String</span> <span class="hljs-title function_">addExclamation</span>(<span class="hljs-params">@NotNull <span class="hljs-built_in">String</span> $this$addExclamation</span>) {
        <span class="hljs-comment">// 方法体</span>
    }
}
</code></pre>
<h3 data-id="heading-0"> 限制和注意事项</h3>
<ol>
<li><strong>没有多态性</strong>：扩展是静态分派的</li>
<li><strong>不能覆盖成员</strong>：扩展函数不会覆盖类的成员函数</li>
<li><strong>作用域限制</strong>：需要导入才能使用</li>
<li><strong>优先级</strong>：成员函数优先于扩展函数</li>
</ol>
<h3 data-id="heading-1">Kotlin扩展的本质是：</h3>
<ul>
<li><strong>语法糖</strong>：提供更好的API设计体验</li>
<li><strong>静态分派</strong>：编译时确定调用的方法</li>
<li><strong>无侵入</strong>：不修改原有类的字节码</li>
<li><strong>类型安全</strong>：编译器进行完整的类型检查</li>
</ul>
<p>这种设计使得Kotlin能够在不破坏现有Java兼容性的前提下，提供灵活的API扩展能力。</p>
<h2 data-id="heading-2">不同类型扩展实现</h2>
<h4 data-id="heading-3">顶层扩展</h4>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 文件: StringExtensions.kt</span>
package com.<span class="hljs-property">example</span>

fun <span class="hljs-title class_">String</span>.<span class="hljs-title function_">customExtension</span>(<span class="hljs-params"/>) { ... }

<span class="hljs-comment">// 使用：自动导入</span>
<span class="hljs-string">"hello"</span>.<span class="hljs-title function_">customExtension</span>()
</code></pre>
<h4 data-id="heading-4">成员扩展</h4>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Host</span> {
    <span class="hljs-comment">// 扩展的接收者是String，但声明在Host内部</span>
    fun <span class="hljs-title class_">String</span>.<span class="hljs-title function_">doSomething</span>(<span class="hljs-params"/>) {
        <span class="hljs-comment">// 可以访问Host的成员</span>
    }
}
</code></pre>
<h4 data-id="heading-5">扩展伴随对象</h4>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {
    companion object
}

fun <span class="hljs-title class_">MyClass</span>.<span class="hljs-property">Companion</span>.<span class="hljs-title function_">extension</span>(<span class="hljs-params"/>) { ... }
</code></pre>
<h2 data-id="heading-6">特殊情况的处理</h2>
<h4 data-id="heading-7">扩展与继承</h4>
<pre><code class="hljs language-js" lang="js">open <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> : <span class="hljs-title class_">Animal</span>()

fun <span class="hljs-title class_">Animal</span>.<span class="hljs-title function_">speak</span>() = <span class="hljs-string">"Animal sound"</span>
fun <span class="hljs-title class_">Dog</span>.<span class="hljs-title function_">speak</span>() = <span class="hljs-string">"Bark"</span>

val <span class="hljs-attr">animal</span>: <span class="hljs-title class_">Animal</span> = <span class="hljs-title class_">Dog</span>()
<span class="hljs-title function_">println</span>(animal.<span class="hljs-title function_">speak</span>()) <span class="hljs-comment">// "Animal sound" (静态分派)</span>
</code></pre>
<h4 data-id="heading-8">可空接收者</h4>
<pre><code class="hljs language-js" lang="js">fun <span class="hljs-title class_">String</span>?.<span class="hljs-title function_">safeLength</span>(): <span class="hljs-title class_">Int</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>?.<span class="hljs-property">length</span> ?: <span class="hljs-number">0</span>
}

<span class="hljs-comment">// 编译为处理null的静态方法</span>

</code></pre>
<h4 data-id="heading-9">泛型扩展</h4>
<pre><code class="hljs language-js" lang="js">fun &lt;T&gt; <span class="hljs-title class_">List</span>&lt;T&gt;.<span class="hljs-title function_">customFilter</span>(): <span class="hljs-title class_">List</span>&lt;T&gt; { ... }

<span class="hljs-comment">// 编译时进行类型擦除，但保留类型安全检查</span>
</code></pre>
<h2 data-id="heading-10">扩展属性背后的机制</h2>
<p>扩展属性<strong>没有幕后字段</strong>（backing field），必须提供getter（和setter）：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">var</span> <span class="hljs-title class_">StringBuilder</span>.<span class="hljs-property">lastChar</span>: <span class="hljs-title class_">Char</span>
    <span class="hljs-title function_">get</span>() = <span class="hljs-title function_">get</span>(length - <span class="hljs-number">1</span>)
    <span class="hljs-title function_">set</span>(value) = <span class="hljs-title function_">setCharAt</span>(length - <span class="hljs-number">1</span>, value)

<span class="hljs-comment">// 编译为两个静态方法：</span>
<span class="hljs-comment">// getLastChar(StringBuilder)</span>
<span class="hljs-comment">// setLastChar(StringBuilder, Char)</span>
</code></pre>
<h2 data-id="heading-11">与Java的互操作性</h2>
<h4 data-id="heading-12">从Java调用Kotlin扩展</h4>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// Kotlin扩展</span>
fun <span class="hljs-title class_">String</span>.<span class="hljs-title function_">kotlinExtension</span>(): <span class="hljs-title class_">String</span> { ... }

<span class="hljs-comment">// Java中调用</span>
<span class="hljs-title class_">String</span> result = <span class="hljs-title class_">ExtensionKt</span>.<span class="hljs-title function_">kotlinExtension</span>(<span class="hljs-string">"hello"</span>);
</code></pre>
<h4 data-id="heading-13">扩展的JVM注解</h4>
<p>编译器可以添加<code>@JvmName</code>来修改生成的Java方法名：</p>
<pre><code class="hljs language-js" lang="js">@<span class="hljs-title class_">JvmName</span>(<span class="hljs-string">"addPrefix"</span>)
fun <span class="hljs-title class_">String</span>.<span class="hljs-title function_">prefix</span>() = <span class="hljs-string">"prefix_$this"</span>
</code></pre>
<h2 data-id="heading-14">实际应用示例</h2>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 实际编译示例</span>
fun <span class="hljs-title class_">String</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-attr">n</span>: <span class="hljs-title class_">Int</span>): <span class="hljs-title class_">String</span> {
    val builder = <span class="hljs-title class_">StringBuilder</span>()
    <span class="hljs-title function_">repeat</span>(<span class="hljs-params">n</span>) { builder.<span class="hljs-title function_">append</span>(<span class="hljs-variable language_">this</span>) }
    <span class="hljs-keyword">return</span> builder.<span class="hljs-title function_">toString</span>()
}

<span class="hljs-comment">// 编译为：</span>
public <span class="hljs-keyword">static</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">repeat</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> receiver, int n</span>) {
    <span class="hljs-title class_">StringBuilder</span> builder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();
    <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; n; i++) {
        builder.<span class="hljs-title function_">append</span>(receiver);
    }
    <span class="hljs-keyword">return</span> builder.<span class="hljs-title function_">toString</span>();
}
</code></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[一次必现ANR问题的深度分析与解决之旅:当NestedScrollView遇上VelocityTracker]]></title>    <link>https://juejin.cn/post/7590128405351432192</link>    <guid>https://juejin.cn/post/7590128405351432192</guid>    <pubDate>2026-01-03T02:34:49.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7590128405351432192" data-draft-id="7590128405351415808" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="一次必现ANR问题的深度分析与解决之旅:当NestedScrollView遇上VelocityTracker"/> <meta itemprop="keywords" content="Android,Debug,性能优化"/> <meta itemprop="datePublished" content="2026-01-03T02:34:49.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="冬奇Lab"/> <meta itemprop="url" content="https://juejin.cn/user/1857501105781193"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            一次必现ANR问题的深度分析与解决之旅:当NestedScrollView遇上VelocityTracker
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1857501105781193/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    冬奇Lab
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-03T02:34:49.000Z" title="Sat Jan 03 2026 02:34:49 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读13分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">下班前总会有问题在等你</h2>
<p>周五下午快下班了,测试同学突然找过来:"这个页面每次点击都会卡死,必现的!"你心想,"必现?那还不简单,分分钟搞定。"结果拿到日志一看,好家伙,<strong>一小时内连续发生了7次ANR</strong>,主线程居然在CPU上执行了超过7秒的计算任务!</p>
<p>这不是段子,这是我最近遇到的一个真实案例。今天就和大家分享这次"惊心动魄"的ANR排查之旅——从发现问题到深度分析,再到提供多套解决方案的完整过程。</p>
<h2 data-id="heading-1">过程速览</h2>
<ul>
<li><strong>问题</strong>: 车载设置应用中,点击日间行车灯设置时必现ANR,主线程阻塞超过7秒</li>
<li><strong>根因</strong>: <code>NestedScrollView</code> 触摸事件处理时,<code>VelocityTracker</code> 的速度计算(最小二乘法)耗时异常</li>
<li><strong>影响</strong>: P0级严重问题,必现,影响用户体验</li>
<li><strong>解决</strong>: 提供4个层级的解决方案,从快速修复到架构优化</li>
<li><strong>收获</strong>: 深入理解Android触摸事件处理机制,掌握ANR排查方法论</li>
</ul>
<h2 data-id="heading-2">问题现场还原</h2>
<h3 data-id="heading-3">案发现场</h3>
<p><strong>时间</strong>: 2025年12月23日 15:25-16:13<br/>
<strong>地点</strong>: 车载设置应用 → 车灯 → 环境灯 → 日间行车灯设置<br/>
<strong>案情</strong>: 每次点击日间行车灯下方的文字,应用立即卡死并闪退</p>
<p><strong>关键证据</strong> (来自ANR trace文件):</p>
<pre><code class="hljs language-ini" lang="ini">Subject: Input dispatching timed out
(SMART_POPUP_INTERRUPT_PERM is not responding.
Waited 5000ms for MotionEvent(<span class="hljs-attr">action</span>=UP))

主线程状态:
- <span class="hljs-attr">state</span>=Native (正在执行native代码)
- CPU <span class="hljs-attr">time</span>=<span class="hljs-number">7538472365</span>纳秒 ≈ <span class="hljs-number">7.5</span>秒
- 用户态时间:702个时间片 ≈ 7.02秒
</code></pre>
<p>看到这里我就纳闷了:一个简单的触摸事件,凭什么要消耗7秒的CPU时间?</p>
<h3 data-id="heading-4">连续作案记录</h3>
<p>更让人惊讶的是,这不是孤立事件。从Critical Event Log中发现,这个ANR在一小时内重复出现了7次:</p>





















































<table><thead><tr><th>时间</th><th>PID</th><th>时间间隔</th><th>状态</th></tr></thead><tbody><tr><td>15:25:03</td><td>3292</td><td>-</td><td>首次出现</td></tr><tr><td>15:49:16</td><td>15858</td><td>24分13秒</td><td>应用重启</td></tr><tr><td>15:49:52</td><td>16887</td><td>36秒</td><td>快速复现</td></tr><tr><td>15:52:31</td><td>16887</td><td>2分39秒</td><td>持续出现</td></tr><tr><td><strong>15:53:18</strong></td><td><strong>17362</strong></td><td><strong>47秒</strong></td><td><strong>当前分析</strong></td></tr><tr><td>15:54:10</td><td>?</td><td>52秒</td><td>再次复现</td></tr><tr><td>16:13:27</td><td>?</td><td>19分17秒</td><td>仍在发生</td></tr></tbody></table>
<p><strong>结论</strong>:这是一个稳定复现的代码级Bug,而不是偶发的系统问题或硬件异常。</p>
<h2 data-id="heading-5">深入分析:真相只有一个</h2>
<h3 data-id="heading-6">调用栈追踪</h3>
<p>让我们看看主线程在干什么(关键部分):</p>
<pre><code class="hljs language-less" lang="less"><span class="hljs-selector-tag">Native</span>层阻塞点:
  <span class="hljs-selector-id">#00</span> <span class="hljs-selector-tag">libinput</span><span class="hljs-selector-class">.so</span>: <span class="hljs-selector-tag">LeastSquaresVelocityTrackerStrategy</span>::<span class="hljs-selector-tag">getEstimator</span>+<span class="hljs-number">299</span>
  <span class="hljs-selector-id">#01</span> <span class="hljs-selector-tag">libinput</span><span class="hljs-selector-class">.so</span>: <span class="hljs-selector-tag">VelocityTracker</span>::<span class="hljs-selector-tag">getVelocity</span>+<span class="hljs-number">65</span>
  <span class="hljs-selector-id">#02</span> <span class="hljs-selector-tag">libandroid_runtime</span><span class="hljs-selector-class">.so</span>: <span class="hljs-selector-tag">android_view_VelocityTracker_nativeComputeCurrentVelocity</span>

<span class="hljs-selector-tag">Java</span>层调用链:
  <span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">android</span><span class="hljs-selector-class">.view</span><span class="hljs-selector-class">.VelocityTracker</span><span class="hljs-selector-class">.nativeComputeCurrentVelocity</span>(Native)
  <span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">android</span><span class="hljs-selector-class">.view</span><span class="hljs-selector-class">.VelocityTracker</span><span class="hljs-selector-class">.computeCurrentVelocity</span>(VelocityTracker.<span class="hljs-attribute">java</span>:<span class="hljs-number">354</span>)
  <span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">androidx</span><span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.widget</span><span class="hljs-selector-class">.NestedScrollView</span><span class="hljs-selector-class">.onTouchEvent</span>(<span class="hljs-attribute">unavailable</span>:<span class="hljs-number">467</span>)
  <span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">android</span><span class="hljs-selector-class">.view</span><span class="hljs-selector-class">.View</span><span class="hljs-selector-class">.dispatchTouchEvent</span>(View.<span class="hljs-attribute">java</span>:<span class="hljs-number">15010</span>)
  ...
  <span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">android</span><span class="hljs-selector-class">.app</span><span class="hljs-selector-class">.Dialog</span><span class="hljs-selector-class">.dispatchTouchEvent</span>(Dialog.<span class="hljs-attribute">java</span>:<span class="hljs-number">911</span>)  ← 问题发生在<span class="hljs-selector-tag">Dialog</span>中
</code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c5b5278982954dcba4bb7f23672d66d0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Yas5aWHTGFi:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768012488&amp;x-signature=jvQvQkPhMsz2d8q7tyfZQdmmTHc%3D" alt="case4-anr-touch-event-flow.png" loading="lazy"/></p>
<p><em>图1: ANR触摸事件处理完整流程</em></p>
<h3 data-id="heading-7">罪魁祸首:VelocityTracker</h3>
<p><strong>什么是VelocityTracker?</strong></p>
<p><code>VelocityTracker</code> 是Android中用于计算触摸滑动速度的工具类。当你在屏幕上滑动时,它会记录你手指的轨迹,然后用**最小二乘法(Least Squares)**拟合一条曲线,计算出滑动速度。这个速度用于实现惯性滚动(Fling)效果。</p>
<p><strong>正常情况</strong>:这个计算应该在几毫秒内完成。
<strong>我们的情况</strong>:耗时超过7秒!</p>
<p><strong>为什么会这样?</strong></p>
<p>经过分析,最可能的原因是<strong>触摸数据异常</strong>:</p>
<ol>
<li>
<p><strong>触摸点积累过多</strong>: <code>VelocityTracker</code> 内部维护了一个历史触摸点队列。如果触摸屏驱动产生了异常的高频采样,队列中可能积累了成百上千个触摸点。</p>
</li>
<li>
<p><strong>最小二乘法的复杂度</strong>: 假设有N个触摸点,最小二乘法的时间复杂度大约是O(N²)到O(N³),当N变得很大时,计算量暴增。</p>
</li>
<li>
<p><strong>Native层没有超时保护</strong>: Android的VelocityTracker实现没有超时机制,如果数据异常,它会老老实实把所有点都算完,哪怕要算7秒。</p>
</li>
</ol>
<p><strong>我踩过的坑</strong>:刚开始我以为是主线程做了耗时操作(比如网络请求或数据库查询),结果发现根本不是!这个ANR完全是由一个"应该瞬间完成"的速度计算引起的。这告诉我们:永远不要对系统API的性能做假设。</p>
<h3 data-id="heading-8">界面结构分析</h3>
<p>问题发生在这样的视图层次中:</p>
<pre><code class="hljs language-scss" lang="scss">DecorView
  └─ Dialog (车灯环境灯设置对话框)
      └─ ViewGroup (多层嵌套)
          └─ NestedScrollView  ← 问题发生位置
              └─ <span class="hljs-selector-attr">[日间行车灯设置内容]</span>
</code></pre>
<p><strong>为什么是NestedScrollView?</strong></p>
<p><code>NestedScrollView</code> 是 AndroidX 提供的增强版 <code>ScrollView</code>,支持嵌套滑动(Nested Scrolling)。相比普通 <code>ScrollView</code>,它的触摸事件处理更复杂,更依赖 <code>VelocityTracker</code> 来协调嵌套滑动。</p>
<h2 data-id="heading-9">解决方案:四个层级的战术选择</h2>
<p>面对这个问题,我准备了4个不同层级的解决方案,从"快速止血"到"根治病灶"。</p>
<h3 data-id="heading-10">方案1:禁用速度追踪(立即修复,5分钟搞定)</h3>
<p><strong>优先级</strong>: ⭐⭐⭐⭐⭐
<strong>实施难度</strong>: ★☆☆☆☆
<strong>预期效果</strong>: 直接避免VelocityTracker计算,立即解决ANR</p>
<p><strong>实施步骤</strong>:</p>
<p>在布局文件中:</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">androidx.core.widget.NestedScrollView</span>
    <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/nested_scroll_view"</span>
    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span>
    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"match_parent"</span>
    <span class="hljs-attr">android:nestedScrollingEnabled</span>=<span class="hljs-string">"false"</span>
    <span class="hljs-attr">android:overScrollMode</span>=<span class="hljs-string">"never"</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- 内容 --&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">androidx.core.widget.NestedScrollView</span>&gt;</span>
</code></pre>
<p>或在代码中动态设置:</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">val</span> nestedScrollView = dialog.findViewById&lt;NestedScrollView&gt;(R.id.nested_scroll_view)
nestedScrollView.isNestedScrollingEnabled = <span class="hljs-literal">false</span>
nestedScrollView.overScrollMode = View.OVER_SCROLL_NEVER

<span class="hljs-comment">// 如果问题依然存在,完全禁用fling行为</span>
nestedScrollView.setOnTouchListener { _, event -&gt;
    <span class="hljs-keyword">if</span> (event.action == MotionEvent.ACTION_UP) {
        nestedScrollView.fling(<span class="hljs-number">0</span>)  <span class="hljs-comment">// 禁用惯性滚动</span>
    }
    <span class="hljs-literal">false</span>
}
</code></pre>
<p><strong>权衡</strong>:</p>
<ul>
<li>✅ 超快:5分钟内完成并验证</li>
<li>✅ 低风险:不影响正常滑动,只是没有惯性效果</li>
<li>⚠️ 用户体验略有下降:失去了丝滑的惯性滚动</li>
</ul>
<p><strong>我的经验</strong>:对于生产环境的紧急Bug,这是最佳选择。先止血,再优化。</p>
<h3 data-id="heading-11">方案2:替换为ScrollView(根本解决,1小时重构)</h3>
<p><strong>优先级</strong>: ⭐⭐⭐⭐
<strong>实施难度</strong>: ★★☆☆☆
<strong>预期效果</strong>: 从根本上避免NestedScrollView的复杂性</p>
<p>如果你的Dialog内容不需要嵌套滑动功能,直接用 <code>ScrollView</code> 替代:</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ScrollView</span>
    <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/scroll_view"</span>
    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span>
    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"match_parent"</span>
    <span class="hljs-attr">android:fillViewport</span>=<span class="hljs-string">"true"</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- 保持原有内容结构 --&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">ScrollView</span>&gt;</span>
</code></pre>
<p>代码迁移:</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// ScrollView 的 API 与 NestedScrollView 高度兼容</span>
<span class="hljs-keyword">val</span> scrollView = dialog.findViewById&lt;ScrollView&gt;(R.id.scroll_view)
<span class="hljs-comment">// 大部分情况下不需要修改其他代码</span>
</code></pre>
<p><strong>适用场景</strong>:</p>
<ul>
<li>内容较简单,不需要与其他滑动组件协同</li>
<li>不需要 CoordinatorLayout 等高级功能</li>
</ul>
<p><strong>权衡</strong>:</p>
<ul>
<li>✅ 彻底解决:不再有VelocityTracker的性能隐患</li>
<li>✅ 更简单:ScrollView 的代码路径更短,更稳定</li>
<li>⚠️ 需测试:确保不影响其他嵌套滑动功能</li>
</ul>
<h3 data-id="heading-12">方案3:自定义SafeNestedScrollView(防御性编程,2小时开发)</h3>
<p><strong>优先级</strong>: ⭐⭐⭐
<strong>实施难度</strong>: ★★★☆☆
<strong>预期效果</strong>: 拦截异常,防止ANR,并记录日志</p>
<p>创建一个带保护机制的自定义 <code>NestedScrollView</code>:</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">package</span> com.android.settings.widget

<span class="hljs-keyword">import</span> android.content.Context
<span class="hljs-keyword">import</span> android.util.AttributeSet
<span class="hljs-keyword">import</span> android.util.Log
<span class="hljs-keyword">import</span> android.view.MotionEvent
<span class="hljs-keyword">import</span> androidx.core.widget.NestedScrollView

<span class="hljs-comment">/**
 * 安全的NestedScrollView,防止VelocityTracker计算导致ANR
 */</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">SafeNestedScrollView</span> <span class="hljs-meta">@JvmOverloads</span> <span class="hljs-keyword">constructor</span>(
    context: Context,
    attrs: AttributeSet? = <span class="hljs-literal">null</span>,
    defStyleAttr: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span>
) : NestedScrollView(context, attrs, defStyleAttr) {

    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> {
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> TAG = <span class="hljs-string">"SafeNestedScrollView"</span>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> MAX_TOUCH_EVENTS_PER_100MS = <span class="hljs-number">100</span>  <span class="hljs-comment">// 异常阈值</span>
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> lastTouchTime = <span class="hljs-number">0L</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> touchEventCount = <span class="hljs-number">0</span>

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onTouchEvent</span><span class="hljs-params">(ev: <span class="hljs-type">MotionEvent</span>)</span></span>: <span class="hljs-built_in">Boolean</span> {
        <span class="hljs-keyword">when</span> (ev.action) {
            MotionEvent.ACTION_DOWN -&gt; {
                lastTouchTime = System.currentTimeMillis()
                touchEventCount = <span class="hljs-number">0</span>
            }

            MotionEvent.ACTION_MOVE -&gt; {
                touchEventCount++

                <span class="hljs-comment">// 检测异常:短时间内大量MOVE事件</span>
                <span class="hljs-keyword">val</span> currentTime = System.currentTimeMillis()
                <span class="hljs-keyword">val</span> duration = currentTime - lastTouchTime

                <span class="hljs-keyword">if</span> (duration <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.99</span> &amp;&amp; touchEventCount &gt; MAX_TOUCH_EVENTS_PER_100MS) {
                    Log.w(TAG, <span class="hljs-string">"检测到异常触摸事件流: <span class="hljs-variable">$touchEventCount</span> 个事件在 <span class="hljs-subst">${duration}</span>ms 内"</span>)
                    <span class="hljs-comment">// 清理触摸状态,防止VelocityTracker积累过多数据</span>
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
                }
            }

            MotionEvent.ACTION_UP, MotionEvent.ACTION_CANCEL -&gt; {
                <span class="hljs-keyword">try</span> {
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.onTouchEvent(ev)
                } <span class="hljs-keyword">catch</span> (e: Exception) {
                    Log.e(TAG, <span class="hljs-string">"触摸事件处理异常"</span>, e)
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
                }
            }
        }

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">super</span>.onTouchEvent(ev)
        } <span class="hljs-keyword">catch</span> (e: Exception) {
            Log.e(TAG, <span class="hljs-string">"触摸事件处理异常"</span>, e)
            <span class="hljs-literal">true</span>
        }
    }

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fling</span><span class="hljs-params">(velocityY: <span class="hljs-type">Int</span>)</span></span> {
        <span class="hljs-comment">// 限制fling速度,防止过大值导致计算问题</span>
        <span class="hljs-keyword">val</span> limitedVelocity = velocityY.coerceIn(-<span class="hljs-number">5000</span>, <span class="hljs-number">5000</span>)
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">super</span>.fling(limitedVelocity)
        } <span class="hljs-keyword">catch</span> (e: Exception) {
            Log.e(TAG, <span class="hljs-string">"Fling执行异常"</span>, e)
        }
    }
}
</code></pre>
<p>在布局中使用:</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">com.android.settings.widget.SafeNestedScrollView</span>
    <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/nested_scroll_view"</span>
    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span>
    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"match_parent"</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- 内容 --&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">com.android.settings.widget.SafeNestedScrollView</span>&gt;</span>
</code></pre>
<p><strong>核心思想</strong>:</p>
<ol>
<li><strong>异常检测</strong>: 监控触摸事件的频率,识别异常模式</li>
<li><strong>提前中断</strong>: 检测到异常时立即中断,不让问题传递到VelocityTracker</li>
<li><strong>异常捕获</strong>: Try-catch包裹关键调用,防止崩溃</li>
<li><strong>速度限制</strong>: 限制fling速度,避免极端值</li>
<li><strong>日志记录</strong>: 记录异常情况,便于后续分析</li>
</ol>
<p><strong>权衡</strong>:</p>
<ul>
<li>✅ 防御性强:多重保护机制</li>
<li>✅ 可观测性:日志记录便于排查</li>
<li>✅ 向后兼容:不影响正常使用场景</li>
<li>⚠️ 开发成本:需要编写和测试自定义View</li>
</ul>
<h3 data-id="heading-13">方案4:系统层优化(长期方案,需跨团队协作)</h3>
<p><strong>优先级</strong>: ⭐⭐
<strong>实施难度</strong>: ★★★★★
<strong>适用场景</strong>: 如果是系统ROM或硬件问题</p>
<p>这个方案需要与硬件团队和系统团队协作:</p>
<ol>
<li>
<p><strong>检查触摸屏驱动</strong>: 确认触摸事件的采样率是否正常,是否存在驱动Bug</p>
</li>
<li>
<p><strong>优化系统库</strong>: 考虑使用Google原生的 <code>libinput.so</code>,或在x86_64架构上优化性能</p>
</li>
<li>
<p><strong>添加超时保护</strong>: 为VelocityTracker的native实现添加超时机制</p>
</li>
</ol>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 使用systrace监控触摸事件</span>
systrace.py -t 10 -o trace.html input view

<span class="hljs-comment"># 分析触摸事件的采样频率和处理时间</span>
</code></pre>
<p><strong>这是我的经验</strong>:这类系统级问题往往牵涉多个团队,周期长,不确定性大。除非你有明确证据表明是系统问题,否则优先选择应用层方案。</p>
<h2 data-id="heading-14">解决方案对比</h2>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/47a847b516bb4299a6d80270e109ad39~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Yas5aWHTGFi:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768012488&amp;x-signature=JWKNza9jTv2%2BYyVVgXUWNKP6gOY%3D" alt="case4-solutions-comparison.png" loading="lazy"/></p>
<p><em>图2: 四种解决方案的优缺点对比</em></p>













































<table><thead><tr><th align="left">方案</th><th align="center">修复时间</th><th align="center">难度</th><th align="center">风险</th><th align="center">效果</th><th align="left">推荐场景</th></tr></thead><tbody><tr><td align="left">方案1: 禁用速度追踪</td><td align="center">5分钟</td><td align="center">⭐</td><td align="center">低</td><td align="center">立即解决</td><td align="left">紧急修复,生产环境</td></tr><tr><td align="left">方案2: 替换为ScrollView</td><td align="center">1小时</td><td align="center">⭐⭐</td><td align="center">中</td><td align="center">根治</td><td align="left">不需要嵌套滑动</td></tr><tr><td align="left">方案3: SafeNestedScrollView</td><td align="center">2小时</td><td align="center">⭐⭐⭐</td><td align="center">低</td><td align="center">防御+监控</td><td align="left">需要嵌套滑动+防御</td></tr><tr><td align="left">方案4: 系统层优化</td><td align="center">数周</td><td align="center">⭐⭐⭐⭐⭐</td><td align="center">高</td><td align="center">彻底根治</td><td align="left">系统定制ROM</td></tr></tbody></table>
<p><strong>我的建议</strong>:</p>
<ul>
<li><strong>生产环境紧急修复</strong>: 方案1(禁用) + 方案2(替换)组合拳</li>
<li><strong>长期架构优化</strong>: 方案3(自定义View) + 代码规范建立</li>
<li><strong>车载系统定制</strong>: 方案4(系统优化) + 应用层防御</li>
</ul>
<h2 data-id="heading-15">验证与测试:修复之后的功课</h2>
<p>修复只是第一步,验证才是关键。以下是我的测试清单:</p>
<h3 data-id="heading-16">功能测试</h3>
<pre><code class="hljs language-markdown" lang="markdown">测试步骤:
<span class="hljs-bullet">1.</span> 进入设置应用
<span class="hljs-bullet">2.</span> 点击车灯 → 环境灯
<span class="hljs-bullet">3.</span> 反复点击日间行车灯下面的文字(至少20次)
<span class="hljs-bullet">4.</span> 观察是否再次出现ANR
<span class="hljs-bullet">5.</span> 测试其他设置页面的滑动功能
</code></pre>
<h3 data-id="heading-17">性能测试</h3>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 1. 监控主线程性能</span>
adb shell am profile start com.android.settings /data/local/tmp/profile.trace
<span class="hljs-comment"># 执行测试操作</span>
adb shell am profile stop com.android.settings

<span class="hljs-comment"># 2. 实时查看日志</span>
adb logcat -s SafeNestedScrollView:* AndroidRuntime:E

<span class="hljs-comment"># 3. 检查是否有新的ANR</span>
adb shell <span class="hljs-built_in">ls</span> -lt /data/anr/
</code></pre>
<h3 data-id="heading-18">关键指标</h3>



































<table><thead><tr><th align="left">指标</th><th align="center">修复前</th><th align="center">目标值</th><th align="left">测量方法</th></tr></thead><tbody><tr><td align="left">触摸响应时间</td><td align="center">大于5000ms</td><td align="center">小于100ms</td><td align="left">Systrace</td></tr><tr><td align="left">主线程最大阻塞</td><td align="center">7520ms</td><td align="center">小于200ms</td><td align="left">StrictMode</td></tr><tr><td align="left">ANR发生率</td><td align="center">100%(必现)</td><td align="center">0%</td><td align="left">线上监控</td></tr><tr><td align="left">Fling流畅度</td><td align="center">N/A</td><td align="center">≥55fps</td><td align="left">FrameMetrics</td></tr></tbody></table>
<h3 data-id="heading-19">回归测试清单</h3>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="disabled"/> 其他设置页面的滑动正常</li>
<li class="task-list-item"><input type="checkbox" disabled="disabled"/> Dialog的显示和关闭正常</li>
<li class="task-list-item"><input type="checkbox" disabled="disabled"/> 其他使用NestedScrollView的页面正常</li>
<li class="task-list-item"><input type="checkbox" disabled="disabled"/> 应用启动速度无明显下降</li>
<li class="task-list-item"><input type="checkbox" disabled="disabled"/> 内存占用无明显增长</li>
</ul>
<h2 data-id="heading-20">预防措施:授人以鱼不如授人以渔</h2>
<p>经历了这次"惊心动魄"的排查,我总结了一些预防措施,希望能帮助你避免类似的坑。</p>
<h3 data-id="heading-21">编码规范</h3>
<h4 data-id="heading-22">❌ 反面教材:主线程隐式计算</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// ❌ 错误:依赖系统组件的隐式计算</span>
nestedScrollView.fling(velocity)  <span class="hljs-comment">// 内部会触发VelocityTracker计算</span>
</code></pre>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// ✅ 正确:主动控制,避免隐式耗时操作</span>
nestedScrollView.smoothScrollTo(x, y, <span class="hljs-number">300</span>)  <span class="hljs-comment">// 明确的滚动行为</span>
</code></pre>
<h4 data-id="heading-23">❌ 反面教材:过度嵌套</h4>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-comment">&lt;!-- ❌ 错误:不必要的嵌套滑动 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">NestedScrollView</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">NestedScrollView</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">RecyclerView</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">NestedScrollView</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">NestedScrollView</span>&gt;</span>
</code></pre>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-comment">&lt;!-- ✅ 正确:使用CoordinatorLayout --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">androidx.coordinatorlayout.widget.CoordinatorLayout</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">com.google.android.material.appbar.AppBarLayout</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">Toolbar</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">com.google.android.material.appbar.AppBarLayout</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">RecyclerView</span>
        <span class="hljs-attr">app:layout_behavior</span>=<span class="hljs-string">"@string/appbar_scrolling_view_behavior"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">androidx.coordinatorlayout.widget.CoordinatorLayout</span>&gt;</span>
</code></pre>
<h3 data-id="heading-24">性能监控方案</h3>
<h4 data-id="heading-25">方案A: Firebase Performance Monitoring</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">val</span> trace = Firebase.performance.newTrace(<span class="hljs-string">"settings_light_dialog_touch"</span>)
trace.start()

<span class="hljs-keyword">try</span> {
    showLightSettingsDialog()
} <span class="hljs-keyword">finally</span> {
    trace.stop()
}
</code></pre>
<h4 data-id="heading-26">方案B: 自定义ANR守卫</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AnrWatchdog</span> : <span class="hljs-type">Thread</span>(<span class="hljs-string">"AnrWatchdog"</span>) {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> handler = Handler(Looper.getMainLooper())
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> checkInterval = <span class="hljs-number">5000L</span>  <span class="hljs-comment">// 5秒检查一次</span>

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">while</span> (!isInterrupted) {
            <span class="hljs-keyword">val</span> blockDetected = AtomicBoolean(<span class="hljs-literal">false</span>)

            handler.post {
                blockDetected.<span class="hljs-keyword">set</span>(<span class="hljs-literal">true</span>)
            }

            sleep(checkInterval)

            <span class="hljs-keyword">if</span> (!blockDetected.<span class="hljs-keyword">get</span>()) {
                <span class="hljs-comment">// 主线程阻塞超过5秒</span>
                reportAnr(Thread.getAllStackTraces())
            }
        }
    }

    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">reportAnr</span><span class="hljs-params">(stackTraces: <span class="hljs-type">Map</span>&lt;<span class="hljs-type">Thread</span>, Array&lt;StackTraceElement&gt;&gt;)</span></span> {
        <span class="hljs-comment">// 上报到监控平台</span>
        Log.e(<span class="hljs-string">"AnrWatchdog"</span>, <span class="hljs-string">"检测到ANR"</span>, Exception().apply {
            stackTrace = stackTraces[Looper.getMainLooper().thread] ?: emptyArray()
        })
    }
}

<span class="hljs-comment">// 在Application中启动</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyApplication</span> : <span class="hljs-type">Application</span>() {
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">super</span>.onCreate()
        AnrWatchdog().start()
    }
}
</code></pre>
<h3 data-id="heading-27">Code Review检查点</h3>
<p>在代码审查时,重点关注以下几点:</p>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="disabled"/> 所有UI线程操作是否耗时小于16ms?(一帧时间)</li>
<li class="task-list-item"><input type="checkbox" disabled="disabled"/> 是否使用了StrictMode检测主线程违规?</li>
<li class="task-list-item"><input type="checkbox" disabled="disabled"/> 复杂视图是否做了性能测试?</li>
<li class="task-list-item"><input type="checkbox" disabled="disabled"/> 触摸事件处理是否有超时保护?</li>
<li class="task-list-item"><input type="checkbox" disabled="disabled"/> 是否有必要的try-catch保护?</li>
</ul>
<h3 data-id="heading-28">团队流程优化</h3>
<ol>
<li><strong>性能测试自动化</strong></li>
</ol>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 在CI/CD中集成性能测试</span>
./gradlew connectedAndroidTest \
  -Pandroid.testInstrumentationRunnerArguments.class=\
  com.android.settings.PerformanceTest
</code></pre>
<ol start="2">
<li>
<p><strong>ANR监控告警</strong></p>
<ul>
<li>集成Bugly、Sentry等APM工具</li>
<li>配置ANR率告警阈值:&gt;0.1%立即告警</li>
<li>每周Review ANR数据,优先修复高频问题</li>
</ul>
</li>
<li>
<p><strong>性能卡点记录</strong></p>
<ul>
<li>建立"性能陷阱"文档,记录团队踩过的坑</li>
<li>在新人培训中分享性能优化案例</li>
<li>定期组织性能优化技术分享</li>
</ul>
</li>
</ol>
<h2 data-id="heading-29">经验教训:我踩过的坑</h2>
<p>这次排查让我深刻体会到几点:</p>
<h3 data-id="heading-30">1. 永远不要对系统API的性能做假设</h3>
<p>我原以为 <code>computeCurrentVelocity()</code> 这种系统API应该是高度优化的,不会有性能问题。<strong>错了!</strong> 在异常数据面前,任何算法都可能退化。</p>
<h3 data-id="heading-31">2. ANR不一定是你写的代码问题</h3>
<p>这次ANR的直接原因是系统触摸屏驱动产生的异常数据,但最终暴露在应用层。这提醒我们:应用开发要有防御性思维,不能假设系统永远正常。</p>
<h3 data-id="heading-32">3. 日志是排查问题的第一生产力</h3>
<p>幸亏Android提供了详细的ANR trace,让我能快速定位到 <code>VelocityTracker</code>。如果没有这些日志,可能要花好几天时间盲猜。</p>
<h3 data-id="heading-33">4. 快速止血比追求完美更重要</h3>
<p>面对生产环境的紧急Bug,方案1(禁用速度追踪)虽然不完美,但5分钟就能止血。先让用户能用起来,再慢慢优化,这才是务实的工程态度。</p>
<h3 data-id="heading-34">5. 文档和复盘同样重要</h3>
<p>写这篇文章的过程,也是对问题的再思考。把排查过程记录下来,不仅能帮助团队其他成员避坑,也能在下次遇到类似问题时快速回忆起解决思路。</p>
<h2 data-id="heading-35">相关文章</h2>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fhome.wonlab.top%2Fblog%2Fandroid_stability_performance%2Fandroid-stability-perf-series-readme" target="_blank" title="https://home.wonlab.top/blog/android_stability_performance/android-stability-perf-series-readme" ref="nofollow noopener noreferrer">Android稳定性&amp;性能深入理解专栏介绍</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fhome.wonlab.top%2Fblog%2Fandroid_stability_performance%2Fcase1-android-ivi-lag-case-analysis-binder-consumed" target="_blank" title="https://home.wonlab.top/blog/android_stability_performance/case1-android-ivi-lag-case-analysis-binder-consumed" ref="nofollow noopener noreferrer">Android车机卡顿案例剖析:从Binder耗尽到单例缺失的深度排查</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fhome.wonlab.top%2Fblog%2Fandroid_stability_performance%2Fcase2-anr-audioserver-deadlock-system-failure" target="_blank" title="https://home.wonlab.top/blog/android_stability_performance/case2-anr-audioserver-deadlock-system-failure" ref="nofollow noopener noreferrer">ANR实战分析：一次audioserver死锁引发的系统级故障排查</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fhome.wonlab.top%2Fblog%2Fandroid_stability_performance%2Fcase3-android-black-screen-analysis" target="_blank" title="https://home.wonlab.top/blog/android_stability_performance/case3-android-black-screen-analysis" ref="nofollow noopener noreferrer">一次 Android 车机黑屏问题的深度剖析：当显示驱动遇上中断风暴</a></li>
</ul>
<hr/>
<p><em>如果你也遇到过类似的诡异问题,欢迎在评论区分享!有任何疑问也可以随时留言讨论。</em></p>
<p><em>本文基于真实案例改编,部分敏感信息已脱敏处理。</em></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[并行不等于更快：CompletableFuture 让你更慢的 5 个姿势]]></title>    <link>https://juejin.cn/post/7589893746081169449</link>    <guid>https://juejin.cn/post/7589893746081169449</guid>    <pubDate>2026-01-02T01:37:52.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7589893746081169449" data-draft-id="7590054976488882216" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="并行不等于更快：CompletableFuture 让你更慢的 5 个姿势"/> <meta itemprop="keywords" content="后端,性能优化,Java"/> <meta itemprop="datePublished" content="2026-01-02T01:37:52.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="一只叫煤球的猫"/> <meta itemprop="url" content="https://juejin.cn/user/1732486058745054"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            并行不等于更快：CompletableFuture 让你更慢的 5 个姿势
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1732486058745054/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    一只叫煤球的猫
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-02T01:37:52.000Z" title="Fri Jan 02 2026 01:37:52 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-02
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读10分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">前言</h2>
<p>上周的某一天，运维同学找到我说生产环境的订单处理接口响应时间突然飙到了 3 秒。</p>
<p>我先让后端同学和运维一起查监控，CPU 使用率倒是不高，线程池的活跃线程数却涨到了 500 多。</p>
<p>再看了眼最近上线的代码，里面一段原本串行的代码，改成了 <code>CompletableFuture</code> 并行处理，本意肯定是想快一点，结果反而变慢了。</p>
<p>这也不是个例。</p>
<p>很多时候我们拿到一段串行代码，第一反应就是看能不能改成并行，觉得多线程跑起来肯定快。</p>
<p>但个别情况下，改完之后不仅不会变快，可能还会比原来还慢。</p>
<p>问题出在哪里？线程池不够大吗？还是机器配置太低吗？其实不然。</p>
<p>真正的原因，可能还是我们使用 CompletableFuture 的姿势不正确。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cf49d84b171e481eba7dd320657d9007~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiA5Y-q5Y-r54Wk55CD55qE54yr:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767922671&amp;x-signature=cBPTmOh3ZRTwNMsyNdvL4r%2FQB4E%3D" alt="fullmetal alchemist ed GIF.gif" loading="lazy"/></p>
<h2 data-id="heading-1">任务拆的太碎：上下文切换吃掉了所有收益</h2>
<p>假设你要处理 1000 个订单号，每个订单号需要调用一个方法做校验，单次调用耗时 0.1 毫秒。串行处理总共需要 100 毫秒。你觉得用 CompletableFuture 并行处理，开 10 个线程应该能快 10 倍吧？</p>
<p>让我们写个测试：</p>
<pre><code class="hljs language-ini" lang="ini">// 串行处理
long <span class="hljs-attr">start</span> = System.nanoTime()<span class="hljs-comment">;</span>
for (String orderId : orderIds) {
    validateOrder(orderId)<span class="hljs-comment">;</span>
}
long <span class="hljs-attr">serialTime</span> = System.nanoTime() - start<span class="hljs-comment">;</span>

// 并行处理
ExecutorService <span class="hljs-attr">executor</span> = Executors.newFixedThreadPool(<span class="hljs-number">10</span>)<span class="hljs-comment">;</span>
<span class="hljs-attr">start</span> = System.nanoTime()<span class="hljs-comment">;</span>
List&lt;CompletableFuture&lt;Void&gt;&gt; <span class="hljs-attr">futures</span> = orderIds.stream()
    .map(orderId -&gt; CompletableFuture.runAsync(
        () -&gt; validateOrder(orderId), executor))
    .collect(Collectors.toList())<span class="hljs-comment">;</span>
CompletableFuture.allOf(futures.toArray(new CompletableFuture<span class="hljs-section">[0]</span>)).join()<span class="hljs-comment">;</span>
long <span class="hljs-attr">parallelTime</span> = System.nanoTime() - start<span class="hljs-comment">;</span>
</code></pre>
<p>结果串行用了 98 毫秒，并行用了 145 毫秒。</p>
<p>为什么会这样？</p>
<p>每提交一个 CompletableFuture，系统都要做一次任务调度，涉及线程唤醒、上下文切换、CPU 缓存失效。这些开销加起来可能就要几微秒。当单个任务本身只需要 0.1 毫秒时，调度开销占比就很高了。1000 个任务就是 1000 次调度，累积起来的开销超过了并行带来的收益。</p>
<p>更稳妥的做法是把粒度收粗，让每个任务足够大，至少覆盖调度成本。</p>
<p>我们改成每 100 个订单号作为一批，提交一个 CompletableFuture：</p>
<pre><code class="hljs language-ini" lang="ini">List&lt;CompletableFuture&lt;Void&gt;&gt; <span class="hljs-attr">futures</span> = new ArrayList&lt;&gt;()<span class="hljs-comment">;</span>
for (int <span class="hljs-attr">i</span> = <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; orderIds.size(); i += 100) {</span>
    List&lt;String&gt; <span class="hljs-attr">batch</span> = orderIds.subList(i, 
        Math.min(i + 100, orderIds.size()))<span class="hljs-comment">;</span>
    futures.add(CompletableFuture.runAsync(() -&gt; {
        for (String orderId : batch) {
            validateOrder(orderId)<span class="hljs-comment">;</span>
        }
    }, executor))<span class="hljs-comment">;</span>
}
CompletableFuture.allOf(futures.toArray(new CompletableFuture<span class="hljs-section">[0]</span>)).join()<span class="hljs-comment">;</span>
</code></pre>
<p>这次只用了 12 毫秒。调度次数从 1000 次降到了 10 次，上下文切换的开销大幅减少，并行的优势才真正体现出来。</p>
<p>这其实就是最常见的策略——分批处理或分片处理。</p>
<p>当然还有一点经验主义，单个任务的执行时间至少要在 1 毫秒以上，并行才有意义。如果任务本身很轻量，就应该打包成批次再提交。</p>
<h2 data-id="heading-2">共享资源：所有线程挤在同一扇门前</h2>
<p>并行处理时，如果多个线程需要访问同一个资源，这个资源就会成为瓶颈。最常见的就是<strong>数据库连接池</strong>。</p>
<p>比方说用 CompletableFuture 并行查询用户信息，每个 future 都要从连接池拿一个数据库连接。连接池配置了 20 个连接，但同时提交了 100 个 CompletableFuture。</p>
<p>结果就是 80 个线程在等待连接释放，白白浪费时间。</p>
<pre><code class="hljs language-ini" lang="ini">// 连接池只有 20 个连接
HikariConfig <span class="hljs-attr">config</span> = new HikariConfig()<span class="hljs-comment">;</span>
config.setMaximumPoolSize(20)<span class="hljs-comment">;</span>
DataSource <span class="hljs-attr">dataSource</span> = new HikariDataSource(config)<span class="hljs-comment">;</span>

// 同时发起 100 个查询
ExecutorService <span class="hljs-attr">executor</span> = Executors.newFixedThreadPool(<span class="hljs-number">100</span>)<span class="hljs-comment">;</span>
List&lt;CompletableFuture&lt;User&gt;&gt; <span class="hljs-attr">futures</span> = userIds.stream()
    .map(userId -&gt; CompletableFuture.supplyAsync(() -&gt; {
        try (Connection <span class="hljs-attr">conn</span> = dataSource.getConnection()) {
            return queryUser(conn, userId)<span class="hljs-comment">;</span>
        }
    }, executor))
    .collect(Collectors.toList())<span class="hljs-comment">;</span>
</code></pre>
<p>监控显示，平均每个查询耗时从串行时的 5 毫秒涨到了 50 毫秒。大部分时间都花在了等待连接上。</p>
<p>除了数据库连接池，还有很多这种典型的场景案例：</p>
<ul>
<li>锁与同步块</li>
<li>数据库连接池、Redis 连接池</li>
<li>HTTP 客户端连接池</li>
<li>限流器、熔断器</li>
<li>单线程日志 append、单队列缓冲</li>
</ul>
<p>一般来讲，这种问题的应对思路通常是：</p>
<ul>
<li>把共享区缩小，把锁粒度压缩到必要范围</li>
<li>让并发度受资源容量约束，别超过连接池和下游的可承受并发</li>
<li>对 I/O 做隔离池，避免同一个池里既跑 CPU 又跑阻塞 I/O</li>
</ul>
<p>最简单的方式就是把线程池改成 20，当然还有另一个朴素但有效的手段，是用信号量把并发度卡在资源容量之内：</p>
<pre><code class="hljs language-ini" lang="ini">Semaphore <span class="hljs-attr">semaphore</span> = new Semaphore(<span class="hljs-number">20</span>)<span class="hljs-comment">; // 不要超过连接池或下游并发上限</span>
List&lt;CompletableFuture&lt;User&gt;&gt; <span class="hljs-attr">futures</span> = userIds.stream()
    .map(userId -&gt; CompletableFuture.supplyAsync(() -&gt; {
        try {
            semaphore.acquire()<span class="hljs-comment">;</span>
            try (Connection <span class="hljs-attr">conn</span> = dataSource.getConnection()) {
                return queryUser(conn, userId)<span class="hljs-comment">;</span>
            }
        } finally {
            semaphore.release()<span class="hljs-comment">;</span>
        }
    }, executor))
    .collect(Collectors.toList())<span class="hljs-comment">;</span>
</code></pre>
<p>如果你的任务需要获取这些资源，并发度就不能设得太高，否则大量线程会阻塞在资源竞争上。</p>
<h2 data-id="heading-3">内存爆炸：一口气提交十万个 Future</h2>
<p>有个定时任务需要处理数据库里的所有待处理订单，数量大概十几万。后端同学写了这样的代码：</p>
<pre><code class="hljs language-ini" lang="ini">List&lt;Order&gt; <span class="hljs-attr">orders</span> = orderRepository.findAllPending()<span class="hljs-comment">; // 10 万条</span>
ExecutorService <span class="hljs-attr">executor</span> = Executors.newFixedThreadPool(<span class="hljs-number">50</span>)<span class="hljs-comment">;</span>

List&lt;CompletableFuture&lt;Void&gt;&gt; <span class="hljs-attr">futures</span> = orders.stream()
    .map(order -&gt; CompletableFuture.runAsync(
        () -&gt; processOrder(order), executor))
    .collect(Collectors.toList())<span class="hljs-comment">;</span>

CompletableFuture.allOf(futures.toArray(new CompletableFuture<span class="hljs-section">[0]</span>)).join()<span class="hljs-comment">;</span>
</code></pre>
<p>这段代码在测试环境跑得好好的，因为测试数据只有几百条。上了生产之后（草台班子没有做好代码审查 😭），JVM 直接 OOM 了。</p>
<p>问题在于这行代码：</p>
<pre><code class="hljs language-ini" lang="ini">.collect(Collectors.toList())<span class="hljs-comment">;</span>
</code></pre>
<p>它会一口气创建 10 万个 CompletableFuture 对象，每个对象占用几百字节到上千字节不等。还没开始处理，光是这些 Future 对象就占用了几百 MB 内存。加上线程池队列里堆积的任务对象，内存很快就撑不住了。</p>
<p>正确的做法是分批处理：</p>
<pre><code class="hljs language-ini" lang="ini">List&lt;Order&gt; <span class="hljs-attr">orders</span> = orderRepository.findAllPending()<span class="hljs-comment">;</span>
ExecutorService <span class="hljs-attr">executor</span> = Executors.newFixedThreadPool(<span class="hljs-number">50</span>)<span class="hljs-comment">;</span>

int <span class="hljs-attr">batchSize</span> = <span class="hljs-number">1000</span><span class="hljs-comment">;</span>
for (int <span class="hljs-attr">i</span> = <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; orders.size(); i += batchSize) {</span>
    List&lt;Order&gt; <span class="hljs-attr">batch</span> = orders.subList(i, 
        Math.min(i + batchSize, orders.size()))<span class="hljs-comment">;</span>
    
    List&lt;CompletableFuture&lt;Void&gt;&gt; <span class="hljs-attr">futures</span> = batch.stream()
        .map(order -&gt; CompletableFuture.runAsync(
            () -&gt; processOrder(order), executor))
        .collect(Collectors.toList())<span class="hljs-comment">;</span>
    
    CompletableFuture.allOf(futures.toArray(new CompletableFuture<span class="hljs-section">[0]</span>)).join()<span class="hljs-comment">;</span>
}
</code></pre>
<p>每次只创建 1000 个 Future，处理完一批再处理下一批。内存占用稳定在可控范围内。</p>
<p>这个问题的本质是缺少背压机制。</p>
<p>生产者一股脑地提交任务，完全不管消费者的处理能力。当任务提交速度远大于处理速度时，未处理的任务就会在内存里堆积，最终导致 OOM。</p>
<h2 data-id="heading-4">线程池配置：不是越大越好</h2>
<p>遇到性能问题时，很多人的第一反应是加大线程池。原来是 50，改成 100，还是慢就改成 200。结果往往是线程越多越慢。</p>
<p>以前做过一个实验，用不同大小的线程池处理同一批 IO 密集型任务。每个任务需要调用一个外部 HTTP 接口，平均耗时 200 毫秒。一共 1000 个任务。</p>



































<table><thead><tr><th>线程数</th><th>总耗时(秒)</th><th>CPU 使用率</th></tr></thead><tbody><tr><td>10</td><td>20.5</td><td>15%</td></tr><tr><td>50</td><td>4.2</td><td>45%</td></tr><tr><td>100</td><td>2.8</td><td>68%</td></tr><tr><td>200</td><td>3.1</td><td>82%</td></tr><tr><td>500</td><td>4.8</td><td>91%</td></tr></tbody></table>
<p>可以看到，线程数从 10 增加到 100 时，性能持续提升。但超过 100 之后，性能反而下降了。这是因为线程数太多会带来几个问题：</p>
<p>线程本身要占用内存，每个线程的栈空间默认是 1MB。500 个线程就是 500MB。</p>
<p>线程越多，操作系统的调度开销越大。CPU 要在不同线程之间频繁切换，每次切换都要保存和恢复上下文。</p>
<p>对于 IO 密集型任务，经验公式是 <code>线程数等于 CPU 核心数乘以 (1 + IO 时间 / CPU 时间)</code>。</p>
<p>假设 IO 时间是 200 毫秒，CPU 时间是 1 毫秒，那么 8 核机器的理想线程数是 <code> 8 * (1 + 200/1) = 1608</code> 。</p>
<p>但这只是理论值，实际上很少需要这么多线程。</p>
<p>更实用的做法是从一个合理的初始值开始，比如 CPU 核心数的 2 到 4 倍，然后通过压测逐步调整，观察 CPU 使用率、响应时间和吞吐量，找到最佳的平衡点。</p>
<p>另一个常见错误是混用线程池。有的代码里创建了多个 ExecutorService，每个地方都用 newFixedThreadPool(50)。</p>
<p>实际运行时可能有 5 个这样的线程池，总共 250 个线程在跑。每个线程池单独看都不大，合在一起就超负荷了。</p>
<p>最好是在应用启动时创建一个全局的线程池，所有 CompletableFuture 共用这一个。</p>
<p>如果确实需要隔离，也应该仔细规划各个线程池的大小，确保总数可控。</p>
<h2 data-id="heading-5">异常处理：一个任务挂了，其他任务也白跑</h2>
<p>CompletableFuture 有个特点，如果其中一个任务抛出异常，调用 allOf().join() 时会立即抛出异常，但其他任务不会停止，它们会继续在后台执行完。</p>
<pre><code class="hljs language-scss" lang="scss">List&lt;CompletableFuture&lt;Void&gt;&gt; futures = Arrays<span class="hljs-selector-class">.asList</span>(
    CompletableFuture.runAsync(() -&gt; <span class="hljs-built_in">task1</span>()),
    CompletableFuture<span class="hljs-selector-class">.runAsync</span>(() -&gt; { throw new <span class="hljs-built_in">RuntimeException</span>(); }),
    CompletableFuture<span class="hljs-selector-class">.runAsync</span>(() -&gt; <span class="hljs-built_in">task3</span>())
);

try {
    CompletableFuture<span class="hljs-selector-class">.allOf</span>(futures.toArray(new CompletableFuture[<span class="hljs-number">0</span>]))<span class="hljs-selector-class">.join</span>();
} catch (Exception e) {
    <span class="hljs-comment">// 进入这里时，task1 和 task3 可能还在执行</span>
}
</code></pre>
<p>如果你的任务之间有依赖关系，这种行为会导致资源浪费。比如第一步查询订单失败了，后面的计算价格、更新库存都没有意义，但它们还在继续跑。</p>
<p>更糟糕的情况是，如果没有正确处理异常，有些任务可能会永远卡住。比如任务内部获取了锁但没有在 finally 里释放，抛出异常后锁就永远不会释放了。</p>
<p>建议每个任务都用 exceptionally 或 handle 方法捕获异常：</p>
<pre><code class="hljs language-less" lang="less"><span class="hljs-selector-tag">List</span>&lt;<span class="hljs-selector-tag">CompletableFuture</span>&lt;<span class="hljs-selector-tag">Result</span>&gt;&gt; <span class="hljs-selector-tag">futures</span> = <span class="hljs-selector-tag">tasks</span><span class="hljs-selector-class">.stream</span>()
    <span class="hljs-selector-class">.map</span>(task -&gt; CompletableFuture.<span class="hljs-built_in">supplyAsync</span>(() -&gt; task.<span class="hljs-built_in">execute</span>())
        .<span class="hljs-built_in">exceptionally</span>(ex -&gt; {
            log.<span class="hljs-built_in">error</span>(<span class="hljs-string">"Task failed"</span>, ex);
            return Result.<span class="hljs-built_in">failure</span>(ex);
        }))
    <span class="hljs-selector-class">.collect</span>(Collectors.<span class="hljs-built_in">toList</span>());

<span class="hljs-selector-tag">List</span>&lt;<span class="hljs-selector-tag">Result</span>&gt; <span class="hljs-selector-tag">results</span> = <span class="hljs-selector-tag">CompletableFuture</span><span class="hljs-selector-class">.allOf</span>(
    futures.<span class="hljs-built_in">toArray</span>(new CompletableFuture[<span class="hljs-number">0</span>]))
    <span class="hljs-selector-class">.thenApply</span>(v -&gt; futures.<span class="hljs-built_in">stream</span>()
        .<span class="hljs-built_in">map</span>(<span class="hljs-attribute">CompletableFuture</span>::join)
        .<span class="hljs-built_in">collect</span>(Collectors.<span class="hljs-built_in">toList</span>()))
    <span class="hljs-selector-class">.join</span>();
</code></pre>
<p>这样可以确保异常被正确记录，而且不会中断其他任务。最后收集结果时，可以检查每个 Result 是成功还是失败，做相应的处理。</p>
<h2 data-id="heading-6">性能测试：看清并发度曲线</h2>
<p>为了验证上面提到的几个问题，我们来做一组对比实验。任务场景是查询用户信息并计算积分，单次查询耗时约 10 毫秒。数据库连接池配置 20 个连接。</p>
<p>测试代码：</p>
<pre><code class="hljs language-ini" lang="ini">// 串行处理
long <span class="hljs-attr">start</span> = System.currentTimeMillis()<span class="hljs-comment">;</span>
for (int userId : userIds) {
    User <span class="hljs-attr">user</span> = queryUser(userId)<span class="hljs-comment">;</span>
    calculatePoints(user)<span class="hljs-comment">;</span>
}
long <span class="hljs-attr">serialTime</span> = System.currentTimeMillis() - start<span class="hljs-comment">;</span>

// 并行处理（不同并发度）
for (int concurrency : new int<span class="hljs-section">[]</span>{10, 20, 50, 100, 200}) {
    ExecutorService <span class="hljs-attr">executor</span> = Executors.newFixedThreadPool(concurrency)<span class="hljs-comment">;</span>
    Semaphore <span class="hljs-attr">semaphore</span> = new Semaphore(<span class="hljs-number">20</span>)<span class="hljs-comment">; // 限制数据库并发</span>
    
    <span class="hljs-attr">start</span> = System.currentTimeMillis()<span class="hljs-comment">;</span>
    List&lt;CompletableFuture&lt;Void&gt;&gt; <span class="hljs-attr">futures</span> = userIds.stream()
        .map(userId -&gt; CompletableFuture.runAsync(() -&gt; {
            try {
                semaphore.acquire()<span class="hljs-comment">;</span>
                User <span class="hljs-attr">user</span> = queryUser(userId)<span class="hljs-comment">;</span>
                calculatePoints(user)<span class="hljs-comment">;</span>
            } finally {
                semaphore.release()<span class="hljs-comment">;</span>
            }
        }, executor))
        .collect(Collectors.toList())<span class="hljs-comment">;</span>
    
    CompletableFuture.allOf(futures.toArray(new CompletableFuture<span class="hljs-section">[0]</span>)).join()<span class="hljs-comment">;</span>
    long <span class="hljs-attr">parallelTime</span> = System.currentTimeMillis() - start<span class="hljs-comment">;</span>
    
    System.out.printf("Concurrency: %d, Time: %dms, Speedup: %.2fx%n",
        concurrency, parallelTime, (double)serialTime / parallelTime)<span class="hljs-comment">;</span>
    
    executor.shutdown()<span class="hljs-comment">;</span>
}
</code></pre>
<p>测试结果（处理 1000 个用户）：</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">Serial:</span> <span class="hljs-string">10200ms</span>
<span class="hljs-attr">Concurrency:</span> <span class="hljs-number">10</span><span class="hljs-string">,</span> <span class="hljs-attr">Time:</span> <span class="hljs-string">1050ms,</span> <span class="hljs-attr">Speedup:</span> <span class="hljs-number">9.</span><span class="hljs-string">71x</span>
<span class="hljs-attr">Concurrency:</span> <span class="hljs-number">20</span><span class="hljs-string">,</span> <span class="hljs-attr">Time:</span> <span class="hljs-string">530ms,</span> <span class="hljs-attr">Speedup:</span> <span class="hljs-number">19.</span><span class="hljs-string">25x</span>
<span class="hljs-attr">Concurrency:</span> <span class="hljs-number">50</span><span class="hljs-string">,</span> <span class="hljs-attr">Time:</span> <span class="hljs-string">540ms,</span> <span class="hljs-attr">Speedup:</span> <span class="hljs-number">18.</span><span class="hljs-string">89x</span>
<span class="hljs-attr">Concurrency:</span> <span class="hljs-number">100</span><span class="hljs-string">,</span> <span class="hljs-attr">Time:</span> <span class="hljs-string">650ms,</span> <span class="hljs-attr">Speedup:</span> <span class="hljs-number">15.</span><span class="hljs-string">69x</span>
<span class="hljs-attr">Concurrency:</span> <span class="hljs-number">200</span><span class="hljs-string">,</span> <span class="hljs-attr">Time:</span> <span class="hljs-string">890ms,</span> <span class="hljs-attr">Speedup:</span> <span class="hljs-number">11.</span><span class="hljs-string">46x</span>
</code></pre>
<p>可以看到，并发度在 20 时达到最佳性能，这正好等于数据库连接池大小。再往上加，性能反而下降了。</p>
<p>我又去掉了信号量限制，让所有线程直接竞争连接池：</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">Concurrency:</span> <span class="hljs-number">50</span> <span class="hljs-string">(no</span> <span class="hljs-string">semaphore),</span> <span class="hljs-attr">Time:</span> <span class="hljs-string">1200ms</span>
<span class="hljs-attr">Concurrency:</span> <span class="hljs-number">100</span> <span class="hljs-string">(no</span> <span class="hljs-string">semaphore),</span> <span class="hljs-attr">Time:</span> <span class="hljs-string">1850ms</span>
</code></pre>
<p>性能显著变差，因为大量线程阻塞在等待连接上。</p>
<p>最后测试任务粒度的影响。把 1000 个任务打包成不同批次：</p>
<pre><code class="hljs language-perl" lang="perl"><span class="hljs-number">1000</span> tasks individually: <span class="hljs-number">2100</span>ms
<span class="hljs-number">100</span> batches (<span class="hljs-number">10</span> tasks <span class="hljs-keyword">each</span>): <span class="hljs-number">180</span>ms
<span class="hljs-number">10</span> batches (<span class="hljs-number">100</span> tasks <span class="hljs-keyword">each</span>): <span class="hljs-number">95</span>ms
<span class="hljs-number">1</span> batch (<span class="hljs-number">1000</span> tasks): <span class="hljs-number">10200</span>ms (serial)
</code></pre>
<p>批次大小在 50 到 100 之间时效果最好，既减少了调度开销，又保留了并行度。</p>
<h2 data-id="heading-7">写在最后</h2>
<p>开头的事故，后来怎么修复的？其实并不复杂：任务粒度收粗、I/O 和 CPU 分池、并发度按连接池容量卡住、批量提交加窗口、每个任务加超时与降级。</p>
<p>CompletableFuture 适合用在需要并发表达、需要组合与编排的场景。</p>
<p>吾日三省吾身。</p>
<p>使用CompletableFuture时，最好也先想清楚几个问题：单任务是否足够重、共享资源是否充足、下游是否能承受并发、队列是否有上界、失败和超时是否可控。</p>
<p>有了答案，再去落地。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[MyBatis类型处理模块详解]]></title>    <link>https://juejin.cn/post/7589908657682628658</link>    <guid>https://juejin.cn/post/7589908657682628658</guid>    <pubDate>2026-01-02T00:33:08.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7589908657682628658" data-draft-id="7589903499599429686" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="MyBatis类型处理模块详解"/> <meta itemprop="keywords" content="MyBatis,Java"/> <meta itemprop="datePublished" content="2026-01-02T00:33:08.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="雨中飘荡的记忆"/> <meta itemprop="url" content="https://juejin.cn/user/694547077666606"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            MyBatis类型处理模块详解
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/694547077666606/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    雨中飘荡的记忆
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-02T00:33:08.000Z" title="Fri Jan 02 2026 00:33:08 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-02
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    1
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">深入理解MyBatis类型转换机制，掌握Java与JDBC之间的桥梁</h2>
<h2 data-id="heading-1">一、MyBatis整体架构与类型处理模块</h2>
<p>在深入类型处理模块之前，我们先了解MyBatis的整体架构，以及类型处理模块在其中的重要地位。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/aa3fb0c4d5a7446ca23a602eccd2c6f6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuo5Lit6aOY6I2h55qE6K6w5b-G:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767918788&amp;x-signature=wtUr2ytFVsbv4eNXpEOp1UhkPnA%3D" alt="" loading="lazy"/></p>
<p>从架构图可以看出，MyBatis采用了分层架构设计，而类型处理模块（TypeHandler）位于基础支撑层，是连接Java类型与JDBC类型的桥梁。它负责在SQL执行过程中，将Java对象参数转换为JDBC能够识别的参数类型，以及将ResultSet中的数据转换为Java对象。</p>
<h2 data-id="heading-2">型处理模块的核心职责</h2>
<p>类型处理模块主要承担以下核心职责：</p>
<pre><code class="hljs language-sql" lang="sql">✅ Java类型与JDBC类型相互转换 <span class="hljs-operator">-</span> 实现双向类型转换
✅ 参数设置时的类型转换 <span class="hljs-operator">-</span> 将Java参数转换为JDBC参数
✅ 结果集获取时的类型转换 <span class="hljs-operator">-</span> 将JDBC结果转换为Java对象
✅ <span class="hljs-keyword">Null</span>值处理 <span class="hljs-operator">-</span> 处理Java空值与JDBC <span class="hljs-keyword">NULL</span>的转换
✅ 类型注册与管理 <span class="hljs-operator">-</span> 维护Java类型与TypeHandler的映射关系
</code></pre>
<h2 data-id="heading-3">为什么需要TypeHandler？</h2>
<p>在Java应用程序和数据库之间，存在着类型系统的差异：</p>



































<table><thead><tr><th>Java类型</th><th>JDBC类型</th><th>说明</th></tr></thead><tbody><tr><td>String</td><td>VARCHAR, CHAR</td><td>字符串类型</td></tr><tr><td>Integer</td><td>INTEGER</td><td>整数类型</td></tr><tr><td>Long</td><td>BIGINT</td><td>长整数类型</td></tr><tr><td>Date</td><td>TIMESTAMP</td><td>日期时间类型</td></tr><tr><td>BigDecimal</td><td>NUMERIC</td><td>精确数值类型</td></tr></tbody></table>
<p>TypeHandler的核心作用就是解决这些类型之间的映射和转换问题。</p>
<h2 data-id="heading-4">二、TypeHandler体系架构</h2>
<p>TypeHandler采用了泛型接口设计，支持各种类型的扩展。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3ad51ae683ef4acaa902418b69e1a75b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuo5Lit6aOY6I2h55qE6K6w5b-G:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767918788&amp;x-signature=SzXgf14IkE6foO9Sa0ZNOmOtSb8%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-5">TypeHandler接口</h2>
<p>TypeHandler是类型转换的核心接口，定义了类型转换的基本方法：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">TypeHandler</span>&lt;T&gt; {
    <span class="hljs-comment">// 设置PreparedStatement参数（Java → JDBC）</span>
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">setParameter</span><span class="hljs-params">(PreparedStatement ps, <span class="hljs-type">int</span> i, 
                     T parameter, JdbcType jdbcType)</span> 
                     <span class="hljs-keyword">throws</span> SQLException;

    <span class="hljs-comment">// 获取ResultSet结果（JDBC → Java，按列名）</span>
    T <span class="hljs-title function_">getResult</span><span class="hljs-params">(ResultSet rs, String columnName)</span> 
               <span class="hljs-keyword">throws</span> SQLException;

    <span class="hljs-comment">// 获取ResultSet结果（JDBC → Java，按列索引）</span>
    T <span class="hljs-title function_">getResult</span><span class="hljs-params">(ResultSet rs, <span class="hljs-type">int</span> columnIndex)</span> 
               <span class="hljs-keyword">throws</span> SQLException;

    <span class="hljs-comment">// 获取CallableStatement结果（存储过程）</span>
    T <span class="hljs-title function_">getResult</span><span class="hljs-params">(CallableStatement cs, <span class="hljs-type">int</span> columnIndex)</span> 
               <span class="hljs-keyword">throws</span> SQLException;
}
</code></pre>
<h2 data-id="heading-6">BaseTypeHandler抽象类</h2>
<p>为了简化TypeHandler的实现，MyBatis提供了BaseTypeHandler抽象类，它帮我们处理了Null值检查等通用逻辑：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseTypeHandler</span>&lt;T&gt; 
    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TypeHandler</span>&lt;T&gt; {

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setParameter</span><span class="hljs-params">(PreparedStatement ps, <span class="hljs-type">int</span> i, 
                            T parameter, JdbcType jdbcType)</span> 
                            <span class="hljs-keyword">throws</span> SQLException {
        <span class="hljs-keyword">if</span> (parameter == <span class="hljs-literal">null</span>) {
            <span class="hljs-comment">// 处理Null值</span>
            ps.setNull(i, jdbcType.TYPE_CODE);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// 设置非空参数，由子类实现</span>
            setNonNullParameter(ps, i, parameter, jdbcType);
        }
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getResult</span><span class="hljs-params">(ResultSet rs, String columnName)</span> 
                      <span class="hljs-keyword">throws</span> SQLException {
        <span class="hljs-type">T</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> getNullableResult(rs, columnName);
        <span class="hljs-comment">// 检查是否为null</span>
        <span class="hljs-keyword">return</span> rs.wasNull() ? <span class="hljs-literal">null</span> : result;
    }

    <span class="hljs-comment">// 抽象方法，由子类实现</span>
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNonNullParameter</span><span class="hljs-params">(
        PreparedStatement ps, <span class="hljs-type">int</span> i, 
        T parameter, JdbcType jdbcType)</span> 
        <span class="hljs-keyword">throws</span> SQLException;

    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> T <span class="hljs-title function_">getNullableResult</span><span class="hljs-params">(
        ResultSet rs, String columnName)</span> 
        <span class="hljs-keyword">throws</span> SQLException;
}
</code></pre>
<h2 data-id="heading-7">TypeHandler继承体系</h2>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/26bad2f4c5c04afb89f4562dafd21504~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuo5Lit6aOY6I2h55qE6K6w5b-G:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767918788&amp;x-signature=seTQVfs5hUvlRob5Vz3jihj5V5Q%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-8">三、类型转换双向流程</h2>
<p>TypeHandler实现了Java类型与JDBC类型之间的双向转换。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6f9997be96a74b76859dc8ce2cc2a2e5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuo5Lit6aOY6I2h55qE6K6w5b-G:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767918788&amp;x-signature=R66jf4fAEP4quOgUYQxhR1ryAzk%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-9">Java → JDBC 转换流程</h2>
<p>当执行SQL语句时，需要将Java参数转换为JDBC参数：</p>
<pre><code class="hljs language-ini" lang="ini">// 1. ParameterHandler获取参数值
Object <span class="hljs-attr">value</span> = getParameterValue(
    parameterObject, parameterMapping)<span class="hljs-comment">;</span>

// 2. 获取对应的TypeHandler
TypeHandler&lt;?&gt; <span class="hljs-attr">typeHandler</span> = 
    parameterMapping.getTypeHandler()<span class="hljs-comment">;</span>

// 3. 调用setParameter设置参数
typeHandler.setParameter(ps, i + 1, value, jdbcType)<span class="hljs-comment">;</span>
</code></pre>
<h2 data-id="heading-10">JDBC → Java 转换流程</h2>
<p>当从ResultSet获取结果时，需要将JDBC数据转换为Java对象：</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// 1. ResultSetHandler处理ResultSet</span>
while (resultSet.next()) {
    <span class="hljs-comment">// 2. 根据ResultMapping获取TypeHandler</span>
    TypeHandler&lt;?&gt; typeHandler = 
        resultMapping<span class="hljs-selector-class">.getTypeHandler</span>();

    <span class="hljs-comment">// 3. 调用getResult获取结果</span>
    <span class="hljs-selector-tag">Object</span> value = typeHandler<span class="hljs-selector-class">.getResult</span>(
        resultSet, column);

    <span class="hljs-comment">// 4. 设置到目标对象</span>
    metaObject<span class="hljs-selector-class">.setValue</span>(property, value);
}
</code></pre>
<h2 data-id="heading-11">四、参数设置时的类型转换</h2>
<p>参数设置是Java类型向JDBC类型转换的过程。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7a139f1c5f914effbc2d910d4b21482f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuo5Lit6aOY6I2h55qE6K6w5b-G:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767918788&amp;x-signature=JQ5i9FSDz4Y6XO951gOfIG5S5vg%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-12">基本类型转换示例</h2>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringTypeHandler</span> 
    <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseTypeHandler</span>&lt;String&gt; {

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNonNullParameter</span><span class="hljs-params">(
        PreparedStatement ps, <span class="hljs-type">int</span> i, 
        String parameter, JdbcType jdbcType)</span> 
        <span class="hljs-keyword">throws</span> SQLException {
        <span class="hljs-comment">// String → VARCHAR</span>
        ps.setString(i, parameter);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getNullableResult</span><span class="hljs-params">(
        ResultSet rs, String columnName)</span> 
        <span class="hljs-keyword">throws</span> SQLException {
        <span class="hljs-comment">// VARCHAR → String</span>
        <span class="hljs-keyword">return</span> rs.getString(columnName);
    }
}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LongTypeHandler</span> 
    <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseTypeHandler</span>&lt;Long&gt; {

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNonNullParameter</span><span class="hljs-params">(
        PreparedStatement ps, <span class="hljs-type">int</span> i, 
        Long parameter, JdbcType jdbcType)</span> 
        <span class="hljs-keyword">throws</span> SQLException {
        <span class="hljs-comment">// Long → BIGINT</span>
        ps.setLong(i, parameter);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> Long <span class="hljs-title function_">getNullableResult</span><span class="hljs-params">(
        ResultSet rs, String columnName)</span> 
        <span class="hljs-keyword">throws</span> SQLException {
        <span class="hljs-comment">// BIGINT → Long</span>
        <span class="hljs-type">long</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> rs.getLong(columnName);
        <span class="hljs-comment">// ⚠️ 关键：检查是否为NULL</span>
        <span class="hljs-keyword">return</span> value == <span class="hljs-number">0</span> &amp;&amp; rs.wasNull() ? <span class="hljs-literal">null</span> : value;
    }
}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DateTypeHandler</span> 
    <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseTypeHandler</span>&lt;Date&gt; {

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNonNullParameter</span><span class="hljs-params">(
        PreparedStatement ps, <span class="hljs-type">int</span> i, 
        Date parameter, JdbcType jdbcType)</span> 
        <span class="hljs-keyword">throws</span> SQLException {
        <span class="hljs-comment">// Date → Timestamp</span>
        ps.setTimestamp(i, 
            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Timestamp</span>(parameter.getTime()));
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> Date <span class="hljs-title function_">getNullableResult</span><span class="hljs-params">(
        ResultSet rs, String columnName)</span> 
        <span class="hljs-keyword">throws</span> SQLException {
        <span class="hljs-comment">// Timestamp → Date</span>
        <span class="hljs-type">Timestamp</span> <span class="hljs-variable">timestamp</span> <span class="hljs-operator">=</span> rs.getTimestamp(columnName);
        <span class="hljs-keyword">return</span> timestamp == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : 
               <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(timestamp.getTime());
    }
}
</code></pre>
<h2 data-id="heading-13">Null值处理</h2>
<p>Null值处理是参数设置中的重要环节：</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-comment">&lt;!-- 场景1：明确的jdbcType --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"insertUser"</span>&gt;</span>
    INSERT INTO t_user (name, email)
    VALUES (
        #{name, jdbcType=VARCHAR}, 
        #{email, jdbcType=VARCHAR}
    )
<span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 场景2：全局配置Null的jdbcType --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"jdbcTypeForNull"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"NULL"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span>
</code></pre>
<p>重要提示：未指定jdbcType时，传入null参数会抛出异常！</p>
<h2 data-id="heading-14">五、结果集获取时的类型转换</h2>
<p>结果集获取是JDBC类型向Java类型转换的过程。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d8f85705b7994c8da2d333c98536eced~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuo5Lit6aOY6I2h55qE6K6w5b-G:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767918788&amp;x-signature=a4y9WD%2B28op%2FvBRBXoVesQBIlhM%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-15">ResultSet结果获取流程</h2>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// 遍历ResultSet的完整流程</span>
while (resultSet.next()) {
    for (ResultMapping mapping : 
         resultMap.getPropertyResultMappings()) {

        <span class="hljs-comment">// 获取列名</span>
        String column = mapping<span class="hljs-selector-class">.getColumn</span>();

        <span class="hljs-comment">// 获取TypeHandler</span>
        TypeHandler&lt;?&gt; handler = 
            mapping<span class="hljs-selector-class">.getTypeHandler</span>();

        <span class="hljs-comment">// 获取结果值</span>
        <span class="hljs-selector-tag">Object</span> value = handler<span class="hljs-selector-class">.getResult</span>(
            resultSet, column);

        <span class="hljs-comment">// 设置到目标对象</span>
        metaObject<span class="hljs-selector-class">.setValue</span>(
            mapping.getProperty(), value);
    }
}
</code></pre>
<h2 data-id="heading-16">三种getResult方式</h2>
<p>TypeHandler提供了三种获取结果的方式：</p>
<pre><code class="hljs language-arduino" lang="arduino">@<span class="hljs-function">Override
<span class="hljs-keyword">public</span> <span class="hljs-type">String</span> <span class="hljs-title">getNullableResult</span><span class="hljs-params">(
    ResultSet rs, <span class="hljs-type">String</span> columnName)</span> 
    throws SQLException </span>{
    <span class="hljs-keyword">return</span> rs.<span class="hljs-built_in">getString</span>(columnName);
}
</code></pre>
<p>使用场景：</p>
<pre><code class="hljs language-java" lang="java">&lt;result column=<span class="hljs-string">"user_name"</span> property=<span class="hljs-string">"userName"</span>/&gt;
<span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> String <span class="hljs-title function_">getNullableResult</span><span class="hljs-params">(
    ResultSet rs, <span class="hljs-type">int</span> columnIndex)</span> 
    <span class="hljs-keyword">throws</span> SQLException {
    <span class="hljs-keyword">return</span> rs.getString(columnIndex);
}
</code></pre>
<p>使用场景：自动映射或需要按索引获取时</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> String <span class="hljs-title function_">getNullableResult</span><span class="hljs-params">(
    CallableStatement cs, <span class="hljs-type">int</span> columnIndex)</span> 
    <span class="hljs-keyword">throws</span> SQLException {
    <span class="hljs-keyword">return</span> cs.getString(columnIndex);
}
</code></pre>
<p>使用场景：</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-operator">&lt;</span><span class="hljs-keyword">select</span> id<span class="hljs-operator">=</span>"callProcedure" statementType<span class="hljs-operator">=</span>"CALLABLE"<span class="hljs-operator">&gt;</span>
    {<span class="hljs-keyword">call</span> get_user_info(
        #{userId, mode<span class="hljs-operator">=</span><span class="hljs-keyword">IN</span>, jdbcType<span class="hljs-operator">=</span><span class="hljs-type">BIGINT</span>},
        #{userName, mode<span class="hljs-operator">=</span><span class="hljs-keyword">OUT</span>, jdbcType<span class="hljs-operator">=</span><span class="hljs-type">VARCHAR</span>}
    )}
<span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span><span class="hljs-keyword">select</span><span class="hljs-operator">&gt;</span>
</code></pre>
<h2 data-id="heading-17">wasNull()的重要性</h2>
<p>在类型转换中，wasNull()方法非常关键：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> Long <span class="hljs-title function_">getNullableResult</span><span class="hljs-params">(
    ResultSet rs, String columnName)</span> 
    <span class="hljs-keyword">throws</span> SQLException {

    <span class="hljs-type">long</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> rs.getLong(columnName);
    <span class="hljs-comment">// ⚠️ 如果数据库是NULL，getLong()返回0</span>

    <span class="hljs-comment">// ✅ 必须检查wasNull()区分真实的0和NULL</span>
    <span class="hljs-keyword">return</span> value == <span class="hljs-number">0</span> &amp;&amp; rs.wasNull() ? <span class="hljs-literal">null</span> : value;
}
</code></pre>
<h2 data-id="heading-18">六、TypeHandler注册机制</h2>
<p>TypeHandlerRegistry负责管理所有TypeHandler的注册和查找。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/089b9e45490544f1bfe3881634b176d3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuo5Lit6aOY6I2h55qE6K6w5b-G:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767918788&amp;x-signature=ECN3JC3i9YWAkTLsa5To5ZUoe8Y%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-19">TypeHandlerRegistry结构</h2>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeHandlerRegistry</span> {
    <span class="hljs-comment">// JDBC类型 → TypeHandler</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt; 
        jdbcTypeHandlerMap = <span class="hljs-keyword">new</span> EnumMap&lt;&gt;(JdbcType.<span class="hljs-keyword">class</span>);

    <span class="hljs-comment">// Java类型 → (JDBC类型 → TypeHandler)</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;Type, Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt;&gt; 
        typeHandlerMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();

    <span class="hljs-comment">// Java类型 → 默认TypeHandler</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;Class&lt;?&gt;, TypeHandler&lt;?&gt;&gt; 
        allTypeHandlersMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TypeHandlerRegistry</span><span class="hljs-params">()</span></span>{
        <span class="hljs-comment">// 注册所有内置TypeHandler</span>
        <span class="hljs-built_in">register</span>(Boolean.<span class="hljs-keyword">class</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">BooleanTypeHandler</span>());
        <span class="hljs-built_in">register</span>(Integer.<span class="hljs-keyword">class</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">IntegerTypeHandler</span>());
        <span class="hljs-built_in">register</span>(Long.<span class="hljs-keyword">class</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">LongTypeHandler</span>());
        <span class="hljs-built_in">register</span>(<span class="hljs-type">String</span>.<span class="hljs-keyword">class</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">StringTypeHandler</span>());
        <span class="hljs-built_in">register</span>(Date.<span class="hljs-keyword">class</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">DateTypeHandler</span>());
        <span class="hljs-comment">// ... 更多注册</span>
    }
}
</code></pre>
<h2 data-id="heading-20">注册TypeHandler的四种方式</h2>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-built_in">void</span> <span class="hljs-title function_">register</span>(<span class="hljs-params">
    Class&lt;T&gt; javaType, 
    TypeHandler&lt;? <span class="hljs-keyword">extends</span> T&gt; typeHandler</span>) {
    <span class="hljs-title function_">register</span>((<span class="hljs-title class_">Type</span>) javaType, typeHandler);
}
<span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-built_in">void</span> <span class="hljs-title function_">register</span>(<span class="hljs-params">
    Class&lt;T&gt; <span class="hljs-keyword">type</span>, 
    JdbcType jdbcType, 
    TypeHandler&lt;? <span class="hljs-keyword">extends</span> T&gt; typeHandler</span>) {
    <span class="hljs-title function_">register</span>((<span class="hljs-title class_">Type</span>) <span class="hljs-keyword">type</span>, jdbcType, typeHandler);
}
<span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-built_in">void</span> <span class="hljs-title function_">register</span>(<span class="hljs-params">
    TypeReference&lt;T&gt; javaTypeReference, 
    TypeHandler&lt;? <span class="hljs-keyword">extends</span> T&gt; typeHandler</span>) {
    <span class="hljs-title function_">register</span>(javaTypeReference.<span class="hljs-title function_">getRawType</span>(), 
             typeHandler);
}
<span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">register</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> packageName</span>) {
    <span class="hljs-title class_">ResolverUtil</span>&lt;<span class="hljs-title class_">Class</span>&lt;?&gt;&gt; resolverUtil = 
        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResolverUtil</span>&lt;&gt;();
    resolverUtil.<span class="hljs-title function_">find</span>(
        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResolverUtil</span>.<span class="hljs-title class_">IsA</span>(<span class="hljs-title class_">TypeHandler</span>.<span class="hljs-property">class</span>), 
        packageName);

    <span class="hljs-title class_">Set</span>&lt;<span class="hljs-title class_">Class</span>&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Class</span>&lt;?&gt;&gt;&gt; handlerSet = 
        resolverUtil.<span class="hljs-title function_">getClasses</span>();

    <span class="hljs-keyword">for</span> (<span class="hljs-title class_">Class</span>&lt;?&gt; <span class="hljs-keyword">type</span> : handlerSet) {
        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">type</span>.<span class="hljs-title function_">isAnonymousClass</span>() &amp;&amp; 
            !<span class="hljs-keyword">type</span>.<span class="hljs-title function_">isInterface</span>() &amp;&amp; 
            !<span class="hljs-title class_">Modifier</span>.<span class="hljs-title function_">isAbstract</span>(<span class="hljs-keyword">type</span>.<span class="hljs-title function_">getModifiers</span>())) {
            <span class="hljs-title function_">register</span>(<span class="hljs-keyword">type</span>);
        }
    }
}
</code></pre>
<h2 data-id="heading-21">查找TypeHandler</h2>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 根据Java类型和JDBC类型查找</span>
<span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-title class_">TypeHandler</span>&lt;T&gt; <span class="hljs-title function_">getTypeHandler</span>(<span class="hljs-params">
    Class&lt;T&gt; <span class="hljs-keyword">type</span>, JdbcType jdbcType</span>) {

    <span class="hljs-comment">// 1. 从Java类型映射中查找</span>
    <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">JdbcType</span>, <span class="hljs-title class_">TypeHandler</span>&lt;?&gt;&gt; jdbcHandlerMap = 
        typeHandlerMap.<span class="hljs-title function_">get</span>(<span class="hljs-keyword">type</span>);

    <span class="hljs-keyword">if</span> (jdbcHandlerMap != <span class="hljs-literal">null</span>) {
        <span class="hljs-title class_">TypeHandler</span>&lt;?&gt; handler = 
            jdbcHandlerMap.<span class="hljs-title function_">get</span>(jdbcType);
        <span class="hljs-keyword">if</span> (handler != <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">return</span> (<span class="hljs-title class_">TypeHandler</span>&lt;T&gt;) handler;
        }
    }

    <span class="hljs-comment">// 2. 查找默认TypeHandler</span>
    <span class="hljs-keyword">return</span> (<span class="hljs-title class_">TypeHandler</span>&lt;T&gt;) <span class="hljs-title function_">getTypeHandler</span>((<span class="hljs-title class_">Type</span>) <span class="hljs-keyword">type</span>);
}
</code></pre>
<h2 data-id="heading-22">七、自定义TypeHandler</h2>
<p>当内置TypeHandler无法满足需求时，可以自定义TypeHandler。</p>
<h2 data-id="heading-23">实现TypeHandler接口</h2>
<p>下面是一个JSON类型处理器的完整示例：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@MappedTypes(List.class)</span>
<span class="hljs-meta">@MappedJdbcTypes(JdbcType.VARCHAR)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JsonListTypeHandler</span> 
    <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseTypeHandler</span>&lt;List&lt;String&gt;&gt; {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Gson</span> <span class="hljs-variable">GSON</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Gson</span>();
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Type</span> <span class="hljs-variable">LIST_TYPE</span> <span class="hljs-operator">=</span> 
        <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeToken</span>&lt;List&lt;String&gt;&gt;(){}.getType();

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNonNullParameter</span><span class="hljs-params">(
        PreparedStatement ps, <span class="hljs-type">int</span> i, 
        List&lt;String&gt; parameter, JdbcType jdbcType)</span> 
        <span class="hljs-keyword">throws</span> SQLException {
        <span class="hljs-comment">// List&lt;String&gt; → JSON字符串</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> GSON.toJson(parameter);
        ps.setString(i, json);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">getNullableResult</span><span class="hljs-params">(
        ResultSet rs, String columnName)</span> 
        <span class="hljs-keyword">throws</span> SQLException {
        <span class="hljs-comment">// JSON字符串 → List&lt;String&gt;</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> rs.getString(columnName);
        <span class="hljs-keyword">return</span> parseJson(json);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">getNullableResult</span><span class="hljs-params">(
        ResultSet rs, <span class="hljs-type">int</span> columnIndex)</span> 
        <span class="hljs-keyword">throws</span> SQLException {
        <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> rs.getString(columnIndex);
        <span class="hljs-keyword">return</span> parseJson(json);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">getNullableResult</span><span class="hljs-params">(
        CallableStatement cs, <span class="hljs-type">int</span> columnIndex)</span> 
        <span class="hljs-keyword">throws</span> SQLException {
        <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> cs.getString(columnIndex);
        <span class="hljs-keyword">return</span> parseJson(json);
    }

    <span class="hljs-keyword">private</span> List&lt;String&gt; <span class="hljs-title function_">parseJson</span><span class="hljs-params">(String json)</span> {
        <span class="hljs-keyword">if</span> (json == <span class="hljs-literal">null</span> || json.trim().isEmpty()) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }
        <span class="hljs-keyword">return</span> GSON.fromJson(json, LIST_TYPE);
    }
}
</code></pre>
<h2 data-id="heading-24">枚举类型处理</h2>
<p>MyBatis提供了两种枚举类型处理器：</p>
<pre><code class="hljs language-scala" lang="scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EnumTypeHandler&lt;E</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Enum&lt;E&gt;&gt;</span> </span>
    <span class="hljs-keyword">extends</span> <span class="hljs-type">BaseTypeHandler</span>&lt;<span class="hljs-type">E</span>&gt; {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Class</span>&lt;<span class="hljs-type">E</span>&gt; <span class="hljs-class"><span class="hljs-keyword">type</span></span>;

    <span class="hljs-meta">@Override</span>
    public void setNonNullParameter(
        <span class="hljs-type">PreparedStatement</span> ps, int i, 
        <span class="hljs-type">E</span> parameter, <span class="hljs-type">JdbcType</span> jdbcType) 
        <span class="hljs-keyword">throws</span> <span class="hljs-type">SQLException</span> {
        <span class="hljs-comment">// Enum → name (VARCHAR)</span>
        ps.setString(i, parameter.name());
    }

    <span class="hljs-meta">@Override</span>
    public <span class="hljs-type">E</span> getNullableResult(
        <span class="hljs-type">ResultSet</span> rs, <span class="hljs-type">String</span> columnName) 
        <span class="hljs-keyword">throws</span> <span class="hljs-type">SQLException</span> {
        <span class="hljs-comment">// name → Enum</span>
        <span class="hljs-type">String</span> name = rs.getString(columnName);
        <span class="hljs-keyword">return</span> name == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : 
               <span class="hljs-type">Enum</span>.valueOf(<span class="hljs-class"><span class="hljs-keyword">type</span>, <span class="hljs-title">name</span>)</span>;
    }
}
public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EnumOrdinalTypeHandler&lt;E</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Enum&lt;E&gt;&gt;</span> </span>
    <span class="hljs-keyword">extends</span> <span class="hljs-type">BaseTypeHandler</span>&lt;<span class="hljs-type">E</span>&gt; {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Class</span>&lt;<span class="hljs-type">E</span>&gt; <span class="hljs-class"><span class="hljs-keyword">type</span></span>;

    <span class="hljs-meta">@Override</span>
    public void setNonNullParameter(
        <span class="hljs-type">PreparedStatement</span> ps, int i, 
        <span class="hljs-type">E</span> parameter, <span class="hljs-type">JdbcType</span> jdbcType) 
        <span class="hljs-keyword">throws</span> <span class="hljs-type">SQLException</span> {
        <span class="hljs-comment">// Enum → ordinal (INTEGER)</span>
        ps.setInt(i, parameter.ordinal());
    }

    <span class="hljs-meta">@Override</span>
    public <span class="hljs-type">E</span> getNullableResult(
        <span class="hljs-type">ResultSet</span> rs, <span class="hljs-type">String</span> columnName) 
        <span class="hljs-keyword">throws</span> <span class="hljs-type">SQLException</span> {
        <span class="hljs-comment">// ordinal → Enum</span>
        int ordinal = rs.getInt(columnName);
        <span class="hljs-keyword">if</span> (ordinal == <span class="hljs-number">0</span> &amp;&amp; rs.wasNull()) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }
        <span class="hljs-type">E</span>[] enums = <span class="hljs-keyword">type</span>.getEnumConstants();
        <span class="hljs-keyword">return</span> enums[ordinal];
    }
}
</code></pre>
<h2 data-id="heading-25">注册自定义TypeHandler的三种方式</h2>
<pre><code class="hljs language-xml" lang="xml">@MappedTypes(List.class)
@MappedJdbcTypes(JdbcType.VARCHAR)
public class JsonListTypeHandler 
    extends BaseTypeHandler&lt;List<span class="hljs-tag">&lt;<span class="hljs-name">String</span>&gt;</span>&gt; {
    // 实现代码...
}
<span class="hljs-tag">&lt;<span class="hljs-name">typeHandlers</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- 指定类名 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">typeHandler</span> 
        <span class="hljs-attr">handler</span>=<span class="hljs-string">"com.example.JsonListTypeHandler"</span>/&gt;</span>

    <span class="hljs-comment">&lt;!-- 指定Java类型和JDBC类型 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">typeHandler</span> 
        <span class="hljs-attr">javaType</span>=<span class="hljs-string">"java.util.List"</span>
        <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">"VARCHAR"</span>
        <span class="hljs-attr">handler</span>=<span class="hljs-string">"com.example.JsonListTypeHandler"</span>/&gt;</span>

    <span class="hljs-comment">&lt;!-- 包扫描 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"com.example.typehandler"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">typeHandlers</span>&gt;</span>
@Configuration
public class MyBatisConfig {
    @Bean
    public ConfigurationCustomizer 
        configurationCustomizer() {
        return configuration -&gt; {
            TypeHandlerRegistry registry = 
                configuration.getTypeHandlerRegistry();
            registry.register(
                List.class, 
                JdbcType.VARCHAR, 
                new JsonListTypeHandler()
            );
        };
    }
}
</code></pre>
<h2 data-id="heading-26">八、最佳实践</h2>
<h2 data-id="heading-27">问题1：类型转换异常</h2>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span> 问题：Cannot <span class="hljs-keyword">convert</span> <span class="hljs-keyword">value</span> <span class="hljs-string">'0000'</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">column</span> <span class="hljs-number">1</span> <span class="hljs-keyword">to</span> <span class="hljs-type">TIMESTAMP</span>
<span class="hljs-operator">/</span><span class="hljs-operator">/</span> 原因：日期格式不匹配
<span class="hljs-operator">/</span><span class="hljs-operator">/</span> 解决：使用正确的日期类型或自定义TypeHandler
</code></pre>
<h2 data-id="heading-28">问题2：Null值处理</h2>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-comment">// 问题：JDBC requires that the JdbcType must be specified</span>
<span class="hljs-comment">// 解决1：指定jdbcType</span>
<span class="hljs-meta">#{name, jdbcType=VARCHAR}</span>

<span class="hljs-comment">// 解决2：全局配置</span>
&lt;setting name=<span class="hljs-string">"jdbcTypeForNull"</span> <span class="hljs-keyword">value</span>=<span class="hljs-string">"NULL"</span>/&gt;
</code></pre>
<h2 data-id="heading-29">问题3：枚举类型处理</h2>
<pre><code class="hljs language-ini" lang="ini">// 配置默认枚举处理器
&lt;settings&gt;
    &lt;setting <span class="hljs-attr">name</span>=<span class="hljs-string">"defaultEnumTypeHandler"</span> value=<span class="hljs-string">"org.apache.ibatis.type.EnumTypeHandler"</span>/&gt;
&lt;/settings&gt;

// 或在ResultMap中指定
&lt;result <span class="hljs-attr">column</span>=<span class="hljs-string">"status"</span> property=<span class="hljs-string">"status"</span>
         <span class="hljs-attr">typeHandler</span>=<span class="hljs-string">"org.apache.ibatis.type.EnumOrdinalTypeHandler"</span>/&gt;
</code></pre>
<h2 data-id="heading-30">九、总结</h2>
<p>MyBatis的类型处理模块是整个框架的基础组件，通过精心设计的TypeHandler体系，实现了Java类型与JDBC类型的无缝转换。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Weex 底层原理与 APM]]></title>    <link>https://juejin.cn/post/7590575755491328054</link>    <guid>https://juejin.cn/post/7590575755491328054</guid>    <pubDate>2026-01-02T02:21:46.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7590575755491328054" data-draft-id="7589916567876354090" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Weex 底层原理与 APM"/> <meta itemprop="keywords" content="前端框架,iOS,Weex"/> <meta itemprop="datePublished" content="2026-01-02T02:21:46.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="杭城小刘"/> <meta itemprop="url" content="https://juejin.cn/user/3175045309408429"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Weex 底层原理与 APM
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3175045309408429/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    杭城小刘
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-02T02:21:46.000Z" title="Fri Jan 02 2026 02:21:46 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-02
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读42分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>从 Vue 组件库（Vue Lib）到 Weex 渲染为 iOS 原生 UIKit 元素，核心是 “Virtual DOM → 跨线程通信 → Native DOM 构建 → 布局计算 → 原生 View 渲染 → 事件反向绑定” 的完整链路。Weex 作为中间层，主要完成 7 大核心工作，接下去看看详细内容.</p>
<p>Weex 侧 APM 该怎么开展？</p>
</blockquote>
<h2 data-id="heading-0">一、核心步骤</h2>
<p>从 Vue Lib 到 Weex 原生 UIKit 元素的完整流程。</p>
<p>首先，用户的需求是 “列举 Weex 做的事情” 并 “结合最新源码标位置”，所以思考过程要先拆解流程：从 Vue 编译产物处理、JS-Native 通信、Virtual DOM 解析、DOM 构建与布局计算、渲染指令生成、原生 View 创建与更新，这几个核心步骤。每个步骤都要对应 Weex 的具体工作，还要找到最新源码中的对应类和方法。</p>
<p>第一步，应该是 Vue 编译产物的适配。因为 Vue 写的代码要被 Weex 识别，Weex 需要处理 Vue 的模板编译结果（比如 render 函数生成的 Virtual DOM），还要注入 Weex 的 JS Runtime API。这里要找最新源码中 JS Runtime 的初始化类，比如 WXJSContext 或 WXBridgeCore，因为 JS 环境的搭建是第一步。</p>
<p>第二步，JS-Native 通信的建立。Vue 的 Virtual DOM 变化需要传递给 Native，所以 Weex 的 Bridge 核心要注册通信方法（比如 callNative），这里对应 WXBridgeCore 的 invokeNative 方法，之前讨论过 bridge 队列，这里要结合最新源码中通信任务的调度。</p>
<p>第三步，Virtual DOM 的解析与 DOM 树构建。Weex 需要把 Vue 的 Virtual DOM（JSON 结构）解析成 Native 侧的 DOM 节点（WXDOMNode），这部分现在在 WXDOMCore 中，比如 createNode 方法，处理节点创建、属性更新，还要维护 DOM 树结构。</p>
<p>第四步，样式解析与 Yoga 布局计算。Vue 的样式（比如 flex）要被 Weex 解析，转换为 Yoga 的布局属性，然后在 dom 线程计算布局，这部分在 WXDOMCore 的_scheduleLayout 方法，调用 Yoga 的 calculateLayout。</p>
<p>第五步，渲染指令生成与传递。DOM 和布局计算完成后，要把结果封装成渲染指令（节点 ID、frame、类型等），通过主线程传递给渲染核心，这里是 WXDOMCore 的_notifyRender 方法，切换到 main queue。</p>
<p>第六步，原生 UIKit 元素的创建与更新。渲染核心（WXRenderCore）接收指令，创建对应 UIKit 控件（UILabel、UIImageView 等），或复用已有 View，更新 frame 和样式，这部分在 WXRenderCore 的 render 方法，还有具体的 View 工厂类（比如 WXViewFactory）。</p>
<p>第七步，事件绑定与反向通信。原生 UI 的事件（比如点击）要传递回 Vue，Weex 需要注册 Native 事件，通过 Bridge 回调 JS，这里对应 WXEventDispatcher 和 WXBridgeCore 的 callbackJS 方法。</p>
<p>具体的逻辑不做深入探讨，可以查看源码研究。</p>
<h2 data-id="heading-1">二、Yoga</h2>
<h3 data-id="heading-2">1. 支持"增量布局更新"</h3>
<p>当组件样式变化时，Yoga 仅重新计算受影响的组件树分支，而非全量重算，大幅减少 RN 应用的布局耗时和卡顿』Yoga 是如何实现仅计算受影响的组件树分支的？类似有个打标记，标记为 dirty？</p>
<p>Yoga 实现增量布局的核心就是 「Dirty 标记机制」+「组件树依赖传播」—— 通过标记 “受影响的节点”，并仅处理这些节点及其关联分支，避免全量重算。</p>
<h4 data-id="heading-3">1. YogaNode 与 Dirty 状态标识</h4>
<p>Yoga 中每个组件对应一个 YogaNode（布局计算的最小单元），每个节点都包含 3 个关键状态标记（用于判断是否需要重算）：</p>
<ul>
<li>dirtyFlags（核心标记）：记录节点的 “脏状态类型”，主要分两类：
<ul>
<li>LAYOUT_DIRTY：节点自身样式（如 width、flex）或子节点布局变化，需要重新计算自身布局；</li>
<li>MEASURE_DIRTY：节点的测量相关属性（如 measureFunction 自定义测量逻辑）变化，需要先重新测量尺寸，再计算布局。</li>
</ul>
</li>
<li>isLayoutClean：布尔值，快速判断节点是否 “干净”（无脏状态），避免重复检查 dirtyFlags；</li>
<li>childCount + children 指针：维护子节点列表，用于后续遍历依赖分支。</li>
</ul>
<h4 data-id="heading-4">2. 脏状态触发与传播：从 “变化节点” 到 “根节点” 的冒泡</h4>
<p>当组件样式变化时（如 RN 中修改 style={{ flex: 2 }}），Yoga 会触发以下流程：</p>
<ul>
<li>
<p>步骤 1：标记自身为 Dirty
直接修改变化节点的 dirtyFlags |= LAYOUT_DIRTY（或 MEASURE_DIRTY），同时设置 isLayoutClean = false。</p>
</li>
<li>
<p>步骤 2：向上冒泡通知父节点
由于父节点的布局（如尺寸、位置）依赖子节点的布局结果（比如父节点是 flex:1，子节点尺寸变化会影响父节点的剩余空间分配），因此会递归向上遍历父节点，直到根节点，将所有 “依赖节点” 都标记为 LAYOUT_DIRTY。
关键优化：父节点仅标记 “需要重算”，但不会立即计算，避免中途重复触发计算。</p>
</li>
<li>
<p>步骤 3：跳过已标记的节点
若某个节点已被标记为 Dirty，后续重复触发时会直接跳过（避免重复冒泡），提升效率。</p>
</li>
</ul>
<h4 data-id="heading-5">3. 布局计算阶段：只处理 Dirty 分支，跳过干净节点（DFS）</h4>
<p>当 Yoga 触发布局计算（如 RN 渲染帧触发、组件挂载完成）时，会从根节点开始遍历组件树，但仅处理 “Dirty 节点及其子树”：</p>
<ul>
<li>
<p>步骤 1：根节点判断状态
若根节点是干净的（isLayoutClean = true），直接终止计算（全量跳过）；若为 Dirty，进入分支处理。</p>
</li>
<li>
<p>步骤 2：递归处理 Dirty 分支
对每个节点，先检查自身状态：</p>
</li>
<li>
<p>若干净：直接复用上次缓存的布局结果（x/y/width/height），不重算；</p>
</li>
<li>
<p>若 Dirty：</p>
<ul>
<li>先处理子节点：如果子节点是 Dirty，先递归计算子节点布局（保证父节点计算时依赖的子节点数据是最新的）；</li>
<li>再计算自身布局：根据 Flex 规则（如 flexDirection、justifyContent）和子节点布局结果，计算自身的最终尺寸和位置；</li>
<li>清除 Dirty 标记：计算完成后，设置 dirtyFlags = 0、isLayoutClean = true，标记为干净。</li>
</ul>
</li>
<li>
<p>步骤 3：增量更新的核心效果
比如修改一个列表项的 margin，只会标记该列表项 → 父列表容器 → 根节点为 Dirty，其他列表项、页面其他组件均为干净，会直接跳过计算，仅重算 “列表项→父容器” 这一小分支。</p>
</li>
</ul>
<h3 data-id="heading-6">2. Flex 布局逻辑如何到 Native 系统</h3>
<p>Flex 布局逻辑，或者说 DSL，是如何翻译为 iOS 的 AutoLayout 和 Android 的 LayoutParams 的？</p>
<p>Yoga 先将 Flex DSL 解析为统一的「布局计算结果」（节点的 x/y/width/height、间距、对齐方式等），再根据平台差异，将计算结果 “映射” 为对应平台的原生布局规则——iOS 映射为 AutoLayout 约束，Android 映射为 LayoutParams + 原生布局容器属性。</p>
<h4 data-id="heading-7">1. 第一步：通用前置流程（跨平台统一）</h4>
<p>无论 iOS 还是 Android，Yoga 都会先完成以下步骤，屏蔽 Flex DSL 的解析差异：</p>
<ol>
<li>解析 Flex 样式：将上层框架的 Flex 配置（如 RN 的 StyleSheet、Weex 的模板样式）解析为 YogaNode 的属性（如 flexDirection、justifyContent、margin、padding 等）；</li>
<li>执行布局计算：通过 Flexbox 算法（基于 Web 标准），计算出每个 YogaNode 的最终布局数据：</li>
</ol>
<ul>
<li>固定属性：width/height（含 auto/flex 计算后的具体数值）、x/y（相对父节点的坐标）；</li>
<li>间距属性：marginLeft/Top/Right/Bottom、paddingLeft/Top/Right/Bottom；</li>
<li>对齐属性：alignItems、justifyContent 对应的节点相对位置关系；</li>
</ul>
<ol start="3">
<li>输出标准化布局数据：将上述结果封装为平台无关的结构体，供后续平台映射使用。</li>
</ol>
<h4 data-id="heading-8">2. 第二步：iOS 端：映射为 AutoLayout 约束（NSLayoutConstraint）</h4>
<p>AutoLayout 的核心是「基于约束的关系描述」（而非直接设置坐标），因此 Yoga 会将 “计算出的具体尺寸 / 位置” 转化为 UIView 的约束（NSLayoutConstraint），核心映射规则如下：一一翻译 css 规则到 iOS AutoLayout 写法：</p>





































<table><thead><tr><th>Flex 核心属性</th><th>对应的 AutoLayout 约束逻辑</th></tr></thead><tbody><tr><td><code>width: 100</code></td><td>映射为 <code>view.widthAnchor.constraint(equalToConstant: 100)</code></td></tr><tr><td><code>height: auto</code></td><td>先通过 Yoga 计算出具体高度（如文字高度、子节点包裹高度），再映射为 <code>heightAnchor</code> 约束；若为 <code>flex:1</code>，则映射为 <code>heightAnchor.constraint(equalTo: superview.heightAnchor, multiplier: 1)</code>（占满父容器剩余高度）</td></tr><tr><td><code>marginLeft: 20</code></td><td>映射为 <code>view.leadingAnchor.constraint(equalTo: superview.leadingAnchor, constant: 20)</code></td></tr><tr><td><code>marginTop: 15</code></td><td>映射为 <code>view.topAnchor.constraint(equalTo: superview.topAnchor, constant: 15)</code></td></tr><tr><td><code>justifyContent: center</code>（父节点 flexDirection: row）</td><td>父节点约束：<code>view.centerXAnchor.constraint(equalTo: superview.centerXAnchor)</code>；若有多个子节点，通过调整子节点间的 <code>spacing</code> 约束实现均匀分布</td></tr><tr><td><code>alignItems: center</code>（父节点 flexDirection: column）</td><td>子节点约束：<code>view.centerYAnchor.constraint(equalTo: superview.centerYAnchor)</code></td></tr><tr><td><code>flex: 1</code>（子节点）</td><td>映射为 <code>view.widthAnchor.constraint(equalTo: superview.widthAnchor, multiplier: 1)</code>（横向占满）+ 父节点的 <code>distribution</code> 约束（分配剩余空间）</td></tr></tbody></table>
<p>补充信息：</p>
<ul>
<li>Yoga 会为每个 <code>UIView</code> 关联一个 <code>YogaNode</code>，布局计算完成后，通过 <code>YogaKit</code>（或上层框架如 RN 的原生层）自动生成约束；</li>
<li>支持 “约束优先级” 适配：比如 <code>flex:1</code> 对应的约束优先级会高于固定尺寸约束，确保 Flex 规则优先生效；</li>
<li>混合布局兼容：若原生视图已有部分 AutoLayout 约束，Yoga 会生成 “补充约束”，避免冲突（通过 <code>active</code>属性控制约束启用 / 禁用）。</li>
</ul>
<h2 data-id="heading-9">三、Weex 剖析</h2>
<pre><code class="hljs language-mermaid" lang="mermaid">sequenceDiagram
    participant V as Vue组件
    participant J as JS Framework
    participant B as JS-Native Bridge
    participant N as Native引擎
    participant P as 原生UI

    V-&gt;&gt;J: .vue单文件 (template/style/script)
    Note right of J: 编译阶段&lt;br&gt;weex-loader编译Vue组件
    J-&gt;&gt;J: 生成Virtual DOM树
    Note right of J: 运行阶段&lt;br&gt;JS Framework管理VNode生命周期
    J-&gt;&gt;B: 通过callNative发送&lt;br&gt;渲染指令JSON
    Note right of B: 通信层&lt;br&gt;将JS调用转为原生模块调用
    B-&gt;&gt;N: 传递渲染指令
    Note right of N: 原生渲染引擎&lt;br&gt;WXRenderManager (Android)&lt;br&gt;WXComponent (iOS)
    N-&gt;&gt;N: 解析指令，创建/更新组件树
    N-&gt;&gt;P: 调用原生API渲染&lt;br&gt;（e.g., UIView, TextView）
    P-&gt;&gt;P: 最终原生视图
</code></pre>
<p>下面针对核心机制详解与源码定位</p>
<h3 data-id="heading-10">1. 编译阶段：从 Vue 到 Virtual DOM</h3>
<ul>
<li>处理 Vue 单文件：开发者的<code>.vue</code>文件通过 Webpack 和 <code>weex-loader</code> 编译成 JavaScript Bundle。这个 Bundle 包含了渲染页面所需的所有信息</li>
<li>生成Virtual DOM：在JS运行时，Vue.js（或 Rax）的渲染函数会生成一棵 Virtual DOM树（VNode）。Weex 的 JS Framework 会拦截常规的 DOM 操作，将其导向 Weex 的渲染管道</li>
</ul>
<p>源码相关：编译过程主要涉及 <code>weex-loader</code> (在 <code>weex-toolkit</code> 项目中)，而 JS Framework 对 VNode 的处理在 <code>js-framework</code> 目录下。重点关注 <code>src/framework.js</code> 中的 <code>Document</code> 和 <code>Element</code> 类，它们模拟了 DOM 结构</p>
<h3 data-id="heading-11">2. 指令生成与通信</h3>
<ul>
<li>
<p>序列化为渲染指令（json 数据）：JS-Framework 不会直接操作 Dom，而是把对 Dom 的操作，描述成对 VNode 对象的创建、更新、删除等，序列化成一种特殊的 JSON 格式的渲染指令。比如</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"module"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"dom"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"method"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"createBody"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"args"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">{</span><span class="hljs-attr">"ref"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"1"</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"div"</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">"style"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>...<span class="hljs-punctuation">}</span><span class="hljs-punctuation">}</span><span class="hljs-punctuation">]</span>
<span class="hljs-punctuation">}</span>
</code></pre>
</li>
<li>
<p>JS-Native 桥接：这些指令通过 callNative 方法，从 JS 端发送到 Native 端，同时 Native 端也可以通过 callJS 方法向 JS 端发送事件（比如用户点击）</p>
</li>
</ul>
<h3 data-id="heading-12">3. 原生端渲染</h3>
<ul>
<li>指令解析与组件渲染：Native 端的渲染引擎（如 Android 的 WXRenderManger 和 iOS 的 WXComponentManager）接收并解析 JS 指令。Weex 维护了一个从 JS 组件到原生 UI 组件的映射表。（例如  映射到 iOS 的 UILabel）</li>
<li>布局与样式：Weex 使用的 Flexbox 布局模型做为统一的布局方案，Native 端需要将 JS 传递的 css 样式属性，转换为原生组件能够理解的布局参数与样式属性。</li>
<li>多线程模型：为了保证 UI 流畅，Weex 采用了多线程模型。DOM 操作和布局计算通常在单独的 DOM 线程进行，而最终创建和更新原生视图的操作必须在 UI 主线程上进行</li>
</ul>
<h3 data-id="heading-13">4. 拓展机制</h3>
<ul>
<li>模块（Module）：用于暴露原生能力（如网络、存储）给前端调用，通过 callNative 触发，支持回调</li>
<li>组件（Component）：拓展自定义 UI 组件，允许开发者创建自定义的原生 UI 组件，并在 JSX 中使用</li>
<li>适配器（Adapter）：提供可替换的实现，如图片下载器</li>
</ul>
<h2 data-id="heading-14">四、为什么自定义 Component 都需要继承自 WXComponent？</h2>
<p>比如下面的代码</p>
<pre><code class="hljs language-objective-c" lang="objective-c">[self registerComponent:@"image" withClass:NSClassFromString(@"WXImageComponent") withProperties:nil];

@interface WXImageComponent : WXComponent

@end
</code></pre>
<p>答：<strong>自定义原生组件必须继承自 WXComponent，本质是复用 Weex 封装的「JS - 原生交互、生命周期、样式布局、渲染基础」等通用能力，确保组件能接入 Weex 运行时生态</strong>。</p>
<p>Weex Module 与 Componet 的区别</p>























<table><thead><tr><th>类型</th><th>核心作用</th><th>基类</th><th>示例</th></tr></thead><tbody><tr><td>Component</td><td>原生 UI 渲染（有视图）</td><td><code>WXComponent</code></td><td><code>WXImageComponent</code>（图片）、<code>WXTextComponent</code>（文本）、自定义按钮组件</td></tr><tr><td>Module</td><td>功能扩展（无视图）</td><td><code>WXModule</code></td><td><code>WXNavigatorModule</code>（导航）、<code>WXStorageModule</code>（存储）、自定义工具模块</td></tr></tbody></table>
<p>实现 JS 与原生组件的「数据同步」（属性、事件、方法）</p>
<p>Weex 的核心是「JS 控制原生组件」，而 <code>WXComponent</code> 封装了 JS 与原生之间的通信协议，无需自定义组件手动处理：</p>
<ul>
<li>
<p>属性同步（Props）：JS 端通过 <code>&lt;my-component prop1="xxx" prop2="yyy"&gt;</code> 传递的属性，WXComponent 会自动解析、类型转换（如 JS 字符串 → 原生 NSString/NSNumber），并通过 <code>setter</code> 方法同步到自定义组件。</p>
<p>示例：WXImageComponent 继承 <code>WXComponent</code> 后，只需重写 <code>-setSrc:(NSString*)src</code> 方法，就能接收 JS 传的 <code>src</code> 属性，无需关心「JS 如何把值传给原生」。</p>
</li>
<li>
<p>事件分发（Events）：原生组件的交互事件（如点击、加载完成），<code>WXComponent</code> 会按照 Weex 协议回传给 JS 端（如 <code>@emit('click')</code> )</p>
<p>示例：自定义按钮组件继承后，只需调用 <code>[self fireEvent:@"click" params:@{@"x": @100, @"y": @200}]</code> ，JS 端就能通过 <code>@onclick</code>接收事件，无需自己实现事件通信。</p>
</li>
<li>
<p>方法调用（Methods）：JS 端通过 <code>this.$refs.myComponent.callMethod('xxx', params)</code> 调用原生组件方法，<code>WXComponent</code></p>
<p>会解析方法名和参数，反射调用自定义组件的对应方法。</p>
<p>示例：自定义播放器组件继承后，只需暴露 <code>-play</code>方法，JS 就能直接调用，<code>WXComponent</code>负责方法查找和参数传递。</p>
</li>
</ul>
<h2 data-id="heading-15">五、JS 数据变化是如何驱动 Native UI 更新的</h2>
<p>纯 Web 端的数据变化会通过 Proxy 去驱动关联的 UI 更新，这也是 Vue3 的工作原理，那么 JS 端的数据变化是如何驱动 Native UI 组件的更新的？</p>
<p>所有的 Native UI Component 都继承自 WXComponent，所以可以直接给 WXComponent 添加一个实现 DataBinding 的 Category，这就是 Weex 最新源码中的 <code>WXComponent+DataBinding.mm</code></p>
<p>核心是：<strong>解析 JS 端传递的「绑定表达式」（如 <code>{{a + b}}</code>），编译为原生可执行的回调 Block，当 JS 数据变化时，通过 Block 计算出组件所需的新值，自动更新组件的属性、样式、事件，或处理列表（<code>v-for</code>）、条件（<code>v-if</code>）、一次性绑定（<code>v-once</code>）等逻辑</strong></p>
<p>可能有些人要问了：为什么当 js 数据变化时，需要让 Native 计算组件所需的新值？这不就是 Native 做了一遍 Vue 响应式的逻辑吗？这种重复逻辑的价值是什么？</p>
<p><strong>Vue3 的 Proxy 只负责「JS 端数据变化的监听 + 依赖收集 + 触发更新通知」—— 它是 “响应式的触发器”，而非 “UI 更新的执行者”</strong></p>
<p>而 Weex 之所以需要 Native 托管，核心是因为「继承自 WXComponent 的 UI 组件是 Native 侧的原生组件，而非 DOM 组件」，JS 端没有任何能力（API）去访问、操作他们，Proxy 再强大，它也只是 Native 侧（Weex）和 Web 端（Vue）负责“喊一声，哎，数据变了，你们谁需要的自助，自己去处理感兴趣的 UI”，却摸不到 UI 组件，Web 端由 DOM API 去渲染绘制，Native 端更触碰不到，必须由 Native 自己来完成：听到通知 -&gt; 计算新值 -&gt; 更新控件的流程。</p>
<h3 data-id="heading-16">1. Proxy 都做了些什么？</h3>
<p>Vue3 的核心实现里 Proxy 做了3件事：全程在 JS 侧，不涉及任何 UI 操作</p>
<p>监听数据操作：通过 Proxy 代理对象拦截数据的 getter、setter</p>
<ul>
<li>通过 getter 收集依赖关系：当组件渲染时触发 getter，Proxy 会记录这个组件依赖了这个数据</li>
<li>通过 setter 触发更新通知：当数据被修改时触发 setter，Proxy 会告诉 Vue 运行时，“user.name” 变了，所有依赖它的组件该更新了</li>
</ul>
<p>Proxy（代理）是 ES6 新增的内置对象，用于<strong>创建一个对象的代理副本</strong>，并通过「陷阱（Trap）」拦截对原对象的基本操作（如属性访问、赋值、删除等），从而自定义这些操作的行为。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler);
</code></pre>
<ul>
<li><code>target</code>：被代理的<strong>原始对象</strong>（可以是对象、数组，甚至函数）；</li>
<li><code>handler</code>：配置对象，包含多个「陷阱方法」（如 <code>get</code>、<code>set</code>），用于定义拦截逻辑；</li>
<li><code>proxy</code>：代理对象，后续对原始对象的操作需通过代理对象进行，才能触发拦截。</li>
</ul>






























<table><thead><tr><th>陷阱方法</th><th>作用</th><th>触发场景</th></tr></thead><tbody><tr><td><code>get(target, key, receiver)</code></td><td>拦截「属性访问」</td><td><code>proxy.key</code> 或 <code>proxy[key]</code></td></tr><tr><td><code>set(target, key, value, receiver)</code></td><td>拦截「属性赋值」</td><td><code>proxy.key = value</code> 或 <code>proxy[key] = value</code></td></tr><tr><td><code>deleteProperty(target, key)</code></td><td>拦截「属性删除」</td><td><code>delete proxy.key</code></td></tr><tr><td><code>has(target, key)</code></td><td>拦截「<code>in</code> 运算符判断」</td><td><code>key in proxy</code></td></tr></tbody></table>
<p>Tips: Proxy 代理的是「整个对象」，而非单个属性，且拦截的是「操作行为」（如 “访问属性” 这个动作），而非属性本身。</p>
<p>Vue 核心流程：<strong>创建代理 → 依赖收集 → 数据修改 → 触发更新</strong>。</p>
<h4 data-id="heading-17">1. 创建代理（reactive 函数的核心）</h4>
<p><code>reactive</code> 函数接收一个原始对象，返回其 Proxy 代理对象，同时配置 <code>get</code>、<code>set</code> 等陷阱方法，为后续依赖收集和更新做准备</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">reactive</span>(<span class="hljs-params">target</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, {
    <span class="hljs-comment">// 拦截属性访问</span>
    <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key, receiver</span>) {
      <span class="hljs-comment">// 1. 先获取原始属性值</span>
      <span class="hljs-keyword">const</span> value = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, key, receiver);
      <span class="hljs-comment">// 2. 收集依赖（关键：记录“谁在访问这个属性”）</span>
      <span class="hljs-title function_">track</span>(target, key);
      <span class="hljs-comment">// 3. 若访问的是嵌套对象，递归创建代理（懒代理，优化性能）</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">'object'</span> &amp;&amp; value !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">reactive</span>(value);
      }
      <span class="hljs-keyword">return</span> value;
    },
    <span class="hljs-comment">// 拦截属性赋值</span>
    <span class="hljs-title function_">set</span>(<span class="hljs-params">target, key, value, receiver</span>) {
      <span class="hljs-comment">// 1. 先设置原始属性值</span>
      <span class="hljs-keyword">const</span> oldValue = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, key, receiver);
      <span class="hljs-keyword">const</span> success = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, key, value, receiver);
      <span class="hljs-comment">// 2. 若值发生变化，触发依赖更新</span>
      <span class="hljs-keyword">if</span> (success &amp;&amp; oldValue !== value) {
        <span class="hljs-title function_">trigger</span>(target, key);
      }
      <span class="hljs-keyword">return</span> success;
    },
    <span class="hljs-comment">// 拦截属性删除</span>
    <span class="hljs-title function_">deleteProperty</span>(<span class="hljs-params">target, key</span>) {
      <span class="hljs-keyword">const</span> success = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">deleteProperty</span>(target, key);
      <span class="hljs-keyword">if</span> (success) {
        <span class="hljs-title function_">trigger</span>(target, key); <span class="hljs-comment">// 删除属性也触发更新</span>
      }
      <span class="hljs-keyword">return</span> success;
    }
  });
}
</code></pre>
<ul>
<li>用 <code>Reflect</code> 操作原始对象，Reflect 是 ES6 新增的内置对象，提供了与 Proxy 陷阱对应的方法，比如 <code>Relect.get</code>、<code>Reflect.set</code> 确保操作原始对象的行为一直，同时避免直接操作 target 所产生的问题</li>
<li>嵌套对象懒代理：Proxy 仅代理当前层级对象，当访问嵌套对象 （proxy.user.name）时，才递归对 user 对象创建代理，避免初始化时递归遍历所有属性，优化性能</li>
</ul>
<h4 data-id="heading-18">2. 依赖收集</h4>
<p>Vue3 用「三层映射」存储依赖，确保精准定位</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// WeakMap：key 是被代理的原始对象（target），value 是该对象的属性-依赖映射</span>
<span class="hljs-keyword">const</span> targetMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>();

<span class="hljs-keyword">function</span> <span class="hljs-title function_">track</span>(<span class="hljs-params">target, key</span>) {
  <span class="hljs-comment">// 1. 若没有当前目标对象的映射，创建一个（Map：key 是属性名，value 是依赖集合）</span>
  <span class="hljs-keyword">if</span> (!targetMap.<span class="hljs-title function_">has</span>(target)) {
    targetMap.<span class="hljs-title function_">set</span>(target, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>());
  }
  <span class="hljs-keyword">const</span> depsMap = targetMap.<span class="hljs-title function_">get</span>(target);

  <span class="hljs-comment">// 2. 若没有当前属性的依赖集合，创建一个（Set：存储依赖函数，去重）</span>
  <span class="hljs-keyword">if</span> (!depsMap.<span class="hljs-title function_">has</span>(key)) {
    depsMap.<span class="hljs-title function_">set</span>(key, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>());
  }
  <span class="hljs-keyword">const</span> deps = depsMap.<span class="hljs-title function_">get</span>(key);

  <span class="hljs-comment">// 3. 将当前活跃的依赖函数（effect）添加到集合中</span>
  <span class="hljs-keyword">if</span> (activeEffect) {
    deps.<span class="hljs-title function_">add</span>(activeEffect);
  }
}
</code></pre>
<p>会产生一个这样的结构</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
	<span class="hljs-string">""</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<h4 data-id="heading-19">3. 数据修改（触发 set/deleteProperty 的陷阱）</h4>
<p>当通过代理对象修改属性（如 <code>proxy.name = 'newName'</code>）或删除属性（如 <code>delete proxy.age</code>）时，会触发对应的 Proxy 陷阱（<code>set</code> 或 <code>deleteProperty</code>）。</p>
<p>陷阱函数会先更新原始对象的属性值，再判断值是否真的发生变化（避免无效更新）</p>
<h4 data-id="heading-20">4. 触发更新 （tigger 函数）</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">trigger</span>(<span class="hljs-params">target, key</span>) {
  <span class="hljs-comment">// 1. 从 targetMap 中获取当前对象的属性-依赖映射</span>
  <span class="hljs-keyword">const</span> depsMap = targetMap.<span class="hljs-title function_">get</span>(target);
  <span class="hljs-keyword">if</span> (!depsMap) <span class="hljs-keyword">return</span>;

  <span class="hljs-comment">// 2. 获取当前属性的所有依赖</span>
  <span class="hljs-keyword">const</span> deps = depsMap.<span class="hljs-title function_">get</span>(key);
  <span class="hljs-keyword">if</span> (!deps) <span class="hljs-keyword">return</span>;

  <span class="hljs-comment">// 3. 执行所有依赖函数（触发更新）</span>
  deps.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">effect</span> =&gt;</span> <span class="hljs-title function_">effect</span>());
}
</code></pre>
<h3 data-id="heading-21">2. Proxy 不做的事情</h3>
<ul>
<li>不计算表达式（比如 user.name + "后缀"的结果，Proxy 不管）</li>
<li>不操作 UI（不管是 DOM 和 Native 控件，Proxy 都不碰）</li>
<li>不跨端通信</li>
</ul>
<p>为什么 Native 组件不能让 Proxy “解决”？</p>
<p>核心矛盾：渲染载体不同。Proxy 之所以在 Web 端能 “间接驱动 UI”，是因为 Web 端有个「中间桥梁」—— DOM，且 JS 端有完整的 DOM API（比如 <code>document.getElementById</code>、<code>element.style.setProperty</code>）：</p>
<p>Web 端完整链路：Proxy 触发更新 → Vue 运行时计算表达式 → 虚拟 DOM diff → 调用 DOM API 操作 DOM → UI 更新</p>
<ul>
<li><strong>JS 端没有操作 Native 控件的 API</strong>：浏览器给 JS 暴露了 DOM API，但 iOS/Android 系统不会给 JS 引擎暴露 “修改 <code>UILabel</code> 文本”“设置 <code>UIImageView</code> 图片” 的 API —— JS 端连 Native 控件的 “引用” 都拿不到，更别说更新了；</li>
<li><strong>Native 控件不在 JS 运行时的内存空间</strong>：JS 引擎（如 V8、JSC）和 Native 应用是两个独立的 “进程 / 虚拟机”，内存不共享 —— Proxy 所在的 JS 内存里，根本没有 Native 控件的实例，想操作都无从下手</li>
</ul>
<p>Weex 的设计优雅之处在于：Native 托管“执行层”，Proxy 保留“触发层”。响应式工作继续复用现有逻辑，由 Proxy 完成，最后的执行层由 Native 实现，也就是 WXComponent+DataBinding</p>
<ul>
<li><strong>响应式系统（Proxy）的核心是 “发现变化”</strong>：不管是 Web 还是 Weex，Proxy 都只干这件事；</li>
<li><strong>UI 更新的核心是 “操作渲染载体”</strong>：Web 端操作 DOM（JS 端能做），Weex 端操作 Native 控件（只能 Native 端做）；</li>
<li><strong>WXComponent+DataBinding 的角色是 “Native 端的 UI 执行器”</strong>：它不是替代 Proxy，而是 Proxy 触发更新后，负责把 “更新通知” 落地到 Native 控件上的唯一途径</li>
</ul>
<h2 data-id="heading-22">六、Weex 自定义组件是如何工作的</h2>
<p>上面分析了自定义组件的数据变化和表达式运算是 Native 负责的，执行层也就是 <code>WXComponent+DataBinding.mm</code> 这个类。</p>
<p>一言以蔽之就是：把 JS 端传递的“原始数据”，通过预编译的绑定规则（Block）计算出 Native 组件需要的最终值，并自动更新 UI 组件，同时适配长列表组件等复杂场景的 UI 优化。</p>
<p>该分类为所有继承自 WXComponent 的组件，注入“数据绑定能力”，无需手动实现。</p>
<h3 data-id="heading-23">1. 绑定规则的“编译存储”，把 JS 表达式转换为 Native 可执行的 block</h3>
<p>数据绑定的「前置准备」：在组件初始化时，解析 JS 端传递的绑定规则（如 <code>[[user.name]]</code>、<code>[[repeat]]</code>），编译为 Native 可执行的 <code>WXDataBindingBlock</code>（代码块），并存储到组件的绑定映射表中（<code>_bindingProps/_bindingStyles/_bindingEvents</code> 等）</p>
<pre><code class="hljs language-objective-c" lang="objective-c">- (void)_storeBindingsWithProps:(NSDictionary *)props styles:(NSDictionary *)styles attributes:(NSDictionary *)attributes events:(NSDictionary *)events;
</code></pre>
<p>接收组件的 props/attrbutes/styles/events 中的绑定规则，解析并存储为可执行的 block。</p>
<ol>
<li><strong>识别绑定表达式</strong>：判断是否包含 <code>WXBindingIdentify</code>（<code>@"@binding"</code>）标记，比如 <code>{"src": {"@binding": "user.name"}}</code>；</li>
<li><strong>AST 解析</strong>：通过 <code>WXJSASTParser</code> 把绑定表达式字符串（如 <code>"user.name + '后缀'"</code>）解析为 AST 节点（<code>WXJSExpression</code>）；</li>
<li><strong>生成执行 Block</strong>：调用 <code>-bindingBlockWithExpression:</code> 把 AST 节点转成 <code>WXDataBindingBlock</code>（后续数据变化时直接执行该 Block 计算结果）；</li>
<li>分类存储：按绑定类型（属性 / 样式 / 事件 / 特殊绑定）存入对应的映射表：
<ul>
<li><code>_bindingProps</code>：属性绑定（如 <code>src</code>）；</li>
<li><code>_bindingStyles</code>：样式绑定（如 <code>fontSize</code>）；</li>
<li><code>_bindingEvents</code>：事件绑定（如 <code>onClick</code> 参数）；</li>
<li>特殊绑定：<code>_bindingRepeat</code>（<code>[[repeat]]</code> 对应 <code>v-for</code>）、<code>_bindingMatch</code>（<code>[[match]]</code> 对应 <code>v-if</code>）、<code>_dataBindOnce</code>（<code>[[once]]</code> 对应 <code>v-once</code>）。</li>
</ul>
</li>
</ol>
<h3 data-id="heading-24">2. WXComponentManager 都做了什么</h3>
<p><code>WXComponentManager</code> 是 Weex iOS 端的 <strong>组件全生命周期与任务调度核心</strong>，所有与 Native 组件相关的操作（创建、更新、布局、销毁、事件绑定）都由它统一管理，同时承担「线程分工协调、UI 任务批量处理、性能监控」等关键职责，是连接 JS 指令、Native 组件、布局引擎和 UI 渲染的 “中枢大脑”。</p>
<h4 data-id="heading-25">1. 组件线程管理</h4>
<p>组件业务的 “专属执行环境”，作为组件线程的「创建者和维护者」，<code>WXComponentManager</code> 确保所有组件核心操作都在<strong>全局唯一的组件线程</strong>中执行，避免线程安全问题和主线程阻塞。</p>
<p>核心工作：</p>
<ul>
<li>懒加载创建全局组件线程（<code>+componentThread</code>），启动 RunLoop 确保线程常驻（<code>_runLoopThread</code>）</li>
<li>提供线程调度接口：<code>WXPerformBlockOnComponentThread</code>（异步）、<code>WXPerformBlockSyncOnComponentThread</code>（同步），让外部模块（如 <code>WXBridgeManager</code>）能将组件任务提交到组件线程</li>
<li>线程断言约束：所有组件核心方法（如 <code>createBody</code>、<code>updateStyles</code>）开头都有 <code>WXAssertComponentThread</code>，强制组件操作在组件线程执</li>
</ul>
<h4 data-id="heading-26">2. 组件树构建与管理：组件的 “增删改查” 全生命周期</h4>
<p>核心工作：</p>
<ul>
<li>创建组件
<ul>
<li>根组件创建（<code>createBody:</code>）：接收 JS 端根组件指令，创建页面根组件（如 <code>&lt;div&gt;</code> 根节点），绑定到页面根视图；</li>
<li>子组件创建（<code>addComponent:type:parentRef:</code>）：根据 JS 端指令，创建子组件并关联父组件，存入 <code>_indexDict</code>（组件 ref → 实例映射，快速查找）。</li>
</ul>
</li>
<li>更新组件关系
<ul>
<li>移动组件（<code>moveComponent:toSuper:atIndex:</code>）：调整组件在组件树中的位置，同步更新视图层级；</li>
<li>删除组件（<code>removeComponent:</code>）：从组件树和索引字典中移除组件，递归删除子组件，释放视图资源。</li>
</ul>
</li>
<li>组件查询与遍历
<ul>
<li>按 ref 查找组件（<code>componentForRef:</code>）：供 JS 端 <code>this.$refs</code> 访问原生组件实例；</li>
<li>遍历组件树（<code>enumerateComponentsUsingBlock:</code>）：支持递归遍历所有组件（如性能统计、全局样式更新）</li>
</ul>
</li>
</ul>
<h4 data-id="heading-27">3.  数据绑定辅助：绑定规则的提取与存储</h4>
<p>配合 <code>WXComponent+DataBinding</code> 模块，<code>WXComponentManager</code> 在组件创建时，从 JS 端传递的 <code>props</code>/<code>styles</code>/<code>attributes</code> 中提取「绑定表达式配置」，为响应式更新铺路。核心工作：</p>
<ul>
<li>提取绑定规则：
<ul>
<li><code>_extractBindings:</code>：从样式 / 属性中提取 <code>[[repeat]]</code>/<code>{"@binding": "expr"}</code> 等绑定配置，移除原始字典中的绑定字段（避免干扰普通属性处理）</li>
<li><code>_extractBindingEvents:</code>：从事件数组中提取绑定参数（如 <code>onClick</code> 的回调表达式）；</li>
<li><code>_extractBindingProps:</code>：提取组件自定义 props 绑定（<code>@componentProps</code>）。</li>
</ul>
</li>
<li>存储绑定规则：调用组件的 <code>_storeBindingsWithProps:styles:attributes:events:</code>，将提取的绑定配置存入组件实例，后续数据变化时触发表达式计算。</li>
</ul>
<h4 data-id="heading-28">4. 组件更新调度：样式 / 属性 / 事件的 “同步与执行”</h4>
<p>当 JS 端触发组件更新（如修改样式、属性、绑定事件）时，<code>WXComponentManager</code> 负责「跨线程调度、数据预处理、UI 同步」，确保更新流程高效且安全。</p>
<ul>
<li>样式更新（<code>updateStyles:forComponent:</code>）
<ul>
<li>组件线程：过滤无效样式（如空值），更新组件实例的样式数据，触发布局计算；</li>
<li>主线程：通过 <code>_addUITask</code> 将样式更新任务（如设置 <code>CALayer.backgroundColor</code>、<code>UILabel.font</code>）批量调度到主线程执行。</li>
</ul>
</li>
<li><strong>属性更新（<code>updateAttributes:forComponent:</code>）</strong>：类似样式更新，组件线程处理数据逻辑，主线程更新原生组件属性（如 <code>UIImageView.image</code>、<code>UIScrollView.contentOffset</code>）。</li>
<li>事件绑定 / 解绑
<ul>
<li>组件线程：维护组件的事件列表（如 <code>click</code>/<code>scroll</code>）；</li>
<li>主线程：绑定 / 移除原生手势识别器（如 <code>UITapGestureRecognizer</code>），捕获用户交互。</li>
</ul>
</li>
<li><strong>批量更新优化</strong>：通过 <code>performBatchBegin</code>/<code>performBatchEnd</code> 标记批量更新范围，合并多个 UI 任务，减少主线程调度次数（提升性能）。</li>
</ul>
<h4 data-id="heading-29">5. 布局调度与 UI 同步：从布局计算到 UI 渲染</h4>
<p>Weex 采用 Flex 布局引擎（Yoga），<code>WXComponentManager</code> 负责布局计算的触发、组件 frame 分配、UI 任务批量执行，确保组件按预期位置渲染。</p>
<ul>
<li>触发布局计算：组件更新、根视图尺寸变化（<code>rootViewFrameDidChange:</code>）时，调用 <code>_layoutAndSyncUI</code> 触发 <code>WXCoreBridge</code> 执行 Yoga 布局计算，得到所有组件的 frame。</li>
<li>分配组件 frame：<code>layoutComponent:frame:isRTL:innerMainSize:</code> 将计算后的 frame 分配给组件，若为根组件，同步更新页面根视图尺寸（适配 <code>wrap_content</code> 模式）。</li>
<li>UI 任务同步：<code>_syncUITasks</code> 批量执行 <code>_uiTaskQueue</code> 中的 UI 任务（如 <code>addSubview</code>、<code>setFrame</code>），异步调度到主线程，避免频繁主线程切换导致掉帧。</li>
<li>帧率同步：通过 <code>WXDisplayLinkManager</code> 监听屏幕刷新率（60fps），确保布局更新与帧率同步，提升渲染流畅度。</li>
</ul>
<h4 data-id="heading-30">6. 生命周期与资源释放：页面卸载时的 “清理工作”</h4>
<p>当 Weex 页面销毁（<code>WXSDKInstance</code> 卸载）时，<code>WXComponentManager</code> 负责清理组件资源，避免内存泄漏。</p>
<p>核心工作（<code>unload</code> 方法）：</p>
<ul>
<li>停止布局调度：调用 <code>_stopDisplayLink</code>，停止帧率监听和布局计算；</li>
<li>解绑渲染资源：遍历所有组件，解除与底层渲染对象（<code>RenderObject</code>）的绑定；</li>
<li>释放 UI 资源：调度到主线程，销毁所有组件的原生视图（<code>_unloadViewWithReusing:</code>）；</li>
<li>清空状态：清空 <code>_indexDict</code>、<code>_uiTaskQueue</code>、<code>_fixedComponents</code> 等容器，解除与 <code>WXSDKInstance</code>的绑定。</li>
<li>清除事件绑定：清除所有的事件、手势等逻辑</li>
</ul>
<h2 data-id="heading-31">七、WXModule 的注册机制及其调用流程</h2>
<pre><code class="hljs language-mermaid" lang="mermaid">sequenceDiagram
    participant JS as JS环境
    participant B as WXBridge
    participant MF as WXModuleFactory
    participant MM as WXModuleManager
    participant MI as Module实例
    participant MC as 自定义Module

    Note over JS,MC: 注册阶段
    MC-&gt;&gt;+MF: registerModule("customModule", MyModule.class)
    MF-&gt;&gt;MF: 生成ModuleFactory并缓存
    MF-&gt;&gt;MF: 反射解析@JSMethod方法
    MF-&gt;&gt;B: 将模块&amp;方法信息传递给JS

    Note over JS,MC: 调用阶段
    JS-&gt;&gt;+B: weex.requireModule('customModule').myMethod(args)
    B-&gt;&gt;+MM: 调用 invokeModuleMethod
    MM-&gt;&gt;+MF: 获取Module实例和方法Invoker
    MF-&gt;&gt;MF: 查找/创建Module实例
    MF-&gt;&gt;MF: 获取方法Invoker
    MF-&gt;&gt;MM: 返回实例和Invoker
    MM-&gt;&gt;+MI: 通过Invoker.invoke调用
    MI-&gt;&gt;+MC: 执行原生方法实现
    MC-&gt;&gt;JS: 通过callback回调JS（可选）
</code></pre>
<h3 data-id="heading-32">1. WXModule 的注册分为 Naitve 注册和 JS 注册</h3>
<ul>
<li><strong>Native 注册</strong>：在 Native 端，调用 <code>[WXSDKEngine registerModule:withClass:]</code> 方法（在 iOS 中） ，这个过程会将自定义 Module 的类和一个模块名称（例如 <code>TestModule</code>）建立映射关系，并生成一个 <code>ModuleFactory</code> 存储在一个全局的 Map（例如 <code>sModuleFactoryMap</code>）中。同时，如果该 Module 被标记为全局（global），SDK 会立即创建一个实例并缓存起来。</li>
<li><strong>JS 注册</strong>：Native 注册完成后，Weex 会将所有已注册 Module 的<strong>模块名称</strong>及其<strong>暴露给 JS 的方法名列表</strong>，通过 <code>WXBridge</code>（JS-Native 通信桥梁）传递给 JS 引擎。这样，JS 端就知道存在哪些模块以及每个模块有哪些方法可以调用。</li>
</ul>
<h3 data-id="heading-33">2. 当 JS 调用 Module 方法时</h3>
<ul>
<li>JS 发起调用：在 JS 代码中，通过 <code>weex.requireModule('moduleName')</code> 获取模块实例 。然后吊影其方法，比如 'staream.fetch()options, callack)'</li>
<li>Bridge 桥接：JS 引擎通过 JSBridge 将这次调用（包括模块名、方法名、参数等信息）传递给 Native 段</li>
<li>Native 端查找与执行：Native 端的 WXModuleManager 根据模块名从之前注册的工厂中获取创建的 Module 实例，并根据方法名找到对应的 MethodInvoker。MethodInvoker 会通过反射手段调用具体的 Native 方法</li>
<li>结果回调：如果有需要，Native 可以通过 WXModuleCallBack 或者 WXModuleKeepAliveCallBack 将结果回调给 JS。WXModuleCallback 只能回调1次，而 WXModuleKeepAliveCallback 可以多次回调</li>
</ul>
<h3 data-id="heading-34">3. WXModuleProtocol 的作用</h3>
<p><strong><code>WXModuleProtocol</code> 是一个协议，定义了 Module 的行为规范</strong>。你的自定义 Module 必须遵循此协议。它声明了 Module 需要实现的方法或属性，例如如何暴露方法给 JS（通过 <code>WX_EXPORT_METHOD</code> 宏）、方法在哪个线程执行（通过实现特定的方法返回目标线程，例如 <code>targetExecuteThread</code>）、以及如何通过 <code>weexInstance</code> 属性弱引用持有它的 WXSDKInstance 实例。
通过遵循 <code>WXModuleProtocol</code>，你自定义的 Module 就能被 Weex SDK 正确识别和调</p>
<h3 data-id="heading-35">4. WXModuleFactory 的作用</h3>
<ol>
<li><strong>存储配置</strong>：在注册阶段，它会缓存 Module 的配置信息，例如模块名和对应的工厂类（<code>WXModuleConfig</code>）。</li>
<li><strong>方法解析</strong>：通过反射，解析 Module 类中所有通过 <code>WX_EXPORT_METHOD</code> 或 <code>WX_EXPORT_METHOD_SYNC</code> 宏暴露的方法，并生成方法名与 <code>MethodInvoker</code>（封装了反射调用逻辑）的映射关系。</li>
<li>提供实例：当 JS 调用 Module 方法时，<code>WXModuleManager</code> 会通过 <code>WXModuleFactory</code> 根据模块名获取或创建 Module 实例，以及对应方法的 <code>MethodInvoker</code>。</li>
</ol>
<h2 data-id="heading-36">八、Weex 分为几个线程</h2>
<h3 data-id="heading-37">1. 主线程</h3>
<p>核心定位：应用的 UI 线程（与原生 App 主线程同源），负责 UI 渲染、用户交互响应，<strong>禁止耗时操作</strong>。</p>
<p>核心职责：</p>
<ul>
<li>承载 Weex 页面的 <strong>原生渲染容器</strong>（如 Android 的 <code>WXFrameLayout</code>、iOS 的 <code>WXSDKInstanceView</code>），执行视图布局、绘制、动画触发；</li>
<li>处理用户交互事件（点击、滑动、输入等），并将事件转发给 JS 线程（如需要 JS 逻辑响应时）；</li>
<li>执行原生模块的 <strong>主线程方法</strong>（通过 <code>@WXModuleAnnotation(runOnUIThread = true)</code> 标记的方法，如弹 Toast、更新 UI 的原生能力）；</li>
<li>接收 JS 线程下发的 <strong>UI 操作指令</strong>（如创建视图、修改样式、更新属性），并映射为原生视图操作；</li>
</ul>
<p><strong>关键约束</strong>：所有直接操作原生视图的逻辑必须在主线程执行，否则会导致 UI 错乱或崩溃</p>
<h3 data-id="heading-38">2. JS 线程</h3>
<p>核心定位：Weex 的 “业务逻辑线程”，独立于主线程，专门运行 JavaScript 代码，避免阻塞 UI。</p>
<p>核心职责：</p>
<ul>
<li>加载并执行 Weex 业务代码（<code>.we</code> 编译后的 JS bundle），包括 Vue/React 组件初始化、数据绑定、生命周期管理；</li>
<li>处理 JS 层面的业务逻辑（事件响应、数据计算、接口请求预处理）；</li>
<li>调用原生模块时，通过 <strong>JSBridge 转发请求</strong>（区分同步 / 异步，同步请求会短暂阻塞 JS 线程，需谨慎使用）；</li>
<li>生成 UI 操作指令（如 <code>createElement</code>、<code>updateStyle</code>），通过跨线程通信发送给主线程执行；</li>
<li>接收主线程转发的用户交互事件（如点击回调），执行对应的 JS 事件处理函数；</li>
</ul>
<p>关键优化**：最新版本中，JS 线程支持 <strong>Bundle 预加载</strong>、<strong>懒加载组件</strong>，减少启动耗时；同时通过 <code>JSContext</code>隔离多个 Weex 实例，避免线程内资源竞争。</p>
<h3 data-id="heading-39">3. 耗时线程</h3>
<h4 data-id="heading-40">1. 网络线程</h4>
<p>核心定位：Weex 框架封装的 <strong>专用网络线程</strong>（跨端统一调度），避免网络请求阻塞主线程或 JS 线程。</p>
<p>核心职责：</p>
<ul>
<li>处理 Weex 内置的网络请求（如 <code>weex.requireModule('stream')</code> 发起的 HTTP/HTTPS 请求）；</li>
<li>负责 JS Bundle 的下载（首次加载或更新时），支持断点续传、缓存管理；</li>
<li>处理网络请求的拦截、重试、超时控制（框架层统一实现，无需业务关心）；</li>
<li>将网络响应结果通过 JSBridge 回传给 JS 线程；</li>
</ul>
<p>设计亮点：与原生系统的网络库解耦，但对外暴露统一的 JS API，线程调度由框架内部管理，业务无需手动切换线程</p>
<h4 data-id="heading-41">2. 图片下载线程</h4>
<p>核心定位：专门处理 Weex 图片的异步加载、解码，避免占用主线程资源导致 UI 卡顿。</p>
<p>核心职责：</p>
<ul>
<li>加载网络图片、本地图片（通过 <code>img</code> 标签或 <code>weex.requireModule('image')</code>）；</li>
<li>图片解码、压缩（适配视图尺寸，减少内存占用）；</li>
<li>图片缓存管理（内存缓存 + 磁盘缓存，框架层统一维护）；</li>
<li>加载完成后，将图片 bitmap 提交到主线程渲染；</li>
</ul>
<p>iOS 侧图片加载线程的核心管理类是 <code>WXImageComponent</code>。</p>
<p>Weex 线程职责边界清晰：<strong>UI 操作归主线程，JS 逻辑归 JS 线程，耗时操作归工作线程 / 网络线程</strong>，避免跨线程直接操作资源</p>
<h2 data-id="heading-42">九、JS 和 Native 通信</h2>
<h3 data-id="heading-43">1. callJS 和 callNative</h3>


























<table><thead><tr><th>通信方向</th><th>发起方</th><th>接收方</th><th>核心目的</th><th>典型场景</th></tr></thead><tbody><tr><td><code>callNative</code></td><td>JS</td><td>Native</td><td>JS 调用 Native 的模块 / 组件接口</td><td>渲染组件、弹 Toast、获取设备信息</td></tr><tr><td><code>callJS</code></td><td>Native</td><td>JS</td><td>Native 触发 JS 的回调函数</td><td>组件事件回调（如按钮点击）、数据同步（如网络请求结果）</td></tr></tbody></table>
<p>两者的底层依赖 <strong>同一个 JS Bridge 通道</strong>，只是「发起方」和「数据格式」不同，Weex 已封装好统一的通信框架，开发者无需关心底层传输细节</p>
<h3 data-id="heading-44">2. callNative 实现</h3>
<p><code>callNative</code> 是 JS 主动调用 Native 接口的过程，核心流程：<strong>JS 构造标准化指令 → 序列化 JSON → 桥接通道发送 → Native 解析指令 → 执行对应接口 → 响应结果回传</strong>。</p>
<p>怎么样？是不是感觉似曾相识，早期做 Hybrid 的时候，JS 和 Native 的通信也是一样的流程，感兴趣的可以查看<a href="https://link.juejin.cn?target=.%2F1.44.md" target="_blank" title="./1.44.md" ref="nofollow noopener noreferrer">这篇文章</a>。</p>
<p>是的，通信要解决的问题一直不变，所以方案也不变。</p>
<h4 data-id="heading-45">1. 标准化指令格式</h4>
<p>为了让 Native 能统一解析，Weex 规定 <code>callNative</code> 的指令必须包含 4 个核心字段（JS 端构造）：</p>
<pre><code class="hljs language-json" lang="json">const callNative指令 = <span class="hljs-punctuation">{</span>
  module<span class="hljs-punctuation">:</span> <span class="hljs-string">"component"</span><span class="hljs-punctuation">,</span>    <span class="hljs-comment">// 模块名（如 component/modal/device）</span>
  method<span class="hljs-punctuation">:</span> <span class="hljs-string">"create"</span><span class="hljs-punctuation">,</span>       <span class="hljs-comment">// 方法名（如 create/toast/getInfo）</span>
  params<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>             <span class="hljs-comment">// 入参（如组件样式、Toast 内容）</span>
  callbackId<span class="hljs-punctuation">:</span> <span class="hljs-string">"cb_123"</span>    <span class="hljs-comment">// 回调 ID（用于 Native 回传结果）</span>
<span class="hljs-punctuation">}</span>;
</code></pre>
<ul>
<li><code>module</code> + <code>method</code>：定位 Native 端的具体接口（如 <code>modal.toast</code> 对应 Native 的「弹 Toast」接口）；</li>
<li><code>params</code>：JS 传递给 Native 的数据（需是 JSON 兼容类型）；</li>
<li><code>callbackId</code>：唯一标识当前请求，Native 执行完成后通过该 ID 找到对应的 JS 回调函数。</li>
</ul>
<h4 data-id="heading-46">2. JS 端实现</h4>
<p>JS 侧调用 Native 的核心是3个实例方法，对应3类场景</p>

























<table><thead><tr><th>方法名</th><th>用途</th><th>对应 Native 接口</th></tr></thead><tbody><tr><td><code>callModule</code></td><td>调用 Native 普通模块（如 <code>modal</code>/<code>storage</code>）</td><td><code>global.callNativeModule</code></td></tr><tr><td><code>callComponent</code></td><td>调用 Native 自定义组件方法</td><td><code>global.callNativeComponent</code></td></tr><tr><td><code>callDOM</code></td><td>调用 DOM 相关 Native 方法（如创建元素）</td><td><code>global.callAddElement</code> 等独立方法</td></tr></tbody></table>
<p>这3个方法都会通过 Native 注入的全局函数（global 上的方法）将调用传递给 Native 层</p>
<p>这3个方法在源码最后</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 调用 DOM 相关 Native 方法</span>
callDOM (action, args) {
  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>[action](<span class="hljs-variable language_">this</span>.<span class="hljs-property">instanceId</span>, args)
}

<span class="hljs-comment">// 调用 Native 自定义组件方法</span>
callComponent (ref, method, args, options) {
  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">componentHandler</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">instanceId</span>, ref, method, args, options)
}

<span class="hljs-comment">// 调用 Native 普通模块方法（最常用，对应原 callNative）</span>
callModule (<span class="hljs-variable language_">module</span>, method, args, options) {
  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">moduleHandler</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">instanceId</span>, <span class="hljs-variable language_">module</span>, method, args, options)
}
</code></pre>
<h5 data-id="heading-47">1. 普通模块调用 callModule → moduleHandler</h5>
<p><code>moduleHandler</code> 是普通模块调用的最终转发函数，源码中通过 <code>global.callNativeModule</code> 对接 Native：</p>
<pre><code class="hljs language-javascript" lang="javascript">proto.<span class="hljs-property">moduleHandler</span> = <span class="hljs-variable language_">global</span>.<span class="hljs-property">callNativeModule</span> ||
    (<span class="hljs-function">(<span class="hljs-params">id, <span class="hljs-variable language_">module</span>, method, args</span>) =&gt;</span>
      <span class="hljs-title function_">fallback</span>(id, [{ <span class="hljs-variable language_">module</span>, method, args }]))
</code></pre>
<ul>
<li>正常情况（客户端环境）：<code>global.callNativeModule</code> 是 <strong>Native 注入到 JS 全局的函数</strong>（iOS/Android 原生实现），直接接收 <code>instanceId</code>、模块名、方法名、参数，传递给 Native 层。</li>
<li>降级情况（无 Native 桥接）：调用 <code>fallback</code> 函数（初始化时由 <code>sendTasks</code> 参数传入，通常用于调试 / 模拟）。</li>
</ul>
<h5 data-id="heading-48">2. 自定义组件调用 callComponent → componentHandler</h5>
<p>逻辑与 <code>moduleHandler</code> 一致，对接 <code>global.callNativeComponent</code>：</p>
<pre><code class="hljs language-javascript" lang="javascript">proto.<span class="hljs-property">componentHandler</span> = <span class="hljs-variable language_">global</span>.<span class="hljs-property">callNativeComponent</span> ||
  (<span class="hljs-function">(<span class="hljs-params">id, ref, method, args, options</span>) =&gt;</span>
    <span class="hljs-title function_">fallback</span>(id, [{ <span class="hljs-attr">component</span>: options.<span class="hljs-property">component</span>, ref, method, args }]))
</code></pre>
<h5 data-id="heading-49">3. DOM 方法调用 callDOM → 独立全局函数映射</h5>
<p>DOM 相关的 Native 方法（如 <code>addElement</code>/<code>updateStyle</code>）被单独映射到 <code>global</code> 上的独立函数（而非统一的 <code>callNative</code>），源码通过 <code>init</code> 函数初始化映射：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 源码第 116-138 行：DOM 方法与 Native 全局函数的映射</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">init</span> () {
  <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">DOM_METHODS</span> = {
    <span class="hljs-attr">createFinish</span>: <span class="hljs-variable language_">global</span>.<span class="hljs-property">callCreateFinish</span>,
    <span class="hljs-attr">addElement</span>: <span class="hljs-variable language_">global</span>.<span class="hljs-property">callAddElement</span>, <span class="hljs-comment">// DOM 创建元素 → Native 的 callAddElement</span>
    <span class="hljs-attr">removeElement</span>: <span class="hljs-variable language_">global</span>.<span class="hljs-property">callRemoveElement</span>, <span class="hljs-comment">// DOM 删除元素 → Native 的 callRemoveElement</span>
    <span class="hljs-attr">updateAttrs</span>: <span class="hljs-variable language_">global</span>.<span class="hljs-property">callUpdateAttrs</span>, <span class="hljs-comment">// 更新属性 → Native 的 callUpdateAttrs</span>
    <span class="hljs-comment">// ... 其他 DOM 方法</span>
  }
  <span class="hljs-keyword">const</span> proto = <span class="hljs-title class_">TaskCenter</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>

  <span class="hljs-comment">// 给 TaskCenter 原型挂载 DOM 方法，直接调用 Native 注入的全局函数</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> name <span class="hljs-keyword">in</span> <span class="hljs-variable constant_">DOM_METHODS</span>) {
    <span class="hljs-keyword">const</span> method = <span class="hljs-variable constant_">DOM_METHODS</span>[name]
    proto[name] = method ?
      <span class="hljs-function">(<span class="hljs-params">id, args</span>) =&gt;</span> <span class="hljs-title function_">method</span>(id, ...args) : <span class="hljs-comment">// 正常情况：调用 Native 全局函数</span>
      <span class="hljs-function">(<span class="hljs-params">id, args</span>) =&gt;</span> <span class="hljs-title function_">fallback</span>(...) <span class="hljs-comment">// 降级情况</span>
  }
}
</code></pre>
<p>例如调用 <code>callDOM('addElement', args)</code> 时，最终会执行 <code>global.callAddElement(instanceId, ...args)</code>，直接对接 Native 的 DOM 模块。其实是注入到 JSContext 里的方法对象。</p>
<p>在 Weex 的 JS 运行环境中，<code>global</code> 是 <strong>JS 全局对象（Global Object）</strong>—— 它是所有 JS 代码的 “顶层容器”，所有未被定义在局部作用域的变量、函数，最终都会挂载到 <code>global</code> 上（类似浏览器环境的 <code>window</code>，Node.js 环境的 <code>global</code>）</p>
<p><strong>Native 向 JS 引擎的 “全局上下文” 注入 <code>callAddElement</code> 函数时，该函数会自动成为 <code>global</code> 对象的属性</strong>——JS 侧的 <code>global.callAddElement</code>，本质就是访问这个被 Native 注入到全局的函数。</p>
<p>QA：global 是什么？</p>
<p>是 JS 全局对象。不管是浏览器、Node.js 还是 Weex 的 JS 引擎（JavaScriptCore/QuickJS），都有一个 <strong>全局对象（Global Object）</strong>：</p>
<ul>
<li>它是 JS 运行环境的 “根”，所有全局变量、函数都是它的属性；</li>
<li>不同环境的全局对象名称不同：
<ul>
<li>浏览器环境：叫 <code>window</code>（比如 <code>window.alert</code>、<code>window.document</code>）；</li>
<li>Node.js 环境：叫 <code>global</code>（比如 <code>global.console</code>、<code>global.setTimeout</code>）；</li>
<li>Weex 环境：叫 <code>global</code>（因为 Weex 不依赖浏览器，没有 <code>window</code>，直接用 JS 引擎原生的全局对象 <code>global</code>）。</li>
</ul>
</li>
</ul>
<pre><code class="hljs language-objective-c" lang="objective-c">// WXJSCoreBridge.mm
- (void)registerCallAddElement:(WXJSCallAddElement)callAddElement
{
    id callAddElementBlock = ^(JSValue *instanceId, JSValue *ref, JSValue *element, JSValue *index, JSValue *ifCallback) {
        NSString *instanceIdString = [instanceId toString];
        WXSDKInstance *instance = [WXSDKManager instanceForID:instanceIdString];
        if (instance.unicornRender) {
            JSValueRef args[] = {instanceId.JSValueRef, ref.JSValueRef, element.JSValueRef, index.JSValueRef};
            [WXCoreBridge callUnicornRenderAction:instanceIdString
                                           module:"dom"
                                           method:"addElement"
                                          context:[JSContext currentContext]
                                             args:args
                                         argCount:4];
            return [JSValue valueWithInt32:0 inContext:[JSContext currentContext]];
        }

        NSDictionary *componentData = [element toDictionary];
        NSString *parentRef = [ref toString];
        NSInteger insertIndex = [[index toNumber] integerValue];
        if (WXAnalyzerCenter.isInteractionLogOpen) {
            WXLogDebug(@"wxInteractionAnalyzer : [jsengin][addElementStart],%@,%@",instanceIdString,componentData[@"ref"]);
        }
        return [JSValue valueWithInt32:(int32_t)callAddElement(instanceIdString, parentRef, componentData, insertIndex) inContext:[JSContext currentContext]];
    };
    
    _jsContext[@"callAddElement"] = callAddElementBlock;
}
</code></pre>
<p>在 js 侧是通过  TaskCenter.js 的 init 方法中定义的，存在映射关系， <code>addElement: global.callAddElement,</code></p>
<h3 data-id="heading-50">3. callJS 实现</h3>
<p><code>WXReactorProtocol</code> 协议：</p>
<ul>
<li>定义 Native 调用 JS 的「标准接口」（如触发回调、发送事件），不关心底层用哪种 JS 引擎（JavaScriptCore / 其他）；</li>
<li>具体的桥接类（如 <code>WXJSCoreBridge</code>）遵守这个协议，实现接口方法 —— 即使未来替换 JS 引擎，只要遵守协议，上层代码（如 Native 模块、组件）无需修改。</li>
</ul>
<pre><code class="hljs language-objective-c" lang="objective-c">
@class JSContext;

@protocol WXReactorProtocol &lt;NSObject&gt;

@required

/**
Weex should register a JSContext to reactor
*/
- (void)registerJSContext:(NSString *)instanceId;

/**
 Reactor execute js source
*/
- (void)render:(NSString *)instanceId source:(NSString*)source data:(NSDictionary* _Nullable)data;

- (void)unregisterJSContext:(NSString *)instanceId;

/**
 When js call Weex NativeModule, invoke callback function
 
 @param instanceId : weex instance id
 @param callbackId : callback function id
 @param args       : args
*/
- (void)invokeCallBack:(NSString *)instanceId function:(NSString *)callbackId args:(NSArray * _Nullable)args;

/**
Native event to js
 
@param instanceId :   instance id
@param ref        :   node reference
@param event      :   event type
@param args       :   parameters in event object
@param domChanges :  dom value changes, used for two-way data binding
*/
- (void)fireEvent:(NSString *)instanceId ref:(NSString *)ref event:(NSString *)event args:(NSDictionary * _Nullable)args domChanges:(NSDictionary * _Nullable)domChanges;

@end
</code></pre>
<p>Native 模块（Module)/组件(Component) 完成任务后 -&gt;  <code>WXBridgeManager.callBack(...)</code> → 构造 JS 脚本（调用 <code>TaskCenter.callback</code>） → <code>WXJSCoreBridge.executeJavascript(...)</code> → JS 引擎执行 → <code>TaskCenter.callback</code> 响应</p>
<p><code>WXJSCoreBridge</code> 本身不直接拼接回调脚本，而是提供 <code>executeJavascript:</code> 方法（源码第 102 行），作为 JS 脚本执行的底层入口；真正的脚本构造，在 <code>WXBridgeManager</code> 中</p>
<p>WXBridgeManager 事件回调</p>
<pre><code class="hljs language-javascript" lang="javascript">- (<span class="hljs-keyword">void</span>)<span class="hljs-attr">fireEvent</span>:(<span class="hljs-title class_">NSString</span> *)instanceId <span class="hljs-attr">ref</span>:(<span class="hljs-title class_">NSString</span> *)ref <span class="hljs-attr">type</span>:(<span class="hljs-title class_">NSString</span> *)type <span class="hljs-attr">params</span>:(<span class="hljs-title class_">NSDictionary</span> *)params
{
    [self <span class="hljs-attr">fireEvent</span>:instanceId <span class="hljs-attr">ref</span>:ref <span class="hljs-attr">type</span>:type <span class="hljs-attr">params</span>:params <span class="hljs-attr">domChanges</span>:nil];
}

- (<span class="hljs-keyword">void</span>)<span class="hljs-attr">fireEvent</span>:(<span class="hljs-title class_">NSString</span> *)instanceId <span class="hljs-attr">ref</span>:(<span class="hljs-title class_">NSString</span> *)ref <span class="hljs-attr">type</span>:(<span class="hljs-title class_">NSString</span> *)type <span class="hljs-attr">params</span>:(<span class="hljs-title class_">NSDictionary</span> *)params <span class="hljs-attr">domChanges</span>:(<span class="hljs-title class_">NSDictionary</span> *)domChanges
{
    [self <span class="hljs-attr">fireEvent</span>:instanceId <span class="hljs-attr">ref</span>:ref <span class="hljs-attr">type</span>:type <span class="hljs-attr">params</span>:params <span class="hljs-attr">domChanges</span>:domChanges <span class="hljs-attr">handlerArguments</span>:nil];
}
- (<span class="hljs-keyword">void</span>)<span class="hljs-attr">fireEvent</span>:(<span class="hljs-title class_">NSString</span> *)instanceId <span class="hljs-attr">ref</span>:(<span class="hljs-title class_">NSString</span> *)ref <span class="hljs-attr">type</span>:(<span class="hljs-title class_">NSString</span> *)type <span class="hljs-attr">params</span>:(<span class="hljs-title class_">NSDictionary</span> *)params <span class="hljs-attr">domChanges</span>:(<span class="hljs-title class_">NSDictionary</span> *)domChanges <span class="hljs-attr">handlerArguments</span>:(<span class="hljs-title class_">NSArray</span> *)handlerArguments
{
	   <span class="hljs-comment">// ...</span>
    <span class="hljs-title class_">WXCallJSMethod</span> *method = [[<span class="hljs-title class_">WXCallJSMethod</span> alloc] <span class="hljs-attr">initWithModuleName</span>:nil <span class="hljs-attr">methodName</span>:@<span class="hljs-string">"fireEvent"</span> <span class="hljs-attr">arguments</span>:[<span class="hljs-title class_">WXUtility</span> <span class="hljs-attr">convertContainerToImmutable</span>:args] <span class="hljs-attr">instance</span>:instance];
    [self <span class="hljs-attr">callJsMethod</span>:method];
}

- (<span class="hljs-keyword">void</span>)<span class="hljs-attr">callJsMethod</span>:(<span class="hljs-title class_">WXCallJSMethod</span> *)method
{
    <span class="hljs-keyword">if</span> (!method || !method.<span class="hljs-property">instance</span>) <span class="hljs-keyword">return</span>;
    
    __weak <span class="hljs-title function_">typeof</span>(self) weakSelf = self;
    <span class="hljs-title class_">WXPerformBlockOnBridgeThreadForInstance</span>(^(){
        <span class="hljs-title class_">WXBridgeContext</span>* context = method.<span class="hljs-property">instance</span>.<span class="hljs-property">useBackupJsThread</span> ? weakSelf.<span class="hljs-property">backupBridgeCtx</span> :  weakSelf.<span class="hljs-property">bridgeCtx</span>;
        [context <span class="hljs-attr">executeJsMethod</span>:method];
    }, method.<span class="hljs-property">instance</span>.<span class="hljs-property">instanceId</span>);
}
</code></pre>
<p>WXBridgeContext.m 代码如下：</p>
<pre><code class="hljs language-javascript" lang="javascript">- (<span class="hljs-keyword">void</span>)<span class="hljs-attr">executeJsMethod</span>:(<span class="hljs-title class_">WXCallJSMethod</span> *)method {    
   <span class="hljs-comment">// ...</span>
    [sendQueue <span class="hljs-attr">addObject</span>:method];
    [self <span class="hljs-attr">performSelector</span>:@<span class="hljs-title function_">selector</span>(_sendQueueLoop) <span class="hljs-attr">withObject</span>:nil];
}

- (<span class="hljs-keyword">void</span>)_sendQueueLoop {
    <span class="hljs-keyword">if</span> ([tasks count] &gt; <span class="hljs-number">0</span> &amp;&amp; execIns) {
        <span class="hljs-title class_">WXSDKInstance</span> * execInstance = [<span class="hljs-title class_">WXSDKManager</span> <span class="hljs-attr">instanceForID</span>:execIns];
        <span class="hljs-title class_">NSTimeInterval</span> start = <span class="hljs-title class_">CACurrentMediaTime</span>()*<span class="hljs-number">1000</span>;
        
        <span class="hljs-keyword">if</span> (execInstance.<span class="hljs-property">instanceJavaScriptContext</span> &amp;&amp; execInstance.<span class="hljs-property">bundleType</span>) {
            [self <span class="hljs-attr">callJSMethod</span>:@<span class="hljs-string">"__WEEX_CALL_JAVASCRIPT__"</span> <span class="hljs-attr">args</span>:@[execIns, [tasks copy]] <span class="hljs-attr">onContext</span>:execInstance.<span class="hljs-property">instanceJavaScriptContext</span> <span class="hljs-attr">completion</span>:nil];
        } <span class="hljs-keyword">else</span> {
            [self <span class="hljs-attr">callJSMethod</span>:@<span class="hljs-string">"callJS"</span> <span class="hljs-attr">args</span>:@[execIns, [tasks copy]]];
        }
        <span class="hljs-comment">// ...</span>
    }
}

- (<span class="hljs-keyword">void</span>)<span class="hljs-attr">callJSMethod</span>:(<span class="hljs-title class_">NSString</span> *)method <span class="hljs-attr">args</span>:(<span class="hljs-title class_">NSArray</span> *)args {
    <span class="hljs-keyword">if</span> (self.<span class="hljs-property">frameworkLoadFinished</span>) {
        [self.<span class="hljs-property">jsBridge</span> <span class="hljs-attr">callJSMethod</span>:method <span class="hljs-attr">args</span>:args];
    } <span class="hljs-keyword">else</span> {
        [_methodQueue <span class="hljs-attr">addObject</span>:@{@<span class="hljs-string">"method"</span>:method, @<span class="hljs-string">"args"</span>:args}];
    }
}
</code></pre>
<p>再到 WXJSCoreManager</p>
<pre><code class="hljs language-javascript" lang="javascript">- (<span class="hljs-title class_">JSValue</span> *)<span class="hljs-attr">callJSMethod</span>:(<span class="hljs-title class_">NSString</span> *)method <span class="hljs-attr">args</span>:(<span class="hljs-title class_">NSArray</span> *)args {
    <span class="hljs-title class_">WXLogDebug</span>(@<span class="hljs-string">"Calling JS... method:%@, args:%@"</span>, method, args);
    <span class="hljs-title class_">WXPerformBlockOnMainThread</span>(^{
        [[<span class="hljs-title class_">WXBridgeManager</span> sharedManager].<span class="hljs-property">lastMethodInfo</span> <span class="hljs-attr">setObject</span>:method ?: @<span class="hljs-string">""</span> <span class="hljs-attr">forKey</span>:@<span class="hljs-string">"method"</span>];
        [[<span class="hljs-title class_">WXBridgeManager</span> sharedManager].<span class="hljs-property">lastMethodInfo</span> <span class="hljs-attr">setObject</span>:args ?: @[] <span class="hljs-attr">forKey</span>:@<span class="hljs-string">"args"</span>];
    });
    <span class="hljs-keyword">return</span> [[_jsContext globalObject] <span class="hljs-attr">invokeMethod</span>:method <span class="hljs-attr">withArguments</span>:[args copy]];
}
</code></pre>
<p>其实不管是 CallJS 还是 CallNative，通信的技术方案设计和 Hybrid 的设计一致，都需要在 JavascriptCore 的 global 对象上挂载一个方法。比如 Native 注册了一个 WXComponent 之后，Weex 侧用 Vue 语法写完了个页面，呈现在用户手机上，用户点击页面上的按钮之后，Native 再将事件回调给 Weex 侧，Weex 再去处理后续逻辑。</p>
<h3 data-id="heading-51">4. WXAssertComponentThread 断言</h3>
<p><code>WXAssertComponentThread</code> 的核心作用是 <strong>强制约束组件相关操作在「组件专属线程」执行</strong>，本质是为了解决「线程安全」和「性能稳定性」问题</p>
<p>iOS 开发的核心线程规则是「UI 操作必须在主线程」，但 Weex 组件的工作流程（绑定解析、数据计算、布局计算、子组件管理）包含大量「非 UI 操作」—— 如果这些操作都在主线程执行，会阻塞主线程（比如长列表数据解析、复杂表达式计算），导致 UI 卡顿（比如滑动掉帧）</p>
<p>因此 Weex 设计了线程分工</p>

















<table><thead><tr><th>线程类型</th><th>负责的操作</th></tr></thead><tbody><tr><td>组件专属线程</td><td>绑定规则解析（<code>_storeBindings</code>）、表达式计算（<code>bindingBlockWithExpression</code>）、数据更新（<code>updateBindingData</code>）、布局计算（<code>calculateLayout</code>）</td></tr><tr><td>主线程</td><td>最终 UI 渲染（如 <code>UIImageView</code> 设图、<code>UILabel</code> 设文本）、子视图增删（<code>insertSubview</code>）</td></tr></tbody></table>
<h4 data-id="heading-52">1. 避免「线程安全问题」，防止崩溃 / 数据错乱</h4>
<p>组件的核心数据（如 <code>_bindingProps</code>、<code>_subcomponents</code>、<code>_flexCssNode</code>）都是「非线程安全的」（没有加锁保护）—— 如果多个线程同时读写这些数据，会导致：</p>
<ul>
<li>数据竞争：比如主线程读取 <code>_subcomponents</code> 遍历，组件线程同时修改 <code>_subcomponents</code>（增删子组件），导致数组越界崩溃；</li>
<li>数据不一致：比如组件线程更新 <code>_bindingProps</code> 的值，主线程同时读取该值用于 UI 更新，导致显示错误的旧值；</li>
<li>野指针：比如组件线程销毁子组件，主线程还在访问该子组件的 <code>view</code>。</li>
</ul>
<p>线程断言通过「强制所有组件核心操作在同一线程执行」，从根源上避免了这些跨线程问题 —— 同一时间只有一个线程操作组件数据，无需复杂锁机制（锁会降低性能）。</p>
<h4 data-id="heading-53">2. 简化调试，快速定位线程问题</h4>
<p>如果没有线程断言，跨线程操作组件可能导致「偶现崩溃」（比如 100 次操作出现 1 次），难以复现和排查（日志中看不到线程上下文）。而线程断言会在「违规线程调用时直接崩溃」，并明确提示「必须在组件线程执行」，开发者能立刻定位到违规代码（比如在主线程调用了 <code>updateBindingData</code>），大幅降低调试成本。</p>
<h4 data-id="heading-54">3. 保证操作顺序一致性</h4>
<p>组件的更新流程是「解析绑定 → 计算表达式 → 更新属性 → 布局计算 → UI 渲染」—— 这些步骤必须按顺序执行。如果分散在多个线程，可能出现「布局计算还没完成，UI 已经开始渲染」的情况（导致布局错乱）。组件专属线程保证了所有操作串行执行，顺序不会乱。</p>
<h3 data-id="heading-55">5. WXJSASTParser 的工作原理</h3>
<p><code>WXJSASTParser</code> 如何把表达式字符串解析为 AST 节点？</p>
<p><code>WXJSASTParser</code> 是 Weex 自定义的「轻量 JS 表达式解析器」—— 核心是「按 JS 语法规则，把字符串拆分为结构化的 AST 节点」，全程不依赖完整 JS 引擎（如 JSC/V8），只支持绑定表达式需要的基础语法（标识符、成员访问、二元运算等），兼顾性能和体积。</p>
<p>整个解析过程分 3 步：<strong>词法分析 → 语法分析 → AST 节点封装</strong>，和编译器的前端流程一致，以下结合示例（<code>"user.name + '?size=100'"</code>）拆解：</p>
<p>先明确：AST 是什么？</p>
<p>AST（抽象语法树）是「用树形结构表示代码语法」的中间结构 —— 比如表达式 <code>user.name + '?size=100'</code>，AST 会拆分为：</p>
<pre><code class="hljs language-shell" lang="shell">根节点：BinaryExpression（运算符 '+'）
├─ 左子节点：MemberExpression（成员访问）
│  ├─ object：Identifier（标识符 'user'）
│  └─ property：Identifier（标识符 'name'）
└─ 右子节点：StringLiteral（字符串字面量 '?size=100'）
</code></pre>
<p>这种结构能被程序快速遍历和计算（比如之前讲的生成 <code>WXDataBindingBlock</code> 时，递归遍历节点执行运算）。</p>
<h4 data-id="heading-56">1.词法分析（Lexical Analysis）</h4>
<p>拆分为词法单元（Token）。词法分析是「把表达式字符串拆分为最小的、有意义的语法单元」，忽略空格、换行等无关字符。核心是「按 JS 语法规则匹配字符序列」。</p>
<p><code>表达式 </code>"user.name + '?size=100'"` 词法分析后得到的 Token 序列：</p>



































<table><thead><tr><th>Token 类型</th><th>Token 值</th><th>说明</th></tr></thead><tbody><tr><td><code>IDENTIFIER</code></td><td><code>user</code></td><td>标识符（变量名 / 属性名）</td></tr><tr><td><code>DOT</code></td><td><code>.</code></td><td>成员访问运算符</td></tr><tr><td><code>IDENTIFIER</code></td><td><code>name</code></td><td>标识符</td></tr><tr><td><code>PLUS</code></td><td><code>+</code></td><td>二元运算符（加法 / 拼接）</td></tr><tr><td><code>STRING_LITERAL</code></td><td><code>?size=100</code></td><td>字符串字面量（去掉引号）</td></tr></tbody></table>
<p>词法分析的实现逻辑（简化）：</p>
<ol>
<li>初始化一个「字符指针」，从表达式字符串开头遍历；</li>
<li>遇到字母 / 下划线 → 继续往后读，直到非字母 / 数字 / 下划线 → 识别为 <code>IDENTIFIER</code>（如 <code>user</code>）；</li>
<li>遇到 <code>+</code>/<code>-</code>/<code>*</code>/<code>/</code>/<code>&gt;</code>/<code>=</code> 等 → 识别为对应运算符（如 <code>+</code> → <code>PLUS</code>）；</li>
<li>遇到 <code>"</code> 或 <code>'</code> → 继续往后读，直到下一个相同引号 → 识别为 <code>STRING_LITERAL</code>（去掉引号）；</li>
<li>遇到 <code>.</code> → 识别为 <code>DOT</code>（成员访问）；</li>
<li>遇到空格 / 制表符 → 直接跳过（无意义字符）；</li>
<li>遇到无法识别的字符（如 <code>#</code>/<code>@</code>）→ 抛出语法错误（<code>WXLogError</code>）。</li>
</ol>
<p>Weex 的 <code>WXJSASTParser</code> 内部会维护一个「Token 流」（数组），词法分析后把 Token 按顺序存入流中，供下一步语法分析使用。</p>
<h4 data-id="heading-57">2. 语法分析（Syntactic Analysis）</h4>
<p>语法分析是「根据 JS 表达式语法规则，把 Token 流组合为树形 AST 节点」—— 核心是「验证 Token 序列是否符合语法，并构建层级关系」。</p>
<p>Weex 支持的 JS 表达式语法子集（核心）：</p>
<ul>
<li>标识符：<code>user</code>、<code>imageUrl</code>（对应 <code>WXJSIdentifier</code>）；</li>
<li>成员访问：<code>user.name</code>、<code>list[0]</code>（对应 <code>WXJSMemberExpression</code>）；</li>
<li>字面量：字符串（<code>'abc'</code>）、数字（<code>123</code>）、布尔（<code>true</code>）、null（对应 <code>WXJSStringLiteral</code>/<code>WXJSNumericLiteral</code> 等）；</li>
<li>二元运算：<code>a + b</code>、<code>age &gt; 18</code>、<code>a === b</code>（对应 <code>WXJSBinaryExpression</code>）；</li>
<li>条件运算：<code>age &gt; 18 ? 'adult' : 'teen'</code>（对应 <code>WXJSConditionalExpression</code>）；</li>
<li>数组表达式：<code>[a, b, c]</code>（对应 <code>WXJSArrayExpression</code>）。</li>
</ul>
<p>示例：Token 流 → AST 节点的构建过程</p>
<p>Token 流：<code>IDENTIFIER(user) → DOT → IDENTIFIER(name) → PLUS → STRING_LITERAL(?size=100)</code></p>
<ol>
<li>语法分析器先读取前 3 个 Token（<code>user</code> → <code>.</code> → <code>name</code>），匹配「成员访问语法规则」（<code>IDENTIFIER . IDENTIFIER</code>）→ 构建 <code>WXJSMemberExpression</code> 节点（左子节点 <code>user</code>，右子节点 <code>name</code>）；</li>
<li>接着读取 <code>PLUS</code>（二元运算符），再读取后面的 <code>STRING_LITERAL(?size=100)</code> → 匹配「二元运算语法规则」（<code>Expression + Expression</code>）；</li>
<li>把之前构建的 <code>WXJSMemberExpression</code> 作为「左子节点」，<code>STRING_LITERAL</code> 作为「右子节点」，<code>PLUS</code>作为「运算符」→ 构建根节点 <code>WXJSBinaryExpression</code>；</li>
<li>最终生成 AST 树（如之前的结构）。</li>
</ol>
<p>语法分析的实现逻辑（简化）：</p>
<p>Weex 采用「递归下降分析法」（最适合手工实现的语法分析方法）：</p>
<ol>
<li>为每种表达式类型定义一个「解析函数」（如 <code>parseMemberExpression</code> 解析成员访问、<code>parseBinaryExpression</code> 解析二元运算）；</li>
<li>解析函数递归调用：比如 <code>parseBinaryExpression</code> 会调用 <code>parseMemberExpression</code> 解析左右操作数，<code>parseMemberExpression</code> 会调用 <code>parseIdentifier</code> 解析标识符；</li>
<li>语法校验：如果 Token 序列不符合规则（如 <code>user.name +</code> 缺少右操作数），会抛出「语法错误」日志，终止解析。</li>
</ol>
<h4 data-id="heading-58">3. AST 节点封装</h4>
<p>转为 Weex 自定义的 <code>WXJSExpression</code>。语法分析生成的是「抽象语法树结构」，Weex 会把这个结构封装为自定义的 <code>WXJSExpression</code> 子类（对应不同表达式类型），每个子类存储该节点的关键信息（如运算符、子节点），供后续生成 <code>WXDataBindingBlock</code> 使用。</p>
<p>示例封装：</p>
<ul>
<li><code>WXJSMemberExpression</code> 类：存储 <code>object</code>（子节点，如 <code>user</code>）、<code>property</code>（子节点，如 <code>name</code>）、<code>computed</code>（是否是计算属性，如 <code>list[0]</code> 为 <code>YES</code>，<code>user.name</code> 为 <code>NO</code>）；</li>
<li><code>WXJSBinaryExpression</code> 类：存储 <code>left</code>（左子节点）、<code>right</code>（右子节点）、<code>operator_</code>（运算符字符串，如 <code>"+"</code>）；</li>
<li>字面量类（如 <code>WXJSStringLiteral</code>）：存储 <code>value</code>（字面量值，如 <code>?size=100</code>）。</li>
</ul>
<p>这些类的定义在 Weex 源码的 <code>WXJSASTParser.h</code> 中，本质是「数据容器」，把 AST 结构转化为 Objective-C 代码可访问的对象。</p>
<p><code>WXJSASTParser</code> 本质：它不是完整的 JS 解析器（不支持 <code>function</code>、<code>for</code> 等复杂语法），而是「专门为 Weex 绑定表达式设计的轻量解析器」—— 只解析需要的 JS 表达式子集，把字符串转为结构化的 AST 节点，最终目的是「让 Native 代码能递归遍历节点，计算出表达式结果」（如 <code>user.name + '?size=100'</code> → <code>avatar.png?size=100</code>）。</p>
<p>这种「自定义轻量解析器」的设计，既避免了依赖完整 JS 引擎的体积和性能开销，又能精准适配 Weex 的绑定需求，是跨端框架的常见优化思路。</p>
<h2 data-id="heading-59">十、值得借鉴的地方</h2>
<h3 data-id="heading-60">1. WXThreadSafeMutableDictionary 线程安全字典</h3>
<p>Weex 中的 WXThreadSafeMutableDictionary 提供了一个线程安全的字典，其本质是通过加 pthread_muext_t 锁来维护内部的一个字典的。
比如下面的代码</p>
<p>初始化锁相关的配置</p>
<pre><code class="hljs language-Objective-C" lang="Objective-C">@interface WXThreadSafeMutableDictionary ()
{
    NSMutableDictionary* _dict;
    pthread_mutex_t _safeThreadDictionaryMutex;
    pthread_mutexattr_t _safeThreadDictionaryMutexAttr;
}

@end

@implementation WXThreadSafeMutableDictionary

- (instancetype)initCommon
{
    self = [super init];
    if (self) {
        pthread_mutexattr_init(&amp;(_safeThreadDictionaryMutexAttr));
        pthread_mutexattr_settype(&amp;(_safeThreadDictionaryMutexAttr), PTHREAD_MUTEX_RECURSIVE); // must use recursive lock
        pthread_mutex_init(&amp;(_safeThreadDictionaryMutex), &amp;(_safeThreadDictionaryMutexAttr));
    }
    return self;
}

- (instancetype)init
{
    self = [self initCommon];
    if (self) {
        _dict = [NSMutableDictionary dictionary];
    }
    return self;
}
</code></pre>
<p>在字典操作的地方使用锁</p>
<pre><code class="hljs language-Objective-C" lang="Objective-C">- (void)setObject:(id)anObject forKey:(id&lt;NSCopying&gt;)aKey
{
    id originalObject = nil; // make sure that object is not released in lock
    @try {
        pthread_mutex_lock(&amp;_safeThreadDictionaryMutex);
        originalObject = [_dict objectForKey:aKey];
        [_dict setObject:anObject forKey:aKey];
    }
    @finally {
        pthread_mutex_unlock(&amp;_safeThreadDictionaryMutex);
    }
    originalObject = nil;
}
</code></pre>
<p>这么写的价值：<strong>解锁逻辑「绝对执行」，彻底避免死锁</strong>
这是 <code>@try-finally</code> 最核心的价值 ——无论 try 块内发生什么（正常执行、提前 return、抛异常），finally 块的解锁逻辑一定会执行</p>
<p>对比无 try-finally 的写法</p>
<pre><code class="hljs language-Objective-C" lang="Objective-C">// Bad: 若setObject抛异常，unlock不会执行→死锁
pthread_mutex_lock(&amp;_mutex);
[_dict setObject:anObject forKey:aKey];
pthread_mutex_unlock(&amp;_mutex); 
</code></pre>
<p>问题：<code>[_dict setObject:anObject forKey:aKey]</code> 可能抛异常（比如 aKey = nil 时会触发 NSInvalidArgumentException），若没有 finally，锁会被永久持有→其他线程调用 lock 时死锁，整个字典无法再操作。</p>
<p>设计优点：</p>
<ul>
<li><code>@try-finallly</code>：即使 try 内逻辑出错，finally 也会执行 pthread_mutex_unlock，保证锁最终释放，这是<strong>线程安全的「兜底保障」</strong></li>
<li>注意，不是 <code>try...catch...finally</code>: 如果加了 catch 逻辑，则字典的 key 为 nil 产生的崩溃也会被捕获掉，这属于不符合预期的行为。因为 key 为 nil 产生的原因太多了，可能是业务代码异常，也可能是数据异常，也可能是逻辑错误，如果一刀切直接用 <code>try...catch...finally</code> 捕获了异常，但是没有配置异常的收集、上报、处理逻辑，属于边界不清晰，本质是为了解决加解锁不匹配而可能带来的线程安全问题，却"多管闲事"，把字典 key 为 nil 本该向上跑的异常而卡住了（这个问题不再赘述，是一个经典的策略问题，端上的异常发生时，安全气垫的“做与不做”问题）</li>
</ul>
<p>延伸：聊聊类似网易的大白解决方案或者业界其他公司中，安全气垫虽然保证了代码不 crash，影响用户体验，但是比如数组本该越界，现在却不越界：</p>
<ol>
<li>唯一能做的就是返回一个错误的值，比如数组长度为3，访问4，现在不 crash，返回了 0 的值，那是不是产生了业务异常？比如商品价格</li>
<li>不 crash，也不返回错误位置的值，类似给一个回调，告诉业务方出现了异常，可以做一些业务层面的提醒或者配置(比如开发阶段商品卡片的价格 Label 显示：商品价格获取错误，数组越界)，同时产生的异常案发现场信息和其他的一些数据会上报，用于 APM 平台去分析和定位。</li>
</ol>
<p>但这也产生一个问题，类似数组越界的场景，可能10000次里面9999次都正常，只有1次异常，业务开发为了这万分之一出现的异常，还需要写一些异常处理的逻辑（比如商品卡片展示价格获取错误，数组越界）。那字典的 key 为 nil 呢？除法的分母为0呢？诸如此类，类似乐观锁和悲观锁的场景</p>
<p>相关问题的思考可以查看这篇文章：<a href="https://link.juejin.cn?target=.%2F1.148.md" target="_blank" title="./1.148.md" ref="nofollow noopener noreferrer">安全气垫</a></p>
<ul>
<li>WXHandlerFactory：Weex 核心的「处理器工厂」，负责管理所有协议（如图片加载、网络请求、存储等）的实现类注册 / 查找；</li>
<li>WXImgLoaderProtocol：Weex 定义的「图片加载协议」，仅声明接口（下载、取消、缓存等），不包含具体实现。</li>
</ul>
<p>Weex 支持业务层自定义图片加载逻辑（比如统一用项目的图片缓存库、添加下载拦截、埋点等），此时自定义实现类会替代默认实现，成为下载执行者：
步骤 1：业务层创建类（如 MyCustomImgLoader），遵循 WXImgLoaderProtocol，实现 wx_loadImageWithURL: 等协议方法（内部可调用 SDWebImage/AFNetworking 等完成下载）；
步骤 2：将自定义类注册到 WXHandlerFactory：</p>
<pre><code class="hljs language-Objective-C" lang="Objective-C">[WXHandlerFactory registerHandler:[MyCustomImgLoader new] forProtocol:@protocol(WXImgLoaderProtocol)];
</code></pre>
<p>步骤 3：此时 [WXHandlerFactory handlerForProtocol:@protocol(WXImgLoaderProtocol)] 会返回 MyCustomImgLoader 实例，所有图片下载由该类负责</p>
<h3 data-id="heading-61">2. 设计分层合理</h3>
<pre><code class="hljs language-mermaid" lang="mermaid">graph TD
    A[开发者编写的 .we/.vue 文件] --&gt; B[Transformer&lt;br/&gt;转换JS Bundle];
    B --&gt; C[JS Framework&lt;br/&gt;解析并管理Virtual DOM];
    C -- 通过JS Bridge发送渲染指令 --&gt; D[Native SDK&lt;br/&gt;渲染引擎];
    D --&gt; E[iOS/Android/Web 原生视图];
    
    C -- 支持多种DSL --&gt; F[Vue.js];
    C -- 支持多种DSL --&gt; G[Rax（类React）];
    D -- 原生能力扩展 --&gt; H[自定义Component];
    D -- 原生能力扩展 --&gt; I[自定义Module];
</code></pre>
<p>Weex 最核心的设计是将整个框架清晰地分为：<strong>语法层（DSL）</strong>、<strong>中间层（JS Framework）<strong>和</strong>渲染层（Native SDK）</strong></p>
<p>这种渲染引擎和语法层 DSL 分离的设计，可以使得上层 DSL 方便拓展 Vue、Rax 写法，下层渲染引擎可以保持较好的稳定性。为了生态的拓展提供了极大的便携性。</p>
<h3 data-id="heading-62">3. 可扩展的组件与模块系统</h3>
<p>Weex 通过<code>WXSDKEngine.registerComponent()</code> 和 <code>registerModule()</code> 方法，允许开发者扩展原生组件 （UI Component）和模块（Login Module）。这套机制设计得足够底层和通用，使得 Weex 可以由开发者来注册，由公司内的体验设计中心规范来落地的组件。以及一些基础能力。这样子 Weex 官方已经提供了一些功能强大的筋骨，我们在其之上可以提供更符合需求的外表和更有力量的一块手臂肌肉。</p>
<p>虽然事后视角来看，Weex、RN、Flutter，甚至是更早的、设计完善的 Hybrid 都有该能力。但这对于远古时期的 Weex 来说，还是可圈可点的。</p>
<h3 data-id="heading-63">4.  轻量 JSBundle + 增量更新支持</h3>
<p>Weex 的 JSBundle 仅包含业务逻辑和组件描述，框架代码（Vue 内核、Weex 基础 API）内置在原生 SDK 中，因此 Bundle 体积极小；同时支持将 Bundle 拆分为 “基础包（公共逻辑）+ 业务包（页面逻辑）”，实现增量更新。</p>
<p>解决了跨端框架 “首屏加载慢” 的痛点（小 Bundle 加载更快），同时增量更新降低了发布成本。</p>
<h2 data-id="heading-64">十一、Weex APM</h2>
<h3 data-id="heading-65">1. 历史背景</h3>
<p>Weex 是诸多年前的产物，部分业务线用 Weex 写了部分功能模块，或者是某几个页面，或者是某个二级、三级业务 SDK 的页面。但可以确定的是：</p>
<ul>
<li>21年就完成了 Flutter 的基建开发（对齐 Native 的 UI 组件库，遵循体验设计平台产出的集团 UI 标准；做了 Flutter 的大量 plugin、打包构建平台、日志库、网络库、探照灯、APM SDK、热修复能力等）。新业务的实现只会在 Native 和 Flutter 上考虑</li>
<li>Weex 业务代码基本上是存量的</li>
<li>Weex 代码没有 bug 就不去修改；有版本迭代，之前是 Weex 实现的，本次只做简单 UI 增删或字段调整，也是会修改一下。初次之外不修改 Weex 代码</li>
</ul>
<p>所以像 Native 一样去全面监控性能、网络、crash、异常、白屏、页面加载耗时等维度的话，ROI 是很低的。那么就需要制定一些策略去有针对性的监控高优问题。</p>
<p>Weex 的异常比较有特点，比如在页面的模版代码中绑定了 data 中的一个对象，此时对象可能并没有值，而是依赖后续的网络请求完成，对象才有了具体的值 data 改变，数据驱动，页面再次 render。所以监控代码会认为第一次 render 的时候访问对象不存在的属性。
真正有问题的代码和不影响业务的异常信息，都会被 Vue 官方认为是异常。基于这样的背景，我们无法 pick 出真正异常或者是开发者判空代码没写好的问题。基于此，我们需要做一些约定和标准。</p>
<h3 data-id="heading-66">2. 优先级权衡标准</h3>
<p>这时候就需要摒弃程序员视角（不然会陷入啥数据都想统计，可能是洁癖、可能是追求），但从 ROI 角度出发，我们就需要切换到用户视角。</p>
<p>假设你是一个用户，什么样的情况代表业务异常，对我们的用户来说比较痛呢？</p>
<ul>
<li>页面白屏了，看都看不到了，别说你们的 App 为我赋能解决用户痛点了</li>
<li>稍微好点，可以看到页面了，但是某一个区域是白屏的。比如：该页面大部分在展示商品价格、商品数量、商品折扣价、商品折扣信息、下面应该是有个“确认支付”按钮，但是此处就是空白，点也点不了。</li>
<li>情况再好点。可以看到全部的页面了，但是点击后无响应。比如：该页面大部分在展示商品价格、商品数量、商品折扣价、商品折扣信息、下面有个“确认支付”按钮。用户在考虑再三，本着理性购物后，发现是刚需品，咬紧牙要付款了，此时点击“确认支付”按钮了，但是页面没有任何反应。用户也是“见多识广”的体面人，猜测可能是网络不好的情况，所以等了1分钟，他很有耐心。切换了 WI-FI 到 5G 后，继续点击，依旧没反应。一怒之下点了10次，等了2分钟，还是没反应。他奔溃了，卸载了 App</li>
</ul>
<p>上述几种情况，总结为：按照异常等级，可以划分为影响业务和不影响业务。什么叫“影响业务”？这是我们自己定义的标准，影响用户是否正常操作 App。比如：页面白屏（页面全部白屏、页面部分白屏）、点击某个按钮无响应，这些叫做“影响业务”，属于 Error 级别。其他的一些轻微异常，不影响用户使用 App 功能，不影响业务，属于 Warning 级别。</p>
<h3 data-id="heading-67">3. UI 显示异常</h3>
<h4 data-id="heading-68">1. 部分白屏：注册的 Component 使用异常</h4>
<p>这种情况就属于页面部分白屏。因为某个哪个 Compoent 会铺满页面，基本类似 iOS UI 控件一样组合使用。就像上文描述的「该页面大部分在展示商品价格、商品数量、商品折扣价、商品折扣信息、下面应该是有个“确认支付”按钮，但是此处就是空白」这个空白粗，理应显示一个 Native 注册的 Button，但是没有显示出来，造成业务的阻塞。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a551c125b89945c492daac9ae8f28310~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p2t5Z-O5bCP5YiY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767925474&amp;x-signature=OD34iKcnKNSl9Au61CaChYwUsvs%3D" alt="WeexComponentRegisterError.png" loading="lazy"/>
.vue（或 Weex 专属.we）文件内基于 Vue 扩展的 Weex 跨平台模板 DSL 代码，在前端构建阶段会先由 Webpack 的weex-loader触发编译流程：首先通过 Weex 核心编译器@weex-cli/compiler（复用并扩展vue-template-compiler）将模板 DSL 解析为模板 AST（抽象语法树）；接着由 Weex 自定义 Babel 插件（如babel-plugin-transform-weex-template）将模板 AST 转换为标准化的 JS AST，并针对 iOS/Android 跨平台特性做属性、样式、事件的适配处理（如样式单位归一化、事件名标准化）；最终生成包含_h（即 Weex 运行时的$createElement，等价于 Vue 的createElement）调用的render函数，该函数会被 Webpack 打包到最终的 Weex JS Bundle 中。</p>
<pre><code class="hljs language-json" lang="json">_c('color-button'<span class="hljs-punctuation">,</span>
  <span class="hljs-punctuation">{</span>
    staticStyle<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
      width<span class="hljs-punctuation">:</span> <span class="hljs-string">"400px"</span><span class="hljs-punctuation">,</span>
      height<span class="hljs-punctuation">:</span> <span class="hljs-string">"40px"</span><span class="hljs-punctuation">,</span>
      marginBottom<span class="hljs-punctuation">:</span> <span class="hljs-string">"20px"</span>
    <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
    attrs<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"title"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"点击计算10+20"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"bgColor"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"#FF6600"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"message"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"hello"</span>
    <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
    on<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"click"</span><span class="hljs-punctuation">:</span> _vm.handleButtonClick
    <span class="hljs-punctuation">}</span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-comment">// 如果有 children 就是 children 信息</span>
)
</code></pre>
<p>在 App 运行阶段，Weex 的 JS 引擎（iOS 端为 JSCore、Android 端为 V8）加载 JS Bundle 后，执行组件的render函数，通过调用 <code>_h</code> 函数将模板描述转换为跨平台的虚拟 DOM（VNode），VNode 会被序列化为 JSON 格式，最终通过 JS Bridge 传递给 Native 端（iOS/Android）用于原生视图渲染。</p>
<p>Weex 的 Component 相关逻辑都由 <code>WXComponentManager</code> 负责。页面在构建展示的时候，会调用 <code>_buildComponent</code> 方法，其内部会调用 WXComponentFactory 的能力（<code>configWithComponentName</code>），根据 ComponentName 获取 Component。</p>
<p><code>configWithComponentName</code> 是 Weex iOS 侧 WXComponentFactory（组件工厂类）的核心方法之一，核心作用是：根据传入的组件名称（如 color-button/div/text），查找该组件对应的 Native 侧配置（WXComponentConfig）；若找不到对应配置，则降级使用基础容器组件 div 的默认配置，并输出警告日志。</p>
<pre><code class="hljs language-Objective-C" lang="Objective-C">- (WXComponentConfig *)configWithComponentName:(NSString *)name
{
    WXAssert(name, @"Can not find config for a nil component name");
    
    WXComponentConfig *config = nil;
    
    [_configLock lock];
    config = [_componentConfigs objectForKey:name];
    if (!config) {
        WXLogWarning(@"No component config for name:%@, use default config", name);
        config = [_componentConfigs objectForKey:@"div"];
    }
    [_configLock unlock];
    
    return config;
}
</code></pre>
<p>UI Component 做的比较随意，认为显示问题降级用 div 就可以了。做为 SDK 这么设计也似乎可以接受，但作为业务方，我们必须收集统计这种异常情况。
所以此处我们可以收集案发现场数据，进行上报。我们发现 Weex 自己封装了 <code>WXExceptionUtils</code>类，暴露了 <code>commitCriticalExceptionRT</code> 接口，用于收集致命问题。</p>
<pre><code class="hljs language-Objective-C" lang="Objective-C">+ (void)commitCriticalExceptionRT:(WXJSExceptionInfo *)jsExceptionInfo{
    
    WXPerformBlockOnComponentThread(^ {
        id&lt;WXJSExceptionProtocol&gt; jsExceptionHandler = [WXHandlerFactory handlerForProtocol:@protocol(WXJSExceptionProtocol)];
        if ([jsExceptionHandler respondsToSelector:@selector(onJSException:)]) {
            [jsExceptionHandler onJSException:jsExceptionInfo];
        }
        if ([WXAnalyzerCenter isOpen]) {
            [WXAnalyzerCenter transErrorInfo:jsExceptionInfo];
        }
    });
}
</code></pre>
<p>可以看到会判断是否存在可以处理 exception 遵循 WXJSExceptionProtocol 的 handler。所以我们新增一个 <code>WXExceptionReporter</code> 类（遵循 WXJSExceptionProtocol 协议），用于收集异常，然后用于统一的上报，内部提供基础数据的组装、字段解析功能。</p>
<p>效果如下：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ad9fc6690769433e8cefadb6cfb52f17~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p2t5Z-O5bCP5YiY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767925474&amp;x-signature=D%2FyuvCXgWZug8Q8IzvqDBppj2dg%3D" alt="WeexComponentBuildFlow.png" loading="lazy"/></p>
<h4 data-id="heading-69">2. 全部白屏</h4>
<p>根据 Weex 的工作原理可以知道，页面需要展示肯定要根据 url 去获取 JS Bundle 内容，然后解析成 VNode 最后通过 JSBridge 去调用 Native 的 UI Component 去展示 UI，那么整个流程几个重要的环节都可能出错，导致页面白屏。</p>
<h5 data-id="heading-70">1. 资源请求失败</h5>
<p>JS Bundle 资源请求失败，存在 Error，此时是无法去展示 Weex 页面的。这种情况就是 HTTP 状态码非200的情况。</p>
<p>每个 Weex 页面都由 WXSDKInstance 负责下载 JS Bundle 资源，所以下载的逻辑在 WXSDKInstance 里。</p>
<pre><code class="hljs language-Objective-C" lang="Objective-C">- (void)_renderWithRequest:(WXResourceRequest *)request options:(NSDictionary *)options data:(id)data; 
{
  _mainBundleLoader.onFinished = ^(WXResourceResponse *response, NSData *data) {

      NSError *error = nil;
      if ([response isKindOfClass:[NSHTTPURLResponse class]] &amp;&amp; ((NSHTTPURLResponse *)response).statusCode != 200) {
          error = [NSError errorWithDomain:WX_ERROR_DOMAIN
                                      code:((NSHTTPURLResponse *)response).statusCode
                                  userInfo:@{@"message":@"status code error."}];
          if (strongSelf.onFailed) {
              strongSelf.onFailed(error);
          }
      }
      
      if (error) {
          [WXExceptionUtils commitCriticalExceptionRT:strongSelf.instanceId
                                              errCode:[NSString stringWithFormat:@"%d", WX_KEY_EXCEPTION_JS_DOWNLOAD]
                                              function:@"_renderWithRequest:options:data:"
                                            exception:[NSString stringWithFormat:@"download bundle error :%@",[error localizedDescription]]
                                            extParams:nil];
          return;
      }

      if (!data) {
          NSString *errorMessage = [NSString stringWithFormat:@"Request to %@ With no data return", request.URL];
          WX_MONITOR_FAIL_ON_PAGE(WXMTJSDownload, WX_ERR_JSBUNDLE_DOWNLOAD, errorMessage, strongSelf.pageName);
          [WXExceptionUtils commitCriticalExceptionRT:strongSelf.instanceId
                                              errCode:[NSString stringWithFormat:@"%d", WX_KEY_EXCEPTION_JS_DOWNLOAD]
                                              function:@"_renderWithRequest:options:data:"
                                            exception:errorMessage
                                            extParams:nil];
          return;
      }
  };
}
</code></pre>
<p>模拟 JS Bundle 下载错误，效果如下：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8127cf21938140c0ae40a15a9a5a26b3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p2t5Z-O5bCP5YiY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767925474&amp;x-signature=r0g86JWgUX33NF7lfv3iwvOb%2B7E%3D" alt="WeexJSBundleDownloadFailed.png" loading="lazy"/></p>
<p>下载 JS Bundle 网络请求完成后，如果出现 Error，则会调用 WXExceptionUtils 的能力，将异常交给 <code>WXExceptionReporter</code> 去处理。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4f045d0177a8483b857901ad7520f993~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p2t5Z-O5bCP5YiY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767925474&amp;x-signature=RuNioiYspuc%2FThdWHk3%2BOyOUpZE%3D" alt="WeexJSBundleDownloadFailedAPM.png" loading="lazy"/></p>
<h5 data-id="heading-71">2. 资源请求成功，数据为空</h5>
<p>还有一种情况就是：**JSBundle 下载请求在 HTTP 层面 “成功完成”（状态码 200），但返回的二进制数据 data 为 nil 或空（长度为 0） **</p>
<p>可能你会好奇，怎么可能有空的 JSBundle，什么场景下会产生这种情况？
凡是正常写代码都符合预期就没有任何 bug 和故障了，所以利用悲观策略，将各种可能出现问题的地方都监控到，因为只要 JSBundle 为空，页面肯定是白屏，对于用户侧来说都是致命的。</p>
<ol>
<li>服务器/CDN 返回“空响应”：后端 / CDN 配置异常：请求的 JSBundle URL 有效，HTTP 状态码返回 200，但响应体（Body）为空（比如静态 JS 文件被删除、CDN 缓存失效且源站无数据、后端接口逻辑错误未写入响应内容）；</li>
<li>下载过程中数据传输截断 / 丢失</li>
</ol>
<ul>
<li>网络波动：下载请求已收到服务器的 “响应完成” 信号，但数据传输过程中因网络中断、超时等导致 NSData 未完整接收（仅 HTTP 头成功接收，体数据为空）；</li>
<li>Weex 加载器（mainBundleLoader）异常：加载器在将响应数据转为 NSData 时出现底层错误（如内存不足、数据解码失败），导致 data 被置为 nil。</li>
</ul>
<p>Mock：将 data 设为 nil。效果如下：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f7346ccdc0574cba97a9bd195bebbbd6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p2t5Z-O5bCP5YiY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767925474&amp;x-signature=3QAb3CTSFZfYP99pqlhWGR3V7mI%3D" alt="WeexJSBundleParseFailed.png" loading="lazy"/></p>
<p>可以看到 Weex 也会把这种错误进行收集，调用 <code>WXExceptionUtils commitCriticalExceptionRT</code>，所以我们添加的 Analyzer 是可以监控到这种异常的。
效果如下：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/03d2c52a165c4844a7a264724a02f71a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p2t5Z-O5bCP5YiY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767925474&amp;x-signature=dZM6FItKQRExX0qKh0VNp53gcl0%3D" alt="WeexJSBundleParseErrorAPM.png" loading="lazy"/></p>
<h5 data-id="heading-72">3. 资源请求成功，数据无法解析</h5>
<p>还有一种特殊的情况就是：<strong>下载的 JSBundle 二进制数据虽非空，但因无法以 UTF-8 编码解码为字符串，导致 Weex 实例无法加载执行该数据，最终页面 UI 无法正常展示</strong>。比如下面的情况：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e6fdbef3fa6549fea8ba93b5ab23f467~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p2t5Z-O5bCP5YiY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767925474&amp;x-signature=QQ5sLB64xvhg92mNApfF6SljymI%3D" alt="WeexJSbundleEncodingError.png" loading="lazy"/></p>
<p>和上面的情况类似，这种都属于概率较小的问题，但也要监控和预防。</p>
<p>一些可能的情况：</p>
<ol>
<li>JSBundle 文件编码非 UTF-8。 <strong>Weex 要求：JS Bundle 文件必须采用 UTF-8 编码（无 BOM）以保证跨平台兼容性，非 UTF-8 编码（如 GBK、UTF-16）可能导致 iOS/Android 平台解析失败</strong></li>
<li>数据损坏/包含非法 UTF-8 字节</li>
</ol>
<ul>
<li>下载截断：UTF-8 是「多字节编码」（比如中文占 3 字节），若下载过程中数据末尾的字符字节不完整（如只下了 2 字节），解码时会因 “字节序列不合法” 失败；</li>
<li>数据篡改：CDN / 网关 / 代理在传输中混入非 UTF-8 字节（如 0xFF、0xFE、0x00 等无效字节），破坏编码结构；</li>
<li>文件损坏：JSBundle 文件打包 / 上传时出错（如压缩后未正确解压），包含乱码 / 二进制碎片</li>
</ul>
<ol start="3">
<li>请求到非文本数据（URL 错误）。请求的 JS Bundle 返回的不是 JS 文本，而是二进制：</li>
</ol>
<ul>
<li>URL 配置错误：指向图片（png/jpg）、压缩包（zip）、二进制协议数据（如 protobuf）、可执行文件等</li>
<li>后端接口错误：原本应返回 JS 文本的接口，异常时返回二进制格式的错误信息（而非文本错误）</li>
<li>缓存污染：Weex 本地缓存的 JSBundle 被其他二进制文件覆盖（如缓存路径冲突）</li>
</ul>
<ol start="4">
<li>特殊字符/编码溢出</li>
</ol>
<ul>
<li>JSBundle 中包含 UTF-8 无法表示的「无效 Unicode 码点」（如超出 U+10FFFF 范围，或保留的未定义码点）</li>
<li>数据量过大：极大型 JSBundle 解码时因内存不足 / 系统限制，导致解码接口返回 nil（iOS 中 NSString 对单字符串长度有隐性限制）</li>
</ul>
<p>这种情况，Weex 官方是怎么做的？</p>
<pre><code class="hljs language-Objective-C" lang="Objective-C">NSString *jsBundleString = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];
if (!jsBundleString) {
    WX_MONITOR_FAIL_ON_PAGE(WXMTJSDownload, WX_ERR_JSBUNDLE_STRING_CONVERT, @"data converting to string failed.", strongSelf.pageName)
    [strongSelf.apmInstance setProperty:KEY_PROPERTIES_ERROR_CODE withValue:[@(WX_ERR_JSBUNDLE_STRING_CONVERT) stringValue]];
    return;
}
</code></pre>
<p>可以看到，这种情况没有被 Weex 没有视为“致命问题”进行上报。只是进行了简单打印。尝试站在框架角度想问题，从 SDK Owner 角度归因：</p>
<ul>
<li>HTTP 状态码错误/无数据：Weex 认为这类错误是「外部不可控故障」（网络、CDN、服务端宕机），会影响大批量实例，属于 “框架级致命异常”，必须通过 WXExceptionUtils 上报（触发全局异常统计、告警）</li>
<li>编码转换失败：可能是分批多次打包，前几次都是 UTF-8 格式，只是这次编码错误，是可以定位的。Weex 认为这类错误是「内部可控问题」（前端打包时未按 UTF-8 规范输出、URL 配置错误指向二进制文件），属于 “业务侧错误”，框架只需记录监控（提醒开发者修复），无需升级为 “框架级致命异常”。</li>
</ul>
<p>但从业务方角度出发，不光页面是 Weex、Native、Flutter、H5，只要是影响了用户体验，都属于致命问题，尤其这种整个页面都是白屏的情况。所以我们需要修改源码，去上报致命异常。调用 <code>WXExceptionUtils commitCriticalExceptionRT</code> 的能力。</p>
<p>效果如下：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2154e2845b9049a0be6451bfb74e380e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p2t5Z-O5bCP5YiY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767925474&amp;x-signature=3BwQrPAEiMiQArQhfy%2FCp2TsDg0%3D" alt="WeexJSBundleEncodingAPM.png" loading="lazy"/></p>
<h3 data-id="heading-73">4. 逻辑异常</h3>
<h4 data-id="heading-74">1. JS 侧 require Module 失败</h4>
<p>在 Native <code>[WXSDKEngine registerModule:@"logicCalculation" withClass:[WXLogicCalculationModule class]]</code> 正常注册的 Module，名字叫 <code>logicCalculation</code>。在 js 侧使用的时候不小心写成 <code>const logicCalculation = weex.requireModule('logicCalculation1')</code>，测试又没回归到，问题逃逸到线上，可能就是逻辑问题。Weex 官方的做法就是在 Xcode 打印 log。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/23cb98cbb5e049c3acc196b1c116b623~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p2t5Z-O5bCP5YiY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767925474&amp;x-signature=l7HXLokeuQyH909ZpVlNHoO1GiM%3D" alt="WeexModuleRequireError.png" loading="lazy"/></p>
<p>所以作为 APM 侧，我们要定位和收集到该问题，进行问题上报。</p>
<p>想办法知道哪里报错，requireModule 不是原生写法，这肯定是 JS 侧封装的，查看 Weex 源码</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f1c8b35c5beb4958b0d1c0af4513e905~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p2t5Z-O5bCP5YiY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767925474&amp;x-signature=GNJIzZRV5ymObWuqAm1zU15ZEuM%3D" alt="WeexRequireModuleError.png" loading="lazy"/></p>
<pre><code class="hljs language-JS" lang="JS"><span class="hljs-comment">// Weex JS Framework 核心源码（简化）</span>
<span class="hljs-title class_">WeexInstance</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">requireModule</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">requireModule</span>(<span class="hljs-params">moduleName</span>) {
  <span class="hljs-comment">// 1. 基础校验：Weex实例是否有效（比如是否已销毁）</span>
  <span class="hljs-keyword">var</span> id = <span class="hljs-title function_">getId</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">// 获取当前Weex实例ID</span>
  <span class="hljs-keyword">if</span> (!(id &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">document</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">document</span>.<span class="hljs-property">taskCenter</span>)) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"[JS Framework] Failed to requireModule(\""</span> + moduleName + <span class="hljs-string">"\"), instance doesn't exist."</span>);
    <span class="hljs-keyword">return</span>;
  }

  <span class="hljs-comment">// 2. 关键校验：检查Module是否在Native侧注册过</span>
  <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isRegisteredModule</span>(moduleName)) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">"[JS Framework] using unregistered weex module \""</span> + moduleName + <span class="hljs-string">"\""</span>);
    <span class="hljs-keyword">return</span>;
  }

  <span class="hljs-comment">// 3. 核心：创建Module代理对象（并非真实对象，仅封装桥接调用）</span>
  <span class="hljs-keyword">var</span> moduleProxy = {};
  <span class="hljs-comment">// 获取该Module在Native侧注册的所有方法（提前从Native同步到JS的方法映射表）</span>
  <span class="hljs-keyword">var</span> moduleMethods = <span class="hljs-title function_">getRegisteredMethods</span>(moduleName);
  
  <span class="hljs-comment">// 4. 为代理对象绑定方法：调用方法时触发JS-Native桥接</span>
  moduleMethods.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">methodName</span>) {
    moduleProxy[methodName] = <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
      <span class="hljs-comment">// 封装调用参数：实例ID、Module名、方法名、参数、回调</span>
      <span class="hljs-keyword">var</span> args = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>);
      <span class="hljs-keyword">var</span> callback = <span class="hljs-literal">null</span>;
      <span class="hljs-comment">// 提取最后一个参数作为回调（Weex约定）</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> args[args.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>] === <span class="hljs-string">'function'</span>) {
        callback = args.<span class="hljs-title function_">pop</span>();
      }
      
      <span class="hljs-comment">// 5. 核心：通过taskCenter（桥接核心）调用Native</span>
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">document</span>.<span class="hljs-property">taskCenter</span>.<span class="hljs-title function_">sendNative</span>(<span class="hljs-string">'callNative'</span>, {
        <span class="hljs-attr">instanceId</span>: id,
        <span class="hljs-attr">module</span>: moduleName,
        <span class="hljs-attr">method</span>: methodName,
        <span class="hljs-attr">params</span>: args,
        <span class="hljs-attr">callback</span>: callback ? <span class="hljs-title function_">generateCallbackId</span>(callback) : <span class="hljs-literal">null</span>
      });
    }.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);
  }, <span class="hljs-variable language_">this</span>);

  <span class="hljs-comment">// 6. 返回代理对象给JS侧使用</span>
  <span class="hljs-keyword">return</span> moduleProxy;
};
</code></pre>
<ul>
<li>返回的不是真实的 Module 实例，而是代理对象（Proxy） —— 所有方法调用都会被拦截，转而通过桥接发送到 Native；</li>
<li>isRegisteredModule 校验：JS 侧会缓存一份「Native 已注册 Module 列表」（Native 初始化时同步到 JS），避免无效桥接。</li>
</ul>
<p>方案一：Weex 由于安全设计，没办法直接注入 JS。也就是说想通过“切面”思想，hook JS 侧 requireModule 是行不通的。这种方案，代码如下</p>
<pre><code class="hljs language-JS" lang="JS"><span class="hljs-comment">// 备份原生requireModule方法</span>
<span class="hljs-keyword">const</span> originalRequireModule = <span class="hljs-title class_">WeexInstance</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">requireModule</span>;

<span class="hljs-comment">// 重写requireModule，在错误触发时主动上报Native</span>
<span class="hljs-title class_">WeexInstance</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">requireModule</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">moduleName</span>) {
  <span class="hljs-comment">// 先执行原生判断逻辑</span>
  <span class="hljs-keyword">const</span> id = <span class="hljs-title function_">getId</span>(<span class="hljs-variable language_">this</span>);
  <span class="hljs-keyword">if</span> (!(id &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">document</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">document</span>.<span class="hljs-property">taskCenter</span>)) {
    <span class="hljs-keyword">const</span> errorMsg = <span class="hljs-string">"[JS Framework] Failed to requireModule(\""</span> + moduleName + <span class="hljs-string">"\"), instance ("</span> + id + <span class="hljs-string">") doesn't exist anymore."</span>;
    <span class="hljs-comment">// 主动上报“实例不存在”错误到Native</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">document</span>.<span class="hljs-property">taskCenter</span>.<span class="hljs-title function_">sendNative</span>(<span class="hljs-string">'__weex_apm_report'</span>, {
      <span class="hljs-attr">type</span>: <span class="hljs-string">'module_require_failed'</span>,
      <span class="hljs-attr">subType</span>: <span class="hljs-string">'instance_not_exist'</span>,
      <span class="hljs-attr">moduleName</span>: moduleName,
      <span class="hljs-attr">message</span>: errorMsg,
      <span class="hljs-attr">instanceId</span>: id
    });
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(errorMsg);
    <span class="hljs-keyword">return</span>;
  }

  <span class="hljs-comment">// 核心：拦截“未注册Module”判断</span>
  <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isRegisteredModule</span>(moduleName)) {
    <span class="hljs-keyword">const</span> warnMsg = <span class="hljs-string">"[JS Framework] using unregistered weex module \""</span> + moduleName + <span class="hljs-string">"\""</span>;
    <span class="hljs-comment">// 主动上报“Module未注册”错误到Native（关键）</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">document</span>.<span class="hljs-property">taskCenter</span>.<span class="hljs-title function_">sendNative</span>(<span class="hljs-string">'__weex_apm_report'</span>, {
      <span class="hljs-attr">type</span>: <span class="hljs-string">'module_not_registered'</span>,
      <span class="hljs-attr">moduleName</span>: moduleName,
      <span class="hljs-attr">message</span>: warnMsg,
      <span class="hljs-attr">instanceId</span>: id,
      <span class="hljs-attr">timestamp</span>: <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>()
    });
    <span class="hljs-comment">// 保留原生warn日志（不影响原有逻辑）</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(warnMsg);
    <span class="hljs-keyword">return</span>;
  }

  <span class="hljs-comment">// 执行原生逻辑</span>
  <span class="hljs-keyword">return</span> originalRequireModule.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, moduleName);
};
</code></pre>
<p>方案二：Native 侧拦截 JS 的 console.warn 调用（无 JS 侵入）</p>
<p>写法1：Weex JS 侧的 <code>console.warn</code> 最终会通过 WXBridgeContext 的 <code>handleJSLog</code> 方法传递到 Native，无需解析最终日志，直接 Hook 该方法拦截 warn 信息，精准匹配 Module 未注册错误</p>
<pre><code class="hljs language-Objective-C" lang="Objective-C">#import &lt;objc/runtime.h&gt;

@implementation NSObject (WXJSLogHook)
+ (void)load {
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
        // 获取WXBridgeContext类（无需头文件）
        Class bridgeContextClass = NSClassFromString(@"WXBridgeContext");
        if (!bridgeContextClass) return;
        
        // Hook处理JS日志的核心方法：handleJSLog:
        SEL handleJSLogSel = NSSelectorFromString(@"handleJSLog:");
        Method originalMethod = class_getInstanceMethod(bridgeContextClass, handleJSLogSel);
        if (!originalMethod) return;
        
        SEL swizzledSel = NSSelectorFromString(@"weex_apm_handleJSLog:");
        Method swizzledMethod = class_getInstanceMethod(self, swizzledSel);
        class_addMethod(bridgeContextClass, swizzledSel, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));
        method_exchangeImplementations(originalMethod, swizzledMethod);
    });
}

// Hook后的handleJSLog方法：拦截JS侧的warn日志
- (void)weex_apm_handleJSLog:(NSDictionary *)logInfo {
    // 1. 先执行原方法，保留原有日志输出逻辑
    [self weex_apm_handleJSLog:logInfo];
    
    // 2. 解析JS日志信息（logInfo格式：{level: 'warn', msg: 'xxx', ...}）
    NSString *logLevel = logInfo[@"level"];
    NSString *logMsg = logInfo[@"msg"];
    
    // 3. 精准匹配“未注册Module”的warn
    if ([logLevel isEqualToString:@"warn"] &amp;&amp; [logMsg containsString:@"using unregistered weex module"]) {
        // 提取Module名称
        NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:@"using unregistered weex module \"(.*?)\"" options:0 error:nil];
        NSTextCheckingResult *match = [regex firstMatchInString:logMsg options:0 range:NSMakeRange(0, logMsg.length)];
        NSString *moduleName = match ? [logMsg substringWithRange:match.rangeAtIndex(1)] : @"";
        
        // 4. 构造APM数据上报
        NSDictionary *apmData = @{
            @"error_type": @"weex_module_not_registered",
            @"module_name": moduleName,
            @"message": logMsg,
            @"source": @"js_console_warn", // 标记来源：JS console.warn
            @"timestamp": @([[NSDate date] timeIntervalSince1970] * 1000)
        };
        
        // 调用 APM SDK 接口，数据先落库，后续统一按照数据上报策略，从本地 DB 捞取、聚合、上报
        // [YourAPMManager reportWeexError:apmData];
    }
}
@end
</code></pre>
<p>核心优势</p>
<ul>
<li>无侵入：无需修改 / 注入 JS 代码，纯 Native 侧实现；</li>
<li>精准：拦截的是 JS 侧传递到 Native 的原始日志数据（而非最终打印的字符串），无格式误差；</li>
<li>覆盖全：所有 JS 侧的console.warn都会经过此方法，100% 覆盖 Module 未注册场景</li>
</ul>
<p>写法二：由于 Weex 代码是大量的存量业务代码，很稳定。而且 Weex 官方好几年不更新，所以我们内部私有化 Weex SDK，也就没有采取 Hook 手段。而是直接修改源码，<code>WXBridgeContext.m</code> 的 <code>+ (void)handleConsoleOutputWithArgument:(NSArray *)arguments logLevel:(WXLogFlag)logLevel</code> 方法。比如：</p>
<pre><code class="hljs language-Objective-C" lang="Objective-C">+ (void)handleConsoleOutputWithArgument:(NSArray *)arguments logLevel:(WXLogFlag)logLevel
{
    NSMutableString *string = [NSMutableString string];
    [string appendString:@"jsLog: "];
    [arguments enumerateObjectsUsingBlock:^(JSValue *jsVal, NSUInteger idx, BOOL *stop) {
        [string appendFormat:@"%@ ", jsVal];
        if (idx == arguments.count - 1) {
            if (logLevel) {
                if (WXLogFlagWarning == logLevel || WXLogFlagError == logLevel) {
                    if ([string containsString:@"using unregistered weex module"]) {
                        // 提取Module名称
                        NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:@"using unregistered weex module \"(.*?)\"" options:0 error:nil];
                        NSTextCheckingResult *match = [regex firstMatchInString:string options:0 range:NSMakeRange(0, string.length)];
                        NSString *moduleName = match ? [string substringWithRange:[match rangeAtIndex:1]] : @"";
                        
                        // 接入收口工具类
                        NSString *exceptionMsg = [NSString stringWithFormat:@"JS require未注册模块：%@，原始日志：%@", moduleName, string];
                        NSDictionary *customExt = @{@"moduleName": moduleName};
                        NSString *instanceId = [WXSDKEngine topInstance].instanceId ?: @"";
                        NSString *bundleUrl = [WXSDKEngine topInstance].scriptURL.absoluteString ?: @"";
                        [[WXExceptionReporter sharedInstance] reportExceptionWithCode:WXCustomExceptionCode_Module_NotRegistered
                                                                        exceptionType:WXCustomExceptionType_Module
                                                                            instanceId:instanceId
                                                                             function:@"handleConsoleOutputWithArgument:logLevel:"
                                                                         exceptionMsg:exceptionMsg
                                                                            bundleUrl:bundleUrl
                                                                         customExtParams:customExt];
                    }
                    
                    id&lt;WXAppMonitorProtocol&gt; appMonitorHandler = [WXSDKEngine handlerForProtocol:@protocol(WXAppMonitorProtocol)];
                    if ([appMonitorHandler respondsToSelector:@selector(commitAppMonitorAlarm:monitorPoint:success:errorCode:errorMsg:arg:)]) {
                        [appMonitorHandler commitAppMonitorAlarm:@"weex" monitorPoint:@"jswarning" success:NO errorCode:@"99999" errorMsg:string arg:[WXSDKEngine topInstance].pageName];
                    }
                }
                WX_LOG(logLevel, @"%@", string);
            } else {
                [string appendFormat:@"%@ ", jsVal];
                WXLogInfo(@"%@", string);
            }
        }
    }];
}
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/feaa4cd760594fb0bf97f43cff8d8778~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p2t5Z-O5bCP5YiY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767925474&amp;x-signature=CzPMJNi1rHB2uiQkqsrjsWjl49M%3D" alt="WeexRequireModuleErrorAPM.png" loading="lazy"/></p>
<h4 data-id="heading-75">2. JS 调用 Moudle 方法失败</h4>
<p>Native 注册了一个负责逻辑的 Module，但是在 JS 侧使用的时候，要么方法名写错了，要么参数少传了，都可能导致预期的逻辑执行错误，发生不符合预期的行为。</p>
<h5 data-id="heading-76">1. 点击事件工作原理</h5>
<p>核心问题：点击事件发生时，如何根据 Component 的点击事件定位到该 Component 在 Vue DSL 中声明的事件？</p>
<p>第一步：页面初始化时，JS 侧构建<strong>事件映射表</strong>。
Weex 页面渲染时，会为每个组件做2件事情：</p>
<ul>
<li>生成组件唯一标识：每个组件都有 <code>ref/componentId/docId</code>，类似组件身份证</li>
<li>绑定事件与方法：解析 <code>@click="handleButtonClick"</code> 时，JS 会将「组件 ID + 事件类型（click）」作为 key，<code>handleButtonClick</code> 作为 value，一起存进组件实例的映射表里，（对应下面的 <code>this.event[type]</code>）</li>
</ul>
<p>第二步：Native 侧捕获点击，携带关键信息调用 fireEvent。
Native 侧能拿到 componentId，是因为渲染组件时，JS 侧会把组件 ID 同步给 Native 渲染引擎（WXComponent），Native 控件和 JS 组件实例通过 ID 一一绑定</p>
<p>第三步：JS 侧调用 <code>fireEvent</code> 方法，其内部通过 <code>ID + 事件类型</code> 找方法。</p>
<ul>
<li>定位组件实例：JS 通过 componentID（代码里的 this.ref）找到组件实例。</li>
<li>查找事件映射：从组件实例的 <code>this.event</code> 里根据 type （如 click）找到具体的 eventDesc（包含具体的 handler）</li>
<li>发起调用 <code>handler.call</code></li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/**
   * Fire an event manually.
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} type type
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">function</span>} event handler
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">boolean</span>} isBubble whether or not event bubble
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">boolean</span>} <span class="hljs-variable">options</span>
   * <span class="hljs-doctag">@return</span> {<span class="hljs-type"/>} anything returned by handler function
   */</span>
  <span class="hljs-title class_">Element</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">fireEvent</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">fireEvent</span> (type, event, isBubble, options) {
    <span class="hljs-keyword">var</span> result = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> isStopPropagation = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">var</span> eventDesc = <span class="hljs-variable language_">this</span>.<span class="hljs-property">event</span>[type];
    <span class="hljs-keyword">if</span> (eventDesc &amp;&amp; event) {
      <span class="hljs-keyword">var</span> handler = eventDesc.<span class="hljs-property">handler</span>;
      event.<span class="hljs-property">stopPropagation</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"/>) {
        isStopPropagation = <span class="hljs-literal">true</span>;
      };
      <span class="hljs-keyword">if</span> (options &amp;&amp; options.<span class="hljs-property">params</span>) {
        result = handler.<span class="hljs-property">call</span>.<span class="hljs-title function_">apply</span>(handler, [ <span class="hljs-variable language_">this</span> ].<span class="hljs-title function_">concat</span>( options.<span class="hljs-property">params</span>, [event] ));
      }
      <span class="hljs-keyword">else</span> {
        result = handler.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, event);
      }
    }

    <span class="hljs-keyword">if</span> (!isStopPropagation
      &amp;&amp; isBubble
      &amp;&amp; (<span class="hljs-variable constant_">BUBBLE_EVENTS</span>.<span class="hljs-title function_">indexOf</span>(type) !== -<span class="hljs-number">1</span>)
      &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">parentNode</span>
      &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">parentNode</span>.<span class="hljs-property">fireEvent</span>) {
      event.<span class="hljs-property">currentTarget</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">parentNode</span>;
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">parentNode</span>.<span class="hljs-title function_">fireEvent</span>(type, event, isBubble); <span class="hljs-comment">// no options</span>
    }

    <span class="hljs-keyword">return</span> result
  };
</code></pre>
<h5 data-id="heading-77">2. JS 调用 module 方法，方法名错误</h5>
<p>Native 注册的 Module 方法名为 <code>multiply:num2:callback:</code>，而在 JS 侧调用的时候方法名多加了几个字符，造成方法名对不上，方法调用失败的问题。</p>
<p>用户点击屏幕上的 UI 控件（此处就是注册 Component <code>[WXSDKEngine registerComponent:@"color-button" withClass:[WXColorButtonComponent class]]</code>)。</p>
<p>Weex 统一给 Comonent 添加了分类来负责事件的处理。<code>WXComponent+Events</code>。源码中 <code>addClickEvent</code> 就是添加了点击事件的监听。当发生点击后会计算点击事件的坐标和时间戳信息，最后封装一个 <code>WXCallJSMethod</code> 对象，方法名固定为 <code>fireEvent</code>。如下堆栈所示：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4aa523b5d1a047e690cd3e0d5e178dbd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p2t5Z-O5bCP5YiY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767925474&amp;x-signature=WvFysSIJKSbgGF6gOWhsRXSiMLk%3D" alt="WeexComponentClickLogic.png" loading="lazy"/></p>
<p>由于 <code>logicCalculation</code> 没有对应的 <code>multiplyWith</code> 方法，所以会报错，被 JS 的 <code>try...catch...</code> 捕获后，通过 <code>console.error</code> 的方式输出异常信息。但是 <code>console.error</code> 被 Native 接管了。所以我们可以在 Native 接管的地方统一拦截处理。只要日志包含 <code>Failed to invoke the event handler</code> 就可以认为是因为方法名问题，导致调用方法出错</p>
<p>代码如下：</p>
<pre><code class="hljs language-Objective-c" lang="Objective-c">+ (void)handleConsoleOutputWithArgument:(NSArray *)arguments logLevel:(WXLogFlag)logLevel
{
    // ...
    if ([string containsString:@"Failed to invoke the event handler"]) {
        // 原有解析逻辑保留
                        NSString *errorMethodName = @"";
                        NSString *eventType = @"";
                        NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:@"'\\.\\.\\.(?:logicCalculation\\.)([a-zA-Z0-9_]+)\\.\\.\\." options:0 error:nil];
                        NSTextCheckingResult *match = [regex firstMatchInString:string options:0 range:NSMakeRange(0, string.length)];
                        if (match) {
                            errorMethodName = [string substringWithRange:[match rangeAtIndex:1]];
                        }
                        NSRegularExpression *eventRegex = [NSRegularExpression regularExpressionWithPattern:@"event handler of \"([^\"]+)\"" options:0 error:nil];
                        NSTextCheckingResult *eventMatch = [eventRegex firstMatchInString:string options:0 range:NSMakeRange(0, string.length)];
                        if (eventMatch) {
                            eventType = [string substringWithRange:[eventMatch rangeAtIndex:1]];
                        }
                        
                        // 接入收口工具类
                        NSString *exceptionMsg = [NSString stringWithFormat:@"Module方法名错误：%@，事件类型：%@，原始日志：%@", errorMethodName, eventType, string];
                        NSDictionary *customExt = @{
                            @"moduleName": @"logicCalculation",
                            @"methodName": errorMethodName,
                            @"eventType": eventType
                        };
                        NSString *instanceId = [WXSDKEngine topInstance].instanceId ?: @"";
                        NSString *bundleUrl = [WXSDKEngine topInstance].scriptURL.absoluteString ?: @"";
                        [[WXExceptionReporter sharedInstance] reportExceptionWithCode:WXCustomExceptionCode_Module_MethodNotFound
                                                                         exceptionType:WXCustomExceptionType_Module
                                                                            instanceId:instanceId
                                                                              function:@"handleConsoleOutputWithArgument:logLevel:"
                                                                         exceptionMsg:exceptionMsg
                                                                             bundleUrl:bundleUrl
                                                                         customExtParams:customExt];
    }
    // ...
}
</code></pre>
<p>效果如下</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/caecf4541d1646cfadc4fb59dd7abf93~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p2t5Z-O5bCP5YiY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767925474&amp;x-signature=MZypkqirSmTiJApbXBRu7j6mUvM%3D" alt="WeexCallModuleMethodNameMismatch.png" loading="lazy"/></p>
<h5 data-id="heading-78">3. JS 调用 module 方法，方法参数个数不匹配</h5>
<p>上面已经讲了点击事件的工作流程，调用方法时，除了调用了不存在的方法或者方法名写错了，还有一种情况就是参数个数不匹配。</p>
<p>这种情况如何识别并监控？
JS 的事件处理函数里，调用注册的 Module 和对应的方法，会统一走到 <code>WXJSCoreBridge.mm</code> 的 <code>- (void)registerCallNativeModule:(WXJSCallNativeModule)callNativeModuleBlock</code> 给当前的 JSContext 注册好的 <code>callNativeModule</code> 回调里。<code>_jsContext[@"callNativeModule"] = ^JSValue *(JSValue *instanceId, JSValue *moduleName, JSValue *methodName, JSValue *args, JSValue *options)</code> 可以拿到模块名、方法名、参数个数、instanceID 等。拿到实际传递的方法参数列表，再通过模块名根据 <code>ModuleFactory</code> 找到模块类对象，然后利用 runtime 能力，遍历类对象的方法列表，找到对应的 SEL，判断其预期的方法参数个数，然后再和实际传递过来的方法参数个数做比较即可</p>
<pre><code class="hljs language-Objective-c" lang="Objective-c">- (void)registerCallNativeModule:(WXJSCallNativeModule)callNativeModuleBlock
{
    // JS 调用 Native 的方法都会走这里。可以解析到：模块名、方法名、参数数组等信息。可以在这里判断方法参数个数是否相同。
    _jsContext[@"callNativeModule"] = ^JSValue *(JSValue *instanceId, JSValue *moduleName, JSValue *methodName, JSValue *args, JSValue *options) {
        // ...
    };
}
</code></pre>
<p>在其 <code>callNativeModule</code> 的 block 里，增加一个方法，专门用来判断和检查方法参数个数是否匹配的问题</p>
<pre><code class="hljs language-Objective-C" lang="Objective-C">// 辅助方法：校验Module方法参数个数
- (void)checkModuleParamCount:(NSString *)moduleName
                   methodName:(NSString *)methodName
                 actualParams:(NSArray *)actualParams
                   instanceId:(NSString *)instanceId {
    // 1. 跳过空值/系统模块（避免无意义校验）
    if (!moduleName || !methodName || actualParams.count &lt; 0) return;
    Class moduleClass = [WXModuleFactory classWithModuleName:moduleName];
    if (!moduleClass) return;

    // 2. 拼接完整的方法选择器（Weex Module方法名带冒号，需补全，如multiply→multiply:num2:callback:）
    // 注：若方法名规则固定，可通过模块类的方法列表获取所有selector，匹配前缀
    SEL targetSel = nil;
    unsigned int methodCount = 0;
    Method *methods = class_copyMethodList(moduleClass, &amp;methodCount);
    for (int i = 0; i &lt; methodCount; i++) {
        Method method = methods[i];
        SEL sel = method_getName(method);
        NSString *selStr = NSStringFromSelector(sel);
        // 匹配前缀（如multiply开头的方法）
        if ([selStr hasPrefix:methodName]) {
            targetSel = sel;
            break;
        }
    }
    free(methods);
    if (!targetSel) return;

    // 3. 解析方法签名，计算预期参数个数（减self/_cmd）
    NSMethodSignature *methodSig = [moduleClass instanceMethodSignatureForSelector:targetSel];
    NSInteger weexParamCount = methodSig.numberOfArguments - 2;

    // 4. 判断参数个数是否不匹配
    if (actualParams.count != weexParamCount) {
        // 构造错误信息
        NSString *errorMsg = [NSString stringWithFormat:@"Module:%@ 方法:%@ 参数个数不匹配，预期%ld个，实际%ld个",
                              moduleName, methodName, weexParamCount, actualParams.count];
        WXLogError(@"[WeexParamError] %@", errorMsg);

        // 5. 上报APM（核心：生产环境监控）
        NSDictionary *apmData = @{
            @"error_type": @"weex_module_param_count_mismatch",
            @"module_name": moduleName,
            @"method_name": methodName,
            @"expected_count": @(weexParamCount),
            @"actual_count": @(actualParams.count),
            @"actual_params": actualParams,
            @"instance_id": instanceId ?: @"",
            @"timestamp": @([[NSDate date] timeIntervalSince1970] * 1000),
            @"message": errorMsg
        };

        // APM:异步上报，避免阻塞JS桥接
        NSLog(@"APM 数据上报通道，【JS 通过 Module 调用 Native 方法，参数个数不匹配】：%@", apmData);
    }
}
</code></pre>
<p>效果如下：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5bd25d1035904328bb1420da7f7961c0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p2t5Z-O5bCP5YiY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767925474&amp;x-signature=Vt4Dsl4Nmtzch2kyJ9N%2FnA6qwsk%3D" alt="WeexCallNativeModuleParamsError.png" loading="lazy"/></p>
<h4 data-id="heading-79">5. Vue 层面异常</h4>
<p>Weex 底层依靠 Vue 实现，差异化就是 VM 去通过 Bridge 在 WeexSDK Native 去做绘制。异常方面除了常规的 JS 运行时异常（如语法错误、类型错误等 7 种），Vue 框架自身的逻辑层、编译层、响应式系统、组件生命周期 等环节会抛出专属异常，这些异常必须通过 Vue.config.errorHandler 兜底。</p>
<p>分析 Weex 源码中：<code>packages/weex-js-framework/index.js/</code></p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">handleError</span> (err, vm, info) {
  <span class="hljs-keyword">if</span> (vm) {
    <span class="hljs-keyword">var</span> cur = vm;
    <span class="hljs-keyword">while</span> ((cur = cur.<span class="hljs-property">$parent</span>)) {
      <span class="hljs-keyword">var</span> hooks = cur.<span class="hljs-property">$options</span>.<span class="hljs-property">errorCaptured</span>;
      <span class="hljs-keyword">if</span> (hooks) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; hooks.<span class="hljs-property">length</span>; i++) {
          <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">var</span> capture = hooks[i].<span class="hljs-title function_">call</span>(cur, err, vm, info) === <span class="hljs-literal">false</span>;
            <span class="hljs-keyword">if</span> (capture) { <span class="hljs-keyword">return</span> }
          } <span class="hljs-keyword">catch</span> (e) {
            <span class="hljs-title function_">globalHandleError</span>(e, cur, <span class="hljs-string">'errorCaptured hook'</span>);
          }
        }
      }
    }
  }
  <span class="hljs-title function_">globalHandleError</span>(err, vm, info);
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">globalHandleError</span> (err, vm, info) {
  <span class="hljs-keyword">if</span> (config.<span class="hljs-property">errorHandler</span>) {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">return</span> config.<span class="hljs-property">errorHandler</span>.<span class="hljs-title function_">call</span>(<span class="hljs-literal">null</span>, err, vm, info)
    } <span class="hljs-keyword">catch</span> (e) {
      <span class="hljs-title function_">logError</span>(e, <span class="hljs-literal">null</span>, <span class="hljs-string">'config.errorHandler'</span>);
    }
  }
  <span class="hljs-title function_">logError</span>(err, vm, info);
}
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f59bc9512ac44aa7868c7bec1817a4f7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p2t5Z-O5bCP5YiY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767925474&amp;x-signature=5SezT87Wi5Mt311I3SEDLwsrRaA%3D" alt="WeexCaptureVueError.png" loading="lazy"/></p>
<p>源码中 nextTick、Vue.prototype.$emit、callHook、Watcher.prototype.get、Watcher.prototype.run、renderRecyclableComponentTemplate、Vue.prototype._render 等等都调用了  handleError 方法。
Vue 内部对部分异常做了封装/拦截，避免直接冒泡到全局（防止阻断应用整体运行），但会通过 errorHandler 暴露出来。</p>
<p>举个例子，WeexAPM 类可以封装为：</p>
<pre><code class="hljs language-JS" lang="JS"><span class="hljs-comment">/**
 * APM
 */</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">WeexAPM</span> {
  <span class="hljs-comment">/**
   * 获取当前的叶子节点
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">*</span>} Vue vm
   * <span class="hljs-doctag">@returns</span> 当前组件名称
   */</span>
  formatComponentName (vm) {
    <span class="hljs-keyword">if</span> (vm.<span class="hljs-property">$root</span> === vm) <span class="hljs-keyword">return</span> <span class="hljs-string">'root'</span>
    <span class="hljs-keyword">var</span> name = vm.<span class="hljs-property">_isVue</span>
      ? (vm.<span class="hljs-property">$options</span> &amp;&amp; vm.<span class="hljs-property">$options</span>.<span class="hljs-property">name</span>) ||
        (vm.<span class="hljs-property">$options</span> &amp;&amp; vm.<span class="hljs-property">$options</span>.<span class="hljs-property">_componentTag</span>)
      : vm.<span class="hljs-property">name</span>
    <span class="hljs-keyword">return</span> (
      (name ? <span class="hljs-string">'component &lt;'</span> + name + <span class="hljs-string">'&gt;'</span> : <span class="hljs-string">'anonymous component'</span>) +
      (vm.<span class="hljs-property">_isVue</span> &amp;&amp; vm.<span class="hljs-property">$options</span> &amp;&amp; vm.<span class="hljs-property">$options</span>.<span class="hljs-property">__file</span>
        ? <span class="hljs-string">' at '</span> + (vm.<span class="hljs-property">$options</span> &amp;&amp; vm.<span class="hljs-property">$options</span>.<span class="hljs-property">__file</span>)
        : <span class="hljs-string">''</span>)
    )
  }

  <span class="hljs-comment">/**
   * 处理Vue错误提示
   */</span>
  monitor (<span class="hljs-title class_">Vue</span>) {
    <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Vue</span>) {
      <span class="hljs-keyword">return</span>
    }
    <span class="hljs-comment">// 错误处理</span>
    <span class="hljs-title class_">Vue</span>.<span class="hljs-property">config</span>.<span class="hljs-property">errorHandler</span> = <span class="hljs-function">(<span class="hljs-params">err, vm, info</span>) =&gt;</span> {
      <span class="hljs-keyword">let</span> componentName = <span class="hljs-string">'unknown'</span>
      <span class="hljs-keyword">if</span> (vm) {
        componentName = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">formatComponentName</span>(vm)
      }
      <span class="hljs-keyword">let</span> errorInfo = {
        <span class="hljs-attr">name</span>: err.<span class="hljs-property">name</span>,
        <span class="hljs-attr">reason</span>: err.<span class="hljs-property">message</span>,
        <span class="hljs-attr">callStack</span>: err.<span class="hljs-property">stack</span>,
        <span class="hljs-attr">componentName</span>: componentName,
        <span class="hljs-attr">info</span>: info,
        <span class="hljs-attr">level</span>: <span class="hljs-string">'VUE_ERROR'</span>
      }
      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">const</span> weexAPMUploader = weex.requireModule(<span class="hljs-string">'weexAPMUploader'</span>)
        weexAPMUploader.<span class="hljs-title function_">uploadException</span>(errorInfo)
      } <span class="hljs-keyword">catch</span> (error) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'APMMonitor 能力有问题，请检查是否注册了weexAPMUploader模块'</span> + error)
      }
    }
  }
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">WeexAPM</span>
</code></pre>
<p>在捕获到 Vue 层面的异常时，可以调用注册好的 weexAPMUploader module 能力，将数据传输到 Native 侧，由 Native 侧进行统一的参数组装，最后调用 APM SDK 的能力进行数据写入数据库、按照策略上报到 APM 服务端进行消费。</p>
<p>模拟产生 Vue 层级的错误：给一个字符串类型的数据，在计算属性里调用 <code>toFixed</code> 方法。按钮的点击事件里将数据改为字符串，则会报错。
可以看到被 <code>Vue.config.errorHandler</code> 捕获了，后续交给 Native 处理即可。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1c302b4a08944df885a48f5cb732c7ca~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p2t5Z-O5bCP5YiY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767925474&amp;x-signature=VtY%2Flp2%2F9jlnThAaAsyQlyi8zgM%3D" alt="WeexMockVueAPM.png" loading="lazy"/></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[大数据-201 决策树从分裂到剪枝：信息增益/增益率、连续变量与CART要点]]></title>    <link>https://juejin.cn/post/7589940210832474155</link>    <guid>https://juejin.cn/post/7589940210832474155</guid>    <pubDate>2026-01-03T01:29:43.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7589940210832474155" data-draft-id="7590654280899674155" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="大数据-201 决策树从分裂到剪枝：信息增益/增益率、连续变量与CART要点"/> <meta itemprop="keywords" content="后端,大数据,机器学习"/> <meta itemprop="datePublished" content="2026-01-03T01:29:43.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="武子康"/> <meta itemprop="url" content="https://juejin.cn/user/149189314230039"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            大数据-201 决策树从分裂到剪枝：信息增益/增益率、连续变量与CART要点
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/149189314230039/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    武子康
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-03T01:29:43.000Z" title="Sat Jan 03 2026 01:29:43 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读14分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">TL;DR</h2>
<ul>
<li>场景：用决策树做分类/回归，需要解释“贪心局部最优、分裂准则、剪枝、连续变量处理”。</li>
<li>结论：核心矛盾是“训练集纯度提升”与“泛化能力”冲突；用增益率/基尼准则 +（预/后）剪枝 + 验证策略来平衡。</li>
<li>产出：一套可复用的概念框架：分裂标准→二叉分裂→连续变量候选切分点→剪枝与验证集修正。</li>
</ul>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d3f819ee50ca40f7acd0b97136f1ef65~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5q2m5a2Q5bq3:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768008582&amp;x-signature=%2F27FUN5TSkjF7bb4ea1Qr0cCoSA%3D" alt="大数据-201 决策树从分裂到剪枝：信息增益/增益率、连续变量与CART要点" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0c92c6d2df6d4f619d8384e5c214dd0a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5q2m5a2Q5bq3:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768008582&amp;x-signature=EKYpFqdwW%2BxyiyJ9Br68jmFvSrM%3D" alt="大数据-201 决策树从分裂到剪枝：信息增益/增益率、连续变量与CART要点" loading="lazy"/></p>
<h2 data-id="heading-1">决策树</h2>
<p>决策树是一种基于树状结构的监督学习模型，常用于分类和回归任务。它的基本思想是通过一系列问题的分层次判断，将数据分割成越来越小的子集，直到达到预期的目标（如纯度较高的叶子节点，或预测值的误差足够小）。决策树的节点表示判断条件，分支表示不同的条件结果，最终的叶子节点对应具体的分类结果或预测值。</p>
<h2 data-id="heading-2">局部最优</h2>
<p>在构建决策树的机器学习过程中，通常采用贪心算法（Greedy Algorithm）作为核心的分割策略。这种方法的基本原理是：在每一步决策时，都选择当前条件下最优的分割方式，而不考虑这一选择对后续步骤可能产生的影响。</p>
<p>具体来说，决策树的构建过程会递归地进行以下操作：</p>
<ol>
<li>在当前节点上，计算所有可能的特征和分割点的信息增益（或基尼不纯度等分裂标准）</li>
<li>选择使信息增益最大化的特征和分割点</li>
<li>根据选定的分割将数据集划分为若干子集</li>
<li>对每个子集递归地重复上述过程，直到满足停止条件（如达到最大深度、节点样本数低于阈值等）</li>
</ol>
<p>这种方法被称为"局部最优"（Locally Optimal），因为它只关注当前步骤的最佳决策，而不考虑全局最优（Globally Optimal）的解决方案。虽然这种策略可能导致最终的决策树不是理论上最优的，但它具有以下显著优势：</p>
<ul>
<li>计算效率高：避免了穷举所有可能的树结构</li>
<li>实现简单：算法逻辑清晰，易于理解和实现</li>
<li>实际效果好：在大多数实际应用场景中仍能获得良好的预测性能</li>
</ul>
<p>例如，在ID3、C4.5和CART等经典决策树算法中，都采用了这种贪心策略。虽然理论上存在可能找到更优树的算法（如动态规划），但由于决策树构建问题的组合爆炸特性，这些方法通常计算复杂度太高，不适合处理实际规模的数据集。</p>
<h2 data-id="heading-3">剪枝</h2>
<p>剪枝是一种用于防止决策树过拟合的方法。在决策树的构建过程中，过度的分裂会导致模型对训练数据过度拟合，进而降低对新数据的泛化能力。剪枝的目的是通过去除一些不必要的分支，简化决策树结构，从而提升模型的泛化能力。常见的剪枝方法有预剪枝（pre-pruning）和后剪枝（post-pruning）。预剪枝在构建决策树时提前停止某些分裂，而后剪枝则是在树构建完成后再去掉一些不重要的分支。</p>
<h2 data-id="heading-4">分裂</h2>
<p>分裂是决策树构建中的一个核心过程，指的是从根节点开始，根据某个特征的值，将数据划分到不同的子节点中。通过不断地分裂，决策树逐渐将数据集划分成更小的子集，使得每个子集内部的样本更具一致性。在分类任务中，分裂的目标是最大化信息增益或基尼系数的变化，在回归任务中则常采用均方误差或方差作为指标。分裂的过程直到达到设定的停止条件（如节点纯度、树的深度限制等）才会停止。</p>
<h2 data-id="heading-5">二叉分裂</h2>
<p>二叉分裂是一种特定的分裂方式，每次只将节点分成两个子节点，形成一个二叉树结构。决策树可以通过二叉分裂的方式构建，其中每次分裂时，将样本数据分成两个互斥的子集。这种分裂方式的优点是结构简单，且在很多实现中效率较高。许多决策树算法（如CART算法）就是基于二叉分裂构建的。这种结构的决策树在每个节点上只能有两个分支，即「是」或「否」，从而确保树结构的简洁性。</p>
<h2 data-id="heading-6">修改局部最优条件</h2>
<ul>
<li>以信息增益作为划分训练数据集的特征，存在偏向于选择取值较多的特征的问题。</li>
<li>使用信息增益比（information gain ratio）可以对这一问题进行矫正</li>
</ul>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/903d6150cc9a4c13926cb4d915de437b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5q2m5a2Q5bq3:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768008582&amp;x-signature=%2FCUCpptviQfdSgCxDNoZC2rCFtQ%3D" alt="修改局部最优条件" loading="lazy"/>
称为属性 a 的“固有值”（intrinsic value）
属性 a 的可能取值越多（即 V 越大），则 IV（a）的值通常会越大。
IV 值会随着叶节点上样本量的变小而逐渐变大，也就是说一个特征中如果标签分类太多，每个叶子上的 IV 值就会非常大。
值得注意的是，增益率准则对可取值数目较少的属性有所偏好，因此，C4.5 算法并不是直接选择增益率最大的候选划分属性，而是使用了一种启发式：先从候选划分属性中找出信息增益高于平均水平的属性，再从中选择增益率最高的。</p>
<h2 data-id="heading-7">连续变量处理手段</h2>
<p>在 C4.5 中，同样还增加了针对连续变量的处理手段。如果输入特征字段是连续型变量，则算法首先会对这一列数进行从小到大的排序，然后选取相邻的两个数的中间数作为切分数据集的备选点，若一个连续变量有 N 个值，则在 C4.5 的处理过程中将产生 N-1 个备选切分点，并且每个切分点都代表着一种二叉树的切分方案，例如：
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ad0c6431e0cd4c27957b13288fa617e6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5q2m5a2Q5bq3:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768008582&amp;x-signature=uD06e6dwmJu8lLDYPYInLWtB%2F%2B4%3D" alt="连续变量处理手段" loading="lazy"/>
这里需要注意的是，此时连续变量的处理并非是将其转换为一个拥有 N-1 个分类水平的分类变量，而是将其转换为了 N-1 个二分方案，而在进行了下一次的切分过程中，在 N-1 个方案都要单独带入考虑，其中每一个切分方案和一个离散变量的地位均相同（一个离散变量就是一个单独的多路切分方案）。
例如如下数据集，数据集中的只有两个字段，第一行代表年龄，是特征变量，第二行代表性别，是目标字段，则对年龄这一连续变量的切分方案如图所示：
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/74674d38e4594c23953a17c4dc829b19~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5q2m5a2Q5bq3:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768008582&amp;x-signature=Uyj6yrNzSyfr%2B8eS%2FyQVOJOfhYs%3D" alt="连续变量处理手段" loading="lazy"/>
从上述能够看出，在对于包含连续变量的数据集进行树模型构建的过程中要消耗更多的运算资源。但与此同时，我们也会发现，当连续变量的某中间点参与到决策的二分过程中，往往代表该点对于最终分类结果有较大影响，这也为我们连续变量的分箱压缩提供了指导性意见。</p>
<p>例如上述案例，若要对 Age 列进行压缩，则可考虑使用 36.5 对其进行分箱，则分箱结果对于性别这一目标字段仍然具有较好的分类效果，这也是决策树最常见的用途之一，也是最重要的模型指导分箱的方法。</p>
<h2 data-id="heading-8">决策树的拟合度优化</h2>
<p>在实际操作中，我们判断模型的是否拟合往往是从模型训练误差和泛化误差，二者结合使用就能判断模型是否存在过拟合现象。虽然我们之前举例时并没有对数据集进行切分，但任何有监督学习算法建模过程中都需要进行训练集和测试集的划分，决策树也不例外，进而我们可用交叉验证计算训练误差和泛化误差，进而判断决策树是否存在过拟合。
这是一套通用的判断有监督学习算法是否过拟合的方法，同时通用的方法中还有更高级的方法。
但对于决策树而言，有一套决策树独有的防止过拟合的解决方案--剪枝。</p>
<h2 data-id="heading-9">决策树剪枝</h2>
<p>所谓剪枝是指在决策树中去除部分叶节点，剪枝（Pruning）主要用来防止过拟合，对于一般的数据集如果总是追求纯的叶节点，或者观测数较小的叶节点，很容易使得树过于庞杂，尤其是存在可以反复使用的连续变量的时候，此时就需要主动去掉一些分支来降低过拟合的风险。</p>
<p>常见的剪枝策略有“预剪枝”（Pre-Pruning）和“后剪枝”（Post-Purning）</p>
<ul>
<li>预剪枝：在决策树生成的过程中，对每个节点在划分前先进行估计，如果当前的节点划分不能带来决策树泛化性能（预测性能）的提升，则停止划分并且当前节点标记为叶节点。</li>
<li>后剪枝：先训练生成一颗完整的树，自底向上对非叶节点进行考察，如果该节点对应的子树替换为叶节点能带来决策树泛化能力的提升，则该子树替换为叶节点。</li>
</ul>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5e856729cd3d45959036fa2d780b81e5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5q2m5a2Q5bq3:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768008582&amp;x-signature=zdykpwRiMMV7A5rHNBz5GKkRtkU%3D" alt="决策树剪枝" loading="lazy"/></p>
<h2 data-id="heading-10">分裂准则</h2>
<p>二叉递归划分：条件成立向左，反之向右</p>
<ul>
<li>对于连续变量：条件是属性小于等于最优分裂点</li>
<li>对于分类变量：条件是属性属于若干类</li>
</ul>
<h2 data-id="heading-11">二叉分裂优点</h2>
<p>相比多路分裂导致数据碎片化的速度慢，允许在一个属性上重复分裂，即可以在一个属性上产生足够多的分裂。两路分裂带来的树预测性能提升足以弥补其相应的树易读性损失。</p>
<p>对于属性不同的被预测变量 Y 分裂准则不同：</p>
<ul>
<li>分类树：Gini 准则，与之前的信息增益很类似，Gini 系数度量一个节点的不纯度。</li>
<li>回归树：一种常见的分割标准是偏差减少（Stand Deviation Reduction，SDR），类似于最小均方差 LS（Least Squares 预测错误的平方和）准则。</li>
</ul>
<h2 data-id="heading-12">利用测试集进行剪枝</h2>
<p>简单讨论 CART 算法剪枝过程，该过程也是测试集用于修正模型的最佳体现。例如，在如下训练集中训练得到的模型，黑色数字表示训练集上的分类情况，红色数字表示模型作用于验证集上的分类情况。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a587f14cc2dd420d8b75ce380d8e279f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5q2m5a2Q5bq3:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768008582&amp;x-signature=slNUScYrdEmvmlkY8KjY1iHYVwg%3D" alt="利用测试集进行剪枝" loading="lazy"/>
则 CART 算法利用验证集剪枝的过程如下：</p>
<ul>
<li>判断每个叶节点在验证集上的错误率</li>
<li>节点 4 的错误率：e(4) = 1/3</li>
<li>节点 5 的错误率 e(5) = 1</li>
<li>节点 6 的错误率 e(6) = 1</li>
<li>节点 7 的错误率为 e(7) = 4 / 9</li>
</ul>
<p>计算节点总加权平均错误率并和父节点进行比较，加权方法就是乘以该节点样本数量占父节点样本总量的百分比（测试集）：</p>
<p>如节点 2 的错误率为 e(2)=1/4，而节点 4 和节点 5 的加权平均错误率为 e(4) * 3/4 + e(5) * 1/4 = 2/4，因此子节点错误率更高，考虑剪枝。
节点 3 的错误率为 e(3) = 4/10，而 e(6)* 1/10 + e(7)*9/10 = 5/10，因此考虑剪枝。
节点 2 和节点 3 的加权平均错误率 e(2) * 4/14 + e(3) * 10/14 =  5/14，比父节点（节点 1）的错误率 e(1) = 7/14 要小，因此保留该节点，停止剪枝。</p>
<p>可以看出，CART 算法剪枝过程更易理解也更便于操作，同时我们也能看到对于建立模型的算法而言，测试集不仅能够对模型准确率进行评估，同时还能起到修正优化模型的作用。</p>
<h2 data-id="heading-13">测试集和验证集</h2>
<p>对于大多数模型而言，测试集实际上的作用就是用来修正模型，为了提高修正的准确率，我们也可以采用交叉验证的方法，反复判别模型修改条件（如是否要剪枝），并设置模型修改出发条件（如多数验证情况需要修改则对其进行修改），从而提高模型优化的可靠性。</p>
<p>而除了训练集和测试集之外，我们还尝尝会划分一个验证集，验证集数据不参与建模叶不参与模型修改和优化，只用于模型最终优化后的模型效力。</p>
<p>而训练集、测试集和验证集的划分通常遵照 6:2:2 的比例进行划分，当然也可以根据实际需求适当调整划分比例，但无论如何，测试集和验证集数据量都不宜过多也不宜过少，该二者数据集数据均不参与建模，若占比太多，则会对模型的构建过程造成较大的影响（欠拟合），而若划分数据过少，训练集数据量较大，则又可能造成过拟合，数据集的划分也是影响拟合度的重要因素。</p>
<h2 data-id="heading-14">错误速查</h2>



























































<table><thead><tr><th>症状</th><th>根因</th><th>定位</th><th>修复</th></tr></thead><tbody><tr><td>训练集准确率高、线上/测试集差</td><td>树太深、叶子太纯导致过拟合</td><td>看深度、叶子样本数、训练-验证差距</td><td>预剪枝（max_depth/min_samples_*）、后剪枝、交叉验证选复杂度</td></tr><tr><td>总是选“取值很多”的特征先分裂</td><td>信息增益对多取值特征有偏好</td><td>统计候选特征取值数与被选频率</td><td>使用增益率/增益比；或改用基尼/正则化剪枝策略</td></tr><tr><td>连续变量分裂很慢、训练耗时暴涨</td><td>连续变量候选切分点多（N-1）</td><td>单列唯一值数量、排序与评估次数</td><td>先分箱/采样候选点/限制最大叶子数；减少高基数连续特征参与</td></tr><tr><td>多路分裂后数据碎片化严重</td><td>多路分裂稀释样本，子节点样本太少</td><td>查看每次分裂后的子节点样本占比</td><td>倾向二叉分裂；提高最小叶子样本阈值</td></tr><tr><td>树结构可解释但稳定性差</td><td>数据扰动导致分裂点变化（高方差模型）</td><td>不同随机种子/重采样下树结构差异</td><td>用剪枝/限制复杂度；需要稳定性则用集成（随机森林/GBDT）</td></tr><tr><td>剪枝后准确率反而下降</td><td>剪枝强度过大或验证集代表性差</td><td>对比剪枝前后训练/验证/测试指标</td><td>调整剪枝阈值；重做数据划分或用交叉验证稳定选择</td></tr><tr><td>验证集效果好、测试集崩</td><td>验证集参与过多调参导致“验证集过拟合”</td><td>观察调参次数与指标波动</td><td>使用嵌套交叉验证；保留最终独立测试集一次性评估</td></tr><tr><td>类别极不平衡时叶子预测偏向多数类</td><td>分裂准则未显式处理类别权重</td><td>混淆矩阵、少数类召回率异常低</td><td>类别权重/重采样；以召回/F1为主目标约束分裂与剪枝</td></tr></tbody></table>
<h2 data-id="heading-15">其他系列</h2>
<h3 data-id="heading-16">🚀 AI篇持续更新中（长期更新）</h3>
<p><strong>AI炼丹日志-29 - 字节跳动 DeerFlow 深度研究框<em>斜体样式</em>架 私有部署 测试上手 架构研究</strong>，持续打造实用AI工具指南！
<strong>AI研究-132 Java 生态前沿 2025：Spring、Quarkus、GraalVM、CRaC 与云原生落地</strong></p>
<h3 data-id="heading-17">💻 Java篇持续更新中（长期更新）</h3>
<p><strong>Java-207 RabbitMQ Direct 交换器路由：RoutingKey 精确匹配、队列多绑定与日志分流实战</strong>
MyBatis 已完结，Spring 已完结，Nginx已完结，Tomcat已完结，分布式服务已完结，Dubbo已完结，MySQL已完结，MongoDB已完结，Neo4j已完结，FastDFS 已完结，OSS已完结，GuavaCache已完结，EVCache已完结，RabbitMQ正在更新... 深入浅出助你打牢基础！</p>
<h3 data-id="heading-18">📊 大数据板块已完成多项干货更新（300篇）：</h3>
<p>包括 Hadoop、Hive、Kafka、Flink、ClickHouse、Elasticsearch 等二十余项核心组件，覆盖离线+实时数仓全栈！
<strong>大数据-278 Spark MLib - 基础介绍 机器学习算法 梯度提升树 GBDT案例 详解</strong></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[手把手教你安装 SQLServer2014-x64-CHS附详细文步骤与避坑指南]]></title>    <link>https://juejin.cn/post/7590159073989525556</link>    <guid>https://juejin.cn/post/7590159073989525556</guid>    <pubDate>2026-01-03T01:32:40.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7590159073989525556" data-draft-id="7590128405351301120" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="手把手教你安装 SQLServer2014-x64-CHS附详细文步骤与避坑指南"/> <meta itemprop="keywords" content="SQL Server"/> <meta itemprop="datePublished" content="2026-01-03T01:32:40.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="用户613541146016"/> <meta itemprop="url" content="https://juejin.cn/user/1602431422584832"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            手把手教你安装 SQLServer2014-x64-CHS附详细文步骤与避坑指南
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1602431422584832/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    用户613541146016
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-03T01:32:40.000Z" title="Sat Jan 03 2026 01:32:40 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>​ </p>
<p><strong>第一步：准备工作（别嫌麻烦，这步最关键）</strong></p>
<ol>
<li><strong>解压文件</strong>：<strong>安装包下载：</strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fpan.quark.cn%2Fs%2F0ec37ef40661" title="https://pan.quark.cn/s/0ec37ef40661" target="_blank" ref="nofollow noopener noreferrer">pan.quark.cn/s/0ec37ef40…</a>，你下载的 <code>SQLServer2014-x64-CHS.zip</code>是个压缩包，先把它解压到一个<strong>根目录</strong>下，比如 <code>D:\SQL2014</code>。<strong>千万别放太深的文件夹里</strong>，也<strong>千万别有中文路径</strong>，不然容易报错。</li>
<li><strong>断网</strong>：虽然不联网也能装，但联网可能会让你注册微软账号，比较麻烦，直接拔网线或禁用网卡最省事。</li>
</ol>
<hr/>
<h3 data-id="heading-0"><strong>第二步：开始安装</strong></h3>
<ol>
<li>进入你解压好的文件夹，找到 <code>setup.exe</code>，右键选择 <strong>“以管理员身份运行”</strong> 。这一步必须有，否则后面权限不够。</li>
<li>稍等片刻，会弹出安装界面。</li>
</ol>
<hr/>
<h3 data-id="heading-1"><strong>第三步：核心安装操作（跟着点就行）</strong></h3>
<ol>
<li>
<p>在左侧点击  <strong>“全新 SQL Server 独立安装或向现有安装添加功能”</strong> 。</p>
</li>
<li>
<p>产品密钥页面：如果你有正版密钥就填上，没有的话直接选下面的  <strong>“指定可用版本” -&gt; “Evaluation（评估版）”</strong> ，这个能用180天，够你学习用了。然后点“下一步”。</p>
</li>
<li>
<p>许可条款：必须接受，点“下一步”。</p>
</li>
<li>
<p><strong>全局规则检查</strong>：让它自己跑一遍，如果全是绿色对勾，就点“下一步”。如果有红色的，就得根据提示解决一下（通常是系统缺个补丁）。</p>
</li>
<li>
<p><strong>Microsoft Update</strong>：这里建议<strong>取消勾选</strong>，不然它会帮你更新系统，很慢。点“下一步”。</p>
</li>
<li>
<p><strong>安装安装程序文件</strong>：系统会自动下载一些必要的组件，等着它转完圈圈，完成后点“下一步”。</p>
</li>
<li>
<p><strong>功能选择（重点来了！）</strong> ：</p>
<ul>
<li>
<p>在左边列表里，<strong>至少要勾选这几个</strong>：</p>
<ul>
<li><strong>数据库引擎服务</strong>（这个是核心，必装）</li>
<li><strong>SQL Server 复制</strong>（可选，一般也装上）</li>
<li><strong>客户端工具连接</strong>（装了这个才能用SSMS管理数据库）</li>
<li><strong>管理工具 - 基本</strong>（这个就是那个叫SSMS的图形化管理界面，强烈建议装上）</li>
</ul>
</li>
<li>
<p>共享功能目录保持默认就行，点“下一步”。</p>
</li>
</ul>
</li>
<li>
<p><strong>实例配置</strong>：直接用默认的 <strong>MSSQLSERVER</strong>​ 就行，点“下一步”。</p>
</li>
<li>
<p><strong>服务器配置</strong>：把“SQL Server 代理”和“SQL Server 数据库引擎”这两个服务的“启动类型”都改成  <strong>“自动”</strong> ，这样开机就能自己启动。点“下一步”。</p>
</li>
<li>
<p><strong>数据库引擎配置（又一个重点！）</strong> ：</p>
<ul>
<li>身份验证模式：<strong>混合模式 (SQL Server 身份验证和 Windows 身份验证)</strong> 。一定要选这个！</li>
<li>下面设置 <strong>sa 密码</strong>：这个sa账号是最高权限，密码设复杂点，记牢了！</li>
<li>指定SQL Server 管理员：点“添加当前用户”，或者把你自己的Windows用户名加进去。点“下一步”。</li>
</ul>
</li>
<li>
<p>后面的“Analysis Services配置”、“Reporting Services配置”等等，如果你没特殊需求，全部点“下一步”跳过就行。</p>
</li>
<li>
<p>最后到“准备安装”页面，检查一下你选的功能对不对，没问题就点  <strong>“安装”</strong> 。</p>
</li>
</ol>
<hr/>
<h3 data-id="heading-2"><strong>第四步：喝杯茶，等它跑完</strong></h3>
<p>现在就等着进度条走完吧，时间取决于你电脑配置，可能十几分钟到半小时不等。看到所有功能都显示“成功”后，点“关闭”。</p>
<hr/>
<h3 data-id="heading-3"><strong>第五步：验证是否安装成功</strong></h3>
<ol>
<li>按键盘上的 <code>Win + R</code>键，输入 <code>services.msc</code>回车，打开服务列表。</li>
<li>找到  <strong>“SQL Server (MSSQLSERVER)”</strong> ​ 这个服务，看它的状态是不是“正在运行”。如果是，说明安装成功了！</li>
</ol>
<p>​</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[InnoDB 核心原理拆解：缓冲池、Redo Log、MVCC 的底层逻辑]]></title>    <link>https://juejin.cn/post/7589942565012013082</link>    <guid>https://juejin.cn/post/7589942565012013082</guid>    <pubDate>2026-01-02T11:00:01.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7589942565012013082" data-draft-id="7589916567875928106" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="InnoDB 核心原理拆解：缓冲池、Redo Log、MVCC 的底层逻辑"/> <meta itemprop="keywords" content="后端,MySQL"/> <meta itemprop="datePublished" content="2026-01-02T11:00:01.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="技术不打烊"/> <meta itemprop="url" content="https://juejin.cn/user/893244690677165"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            InnoDB 核心原理拆解：缓冲池、Redo Log、MVCC 的底层逻辑
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/893244690677165/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    技术不打烊
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-02T11:00:01.000Z" title="Fri Jan 02 2026 11:00:01 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-02
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    1
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/eeafb70904254eb59d8ac0f458bd102e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oqA5pyv5LiN5omT54OK:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767956401&amp;x-signature=76hROktUhZ5sBCezO5Uecr1FG3g%3D" alt="1.png" loading="lazy"/>
WHAAAAT，你的线上查询突然从 50ms 飙到 5 秒？DBA 甩过来一句"缓冲池命中率才 60%"就走了，你一脸懵：这玩意儿到底啥原理？为啥能把性能拖垮成这样？</p>
<p>数据不会撒谎 。MySQL 官方文档显示，<strong>缓冲池命中率从 95% 跌到 60%，意味着每 10 次查询就有 4 次要读磁盘</strong>——内存访问耗时 100 纳秒，磁盘 IO 却要 10 毫秒，这是 10 万倍的性能鸿沟 。问题来了，为什么大厂 DBA 都在死磕 InnoDB 的三大机制：缓冲池、事务日志、MVCC？因为这三个组件的协同逻辑，直接决定了 MySQL 能不能扛住高并发。</p>
<h2 data-id="heading-0">缓冲池：内存和磁盘的生死较量</h2>
<p>为什么 MySQL 不直接读磁盘？答案藏在一个 16KB 的"页"里 。InnoDB 把数据按 16KB 为单位组织成页（Page），缓冲池的本质就是把这些热点数据页缓存在内存里 。什么概念？假设你查一条用户记录，没有缓冲池的话，MySQL 要去磁盘上捞数据，耗时 10ms；有缓冲池直接内存读取，只要 0.1ms——<strong>性能差了 100 倍</strong> 。</p>
<p>但真正的精髓在改进版 LRU 算法 。传统 LRU（最近最少使用）有个致命问题：一次全表扫描就能把缓存"污染"干净。InnoDB 怎么破？<strong>把 LRU 链表切成两截：young 区（新数据区）和 old 区（老数据区）</strong>。新读入的页先扔到 old 区，只有被再次访问才能晋升到 young 区 。这招太绝了——扫描几百万行的临时数据，最多占用 3/8 的 old 区，核心热点数据稳稳待在 young 区不受干扰。</p>
<p>配置建议？行业共识是<strong>物理内存的 70-80%</strong> 。但 Percona 的工程师跳出来打脸：对于 1TB 内存的大服务器，按 80% 规则分配 820GB 给缓冲池？扯淡！实际公式是 <strong>(总内存 - 7GB) × 0.9</strong> 。64GB 的机器，缓冲池设到 51GB 就够了——剩下的内存要留给连接管理、查询排序、操作系统缓存（今年大家都在玩云原生，内存超分可太常见了）。[^4][^5]</p>
<h2 data-id="heading-1">Redo Log：崩溃恢复的救命稻草</h2>
<p>**MySQL 如何做到"宕机也不丢数据"？**秘密藏在 WAL（Write-Ahead Logging）机制里 。简单来说就是：<strong>先写日志，再刷数据</strong> 。当你执行一条 UPDATE 语句，InnoDB 不会傻乎乎立刻把脏页刷到磁盘（随机 IO 太慢了），而是先把修改记录写入 Redo Log，事务就算提交成功 。</p>
<p>啧啧，这逻辑听着像"空手套白狼"？但数学不会骗人。Redo Log 是<strong>顺序写</strong>，一秒能写几千次；数据页刷盘是<strong>随机写</strong>，可能只有几百次 。万一服务器突然断电，重启后 MySQL 读取 Redo Log，把未刷盘的数据页恢复回来——这就是崩溃恢复（Crash Recovery）的完整链路 。</p>
<p>关键参数 <code>innodb_flush_log_at_trx_commit</code> 有三档设置 ：</p>
<ul>
<li><strong>设成 1（默认）</strong>：每次事务提交都刷盘，最安全但性能最低</li>
<li><strong>设成 2</strong>：每秒刷一次盘，性能飙升但宕机可能丢 1 秒数据</li>
<li><strong>设成 0</strong>：写到内存就返回，最快但风险最高</li>
</ul>
<p>什么概念？从 1 改成 2，写入 QPS 能翻倍 。但代价是断电瞬间，那些还在内存里的事务就永久蒸发了 。<strong>金融系统死磕 1，日志类业务用 2，你得根据业务属性选</strong> 。</p>
<p>Undo Log 是另一条暗线 。它不仅负责事务回滚（执行失败时还原现场），更是 MVCC 实现的基础——<strong>通过 Undo Log 串起来的历史版本链，MySQL 才能让读操作不加锁</strong> 。</p>
<h2 data-id="heading-2">MVCC：读写不阻塞的黑魔法</h2>
<p>**为什么 SELECT 不需要加锁？**这是 InnoDB 最骚的设计。传统数据库要么读加锁（阻塞写），要么写加锁（阻塞读），MVCC（多版本并发控制）直接掀桌：<strong>每条记录存多个版本，读旧版本、写新版本，互不干扰</strong> 。</p>
<p>三个核心组件撑起整套机制 ：</p>
<ul>
<li><strong>隐藏列</strong>：每行记录带两个隐藏字段——trx_id（创建该版本的事务 ID）和 roll_pointer（指向 Undo Log 里的旧版本）</li>
<li><strong>Undo Log</strong>：存储历史版本数据，通过 roll_pointer 串成链表</li>
<li><strong>Read View</strong>：事务启动时生成的"快照"，决定能看到哪些版本</li>
</ul>
<p>敢情这就是版本链的精髓！事务 A 在改数据时，事务 B 读取的是旧版本（通过 roll_pointer 回溯 Undo Log），两边完全不冲突 。但"快照读"和"当前读"差别巨大：</p>
<ul>
<li><strong>快照读（普通 SELECT）</strong>：读历史版本，不加锁</li>
<li><strong>当前读（SELECT FOR UPDATE）</strong>：读最新版本，必须加锁</li>
</ul>
<p>MySQL 默认隔离级别是 <strong>RR（可重复读）</strong> 而非 RC（读已提交），核心原因在 Read View 生成时机 ：</p>
<ul>
<li><strong>RC 模式</strong>：每次查询都生成新 Read View，能看到其他事务已提交的修改</li>
<li><strong>RR 模式</strong>：事务开始时生成唯一 Read View，整个事务期间看到的数据保持一致</li>
</ul>
<p>什么概念？在 RR 隔离级别下，你第一次查询看到余额 100 元，就算别的事务把余额改成 200 元并提交了，你这个事务里再查还是 100 元——这叫"可重复读" 。但代价是可能出现幻读（其他事务插入新行），这就是为什么 InnoDB 还得靠间隙锁来补刀。</p>
<h2 data-id="heading-3">从原理到实战：完整生命周期</h2>
<p>把三大机制串起来看，一条 <code>UPDATE users SET balance = 200 WHERE id = 1</code> 到底经历了啥？</p>
<ol>
<li><strong>执行器启动</strong>：先去缓冲池找 id=1 的数据页，命中直接读取，未命中就从磁盘加载进缓冲池</li>
<li><strong>写 Undo Log</strong>：把旧版本（balance=100）写入 Undo Log，生成 roll_pointer 指针</li>
<li><strong>更新数据页</strong>：在缓冲池里把 balance 改成 200，标记为脏页，此时<strong>数据还没刷盘</strong></li>
<li><strong>写 Redo Log</strong>：把"将 id=1 的 balance 改成 200"这条操作记录到 Redo Log</li>
<li><strong>提交事务</strong>：根据 <code>innodb_flush_log_at_trx_commit</code> 决定何时刷盘，事务提交完成</li>
</ol>
<p>整个链路下来，磁盘只写了一次 Redo Log（顺序写），数据页的随机写被延后到后台刷脏页线程慢慢处理 。<strong>这就是为什么 InnoDB 能扛住每秒上万次写入</strong> 。</p>
<p>性能优化的五条铁律：</p>
<ul>
<li><strong>缓冲池别小气</strong>：专用数据库服务器，直接设到物理内存的 75%（小于 64GB 机器）或用 (RAM - 7GB) × 0.9 公式[^4]</li>
<li><strong>日志刷盘看场景</strong>：非金融业务可以把 <code>innodb_flush_log_at_trx_commit</code> 改成 2，性能翻倍</li>
<li><strong>避免长事务</strong>：事务开启超过 10 分钟，Undo Log 膨胀会拖垮整个系统</li>
<li><strong>监控命中率</strong>：缓冲池命中率低于 95%，立刻检查是不是有全表扫描在"污染"缓存</li>
<li><strong>拆分大查询</strong>：单次扫描超过 10 万行，考虑加索引或改业务逻辑</li>
</ul>
<p>真实案例：某电商公司遇到慢查询，发现缓冲池命中率只有 60% 。排查后发现是报表任务每小时跑一次全表扫描，把核心交易数据全挤出缓存了。解决方案？给报表查询单独分配从库，主库缓冲池命中率立刻飙回 98%，查询耗时从 5 秒降到 50ms。</p>
<hr/>
<p>InnoDB 的高性能不是魔法，而是缓冲池、Redo Log、MVCC 三大机制精密协作的结果。<strong>懂原理和会用命令，差的是十倍调优效率</strong>。现在去检查你的 <code>innodb_buffer_pool_size</code> 是多少？用 <code>SHOW ENGINE INNODB STATUS</code> 看看缓冲池命中率？把 <code>EXPLAIN</code> 结果贴出来，咱们评论区一起分析慢查询到底卡在哪儿。</p>
<p>你还想深挖 InnoDB 的哪些黑科技？索引底层的 B+ 树实现？锁机制里的间隙锁和临键锁？留言告诉我，下期安排！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[SQL Server 完整锁类型详解]]></title>    <link>https://juejin.cn/post/7590071125398503464</link>    <guid>https://juejin.cn/post/7590071125398503464</guid>    <pubDate>2026-01-02T11:16:57.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7590071125398503464" data-draft-id="7590054976489685032" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="SQL Server 完整锁类型详解"/> <meta itemprop="keywords" content="数据库"/> <meta itemprop="datePublished" content="2026-01-02T11:16:57.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="大巨头"/> <meta itemprop="url" content="https://juejin.cn/user/3993841710667752"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            SQL Server 完整锁类型详解
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3993841710667752/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    大巨头
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-02T11:16:57.000Z" title="Fri Jan 02 2026 11:16:57 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-02
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    2
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">SQL Server 完整锁类型详解</h2>
<p>你想了解 SQL Server 中的所有锁类型，SQL Server 的锁按<strong>锁定资源粒度</strong>和<strong>锁的功能类型</strong>可分为两大核心分类，同时有明确的兼容性规则，下面为你逐一拆解所有关键锁类型：</p>
<h3 data-id="heading-1">一、 按锁的功能类型分类（核心业务相关锁）</h3>
<p>这是日常开发、排查锁阻塞时最常接触的锁类型，按“共享/排他/特殊功能”划分：</p>
<h4 data-id="heading-2">1. 共享类锁（允许多会话同时持有，不相互阻塞）</h4>























<table><thead><tr><th>锁类型标识</th><th>锁名称</th><th>核心用途</th><th>关键特性</th></tr></thead><tbody><tr><td>S</td><td>共享锁（Shared Lock）</td><td>保护数据读取操作（如 <code>SELECT</code>），防止读取期间数据被修改</td><td>1. 多个会话可同时持有同一资源的 <code>S</code> 锁 2. 与 <code>X</code> 锁（排他锁）、<code>U</code> 锁（更新锁）互斥 3. 阻塞写操作（<code>INSERT/UPDATE/DELETE</code>），不阻塞读操作 4. 默认读完即释放（事务内持有至事务结束）</td></tr><tr><td>Sch-S</td><td>架构稳定性锁（Schema Stability Lock）</td><td>保护对象架构（表、视图等）不被修改，确保访问对象期间架构稳定</td><td>1. 所有访问对象的操作（无论读写）都会自动授予 2. 多个会话可同时持有，与 <code>S/X/U</code> 等数据锁兼容 3. 仅与 <code>Sch-M</code> 锁（架构修改锁）互斥 4. 操作完成后立即释放，几乎无性能开销</td></tr></tbody></table>
<h4 data-id="heading-3">2. 排他类锁（仅允许单个会话持有，阻塞所有其他锁）</h4>























<table><thead><tr><th>锁类型标识</th><th>锁名称</th><th>核心用途</th><th>关键特性</th></tr></thead><tbody><tr><td>X</td><td>排他锁（Exclusive Lock）</td><td>保护数据修改操作（<code>INSERT/UPDATE/DELETE</code>），防止并发修改数据</td><td>1. 同一资源仅能被一个会话持有 <code>X</code> 锁 2. 与所有其他锁（<code>S/U/Sch-S</code> 等）都互斥 3. 阻塞所有读、写操作，持有至事务提交/回滚 4. 数据修改时自动授予，无需显式指定</td></tr><tr><td>Sch-M</td><td>架构修改锁（Schema Modification Lock）</td><td>保护对象架构修改操作，确保架构修改期间无其他会话访问该对象</td><td>1. 执行 <code>ALTER TABLE/DROP TABLE/RENAME TABLE</code> 等操作时授予 2. 排他锁，与所有锁（包括 <code>Sch-S</code> 锁）互斥 3. 阻塞该对象的所有读写操作，操作完成后释放 4. 优先级极高，通常会等待现有锁释放后再授予</td></tr></tbody></table>
<h4 data-id="heading-4">3. 特殊功能锁（介于共享与排他之间，解决特定场景问题）</h4>



























































<table><thead><tr><th>锁类型标识</th><th>锁名称</th><th>核心用途</th><th>关键特性</th></tr></thead><tbody><tr><td>U</td><td>更新锁（Update Lock）</td><td>用于更新操作的前期锁定（先查后改场景），防止死锁</td><td>1. 执行 <code>UPDATE</code> 时，先对目标资源授予 <code>U</code> 锁，确认需要修改后升级为 <code>X</code> 锁 2. 同一资源仅能被一个会话持有 <code>U</code> 锁（互斥），与 <code>S</code> 锁兼容，与 <code>X/U</code> 锁互斥 3. 避免多个会话同时持有 <code>S</code> 锁后升级为 <code>X</code> 锁导致的死锁 4. 持有至事务提交/回滚或升级为 <code>X</code> 锁</td></tr><tr><td>IX</td><td>意向排他锁（Intent Exclusive Lock）</td><td>标识会话<strong>意向</strong>对某个资源的下级粒度（如表→行）持有 <code>X</code> 锁，用于快速锁检测</td><td>1. 对下级资源加 <code>X</code> 锁前，先对上级资源加 <code>IX</code> 锁（如更新某行前，先对表加 <code>IX</code> 锁） 2. 与 <code>S/IS</code> 锁互斥，与 <code>IX/U</code> 等锁兼容 3. 仅用于锁层级检测，不直接阻塞数据操作 4. 自动授予，无需显式控制</td></tr><tr><td>IS</td><td>意向共享锁（Intent Shared Lock）</td><td>标识会话<strong>意向</strong>对某个资源的下级粒度持有 <code>S</code> 锁，用于快速锁检测</td><td>1. 对下级资源加 <code>S</code> 锁前，先对上级资源加 <code>IS</code> 锁（如查询某行前，先对表加 <code>IS</code> 锁） 2. 与大多数锁（<code>S/IS/IX/U</code> 等）兼容，仅与 <code>X/Sch-M</code> 锁互斥 3. 无实际阻塞作用，仅用于锁层级校验 4. 自动授予，操作完成后快速释放</td></tr><tr><td>IU</td><td>意向更新锁（Intent Update Lock）</td><td>标识会话<strong>意向</strong>对某个资源的下级粒度持有 <code>U</code> 锁，是 <code>U</code> 锁的意向锁</td><td>1. 对下级资源加 <code>U</code> 锁前，先对上级资源加 <code>IU</code> 锁 2. 兼容性与 <code>IX</code> 锁类似，与 <code>S/IS</code> 锁兼容，与 <code>X/Sch-M</code> 锁互斥 3. 仅用于锁层级管理，日常场景中较少直接观测到</td></tr><tr><td>BU</td><td>大容量更新锁（Bulk Update Lock）</td><td>用于大容量数据加载操作（如 <code>BULK INSERT</code>），提高批量操作性能</td><td>1. 仅在启用 <code>TABLOCK</code> 提示或批量加载选项时授予 2. 同一表可被多个会话持有 <code>BU</code> 锁（相互兼容），与 <code>S</code> 锁兼容，与 <code>X/Sch-M</code> 锁互斥 3. 阻塞普通写操作，不阻塞批量加载操作和读操作 4. 大幅提升大容量数据插入的性能，减少锁竞争</td></tr><tr><td>RangeS-S</td><td>范围共享-共享锁（键范围锁）</td><td>用于可序列化隔离级别下的范围查询，防止幻读</td><td>1. 锁定查询结果的键范围及对应数据，防止其他会话插入/修改该范围内的数据 2. 共享锁特性，多个会话可同时持有，与 <code>X</code> 锁互斥 3. 仅在可序列化隔离级别下生效，是防止幻读的核心锁 4. 持有至事务结束</td></tr><tr><td>RangeS-U</td><td>范围共享-更新锁（键范围锁）</td><td>用于可序列化隔离级别下的范围更新查询前期锁定</td><td>1. 介于 <code>RangeS-S</code> 和 <code>RangeX-X</code> 之间，先锁定范围，再升级为更新锁 2. 互斥性与 <code>U</code> 锁类似，防止并发范围更新导致的死锁 3. 仅在可序列化隔离级别下生效</td></tr><tr><td>RangeX-X</td><td>范围排他-排他锁（键范围锁）</td><td>用于可序列化隔离级别下的范围数据修改，防止范围数据被篡改</td><td>1. 排他性锁，锁定键范围及数据，阻塞所有对该范围的读写操作 2. 与所有键范围锁和数据锁互斥，持有至事务结束 3. 可序列化隔离级别下修改范围数据时自动授予</td></tr></tbody></table>
<h3 data-id="heading-5">二、 按锁定资源粒度分类（锁的作用范围）</h3>
<p>SQL Server 支持“锁升级”机制（从细粒度锁升级为粗粒度锁，减少锁资源开销），按粒度从细到粗分为：</p>
<ol start="0">
<li>
<p><strong>行级锁（Row Lock）</strong></p>
<ul>
<li>最细粒度的锁，锁定表中的单条或多条记录（通过主键/索引定位）</li>
<li>优点：锁竞争最小，并发性能最高；缺点：锁数量过多时，消耗内存资源</li>
<li>对应锁类型：<code>S/X/U</code> 等，日常 <code>SELECT/UPDATE</code> 优先使用行级锁</li>
</ul>
</li>
<li>
<p><strong>页级锁（Page Lock）</strong></p>
<ul>
<li>锁定数据页（SQL Server 中一页默认8KB），包含多条行记录</li>
<li>优点：锁数量少于行级锁，内存开销小；缺点：锁竞争比行级锁高（锁定一页即锁定所有行）</li>
<li>对应锁类型：<code>S/X/U</code> 等，当行级锁数量过多时，会升级为页级锁</li>
</ul>
</li>
<li>
<p><strong>表级锁（Table Lock）</strong></p>
<ul>
<li>锁定整个数据表，粒度最粗</li>
<li>优点：锁管理开销最小，无需维护大量细粒度锁；缺点：锁竞争最大，并发性能最低</li>
<li>对应锁类型：<code>S/X/Sch-S/Sch-M/IX/IS</code> 等，锁升级的最终级别（默认行级锁数量超过5000时升级为表级锁）</li>
</ul>
</li>
<li>
<p><strong>其他粒度锁（较少见）</strong></p>
<ul>
<li><strong>数据库锁</strong>：锁定整个数据库（如 <code>ALTER DATABASE</code> 操作），标识为 <code>D</code></li>
<li><strong>文件锁</strong>：锁定数据库文件，标识为 <code>F</code></li>
<li><strong>索引锁</strong>：锁定索引页或索引键，标识为 <code>I</code></li>
<li><strong>元数据锁</strong>：锁定系统元数据（如系统视图），标识为 <code>M</code></li>
</ul>
</li>
</ol>
<h3 data-id="heading-6">三、 核心补充：锁的兼容性与锁升级</h3>
<h4 data-id="heading-7">1. 核心兼容性规则（关键）</h4>
<ul>
<li>共享类锁（<code>S/Sch-S/IS</code>）之间相互兼容，可同时持有</li>
<li>排他类锁（<code>X/Sch-M</code>）与所有其他锁都互斥，仅能单独持有</li>
<li>意向锁（<code>IX/IS/IU</code>）仅与排他类锁互斥，与共享类锁、其他意向锁兼容</li>
<li>更新锁（<code>U</code>）仅与 <code>S/IS</code> 锁兼容，与 <code>X/U/IX</code> 等锁互斥</li>
</ul>
<h4 data-id="heading-8">2. 锁升级机制</h4>
<ul>
<li>触发条件：当单个会话对某表的行级锁/页级锁数量超过阈值（默认5000个锁），或锁资源消耗过多时，SQL Server 会自动将细粒度锁升级为表级锁</li>
<li>目的：减少锁的维护开销，降低内存占用</li>
<li>控制方式：可通过 <code>ALTER TABLE 表名 SET LOCK_ESCALATION = {AUTO | TABLE | DISABLE}</code> 调整锁升级策略</li>
</ul>
<h3 data-id="heading-9">总结</h3>
<ol start="0">
<li>核心功能锁：<code>S</code>（读锁）、<code>X</code>（写锁）、<code>Sch-S</code>（架构稳定）、<code>Sch-M</code>（架构修改）、<code>U</code>（更新）是日常排查的重点；</li>
<li>意向锁（<code>IX/IS</code>）：用于锁层级检测，无直接业务影响；</li>
<li>键范围锁（<code>RangeS-S/RangeX-X</code>）：仅在可序列化隔离级别下生效，防止幻读；</li>
<li>粒度分类：行级（高并发）→ 页级 → 表级（低并发），支持自动锁升级；</li>
<li>核心规则：共享锁兼容、排他锁互斥、意向锁用于快速检测。</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[面试官 : ” 说一下 Vue 中的 setup 中的 props 和 context “]]></title>    <link>https://juejin.cn/post/7590159073988706356</link>    <guid>https://juejin.cn/post/7590159073988706356</guid>    <pubDate>2026-01-02T11:53:28.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7590159073988706356" data-draft-id="7590128405350596608" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="面试官 : ” 说一下 Vue 中的 setup 中的 props 和 context “"/> <meta itemprop="keywords" content="前端,Vue.js,面试"/> <meta itemprop="datePublished" content="2026-01-02T11:53:28.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="千寻girling"/> <meta itemprop="url" content="https://juejin.cn/user/2276467567770442"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            面试官 : ” 说一下 Vue 中的 setup 中的 props 和 context “
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2276467567770442/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    千寻girling
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-02T11:53:28.000Z" title="Fri Jan 02 2026 11:53:28 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-02
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{color:#595959;font-size:15px;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(60,10,30,.04) 3%,transparent 0),linear-gradient(1turn,rgba(60,10,30,.04) 3%,transparent 0);background-size:20px 20px;background-position:50%}.markdown-body p{color:#595959;font-size:15px;line-height:2;font-weight:400}.markdown-body p+p{margin-top:16px}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{padding:30px 0;margin:0;color:#135ce0}.markdown-body h1{position:relative;text-align:center;font-size:22px;margin:50px 0}.markdown-body h1:before{position:absolute;content:"";top:-10px;left:50%;width:32px;height:32px;transform:translateX(-50%);background-size:100% 100%;opacity:.36;background-repeat:no-repeat;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABfVBMVEX///8Ad/8AgP8AgP8AgP8Aff8AgP8Af/8AgP8AVf8Af/8Af/8AgP8AgP8Af/8Afv8AAP8Afv8Afv8Aef8AgP8AdP8Afv8AgP8AgP8Acf8Ae/8AgP8Af/8AgP8Af/8Af/8AfP8Afv8AgP8Af/8Af/8Afv8Afv8AgP8Afv8AgP8Af/8Af/8AgP8AgP8Afv8AgP8Af/8AgP8AgP8AgP8Ae/8Afv8Af/8AgP8Af/8AgP8Af/8Af/8Aff8Af/8Abf8AgP8Af/8AgP8Af/8Af/8Afv8AgP8AgP8Afv8Afv8AgP8Af/8Aff8AgP8Afv8AgP8Aff8AgP8AfP8AgP8Ae/8AgP8Af/8AgP8AgP8AgP8Afv8AgP8AgP8AgP8Afv8AgP8AgP8AgP8AgP8AgP8Af/8AgP8Af/8Af/8Aev8Af/8AgP8Aff8Afv8AgP8AgP8AgP8Af/8AgP8Af/8Af/8AgP8Afv8AgP8AgP8AgP8AgP8Af/8AeP8Af/8Af/8Af//////rzEHnAAAAfXRSTlMAD7CCAivatxIDx5EMrP19AXdLEwgLR+6iCR/M0yLRzyFF7JupSXn8cw6v60Q0QeqzKtgeG237HMne850/6Qeq7QaZ+WdydHtj+OM3qENCMRYl1B3K2U7wnlWE/mhlirjkODa9FN/BF7/iNV/2kASNZpX1Wlf03C4stRGxgUPclqoAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEaBzgZ4yeM3AAAAT9JREFUOMvNUldbwkAQvCAqsSBoABE7asSOBRUVVBQNNuy9996789+9cMFAMHnVebmdm+/bmdtbQv4dOFOW2UjPzgFyLfo6nweKfIMOBYWwFtmMPGz2Yj2pJI0JDq3udJW6VVbmKa9I192VQFV1ktXUAl5NB0cd4KpnORqsEO2ZIRpF9gJfE9Dckqq0KuZt7UAH5+8EPF3spjsRpCeQNO/tA/qDwIDA+OCQbBoKA8NOdjMySgcZGVM6jwcgRuUiSs0nlPFNSrEpJfU0jTLD6llqbvKxei7OzvkFNQohi0vAsj81+MoqsCaoPOQFgus/1LyxichW+hS2JWCHZ7VlF9jb187pIAYcHiViHAMnp5mTjJ8B5xeEXF4B1ze/fTh/C0h398DDI9HB07O8ci+vRBdvdGnfP4gBuM8vw7X/G3wDmFhFZEdxzjMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDEtMjZUMDc6NTY6MjUrMDE6MDA67pVWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAxLTI2VDA3OjU2OjI1KzAxOjAwS7Mt6gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAWdEVYdFRpdGxlAGp1ZWppbl9sb2dvIGNvcHlxapmKAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC)}.markdown-body h2{position:relative;font-size:20px;border-left:4px solid;padding:0 0 0 10px;margin:30px 0}.markdown-body h3{font-size:16px}.markdown-body ul{list-style:disc outside;margin-left:2em;margin-top:1em}.markdown-body li{line-height:2;color:#595959}.markdown-body img.loaded{margin:0 auto;display:block}.markdown-body blockquote{background:#fff9f9;margin:2em 0;padding:2px 20px;border-left:4px solid #b2aec5}.markdown-body blockquote p{color:#666;line-height:2}.markdown-body a{color:#036aca;border-bottom:1px solid rgba(3,106,202,.8);font-weight:400;text-decoration:none}.markdown-body em strong,.markdown-body strong{color:#036aca}.markdown-body hr{border-top:1px solid #135ce0}.markdown-body pre{overflow:auto}.markdown-body code,.markdown-body pre{overflow:auto;position:relative;line-height:1.75;font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body table{border-collapse:collapse;margin:1rem 0;overflow-x:auto}.markdown-body table td,.markdown-body table th{border:1px solid #dfe2e5;padding:.6em 1em}.markdown-body table tr{border-top:1px solid #dfe2e5}.markdown-body table tr:nth-child(2n){background-color:#f6f8fa}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h3 data-id="heading-0">一、props：和 Vue2 核心逻辑完全一致，仅访问方式微调</h3>
<p><code>props</code> 作为 Vue 「父传子」的核心通信方式</p>
<p>Vue3 中 <strong>单向数据流、类型校验、默认值 / 必传项</strong> 等核心规则和 Vue2 完全一样，唯一区别是「访问方式」：</p>
<h4 data-id="heading-1">1. 共性（Vue2/Vue3 通用）</h4>
<ul>
<li>单向数据流：子组件不能直接修改 props，必须通过 <code>emit</code> 通知父组件修改；</li>
<li>支持类型校验（ String / Number / Array / Object 等）、默认值、自定义校验规则；</li>
<li>父组件传的属性如果没被 props 声明，会落到 <code>attrs</code> 中（下文会提）。</li>
</ul>
<h4 data-id="heading-2">2. 用法对比（Vue2 选项式 vs Vue3 组合式）</h4>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-comment">&lt;!-- Vue2 选项式 API --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">props</span>: {
    <span class="hljs-attr">name</span>: { <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>, <span class="hljs-attr">default</span>: <span class="hljs-string">'默认名'</span> },
    <span class="hljs-attr">age</span>: { <span class="hljs-attr">type</span>: <span class="hljs-title class_">Number</span>, <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span> }
  },
  <span class="hljs-title function_">mounted</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>); <span class="hljs-comment">// 👉 通过 this 访问</span>
  }
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-comment">&lt;!-- Vue3 组合式 API（setup） --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-comment">// 👉 props 定义规则和 Vue2 完全一样</span>
  <span class="hljs-attr">props</span>: {
    <span class="hljs-attr">name</span>: { <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>, <span class="hljs-attr">default</span>: <span class="hljs-string">'默认名'</span> },
    <span class="hljs-attr">age</span>: { <span class="hljs-attr">type</span>: <span class="hljs-title class_">Number</span>, <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span> }
  },
  <span class="hljs-comment">// 👉 props 作为 setup 第一个参数传入，无需 this</span>
  <span class="hljs-title function_">setup</span>(<span class="hljs-params">props</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(props.<span class="hljs-property">name</span>); <span class="hljs-comment">// 直接访问</span>
    <span class="hljs-comment">// 注意：props 是响应式的，解构会丢失响应式，需用 toRefs</span>
    <span class="hljs-keyword">const</span> { name } = <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">toRefs</span>(props);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name.<span class="hljs-property">value</span>); <span class="hljs-comment">// ref 需 .value 访问</span>
  }
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<h3 data-id="heading-3">二、context：Vue3 把 Vue2 的「this 上的通信属性」聚合到上下文</h3>
<p><code>context</code> 是 <code>setup</code> 的第二个参数（非响应式，可直接解构），核心作用是替代 Vue2 中 <code>this</code> 上的「非 props 相关通信能力」，你提到的几个属性对应关系精准，补充用法细节：</p>






























<table><thead><tr><th>context 属性</th><th>Vue2 对应写法</th><th>核心用法示例</th></tr></thead><tbody><tr><td>context.emit</td><td>this.$emit</td><td>子传父触发事件：<code>context.emit('change', { id: 1 })</code>（父组件用 <code>@change</code> 接收）</td></tr><tr><td>context.slots</td><td>this.$slots</td><td>访问父组件传入的插槽：<code>context.slots.header()</code>（Vue3 插槽是函数，需加 () 调用）</td></tr><tr><td>context.attrs</td><td>this.$attrs</td><td>接收父组件未被 props 声明的属性：父传 <code>class="box"</code> 且 props 未声明 → <code>context.attrs.class</code></td></tr><tr><td>context.expose()</td><td>无（Vue2 无此能力）</td><td>主动暴露子组件内部属性给父组件：<code>context.expose({ fn: () =&gt; console.log('暴露的方法') })</code></td></tr></tbody></table>
<h4 data-id="heading-4">核心示例（context 解构使用，更简洁）</h4>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-title function_">setup</span>(<span class="hljs-params">props, { emit, slots, attrs, expose }</span>) {
    <span class="hljs-comment">// 1. 子传父：触发自定义事件</span>
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"/>) =&gt; <span class="hljs-title function_">emit</span>(<span class="hljs-string">'submit'</span>, <span class="hljs-string">'子组件数据'</span>);

    <span class="hljs-comment">// 2. 访问具名插槽</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(slots.<span class="hljs-title function_">footer</span>()); <span class="hljs-comment">// 获取父组件传入的 footer 插槽内容</span>

    <span class="hljs-comment">// 3. 访问未声明的属性</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(attrs[<span class="hljs-string">'data-id'</span>]); <span class="hljs-comment">// 父传 data-id="123" 且未被 props 声明</span>

    <span class="hljs-comment">// 4. 暴露内部方法给父组件（父通过 ref 仅能访问暴露的内容）</span>
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">internalFn</span> = (<span class="hljs-params"/>) =&gt; <span class="hljs-string">'内部逻辑'</span>;
    <span class="hljs-title function_">expose</span>({ internalFn }); <span class="hljs-comment">// 父组件 ref.value.internalFn() 可调用</span>

    <span class="hljs-keyword">return</span> { handleClick };
  }
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<h4 data-id="heading-5">1. 子组件（Child.vue）：核心逻辑详解</h4>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-comment">&lt;!-- 点击按钮触发子传父事件 --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"handleClick"</span>&gt;</span>点击触发submit事件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

  <span class="hljs-comment">&lt;!-- 渲染父组件传入的footer具名插槽 --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"slot-container"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"footer"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

  <span class="hljs-comment">&lt;!-- 把attrs中的data-id透传给内部div（演示attrs用法） --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:data-id</span>=<span class="hljs-string">"attrs['data-id']"</span>&gt;</span>透传父组件未声明的data-id属性<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
<span class="hljs-comment">// 导入vue的核心方法（按需导入，Vue3组合式API规范）</span>
<span class="hljs-keyword">import</span> { toRefs } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-comment">// 第一步：声明props（仅声明name，未声明data-id，所以data-id会落到attrs中）</span>
  <span class="hljs-attr">props</span>: {
    <span class="hljs-attr">name</span>: {
      <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,
      <span class="hljs-attr">default</span>: <span class="hljs-string">'默认名称'</span>
    }
  },

  <span class="hljs-comment">// setup第二个参数解构出：emit（子传父）、slots（插槽）、attrs（透传属性）、expose（暴露内容）</span>
  <span class="hljs-title function_">setup</span>(<span class="hljs-params">props, { emit, slots, attrs, expose }</span>) {
    <span class="hljs-comment">// 👉 1. 子传父：触发自定义事件（核心用法）</span>
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"/>) =&gt; {
      <span class="hljs-comment">// 第一个参数：事件名（父组件用@submit接收）；第二个参数：传递给父组件的数据</span>
      <span class="hljs-title function_">emit</span>(<span class="hljs-string">'submit'</span>, {
        <span class="hljs-attr">msg</span>: <span class="hljs-string">'子组件传递的数据'</span>,
        <span class="hljs-attr">name</span>: props.<span class="hljs-property">name</span> <span class="hljs-comment">// 结合props使用，把props数据也传给父组件</span>
      });
    };

    <span class="hljs-comment">// 👉 2. 访问具名插槽（控制台打印插槽内容，验证是否传入）</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'===== 访问footer插槽 ====='</span>);
    <span class="hljs-comment">// Vue3中slots的每个插槽都是函数，调用后返回VNode数组（插槽的DOM结构）</span>
    <span class="hljs-keyword">if</span> (slots.<span class="hljs-property">footer</span>) { <span class="hljs-comment">// 先判断父组件是否传入了footer插槽，避免报错</span>
      <span class="hljs-keyword">const</span> footerSlotContent = slots.<span class="hljs-title function_">footer</span>();
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'footer插槽的VNode内容：'</span>, footerSlotContent);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'父组件未传入footer插槽'</span>);
    }

    <span class="hljs-comment">// 👉 3. 访问父组件未被props声明的属性（attrs）</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'===== 访问attrs ====='</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'父组件传入的data-id：'</span>, attrs[<span class="hljs-string">'data-id'</span>]); <span class="hljs-comment">// 父传的data-id未被props声明，所以在attrs中</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'父组件传入的class（若有）：'</span>, attrs.<span class="hljs-property">class</span>); <span class="hljs-comment">// class/style会自动透传，也会在attrs中</span>
    <span class="hljs-comment">// 注意：attrs是非响应式的，若需要响应式，可结合toRefs（但一般attrs无需响应式）</span>

    <span class="hljs-comment">// 👉 4. 暴露子组件内部方法/属性给父组件（父组件通过ref访问）</span>
    <span class="hljs-comment">// 定义子组件内部方法（未return也能通过expose暴露）</span>
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">internalFn</span> = (<span class="hljs-params"/>) =&gt; {
      <span class="hljs-keyword">return</span> <span class="hljs-string">`内部方法执行成功！props.name的值是：<span class="hljs-subst">${props.name}</span>`</span>;
    };
    <span class="hljs-comment">// 定义内部属性（仅暴露给父组件，模板中无法直接使用，除非return）</span>
    <span class="hljs-keyword">const</span> internalData = <span class="hljs-string">'子组件内部私有数据'</span>;

    <span class="hljs-comment">// 主动暴露指定内容（只有这里声明的，父组件才能通过ref访问）</span>
    <span class="hljs-title function_">expose</span>({
      internalFn, <span class="hljs-comment">// 暴露内部方法</span>
      internalData, <span class="hljs-comment">// 暴露内部属性</span>
      <span class="hljs-comment">// 也可以暴露props（方便父组件直接获取props值）</span>
      <span class="hljs-attr">getPropsName</span>: <span class="hljs-function">() =&gt;</span> props.<span class="hljs-property">name</span>
    });

    <span class="hljs-comment">// 👉 5. 补充：props的响应式使用（可选）</span>
    <span class="hljs-comment">// 解构props并保留响应式（若需要单独使用props中的属性）</span>
    <span class="hljs-keyword">const</span> { name } = <span class="hljs-title function_">toRefs</span>(props);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'===== props使用 ====='</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'props.name的值（响应式）：'</span>, name.<span class="hljs-property">value</span>);

    <span class="hljs-comment">// 把需要在模板中使用的方法return出去（handleClick在模板中绑定点击事件，必须return）</span>
    <span class="hljs-keyword">return</span> {
      handleClick,
      attrs <span class="hljs-comment">// 把attrsreturn出去，方便模板中使用（如上面模板中的:data-id="attrs['data-id']"）</span>
    };
  }
};
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<h4 data-id="heading-6">2. 父组件（Parent.vue）：调用子组件并配合使用</h4>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"parent-container"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>父组件<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- 第二步：使用子组件，完成以下操作：
         1. 传props：name="测试名称"
         2. 传未声明的属性：data-id="10086"（会落到子组件attrs中）
         3. 绑定子组件的自定义事件：@submit="handleChildSubmit"
         4. 传入具名插槽：&lt;template #footer&gt;...&lt;/template&gt;
         5. 给子组件加ref：childRef（用于访问子组件暴露的内容）
    --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">Child</span>
      <span class="hljs-attr">ref</span>=<span class="hljs-string">"childRef"</span>
      <span class="hljs-attr">name</span>=<span class="hljs-string">"测试名称"</span>
      <span class="hljs-attr">data-id</span>=<span class="hljs-string">"10086"</span>
      <span class="hljs-attr">class</span>=<span class="hljs-string">"child-component"</span>
      @<span class="hljs-attr">submit</span>=<span class="hljs-string">"handleChildSubmit"</span>
    &gt;</span>
      <span class="hljs-comment">&lt;!-- 传入footer具名插槽（子组件会访问这个插槽） --&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">footer</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是父组件传给子组件的footer插槽内容<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">Child</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- 显示子组件传递的数据 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"child-data"</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"childSubmitData"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>子组件传递的数据：<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>msg：{{ childSubmitData.msg }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>name：{{ childSubmitData.name }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- 点击按钮访问子组件暴露的方法/属性 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"accessChildExpose"</span>&gt;</span>访问子组件暴露的内容<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
<span class="hljs-comment">// 导入子组件</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./Child.vue'</span>;
<span class="hljs-comment">// 导入vue的ref（用于创建子组件的引用）和onMounted（生命周期）</span>
<span class="hljs-keyword">import</span> { ref, onMounted } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-comment">// 注册子组件</span>
  <span class="hljs-attr">components</span>: {
    <span class="hljs-title class_">Child</span>
  },

  <span class="hljs-title function_">setup</span>(<span class="hljs-params"/>) {
    <span class="hljs-comment">// 👉 1. 创建子组件的ref引用（用于访问子组件暴露的内容）</span>
    <span class="hljs-keyword">const</span> childRef = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>);

    <span class="hljs-comment">// 👉 2. 接收子组件的自定义事件数据</span>
    <span class="hljs-keyword">const</span> childSubmitData = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>);
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleChildSubmit</span> = (<span class="hljs-params">data</span>) =&gt; {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'父组件接收到子组件的submit事件数据：'</span>, data);
      childSubmitData.<span class="hljs-property">value</span> = data; <span class="hljs-comment">// 把数据存到响应式变量中，模板中显示</span>
    };

    <span class="hljs-comment">// 👉 3. 访问子组件通过expose暴露的内容</span>
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">accessChildExpose</span> = (<span class="hljs-params"/>) =&gt; {
      <span class="hljs-comment">// 确保子组件已挂载（避免初始时childRef.value为null）</span>
      <span class="hljs-keyword">if</span> (childRef.<span class="hljs-property">value</span>) {
        <span class="hljs-comment">// 调用子组件暴露的internalFn方法</span>
        <span class="hljs-keyword">const</span> fnResult = childRef.<span class="hljs-property">value</span>.<span class="hljs-title function_">internalFn</span>();
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'调用子组件暴露的internalFn结果：'</span>, fnResult);

        <span class="hljs-comment">// 获取子组件暴露的internalData属性</span>
        <span class="hljs-keyword">const</span> internalData = childRef.<span class="hljs-property">value</span>.<span class="hljs-property">internalData</span>;
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'获取子组件暴露的internalData：'</span>, internalData);

        <span class="hljs-comment">// 调用子组件暴露的getPropsName方法（获取子组件的props.name）</span>
        <span class="hljs-keyword">const</span> propsName = childRef.<span class="hljs-property">value</span>.<span class="hljs-title function_">getPropsName</span>();
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'子组件的props.name：'</span>, propsName);

        <span class="hljs-comment">// 注意：子组件未暴露的内容，父组件无法访问（比如子组件的handleClick）</span>
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'访问子组件未暴露的handleClick：'</span>, childRef.<span class="hljs-property">value</span>.<span class="hljs-property">handleClick</span>); <span class="hljs-comment">// undefined</span>
      }
    };

    <span class="hljs-comment">// 👉 4. 生命周期：组件挂载后，也可以主动访问子组件暴露的内容</span>
    <span class="hljs-title function_">onMounted</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'===== 组件挂载后访问子组件暴露内容 ====='</span>);
      <span class="hljs-keyword">if</span> (childRef.<span class="hljs-property">value</span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'挂载后获取internalData：'</span>, childRef.<span class="hljs-property">value</span>.<span class="hljs-property">internalData</span>);
      }
    });

    <span class="hljs-comment">// return需要在模板中使用的变量/方法</span>
    <span class="hljs-keyword">return</span> {
      childRef,
      childSubmitData,
      handleChildSubmit,
      accessChildExpose
    };
  }
};
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<h3 data-id="heading-7">三、关键总结</h3>
<ol>
<li><code>props</code>：<strong>规则完全继承 Vue2</strong>，仅在 Vue3 setup 中需通过第一个参数访问，注意响应式解构（用 <code>toRefs</code>）；</li>
<li><code>context</code>：<strong>替代 Vue2 中 this 上的通信属性</strong>，把 <code>$emit/$slots/$attrs</code> 聚合到 <strong>上下文( context )</strong> ，新增 <code>expose()</code> 增强组件封装性（Vue2 父组件通过 ref 能访问子组件所有内容，Vue3 需主动暴露才可见）；</li>
<li>简化记忆：<code>setup(props, context)</code> → 第一个参数管「父传子的 props」，第二个参数管「子传父、插槽、透传属性、暴露内容」。</li>
</ol>
<p>这种设计既保留了 Vue2 的使用习惯，又让组合式 API 脱离了 <code>this</code> 的束缚，逻辑更聚合，是 Vue3 兼顾「易用性」和「灵活性」的核心设计。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[面试官 : “ 说一下 Vue 的 8 个生命周期钩子都做了什么 ? ”]]></title>    <link>https://juejin.cn/post/7590054976489783336</link>    <guid>https://juejin.cn/post/7590054976489783336</guid>    <pubDate>2026-01-02T12:53:42.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7590054976489783336" data-draft-id="7590159073988739124" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="面试官 : “ 说一下 Vue 的 8 个生命周期钩子都做了什么 ? ”"/> <meta itemprop="keywords" content="前端,Vue.js,面试"/> <meta itemprop="datePublished" content="2026-01-02T12:53:42.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="千寻girling"/> <meta itemprop="url" content="https://juejin.cn/user/2276467567770442"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            面试官 : “ 说一下 Vue 的 8 个生命周期钩子都做了什么 ? ”
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2276467567770442/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    千寻girling
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-02T12:53:42.000Z" title="Fri Jan 02 2026 12:53:42 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-02
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{color:#595959;font-size:15px;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(60,10,30,.04) 3%,transparent 0),linear-gradient(1turn,rgba(60,10,30,.04) 3%,transparent 0);background-size:20px 20px;background-position:50%}.markdown-body p{color:#595959;font-size:15px;line-height:2;font-weight:400}.markdown-body p+p{margin-top:16px}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{padding:30px 0;margin:0;color:#135ce0}.markdown-body h1{position:relative;text-align:center;font-size:22px;margin:50px 0}.markdown-body h1:before{position:absolute;content:"";top:-10px;left:50%;width:32px;height:32px;transform:translateX(-50%);background-size:100% 100%;opacity:.36;background-repeat:no-repeat;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABfVBMVEX///8Ad/8AgP8AgP8AgP8Aff8AgP8Af/8AgP8AVf8Af/8Af/8AgP8AgP8Af/8Afv8AAP8Afv8Afv8Aef8AgP8AdP8Afv8AgP8AgP8Acf8Ae/8AgP8Af/8AgP8Af/8Af/8AfP8Afv8AgP8Af/8Af/8Afv8Afv8AgP8Afv8AgP8Af/8Af/8AgP8AgP8Afv8AgP8Af/8AgP8AgP8AgP8Ae/8Afv8Af/8AgP8Af/8AgP8Af/8Af/8Aff8Af/8Abf8AgP8Af/8AgP8Af/8Af/8Afv8AgP8AgP8Afv8Afv8AgP8Af/8Aff8AgP8Afv8AgP8Aff8AgP8AfP8AgP8Ae/8AgP8Af/8AgP8AgP8AgP8Afv8AgP8AgP8AgP8Afv8AgP8AgP8AgP8AgP8AgP8Af/8AgP8Af/8Af/8Aev8Af/8AgP8Aff8Afv8AgP8AgP8AgP8Af/8AgP8Af/8Af/8AgP8Afv8AgP8AgP8AgP8AgP8Af/8AeP8Af/8Af/8Af//////rzEHnAAAAfXRSTlMAD7CCAivatxIDx5EMrP19AXdLEwgLR+6iCR/M0yLRzyFF7JupSXn8cw6v60Q0QeqzKtgeG237HMne850/6Qeq7QaZ+WdydHtj+OM3qENCMRYl1B3K2U7wnlWE/mhlirjkODa9FN/BF7/iNV/2kASNZpX1Wlf03C4stRGxgUPclqoAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEaBzgZ4yeM3AAAAT9JREFUOMvNUldbwkAQvCAqsSBoABE7asSOBRUVVBQNNuy9996789+9cMFAMHnVebmdm+/bmdtbQv4dOFOW2UjPzgFyLfo6nweKfIMOBYWwFtmMPGz2Yj2pJI0JDq3udJW6VVbmKa9I192VQFV1ktXUAl5NB0cd4KpnORqsEO2ZIRpF9gJfE9Dckqq0KuZt7UAH5+8EPF3spjsRpCeQNO/tA/qDwIDA+OCQbBoKA8NOdjMySgcZGVM6jwcgRuUiSs0nlPFNSrEpJfU0jTLD6llqbvKxei7OzvkFNQohi0vAsj81+MoqsCaoPOQFgus/1LyxichW+hS2JWCHZ7VlF9jb187pIAYcHiViHAMnp5mTjJ8B5xeEXF4B1ze/fTh/C0h398DDI9HB07O8ci+vRBdvdGnfP4gBuM8vw7X/G3wDmFhFZEdxzjMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDEtMjZUMDc6NTY6MjUrMDE6MDA67pVWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAxLTI2VDA3OjU2OjI1KzAxOjAwS7Mt6gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAWdEVYdFRpdGxlAGp1ZWppbl9sb2dvIGNvcHlxapmKAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC)}.markdown-body h2{position:relative;font-size:20px;border-left:4px solid;padding:0 0 0 10px;margin:30px 0}.markdown-body h3{font-size:16px}.markdown-body ul{list-style:disc outside;margin-left:2em;margin-top:1em}.markdown-body li{line-height:2;color:#595959}.markdown-body img.loaded{margin:0 auto;display:block}.markdown-body blockquote{background:#fff9f9;margin:2em 0;padding:2px 20px;border-left:4px solid #b2aec5}.markdown-body blockquote p{color:#666;line-height:2}.markdown-body a{color:#036aca;border-bottom:1px solid rgba(3,106,202,.8);font-weight:400;text-decoration:none}.markdown-body em strong,.markdown-body strong{color:#036aca}.markdown-body hr{border-top:1px solid #135ce0}.markdown-body pre{overflow:auto}.markdown-body code,.markdown-body pre{overflow:auto;position:relative;line-height:1.75;font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body table{border-collapse:collapse;margin:1rem 0;overflow-x:auto}.markdown-body table td,.markdown-body table th{border:1px solid #dfe2e5;padding:.6em 1em}.markdown-body table tr{border-top:1px solid #dfe2e5}.markdown-body table tr:nth-child(2n){background-color:#f6f8fa}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h3 data-id="heading-0">一、Vue3 8 个核心生命周期钩子（按执行顺序）</h3>




































































<table><thead><tr><th>阶段</th><th>选项式 API 名称</th><th>组合式 API 名称</th><th>执行时机</th><th>核心作用 &amp; 实战场景</th></tr></thead><tbody><tr><td>初始化阶段</td><td>beforeCreate</td><td>无（setup 替代）</td><td>实例创建前，数据 / 方法未初始化，<code>this</code> 不可用</td><td>Vue2 中用于初始化非响应式数据；Vue3 中逻辑移到 <code>setup</code> 最顶部（无响应式操作）</td></tr><tr><td>初始化阶段</td><td>created</td><td>无（setup 替代）</td><td>实例创建完成，数据 / 方法已初始化，DOM 未生成</td><td>1. 发起异步请求（接口请求）；2. 初始化非 DOM 相关逻辑（如数据格式化）</td></tr><tr><td>挂载阶段</td><td>beforeMount</td><td>onBeforeMount</td><td>挂载开始前，模板编译完成，DOM 未挂载到页面（<code>$el</code> 未生成）</td><td>1. 预操作 DOM 结构（如计算 DOM 尺寸，需结合 <code>nextTick</code>）；2. 初始化第三方库（挂载前准备）</td></tr><tr><td>挂载阶段</td><td>mounted</td><td>onMounted</td><td>DOM 挂载完成（<code>$el</code> 已挂载），页面可见</td><td>1. 操作真实 DOM（如初始化 ECharts / 地图）；2. 发起依赖 DOM 的异步请求；3. 监听 DOM 事件</td></tr><tr><td>更新阶段</td><td>beforeUpdate</td><td>onBeforeUpdate</td><td>数据更新后，DOM 重新渲染前</td><td>1. 获取更新前的 DOM 状态（如旧输入框值）；2. 取消不必要的监听 / 定时器（避免重复执行）</td></tr><tr><td>更新阶段</td><td>onUpdated</td><td>onUpdated</td><td>DOM 重新渲染完成，页面已更新</td><td>1. 获取更新后的 DOM 状态；2. 重新计算 DOM 相关数据（如滚动位置重置）</td></tr><tr><td>卸载阶段</td><td>beforeUnmount</td><td>onBeforeUnmount</td><td>组件卸载前（实例仍可用，DOM 未销毁）</td><td>1. 清理副作用（清除定时器 / 事件监听）；2. 销毁第三方库实例（如 ECharts 销毁）</td></tr><tr><td>卸载阶段</td><td>unmounted</td><td>onUnmounted</td><td>组件卸载完成，DOM 销毁，实例失效</td><td>1. 最终清理（如取消接口请求）；2. 释放内存（清空大型数组 / 对象引用）</td></tr></tbody></table>
<h3 data-id="heading-1">二、关键细节（Vue3 核心变化）</h3>
<h4 data-id="heading-2">1. setup 替代 beforeCreate/created</h4>
<p>Vue3 中 <code>setup</code> 执行时机 = <code>beforeCreate</code> + <code>created</code>，这两个钩子在组合式 API 中被废弃，所有初始化逻辑直接写在 <code>setup</code> 中：</p>
<p>以下是 Vue3 生命周期钩子的<strong>完整可运行代码示例</strong>，包含<strong>选项式 API</strong> 和<strong>组合式 API（<code>&lt;script setup&gt;</code> 推荐写法）</strong>  两种风格，附带详细注释和实战场景（如接口请求、DOM 操作、定时器清理等），可直接复制到 Vue3 项目中运行。</p>
<h3 data-id="heading-3">三、组合式 API 示例（<code>&lt;script setup&gt;</code> 推荐）</h3>
<p><strong>Vue3 生命周期演示</strong></p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"life-cycle-demo"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>Vue3 生命周期演示（组合式 API）<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- 绑定响应式数据，触发更新阶段 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>当前计数：{{ count }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"count++"</span>&gt;</span>点击更新计数（触发更新钩子）<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- 挂载 ECharts 示例 DOM --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"chart"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"width: 300px; height: 200px; margin: 20px 0;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">import</span> { 
  ref, 
  onBeforeMount, 
  onMounted, 
  onBeforeUpdate, 
  onUpdated, 
  onBeforeUnmount, 
  unmounted 
} <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>;
<span class="hljs-comment">// 模拟 ECharts（实际需安装：npm install echarts）</span>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> echarts <span class="hljs-keyword">from</span> <span class="hljs-string">'echarts'</span>;

<span class="hljs-comment">// 🫱🫱🫱 1. setup 本身替代 beforeCreate + created（初始化阶段）</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'===== setup 执行（等价于 beforeCreate + created）====='</span>);
<span class="hljs-comment">// 响应式数据初始化</span>
<span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);
<span class="hljs-comment">// 模拟接口请求（created 阶段核心场景）</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchData</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'发起异步接口请求（created 阶段）'</span>);
    <span class="hljs-comment">// 模拟接口延迟</span>
    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> {
      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>({ <span class="hljs-attr">data</span>: <span class="hljs-string">'模拟接口返回数据'</span> }), <span class="hljs-number">1000</span>);
    });
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'接口请求完成：'</span>, res.<span class="hljs-property">data</span>);
  } <span class="hljs-keyword">catch</span> (err) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'接口请求失败：'</span>, err);
  }
};
<span class="hljs-comment">// 执行接口请求（等价于 created 中调用）</span>
<span class="hljs-title function_">fetchData</span>();

<span class="hljs-comment">// 🫱🫱🫱 2. 挂载阶段：beforeMount（DOM 未挂载）</span>
<span class="hljs-title function_">onBeforeMount</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'===== onBeforeMount 执行 ====='</span>);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'DOM 未挂载，#chart 元素：'</span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'chart'</span>)); <span class="hljs-comment">// null</span>
  <span class="hljs-comment">// 若需提前操作 DOM，需结合 nextTick</span>
});

<span class="hljs-comment">// 🫱🫱🫱 3. 挂载阶段：mounted（DOM 已挂载，核心操作 DOM 场景）</span>
<span class="hljs-keyword">let</span> myChart = <span class="hljs-literal">null</span>;
<span class="hljs-title function_">onMounted</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'===== onMounted 执行 ====='</span>);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'DOM 已挂载，#chart 元素：'</span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'chart'</span>)); <span class="hljs-comment">// 存在</span>
  <span class="hljs-comment">// 初始化 ECharts（依赖 DOM 的第三方库）</span>
  myChart = echarts.<span class="hljs-title function_">init</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'chart'</span>));
  myChart.<span class="hljs-title function_">setOption</span>({
    <span class="hljs-attr">title</span>: { <span class="hljs-attr">text</span>: <span class="hljs-string">'生命周期演示图表'</span> },
    <span class="hljs-attr">xAxis</span>: { <span class="hljs-attr">type</span>: <span class="hljs-string">'category'</span>, <span class="hljs-attr">data</span>: [<span class="hljs-string">'Mon'</span>, <span class="hljs-string">'Tue'</span>, <span class="hljs-string">'Wed'</span>] },
    <span class="hljs-attr">yAxis</span>: { <span class="hljs-attr">type</span>: <span class="hljs-string">'value'</span> },
    <span class="hljs-attr">series</span>: [{ <span class="hljs-attr">data</span>: [<span class="hljs-number">120</span>, <span class="hljs-number">200</span>, <span class="hljs-number">150</span>], <span class="hljs-attr">type</span>: <span class="hljs-string">'bar'</span> }]
  });
  <span class="hljs-comment">// 模拟定时器（需在卸载阶段清理）</span>
  <span class="hljs-keyword">const</span> timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'定时器运行中（count：'</span>, count.<span class="hljs-property">value</span>, <span class="hljs-string">'）'</span>);
  }, <span class="hljs-number">1000</span>);
  <span class="hljs-comment">// 把定时器存到全局，方便卸载时清理</span>
  <span class="hljs-variable language_">window</span>.<span class="hljs-property">lifeCycleTimer</span> = timer;
});

<span class="hljs-comment">// 🫱🫱🫱 4. 更新阶段：beforeUpdate（数据更新，DOM 未重新渲染）</span>
<span class="hljs-title function_">onBeforeUpdate</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'===== onBeforeUpdate 执行 ====='</span>);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'数据已更新（count：'</span>, count.<span class="hljs-property">value</span>, <span class="hljs-string">'），DOM 未刷新'</span>);
  <span class="hljs-comment">// 可获取更新前的 DOM 状态（如旧的图表数据）</span>
});

<span class="hljs-comment">// 🫱🫱🫱 5. 更新阶段：updated（DOM 已重新渲染）</span>
<span class="hljs-title function_">onUpdated</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'===== onUpdated 执行 ====='</span>);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'DOM 已更新（count：'</span>, count.<span class="hljs-property">value</span>, <span class="hljs-string">'）'</span>);
  <span class="hljs-comment">// 若数据更新后需重新渲染图表</span>
  <span class="hljs-keyword">if</span> (myChart) {
    myChart.<span class="hljs-title function_">setOption</span>({
      <span class="hljs-attr">series</span>: [{ <span class="hljs-attr">data</span>: [<span class="hljs-number">120</span> + count.<span class="hljs-property">value</span> * <span class="hljs-number">10</span>, <span class="hljs-number">200</span> + count.<span class="hljs-property">value</span> * <span class="hljs-number">10</span>, <span class="hljs-number">150</span> + count.<span class="hljs-property">value</span> * <span class="hljs-number">10</span>] }]
    });
  }
});

<span class="hljs-comment">// 🫱🫱🫱 6. 卸载阶段：beforeUnmount（组件即将卸载，清理副作用）</span>
<span class="hljs-title function_">onBeforeUnmount</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'===== onBeforeUnmount 执行 ====='</span>);
  <span class="hljs-comment">// 清理定时器</span>
  <span class="hljs-built_in">clearInterval</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">lifeCycleTimer</span>);
  <span class="hljs-comment">// 销毁 ECharts 实例</span>
  <span class="hljs-keyword">if</span> (myChart) {
    myChart.<span class="hljs-title function_">dispose</span>();
    myChart = <span class="hljs-literal">null</span>;
  }
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'副作用已清理（定时器、ECharts 已销毁）'</span>);
});

<span class="hljs-comment">// 🫱🫱🫱 7. 卸载阶段：unmounted（组件已完全卸载）</span>
<span class="hljs-title function_">unmounted</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'===== unmounted 执行 ====='</span>);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'组件已卸载，DOM 已销毁，实例失效'</span>);
});
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<h3 data-id="heading-4">四、选项式 API 示例（兼容 Vue2 写法）</h3>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"life-cycle-demo"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>Vue3 生命周期演示（选项式 API）<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>当前计数：{{ count }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"count++"</span>&gt;</span>点击更新计数<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"chart"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"width: 300px; height: 200px; margin: 20px 0;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> echarts <span class="hljs-keyword">from</span> <span class="hljs-string">'echarts'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-comment">// 响应式数据</span>
  <span class="hljs-title function_">data</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,
      <span class="hljs-attr">myChart</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">timer</span>: <span class="hljs-literal">null</span>
    };
  },

  <span class="hljs-comment">// 🫱🫱🫱 1. 初始化阶段：beforeCreate（实例刚创建，数据/方法未初始化）</span>
  <span class="hljs-title function_">beforeCreate</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'===== beforeCreate 执行 ====='</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'数据未初始化：'</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>); <span class="hljs-comment">// undefined</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'方法未初始化：'</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">fetchData</span>); <span class="hljs-comment">// undefined</span>
  },

  <span class="hljs-comment">// 🫱🫱🫱 2. 初始化阶段：created（数据/方法已初始化，DOM 未生成）</span>
  <span class="hljs-title function_">created</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'===== created 执行 ====='</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'数据已初始化：'</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>); <span class="hljs-comment">// 0</span>
    <span class="hljs-comment">// 发起异步请求</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">fetchData</span>();
  },

  <span class="hljs-comment">// 🫱🫱🫱 3. 挂载阶段：beforeMount（模板编译完成，DOM 未挂载）</span>
  <span class="hljs-title function_">beforeMount</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'===== beforeMount 执行 ====='</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'DOM 未挂载，#chart 元素：'</span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'chart'</span>)); <span class="hljs-comment">// null</span>
  },

  <span class="hljs-comment">// 🫱🫱🫱 4. 挂载阶段：mounted（DOM 已挂载，可操作真实 DOM）</span>
  <span class="hljs-title function_">mounted</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'===== mounted 执行 ====='</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'DOM 已挂载，#chart 元素：'</span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'chart'</span>)); <span class="hljs-comment">// 存在</span>
    <span class="hljs-comment">// 初始化 ECharts</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">myChart</span> = echarts.<span class="hljs-title function_">init</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'chart'</span>));
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">myChart</span>.<span class="hljs-title function_">setOption</span>({
      <span class="hljs-attr">title</span>: { <span class="hljs-attr">text</span>: <span class="hljs-string">'选项式 API 图表'</span> },
      <span class="hljs-attr">xAxis</span>: { <span class="hljs-attr">type</span>: <span class="hljs-string">'category'</span>, <span class="hljs-attr">data</span>: [<span class="hljs-string">'Mon'</span>, <span class="hljs-string">'Tue'</span>, <span class="hljs-string">'Wed'</span>] },
      <span class="hljs-attr">yAxis</span>: { <span class="hljs-attr">type</span>: <span class="hljs-string">'value'</span> },
      <span class="hljs-attr">series</span>: [{ <span class="hljs-attr">data</span>: [<span class="hljs-number">120</span>, <span class="hljs-number">200</span>, <span class="hljs-number">150</span>], <span class="hljs-attr">type</span>: <span class="hljs-string">'bar'</span> }]
    });
    <span class="hljs-comment">// 启动定时器</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">timer</span> = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'定时器运行中（count：'</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>, <span class="hljs-string">'）'</span>);
    }, <span class="hljs-number">1000</span>);
  },

  <span class="hljs-comment">// 🫱🫱🫱 5. 更新阶段：beforeUpdate（数据更新，DOM 未重新渲染）</span>
  <span class="hljs-title function_">beforeUpdate</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'===== beforeUpdate 执行 ====='</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'数据已更新（count：'</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>, <span class="hljs-string">'），DOM 未刷新'</span>);
  },

  <span class="hljs-comment">// 🫱🫱🫱 6. 更新阶段：updated（DOM 已重新渲染）</span>
  <span class="hljs-title function_">updated</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'===== updated 执行 ====='</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'DOM 已更新（count：'</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>, <span class="hljs-string">'）'</span>);
    <span class="hljs-comment">// 重新渲染图表</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">myChart</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">myChart</span>.<span class="hljs-title function_">setOption</span>({
        <span class="hljs-attr">series</span>: [{ <span class="hljs-attr">data</span>: [<span class="hljs-number">120</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> * <span class="hljs-number">10</span>, <span class="hljs-number">200</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> * <span class="hljs-number">10</span>, <span class="hljs-number">150</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> * <span class="hljs-number">10</span>] }]
      });
    }
  },

  <span class="hljs-comment">// 🫱🫱🫱 7. 卸载阶段：beforeUnmount（组件即将卸载，清理副作用）</span>
  <span class="hljs-title function_">beforeUnmount</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'===== beforeUnmount 执行 ====='</span>);
    <span class="hljs-comment">// 清理定时器</span>
    <span class="hljs-built_in">clearInterval</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">timer</span>);
    <span class="hljs-comment">// 销毁 ECharts</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">myChart</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">myChart</span>.<span class="hljs-title function_">dispose</span>();
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">myChart</span> = <span class="hljs-literal">null</span>;
    }
  },

  <span class="hljs-comment">// 🫱🫱🫱 8. 卸载阶段：unmounted（组件已完全卸载）</span>
  <span class="hljs-title function_">unmounted</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'===== unmounted 执行 ====='</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'组件已卸载，资源已清理'</span>);
  },

  <span class="hljs-comment">// 自定义方法：模拟接口请求</span>
  <span class="hljs-attr">methods</span>: {
    <span class="hljs-keyword">async</span> <span class="hljs-title function_">fetchData</span>(<span class="hljs-params"/>) {
      <span class="hljs-keyword">try</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'发起接口请求（created 阶段）'</span>);
        <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> {
          <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>({ <span class="hljs-attr">data</span>: <span class="hljs-string">'选项式 API 接口数据'</span> }), <span class="hljs-number">1000</span>);
        });
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'接口请求完成：'</span>, res.<span class="hljs-property">data</span>);
      } <span class="hljs-keyword">catch</span> (err) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'接口请求失败：'</span>, err);
      }
    }
  }
};
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<h3 data-id="heading-5">五、测试方式（验证生命周期执行）</h3>
<ol>
<li>
<p><strong>挂载阶段</strong>：页面加载后，控制台会依次打印 <code>setup</code>/<code>beforeCreate</code>→<code>created</code>→<code>beforeMount</code>→<code>mounted</code>，同时 ECharts 图表渲染完成，定时器开始运行。</p>
</li>
<li>
<p><strong>更新阶段</strong>：点击 “点击更新计数” 按钮，触发 <code>beforeUpdate</code>→<code>updated</code>，图表数据随计数更新。</p>
</li>
<li>
<p><strong>卸载阶段</strong>：</p>
<ul>
<li>若使用路由，跳转到其他页面（组件卸载）；</li>
<li>或手动移除组件（如用 <code>v-if</code> 控制），控制台会打印 <code>beforeUnmount</code>→<code>unmounted</code>，定时器停止，ECharts 实例销毁。</li>
</ul>
</li>
</ol>
<h3 data-id="heading-6">六、核心注意点</h3>
<ol>
<li><strong>组合式 API 无 <code>beforeCreate/created</code></strong>：所有初始化逻辑直接写在 <code>&lt;script setup&gt;</code> 顶部，等价于这两个钩子。</li>
<li><strong>副作用必须清理</strong>：定时器、事件监听、第三方库实例（如 ECharts）需在 <code>onBeforeUnmount</code>/<code>beforeUnmount</code> 中清理，避免内存泄漏。</li>
<li><strong>DOM 操作仅在 <code>mounted/updated</code> 中安全</strong>：<code>beforeMount</code> 中操作 DOM 需结合 <code>nextTick</code>。</li>
<li><strong>updated 中避免无限循环</strong>：不要在 <code>updated</code> 中直接修改响应式数据（除非加条件判断）。</li>
</ol>
<p>通过这个示例，你可以直观看到每个生命周期钩子的执行时机和实际用途，覆盖日常开发中 90% 以上的生命周期场景</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[webpack异步加载原理梳理解构]]></title>    <link>https://juejin.cn/post/7590128405350875136</link>    <guid>https://juejin.cn/post/7590128405350875136</guid>    <pubDate>2026-01-02T14:03:06.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7590128405350875136" data-draft-id="7589935326782996514" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="webpack异步加载原理梳理解构"/> <meta itemprop="keywords" content="前端,JavaScript,Webpack"/> <meta itemprop="datePublished" content="2026-01-02T14:03:06.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="sophie旭"/> <meta itemprop="url" content="https://juejin.cn/user/2559318799692952"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            webpack异步加载原理梳理解构
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2559318799692952/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    sophie旭
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-02T14:03:06.000Z" title="Fri Jan 02 2026 14:03:06 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-02
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    8
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">背景：</h2>
<p>这几天重新梳理了一下 webpack异步加载的原理，并对实现细节进行了一番拆解，再次让我感叹：真是万变不离其宗，基础知识真的是构建上层建筑的坚实底座，在此也分享给大家，希望大家可以领略到webpack实现异步加载之美</p>
<h2 data-id="heading-1">基座一：webpack模块化方案</h2>
<h3 data-id="heading-2">你可能也吐槽过 webpack产物为啥这么丑？</h3>
<h4 data-id="heading-3">原始源代码</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// src/index.js (入口文件)</span>
<span class="hljs-keyword">let</span> title = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./title.js'</span>)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(title);
<span class="hljs-comment">// src/title.js</span>
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-string">'bu'</span>;
</code></pre>
<h4 data-id="heading-4">构建后产物结构概览</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">/******/</span> (<span class="hljs-function">() =&gt;</span> { <span class="hljs-comment">// webpack bootstrap 启动函数</span>
<span class="hljs-comment">/******/</span> 	<span class="hljs-keyword">var</span> __webpack_modules__ = ([
<span class="hljs-comment">/* 0 */</span> <span class="hljs-comment">/* title.js 模块 */</span>
(<span class="hljs-function">(<span class="hljs-params"><span class="hljs-variable language_">module</span></span>) =&gt;</span> {
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-string">'bu'</span>;
}),
<span class="hljs-comment">/* 1 */</span> <span class="hljs-comment">/* index.js 模块 */</span>
(<span class="hljs-function">(<span class="hljs-params">__unused_webpack_module, __unused_webpack_exports, __webpack_require__</span>) =&gt;</span> {
<span class="hljs-keyword">let</span> title = <span class="hljs-title function_">__webpack_require__</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 加载模块0</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(title);
})
<span class="hljs-comment">/******/</span> 	]);
<span class="hljs-comment">/******/</span> 	<span class="hljs-comment">/* 模块缓存 */</span>
<span class="hljs-comment">/******/</span> 	<span class="hljs-keyword">var</span> __webpack_module_cache__ = {};
<span class="hljs-comment">/******/</span> 	<span class="hljs-comment">/* Webpack 自实现的 require 函数 */</span>
<span class="hljs-comment">/******/</span> 	<span class="hljs-keyword">function</span> <span class="hljs-title function_">__webpack_require__</span>(<span class="hljs-params">moduleId</span>) {
<span class="hljs-comment">/******/</span> 		<span class="hljs-comment">/* 检查缓存 */</span>
<span class="hljs-comment">/******/</span> 		<span class="hljs-keyword">var</span> cachedModule = __webpack_module_cache__[moduleId];
<span class="hljs-comment">/******/</span> 		<span class="hljs-keyword">if</span> (cachedModule !== <span class="hljs-literal">undefined</span>) {
<span class="hljs-comment">/******/</span> 			<span class="hljs-keyword">return</span> cachedModule.<span class="hljs-property">exports</span>;
<span class="hljs-comment">/******/</span> 		}
<span class="hljs-comment">/******/</span> 		<span class="hljs-comment">/* 创建新模块并加入缓存 */</span>
<span class="hljs-comment">/******/</span> 		<span class="hljs-keyword">var</span> <span class="hljs-variable language_">module</span> = __webpack_module_cache__[moduleId] = {
<span class="hljs-comment">/******/</span> 			<span class="hljs-attr">exports</span>: {}
<span class="hljs-comment">/******/</span> 		};
<span class="hljs-comment">/******/</span> 		<span class="hljs-comment">/* 执行模块函数 */</span>
<span class="hljs-comment">/******/</span> 		__webpack_modules__[moduleId](<span class="hljs-variable language_">module</span>, <span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>, __webpack_require__);
<span class="hljs-comment">/******/</span> 		<span class="hljs-comment">/* 返回模块的 exports 对象 */</span>
<span class="hljs-comment">/******/</span> 		<span class="hljs-keyword">return</span> <span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>;
<span class="hljs-comment">/******/</span> 	}
<span class="hljs-comment">/******/</span> 	<span class="hljs-comment">/* 启动入口模块 */</span>
<span class="hljs-comment">/******/</span> 	<span class="hljs-keyword">return</span> <span class="hljs-title function_">__webpack_require__</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 加载入口模块(index.js)</span>
<span class="hljs-comment">/******/</span> })()
;
</code></pre>
<h3 data-id="heading-5">✅ 核心原因：规范转换成本（模块系统适配）</h3>
<p><strong>浏览器原生不支持模块规范</strong><br/>
浏览器无法直接执行 CommonJS/AMP/UMD 模块语法（如 <code>require()</code> / <code>module.exports</code> / <code>define()</code>）。Webpack 必须将这些规范<strong>统一转换为浏览器可执行的函数包装形式</strong>。</p>
<ul>
<li>
<p><strong>整个打包产物</strong>被包裹在一个<strong>外层 IIFE</strong> 中（立即执行）</p>
<ul>
<li><strong>意义</strong>：创建独立作用域</li>
</ul>
<pre><code class="hljs language-javascript" lang="javascript"> <span class="hljs-comment">// 未包裹：变量暴露全局</span>
<span class="hljs-keyword">var</span> utils = {...} <span class="hljs-comment">// 可能覆盖其他脚本的同名变量</span>

<span class="hljs-comment">// IIFE 包裹后：</span>
(<span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">var</span> utils = {...} <span class="hljs-comment">// 安全隔离</span>
})();
</code></pre>
</li>
<li>
<p><strong>每个模块</strong>被转换为<strong>标准函数</strong>（非立即执行），作为参数传递给运行时：function(module, exports...)</p>
<ul>
<li><strong>意义</strong>：<strong>模块环境隔离</strong> -每次调用模块函数时都会创建新的：</li>
</ul>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> <span class="hljs-variable language_">module</span> = { <span class="hljs-attr">exports</span>: {} };
modules[moduleId].<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>, ...);
</code></pre>
</li>
<li>
<p>模块路径被替换为 <strong>数字 ID</strong></p>
<ul>
<li>提升性能 &amp; 减少体积
<ul>
<li>✅ <strong>大幅缩短引用路径</strong>：<br/>
<code>'./src/utils/string-format.js'</code> → <code>__webpack_require__(17)</code></li>
<li>✅ <strong>避免路径解析开销</strong>：浏览器无需处理文件路径逻辑</li>
</ul>
</li>
</ul>
</li>
<li>
<p>原生 <code>require/module</code> 被替换为 Webpack 自实现的  <strong><code>__webpack_require__</code></strong>  函数</p>
<ul>
<li><strong>规范统一</strong>：将 ESM/CommonJS/AMD 转为浏览器可执行格式</li>
</ul>
</li>
<li>
<p>生成复杂的 <strong>运行时(runtime)代码</strong> 处理模块加载/缓存</p>
<ul>
<li>避免重复执行（如多次 <code>require</code> 同一模块）</li>
</ul>
</li>
<li>
<p>模块字典（所有代码被打包成键值对（键：上面提到的数字ID，值：上面提到的<strong>每个模块</strong>被转换的<strong>标准函数</strong>））</p>
<ul>
<li>✅ <strong>快速索引</strong>：通过数字 ID 实现 O(1) 复杂度的模块查找</li>
</ul>
</li>
</ul>
<h2 data-id="heading-6">基座二：jsonp</h2>
<p>传统的 JSONP 流程：</p>
<pre><code class="hljs language-mermaid" lang="mermaid">
sequenceDiagram

participant Client as 客户端

participant Server as 服务器

Client-&gt;&gt;Client: 创建回调函数

Note right of Client: window.myCallback = &lt;br/&gt;function(data){...}

Client-&gt;&gt;Server: 动态创建&lt;script src="api?callback=myCallback"&gt;

Server-&gt;&gt;Server: 准备数据

Server-&gt;&gt;Client: 返回 myCallback({...数据...})

Client-&gt;&gt;Client: 执行回调函数

</code></pre>
<p>Webpack 异步加载机制与 JSONP 的对比</p>
<ol>
<li><strong>脚本加载机制相同</strong>：</li>
</ol>
<pre><code class="hljs language-javascript" lang="javascript">
<span class="hljs-comment">// 两者都使用相同的基础加载方式</span>

<span class="hljs-keyword">const</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">'script'</span>);

script.<span class="hljs-property">src</span> = <span class="hljs-string">'resource.js'</span>;

<span class="hljs-variable language_">document</span>.<span class="hljs-property">head</span>.<span class="hljs-title function_">appendChild</span>(script);

</code></pre>
<ol start="2">
<li><strong>全局回调设计</strong>：</li>
</ol>
<pre><code class="hljs language-javascript" lang="javascript">
<span class="hljs-comment">// JSONP</span>

<span class="hljs-variable language_">window</span>.<span class="hljs-property">jsonpCallback</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) { ... }

<span class="hljs-comment">// Webpack</span>

<span class="hljs-variable language_">window</span>.<span class="hljs-property">webpackJsonp</span> = [];

<span class="hljs-variable language_">window</span>.<span class="hljs-property">webpackJsonp</span>.<span class="hljs-property">push</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) { ... }

</code></pre>
<ol start="3">
<li><strong>执行流程相似</strong>：</li>
</ol>
<pre><code class="hljs language-mermaid" lang="mermaid">
graph TD

A[创建 script 标签] --&gt; B[设置 src]

B --&gt; C[添加到 DOM]

C --&gt; D[服务器返回 JS]

D --&gt; E[执行 JS 代码]

E --&gt; F[触发全局回调]

</code></pre>
<p>那么不一样的地方在哪呢？</p>
<p>对了就是全局回调，异步加载的回调函数设计是非常精妙的，咱们往下看</p>
<h2 data-id="heading-7">精妙的全局回调设计-webpackJsonpCallback</h2>
<p>好了，现在我们拿到异步组件脚本了，我们应该做什么呢？</p>
<p><code>对了，就是要接入 我们上面聊的 webpack模块化方案，只有这样webpack 才能正常加载并缓存我们的异步模块</code></p>
<p>那么问题来了，怎样才能和上面说的 webpack模块化方案 接上轨呢？</p>
<p><code>答案就在 这个jsonp的全局回调上</code></p>
<p>显然我们要在回调里 把当前模块加入到 模块字典里，及 <strong>webpack_modules</strong> 里，</p>
<p><code>我们管这一步，叫做 全局模块注册，注意这里仅仅是注册模块，并没有执行模块</code></p>
<h3 data-id="heading-8">按需执行 如何做到</h3>
<p>好了，注册模块我们实现了，那么按需执行呢？</p>
<p>按需执行，即我们希望由我们来控制 什么时候执行该模块，那么如何实现呢？</p>
<h3 data-id="heading-9">精妙设计一：加载模块和执行模块分离--解耦请求与响应</h3>
<h3 data-id="heading-10"/>
<pre><code class="hljs language-mermaid" lang="mermaid">graph LR
A[发起请求] --&gt; B[存储控制器]
C[响应到达] --&gt; D[取出控制器]
D --&gt; E[触发回调]


</code></pre>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 步骤1: 初始化Promise</span>
<span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
  <span class="hljs-comment">// 这个回调会立即执行！</span>
  installedChunks[chunkId] = [[resolve, reject]];
});

<span class="hljs-comment">// 步骤2: 文件加载完成后</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">chunkLoaded</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> callbacks = installedChunks[chunkId];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [res] <span class="hljs-keyword">of</span> callbacks) {
    <span class="hljs-title function_">res</span>(); <span class="hljs-comment">// 手动触发所有resolve</span>
  }
  installedChunks[chunkId] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 标记为已加载</span>
}

<span class="hljs-comment">// 步骤3: 触发.then()</span>
promise.<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-comment">// 这里才会执行！</span>
  <span class="hljs-title function_">__webpack_require__</span>(moduleId);
});
</code></pre>
<p>也就是说在异步加载模块流程会封装成一个promise，
在加载模块前，我们会提前将该promise的resolve回调存储起来，存到 installedChunks；</p>
<p>当加载模块请求响应回来之后，我们从 installedChunks里拿到 resolve 回调执行
我们可以在resolve 里面控制何时 执行模块</p>
<pre><code class="hljs language-mermaid" lang="mermaid">
sequenceDiagram

participant T as .then()调用

participant R as Runtime(运行时)

participant S as 网络请求

T-&gt;&gt;R: __webpack_require__.e("hello_chunk")

activate R

R-&gt;&gt;R: 创建Promise&lt;br&gt;installedChunks["hello_chunk"] = [[resolve, reject]]

R-&gt;&gt;S: 发起chunk加载请求

deactivate R

S--&gt;&gt;R: 返回chunk内容

activate R

R-&gt;&gt;R: 执行webpackJsonpCallback

R-&gt;&gt;R: 找到对应resolve函数

R-&gt;&gt;Promise: 执行resolve()

deactivate R

Promise--&gt;&gt;T: 触发.then()回调

</code></pre>
<p>到这里我们可以给出__webpack_require__.e 和 webpackJsonpCallback的代码了：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 异步加载函数 (修正版)</span>
  __webpack_require__.<span class="hljs-property">e</span> = <span class="hljs-function">(<span class="hljs-params">chunkId</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
      <span class="hljs-comment">// 检查模块是否已加载</span>
      <span class="hljs-keyword">if</span> (installedChunks[chunkId] === <span class="hljs-number">0</span>) {
        <span class="hljs-title function_">resolve</span>();
        <span class="hljs-keyword">return</span>;
      }
      
      <span class="hljs-comment">// 检查是否已在加载中</span>
      <span class="hljs-keyword">if</span> (installedChunks[chunkId]) {
        installedChunks[chunkId].<span class="hljs-title function_">push</span>([resolve, reject]);
        <span class="hljs-keyword">return</span>;
      }
      
      <span class="hljs-comment">// 初始化加载状态</span>
      installedChunks[chunkId] = [[resolve, reject]];
      
      <span class="hljs-comment">// 创建脚本标签加载 chunk</span>
      <span class="hljs-keyword">const</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">'script'</span>);
      script.<span class="hljs-property">src</span> = <span class="hljs-string">`<span class="hljs-subst">${chunkId}</span>.js`</span>;
      script.<span class="hljs-property">onerror</span> = <span class="hljs-function">() =&gt;</span> {
        <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`Failed to load chunk <span class="hljs-subst">${chunkId}</span>`</span>));
        <span class="hljs-comment">// 清理加载状态</span>
        <span class="hljs-keyword">if</span> (installedChunks[chunkId]) {
          installedChunks[chunkId] = <span class="hljs-literal">undefined</span>;
        }
      };
      
      <span class="hljs-comment">// 关键步骤：将脚本添加到文档头部 (之前遗漏的部分)</span>
      <span class="hljs-variable language_">document</span>.<span class="hljs-property">head</span>.<span class="hljs-title function_">appendChild</span>(script);
    });
  };
  
<span class="hljs-keyword">function</span> <span class="hljs-title function_">webpackJsonpCallback</span>(<span class="hljs-params">data</span>) {
    <span class="hljs-keyword">const</span> [chunkIds, moreModules] = data;
    
    <span class="hljs-comment">// 注册新模块</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> moduleId <span class="hljs-keyword">in</span> moreModules) {
      __webpack_modules__[moduleId] = moreModules[moduleId];
    }
    
    <span class="hljs-comment">// 处理每个 chunk 的 Promise</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> chunkId <span class="hljs-keyword">of</span> chunkIds) {
      <span class="hljs-keyword">const</span> chunkState = installedChunks[chunkId];
      <span class="hljs-keyword">if</span> (!chunkState) <span class="hljs-keyword">continue</span>;
      
      <span class="hljs-comment">// 执行所有 resolve 回调</span>
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [resolve] <span class="hljs-keyword">of</span> chunkState) {
        <span class="hljs-title function_">resolve</span>();
      }
      
      <span class="hljs-comment">// 标记 chunk 为已加载</span>
      installedChunks[chunkId] = <span class="hljs-number">0</span>;
    }
  }
</code></pre>
<p>是不是很棒，加载由我们控制，执行也由我们控制，</p>
<h3 data-id="heading-11">精妙设计二：加载时序问题解决方案</h3>
<p>当我们加载异步组件后，我们发现它并不是用  webpackJsonpCallback 包裹起来,而是用 webpackJsonp.push</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// hello_chunk.js</span>
webpackJsonp.<span class="hljs-title function_">push</span>([[<span class="hljs-string">"hello_chunk"</span>], {<span class="hljs-string">"./src/hello.js"</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"/>){...}}])
</code></pre>
<p>在webpack 实现里我们会看到这句话：</p>
<p><code>webpackJsonp.push = webpackJsonpCallback;</code></p>
<p><code>为什么 webpack 要多此一举 ？为什么不直接用 webpackJsonpCallback 包裹起来呢?</code></p>
<h4 data-id="heading-12">核心原因：解决异步加载的顺序问题</h4>
<p><strong>加载顺序不确定性</strong>：</p>
<ul>
<li>
<p>异步 chunk 可能在主 runtime 加载完成之前就加载完毕（<code>关键：此时webpackJsonpCallback 可能还没有定义，因为 webpackJsonpCallback 是写在主 runtime里的</code>）</p>
</li>
<li>
<p>也可能在主 runtime 加载完成之后才加载</p>
</li>
</ul>
<h4 data-id="heading-13">关键设计：劫持push方法</h4>
<p><code>此时就算找不到 webpackJsonpCallback，但是 webpackJsonp.push 是原生方法，肯定可以找到，这样即使 webpackJsonpCallback 未定义，也不会让 已加载的分块 丢失</code></p>
<p><code>也就是允许任何时间加载的分块，webpack都能处理，完全解耦加载顺序</code></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 关键设计：劫持push方法</span>
webpackJsonp.<span class="hljs-property">push</span> = webpackJsonpCallback;

<span class="hljs-comment">// 处理初始化前已加载的分块</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; webpackJsonp.<span class="hljs-property">length</span>; i++) {
    <span class="hljs-title function_">webpackJsonpCallback</span>(webpackJsonp[i]);
}

webpackJsonp.<span class="hljs-property">length</span> = <span class="hljs-number">0</span>; <span class="hljs-comment">// 清空初始队列</span>

<span class="hljs-comment">// 将处理后的队列暴露到全局</span>
<span class="hljs-variable language_">window</span>.<span class="hljs-property">webpackJsonp</span> = webpackJsonp;
</code></pre>
<h4 data-id="heading-14">场景1：分块在主runtime之前加载完成</h4>
<pre><code class="hljs language-mermaid" lang="mermaid">
sequenceDiagram

participant Browser

participant Chunk as 异步分块

participant Runtime as Webpack Runtime

Browser-&gt;&gt;Chunk: 1. 加载分块文件

Chunk-&gt;&gt;Browser: 2. 执行分块代码

Note right of Chunk: webpackJsonp.push([[1], modules])

Browser-&gt;&gt;Runtime: 3. 加载主runtime

Runtime-&gt;&gt;Runtime: 4. 初始化时重写push方法

Runtime-&gt;&gt;Runtime: 5. 处理已缓存的推送

Runtime-&gt;&gt;Runtime: 6. 执行回调逻辑

</code></pre>
<h4 data-id="heading-15">场景2：分块在主runtime之后加载完成</h4>
<pre><code class="hljs language-mermaid" lang="mermaid">
sequenceDiagram

participant Browser

participant Runtime as Webpack Runtime

participant Chunk as 异步分块

Browser-&gt;&gt;Runtime: 1. 加载主runtime

Runtime-&gt;&gt;Runtime: 2. 初始化时重写push方法

Runtime-&gt;&gt;Runtime: 3. 处理初始队列(空)

Browser-&gt;&gt;Chunk: 4. 加载分块文件

Chunk-&gt;&gt;Browser: 5. 执行分块代码

Note right of Chunk: webpackJsonp.push([[1], modules])

Browser-&gt;&gt;Runtime: 6. 推送触发回调

</code></pre>
<h2 data-id="heading-16">总流程概览</h2>
<h4 data-id="heading-17">1. <strong>编译阶段（Build Time）</strong></h4>
<ul>
<li>
<p><strong>语法识别</strong>：Webpack 解析 AST 时识别 <code>import('./LazyComponent')</code> 语法</p>
</li>
<li>
<p><strong>模块分离</strong>：</p>
</li>
</ul>
<pre><code class="hljs language-javascript" lang="javascript">  <span class="hljs-comment">// 原始代码</span>
  <span class="hljs-keyword">import</span>(<span class="hljs-string">'./LazyComponent'</span>);
  
  <span class="hljs-comment">// Webpack 处理：</span>
  <span class="hljs-number">1.</span> 将 <span class="hljs-title class_">LazyComponent</span> 及其依赖抽离为独立 chunk（如 <span class="hljs-string">`src_LazyComponent_js.js`</span>）
  <span class="hljs-number">2.</span> 生成 chunk <span class="hljs-variable constant_">ID</span>（如 <span class="hljs-string">"chunk-lazy"</span>）
  <span class="hljs-number">3.</span> 生成模块 <span class="hljs-variable constant_">ID</span>（如 <span class="hljs-number">42</span>）
- **代码转换**：
  <span class="hljs-string">``</span><span class="hljs-string">`javascript
  // 转换后代码
  __webpack_require__.e("chunk-lazy")
    .then(__webpack_require__.bind(__webpack_require__, 42))
</span></code></pre>
<ul>
<li><strong>生成 chunk 文件</strong>：</li>
</ul>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// src_LazyComponent_js.js 内容</span>
  (<span class="hljs-variable language_">window</span>[<span class="hljs-string">"webpackJsonp"</span>] = <span class="hljs-variable language_">window</span>[<span class="hljs-string">"webpackJsonp"</span>] || []).<span class="hljs-title function_">push</span>([
    [<span class="hljs-string">"chunk-lazy"</span>],
    {
      <span class="hljs-string">"./src/LazyComponent.js"</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-variable language_">module</span>, __webpack_exports__, __webpack_require__</span>) =&gt;</span> {
        <span class="hljs-comment">// 模块实际代码</span>
      }
    }
  ]);
</code></pre>
<h4 data-id="heading-18">2. <strong>运行时阶段（Runtime）</strong></h4>
<ul>
<li><strong>触发加载</strong>：</li>
</ul>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 执行编译后的代码</span>
<span class="hljs-keyword">const</span> promise = __webpack_require__.<span class="hljs-title function_">e</span>(<span class="hljs-string">"chunk-lazy"</span>);
</code></pre>
<ul>
<li><strong>加载器执行</strong>：</li>
</ul>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// __webpack_require__.e 核心逻辑</span>
  __webpack_require__.<span class="hljs-property">e</span> = <span class="hljs-function">(<span class="hljs-params">chunkId</span>) =&gt;</span> {
    <span class="hljs-comment">// 检查缓存</span>
    <span class="hljs-keyword">if</span> (installedChunks[chunkId] === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>();
    
    <span class="hljs-comment">// 创建加载 Promise</span>
    <span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
      <span class="hljs-comment">// 创建 script 标签</span>
      <span class="hljs-keyword">const</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">'script'</span>);
      script.<span class="hljs-property">src</span> = <span class="hljs-string">`<span class="hljs-subst">${publicPath}</span><span class="hljs-subst">${chunkId}</span>.chunk.js`</span>;
      
      <span class="hljs-comment">// 错误处理</span>
      script.<span class="hljs-property">onerror</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`Loading failed <span class="hljs-subst">${chunkId}</span>`</span>));
      
      <span class="hljs-comment">// 注册全局回调</span>
      <span class="hljs-keyword">const</span> originalPush = webpackJsonp.<span class="hljs-property">push</span>.<span class="hljs-title function_">bind</span>(webpackJsonp);
      webpackJsonp.<span class="hljs-property">push</span> = <span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> {
        <span class="hljs-title function_">webpackJsonpCallback</span>(item);
        <span class="hljs-title function_">originalPush</span>(item);
      };

      <span class="hljs-comment">// 处理运行时初始化前已加载的数据</span>
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; webpackJsonp.<span class="hljs-property">length</span>; i++) {
        <span class="hljs-title function_">webpackJsonpCallback</span>(webpackJsonp[i]);
      }

      <span class="hljs-comment">// 清空队列但不移除引用</span>
      webpackJsonp.<span class="hljs-title function_">splice</span>(<span class="hljs-number">0</span>, webpackJsonp.<span class="hljs-property">length</span>);


      
      <span class="hljs-comment">// 触发加载</span>
      <span class="hljs-variable language_">document</span>.<span class="hljs-property">head</span>.<span class="hljs-title function_">appendChild</span>(script);
    });
    
    <span class="hljs-comment">// 标记为加载中</span>
    installedChunks[chunkId] = [promise, resolve, reject];
    <span class="hljs-keyword">return</span> promise;
  };
</code></pre>
<h4 data-id="heading-19">3. <strong>模块注册阶段（Chunk Execution）</strong></h4>
<ul>
<li><strong>Chunk 脚本执行</strong>：</li>
</ul>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 浏览器加载并执行 src_LazyComponent_js.js</span>
  <span class="hljs-variable language_">window</span>.<span class="hljs-property">webpackJsonp</span>.<span class="hljs-title function_">push</span>([
    [<span class="hljs-string">"chunk-lazy"</span>], 
    { 
      <span class="hljs-string">"./src/LazyComponent.js"</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">module</span>, <span class="hljs-built_in">exports</span></span>) {
        <span class="hljs-comment">// 组件实现</span>
        <span class="hljs-built_in">exports</span>.<span class="hljs-property">default</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">LazyComp</span>(<span class="hljs-params"/>) { ... }
      }
    }
  ]);
</code></pre>
<ul>
<li><strong>回调触发</strong>：</li>
</ul>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">webpackJsonpCallback</span>(<span class="hljs-params">data</span>) {
    <span class="hljs-keyword">const</span> [chunkIds, modules] = data;
    
    <span class="hljs-comment">// 1. 注册模块到全局存储</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> moduleId <span class="hljs-keyword">in</span> modules) {
      __webpack_modules__[moduleId] = modules[moduleId];
    }
    
    <span class="hljs-comment">// 2. 标记chunk为已加载</span>
    chunkIds.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">chunkId</span> =&gt;</span> {
      installedChunks[chunkId] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 0 = 已加载</span>
    });
    
    <span class="hljs-comment">// 3. 执行所有等待中的resolve</span>
    <span class="hljs-keyword">const</span> resolves = [];
    chunkIds.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">chunkId</span> =&gt;</span> {
      <span class="hljs-keyword">if</span> (installedChunks[chunkId]) {
        resolves.<span class="hljs-title function_">push</span>(installedChunks[chunkId][<span class="hljs-number">1</span>]); <span class="hljs-comment">// 获取resolve函数</span>
        installedChunks[chunkId] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 清除等待状态</span>
      }
    });
    <span class="hljs-comment">// resolve可以控制何时执行模块</span>
    <span class="hljs-comment">// 比如resolve可以是() =&gt; {</span>

    <span class="hljs-comment">// 执行模块加载</span>
    <span class="hljs-comment">//const module = __webpack_require__(42);</span>
    <span class="hljs-comment">//return module;</span>
    <span class="hljs-comment">//}</span>
    resolves.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-title function_">resolve</span>());
  }
</code></pre>
<p>至此，webpack异步加载原理 我们已经大致清楚了，是不是还挺有意思的，同时也能给我们一些启发，尤其精妙设计那里，希望有机会用到，这样我们也是站在巨人的肩膀上了～</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Vue3 应用实例创建及页面渲染底层原理]]></title>    <link>https://juejin.cn/post/7590020026395377718</link>    <guid>https://juejin.cn/post/7590020026395377718</guid>    <pubDate>2026-01-02T15:13:42.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7590020026395377718" data-draft-id="7590020026395361334" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Vue3 应用实例创建及页面渲染底层原理"/> <meta itemprop="keywords" content="前端,JavaScript,面试"/> <meta itemprop="datePublished" content="2026-01-02T15:13:42.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="秀秀不只会前端"/> <meta itemprop="url" content="https://juejin.cn/user/1410009035452887"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Vue3 应用实例创建及页面渲染底层原理
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1410009035452887/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    秀秀不只会前端
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-02T15:13:42.000Z" title="Fri Jan 02 2026 15:13:42 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-02
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    6
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">整体流程</h2>
<p>完整的创建与渲染流程可以分成这些阶段：</p>
<ol>
<li><strong>创建 App 实例</strong></li>
<li><strong>创建根组件实例</strong></li>
<li><strong>设置响应式状态</strong></li>
<li><strong>创建渲染器（Renderer）</strong></li>
<li><strong>挂载 Mount</strong></li>
<li><strong>vnode -&gt; DOM 渲染</strong></li>
<li><strong>数据变更触发更新</strong></li>
<li><strong>重新渲染 / diff / patch</strong></li>
</ol>
<p>流程图大致如下：</p>
<pre><code class="hljs language-Plain" lang="Plain">createApp() ───&gt; app.mount('#app')
         │                 │
         ▼                 ▼
   createRootComponent    createRenderer
         │                 │
         ▼                 ▼
 setup() / render()   render(vnode) -&gt; patch
         │                 │
         ▼                 ▼
   effect(fn) ────&gt; scheduler -&gt; patch updates
</code></pre>
<h2 data-id="heading-1">1、createApp 初始化</h2>
<p>Vue 应用的入口通常是：</p>
<pre><code class="hljs language-JavaScript" lang="JavaScript"><span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>).<span class="hljs-title function_">mount</span>(<span class="hljs-string">'#app'</span>)
</code></pre>
<p>从源码看 createApp：</p>
<pre><code class="hljs language-TypeScript" lang="TypeScript"><span class="hljs-comment">// packages/runtime-core/src/apiCreateApp.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createAppAPI</span>(<span class="hljs-params">render</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createApp</span>(<span class="hljs-params">rootComponent, rootProps = <span class="hljs-literal">null</span></span>) {
    <span class="hljs-keyword">const</span> app = {
      <span class="hljs-attr">_component</span>: rootComponent,
      <span class="hljs-attr">_props</span>: rootProps,
      <span class="hljs-attr">_container</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">_context</span>: <span class="hljs-title function_">createAppContext</span>()
    }
    <span class="hljs-keyword">const</span> proxy = (app.<span class="hljs-property">_instance</span> = {
      app
    })
    <span class="hljs-comment">// register global APIs</span>
    <span class="hljs-comment">// ...</span>
    <span class="hljs-keyword">return</span> {
      <span class="hljs-title function_">mount</span>(<span class="hljs-params">container</span>) {
        <span class="hljs-keyword">const</span> vnode = <span class="hljs-title function_">createVNode</span>(rootComponent, rootProps)
        app.<span class="hljs-property">_container</span> = container
        <span class="hljs-title function_">render</span>(vnode, container)
      },
      <span class="hljs-title function_">unmount</span>(<span class="hljs-params"/>) { <span class="hljs-comment">/* ... */</span> }
    }
  }
}
</code></pre>
<p>关键点：</p>
<ul>
<li><code>createAppAPI(render)</code> 生成 createApp 函数</li>
<li>app 内保存 <code>_component</code>、上下文 <code>_context</code></li>
<li><code>app.mount</code> 调用 <code>render(vnode, container)</code></li>
</ul>
<p><code>render</code> 由 <strong>平台渲染器</strong> 注入（在 web 下是 DOM 渲染器）。</p>
<h2 data-id="heading-2">2、createVNode 创建虚拟节点（VNode）</h2>
<p>在 mount 前会创建一个虚拟节点：</p>
<pre><code class="hljs language-TypeScript" lang="TypeScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createVNode</span>(<span class="hljs-params"><span class="hljs-keyword">type</span>, props, children</span>) {
  <span class="hljs-keyword">const</span> vnode = {
    <span class="hljs-keyword">type</span>,
    props,
    children,
    <span class="hljs-attr">shapeFlag</span>: <span class="hljs-title function_">getShapeFlag</span>(<span class="hljs-keyword">type</span>),
    <span class="hljs-attr">el</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">key</span>: props &amp;&amp; props.<span class="hljs-property">key</span>
  }
  <span class="hljs-keyword">return</span> vnode
}
</code></pre>
<p><code>vnode</code> 是渲染的基础单元：</p>
<p><code>shapeFlag</code> 用来快速判断 vnode 类型，是内部性能优化。</p>
<h2 data-id="heading-3">3、渲染器 Renderer 初始化</h2>
<p>Vue3 是平台无关的（runtime-core），真正依赖 DOM 的是在 <strong>runtime-dom</strong> 中。</p>
<p>创建 Renderer：</p>
<pre><code class="hljs language-TypeScript" lang="TypeScript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> renderer = <span class="hljs-title function_">createRenderer</span>({
  <span class="hljs-attr">createElement</span>: hostCreateElement,
  <span class="hljs-attr">patchProp</span>: hostPatchProp,
  <span class="hljs-attr">insert</span>: hostInsert,
  <span class="hljs-attr">remove</span>: hostRemove,
  <span class="hljs-attr">setElementText</span>: hostSetElementText
})
</code></pre>
<p><code>createRenderer</code> 返回了我们前面在 createApp 中使用的 <code>render(vnode, container)</code> 函数。</p>
<h2 data-id="heading-4">4、render &amp; patch</h2>
<p>核心渲染入口：</p>
<pre><code class="hljs language-TypeScript" lang="TypeScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params">vnode, container</span>) {
  <span class="hljs-title function_">patch</span>(<span class="hljs-literal">null</span>, vnode, container, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>)
}
</code></pre>
<p>patch 是渲染补丁函数：</p>
<pre><code class="hljs language-TypeScript" lang="TypeScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">patch</span>(<span class="hljs-params">n1, n2, container, parentComponent, anchor</span>) {
  <span class="hljs-keyword">const</span> { <span class="hljs-keyword">type</span>, shapeFlag } = n2
  <span class="hljs-keyword">if</span> (shapeFlag &amp; <span class="hljs-title class_">ShapeFlags</span>.<span class="hljs-property">ELEMENT</span>) {
    <span class="hljs-title function_">processElement</span>()
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (shapeFlag &amp; <span class="hljs-title class_">ShapeFlags</span>.<span class="hljs-property">STATEFUL_COMPONENT</span>) {
    <span class="hljs-title function_">processComponent</span>(...)
  }
}
</code></pre>
<p>简化为：</p>
<ul>
<li>如果是 <strong>DOM 元素 vnode</strong> → 挂载/更新</li>
<li>如果是 <strong>组件 vnode</strong> → 创建组件实例、挂载、渲染子树</li>
</ul>
<h2 data-id="heading-5">5、组件实例创建</h2>
<p>当渲染组件时：</p>
<pre><code class="hljs language-TypeScript" lang="TypeScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">processComponent</span>(<span class="hljs-params">n1, n2, container, parentComponent, anchor</span>) {
  <span class="hljs-title function_">mountComponent</span>(n2, container, parentComponent, anchor)
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">mountComponent</span>(<span class="hljs-params">vnode, container, parentComponent, anchor</span>) {
  <span class="hljs-keyword">const</span> instance = <span class="hljs-title function_">createComponentInstance</span>(vnode, parentComponent)
  <span class="hljs-title function_">setupComponent</span>(instance)
  <span class="hljs-title function_">setupRenderEffect</span>(instance, container, anchor)
}
</code></pre>
<ul>
<li>processComponent 处理组件</li>
<li>mountComponent 挂载组件
<ul>
<li>createComponentInstance 创建组件实例</li>
<li>setupComponent 创建组件对象</li>
</ul>
</li>
</ul>
<p>createComponentInstance：</p>
<pre><code class="hljs language-TypeScript" lang="TypeScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createComponentInstance</span>(<span class="hljs-params">vnode, parent</span>) {
  <span class="hljs-keyword">const</span> instance = {
    vnode,
    parent,
    <span class="hljs-attr">proxy</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">ctx</span>: {},
    <span class="hljs-attr">props</span>: {},
    <span class="hljs-attr">attrs</span>: {},
    <span class="hljs-attr">slots</span>: {},
    <span class="hljs-attr">setupState</span>: {},
    <span class="hljs-attr">isMounted</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">subTree</span>: <span class="hljs-literal">null</span>
  }
  <span class="hljs-keyword">return</span> instance
}
</code></pre>
<p>实例保存基础信息，还没运行 setup。</p>
<h2 data-id="heading-6">6、 setupComponent（初始化组件）</h2>
<pre><code class="hljs language-TypeScript" lang="TypeScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">setupComponent</span>(<span class="hljs-params">instance</span>) {
  <span class="hljs-title function_">initProps</span>(instance, vnode.<span class="hljs-property">props</span>)
  <span class="hljs-title function_">initSlots</span>(instance, vnode.<span class="hljs-property">children</span>)
  <span class="hljs-title function_">setupStatefulComponent</span>(instance)
}
</code></pre>
<p>内部会执行：</p>
<pre><code class="hljs language-TypeScript" lang="TypeScript"><span class="hljs-keyword">const</span> { setup } = <span class="hljs-title class_">Component</span>
<span class="hljs-keyword">if</span> (setup) {
  <span class="hljs-keyword">const</span> setupResult = <span class="hljs-title function_">setup</span>(props, ctx)
  <span class="hljs-title function_">handleSetupResult</span>(instance, setupResult)
}
</code></pre>
<p>​<strong>setup 返回值</strong>​：</p>
<ul>
<li>返回对象 → 作为响应式状态 state</li>
<li>返回函数 → render 函数</li>
</ul>
<p>最终让组件拥有 <code>instance.render</code>。</p>
<h2 data-id="heading-7">7、创建响应式状态</h2>
<p>Vue3 的响应式来自 <code>reactivity</code> 包：</p>
<pre><code class="hljs language-JavaScript" lang="JavaScript"><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>({ <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> })
</code></pre>
<p>底层是 <code>Proxy</code> 拦截 getter/setter：</p>
<ul>
<li>getter：收集依赖</li>
<li>setter：触发依赖更新</li>
</ul>
<p>依赖管理核心是 ​<strong>effect / track / trigger</strong>​。</p>
<h2 data-id="heading-8">8、 setupRenderEffect 与首次渲染</h2>
<p>创建渲染器副作用，并调度组件挂载和异步更新：</p>
<pre><code class="hljs language-TypeScript" lang="TypeScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">setupRenderEffect</span>(<span class="hljs-params">instance, container, anchor</span>) {
  instance.<span class="hljs-property">update</span> = <span class="hljs-title function_">effect</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">componentEffect</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">if</span> (!instance.<span class="hljs-property">isMounted</span>) {
      <span class="hljs-keyword">const</span> subTree = (instance.<span class="hljs-property">subTree</span> = instance.<span class="hljs-property">render</span>.<span class="hljs-title function_">call</span>(proxy))
      <span class="hljs-title function_">patch</span>(<span class="hljs-literal">null</span>, subTree, container, instance, anchor)
      instance.<span class="hljs-property">isMounted</span> = <span class="hljs-literal">true</span>
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// 更新更新逻辑</span>
    }
  }, {
    <span class="hljs-attr">scheduler</span>: queueJob
  })
}
</code></pre>
<p>这里：</p>
<ul>
<li>创建一个 <strong>响应式 effect</strong></li>
<li>第一次执行 render 得到 subTree</li>
<li>patch 子树到 DOM</li>
</ul>
<blockquote>
<p><code>effect</code> + <code>scheduler</code> 实现异步更新。</p>
</blockquote>
<h2 data-id="heading-9">9、vnode-&gt; 真实 DOM（DOM mount）</h2>
<p>当 patch 到真正的 DOM 时，走的是 element 分支：</p>
<pre><code class="hljs language-TypeScript" lang="TypeScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">processElement</span>(<span class="hljs-params">...</span>) {
  <span class="hljs-keyword">if</span> (!n1) {
    <span class="hljs-title function_">mountElement</span>(vnode, container)
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-title function_">patchElement</span>(n1, n2)
  }
}
</code></pre>
<p>mountElement</p>
<pre><code class="hljs language-TypeScript" lang="TypeScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">mountElement</span>(<span class="hljs-params">vnode, container</span>) {
  <span class="hljs-keyword">const</span> el = (vnode.<span class="hljs-property">el</span> = <span class="hljs-title function_">hostCreateElement</span>(vnode.<span class="hljs-property">type</span>))
  <span class="hljs-comment">// props</span>
  <span class="hljs-keyword">for</span> (key <span class="hljs-keyword">in</span> props) {
    <span class="hljs-title function_">hostPatchProp</span>(el, key, <span class="hljs-literal">null</span>, props[key])
  }
  <span class="hljs-comment">// children</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> children === <span class="hljs-string">'string'</span>) {
    <span class="hljs-title function_">hostSetElementText</span>(el, children)
  } <span class="hljs-keyword">else</span> {
    children.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> <span class="hljs-title function_">patch</span>(<span class="hljs-literal">null</span>, c, el))
  }
  <span class="hljs-title function_">hostInsert</span>(el, container)
}
</code></pre>
<h2 data-id="heading-10">10、更新 &amp; Diff 算法</h2>
<p>当响应式状态改变：</p>
<pre><code class="hljs language-JavaScript" lang="JavaScript">state.<span class="hljs-property">count</span>++
</code></pre>
<p>触发 setter → <code>trigger</code>：</p>
<ul>
<li>将 effect 放入更新队列</li>
<li>异步执行 scheduler</li>
<li>调用 instance.update 再次 patch</li>
</ul>
<p>更新阶段：</p>
<pre><code class="hljs language-TypeScript" lang="TypeScript"><span class="hljs-title function_">patchElement</span>(n1, n2)
</code></pre>
<p>核心逻辑：</p>
<ol>
<li>props diff</li>
<li>children diff</li>
<li><strong>unkeyed/keyed diff</strong> 算法（最小化移动）</li>
</ol>
<blockquote>
<p>具体见 <code>patchChildren</code> 和 <code>patchKeyedChildren</code>。</p>
</blockquote>
<h2 data-id="heading-11">整体核心对象关系架构</h2>
<pre><code class="hljs language-Plain" lang="Plain">App
 └─ vnode(root)
     └─ ComponentInstance
         ├─ props / slots
         ├─ setupState
         └─ render() -&gt; subTree
             └─ vnode tree
                 └─ DOM nodes
</code></pre>
<p>响应式依赖结构：</p>
<pre><code class="hljs language-Plain" lang="Plain">reactive state
 ├─ effects[]
 └─ track -&gt; effect
              └─ scheduler -&gt; patch
</code></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Vue 原生渲染真要来了？Lynx引擎首次跑通Vue]]></title>    <link>https://juejin.cn/post/7589932422654869540</link>    <guid>https://juejin.cn/post/7589932422654869540</guid>    <pubDate>2026-01-02T15:44:11.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7589932422654869540" data-draft-id="7589932422654853156" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Vue 原生渲染真要来了？Lynx引擎首次跑通Vue"/> <meta itemprop="keywords" content="前端,JavaScript"/> <meta itemprop="datePublished" content="2026-01-02T15:44:11.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="小小荧"/> <meta itemprop="url" content="https://juejin.cn/user/606586151371054"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Vue 原生渲染真要来了？Lynx引擎首次跑通Vue
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/606586151371054/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    小小荧
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-02T15:44:11.000Z" title="Fri Jan 02 2026 15:44:11 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-02
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    3
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">Vue 原生渲染真要来了？Lynx引擎首次跑通Vue</h2>
<blockquote>
<p><strong>“这一次，Vue 终于能在移动端跑出原生性能了。”</strong></p>
</blockquote>
<p><strong>最新动态</strong>：一位前端工程师在48小时内，成功将Vue 3的响应式系统与字节跳动的Lynx.js引擎对接，实现了首个Vue自定义渲染器原型。这标志着近200万Vue开发者有望直接使用熟悉的<code>ref</code>、<code>&lt;SFC&gt;</code>等语法，驱动iOS/Android的原生控件，告别WebView的性能束缚。</p>
<h4 data-id="heading-1">一、突破性进展：Vue 已在 Lynx 上跑通</h4>
<p>近日，前端工程师 <strong>@Shenqingchuan</strong> 在社交平台展示了他的成果：一个在Lynx引擎上运行的Vue 3计数器Demo。</p>
<p><img src="https://static.xxytime.top/2026/01/02/8b661e5f-3da3-4935-bb11-e9f6b63ec73e.jpg" alt="" loading="lazy"/></p>
<p>这项原型验证了技术可行性，他也公开邀请对 <strong>“Vue Lynx”</strong> 感兴趣且熟悉Vue核心代码（尤其是<code>runtime-core</code>）的开发者加入共建。</p>
<h4 data-id="heading-2">二、什么是 Lynx.js？</h4>
<p><strong>Lynx</strong> 是字节跳动于今年3月开源的一款<strong>高性能双线程原生渲染框架</strong>，其核心架构优势在于：</p>
<p><img src="https://static.xxytime.top/2026/01/02/bf76f567-c0b0-41c5-a9e4-d4531726b655.jpg" alt="" loading="lazy"/></p>
<ul>
<li><strong>UI线程</strong>：使用自研<code>PrimJS</code>配合基于Rust的<code>Rspack</code>（Rspeedy），实现毫秒级首帧直出。</li>
<li><strong>后台线程</strong>：独立运行业务逻辑、网络请求等，避免复杂计算阻塞界面。</li>
<li><strong>原生渲染</strong>：直接调用平台原生控件，其渲染性能与Flutter属于同一梯队。</li>
<li><strong>实战验证</strong>：已广泛应用于TikTok搜索、直播等亿级月活业务场景。</li>
</ul>
<p>Lynx框架本身保持中立，其团队曾公开表示欢迎Vue等框架接入，这为此次“Vue-Lynx”的原型诞生提供了土壤。</p>
<h4 data-id="heading-3">三、官方与社区的积极信号</h4>
<p>此次尝试迅速获得了来自双方核心人物的关注：</p>
<ul>
<li><strong>Lynx架构师 @Huxpro</strong> 转发并帮助招募合作者。</li>
<li><strong>Vue作者 @youyuxi</strong> 的转发，相当于给予了项目“官方默许”的认证。</li>
</ul>
<p>此外，在最近的React Advanced大会上，@Huxpro预告了<strong>lynx-ui</strong>组件库将于12月开源，这将为上层框架提供丰富的原生UI物料，进一步夯实生态基础。</p>
<h4 data-id="heading-4">四、核心优势：为什么这次可能成了？</h4>
<p>相比历史上的类似尝试（如Weex），此次“Vue + Lynx”的组合在多个层面具备了更坚实的基础：</p>






























<table><thead><tr><th align="left">维度</th><th align="left">Vue + Lynx 方案</th><th align="left">传统方案的典型痛点</th></tr></thead><tbody><tr><td align="left"><strong>渲染性能</strong></td><td align="left"><strong>双线程原生控件</strong>，无WebView层级</td><td align="left">WebView易掉帧、卡顿</td></tr><tr><td align="left"><strong>开发体验</strong></td><td align="left">完整<strong>Vue 3组合式API</strong>，对接现代构建工具（Vite/Rspeedy）</td><td align="left">需学习新语法，或构建速度慢</td></tr><tr><td align="left"><strong>调试支持</strong></td><td align="left">拥有<strong>Lynx DevTool</strong>，支持真机断点调试</td><td align="left">调试依赖日志，体验差</td></tr><tr><td align="left"><strong>技术验证</strong></td><td align="left">底层引擎已在<strong>10亿+DAU</strong>产品中验证</td><td align="left">多为实验室级原型，缺乏大规模验证</td></tr></tbody></table>
<h4 data-id="heading-5">五、代码一瞥：Vue Lynx 初体验</h4>
<p>一个简单的Vue组件在Lynx环境下可能这样编写：</p>
<pre><code class="hljs language-vue" lang="vue">&lt;!-- HelloLynx.vue --&gt;
&lt;script setup&gt;
import logo from './assets/lynx-logo.png'
import { ref } from 'vue'

const count = ref(0)
setInterval(() =&gt; count.value++, 1800)
&lt;/script&gt;

&lt;template&gt;
  &lt;view class="container"&gt;
    &lt;image :src="logo" class="logo" /&gt;
    &lt;text class="h1"&gt;Hello Vue-Lynx&lt;/text&gt;
    &lt;text class="p"&gt;双线程原生渲染，首帧直出！&lt;/text&gt;
    &lt;button class="btn" @click="count++"&gt;点我：{{ count }}&lt;/button&gt;
  &lt;/view&gt;
&lt;/template&gt;
</code></pre>
<p>其中的 <code>&lt;view&gt;</code>、<code>&lt;text&gt;</code>、<code>&lt;image&gt;</code> 等标签将被编译并映射为<strong>平台原生组件</strong>，而开发者使用的仍然是百分之百标准的Vue语法。</p>
<h4 data-id="heading-6">六、技术实现路径展望</h4>
<p>要实现生产可用的“Vue Lynx”，还需攻克几个关键节点：</p>
<ol>
<li><strong>编译链路适配</strong>：需要开发新的插件（如<code>vue-loader-rs</code>），将Vue SFC编译为Lynx双线程可识别的代码包，并严格区分UI线程与后台线程的职责。</li>
<li><strong>定制运行时</strong>：在Vue核心库中新增一个<code>vue/runtime-lynx</code>包，实现与<code>PrimJS</code> API对接的节点操作、调度器和事件系统。</li>
<li><strong>线程边界管理</strong>：可能通过扩展SFC语法（如引入<code>&lt;script main&gt;</code>标签），或在编译时进行静态分析，来明确代码的运行线程，确保开发者既能畅快编码又不违反架构约束。</li>
</ol>
<h4 data-id="heading-7">七、Vue Native 生态路线图</h4>
<p>目前，让Vue开发移动原生应用的方案并非唯一，开发者可根据需求选择：</p>








































<table><thead><tr><th align="left">路线</th><th align="left">渲染方式</th><th align="left">性能</th><th align="left">开发体验</th><th align="left">适用场景</th></tr></thead><tbody><tr><td align="left"><strong>NativeScript-Vue 3</strong></td><td align="left">原生控件</td><td align="left">★★★★</td><td align="left">Vite + Tailwind，成熟</td><td align="left">追求100%原生UI，无需WebView</td></tr><tr><td align="left"><strong>Ionic Vue + Capacitor</strong></td><td align="left">WebView</td><td align="left">★★★</td><td align="left">最接近Web开发，PWA友好</td><td align="left">一套代码覆盖Web/App，重开发效率</td></tr><tr><td align="left"><strong>uni-app / uni-appx</strong></td><td align="left">WebView → 原生渲染</td><td align="left">★★★☆</td><td align="left">中文生态完善，工具链强</td><td align="left">需同时发布国内多端（小程序+App）</td></tr><tr><td align="left"><strong>Vue + Lynx</strong></td><td align="left"><strong>双线程原生</strong></td><td align="left">★★★★☆</td><td align="left">早期，需配置，潜力大</td><td align="left"><strong>追求极致性能，愿参与生态共建</strong></td></tr></tbody></table>
<p><strong>简单决策参考</strong>：</p>
<ul>
<li><strong>“我现在就要用”</strong> → 选择 NativeScript-Vue 或 uni-app。</li>
<li><strong>“我要最像Web的开发体验”</strong> → 选择 Ionic Vue。</li>
<li><strong>“我看重未来性能和前沿技术”</strong> → 密切关注并尝试参与 <strong>Vue + Lynx</strong>。</li>
</ul>
<h4 data-id="heading-8">八、结语：这一次，不再缺席？</h4>
<p>Vue社区对“原生渲染”的期待由来已久。如今，多条技术路径正在并行发展：</p>
<ul>
<li><strong>NativeScript-Vue 3</strong> 已趋成熟。</li>
<li><strong>uni-appx</strong> 持续拓展多端能力。</li>
<li>而最具颠覆性的 <strong>Vue + Lynx</strong> 路径，正以开源共建的模式吸引开发者。</li>
</ul>
<p>或许在不久的将来，我们只需一条命令：</p>
<pre><code class="hljs language-bash" lang="bash">npm create vue-native@latest
</code></pre>
<p>便可从多个生产就绪的Vue原生渲染模板中任选其一。</p>
<p><strong>Weex时代的遗憾，或许真的能在2025年被彻底填补。Vue Native，这一次可能真的要启动了。</strong></p>
<blockquote>
<p><strong>保持关注</strong>：</p>
<ul>
<li>Lynx 项目：<code>github.com/lynx-family/lynx</code></li>
<li>生态动态：可关注 <code>@Huxpro</code> 等核心开发者的最新消息。</li>
</ul>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[kotlin协程-热数据通道Channel]]></title>    <link>https://juejin.cn/post/7590159073988624436</link>    <guid>https://juejin.cn/post/7590159073988624436</guid>    <pubDate>2026-01-02T10:55:50.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7590159073988624436" data-draft-id="7590104561475878964" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="kotlin协程-热数据通道Channel"/> <meta itemprop="keywords" content="Kotlin"/> <meta itemprop="datePublished" content="2026-01-02T10:55:50.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Huang兄"/> <meta itemprop="url" content="https://juejin.cn/user/52404619842712"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            kotlin协程-热数据通道Channel
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/52404619842712/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Huang兄
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-02T10:55:50.000Z" title="Fri Jan 02 2026 10:55:50 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-02
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    4
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:14px;overflow-x:hidden;color:var(--cyanosis-base-color);transition:color .35s;--cyanosis-base-color:#353535;--cyanosis-title-color:#005bb7;--cyanosis-strong-color:#2196f3;--cyanosis-em-color:#4fc3f7;--cyanosis-del-color:#ccc;--cyanosis-link-color:#3da8f5;--cyanosis-linkh-color:#007fff;--cyanosis-border-color:#bedcff;--cyanosis-border-color-2:#ececec;--cyanosis-bg-color:#fff;--cyanosis-blockquote-color:#8c8c8c;--cyanosis-blockquote-bg-color:#f0fdff;--cyanosis-code-color:#c2185b;--cyanosis-code-bg-color:#fff4f4;--cyanosis-code-pre-color:#f8f8f8;--cyanosis-table-border-color:#c3e0fd;--cyanosis-table-th-color:#dff0ff;--cyanosis-table-tht-color:#005bb7;--cyanosis-table-tr-nc-color:#f7fbff;--cyanosis-table-trh-color:#e0edf7;--cyanosis-slct-title-color:#005bb7;--cyanosis-slct-titlebg-color:rgba(175,207,247,0.25);--cyanosis-slct-text-color:#c80000;--cyanosis-slct-bg-color:rgba(175,207,247,0.25);--cyanosis-slct-del-color:#999;--cyanosis-slct-elbg-color:#e8ebec;--cyanosis-slct-codebg-color:#ffeaeb;--cyanosis-slct-prebg-color:rgba(160,200,255,0.25)}.markdown-body.__dark{--cyanosis-base-color:#cacaca;--cyanosis-title-color:#ddd;--cyanosis-strong-color:#fe9900;--cyanosis-em-color:#ffd28e;--cyanosis-del-color:#ccc;--cyanosis-link-color:#ffb648;--cyanosis-linkh-color:#fe9900;--cyanosis-border-color:#ffe3ba;--cyanosis-border-color-2:#ffcb7b;--cyanosis-bg-color:#2f2f2f;--cyanosis-blockquote-color:#c7c7c7;--cyanosis-blockquote-bg-color:rgba(255,199,116,0.1);--cyanosis-code-color:#000;--cyanosis-code-bg-color:#ffcb7b;--cyanosis-code-pre-color:rgba(255,227,185,0.5);--cyanosis-table-border-color:#fe9900;--cyanosis-table-th-color:#ffb648;--cyanosis-table-tht-color:#000;--cyanosis-table-tr-nc-color:#6d5736;--cyanosis-table-trh-color:#947443;--cyanosis-slct-title-color:#000;--cyanosis-slct-titlebg-color:#fe9900;--cyanosis-slct-text-color:#00c888;--cyanosis-slct-bg-color:rgba(175,207,247,0.25);--cyanosis-slct-del-color:#999;--cyanosis-slct-elbg-color:#000;--cyanosis-slct-codebg-color:#ffcb7b;--cyanosis-slct-prebg-color:rgba(160,200,255,0.25)}.markdown-body h1{padding-bottom:4px;font-size:30px}.markdown-body h1,.markdown-body h2{margin-top:36px;margin-bottom:10px;line-height:1.5;color:var(--cyanosis-title-color);transition:color .35s}.markdown-body h2{position:relative;padding-left:10px;padding-right:10px;padding-bottom:10px;font-size:24px;border-bottom:1px solid var(--cyanosis-border-color-2)}.markdown-body h2:before{content:"「";position:absolute;top:-6px;left:-14px}.markdown-body h2:after{content:"」";position:relative;top:6px;right:auto}.markdown-body h3{position:relative;padding-bottom:0;margin-top:30px;margin-bottom:10px;font-size:20px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body h3:before{content:"»";padding-right:6px;color:var(--cyanosis-strong-color)}.markdown-body h4{margin-top:24px;font-size:16px}.markdown-body h4,.markdown-body h5{padding-bottom:0;margin-bottom:10px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body h5{margin-top:18px;font-size:14px}.markdown-body h6{padding-bottom:0;margin-top:12px;margin-bottom:10px;font-size:12px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body p{line-height:inherit;margin-top:16px;margin-bottom:16px}.markdown-body img{max-width:100%}.markdown-body hr{position:relative;width:98%;height:1px;margin-top:32px;margin-bottom:32px;background-image:linear-gradient(90deg,var(--cyanosis-link-color),rgba(255,0,0,.3),hsla(0,0%,100%,.1),rgba(255,0,0,.3),var(--cyanosis-link-color));border-width:0;overflow:visible}.markdown-body hr:after{content:"";position:absolute;margin:auto;left:0;right:0;bottom:0;top:0;display:inline-block;width:60px;height:20px;background-color:var(--cyanosis-bg-color);background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAgCAYAAABgrToAAAADoklEQVRYR82XTYgcRRTHf2933Q1RjAa9eFO8JHoJ8RQVBQ2iBwXBET0YEUTXNVmNQtTpmeqaWV0XNRq/o4KoECSCEPSg4CF+BYUkIIiCoCJCPIhC/Ihh2Z0nVV27VnZnenumW9i6ddV7//frV69fVQurfMgq56NawFTPAU6QyomqXrw6wIZeyhCPebA5buNR+akKyGoAjd6BshthnYdSjqNcRVuOlIUsD2j0SuA94IwuMHdh5ZUykOUBXfSGbmKI54EtAeYIHSZoy5dl4JxvNYBOKdW1KE8BQ8AkVk6WhasWsAiN0TX9gveXQaPP+Aytpc4u+bMI06JNohsYYYYOR2lJWtS3OKDRfcAtQfgDoI6Vo4UCGb0OmAEuDvZvYmVbEd/igC3dzDz7gQu8sPA9kJDK27mBmjqBeLjTg90PDFOjWawFFQd06kZHEfaj3LAIpTRpSXsZ5E06zEYP9sDimnAApYaV2SLZG/wjMeqAkijwW4xQJ5Gf/ZzRC8OW3hiBTGGlURRswW55Bh/Ssxljrwew8l1PQaM14GngvGDzBUKdDsMeTtgU5o8B92PFlUf3YXUrHa7Fys6lBqcCGnX15YQ2A18FyPd7Crd1A3M8C1wdbH4DD3hWeP6IEXbQkG97ajR1HPFnuPP5jFFq1OWX7hl8WM9l1AO648uNfwLk7tytMeogty+xeQ4rO3r6bdcx1nuwOGsHmaXGtPzae4uzGnLH1kQkvpdZGrHjssBZJrL+pqS05KWc8tgITAPXRzYvYOXe/C2OV43eDcRBDtIhoS2f9wzc0Cv8Wls+zoFzUC5zF0U241h5uZtPfptp6OUM8wbK+cH5GEpCS17P3fJei0Z3+npTxryJ8CPzbKMtn/ZyWbkPGl0PuFPkmkjkcb4h4R2ZLwRq1H0ALmvjkf2HwK1Y+T1PY2XABe/sHJ6MxN5lnoSpnC/UGbsTaI5phK2R7x6s3Ffk5YoDOrWm3onwJHBmEP86bPmBrsGaenNoIdnxCH+gPEhLXi0Cl1VBvyPVLSh7gEuC62yAfOIUqabWEaaiucMIk6RyqJ+Q/QM69V26jjW86Gvov/EaoyT8zRCn+Xq7PVrbx0nuYUaO9wM3WAbjCE1NEUw09Um4UV+2OKfYfu5/S19gsAzGKqm6LE5FrShbdS0ku465DjDwKA/oQht19ejqbaEVuRbiLhuHByYLjtUAZpDutzP7cYdHsPJXWbjyNVgFwQoa1WXwf4Jd9YD/Ap80+yE7+u9aAAAAAElFTkSuQmCC);background-repeat:no-repeat;background-size:auto 100%;background-position-x:center;transition:background-color .5s}.markdown-body code{padding:.065em .4em;font-size:.87em;color:var(--cyanosis-code-color);word-break:break-word;overflow-x:auto;background-color:var(--cyanosis-code-bg-color);border-radius:2px}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{display:block;padding:16px 12px;margin:0;font-size:12px;color:#333;word-break:normal;overflow-x:auto;background:var(--cyanosis-code-pre-color)}.markdown-body pre&gt;code::-webkit-scrollbar{width:4px;height:4px}.markdown-body pre&gt;code::-webkit-scrollbar-track{background-color:var(--cyanosis-border-color)}.markdown-body pre&gt;code::-webkit-scrollbar-thumb{background-color:var(--cyanosis-strong-color);border-radius:10px}.markdown-body a{position:relative;text-decoration:none;color:var(--cyanosis-link-color);border-bottom:1px solid var(--cyanosis-border-color)}.markdown-body a:hover{border-bottom-color:var(--cyanosis-linkh-color)}.markdown-body a:active,.markdown-body a:hover{color:var(--cyanosis-linkh-color)}.markdown-body a:after{position:absolute;content:"";top:100%;left:0;width:100%;opacity:0;border-bottom:1px solid var(--cyanosis-border-color);transition:top .3s,opacity .3s;transform:translateZ(0)}.markdown-body a:hover:after{top:0;opacity:1;border-bottom-color:var(--cyanosis-linkh-color)}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid var(--cyanosis-table-border-color);border-spacing:0;border-collapse:collapse}.markdown-body table thead{color:#000;text-align:left;font-size:14px;background:#f6f6f6}.markdown-body table tr:nth-child(2n){background-color:var(--cyanosis-table-tr-nc-color)}.markdown-body table tr:hover{background-color:var(--cyanosis-table-trh-color)}.markdown-body table td,.markdown-body table th{padding:12px 8px;line-height:24px;border:1px solid var(--cyanosis-table-border-color)}.markdown-body table th{color:var(--cyanosis-table-tht-color);background-color:var(--cyanosis-table-th-color)}.markdown-body table td{min-width:120px}.markdown-body blockquote{color:var(--cyanosis-blockquote-color);border-left:4px solid var(--cyanosis-strong-color);background-color:var(--cyanosis-blockquote-bg-color);padding:1px 20px;margin:22px 0;transition:color .35s}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body b,.markdown-body blockquote&gt;b,.markdown-body blockquote&gt;strong,.markdown-body strong{color:var(--cyanosis-strong-color)}.markdown-body em,.markdown-body i{color:var(--cyanosis-em-color)}.markdown-body del{color:var(--cyanosis-del-color)}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:4px}.markdown-body ol li{padding-left:6px}.markdown-body details&gt;summary{outline:none;color:var(--cyanosis-title-color);font-size:20px;font-weight:bolder;border-bottom:1px solid var(--cyanosis-border-color);cursor:pointer}.markdown-body details&gt;p{padding:10px 20px;margin:10px 0 0;color:#666;background-color:var(--cyanosis-blockquote-bg-color);border:2px dashed var(--cyanosis-strong-color)}.markdown-body h1::selection,.markdown-body h2::selection,.markdown-body h3::selection,.markdown-body h4::selection,.markdown-body h5::selection,.markdown-body h6::selection{color:var(--cyanosis-slct-title-color);background-color:var(--cyanosis-slct-titlebg-color)}.markdown-body ol li::selection,.markdown-body p::selection,.markdown-body ul li::selection{color:var(--cyanosis-slct-text-color);background-color:var(--cyanosis-slct-bg-color)}.markdown-body a::selection,.markdown-body b::selection,.markdown-body em::selection,.markdown-body i::selection,.markdown-body strong::selection{background-color:var(--cyanosis-slct-elbg-color)}.markdown-body del::selection{color:var(--cyanosis-slct-del-color);background-color:var(--cyanosis-slct-elbg-color)}.markdown-body table thead th::selection{background-color:transparent}.markdown-body table tbody td::selection{background-color:var(--cyanosis-slct-bg-color)}.markdown-body code::selection{background-color:var(--cyanosis-slct-codebg-color)}.markdown-body pre&gt;code::selection{background-color:var(--cyanosis-slct-prebg-color)}.markdown-body .contains-task-list{padding-left:14px;list-style:none}.markdown-body .contains-task-list input[type=checkbox]{position:relative}.markdown-body .contains-task-list input[type=checkbox]:before{content:"";position:absolute;top:0;left:0;right:0;bottom:0;width:inherit;height:inherit;background:#f0f8ff;border:1px solid #add6ff;border-radius:2px;box-sizing:border-box;z-index:1}.markdown-body .contains-task-list input[type=checkbox]:checked:after{content:"✓";position:absolute;top:-12px;left:0;right:0;bottom:0;width:0;height:0;color:#f55;font-size:20px;font-weight:700;z-index:2}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="atom-one-dark">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#abb2bf;background:#282c34}.hljs-comment,.hljs-quote{color:#5c6370;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#c678dd}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e06c75}.hljs-literal{color:#56b6c2}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#98c379}.hljs-built_in,.hljs-class .hljs-title{color:#e6c07b}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#d19a66}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#61aeee}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}</style><p>种一颗树的最好时机是十年前，其次是现在。
学习也一样。
跟着霍老师的《深入理解 Kotlin 携程》学习一下协程。</p>
<h2 data-id="heading-0">直奔主题，认识 Channel</h2>
<p>Channel 实际上就是一个并发安全的队列，它可以用来连接协程，实现不同协程的通信</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> channel = Channel&lt;<span class="hljs-built_in">Int</span>&gt;()
    <span class="hljs-keyword">val</span> producer = GlobalScope.launch {
        <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>
        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
            delay(<span class="hljs-number">1000</span>)
            channel.send(i++)
        }
    }
    <span class="hljs-keyword">val</span> consumer = GlobalScope.launch {
        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
            <span class="hljs-keyword">val</span> element = channel.receive()
            println(element)
        }
    }
    producer.join()
    consumer.join()
}
</code></pre>
<p>上述的代码中构造了两个协程 producer 和 consumer，我么呢没有为它们明确制定调度器，所以他们的调度器都是默认的。其中 producer 中每隔 1 秒向 Channel 发送一个整数，而 consumer 中一致在读取 channel 来获取数据并打印，显然发送端比接收端更慢，在没有可以读取的值时，receive 是挂起的，直到有新元素到达，这么看来 receive 一定是一个挂起函数，那么 send 呢？</p>
<h2 data-id="heading-1">Channel 的容量</h2>
<p>我们查看 send 方法的声明，发现它也是挂起函数。那么发送端为什么要挂起？上面也提到，Channel 实际上就是一个队列，队列中一定存在缓冲区，一旦这个缓冲区满了，一直没有人调用 receive 并取走元素，send 就要挂起，等待接收者取走元素后再写入 Channel。</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;E&gt;</span> <span class="hljs-title">Channel</span><span class="hljs-params">(capacity: <span class="hljs-type">Int</span> = RENDEZVOUS)</span></span>: Channel&lt;E&gt; =
    <span class="hljs-keyword">when</span> (capacity) {
        RENDEZVOUS -&gt; RendezvousChannel()
        UNLIMITED -&gt; LinkedListChannel()
        CONFLATED -&gt; ConflatedChannel()
        BUFFERED -&gt; ArrayChannel(CHANNEL_DEFAULT_CAPACITY)
        <span class="hljs-keyword">else</span> -&gt; ArrayChannel(capacity)
    }
</code></pre>
<p>我们构造 Cahnnel 的时候调用了一个名为 Channle 的函数，但它不是 Channel 的构造函数。在 Kotlin 中，经常定义一个顶级函数来伪装成同名类型的构造器，这本质上是工厂函数。这里有一个 Int 类型的 capacity 参数，默认值为 RENDEZVOUS。
这时候如果不调用 receive，send 就会一直挂起等待。</p>
<p><code>UNLIMITED</code>比较好理解，没有限制，来者不拒。
<code>CONFLATED</code>这个名字可能有迷惑性，字面意思是合并，但实际上这个函数的效果是只保留最后一个元素，也就是说缓冲区只有一个元素大小，每次有新元素到来，都会覆盖掉旧元素。
<code>BUFFERED</code>效果类似于 ArrayBlockingQueue，接收一个值作为缓冲区容量大小。</p>
<h3 data-id="heading-2">迭代 Channel</h3>
<p>我们在发送和读取的时候写了一个<code>while(true)</code>的死循环，因为需要不断地进行读写操作。这里我们可以直接获取一个 Channel 的 Iterator</p>
<pre><code class="hljs language-kotlin" lang="kotlin">    <span class="hljs-keyword">val</span> consumer = GlobalScope.launch {
        <span class="hljs-keyword">val</span> iter = channel.iterator()
        <span class="hljs-keyword">while</span> (iter.hasNext()) {
            <span class="hljs-keyword">val</span> element = iter.next()
            println(element)
            delay(<span class="hljs-number">1000</span>)
        }
    }
</code></pre>
<p>其中 iter.hasNext()是挂起函数，在判断是否有下一个元素的时候就需要去 Channel 中读取元素了。当然也可以<code>for ... in ..</code>:</p>
<pre><code class="hljs language-kotlin" lang="kotlin">    <span class="hljs-keyword">val</span> consumer = GlobalScope.launch {
        <span class="hljs-keyword">for</span>(element <span class="hljs-keyword">in</span> channel) {
            println(element)
            delay(<span class="hljs-number">1000</span>)
        }
    }
</code></pre>
<h3 data-id="heading-3">produce 和 actor</h3>
<p>来看两个便捷的构造生产者和消费这的 api，我们可以通过<code>produce</code>来启动移动生产者协程，并返回一个<code>ReceiveChannel</code>,其他协程就可以通过这个 channel 来获取数据了。<br/>
同样的，我们可以通过<code>actor</code>来启动消费者协程，并返回一个<code>SendChannel</code>,其他协程就可以通过这个 channel 来发送数据了。</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">val</span> receiveChannel : ReceiveChannel&lt;<span class="hljs-built_in">Int</span>&gt; = GlobalScope.produce{
    repeat(<span class="hljs-number">100</span>){

        delay(<span class="hljs-number">100</span>)
        send(it)
    }
}

<span class="hljs-keyword">val</span> sendChannel : SendChannel&lt;<span class="hljs-built_in">Int</span>&gt; = GlobalScope.actor {
    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>){
        <span class="hljs-keyword">val</span> element = receive()
        println(element)
    }
}

</code></pre>
<h2 data-id="heading-4">Channel 的关闭</h2>
<p>以上面的<code>produce</code>方法为例,我们可以看到最终返回的是一个<code>ProducerCoroutine</code>,它的定义如下：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProducerCoroutine</span>&lt;<span class="hljs-type">E</span>&gt;(
    parentContext: CoroutineContext, channel: Channel&lt;E&gt;
) : ChannelCoroutine&lt;E&gt;(parentContext, channel, <span class="hljs-literal">true</span>, active = <span class="hljs-literal">true</span>), ProducerScope&lt;E&gt; {
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> isActive: <span class="hljs-built_in">Boolean</span>
        <span class="hljs-keyword">get</span>() = <span class="hljs-keyword">super</span>.isActive

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCompleted</span><span class="hljs-params">(value: <span class="hljs-type">Unit</span>)</span></span> {
        _channel.close()
    }

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCancelled</span><span class="hljs-params">(cause: <span class="hljs-type">Throwable</span>, handled: <span class="hljs-type">Boolean</span>)</span></span> {
        <span class="hljs-keyword">val</span> processed = _channel.close(cause)
        <span class="hljs-keyword">if</span> (!processed &amp;&amp; !handled) handleCoroutineException(context, cause)
    }
}

</code></pre>
<p>我们发现在它的<code>完成</code>和<code>取消</code>方法中都会调用<code>_channel.close</code>的方法。也正是这样，Channel 才被称为热数据流。这里有一点需要注意：对千一个<code>Channe</code>如果我们调用了它的<code>close</code>方法，它会<strong>立即停止接收</strong>新元素，也就是说这时候它的<code>isClosedForSend</code>会立即返回<code>true</code>,而由<code>Channel缓冲区</code>的存在， 这时候可能还有一些元素没有被处理完，因此要等所有的元素都被读取之后<code>isClosedForReceive</code>才会返回<code>true</code>.</p>
<h2 data-id="heading-5">BroadcastChannel</h2>
<p>在实际环境中，经常会出现一个发送对应多个接收的情况。这里我们就需要 BroadcastChannel 了。</p>
<pre><code class="hljs language-kotlin" lang="kotlin">    <span class="hljs-keyword">val</span> broadcastChannel =  BroadcastChannel&lt;<span class="hljs-built_in">Int</span>&gt;(Channel.BUFFERED)

    <span class="hljs-keyword">val</span> producer = GlobalScope.launch {
        List(<span class="hljs-number">3</span>){
            delay(<span class="hljs-number">1000</span>)
            broadcastChannel.send(it)
        }
    }
    List(<span class="hljs-number">3</span>){
        index -&gt;
        GlobalScope.launch {
            <span class="hljs-keyword">val</span> receiveChannel = broadcastChannel.openSubscription()
            <span class="hljs-keyword">for</span>(i <span class="hljs-keyword">in</span> receiveChannel){
                println(<span class="hljs-string">"[#<span class="hljs-variable">$index</span>] received <span class="hljs-variable">$i</span>"</span>)
            }
        }
    }.joinAll()
</code></pre>
<p>这里有个细节需要注意一下，如果把发送端的<code>dealy(100)</code>去掉，可能会出现部分元素收不到或者完全收不到的情况，这是因为<code>BroadcastChannel</code>在发送的时候没有订阅者，这条消息就被丢弃了。<br/>
我们也可以通过普通的 Channel 进行转换：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">val</span> channel = Channel&lt;<span class="hljs-built_in">Int</span>&gt;()
channel.broadcast(<span class="hljs-number">3</span>)
</code></pre>
<p>这里需要注意一下，<strong>BroadcastChannel</strong>被标记为过时了，可以使用<code>SharedFlow</code>和<code>StateFlow</code>代替。<code>channel.broadcast()</code>方法也被标记为过时，也是使用<code>SharedFlow</code>来代替</p>
<hr/>
<p>以上</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[kotlin协程-冷数据流Flow]]></title>    <link>https://juejin.cn/post/7590128405350612992</link>    <guid>https://juejin.cn/post/7590128405350612992</guid>    <pubDate>2026-01-02T10:57:20.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7590128405350612992" data-draft-id="7590071125398487080" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="kotlin协程-冷数据流Flow"/> <meta itemprop="keywords" content="Kotlin"/> <meta itemprop="datePublished" content="2026-01-02T10:57:20.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Huang兄"/> <meta itemprop="url" content="https://juejin.cn/user/52404619842712"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            kotlin协程-冷数据流Flow
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/52404619842712/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Huang兄
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-02T10:57:20.000Z" title="Fri Jan 02 2026 10:57:20 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-02
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:14px;overflow-x:hidden;color:var(--cyanosis-base-color);transition:color .35s;--cyanosis-base-color:#353535;--cyanosis-title-color:#005bb7;--cyanosis-strong-color:#2196f3;--cyanosis-em-color:#4fc3f7;--cyanosis-del-color:#ccc;--cyanosis-link-color:#3da8f5;--cyanosis-linkh-color:#007fff;--cyanosis-border-color:#bedcff;--cyanosis-border-color-2:#ececec;--cyanosis-bg-color:#fff;--cyanosis-blockquote-color:#8c8c8c;--cyanosis-blockquote-bg-color:#f0fdff;--cyanosis-code-color:#c2185b;--cyanosis-code-bg-color:#fff4f4;--cyanosis-code-pre-color:#f8f8f8;--cyanosis-table-border-color:#c3e0fd;--cyanosis-table-th-color:#dff0ff;--cyanosis-table-tht-color:#005bb7;--cyanosis-table-tr-nc-color:#f7fbff;--cyanosis-table-trh-color:#e0edf7;--cyanosis-slct-title-color:#005bb7;--cyanosis-slct-titlebg-color:rgba(175,207,247,0.25);--cyanosis-slct-text-color:#c80000;--cyanosis-slct-bg-color:rgba(175,207,247,0.25);--cyanosis-slct-del-color:#999;--cyanosis-slct-elbg-color:#e8ebec;--cyanosis-slct-codebg-color:#ffeaeb;--cyanosis-slct-prebg-color:rgba(160,200,255,0.25)}.markdown-body.__dark{--cyanosis-base-color:#cacaca;--cyanosis-title-color:#ddd;--cyanosis-strong-color:#fe9900;--cyanosis-em-color:#ffd28e;--cyanosis-del-color:#ccc;--cyanosis-link-color:#ffb648;--cyanosis-linkh-color:#fe9900;--cyanosis-border-color:#ffe3ba;--cyanosis-border-color-2:#ffcb7b;--cyanosis-bg-color:#2f2f2f;--cyanosis-blockquote-color:#c7c7c7;--cyanosis-blockquote-bg-color:rgba(255,199,116,0.1);--cyanosis-code-color:#000;--cyanosis-code-bg-color:#ffcb7b;--cyanosis-code-pre-color:rgba(255,227,185,0.5);--cyanosis-table-border-color:#fe9900;--cyanosis-table-th-color:#ffb648;--cyanosis-table-tht-color:#000;--cyanosis-table-tr-nc-color:#6d5736;--cyanosis-table-trh-color:#947443;--cyanosis-slct-title-color:#000;--cyanosis-slct-titlebg-color:#fe9900;--cyanosis-slct-text-color:#00c888;--cyanosis-slct-bg-color:rgba(175,207,247,0.25);--cyanosis-slct-del-color:#999;--cyanosis-slct-elbg-color:#000;--cyanosis-slct-codebg-color:#ffcb7b;--cyanosis-slct-prebg-color:rgba(160,200,255,0.25)}.markdown-body h1{padding-bottom:4px;font-size:30px}.markdown-body h1,.markdown-body h2{margin-top:36px;margin-bottom:10px;line-height:1.5;color:var(--cyanosis-title-color);transition:color .35s}.markdown-body h2{position:relative;padding-left:10px;padding-right:10px;padding-bottom:10px;font-size:24px;border-bottom:1px solid var(--cyanosis-border-color-2)}.markdown-body h2:before{content:"「";position:absolute;top:-6px;left:-14px}.markdown-body h2:after{content:"」";position:relative;top:6px;right:auto}.markdown-body h3{position:relative;padding-bottom:0;margin-top:30px;margin-bottom:10px;font-size:20px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body h3:before{content:"»";padding-right:6px;color:var(--cyanosis-strong-color)}.markdown-body h4{margin-top:24px;font-size:16px}.markdown-body h4,.markdown-body h5{padding-bottom:0;margin-bottom:10px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body h5{margin-top:18px;font-size:14px}.markdown-body h6{padding-bottom:0;margin-top:12px;margin-bottom:10px;font-size:12px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body p{line-height:inherit;margin-top:16px;margin-bottom:16px}.markdown-body img{max-width:100%}.markdown-body hr{position:relative;width:98%;height:1px;margin-top:32px;margin-bottom:32px;background-image:linear-gradient(90deg,var(--cyanosis-link-color),rgba(255,0,0,.3),hsla(0,0%,100%,.1),rgba(255,0,0,.3),var(--cyanosis-link-color));border-width:0;overflow:visible}.markdown-body hr:after{content:"";position:absolute;margin:auto;left:0;right:0;bottom:0;top:0;display:inline-block;width:60px;height:20px;background-color:var(--cyanosis-bg-color);background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAgCAYAAABgrToAAAADoklEQVRYR82XTYgcRRTHf2933Q1RjAa9eFO8JHoJ8RQVBQ2iBwXBET0YEUTXNVmNQtTpmeqaWV0XNRq/o4KoECSCEPSg4CF+BYUkIIiCoCJCPIhC/Ihh2Z0nVV27VnZnenumW9i6ddV7//frV69fVQurfMgq56NawFTPAU6QyomqXrw6wIZeyhCPebA5buNR+akKyGoAjd6BshthnYdSjqNcRVuOlIUsD2j0SuA94IwuMHdh5ZUykOUBXfSGbmKI54EtAeYIHSZoy5dl4JxvNYBOKdW1KE8BQ8AkVk6WhasWsAiN0TX9gveXQaPP+Aytpc4u+bMI06JNohsYYYYOR2lJWtS3OKDRfcAtQfgDoI6Vo4UCGb0OmAEuDvZvYmVbEd/igC3dzDz7gQu8sPA9kJDK27mBmjqBeLjTg90PDFOjWawFFQd06kZHEfaj3LAIpTRpSXsZ5E06zEYP9sDimnAApYaV2SLZG/wjMeqAkijwW4xQJ5Gf/ZzRC8OW3hiBTGGlURRswW55Bh/Ssxljrwew8l1PQaM14GngvGDzBUKdDsMeTtgU5o8B92PFlUf3YXUrHa7Fys6lBqcCGnX15YQ2A18FyPd7Crd1A3M8C1wdbH4DD3hWeP6IEXbQkG97ajR1HPFnuPP5jFFq1OWX7hl8WM9l1AO648uNfwLk7tytMeogty+xeQ4rO3r6bdcx1nuwOGsHmaXGtPzae4uzGnLH1kQkvpdZGrHjssBZJrL+pqS05KWc8tgITAPXRzYvYOXe/C2OV43eDcRBDtIhoS2f9wzc0Cv8Wls+zoFzUC5zF0U241h5uZtPfptp6OUM8wbK+cH5GEpCS17P3fJei0Z3+npTxryJ8CPzbKMtn/ZyWbkPGl0PuFPkmkjkcb4h4R2ZLwRq1H0ALmvjkf2HwK1Y+T1PY2XABe/sHJ6MxN5lnoSpnC/UGbsTaI5phK2R7x6s3Ffk5YoDOrWm3onwJHBmEP86bPmBrsGaenNoIdnxCH+gPEhLXi0Cl1VBvyPVLSh7gEuC62yAfOIUqabWEaaiucMIk6RyqJ+Q/QM69V26jjW86Gvov/EaoyT8zRCn+Xq7PVrbx0nuYUaO9wM3WAbjCE1NEUw09Um4UV+2OKfYfu5/S19gsAzGKqm6LE5FrShbdS0ku465DjDwKA/oQht19ejqbaEVuRbiLhuHByYLjtUAZpDutzP7cYdHsPJXWbjyNVgFwQoa1WXwf4Jd9YD/Ap80+yE7+u9aAAAAAElFTkSuQmCC);background-repeat:no-repeat;background-size:auto 100%;background-position-x:center;transition:background-color .5s}.markdown-body code{padding:.065em .4em;font-size:.87em;color:var(--cyanosis-code-color);word-break:break-word;overflow-x:auto;background-color:var(--cyanosis-code-bg-color);border-radius:2px}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{display:block;padding:16px 12px;margin:0;font-size:12px;color:#333;word-break:normal;overflow-x:auto;background:var(--cyanosis-code-pre-color)}.markdown-body pre&gt;code::-webkit-scrollbar{width:4px;height:4px}.markdown-body pre&gt;code::-webkit-scrollbar-track{background-color:var(--cyanosis-border-color)}.markdown-body pre&gt;code::-webkit-scrollbar-thumb{background-color:var(--cyanosis-strong-color);border-radius:10px}.markdown-body a{position:relative;text-decoration:none;color:var(--cyanosis-link-color);border-bottom:1px solid var(--cyanosis-border-color)}.markdown-body a:hover{border-bottom-color:var(--cyanosis-linkh-color)}.markdown-body a:active,.markdown-body a:hover{color:var(--cyanosis-linkh-color)}.markdown-body a:after{position:absolute;content:"";top:100%;left:0;width:100%;opacity:0;border-bottom:1px solid var(--cyanosis-border-color);transition:top .3s,opacity .3s;transform:translateZ(0)}.markdown-body a:hover:after{top:0;opacity:1;border-bottom-color:var(--cyanosis-linkh-color)}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid var(--cyanosis-table-border-color);border-spacing:0;border-collapse:collapse}.markdown-body table thead{color:#000;text-align:left;font-size:14px;background:#f6f6f6}.markdown-body table tr:nth-child(2n){background-color:var(--cyanosis-table-tr-nc-color)}.markdown-body table tr:hover{background-color:var(--cyanosis-table-trh-color)}.markdown-body table td,.markdown-body table th{padding:12px 8px;line-height:24px;border:1px solid var(--cyanosis-table-border-color)}.markdown-body table th{color:var(--cyanosis-table-tht-color);background-color:var(--cyanosis-table-th-color)}.markdown-body table td{min-width:120px}.markdown-body blockquote{color:var(--cyanosis-blockquote-color);border-left:4px solid var(--cyanosis-strong-color);background-color:var(--cyanosis-blockquote-bg-color);padding:1px 20px;margin:22px 0;transition:color .35s}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body b,.markdown-body blockquote&gt;b,.markdown-body blockquote&gt;strong,.markdown-body strong{color:var(--cyanosis-strong-color)}.markdown-body em,.markdown-body i{color:var(--cyanosis-em-color)}.markdown-body del{color:var(--cyanosis-del-color)}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:4px}.markdown-body ol li{padding-left:6px}.markdown-body details&gt;summary{outline:none;color:var(--cyanosis-title-color);font-size:20px;font-weight:bolder;border-bottom:1px solid var(--cyanosis-border-color);cursor:pointer}.markdown-body details&gt;p{padding:10px 20px;margin:10px 0 0;color:#666;background-color:var(--cyanosis-blockquote-bg-color);border:2px dashed var(--cyanosis-strong-color)}.markdown-body h1::selection,.markdown-body h2::selection,.markdown-body h3::selection,.markdown-body h4::selection,.markdown-body h5::selection,.markdown-body h6::selection{color:var(--cyanosis-slct-title-color);background-color:var(--cyanosis-slct-titlebg-color)}.markdown-body ol li::selection,.markdown-body p::selection,.markdown-body ul li::selection{color:var(--cyanosis-slct-text-color);background-color:var(--cyanosis-slct-bg-color)}.markdown-body a::selection,.markdown-body b::selection,.markdown-body em::selection,.markdown-body i::selection,.markdown-body strong::selection{background-color:var(--cyanosis-slct-elbg-color)}.markdown-body del::selection{color:var(--cyanosis-slct-del-color);background-color:var(--cyanosis-slct-elbg-color)}.markdown-body table thead th::selection{background-color:transparent}.markdown-body table tbody td::selection{background-color:var(--cyanosis-slct-bg-color)}.markdown-body code::selection{background-color:var(--cyanosis-slct-codebg-color)}.markdown-body pre&gt;code::selection{background-color:var(--cyanosis-slct-prebg-color)}.markdown-body .contains-task-list{padding-left:14px;list-style:none}.markdown-body .contains-task-list input[type=checkbox]{position:relative}.markdown-body .contains-task-list input[type=checkbox]:before{content:"";position:absolute;top:0;left:0;right:0;bottom:0;width:inherit;height:inherit;background:#f0f8ff;border:1px solid #add6ff;border-radius:2px;box-sizing:border-box;z-index:1}.markdown-body .contains-task-list input[type=checkbox]:checked:after{content:"✓";position:absolute;top:-12px;left:0;right:0;bottom:0;width:0;height:0;color:#f55;font-size:20px;font-weight:700;z-index:2}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="atom-one-dark">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#abb2bf;background:#282c34}.hljs-comment,.hljs-quote{color:#5c6370;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#c678dd}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e06c75}.hljs-literal{color:#56b6c2}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#98c379}.hljs-built_in,.hljs-class .hljs-title{color:#e6c07b}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#d19a66}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#61aeee}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}</style><p>种一颗树的最好时机是十年前，其次是现在。
学习也一样。
跟着霍老师的《深入理解 Kotlin 携程》学习一下协程。</p>
<h2 data-id="heading-0">一点前言</h2>
<p>随着RxJava的流行，响应式编程模型逐步深入人心。Flow就是kotlin协程与响应式编程模型结合的产物。</p>
<h2 data-id="heading-1">认识Flow</h2>
<p>我们从序列生成器开始</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">val</span> ints = sequence {
    (<span class="hljs-number">10.</span><span class="hljs-number">.30</span>).forEach {
        yield(it)
    }
}
</code></pre>
<p>这里如果希望在元素之间加个延时怎么办？因为受<code>restrictsSuspension</code>注解的约束，delay函数不能再SequenceScope的扩展成员中被调用</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/838fcf6f8af0444cb6ce03ef11800d99~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSHVhbmflhYQ=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767956240&amp;x-signature=0DTTipAvGAV7ez1lN732YsOEiBM%3D" alt="delay_in_sequence.png" loading="lazy"/></p>
<p>假设序列生成器不受这个限制，调用delay函数会导致后续的执行流程的线程发生变化，外部的调用者发现在访问ints的下一个元素的时候居然还会有切换线程的副作用。不仅如此，通过制定调度器来限定序列创建所在的线程同样是不可以的，我们甚至没有办法为它设置协程上下文。<br/>
那么我们来看一下Flow。</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">val</span> intFlow = flow {
    (<span class="hljs-number">1.</span><span class="hljs-number">.3</span>).forEach {
        emit(it)
        delay(<span class="hljs-number">1000</span>)
    }
}
</code></pre>
<p>Flow也可以设定它运行时所使用的调度器：</p>
<pre><code class="hljs language-kotlin" lang="kotlin">intFlow.flowOn(Dispatchers.IO).collect { println(it) }
</code></pre>
<p>最终消费intFlow需要调用collect函数。</p>
<h3 data-id="heading-2">冷数据流</h3>
<p>在Flow创建出来之后，不消费则不生产，多次消费则多次生产，生产和消费总是相对应的。</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> intFlow = flow {
        (<span class="hljs-number">1.</span><span class="hljs-number">.3</span>).forEach {
            emit(it)
            delay(<span class="hljs-number">1000</span>)
        }
    }
    intFlow.flowOn(Dispatchers.IO).collect { println(it) }
    intFlow.flowOn(Dispatchers.IO).collect { println(it) }
}
</code></pre>
<p>这里会输出两次“123”</p>
<h3 data-id="heading-3">异常处理</h3>
<p>Flow的异常处理也比较直接，直接调用<code>catch</code>函数即可。需要注意的是，<code>catch</code>函数只能捕获它上游的异常，并且，当我们没有调用<code>catch</code>函数时，未捕获的异常会在消费时抛出。当然了，我们可以使用<code>onCompletion</code>来进行FLow完成时的逻辑</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    flow {
        emit(<span class="hljs-number">1</span>)
        <span class="hljs-keyword">throw</span> ArithmeticException(<span class="hljs-string">"div 0"</span>)
    }.<span class="hljs-keyword">catch</span> { t: Throwable -&gt;
        println(<span class="hljs-string">"caught error :<span class="hljs-variable">$t</span>"</span>)
    }.onCompletion { t: Throwable? -&gt; 
        println(<span class="hljs-string">"finally."</span>)
    }.flowOn(Dispatchers.Default)
        .collect { value -&gt; println(value) }
}
</code></pre>
<p><code>onCompletion</code>类似于<code>try ... catch ... finally</code> 中的finally。这套处理机制的设计初衷是确保Flow操作中异常的透明，因此我们<strong>不能</strong>或者<strong>禁止</strong>这样写：</p>
<pre><code class="hljs language-kotlin" lang="kotlin">flow { 
    <span class="hljs-keyword">try</span> {
        emit(<span class="hljs-number">1</span>)
        <span class="hljs-keyword">throw</span> ArithmeticException(<span class="hljs-string">"Div 0"</span>)
    } <span class="hljs-keyword">catch</span> (e: ArithmeticException) {
        println(<span class="hljs-string">"caught error: <span class="hljs-variable">$e</span>"</span>)
    }<span class="hljs-keyword">finally</span> {
        println(<span class="hljs-string">"finally"</span>)
    }
}
</code></pre>
<h3 data-id="heading-4">末端操作符</h3>
<p>collect是最基本的末端操作符，还有其他末端操作符，大体分为两类</p>
<ul>
<li>集合类型转换操作符，包括toList、toSet等</li>
<li>聚合操作符，包括将Flow规约到单值的reduce、fold等操作；还有获得单个元素的操作符，包括single、singleOrNull、first等</li>
</ul>
<p>由于Flow的消费端一定需要运行在协程中，因此末端操作符都是挂起函数。</p>
<h3 data-id="heading-5">分离Flow的消费和触发</h3>
<p>我们还可以通过onEach来做到这一点，这样消费的具体操作就不需要与末端操作符放到一起，collect函数可以放到其他任意位置调用</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createFlow</span><span class="hljs-params">()</span></span> = flow&lt;<span class="hljs-built_in">Int</span>&gt;{
    (<span class="hljs-number">1.</span><span class="hljs-number">.10</span>).forEach {
        emit(it)
        delay(<span class="hljs-number">1000</span>)
    }
}.onEach {
    println(it)
}

<span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    GlobalScope.launch {
        createFlow().collect()
    }
     delay(<span class="hljs-number">20</span> * <span class="hljs-number">1000</span>)
}

</code></pre>
<p>需要注意一下，Flow并没有提供取消操作，想要取消Flow，只需要取消它所在的协程即可。</p>
<h3 data-id="heading-6">其他Flow的创建方式</h3>
<p>当我们使用<code>flow{...}</code>来创建Flow时，无法随意切换调度器，因为emit函数不是线程安全的。想要在生成元素时切换调度器，就必须使用channelFlow函数来创建Flow：</p>
<pre><code class="hljs language-kotlin" lang="kotlin">channelFlow { 
    send(<span class="hljs-number">1</span>)
    withContext(Dispatchers.IO){
        send(<span class="hljs-number">2</span>)
    }
}
</code></pre>
<p>此外，我们可以通过集合矿建来创建Flow：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    listOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>).asFlow().collect { value -&gt; println(value) }
    setOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>).asFlow().collect { value -&gt; println(value) }
    flowOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>).collect { value -&gt; println(value) }
}
</code></pre>
<h3 data-id="heading-7">背压</h3>
<p>只要是响应式编程，就一定会有背压问题，背压问题在生产者的生产速率高于消费者的处理速率情况下出现。为了保证数据不丢失，我们可以添加一个制定容量的buffer。但这只是治标不治本的方法，随着时间的推移，还是会造成时间上的积压。
出现背压问题的根本原因是生产者和消费者的速速率不匹配，除了直接优化消费者的性能外，我们还可以采取一些取舍的手段。</p>
<p>第一种是conflate，和Channel的Conflate模式一致，新数据覆盖老数据。</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
  flow {
      List(<span class="hljs-number">100</span>){
          emit(it)
      }
  }.conflate()
      .collect{value -&gt;
          println(<span class="hljs-string">"Collected: <span class="hljs-variable">$value</span>"</span>)
          delay(<span class="hljs-number">100</span>)
          println(<span class="hljs-string">"<span class="hljs-variable">$value</span> collected"</span>)
      }
}

</code></pre>
<p>虽然我们发送了100个元素，但最终只接收到2个，多次运行的结果并不相同。
第二种是collectLasted，只处理最新的数据，区别在于：collectLasted并不会直接用新数据覆盖老数据，而是每一个数据都会处理，只不过如果前一个还没被处理完后一个就来了话，处理前一个数据的逻辑就会被取消。</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    flow {
        List(<span class="hljs-number">10</span>) {
            emit(it)
        }
    }.collectLatest { value -&gt;
        println(<span class="hljs-string">"Collected: <span class="hljs-variable">$value</span>"</span>)
        delay(<span class="hljs-number">1000</span>)
        println(<span class="hljs-string">"<span class="hljs-variable">$value</span> collected"</span>)
    }
}
</code></pre>
<p>输出</p>
<blockquote>
<p>Collected: 0
Collected: 1
Collected: 2
Collected: 3
Collected: 4
Collected: 5
Collected: 6
Collected: 7
Collected: 8
Collected: 9
9 collected</p>
</blockquote>
<p>前面的<code>println("Collected: $value")</code>输出了所有结果，后面的<code>println("$value collected")</code>只输出了最后一个结果，因为后面的数据到达时，处理上个数据的操作正好被挂起了。</p>
<p>除此之外，还有mapLatest,flatMapLatest等。</p>
<h3 data-id="heading-8">Flow的变换</h3>
<p>我们可以使用<code>map</code>来变换Flow的数据</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    flow {
        List(<span class="hljs-number">5</span>) {
            emit(it)
        }
    }.map {
        it * <span class="hljs-number">2</span>
    }.collect {
        println(it)
    }
}
</code></pre>
<p>输出</p>
<blockquote>
<p>0
2
4
6
8</p>
</blockquote>
<p>还有按照顺序拼接的flattenConcat，不保证顺序的flattenMerge操作等</p>
<hr/>
<p>以上</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[为什么view.post()能获取到view的宽高?]]></title>    <link>https://juejin.cn/post/7590054976489717800</link>    <guid>https://juejin.cn/post/7590054976489717800</guid>    <pubDate>2026-01-02T11:57:14.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7590054976489717800" data-draft-id="7590104561474797620" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="为什么view.post()能获取到view的宽高?"/> <meta itemprop="keywords" content="源码"/> <meta itemprop="datePublished" content="2026-01-02T11:57:14.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="XRay"/> <meta itemprop="url" content="https://juejin.cn/user/3966693685869288"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            为什么view.post()能获取到view的宽高?
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3966693685869288/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    XRay
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-02T11:57:14.000Z" title="Fri Jan 02 2026 11:57:14 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-02
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    3
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>我们经常会遇到要获取 view 的宽高的情况，如果直接在 onCreate() 方法中获取 View 的宽高，拿到的结果是 0，但是通过 view 的 post() 方法却可以拿到 view 的宽高，运行如下代码：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">TAG</span> <span class="hljs-operator">=</span> MyActivity.class.getSimpleName();

    <span class="hljs-keyword">private</span> TextView tv;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Bundle savedInstanceState)</span> {
        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        tv = (TextView) findViewById(R.id.my_text);
        Log.d(TAG, <span class="hljs-string">"11111 width: "</span> + tv.getMeasuredWidth() + <span class="hljs-string">" - height : "</span> + tv.getHeight());
        tv.post(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() {

            <span class="hljs-meta">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> {
                Log.d(TAG, <span class="hljs-string">"22222 width: "</span> + tv.getMeasuredWidth() + <span class="hljs-string">" - height : "</span> + tv.getMeasuredHeight());
            }
        });
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onResume</span><span class="hljs-params">()</span> {
        <span class="hljs-built_in">super</span>.onResume();
        Log.e(TAG, <span class="hljs-string">"33333 height："</span> + tv.getMeasuredHeight());
    }
}
</code></pre>
<p>activity_main.xml:</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"utf-8"</span>?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span>
    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span>
    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"match_parent"</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span>
        <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/my_text"</span>
        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"wrap_content"</span>
        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span>
        <span class="hljs-attr">android:text</span>=<span class="hljs-string">"Hello World!"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span>
</code></pre>
<p>打印结果如下：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-number">11111</span> width: <span class="hljs-number">0</span> - height : <span class="hljs-number">0</span>
<span class="hljs-number">33333</span> height：<span class="hljs-number">0</span>
<span class="hljs-number">22222</span> width: <span class="hljs-number">201</span> - height : <span class="hljs-number">51</span>
</code></pre>
<p>其中 getMeasuredWidth() 获取的是成员变量 mMeasuredWidth 的值:</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMeasuredWidth</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">return</span> mMeasuredWidth &amp; MEASURED_SIZE_MASK;
}
</code></pre>
<p>通过前面的文章 <a href="https://juejin.cn/post/7301648406198894618" target="_blank" title="https://juejin.cn/post/7301648406198894618">Android View的绘制流程</a> 我们知道执行完 View 的 measure() 方法才会对 mMeasuredWidth 赋值，第一次触发绘制在 OnResume() 生命周期方法调用之后，为什么这里在 OnCreate() 方法里面执行 tv.post(Runnable action) 却可以获取到View的宽高呢？</p>
<p>下面我们就围绕这个疑问通过源码来分析，源码基于Android SDK 31。</p>
<p>先来看看 View 的 post() 方法做了什么：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">View</span>{

    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">post</span><span class="hljs-params">(Runnable action)</span> {
        <span class="hljs-keyword">final</span> <span class="hljs-type">AttachInfo</span> <span class="hljs-variable">attachInfo</span> <span class="hljs-operator">=</span> mAttachInfo;
        <span class="hljs-comment">// 若 attachInfo 不为 null,直接调用其内部 Handler 的 post() 方法</span>
        <span class="hljs-keyword">if</span> (attachInfo != <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">return</span> attachInfo.mHandler.post(action);
        }

        <span class="hljs-comment">// 下面是 attachInfo 为 null 的情况</span>
        getRunQueue().post(action);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
   }
}
</code></pre>
<p>这里通过判断 attachInfo 是否为 null 进行了不同的处理，我们先来研究 attachInfo 为 null 的情况， attachInfo 为 null 时调用了 getRunQueue() 的 post() 方法：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">View</span>{

    <span class="hljs-comment">/**
    * Queue of pending runnables. Used to postpone calls to post() until this
    * view is attached and has a handler.
    */</span>
    <span class="hljs-keyword">private</span> HandlerActionQueue mRunQueue;

    <span class="hljs-keyword">private</span> HandlerActionQueue <span class="hljs-title function_">getRunQueue</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">if</span> (mRunQueue == <span class="hljs-literal">null</span>) {
            mRunQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HandlerActionQueue</span>();
        }
        <span class="hljs-keyword">return</span> mRunQueue;
    }
}
</code></pre>
<p>其中 getRunQueue() 返回的是 mRunQueue，它是是 HandlerActionQueue 的实例，HandlerActionQueue 的 post() 方法的代码如下：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HandlerActionQueue</span> {

    <span class="hljs-keyword">private</span> HandlerAction[] mActions;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">post</span><span class="hljs-params">(Runnable action)</span> {
        postDelayed(action, <span class="hljs-number">0</span>);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postDelayed</span><span class="hljs-params">(Runnable action, <span class="hljs-type">long</span> delayMillis)</span> {
        <span class="hljs-comment">// 1. 将传入的 Runnable 封装成 HandlerAction</span>
        <span class="hljs-keyword">final</span> <span class="hljs-type">HandlerAction</span> <span class="hljs-variable">handlerAction</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HandlerAction</span>(action, delayMillis);

        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) {
            <span class="hljs-keyword">if</span> (mActions == <span class="hljs-literal">null</span>) {
                mActions = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HandlerAction</span>[<span class="hljs-number">4</span>];
            }
            <span class="hljs-comment">// 2. 将 HandlerAction 保存在 mActions 数组中</span>
            mActions = GrowingArrayUtils.append(mActions, mCount, handlerAction);
            mCount++;
        }
    }
}
</code></pre>
<p>这里先将传入的 action 封装成 HandlerAction 对象，然后将 HandlerAction 对象保存到了 mActions 数组中。由此可知 <code>attachInfo 为 null 时，post(Runnable action) 只是把 action 添加到 mActions 数组里面存了起来，暂时还没有执行</code>。而执行 View 的 post() 方法时 attachInfo 是否为 null 呢？答案是肯定的，View 中只有一处给 mAttachInfo 赋值的地方，在 dispatchAttachedToWindow() 方法中：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">View</span>{

    <span class="hljs-keyword">void</span> <span class="hljs-title function_">dispatchAttachedToWindow</span><span class="hljs-params">(AttachInfo info, <span class="hljs-type">int</span> visibility)</span> {
        <span class="hljs-comment">// 给 mAttachInfo 赋值，此时同一个 ViewRootImpl 内的所有 View 共用同一个 AttachInfo</span>
        mAttachInfo = info;
        ...
        <span class="hljs-comment">// mRunQueue 又出现了，其内部保存了我们的 action 任务</span>
        <span class="hljs-keyword">if</span> (mRunQueue != <span class="hljs-literal">null</span>) {
            <span class="hljs-comment">// 内部执行了 info.mHandler.post(action)</span>
            mRunQueue.executeActions(info.mHandler);
            mRunQueue = <span class="hljs-literal">null</span>;
        }
        ...
    }
}
</code></pre>
<p>在这里给 mAttachInfo 赋值后，使用 Handler 执行 mActions 中存储的任务，所以<code>这里才会真正执行 Handler.post(action)</code> 。</p>
<p>View 的 dispatchAttachedToWindow() 又是在什么时候调用的呢？在绘制流程的开始阶段会调用 ViewRootImpl 的 performTraversals() 方法：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ViewRootImpl</span>{
    <span class="hljs-comment">/**
    * 1. AttachInfo 的创建是在 ViewRootImpl 的构造方法中
    * 2. 同一个 View Hierachy 树结构中所有的 View 共用一个 AttachInfo
    */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ViewRootImpl</span><span class="hljs-params">(...)</span>{
        mAttachInfo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">View</span>.AttachInfo(mWindowSession, mWindow, display, <span class="hljs-built_in">this</span>, mHandler, <span class="hljs-built_in">this</span>,context);
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">performTraversals</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// mView 即 DecorView，host 的类型是 DecorView，DecorView 继承自 FrameLayout</span>
        <span class="hljs-comment">// 每个 Activity 都会关联一个 Window，每个 Window 又对应一个 DecorView 对象</span>
        <span class="hljs-keyword">final</span> <span class="hljs-type">View</span> <span class="hljs-variable">host</span> <span class="hljs-operator">=</span> mView;

        <span class="hljs-comment">// 调用 DecorView 的 dispatchAttachedToWindow()</span>
        <span class="hljs-comment">// 关注 1</span>
        host.dispatchAttachedToWindow(mAttachInfo, <span class="hljs-number">0</span>);

        <span class="hljs-comment">// 开始绘制的三大流程：测量、布局、绘制</span>
        performMeasure();
        performLayout();
        performDraw();
        ...
    }
}
</code></pre>
<p>这里会调用 DecorView 的 dispatchAttachedToWindow() 方法，DecorView 中并没有这个方法，该方法在 DecorView 的父类——ViewGroup 中：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ViewGroup</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">View</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ViewParent</span>, ViewManager {

    <span class="hljs-keyword">void</span> <span class="hljs-title function_">dispatchAttachedToWindow</span><span class="hljs-params">(AttachInfo info, <span class="hljs-type">int</span> visibility)</span> {
        <span class="hljs-built_in">super</span>.dispatchAttachedToWindow(info, visibility);

        <span class="hljs-comment">// 获取子 View 的数量</span>
        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> mChildrenCount;
        <span class="hljs-keyword">final</span> View[] children = mChildren;

        <span class="hljs-comment">// 遍历所有子 View，调用所有子 View 的 dispatchAttachedToWindow() &amp; 为每个子 View 关联 AttachInfo</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; count; i++) {
        <span class="hljs-keyword">final</span> <span class="hljs-type">View</span> <span class="hljs-variable">child</span> <span class="hljs-operator">=</span> children[i];
            child.dispatchAttachedToWindow(info,combineVisibility(visibility, child.getVisibility()));
        }
    }
}
</code></pre>
<p>在这里会遍历 DecorView 中的子 View 并执行子 View 的 dispatchAttachedToWindow() 方法，所以，<code>View 的 dispatchAttachedToWindow() 方法是在 ViewRootImpl 的 performTraversals() 方法中调用的</code>。</p>
<p>而 ViewRootImpl 的 performTraversals() 方法的执行在 onResume() 之后，在文章最开始的示例中，tv.post(Runnable action) 是在 onCreate() 方法中调用的，所以此时 mAttachInfo 为 null。</p>
<p>真正执行 Handler.post(action) 在关注 1 处，但是上面的关注 1 明明是在绘制流程开始之前执行的，这样执行 action 获取出来的宽高不应该是 0 吗？</p>
<p>这是因为<code>在绘制流程开始之前代码里给 mHandler 添加了同步屏障消息，此时会优先处理异步消息，即优先处理绘制流程</code>：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ViewRootImpl</span>{

    <span class="hljs-keyword">void</span> <span class="hljs-title function_">scheduleTraversals</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">if</span> (!mTraversalScheduled) {
            mTraversalScheduled = <span class="hljs-literal">true</span>;
            <span class="hljs-comment">// 添加同步屏障</span>
            mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();
            <span class="hljs-comment">// 开始绘制流程</span>
            mChoreographer.postCallback(Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="hljs-literal">null</span>);
        }
    }
}
</code></pre>
<p>只有等绘制流程结束后，才会处理 mHandler 中的同步消息，这时候才会执行 action 的 run() 方法，所以 action 的 run() 方法其实是在 measure() 方法之后执行的，所以在这里可以获取到正确的宽高值。</p>
<p>至于什么是同步屏障，大家看这里：<a href="https://juejin.cn/post/7589935326782865442" target="_blank" title="https://juejin.cn/post/7589935326782865442">Android消息机制之同步屏障</a></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[2025 技术总结：我把技术重新结构化的一年]]></title>    <link>https://juejin.cn/post/7590128405350760448</link>    <guid>https://juejin.cn/post/7590128405350760448</guid>    <pubDate>2026-01-02T12:05:47.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7590128405350760448" data-draft-id="7589849698488746018" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="2025 技术总结：我把技术重新结构化的一年"/> <meta itemprop="keywords" content="Android"/> <meta itemprop="datePublished" content="2026-01-02T12:05:47.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="潜龙勿用之化骨龙"/> <meta itemprop="url" content="https://juejin.cn/user/2313028195058471"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            2025 技术总结：我把技术重新结构化的一年
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2313028195058471/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    潜龙勿用之化骨龙
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-02T12:05:47.000Z" title="Fri Jan 02 2026 12:05:47 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-02
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>如果说前几年我是在“捡 API、抄 Demo、补锅”，那 2025 就是我开始“写自己的框架”的一年。</p>
<p>我不追热点、不卷新概念。<br/>
我更像是在给自己搭一个“能复用、能解释、能传给别人”的技术体系。</p>
<p>这一年，我围绕 <strong>Kotlin 协程、并发模型、Flow、架构设计、工程实践</strong> 写了点文章。</p>
<h2 data-id="heading-0">🧭 一、协程与并发：从“会用”到“吃透”</h2>
<p>今年我最大的突破，是终于把协程从“工具”理解成“范式”。</p>
<h3 data-id="heading-1">1. 协程解决的不是“怎么开线程”，而是“怎么组织并发工作流”。</h3>
<p>我写了多篇文章，从底层解释协程的本质：</p>
<ul>
<li>协程是挂起式，不阻塞线程 <a href="https://juejin.cn/post/7505243504915431475" target="_blank" title="https://juejin.cn/post/7505243504915431475">Kotlin协程优雅打印奇偶数</a></li>
<li>调度是协作式，而不是抢占式 <a href="https://juejin.cn/post/7479048132670013481" target="_blank" title="https://juejin.cn/post/7479048132670013481">深入理解 Kotlin 协程的挂起与恢复机制</a></li>
<li>suspend 是“可暂停的函数”，不是“异步”<a href="https://juejin.cn/post/7479048132670013481" target="_blank" title="https://juejin.cn/post/7479048132670013481">深入理解 Kotlin 协程的挂起与恢复机制</a></li>
<li>协程能从根本上降低死锁风险  <a href="https://juejin.cn/post/7552438352643047475" target="_blank" title="https://juejin.cn/post/7552438352643047475">并发编程的新篇章：以Kotlin协程告别JUC的重锁与死锁风险</a></li>
</ul>
<p>我甚至写了一个“奇偶打印”和“非阻塞优先级队列” 的示例，用代码证明：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9af9639936274fc39e5943d76a95877f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5r2c6b6Z5Yu_55So5LmL5YyW6aqo6b6Z:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767960346&amp;x-signature=3voDac5NpVmEdxRGg62BCU3p0IQ%3D" alt="image.png" loading="lazy"/></p>
<p>这段代码只跑在一个线程上，却能实现并发协作。</p>
<h3 data-id="heading-2"><strong>2. 告别 JUC：协程替代传统并发模型</strong></h3>
<p>今年我系统性地对比了协程与 JUC：</p>

























<table><thead><tr><th>JUC</th><th>协程</th></tr></thead><tbody><tr><td>ReentrantLock</td><td>Mutex</td></tr><tr><td>BlockingQueue</td><td>Channel</td></tr><tr><td>CompletableFuture</td><td>Deferred</td></tr><tr><td>ThreadPool</td><td>CoroutineDispatcher</td></tr></tbody></table>
<p>我不仅能替代，还能解释为什么协程更安全：</p>
<ul>
<li>不阻塞线程</li>
<li>可取消</li>
<li>结构化并发自动清理资源</li>
<li>不会因为线程被占满导致死锁</li>
</ul>
<p>这是我今年最有体系的一组文章 <a href="https://juejin.cn/post/7552438352643047475" target="_blank" title="https://juejin.cn/post/7552438352643047475">并发编程的新篇章：以Kotlin协程告别JUC的重锁与死锁风险</a></p>
<h3 data-id="heading-3"><strong>3. 协程异常体系：从“try-catch 不生效”到彻底理解</strong></h3>
<p>今年我终于搞懂了：</p>
<ul>
<li>为什么外层 try-catch 捕获不到协程内部异常</li>
<li>coroutineScope 会让兄弟协程一起失败</li>
<li>supervisorScope 可以隔离失败</li>
<li>Repository 层统一处理异常后，协程作用域的差异会被弱化</li>
</ul>
<p>这些理解让我在架构层面能更稳地设计协程模型 详情请见 <a href="https://juejin.cn/post/7574244766424006665" target="_blank" title="https://juejin.cn/post/7574244766424006665">协程异常处理使用策略</a></p>
<h2 data-id="heading-4">🧱 二、架构思维：从“我能写”到“我能讲清楚”</h2>
<p>今年我不仅写代码，还开始“写体系”。</p>
<h3 data-id="heading-5"><strong>1. Clean Architecture：从 PPT 到真正落地</strong></h3>
<p>以前我理解的 Clean Architecture 是“分层”。<br/>
今年我终于意识到，它不仅仅是一张结构图，更是一套<strong>行为准则</strong>。<br/>
它要求我们在复杂系统里保持边界清晰，让每一段逻辑都有明确的归宿。</p>
<p>我不再追求炫技式的抽象，而是回到业务本质：<br/>
<strong>业务逻辑必须被收敛，而不是散落在 ViewModel、Repository、Utils 各个角落。</strong></p>
<h4 data-id="heading-6"><strong>“轻量化” UseCase：业务动作的最小单位</strong></h4>
<p>在遵循 Clean Architecture 原则的基础上，我对 UseCase 的实践进行了精简。我主张回归 UseCase 作为‘业务意图载体’的本质，不再追求繁琐的继承体系或过度模板化，而是确保逻辑严谨地收敛于领域层。</p>
<p>每一个 UseCase 都应聚焦于单一业务主题，通过清晰的边界管理，实现复杂业务步骤的有序编排。</p>
<p>例如登录流程，我会这样写：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c55698b27de64cb5a6f13db765f3fa8a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5r2c6b6Z5Yu_55So5LmL5YyW6aqo6b6Z:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767960346&amp;x-signature=uvaLgVaenuznlRaAJO%2BVUQrficE%3D" alt="image.png" loading="lazy"/></p>
<p>调用端非常自然：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6dad32f7588b41ad8dd480eb392e980d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5r2c6b6Z5Yu_55So5LmL5YyW6aqo6b6Z:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767960346&amp;x-signature=M0oE7JkL5g5dRd7l2Huvs5LiM0w%3D" alt="image.png" loading="lazy"/></p>
<p>当然这代码示例过于简单,仅供参考。</p>
<p>UseCase 就是一个“可注入的业务动作集合”，<br/>
它让业务逻辑从 UI 层和数据层中被抽离出来，形成一个<strong>可复用、可测试、可复述</strong>的独立单元。</p>
<h4 data-id="heading-7"><strong>总结：架构的本质是“确定性”</strong></h4>
<p>这套体系根治了协作中‘逻辑乱飞’的顽疾。好的架构不应是开发的阻碍，而是提速的基石。 我们追求的是‘开发体验’与‘代码直观性’的统一：当代码写起来顺畅、读起来清晰，架构规范便能真正内化为团队的行为准则。</p>
<h3 data-id="heading-8"><strong>2. Data 层四条红线：年度架构实践的核心沉淀</strong></h3>
<p>今年我总结了 Data 层的四条底线：</p>
<h5 data-id="heading-9">接口契约化：Repository 接口必须强制使用 suspend 或 Flow。</h5>
<h5 data-id="heading-10">拒绝阻塞：严禁在数据流中使用阻塞队列（Blocking Queue）。</h5>
<h5 data-id="heading-11">并发轻量化：禁止使用 Java 原生重型锁，全面拥抱协程并发原语。</h5>
<h5 data-id="heading-12">响应纯粹性：确保 suspend 函数内部实现必须为“真异步”逻辑。</h5>
<p>这四条红线，让我在团队里第一次把“协程架构规范”讲清楚了。</p>
<h3 data-id="heading-13"><strong>3. Repository 不应该启动协程</strong></h3>
<p>今年我重构了大量代码，把这种写法：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/587b80a7aea344af859cace5ebc5ae6b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5r2c6b6Z5Yu_55So5LmL5YyW6aqo6b6Z:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767960346&amp;x-signature=gF%2FSq3Ys%2F8HhswJ308ShASQjnDU%3D" alt="image.png" loading="lazy"/></p>
<p>改成：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/90f59827f82843fea87ab47bba21b140~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5r2c6b6Z5Yu_55So5LmL5YyW6aqo6b6Z:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767960346&amp;x-signature=5ghQhaSAQt4i7tkOzUf2lZ%2FsCKw%3D" alt="image.png" loading="lazy"/></p>
<p>当然如果repo层发起了网络请求(retrofit)或者操作数据库(room),那么withContext(Dispatchers.IO) 也省了。如下:</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fa71a508c14043deac3266b02bf388fe~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5r2c6b6Z5Yu_55So5LmL5YyW6aqo6b6Z:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767960346&amp;x-signature=A0XUa2L1MS27pzp0%2FwtwZEo4BNc%3D" alt="image.png" loading="lazy"/></p>
<p>协程作用域交给 ViewModel 管理，生命周期更清晰，测试也更简单。</p>
<h2 data-id="heading-14">⚙️ 三、工程能力：从“能解决问题”到“能搭体系”</h2>
<p>今年我在工程实践上做了几件让我自己很满意的事情：<br/>
不只是把问题解决掉，而是把它们沉淀成<strong>可复用、可推广的工程能力</strong>。</p>
<hr/>
<h3 data-id="heading-15"><strong>1. 非阻塞优先级队列：从 Java 阻塞模型到协程模型</strong></h3>
<p>在并发编程里，队列是最基础也最关键的数据结构，尤其是在生产者-消费者模型中。<br/>
Java 的阻塞队列（如 <code>ArrayBlockingQueue</code>、<code>PriorityBlockingQueue</code>）虽然成熟，但它们依赖线程阻塞与唤醒，意味着：</p>
<ul>
<li>线程会被挂起</li>
<li>需要 OS 调度</li>
<li>上下文切换成本高</li>
</ul>
<p>在高并发场景下，这种模型往往会成为瓶颈。</p>
<p>今年我尝试把这个问题换一种方式解决：<br/>
<strong>用 Kotlin 协程实现一个真正意义上的“非阻塞优先级队列”。</strong></p>
<p>协程的挂起不会阻塞线程，因此可以让队列在“空”或“满”时挂起协程，而不是挂起线程。<br/>
这带来的好处非常明显：</p>
<ul>
<li>没有线程阻塞</li>
<li>没有线程唤醒</li>
<li>没有上下文切换</li>
<li>并发吞吐量更高</li>
</ul>
<p>是核心实现请看
<a href="https://juejin.cn/post/7531992014910930995" target="_blank" title="https://juejin.cn/post/7531992014910930995">基于Kotlin协程的非阻塞优先级队列设计与实现</a></p>
<p>这种能力在实际场景中非常有价值，例如：</p>
<ul>
<li>任务调度系统</li>
<li>实时系统</li>
<li>多优先级任务处理</li>
<li>车载系统、IoT 等高并发但线程资源有限的场景</li>
</ul>
<p>它让我第一次真正感受到：<br/>
<strong>协程不是“轻量线程”，而是另一种并发模型。</strong></p>
<h3 data-id="heading-16"><strong>2. 深入理解 runBlocking：协程世界与阻塞世界的“唯一桥梁”</strong></h3>
<p><code>runBlocking</code> 是协程里最容易被误用的 API。<br/>
它的作用很直接：<strong>启动一个协程，并阻塞当前线程直到协程执行完毕。</strong></p>
<p>它的存在意义非常明确：<br/>
<strong>在阻塞世界与协程世界之间搭桥。</strong></p>
<p>它的本质是：</p>
<blockquote>
<p><strong>把挂起函数变成阻塞调用，让非协程环境也能使用协程能力。</strong></p>
</blockquote>
<p>典型场景包括：</p>
<ul>
<li>Java 代码调用 Kotlin 挂起函数</li>
<li>Retrofit 拦截器需要同步获取 token</li>
<li>基于 HandlerThread 的旧架构需要串行执行挂起任务</li>
</ul>
<p><a href="https://juejin.cn/post/7566524333696794665" target="_blank" title="https://juejin.cn/post/7566524333696794665">Android 中  runBlocking其实只有一种使用场景</a></p>
<p>但即便如此，也应该优先考虑纯协程方案，runBlocking 只是兜底手段。</p>
<h3 data-id="heading-17">4. Kotlin 协程的五大常见错误用法及最佳实践</h3>
<p>详情请见 <a href="https://juejin.cn/post/7527881245238263846" target="_blank" title="https://juejin.cn/post/7527881245238263846">Kotlin 协程的五大常见错误用法及最佳实践</a></p>
<h2 data-id="heading-18">🧩 四、文档：从“写文档”到“做知识产品”</h2>
<p>今年我写的文档比写代码还多。</p>
<p>原因很简单：
我有强烈的分享欲，也习惯把一切做成可复用的规范。比如:</p>
<h3 data-id="heading-19"><a href="https://juejin.cn/user/2313028195058471/posts" target="_blank" title="https://juejin.cn/user/2313028195058471/posts">Kotlin 协程的五大常见错误用法及最佳实践</a></h3>
<h3 data-id="heading-20"><a href="https://juejin.cn/post/7583567658253762586" target="_blank" title="https://juejin.cn/post/7583567658253762586">Repository 方法设计：suspend 与 Flow 的决选择指南（以朋友圈为例）</a></h3>
<h3 data-id="heading-21"><a href="https://juejin.cn/post/7585476892975988770" target="_blank" title="https://juejin.cn/post/7585476892975988770">Android Data 层设计的四条红线：为什么必须坚持、如何落地</a></h3>
<p>所以我开始用更“产品化”的方式沉淀知识：</p>
<p>用图把架构讲得一目了然</p>
<p>用类比把复杂逻辑讲得人人能懂</p>
<p>用模板把新人 onboarding 的成本降到最低</p>
<p>前阵子我给团队做了一份“错误处理流程图”，
大家看完后的第一句话是：“终于懂了。”</p>
<p>那一刻我更确定：
文档不是记录，而是团队的知识基础设施。</p>
<h2 data-id="heading-22">🤝 五、AI：从工具到“第二大脑”</h2>
<p>2025，我真正学会了和 AI 合作。</p>
<p>我用它：</p>
<h5 data-id="heading-23">生成架构图</h5>
<h5 data-id="heading-24">写文档</h5>
<h5 data-id="heading-25">验证设计</h5>
<h5 data-id="heading-26">做知识树</h5>
<h5 data-id="heading-27">当思考伙伴</h5>
<p>这一年，我不再把 AI 当成工具，而是把它当成随时在线的第二大脑。</p>
<h2 data-id="heading-28">🚀 六、2026：从“积累”到“影响力”</h2>
<p>明年我想做三件事：</p>
<h4 data-id="heading-29"><strong>1. 把技术体系补全</strong></h4>
<p>包括：</p>
<ul>
<li>clean 架构</li>
<li>Compose 最佳实践</li>
<li>工程化与并发模型</li>
</ul>
<h4 data-id="heading-30"><strong>2. 输出更多“别人能直接用”的东西</strong></h4>
<p>比如：</p>
<ul>
<li>模板</li>
<li>图示</li>
<li>代码骨架</li>
<li>体系化知识</li>
</ul>
<h4 data-id="heading-31"><strong>3. 让 AI 成为真正的合作者</strong></h4>
<p>继续探索：</p>
<ul>
<li>AI 如何参与架构设计</li>
<li>AI 如何生成文档</li>
<li>AI 如何融入学习系统</li>
</ul>
<h2 data-id="heading-32"><strong>结语：2025，是我技术生涯的“结构化元年”</strong></h2>
<p>这一年，我不再盲目追求技术栈的“增量”，而开始深耕知识的“质量”。我时刻复盘这五个维度：</p>
<h5 data-id="heading-33">可复用性：代码能否超越单一场景，转化为通用的资产</h5>
<h5 data-id="heading-34">可阐述性：逻辑能否抽丝剥茧，让复杂的架构变得直观易懂</h5>
<h5 data-id="heading-35">可传递性：思想能否跨越个体，成为团队协作的共识</h5>
<h5 data-id="heading-36">可沉淀性：经验能否脱离业务，固化为可参考的实践指南</h5>
<h5 data-id="heading-37">体系化：零散的点能否连接成面，构建出稳固的技术护城河</h5></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Vite 5大实战优化技巧：让你的开发效率提升200%｜2025前端工程化指南]]></title>    <link>https://juejin.cn/post/7590159073989427252</link>    <guid>https://juejin.cn/post/7590159073989427252</guid>    <pubDate>2026-01-03T00:17:45.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7590159073989427252" data-draft-id="7590303618428420131" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Vite 5大实战优化技巧：让你的开发效率提升200%｜2025前端工程化指南"/> <meta itemprop="keywords" content="后端,前端,人工智能"/> <meta itemprop="datePublished" content="2026-01-03T00:17:45.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="阿橙的百宝箱"/> <meta itemprop="url" content="https://juejin.cn/user/1638743356481367"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Vite 5大实战优化技巧：让你的开发效率提升200%｜2025前端工程化指南
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1638743356481367/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    阿橙的百宝箱
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-03T00:17:45.000Z" title="Sat Jan 03 2026 00:17:45 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0"><strong>Vite 5大实战优化技巧：让你的开发效率提升200%｜2025前端工程化指南</strong></h2>
<h2 data-id="heading-1">引言</h2>
<p>在前端工程化领域，构建工具的性能和开发体验直接影响团队的生产力。Vite 作为新一代前端构建工具，凭借其原生 ESM（ES Modules）支持和极速的热更新能力，已经成为现代前端开发的标杆。然而，许多开发者仅停留在基础使用层面，未能充分发挥 Vite 的潜力。</p>
<p>本文将深入剖析 Vite 的 <strong>5 大实战优化技巧</strong>，涵盖配置调优、依赖预构建、插件扩展、SSR 优化以及生产构建提速等方面。通过科学合理的优化手段，你的开发效率有望提升 <strong>200%</strong> 以上。无论你是个人开发者还是团队技术负责人，这些技巧都将为你的项目带来质的飞跃。</p>
<hr/>
<h2 data-id="heading-2">一、精准配置：从默认到极致</h2>
<h3 data-id="heading-3">1.1 按需启用 <code>optimizeDeps</code></h3>
<p>Vite 的依赖预构建（Dependency Pre-Bundling）是其核心优势之一，但默认配置可能无法满足所有场景需求。通过精细化配置 <code>optimizeDeps</code>，可以显著减少冷启动时间：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// vite.config.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">optimizeDeps</span>: {
    <span class="hljs-attr">include</span>: [<span class="hljs-string">'lodash-es'</span>, <span class="hljs-string">'axios'</span>], <span class="hljs-comment">// 强制预构建特定依赖</span>
    <span class="hljs-attr">exclude</span>: [<span class="hljs-string">'moment'</span>],            <span class="hljs-comment">// 排除已适配 ESM 的库</span>
    <span class="hljs-attr">needsInterop</span>: [<span class="hljs-string">'react-dom'</span>]     <span class="hljs-comment">// 标记需要 ESM 转换的 CJS 模块</span>
  }
}
</code></pre>
<p><strong>关键点</strong>：</p>
<ul>
<li><code>include</code>：避免动态导入导致的重复构建。</li>
<li><code>exclude</code>：跳过已支持 ESM 的库（如 <code>lodash-es</code>）。</li>
<li><code>needsInterop</code>：解决 CommonJS → ESM 的兼容性问题。</li>
</ul>
<h3 data-id="heading-4">1.2 Chunking Strategy：手动控制代码分割</h3>
<p>默认的文件分割策略可能导致冗余请求。通过 <code>rollupOptions.output.manualChunks</code> 自定义分割逻辑：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">build</span>: {
    <span class="hljs-attr">rollupOptions</span>: {
      <span class="hljs-attr">output</span>: {
        <span class="hljs-attr">manualChunks</span>: {
          <span class="hljs-attr">vendor</span>: [<span class="hljs-string">'react'</span>, <span class="hljs-string">'react-dom'</span>],
          <span class="hljs-attr">utils</span>: [<span class="hljs-string">'lodash-es'</span>, <span class="hljs-string">'date-fns'</span>]
        }
      }
    }
}
</code></pre>
<p>此配置可将高频依赖合并为独立 chunk，减少 HTTP/2 多路复用的压力。</p>
<hr/>
<h2 data-id="heading-5">二、依赖预构建的黑科技</h2>
<h3 data-id="heading-6">2.1 Cache Dir：跨项目共享缓存</h3>
<p>Vite默认将预构建结果存储在 <code>node_modules/.vite</code>，但可通过 <code>cacheDir</code>实现全局缓存共享：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
 <span class="hljs-attr">cacheDir</span>: <span class="hljs-string">'/path/to/global/cache'</span> 
}
</code></pre>
<p><strong>收益</strong>：多个项目共用同一份缓存文件，节省磁盘空间和构建时间。</p>
<h3 data-id="heading-7">2.2 Patch-Package修复第三方依赖</h3>
<p>部分老旧库（如 <code>[email protected]</code>）存在 ESM兼容性问题。推荐使用 <code>patch-package</code>打补丁：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># Step1:修改node_modules内的源码后运行:</span>
npx patch-package package-name

<span class="hljs-comment"># Step2:在package.json中注入hooks:</span>
<span class="hljs-string">"scripts"</span>: {
 <span class="hljs-string">"postinstall"</span>: <span class="hljs-string">"patch-package"</span>
}
</code></pre>
<hr/>
<h2 data-id="heading-8">三、插件系统深度定制</h2>
<h3 data-id="heading-9">3.1 Virtual Modules替代环境变量</h3>
<p>传统环境变量注入会导致频繁的全量重载。改用虚拟模块实现按需更新：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// vite-plugin-env.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"/>) {
 <span class="hljs-keyword">return</span> {
   <span class="hljs-attr">name</span>: <span class="hljs-string">'virtual-env'</span>,
   <span class="hljs-title function_">resolveId</span>(<span class="hljs-params">id</span>) {
     <span class="hljs-keyword">if</span> (id === <span class="hljs-string">'@env'</span>) <span class="hljs-keyword">return</span> id 
   },
   <span class="hljs-title function_">load</span>(<span class="hljs-params">id</span>) {
     <span class="hljs-keyword">if</span> (id === <span class="hljs-string">'@env'</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">`export const API_KEY = "<span class="hljs-subst">${process.env.API_KEY}</span>"`</span>
   }
 }
}
</code></pre>
<h3 data-id="heading-10">3.2 WASM加速方案对比</h3>























<table><thead><tr><th>WASM加载方式</th><th>HMR支持</th><th>SSR兼容性</th><th>Bundle大小</th></tr></thead><tbody><tr><td><code>?init</code>同步模式</td><td>❌</td><td>✅</td><td>⚠️较大</td></tr><tr><td>异步import()</td><td>✅</td><td>❌</td><td>✅最优</td></tr></tbody></table>
<p>推荐使用异步加载以获得最佳性能：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> init <span class="hljs-keyword">from</span> <span class="hljs-string">'./pkg/wasm_module_bg.wasm?init'</span>
<span class="hljs-keyword">const</span> { add } = <span class="hljs-keyword">await</span> <span class="hljs-title function_">init</span>()
</code></pre>
<hr/>
<h2 data-id="heading-11">四、SSR生产级优化手册</h2>
<h3 data-id="heading-12">4.1 Streaming + Islands架构实践</h3>
<p>结合React18的Suspense实现流式渲染与局部水合：</p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-comment">// server-entry.jsx</span>
<span class="hljs-keyword">import</span> { renderToPipeableStream } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom/server'</span>

<span class="hljs-keyword">const</span> stream = <span class="hljs-title function_">renderToPipeableStream</span>(
 <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>,
 { <span class="hljs-title function_">onShellReady</span>(<span class="hljs-params"/>) { <span class="hljs-title function_">pipe</span>(response) } }
)

<span class="hljs-comment">// client-entry.jsx </span>
<span class="hljs-keyword">import</span> { hydrateRoot } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom/client'</span>
<span class="hljs-title function_">hydrateRoot</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'app'</span>), <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>)
</code></pre>
<h3 data-id="heading-13">4.2 CSR Fallback兜底策略</h3>
<p>在负载过高时自动降级到CSR模式：</p>
<pre><code class="hljs language-nginx" lang="nginx">location / {
 proxy_pass http://node_server;
 error_page502= @csr_fallback;
}

location @csr_fallback{
 root /path/to/spa-dist;
 try_files$uri /index.html;
}
</code></pre>
<hr/>
<p>##五、生产构建终极提速</p>
<p>###5.1 SWC替代Babel<br/>
对于大型项目（10k+模块），切换到SWC编译可提速40%：</p>
<pre><code class="hljs language-javascript" lang="javascript">exportdefault{
 <span class="hljs-attr">esbuild</span>:{
 <span class="hljs-attr">loader</span>:<span class="hljs-string">'tsx'</span>,
 <span class="hljs-attr">target</span>:<span class="hljs-string">'es2020'</span>
 },
 <span class="hljs-comment">//禁用esbuild转译器以启用SWC </span>
 <span class="hljs-attr">transpileOnly</span>:<span class="hljs-literal">false</span>,
 <span class="hljs-attr">swcOptions</span>:{
 <span class="hljs-attr">jsc</span>:{
 <span class="hljs-attr">parser</span>:{
 <span class="hljs-attr">syntax</span>:<span class="hljs-string">'typescript'</span>
 },
 <span class="hljs-attr">transform</span>:{
 <span class="hljs-attr">react</span>:{
 <span class="hljs-attr">runtime</span>:<span class="hljs-string">'automatic'</span>
 }
 }
 }
 }
}
</code></pre>
<p>###5.2 Parallel Compression实战<br/>
启用多线程压缩（需Node≥18）：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span>{ compression }<span class="hljs-keyword">from</span><span class="hljs-string">'vite-plugin-compression2'</span>

exportdefault{
 <span class="hljs-attr">plugins</span>:[
 <span class="hljs-title function_">compression</span>({
 <span class="hljs-attr">algorithm</span>:<span class="hljs-string">'brotliCompress'</span>,
 <span class="hljs-attr">workers</span>:os.<span class="hljs-title function_">cpus</span>().<span class="hljs-property">length</span> -<span class="hljs-number">1</span> 
 })
 ]
}
</code></pre>
<hr/>
<p>##总结</p>
<p>通过对Vite工具的深度挖掘与技术方案的合理选型：</p>
<p>1️⃣ <strong>冷启动时间</strong>可从平均6s缩短至&lt;2s；<br/>
2️⃣ <strong>HMR更新延迟</strong>稳定控制在50ms以内；<br/>
3️⃣ <strong>生产构建速度</strong>相比Webpack提升300%；</p>
<p>2025年的前端工程化战场属于那些能将工具链价值榨取到极致的团队。建议读者按照本文给出的方向逐步验证效果并建立量化指标监控体系——毕竟没有度量就没有优化！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[MyBatis事务管理模块详解]]></title>    <link>https://juejin.cn/post/7590503651141222426</link>    <guid>https://juejin.cn/post/7590503651141222426</guid>    <pubDate>2026-01-03T00:40:33.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7590503651141222426" data-draft-id="7590021144779866158" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="MyBatis事务管理模块详解"/> <meta itemprop="keywords" content="MyBatis"/> <meta itemprop="datePublished" content="2026-01-03T00:40:33.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="雨中飘荡的记忆"/> <meta itemprop="url" content="https://juejin.cn/user/694547077666606"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            MyBatis事务管理模块详解
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/694547077666606/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    雨中飘荡的记忆
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-03T00:40:33.000Z" title="Sat Jan 03 2026 00:40:33 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读10分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>全面解析MyBatis事务管理机制，助你掌握数据一致性的核心技术</p>
</blockquote>
<h2 data-id="heading-0">一、MyBatis整体架构与事务管理模块</h2>
<p>在深入事务管理模块之前,我们先了解MyBatis的整体架构,以及事务管理模块在其中的重要地位。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f51cffd6fb4c4336b3b3c56b5cf00117~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuo5Lit6aOY6I2h55qE6K6w5b-G:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768005633&amp;x-signature=JV9t4JfVpr6gJf7v%2FN3nFbgcvcw%3D" alt="" loading="lazy"/></p>
<p>从上图可以看出,MyBatis采用了分层架构设计,而事务管理模块(Transaction)位于基础支撑层,是保证数据一致性的关键组件。</p>
<h2 data-id="heading-1">1.1 事务管理模块的核心职责</h2>
<p>事务管理模块主要承担以下核心职责：</p>
<pre><code class="hljs">✅ 管理数据库事务 - 控制事务的开始、提交和回滚
✅ 事务提交和回滚 - 根据操作结果决定提交或回滚事务
✅ 连接管理 - 获取和释放数据库连接
✅ 与不同框架集成 - 支持与Spring、Guice等框架的集成
✅ 隔离级别控制 - 支持不同的事务隔离级别
</code></pre>
<h2 data-id="heading-2">1.2 什么是事务</h2>
<p><strong>事务(Transaction)</strong> 是数据库操作的基本单元,包含一系列操作,这些操作<strong>要么全部成功,要么全部失败</strong>。</p>
<p>事务具有四个重要特性(ACID):</p>






























<table><thead><tr><th>特性</th><th>说明</th><th>示例场景</th></tr></thead><tbody><tr><td>原子性Atomicity</td><td>事务中的操作要么全部成功要么全部失败</td><td>转账：扣款和存款同时成功或同时失败</td></tr><tr><td>一致性Consistency</td><td>事务执行前后数据库状态保持一致</td><td>转账前后总金额不变</td></tr><tr><td>隔离性Isolation</td><td>并发事务之间相互隔离</td><td>一个事务看不到其他未提交事务的数据</td></tr><tr><td>持久性Durability</td><td>事务提交后数据永久保存</td><td>即使系统崩溃提交的数据也不会丢失</td></tr></tbody></table>
<h2 data-id="heading-3">二、Transaction接口架构</h2>
<p>MyBatis的事务管理模块采用了简洁的接口设计。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2b93720e41a2456499093ac255797bd2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuo5Lit6aOY6I2h55qE6K6w5b-G:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768005633&amp;x-signature=94uA8%2BZz%2FLp2lnalExAQOUOOvJM%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-4">2.1 Transaction接口</h2>
<p>Transaction是事务管理的<strong>顶层接口</strong>:</p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">Transaction</span> {
    <span class="hljs-comment">// 获取数据库连接</span>
    <span class="hljs-function">Connection <span class="hljs-title">getConnection</span>() throws SQLException</span>;

    <span class="hljs-comment">// 提交事务</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">commit</span>() throws SQLException</span>;

    <span class="hljs-comment">// 回滚事务</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rollback</span>() throws SQLException</span>;

    <span class="hljs-comment">// 关闭连接</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">close</span>() throws SQLException</span>;

    <span class="hljs-comment">// 获取事务超时时间</span>
    <span class="hljs-function">Integer <span class="hljs-title">getTimeout</span>() throws SQLException</span>;
}
</code></pre>
<h2 data-id="heading-5">2.2 Transaction实现类</h2>
<p>MyBatis提供了多种Transaction实现：</p>
<pre><code class="hljs language-scss" lang="scss">Transaction (接口)
  ├── JdbcTransaction (JDBC事务)
  ├── ManagedTransaction (托管事务)
  └── 自定义Transaction实现
</code></pre>
<p>JdbcTransaction是使用<strong>JDBC原生方式</strong>管理事务的实现：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JdbcTransaction</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Transaction</span> {
    <span class="hljs-keyword">protected</span> Connection connection;
    <span class="hljs-keyword">protected</span> DataSource dataSource;
    <span class="hljs-keyword">protected</span> TransactionIsolationLevel level;
    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> autoCommit;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">JdbcTransaction</span><span class="hljs-params">(DataSource ds, 
                          TransactionIsolationLevel desiredLevel, 
                          <span class="hljs-type">boolean</span> desiredAutoCommit)</span> {
        dataSource = ds;
        level = desiredLevel;
        autoCommit = desiredAutoCommit;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException {
        <span class="hljs-keyword">if</span> (connection == <span class="hljs-literal">null</span>) {
            openConnection();
        }
        <span class="hljs-keyword">return</span> connection;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">commit</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException {
        <span class="hljs-keyword">if</span> (connection != <span class="hljs-literal">null</span> &amp;&amp; !connection.getAutoCommit()) {
            connection.commit();
        }
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rollback</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException {
        <span class="hljs-keyword">if</span> (connection != <span class="hljs-literal">null</span> &amp;&amp; !connection.getAutoCommit()) {
            connection.rollback();
        }
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException {
        <span class="hljs-keyword">if</span> (connection != <span class="hljs-literal">null</span>) {
            connection.close();
            connection = <span class="hljs-literal">null</span>;
        }
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">openConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException {
        connection = dataSource.getConnection();
        <span class="hljs-keyword">if</span> (level != <span class="hljs-literal">null</span>) {
            connection.setTransactionIsolation(level.getLevel());
        }
        <span class="hljs-keyword">if</span> (autoCommit != <span class="hljs-literal">null</span> 
            &amp;&amp; autoCommit != connection.getAutoCommit()) {
            connection.setAutoCommit(autoCommit);
        }
    }
}
</code></pre>
<p>ManagedTransaction让<strong>容器来管理</strong>事务的生命周期：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ManagedTransaction</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Transaction</span> {
    <span class="hljs-keyword">private</span> DataSource dataSource;
    <span class="hljs-keyword">private</span> TransactionIsolationLevel level;
    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> closeConnection;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ManagedTransaction</span><span class="hljs-params">(DataSource ds, 
                             TransactionIsolationLevel level, 
                             <span class="hljs-type">boolean</span> closeConnection)</span> {
        <span class="hljs-built_in">this</span>.dataSource = ds;
        <span class="hljs-built_in">this</span>.level = level;
        <span class="hljs-built_in">this</span>.closeConnection = closeConnection;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException {
        <span class="hljs-keyword">if</span> (connection == <span class="hljs-literal">null</span>) {
            openConnection();
        }
        <span class="hljs-keyword">return</span> connection;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">commit</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException {
        <span class="hljs-comment">// 不做任何事，由容器管理提交</span>
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rollback</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException {
        <span class="hljs-comment">// 不做任何事，由容器管理回滚</span>
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException {
        <span class="hljs-keyword">if</span> (closeConnection &amp;&amp; connection != <span class="hljs-literal">null</span>) {
            connection.close();
            connection = <span class="hljs-literal">null</span>;
        }
    }
}
</code></pre>
<h2 data-id="heading-6">三、事务管理流程</h2>
<p>完整的事务管理流程是确保数据一致性的关键。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/88043f1eb1954c0aa444d887b77c8e91~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuo5Lit6aOY6I2h55qE6K6w5b-G:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768005633&amp;x-signature=HG3Tu1H0iREvZBlYbz%2BvtIoBvlc%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-7">3.1 事务生命周期</h2>
<p>一个完整的事务生命周期包括以下阶段：</p>
<pre><code class="hljs language-ini" lang="ini">// 1. 开启事务
SqlSession <span class="hljs-attr">session</span> = sqlSessionFactory.openSession()<span class="hljs-comment">;</span>

try {
    // 2. 执行数据库操作
    User <span class="hljs-attr">user</span> = new User(<span class="hljs-string">"张三"</span>, <span class="hljs-string">"zhangsan@example.com"</span>)<span class="hljs-comment">;</span>
    userMapper.insert(user)<span class="hljs-comment">;</span>

    Order <span class="hljs-attr">order</span> = new Order(user.getId(), <span class="hljs-string">"iPhone 15"</span>, <span class="hljs-number">6999</span>)<span class="hljs-comment">;</span>
    orderMapper.insert(order)<span class="hljs-comment">;</span>

    // 3. 提交事务
    session.commit()<span class="hljs-comment">;</span>
} catch (Exception e) {
    // 4. 回滚事务
    session.rollback()<span class="hljs-comment">;</span>
    throw e<span class="hljs-comment">;</span>
} finally {
    // 5. 关闭会话
    session.close()<span class="hljs-comment">;</span>
}
</code></pre>
<h2 data-id="heading-8">3.2 自动提交与手动提交</h2>
<p>MyBatis支持两种事务提交模式：</p>
<pre><code class="hljs language-ini" lang="ini">// 自动提交模式：每条SQL自动提交
SqlSession <span class="hljs-attr">session</span> = sqlSessionFactory.openSession(<span class="hljs-literal">true</span>)<span class="hljs-comment">;</span>
try {
    User <span class="hljs-attr">user</span> = new User(<span class="hljs-string">"张三"</span>, <span class="hljs-string">"zhangsan@example.com"</span>)<span class="hljs-comment">;</span>
    userMapper.insert(user)<span class="hljs-comment">;</span>
    // 无需手动提交，自动提交
} finally {
    session.close()<span class="hljs-comment">;</span>
}
// 手动提交模式：需要显式提交
SqlSession <span class="hljs-attr">session</span> = sqlSessionFactory.openSession(<span class="hljs-literal">false</span>)<span class="hljs-comment">;</span>
try {
    User <span class="hljs-attr">user</span> = new User(<span class="hljs-string">"张三"</span>, <span class="hljs-string">"zhangsan@example.com"</span>)<span class="hljs-comment">;</span>
    userMapper.insert(user)<span class="hljs-comment">;</span>

    Order <span class="hljs-attr">order</span> = new Order(user.getId(), <span class="hljs-string">"iPhone 15"</span>, <span class="hljs-number">6999</span>)<span class="hljs-comment">;</span>
    orderMapper.insert(order)<span class="hljs-comment">;</span>

    // 多条SQL在同一事务中
    session.commit()<span class="hljs-comment">; // 显式提交</span>
} catch (Exception e) {
    session.rollback()<span class="hljs-comment">; // 显式回滚</span>
    throw e<span class="hljs-comment">;</span>
} finally {
    session.close()<span class="hljs-comment">;</span>
}
</code></pre>
<h2 data-id="heading-9">3.3 Executor中的事务管理</h2>
<p>Executor在执行SQL时会涉及到事务管理：</p>
<pre><code class="hljs language-scss" lang="scss">public abstract class BaseExecutor implements Executor {
    private Transaction transaction;

    <span class="hljs-keyword">@Override</span>
    public int <span class="hljs-attribute">update</span>(MappedStatement ms, Object parameter) 
            throws SQLException {
        ErrorContext<span class="hljs-selector-class">.instance</span>()<span class="hljs-selector-class">.begin</span>(ms.getId(), 
            ms<span class="hljs-selector-class">.getSqlSource</span>()<span class="hljs-selector-class">.getBoundSql</span>(parameter));
        try {
            <span class="hljs-comment">// 清空一级缓存</span>
            <span class="hljs-built_in">clearLocalCache</span>();

            <span class="hljs-comment">// 执行更新操作</span>
            return <span class="hljs-built_in">doUpdate</span>(ms, parameter);
        } catch (SQLException e) {
            throw ExceptionFactory<span class="hljs-selector-class">.wrapException</span>(
                "Error updating database. Cause: " + e, e);
        } finally {
            ErrorContext<span class="hljs-selector-class">.instance</span>()<span class="hljs-selector-class">.end</span>();
        }
    }

    <span class="hljs-keyword">@Override</span>
    public void commit(boolean required) throws SQLException {
        if (closed) {
            throw new <span class="hljs-built_in">ExecutorException</span>(
                "Cannot commit, transaction is already closed");
        }

        <span class="hljs-comment">// 清空一级缓存</span>
        <span class="hljs-built_in">clearLocalCache</span>();

        <span class="hljs-comment">// 刷新批处理</span>
        <span class="hljs-built_in">flushStatements</span>();

        <span class="hljs-comment">// 提交事务</span>
        if (required) {
            transaction<span class="hljs-selector-class">.commit</span>();
        }
    }

    <span class="hljs-keyword">@Override</span>
    public void rollback(boolean required) throws SQLException {
        if (closed) {
            throw new <span class="hljs-built_in">ExecutorException</span>(
                "Cannot rollback, transaction is already closed");
        }

        <span class="hljs-comment">// 清空一级缓存</span>
        <span class="hljs-built_in">clearLocalCache</span>();

        <span class="hljs-comment">// 刷新批处理</span>
        <span class="hljs-built_in">flushStatements</span>(true);

        <span class="hljs-comment">// 回滚事务</span>
        if (required) {
            transaction<span class="hljs-selector-class">.rollback</span>();
        }
    }
}
</code></pre>
<h2 data-id="heading-10">四、事务提交和回滚机制</h2>
<p>事务的提交和回滚是保证数据一致性的核心机制。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/78544a13f1134e4da78dd202dce2cbef~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuo5Lit6aOY6I2h55qE6K6w5b-G:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768005633&amp;x-signature=ME4kkWLpcZp0n5uHO1Nl2PWwI58%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-11">4.1 事务提交流程</h2>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// SqlSession中的提交实现</span>
<span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">commit</span><span class="hljs-params">()</span> {
    <span class="hljs-type">boolean</span> <span class="hljs-variable">commit</span> <span class="hljs-operator">=</span> required;
    <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">// 执行所有挂起的SQL语句</span>
        flushStatements();

        <span class="hljs-keyword">if</span> (commit) {
            <span class="hljs-comment">// 委托给Executor提交</span>
            executor.commit(isCommitOrRollbackRequired(<span class="hljs-literal">false</span>));
        }
    } <span class="hljs-keyword">catch</span> (Exception e) {
        <span class="hljs-keyword">throw</span> ExceptionFactory.wrapException(
            <span class="hljs-string">"Error committing transaction. Cause: "</span> + e, e);
    }
}

<span class="hljs-comment">// Executor中的提交实现</span>
<span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">commit</span><span class="hljs-params">(<span class="hljs-type">boolean</span> required)</span> <span class="hljs-keyword">throws</span> SQLException {
    <span class="hljs-keyword">if</span> (closed) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExecutorException</span>(
            <span class="hljs-string">"Cannot commit, transaction is already closed"</span>);
    }

    <span class="hljs-keyword">if</span> (required) {
        <span class="hljs-comment">// 清空一级缓存</span>
        clearLocalCache();

        <span class="hljs-comment">// 刷新批处理</span>
        flushStatements();

        <span class="hljs-comment">// 提交数据库事务</span>
        transaction.commit();
    }
}
</code></pre>
<h2 data-id="heading-12">4.2 事务回滚流程</h2>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// SqlSession中的回滚实现</span>
<span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rollback</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">// 执行所有挂起的SQL语句</span>
        flushStatements(<span class="hljs-literal">true</span>);

        <span class="hljs-comment">// 委托给Executor回滚</span>
        executor.rollback(isCommitOrRollbackRequired(<span class="hljs-literal">true</span>));
    } <span class="hljs-keyword">catch</span> (Exception e) {
        <span class="hljs-keyword">throw</span> ExceptionFactory.wrapException(
            <span class="hljs-string">"Error rolling back transaction. Cause: "</span> + e, e);
    }
}

<span class="hljs-comment">// Executor中的回滚实现</span>
<span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rollback</span><span class="hljs-params">(<span class="hljs-type">boolean</span> required)</span> <span class="hljs-keyword">throws</span> SQLException {
    <span class="hljs-keyword">if</span> (closed) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExecutorException</span>(
            <span class="hljs-string">"Cannot rollback, transaction is already closed"</span>);
    }

    <span class="hljs-keyword">if</span> (required) {
        <span class="hljs-comment">// 清空一级缓存</span>
        clearLocalCache();

        <span class="hljs-comment">// 刷新批处理</span>
        flushStatements(<span class="hljs-literal">true</span>);

        <span class="hljs-comment">// 回滚数据库事务</span>
        transaction.rollback();
    }
}
</code></pre>
<h2 data-id="heading-13">4.3 回滚触发条件</h2>
<p>以下情况会触发事务回滚：</p>
<pre><code class="hljs language-ini" lang="ini">try {
    userMapper.insert(user)<span class="hljs-comment">;</span>
    orderMapper.insert(order)<span class="hljs-comment">;</span>
    session.commit()<span class="hljs-comment">;</span>
} catch (Exception e) {
    session.rollback()<span class="hljs-comment">;</span>
    throw e<span class="hljs-comment">;</span>
}
if (!isValid(order)) {
    session.rollback()<span class="hljs-comment">;</span>
    return<span class="hljs-comment">;</span>
}
session.commit()<span class="hljs-comment">;</span>
SqlSession <span class="hljs-attr">session</span> = sqlSessionFactory.openSession(
    ExecutorType.BATCH)<span class="hljs-comment">;</span>
try {
    List&lt;User&gt; <span class="hljs-attr">users</span> = getBatchUsers()<span class="hljs-comment">;</span>
    for (User user : users) {
        userMapper.insert(user)<span class="hljs-comment">;</span>
    }
    session.commit()<span class="hljs-comment">;</span>
} catch (Exception e) {
    session.rollback()<span class="hljs-comment">;</span>
    throw e<span class="hljs-comment">;</span>
} finally {
    session.close()<span class="hljs-comment">;</span>
}
</code></pre>
<h2 data-id="heading-14">4.4 事务隔离级别</h2>
<p>MyBatis支持标准的JDBC事务隔离级别：</p>
<pre><code class="hljs language-scss" lang="scss">public enum IsolationLevel {
    <span class="hljs-attribute">NONE</span>(Connection.TRANSACTION_NONE),
    <span class="hljs-built_in">READ_COMMITTED</span>(Connection.TRANSACTION_READ_COMMITTED),
    <span class="hljs-built_in">READ_UNCOMMITTED</span>(Connection.TRANSACTION_READ_UNCOMMITTED),
    <span class="hljs-built_in">REPEATABLE_READ</span>(Connection.TRANSACTION_REPEATABLE_READ),
    <span class="hljs-built_in">SERIALIZABLE</span>(Connection.TRANSACTION_SERIALIZABLE);

    public int <span class="hljs-built_in">getLevel</span>() {
        return level;
    }
}
</code></pre>
<p>配置方式：</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-comment">&lt;!-- 在mybatis-config.xml中配置 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"defaultTransactionIsolationLevel"</span> 
             <span class="hljs-attr">value</span>=<span class="hljs-string">"READ_COMMITTED"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 在DataSource中配置 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"POOLED"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"driver"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"${driver}"</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"url"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"${url}"</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"${username}"</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"${password}"</span>/&gt;</span>
    <span class="hljs-comment">&lt;!-- 设置默认隔离级别 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"defaultTransactionIsolationLevel"</span> 
              <span class="hljs-attr">value</span>=<span class="hljs-string">"2"</span>/&gt;</span> <span class="hljs-comment">&lt;!-- READ_COMMITTED --&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span>
</code></pre>
<h2 data-id="heading-15">五、与Spring框架集成</h2>
<p>在实际项目中,MyBatis通常与Spring集成,由Spring统一管理事务。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8a723c4cc44d4275b56e7742e41ff8e2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuo5Lit6aOY6I2h55qE6K6w5b-G:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768005633&amp;x-signature=rtIcddWP9rgg3zVHG5Rpo3lh2NA%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-16">5.1 Spring事务配置</h2>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-comment">&lt;!-- 配置事务管理器 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"transactionManager"</span> 
      <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"dataSource"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"dataSource"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 配置事务通知 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">tx:advice</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"txAdvice"</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">"transactionManager"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">tx:attributes</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"select*"</span> <span class="hljs-attr">read-only</span>=<span class="hljs-string">"true"</span>/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"get*"</span> <span class="hljs-attr">read-only</span>=<span class="hljs-string">"true"</span>/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"query*"</span> <span class="hljs-attr">read-only</span>=<span class="hljs-string">"true"</span>/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"*"</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">"REQUIRED"</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">tx:attributes</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">tx:advice</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 配置事务切面 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"servicePointcut"</span> 
                  <span class="hljs-attr">expression</span>=<span class="hljs-string">"execution(* com.example.service.*.*(..))"</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span> <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">"txAdvice"</span> 
                 <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">"servicePointcut"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span>
@Configuration
@EnableTransactionManagement
public class MyBatisConfig {

    @Bean
    public DataSourceTransactionManager transactionManager(
            DataSource dataSource) {
        return new DataSourceTransactionManager(dataSource);
    }

    @Bean
    public SqlSessionFactoryBean sqlSessionFactory(
            DataSource dataSource) throws Exception {
        SqlSessionFactoryBean sessionFactory = 
            new SqlSessionFactoryBean();
        sessionFactory.setDataSource(dataSource);
        sessionFactory.setMapperLocations(
            new PathMatchingResourcePatternResolver()
                .getResources("classpath:mapper/*.xml"));
        return sessionFactory;
    }

    @Bean
    public MapperScannerConfigurer mapperScannerConfigurer() {
        MapperScannerConfigurer scanner = 
            new MapperScannerConfigurer();
        scanner.setBasePackage("com.example.mapper");
        return scanner;
    }
}
</code></pre>
<h2 data-id="heading-17">5.2 使用@Transactional注解</h2>
<p>在Service层使用@Transactional注解：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> {

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> <span class="hljs-title class_">UserMapper</span> userMapper;

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> <span class="hljs-title class_">OrderMapper</span> orderMapper;

    <span class="hljs-comment">// 默认事务管理</span>
    <span class="hljs-meta">@Transactional</span>
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">createUserWithOrder</span>(<span class="hljs-params">User user, Order order</span>) {
        userMapper.<span class="hljs-title function_">insert</span>(user);
        orderMapper.<span class="hljs-title function_">insert</span>(order);
    }

    <span class="hljs-comment">// 只读事务</span>
    <span class="hljs-meta">@Transactional</span>(readOnly = <span class="hljs-literal">true</span>)
    <span class="hljs-keyword">public</span> <span class="hljs-title class_">User</span> <span class="hljs-title function_">getUserById</span>(<span class="hljs-params">Long id</span>) {
        <span class="hljs-keyword">return</span> userMapper.<span class="hljs-title function_">selectById</span>(id);
    }

    <span class="hljs-comment">// 指定隔离级别</span>
    <span class="hljs-meta">@Transactional</span>(isolation = <span class="hljs-title class_">Isolation</span>.<span class="hljs-property">READ_COMMITTED</span>)
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">updateUser</span>(<span class="hljs-params">User user</span>) {
        userMapper.<span class="hljs-title function_">update</span>(user);
    }

    <span class="hljs-comment">// 指定传播行为</span>
    <span class="hljs-meta">@Transactional</span>(propagation = <span class="hljs-title class_">Propagation</span>.<span class="hljs-property">REQUIRES_NEW</span>)
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">logOperation</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> operation</span>) {
        <span class="hljs-comment">// 在新事务中执行</span>
    }

    <span class="hljs-comment">// 指定回滚异常</span>
    <span class="hljs-meta">@Transactional</span>(rollbackFor = {<span class="hljs-title class_">Exception</span>.<span class="hljs-property">class</span>})
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">transfer</span>(<span class="hljs-params">Long fromId, Long toId, BigDecimal amount</span>) {
        userMapper.<span class="hljs-title function_">decrease</span>(fromId, amount);
        userMapper.<span class="hljs-title function_">increase</span>(toId, amount);
    }

    <span class="hljs-comment">// 不回滚特定异常</span>
    <span class="hljs-meta">@Transactional</span>(noRollbackFor = {<span class="hljs-title class_">BusinessException</span>.<span class="hljs-property">class</span>})
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">processWithBusinessException</span>(<span class="hljs-params"/>) {
        <span class="hljs-comment">// ...</span>
    }

    <span class="hljs-comment">// 超时设置</span>
    <span class="hljs-meta">@Transactional</span>(timeout = <span class="hljs-number">30</span>)
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">longRunningOperation</span>(<span class="hljs-params"/>) {
        <span class="hljs-comment">// ...</span>
    }
}
</code></pre>
<h2 data-id="heading-18">5.3 Spring事务传播行为</h2>
<p>Spring支持多种事务传播行为：</p>













































<table><thead><tr><th>传播行为</th><th>说明</th><th>使用场景</th></tr></thead><tbody><tr><td>REQUIRED(默认)</td><td>如果当前存在事务,则加入否则创建新事务</td><td>大多数情况</td></tr><tr><td>REQUIRES_NEW</td><td>总是创建新事务挂起当前事务</td><td>日志记录审计</td></tr><tr><td>SUPPORTS</td><td>如果当前存在事务,则加入否则非事务执行</td><td>查询操作</td></tr><tr><td>NOT_SUPPORTED</td><td>总是非事务执行挂起当前事务</td><td>批量导入</td></tr><tr><td>NEVER</td><td>总是非事务执行如果存在事务则抛异常</td><td>不需要事务的操作</td></tr><tr><td>MANDATORY</td><td>必须在事务中执行否则抛异常</td><td>必须有事务的操作</td></tr><tr><td>NESTED</td><td>如果当前存在事务则嵌套执行</td><td>嵌套业务逻辑</td></tr></tbody></table>
<h2 data-id="heading-19">5.4 集成示例</h2>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderService</span> {

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> UserService userService;

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> OrderService orderService;

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> PaymentService paymentService;

    <span class="hljs-comment">// 主流程：使用REQUIRED传播</span>
    <span class="hljs-meta">@Transactional(propagation = Propagation.REQUIRED)</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createOrder</span><span class="hljs-params">(Order order)</span> {
        <span class="hljs-comment">// 1. 创建用户（加入当前事务）</span>
        userService.updateUserBalance(
            order.getUserId(), 
            order.getAmount().negate());

        <span class="hljs-comment">// 2. 创建订单（加入当前事务）</span>
        orderMapper.insert(order);

        <span class="hljs-comment">// 3. 支付（加入当前事务）</span>
        paymentService.processPayment(order);

        <span class="hljs-comment">// 事务提交</span>
    }

    <span class="hljs-comment">// 支付服务：REQUIRES_NEW，独立事务</span>
    <span class="hljs-meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processPayment</span><span class="hljs-params">(Order order)</span> {
        <span class="hljs-comment">// 在新事务中执行</span>
        paymentMapper.insert(order);
    }

    <span class="hljs-comment">// 异常处理：自动回滚</span>
    <span class="hljs-meta">@Transactional(rollbackFor = Exception.class)</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(Long fromId, Long toId, 
                        BigDecimal amount)</span> {
        <span class="hljs-keyword">try</span> {
            userService.decrease(fromId, amount);
            userService.increase(toId, amount);
            <span class="hljs-comment">// 成功：自动提交</span>
        } <span class="hljs-keyword">catch</span> (Exception e) {
            <span class="hljs-comment">// 失败：自动回滚</span>
            <span class="hljs-keyword">throw</span> e;
        }
    }
}
</code></pre>
<h2 data-id="heading-20">六、事务传播机制</h2>
<p>事务传播定义了事务方法被调用时事务边界的行为。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d4624412659e4e16b76d7db137b46ae6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuo5Lit6aOY6I2h55qE6K6w5b-G:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768005633&amp;x-signature=OCANyrEM0ryl28nch8dVKULCiF0%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-21">6.1 传播行为详解</h2>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-meta">@Transactional</span>(propagation = <span class="hljs-title class_">Propagation</span>.<span class="hljs-property">REQUIRED</span>)
<span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">methodA</span>(<span class="hljs-params"/>) {
    <span class="hljs-title function_">methodB</span>();  <span class="hljs-comment">// 加入methodA的事务</span>
}

<span class="hljs-meta">@Transactional</span>(propagation = <span class="hljs-title class_">Propagation</span>.<span class="hljs-property">REQUIRED</span>)
<span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">methodB</span>(<span class="hljs-params"/>) {
    <span class="hljs-comment">// ...</span>
}
<span class="hljs-meta">@Transactional</span>(propagation = <span class="hljs-title class_">Propagation</span>.<span class="hljs-property">REQUIRED</span>)
<span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">methodA</span>(<span class="hljs-params"/>) {
    <span class="hljs-title function_">methodB</span>();  <span class="hljs-comment">// methodB在新事务中执行</span>
    <span class="hljs-comment">// methodA的事务被挂起</span>
}

<span class="hljs-meta">@Transactional</span>(propagation = <span class="hljs-title class_">Propagation</span>.<span class="hljs-property">REQUIRES_NEW</span>)
<span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">methodB</span>(<span class="hljs-params"/>) {
    <span class="hljs-comment">// 在独立事务中执行</span>
}
<span class="hljs-meta">@Transactional</span>(propagation = <span class="hljs-title class_">Propagation</span>.<span class="hljs-property">REQUIRED</span>)
<span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">methodA</span>(<span class="hljs-params"/>) {
    <span class="hljs-title function_">methodB</span>();  <span class="hljs-comment">// methodB在嵌套事务中执行</span>
    <span class="hljs-comment">// 如果methodB失败，只回滚methodB</span>
}

<span class="hljs-meta">@Transactional</span>(propagation = <span class="hljs-title class_">Propagation</span>.<span class="hljs-property">NESTED</span>)
<span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">methodB</span>(<span class="hljs-params"/>) {
    <span class="hljs-comment">// 在嵌套事务中执行</span>
}
<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TransactionalService</span> {

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> <span class="hljs-title class_">LogService</span> logService;

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> <span class="hljs-title class_">DataService</span> dataService;

    <span class="hljs-comment">// 主事务</span>
    <span class="hljs-meta">@Transactional</span>(propagation = <span class="hljs-title class_">Propagation</span>.<span class="hljs-property">REQUIRED</span>)
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">businessOperation</span>(<span class="hljs-params"/>) {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 1. 业务操作（主事务）</span>
            dataService.<span class="hljs-title function_">insertData</span>(<span class="hljs-string">"业务数据"</span>);

            <span class="hljs-comment">// 2. 记录日志（独立事务）</span>
            logService.<span class="hljs-title function_">saveLog</span>(<span class="hljs-string">"操作日志"</span>);

            <span class="hljs-comment">// 3. 发送通知（独立事务）</span>
            logService.<span class="hljs-title function_">sendNotification</span>(<span class="hljs-string">"操作通知"</span>);

        } <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">Exception</span> e) {
            <span class="hljs-comment">// 业务失败，主事务回滚</span>
            <span class="hljs-comment">// 但日志记录和通知不会回滚</span>
            <span class="hljs-comment">// （因为使用了REQUIRES_NEW）</span>
            <span class="hljs-keyword">throw</span> e;
        }
    }
}

<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogService</span> {

    <span class="hljs-comment">// 独立事务记录日志</span>
    <span class="hljs-meta">@Transactional</span>(propagation = <span class="hljs-title class_">Propagation</span>.<span class="hljs-property">REQUIRES_NEW</span>)
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">saveLog</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> message</span>) {
        <span class="hljs-comment">// 在新事务中执行</span>
        <span class="hljs-comment">// 无论主事务成功或失败，日志都会被记录</span>
        logMapper.<span class="hljs-title function_">insert</span>(message);
    }

    <span class="hljs-comment">// 独立事务发送通知</span>
    <span class="hljs-meta">@Transactional</span>(propagation = <span class="hljs-title class_">Propagation</span>.<span class="hljs-property">REQUIRES_NEW</span>)
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">sendNotification</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> message</span>) {
        <span class="hljs-comment">// 在新事务中执行</span>
        notificationMapper.<span class="hljs-title function_">insert</span>(message);
    }
}
<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IsolationLevelService</span> {

    <span class="hljs-comment">// 读已提交：允许不可重复读</span>
    <span class="hljs-meta">@Transactional</span>(isolation = <span class="hljs-title class_">Isolation</span>.<span class="hljs-property">READ_COMMITTED</span>)
    <span class="hljs-keyword">public</span> <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">User</span>&gt; <span class="hljs-title function_">listUsers</span>(<span class="hljs-params"/>) {
        <span class="hljs-keyword">return</span> userMapper.<span class="hljs-title function_">selectAll</span>();
    }

    <span class="hljs-comment">// 可重复读：防止不可重复读和幻读</span>
    <span class="hljs-meta">@Transactional</span>(isolation = <span class="hljs-title class_">Isolation</span>.<span class="hljs-property">REPEATABLE_READ</span>)
    <span class="hljs-keyword">public</span> <span class="hljs-title class_">User</span> <span class="hljs-title function_">getUserWithLock</span>(<span class="hljs-params">Long id</span>) {
        <span class="hljs-keyword">return</span> userMapper.<span class="hljs-title function_">selectByIdForUpdate</span>(id);
    }

    <span class="hljs-comment">// 串行化：最高隔离级别</span>
    <span class="hljs-meta">@Transactional</span>(isolation = <span class="hljs-title class_">Isolation</span>.<span class="hljs-property">SERIALIZABLE</span>)
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">criticalOperation</span>(<span class="hljs-params"/>) {
        <span class="hljs-comment">// 串行执行，完全隔离</span>
    }
}
</code></pre>
<h2 data-id="heading-22">七、最佳实践</h2>
<p>事务传播定义了事务方法被调用时事务边界的行为。</p>
<h2 data-id="heading-23">7.1 事务边界划分</h2>
<pre><code class="hljs language-java" lang="java">✅ 事务范围要小 - 事务尽可能短，减少锁竞争
✅ 事务放在Service层 - 不在DAO层管理事务
✅ 避免长事务 - 不要在事务中进行RPC、HTTP等外部调用
✅ 明确事务边界 - 使用<span class="hljs-meta">@Transactional</span>清晰标注事务范围要小 - 事务尽可能短，减少锁竞争
✅ 事务放在Service层 - 不在DAO层管理事务
✅ 避免长事务 - 不要在事务中进行RPC、HTTP等外部调用
✅ 明确事务边界 - 使用<span class="hljs-meta">@Transactional</span>清晰标注
</code></pre>
<h2 data-id="heading-24">7.2 性能优化建议</h2>
<pre><code class="hljs language-ini" lang="ini">1️⃣ 选择合适的隔离级别 - READ_COMMITTED通常足够
2️⃣ 避免事务中的外部调用 - 如网络请求、文件操作
3️⃣ 批量操作使用BatchExecutor - 提升批量操作性能
4️⃣ 合理使用只读事务 - 查询操作使用<span class="hljs-attr">readOnly</span>=<span class="hljs-literal">true</span>
</code></pre>
<h2 data-id="heading-25">7.3 常见问题解决</h2>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 问题：异常被捕获，事务未回滚</span>
<span class="hljs-meta">@Transactional</span>
<span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">process</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">// 业务代码</span>
    } <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">Exception</span> e) {
        e.<span class="hljs-title function_">printStackTrace</span>(); <span class="hljs-comment">// 捕获异常，事务不回滚</span>
    }
}

<span class="hljs-comment">//解决：要么抛出异常，要么手动回滚</span>
<span class="hljs-meta">@Transactional</span>(rollbackFor = <span class="hljs-title class_">Exception</span>.<span class="hljs-property">class</span>)
<span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">process</span>(<span class="hljs-params"/>) {
    <span class="hljs-comment">// 业务代码</span>
}
<span class="hljs-comment">// 查询方法使用只读事务</span>
<span class="hljs-meta">@Transactional</span>(readOnly = <span class="hljs-literal">true</span>)
<span class="hljs-keyword">public</span> <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">User</span>&gt; <span class="hljs-title function_">listUsers</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> userMapper.<span class="hljs-title function_">selectAll</span>();
}

<span class="hljs-comment">//好处：</span>
<span class="hljs-comment">//告诉数据库这是只读操作</span>
<span class="hljs-comment">//数据库可以进行优化</span>
<span class="hljs-comment">//减少锁竞争</span>
<span class="hljs-comment">// 设置事务超时时间（单位：秒）</span>
<span class="hljs-meta">@Transactional</span>(timeout = <span class="hljs-number">30</span>)
<span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">longRunningOperation</span>(<span class="hljs-params"/>) {
    <span class="hljs-comment">// 如果方法执行超过30秒，事务自动回滚</span>
}
</code></pre>
<p>MyBatis的事务管理模块提供了<strong>灵活而强大</strong>的事务控制能力。</p>
<pre><code class="hljs">1️⃣ Transaction接口 - 定义事务的基本操作
2️⃣ JdbcTransaction - 使用JDBC原生方式管理事务
3️⃣ ManagedTransaction - 由容器管理事务生命周期
4️⃣ 事务提交和回滚 - 根据操作结果决定提交或回滚
5️⃣ 框架集成 - 与Spring等框架无缝集成
</code></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Hibernate（19）什么是Hibernate的急加载？]]></title>    <link>https://juejin.cn/post/7590020026395443254</link>    <guid>https://juejin.cn/post/7590020026395443254</guid>    <pubDate>2026-01-02T23:58:16.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7590020026395443254" data-draft-id="7589940210832392235" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Hibernate（19）什么是Hibernate的急加载？"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-01-02T23:58:16.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Victor356"/> <meta itemprop="url" content="https://juejin.cn/user/3492507879476878"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Hibernate（19）什么是Hibernate的急加载？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3492507879476878/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Victor356
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-02T23:58:16.000Z" title="Fri Jan 02 2026 23:58:16 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-02
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>Hibernate的急加载（Eager Loading）是一种数据加载策略，即在加载实体时立即加载其关联实体。这种方式通过一次查询获取所有相关联的数据，避免在后续访问关联数据时重复查询数据库。急加载通常用于需要频繁访问关联数据的场景，从而提高查询效率和减少数据库访问次数。</p>
<h3 data-id="heading-0">急加载的实现</h3>
<p>在Hibernate中，急加载通过在关联关系上指定<code>FetchType.EAGER</code>来实现。常用于<code>@OneToMany</code>、<code>@ManyToOne</code>、<code>@OneToOne</code>、<code>@ManyToMany</code>等关联关系。</p>
<h3 data-id="heading-1">示例代码</h3>
<p>下面是一个完整的示例，展示如何在Hibernate中使用急加载。</p>
<h4 data-id="heading-2">配置文件 <code>hibernate.cfg.xml</code></h4>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">hibernate-configuration</span> <span class="hljs-keyword">PUBLIC</span>
        <span class="hljs-string">"-//Hibernate/Hibernate Configuration DTD 3.0//EN"</span>
        <span class="hljs-string">"http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">hibernate-configuration</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">session-factory</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- 数据库连接配置 --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.connection.driver_class"</span>&gt;</span>com.mysql.cj.jdbc.Driver<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.connection.url"</span>&gt;</span>jdbc:mysql://localhost:3306/your_database<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.connection.username"</span>&gt;</span>your_username<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.connection.password"</span>&gt;</span>your_password<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>

        <span class="hljs-comment">&lt;!-- Hibernate 属性配置 --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.dialect"</span>&gt;</span>org.hibernate.dialect.MySQLDialect<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.show_sql"</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.format_sql"</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.hbm2ddl.auto"</span>&gt;</span>update<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>

        <span class="hljs-comment">&lt;!-- 映射类配置 --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">mapping</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.example.domain.Student"</span>/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">mapping</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.example.domain.Course"</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">session-factory</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">hibernate-configuration</span>&gt;</span>
</code></pre>
<h4 data-id="heading-3">HibernateUtil 类</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">import</span> org.hibernate.SessionFactory;
<span class="hljs-keyword">import</span> org.hibernate.cfg.Configuration;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HibernateUtil</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> SessionFactory sessionFactory;

    <span class="hljs-keyword">static</span> {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 从配置文件创建SessionFactory</span>
            sessionFactory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Configuration</span>().configure(<span class="hljs-string">"hibernate.cfg.xml"</span>).buildSessionFactory();
        } <span class="hljs-keyword">catch</span> (Throwable ex) {
            <span class="hljs-comment">// 记录启动失败的错误</span>
            System.err.println(<span class="hljs-string">"Initial SessionFactory creation failed."</span> + ex);
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExceptionInInitializerError</span>(ex);
        }
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SessionFactory <span class="hljs-title function_">getSessionFactory</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> sessionFactory;
    }
}
</code></pre>
<h4 data-id="heading-4">实体类 Student 和 Course</h4>
<h5 data-id="heading-5">Student 类</h5>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.example.domain;

<span class="hljs-keyword">import</span> javax.persistence.*;
<span class="hljs-keyword">import</span> java.util.HashSet;
<span class="hljs-keyword">import</span> java.util.Set;

<span class="hljs-meta">@Entity</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> {
    <span class="hljs-meta">@Id</span>
    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span>
    <span class="hljs-keyword">private</span> Long id;
    
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;

    <span class="hljs-meta">@OneToMany(mappedBy = "student", fetch = FetchType.EAGER, cascade = CascadeType.ALL)</span>
    <span class="hljs-keyword">private</span> Set&lt;Course&gt; courses = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> {}

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> {
        <span class="hljs-built_in">this</span>.name = name;
        <span class="hljs-built_in">this</span>.age = age;
    }

    <span class="hljs-comment">// getters 和 setters</span>
    <span class="hljs-keyword">public</span> Long <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> id;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(Long id)</span> {
        <span class="hljs-built_in">this</span>.id = id;
    }

    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> name;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> {
        <span class="hljs-built_in">this</span>.name = name;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> age;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> {
        <span class="hljs-built_in">this</span>.age = age;
    }

    <span class="hljs-keyword">public</span> Set&lt;Course&gt; <span class="hljs-title function_">getCourses</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> courses;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCourses</span><span class="hljs-params">(Set&lt;Course&gt; courses)</span> {
        <span class="hljs-built_in">this</span>.courses = courses;
    }
}
</code></pre>
<h5 data-id="heading-6">Course 类</h5>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.example.domain;

<span class="hljs-keyword">import</span> javax.persistence.*;

<span class="hljs-meta">@Entity</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Course</span> {
    <span class="hljs-meta">@Id</span>
    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span>
    <span class="hljs-keyword">private</span> Long id;
    
    <span class="hljs-keyword">private</span> String name;

    <span class="hljs-meta">@ManyToOne(fetch = FetchType.EAGER)</span>
    <span class="hljs-meta">@JoinColumn(name = "student_id")</span>
    <span class="hljs-keyword">private</span> Student student;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Course</span><span class="hljs-params">()</span> {}

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Course</span><span class="hljs-params">(String name, Student student)</span> {
        <span class="hljs-built_in">this</span>.name = name;
        <span class="hljs-built_in">this</span>.student = student;
    }

    <span class="hljs-comment">// getters 和 setters</span>
    <span class="hljs-keyword">public</span> Long <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> id;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(Long id)</span> {
        <span class="hljs-built_in">this</span>.id = id;
    }

    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> name;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> {
        <span class="hljs-built_in">this</span>.name = name;
    }

    <span class="hljs-keyword">public</span> Student <span class="hljs-title function_">getStudent</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> student;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setStudent</span><span class="hljs-params">(Student student)</span> {
        <span class="hljs-built_in">this</span>.student = student;
    }
}
</code></pre>
<h3 data-id="heading-7">急加载示例代码</h3>
<p>下面的示例展示了如何在并发环境中使用急加载。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">import</span> org.hibernate.Session;
<span class="hljs-keyword">import</span> org.hibernate.SessionFactory;
<span class="hljs-keyword">import</span> org.hibernate.Transaction;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HibernateEagerLoadingExample</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">// 获取SessionFactory</span>
        <span class="hljs-type">SessionFactory</span> <span class="hljs-variable">sessionFactory</span> <span class="hljs-operator">=</span> HibernateUtil.getSessionFactory();

        <span class="hljs-comment">// 插入示例数据</span>
        insertSampleData(sessionFactory);

        <span class="hljs-comment">// 示例: 使用急加载加载数据</span>
        <span class="hljs-type">Session</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;
        <span class="hljs-type">Transaction</span> <span class="hljs-variable">transaction</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;

        <span class="hljs-keyword">try</span> {
            session = sessionFactory.openSession();
            transaction = session.beginTransaction();

            <span class="hljs-comment">// 获取Student对象</span>
            <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> session.get(Student.class, <span class="hljs-number">1L</span>);
            System.out.println(<span class="hljs-string">"Student: "</span> + student.getName() + <span class="hljs-string">", Age: "</span> + student.getAge());

            <span class="hljs-comment">// 访问急加载的集合</span>
            System.out.println(<span class="hljs-string">"Courses: "</span> + student.getCourses().size());
            <span class="hljs-keyword">for</span> (Course course : student.getCourses()) {
                System.out.println(<span class="hljs-string">"Course: "</span> + course.getName());
            }

            transaction.commit();
        } <span class="hljs-keyword">catch</span> (Exception e) {
            <span class="hljs-keyword">if</span> (transaction != <span class="hljs-literal">null</span>) {
                transaction.rollback();
            }
            e.printStackTrace();
        } <span class="hljs-keyword">finally</span> {
            <span class="hljs-keyword">if</span> (session != <span class="hljs-literal">null</span>) {
                session.close();
            }
        }

        <span class="hljs-comment">// 关闭SessionFactory</span>
        sessionFactory.close();
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertSampleData</span><span class="hljs-params">(SessionFactory sessionFactory)</span> {
        <span class="hljs-type">Session</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> sessionFactory.openSession();
        <span class="hljs-type">Transaction</span> <span class="hljs-variable">transaction</span> <span class="hljs-operator">=</span> session.beginTransaction();
        <span class="hljs-keyword">try</span> {
            <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">"John Doe"</span>, <span class="hljs-number">20</span>);
            <span class="hljs-type">Course</span> <span class="hljs-variable">course1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Course</span>(<span class="hljs-string">"Mathematics"</span>, student);
            <span class="hljs-type">Course</span> <span class="hljs-variable">course2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Course</span>(<span class="hljs-string">"Physics"</span>, student);
            student.getCourses().add(course1);
            student.getCourses().add(course2);
            session.save(student);
            transaction.commit();
        } <span class="hljs-keyword">catch</span> (Exception e) {
            <span class="hljs-keyword">if</span> (transaction != <span class="hljs-literal">null</span>) {
                transaction.rollback();
            }
            e.printStackTrace();
        } <span class="hljs-keyword">finally</span> {
            <span class="hljs-keyword">if</span> (session != <span class="hljs-literal">null</span>) {
                session.close();
            }
        }
    }
}
</code></pre>
<h3 data-id="heading-8">详细解释</h3>
<ol>
<li>
<p><strong>配置急加载</strong>：在实体类的关联字段上添加<code>fetch = FetchType.EAGER</code>注解。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@OneToMany(mappedBy = "student", fetch = FetchType.EAGER, cascade = CascadeType.ALL)</span>
<span class="hljs-keyword">private</span> Set&lt;Course&gt; courses = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();
</code></pre>
</li>
<li>
<p><strong>示例场景</strong>：</p>
<ul>
<li>在一个会话中获取Student对象及其关联的Course集合。</li>
<li>急加载策略会在获取Student对象时立即加载其关联的Course集合。</li>
<li>访问Student对象的Courses集合时，不需要额外的数据库查询，因为关联的Course对象已经在加载Student对象时一起加载了。</li>
</ul>
</li>
<li>
<p><strong>事务管理</strong>：在事务中进行数据操作，并在操作完成后提交事务。如果操作失败，则回滚事务以确保数据一致性。</p>
</li>
</ol>
<h3 data-id="heading-9">总结</h3>
<p>急加载是一种数据加载策略，通过在加载实体时立即加载其关联实体，减少了在后续访问关联数据时的数据库查询次数。在Hibernate中，通过<code>fetch = FetchType.EAGER</code>注解可以方便地实现急加载。理解并正确应用急加载，可以有效地提高查询效率和减少数据库访问次数，特别是在需要频繁访问关联数据的场景中。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Hibernate（20）Hibernate如何处理继承关系？]]></title>    <link>https://juejin.cn/post/7590020026395459638</link>    <guid>https://juejin.cn/post/7590020026395459638</guid>    <pubDate>2026-01-02T23:58:56.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7590020026395459638" data-draft-id="7590654280899657771" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Hibernate（20）Hibernate如何处理继承关系？"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-01-02T23:58:56.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Victor356"/> <meta itemprop="url" content="https://juejin.cn/user/3492507879476878"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Hibernate（20）Hibernate如何处理继承关系？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3492507879476878/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Victor356
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-02T23:58:56.000Z" title="Fri Jan 02 2026 23:58:56 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-02
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>Hibernate提供了几种策略来处理继承关系，主要有三种：</p>
<ol>
<li><strong>单表继承（Single Table Inheritance）</strong>：在单个表中存储继承层次结构的所有类。</li>
<li><strong>表连接继承（Joined Table Inheritance）</strong>：为每个类创建独立的表，并使用外键建立关联。</li>
<li><strong>表每类继承（Table Per Class Inheritance）</strong>：为每个具体类创建独立的表，不存储父类信息。</li>
</ol>
<p>下面详细介绍这三种策略，并通过具体的示例代码演示如何在Hibernate中实现它们。</p>
<h3 data-id="heading-0">单表继承（Single Table Inheritance）</h3>
<p>在单表继承策略中，继承层次结构的所有类的属性和数据都存储在同一个表中，通过一个区分列（discriminator column）来区分具体的类型。</p>
<h4 data-id="heading-1">示例</h4>
<h5 data-id="heading-2">配置文件 <code>hibernate.cfg.xml</code></h5>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">hibernate-configuration</span> <span class="hljs-keyword">PUBLIC</span>
        <span class="hljs-string">"-//Hibernate/Hibernate Configuration DTD 3.0//EN"</span>
        <span class="hljs-string">"http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">hibernate-configuration</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">session-factory</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.connection.driver_class"</span>&gt;</span>com.mysql.cj.jdbc.Driver<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.connection.url"</span>&gt;</span>jdbc:mysql://localhost:3306/your_database<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.connection.username"</span>&gt;</span>your_username<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.connection.password"</span>&gt;</span>your_password<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.dialect"</span>&gt;</span>org.hibernate.dialect.MySQLDialect<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.show_sql"</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.format_sql"</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.hbm2ddl.auto"</span>&gt;</span>update<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">mapping</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.example.domain.Person"</span>/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">mapping</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.example.domain.Employee"</span>/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">mapping</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.example.domain.Student"</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">session-factory</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">hibernate-configuration</span>&gt;</span>
</code></pre>
<h5 data-id="heading-3">实体类</h5>
<h6 data-id="heading-4">父类 <code>Person</code></h6>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.example.domain;

<span class="hljs-keyword">import</span> javax.persistence.*;

<span class="hljs-meta">@Entity</span>
<span class="hljs-meta">@Inheritance(strategy = InheritanceType.SINGLE_TABLE)</span>
<span class="hljs-meta">@DiscriminatorColumn(name = "person_type", discriminatorType = DiscriminatorType.STRING)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {
    <span class="hljs-meta">@Id</span>
    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span>
    <span class="hljs-keyword">private</span> Long id;
    
    <span class="hljs-keyword">private</span> String name;

    <span class="hljs-comment">// constructors, getters, and setters</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span> {}

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name)</span> {
        <span class="hljs-built_in">this</span>.name = name;
    }

    <span class="hljs-keyword">public</span> Long <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> id;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(Long id)</span> {
        <span class="hljs-built_in">this</span>.id = id;
    }

    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> name;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> {
        <span class="hljs-built_in">this</span>.name = name;
    }
}
</code></pre>
<h6 data-id="heading-5">子类 <code>Employee</code></h6>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.example.domain;

<span class="hljs-keyword">import</span> javax.persistence.DiscriminatorValue;
<span class="hljs-keyword">import</span> javax.persistence.Entity;

<span class="hljs-meta">@Entity</span>
<span class="hljs-meta">@DiscriminatorValue("EMPLOYEE")</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> salary;

    <span class="hljs-comment">// constructors, getters, and setters</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Employee</span><span class="hljs-params">()</span> {}

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Employee</span><span class="hljs-params">(String name, <span class="hljs-type">double</span> salary)</span> {
        <span class="hljs-built_in">super</span>(name);
        <span class="hljs-built_in">this</span>.salary = salary;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getSalary</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> salary;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSalary</span><span class="hljs-params">(<span class="hljs-type">double</span> salary)</span> {
        <span class="hljs-built_in">this</span>.salary = salary;
    }
}
</code></pre>
<h6 data-id="heading-6">子类 <code>Student</code></h6>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.example.domain;

<span class="hljs-keyword">import</span> javax.persistence.DiscriminatorValue;
<span class="hljs-keyword">import</span> javax.persistence.Entity;

<span class="hljs-meta">@Entity</span>
<span class="hljs-meta">@DiscriminatorValue("STUDENT")</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span> {
    <span class="hljs-keyword">private</span> String major;

    <span class="hljs-comment">// constructors, getters, and setters</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> {}

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name, String major)</span> {
        <span class="hljs-built_in">super</span>(name);
        <span class="hljs-built_in">this</span>.major = major;
    }

    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getMajor</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> major;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMajor</span><span class="hljs-params">(String major)</span> {
        <span class="hljs-built_in">this</span>.major = major;
    }
}
</code></pre>
<h4 data-id="heading-7">插入和查询示例代码</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">import</span> org.hibernate.Session;
<span class="hljs-keyword">import</span> org.hibernate.SessionFactory;
<span class="hljs-keyword">import</span> org.hibernate.Transaction;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HibernateSingleTableInheritanceExample</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">// 获取SessionFactory</span>
        <span class="hljs-type">SessionFactory</span> <span class="hljs-variable">sessionFactory</span> <span class="hljs-operator">=</span> HibernateUtil.getSessionFactory();

        <span class="hljs-comment">// 插入数据</span>
        insertSampleData(sessionFactory);

        <span class="hljs-comment">// 查询数据</span>
        queryData(sessionFactory);

        <span class="hljs-comment">// 关闭SessionFactory</span>
        sessionFactory.close();
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertSampleData</span><span class="hljs-params">(SessionFactory sessionFactory)</span> {
        <span class="hljs-type">Session</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> sessionFactory.openSession();
        <span class="hljs-type">Transaction</span> <span class="hljs-variable">transaction</span> <span class="hljs-operator">=</span> session.beginTransaction();
        <span class="hljs-keyword">try</span> {
            <span class="hljs-type">Employee</span> <span class="hljs-variable">employee</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-string">"John Doe"</span>, <span class="hljs-number">50000.0</span>);
            <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">"Jane Doe"</span>, <span class="hljs-string">"Computer Science"</span>);

            session.save(employee);
            session.save(student);

            transaction.commit();
        } <span class="hljs-keyword">catch</span> (Exception e) {
            <span class="hljs-keyword">if</span> (transaction != <span class="hljs-literal">null</span>) {
                transaction.rollback();
            }
            e.printStackTrace();
        } <span class="hljs-keyword">finally</span> {
            <span class="hljs-keyword">if</span> (session != <span class="hljs-literal">null</span>) {
                session.close();
            }
        }
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">queryData</span><span class="hljs-params">(SessionFactory sessionFactory)</span> {
        <span class="hljs-type">Session</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> sessionFactory.openSession();
        <span class="hljs-keyword">try</span> {
            List&lt;Person&gt; persons = session.createQuery(<span class="hljs-string">"FROM Person"</span>, Person.class).list();
            <span class="hljs-keyword">for</span> (Person person : persons) {
                System.out.println(<span class="hljs-string">"Person: "</span> + person.getName());
                <span class="hljs-keyword">if</span> (person <span class="hljs-keyword">instanceof</span> Employee) {
                    System.out.println(<span class="hljs-string">"Employee Salary: "</span> + ((Employee) person).getSalary());
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (person <span class="hljs-keyword">instanceof</span> Student) {
                    System.out.println(<span class="hljs-string">"Student Major: "</span> + ((Student) person).getMajor());
                }
            }
        } <span class="hljs-keyword">finally</span> {
            <span class="hljs-keyword">if</span> (session != <span class="hljs-literal">null</span>) {
                session.close();
            }
        }
    }
}
</code></pre>
<h3 data-id="heading-8">表连接继承（Joined Table Inheritance）</h3>
<p>在表连接继承策略中，为每个类创建独立的表，子类表包含自己的属性并通过外键引用父类表中的记录。</p>
<h4 data-id="heading-9">示例</h4>
<h5 data-id="heading-10">实体类</h5>
<h6 data-id="heading-11">父类 <code>Person</code></h6>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.example.domain;

<span class="hljs-keyword">import</span> javax.persistence.*;

<span class="hljs-meta">@Entity</span>
<span class="hljs-meta">@Inheritance(strategy = InheritanceType.JOINED)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {
    <span class="hljs-meta">@Id</span>
    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span>
    <span class="hljs-keyword">private</span> Long id;
    
    <span class="hljs-keyword">private</span> String name;

    <span class="hljs-comment">// constructors, getters, and setters</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span> {}

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name)</span> {
        <span class="hljs-built_in">this</span>.name = name;
    }

    <span class="hljs-keyword">public</span> Long <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> id;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(Long id)</span> {
        <span class="hljs-built_in">this</span>.id = id;
    }

    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> name;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> {
        <span class="hljs-built_in">this</span>.name = name;
    }
}
</code></pre>
<h6 data-id="heading-12">子类 <code>Employee</code></h6>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.example.domain;

<span class="hljs-keyword">import</span> javax.persistence.Entity;

<span class="hljs-meta">@Entity</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> salary;

    <span class="hljs-comment">// constructors, getters, and setters</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Employee</span><span class="hljs-params">()</span> {}

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Employee</span><span class="hljs-params">(String name, <span class="hljs-type">double</span> salary)</span> {
        <span class="hljs-built_in">super</span>(name);
        <span class="hljs-built_in">this</span>.salary = salary;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getSalary</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> salary;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSalary</span><span class="hljs-params">(<span class="hljs-type">double</span> salary)</span> {
        <span class="hljs-built_in">this</span>.salary = salary;
    }
}
</code></pre>
<h6 data-id="heading-13">子类 <code>Student</code></h6>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.example.domain;

<span class="hljs-keyword">import</span> javax.persistence.Entity;

<span class="hljs-meta">@Entity</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span> {
    <span class="hljs-keyword">private</span> String major;

    <span class="hljs-comment">// constructors, getters, and setters</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> {}

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name, String major)</span> {
        <span class="hljs-built_in">super</span>(name);
        <span class="hljs-built_in">this</span>.major = major;
    }

    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getMajor</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> major;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMajor</span><span class="hljs-params">(String major)</span> {
        <span class="hljs-built_in">this</span>.major = major;
    }
}
</code></pre>
<p>查询和插入数据的代码与单表继承的示例相同。</p>
<h3 data-id="heading-14">表每类继承（Table Per Class Inheritance）</h3>
<p>在表每类继承策略中，每个具体类都有自己的独立表，不存储父类信息，所有字段（包括父类的字段）都在子类表中。</p>
<h4 data-id="heading-15">示例</h4>
<h5 data-id="heading-16">实体类</h5>
<h6 data-id="heading-17">父类 <code>Person</code></h6>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.example.domain;

<span class="hljs-keyword">import</span> javax.persistence.*;

<span class="hljs-meta">@Entity</span>
<span class="hljs-meta">@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {
    <span class="hljs-meta">@Id</span>
    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.TABLE)</span>
    <span class="hljs-keyword">private</span> Long id;
    
    <span class="hljs-keyword">private</span> String name;

    <span class="hljs-comment">// constructors, getters, and setters</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span> {}

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name)</span> {
        <span class="hljs-built_in">this</span>.name = name;
    }

    <span class="hljs-keyword">public</span> Long <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> id;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(Long id)</span> {
        <span class="hljs-built_in">this</span>.id = id;
    }

    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> name;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> {
        <span class="hljs-built_in">this</span>.name = name;
    }
}
</code></pre>
<h6 data-id="heading-18">子类 <code>Employee</code></h6>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.example.domain;

<span class="hljs-keyword">import</span> javax.persistence.Entity;

<span class="hljs-meta">@Entity</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> salary;

    <span class="hljs-comment">// constructors, getters, and setters</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Employee</span><span class="hljs-params">()</span> {}

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Employee</span><span class="hljs-params">(String name, <span class="hljs-type">double</span> salary)</span> {
        <span class="hljs-built_in">super</span>(name);
        <span class="hljs-built_in">this</span>.salary = salary;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getSalary</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> salary;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSalary</span><span class="hljs-params">(<span class="hljs-type">double</span> salary)</span> {
        <span class="hljs-built_in">this</span>.salary = salary;
    }
}
</code></pre>
<h6 data-id="heading-19">子类 <code>Student</code></h6>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.example.domain;

<span class="hljs-keyword">import</span> javax.persistence.Entity;

<span class="hljs-meta">@Entity</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span> {
    <span class="hljs-keyword">private</span> String major;

    <span class="hljs-comment">// constructors, getters, and setters</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> {}

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name, String major)</span> {
        <span class="hljs-built_in">super</span>(name);
        <span class="hljs-built_in">this</span>.major = major;
    }

    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getMajor</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> major;
    }

    
</code></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[程序员副业 | 2025年12月复盘]]></title>    <link>https://juejin.cn/post/7589958976227344394</link>    <guid>https://juejin.cn/post/7589958976227344394</guid>    <pubDate>2026-01-02T15:06:01.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7589958976227344394" data-draft-id="7590326071413719090" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="程序员副业 | 2025年12月复盘"/> <meta itemprop="keywords" content="后端,创业"/> <meta itemprop="datePublished" content="2026-01-02T15:06:01.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="嘟嘟MD"/> <meta itemprop="url" content="https://juejin.cn/user/3368559354851470"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            程序员副业 | 2025年12月复盘
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3368559354851470/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    嘟嘟MD
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-02T15:06:01.000Z" title="Fri Jan 02 2026 15:06:01 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-02
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{line-height:1.75;font-family:-apple-system-font,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei UI,Microsoft YaHei,Arial,sans-serif;letter-spacing:2px;background-image:linear-gradient(90deg,rgba(50,0,0,.05) 3%,transparent 0),linear-gradient(1turn,rgba(50,0,0,.05) 3%,transparent 0);background-size:20px 20px;background-position:50%;word-break:break-word;font-weight:400;font-size:15px;overflow-x:hidden;color:#333}.markdown-body h1{font-size:23px;margin-bottom:5px;font-weight:700;padding-left:10px;border-left:5px solid #773098}.markdown-body h2{font-size:19px;font-weight:700;padding-left:10px;border-left:5px solid #916dd5}.markdown-body h3{font-size:17px;font-weight:700;padding-left:10px;border-left:5px solid #d89cf6}.markdown-body h4{font-size:16px}.markdown-body h5{font-size:15px}.markdown-body h6{font-size:14px;margin-top:5px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{display:block;max-width:100%;margin:1em 0;border-radius:6px;box-shadow:2px 4px 7px #999;user-select:none}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{padding:.2em .5em;font-weight:700;font-family:-apple-system-font,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei UI,Microsoft YaHei,Arial,sans-serif;font-size:1em;color:#916dd5;word-break:break-word;overflow-x:auto;background-color:none;border-radius:2px}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{display:block;font-family:-apple-system-font,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei UI,Microsoft YaHei,Arial,sans-serif;font-weight:400;font-size:.9em;padding:16px 12px;margin:0;color:#333;word-break:normal;overflow-x:auto;background:#f8f8f8;scroll-behavior:smooth}.markdown-body a{text-decoration:none;color:#916dd5;font-weight:700;border-bottom:1px solid #916dd5}.markdown-body a:active,.markdown-body a:hover{color:#773098}.markdown-body table{display:inline-block!important;font-size:14px;width:auto;max-width:100%;overflow:auto;border:1px solid #916dd5;border-collapse:collapse}.markdown-body thead{background-color:#916dd5;color:#fff;text-align:left}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px;border:1px solid #916dd5}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #d89cf6;background-color:#f4eeff}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0;line-height:26px}.markdown-body ol,.markdown-body ul{padding-left:28px;list-style-type:circle}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body b,.markdown-body strong{color:#916dd5;font-weight:700}.markdown-body b:before,.markdown-body strong:before{content:"「"}.markdown-body b:after,.markdown-body strong:after{content:"」"}.markdown-body em,.markdown-body i{color:#916dd5}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="github-gist">.markdown-body pre,.markdown-body pre&gt;code.hljs{background:#fff;color:#333}.hljs-comment,.hljs-meta{color:#969896}.hljs-emphasis,.hljs-quote,.hljs-strong,.hljs-template-variable,.hljs-variable{color:#df5000}.hljs-keyword,.hljs-selector-tag,.hljs-type{color:#d73a49}.hljs-attribute,.hljs-bullet,.hljs-literal,.hljs-symbol{color:#0086b3}.hljs-name,.hljs-section{color:#63a35c}.hljs-tag{color:#333}.hljs-attr,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-id,.hljs-selector-pseudo,.hljs-title{color:#6f42c1}.hljs-addition{color:#55a532;background-color:#eaffea}.hljs-deletion{color:#bd2c00;background-color:#ffecec}.hljs-link{text-decoration:underline}.hljs-number{color:#005cc5}.hljs-string{color:#032f62}</style><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2557cd7a86814ef8af74fe2f6ba77795~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=900&amp;h=383&amp;s=91599&amp;e=jpg&amp;b=64a5ef" alt="必看大字最新消息重磅公众号首图(2) (1).jpg" loading="lazy"/></p>
<blockquote>
<p>本文首发于公众号：<a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FUJXHYrD_cfoIYeBStWEWqg" target="_blank" title="https://mp.weixin.qq.com/s/UJXHYrD_cfoIYeBStWEWqg" ref="nofollow noopener noreferrer">嘟爷创业日记</a> 。 我已经坚持日更600天+，欢迎过来追剧~</p>
</blockquote>
<blockquote>
<p>大家好，我是嘟嘟MD，一个10年程序员，现在离职创业，有700天了，我每个月都会写一篇总结复盘，让大家可以近距离看看一个离职程序员都在干什么，今天这篇是十二月份的总结，大概2000字，略长，有空的可以翻翻，希望对大家有一丢丢的借鉴作用！</p>
</blockquote>
<h2 data-id="heading-0">一、月度大事</h2>
<p>今天先把12月的复盘写了， 改天再把25年的复盘整理哈，这一年还是经历了很多事情，需要好好总结复盘</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8023525e5f604425bd93e772ca6746b9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Zif5ZifTUQ=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767971161&amp;x-signature=ufk%2BPyYq13HMx0zf6yE68zBqGis%3D" alt="image.png" loading="lazy"/></p>
<p><strong>1：公众号运营+B站视频运营</strong></p>
<p>公众号和B站视频运营目前还是最高优先级，先说这块内容，本月公众号发表29篇（2篇软文），视频号创作26篇，文章更多一些这次。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/022ffe39e8fc4206a7369ec9d02284fa~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Zif5ZifTUQ=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767971161&amp;x-signature=TNIDpoHCXtNYXqa%2FYpSMHx08pYM%3D" alt="image.png" loading="lazy"/></p>
<p>这个月还是很卷的，毕竟这个算是目前最稳定的收入来源啦，平时就跟上班一样，每天醒来最优先的事情就是找选题，测试工作流，写文章、录视频、发布。只有这个事情做完了，我才能抽空处理其他的事情。</p>
<p>不过有时候事情太多了，比如线下团队的事情，要去现场开会讨论啥的，好几次晚上11点到家，1个小时内火急火燎的赶着写文章，也挺不容易哈哈。</p>
<p>更新下我目前几个号的粉丝体量，还是B站增长稳定。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/25da068fb9154640b51e2cde38509137~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Zif5ZifTUQ=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767971161&amp;x-signature=KxHR1pLEOx0SDENkpIjtyVLEkXI%3D" alt="图片" loading="lazy"/></p>
<p>Youtube这块进度比我设想的要快呢，没想到年前就4000小时播放达成，直接申请了开通YPP，可以开始赚美刀了，最近看了下，视频播放已经有5刀的收益了，赚美刀的感觉真爽啊，终于熬出头了，明年又多了一条收益渠道，前期不多，但是我可以熬嘿嘿。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/851e55c881c34f9aaaf4a032523c5861~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Zif5ZifTUQ=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767971161&amp;x-signature=FAVONoKBk077KrZm%2FKNadReLtcw%3D" alt="图片" loading="lazy"/></p>
<p><strong>2：商单业务和接广业务</strong></p>
<p>这个月的软文和商单还行，中规中矩，刚好吃的过来，有一些还在推进的就没统计，其实这个商单+软文推广的算是不确定性收益，有高有低，好的时候破万，差的时候小几千，都是符合我自己赛道的，这些客户大部分都是通过公域链接过来的，核心还是我持续的做内容，有曝光才有新的客户源源不断链接，明天继续坚持做啦。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8bf468b0c45a4dbd95b25643d1767761~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Zif5ZifTUQ=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767971161&amp;x-signature=XKyx8g6jcjV%2FT%2BPlXiYT2LwoUN4%3D" alt="图片" loading="lazy"/></p>
<p><strong>3：线下公司成立+项目推进</strong></p>
<p>这个月下旬和之前福AI的几个线下成员一起成立了公司，核心目的是更好的承接相关的业务，签合同的时候方便。所以这个月线下事情很多，各种开会😮‍💨，新公司成立了我们讨论后决定定下来几个赛道先做，所以我这个月下旬参加了破局的一个视频号带货的，这个算是公司未来一个项目方向，目前先暂时由我牵头推进这项业务。我自己的ComfyUI电商赛道的也包装了一下当做公司的产品去推广。</p>
<p><strong>4：社群续费</strong></p>
<p>今年社群的续费其实弄的有点仓促，事情太多了， 一直拖到12月25号，也就是圣诞节这天，晚上10点左右才急急忙忙的发出来，今年确实事情太多，社群交付没有去年密集，所以整体续费率没有去年的高，只有60%左右的续费率，去年我记得是65%，也是感谢大家的支持，新用户也有几个加入。</p>
<p>新的一年期待和大家有更多额交流，其实目前有挺多非常好的赛道，我是已经定下来在AI绘画这个赛道深耕，所以没精力去做别的，但是我一直推荐我身边的小伙伴去尝试，有红利期。</p>
<h2 data-id="heading-1">二、有什么收获</h2>
<h3 data-id="heading-2">【认知方面】</h3>
<p><strong>1：流水不争先，争的是滔滔不绝</strong></p>
<p>这句话放在最后一个月来说，也可以总结我这一年吧，我这个赛道不好做，数据不好，但是我坚持下来了，很多和我一起做的人，做着做着就消失了，我的竞争对手就少了，我的公众号目前已经算是ComfyUI的全国头部了，没有人比我更新的更多更稳定。</p>
<p>因为持续的在坚持输出，机会反而变得越来越多，更多的人链接过来，更多的合作机会，以及上面提的坚持了5个月开通了油管YPP创作收益。</p>
<p>我其实一直很羡慕那些一个号就有几百万粉丝，光靠这个号就可以养活一个公司的那种，我也想这样，靠一个号养活我自己，现在我看到了苗头，这一年的努力没有白费。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8476523835aa45508a9f96096c179ea8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Zif5ZifTUQ=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767971161&amp;x-signature=GH%2Fh7iYHsovyicSN6KXn9u0OHMA%3D" alt="图片" loading="lazy"/></p>
<h3 data-id="heading-3">【收入方面】</h3>
<p>这个月除了稳定的稿费后，多了商单以及社群续费，所以整体上还行，算是给2025年收个好尾，2026年要继续努力，争取线下公司的业务也能发展起来。</p>
<ul>
<li>1：旧的几个副业收益（旧的收益开始不稳定了）</li>
<li>2：AI绘画相关变现（目前可以稳定月8000+）</li>
<li>3：社群续费+商单收入</li>
<li/>
<li>目前我的收益体系和前一年变化还是很大的，旧的收益确实一直在降低，感觉明年就会没了，这也没办法，没有时间精力投入，躺赚了几年也差不多了， 后面会更加聚焦AI绘画这个赛道，努力挖掘一些有福利的收入渠道。</li>
</ul>
<h3 data-id="heading-4">【技能方面】</h3>
<p><strong>1：书单号剪辑和创作</strong></p>
<p>这个月下旬其实在努力的推进线下公司安排的任务，就是做书单号，所以各种学习剪辑的功能，也是抽时间学，这个月感觉忙的飞起，各种事情都要做。</p>
<h2 data-id="heading-5">三、问题</h2>
<p>这个月问题有点多，继续罗列一下：</p>
<p><strong>1：睡眠+健身</strong></p>
<p>老身长谈问题，身体确实变差了，免疫力下降，还是熬夜的问题，跑步的话就跑了几天，大多数就是去公园散完步，每天睡觉时间挤压在5小时，熬夜到凌晨3点，早上8点醒的大有时候。这样就导致了我一整天精气神不大够。</p>
<p><strong>2：产品问题</strong></p>
<p>产品手册12月有更新，但是后面又因为其他事情很忙，就被推后了，感觉被我推了一整年，这让我不得不思考这个产品手册到底是不是个必需品。真令人头大，弄得每个月都要计划完整，但是又被拖延，弄得我都焦虑了。</p>
<h2 data-id="heading-6">四、下月计划</h2>
<p>新年1月份，我罗列了一下重要的计划：</p>
<p><strong>1：早睡早起+减肥</strong></p>
<p>新的一年，把早睡早起列入最高优先级，25年最后一天去丈母娘家吃饭，被说是不是胖了哈哈，确实，一直久坐，感觉肚子比之前大了些，这还得了，新年必须减肥！</p>
<p><strong>2：项目SOP手册的制作</strong></p>
<p>负责的视频书单号项目1月份要把SOP手册搞出来，方便后续培训用，这个算是1月份比较重要的事情，我自己的产品的话如果可以就同步更新。</p>
<h2 data-id="heading-7">五、总结</h2>
<p>上面算是我这个月的一些重要事情的总结，我分享出来也是给大家可以近距离看看一个离职的程序员的日常，有做的不好的地方也有做的可取的地方，我也是个普通人，一直在尝试和挣扎，我写这篇月度总结，是去翻我这个月发的公众号文章，然后提取出来的，不然我早忘记了，以后年度总结也可以回看月度总结，也能提炼！所以，我写的东西务必是要真实，不能自己骗自己！</p>
<p>我是嘟嘟，一个12年全栈程序员，现在离职创业，需要你的三连~</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[赫蹏(hètí):为中文网页内容赋予优雅排版的开源利器]]></title>    <link>https://juejin.cn/post/7589932422654836772</link>    <guid>https://juejin.cn/post/7589932422654836772</guid>    <pubDate>2026-01-02T15:42:40.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7589932422654836772" data-draft-id="7589919989039235135" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="赫蹏(hètí):为中文网页内容赋予优雅排版的开源利器"/> <meta itemprop="keywords" content="开源"/> <meta itemprop="datePublished" content="2026-01-02T15:42:40.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="修己xj"/> <meta itemprop="url" content="https://juejin.cn/user/2641475936724142"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            赫蹏(hètí):为中文网页内容赋予优雅排版的开源利器
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2641475936724142/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    修己xj
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-02T15:42:40.000Z" title="Fri Jan 02 2026 15:42:40 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-02
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0e03929226554e518e5ee5904a9c78f5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5L-u5bexeGo=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767973359&amp;x-signature=uh3uCw%2FigvJkXddGXki2h6BEb%2BM%3D" alt="fHJ9cZeOp.jpg" loading="lazy"/></p>
<p>fHJ9cZeOp.jpg</p>
<p>在当今信息爆炸的时代，内容呈现的形式往往决定了阅读体验的优劣。对于中文网站来说，一个长期存在的挑战是如何实现符合传统中文排版美学的网页展示。尽管现代CSS技术已经十分强大，但针对中文特点的排版优化仍然不够完善。今天，我们将介绍一个专门为解决这一问题而生的开源项目——<strong>赫蹏</strong>（hètí）。</p>
<h2 data-id="heading-0">什么是赫蹏？</h2>
<p>赫蹏是一个专为中文内容展示设计的排版样式增强库，名称取自古代对纸张的雅称。这个项目由开发者Sivan创建，基于通行的中文排版规范，旨在为网站的读者提供更加舒适、专业的文章阅读体验。</p>
<p>简单来说，<strong>赫蹏让中文网页内容“自动变好看”</strong> 。</p>
<p>该项目在github 已有6.6k star</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ce0f630a865241b0a5dbf6d4ff5fc843~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5L-u5bexeGo=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767973359&amp;x-signature=9xQC5WG4FwXVNsC1CeTZRlVMG9E%3D" alt="_20260102_222650.png" loading="lazy"/></p>
<p>_20260102_222650.png</p>
<ul>
<li>github 地址： <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsivan%2Fheti" target="_blank" title="https://github.com/sivan/heti" ref="nofollow noopener noreferrer">github.com/sivan/heti</a></li>
<li>在线预览地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fsivan.github.io%2Fheti%2F" target="_blank" title="https://sivan.github.io/heti/" ref="nofollow noopener noreferrer">sivan.github.io/heti/</a></li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b6df3713ee7848e39606c2fbf09bba09~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5L-u5bexeGo=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767973359&amp;x-signature=4T8HTedr%2Bmyatk7rQ%2FK3iSUPqBc%3D" alt="_20260102_223923.png" loading="lazy"/></p>
<p>_20260102_223923.png</p>
<h2 data-id="heading-1">核心特性一览</h2>
<h3 data-id="heading-2">🎯 贴合网格的精准排版</h3>
<p>赫蹏实现了基于网格系统的中文排版，确保文字、段落和间距都遵循严谨的视觉规律，让页面呈现出整齐划一的专业感。</p>
<h3 data-id="heading-3">📝 全标签样式美化</h3>
<p>项目不仅仅针对段落文本，而是对整个HTML文档中的各类标签（标题、列表、表格、代码块等）都进行了细致的美化，形成统一而和谐的整体视觉风格。</p>
<h3 data-id="heading-4">🏮 传统版式支持</h3>
<p>赫蹏贴心地预置了<strong>古文、诗词样式</strong>，并提供了多种传统排版样式支持：</p>
<ul>
<li>行间注（类似于古籍中的双行小注）</li>
<li>多栏排版</li>
<li>竖排文字</li>
<li>为需要展示传统文学内容的网站提供了极大便利</li>
</ul>
<h3 data-id="heading-5">🌗 智能适配设计</h3>
<ul>
<li><strong>自适应黑暗模式</strong>：跟随系统设置自动切换明暗主题</li>
<li><strong>移动端优先</strong>：在各种屏幕尺寸上都有良好表现</li>
<li><strong>简繁中文支持</strong>：满足不同地区用户的需求</li>
</ul>
<h3 data-id="heading-6">✨ 智能排版增强（基于JavaScript）</h3>
<p>这是赫蹏的“黑科技”部分：</p>
<ul>
<li><strong>中西文混排美化</strong>：自动在中英文之间添加适当间距，再也不用手动敲空格</li>
<li><strong>全角标点挤压</strong>：智能调整标点符号的间距，避免出现难看的空白</li>
</ul>
<h3 data-id="heading-7">🎨 字体优化</h3>
<p>提供多种预设的中文字体族选择（桌面端），可根据不同内容风格搭配最合适的字体组合。</p>
<h2 data-id="heading-8">极简的安装与使用</h2>
<p>赫蹏的设计哲学是“最小化侵入”，使用起来异常简单：</p>
<h3 data-id="heading-9">基础使用（仅CSS）</h3>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-comment">&lt;!-- 1. 引入样式 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"//unpkg.com/heti/umd/heti.min.css"</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 2. 添加类名 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">article</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"heti"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>文章标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这里是你所有的中文内容...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span>
</code></pre>
<p>只需这两步，你的内容就会立刻获得专业级的中文排版效果。</p>
<h3 data-id="heading-10">增强功能（添加JavaScript）</h3>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"//unpkg.com/heti/umd/heti-addon.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-keyword">const</span> heti = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Heti</span>(<span class="hljs-string">'.heti'</span>);
  heti.<span class="hljs-title function_">autoSpacing</span>(); <span class="hljs-comment">// 启用智能中西文混排和标点挤压</span>
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<h2 data-id="heading-11">实际效果展示</h2>
<p>我比较喜欢的是<code>竖排</code>排版的样式,我们在markdown中也可以直接使用，如下使用</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"//unpkg.com/heti/umd/heti.min.css"</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"card__vertical-container"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"heti--vertical heti--ancient"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>出師表<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"heti-small"</span>&gt;</span>作者：<span class="hljs-tag">&lt;<span class="hljs-name">abbr</span> <span class="hljs-attr">title</span>=<span class="hljs-string">"字孔明"</span>&gt;</span>諸葛亮<span class="hljs-tag">&lt;/<span class="hljs-name">abbr</span>&gt;</span>（181年－234年10月8日）<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>先帝創業未半，而中道崩殂；今天下三分，益州疲弊，此誠危急存亡之秋也﹗然侍衞之臣，不懈於內；忠志之士，忘身於外者，蓋追先帝之殊遇，欲報之於陛下也。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>誠宜開張聖聽，以光先帝遺德，恢弘志士之氣﹔不宜妄自菲薄，引喻失義，以塞忠諫之路也。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>宮中、府中，俱為一體；陟罰臧否，不宜異同。若有作姦、犯科，及為忠善者，宜付有司，論其刑賞，以昭陛下平明之治；不宜偏私，使內外異法也。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>侍中、侍郎郭攸之、費禕、董允等，此皆良實，志慮忠純，是以先帝簡拔以遺陛下。愚以為宮中之事，事無大小，悉以咨之，然後施行，必能裨補闕漏，有所廣益。將軍向寵，性行淑均，曉暢軍事，試用於昔日，先帝稱之曰「能」，是以眾議舉寵為督。愚以為營中之事，悉以咨之，必能使行陣和睦，優劣得所。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>親賢臣，遠小人，此先漢所以興隆也﹔親小人，遠賢臣，此後漢所以傾頹也。先帝在時，每與臣論此事，未嘗不歎息痛恨於桓、靈也！侍中、尚書、長史、參軍，此悉貞良死節之臣，願陛下親之、信之，則漢室之隆，可計日而待也。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>臣本布衣，躬耕於南陽，苟全性命於亂世，不求聞達於諸侯。先帝不以臣卑鄙，猥自枉屈，三顧臣於草廬之中，諮臣以當世之事；由是感激，遂許先帝以驅馳。後值傾覆，受任於敗軍之際，奉命於危難之間，爾來二十有一年矣。先帝知臣謹慎，故臨崩寄臣以大事也。受命以來，夙夜憂歎，恐託付不效，以傷先帝之明。故五月渡瀘，深入不毛。今南方已定，兵甲已足，當獎率三軍，北定中原，庶竭駑鈍，攘除姦凶，興復漢室，還於舊都。此臣所以報先帝而忠陛下之職分也。至於斟酌損益，進盡忠言，則攸之、禕、允之任也。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>願陛下託臣以討賊興復之效；不效，則治臣之罪，以告先帝之靈。若無興德之言，則責攸之、禕、允等之慢，以彰其咎。陛下亦宜自謀，以諮諏善道，察納雅言，深追先帝遺詔。臣不勝受恩感激。今當遠離，臨表涕零，不知所言！<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<p>效果如下：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/66cd0cea86df43b4b42d33db05df510e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5L-u5bexeGo=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767973359&amp;x-signature=fnlY5JZqQyF9f1LnM5jYA6VkdRw%3D" alt="_20260102_224539.png" loading="lazy"/></p>
<p>_20260102_224539.png</p>
<p>我使用ai 基于赫蹏（hètí）做了一个竖版排版的网站，感兴趣的家人们也可以使用下</p>
<p>博主竖版排版网址： <a href="https://link.juejin.cn?target=http%3A%2F%2Fh5.xiuji.mynatapp.cc%2Fheti%2F" target="_blank" title="http://h5.xiuji.mynatapp.cc/heti/" ref="nofollow noopener noreferrer">h5.xiuji.mynatapp.cc/heti/</a></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/306711b4cbac4f0c980f268a244573e9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5L-u5bexeGo=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767973359&amp;x-signature=6mAEs7SPQyp%2FZOhpGGTM4QRMQsY%3D" alt="_20260102_232901.png" loading="lazy"/></p>
<p>_20260102_232901.png</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d1f0192156d445ceaa4a8f701c5b2a4d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5L-u5bexeGo=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767973359&amp;x-signature=4WnpAxJXKTshftIuEHu2rRk9zaY%3D" alt="_.png" loading="lazy"/></p>
<p>_.png</p>
<h2 data-id="heading-12">结语：让内容回归本质</h2>
<p>在追求炫酷交互和复杂动画的今天，赫蹏提醒我们一个基本事实：对于内容型网站，<strong>优秀的可读性才是最重要的用户体验</strong>。这个项目以极低的成本，为中文网页带来了显著的品质提升。</p>
<p>如果你正在经营一个以中文内容为主的网站，或者只是想在个人博客上获得更好的排版效果，不妨尝试一下赫蹏。正如项目README中所说的：“总之，用上就会变好看。”</p>
<p>赫蹏不仅是一个工具，更是对中文数字阅读体验的一次优雅致敬。在这个注意力稀缺的时代，为读者提供一个舒适的阅读环境，或许就是最好的内容策略。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[告别延迟！通义开源Fun-Audio-Chat，这才是我们要的语音AI]]></title>    <link>https://juejin.cn/post/7589940210832228395</link>    <guid>https://juejin.cn/post/7589940210832228395</guid>    <pubDate>2026-01-02T14:07:20.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7589940210832228395" data-draft-id="7590020026395279414" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="告别延迟！通义开源Fun-Audio-Chat，这才是我们要的语音AI"/> <meta itemprop="keywords" content="AIGC"/> <meta itemprop="datePublished" content="2026-01-02T14:07:20.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="墨风如雪"/> <meta itemprop="url" content="https://juejin.cn/user/4064249017803927"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            告别延迟！通义开源Fun-Audio-Chat，这才是我们要的语音AI
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4064249017803927/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    墨风如雪
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-02T14:07:20.000Z" title="Fri Jan 02 2026 14:07:20 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-02
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>说实话，玩了这么久的语音助手，最让我难受的不是它听不懂，而是那种明显的“割裂感”。</p>
<p>你说完一句话，系统开始转圈，把声音转成字，丢给大模型思考，生成文字，再找个TTS念出来。这一套流程下来，哪怕延迟只有一两秒，那种“我在跟机器说话”的感觉也挥之不去。</p>
<p>但在2025年年底，这个局面可能真的要变了。</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.worldcodeing.com%2Fwp-content%2Fuploads%2F2026%2F01%2FiShot_2026-01-02_21.58.28-1024x384.png" target="_blank" title="https://blog.worldcodeing.com/wp-content/uploads/2026/01/iShot_2026-01-02_21.58.28-1024x384.png" ref="nofollow noopener noreferrer"><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/df3c2e24c2a14683bef6a97cce0d1b37~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aKo6aOO5aaC6Zuq:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767967639&amp;x-signature=O2MjY%2BvCRcsmcz9AkPY4915XT00%3D" alt="iShot_2026-01-02_21.58.28" loading="lazy"/></a></p>
<p>就在12月23日，阿里通义大模型团队悄悄扔出了一个重磅炸弹：<strong>Fun-Audio-Chat-8B</strong>。这不是又一个普通的语音助手，而是通义百聆家族里首个主打**端到端“语音对语音”**交互的模型。</p>
<p>最关键的是，它直接开源了。</p>
<p><strong>为什么这次不一样？</strong></p>
<p>以前我们做语音交互，像是搞接力赛，耳朵（ASR）、大脑（LLM）和嘴巴（TTS）各跑各的。Fun-Audio-Chat直接把这个流程打通了，它采用了一种叫**端到端S2S（Sequence-to-Sequence）**的架构。简单来说，模型直接听声音，然后直接吐声音。</p>
<p>这种改变带来的体验升级是质的。没有了中间商赚差价，延迟被压到了极低。而且它支持“全双工交互”，你可以像跟真人聊天一样随时打断它，它也能一边听一边想一边说。这种“边听边说”的能力，才是通义这个新模型最吓人的地方。</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.worldcodeing.com%2Fwp-content%2Fuploads%2F2026%2F01%2FiShot_2026-01-02_21.59.03-1024x601.png" target="_blank" title="https://blog.worldcodeing.com/wp-content/uploads/2026/01/iShot_2026-01-02_21.59.03-1024x601.png" ref="nofollow noopener noreferrer"><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/11bc14268eb54304914c3f0e153b510f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aKo6aOO5aaC6Zuq:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767967639&amp;x-signature=D%2FQaGjw7nnR%2FQuvz8EitCIkLspc%3D" alt="iShot_2026-01-02_21.59.03" loading="lazy"/></a></p>
<p><strong>聪明的“双分辨率”设计</strong></p>
<p>你可能会担心，直接处理音频数据，算力扛得住吗？</p>
<p>这就要提到通义团队这次搞的一个很骚的操作：<strong>双分辨率架构</strong>。</p>
<p>他们发现，人类说话的语速其实并不快，但声音的细节（音色、情感）需要高采样率。于是他们让模型的大脑（LLM层）以5Hz的低帧率去处理语义，省劲又快；然后专门配了一个“语音重合成头”，以25Hz的高帧率去还原声音细节。</p>
<p>结果就是，这玩意儿比原本的方案省了近50%的GPU计算开销。对于想在本地部署（比如你有一张RTX 3090或4090）的开发者来说，这简直是福音。</p>
<p><strong>它真的懂你的情绪</strong></p>
<p>除了快，Fun-Audio-Chat最让我惊喜的是它的“情商”。</p>
<p>以前的语音助手全是莫得感情的读稿机器。但Fun-Audio-Chat引入了<strong>Core-Cocktail训练策略</strong>，在保留强大文本逻辑的同时，疯补了百万小时的语音数据。</p>
<p>这意味着什么？意味着它不需要你打字备注[悲伤]，光听你说话的语气、停顿、叹气，它就能get到你的情绪。它会根据你的状态，调整自己的语调来安慰你或者陪你开心。这种无提示的情绪感知，才是通义百聆想做的“AI语音搭子”。</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.worldcodeing.com%2Fwp-content%2Fuploads%2F2026%2F01%2FiShot_2026-01-02_21.59.17.png" target="_blank" title="https://blog.worldcodeing.com/wp-content/uploads/2026/01/iShot_2026-01-02_21.59.17.png" ref="nofollow noopener noreferrer"><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fba0a677a69440acb712c06a99ad2f23~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aKo6aOO5aaC6Zuq:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767967639&amp;x-signature=r5%2Bz343AtaD5defB18eT2ESWNpw%3D" alt="iShot_2026-01-02_21.59.17" loading="lazy"/></a></p>
<p><strong>不仅能聊，还能干活</strong></p>
<p>别以为它只是个聊天机器人。在<strong>语音功能调用</strong>这块，它也做得相当扎实。你可以直接用大白话让它“放首轻松的歌，顺便查查去机场堵不堵”，它能直接调用函数去执行，而不是傻傻地回你一句“我不明白您的意思”。</p>
<p><strong>实测成绩单</strong></p>
<p>在这个圈子，光吹技术没用，还得看跑分。</p>
<p>在OpenAudioBench、MMAU这些硬核评测里，Fun-Audio-Chat-8B面对同尺寸（8B）的竞品，比如GLM4-Voice和Kimi-Audio，几乎是压倒性的优势。特别是在语音理解和生成质量上，它确实拿出了榜一大哥的实力。</p>
<p><strong>写在最后</strong></p>
<p>目前，Fun-Audio-Chat-8B的权重、推理代码都已经扔到了Hugging Face、魔搭社区和GitHub上。</p>
<p>如果你是一个对语音交互有执念的开发者，或者想给自己的应用加上一个真的“像人”的语音接口，这个模型绝对值得你去跑一下。</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.worldcodeing.com%2Fwp-content%2Fuploads%2F2026%2F01%2FiShot_2026-01-02_21.59.49-1024x307.png" target="_blank" title="https://blog.worldcodeing.com/wp-content/uploads/2026/01/iShot_2026-01-02_21.59.49-1024x307.png" ref="nofollow noopener noreferrer"><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e944eca920164173a62d33be1d7c53c2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aKo6aOO5aaC6Zuq:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767967639&amp;x-signature=SszNbSIskB71k4b0xbBgDerhHgw%3D" alt="iShot_2026-01-02_21.59.49" loading="lazy"/></a></p>
<p>2025年的尾巴，通义不仅卷了技术，还把门槛给打下来了。语音交互的iPhone时刻，可能真的不远了。</p>
<p><strong>如果你也对最新的AI信息感兴趣或者有疑问 都可以加入我的大家庭 第一时间分享最新AI资讯、工具、教程、文档 欢迎你的加入！！！😉😉😉</strong></p>
<p>公众号：墨风如雪小站</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[latex-公式写法]]></title>    <link>https://juejin.cn/post/7590020026395312182</link>    <guid>https://juejin.cn/post/7590020026395312182</guid>    <pubDate>2026-01-02T14:20:19.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7590020026395312182" data-draft-id="7590020026395295798" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="latex-公式写法"/> <meta itemprop="keywords" content="程序员"/> <meta itemprop="datePublished" content="2026-01-02T14:20:19.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="自由生长2024"/> <meta itemprop="url" content="https://juejin.cn/user/1591748569862670"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            latex-公式写法
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1591748569862670/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    自由生长2024
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-02T14:20:19.000Z" title="Fri Jan 02 2026 14:20:19 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-02
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h4 data-id="heading-0"><strong>一、LaTeX 是什么？</strong></h4>
<p>LaTeX 是一种专业的<strong>文档排版系统</strong>，尤其在数学、物理、计算机科学等领域被广泛用于编写包含复杂公式的论文、书籍和演示文稿。它的核心特点是可以用<strong>代码</strong>来生成美观、精确的数学公式。</p>
<hr/>
<h4 data-id="heading-1"><strong>二、这段 LaTeX 代码的解读</strong></h4>
<p>这段代码：</p>
<pre><code class="hljs language-latex" lang="latex">\[
\text{指数} = \frac{80}{114.2857} \times 1000 \approx 700 \text{点}
\]
</code></pre>
<p><strong>渲染（显示）出来的效果就是：</strong></p>
<div class="math math-display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>指数</mtext><mo>=</mo><mfrac><mn>80</mn><mn>114.2857</mn></mfrac><mo>×</mo><mn>1000</mn><mo>≈</mo><mn>700</mn><mtext>点</mtext></mrow><annotation encoding="application/x-tex">\text{指数} = \frac{80}{114.2857} \times 1000 \approx 700 \text{点}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"/><span class="mord text"><span class="mord cjk_fallback">指数</span></span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:2.0074em;vertical-align:-0.686em;"/><span class="mord"><span class="mopen nulldelimiter"/><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"/><span class="mord"><span class="mord">114.2857</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"/><span class="frac-line" style="border-bottom-width:0.04em;"/></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"/><span class="mord"><span class="mord">80</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span/></span></span></span></span><span class="mclose nulldelimiter"/></span><span class="mspace" style="margin-right:0.2222em;"/><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"/></span><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord">1000</span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:0.6833em;"/><span class="mord">700</span><span class="mord text"><span class="mord cjk_fallback">点</span></span></span></span></span></span></div>
<hr/>
<h4 data-id="heading-2"><strong>三、代码结构解析</strong></h4>
<ol>
<li>
<p><code>\[</code> 和 <code>\]</code>：</p>
<ul>
<li>这是 LaTeX 中表示<strong>独立显示公式</strong>的符号。公式会单独居中显示在一行。</li>
</ul>
</li>
<li>
<p><code>\text{指数}</code>：</p>
<ul>
<li><code>\text{}</code> 命令用于在公式中插入<strong>正常文本</strong>（而不是数学斜体）。</li>
<li>这里是为了在公式中显示中文“指数”两个字。</li>
</ul>
</li>
<li>
<p><code>\frac{80}{114.2857}</code>：</p>
<ul>
<li><code>\frac{分子}{分母}</code> 是 LaTeX 中创建<strong>分数</strong>的命令。</li>
<li>这里生成分数：分子是 80，分母是 114.2857。</li>
</ul>
</li>
<li>
<p><code>\times</code>：</p>
<ul>
<li>生成乘号 “×”。</li>
</ul>
</li>
<li>
<p><code>\approx</code>：</p>
<ul>
<li>生成约等号 “≈”。</li>
</ul>
</li>
<li>
<p><code>\text{点}</code>：</p>
<ul>
<li>同上，在公式末尾添加中文“点”字。</li>
</ul>
</li>
</ol>
<hr/>
<h4 data-id="heading-3"><strong>四、为什么在对话中使用 LaTeX？</strong></h4>
<p>在解释<strong>数学公式、金融计算、科学原理</strong>时，LaTeX 是最清晰、最准确的方式。它能确保：</p>
<ul>
<li>公式结构（如分数、上下标）准确无误。</li>
<li>排版专业美观，易于阅读和理解。</li>
<li>是学术和技术交流的通用标准。</li>
</ul>
<hr/>
<h4 data-id="heading-4"><strong>五、如何看到渲染后的公式？</strong></h4>
<ul>
<li><strong>在支持 LaTeX 的平台上</strong>（如 Stack Exchange、Jupyter Notebook、Overleaf、Obsidian 等），这段代码会自动渲染成您看到的漂亮公式。</li>
<li><strong>在不支持的环境下</strong>（如纯文本聊天），它则会以代码形式显示。不过，现在很多AI助手（包括我）和高级笔记软件都内置了 LaTeX 渲染引擎，可以直接显示公式。</li>
</ul>
<p>所有包含 <code>\[ ... \]</code> 或 <code>$$ ... $$</code> 的数学公式，都是用 LaTeX 编写的。这是一个非常好且实用的知识交流工具。</p>
<h2 data-id="heading-5">新老版本</h2>
<p>有的渲染器只支持 $$，不支持 <code>\[ \]</code>。</p>
<p>这是一个在实际使用中经常遇到的兼容性问题。</p>
<hr/>
<h4 data-id="heading-6"><strong>一、现状与区别</strong></h4>
<ol>
<li>
<p><strong><code>$$ ... $$</code></strong>（经典TeX格式）</p>
<ul>
<li>这是最古老、最经典的TeX数学环境。</li>
<li>几乎<strong>所有</strong>支持LaTeX的渲染器都兼容它。</li>
<li><strong>缺点</strong>：在正式LaTeX文档中，它不被推荐为首选（可能产生不一致的间距），但在网页、Markdown等场景中应用极广。</li>
</ul>
</li>
<li>
<p><strong><code>\[ ... \]</code></strong>（LaTeX标准格式）</p>
<ul>
<li>这是LaTeX2的标准语法，用于创建无编号的显示公式。</li>
<li>在<strong>完整的LaTeX文档</strong>（如.tex文件）中是首选。</li>
<li><strong>缺点</strong>：一些<strong>较旧或简化的渲染器</strong>（尤其是某些Markdown解析器、旧版网站）可能不支持它。</li>
</ul>
</li>
</ol>
<p>比如掘金网站就不支持！</p>
<hr/>
<h4 data-id="heading-7"><strong>二、常见场景支持度</strong></h4>



























































<table><thead><tr><th align="left">环境/平台</th><th align="left">通常支持 <code>$$</code></th><th align="left">通常支持 <code>\[ \]</code></th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><strong>标准LaTeX编译器</strong> (pdfLaTeX, XeLaTeX)</td><td align="left">✅（但不推荐）</td><td align="left">✅（首选）</td><td align="left">两者都工作，但后者是标准</td></tr><tr><td align="left"><strong>MathJax（默认配置）</strong></td><td align="left">✅</td><td align="left">✅</td><td align="left">两者都支持</td></tr><tr><td align="left"><strong>KaTeX</strong></td><td align="left">✅</td><td align="left">✅（需确认配置）</td><td align="left">两者都支持，但<code>$$</code>最稳妥</td></tr><tr><td align="left"><strong>GitHub Flavored Markdown</strong></td><td align="left">❌（需特殊处理）</td><td align="left">❌</td><td align="left">GitHub为安全默认禁用</td></tr><tr><td align="left"><strong>Jupyter Notebook</strong></td><td align="left">✅</td><td align="left">✅</td><td align="left">两者都支持</td></tr><tr><td align="left"><strong>Stack Exchange（如Math.SE）</strong></td><td align="left">✅</td><td align="left">✅</td><td align="left">两者都支持</td></tr><tr><td align="left"><strong>某些旧版论坛/博客</strong></td><td align="left">✅</td><td align="left">❌</td><td align="left">可能只识别<code>$$</code></td></tr><tr><td align="left"><strong>Obsidian（默认）</strong></td><td align="left">✅</td><td align="left">✅</td><td align="left">两者都支持</td></tr></tbody></table>
<hr/>
<h4 data-id="heading-8"><strong>三、最佳实践建议</strong></h4>
<p>为了保证<strong>最大兼容性</strong>，尤其在<strong>网页、Markdown、技术论坛</strong>等不确定渲染器配置的环境中：</p>
<h5 data-id="heading-9"><strong>建议1：使用 <code>$$ ... $$</code>（最安全）</strong></h5>
<pre><code class="hljs language-latex" lang="latex">$$
\text{指数} = \frac{80}{114.2857} \times 1000 \approx 700 \ \text{点}
$$
</code></pre>
<p>这样写几乎能在<strong>所有场景</strong>下工作。</p>
<h5 data-id="heading-10"><strong>建议2：明确使用 <code>\displaystyle</code>（如果需要行内显示数学样式）</strong></h5>
<p>如果您需要在行内插入复杂公式（如分数），但环境只支持<code>$...$</code>（行内模式），可以：</p>
<pre><code class="hljs language-latex" lang="latex">$ \displaystyle \frac{80}{114.2857} \times 1000 \approx 700 $ 点
</code></pre>
<p>（<code>\displaystyle</code>会使公式像显示模式一样渲染）</p>
<hr/>
<h4 data-id="heading-11"><strong>四、回到我们的例子</strong></h4>
<p>如果为了<strong>绝对兼容</strong>，我应该将之前的公式写成：</p>
<pre><code class="hljs language-latex" lang="latex">$$
\text{指数} = \frac{80}{114.2857} \times 1000 \approx 700 \ \text{点}
$$
</code></pre>
<p>或者，如果渲染器非常基础，甚至要避免使用 <code>\text{}</code>：</p>
<pre><code class="hljs language-latex" lang="latex">$$
指数 = \frac{80}{114.2857} \times 1000 \approx 700 \ 点
$$
</code></pre>
<p>（虽然不标准，但某些仅支持基本数学命令的解析器可能只能这样处理中文）</p>
<hr/>
<h4 data-id="heading-12"><strong>五、总结</strong></h4>
<ul>
<li><strong><code>$$</code> 是“最大公约数”</strong>，兼容性最好，尤其在网络环境。</li>
<li><strong><code>\[ \]</code> 更标准</strong>，但在非完整LaTeX环境中可能失效。</li>
<li><strong>在不确定时，优先用 <code>$$</code></strong>。</li>
<li><strong>重要文档中，先测试目标平台的渲染支持情况</strong>。</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Factory.ai CLI 更新日志（持续更新）]]></title>    <link>https://juejin.cn/post/7590104561476091956</link>    <guid>https://juejin.cn/post/7590104561476091956</guid>    <pubDate>2026-01-02T14:24:59.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7590104561476091956" data-draft-id="7590159073988919348" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Factory.ai CLI 更新日志（持续更新）"/> <meta itemprop="keywords" content="AI编程"/> <meta itemprop="datePublished" content="2026-01-02T14:24:59.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="是魔丸啊"/> <meta itemprop="url" content="https://juejin.cn/user/3217622495411292"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Factory.ai CLI 更新日志（持续更新）
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3217622495411292/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    是魔丸啊
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-02T14:24:59.000Z" title="Fri Jan 02 2026 14:24:59 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-02
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读22分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.factory.ai%2Fchangelog%2Fcli-updates" target="_blank" title="https://docs.factory.ai/changelog/cli-updates" ref="nofollow noopener noreferrer">转载</a></p>
<h2 data-id="heading-0">12月30日 v0.41.0</h2>
<h3 data-id="heading-1">新功能</h3>
<p><strong>/wrapped 命令</strong> - 年度回顾统计，展示您的 Droid 使用情况、获得的徽章、模型偏好和会话指标 (cli)</p>
<p><strong>快速模型切换</strong> - 无需 LLM compaction 即可更快地切换 provider/model (cli)</p>
<p><strong>批量 tool 权限</strong> - 并行 tool 调用现在显示单个权限提示 (cli)</p>
<p><strong>自定义 BYOK models</strong> - 自定义 models 现在出现在 model selector 中 (cli)</p>
<p><strong>自动同步仓库</strong> - 打开 template modal 时自动同步 GitHub/GitLab 仓库 (app)</p>
<h3 data-id="heading-2">改进</h3>
<p><strong>PDF 和文本文件上传</strong> - 在 Web/Desktop apps 的聊天中附加 PDF 和文本文件 (app)</p>
<p><strong>发送按钮</strong> - 会话聊天输入中的可视化发送按钮 (app)</p>
<p><strong>ASCII 启动动画</strong> - CLI 启动时的动画 Droid logo（可配置）(cli)</p>
<p><strong>Token 倍率显示</strong> - 在 model 描述中显示 Factory token 费率 (cli)</p>
<h3 data-id="heading-3">Bug 修复</h3>
<ul>
<li>修复用户卡在损坏的 onboarding 状态中的问题 (app)</li>
<li>修复仅使用 terminal 的用户的 CLI onboarding 重定向问题</li>
<li>修复 GitHub org 管理 modal 中缺失仓库的问题 (app)</li>
<li>修复多选项 spec mode 选择问题 (cli)</li>
<li>修复阻止订阅启动的 catch-22 bug (app)</li>
</ul>
<h2 data-id="heading-4">12月23日 v0.40.0</h2>
<h3 data-id="heading-5">新功能</h3>
<p><strong>从 settings 加载自定义 models</strong> - 直接从 settings.json 加载自定义 models</p>
<p><strong>并行 tool 确认</strong> - 并行 tool 调用使用单个权限请求，而不是逐个提示</p>
<p><strong>多选项 spec mode</strong> - Spec mode 现在可以呈现多个实现选项供用户选择</p>
<p><strong>Settings 文件监视</strong> - Settings 文件更改时自动重新加载</p>
<p><strong>Exec mode 中的 token 使用情况</strong> - Token 使用情况现在显示在 exec streaming 输出中</p>
<p><strong>Stop hook 改进</strong> - Stop hook 的决策和原因支持，以匹配 Claude code spec</p>
<h3 data-id="heading-6">Bug 修复</h3>
<ul>
<li><strong>Opus 4.5 model 修复</strong> - 修复 Opus 4.5 作为 effort model 工作，改进 thinking guard</li>
<li><strong>Tool 完成修复</strong> - 修复 tools 在新 assistant 消息上未正确完成的问题</li>
<li><strong>Web 搜索日期修复</strong> - Web search tool 现在包含动态日期以获得更准确的结果</li>
</ul>
<h2 data-id="heading-7">12月19日 v0.39.0</h2>
<h3 data-id="heading-8">新功能</h3>
<p><strong>上下文利用率设置</strong> - 新设置可在状态栏中显示 token 使用指示器</p>
<p><strong>默认启用自定义 Droids</strong> - 自定义 Droids 功能现在对所有用户可用，无需选择加入</p>
<h3 data-id="heading-9">Bug 修复</h3>
<ul>
<li><strong>Grep tool 修复</strong> - 修复 Grep tool 中的 pattern 参数处理</li>
<li><strong>BYOK Grok 修复</strong> - 修复使用 Grok models 与 thinking/reasoning streams 时的崩溃</li>
<li><strong>Warmup 改进</strong> - 添加禁用 warmup 请求的选项，并为斜杠命令跳过 warmup</li>
<li><strong>非 git 目录支持</strong> - 当不在 git 仓库中时，使用当前工作目录作为项目目录</li>
</ul>
<h2 data-id="heading-10">12月18日 v0.38.0</h2>
<h3 data-id="heading-11">Bug 修复</h3>
<p><strong>GPT-5.2 改进</strong> - 修复请求参数和 reasoning effort 选项，以获得更好的 model 性能</p>
<p><strong>防止 .env 自动加载</strong> - CLI 在独立构建中不再自动从工作目录加载 .env 文件，使行为更可预测</p>
<h2 data-id="heading-12">12月17日 v0.37.0</h2>
<h3 data-id="heading-13">改进</h3>
<p><strong>Todo tool 改进</strong> - 简化 todo 格式并刷新 UI 以提高可靠性</p>
<p><strong>Chrome DevTools MCP server</strong> - 将 Chrome DevTools Protocol 添加到 MCP registry</p>
<p><strong>Model 清理</strong> - 删除过时的 models</p>
<h3 data-id="heading-14">Bug 修复</h3>
<ul>
<li>修复 Codex models 的 API 请求处理</li>
</ul>
<h2 data-id="heading-15">12月17日 v0.36.6</h2>
<h3 data-id="heading-16">新功能</h3>
<p><strong>Gemini 3 Flash model</strong> - 添加对 Gemini 3 Flash 的支持</p>
<h3 data-id="heading-17">改进</h3>
<p><strong>Agent 就绪信号</strong> - 在 readiness 报告中扩展 agent 就绪信号</p>
<h3 data-id="heading-18">Bug 修复</h3>
<ul>
<li>修复过于严格的过滤，允许常见的只读 git 命令</li>
<li>修复 WSL 上的复制/粘贴问题</li>
<li>修复 /readiness 报告中的仓库去重问题</li>
</ul>
<h2 data-id="heading-19">12月13日 v0.36.2</h2>
<h3 data-id="heading-20">新功能</h3>
<p><strong>GPT-5.2 model</strong> - 添加对 GPT-5.2 model 的支持</p>
<p><strong>MCP tool 启用/禁用</strong> - 添加按 server 启用/禁用单个 MCP tools 的能力</p>
<h2 data-id="heading-21">12月10日 v0.36.0</h2>
<h3 data-id="heading-22">新功能</h3>
<p><strong>Droid 创建中的 MCP tools</strong> - MCP tools 现在在自定义 droid 创建和编辑流程中显示</p>
<h3 data-id="heading-23">Bug 修复</h3>
<ul>
<li>修复文件名与元数据名称不匹配时的 droid 删除问题</li>
<li>标准化 droid 创建/编辑流程中的帮助文本位置和格式</li>
<li>将 reasoning_effort 添加到 stream-json 系统初始化事件</li>
</ul>
<h2 data-id="heading-24">12月8日 v0.33.0</h2>
<h3 data-id="heading-25">Bug 修复</h3>
<ul>
<li>修复 autonomy mode 在 tool 确认时未正确设置的问题</li>
<li>通过字符计数改进 @-tagged 文件截断，以防止上下文溢出</li>
<li>使用可关闭通知更新 Opus 4.5 定价</li>
<li>将 Figma MCP server 恢复到 registry</li>
</ul>
<h2 data-id="heading-26">12月5日 v0.32.0</h2>
<h3 data-id="heading-27">Bug 修复</h3>
<ul>
<li>按 ESC 关闭扩展的 tool 结果视图</li>
<li>改进输入框光标在换行时的上/下移动</li>
<li>修复 Windows 粘贴问题</li>
<li>修复 npm run format 与 Windows 传统 format 命令在 denylist 中的冲突</li>
<li>修复 Microsoft MCP servers 的身份验证问题</li>
<li>/readiness 命令现在默认启用</li>
</ul>
<h2 data-id="heading-28">12月4日 v0.31.0</h2>
<h3 data-id="heading-29">新功能</h3>
<p><strong>GPT-5.1-Codex-Max model</strong> - 添加对 GPT-5.1-Codex-Max model 的支持</p>
<p><strong>图像压缩</strong> - 图像现在在上传前压缩以减少带宽</p>
<p><strong>IDE 自动连接设置</strong> - 添加从外部 terminals 自动连接到 IDE 的设置</p>
<p><strong>禁用 hooks 标志</strong> - 添加 --no-hooks 标志以禁用 hooks 执行</p>
<h3 data-id="heading-30">Bug 修复</h3>
<ul>
<li>改进 Droid docs 搜索</li>
<li>长 Execute tool 命令现在在 UI header 中截断</li>
<li>修复磁盘上的图像在上传后未被清除的问题</li>
<li>修复 thinking level 在对话中途更改的问题，通过在每个 agent turn 中锁定它</li>
<li>修复 review preset 项对未选中项使用错误颜色的问题</li>
<li>修复输入框处理多宽度字符（如 CJK 和 emoji）的问题</li>
<li>修复 @ 建议菜单打开时的左/右箭头键导航</li>
<li>捆绑代码签名的 ripgrep 二进制文件以提高安全性和可靠性</li>
</ul>
<h2 data-id="heading-31">12月3日 v0.30.0</h2>
<h3 data-id="heading-32">新功能</h3>
<p><strong>搜索隐藏文件</strong> - Grep 和 Glob tools 现在在搜索结果中包含隐藏文件</p>
<p><strong>会话搜索</strong> - 向会话选择器添加搜索功能，以快速查找会话</p>
<p><strong>图像指示器</strong> - 用户消息现在在附加图像时显示图像指示器</p>
<h3 data-id="heading-33">Bug 修复</h3>
<ul>
<li>修复某些文件操作的 EPERM 权限错误 - Windows 文件重命名重试逻辑</li>
<li>修复 Ghostty terminal 中 /review 和 /bg-process 命令的 ESC 键导航</li>
<li>MCP registry 更新</li>
</ul>
<h2 data-id="heading-34">12月2日 v0.28.1</h2>
<h3 data-id="heading-35">改进</h3>
<p><strong>证书缓存</strong> - 证书现在在启动时缓存以加快加载速度</p>
<p><strong>图像上传限制</strong> - 对话图像现在受到限制，以防止上传大图像时出现 413 错误</p>
<p><strong>MCP registry helper</strong> - 在 MCP registry 中为 STDIO servers 添加注释，解释安装要求</p>
<h3 data-id="heading-36">Bug 修复</h3>
<ul>
<li>修复 assistant 消息中断后 thinking block 中的无效签名</li>
<li>修复异步加载时 settings 菜单未显示所有选项的问题</li>
</ul>
<h2 data-id="heading-37">12月1日 v0.28.0</h2>
<h3 data-id="heading-38">新功能</h3>
<p><strong>显示所有会话</strong> - 跨目录查看和管理所有会话</p>
<p><strong>窗口化斜杠命令导航</strong> - 改进斜杠命令菜单中的导航，支持窗口化滚动</p>
<p><strong>改进 thinking 显示</strong> - 重构 thinking block 渲染以提高清晰度</p>
<p><strong>Figma MCP server</strong> - 添加对 Figma MCP server 集成的支持</p>
<h3 data-id="heading-39">Bug 修复</h3>
<ul>
<li>修复 Cerebras 风格的上下文长度超出错误检测</li>
<li>修复重复的 spec modes 和输入上方的双空行</li>
<li>为 Opus model 添加促销价格标签</li>
<li>修复 /install-github-app 命令问题</li>
</ul>
<h2 data-id="heading-40">11月28日 v0.27.4</h2>
<h3 data-id="heading-41">新功能</h3>
<p><strong>交错 thinking 支持</strong> - 在 streaming 期间显示多个 thinking blocks，包括带有安全消息的已编辑 thinking blocks</p>
<p><strong>显示 thinking 设置</strong> - 在主视图上显示 AI thinking/reasoning，在 /settings 中打开/关闭</p>
<p><strong>Hooks 始终启用</strong> - Hooks 功能现在永久启用，可通过 /hooks 命令使用</p>
<h3 data-id="heading-42">Bug 修复</h3>
<ul>
<li>修复 /model 菜单中的 ESC/Q 导航 - 按 ESC 或 Q 现在正确导航回上一级菜单，而不是关闭所有菜单</li>
<li>修复由 terminal 响应字节泄漏到 stdin 导致的 prompt 输入中出现垃圾字符</li>
<li>修复 spec mode 中的 reasoning effort 显示，以正确反映实际使用的 reasoning effort</li>
<li>修复 OpenAI chat completions streaming 对 tool 调用的支持</li>
<li>通过更好的提示改进 Gemini 对 todo tool 的使用</li>
<li>修复 GLM-4.6 的 model warmup</li>
<li>修复 /install-github-app 命令问题</li>
</ul>
<h2 data-id="heading-43">11月25日 v0.27.2</h2>
<h3 data-id="heading-44">新功能</h3>
<p><strong>项目级 MCP 配置</strong> - 使用 .factory/mcp.json 在项目级别配置 MCP servers</p>
<p><strong>/ide 命令</strong> - 新命令用于管理 VS Code、Cursor 和 Windsurf IDE 集成。显示当前 extension 版本或提示安装</p>
<p><strong>自定义 models 中的额外参数</strong> - 向自定义 model 配置传递额外参数，例如 service_tier、temperature、top_p 等</p>
<h3 data-id="heading-45">Bug 修复</h3>
<ul>
<li>修复 task tool 在运行 subagents 时无限等待的问题</li>
<li>修复加载会话时扩展波浪号（~）路径的问题</li>
<li>改进 @ 搜索排名 - 完全匹配的文件名现在出现在顶部，使用 VSCode 风格的双列显示</li>
<li>删除自动创建 .factory/skills 文件夹</li>
<li>触发时显示 compacting 状态</li>
<li>合并 markdown 渲染（修复 spec mode 中缺失字符）</li>
<li>并行化 Windows 上的证书加载</li>
</ul>
<h2 data-id="heading-46">11月24日 v0.27.1</h2>
<h3 data-id="heading-47">新功能</h3>
<p><strong>改进 rewind 功能</strong> - 新的 /rewind 命令，以及速度和 UX 改进</p>
<p><strong>/install-github-app 命令</strong> - 新命令直接从 CLI 安装 Factory GitHub app</p>
<p><strong>MCP tool 响应中的图像</strong> - MCP tools 现在可以返回正确发送到 LLM 的图像</p>
<h3 data-id="heading-48">Bug 修复</h3>
<ul>
<li>升级到 bun 1.3.3</li>
<li>更安全的机制来检查 ripgrep 是否已安装</li>
<li>修复 gpt-5.1-codex reasoning</li>
<li>Shift+Backspace 像 Backspace 一样删除单个字符</li>
<li>修复 GLM4.6 作为 spec mode model</li>
<li>修复 exitSpecMode prompt</li>
<li>修复 subdroids 的自定义 models</li>
<li>防止启动期间的控制台日志</li>
<li>修复 Gemini 的 spec mode</li>
</ul>
<h2 data-id="heading-49">11月22日 v0.26.12</h2>
<h3 data-id="heading-50">新功能</h3>
<p><strong>/review 命令</strong> - 提供交互式 code review 工作流。以不同方式 review 代码更改：与 base branch 比较、review 特定 commits、检查未提交的更改或提供自定义 review 指令</p>
<h3 data-id="heading-51">Bug 修复</h3>
<ul>
<li>Gemini 3 Pro 现在使用更新的 0.8× 定价倍率 - 替换介绍性定价</li>
<li>MCP navigator 现在填充 terminal</li>
<li>更新 /resume 的路由以正确过滤到 /sessions</li>
<li>导航历史时将光标定位在开头</li>
<li>使 mcp navigator 中的所有视图全宽</li>
<li>修复 Windows 上的乱码字符渲染</li>
<li>统一 LLM 重试逻辑，并在 exec mode 中进行更多重试</li>
<li>删除已弃用的 Figma MCP server</li>
</ul>
<h2 data-id="heading-52">11月21日 v0.26.10</h2>
<h3 data-id="heading-53">新功能</h3>
<p><strong>MCP Registry 扩展</strong> - 添加 30+ 个新 MCP server 集成，包括开发工具（Playwright、Braintrust、Honeycomb）、数据库（Supabase、MongoDB、Prisma、Neon）、安全扫描（Snyk、Semgrep）等</p>
<h3 data-id="heading-54">Bug 修复</h3>
<ul>
<li>修复 turn 中途 model 更改的竞争条件</li>
<li>修复 bug report 命令</li>
<li>修复自定义 model 配置中重复 model IDs 的支持</li>
<li>修复 Windows 上的 PowerShell 命令执行</li>
</ul>
<h2 data-id="heading-55">11月20日 v0.26.8</h2>
<h3 data-id="heading-56">新功能</h3>
<p><strong>后台进程支持</strong> - 添加在 CLI 中运行和管理后台进程的支持。包括新的 bg-process 命令，用于列出、终止和清理进程，具有持久的进程状态跟踪</p>
<p><strong>MCP Registry 搜索</strong> - 向 MCP registry 列表视图（/mcp）添加搜索功能。直接在列表界面中键入以过滤可用的 MCP servers</p>
<h3 data-id="heading-57">Bug 修复</h3>
<ul>
<li>修复挂起/恢复 TUI 时的竞争条件和渲染问题（例如，打开外部编辑器时）</li>
<li>修复 grep tool 日志中的循环依赖问题</li>
</ul>
<h2 data-id="heading-58">11月19日 v0.26.7</h2>
<h3 data-id="heading-59">新功能</h3>
<p><strong>目录特定会话</strong> - 会话现在按目录存储，并在加载时自动切换到正确的工作目录。/sessions 命令仅显示在当前目录中创建的会话以及收藏的会话</p>
<p><strong>MCP 图像支持</strong> - MCP tools 现在可以返回发送到 LLM 进行分析的图像</p>
<p><strong>Subdroids 的自定义 Models</strong> - Subdroids 现在可以使用自定义 models，而不是从父会话继承</p>
<h3 data-id="heading-60">Bug 修复</h3>
<ul>
<li>修复 exec mode 中的控制台输出问题</li>
<li>修复 Gemini models 的 spec mode</li>
<li>修复 exit spec mode prompt 行为</li>
</ul>
<h2 data-id="heading-61">11月18日 v0.26.3</h2>
<h3 data-id="heading-62">新功能</h3>
<p><strong>默认启用 Skills</strong> - Skills 命令现在对所有用户启用</p>
<p><strong>Claude Code Hooks 自动迁移</strong> - 自动检测并从 Claude Code CLI 导入 hooks，并提供交互式提示。智能翻译将 bash_tool 转换为 Execute，将 CLAUDE_CWD 转换为 DROID_CWD，防止重复并跟踪迁移状态</p>
<p><strong>@ 建议改进</strong> - 现在除了文件外还包括文件夹，具有更好的 UI 和性能</p>
<h3 data-id="heading-63">Bug 修复</h3>
<ul>
<li>修复 GLM4.6 配置问题，导致其无法在 spec mode 中工作</li>
<li>修复 warmup API 调用</li>
<li>Shift+Backspace 现在像 Backspace 一样删除单个字符</li>
</ul>
<h2 data-id="heading-64">11月14日 v0.26.0</h2>
<h3 data-id="heading-65">新功能</h3>
<p><strong>Skills 系统</strong> - 与 Claude Code 兼容的 .factory/skills 支持模块化、基于 prompt 的功能。使用 /skills 命令管理 skills 并从 .claude/skills 目录导入</p>
<p><strong>会话收藏</strong> - 新的 /favorite 命令用于 pin/unpin 会话，将活动项目保持在会话列表顶部</p>
<p><strong>增强 Bug 报告</strong> - /bug 命令现在自动压缩会话上下文，上传到 Factory，并自动返回可共享的报告 ID</p>
<p><strong>更清晰的 Diff Viewer</strong> - 改进的 UI，使用水平线而不是边框</p>
<h3 data-id="heading-66">Bug 修复</h3>
<ul>
<li>始终提示接受或拒绝生成的 specs，并将正确的标签传递给 UI 流程</li>
<li>droid spec 现在将文件写入预期的默认路径，无需手动覆盖</li>
<li>修复 autonomy 处理，以便 MCP tools 在每个会话中尊重配置的确认级别</li>
<li>改进 pre-update 逻辑中的错误处理</li>
<li>将 Axiom MCP server 添加到 registry</li>
</ul>
<h2 data-id="heading-67">11月13日 v0.25.0</h2>
<h3 data-id="heading-68">新功能</h3>
<p><strong>增强 Hooks 系统</strong> - 添加 7 个新 hook 类型以实现完整的生命周期控制：</p>
<ul>
<li><strong>UserPromptSubmit</strong> - 在提示发送到 agent 之前修改或验证提示</li>
<li><strong>Stop</strong> - 在 agent 完成时执行自定义逻辑（例如，指标收集）</li>
<li><strong>SubagentStop</strong> - 跟踪和记录 subagent 任务完成</li>
<li><strong>PreCompact</strong> - 在对话 compaction 之前运行自定义逻辑（如果需要，可以阻止 compaction）</li>
<li><strong>SessionStart</strong> - 初始化会话并注入环境变量</li>
<li><strong>SessionEnd</strong> - 会话结束时的清理任务（在 logout、quit、Ctrl+C 时触发）</li>
</ul>
<p><strong>MCP Tool Autonomy Levels</strong> - 对 MCP tool 确认的精细控制：低 autonomy 需要对只读 MCP tools 进行确认，高 autonomy 需要对所有 MCP tool 调用进行确认</p>
<p><strong>Execute Tool Streaming</strong> - 长时间运行的命令现在实时显示输出的最后两个非空行。不再想知道 Droid 是否卡住或缓慢</p>
<h3 data-id="heading-69">Bug 修复</h3>
<ul>
<li>修复 hooks UI 中的粘贴处理 - 粘贴命令时不再有转义序列伪影</li>
<li>修复对话 compaction 后的消息 ID 对齐</li>
<li>修复切换 providers 重试时未完成的 tool 使用被清除的问题</li>
<li>修复 GPT models 的 markdown prompt 使用</li>
<li>修复窄 terminal 窗口的 /mcp 渲染</li>
<li>修复挂起 TUI 时的括号粘贴处理</li>
<li>身份验证错误现在直接在 CLI 中显示，并带有清晰的错误消息</li>
</ul>
<h2 data-id="heading-70">11月12日 v0.24.0</h2>
<h3 data-id="heading-71">新功能</h3>
<p><strong>Hooks</strong> - 引入强大的 hooks 系统，允许您在 tool 执行之前/之后运行自定义 scripts，具有可配置的退出代码以实现不同的行为（成功、警告、阻止、中止）- [实验性 - 在 /settings 中打开]</p>
<p><strong>交互式 Spec 编辑</strong> - 添加在执行前交互式编辑 specs 的能力</p>
<p><strong>Prompt Cache Warmup</strong> - 在您键入时添加 prompt-cache warmup 以获得更快的响应</p>
<h3 data-id="heading-72">Bug 修复</h3>
<ul>
<li>修复 model 切换以在需要时正确处理对话 compaction</li>
<li>修复 spec mode tab 循环以调整 reasoning levels</li>
<li>修复挂起 TUI 时的括号粘贴</li>
<li>修正 ApplyPatch tool diff 显示中的行号</li>
<li>消除 ripgrep 路径解析中的竞争条件</li>
<li>各种 agent 循环稳定性改进</li>
<li>Tool 执行现在正确尊重 autonomy mode</li>
<li>应用 Figma MCP server 兼容性的解决方法</li>
</ul>
<h2 data-id="heading-73">11月10日 v0.23.0</h2>
<h3 data-id="heading-74">新功能</h3>
<p><strong>Markdown 表格渲染</strong> - CLI 现在正确渲染 markdown 表格，以更好地显示结构化数据和文档</p>
<p><strong>固定 todo 计划</strong> - 固定重要的 todo 项以保持可见并在长时间运行的会话期间跟踪任务</p>
<p><strong>MCP tool 结果格式化</strong> - 改进 MCP tool 结果的格式化，输出更清晰、更易读</p>
<h3 data-id="heading-75">Bug 修复</h3>
<ul>
<li>修复 chat completion APIs 的 thinking block 支持，以在兼容 models 中启用扩展推理</li>
<li>修复 baseline 版本在更新时恢复到非 baseline 构建的问题</li>
<li>修复 droid exec 命令中的 autonomy mode 处理，以实现更可靠的执行</li>
<li>恢复 Windows 上的 Ctrl+T 键盘快捷键功能</li>
</ul>
<h2 data-id="heading-76">11月7-8日 v0.22.14</h2>
<h3 data-id="heading-77">新功能</h3>
<p><strong>Tab 键循环 reasoning levels</strong> - 使用 Tab 键在不同 reasoning levels 之间导航以获得更好的控制</p>
<p><strong>扩展 bash mode 输出</strong> - Transcript 视图现在扩展并显示 bash 命令输出以提高可见性</p>
<h3 data-id="heading-78">Bug 修复</h3>
<ul>
<li>修复 droid exec 的 MCP tool 发现，以便 tools 在 --list-tools 中正确显示并通过验证</li>
<li>修复 diff 视图以换行以更好地读取长行</li>
<li>修复 MCP servers 的 OAuth 刷新</li>
<li>修复 transcript 视图中的 markdown 渲染 bug</li>
<li>修复 TUI 中的消息取消处理</li>
<li>修复 completions 中的 prompt cache key 处理</li>
<li>恢复 Windows 上的 Ctrl+T 键盘快捷键</li>
</ul>
<h2 data-id="heading-79">11月6日 v0.22.12</h2>
<h3 data-id="heading-80">新功能</h3>
<p><strong>Quit/exit 别名</strong> - 键入 'quit' 或 'exit' 命令以退出会话</p>
<h3 data-id="heading-81">Bug 修复</h3>
<ul>
<li>收集所有 AGENTS.md 和 CLAUDE.md 文件用于系统提醒</li>
<li>修复通过 UI 添加 servers 时的 MCP server 参数解析</li>
<li>改进系统诊断实用程序以更好地进行故障排除</li>
<li>清理和动态渲染待处理的 tools，以明确 Droid 没有卡住</li>
</ul>
<h2 data-id="heading-82">11月5日 v0.22.11</h2>
<h3 data-id="heading-83">新功能</h3>
<p><strong>Context7 MCP server</strong> - 将 Context7 MCP server 添加到 MCP registry</p>
<h3 data-id="heading-84">Bug 修复</h3>
<ul>
<li>改进 droid exec 运行类型跟踪</li>
<li>改进 MCP 客户端信息处理</li>
</ul>
<h2 data-id="heading-85">11月4日 v0.22.10</h2>
<h3 data-id="heading-86">新功能</h3>
<p><strong>OAuth Discovery</strong> - 自动发现 OAuth providers 以简化 MCP 的身份验证设置</p>
<p><strong>OpenAI Reasoning Summaries</strong> - 在扩展会话视图中显示 OpenAI 的扩展 reasoning 摘要</p>
<h3 data-id="heading-87">Bug 修复</h3>
<ul>
<li>修复 terminal 会话中的复制粘贴行为</li>
<li>改进超时处理以实现更可靠的操作</li>
<li>增强 Windows 兼容性</li>
<li>默认启用自定义 droids</li>
<li>改进错误日志和诊断</li>
</ul>
<h2 data-id="heading-88">11月1日 v0.22.9</h2>
<h3 data-id="heading-89">新功能</h3>
<p><strong>MCP Registry</strong> - 添加精选的 MCP servers 选择，以便轻松发现和设置</p>
<p><strong>Tool 权限支持</strong> - 在 stream-jsonrpc mode 中实现请求 tool 权限流程，支持多个并发 tool 确认</p>
<p><strong>会话恢复</strong> - 退出时显示 resume 命令（Ctrl+C 或 /quit），新增 -r、--resume 标志以继续会话</p>
<p><strong>Thinking Traces 显示</strong> - 添加 UI 组件以在扩展会话视图中显示 thinking blocks</p>
<h3 data-id="heading-90">Bug 修复</h3>
<ul>
<li>修复 CLI completion 声音，通过将嵌入的声音文件提取到主机文件系统，使其可供外部 shell 命令访问</li>
<li>添加 tool 取消后用户消息中的 tool 使用</li>
<li>为不支持 AVX2 SIMD 指令的 x64 CPUs（2013 年之前）添加 baseline 构建</li>
<li>更新静态拆分逻辑以使用文本消息作为稳定检查点，减少渲染期间的闪烁</li>
<li>修复 delta.extra_content.google 中 Gemini thinking 内容的存储和发送</li>
<li>由于成功率低（~80%），删除 MultiEdit tool</li>
<li>使用乐观 JSON 解析添加从格式错误的可选参数中恢复</li>
</ul>
<h2 data-id="heading-91">10月31日 v0.22.7</h2>
<h3 data-id="heading-92">新功能</h3>
<p><strong>Streaming 响应中的 reasoning 字段支持</strong> - 添加对在 chat completion streaming chunks 中显示 reasoning 字段的支持，用于提供扩展 reasoning 的 models</p>
<p><strong>从 Claude 导入已恢复</strong> - 在 droids 菜单中重新启用"从 Claude 导入"选项，以便更轻松地迁移对话</p>
<h3 data-id="heading-93">Bug 修复</h3>
<ul>
<li>修复 MCP 状态指示器，仅在实际配置 MCP servers 时显示</li>
<li>修复消息列表闪烁</li>
<li>添加对添加 MCP servers 时自定义 headers 的支持</li>
<li>修复声音文件未包含在 SEA 二进制版本中的问题</li>
<li>修复 Ctrl+C 中断消息仅显示给用户而不出现在日志中以获得更清晰的输出</li>
<li>解决 tool 取消后 tool 使用错误地出现在用户消息中的问题</li>
</ul>
<h2 data-id="heading-94">10月30日 v0.22.6</h2>
<h3 data-id="heading-95">新功能</h3>
<p><strong>MCP 改版</strong> - Model Context Protocol 实现的完全改革（文档已更新）</p>
<h3 data-id="heading-96">Bug 修复</h3>
<ul>
<li>修复 OpenAI organization 字段的问题</li>
<li>在 Droids（subagents）菜单中恢复导入（I）选项</li>
</ul>
<h2 data-id="heading-97">10月29日 v0.22.5</h2>
<h3 data-id="heading-98">Bug 修复</h3>
<p><strong>默认 Model 行为</strong> - 改进默认 model 行为</p>
<h2 data-id="heading-99">10月28日 v0.22.4</h2>
<h3 data-id="heading-100">Bug 修复</h3>
<p><strong>恢复报告预览</strong> - 重新启用 reliability 报告的 HTML 预览，以便您可以直接在 web 中查看它们</p>
<p><strong>修复 --help 文本</strong> - 运行 droid exec --help 之前为在 streaming mode 中使用 droid exec 提供不正确的信息。现在已更新为包含正确的标志名称和正确的说明</p>
<h2 data-id="heading-101">10月21-25日 v0.22.3</h2>
<h3 data-id="heading-102">新功能和增强</h3>
<p><strong>详细 transcript 视图（Ctrl+O）</strong> - 按 Ctrl+O 查看全面的 tool 执行详细信息，包括所有 tool 类型的完整细分，包括 Execute、Edit、MultiEdit、Create 等</p>
<p><strong>可自定义的 completion 声音</strong> - 配置命令完成时的声音通知，支持在 focus mode 和自定义声音文件路径中使用不同的声音</p>
<p><strong>Terminal 设置支持</strong> - 添加对 Warp、iTerm2 和 macOS Terminal 的自动设置支持，具有自动 terminal 指示器以改进集成</p>
<p><strong>PowerShell 更新</strong> - 现在使用 pwsh.exe 以在 Windows 系统上获得更好的 PowerShell 兼容性和可靠性</p>
<p><strong>拖放图像支持</strong> - 通过拖放将图像附加到 CLI 会话，以便更轻松地进行多模态交互</p>
<p><strong>Subagents 中的自定义 models</strong> - 添加在通过 Task tool 执行 subagents 时使用自定义 models 的支持</p>
<p><strong>自定义 droid 描述</strong> - 将自定义 droid 描述移至 Task tool 以获得更好的组织和可用性</p>
<p><strong>droid exec 自定义 model 支持</strong> - 添加对 droid exec 会话中自定义 models 的支持</p>
<h3 data-id="heading-103">Bug 修复和稳定性</h3>
<ul>
<li>解决 prompt caching 问题以提高性能并降低成本</li>
<li>添加 model ID 日志记录到 CLI tool 执行以获得更好的可观察性</li>
<li>限制 Ctrl+O 视图中渲染的消息以提高大 transcripts 的性能</li>
<li>修复声音文件未包含在 SEA 二进制版本中的问题</li>
<li>修复导致意外行为的 readonly 值更改问题</li>
<li>修复 ExitSpecMode 闪烁问题以获得更流畅的用户体验</li>
<li>删除 settings 中的重复自定义 models header</li>
<li>改进对 legacy 会话的会话持久性以保持向后兼容性</li>
<li>修复 Windows 系统上的无限渲染问题</li>
<li>修复 400 错误处理和验证</li>
<li>添加 model 验证错误消息以更好地进行调试</li>
<li>修复证书加载时间，以在日志初始化后发生</li>
</ul>
<h2 data-id="heading-104">10月14-20日 v0.21.3</h2>
<h3 data-id="heading-105">新功能和增强</h3>
<p><strong>MCP OAuth 支持</strong> - 在 TUI 中为 Model Context Protocol 添加 OAuth 身份验证支持，以实现安全的 server 连接</p>
<p><strong>系统证书支持</strong> - 添加对在 Windows 和 macOS 上加载系统证书的支持，以及额外的 Windows 系统证书支持</p>
<p><strong>模糊搜索实现</strong> - 新的模糊搜索，以改进 CLI 命令和选项发现</p>
<p><strong>Rewind fork 工作流</strong> - 添加从对话会话中的先前点 rewind 和 fork 的能力</p>
<p><strong>Bug 报告增强</strong> - 向 bug 报告添加版本、OS 和 shell 信息，以更好地进行故障排除</p>
<p><strong>Subagent tool 的实时更新</strong> - 使用 Task tool 时添加实时进度更新</p>
<p><strong>增强自定义 droid prompts</strong> - 改进 prompts 以鼓励更主动地使用自定义 droids</p>
<p><strong>Droid Shield 可选设置</strong> - 使 Droid Shield 成为可配置设置，并支持切换</p>
<h3 data-id="heading-106">Bug 修复和稳定性</h3>
<ul>
<li>将 session_id 添加到 stream-json 输出格式以更好地进行跟踪和调试</li>
<li>增强身份验证流程以实现更流畅的 onboarding</li>
<li>通过删除冗余的 onboarding 步骤简化首次运行体验</li>
<li>修复阻止身份验证的 OAuth 回调 server 端口冲突问题</li>
<li>修复导致 TLS 错误的证书加载时间问题</li>
<li>改进错误元数据日志记录以更好地进行调试</li>
<li>修复不同 shell 环境中的 terminal 设置问题</li>
<li>当 ripgrep（rg）在 PATH 中不可用时，提供更好的错误消息</li>
<li>改进对文件路径中损坏的 unicode 规范化的处理</li>
<li>修复 impact level 默认值处理</li>
</ul>
<h2 data-id="heading-107">9月30日 - 10月13日 v0.19.8</h2>
<h3 data-id="heading-108">新功能和增强</h3>
<p><strong>droid exec Slack 集成</strong> - 向 droid exec 添加 slack_post_message tool，用于向 Slack channels 发布更新</p>
<p><strong>droid exec streaming JSON 输入 mode</strong> - 为多 turn exec 会话添加 streaming JSON 输入 mode，以实现更好的自动化工作流</p>
<p><strong>droid exec tool 配置</strong> - 添加在 droid exec 会话中启用/禁用特定 tools 的能力</p>
<p><strong>droid exec 预创建会话 IDs</strong> - 添加对 droid exec 中预创建会话 IDs 的支持，以实现更好的会话管理</p>
<p><strong>初始 prompt 支持</strong> - 添加通过命令行使用初始 prompt 启动 TUI 的支持</p>
<p><strong>GLM-4.6 支持</strong> - 添加 GLM-4.6 的 LLM proxy 支持，包括 Fireworks、Baseten 和 DeepInfra providers</p>
<p><strong>Azure OpenAI 对 GPT-5 的支持</strong> - 在 TUI 中为 GPT-5 Codex 添加 Azure OpenAI 支持</p>
<p><strong>自定义 droid 生成</strong> - 添加使用 LLM 自动生成自定义 droids 以加快设置</p>
<p><strong>MCP 可流式传输 HTTP servers</strong> - 添加对可流式传输 HTTP MCP servers 的支持</p>
<p><strong>Model selector 刷新</strong> - 更新 model selector UI，改进组织和图像支持警告</p>
<p><strong>Tab 键自动完成</strong> - Tab 键现在自动完成自定义命令而不提交，以获得更好的 UX</p>
<h3 data-id="heading-109">Bug 修复和稳定性</h3>
<p><strong>droid exec 会话继续修复</strong> - 修复 droid exec 以正确继续现有会话，而不是覆盖会话数据</p>
<ul>
<li>UI 中 Codex models 的动态 reasoning 标签</li>
<li>AGENTS.md 源路径现在显示在 settings 中以提高透明度</li>
<li>当自定义 model JSON 配置损坏时提供更好的错误消息</li>
<li>当自动更新不可用时的手动更新说明</li>
<li>修复 task subagents 在中止时正确终止</li>
<li>修复 Windows 系统上的文件重命名重试逻辑</li>
<li>修复 Windows 上的反斜杠渲染问题</li>
<li>对自定义 subagents 可靠性进行重大改进</li>
<li>修复 task tool subagents prompt 以实现更好的执行</li>
<li>在 spec mode 中不要在取消的文件编辑时停止 agent</li>
<li>在执行 ripgrep 之前验证工作目录是否存在</li>
<li>修复 subagents 从 TUI 父会话继承 model</li>
<li>截断大 MCP tool 结果以防止上下文溢出</li>
<li>使用 Fireworks cached input 修复 /cost 命令</li>
<li>为更好的跟踪向 LLM 请求添加 user-agent header</li>
<li>锁定文件系统权限以提高安全性</li>
<li>修复 spec mode 中失败编辑调用的渲染</li>
<li>修复 compaction 逻辑并在没有 tool 结果的情况下重试</li>
<li>在 compaction/caching 之前应用输出转换</li>
<li>持久化会话的 token 使用情况以准确跟踪成本</li>
<li>修复 /new 命令以正确重置 timer 和 sessionId</li>
<li>修复没有 tool 结果的 compaction 重试</li>
<li>使用 unicode 规范化回退修复 screenshot 读取</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item>  </channel></rss>