<?xml version="1.0" encoding="UTF-8"?><rss version="2.0">  <channel>      <title>掘金文章推荐</title>      <link>https://juejin.cn/recommended?sort=newest</link>      <description>一个帮助开发者成长的社区</description>      <generator>python juejin_recom.py @Pi20</generator>      <item>    <title><![CDATA[Vue-响应式原理深度解析（含手写源码）]]></title>    <link>https://juejin.cn/post/7602463463105249326</link>    <guid>https://juejin.cn/post/7602463463105249326</guid>    <pubDate>2026-02-03T10:07:34.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602463463105249326" data-draft-id="7602303923171393545" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Vue-响应式原理深度解析（含手写源码）"/> <meta itemprop="keywords" content="前端,JavaScript,面试"/> <meta itemprop="datePublished" content="2026-02-03T10:07:34.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="发现一只大呆瓜"/> <meta itemprop="url" content="https://juejin.cn/user/180747382561607"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Vue-响应式原理深度解析（含手写源码）
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/180747382561607/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    发现一只大呆瓜
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T10:07:34.000Z" title="Tue Feb 03 2026 10:07:34 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    1
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h3 data-id="heading-0">前言</h3>
<p>双向数据绑定是 Vue 的灵魂特性。它将 <strong>Model（数据层）</strong> 与 <strong>View（视图层）</strong> 紧密相连：JS 逻辑更新 Model，视图自动重绘；用户操作 View，数据自动同步。本文将带你从源码级别对比 Vue 2 与 Vue 3 在响应式实现上的异同。</p>
<h2 data-id="heading-1">一、 Vue 2：数据劫持 + 发布订阅</h2>
<h3 data-id="heading-2">1. 核心原理</h3>
<p>Vue 2 基于 <code>Object.defineProperty</code> 实现数据劫持，通过 <strong>Observer（监听器）</strong> 、<strong>Compile（解析器）</strong> 和 <strong>Watcher（订阅者）</strong> 的配合完成。</p>
<h3 data-id="heading-3">2. 关键步骤</h3>
<ol>
<li>
<p><strong>数据劫持 (Observer)</strong> ：遍历 <code>data</code> 属性，利用 <code>Object.defineProperty</code> 注入 <code>getter</code>（依赖收集）和 <code>setter</code>（分发更新）。</p>
</li>
<li>
<p><strong>模板解析 (Compile)</strong> ：解析指令（如 <code>v-model</code>）和插值表达式（<code>{{}}</code>），为每个绑定点创建一个 <strong>Watcher</strong>。</p>
</li>
<li>
<p><strong>依赖收集 (Dep)</strong> ：每个属性对应一个 <code>Dep</code> 容器。读取属性时，将对应的 Watcher 存入 Dep。</p>
</li>
<li>
<p><strong>派发更新 (Watcher)</strong> ：修改数据时会触发 <code>setter</code>，通知所有关联的 Watcher 执行 <code>update</code> 方法更新 DOM。</p>
</li>
</ol>
<h3 data-id="heading-4">3. 源码仿真实现</h3>
<pre><code class="hljs language-html" lang="html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"zh-CN"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Vue2 响应式原理简易实现<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  <span class="hljs-comment">&lt;!-- 测试模板 --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>{{ message }}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"message"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>年龄：{{ age }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"vm.age++"</span>&gt;</span>年龄+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    <span class="hljs-comment">//  1. 依赖收集器 Dep：管理所有 Watcher，数据变化时通知更新 </span>
    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dep</span> {
      <span class="hljs-title function_">constructor</span>(<span class="hljs-params"/>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">subs</span> = []; <span class="hljs-comment">// 存储订阅者（Watcher 实例）</span>
      }

      <span class="hljs-comment">// 添加订阅者</span>
      <span class="hljs-title function_">addSub</span>(<span class="hljs-params">sub</span>) {
        <span class="hljs-keyword">if</span> (sub &amp;&amp; sub.<span class="hljs-property">update</span>) { <span class="hljs-comment">// 确保是合法的 Watcher</span>
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">subs</span>.<span class="hljs-title function_">push</span>(sub);
        }
      }

      <span class="hljs-comment">// 通知所有订阅者更新</span>
      <span class="hljs-title function_">notify</span>(<span class="hljs-params"/>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">subs</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">sub</span> =&gt;</span> sub.<span class="hljs-title function_">update</span>());
      }
    }

    <span class="hljs-comment">//  2. 数据劫持器 Observer：劫持 data 所有属性的 get/set </span>
    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Observer</span> {
      <span class="hljs-title function_">constructor</span>(<span class="hljs-params">data</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">observe</span>(data);
      }

      <span class="hljs-comment">// 遍历数据对象，劫持所有属性</span>
      <span class="hljs-title function_">observe</span>(<span class="hljs-params">data</span>) {
        <span class="hljs-keyword">if</span> (!data || <span class="hljs-keyword">typeof</span> data !== <span class="hljs-string">'object'</span>) {
          <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 非对象直接返回</span>
        }

        <span class="hljs-comment">// 遍历对象的所有属性</span>
        <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(data).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> {
          <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">defineReactive</span>(data, key, data[key]);
        });
      }

      <span class="hljs-comment">// 核心：用 Object.defineProperty 劫持单个属性</span>
      <span class="hljs-title function_">defineReactive</span>(<span class="hljs-params">obj, key, value</span>) {
        <span class="hljs-keyword">const</span> dep = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dep</span>(); <span class="hljs-comment">// 每个属性对应一个 Dep</span>
        <span class="hljs-keyword">const</span> that = <span class="hljs-variable language_">this</span>; <span class="hljs-comment">// 保存 Observer 实例的 this</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">observe</span>(value); <span class="hljs-comment">// 递归劫持子属性（处理嵌套对象）</span>

        <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, key, {
          <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 可枚举</span>
          <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 可配置</span>
          <span class="hljs-comment">// 读取属性时触发：收集依赖</span>
          <span class="hljs-title function_">get</span>(<span class="hljs-params"/>) {
            <span class="hljs-comment">// Dep.target 是当前正在执行的 Watcher，添加到 Dep 中</span>
            <span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span> &amp;&amp; dep.<span class="hljs-title function_">addSub</span>(<span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span>);
            <span class="hljs-keyword">return</span> value;
          },
          <span class="hljs-comment">// 赋值属性时触发：通知更新</span>
          <span class="hljs-title function_">set</span>(<span class="hljs-params">newValue</span>) {
            <span class="hljs-keyword">if</span> (newValue === value) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 值未变化则不处理</span>
            value = newValue;
            that.<span class="hljs-title function_">observe</span>(newValue); <span class="hljs-comment">// 使用保存的 that 调用 observe</span>
            dep.<span class="hljs-title function_">notify</span>(); <span class="hljs-comment">// 通知所有 Watcher 更新</span>
          }
        });
      }
    }

    <span class="hljs-comment">//  3. 订阅者 Watcher：连接 Observer 和 Compile，负责更新 DOM </span>
    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Watcher</span> {
      <span class="hljs-comment">/**
       * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Object</span>} <span class="hljs-variable">vm</span> - Vue 实例
       * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">expr</span> - data 中的属性名（如 'message'）
       * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Function</span>} <span class="hljs-variable">cb</span> - 更新 DOM 的回调函数
       */</span>
      <span class="hljs-title function_">constructor</span>(<span class="hljs-params">vm, expr, cb</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span> = vm;
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">expr</span> = expr;
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">cb</span> = cb;
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">oldValue</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getOldValue</span>(); <span class="hljs-comment">// 记录旧值</span>
      }

      <span class="hljs-comment">// 获取旧值：触发 get 方法，完成依赖收集</span>
      <span class="hljs-title function_">getOldValue</span>(<span class="hljs-params"/>) {
        <span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span> = <span class="hljs-variable language_">this</span>; <span class="hljs-comment">// 将当前 Watcher 挂载到 Dep.target</span>
        <span class="hljs-keyword">const</span> oldValue = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getVal</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">expr</span>); <span class="hljs-comment">// 读取属性，触发 get</span>
        <span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 收集完依赖后清空</span>
        <span class="hljs-keyword">return</span> oldValue;
      }

      <span class="hljs-comment">// 解析属性路径（处理嵌套对象，如 'user.name'）</span>
      <span class="hljs-title function_">getVal</span>(<span class="hljs-params">vm, expr</span>) {
        <span class="hljs-keyword">return</span> expr.<span class="hljs-title function_">split</span>(<span class="hljs-string">'.'</span>).<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">data, currentKey</span>) =&gt;</span> {
          <span class="hljs-keyword">return</span> data[currentKey];
        }, vm.<span class="hljs-property">$data</span>);
      }

      <span class="hljs-comment">// 数据变化时执行：更新 DOM</span>
      <span class="hljs-title function_">update</span>(<span class="hljs-params"/>) {
        <span class="hljs-keyword">const</span> newValue = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getVal</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">expr</span>);
        <span class="hljs-keyword">if</span> (newValue !== <span class="hljs-variable language_">this</span>.<span class="hljs-property">oldValue</span>) {
          <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">cb</span>(newValue); <span class="hljs-comment">// 执行回调更新 DOM</span>
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">oldValue</span> = newValue; <span class="hljs-comment">// 更新旧值</span>
        }
      }
    }

    <span class="hljs-comment">//  4. 模板解析器 Compile：解析 v-model 和 {{}}，创建 Watcher </span>
    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Compile</span> {
      <span class="hljs-title function_">constructor</span>(<span class="hljs-params">el, vm</span>) {
        <span class="hljs-comment">// 获取挂载元素（支持选择器或 DOM 元素）</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">el</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isElementNode</span>(el) ? el : <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(el);
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span> = vm;
        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">el</span>) {
          <span class="hljs-comment">// 1. 将模板内容移到文档碎片中（减少 DOM 操作，提升性能）</span>
          <span class="hljs-keyword">const</span> fragment = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">node2Fragment</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">el</span>);
          <span class="hljs-comment">// 2. 解析模板中的指令和插值表达式</span>
          <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compile</span>(fragment);
          <span class="hljs-comment">// 3. 将解析后的碎片放回原元素</span>
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">el</span>.<span class="hljs-title function_">appendChild</span>(fragment);
        }
      }

      <span class="hljs-comment">// 判断是否是元素节点（如 div、input）</span>
      <span class="hljs-title function_">isElementNode</span>(<span class="hljs-params">node</span>) {
        <span class="hljs-keyword">return</span> node.<span class="hljs-property">nodeType</span> === <span class="hljs-number">1</span>;
      }

      <span class="hljs-comment">// 判断是否是指令（以 v- 开头）</span>
      <span class="hljs-title function_">isDirective</span>(<span class="hljs-params">attrName</span>) {
        <span class="hljs-keyword">return</span> attrName.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">'v-'</span>);
      }

      <span class="hljs-comment">// 将节点移到文档碎片</span>
      <span class="hljs-title function_">node2Fragment</span>(<span class="hljs-params">el</span>) {
        <span class="hljs-keyword">const</span> fragment = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createDocumentFragment</span>();
        <span class="hljs-keyword">let</span> firstChild;
        <span class="hljs-keyword">while</span> (firstChild = el.<span class="hljs-property">firstChild</span>) {
          fragment.<span class="hljs-title function_">appendChild</span>(firstChild); <span class="hljs-comment">// 移动节点（原节点会被移除）</span>
        }
        <span class="hljs-keyword">return</span> fragment;
      }

      <span class="hljs-comment">// 核心：解析文档碎片中的所有节点</span>
      <span class="hljs-title function_">compile</span>(<span class="hljs-params">fragment</span>) {
        <span class="hljs-keyword">const</span> childNodes = fragment.<span class="hljs-property">childNodes</span>;
        <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(childNodes).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">node</span> =&gt;</span> {
          <span class="hljs-comment">// 1. 处理元素节点（解析 v-model 等指令）</span>
          <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isElementNode</span>(node)) {
            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compileElement</span>(node);
          } 
          <span class="hljs-comment">// 2. 处理文本节点（解析 {{}} 插值）</span>
          <span class="hljs-keyword">else</span> {
            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compileText</span>(node);
          }
          <span class="hljs-comment">// 递归解析子节点（处理嵌套模板）</span>
          <span class="hljs-keyword">if</span> (node.<span class="hljs-property">childNodes</span> &amp;&amp; node.<span class="hljs-property">childNodes</span>.<span class="hljs-property">length</span>) {
            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compile</span>(node);
          }
        });
      }

      <span class="hljs-comment">// 解析元素节点（如 v-model）</span>
      <span class="hljs-title function_">compileElement</span>(<span class="hljs-params">node</span>) {
        <span class="hljs-keyword">const</span> attrs = node.<span class="hljs-property">attributes</span>;
        <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(attrs).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">attr</span> =&gt;</span> {
          <span class="hljs-keyword">const</span> attrName = attr.<span class="hljs-property">name</span>;
          <span class="hljs-comment">// 判断是否是指令</span>
          <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isDirective</span>(attrName)) {
            <span class="hljs-keyword">const</span> expr = attr.<span class="hljs-property">value</span>; <span class="hljs-comment">// 指令对应的数据属性（如 'message'）</span>
            <span class="hljs-keyword">const</span> [, directive] = attrName.<span class="hljs-title function_">split</span>(<span class="hljs-string">'-'</span>); <span class="hljs-comment">// 提取指令名（如 'model'）</span>
            <span class="hljs-comment">// 执行指令对应的更新方法</span>
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">compileUtil</span>[directive](node, <span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span>, expr);
          }
        });
      }

      <span class="hljs-comment">// 解析文本节点（{{}} 插值）</span>
      <span class="hljs-title function_">compileText</span>(<span class="hljs-params">node</span>) {
        <span class="hljs-keyword">const</span> textContent = node.<span class="hljs-property">textContent</span>;
        <span class="hljs-comment">// 正则匹配 {{xxx}} 格式</span>
        <span class="hljs-keyword">const</span> reg = <span class="hljs-regexp">/\{\{(.+?)\}\}/g</span>;
        <span class="hljs-keyword">if</span> (reg.<span class="hljs-title function_">test</span>(textContent)) {
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">compileUtil</span>.<span class="hljs-title function_">text</span>(node, <span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span>, textContent);
        }
      }

      <span class="hljs-comment">// 指令处理工具集</span>
      compileUtil = {
        <span class="hljs-comment">// 获取数据属性的值</span>
        <span class="hljs-title function_">getVal</span>(<span class="hljs-params">vm, expr</span>) {
          <span class="hljs-keyword">return</span> expr.<span class="hljs-title function_">split</span>(<span class="hljs-string">'.'</span>).<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">data, currentKey</span>) =&gt;</span> {
            <span class="hljs-keyword">return</span> data[currentKey];
          }, vm.<span class="hljs-property">$data</span>);
        },

        <span class="hljs-comment">// 设置数据属性的值（用于 v-model）</span>
        <span class="hljs-title function_">setVal</span>(<span class="hljs-params">vm, expr, value</span>) {
          <span class="hljs-keyword">return</span> expr.<span class="hljs-title function_">split</span>(<span class="hljs-string">'.'</span>).<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">data, currentKey, index, arr</span>) =&gt;</span> {
            <span class="hljs-keyword">if</span> (index === arr.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>) {
              <span class="hljs-keyword">return</span> data[currentKey] = value;
            }
            <span class="hljs-keyword">return</span> data[currentKey];
          }, vm.<span class="hljs-property">$data</span>);
        },

        <span class="hljs-comment">// 处理 v-model 指令</span>
        <span class="hljs-title function_">model</span>(<span class="hljs-params">node, vm, expr</span>) {
          <span class="hljs-keyword">const</span> updateFn = <span class="hljs-variable language_">this</span>.<span class="hljs-property">updater</span>.<span class="hljs-property">modelUpdater</span>;
          <span class="hljs-comment">// 1. 初始化：设置输入框默认值</span>
          <span class="hljs-title function_">updateFn</span>(node, <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getVal</span>(vm, expr));
          <span class="hljs-comment">// 2. 创建 Watcher：数据变化时更新输入框</span>
          <span class="hljs-keyword">new</span> <span class="hljs-title class_">Watcher</span>(vm, expr, <span class="hljs-function">(<span class="hljs-params">newValue</span>) =&gt;</span> {
            <span class="hljs-title function_">updateFn</span>(node, newValue);
          });
          <span class="hljs-comment">// 3. 监听输入框事件：输入内容同步到 data</span>
          node.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'input'</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
            <span class="hljs-keyword">const</span> newValue = e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>;
            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setVal</span>(vm, expr, newValue);
          });
        },

        <span class="hljs-comment">// 处理 {{}} 插值文本</span>
        <span class="hljs-title function_">text</span>(<span class="hljs-params">node, vm, expr</span>) {
          <span class="hljs-keyword">const</span> updateFn = <span class="hljs-variable language_">this</span>.<span class="hljs-property">updater</span>.<span class="hljs-property">textUpdater</span>;
          <span class="hljs-comment">// 替换 {{}} 为真实数据</span>
          <span class="hljs-keyword">const</span> content = expr.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\{\{(.+?)\}\}/g</span>, <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> {
            <span class="hljs-keyword">const</span> prop = args[<span class="hljs-number">1</span>].<span class="hljs-title function_">trim</span>();
            <span class="hljs-comment">// 创建 Watcher：数据变化时更新文本</span>
            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Watcher</span>(vm, prop, <span class="hljs-function">(<span class="hljs-params">newValue</span>) =&gt;</span> {
              <span class="hljs-title function_">updateFn</span>(node, <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getContentValue</span>(vm, expr));
            });
            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getVal</span>(vm, prop);
          });
          <span class="hljs-comment">// 初始化文本内容</span>
          <span class="hljs-title function_">updateFn</span>(node, content);
        },

        <span class="hljs-comment">// 获取插值文本的完整内容（处理多个 {{}} 情况）</span>
        <span class="hljs-title function_">getContentValue</span>(<span class="hljs-params">vm, expr</span>) {
          <span class="hljs-keyword">return</span> expr.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\{\{(.+?)\}\}/g</span>, <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getVal</span>(vm, args[<span class="hljs-number">1</span>].<span class="hljs-title function_">trim</span>());
          });
        },

        <span class="hljs-comment">// DOM 更新方法集</span>
        <span class="hljs-attr">updater</span>: {
          <span class="hljs-comment">// 更新 v-model 指令的 DOM（输入框值）</span>
          <span class="hljs-title function_">modelUpdater</span>(<span class="hljs-params">node, value</span>) {
            node.<span class="hljs-property">value</span> = value;
          },
          <span class="hljs-comment">// 更新文本节点内容</span>
          <span class="hljs-title function_">textUpdater</span>(<span class="hljs-params">node, value</span>) {
            node.<span class="hljs-property">textContent</span> = value;
          }
        }
      };
    }

    <span class="hljs-comment">//  5. Vue 核心类：整合所有模块 </span>
    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Vue</span> {
      <span class="hljs-title function_">constructor</span>(<span class="hljs-params">options</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">$el</span> = options.<span class="hljs-property">el</span>; <span class="hljs-comment">// 挂载元素</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">$data</span> = options.<span class="hljs-property">data</span>; <span class="hljs-comment">// 响应式数据</span>

        <span class="hljs-comment">// 1. 如果有挂载元素，初始化响应式</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">$el</span>) {
          <span class="hljs-comment">// 劫持 data 所有属性</span>
          <span class="hljs-keyword">new</span> <span class="hljs-title class_">Observer</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$data</span>);
          <span class="hljs-comment">// 代理 data 属性到 Vue 实例（可通过 vm.message 访问 vm.$data.message）</span>
          <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">proxyData</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$data</span>);
          <span class="hljs-comment">// 解析模板</span>
          <span class="hljs-keyword">new</span> <span class="hljs-title class_">Compile</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$el</span>, <span class="hljs-variable language_">this</span>);
        }
      }

      <span class="hljs-comment">// 代理 data 属性到 Vue 实例</span>
      <span class="hljs-title function_">proxyData</span>(<span class="hljs-params">data</span>) {
        <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(data).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> {
          <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<span class="hljs-variable language_">this</span>, key, {
            <span class="hljs-title function_">get</span>(<span class="hljs-params"/>) {
              <span class="hljs-keyword">return</span> data[key];
            },
            <span class="hljs-title function_">set</span>(<span class="hljs-params">newValue</span>) {
              data[key] = newValue;
            }
          });
        });
      }
    }

    <span class="hljs-comment">//  测试例子 </span>
    <span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({
      <span class="hljs-attr">el</span>: <span class="hljs-string">'#app'</span>,
      <span class="hljs-attr">data</span>: {
        <span class="hljs-attr">message</span>: <span class="hljs-string">'Hello Vue2 响应式！'</span>,
        <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>
      }
    });
  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<h2 data-id="heading-5">二、 Vue 3：基于 Proxy 的升级进化</h2>
<h3 data-id="heading-6">1. 核心改进</h3>
<p>Vue 3 彻底放弃了 <code>Object.defineProperty</code>，转而使用 ES6 的 <code>Proxy</code>。它不仅解决了 Vue 2 无法监听对象新增属性和数组索引的问题，还显著提升了初始化性能。</p>
<h3 data-id="heading-7">2. 响应式流程</h3>
<ol>
<li>
<p><strong>Proxy 代理</strong>：拦截对象的 <code>get</code> 和 <code>set</code>。</p>
</li>
<li>
<p><strong>依赖追踪 (Track)</strong> ：在 <code>get</code> 时，将当前正在执行的 <code>Effect</code>（副作用函数）记录在全局映射表 <code>targetMap</code> 中。</p>
</li>
<li>
<p><strong>触发更新 (Trigger)</strong> ：在 <code>set</code> 时，从 <code>targetMap</code> 中找到该属性对应的所有 <code>Effect</code> 并重新执行。</p>
</li>
</ol>
<h3 data-id="heading-8">3. 源码仿真实现</h3>
<p>在 Vue3中，我们通过 <code>reactive</code> 声明响应式数据。</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"zh-CN"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Vue3 双向数据绑定简易实现<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  <span class="hljs-comment">&lt;!-- 测试模板 --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>{{ message }}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"message"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>年龄：{{ user.age }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span>  <span class="hljs-attr">onclick</span>=<span class="hljs-string">"state.user.age++"</span>&gt;</span>年龄+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"number"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"user.age"</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    <span class="hljs-comment">//  1. 依赖管理核心：存储「数据-副作用」映射 </span>
    <span class="hljs-keyword">const</span> targetMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>(); <span class="hljs-comment">// 全局依赖映射：target → key → effects</span>
    <span class="hljs-keyword">let</span> activeEffect = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 当前正在执行的副作用函数</span>

    <span class="hljs-comment">// 收集依赖（追踪）</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">track</span>(<span class="hljs-params">target, key</span>) {
      <span class="hljs-keyword">if</span> (!activeEffect) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 无副作用函数则不收集</span>
      <span class="hljs-comment">// 1. 获取 target 对应的依赖映射</span>
      <span class="hljs-keyword">let</span> depsMap = targetMap.<span class="hljs-title function_">get</span>(target);
      <span class="hljs-keyword">if</span> (!depsMap) {
        depsMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
        targetMap.<span class="hljs-title function_">set</span>(target, depsMap);
      }
      <span class="hljs-comment">// 2. 获取 key 对应的副作用集合</span>
      <span class="hljs-keyword">let</span> deps = depsMap.<span class="hljs-title function_">get</span>(key);
      <span class="hljs-keyword">if</span> (!deps) {
        deps = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(); <span class="hljs-comment">// 用 Set 避免重复副作用</span>
        depsMap.<span class="hljs-title function_">set</span>(key, deps);
      }
      <span class="hljs-comment">// 3. 添加当前副作用到集合</span>
      deps.<span class="hljs-title function_">add</span>(activeEffect);
    }

    <span class="hljs-comment">// 触发依赖更新</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">trigger</span>(<span class="hljs-params">target, key</span>) {
      <span class="hljs-comment">// 1. 获取 target 对应的依赖映射</span>
      <span class="hljs-keyword">const</span> depsMap = targetMap.<span class="hljs-title function_">get</span>(target);
      <span class="hljs-keyword">if</span> (!depsMap) <span class="hljs-keyword">return</span>;
      <span class="hljs-comment">// 2. 获取 key 对应的副作用集合</span>
      <span class="hljs-keyword">const</span> deps = depsMap.<span class="hljs-title function_">get</span>(key);
      <span class="hljs-keyword">if</span> (!deps) <span class="hljs-keyword">return</span>;
      <span class="hljs-comment">// 3. 执行所有副作用函数</span>
      deps.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">effect</span> =&gt;</span> <span class="hljs-title function_">effect</span>());
    }

    <span class="hljs-comment">//  2. 创建响应式对象：reactive（基于 Proxy + Reflect） </span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">reactive</span>(<span class="hljs-params">target</span>) {
      <span class="hljs-comment">// 非对象直接返回</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> target !== <span class="hljs-string">'object'</span> || target === <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">return</span> target;
      }

      <span class="hljs-comment">// 创建 Proxy 代理</span>
      <span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, {
        <span class="hljs-comment">// 拦截属性读取</span>
        <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key, receiver</span>) {
          <span class="hljs-keyword">const</span> result = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, key, receiver);
          <span class="hljs-title function_">track</span>(target, key); <span class="hljs-comment">// 收集依赖</span>
          <span class="hljs-comment">// 递归处理嵌套对象（懒代理，读取时才创建响应式）</span>
          <span class="hljs-keyword">return</span> <span class="hljs-title function_">reactive</span>(result);
        },
        <span class="hljs-comment">// 拦截属性赋值</span>
        <span class="hljs-title function_">set</span>(<span class="hljs-params">target, key, value, receiver</span>) {
          <span class="hljs-keyword">const</span> oldValue = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, key, receiver);
          <span class="hljs-keyword">const</span> result = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, key, value, receiver);
          <span class="hljs-comment">// 值变化才触发更新</span>
          <span class="hljs-keyword">if</span> (oldValue !== value) {
            <span class="hljs-title function_">trigger</span>(target, key); <span class="hljs-comment">// 触发依赖更新</span>
          }
          <span class="hljs-keyword">return</span> result;
        },
        <span class="hljs-comment">// 拦截属性删除（可选，补充完整度）</span>
        <span class="hljs-title function_">deleteProperty</span>(<span class="hljs-params">target, key</span>) {
          <span class="hljs-keyword">const</span> result = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">deleteProperty</span>(target, key);
          <span class="hljs-title function_">trigger</span>(target, key);
          <span class="hljs-keyword">return</span> result;
        }
      });

      <span class="hljs-keyword">return</span> proxy;
    }

    <span class="hljs-comment">//  3. 副作用函数：effect（依赖收集的入口） </span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">effect</span>(<span class="hljs-params">fn</span>) {
      <span class="hljs-comment">// 包装副作用函数</span>
      <span class="hljs-keyword">const</span> <span class="hljs-title function_">effectFn</span> = (<span class="hljs-params"/>) =&gt; {
        activeEffect = effectFn; <span class="hljs-comment">// 标记当前副作用</span>
        <span class="hljs-title function_">fn</span>(); <span class="hljs-comment">// 执行函数，触发 get 拦截，收集依赖</span>
        activeEffect = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 重置</span>
      };
      <span class="hljs-title function_">effectFn</span>(); <span class="hljs-comment">// 立即执行一次，完成初始依赖收集</span>
      <span class="hljs-keyword">return</span> effectFn;
    }

    <span class="hljs-comment">//  4. 模板解析器：Compile（解析 {{}} 和 v-model） </span>
    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Compile</span> {
      <span class="hljs-title function_">constructor</span>(<span class="hljs-params">el, data</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">el</span> = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(el); <span class="hljs-comment">// 挂载元素</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span> = data; <span class="hljs-comment">// 响应式数据</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">fragment</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">createFragment</span>(); <span class="hljs-comment">// 创建文档碎片</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compile</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">fragment</span>); <span class="hljs-comment">// 解析模板</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">el</span>.<span class="hljs-title function_">appendChild</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">fragment</span>); <span class="hljs-comment">// 挂载到 DOM</span>
      }

      <span class="hljs-comment">// 创建文档碎片（减少 DOM 操作）</span>
      <span class="hljs-title function_">createFragment</span>(<span class="hljs-params"/>) {
        <span class="hljs-keyword">const</span> fragment = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createDocumentFragment</span>();
        <span class="hljs-keyword">let</span> child;
        <span class="hljs-keyword">while</span> (child = <span class="hljs-variable language_">this</span>.<span class="hljs-property">el</span>.<span class="hljs-property">firstChild</span>) {
          fragment.<span class="hljs-title function_">appendChild</span>(child);
        }
        <span class="hljs-keyword">return</span> fragment;
      }

      <span class="hljs-comment">// 核心解析方法</span>
      <span class="hljs-title function_">compile</span>(<span class="hljs-params">node</span>) {
        <span class="hljs-keyword">if</span> (node.<span class="hljs-property">nodeType</span> === <span class="hljs-number">1</span>) { <span class="hljs-comment">// 元素节点（解析 v-model）</span>
          <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compileElement</span>(node);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.<span class="hljs-property">nodeType</span> === <span class="hljs-number">3</span> &amp;&amp; <span class="hljs-regexp">/\{\{(.+?)\}\}/</span>.<span class="hljs-title function_">test</span>(node.<span class="hljs-property">textContent</span>)) { <span class="hljs-comment">// 文本节点（解析 {{}}）</span>
          <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compileText</span>(node);
        }

        <span class="hljs-comment">// 递归解析子节点</span>
        node.<span class="hljs-property">childNodes</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">child</span> =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compile</span>(child));
      }

      <span class="hljs-comment">// 解析元素节点（v-model 指令）</span>
      <span class="hljs-title function_">compileElement</span>(<span class="hljs-params">node</span>) {
        <span class="hljs-keyword">const</span> attrs = node.<span class="hljs-property">attributes</span>;
        <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(attrs).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">attr</span> =&gt;</span> {
          <span class="hljs-keyword">const</span> { name, value } = attr;
          <span class="hljs-keyword">if</span> (name === <span class="hljs-string">'v-model'</span>) { <span class="hljs-comment">// 处理 v-model</span>
            <span class="hljs-comment">// 1. 初始化：用响应式数据设置 DOM 值</span>
            node.<span class="hljs-property">value</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getVal</span>(value);
            <span class="hljs-comment">// 2. 监听输入事件，同步到响应式数据</span>
            node.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'input'</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
              <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setVal</span>(value, e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>);
            });
            <span class="hljs-comment">// 3. 监听数据变化，更新 DOM</span>
            <span class="hljs-title function_">effect</span>(<span class="hljs-function">() =&gt;</span> {
              node.<span class="hljs-property">value</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getVal</span>(value);
            });
            <span class="hljs-comment">// 移除指令属性（可选，美化 DOM）</span>
            node.<span class="hljs-title function_">removeAttribute</span>(name);
          }
        });
      }

      <span class="hljs-comment">// 解析文本节点（{{}} 插值）</span>
      <span class="hljs-title function_">compileText</span>(<span class="hljs-params">node</span>) {
        <span class="hljs-keyword">const</span> reg = <span class="hljs-regexp">/\{\{(.+?)\}\}/g</span>;
        <span class="hljs-keyword">const</span> text = node.<span class="hljs-property">textContent</span>;
        <span class="hljs-comment">// 替换 {{}} 为真实数据，并创建副作用</span>
        node.<span class="hljs-property">textContent</span> = text.<span class="hljs-title function_">replace</span>(reg, <span class="hljs-function">(<span class="hljs-params">_, expr</span>) =&gt;</span> {
          <span class="hljs-keyword">const</span> prop = expr.<span class="hljs-title function_">trim</span>();
          <span class="hljs-comment">// 监听数据变化，更新文本</span>
          <span class="hljs-title function_">effect</span>(<span class="hljs-function">() =&gt;</span> {
            node.<span class="hljs-property">textContent</span> = text.<span class="hljs-title function_">replace</span>(reg, <span class="hljs-function">(<span class="hljs-params">_, innerExpr</span>) =&gt;</span> {
              <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getVal</span>(innerExpr.<span class="hljs-title function_">trim</span>());
            });
          });
          <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getVal</span>(prop);
        });
      }

      <span class="hljs-comment">// 获取响应式数据的值（处理嵌套，如 user.age）</span>
      <span class="hljs-title function_">getVal</span>(<span class="hljs-params">expr</span>) {
        <span class="hljs-keyword">return</span> expr.<span class="hljs-title function_">split</span>(<span class="hljs-string">'.'</span>).<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">data, key</span>) =&gt;</span> {
          <span class="hljs-keyword">return</span> data[key];
        }, <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>);
      }

      <span class="hljs-comment">// 设置响应式数据的值（处理嵌套，如 user.age）</span>
      <span class="hljs-title function_">setVal</span>(<span class="hljs-params">expr, value</span>) {
        <span class="hljs-keyword">return</span> expr.<span class="hljs-title function_">split</span>(<span class="hljs-string">'.'</span>).<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">data, key, index, arr</span>) =&gt;</span> {
          <span class="hljs-keyword">if</span> (index === arr.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>) {
            <span class="hljs-comment">// 处理数字类型（如 age）</span>
            <span class="hljs-keyword">return</span> data[key] = <span class="hljs-built_in">isNaN</span>(<span class="hljs-title class_">Number</span>(value)) ? value : <span class="hljs-title class_">Number</span>(value);
          }
          <span class="hljs-keyword">return</span> data[key];
        }, <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>);
      }
    }

    <span class="hljs-comment">//  4. 测试代码 </span>
    <span class="hljs-comment">// 1. 创建响应式数据</span>
    <span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>({
      <span class="hljs-attr">message</span>: <span class="hljs-string">'Hello Vue3 双向绑定！'</span>,
      <span class="hljs-attr">user</span>: {
        <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>
      }
    });

    <span class="hljs-comment">// 2. 解析模板，完成双向绑定</span>
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Compile</span>(<span class="hljs-string">'#app'</span>, state);

    <span class="hljs-comment">// 暴露到全局，方便控制台测试</span>
    <span class="hljs-variable language_">window</span>.<span class="hljs-property">state</span> = state;
  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>

</code></pre>
<h2 data-id="heading-9">三、 总结：Vue 2 vs Vue 3 响应式对比</h2>






























<table><thead><tr><th><strong>特性</strong></th><th><strong>Vue 2 (defineProperty)</strong></th><th><strong>Vue 3 (Proxy)</strong></th></tr></thead><tbody><tr><td><strong>性能</strong></td><td>必须全量遍历属性，开销大</td><td>懒代理（读取时才处理），更高效</td></tr><tr><td><strong>动态性</strong></td><td>无法检测属性新增、删除</td><td>完美支持属性新增、删除及数组索引</td></tr><tr><td><strong>实现复杂度</strong></td><td>需要手动重写数组方法</td><td>原生支持所有对象操作</td></tr><tr><td><strong>兼容性</strong></td><td>支持 IE9+</td><td>不支持 IE (依赖 ES6)</td></tr></tbody></table></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Go 的三种 Option 设计：从轻量 Functional Options 到 gRPC/OTel 进阶玩法]]></title>    <link>https://juejin.cn/post/7602225961095807010</link>    <guid>https://juejin.cn/post/7602225961095807010</guid>    <pubDate>2026-02-03T10:01:21.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602225961095807010" data-draft-id="7602216700747808768" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Go 的三种 Option 设计：从轻量 Functional Options 到 gRPC/OTel 进阶玩法"/> <meta itemprop="keywords" content="Go"/> <meta itemprop="datePublished" content="2026-02-03T10:01:21.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="下次一定57"/> <meta itemprop="url" content="https://juejin.cn/user/3722294009017404"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Go 的三种 Option 设计：从轻量 Functional Options 到 gRPC/OTel 进阶玩法
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3722294009017404/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    下次一定57
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T10:01:21.000Z" title="Tue Feb 03 2026 10:01:21 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读12分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">引言</h2>
<p>在 Go 里，构造函数经常会遇到一个问题：参数越来越多。例如  <code>NewServer(port, healthz, middlewares, jwt, serviceName, ...) </code> 这种函数签名，一旦需求增长就会变成“参数灾难”：</p>
<ul>
<li>
<p>可读性差：调用处一串参数，看不出谁是谁</p>
</li>
<li>
<p>易用性差：可选项很多时，必须传一堆默认值占位</p>
</li>
<li>
<p>兼容性差：新增一个参数就破坏所有调用方（编译报错）</p>
</li>
<li>
<p>维护成本高：参数顺序、默认值、校验逻辑分散</p>
</li>
</ul>
<p><code>NewServer</code>参数泛滥问题，正是 Go 语言中构造函数的常见痛点，而<strong>函数式选项模式（Functional Options Pattern）</strong> 是应对这类场景的优雅最优解。它不直接传递零散参数，而是将每个配置项封装为独立的 “选项函数”，构造函数仅接收可变长度的选项函数切片，内部遍历执行以完成结构体初始化。这种模式完美攻克参数灾难的四大痛点。</p>
<p>为了在不同复杂度与工程约束下都能落地，函数式选项模式在实践中常见三种变体：（1）轻量函数型：样板代码最少、上手最快；（2）接口 + 配置载体型（<code>gRPC</code> 风格）：进一步解耦，避免核心结构体被配置“污染”；（3）不可变配置型（<code>OpenTelemetry</code> 风格）：通过值传递返回新配置，更利于并发安全与配置可追溯。下面按顺序逐一展开。</p>
<h2 data-id="heading-1">第一种：轻量版 Functional Options（最常见）</h2>
<p>这是<strong>函数式选项模式</strong>最基础、简洁的实现形式，核心无需引入复杂接口，仅通过<strong>定义一个接收目标结构体指针的函数类型</strong>，再封装一系列<code>WithXXX</code>命名的工厂函数，返回能修改结构体字段的闭包即可。构造函数中先初始化结构体的合理默认值，再遍历执行传入的所有选项函数，覆盖用户需要自定义的配置。这种模式以极简的代码量解决了多参数构造函数的四大痛点。</p>
<p>下面例子是简单的对 <code>gin</code>  进行封装的 <code>Server</code> 端，简化了大部分逻辑，用来认识这种实现形式，在用时可根据自己的业务逻辑自行添加。</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-comment">// 定义选项函数类型 接收*Server指针，用于修改结构体字段</span>
<span class="hljs-keyword">type</span> ServerOption <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(*Server)</span></span>

<span class="hljs-comment">// WithServiceName 设置服务名称</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithServiceName</span><span class="hljs-params">(srvName <span class="hljs-type">string</span>)</span></span> ServerOption {
	<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s *Server)</span></span> {
		s.serviceName = srvName
	}
}
<span class="hljs-comment">// WithPort 设置服务端口</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithPort</span><span class="hljs-params">(port <span class="hljs-type">int</span>)</span></span> ServerOption {
	<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s *Server)</span></span> {
		s.port = port
	}
}
<span class="hljs-comment">// WithMiddlewares 设置中间件列表</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithMiddlewares</span><span class="hljs-params">(middlewares []<span class="hljs-type">string</span>)</span></span> ServerOption {
	<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s *Server)</span></span> {
		s.middlewares = middlewares
	}
}
<span class="hljs-comment">// WithHealthz 设置健康检查开关</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithHealthz</span><span class="hljs-params">(healthz <span class="hljs-type">bool</span>)</span></span> ServerOption {
	<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s *Server)</span></span> {
		s.healthz = healthz
	}
}

</code></pre>
<p>这种形式一般都是一个文件夹下两个文件，一个为 <code>option.go</code>， 一个为 <code>Server.go</code>，在程序的主入口，直接调用 。<code>NewServer(With...)</code>函数，拿到返回值 <code>srv</code> 之后，即可通过 <code>srv.Start()</code> 启动服务，当然可以根据自己加更多逻辑，比如优雅退出等等。</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-keyword">type</span> Server <span class="hljs-keyword">struct</span> {
	*gin.Engine
	port <span class="hljs-type">int</span>
	<span class="hljs-comment">// 是否开启健康检查接口， 默认开启， 如果开启会自动添加 /health 接口</span>
	healthz <span class="hljs-type">bool</span>
	<span class="hljs-comment">// 中间件</span>
	middlewares []<span class="hljs-type">string</span>
    <span class="hljs-comment">// jwt配置信息 后续自己可扩展</span>
	jwt *JwtInfo
	server *http.Server
	serviceName <span class="hljs-type">string</span>
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewServer</span><span class="hljs-params">(opts ...ServerOption)</span></span> *Server {
	srv := &amp;Server{
		port:            <span class="hljs-number">8080</span>,
		healthz:         <span class="hljs-literal">true</span>,
		serviceName: <span class="hljs-string">"test"</span>,
        Engine:      gin.Default(),
	}

	<span class="hljs-keyword">for</span> _, o := <span class="hljs-keyword">range</span> opts {
		o(srv)
	}
	
	<span class="hljs-comment">// 遍历用户传的中间件 在自己库中查找 没找到就跳过 这是只是为了演示配置</span>
	<span class="hljs-keyword">for</span> _, m := <span class="hljs-keyword">range</span> srv.middlewares {
		mw, ok := Middlewares[m]
		<span class="hljs-keyword">if</span> !ok {
			log.Warnf(<span class="hljs-string">"can not find middleware: %s"</span>, m)
			<span class="hljs-keyword">continue</span>
		}

		log.Infof(<span class="hljs-string">"intall middleware: %s"</span>, m)
		srv.Engine.Use(mw)
	}
    
    <span class="hljs-keyword">return</span> srv
}

<span class="hljs-comment">// 绑定一些方法 </span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Server)</span></span> Start(ctx context.Context) <span class="hljs-type">error</span> {}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Server)</span></span> Stop(ctx context.Context) <span class="hljs-type">error</span> {}



<span class="hljs-comment">// 这里的代码是放到其他目录的 由于这里会用到 自己去写的时候 建议不要放到这里</span>
<span class="hljs-keyword">var</span> Middlewares = defaultMiddlewares()

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">defaultMiddlewares</span><span class="hljs-params">()</span></span> <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]gin.HandlerFunc {
	<span class="hljs-keyword">return</span> <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]gin.HandlerFunc{
		<span class="hljs-string">"cors"</span>:     Cors(),  <span class="hljs-comment">// 跨域的中间件 需自行实现跨域逻辑</span>
		<span class="hljs-string">"context"</span>:  Context(), <span class="hljs-comment">// 自定义上下文传递中间件，需自行实现</span>
	}
}

</code></pre>
<h2 data-id="heading-2">第二种：接口型选项模式（<code>gRPC</code> 经典实现）</h2>
<p>这种模式是基础函数式选项的进阶，核心是引入了<strong>选项接口</strong>（<code>DialOption</code>）和<strong>专门的配置载体结构体</strong>（<code>dialOptions</code>），不再让选项函数直接耦合目标结构体（<code>ClientConn</code>）。通过定义<code>apply</code>方法作为接口约定，将所有配置项聚合到<code>dialOptions</code>中，选项的实现都围绕这个配置载体展开，最后在构造函数中统一将配置应用到目标结构体。这种模式让配置逻辑与目标结构体解耦，同时接口的约束让选项扩展更具规范性。</p>
<p>代码中有注释，等了解完代码，再回过头看下面文字会有更深的理解。</p>
<p>首先第一点<strong>解耦</strong>，解耦无论在哪种语言中提到，大部分就是多加一层，这里也是同理。比如在第一种基础的选项模式中，随着功能越来越完善，要新加一些超时字段，比如连接超时读写超时，或者就是单纯加字段，这个时候，只能在 <code>Server</code>结构体中添加这些字段，然后还要手动去写它们的默认值，再加一些 <code>with...()</code> 方法，我们要清楚的是这个结构体核心职责是 “管理网络连接”，但最终却塞满了超时还有一堆额外加的配置项，可读性和维护性极差，这就是常说的业务结构体被配置 “污染”，下面这一种就是解决这个问题，<code>DialOption</code>接口 + <code>dialOptions</code> 配置载体（<code>dialOptions</code> 里面承担了所有配置相关的逻辑 ），使得 <code>ClientConn </code>只专注于自己的核心业务，需求迭代时完全不用改动<code>ClientConn</code>。</p>
<p>第二点<strong>扩展性</strong>，这也源于 Go 面向接口编程思想，在Go语言中，<strong>接口约定优于实现</strong>：<code>DialOption</code>接口只定义了<code>apply(*dialOptions)</code>一个方法，这是一种<strong>行为约定</strong>，它不关心实现者是<code>funcDialOption</code>还是其他实现比如自己实现一个<code>ValidateTargetOption</code>，只要满足这个行为约定，就能被构造函数处理。</p>
<p>比如现在需要验证合法性，如果说是第一种，必然是在需要验证的 <code>with...()</code> 函数中添加，无疑是需要修改核心逻辑，这里只是举一个很好理解的例子，在大多数情况下，比如链路跟踪，有了一个公认的规范 <code>OpenTelemetry</code>  可以理解成类似 <code>Type-C</code> 硬件协议规范，这时候你的系统要接入链路跟踪，之前可能用的不是这种规范，如果用第一种，无疑是需要修改核心业务逻辑，如果是这一种，逻辑都再配置层，核心逻辑不需要动，这里给大家用 <code>ValidateTargetOption</code>  自己写的实现接口的结构体，用于验证<code>url</code> 是否合法，放在文章最后。</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-keyword">type</span> DialOption <span class="hljs-keyword">interface</span> {
	apply(*dialOptions)
}

<span class="hljs-comment">// 实现上面接口 </span>
<span class="hljs-keyword">type</span> funcDialOption <span class="hljs-keyword">struct</span> {
    <span class="hljs-comment">// 结构体字段是函数</span>
	f <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(*dialOptions)</span></span>
}
<span class="hljs-comment">// 这个方法 在后续 NewClient 会用到</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(fdo *funcDialOption)</span></span> apply(do *dialOptions) {
    <span class="hljs-comment">// fdo.f 本质上就是一个函数 func(*dialOptions) 里面有一些逻辑 逻辑是通过 with...() 传来的 可以看完下面的在回来理解</span>
    <span class="hljs-comment">// 把传来的 dialOptions 配置项（全局唯一） 放入f这个函数中执行对应逻辑 这些逻辑就是向它的各个字段赋值</span>
	fdo.f(do)
}

<span class="hljs-comment">// 主 ClientConn 里面有个 dialOptions 这个字段就解耦了</span>
<span class="hljs-keyword">type</span> dialOptions <span class="hljs-keyword">struct</span> {
	unaryInt  UnaryClientInterceptor
	streamInt StreamClientInterceptor
	chainUnaryInts  []UnaryClientInterceptor
	chainStreamInts []StreamClientInterceptor
    target 						<span class="hljs-type">string</span>
	compressorV0                Compressor
	dc                          Decompressor
	bs                          internalbackoff.Strategy
	block                       <span class="hljs-type">bool</span>
	returnLastError             <span class="hljs-type">bool</span>
	timeout                     time.Duration
 	disableHealthCheck          <span class="hljs-type">bool</span>
   <span class="hljs-comment">// ..... 等等一系列配置相关的  巧妙的与 主 ClientConn 分开 这使得 ClientConn 只专注于自己的核心业务</span>
}


<span class="hljs-comment">// 这个函数是用于封装的 这使得 以后的 with 方法直接调用这个函数就可以很方便的返回 实现接口的 funcDialOption 结构体</span>
<span class="hljs-comment">/* 
拆解一下这个函数便于理解： 
首先 newFuncDialOption 接收的参数就是一个 f 函数 函数长相是 func(*dialOptions) 没有返回值，形参介绍完成
其次：newFuncDialOption 的返回值 就是 实现接口的 funcDialOption 结构体  返回值介绍完成
函数内容：实现接口的 funcDialOption 结构体 有个字段是函数 把传来的形参直接赋值上并返回
*/</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newFuncDialOption</span><span class="hljs-params">(f <span class="hljs-keyword">func</span>(*dialOptions)</span></span>) *funcDialOption {
	<span class="hljs-keyword">return</span> &amp;funcDialOption{
		f: f,
	}
}

<span class="hljs-comment">// 大家看完这种 with 函数返回的 内部逻辑  就能明白 就是给 dialOptions 里面的值赋值的</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithChainUnaryInterceptor</span><span class="hljs-params">(interceptors ...UnaryClientInterceptor)</span></span> DialOption {
	<span class="hljs-keyword">return</span> newFuncDialOption(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(o *dialOptions)</span></span> {
		o.chainUnaryInts = <span class="hljs-built_in">append</span>(o.chainUnaryInts, interceptors...)
	})
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithStreamInterceptor</span><span class="hljs-params">(f StreamClientInterceptor)</span></span> DialOption {
	<span class="hljs-keyword">return</span> newFuncDialOption(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(o *dialOptions)</span></span> {
		o.streamInt = f
	})
}
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithDisableHealthCheck</span><span class="hljs-params">()</span></span> DialOption {
	<span class="hljs-keyword">return</span> newFuncDialOption(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(o *dialOptions)</span></span> {
		o.disableHealthCheck = <span class="hljs-literal">true</span>
	})
}
<span class="hljs-comment">// 等等.... 几乎能用的字段都放一个 with </span>
</code></pre>
<p>这里的最大重点就是 <code>defaultDialOptions()</code> 这个函数就是存放默认值，解耦的关键，无论后续添加什么字段，都放在该函数中进行初始化，在 <code>NewClient() </code>函数中任何地方都不需要改。</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewClient</span><span class="hljs-params">(target <span class="hljs-type">string</span>, opts ...DialOption)</span></span> (conn *ClientConn, err <span class="hljs-type">error</span>) {
    cc := &amp;ClientConn{
       target: target,
       conns:  <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[*addrConn]<span class="hljs-keyword">struct</span>{}),
       dopts:  defaultDialOptions(),   <span class="hljs-comment">// 一切相关的配置都放在这里 不污染主路线</span>
    }

	<span class="hljs-comment">// 这边就是我们传入的 with.... 去进行 赋值</span>
    <span class="hljs-keyword">for</span> _, opt := <span class="hljs-keyword">range</span> opts {
       <span class="hljs-comment">// 调用上面的 apply 方法 </span>
       opt.apply(&amp;cc.dopts)
    }

    chainUnaryClientInterceptors(cc)
    chainStreamClientInterceptors(cc)


   <span class="hljs-comment">// 各种逻辑....</span>

    <span class="hljs-keyword">return</span> cc, <span class="hljs-literal">nil</span>
}

<span class="hljs-comment">// 同样绑定各种方法 </span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cc *ClientConn)</span></span> GetState() connectivity.State {
	<span class="hljs-keyword">return</span> cc.csMgr.getState()
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cc *ClientConn)</span></span> waitForResolvedAddrs(ctx context.Context) (<span class="hljs-type">bool</span>, <span class="hljs-type">error</span>) {...}
</code></pre>
<h2 data-id="heading-3">第三种：不可变配置型选项模式（<code>OpenTelemetry</code> 风格）</h2>
<p>这种模式是<strong>函数式选项的安全进阶版</strong>，核心区别于前两种的<strong>可变配置修改</strong>，它采用<strong>值传递 + 返回新配置</strong>的方式实现不可变性，所有配置操作都不会修改原有配置对象，而是返回一个全新的配置副本。这种模式在 <code>OpenTelemetry</code>、<code>Prometheus</code> 等核心组件中广泛使用，特别适合对<strong>并发安全、配置不可篡改、数据一致性</strong>有严格要求的场景（比如链路追踪、监控采集、全局配置管理等）。</p>
<p>前两种模式中，配置的修改都是就地修改（通过指针操作修改结构体字段）：第一种直接修改目标结构体 <code>*Server</code>，第二种修改配置载体 <code>*dialOptions</code>，这种可变模式在单协程场景下没问题，但在并发场景中，如果配置被意外复用、修改，可能会引发不可预期的问题。而不可变配置模式从根源上解决了这个问题 ，配置一旦创建，就无法被修改，后续的所有配置调整都只会生成新的配置对象，天然具备线程安全，且能追溯配置变更轨迹。</p>
<p>这里的 <code>tracerProviderConfig</code> 同样是用于解耦的配置项，只不过是安全进阶版。</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-comment">// 同样定义选项接口   不可变核心：接收旧配置，返回新配置 </span>
<span class="hljs-keyword">type</span> TracerProviderOption <span class="hljs-keyword">interface</span> {
    <span class="hljs-comment">// 与前两种的区别：apply方法不是修改指针，而是入参旧配置，返回新配置</span>
	apply(tracerProviderConfig) tracerProviderConfig
}

<span class="hljs-comment">// 定义接口的函数类型实现，类似第二种的 funcDialOption，只是简化选项创建，本质是一样的</span>
<span class="hljs-comment">// 第二种是 结构体里字段是函数  这里是 这个结构体就是个函数 函数形式 func(tracerProviderConfig) tracerProviderConfig</span>
<span class="hljs-keyword">type</span> traceProviderOptionFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(tracerProviderConfig)</span></span> tracerProviderConfig

<span class="hljs-comment">// 依旧实现 apply 方法</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(fn traceProviderOptionFunc)</span></span> apply(cfg tracerProviderConfig) tracerProviderConfig {
	<span class="hljs-keyword">return</span> fn(cfg)
}


<span class="hljs-comment">// 各种 with 函数 返回都是接口   主要看 return 地方</span>
<span class="hljs-comment">/*
首先 内层 匿名函数 func(cfg tracerProviderConfig) tracerProviderConfig 这是实际承载配置逻辑的函数
traceProviderOptionFunc() 可以理解成同签名函数类型的安全转换  转换的双方是 “同构” 的，没有数据丢失 
*/</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithResource</span><span class="hljs-params">(r *resource.Resource)</span></span> TracerProviderOption {
	<span class="hljs-keyword">return</span> traceProviderOptionFunc(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(cfg tracerProviderConfig)</span></span> tracerProviderConfig {
		<span class="hljs-keyword">var</span> err <span class="hljs-type">error</span>
		cfg.resource, err = resource.Merge(resource.Environment(), r)
		<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
			<span class="hljs-comment">// 错误逻辑....</span>
		}
		<span class="hljs-keyword">return</span> cfg
	})
}


<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithIDGenerator</span><span class="hljs-params">(g IDGenerator)</span></span> TracerProviderOption {
	<span class="hljs-keyword">return</span> traceProviderOptionFunc(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(cfg tracerProviderConfig)</span></span> tracerProviderConfig {
		<span class="hljs-keyword">if</span> g != <span class="hljs-literal">nil</span> {
			cfg.idGenerator = g
		}
		<span class="hljs-keyword">return</span> cfg
	})
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithSampler</span><span class="hljs-params">(s Sampler)</span></span> TracerProviderOption {
	<span class="hljs-keyword">return</span> traceProviderOptionFunc(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(cfg tracerProviderConfig)</span></span> tracerProviderConfig {
		<span class="hljs-keyword">if</span> s != <span class="hljs-literal">nil</span> {
			cfg.sampler = s
		}
		<span class="hljs-keyword">return</span> cfg
	})
}

<span class="hljs-comment">// ....</span>
</code></pre>
<pre><code class="hljs language-go" lang="go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewTracerProvider</span><span class="hljs-params">(opts ...TracerProviderOption)</span></span> *TracerProvider {
    <span class="hljs-comment">// 默认值</span>
    o := tracerProviderConfig{
       spanLimits: NewSpanLimits(),
    }
    <span class="hljs-comment">// 从环境变量里读取</span>
    o = applyTracerProviderEnvConfigs(o)
    
	<span class="hljs-comment">// 用户 with... 传来的 </span>
    <span class="hljs-keyword">for</span> _, opt := <span class="hljs-keyword">range</span> opts {
       o = opt.apply(o)
    }
	
	<span class="hljs-comment">// 生成 要返回值</span>
    tp := &amp;TracerProvider{
       namedTracer: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[instrumentation.Scope]*tracer),
       sampler:     o.sampler,
       idGenerator: o.idGenerator,
       spanLimits:  o.spanLimits,
       resource:    o.resource,
    }

    <span class="hljs-comment">// 其他逻辑  ...</span>

    <span class="hljs-keyword">return</span> tp
}
<span class="hljs-comment">// 同样绑定一系列方法</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *TracerProvider)</span></span> Tracer(name <span class="hljs-type">string</span>, opts ...trace.TracerOption) trace.Tracer {...}
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *TracerProvider)</span></span> RegisterSpanProcessor(sp SpanProcessor) {...}

</code></pre>
<h2 data-id="heading-4">自己实现的 <code>ValidateTargetOption</code></h2>
<p>通过下面自己编写的实现 <code>DialOption</code> 接口的结构体，就能封装复杂的 <code>gRPC</code> 客户端目标地址（target）合法性校验逻辑，还能携带额外配置参数满足多样化校验需求。后续调用方只需通过我们提供的 <code>WithValidateTarget()</code> 方法传入校验规则，即可让 <code>gRPC</code> 客户端在初始化时自动完成地址校验，整个扩展过程对原有代码零侵入，扩展性和可维护性拉满。</p>
<p><code>gRPC</code> 实际 Target 格式校验更复杂，这里只是通过这个例子告诉大家可以自己写实现接口的结构体，并应用到它们内部。</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-comment">// 自定义结构体：专门用于校验target合法性</span>
<span class="hljs-keyword">type</span> ValidateTargetOption <span class="hljs-keyword">struct</span> {
	<span class="hljs-comment">// 可携带额外配置，比如是否允许本地地址、是否必须是https等</span>
	allowLocal <span class="hljs-type">bool</span>
}

<span class="hljs-comment">// 实现 apply 方法</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v *ValidateTargetOption)</span></span> apply(do *dialOptions) {
	<span class="hljs-comment">// 判断target是否为空</span>
	<span class="hljs-keyword">if</span> do.target == <span class="hljs-string">""</span> {
        <span class="hljs-comment">// 这里不建议直接 Fatal 这里为了演示 代码尽量少</span>
		log.Fatalf(<span class="hljs-string">"validate failed: target address is empty"</span>)
	}

	<span class="hljs-comment">// 解析url，校验格式合法性</span>
	_, err := url.Parse(do.target)
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
		log.Fatalf(<span class="hljs-string">"validate failed: target address format is invalid, err: %v"</span>, err)
	}

	<span class="hljs-comment">//根据allowLocal配置，判断是否允许本地地址（127.0.0.1、localhost）</span>
	<span class="hljs-keyword">if</span> !v.allowLocal &amp;&amp; (do.target == <span class="hljs-string">"127.0.0.1"</span> || do.target == <span class="hljs-string">"localhost"</span>) {
		log.Fatalf(<span class="hljs-string">"validate failed: local address is not allowed"</span>)
	}

	<span class="hljs-comment">// 校验通过，打印日志</span>
	log.Printf(<span class="hljs-string">"validate success: target address %s is valid"</span>, do.target)
}

<span class="hljs-comment">// 提供 with 函数</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithValidateTarget</span><span class="hljs-params">(allowLocal <span class="hljs-type">bool</span>)</span></span> DialOption {
	<span class="hljs-keyword">return</span> &amp;ValidateTargetOption{allowLocal: allowLocal}
}
</code></pre>
<h2 data-id="heading-5">总结</h2>
<p>函数式选项模式是 Go 语言解决构造函数 "参数灾难" 的最优解，三种实现形式各有侧重、按需选用：轻量版极简直观，无需额外接口，通过闭包直接修改目标结构体，适合普通业务服务的快速落地；接口型（<code>gRPC</code> 风格）通过引入配置载体结构体和解耦接口，让核心业务结构体摆脱配置污染，扩展性和规范性更强，适合复杂基础组件的开发；不可变配置型（<code>OpenTelemetry</code> 风格）采用值传递返回新配置的方式，从根源上保证并发安全和配置不可篡改，适合链路追踪、监控采集等对数据一致性有严格要求的场景。三种模式均能解决多参数带来的可读性、易用性等问题，核心差异在于解耦程度和安全等级，实际开发中可根据业务复杂度和场景要求选择对应的实现方案。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[拒绝当“重复提示词机器“：Skills 完全入门指南，及与 MCP 的深度对比]]></title>    <link>https://juejin.cn/post/7602440800295731246</link>    <guid>https://juejin.cn/post/7602440800295731246</guid>    <pubDate>2026-02-03T10:03:59.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602440800295731246" data-draft-id="7602464510607310874" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="拒绝当“重复提示词机器“：Skills 完全入门指南，及与 MCP 的深度对比"/> <meta itemprop="keywords" content="后端,Java"/> <meta itemprop="datePublished" content="2026-02-03T10:03:59.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="让我上个超影吧"/> <meta itemprop="url" content="https://juejin.cn/user/3411151088782442"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            拒绝当“重复提示词机器“：Skills 完全入门指南，及与 MCP 的深度对比
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3411151088782442/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    让我上个超影吧
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T10:03:59.000Z" title="Tue Feb 03 2026 10:03:59 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读11分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">一、什么是 Skills？它到底解决了什么痛点？</h2>
<p>想象这样一个场景：你正在用<strong>CodeBuddy</strong>写代码，每次让 AI 帮忙审查代码，都要重复说： <strong>"请用中文写注释"、"记得检查空指针"、"按照我们团队的 RESTful 规范来</strong>"。说了一遍又一遍，AI 还是经常忘记。</p>
<p><strong>Skills（技能）就是来解决这个问题的。</strong></p>
<p>简单来说，<strong>Skills 是给 AI 准备的一份"专业上岗培训手册"</strong> 。你可以把团队的代码规范、特定的开发流程、或者某个领域（如 Chrome 插件开发）的最佳实践，打包成一个 Skill。一旦安装，AI 就会自动记住这些规则，在你需要的时候自动调用，无需反复提醒。</p>
<h4 data-id="heading-1">核心痛点解决</h4>






























<table><thead><tr><th>痛点</th><th>传统方式</th><th>使用 Skills 后</th></tr></thead><tbody><tr><td>重复劳动</td><td>每次都要粘贴同样的 prompt</td><td>一次编写，永久复用，自动触发</td></tr><tr><td>团队标准不一</td><td>新人不知道团队规范，AI 输出风格各异</td><td>Skill 随 Git 仓库共享，全员统一标准</td></tr><tr><td>上下文溢出</td><td>长 prompt 占用大量 token，导致 AI 失忆</td><td>渐进式加载，用时才展开，节省 token</td></tr><tr><td>知识沉淀困难</td><td>好的提示词散落在聊天记录里</td><td>标准化文件，可版本控制，沉淀为团队资产</td></tr></tbody></table>
<p><strong>一句话总结</strong>：Skills 让 AI 从"通用实习生"变成"懂行老手"，知道在什么时候该用什么方法做什么事。</p>
<p>这里也推荐我在B站看的科普视频，讲得很形象</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1dz6oBWEWx%2F%3Fspm_id_from%3D333.1391.0.0" target="_blank" title="https://www.bilibili.com/video/BV1dz6oBWEWx/?spm_id_from=333.1391.0.0" ref="nofollow noopener noreferrer">www.bilibili.com/video/BV1dz…</a></p>
<h2 data-id="heading-2">二、在 CodeBuddy中使用 Skills：从零开始</h2>
<p>这里为啥用CodeBuddy这个软件，无他，就因为免费，大多数人能够直接接触到，国外的一些IDE和模型都要用魔法，新手使用不方便</p>
<p>CodeBuddy（腾讯的 AI IDE）近期全面支持了 Skills 功能，并且支持<strong>全局 Skills</strong>（所有项目通用）和<strong>项目 Skills</strong>（仅当前项目生效）两种类型</p>
<h3 data-id="heading-3">第一步：创建 Skills 的目录</h3>
<p>Skills 通过在特定目录中创建 <code>SKILL.md</code> 文件来定义：</p>
<blockquote>
<ol>
<li><strong>项目级 Skills</strong>：<code>.codebuddy/skills/</code>（项目根目录下）</li>
<li><strong>用户级 Skills</strong>：<code>~/.codebuddy/skills/</code>（用户主目录下）</li>
</ol>
</blockquote>
<p>每个 Skill 一个独立的目录，包含 <code>SKILL.md</code> 文件，整体框架目录如下：</p>
<pre><code class="hljs language-objectivec" lang="objectivec">.codebuddy/skills/
├── pdf/
│   └── <span class="hljs-built_in">SKILL</span>.md
├── data-analysis/
│   └── <span class="hljs-built_in">SKILL</span>.md
└── code-review/
    └── <span class="hljs-built_in">SKILL</span>.md
</code></pre>
<p>每个技能文件夹下面又可以细分</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-built_in">skill-name</span>(pdf)/
├── SKILL<span class="hljs-selector-class">.md</span> (必需)
│   ├── YAML frontmatter 元数据 (必需)
│   │   ├── name: (必需)
│   │   └── description: (必需)
│   └── Markdown 指令 (必需)
└── Bundled Resources (可选)
    ├── scripts/          - 可执行代码 (Python/Bash 等)
    ├── references/       - 旨在根据需要加载到上下文中的文档
    └── assets/           - 用在输出中的文件 (模板、图标、字体等)
</code></pre>
<h4 data-id="heading-4"><strong>SKILL.md (必需)</strong></h4>
<p>这是 Skill 的核心定义文件。</p>
<p><strong>元数据 (</strong> <strong>YAML</strong> <strong>Frontmatter):</strong> <strong><code>name</code></strong> ****和 <strong><code>description</code></strong> ****决定了 AI 何时会使用这个 Skill。描述需具体说明 Skill 的功能和使用场景。</p>
<p>示例：</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-meta">---</span>
<span class="hljs-attr">name:</span> <span class="hljs-string">pdf-editor</span>
<span class="hljs-attr">description:</span> <span class="hljs-string">This</span> <span class="hljs-string">skill</span> <span class="hljs-string">should</span> <span class="hljs-string">be</span> <span class="hljs-string">used</span> <span class="hljs-string">when</span> <span class="hljs-string">users</span> <span class="hljs-string">ask</span> <span class="hljs-string">to</span> <span class="hljs-string">modify,</span> <span class="hljs-string">rotate,</span> <span class="hljs-string">or</span> <span class="hljs-string">extract</span> <span class="hljs-string">text</span> <span class="hljs-string">from</span> <span class="hljs-string">PDF</span> <span class="hljs-string">files.</span>
<span class="hljs-attr">allowed-tools:</span> <span class="hljs-comment"># 可选，指定允许使用的工具</span>
<span class="hljs-attr">disable:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 可选，是否禁用</span>
<span class="hljs-meta">---
</span>
<span class="hljs-comment"># PDF Editor</span>

<span class="hljs-string">To</span> <span class="hljs-string">rotate</span> <span class="hljs-string">a</span> <span class="hljs-string">PDF...</span>
</code></pre>
<h4 data-id="heading-5">打包资源 (可选)</h4>
<ol>
<li>
<h5 data-id="heading-6">Scripts (<code>scripts/</code>)</h5>
</li>
</ol>
<p>用于需要确定性可靠性或被重复重写的任务的可执行代码。</p>
<blockquote>
<ul>
<li><strong>用途</strong>：当代码被重复重写或需要高可靠性时。</li>
<li><strong>示例</strong>：<code>scripts/rotate_pdf.py</code> 用于 PDF 旋转。</li>
</ul>
</blockquote>
<ol start="2">
<li>
<h5 data-id="heading-7">References (<code>references/</code>)</h5>
</li>
</ol>
<p>旨在根据需要加载到上下文中以辅助 AI 思考的文档和参考资料。</p>
<blockquote>
<ul>
<li><strong>用途</strong>：数据库架构、API 文档、领域知识、公司政策等。</li>
<li><strong>优势</strong>：保持 <code>SKILL.md</code> 精简，仅在 AI 确定需要时才加载。</li>
</ul>
</blockquote>
<ol start="3">
<li>
<h5 data-id="heading-8">Assets (<code>assets/</code>)</h5>
</li>
</ol>
<p>不打算加载到上下文中，而是用于 AI 生成的输出中的文件。</p>
<blockquote>
<ul>
<li><strong>用途</strong>：品牌资产、PPT 模板、HTML/React 样板代码等。</li>
</ul>
</blockquote>
<p>了解完上面，创建的目录如下：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/95ef5ff2961446ffaab769cd380d7c7e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6K6p5oiR5LiK5Liq6LaF5b2x5ZCn:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770717839&amp;x-signature=GEQXlKl4R5PfFisTnG6kejVThW0%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-9">第二步：创建你的第一个 Skill：比想象中简单</h3>
<p>一个标准的 Skill 就是一个文件夹，核心是 ****<strong><code>SKILL.md</code></strong> <strong>文件</strong></p>
<p>一个 Skill 本质上就是一个 Markdown 文件（文件名固定为 SKILL.md），内容几乎只由下面三段组成：</p>
<p>SKILL.md 基本模板:</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-meta">---</span>
<span class="hljs-attr">name:</span> <span class="hljs-string">your-skill-name</span>
<span class="hljs-attr">description:</span> <span class="hljs-string">What</span> <span class="hljs-string">it</span> <span class="hljs-string">does</span> <span class="hljs-string">and</span> <span class="hljs-string">when</span> <span class="hljs-string">Claude</span> <span class="hljs-string">should</span> <span class="hljs-string">use</span> <span class="hljs-string">it</span>
<span class="hljs-meta">---
</span>
<span class="hljs-comment"># Skill Title</span>

<span class="hljs-comment">## Instructions</span>
<span class="hljs-string">Clear,</span> <span class="hljs-string">concrete,</span> <span class="hljs-string">actionable</span> <span class="hljs-string">rules.</span>

<span class="hljs-comment">## Examples</span>
<span class="hljs-bullet">-</span> <span class="hljs-string">Example</span> <span class="hljs-string">usage</span> <span class="hljs-number">1</span>
<span class="hljs-bullet">-</span> <span class="hljs-string">Example</span> <span class="hljs-string">usage</span> <span class="hljs-number">2</span>

<span class="hljs-comment">## Guidelines</span>
<span class="hljs-bullet">-</span> <span class="hljs-string">Guideline</span> <span class="hljs-number">1</span>
<span class="hljs-bullet">-</span> <span class="hljs-string">Guideline</span> <span class="hljs-number">2</span>
</code></pre>



































<table><thead><tr><th>字段</th><th>必填</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>name</td><td>否</td><td>Skill 名称,未指定时使用目录名</td><td>pdf</td></tr><tr><td>description</td><td>否</td><td>Skill 描述,帮助 AI 理解何时使用</td><td>PDF 文档处理专家 （project)</td></tr><tr><td>allowed-tools</td><td>否</td><td>允许使用的工具白名单,逗号分隔</td><td>Read, Write, Bash</td></tr><tr><td>disable-model-invocation</td><td>否</td><td>设置为 true 时，Skill 不会出现在 Skill 工具中，只能通过 /skill-name 手动触发</td><td>TRUE</td></tr></tbody></table>
<p>这里给出一个案例，大家可以进行尝试，比较简单，所以只是用<strong>SKILL.md</strong>即可，不需要脚本和素材之类的</p>
<p><strong>示例 ：前端页面设计 Skill</strong></p>
<p><strong>文件</strong>：<code>.codebuddy/skills/frontend-design/SKILL.md</code></p>
<pre><code class="hljs language-markdown" lang="markdown">---
name: frontend-design
description: 创建具有高品质设计的独特、生产级前端界面。当用户要求构建 Web 组件、页面、作品、海报或应用程序时使用此技能（示例包括网站、落地页、仪表盘、React 组件、HTML/CSS 布局，或为任何 Web UI 进行美化/优化）。生成具有创意、精致代码和 UI 设计，避免通用 AI 美学。
<span class="hljs-section">license: 完整条款见 LICENSE.txt
---</span>

本技能指导创建独特、生产级前端界面，避免通用的"AI 垃圾"美学。实现真正可用的代码，对美学细节和创意选择给予特别关注。

用户提供前端需求：要构建的组件、页面、应用程序或界面。他们可能包含有关用途、受众或技术约束的上下文。

<span class="hljs-section">## 设计思维</span>

在编码之前，理解上下文并致力于<span class="hljs-strong">**大胆**</span>的美学方向：
<span class="hljs-bullet">-</span> <span class="hljs-strong">**目的**</span>：此界面解决什么问题？谁使用它？
<span class="hljs-bullet">-</span> <span class="hljs-strong">**风格**</span>：选择一个极端：极简主义、极繁主义混乱、复古未来主义、有机/自然、奢华/精致、趣味/玩具风、编辑/杂志风、粗野主义/原始、装饰艺术/几何、柔和/ pastel、工业/实用等。有众多风格可供选择。将这些作为灵感，但设计出忠于美学方向的风格。
<span class="hljs-bullet">-</span> <span class="hljs-strong">**约束**</span>：技术要求（框架、性能、无障碍）。
<span class="hljs-bullet">-</span> <span class="hljs-strong">**差异化**</span>：是什么让它<span class="hljs-strong">**令人难忘**</span>？有什么是别人会记住的？

<span class="hljs-strong">**关键**</span>：选择清晰的概念方向并精准执行。大胆极繁和精致极简都有效——关键是意图性，而非强度。

然后实现可用的代码（HTML/CSS/JS、React、Vue 等），具备：
<span class="hljs-bullet">-</span> 生产级和功能完整
<span class="hljs-bullet">-</span> 视觉冲击力和令人难忘
<span class="hljs-bullet">-</span> 具有清晰美学观点的连贯性
<span class="hljs-bullet">-</span> 每个细节都精心打磨

<span class="hljs-section">## 前端美学指南</span>

专注于：
<span class="hljs-bullet">-</span> <span class="hljs-strong">**字体排版**</span>：选择美观、独特、有趣的字体。避免通用字体如 Arial 和 Inter；选择能够提升前端美学的独特字体；出人意料、有个性的字体选择。将独特的展示字体与精致正文字体搭配。
<span class="hljs-bullet">-</span> <span class="hljs-strong">**色彩与主题**</span>：致力于连贯的美学。使用 CSS 变量保持一致性。主色调搭配锐利点缀色胜过胆怯、均匀分布的调色板。
<span class="hljs-bullet">-</span> <span class="hljs-strong">**动效**</span>：使用动画实现效果和微交互。HTML 优先使用纯 CSS 方案。React 可用时使用 Motion 库。专注于高影响力时刻：一个精心编排的页面加载配合交错显示（animation-delay）比分散的微交互带来更多愉悦。使用滚动触发和令人惊喜的悬停状态。
<span class="hljs-bullet">-</span> <span class="hljs-strong">**空间构图**</span>：意想不到的布局。不对称。重叠。对角线流动。打破网格的元素。充足的负空间<span class="hljs-strong">**或**</span>控制的密度。
<span class="hljs-bullet">-</span> <span class="hljs-strong">**背景与视觉细节**</span>：创造氛围和深度，而非默认纯色。添加与整体美学匹配的上下文效果和纹理。应用创意形式如渐变网格、噪点纹理、几何图案、分层透明、戏剧性阴影、装饰性边框、自定义光标和颗粒叠加。

永远不要使用通用的 AI 生成美学，如过度使用的字体家族（Inter、Roboto、Arial、系统字体）、陈词滥调的配色方案（特别是白色背景上的紫色渐变）、可预测的布局和组件模式，以及缺乏上下文特性的千篇一律设计。

富有创意地诠释并做出出人意料的选择，让人感觉真正为上下文而设计。没有设计应该是相同的。在明暗主题、不同字体、不同美学之间变化。永远不要跨越世代趋同于常见选择（例如 Space Grotesk）。

<span class="hljs-strong">**重要**</span>：将实现复杂度与美学愿景匹配。极繁主义设计需要包含大量动画和效果的复杂代码。极简或精致设计需要克制、精确，并仔细关注间距、字体和微妙细节。优雅来自于良好地执行愿景。

记住：Claude 能够创造非凡的创意作品。不要退缩，展示当跳出思维定势并完全致力于独特愿景时，真正能创造什么。
</code></pre>
<h3 data-id="heading-10">第三步：使用Skill</h3>
<p>我们写一个前端html页面，刚好满足这个Skill，看下AI如何操作吧</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/61ad47b1f8744996ab1d898759babf3e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6K6p5oiR5LiK5Liq6LaF5b2x5ZCn:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770717839&amp;x-signature=6HnIquCrBV%2BHYJfmqVk17y7lgtU%3D" alt="" loading="lazy"/></p>
<p>可以看到AI自己自动使用Skill，接下来我们看一下页面的效果吧</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cc64e64a445847bbbff04545f870d821~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6K6p5oiR5LiK5Liq6LaF5b2x5ZCn:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770717839&amp;x-signature=fJxW27jONiCVsEPno1mANSUrOgI%3D" alt="" loading="lazy"/></p>
<p>还是比较好看的</p>
<h2 data-id="heading-11">三、推荐开源 Skills及如何下载使用</h2>
<p>以下是 GitHub 上最热门的 Skills 仓库，下载后按照需要将对应的Skill导入到 <code>.codebuddy/skills/</code> 目录：</p>
<h3 data-id="heading-12">开源Skills</h3>
<blockquote>
<h4 data-id="heading-13">1. <strong>anthropics/skills</strong>（官方，必装）</h4>
<ul>
<li><strong>Star</strong>: 40k+</li>
<li><strong>地址</strong>: <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fanthropics%2Fskills" target="_blank" title="https://github.com/anthropics/skills" ref="nofollow noopener noreferrer">github.com/anthropics/…</a></li>
<li><strong>亮点</strong>：官方出品，包含文档处理（PDF/Word/Excel/PPT）、skill-creator（创建 Skill 的 Skill）、MCP 构建器等。新手入门首选。</li>
</ul>
</blockquote>
<h4 data-id="heading-14">2. <strong>obra/superpowers</strong>（社区最强）</h4>
<blockquote>
<ul>
<li><strong>Star</strong>: 22k+</li>
<li><strong>地址</strong>: <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fobra%2Fsuperpowers" target="_blank" title="https://github.com/obra/superpowers" ref="nofollow noopener noreferrer">github.com/obra/superp…</a></li>
<li><strong>亮点</strong>：包含 20+ 实战技能，涵盖 TDD 测试驱动开发、Debug 调试模式、团队协作规范等，非常接地气。</li>
</ul>
</blockquote>
<h4 data-id="heading-15">3. <strong>vercel-labs/agent-skills</strong>（前端专属）</h4>
<blockquote>
<ul>
<li><strong>地址</strong>: <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fvercel-labs%2Fagent-skills" target="_blank" title="https://github.com/vercel-labs/agent-skills" ref="nofollow noopener noreferrer">github.com/vercel-labs…</a></li>
<li><strong>亮点</strong>：Vercel 团队维护，包含 <code>react-best-practices</code> 和 <code>vue-best-practices</code>，整理了 40+ 条 React/Next.js 性能与架构规则，AI 写代码时会主动提示性能陷阱。</li>
</ul>
</blockquote>
<h4 data-id="heading-16">4. <strong>K-Dense-AI/claude-scientific-skills</strong>（科研专属）</h4>
<blockquote>
<ul>
<li><strong>Star</strong>: 5.8k+</li>
<li><strong>地址</strong>: <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FK-Dense-AI%2Fclaude-scientific-skills" target="_blank" title="https://github.com/K-Dense-AI/claude-scientific-skills" ref="nofollow noopener noreferrer">github.com/K-Dense-AI/…</a></li>
<li><strong>亮点</strong>：140+ 科学领域技能，生物、化学、数据分析、文献整理全覆盖，研究人员必备。</li>
</ul>
</blockquote>
<h4 data-id="heading-17">5. <strong>ComposioHQ/awesome-claude-skills</strong>（资源合集）</h4>
<blockquote>
<ul>
<li><strong>Star</strong>: 19k+</li>
<li><strong>地址</strong>: <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FComposioHQ%2Fawesome-claude-skills" target="_blank" title="https://github.com/ComposioHQ/awesome-claude-skills" ref="nofollow noopener noreferrer">github.com/ComposioHQ/…</a></li>
<li><strong>亮点</strong>：Awesome 列表形式，汇集了官方和社区的各种 Skills，分类清晰，持续更新。</li>
</ul>
</blockquote>
<h3 data-id="heading-18"><strong>导入方法</strong>：</h3>
<ul>
<li><strong>CodeBuddy</strong> <strong>IDE</strong>：设置 → Skill 配置路径 → 导入本地文件夹</li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c67b033257584487b2cb671da8e6ffcc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6K6p5oiR5LiK5Liq6LaF5b2x5ZCn:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770717839&amp;x-signature=axxYAgivrObZiTrbkt0pPc2fco4%3D" alt="" loading="lazy"/></p>
<p>下载Skills，这里我是下载的第一个开源项目的所有的Skills</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4908fe0749a1430399b886710b293e11~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6K6p5oiR5LiK5Liq6LaF5b2x5ZCn:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770717839&amp;x-signature=k16fcVv7YABX5oFk9Jdl4pWYvu0%3D" alt="" loading="lazy"/></p>
<p>选中你所需要的一条Skill导入CodeBuddy即可</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1e34c1aa35244f1eaf7a4d6183a0744b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6K6p5oiR5LiK5Liq6LaF5b2x5ZCn:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770717839&amp;x-signature=uA8%2FqOUN6daxIsIPEZm262j6Ah4%3D" alt="" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/76f2098873f244f4af5b541fb8e1a4af~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6K6p5oiR5LiK5Liq6LaF5b2x5ZCn:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770717839&amp;x-signature=TmIH4TjSfrtUNjKjSFyl6uOk86w%3D" alt="" loading="lazy"/></p>
<p>可以看到导入成功了</p>
<p>其实刚才最开始的示例我也是直接复制的这个开源项目的Skill才使得前端页面生成比较好看</p>
<h2 data-id="heading-19">四、Skills与MCP的区别</h2>
<p>最后就是很多人会混淆Skills和MCP，它们确实有相似之处，但解决的问题完全不同：</p>



































<table><thead><tr><th>对比维度</th><th>Skills</th><th>MCP</th></tr></thead><tbody><tr><td>核心定位</td><td>解决"方法论"问题，教AI怎么做某类任务</td><td>解决"连接"问题，让AI能访问外部世界</td></tr><tr><td>加载方式</td><td>按需加载，只加载技能名字和描述，使用时才加载执行细节</td><td>全量加载，不管用不用都全部加载进去</td></tr><tr><td>适用场景</td><td>固定工作流程，需要AI按步骤执行</td><td>访问外部数据或服务，深度集成外部系统</td></tr><tr><td>输入输出</td><td>自然语言描述和结果，灵活易读</td><td>JSON结构化参数和结果，可组合可测试</td></tr><tr><td>扩展性</td><td>可以无限增加技能，不会明显拖慢对话</td><td>工具越多，上下文越爆炸，成本和延迟越高</td></tr></tbody></table>
<p><strong>大白话理解</strong>：</p>
<blockquote>
<ul>
<li>Skills主要聚焦于工具处理，是一套完整的方法论，例如处理文件、设计、写文章</li>
<li>MCP主要起到连接作用，适合深度集成外部系统，自定义上传、下载、推送等流程</li>
</ul>
</blockquote>
<p>两者并不是竞争或替代的关系，而是结合关系。对于普通用户、日常工作，大部分时候只需要Skills就足够；对于复杂的企业场景、跨平台/自动分发等任务，使用Skills + MCP可以实现更加稳定和高效的输出。</p>
<p><strong>什么时候用Skills，什么时候用</strong> <strong>mcp</strong> <strong>？</strong></p>
<p>判断标准：任务是"如何做"还是"做什么"？</p>
<blockquote>
<ul>
<li>
<p><strong>Skills</strong>：当你有固定的工作流程，需要AI按步骤执行时</p>
<ul>
<li>示例："按什么格式写技术教程"、"代码审查的5个步骤"</li>
</ul>
</li>
<li>
<p><strong>MCP</strong>：当你需要AI访问外部数据或服务时</p>
<ul>
<li>示例："查询GitHub的Issue"、"读取SQLite数据库"</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>感兴趣的宝子可以关注一波，后续会更新更多有用的知识！！！</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/94d92b4ed927471ba156d58f7dd69c7f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6K6p5oiR5LiK5Liq6LaF5b2x5ZCn:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770717839&amp;x-signature=mLWFttNhmqNRforBOjGFITujbJs%3D" alt="" loading="lazy"/></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Go errgroup 源码深度剖析：从原理到 Context 取消机制全解析]]></title>    <link>https://juejin.cn/post/7602205524718927906</link>    <guid>https://juejin.cn/post/7602205524718927906</guid>    <pubDate>2026-02-03T10:07:36.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602205524718927906" data-draft-id="7602246300453306403" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content=" Go errgroup 源码深度剖析：从原理到 Context 取消机制全解析"/> <meta itemprop="keywords" content="源码"/> <meta itemprop="datePublished" content="2026-02-03T10:07:36.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="下次一定57"/> <meta itemprop="url" content="https://juejin.cn/user/3722294009017404"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
             Go errgroup 源码深度剖析：从原理到 Context 取消机制全解析
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3722294009017404/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    下次一定57
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T10:07:36.000Z" title="Tue Feb 03 2026 10:07:36 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读11分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">Go errgroup</h2>
<p>专门用于简化一组 goroutine 的生命周期管理和错误收集，解决了普通<code>WaitGroup</code>无法便捷收集错误、无法快速取消其他 goroutine 的痛点。</p>
<h2 data-id="heading-1">errgroup vs 原生 WaitGroup</h2>






























<table><thead><tr><th align="center">特性</th><th align="center">sync.WaitGroup</th><th align="center">errgroup</th></tr></thead><tbody><tr><td align="center">等待 goroutine 结束</td><td align="center">需要手动 Add/Done</td><td align="center">自动管理，无需手动调用</td></tr><tr><td align="center">收集错误</td><td align="center">需要自己用 channel 实现</td><td align="center">自动收集第一个非 nil 错误</td></tr><tr><td align="center">取消其他 goroutine</td><td align="center">需要自己结合 Context 实现</td><td align="center">内置 Context，自动取消</td></tr><tr><td align="center">使用复杂度</td><td align="center">低（但扩展功能复杂）</td><td align="center">中（一站式解决多 goroutine 问题）</td></tr></tbody></table>
<h2 data-id="heading-2">使用示例</h2>
<p>下面代码是 通过开启三个 goroutine 并发执行，能够感知错误，并且便捷收集第一个错误</p>
<p><code>context.Cause(ctx)</code>  这个函数是专门用来获取 Context 取消原因的，后续会详细介绍</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> (
	<span class="hljs-string">"context"</span>
	<span class="hljs-string">"errors"</span>
	<span class="hljs-string">"fmt"</span>
	<span class="hljs-string">"time"</span>

	<span class="hljs-string">"golang.org/x/sync/errgroup"</span>
)

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
	eg, ctx := errgroup.WithContext(context.Background())
	eg.Go(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> {
		fmt.Println(<span class="hljs-string">"doing task1"</span>)
		time.Sleep(<span class="hljs-number">5</span> * time.Second)
		<span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">"task1 error"</span>) <span class="hljs-comment">// 业务错误：作为取消原因 这边取消 其他 goroutine  就会走 &lt;-ctx.Done()</span>
	})

	eg.Go(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> {
		<span class="hljs-keyword">for</span> {
			<span class="hljs-keyword">select</span> {
			<span class="hljs-keyword">case</span> &lt;-time.After(time.Second):
				fmt.Println(<span class="hljs-string">"doing task2"</span>)
			<span class="hljs-keyword">case</span> &lt;-ctx.Done():
				fmt.Println(<span class="hljs-string">"task2 canceled"</span>)
				<span class="hljs-comment">// 可以调用 context.Cause()，获取取消的具体原因 </span>
				cause := context.Cause(ctx)
				fmt.Printf(<span class="hljs-string">"task2 被取消的原因：%v\n"</span>, cause)
				<span class="hljs-keyword">return</span> ctx.Err()  <span class="hljs-comment">//这时候 return 的错误 是第二次或者第三次了 我们只记录第一次的</span>
			}
		}
	})

	eg.Go(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> {
		<span class="hljs-keyword">for</span> {
			<span class="hljs-keyword">select</span> {
			<span class="hljs-keyword">case</span> &lt;-time.After(time.Second):
				fmt.Println(<span class="hljs-string">"doing task3"</span>)
			<span class="hljs-keyword">case</span> &lt;-ctx.Done():
				fmt.Println(<span class="hljs-string">"task3 canceled"</span>)
				<span class="hljs-comment">// 可以调用 context.Cause()，获取取消的具体原因</span>
				cause := context.Cause(ctx)
				fmt.Printf(<span class="hljs-string">"task3 被取消的原因：%v\n"</span>, cause)
				<span class="hljs-keyword">return</span> ctx.Err()
			}
		}
	})

	err := eg.Wait()
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
		fmt.Println(<span class="hljs-string">"task failed"</span>)
		<span class="hljs-comment">// 在 Wait() 后, 返回第一次错误</span>
		fmt.Printf(<span class="hljs-string">"整体任务被取消的原因：%v\n"</span>, err)
	} <span class="hljs-keyword">else</span> {
		fmt.Println(<span class="hljs-string">"task success"</span>)
	}
}

</code></pre>
<h2 data-id="heading-3">errgroup 源码解析</h2>
<h3 data-id="heading-4">内部结构体</h3>
<pre><code class="hljs language-go" lang="go"><span class="hljs-comment">// 空结构体在 Go 中不占用字节内存，是标准用于通知的</span>
<span class="hljs-keyword">type</span> token <span class="hljs-keyword">struct</span>{}

<span class="hljs-keyword">type</span> Group <span class="hljs-keyword">struct</span> {
	cancel <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">error</span>)</span></span>  <span class="hljs-comment">//  取消下级关联 Context 的函数</span>

	wg sync.WaitGroup  <span class="hljs-comment">// 管理 goroutine 的等待，替代手动 Add/Done</span>

	sem <span class="hljs-keyword">chan</span> token  <span class="hljs-comment">// 带缓冲的通道 限制最大能有几个 goroutine 并行 用 SetLimit 函数去指明 不用这个函数那这个字段就不用管</span>

	errOnce sync.Once  <span class="hljs-comment">// 原子语句  无论多少 goroutine 写入 都只执行一次 </span>
	err     <span class="hljs-type">error</span>
}

</code></pre>
<h3 data-id="heading-5">入口函数</h3>
<p>新版本使用了 <code>WithCancelCause</code>  换掉了传统的 <code>context.WithCancel</code></p>
<p>对于  <code>context.WithCancelCause</code> 与  <code>context.WithCancel</code> 的 源码 放在文章最后，深入理解 <code>context</code>  可阅读</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithContext</span><span class="hljs-params">(ctx context.Context)</span></span> (*Group, context.Context) {
    <span class="hljs-comment">//返回 子Context 和 可以取消的函数  这里覆盖了主 ctx 无所谓</span>
	ctx, cancel := context.WithCancelCause(ctx)
 	<span class="hljs-comment">// 返回 errgroup 内置 结构体 和 context</span>
	<span class="hljs-keyword">return</span> &amp;Group{cancel: cancel}, ctx
}

</code></pre>
<h3 data-id="heading-6"><code>(g *Group) SetLimit(n int)</code> 函数</h3>
<p>用于控制同时活跃的 goroutine 数量，实现并发限制，小于0，就没有限制，也就不用 <code>g.sem</code> 字段</p>
<p>必须是在初始化的时候去调用 <code>SetLimit</code>  函数，必须保证当前无活跃 goroutine，否则直接 panic 为了安全</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span></span> SetLimit(n <span class="hljs-type">int</span>) {
	<span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">0</span> {
		g.sem = <span class="hljs-literal">nil</span>
		<span class="hljs-keyword">return</span>
	}
	<span class="hljs-keyword">if</span> active := <span class="hljs-built_in">len</span>(g.sem); active != <span class="hljs-number">0</span> {
		<span class="hljs-built_in">panic</span>(fmt.Errorf(<span class="hljs-string">"errgroup: modify limit while %v goroutines in the group are still active"</span>, active))
	}
    <span class="hljs-comment">// 启动 容量为 n 的 cannel </span>
	g.sem = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> token, n)
}

</code></pre>
<h3 data-id="heading-7"><code>(g *Group) done()</code> 函数</h3>
<p>本质对 <code>WaitGroup</code> 封装了一个 对 goroutine 数量限制 不设置的话 就相当于 <code>WaitGroup.Done()</code></p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span></span> done() {
	<span class="hljs-keyword">if</span> g.sem != <span class="hljs-literal">nil</span> {  <span class="hljs-comment">// 如果设置了goroutine数量限制</span>
		&lt;-g.sem       <span class="hljs-comment">// 释放信号量，从sem通道取出一个token，允许新的goroutine启动</span>
	}
	g.wg.Done()       <span class="hljs-comment">// 通知 WaitGroup：一个goroutine执行完成</span>
}
</code></pre>
<h3 data-id="heading-8"><code>(g *Group) Wait()</code> 函数</h3>
<p>同样也是多封装了一下 调用 <code>cancel(g.err) </code>方法 去记录错误（如果有的话） 内部具体细节可以看最后源码</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span></span> Wait() <span class="hljs-type">error</span> {
	g.wg.Wait()          <span class="hljs-comment">// 阻塞，直到所有goroutine调用了wg.Done()</span>
	<span class="hljs-keyword">if</span> g.cancel != <span class="hljs-literal">nil</span> { <span class="hljs-comment">// 如果绑定了Context（通过WithContext创建）</span>
		g.cancel(g.err)  <span class="hljs-comment">// 取消Context，传递错误作为取消原因</span>
	}
	<span class="hljs-keyword">return</span> g.err         <span class="hljs-comment">// 返回第一个非nil错误（无错误则返回nil）</span>
}
</code></pre>
<h3 data-id="heading-9">核心 <code>(g *Group) Go</code> 函数</h3>
<p>这里并没有捕获 <code>panic</code> ，如果捕捉的话可能导致 <code>panic</code> 时机延迟，调试困难，<code>panic</code> 栈会被转为普通值，无法被监控工具捕获，而且还可能导致死锁</p>
<p>比如 两个<code>goroutine</code>被创建 第一个发生 <code>panic </code>第二个在阻塞等待，<code>Wait</code> 需要等待两个任务结束才返回，死锁</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span></span> Go(f <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span>) {
	<span class="hljs-comment">// 若设置了goroutine数量限制，先获取信号量 如果已经满了 阻塞直到有空闲token</span>
	<span class="hljs-keyword">if</span> g.sem != <span class="hljs-literal">nil</span> {
		g.sem &lt;- token{} <span class="hljs-comment">// 发送空token到sem通道，占用一个并发名额</span>
	}

	<span class="hljs-comment">// 增加WaitGroup计数</span>
	g.wg.Add(<span class="hljs-number">1</span>)
	
	<span class="hljs-comment">// 启动新goroutine执行任务</span>
	<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> {
		<span class="hljs-keyword">defer</span> g.done() <span class="hljs-comment">// 最后执行无论错误还是正常</span>

		<span class="hljs-comment">// 执行用户传入的函数，获取错误</span>
		<span class="hljs-keyword">if</span> err := f(); err != <span class="hljs-literal">nil</span> {
			<span class="hljs-comment">// 仅第一次执行  保证只存第一个错误</span>
			g.errOnce.Do(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> {
				g.err = err          <span class="hljs-comment">// 存储第一个错误</span>
				<span class="hljs-keyword">if</span> g.cancel != <span class="hljs-literal">nil</span> { <span class="hljs-comment">// 若绑定了Context，取消所有关联 goroutine 大部分都会有的 因为我们在入口传了</span>
					g.cancel(g.err)
				}
			})
		}
	}()
}

<span class="hljs-comment">// 这个函数和 Go 的唯一区别就是 它不阻塞 一旦数量满了 直接退出</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span></span> TryGo(f <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span>) <span class="hljs-type">bool</span> {
    	<span class="hljs-keyword">if</span> g.sem != <span class="hljs-literal">nil</span> {
		<span class="hljs-keyword">select</span> {
		<span class="hljs-keyword">case</span> g.sem &lt;- token{}: <span class="hljs-comment">// 成功获取token</span>
		<span class="hljs-keyword">default</span>:               <span class="hljs-comment">// 无空闲token  并发数达上限，直接返回false</span>
			<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
		}
	}
    ...  <span class="hljs-comment">//逻辑一样</span>
}

</code></pre>
<h2 data-id="heading-10">Context 部分源码</h2>
<h3 data-id="heading-11"><code>context.WithCancelCause</code> 与  <code>context.WithCancel</code> 的 源码 区别</h3>
<p>简单理解就是在返回 <code>cancel</code>函数的时候多了一个参数而已</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithCancel</span><span class="hljs-params">(parent Context)</span></span> (ctx Context, cancel CancelFunc) {
	c := withCancel(parent)
	<span class="hljs-keyword">return</span> c, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> { c.cancel(<span class="hljs-literal">true</span>, Canceled, <span class="hljs-literal">nil</span>) }
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithCancelCause</span><span class="hljs-params">(parent Context)</span></span> (ctx Context, cancel CancelCauseFunc) {
	c := withCancel(parent)
	<span class="hljs-keyword">return</span> c, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(cause <span class="hljs-type">error</span>)</span></span> { c.cancel(<span class="hljs-literal">true</span>, Canceled, cause) }
}

</code></pre>
<h3 data-id="heading-12">先介绍核心结构体 <code>cancelCtx</code>  和 <code>cancelCtx.cancel</code> 方法</h3>
<p><code>context.WithCancel</code> 和 <code>context.WithCancelCause</code> 以及 <code>context.WithTimeout</code> 都有它的影子</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-comment">// 核心结构体 cancelCtx</span>
<span class="hljs-keyword">type</span> cancelCtx <span class="hljs-keyword">struct</span> {
	Context          <span class="hljs-comment">//       嵌入父Context，继承父Context的所有方法（Done/Err/Value等）  该字段是个接口</span>
	mu       sync.Mutex            <span class="hljs-comment">// 保护以下字段的并发读写安全</span>
	done     atomic.Value       <span class="hljs-comment">// 存储chan struct{}，负责通知外部阻塞函数 查看 Done方法 和 Cancel 方法 之后就明白</span>
	children <span class="hljs-keyword">map</span>[canceler]<span class="hljs-keyword">struct</span>{} <span class="hljs-comment">// 存储当前Context的子canceler，取消时会遍历取消所有子Context</span>
	err      atomic.Value          <span class="hljs-comment">// 存储取消时的错误（如context.Canceled），原子操作避免锁竞争</span>
	cause    <span class="hljs-type">error</span>                 <span class="hljs-comment">// WithCancelCause的核心 ：存储取消原因，仅在第一次取消时赋值</span>
}

<span class="hljs-comment">// context包内部的接口，定义了「可取消」的行为</span>
<span class="hljs-keyword">type</span> canceler <span class="hljs-keyword">interface</span> {
	cancel(removeFromParent <span class="hljs-type">bool</span>, err <span class="hljs-type">error</span>, cause <span class="hljs-type">error</span>)
	Done() &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>{}
}
</code></pre>
<h3 data-id="heading-13">核心方法 <code>cancelCtx.cancel</code></h3>
<p>这个函数 是写方法，使用频率是极低的 可能就是手动 cancel 或者 父 context 进行 cancel，为了防止并发问题也就是同时进行 <code>c.err.Load()</code> 发现没有，然后都执行了 <code>c.err.Store(err)</code> 是有问题的 我们只记录第一次 而且后面 <code>close(d)</code> 会报错，这里必须用锁，也不会影响性能</p>
<p>读方法 <code>Err()、Done()</code> 方法 常见 <code>for + select</code> 可能每个 goroutine 每毫秒跑几万次，这种就不能加锁，太影响性能 这个时候就体现出来 <code>atomic.Value </code> 这个字段的好处，防止一个 goroutine 在 <code>cancel() </code>里写 <code>c.err</code>，另一个 goroutine 同时在 Err() 里读 <code>c.err</code></p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *cancelCtx)</span></span> cancel(removeFromParent <span class="hljs-type">bool</span>, err, cause <span class="hljs-type">error</span>) {
    <span class="hljs-comment">// Context 设计原则：取消必须关联错误</span>
    <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> {
        <span class="hljs-built_in">panic</span>(<span class="hljs-string">"context: internal error: missing cancel error"</span>)
    }
    
    <span class="hljs-comment">// 旧版本 并没有 WithCancelCause 也就没有这个字段 兼容 旧逻辑</span>
    <span class="hljs-keyword">if</span> cause == <span class="hljs-literal">nil</span> {
        cause = err
    }

    <span class="hljs-comment">// 上面已经解释</span>
    c.mu.Lock()
    <span class="hljs-comment">// 看一下 里面有没有数据</span>
    <span class="hljs-keyword">if</span> c.err.Load() != <span class="hljs-literal">nil</span> {  <span class="hljs-comment">//原子地把值拿出来</span>
        c.mu.Unlock()
        <span class="hljs-keyword">return</span>  <span class="hljs-comment">// 说明有数据 已经写过了 只要写过了 就一定是在这个函数中写的 说明运行过一次 直接return</span>
    }

    <span class="hljs-comment">// 到这说明第一次进 cancel 方法 写入错误下一个 goroutine 再来调用 直接 return</span>
    c.err.Store(err)   <span class="hljs-comment">// 原子操作：高频读取时无需加锁，性能更优</span>
    c.cause = cause    <span class="hljs-comment">// 保证了仅第一次赋值有效  因为第二次直接 return </span>

    
    <span class="hljs-comment">// 关闭取消信号通道，用于通知外部 select { case &lt;-ctx.Done(): } 消除阻塞</span>
    d, _ := c.done.Load().(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>{})
    <span class="hljs-keyword">if</span> d == <span class="hljs-literal">nil</span> {
        <span class="hljs-comment">// 懒创建 下面会详细讲</span>
        c.done.Store(closedchan)
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// 若 done 通道已创建，关闭通道 消除阻塞</span>
        <span class="hljs-built_in">close</span>(d)
    }

    <span class="hljs-comment">// 递归取消所有子 Context</span>
    <span class="hljs-keyword">for</span> child := <span class="hljs-keyword">range</span> c.children {
        <span class="hljs-comment">// 持有父锁时获取子锁会有嵌套锁风险，但 Context 取消是低频操作，可接受 </span>
        child.cancel(<span class="hljs-literal">false</span>, err, cause)
    }
    <span class="hljs-comment">// 清空子列表，释放内存，避免泄漏</span>
    c.children = <span class="hljs-literal">nil</span>

    <span class="hljs-comment">//解锁</span>
    c.mu.Unlock()

    <span class="hljs-comment">// 基本上都是 True  默认移除 避免内存泄漏</span>
    <span class="hljs-keyword">if</span> removeFromParent {
        <span class="hljs-comment">// 从父 Context 移除自身</span>
        removeChild(c.Context, c)
    }
}

</code></pre>
<h3 data-id="heading-14">懒创建</h3>
<p>我们在写代码的时候，很少去写 <code>ctx.Done()</code>  方法，非常常见的两种，要么不用，要么只用  <code>cancel</code></p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-comment">// 第一种 不用</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">work</span><span class="hljs-params">(ctx context.Context)</span></span> {
    time.Sleep(<span class="hljs-number">10</span> * time.Second)
}

<span class="hljs-comment">// 第二种 只 cancel</span>
ctx, cancel := context.WithCancel(parent)
<span class="hljs-keyword">defer</span> cancel()

doSomething(ctx) <span class="hljs-comment">// ctx 只是被传来传去</span>
</code></pre>
<p>正常逻辑是 建完 <code>ctx</code> 要使用 <code>Done()</code>方法</p>
<p>它进行了两次判断 其实可以进行一次 在刚开始进来的时候加锁就可以直接判断是否有值，可以一样的效果，但是这个函数读极多，就写一次，所以大多数情况下都直接返回，根本不需要锁，如果按刚开始就加锁，性能直线下降</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *cancelCtx)</span></span> Done() &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>{} {  <span class="hljs-comment">//返回一个只能接收的 channel</span>
	d := c.done.Load() <span class="hljs-comment">//第一次读取</span>
	<span class="hljs-keyword">if</span> d != <span class="hljs-literal">nil</span> {
        <span class="hljs-comment">//之前已经调用过 Done() </span>
		<span class="hljs-keyword">return</span> d.(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>{})
	}
	c.mu.Lock()
	<span class="hljs-keyword">defer</span> c.mu.Unlock()
	d = c.done.Load() <span class="hljs-comment">// 第二次重新读取</span>
	<span class="hljs-keyword">if</span> d == <span class="hljs-literal">nil</span> {
        <span class="hljs-comment">// 第一次 初始化并存入</span>
		d = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>{})
		c.done.Store(d)
	}
	<span class="hljs-keyword">return</span> d.(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>{})
}
</code></pre>
<p>解释  <code> Done()</code>  是 极高频函数</p>
<p>go语言非常常见的 阻塞循环，每次执行 <code>ctx.Done()</code> 函数 返回的没有数据的 channel 只能走 default 逻辑，default 啥也不干 然后再回到 select 语句中 在执行 <code>ctx.Done()</code> 函数 直到 调用 <code>concel</code> 函数 ，可能每毫秒跑几万次，只第一次进行了修改，进行了两次判断，其他的都是直接返回，所以不能在刚开始进行加锁</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-keyword">for</span> {
    <span class="hljs-keyword">select</span> {
    <span class="hljs-keyword">case</span> &lt;-ctx.Done():
        <span class="hljs-keyword">return</span>
    <span class="hljs-keyword">default</span>:
    }
}
</code></pre>
<h3 data-id="heading-15">深入 <code>withCancel</code> 函数</h3>
<p>我们都知道 <code>parent</code> 参数一般情况就是我们自己传的 <code>ctx</code> 可能是 <code>context.WithCancel</code> 或者 <code>context.Background</code></p>
<p>在标准项目或者大型项目中，在主要内部结构体中会定义 <code>cancel</code> 字段用于 优雅退出</p>
<p>如果 <code>parent</code> 是  <code>context.Background</code>  没啥意义，</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">withCancel</span><span class="hljs-params">(parent Context)</span></span> *cancelCtx {
	<span class="hljs-keyword">if</span> parent == <span class="hljs-literal">nil</span> {
		<span class="hljs-built_in">panic</span>(<span class="hljs-string">"cannot create context from nil parent"</span>)
	}
	<span class="hljs-comment">// 1. 创建空的cancelCtx实例</span>
	c := &amp;cancelCtx{}
	<span class="hljs-comment">// 2. 建立当前 cancelCtx 和父 Context 的关联，作用是父取消时，子也会被取消</span>
	c.propagateCancel(parent, c)
	<span class="hljs-keyword">return</span> c
}
</code></pre>
<h3 data-id="heading-16"><code>propagateCancel</code> 函数</h3>
<pre><code class="hljs language-go" lang="go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *cancelCtx)</span></span> propagateCancel(parent Context, child canceler) {
	<span class="hljs-comment">// 挂载到字段 </span>
	c.Context = parent

	<span class="hljs-comment">// 查看 父Context是否可取消</span>
	done := parent.Done()
	<span class="hljs-keyword">if</span> done == <span class="hljs-literal">nil</span> {
		<span class="hljs-keyword">return</span> 		<span class="hljs-comment">//  如果是 context.Background 无需关联，父永远不会取消，子只能手动取消</span>
	}

	<span class="hljs-comment">// 检查父Context是否已经取消  非阻塞</span>
	<span class="hljs-keyword">select</span> {
	<span class="hljs-keyword">case</span> &lt;-done:
		<span class="hljs-comment">// 父已取消：立即取消子Context，继承父的错误和原因  这里的child 也就是我们刚创建的  空的cancelCtx实例</span>
		child.cancel(<span class="hljs-literal">false</span>, parent.Err(), Cause(parent))
		<span class="hljs-keyword">return</span>
	<span class="hljs-keyword">default</span>:  <span class="hljs-comment">// 父没取消  正常情况，在代码健壮的情况下 不太可能刚创建就取消了</span>
	}

	<span class="hljs-comment">// 断言 将父Context转为 *cancelCtx  几乎所有的Context 底层都有它的影子 这是最常见的</span>
	<span class="hljs-keyword">if</span> p, ok := parentCancelCtx(parent); ok {
		p.mu.Lock() <span class="hljs-comment">// 加锁保证并发安全</span>
		<span class="hljs-keyword">if</span> err := p.err.Load(); err != <span class="hljs-literal">nil</span> {
			<span class="hljs-comment">// 父已取消：立即取消刚创建的 cancelCtx实例</span>
			child.cancel(<span class="hljs-literal">false</span>, err.(<span class="hljs-type">error</span>), p.cause)
		} <span class="hljs-keyword">else</span> {
			<span class="hljs-comment">// 父未取消：将子Context加入父的children列表 当父取消时会遍历取消子</span>
			<span class="hljs-keyword">if</span> p.children == <span class="hljs-literal">nil</span> {  <span class="hljs-comment">//第一次需要创建</span>
				p.children = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[canceler]<span class="hljs-keyword">struct</span>{})
			}
			p.children[child] = <span class="hljs-keyword">struct</span>{}{}
		}
		p.mu.Unlock()
		<span class="hljs-keyword">return</span>   <span class="hljs-comment">// 大多数到这返回了</span>
	}

	<span class="hljs-comment">// 特殊情况：父Context实现了afterFuncer接口（比如WithDeadline/WithTimeout）</span>
	<span class="hljs-keyword">if</span> a, ok := parent.(afterFuncer); ok {
		c.mu.Lock()
		<span class="hljs-comment">// 注册回调：父取消时，触发子取消</span>
		stop := a.AfterFunc(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> {
			child.cancel(<span class="hljs-literal">false</span>, parent.Err(), Cause(parent))
		})
		<span class="hljs-comment">// 包装父Context，记录stop函数（子取消时可停止回调）</span>
		c.Context = stopCtx{
			Context: parent,
			stop:    stop,
		}
		c.mu.Unlock()
		<span class="hljs-keyword">return</span>
	}

	<span class="hljs-comment">// 兜底方案：父Context不是cancelCtx也不是afterFuncer，但可取消（Done()≠nil） 自己实现的 Context</span>
	goroutines.Add(<span class="hljs-number">1</span>)
	<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> {
		<span class="hljs-keyword">select</span> {
		<span class="hljs-keyword">case</span> &lt;-parent.Done():
			<span class="hljs-comment">// 父取消时，取消子Context</span>
			child.cancel(<span class="hljs-literal">false</span>, parent.Err(), Cause(parent))
		<span class="hljs-keyword">case</span> &lt;-child.Done():
			<span class="hljs-comment">// 子先取消，无需处理</span>
		}
	}()
}
</code></pre>
<h3 data-id="heading-17">核心函数 <code>context.Cause</code></h3>
<p><code>Cause</code> 是用户获取 Context 取消原因的 <strong>唯一入口</strong>， <code>errgroup</code> 在 <code>wait</code> 判断时，可以拿到第一个错误，你也可以调用这个函数拿到错误，阅读源码我们知道，<code>errgroup</code> 内部主动 <code>cancel(err)</code> 传入了错误，并存储在了 <code>cause</code> 当然可以用该函数拿出</p>
<p>后续可以通过 <code>cause := context.Cause(ctx)</code>  拿到错误</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Cause</span><span class="hljs-params">(c Context)</span></span> <span class="hljs-type">error</span> {
    <span class="hljs-comment">// 每个 Context 都有 Value(key any) any 这个函数 </span>
	<span class="hljs-keyword">if</span> cc, ok := c.Value(&amp;cancelCtxKey).(*cancelCtx); ok {
		cc.mu.Lock()
		cause := cc.cause
		cc.mu.Unlock()
		<span class="hljs-keyword">if</span> cause != <span class="hljs-literal">nil</span> {
			<span class="hljs-keyword">return</span> cause
		}
	}

	<span class="hljs-keyword">return</span> c.Err()
}

</code></pre>
<h3 data-id="heading-18"><code>Value</code> 函数</h3>
<p>其实就是递归向上找，我们这种情况直接返回，需要想上找的情况是自己存的业务 <code>key</code> ，后面会举例</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *cancelCtx)</span></span> Value(key any) any {
	<span class="hljs-keyword">if</span> key == &amp;cancelCtxKey {
		<span class="hljs-keyword">return</span> c
	}
	<span class="hljs-keyword">return</span> value(c.Context, key)
}

<span class="hljs-comment">// switch 所有的 已知的 context 找不到继续 向上找</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">value</span><span class="hljs-params">(c Context, key any)</span></span> any {
	<span class="hljs-keyword">for</span> {
		<span class="hljs-keyword">switch</span> ctx := c.(<span class="hljs-keyword">type</span>) {
		<span class="hljs-keyword">case</span> *valueCtx:
			<span class="hljs-keyword">if</span> key == ctx.key {
				<span class="hljs-keyword">return</span> ctx.val
			}
			c = ctx.Context
		<span class="hljs-keyword">case</span> *cancelCtx:
			<span class="hljs-keyword">if</span> key == &amp;cancelCtxKey {
				<span class="hljs-keyword">return</span> c
			}
			c = ctx.Context
		<span class="hljs-keyword">case</span> withoutCancelCtx:
			<span class="hljs-keyword">if</span> key == &amp;cancelCtxKey {
				<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
			}
			c = ctx.c
		<span class="hljs-keyword">case</span> *timerCtx:
			<span class="hljs-keyword">if</span> key == &amp;cancelCtxKey {
				<span class="hljs-keyword">return</span> &amp;ctx.cancelCtx
			}
			c = ctx.Context
		<span class="hljs-keyword">case</span> backgroundCtx, todoCtx:  <span class="hljs-comment">// 空 emptyCtx</span>
			<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
		<span class="hljs-keyword">default</span>:
			<span class="hljs-keyword">return</span> c.Value(key)
		}
	}
}
</code></pre>
<h3 data-id="heading-19">自定义业务 key</h3>
<pre><code class="hljs language-go" lang="go"><span class="hljs-comment">// 自定义业务 key</span>
<span class="hljs-keyword">type</span> userKey <span class="hljs-keyword">struct</span>{}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-comment">// 根 context，存入业务数据</span>
    ctx1 := context.WithValue(context.Background(), userKey{}, <span class="hljs-string">"张三"</span>)
    
    <span class="hljs-comment">// 在它基础上创建 cancelCtx</span>
    ctx2, cancel := context.WithCancel(ctx1)
    
    <span class="hljs-comment">// 再套一层 cancelCtx</span>
    ctx3, cancel2 := context.WithCancel(ctx2)
    
    <span class="hljs-comment">// 现在的结构：</span>
    <span class="hljs-comment">// Background (空)</span>
    <span class="hljs-comment">//    └── ctx1 (valueCtx, 存了 userKey="张三")</span>
    <span class="hljs-comment">//           └── ctx2 (cancelCtx)</span>
    <span class="hljs-comment">//                  └── ctx3 (cancelCtx)  ← 我们拿着这个</span>
    
    <span class="hljs-comment">// 查询业务数据：ctx3 本身没有，会递归向上找</span>
    user := ctx3.Value(userKey{})
    fmt.Println(<span class="hljs-string">"找到用户:"</span>, user)  <span class="hljs-comment">// 输出: 找到用户: 张三</span>
    
    <span class="hljs-comment">// 即使 cancel 了，依然能找到</span>
    cancel2()
    cancel()
    
    user2 := ctx3.Value(userKey{})
    fmt.Println(<span class="hljs-string">"cancel后:"</span>, user2)  <span class="hljs-comment">// 输出: cancel后: 张三</span>
}
</code></pre>
<h2 data-id="heading-20">总结</h2>
<p><code>errgroup</code> 是对  <code>sync.WaitGroup </code> 的增强封装，可以对 goroutine 数量限制 ，并且不需要显式的写<code>WaitGroup..Add(1)</code>，内部自动管理，防止漏写，出错自动 <code>cancel</code></p>
<p>如果自己相加业务逻辑 直接可以复制代码，按自己的需求添加字段或者函数</p>
<p>对于 <code>context</code> 源代码，要搞清楚当 <code>cancel</code> 后切断的是父对子的连接，但子有个字段专门存放父，这个并没有切断，才使得我们可以调用 <code>context.Cause</code> 方法一直向上找</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[JavaScript 内存机制与闭包原理深度剖析]]></title>    <link>https://juejin.cn/post/7602411521072087059</link>    <guid>https://juejin.cn/post/7602411521072087059</guid>    <pubDate>2026-02-03T10:02:42.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602411521072087059" data-draft-id="7602401081265504292" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="JavaScript 内存机制与闭包原理深度剖析"/> <meta itemprop="keywords" content="前端,JavaScript,面试"/> <meta itemprop="datePublished" content="2026-02-03T10:02:42.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="NEXT06"/> <meta itemprop="url" content="https://juejin.cn/user/1176918763246011"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            JavaScript 内存机制与闭包原理深度剖析
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1176918763246011/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    NEXT06
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T10:02:42.000Z" title="Tue Feb 03 2026 10:02:42 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在日常的前端开发中，我们往往专注于业务逻辑的实现，而忽略了 JavaScript 引擎底层的内存管理。作为一门高级语言，JavaScript 确实帮我们屏蔽了手动分配和释放内存的繁琐（如 C 语言中的 malloc 和 free），但这并不意味着我们可以完全无视内存机制。</p>
<p>你是否遇到过这样的困惑：为什么修改一个变量会莫名其妙地影响另一个变量？为什么看似执行完毕的函数，其内部变量却依然驻留在内存中？或者在性能优化时，面对内存泄漏束手无策？</p>
<p>这一切的答案，都隐藏在 JavaScript 的内存布局与闭包的底层实现之中。如果不理解这些底层原理，就很难写出高性能且健壮的代码。本文将结合 V8 引擎的实现机制，深入剖析 JS 的内存管理与闭包真相。</p>
<h2 data-id="heading-0">一、JS 的内存世界：栈与堆</h2>
<p>JavaScript 引擎（以 Chrome V8 为例）在执行代码时，会将内存划分为两个核心区域：<strong>栈内存（Stack）</strong>  和 <strong>堆内存（Heap）</strong> 。这种划分并非随意为之，而是为了在“执行效率”与“存储容量”之间找到平衡。</p>
<h3 data-id="heading-1">1. 栈内存（Stack）：执行的主战场</h3>
<p>栈内存主要用于存储<strong>基本数据类型</strong>（Number, String, Boolean, Undefined, Null, Symbol, BigInt）以及<strong>执行上下文（Execution Context）</strong> 。</p>
<ul>
<li><strong>特点</strong>：空间较小，内存地址连续。</li>
<li><strong>管理方式</strong>：遵循“后进先出”（LIFO）原则。</li>
<li><strong>优势</strong>：操作极快。V8 引擎只需移动栈顶指针（ESP），即可完成上下文的切换和内存的回收。</li>
</ul>
<p>由于 JavaScript 是单线程语言，主线程的调用栈切换非常频繁。如果栈内存过大或存储的数据结构过于复杂，会导致栈指针移动受阻，直接阻塞主线程，造成页面卡顿。因此，栈主要用于处理轻量级的数据和维持程序执行流。</p>
<h3 data-id="heading-2">2. 堆内存（Heap）：数据的仓库</h3>
<p>堆内存用于存储<strong>引用数据类型</strong>（Object, Array, Function 等）。</p>
<ul>
<li><strong>特点</strong>：空间巨大，内存地址不连续（杂乱）。</li>
<li><strong>管理方式</strong>：由垃圾回收器（GC）进行管理。</li>
<li><strong>劣势</strong>：内存分配和回收的开销较大。</li>
</ul>
<h3 data-id="heading-3">3. 代码实战：赋值行为的差异</h3>
<p>理解了栈和堆的区别，就能解释为什么不同类型的变量在赋值时表现截然不同。</p>
<p><strong>场景一：基本类型的赋值（值拷贝）</strong></p>
<p>JavaScript</p>
<pre><code class="hljs language-ini" lang="ini">// 对应 File 1.js
function foo() {
    var <span class="hljs-attr">a</span> = <span class="hljs-number">1</span><span class="hljs-comment">; </span>
    var <span class="hljs-attr">b</span> = a<span class="hljs-comment">; // 在栈中开辟新空间，将 1 拷贝给 b</span>
    <span class="hljs-attr">a</span> = <span class="hljs-number">2</span><span class="hljs-comment">;     // 修改 a，不影响 b</span>
    console.log(a)<span class="hljs-comment">; // 2</span>
    console.log(b)<span class="hljs-comment">; // 1</span>
}
foo()<span class="hljs-comment">;</span>
</code></pre>
<p>对于基本类型，变量直接在栈中存储其<strong>值</strong>。var b = a 执行的是<strong>完整的值拷贝</strong>，a 和 b 在内存中是完全独立的两个块。</p>
<p><strong>场景二：引用类型的赋值（地址拷贝）</strong></p>
<p>JavaScript</p>
<pre><code class="hljs language-css" lang="css">// 对应 File <span class="hljs-number">2</span><span class="hljs-selector-class">.js</span>
function foo() {
    <span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">a</span> = {name: <span class="hljs-string">"极客时间"</span>}; // 堆中存储对象，栈中 <span class="hljs-selector-tag">a</span> 存储该对象的堆地址
    <span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">b</span> = <span class="hljs-selector-tag">a</span>;                // 栈中 <span class="hljs-selector-tag">b</span> 复制了 <span class="hljs-selector-tag">a</span> 的地址指针
    <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.name</span> = "极客邦";         // 通过地址修改堆中的实体
    console<span class="hljs-selector-class">.log</span>(<span class="hljs-selector-tag">a</span>); // {name: <span class="hljs-string">"极客邦"</span>}
    console<span class="hljs-selector-class">.log</span>(<span class="hljs-selector-tag">b</span>); // {name: <span class="hljs-string">"极客邦"</span>}
}
foo();
</code></pre>
<p>对于引用类型，变量在栈中存储的是<strong>指向堆内存的地址（指针）</strong> ，真正的实体数据存在堆中。var b = a 仅仅是拷贝了这个指针。因此，a 和 b 指向同一个堆内存块，修改其中一个，必然影响另一个。</p>
<hr/>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/07b90eda429f43ff9b5c9264ad6bb34c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTkVYVDA2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770717762&amp;x-signature=MjXhPw77oW1s5brelPbQhI93vaU%3D" alt="image.png" loading="lazy"/></p>
<hr/>
<h2 data-id="heading-4">二、动态类型的双刃剑</h2>
<p>JavaScript 是一门<strong>动态弱类型</strong>语言，这意味着变量本身没有类型，<strong>值</strong>才有类型，且类型可以在运行时改变。</p>
<p>JavaScript</p>
<pre><code class="hljs language-ini" lang="ini">// 对应 File 3.js
var bar<span class="hljs-comment">; </span>
<span class="hljs-attr">bar</span> = <span class="hljs-number">12</span><span class="hljs-comment">;           // Number</span>
<span class="hljs-attr">bar</span> = <span class="hljs-string">"极客时间"</span><span class="hljs-comment">;    // String</span>
<span class="hljs-attr">bar</span> = {name: <span class="hljs-string">"G"</span>}<span class="hljs-comment">;  // Object</span>
</code></pre>
<p>相比之下，C 语言等静态语言在编译阶段就需要确定变量类型和内存大小：</p>
<p>C</p>
<pre><code class="hljs language-ini" lang="ini">// 对应 File 4.c
int <span class="hljs-attr">a</span> = <span class="hljs-number">1</span><span class="hljs-comment">; // 编译期分配 4 字节</span>
char* <span class="hljs-attr">b</span> = <span class="hljs-string">"hello"</span><span class="hljs-comment">;</span>
</code></pre>
<p><strong>对比分析</strong>：</p>
<ul>
<li><strong>静态语言</strong>：编译器知道 int 永远占 4 个字节，因此可以生成极其高效的内存指令。</li>
<li><strong>JavaScript</strong>：V8 引擎无法在编译期确定 bar 到底需要多少空间（可能是 8 字节的数字，也可能是巨大的对象）。</li>
</ul>
<p>为了应对这种动态性，V8 采用了复杂的**对象模型（Object Model）<strong>和</strong>隐藏类（Hidden Class）**技术，将易变的数据结构尽量标准化。这也解释了为什么在 JS 中不建议频繁更改对象的形状（如动态添加属性），因为这会破坏引擎的优化策略。</p>
<p>值得注意的是 JS 的一个历史遗留 Bug：</p>
<p>JavaScript</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span>); <span class="hljs-comment">// "object"</span>
</code></pre>
<p>这是因为在 JS 的第一版实现中，使用低位二进制标签表示类型，000 开头表示对象，而 null 全是 0，导致被误判为 Object。为了兼容性，这个 Bug 被保留至今。</p>
<h2 data-id="heading-5">三、闭包的底层真相：逃逸的变量</h2>
<p>许多开发者对闭包的理解仅停留在“函数内部访问外部变量”。但从内存角度看，<strong>闭包的本质是变量从栈内存“逃逸”到了堆内存</strong>。</p>
<p>按照常规逻辑，函数执行完毕后，其执行上下文（Execution Context）会从调用栈弹出，栈上的局部变量应该被销毁。那么，闭包是如何让变量“活”下来的？</p>
<h3 data-id="heading-6">1. 预扫描与逃逸分析</h3>
<p>V8 引擎在执行代码前，会进行<strong>词法扫描（Scoping）</strong> 。</p>
<p>JavaScript</p>
<pre><code class="hljs language-ini" lang="ini">// 对应 File 6.html
function foo() {
    var <span class="hljs-attr">myName</span> = <span class="hljs-string">"极客时间"</span><span class="hljs-comment">; // 外部变量</span>
    let <span class="hljs-attr">test1</span> = <span class="hljs-number">1</span><span class="hljs-comment">;</span>
    const <span class="hljs-attr">test2</span> = <span class="hljs-number">2</span><span class="hljs-comment">;        // 未被内部函数引用</span>
    
    var <span class="hljs-attr">innerBar</span> = { 
        setName: function(newName){
            <span class="hljs-attr">myName</span> = newName<span class="hljs-comment">; // 引用 myName</span>
        },
        getName: function(){
            console.log(test1)<span class="hljs-comment">; // 引用 test1</span>
            return myName<span class="hljs-comment">;</span>
        }
    }
    return innerBar<span class="hljs-comment">;</span>
}
var <span class="hljs-attr">bar</span> = foo()<span class="hljs-comment">;</span>
</code></pre>
<p><strong>执行过程深度剖析</strong>：</p>
<ol>
<li>
<p><strong>编译阶段</strong>：当编译 foo 函数时，引擎会快速扫描其内部函数（setName, getName）。</p>
</li>
<li>
<p><strong>闭包检测</strong>：引擎发现内部函数引用了 foo 作用域下的 myName 和 test1。</p>
</li>
<li>
<p><strong>堆内存分配</strong>：</p>
<ul>
<li>引擎判断这两个变量需要“长生不老”，于是不会把它们仅仅放在栈上。</li>
<li>引擎会在<strong>堆内存</strong>中创建一个专门的对象（通常称为 Closure Scope 或 Context Extension）。</li>
<li>myName 和 test1 被存储到这个堆对象中。</li>
<li><strong>注意</strong>：test2 没有被引用，所以它依然只留在栈上，随 foo 执行结束而销毁。</li>
</ul>
</li>
<li>
<p><strong>引用维持</strong>：foo 返回的 innerBar 对象中，包含了指向这个堆内存闭包对象的指针（即 [[Scopes]] 属性）。</p>
</li>
</ol>
<h3 data-id="heading-7">2. 执行结束后的内存状态</h3>
<p>当 foo() 执行完毕出栈后：</p>
<ul>
<li>foo 的执行上下文被销毁。</li>
<li>栈上的 test2 被销毁。</li>
<li><strong>堆上的闭包对象依然存在</strong>，因为 bar 变量引用了 innerBar，而 innerBar 引用了该闭包对象。</li>
</ul>
<p>这就是闭包的“魔法”：<strong>通过在堆中开辟空间，打破了栈内存的生命周期限制。</strong></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/75b14f9933324377a46a6fcd9153272a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTkVYVDA2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770717762&amp;x-signature=cMPRizfOzCMZo96CW5pVH1zeUYA%3D" alt="image.png" loading="lazy"/></p>
<h2 data-id="heading-8">四、闭包实战与陷阱</h2>
<p>理解了内存模型，我们来看两个容易踩坑的实战题目。</p>
<h3 data-id="heading-9">题目 1：共享的闭包环境</h3>
<p>JavaScript</p>
<pre><code class="hljs language-ini" lang="ini">function createCounter() {
    let <span class="hljs-attr">count</span> = <span class="hljs-number">0</span><span class="hljs-comment">;</span>
    return {
        increment: function() { count++<span class="hljs-comment">; },</span>
        get: function() { return count<span class="hljs-comment">; }</span>
    }<span class="hljs-comment">;</span>
}

const <span class="hljs-attr">counterA</span> = createCounter()<span class="hljs-comment">;</span>
const <span class="hljs-attr">counterB</span> = createCounter()<span class="hljs-comment">;</span>

counterA.increment()<span class="hljs-comment">;</span>
console.log(counterA.get())<span class="hljs-comment">; // 输出什么？</span>
console.log(counterB.get())<span class="hljs-comment">; // 输出什么？</span>
</code></pre>
<p><strong>解析</strong>：</p>
<ul>
<li>输出：1 和 0。</li>
<li><strong>原因</strong>：每次调用 createCounter 都会创建一个<strong>新的</strong>执行上下文，并在堆中分配一个<strong>新的</strong>闭包对象。counterA 和 counterB 拥有各自独立的闭包环境，互不干扰。</li>
</ul>
<h3 data-id="heading-10">题目 2：引用的副作用</h3>
<p>JavaScript</p>
<pre><code class="hljs language-ini" lang="ini">function foo() {
    var <span class="hljs-attr">myName</span> = <span class="hljs-string">"极客时间"</span><span class="hljs-comment">;</span>
    var <span class="hljs-attr">inner</span> = {
        setName: function(name) { <span class="hljs-attr">myName</span> = name<span class="hljs-comment">; },</span>
        getName: function() { return myName<span class="hljs-comment">; }</span>
    }<span class="hljs-comment">;</span>
    return inner<span class="hljs-comment">;</span>
}

var <span class="hljs-attr">bar1</span> = foo()<span class="hljs-comment">;</span>
bar1.setName("极客邦")<span class="hljs-comment">;</span>
console.log(bar1.getName())<span class="hljs-comment">; // 输出 "极客邦"</span>
</code></pre>
<p><strong>解析</strong>：</p>
<ul>
<li>这里 setName 和 getName 是定义在同一个 foo 调用中的。</li>
<li>它们共享同一个堆内存中的 Closure(foo) 对象。</li>
<li>setName 修改的是堆中那个唯一的 myName，所以 getName 读取到的也是修改后的值。</li>
</ul>
<p><strong>陷阱提示</strong>：这也意味着，如果不小心持有了对闭包的引用且不释放（例如将回调函数挂载到全局事件上），那么这个闭包对象及其引用的所有变量将永远驻留在堆内存中，造成<strong>内存泄漏</strong>。</p>
<h2 data-id="heading-11">五、总结</h2>
<p>JavaScript 的内存管理机制是其灵活性与性能之间的精妙平衡：</p>
<ol>
<li><strong>栈（Stack）</strong> ：负责程序执行的控制流和短期数据的存储，追求极致的速度。</li>
<li><strong>堆（Heap）</strong> ：负责长期大数据的存储，通过引用计数和标记清除等 GC 算法管理生命周期。</li>
<li><strong>闭包（Closure）</strong> ：本质是<strong>空间换时间</strong>。它牺牲了堆内存空间，换取了变量生命周期的延长和状态的封装。</li>
</ol>
<p>作为开发者，我们不需要手动 malloc 内存，但必须清晰地知道每一行代码背后，变量究竟是在栈上瞬息即逝，还是在堆中长久驻留。只有对内存保持敬畏，才能在享受 JavaScript 动态特性的同时，写出高效、稳定的应用。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Flutter——页面跳转（路由、导航）]]></title>    <link>https://juejin.cn/post/7602440800295747630</link>    <guid>https://juejin.cn/post/7602440800295747630</guid>    <pubDate>2026-02-03T10:06:17.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602440800295747630" data-draft-id="7602303923171426313" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Flutter——页面跳转（路由、导航）"/> <meta itemprop="keywords" content="APP,Flutter"/> <meta itemprop="datePublished" content="2026-02-03T10:06:17.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Haha_bj"/> <meta itemprop="url" content="https://juejin.cn/user/2612027844214647"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Flutter——页面跳转（路由、导航）
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2612027844214647/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Haha_bj
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T10:06:17.000Z" title="Tue Feb 03 2026 10:06:17 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    7
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>Flutter 开发中实现页面跳转的核心知识点。Flutter 提供了两种导航方式：<strong>基础导航（适用于简单场景、少量页面）</strong> 和 <strong>命名路由（适用于复杂场景、多页面应用）</strong></p>
<h3 data-id="heading-0">一、核心概念</h3>
<p>在 Flutter 中，所有页面都是「Widget」，导航的本质是「管理页面栈（Stack）」：</p>
<ul>
<li>「跳转页面」：将新页面「压入」栈顶（<code>push</code>）。</li>
<li>「返回页面」：将当前页面「弹出」栈顶（<code>pop</code>）。</li>
<li>Flutter 提供了 <code>Navigator</code> 组件来管理页面栈，日常开发中常用 <code>Navigator.of(context)</code> 来获取导航实例。</li>
</ul>
<hr/>
<h2 data-id="heading-1">方案 1：基础导航（直接跳转，简单高效）</h2>
<p>适用于 <strong>页面数量少（3-5 个）、无需传参 / 少量传参</strong> 的场景（如简单工具类 App），核心是 <code>Navigator.push()</code> 和 <code>Navigator.pop()</code>。</p>
<h3 data-id="heading-2">1.1 基本页面跳转（无参）</h3>
<h4 data-id="heading-3">步骤 1：定义两个页面 Widget（首页 + 详情页）</h4>
<pre><code class="hljs language-Dart" lang="Dart"><span class="hljs-keyword">import</span> <span class="hljs-string">'package:flutter/material.dart'</span>;

<span class="hljs-keyword">void</span> main() =&gt; runApp(<span class="hljs-keyword">const</span> MyApp());

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-keyword">const</span> MyApp({<span class="hljs-keyword">super</span>.key});

  <span class="hljs-meta">@override</span>
  Widget build(BuildContext context) {
    <span class="hljs-keyword">return</span> MaterialApp(
      title: <span class="hljs-string">'Flutter 导航示例'</span>,
      theme: ThemeData(primarySwatch: Colors.blue),
      home: <span class="hljs-keyword">const</span> HomePage(), <span class="hljs-comment">// 首页</span>
    );
  }
}

<span class="hljs-comment">// 首页 Widget</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HomePage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-keyword">const</span> HomePage({<span class="hljs-keyword">super</span>.key});

  <span class="hljs-meta">@override</span>
  Widget build(BuildContext context) {
    <span class="hljs-keyword">return</span> Scaffold(
      appBar: AppBar(title: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">'首页'</span>)),
      body: Center(
        child: ElevatedButton(
          onPressed: () {
            <span class="hljs-comment">// 核心：跳转至详情页（push 压入栈顶）</span>
            Navigator.push(
              context,
              MaterialPageRoute(
                builder: (context) =&gt; <span class="hljs-keyword">const</span> DetailPage(), <span class="hljs-comment">// 目标页面</span>
              ),
            );
          },
          child: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">'跳转到详情页'</span>),
        ),
      ),
    );
  }
}

<span class="hljs-comment">// 详情页 Widget</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DetailPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-keyword">const</span> DetailPage({<span class="hljs-keyword">super</span>.key});

  <span class="hljs-meta">@override</span>
  Widget build(BuildContext context) {
    <span class="hljs-keyword">return</span> Scaffold(
      appBar: AppBar(
        title: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">'详情页'</span>),
        <span class="hljs-comment">// 导航栏默认自带返回按钮，点击等价于 Navigator.pop()</span>
      ),
      body: Center(
        child: ElevatedButton(
          onPressed: () {
            <span class="hljs-comment">// 核心：返回上一页（pop 弹出栈顶）</span>
            Navigator.pop(context);
          },
          child: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">'返回首页'</span>),
        ),
      ),
    );
  }
}
</code></pre>
<h4 data-id="heading-4">关键说明：</h4>
<ul>
<li><code>MaterialPageRoute</code>：Material 风格的路由过渡动画（Android 上下滑动、iOS 左右滑动），无需手动配置。</li>
<li><code>Navigator.push(context, route)</code>：将目标页面压入栈顶，实现跳转。</li>
<li><code>Navigator.pop(context)</code>：将当前页面弹出栈顶，返回上一页（无返回值）。</li>
<li>详情页的 <code>AppBar</code> 会默认添加返回按钮，点击后自动调用 <code>Navigator.pop()</code>，无需手动实现。</li>
</ul>
<h3 data-id="heading-5">1.2 页面传参（带参跳转 + 返回值传递）</h3>
<p>实际开发中常需要给下一页传参（如传递商品 ID），或接收下一页的返回值（如选择图片后返回图片路径）。</p>
<h4 data-id="heading-6">步骤 1：带参跳转（首页 → 详情页，传递字符串 / 数字）</h4>
<p>修改 <code>DetailPage</code> 增加构造函数接收参数，修改首页的跳转逻辑：</p>
<pre><code class="hljs language-Dart" lang="Dart"><span class="hljs-comment">// 详情页（修改：添加构造函数接收参数）</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DetailPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> title; <span class="hljs-comment">// 接收的标题参数</span>
  <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> id; <span class="hljs-comment">// 接收的ID参数</span>

  <span class="hljs-comment">// 构造函数（必填参数，也可设置可选参数）</span>
  <span class="hljs-keyword">const</span> DetailPage({<span class="hljs-keyword">super</span>.key, <span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.title, <span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.id});

  <span class="hljs-meta">@override</span>
  Widget build(BuildContext context) {
    <span class="hljs-keyword">return</span> Scaffold(
      appBar: AppBar(title: Text(title)),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Text(<span class="hljs-string">'接收的ID：<span class="hljs-subst">$id</span>'</span>),
            <span class="hljs-keyword">const</span> SizedBox(height: <span class="hljs-number">20</span>),
            ElevatedButton(
              onPressed: () {
                <span class="hljs-comment">// 返回上一页，并携带返回值（"从详情页返回的内容"）</span>
                Navigator.pop(context, <span class="hljs-string">"从详情页返回的内容"</span>);
              },
              child: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">'返回首页并传值'</span>),
            ),
          ],
        ),
      ),
    );
  }
}

<span class="hljs-comment">// 首页（修改：带参跳转 + 接收返回值）</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HomePage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-keyword">const</span> HomePage({<span class="hljs-keyword">super</span>.key});

  <span class="hljs-meta">@override</span>
  Widget build(BuildContext context) {
    <span class="hljs-keyword">return</span> Scaffold(
      appBar: AppBar(title: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">'首页'</span>)),
      body: Center(
        child: ElevatedButton(
          onPressed: () <span class="hljs-keyword">async</span> {
            <span class="hljs-comment">// 异步接收返回值（await 等待 Navigator.push 执行完成）</span>
            <span class="hljs-keyword">final</span> result = <span class="hljs-keyword">await</span> Navigator.push(
              context,
              MaterialPageRoute(
                builder: (context) =&gt; <span class="hljs-keyword">const</span> DetailPage(
                  title: <span class="hljs-string">'详情页（带参）'</span>,
                  id: <span class="hljs-number">1001</span>,
                ),
              ),
            );

            <span class="hljs-comment">// 打印返回值（详情页传递的内容）</span>
            <span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>) {
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(content: Text(<span class="hljs-string">'接收的返回值：<span class="hljs-subst">$result</span>'</span>)),
              );
            }
          },
          child: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">'带参跳转到详情页'</span>),
        ),
      ),
    );
  }
}
</code></pre>
<h4 data-id="heading-7">关键说明：</h4>
<ol>
<li><strong>给下一页传参</strong>：通过目标页面的「构造函数」传递，支持所有 Dart 数据类型（字符串、数字、对象等）。</li>
<li><strong>接收下一页返回值</strong>：<code>Navigator.push()</code> 是异步操作，返回 <code>Future</code>，通过 <code>await</code> 可接收目标页面 <code>pop</code> 时传递的参数。</li>
<li><strong><code>Navigator.pop(context, result)</code></strong> ：第二个参数是返回值，可省略（无返回值时）。</li>
</ol>
<h2 data-id="heading-8">方案 2：命名路由（配置式跳转，适合复杂应用）</h2>
<p>适用于 <strong>页面数量多（5 个以上）、需要统一管理、频繁跳转</strong> 的场景（如电商、社交 App），核心是「提前配置路由表，通过路由名称跳转」。</p>
<h3 data-id="heading-9">2.1 基本配置与跳转（无参）</h3>
<h4 data-id="heading-10">步骤 1：在 <code>MaterialApp</code> 中配置 <code>routes</code> 路由表</h4>
<p>路由表是一个 <code>Map&lt;String, WidgetBuilder&gt;</code>，key 是路由名称（通常以 <code>/</code> 开头），value 是页面构建函数。</p>
<pre><code class="hljs language-Dart" lang="Dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-keyword">const</span> MyApp({<span class="hljs-keyword">super</span>.key});

  <span class="hljs-meta">@override</span>
  Widget build(BuildContext context) {
    <span class="hljs-keyword">return</span> MaterialApp(
      title: <span class="hljs-string">'Flutter 命名路由示例'</span>,
      theme: ThemeData(primarySwatch: Colors.blue),
      <span class="hljs-comment">// 1. 配置路由表</span>
      routes: {
        <span class="hljs-string">'/'</span>: (context) =&gt; <span class="hljs-keyword">const</span> HomePage(), <span class="hljs-comment">// 首页（默认路由）</span>
        <span class="hljs-string">'/detail'</span>: (context) =&gt; <span class="hljs-keyword">const</span> DetailPage(), <span class="hljs-comment">// 详情页</span>
      },
      <span class="hljs-comment">// 2. 设置默认启动页面（等价于 home: const HomePage()）</span>
      initialRoute: <span class="hljs-string">'/'</span>,
    );
  }
}
</code></pre>
<h4 data-id="heading-11">步骤 2：通过路由名称跳转 / 返回</h4>
<p>修改首页的跳转逻辑，使用 <code>Navigator.pushNamed()</code> 替代 <code>Navigator.push()</code>：</p>
<pre><code class="hljs language-Dart" lang="Dart"><span class="hljs-comment">// 首页</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HomePage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-keyword">const</span> HomePage({<span class="hljs-keyword">super</span>.key});

  <span class="hljs-meta">@override</span>
  Widget build(BuildContext context) {
    <span class="hljs-keyword">return</span> Scaffold(
      appBar: AppBar(title: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">'首页'</span>)),
      body: Center(
        child: ElevatedButton(
          onPressed: () {
            <span class="hljs-comment">// 核心：通过路由名称跳转</span>
            Navigator.pushNamed(context, <span class="hljs-string">'/detail'</span>);
          },
          child: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">'命名路由跳转到详情页'</span>),
        ),
      ),
    );
  }
}
</code></pre>
<h4 data-id="heading-12">关键说明：</h4>
<ul>
<li><code>routes</code>：路由表，统一管理所有页面，便于后期维护（修改页面只需修改路由表，无需修改所有跳转处）。</li>
<li><code>initialRoute</code>：默认启动路由（替代 <code>home</code>），必须和路由表中的某个 key 对应。</li>
<li><code>Navigator.pushNamed(context, '/detail')</code>：通过路由名称跳转，无需再创建 <code>MaterialPageRoute</code>。</li>
<li>返回逻辑不变，依然使用 <code>Navigator.pop(context)</code>。</li>
</ul>
<h3 data-id="heading-13">2.2 命名路由传参（带参跳转）</h3>
<p>命名路由传参有两种常用方式：<code>arguments</code> 传参（推荐）、路由名称拼接参数（不推荐，仅适用于简单参数）。</p>
<h4 data-id="heading-14">方式 1：<code>arguments</code> 传参（推荐，支持任意数据类型）</h4>
<ol>
<li>跳转时通过 <code>arguments</code> 传递参数：</li>
</ol>
<pre><code class="hljs language-php" lang="php"><span class="hljs-comment">// 首页跳转逻辑修改</span>
<span class="hljs-title function_ invoke__">ElevatedButton</span>(
  <span class="hljs-attr">onPressed</span>: () {
    <span class="hljs-comment">// 传递参数（可传字符串、数字、Map、自定义对象等）</span>
    Navigator.<span class="hljs-title function_ invoke__">pushNamed</span>(
      context,
      <span class="hljs-string">'/detail'</span>,
      <span class="hljs-attr">arguments</span>: {
        <span class="hljs-string">'title'</span>: <span class="hljs-string">'详情页（命名路由传参）'</span>,
        <span class="hljs-string">'id'</span>: <span class="hljs-number">1001</span>,
      },
    );
  },
  child: <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">Text</span>(<span class="hljs-string">'命名路由带参跳转'</span>),
),
</code></pre>
<ol start="2">
<li>详情页通过 <code>ModalRoute.of(context)?.settings.arguments</code> 接收参数：</li>
</ol>
<pre><code class="hljs language-Dart" lang="Dart"><span class="hljs-comment">// 详情页修改</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DetailPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-keyword">const</span> DetailPage({<span class="hljs-keyword">super</span>.key});

  <span class="hljs-meta">@override</span>
  Widget build(BuildContext context) {
    <span class="hljs-comment">// 接收 arguments 参数</span>
    <span class="hljs-keyword">final</span> <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">dynamic</span>&gt; args = ModalRoute.of(context)?.settings.arguments <span class="hljs-keyword">as</span> <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">dynamic</span>&gt;;

    <span class="hljs-keyword">return</span> Scaffold(
      appBar: AppBar(title: Text(args[<span class="hljs-string">'title'</span>])),
      body: Center(
        child: Text(<span class="hljs-string">'接收的ID：<span class="hljs-subst">${args[<span class="hljs-string">'id'</span>]}</span>'</span>),
      ),
    );
  }
}
</code></pre>
<h4 data-id="heading-15">方式 2：路由名称拼接参数（仅适用于简单参数，如 ID）</h4>
<pre><code class="hljs language-Dart" lang="Dart"><span class="hljs-comment">// 跳转时拼接参数</span>
Navigator.pushNamed(context, <span class="hljs-string">'/detail/1001'</span>);

<span class="hljs-comment">// 配置路由表时使用通配符</span>
routes: {
  <span class="hljs-string">'/detail/:id'</span>: (context) =&gt; <span class="hljs-keyword">const</span> DetailPage(),
},

<span class="hljs-comment">// 详情页提取参数（需额外解析，较繁琐，不推荐）</span>
<span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> id = ModalRoute.of(context)?.settings.name?.split(<span class="hljs-string">'/'</span>).last ?? <span class="hljs-string">''</span>;
</code></pre>
<h3 data-id="heading-16">2.3 未知路由处理（404 页面）</h3>
<p>当跳转的路由名称不在路由表中时，会出现错误，可通过 <code>onUnknownRoute</code> 配置兜底页面（404 页面）：</p>
<pre><code class="hljs language-Dart" lang="Dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-keyword">const</span> MyApp({<span class="hljs-keyword">super</span>.key});

  <span class="hljs-meta">@override</span>
  Widget build(BuildContext context) {
    <span class="hljs-keyword">return</span> MaterialApp(
      title: <span class="hljs-string">'Flutter 命名路由示例'</span>,
      theme: ThemeData(primarySwatch: Colors.blue),
      routes: {
        <span class="hljs-string">'/'</span>: (context) =&gt; <span class="hljs-keyword">const</span> HomePage(),
        <span class="hljs-string">'/detail'</span>: (context) =&gt; <span class="hljs-keyword">const</span> DetailPage(),
      },
      initialRoute: <span class="hljs-string">'/'</span>,
      <span class="hljs-comment">// 未知路由兜底</span>
      onUnknownRoute: (settings) {
        <span class="hljs-keyword">return</span> MaterialPageRoute(
          builder: (context) =&gt; <span class="hljs-keyword">const</span> NotFoundPage(),
        );
      },
    );
  }
}

<span class="hljs-comment">// 404 页面</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NotFoundPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-keyword">const</span> NotFoundPage({<span class="hljs-keyword">super</span>.key});

  <span class="hljs-meta">@override</span>
  Widget build(BuildContext context) {
    <span class="hljs-keyword">return</span> Scaffold(
      appBar: AppBar(title: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">'页面不存在'</span>)),
      body: <span class="hljs-keyword">const</span> Center(child: Text(<span class="hljs-string">'404 - 页面未找到'</span>)),
    );
  }
}
</code></pre>
<h2 data-id="heading-17">方案 3：进阶：路由管理（封装路由工具类）</h2>
<p>当项目页面非常多时，直接在 <code>MaterialApp</code> 中配置路由表会显得臃肿，推荐封装「路由工具类」，统一管理路由跳转、传参、拦截等逻辑。</p>
<h3 data-id="heading-18">3.1 封装路由工具类</h3>
<pre><code class="hljs language-Dart" lang="Dart"><span class="hljs-keyword">import</span> <span class="hljs-string">'package:flutter/material.dart'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'package:your_project_name/pages/home_page.dart'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'package:your_project_name/pages/detail_page.dart'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'package:your_project_name/pages/not_found_page.dart'</span>;

<span class="hljs-comment">// 路由名称常量（避免硬编码，便于维护）</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RouteNames</span> </span>{
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">String</span> home = <span class="hljs-string">'/'</span>;
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">String</span> detail = <span class="hljs-string">'/detail'</span>;
}

<span class="hljs-comment">// 路由工具类</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RouteManager</span> </span>{
  <span class="hljs-comment">// 配置路由表</span>
  <span class="hljs-keyword">static</span> <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, WidgetBuilder&gt; routes = {
    RouteNames.home: (context) =&gt; <span class="hljs-keyword">const</span> HomePage(),
    RouteNames.detail: (context) =&gt; <span class="hljs-keyword">const</span> DetailPage(),
  };

  <span class="hljs-comment">// 路由跳转（封装 pushNamed，统一处理传参）</span>
  <span class="hljs-keyword">static</span> Future&lt;T?&gt; pushNamed&lt;T&gt;(BuildContext context, <span class="hljs-built_in">String</span> routeName, {<span class="hljs-built_in">Object?</span> arguments}) {
    <span class="hljs-keyword">return</span> Navigator.pushNamed&lt;T&gt;(context, routeName, arguments: arguments);
  }

  <span class="hljs-comment">// 返回上一页（封装 pop，统一处理返回值）</span>
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> pop&lt;T&gt;(BuildContext context, {T? result}) {
    Navigator.pop&lt;T&gt;(context, result);
  }

  <span class="hljs-comment">// 未知路由处理</span>
  <span class="hljs-keyword">static</span> Route&lt;<span class="hljs-built_in">dynamic</span>&gt; onUnknownRoute(RouteSettings settings) {
    <span class="hljs-keyword">return</span> MaterialPageRoute(
      builder: (context) =&gt; <span class="hljs-keyword">const</span> NotFoundPage(),
    );
  }
}
</code></pre>
<h3 data-id="heading-19">3.2 使用封装后的路由工具类</h3>
<pre><code class="hljs language-Dart" lang="Dart"><span class="hljs-comment">// MyApp 中配置</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-keyword">const</span> MyApp({<span class="hljs-keyword">super</span>.key});

  <span class="hljs-meta">@override</span>
  Widget build(BuildContext context) {
    <span class="hljs-keyword">return</span> MaterialApp(
      title: <span class="hljs-string">'Flutter 路由封装示例'</span>,
      theme: ThemeData(primarySwatch: Colors.blue),
      routes: RouteManager.routes,
      initialRoute: RouteNames.home,
      onUnknownRoute: RouteManager.onUnknownRoute,
    );
  }
}

<span class="hljs-comment">// 首页跳转</span>
ElevatedButton(
  onPressed: () {
    RouteManager.pushNamed(
      context,
      RouteNames.detail,
      arguments: {<span class="hljs-string">'title'</span>: <span class="hljs-string">'详情页（封装路由）'</span>, <span class="hljs-string">'id'</span>: <span class="hljs-number">1001</span>},
    );
  },
  child: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">'封装路由带参跳转'</span>),
),

<span class="hljs-comment">// 详情页返回</span>
ElevatedButton(
  onPressed: () {
    RouteManager.pop(context, result: <span class="hljs-string">"从封装路由详情页返回"</span>);
  },
  child: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">'返回首页'</span>),
),
</code></pre>
<h2 data-id="heading-20">关键补充：路由过渡动画自定义</h2>
<p>默认的 <code>MaterialPageRoute</code> 是 Material 风格动画，若需要自定义过渡动画（如淡入淡出、缩放），可使用 <code>PageRouteBuilder</code>：</p>
<pre><code class="hljs language-Dart" lang="Dart"><span class="hljs-comment">// 自定义淡入淡出动画跳转</span>
Navigator.push(
  context,
  PageRouteBuilder(
    pageBuilder: (context, animation, secondaryAnimation) =&gt; <span class="hljs-keyword">const</span> DetailPage(),
    transitionsBuilder: (context, animation, secondaryAnimation, child) {
      <span class="hljs-comment">// 淡入淡出动画</span>
      <span class="hljs-keyword">return</span> FadeTransition(
        opacity: animation,
        child: child,
      );
    },
    transitionDuration: <span class="hljs-keyword">const</span> <span class="hljs-built_in">Duration</span>(milliseconds: <span class="hljs-number">500</span>), <span class="hljs-comment">// 动画时长</span>
  ),
);
</code></pre>
<h3 data-id="heading-21">总结</h3>
<ol>
<li>Flutter 导航核心是「页面栈管理」，通过 <code>Navigator</code> 实现 <code>push</code>（跳转）和 <code>pop</code>（返回）。</li>
<li>简单场景用「基础导航」（<code>Navigator.push</code>），快速高效；复杂场景用「命名路由」（<code>Navigator.pushNamed</code>），便于统一管理。</li>
<li>传参方式：基础导航用「构造函数」，命名路由用「<code>arguments</code>」（推荐）。</li>
<li>最佳实践：页面较多时封装「路由工具类」，统一管理路由表、跳转、未知路由，提升项目可维护性。</li>
<li>自定义过渡动画可使用 <code>PageRouteBuilder</code>，满足个性化 UI 需求。</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[手写 React KeepAlive 组件：实现组件缓存与切换]]></title>    <link>https://juejin.cn/post/7602205524718944290</link>    <guid>https://juejin.cn/post/7602205524718944290</guid>    <pubDate>2026-02-03T10:09:07.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602205524718944290" data-draft-id="7602225961095790626" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="手写 React KeepAlive 组件：实现组件缓存与切换"/> <meta itemprop="keywords" content="前端,React.js"/> <meta itemprop="datePublished" content="2026-02-03T10:09:07.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="lIIIllIlIllIIl"/> <meta itemprop="url" content="https://juejin.cn/user/793196846923641"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            手写 React KeepAlive 组件：实现组件缓存与切换
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/793196846923641/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    lIIIllIlIllIIl
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T10:09:07.000Z" title="Tue Feb 03 2026 10:09:07 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在 React 开发中，组件的<strong>频繁挂载和卸载</strong>往往会导致<strong>状态丢失和性能开销</strong>，尤其在 tab 切换或路由场景下。例如，当用户在不同视图间切换时，如果组件每次都重新渲染，内部的计数器、表单数据等状态就会重置，用户体验变差。为了解决这个问题，<code>React</code> 官方提供了 <code>&lt;KeepAlive&gt;</code> 组件，但理解其原理并手写实现，能帮助我们更深入掌握组件生命周期管理和状态缓存。本文将基于一个简单的计数器 tab 切换示例，详细讲解 <code>KeepAlive</code> 的手写过程。我们会使用对象作为缓存结构（类似于 Map），通过 <code>display</code> 属性<strong>控制组件显示隐藏</strong>，从而实现<strong>缓存活化</strong>。</p>
<h3 data-id="heading-0">KeepAlive 的核心原理</h3>
<p><code>KeepAlive</code> 的本质是<strong>缓存组件实例，避免卸载</strong>。它不像条件渲染（如 if 语句）那样销毁组件，而是将不活跃的组件“隐藏”起来，保留其状态。当切换回该组件时，直接显示即可，无需重新挂载。这涉及到 React 的渲染机制：组件可以通过 CSS 中 <code>display: none</code> <strong>隐藏</strong>，但仍保持在 DOM 中，生命周期钩子不会触发卸载。</p>
<p>为什么用缓存结构？因为需要存储多个组件。例如，在多 tab 场景下，每个 tab 对应一个组件，我们用一个键值对存储：key 为 tab ID，value 为组件 JSX。Map（ES6 新增的数据结构），它允许任意类型作为 key（如对象），而对象字面量的 key 只能是字符串。但在简单场景下，对象 {} 也能胜任，且更轻量。JSON 与此类似，都是 key-value，但 JSON 是字符串序列化形式，不适合直接作为缓存。</p>
<p>切换显示的逻辑：当 <code>activeId</code> 变化时，检查缓存中是否有对应组件；如果没有，添加当前 children；然后遍历缓存，渲染所有组件，但只显示 active 的那个。通过 Object.entries 将缓存转为二维数组 <code>[[key1, value1], [key2, value2]]</code>，便于 map 渲染。</p>
<p>这种设计提升了组件的复用性：父组件通过 <code>children</code> 传入任意内容，<code>KeepAlive</code> 只负责<strong>缓存和显示控制</strong>。props 如 <code>activeId</code> 用于标识当前活跃 tab。</p>
<h3 data-id="heading-1">示例场景：计数器 tab 切换</h3>
<p>假设我们有一个 <code>App</code> 组件，包含两个计数器视图 A 和 B。用户点击按钮切换 tab，我们希望切换时保留计数器状态，而不是重置为 0。以下是 <code>App.jsx</code> 的完整代码：</p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-keyword">import</span> {
  useState,
  useEffect,
} <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-keyword">import</span> <span class="hljs-title class_">KeepAlive</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./components/KeepAlive.jsx'</span>;


<span class="hljs-keyword">const</span> <span class="hljs-title function_">Counter</span> = (<span class="hljs-params">{ name }</span>) =&gt; {
  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"挂载"</span>, name);
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"卸载"</span>, name);
    }    
  }, [])

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{padding:</span> '<span class="hljs-attr">20px</span>', <span class="hljs-attr">border:</span> '<span class="hljs-attr">1px</span> <span class="hljs-attr">solid</span> #<span class="hljs-attr">ccc</span>'}}&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>{name} 视图<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>当前计数：{count}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setCount(count + 1)}&gt;点击加1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  )
}

<span class="hljs-keyword">const</span> <span class="hljs-title function_">OtherCounter</span> = (<span class="hljs-params">{ name }</span>) =&gt; {
  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"挂载"</span>, name);
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"卸载"</span>, name);
    }    
  }, [])

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{padding:</span> '<span class="hljs-attr">20px</span>', <span class="hljs-attr">border:</span> '<span class="hljs-attr">1px</span> <span class="hljs-attr">solid</span> #<span class="hljs-attr">ccc</span>'}}&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>{name} 视图<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>当前计数：{count}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setCount(count + 1)}&gt;点击加1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  )
}


<span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-keyword">const</span> [activeTab, setActiveTab] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">'A'</span>);

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{marginBottom:</span> '<span class="hljs-attr">20px</span>'}}&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setActiveTab('A')}&gt;显示A组件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setActiveTab('B')}&gt;显示B组件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      {/* children 提升组件的定制能力 给父组件方便 */}
      <span class="hljs-tag">&lt;<span class="hljs-name">KeepAlive</span> <span class="hljs-attr">activeId</span>=<span class="hljs-string">{activeTab}</span>&gt;</span>
        { activeTab === 'A' ? <span class="hljs-tag">&lt;<span class="hljs-name">Counter</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"A"</span> /&gt;</span> : <span class="hljs-tag">&lt;<span class="hljs-name">OtherCounter</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"B"</span> /&gt;</span> }
      <span class="hljs-tag">&lt;/<span class="hljs-name">KeepAlive</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  )
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>
</code></pre>
<p>在这里，Counter 和 OtherCounter 是两个独立的计数器组件，使用 useEffect 记录挂载/卸载日志。App 通过 useState 管理 activeTab，按钮切换它。KeepAlive 包裹条件渲染的 children：当 activeTab 为 'A' 时渲染 Counter，否则 OtherCounter。</p>
<p>运行这个 App，如果没有 KeepAlive，切换 tab 时会看到控制台打印“卸载 A”和“挂载 B”，计数器重置。但有了 KeepAlive，只在首次渲染时挂载，以后切换只隐藏/显示，无卸载日志，状态保留。</p>
<h3 data-id="heading-2">手写 KeepAlive 组件</h3>
<p>现在，我们实现 KeepAlive.jsx。它使用 useState 存储缓存，useEffect 在 activeId 或 children 变化时更新缓存。渲染时遍历缓存，应用 display 样式。代码如下：</p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-keyword">import</span> {
  useState,
  useEffect,
} <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-keyword">const</span> <span class="hljs-title function_">KeepAlive</span> = (<span class="hljs-params">{
  activeId,
  children,
}</span>) =&gt; {
  <span class="hljs-keyword">const</span> [cache, setCache] = <span class="hljs-title function_">useState</span>({});  <span class="hljs-comment">// 缓存组件的</span>
  <span class="hljs-comment">// console.log(children, "--------");</span>
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// activeId updata 切换显示</span>
    <span class="hljs-comment">// children updata 保存</span>
    <span class="hljs-keyword">if</span> (!cache[activeId]) {  <span class="hljs-comment">// activeId key</span>
      <span class="hljs-title function_">setCache</span>(<span class="hljs-function">(<span class="hljs-params">pre</span>) =&gt;</span> ({
        ...pre,
        [activeId]: children
      }))
    }
    <span class="hljs-comment">// console.log(cache, "????????");</span>
  }, [activeId, children, cache])
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;&gt;</span>
      {
        // Object.entries 对象变成数组
        // [key, value] 又方便使用
        Object.entries(cache).map(([id, components]) =&gt; (
          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{id}</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{display:</span> <span class="hljs-attr">id</span> === <span class="hljs-string">activeId</span> ? '<span class="hljs-attr">block</span>' <span class="hljs-attr">:</span> '<span class="hljs-attr">none</span>'}}
          &gt;</span>
            {components}
          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        ))
      }
    <span class="hljs-tag">&lt;/&gt;</span></span>
  )
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">KeepAlive</span>
</code></pre>
<p>剖析代码：</p>
<ul>
<li>useState({}) 初始化 cache 为空对象。</li>
<li>useEffect 依赖 [activeId, children, cache]：当这些变化时，检查 cache 是否有 activeId；如果没有，添加 children 到 cache。</li>
<li>渲染部分：使用 Object.entries(cache) 转为 [[id, components]] 数组，map 渲染每个缓存项。每个项包裹在 div 中，key 为 id（确保唯一），style 根据 id === activeId 设置 display: block 或 none。</li>
<li>注释解释了 Object.entries 的作用：将对象拆成易迭代的二维数组。</li>
</ul>
<p>这个实现简单有效。首次切换到 'A' 时，cache 添加 {'A':  }，渲染 div display: block。切换 'B' 时，添加 {'B':  }，现在渲染两个 div：A 为 none，B 为 block。组件实例保留，状态不丢。</p>
<p>总结，手写 KeepAlive 考察了对 React 状态、effect 和渲染的理解。通过缓存和 display 控制，我们实现了高效组件复用。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[新手必看｜5个Python基础语法避坑技巧（附代码示例）]]></title>    <link>https://juejin.cn/post/7602246300453126179</link>    <guid>https://juejin.cn/post/7602246300453126179</guid>    <pubDate>2026-02-03T09:30:32.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602246300453126179" data-draft-id="7602188264114962447" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="新手必看｜5个Python基础语法避坑技巧（附代码示例）"/> <meta itemprop="keywords" content="Python"/> <meta itemprop="datePublished" content="2026-02-03T09:30:32.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="躺平大鹅"/> <meta itemprop="url" content="https://juejin.cn/user/2455634286221657"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            新手必看｜5个Python基础语法避坑技巧（附代码示例）
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2455634286221657/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    躺平大鹅
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T09:30:32.000Z" title="Tue Feb 03 2026 09:30:32 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    11
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>作为刚入门编程的新手，Python基础语法看似简单，但很容易在细节上踩坑，导致代码报错、运行异常，既影响效率又打击积极性。今天整理了5个最常见的Python语法避坑点，搭配可直接复制运行的代码示例，新手看完就能避开90%的基础错误，快速夯实基础～</p>
<h3 data-id="heading-0">一、缩进错误（最高频！）</h3>
<p>Python的缩进不是“可选装饰”，而是语法的一部分，这和Java、C++的括号分隔不同，新手最容易忽略缩进规范，导致IndentationError。</p>
<p>❌ 错误示例：</p>
<pre><code class="hljs language-python" lang="python">a = <span class="hljs-number">10</span>
<span class="hljs-keyword">if</span> a &gt; <span class="hljs-number">5</span>:
<span class="hljs-built_in">print</span>(<span class="hljs-string">"a大于5"</span>)  <span class="hljs-comment"># 缩进不一致，报错</span>
    
</code></pre>
<p>✅ 正确示例：</p>
<pre><code class="hljs language-python" lang="python">a = <span class="hljs-number">10</span>
<span class="hljs-keyword">if</span> a &gt; <span class="hljs-number">5</span>:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"a大于5"</span>)  <span class="hljs-comment"># 统一使用4个空格缩进（CSDN规范）</span>
    
</code></pre>
<p>💡 避坑技巧：固定使用4个空格缩进（不要用Tab键，避免不同编辑器显示异常），IDE（如PyCharm、VS Code）可设置“Tab自动转为4个空格”，从根源避免缩进问题。</p>
<h3 data-id="heading-1">二、变量命名规范（避免语法报错+提高可读性）</h3>
<p>Python变量命名有明确规则，新手容易使用关键字、特殊符号，导致代码无法运行，同时混乱的命名会让后续调试变得困难。</p>
<p>❌ 错误示例：</p>
<pre><code class="hljs language-python" lang="python">123name = <span class="hljs-string">"张三"</span>  <span class="hljs-comment"># 不能以数字开头</span>
name@age = <span class="hljs-number">20</span>    <span class="hljs-comment"># 不能包含@、#等特殊符号（下划线_除外）</span>
<span class="hljs-keyword">if</span> = <span class="hljs-number">5</span>           <span class="hljs-comment"># 不能使用关键字（if、for、while等）</span>
    
</code></pre>
<p>✅ 正确示例：</p>
<pre><code class="hljs language-python" lang="python">user_name = <span class="hljs-string">"张三"</span>  <span class="hljs-comment"># 小写字母+下划线（蛇形命名法，Python推荐）</span>
user_age = <span class="hljs-number">20</span>
flag = <span class="hljs-number">5</span>
    
</code></pre>
<h3 data-id="heading-2">三、中英文符号混淆（隐蔽性极强！）</h3>
<p>这是新手最容易踩的“隐形坑”，中英文的括号、引号、逗号看起来相似，但Python只识别英文符号，一旦用了中文符号，就会报SyntaxError，却很难快速找到问题所在。</p>
<p>❌ 错误示例：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-built_in">print</span>(“Hello Python”)  <span class="hljs-comment"># 中文双引号</span>
<span class="hljs-keyword">if</span> a == <span class="hljs-number">5</span>：            <span class="hljs-comment"># 中文冒号</span>
    
</code></pre>
<p>✅ 正确示例：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-built_in">print</span>(<span class="hljs-string">"Hello Python"</span>)  <span class="hljs-comment"># 英文双引号</span>
<span class="hljs-keyword">if</span> a == <span class="hljs-number">5</span>:            <span class="hljs-comment"># 英文冒号</span>
    
</code></pre>
<p>💡 避坑技巧：编程时固定切换到英文输入法，IDE可安装“中英文符号检测插件”，实时提醒错误。</p>
<h3 data-id="heading-3">四、列表/字典索引取值错误</h3>
<p>Python中列表、字典是最常用的数据结构，新手容易出现“索引越界”“字典键不存在”的错误，尤其是循环取值时。</p>
<p>❌ 错误示例：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 列表索引从0开始，不是1</span>
list1 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]
<span class="hljs-built_in">print</span>(list1[<span class="hljs-number">4</span>])  <span class="hljs-comment"># 列表长度为4，最大索引是3，报错</span>

<span class="hljs-comment"># 字典取值时，键不存在报错</span>
dict1 = {<span class="hljs-string">"name"</span>:<span class="hljs-string">"张三"</span>, <span class="hljs-string">"age"</span>:<span class="hljs-number">20</span>}
<span class="hljs-built_in">print</span>(dict1[<span class="hljs-string">"gender"</span>])  <span class="hljs-comment"># 键gender不存在，报错</span>
    
</code></pre>
<p>✅ 正确示例：</p>
<pre><code class="hljs language-python" lang="python">list1 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]
<span class="hljs-built_in">print</span>(list1[<span class="hljs-number">3</span>])  <span class="hljs-comment"># 取最后一个元素，索引3</span>

dict1 = {<span class="hljs-string">"name"</span>:<span class="hljs-string">"张三"</span>, <span class="hljs-string">"age"</span>:<span class="hljs-number">20</span>}
<span class="hljs-comment"># 方法1：判断键是否存在</span>
<span class="hljs-keyword">if</span> <span class="hljs-string">"gender"</span> <span class="hljs-keyword">in</span> dict1:
    <span class="hljs-built_in">print</span>(dict1[<span class="hljs-string">"gender"</span>])
<span class="hljs-comment"># 方法2：使用get()方法，不存在返回默认值None</span>
<span class="hljs-built_in">print</span>(dict1.get(<span class="hljs-string">"gender"</span>))
    
</code></pre>
<h3 data-id="heading-4">五、循环中修改可迭代对象（容易导致死循环/漏值）</h3>
<p>新手在for循环中，经常直接修改列表、字典等可迭代对象，导致循环次数异常、漏取元素，甚至死循环。</p>
<p>❌ 错误示例：</p>
<pre><code class="hljs language-python" lang="python">list1 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]
<span class="hljs-comment"># 循环中删除列表元素，导致漏值</span>
<span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> list1:
    <span class="hljs-keyword">if</span> num % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:
        list1.remove(num)
<span class="hljs-built_in">print</span>(list1)  <span class="hljs-comment"># 预期[1,3,5]，实际[1,3,5]（此处看似正确，复杂场景会漏值）</span>
    
</code></pre>
<p>✅ 正确示例：</p>
<pre><code class="hljs language-python" lang="python">list1 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]
<span class="hljs-comment"># 遍历列表副本，修改原列表</span>
<span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> list1[:]:
    <span class="hljs-keyword">if</span> num % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:
        list1.remove(num)
<span class="hljs-built_in">print</span>(list1)  <span class="hljs-comment"># 正确输出[1,3,5]</span>
    
</code></pre>
<h3 data-id="heading-5">最后</h3>
<p>Python基础语法的坑，大多集中在细节上，新手只要多注意规范、多练习，就能快速避开。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[二叉树解题心法：从思维到实战，一文理解所有核心考点]]></title>    <link>https://juejin.cn/post/7602420156397142059</link>    <guid>https://juejin.cn/post/7602420156397142059</guid>    <pubDate>2026-02-03T10:20:35.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602420156397142059" data-draft-id="7602488966609371174" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="二叉树解题心法：从思维到实战，一文理解所有核心考点"/> <meta itemprop="keywords" content="JavaScript,后端,算法"/> <meta itemprop="datePublished" content="2026-02-03T10:20:35.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="颜酱"/> <meta itemprop="url" content="https://juejin.cn/user/905653309941495"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            二叉树解题心法：从思维到实战，一文理解所有核心考点
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/905653309941495/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    颜酱
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T10:20:35.000Z" title="Tue Feb 03 2026 10:20:35 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读19分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">二叉树解题心法：从思维到实战，一文理解所有核心考点</h2>
<p>二叉树是算法面试的<strong>核心基础考点</strong>，无论是遍历、构造、序列化还是子树相关问题，都有一套统一的解题框架和思维模式。本文将从<strong>解题总纲</strong>出发，依次讲解<strong>遍历与分解问题思维</strong>、<strong>二叉树构造</strong>、<strong>序列化与反序列化</strong>三大核心模块，结合LeetCode经典真题，从原理到代码实现层层拆解，让你形成一套可复用的二叉树解题体系，轻松应对各类二叉树问题。</p>
<h3 data-id="heading-1">一、二叉树解题总纲（纲领篇）</h3>
<p>所有二叉树问题的解题思维，都可以归为两类，且无论使用哪种思维，都要聚焦<strong>单个节点的操作</strong>和<strong>执行时机</strong>：</p>
<h4 data-id="heading-2">核心思维模式</h4>
<ol>
<li>
<p><strong>遍历思维</strong>：能否通过<strong>遍历一遍二叉树</strong>得到答案？若可以，编写<code>traverse</code>遍历函数，配合外部变量记录结果，让每个节点执行相同操作。</p>
</li>
<li>
<p><strong>分解问题思维</strong>：能否通过<strong>子问题（子树）的答案推导原问题答案</strong>？若可以，定义递归函数并明确其<strong>返回值含义</strong>，充分利用子树的返回值构建原问题解。</p>
</li>
</ol>
<h4 data-id="heading-3">核心思考步骤</h4>
<p>单独抽出一个二叉树节点，思考两个关键问题：</p>
<ol>
<li>
<p>这个节点<strong>需要做什么事情</strong>？（如交换左右子节点、计算子树高度、序列化子树等）</p>
</li>
<li>
<p>这件事需要在<strong>什么时候做</strong>？（前序/中序/后序位置，层序的当前层）</p>
</li>
</ol>
<p><strong>其他节点无需操心</strong>，递归函数会帮你在所有节点上执行相同的操作——这是二叉树递归解题的核心，也是「分治思想」的完美体现。</p>
<h3 data-id="heading-4">二、二叉树解题思维：遍历 vs 分解问题（思维篇）</h3>
<p>我们通过3道LeetCode经典简单题，实战区分两种思维模式的差异与适用场景，理解<strong>前/中/后序位置</strong>的核心作用。</p>
<h4 data-id="heading-5">题1：翻转二叉树（LeetCode 226）</h4>
<p><strong>题目要求</strong>：原地翻转二叉树，交换每个节点的左右子节点，返回翻转后的根节点。</p>
<p><strong>核心结论</strong>：前后序位置均可实现，遍历思维更直观，分解思维更贴合递归本质。</p>
<h5 data-id="heading-6">解法1：遍历思维（前序遍历）</h5>
<p>遍历每个节点，在<strong>前序位置</strong>直接交换当前节点的左右子节点，递归处理子节点即可。</p>
<pre><code class="hljs language-JavaScript" lang="JavaScript">
<span class="hljs-comment">/**
 * 遍历思维：前序递归，直接操作每个节点
 * 核心：前序位置交换左右子节点，原地修改
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">invertTree</span>(<span class="hljs-params">root</span>) {
  <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  <span class="hljs-comment">// 前序位置：当前节点操作——交换左右子节点</span>
  [root.<span class="hljs-property">left</span>, root.<span class="hljs-property">right</span>] = [root.<span class="hljs-property">right</span>, root.<span class="hljs-property">left</span>];
  <span class="hljs-comment">// 递归遍历左右子树，完成下层翻转</span>
  <span class="hljs-title function_">invertTree</span>(root.<span class="hljs-property">left</span>);
  <span class="hljs-title function_">invertTree</span>(root.<span class="hljs-property">right</span>);
  <span class="hljs-keyword">return</span> root;
}
</code></pre>
<h5 data-id="heading-7">解法2：分解问题思维</h5>
<p><strong>函数定义</strong>：<code>invertTree(root)</code> 表示「翻转以<code>root</code>为根的二叉树，返回翻转后的根节点」。</p>
<p>利用函数定义，先翻转左右子树，再交换当前节点的左右子节点，贴合「子问题推导原问题」的思路。</p>
<pre><code class="hljs language-JavaScript" lang="JavaScript">
<span class="hljs-comment">/**
 * 分解问题思维：利用子树结果推导原问题
 * 核心：先解子问题（翻转左右子树），再处理当前节点
 */</span>
<span class="hljs-keyword">var</span> invertTree = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) {
    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    <span class="hljs-comment">// 子问题1：翻转左子树，得到翻转后的左子树根</span>
    <span class="hljs-keyword">var</span> left = <span class="hljs-title function_">invertTree</span>(root.<span class="hljs-property">left</span>);
    <span class="hljs-comment">// 子问题2：翻转右子树，得到翻转后的右子树根</span>
    <span class="hljs-keyword">var</span> right = <span class="hljs-title function_">invertTree</span>(root.<span class="hljs-property">right</span>);
    <span class="hljs-comment">// 处理当前节点：交换左右子节点</span>
    root.<span class="hljs-property">left</span> = right;
    root.<span class="hljs-property">right</span> = left;
    <span class="hljs-comment">// 符合函数定义：返回翻转后的当前根节点</span>
    <span class="hljs-keyword">return</span> root;
}
</code></pre>
<h4 data-id="heading-8">题2：填充节点的右侧指针（LeetCode 116）</h4>
<p><strong>题目要求</strong>：完美二叉树中，将同一层相邻节点通过<code>next</code>指针连接，最右侧节点<code>next</code>为<code>null</code>，原地修改。</p>
<p><strong>核心结论</strong>：<strong>遍历思维更适用</strong>，需将「两个相邻节点」作为遍历单元（三叉树思维），中后序无法实现。</p>
<pre><code class="hljs language-JavaScript" lang="JavaScript">
<span class="hljs-comment">/**
 * 遍历思维：自定义遍历单元（两个相邻节点）
 * 核心：前序位置连接相邻节点，递归处理下层所有相邻对
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">connect</span>(<span class="hljs-params">root</span>) {
  <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> root;
  <span class="hljs-comment">// 从根节点的左右子节点开始，处理第一层相邻对</span>
  <span class="hljs-title function_">link</span>(root.<span class="hljs-property">left</span>, root.<span class="hljs-property">right</span>);
  <span class="hljs-keyword">return</span> root;

  <span class="hljs-comment">// 遍历单元：两个相邻节点，负责连接并处理下层</span>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">link</span>(<span class="hljs-params">node1, node2</span>) {
    <span class="hljs-keyword">if</span> (!node1 || !node2) <span class="hljs-keyword">return</span>;
    <span class="hljs-comment">// 前序位置：核心操作——连接两个相邻节点</span>
    node1.<span class="hljs-property">next</span> = node2;
    <span class="hljs-comment">// 处理同父节点的左右子节点</span>
    <span class="hljs-title function_">link</span>(node1.<span class="hljs-property">left</span>, node1.<span class="hljs-property">right</span>);
    <span class="hljs-comment">// 处理跨父节点的相邻子节点（核心难点）</span>
    <span class="hljs-title function_">link</span>(node1.<span class="hljs-property">right</span>, node2.<span class="hljs-property">left</span>);
    <span class="hljs-comment">// 处理另一父节点的左右子节点</span>
    <span class="hljs-title function_">link</span>(node2.<span class="hljs-property">left</span>, node2.<span class="hljs-property">right</span>);
  }
}
</code></pre>
<h4 data-id="heading-9">题3：将二叉树展开为链表（LeetCode 114）</h4>
<p><strong>题目要求</strong>：原地将二叉树展开为单链表，按<strong>前序遍历顺序</strong>通过<code>right</code>指针连接，<code>left</code>指针置空。</p>
<p><strong>核心结论</strong>：<strong>分解问题思维更高效</strong>，后序位置利用子树展开结果，直接拼接即可；遍历思维需额外记录前序节点，实现复杂。</p>
<pre><code class="hljs language-JavaScript" lang="JavaScript">
<span class="hljs-comment">/**
 * 分解问题思维：后序遍历，利用子树展开结果拼接
 * 函数定义：flatten(root) 表示「将root为根的树展开为前序链表」
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">flatten</span>(<span class="hljs-params">root</span>) {
    <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;
    <span class="hljs-comment">// 子问题1：展开左子树</span>
    <span class="hljs-title function_">flatten</span>(root.<span class="hljs-property">left</span>);
    <span class="hljs-comment">// 子问题2：展开右子树</span>
    <span class="hljs-title function_">flatten</span>(root.<span class="hljs-property">right</span>);

    <span class="hljs-comment">// 后序位置：利用子树结果处理当前节点（关键！后序能获取子树处理后的结果）</span>
    <span class="hljs-keyword">const</span> left = root.<span class="hljs-property">left</span>;  <span class="hljs-comment">// 已展开的左链表</span>
    <span class="hljs-keyword">const</span> right = root.<span class="hljs-property">right</span>; <span class="hljs-comment">// 已展开的右链表</span>

    <span class="hljs-comment">// 核心操作：将左链表拼接到root.right，左指针置空</span>
    root.<span class="hljs-property">left</span> = <span class="hljs-literal">null</span>;
    root.<span class="hljs-property">right</span> = left;

    <span class="hljs-comment">// 找到左链表的尾节点，拼接右链表</span>
    <span class="hljs-keyword">let</span> p = root;
    <span class="hljs-keyword">while</span> (p.<span class="hljs-property">right</span> !== <span class="hljs-literal">null</span>) p = p.<span class="hljs-property">right</span>;
    p.<span class="hljs-property">right</span> = right;
}
</code></pre>
<h4 data-id="heading-10">思维对比与前/后序核心作用</h4>




























<table><thead><tr><th>思维模式</th><th>核心特点</th><th>适用场景</th><th>关键位置</th></tr></thead><tbody><tr><td>遍历思维</td><td>直接操作节点，配合外部变量</td><td>无需子树结果，仅需遍历节点执行操作</td><td>前序（优先）、层序</td></tr><tr><td>分解问题思维</td><td>利用子树返回值，推导原问题</td><td>需基于子树处理结果完成当前节点操作</td><td>后序（优先）、前序</td></tr><tr><td><strong>前序 vs 后序核心区别</strong>：</td><td/><td/></tr></tbody></table>
<ul>
<li>
<p>前序位置：<strong>只能获取父节点传递的参数</strong>，无法获取子树的处理结果，适合「先操作当前节点，再递归子节点」；</p>
</li>
<li>
<p>后序位置：<strong>既能获取参数，又能获取子树的返回值</strong>，是「分解问题思维」的核心位置，几乎所有子树相关问题都需要在后序位置处理。</p>
</li>
</ul>
<h3 data-id="heading-11">三、二叉树构造问题：分解问题的极致应用（构造篇）</h3>
<p>二叉树的构造问题是<strong>分解问题思维</strong>的典型场景，核心框架为：</p>
<p><strong>构造整棵树 = 构建根节点 + 递归构造左子树 + 递归构造右子树</strong></p>
<p>所有构造问题的解题步骤可总结为<strong>四步通用框架</strong>：</p>
<ol>
<li>
<p><strong>定根</strong>：确定当前子树的根节点（如最大值、前序首元素、后序尾元素）；</p>
</li>
<li>
<p><strong>找边界</strong>：根据根节点，划分左/右子树的元素边界（如数组区间、遍历序列索引）；</p>
</li>
<li>
<p><strong>算大小</strong>：计算左/右子树的节点个数，作为分割遍历序列的依据；</p>
</li>
<li>
<p><strong>分治构建</strong>：递归构建左/右子树，挂载到当前根节点的左右指针。</p>
</li>
</ol>
<p>下面结合4道LeetCode经典构造题，从简单到复杂，吃透构造问题的通用解法。</p>
<h4 data-id="heading-12">题1：最大二叉树（LeetCode 654）</h4>
<p><strong>题目要求</strong>：给定无重复整数数组，构建最大二叉树——根为数组最大值，左子树用最大值左区间构建，右子树用最大值右区间构建。</p>
<p><strong>核心思路</strong>：<strong>数组索引分治</strong>，全程操作原数组，无数组拷贝，空间效率最优。</p>
<pre><code class="hljs language-JavaScript" lang="JavaScript">
<span class="hljs-comment">/**
 * 最大二叉树构造：数组区间分治，分解问题思维
 * 核心：找区间最大值定根，分割区间递归构建左右子树
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">constructMaximumBinaryTree</span>(<span class="hljs-params">nums</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">build</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>);

  <span class="hljs-comment">// 函数定义：用nums[low..high]构建最大二叉树，返回根节点</span>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">build</span>(<span class="hljs-params">nums, low, high</span>) {
    <span class="hljs-keyword">if</span> (low &gt; high) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// 区间无效，返回null</span>

    <span class="hljs-comment">// 步骤1：找区间最大值及索引（定根）</span>
    <span class="hljs-keyword">let</span> maxVal = -<span class="hljs-title class_">Infinity</span>, maxIdx = -<span class="hljs-number">1</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = low; i &lt;= high; i++) {
      <span class="hljs-keyword">if</span> (nums[i] &gt; maxVal) {
        maxVal = nums[i];
        maxIdx = i;
      }
    }

    <span class="hljs-comment">// 步骤2：构建当前根节点</span>
    <span class="hljs-keyword">const</span> root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(maxVal);
    <span class="hljs-comment">// 步骤3：分治构建左右子树（找边界）</span>
    root.<span class="hljs-property">left</span> = <span class="hljs-title function_">build</span>(nums, low, maxIdx - <span class="hljs-number">1</span>);
    root.<span class="hljs-property">right</span> = <span class="hljs-title function_">build</span>(nums, maxIdx + <span class="hljs-number">1</span>, high);

    <span class="hljs-keyword">return</span> root;
  }
}
</code></pre>
<h4 data-id="heading-13">题2：从前序与中序遍历序列构造二叉树（LeetCode 105）</h4>
<p><strong>题目要求</strong>：给定二叉树的前序和中序遍历序列，构造并返回二叉树（节点值无重复）。</p>
<p><strong>核心特性</strong>：</p>
<ol>
<li>
<p>前序：<strong>根 → 左子树 → 右子树</strong>（首元素为根）；</p>
</li>
<li>
<p>中序：<strong>左子树 → 根 → 右子树</strong>（根为分割点，划分左右子树）；</p>
</li>
<li>
<p>关键桥梁：中序中左子树的节点个数，是分割前序序列的唯一依据。</p>
</li>
</ol>
<p><strong>性能优化</strong>：构建中序「值→索引」Map，将根节点查询时间从O(n)降至O(1)，时间复杂度从O(n²)优化为O(n)。</p>
<pre><code class="hljs language-JavaScript" lang="JavaScript">
<span class="hljs-comment">/**
 * 前序+中序构造二叉树：索引分治+Map优化
 * 核心：前序定根，中序分左右，节点数做桥梁
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">buildTree</span>(<span class="hljs-params">preorder, inorder</span>) {
  <span class="hljs-keyword">if</span> (preorder.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  <span class="hljs-comment">// 构建中序值→索引Map，O(1)查询根节点位置</span>
  <span class="hljs-keyword">const</span> valToIndex = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
  inorder.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">val, idx</span>) =&gt;</span> valToIndex.<span class="hljs-title function_">set</span>(val, idx));
  <span class="hljs-comment">// 初始区间：全数组[0, len-1]</span>
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">build</span>(<span class="hljs-number">0</span>, preorder.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, inorder.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>);

  <span class="hljs-comment">// 函数定义：用pre[pStart..pEnd]和in[iStart..iEnd]构建子树</span>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">build</span>(<span class="hljs-params">pStart, pEnd, iStart, iEnd</span>) {
    <span class="hljs-keyword">if</span> (pStart &gt; pEnd) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    <span class="hljs-comment">// 步骤1：前序首元素为根（定根）</span>
    <span class="hljs-keyword">const</span> rootVal = preorder[pStart];
    <span class="hljs-keyword">const</span> root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(rootVal);
    <span class="hljs-comment">// 步骤2：中序中找根节点索引（找边界）</span>
    <span class="hljs-keyword">const</span> rootInIdx = valToIndex.<span class="hljs-title function_">get</span>(rootVal);
    <span class="hljs-comment">// 步骤3：计算左子树节点数（做桥梁）</span>
    <span class="hljs-keyword">const</span> leftSize = rootInIdx - iStart;

    <span class="hljs-comment">// 步骤4：分治构建左右子树</span>
    root.<span class="hljs-property">left</span> = <span class="hljs-title function_">build</span>(pStart + <span class="hljs-number">1</span>, pStart + leftSize, iStart, rootInIdx - <span class="hljs-number">1</span>);
    root.<span class="hljs-property">right</span> = <span class="hljs-title function_">build</span>(pStart + leftSize + <span class="hljs-number">1</span>, pEnd, rootInIdx + <span class="hljs-number">1</span>, iEnd);
    <span class="hljs-keyword">return</span> root;
  }
}
</code></pre>
<h4 data-id="heading-14">题3：从中序与后序遍历序列构造二叉树（LeetCode 106）</h4>
<p><strong>题目要求</strong>：给定二叉树的中序和后序遍历序列，构造并返回二叉树（节点值无重复）。</p>
<p><strong>核心特性</strong>（与前序+中序的唯一区别）：</p>
<ul>
<li>
<p>后序：<strong>左子树 → 右子树 → 根</strong>（尾元素为根）；</p>
</li>
<li>
<p>后序序列分割时，需<strong>排除尾节点的根</strong>，右区间结束位置为<code>pEnd - 1</code>。</p>
</li>
</ul>
<pre><code class="hljs language-JavaScript" lang="JavaScript">
<span class="hljs-comment">/**
 * 中序+后序构造二叉树：索引分治+Map优化
 * 核心：后序定根（尾元素），中序分左右，节点数做桥梁
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">buildTree</span>(<span class="hljs-params">inorder, postorder</span>) {
  <span class="hljs-keyword">if</span> (postorder.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">const</span> valToIndex = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
  inorder.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">val, idx</span>) =&gt;</span> valToIndex.<span class="hljs-title function_">set</span>(val, idx));
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">build</span>(<span class="hljs-number">0</span>, postorder.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, inorder.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>);

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">build</span>(<span class="hljs-params">pStart, pEnd, iStart, iEnd</span>) {
    <span class="hljs-keyword">if</span> (pStart &gt; pEnd) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    <span class="hljs-comment">// 步骤1：后序尾元素为根（定根，与前序的核心区别）</span>
    <span class="hljs-keyword">const</span> rootVal = postorder[pEnd];
    <span class="hljs-keyword">const</span> root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(rootVal);
    <span class="hljs-keyword">const</span> rootInIdx = valToIndex.<span class="hljs-title function_">get</span>(rootVal);
    <span class="hljs-keyword">const</span> leftSize = rootInIdx - iStart;

    <span class="hljs-comment">// 步骤2：分治构建左右子树（后序区间分割与前序不同）</span>
    root.<span class="hljs-property">left</span> = <span class="hljs-title function_">build</span>(pStart, pStart + leftSize - <span class="hljs-number">1</span>, iStart, rootInIdx - <span class="hljs-number">1</span>);
    root.<span class="hljs-property">right</span> = <span class="hljs-title function_">build</span>(pStart + leftSize, pEnd - <span class="hljs-number">1</span>, rootInIdx + <span class="hljs-number">1</span>, iEnd);
    <span class="hljs-keyword">return</span> root;
  }
}
</code></pre>
<h4 data-id="heading-15">题4：从前序与后序遍历序列构造二叉树（LeetCode 889）</h4>
<p><strong>题目要求</strong>：给定二叉树的前序和后序遍历序列，构造并返回二叉树（节点值无重复，答案不唯一）。</p>
<p><strong>核心特性</strong>（与前两题的关键区别）：</p>
<ol>
<li>
<p>前序+后序<strong>无法唯一确定二叉树</strong>（根节点加单个子节点，左/右均可），题目允许返回任意合法答案；</p>
</li>
<li>
<p>前序第二个元素为<strong>左子树的根</strong>，通过后序找到其位置，计算左子树大小（分割序列的依据）；</p>
</li>
<li>
<p>递归终止时需单独处理<strong>叶子节点</strong>（避免数组越界）。</p>
</li>
</ol>
<pre><code class="hljs language-JavaScript" lang="JavaScript">
<span class="hljs-comment">/**
 * 前序+后序构造二叉树：索引分治+叶子节点单独处理
 * 核心：前序定根，后序定左子树边界，答案不唯一
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">constructFromPrePost</span>(<span class="hljs-params">preorder, postorder</span>) {
  <span class="hljs-keyword">if</span> (preorder.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  <span class="hljs-comment">// 构建后序值→索引Map</span>
  <span class="hljs-keyword">const</span> valToIndex = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
  postorder.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">val, idx</span>) =&gt;</span> valToIndex.<span class="hljs-title function_">set</span>(val, idx));
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">build</span>(<span class="hljs-number">0</span>, preorder.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, postorder.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>);

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">build</span>(<span class="hljs-params">pStart, pEnd, postStart, postEnd</span>) {
    <span class="hljs-keyword">if</span> (pStart &gt; pEnd) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    <span class="hljs-comment">// 单独处理叶子节点（避免preStart+1越界，关键！）</span>
    <span class="hljs-keyword">if</span> (pStart === pEnd) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(preorder[pStart]);

    <span class="hljs-comment">// 步骤1：前序首元素为根</span>
    <span class="hljs-keyword">const</span> rootVal = preorder[pStart];
    <span class="hljs-keyword">const</span> root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(rootVal);
    <span class="hljs-comment">// 步骤2：前序第二个元素为左子树根，找其在后序的位置</span>
    <span class="hljs-keyword">const</span> leftRootVal = preorder[pStart + <span class="hljs-number">1</span>];
    <span class="hljs-keyword">const</span> leftPostIdx = valToIndex.<span class="hljs-title function_">get</span>(leftRootVal);
    <span class="hljs-comment">// 步骤3：计算左子树节点数</span>
    <span class="hljs-keyword">const</span> leftSize = leftPostIdx - postStart + <span class="hljs-number">1</span>;

    <span class="hljs-comment">// 步骤4：分治构建左右子树</span>
    root.<span class="hljs-property">left</span> = <span class="hljs-title function_">build</span>(pStart + <span class="hljs-number">1</span>, pStart + leftSize, postStart, leftPostIdx);
    root.<span class="hljs-property">right</span> = <span class="hljs-title function_">build</span>(pStart + leftSize + <span class="hljs-number">1</span>, pEnd, leftPostIdx + <span class="hljs-number">1</span>, postEnd - <span class="hljs-number">1</span>);
    <span class="hljs-keyword">return</span> root;
  }
}
</code></pre>
<h4 data-id="heading-16">构造问题通用总结</h4>
<ol>
<li>
<p><strong>必用分解问题思维</strong>：构造整棵树的本质是递归构造子树，必须定义「区间构建子树」的递归函数；</p>
</li>
<li>
<p><strong>索引分治是最优解</strong>：全程操作原数组，无数组拷贝，空间复杂度O(n)（递归栈）；</p>
</li>
<li>
<p><strong>Map是性能刚需</strong>：将根节点查询时间从O(n)降至O(1)，避免时间复杂度升至O(n²)；</p>
</li>
<li>
<p><strong>节点数是核心桥梁</strong>：中序/后序中计算的左子树节点数，是分割前序/后序序列的唯一依据；</p>
</li>
<li>
<p><strong>边界处理要严谨</strong>：区间为<strong>闭区间</strong>，不可随意增减索引，避免节点缺失/重复。</p>
</li>
</ol>
<h3 data-id="heading-17">四、二叉树后序篇：子树相关问题的核心解法（后序篇）</h3>
<p>通过前面的题目我们发现：<strong>后序位置是处理子树相关问题的黄金位置</strong>——因为后序能获取左右子树的返回值，而子树问题的本质，正是基于子树的结果推导当前节点的答案。</p>
<p>LeetCode 652「寻找重复的子树」是后序思维的经典应用，结合<strong>子树序列化</strong>和<strong>哈希表统计</strong>，完美体现「后序+分解问题」的解题思路。</p>
<h4 data-id="heading-18">题：寻找重复的子树（LeetCode 652）</h4>
<p><strong>题目要求</strong>：找出二叉树中所有重复的子树，返回重复子树的根节点数组（每个重复子树仅返回一次）。</p>
<p><strong>核心思路</strong>：</p>
<ol>
<li>
<p><strong>后序序列化子树</strong>：按「左→右→根」拼接子树标识（唯一标识子树结构，避免歧义）；</p>
</li>
<li>
<p><strong>哈希表统计次数</strong>：用Map记录每个子树标识的出现次数；</p>
</li>
<li>
<p><strong>首次重复时收集</strong>：仅当子树出现次数从1→2时收集根节点（避免重复添加）。</p>
</li>
</ol>
<p><strong>关键细节</strong>：</p>
<ul>
<li>
<p>空节点必须用<strong>统一标记（#）</strong> 表示，不可省略（缺失会导致结构歧义）；</p>
</li>
<li>
<p>节点值/空标记必须用<strong>分隔符（,）</strong> 分隔，避免多位数拼接冲突（如12和1,2）；</p>
</li>
<li>
<p>序列化顺序必须为<strong>左→右→根</strong>（标准后序），能最大程度保留子树结构信息，避免标识重复。</p>
</li>
</ul>
<pre><code class="hljs language-JavaScript" lang="JavaScript">
<span class="hljs-comment">/**
 * 寻找重复子树：后序序列化+哈希统计+分解问题思维
 * 核心：后序位置返回子树标识，利用子树结果统计重复
 */</span>
<span class="hljs-keyword">var</span> findDuplicateSubtrees = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) {
    <span class="hljs-keyword">const</span> countMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>(); <span class="hljs-comment">// 子树标识→出现次数</span>
    <span class="hljs-keyword">const</span> result = []; <span class="hljs-comment">// 存储重复子树根节点</span>

    <span class="hljs-comment">// 函数定义：序列化当前节点为根的子树，返回唯一标识</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">serialize</span>(<span class="hljs-params">node</span>) {
        <span class="hljs-keyword">if</span> (node === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">'#'</span>; <span class="hljs-comment">// 空节点标记，不可省略</span>
        <span class="hljs-comment">// 后序遍历：先序列化左右子树（子问题）</span>
        <span class="hljs-keyword">const</span> left = <span class="hljs-title function_">serialize</span>(node.<span class="hljs-property">left</span>);
        <span class="hljs-keyword">const</span> right = <span class="hljs-title function_">serialize</span>(node.<span class="hljs-property">right</span>);
        <span class="hljs-comment">// 后序位置：拼接当前子树标识（左→右→根，标准后序）</span>
        <span class="hljs-keyword">const</span> curStr = <span class="hljs-string">`<span class="hljs-subst">${left}</span>,<span class="hljs-subst">${right}</span>,<span class="hljs-subst">${node.val}</span>`</span>;
        <span class="hljs-comment">// 统计次数，首次重复时收集（count===2）</span>
        <span class="hljs-keyword">const</span> count = (countMap.<span class="hljs-title function_">get</span>(curStr) || <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>;
        countMap.<span class="hljs-title function_">set</span>(curStr, count);
        <span class="hljs-keyword">if</span> (count === <span class="hljs-number">2</span>) result.<span class="hljs-title function_">push</span>(node);
        <span class="hljs-comment">// 返回子树标识，供父节点拼接（分解问题的核心）</span>
        <span class="hljs-keyword">return</span> curStr;
    }

    <span class="hljs-title function_">serialize</span>(root);
    <span class="hljs-keyword">return</span> result;
};
</code></pre>
<h4 data-id="heading-19">后序思维核心总结</h4>
<ol>
<li>
<p><strong>子树问题必用后序</strong>：只要题目与子树相关，大概率需要在后序位置写代码，利用子树的返回值；</p>
</li>
<li>
<p><strong>后序是分解问题的核心</strong>：后序位置能获取左右子树的处理结果，是「子问题推导原问题」的最佳时机；</p>
</li>
<li>
<p><strong>序列化标识要唯一</strong>：子树序列化需满足「空节点标记+分隔符+标准遍历顺序」，避免结构歧义。</p>
</li>
</ol>
<h3 data-id="heading-20">五、二叉树序列化与反序列化：遍历的极致应用（序列化篇）</h3>
<p>序列化的目的是<strong>将二叉树转换为独立于编程语言的格式</strong>（如字符串），方便存储/传输；反序列化则是将序列化格式还原为二叉树，核心要求是<strong>能还原出唯一的二叉树</strong>。</p>
<h4 data-id="heading-21">序列化与反序列化的核心结论</h4>
<p>当二叉树节点值无重复时，序列化结果的<strong>唯一性</strong>取决于「是否包含空节点信息」和「遍历顺序」，总结为3条核心规则：</p>
<ol>
<li>
<p><strong>无空节点信息</strong>：仅一种遍历顺序无法唯一还原，前序+中序/后序+中序可还原，前序+后序不可还原；</p>
</li>
<li>
<p><strong>有空节点信息</strong>：前序/后序可唯一还原（根节点位置固定），中序<strong>无法还原</strong>（根节点位置不固定）；</p>
</li>
<li>
<p><strong>层序遍历</strong>：包含空节点信息时可唯一还原，是工程中最常用的序列化方式（按层存储，结构直观）。</p>
</li>
</ol>
<h4 data-id="heading-22">核心通用规则</h4>
<p>无论哪种遍历方式的序列化/反序列化，都需遵守3条通用规则：</p>
<ol>
<li>
<p><strong>空节点显式标记</strong>：用统一符号（如#）标记空节点，不可省略；</p>
</li>
<li>
<p><strong>分隔符分隔</strong>：用逗号（,）分隔节点值/空标记，避免拼接冲突；</p>
</li>
<li>
<p><strong>遍历顺序一致</strong>：反序列化的遍历顺序必须与序列化完全一致（如前序序列化→前序反序列化）。</p>
</li>
</ol>
<p>下面依次讲解<strong>前序、后序、层序</strong>的序列化与反序列化实现（中序无法唯一反序列化，无需实现），均为<strong>工程优化版</strong>，兼顾效率与鲁棒性。</p>
<h4 data-id="heading-23">1. 前序序列化与反序列化</h4>
<p><strong>核心规则</strong>：序列化按「根→左→右」，反序列化也按「根→左→右」，用<strong>索引指针</strong>替代数组shift（O(1)效率）。</p>
<pre><code class="hljs language-JavaScript" lang="JavaScript">
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">NULL_NODE_MARK</span> = <span class="hljs-string">'#'</span>; <span class="hljs-comment">// 空节点标记，单一数据源</span>

<span class="hljs-comment">/**
 * 前序序列化：根→左→右，包含空节点标记
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">serializePreorder</span>(<span class="hljs-params">root</span>) {
  <span class="hljs-keyword">const</span> res = [];
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">traverse</span>(<span class="hljs-params">node</span>) {
    <span class="hljs-keyword">if</span> (node === <span class="hljs-literal">null</span>) {
      res.<span class="hljs-title function_">push</span>(<span class="hljs-variable constant_">NULL_NODE_MARK</span>);
      <span class="hljs-keyword">return</span>;
    }
    res.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">val</span>); <span class="hljs-comment">// 前序：先根</span>
    <span class="hljs-title function_">traverse</span>(node.<span class="hljs-property">left</span>); <span class="hljs-comment">// 再左</span>
    <span class="hljs-title function_">traverse</span>(node.<span class="hljs-property">right</span>); <span class="hljs-comment">// 最后右</span>
  }
  <span class="hljs-title function_">traverse</span>(root);
  <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">join</span>(<span class="hljs-string">','</span>);
}

<span class="hljs-comment">/**
 * 前序反序列化：根→左→右，索引指针优化
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">deserializePreorder</span>(<span class="hljs-params">serializeStr</span>) {
  <span class="hljs-keyword">if</span> (!serializeStr || serializeStr.<span class="hljs-title function_">trim</span>() === <span class="hljs-string">''</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">const</span> arr = serializeStr.<span class="hljs-title function_">split</span>(<span class="hljs-string">','</span>);
  <span class="hljs-keyword">let</span> idx = <span class="hljs-number">0</span>; <span class="hljs-comment">// 索引指针，O(1)取数</span>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">build</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">const</span> val = arr[idx++];
    <span class="hljs-keyword">if</span> (val === <span class="hljs-variable constant_">NULL_NODE_MARK</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">const</span> node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-title class_">Number</span>(val));
    node.<span class="hljs-property">left</span> = <span class="hljs-title function_">build</span>(); <span class="hljs-comment">// 先构建左子树</span>
    node.<span class="hljs-property">right</span> = <span class="hljs-title function_">build</span>(); <span class="hljs-comment">// 再构建右子树</span>
    <span class="hljs-keyword">return</span> node;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">build</span>();
}
</code></pre>
<h4 data-id="heading-24">2. 后序序列化与反序列化</h4>
<p><strong>核心规则</strong>：序列化按「左→右→根」，反序列化从<strong>数组尾部取元素</strong>（根在尾部），且<strong>先构建右子树，再构建左子树</strong>（与序列化顺序镜像）。</p>
<pre><code class="hljs language-JavaScript" lang="JavaScript">
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">NULL_NODE_MARK</span> = <span class="hljs-string">'#'</span>;

<span class="hljs-comment">/**
 * 后序序列化：左→右→根，包含空节点标记
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">serializePostorder</span>(<span class="hljs-params">root</span>) {
  <span class="hljs-keyword">const</span> res = [];
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">traverse</span>(<span class="hljs-params">node</span>) {
    <span class="hljs-keyword">if</span> (node === <span class="hljs-literal">null</span>) {
      res.<span class="hljs-title function_">push</span>(<span class="hljs-variable constant_">NULL_NODE_MARK</span>);
      <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-title function_">traverse</span>(node.<span class="hljs-property">left</span>); <span class="hljs-comment">// 先左</span>
    <span class="hljs-title function_">traverse</span>(node.<span class="hljs-property">right</span>); <span class="hljs-comment">// 再右</span>
    res.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">val</span>); <span class="hljs-comment">// 最后根</span>
  }
  <span class="hljs-title function_">traverse</span>(root);
  <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">join</span>(<span class="hljs-string">','</span>);
}

<span class="hljs-comment">/**
 * 后序反序列化：从尾部取元素，先右后左构建
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">deserializePostorder</span>(<span class="hljs-params">serializeStr</span>) {
  <span class="hljs-keyword">if</span> (!serializeStr || serializeStr.<span class="hljs-title function_">trim</span>() === <span class="hljs-string">''</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">const</span> arr = serializeStr.<span class="hljs-title function_">split</span>(<span class="hljs-string">','</span>);
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">build</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">const</span> val = arr.<span class="hljs-title function_">pop</span>(); <span class="hljs-comment">// 尾部取元素，根在最后</span>
    <span class="hljs-keyword">if</span> (val === <span class="hljs-variable constant_">NULL_NODE_MARK</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">const</span> node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-title class_">Number</span>(val));
    node.<span class="hljs-property">right</span> = <span class="hljs-title function_">build</span>(); <span class="hljs-comment">// 先构建右子树（镜像顺序）</span>
    node.<span class="hljs-property">left</span> = <span class="hljs-title function_">build</span>(); <span class="hljs-comment">// 再构建左子树</span>
    <span class="hljs-keyword">return</span> node;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">build</span>();
}
</code></pre>
<h4 data-id="heading-25">3. 层序序列化与反序列化（工程推荐）</h4>
<p><strong>核心规则</strong>：按「从上到下、从左到右」遍历，用<strong>队列</strong>实现按层访问，反序列化时用队列维护<strong>待构建子树的父节点</strong>，按顺序分配左右子节点。</p>
<p><strong>工程优化</strong>：序列化时去除末尾冗余空标记，让结果更紧凑；反序列化时增加边界校验，增强鲁棒性。</p>
<pre><code class="hljs language-JavaScript" lang="JavaScript">
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">NULL_NODE_MARK</span> = <span class="hljs-string">'#'</span>;

<span class="hljs-comment">/**
 * 层序序列化：队列实现，去除末尾冗余空标记（工程优化）
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">serializeLevelorder</span>(<span class="hljs-params">root</span>) {
  <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-variable constant_">NULL_NODE_MARK</span>;
  <span class="hljs-keyword">const</span> res = [];
  <span class="hljs-keyword">const</span> queue = [root];
  <span class="hljs-keyword">while</span> (queue.<span class="hljs-property">length</span>) {
    <span class="hljs-keyword">const</span> node = queue.<span class="hljs-title function_">shift</span>();
    <span class="hljs-keyword">if</span> (node === <span class="hljs-literal">null</span>) {
      res.<span class="hljs-title function_">push</span>(<span class="hljs-variable constant_">NULL_NODE_MARK</span>);
      <span class="hljs-keyword">continue</span>;
    }
    res.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">val</span>);
    queue.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">left</span>); <span class="hljs-comment">// 左右子节点均入队，无论是否为空</span>
    queue.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">right</span>);
  }
  <span class="hljs-comment">// 去除末尾冗余空标记，优化存储</span>
  <span class="hljs-keyword">while</span> (res[res.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>] === <span class="hljs-variable constant_">NULL_NODE_MARK</span>) res.<span class="hljs-title function_">pop</span>();
  <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">join</span>(<span class="hljs-string">','</span>);
}

<span class="hljs-comment">/**
 * 层序反序列化：队列维护父节点，按顺序分配左右子节点
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">deserializeLevelorder</span>(<span class="hljs-params">serializeStr</span>) {
  <span class="hljs-keyword">if</span> (!serializeStr || serializeStr.<span class="hljs-title function_">trim</span>() === <span class="hljs-string">''</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">const</span> arr = serializeStr.<span class="hljs-title function_">split</span>(<span class="hljs-string">','</span>);
  <span class="hljs-keyword">let</span> idx = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">const</span> root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-title class_">Number</span>(arr[idx++]));
  <span class="hljs-keyword">const</span> queue = [root]; <span class="hljs-comment">// 队列存储待构建子树的父节点</span>

  <span class="hljs-keyword">while</span> (queue.<span class="hljs-property">length</span> &amp;&amp; idx &lt; arr.<span class="hljs-property">length</span>) {
    <span class="hljs-keyword">const</span> parent = queue.<span class="hljs-title function_">shift</span>();
    <span class="hljs-comment">// 构建左子节点</span>
    <span class="hljs-keyword">if</span> (idx &lt; arr.<span class="hljs-property">length</span>) {
      <span class="hljs-keyword">const</span> leftVal = arr[idx++];
      parent.<span class="hljs-property">left</span> = leftVal !== <span class="hljs-variable constant_">NULL_NODE_MARK</span> ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-title class_">Number</span>(leftVal)) : <span class="hljs-literal">null</span>;
      parent.<span class="hljs-property">left</span> &amp;&amp; queue.<span class="hljs-title function_">push</span>(parent.<span class="hljs-property">left</span>);
    }
    <span class="hljs-comment">// 构建右子节点</span>
    <span class="hljs-keyword">if</span> (idx &lt; arr.<span class="hljs-property">length</span>) {
      <span class="hljs-keyword">const</span> rightVal = arr[idx++];
      parent.<span class="hljs-property">right</span> = rightVal !== <span class="hljs-variable constant_">NULL_NODE_MARK</span> ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-title class_">Number</span>(rightVal)) : <span class="hljs-literal">null</span>;
      parent.<span class="hljs-property">right</span> &amp;&amp; queue.<span class="hljs-title function_">push</span>(parent.<span class="hljs-property">right</span>);
    }
  }
  <span class="hljs-keyword">return</span> root;
}
</code></pre>
<h4 data-id="heading-26">序列化核心总结</h4>
<ol>
<li>
<p><strong>前/后序</strong>：实现简单，递归即可，适合算法题；</p>
</li>
<li>
<p><strong>层序</strong>：结构直观，工程中常用，队列实现按层访问；</p>
</li>
<li>
<p><strong>反序列化关键</strong>：前序用索引指针，后序从尾部取元素，层序用队列维护父节点；</p>
</li>
<li>
<p><strong>唯一性保障</strong>：包含空节点信息的前/后/层序，均可唯一还原二叉树。</p>
</li>
</ol>
<h3 data-id="heading-27">六、二叉树解题心法终极总结</h3>
<p>本文从<strong>解题总纲</strong>到<strong>思维模式</strong>，再到<strong>构造、后序、序列化</strong>三大核心模块，层层拆解了二叉树的解题规律，最终可总结为<strong>三大核心心法</strong>，记牢这几点，所有二叉树问题均可迎刃而解：</p>
<h4 data-id="heading-28">心法1：思维模式二选一，聚焦节点与时机</h4>
<ol>
<li>
<p>遍历思维：直接操作节点，配合外部变量，前序/层序优先；</p>
</li>
<li>
<p>分解问题思维：定义递归函数返回值，利用子树结果，后序优先；</p>
</li>
<li>
<p>所有问题都要聚焦「单个节点该做什么，在什么时候做」。</p>
</li>
</ol>
<h4 data-id="heading-29">心法2：前中后序有分工，后序是子树核心</h4>
<ol>
<li>
<p>前序：先操作当前节点，再递归子节点，适合遍历、翻转、连接等操作；</p>
</li>
<li>
<p>中序：仅适合二叉搜索树（BST）的有序遍历，普通二叉树应用极少；</p>
</li>
<li>
<p>后序：能获取子树返回值，是分解问题、子树相关问题的黄金位置；</p>
</li>
<li>
<p>层序：按层访问，工程常用，适合层序遍历、层序序列化等问题。</p>
</li>
</ol>
<h4 data-id="heading-30">心法3：构造与序列化，各有通用框架</h4>
<ol>
<li>
<p>构造问题：定根→找边界→算大小→分治构建，索引分治+Map优化是最优解；</p>
</li>
<li>
<p>序列化问题：空节点标记+分隔符+一致遍历顺序，前/后/层序均可实现，层序工程首选；</p>
</li>
<li>
<p>子树序列化：左→右→根标准后序，保证标识唯一，避免结构歧义。</p>
</li>
</ol>
<h3 data-id="heading-31">最后</h3>
<p>二叉树的所有问题，本质都是<strong>递归分治</strong>的应用，而递归的核心是「相信递归函数的定义，聚焦当前节点」。本文的所有解法和框架，都建立在「二叉树解题总纲」之上，只要你能理解并灵活运用「遍历」和「分解问题」两种思维，掌握前/中/后序的核心作用，就能轻松应对各类二叉树问题。</p>
<p>建议大家结合本文的代码，在LeetCode上动手实现一遍，从简单题到复杂题，逐步形成自己的解题体系——二叉树的基础打牢了，后续的二叉搜索树（BST）、平衡二叉树（AVL）、红黑树等高级数据结构，都会迎刃而解。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[二叉搜索树（BST）核心心法：从特性到实战，理解高频考点]]></title>    <link>https://juejin.cn/post/7602420156397158443</link>    <guid>https://juejin.cn/post/7602420156397158443</guid>    <pubDate>2026-02-03T10:21:20.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602420156397158443" data-draft-id="7602411521072136211" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="二叉搜索树（BST）核心心法：从特性到实战，理解高频考点"/> <meta itemprop="keywords" content="后端,JavaScript,算法"/> <meta itemprop="datePublished" content="2026-02-03T10:21:20.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="颜酱"/> <meta itemprop="url" content="https://juejin.cn/user/905653309941495"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            二叉搜索树（BST）核心心法：从特性到实战，理解高频考点
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/905653309941495/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    颜酱
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T10:21:20.000Z" title="Tue Feb 03 2026 10:21:20 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读42分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">二叉搜索树（BST）核心心法：从特性到实战，理解高频考点</h2>
<p>二叉搜索树（Binary Search Tree，简称BST）是算法领域最基础、最常用的树形数据结构之一，其「左小右大」的核心特性赋予了它高效的查找、插入、删除能力，时间复杂度均为O(logN)（平衡BST下）。同时，BST的中序遍历天然升序的特性，使其能轻松解决有序性相关问题。本文将从<strong>BST核心特性</strong>出发，循序渐进讲解<strong>基础操作、经典题型、进阶实战</strong>，提炼通用解题心法，帮你彻底吃透BST所有高频考点。</p>
<h3 data-id="heading-1">一、BST核心特性：一切操作的基础</h3>
<p>BST的定义看似简单，却是所有解题思路的源头，必须牢牢掌握<strong>严格定义</strong>和<strong>衍生性质</strong>，避免因理解偏差导致解题错误。</p>
<h4 data-id="heading-2">1.1 严格定义（3条核心规则）</h4>
<p>对于BST的任意一个节点<code>node</code>，必须同时满足：</p>
<ol>
<li>
<p>左子树的<strong>所有节点</strong>值都<strong>严格小于</strong><code>node.val</code>；</p>
</li>
<li>
<p>右子树的<strong>所有节点</strong>值都<strong>严格大于</strong><code>node.val</code>；</p>
</li>
<li>
<p>左子树和右子树自身也必须是合法的BST。</p>
</li>
</ol>
<p><strong>关键误区</strong>：切勿简化为「仅当前节点大于左子节点、小于右子节点」，深层子节点的约束会被忽略，导致BST合法性判断、遍历等操作出错。</p>
<h4 data-id="heading-3">1.2 核心衍生性质（算法解题的关键）</h4>
<p>从严格定义可推导出2个最常用的性质，几乎所有BST题目都围绕这两个性质展开：</p>
<ol>
<li>
<p><strong>高效查找性</strong>：根据「左小右大」，查找目标节点时可一次性排除一半子树，无需遍历所有节点，基础查找/插入/删除的时间复杂度为O(logN)（平衡BST），远优于普通二叉树的O(N)；</p>
</li>
<li>
<p><strong>中序遍历有序性</strong>：BST的中序遍历（左→根→右）结果为<strong>严格升序</strong>，逆序中序遍历（右→根→左）结果为<strong>严格降序</strong>。这一性质是解决「第K小元素」「累加树转换」等有序性问题的核心。</p>
</li>
</ol>
<h4 data-id="heading-4">1.3 BST与普通二叉树的核心区别</h4>
<p>普通二叉树的操作仅能通过<strong>全遍历</strong>（前/中/后序）实现，而BST可通过<strong>特性引导遍历</strong>（根据目标值与当前节点值的大小，决定左/右子树遍历），大幅提升效率；同时，BST的有序性是普通二叉树不具备的，这是解决各类有序问题的天然优势。</p>
<h3 data-id="heading-5">二、BST基础操作：查、增、删、验（高频面试题）</h3>
<p>BST的基础操作是所有进阶题型的铺垫，核心思路是**「特性引导遍历找位置 + 针对性修改」**，其中「删除」和「合法性验证」略复杂，需重点掌握。</p>
<h4 data-id="heading-6">2.1 查找节点（力扣700题）</h4>
<h5 data-id="heading-7">核心思路</h5>
<p>利用「左小右大」特性，递归/迭代引导遍历：目标值大于当前节点值则走右子树，小于则走左子树，等于则找到目标节点，空节点则表示未找到。</p>
<h5 data-id="heading-8">实现代码（递归版，简洁高效）</h5>
<pre><code class="hljs language-JavaScript" lang="JavaScript">
<span class="hljs-comment">/**
 * 查找BST中值为target的节点，找到返回节点，未找到返回null
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">TreeNode</span>} root BST根节点
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number</span>} target 目标值
 * <span class="hljs-doctag">@return</span> {<span class="hljs-type">TreeNode</span>} 目标节点/null
 */</span>
<span class="hljs-keyword">var</span> searchBST = <span class="hljs-keyword">function</span>(<span class="hljs-params">root, target</span>) {
    <span class="hljs-comment">// 递归终止：空节点未找到，直接返回null</span>
    <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    <span class="hljs-comment">// 目标值更大，去右子树查找</span>
    <span class="hljs-keyword">if</span> (target &gt; root.<span class="hljs-property">val</span>) <span class="hljs-keyword">return</span> <span class="hljs-title function_">searchBST</span>(root.<span class="hljs-property">right</span>, target);
    <span class="hljs-comment">// 目标值更小，去左子树查找</span>
    <span class="hljs-keyword">if</span> (target &lt; root.<span class="hljs-property">val</span>) <span class="hljs-keyword">return</span> <span class="hljs-title function_">searchBST</span>(root.<span class="hljs-property">left</span>, target);
    <span class="hljs-comment">// 找到目标节点，返回当前节点</span>
    <span class="hljs-keyword">return</span> root
};
</code></pre>
<h5 data-id="heading-9">复杂度</h5>
<p>时间：O(logN)（平衡BST）/ O(N)（链状BST），空间：O(logN)（递归栈）。</p>
<h4 data-id="heading-10">2.2 插入节点（力扣701题）</h4>
<h5 data-id="heading-11">核心思路</h5>
<ol>
<li>
<p>BST插入的<strong>关键性质</strong>：新节点最终必作为<strong>叶子节点</strong>插入，无需调整原有树结构（输入保证新值唯一）；</p>
</li>
<li>
<p>利用特性找到空节点（插入位置），创建新节点并返回，回溯时完成父节点与新节点的链接。</p>
</li>
</ol>
<h5 data-id="heading-12">实现代码</h5>
<pre><code class="hljs language-JavaScript" lang="JavaScript">
<span class="hljs-comment">/**
 * 向BST插入新值，保持BST性质，返回插入后的根节点
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">TreeNode</span>} root BST根节点
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number</span>} value 新值（保证唯一）
 * <span class="hljs-doctag">@return</span> {<span class="hljs-type">TreeNode</span>} 插入后的根节点
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">insertIntoBST</span>(<span class="hljs-params">root, value</span>) {
    <span class="hljs-comment">// 递归终止：找到空节点，创建新节点作为插入位置</span>
    <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(value);
    <span class="hljs-comment">// 新值更大，去右子树插入，更新右子树链接</span>
    <span class="hljs-keyword">if</span> (value &gt; root.<span class="hljs-property">val</span>) {
        root.<span class="hljs-property">right</span> = <span class="hljs-title function_">insertIntoBST</span>(root.<span class="hljs-property">right</span>, value);
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// 新值更小，去左子树插入，更新左子树链接</span>
        root.<span class="hljs-property">left</span> = <span class="hljs-title function_">insertIntoBST</span>(root.<span class="hljs-property">left</span>, value);
    }
    <span class="hljs-comment">// 回溯返回当前节点，保证树结构连续</span>
    <span class="hljs-keyword">return</span> root;
}
</code></pre>
<h5 data-id="heading-13">复杂度</h5>
<p>时间：O(logN)，空间：O(logN)（递归栈）。</p>
<h4 data-id="heading-14">2.3 验证BST合法性（力扣98题）</h4>
<h5 data-id="heading-15">核心思路</h5>
<ol>
<li>
<p>关键问题：单个节点的合法值范围由<strong>所有祖先节点</strong>共同决定，而非仅父节点；</p>
</li>
<li>
<p>解决方案：递归传递<strong>动态上下界</strong>，为每个节点划定开区间合法范围<code>(min, max)</code>，节点值必须严格在区间内，同时左右子树也需合法。</p>
</li>
</ol>
<h5 data-id="heading-16">实现代码</h5>
<pre><code class="hljs language-JavaScript" lang="JavaScript">
<span class="hljs-comment">/**
 * 验证二叉树是否为合法BST
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">TreeNode</span>} root 二叉树根节点
 * <span class="hljs-doctag">@return</span> {<span class="hljs-type">boolean</span>} 是否为合法BST
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">isValidBST</span>(<span class="hljs-params">root</span>) {
    <span class="hljs-comment">// 空树视为合法BST，根节点初始上下界为负无穷/正无穷</span>
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">traverse</span>(root, -<span class="hljs-title class_">Infinity</span>, <span class="hljs-title class_">Infinity</span>);
    
    <span class="hljs-comment">// 递归辅助：验证当前节点是否在(min, max)区间内</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">traverse</span>(<span class="hljs-params">node, min, max</span>) {
        <span class="hljs-keyword">if</span> (node === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        <span class="hljs-comment">// 节点值超出开区间，直接判定非法</span>
        <span class="hljs-keyword">if</span> (node.<span class="hljs-property">val</span> &lt;= min || node.<span class="hljs-property">val</span> &gt;= max) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        <span class="hljs-comment">// 验证左子树：上界更新为当前节点值，下界继承</span>
        <span class="hljs-keyword">const</span> leftValid = <span class="hljs-title function_">traverse</span>(node.<span class="hljs-property">left</span>, min, node.<span class="hljs-property">val</span>);
        <span class="hljs-comment">// 验证右子树：下界更新为当前节点值，上界继承</span>
        <span class="hljs-keyword">const</span> rightValid = <span class="hljs-title function_">traverse</span>(node.<span class="hljs-property">right</span>, node.<span class="hljs-property">val</span>, max);
        <span class="hljs-comment">// 左右子树都合法，当前子树才合法</span>
        <span class="hljs-keyword">return</span> leftValid &amp;&amp; rightValid;
    }
}
</code></pre>
<h5 data-id="heading-17">关键易错点</h5>
<ul>
<li>
<p>初始上下界必须为<code>(-Infinity, Infinity)</code>，根节点无祖先约束；</p>
</li>
<li>
<p>必须用<strong>开区间</strong>（<code>&lt;= / &gt;=</code>），避免节点值等于边界（如<code>[2,2,2]</code>误判为合法）。</p>
</li>
</ul>
<h4 data-id="heading-18">2.4 删除节点（力扣450题，核心难点）</h4>
<h5 data-id="heading-19">核心思路</h5>
<p>先通过特性找到目标节点，再分<strong>4种情况</strong>处理删除，核心是「删除后保持BST性质」，其中「有左右双孩子」的情况是难点。</p>
<h5 data-id="heading-20">4种删除情况</h5>
<ol>
<li>
<p>目标节点是<strong>叶子节点</strong>（左右子树均空）：直接删除，返回null让父节点置空该子树；</p>
</li>
<li>
<p>只有右子树：用右子树替换当前节点，返回右子树根节点；</p>
</li>
<li>
<p>只有左子树：用左子树替换当前节点，返回左子树根节点；</p>
</li>
<li>
<p>有<strong>左右双孩子</strong>（核心）：选择「左子树最大值节点（前驱）」或「右子树最小值节点（后继）」替换当前节点，再删除该替换节点（保证BST性质不变）。</p>
</li>
</ol>
<h5 data-id="heading-21">实现代码（前驱节点替换法，不修改节点值，仅调整指针）</h5>
<pre><code class="hljs language-JavaScript" lang="JavaScript">
<span class="hljs-comment">/**
 * 删除BST中值为key的节点，保持BST性质，返回删除后的根节点
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">TreeNode</span>} root BST根节点
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number</span>} key 要删除的节点值
 * <span class="hljs-doctag">@return</span> {<span class="hljs-type">TreeNode</span>} 删除后的根节点
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">deleteNode</span>(<span class="hljs-params">root, key</span>) {
    <span class="hljs-comment">// 递归终止：空树/未找到目标节点，返回null</span>
    <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;

    <span class="hljs-comment">// 目标值更大，去右子树递归删除，更新右子树链接</span>
    <span class="hljs-keyword">if</span> (key &gt; root.<span class="hljs-property">val</span>) {
        root.<span class="hljs-property">right</span> = <span class="hljs-title function_">deleteNode</span>(root.<span class="hljs-property">right</span>, key);
        <span class="hljs-keyword">return</span> root;
    }
    <span class="hljs-comment">// 目标值更小，去左子树递归删除，更新左子树链接</span>
    <span class="hljs-keyword">if</span> (key &lt; root.<span class="hljs-property">val</span>) {
        root.<span class="hljs-property">left</span> = <span class="hljs-title function_">deleteNode</span>(root.<span class="hljs-property">left</span>, key);
        <span class="hljs-keyword">return</span> root;
    }

    <span class="hljs-comment">// 找到目标节点，分情况处理</span>
    <span class="hljs-keyword">if</span> (key === root.<span class="hljs-property">val</span>) {
        <span class="hljs-comment">// 情况1：叶子节点，直接删除</span>
        <span class="hljs-keyword">if</span> (!root.<span class="hljs-property">left</span> &amp;&amp; !root.<span class="hljs-property">right</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        <span class="hljs-comment">// 情况2：只有右子树，用右子树替换</span>
        <span class="hljs-keyword">if</span> (!root.<span class="hljs-property">left</span>) <span class="hljs-keyword">return</span> root.<span class="hljs-property">right</span>;
        <span class="hljs-comment">// 情况3：只有左子树，用左子树替换</span>
        <span class="hljs-keyword">if</span> (!root.<span class="hljs-property">right</span>) <span class="hljs-keyword">return</span> root.<span class="hljs-property">left</span>;
        <span class="hljs-comment">// 情况4：有双孩子，左子树最大值（前驱）替换</span>
        <span class="hljs-keyword">let</span> maxLeft = root.<span class="hljs-property">left</span>;
        <span class="hljs-comment">// 找到左子树最右侧节点（最大值）</span>
        <span class="hljs-keyword">while</span> (maxLeft.<span class="hljs-property">right</span>) maxLeft = maxLeft.<span class="hljs-property">right</span>;
        <span class="hljs-comment">// 先删除左子树的最大值节点</span>
        root.<span class="hljs-property">left</span> = <span class="hljs-title function_">deleteNode</span>(root.<span class="hljs-property">left</span>, maxLeft.<span class="hljs-property">val</span>);
        <span class="hljs-comment">// 用前驱节点替换当前节点，调整指针</span>
        maxLeft.<span class="hljs-property">left</span> = root.<span class="hljs-property">left</span>;
        maxLeft.<span class="hljs-property">right</span> = root.<span class="hljs-property">right</span>;
        <span class="hljs-keyword">return</span> maxLeft;
    }

    <span class="hljs-keyword">return</span> root;
}
</code></pre>
<h5 data-id="heading-22">复杂度</h5>
<p>时间：O(logN)，空间：O(logN)（递归栈）。</p>
<h3 data-id="heading-23">三、BST经典题型：利用有序性解决问题</h3>
<p>BST的中序遍历有序性是解决这类问题的「黄金钥匙」，核心思路是**「通过中序遍历将BST转化为有序序列，再针对性处理」**，无需额外排序，时间复杂度最优。</p>
<h4 data-id="heading-24">3.1 寻找第K小的元素（力扣230题）</h4>
<h5 data-id="heading-25">题目要求</h5>
<p>给定BST，查找其中第K小的元素（从1开始计数）。</p>
<h5 data-id="heading-26">核心思路</h5>
<p>利用BST<strong>中序遍历升序</strong>的特性，中序遍历过程中维护全局计数，遍历到第K个节点时即为答案，找到后立即终止遍历（剪枝）。</p>
<h5 data-id="heading-27">实现代码</h5>
<pre><code class="hljs language-JavaScript" lang="JavaScript">
<span class="hljs-comment">/**
 * 查找BST中第K小的元素
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">TreeNode</span>} root BST根节点
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number</span>} k 第k小（1&lt;=k&lt;=节点总数）
 * <span class="hljs-doctag">@return</span> {<span class="hljs-type">number</span>} 第k小节点值
 */</span>
<span class="hljs-keyword">var</span> kthSmallest = <span class="hljs-keyword">function</span>(<span class="hljs-params">root, k</span>) {
    <span class="hljs-keyword">let</span> res = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 存储结果</span>
    <span class="hljs-keyword">let</span> rank = <span class="hljs-number">0</span>;   <span class="hljs-comment">// 全局计数，记录当前遍历节点的排名</span>

    <span class="hljs-comment">// 中序遍历：左→根→右</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">traverse</span>(<span class="hljs-params">node</span>) {
        <span class="hljs-comment">// 递归终止：空节点/已找到目标，直接返回</span>
        <span class="hljs-keyword">if</span> (node === <span class="hljs-literal">null</span> || res !== <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;
        <span class="hljs-comment">// 遍历左子树</span>
        <span class="hljs-title function_">traverse</span>(node.<span class="hljs-property">left</span>);
        <span class="hljs-comment">// 处理当前节点：计数+判断是否为第k小</span>
        rank++;
        <span class="hljs-keyword">if</span> (rank === k) {
            res = node.<span class="hljs-property">val</span>;
            <span class="hljs-keyword">return</span>;
        }
        <span class="hljs-comment">// 遍历右子树</span>
        <span class="hljs-title function_">traverse</span>(node.<span class="hljs-property">right</span>);
    }

    <span class="hljs-title function_">traverse</span>(root);
    <span class="hljs-keyword">return</span> res;
};
</code></pre>
<h5 data-id="heading-28">关键优化</h5>
<p>找到目标后立即终止遍历，避免无效的后续递归，提升实际执行效率。</p>
<h4 data-id="heading-29">3.2 BST转化为累加树（力扣538/1038题）</h4>
<h5 data-id="heading-30">题目要求</h5>
<p>将BST转化为累加树，使每个节点的新值等于原树中<strong>大于或等于</strong>该节点值的所有节点值之和。</p>
<h5 data-id="heading-31">核心思路</h5>
<ol>
<li>
<p>BST中序遍历（左→根→右）为升序 → <strong>逆序中序遍历（右→根→左）为降序</strong>；</p>
</li>
<li>
<p>逆序遍历过程中维护全局累加和<code>sum</code>，先遍历的节点值一定更大，累加后赋值给当前节点，自然得到「所有大于等于当前节点值的和」。</p>
</li>
</ol>
<h5 data-id="heading-32">实现代码</h5>
<pre><code class="hljs language-JavaScript" lang="JavaScript">
<span class="hljs-comment">/**
 * 将BST转化为累加树，直接修改原树，返回根节点
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">TreeNode</span>} root BST根节点
 * <span class="hljs-doctag">@return</span> {<span class="hljs-type">TreeNode</span>} 累加树根节点
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">convertBST</span>(<span class="hljs-params">root</span>) {
    <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>; <span class="hljs-comment">// 全局累加和，记录所有已遍历节点值的和</span>

    <span class="hljs-comment">// 逆序中序遍历：右→根→左</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">traverse</span>(<span class="hljs-params">node</span>) {
        <span class="hljs-keyword">if</span> (node === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;
        <span class="hljs-comment">// 先遍历右子树（更大的节点）</span>
        <span class="hljs-title function_">traverse</span>(node.<span class="hljs-property">right</span>);
        <span class="hljs-comment">// 处理当前节点：累加+更新值</span>
        sum += node.<span class="hljs-property">val</span>;
        node.<span class="hljs-property">val</span> = sum;
        <span class="hljs-comment">// 再遍历左子树（更小的节点）</span>
        <span class="hljs-title function_">traverse</span>(node.<span class="hljs-property">left</span>);
    }

    <span class="hljs-title function_">traverse</span>(root);
    <span class="hljs-keyword">return</span> root;
}
</code></pre>
<h5 data-id="heading-33">优势</h5>
<p>直接修改原树节点值，空间复杂度仅为O(logN)（递归栈），无需额外创建节点，为最优解。</p>
<h3 data-id="heading-34">四、BST进阶题型：构造与子树问题</h3>
<p>这类题目属于BST的高频难题，核心考察<strong>动态规划</strong>和<strong>后序遍历的信息收集能力</strong>，其中「二叉搜索子树的最大键值和」是综合考察的典型代表。</p>
<h4 data-id="heading-35">4.1 构造不同的BST（力扣96/95题）</h4>
<p>这类题目考察BST的组合特性，核心是**「以任意节点为根，拆分左右子树节点数，利用乘法原理计算组合数/生成组合」**。</p>
<h5 data-id="heading-36">4.1.1 计算BST种数（力扣96题，动态规划+卡特兰数）</h5>
<h6 data-id="heading-37">核心思路</h6>
<ol>
<li>
<p>关键性质：BST的种数仅与<strong>节点数量</strong>有关，与节点具体值无关；</p>
</li>
<li>
<p>动态规划定义：<code>dp[i]</code>表示<code>i</code>个节点能组成的不同BST种数；</p>
</li>
<li>
<p>状态转移：选<code>j</code>为根节点，左子树有<code>j-1</code>个节点，右子树有<code>i-j</code>个节点，总种数为<code>dp[j-1] * dp[i-j]</code>（乘法原理）。</p>
</li>
</ol>
<h6 data-id="heading-38">实现代码</h6>
<pre><code class="hljs language-JavaScript" lang="JavaScript">
<span class="hljs-comment">/**
 * 计算n个节点（1~n）能组成的不同BST种数
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number</span>} n 节点总数
 * <span class="hljs-doctag">@return</span> {<span class="hljs-type">number</span>} BST种数
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">numTrees</span>(<span class="hljs-params">n</span>) {
    <span class="hljs-keyword">const</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(n + <span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>);
    <span class="hljs-comment">// 边界条件：0个/1个节点，仅1种BST</span>
    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;
    dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;

    <span class="hljs-comment">// 计算2~n个节点的种数</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) {
        <span class="hljs-keyword">let</span> total = <span class="hljs-number">0</span>;
        <span class="hljs-comment">// 枚举根节点j，拆分左右子树</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt;= i; j++) {
            total += dp[j - <span class="hljs-number">1</span>] * dp[i - j];
        }
        dp[i] = total;
    }

    <span class="hljs-keyword">return</span> dp[n];
}
</code></pre>
<h6 data-id="heading-39">本质</h6>
<p>该问题的解为<strong>卡特兰数</strong>，适用于所有「合法组合数」问题（如括号生成、出栈顺序等）。</p>
<h5 data-id="heading-40">4.1.2 生成所有BST（力扣95题，递归+子问题复用）</h5>
<h6 data-id="heading-41">核心思路</h6>
<p>递归构造闭区间<code>[lo, hi]</code>的所有BST：枚举区间内每个数为根节点，递归生成左右子树的所有组合，再通过笛卡尔积组合左右子树与根节点。</p>
<h6 data-id="heading-42">实现代码</h6>
<pre><code class="hljs language-JavaScript" lang="JavaScript">
<span class="hljs-comment">/**
 * 生成n个节点（1~n）的所有不同BST，返回根节点数组
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number</span>} n 节点总数
 * <span class="hljs-doctag">@return</span> {<span class="hljs-type">TreeNode[]</span>} 所有BST根节点数组
 */</span>
<span class="hljs-keyword">var</span> generateTrees = <span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) {
    <span class="hljs-keyword">if</span> (n === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> [];
    <span class="hljs-comment">// 构造闭区间[1, n]的所有BST</span>
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">build</span>(<span class="hljs-number">1</span>, n);

    <span class="hljs-comment">// 递归构造闭区间[lo, hi]的所有BST</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">build</span>(<span class="hljs-params">lo, hi</span>) {
        <span class="hljs-keyword">const</span> res = [];
        <span class="hljs-comment">// 边界条件：lo&gt;hi，添加null（保证叶子节点能被正确创建）</span>
        <span class="hljs-keyword">if</span> (lo &gt; hi) {
            res.<span class="hljs-title function_">push</span>(<span class="hljs-literal">null</span>);
            <span class="hljs-keyword">return</span> res;
        }
        <span class="hljs-comment">// 枚举根节点</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = lo; i &lt;= hi; i++) {
            <span class="hljs-comment">// 递归生成左右子树的所有组合</span>
            <span class="hljs-keyword">const</span> leftTrees = <span class="hljs-title function_">build</span>(lo, i - <span class="hljs-number">1</span>);
            <span class="hljs-keyword">const</span> rightTrees = <span class="hljs-title function_">build</span>(i + <span class="hljs-number">1</span>, hi);
            <span class="hljs-comment">// 组合左右子树与根节点</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> left <span class="hljs-keyword">of</span> leftTrees) {
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> right <span class="hljs-keyword">of</span> rightTrees) {
                    <span class="hljs-keyword">const</span> root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(i);
                    root.<span class="hljs-property">left</span> = left;
                    root.<span class="hljs-property">right</span> = right;
                    res.<span class="hljs-title function_">push</span>(root);
                }
            }
        }
        <span class="hljs-keyword">return</span> res;
    }
};
</code></pre>
<h4 data-id="heading-43">4.2 二叉搜索子树的最大键值和（力扣1373题，BST综合实战）</h4>
<p>该题是BST后序遍历的经典代表，考察**「子树信息收集与传递」**能力，是大厂面试的高频难题。</p>
<h5 data-id="heading-44">题目要求</h5>
<p>给定一棵二叉树，找到其中<strong>所有合法BST子树</strong>的最大键值和（若所有BST子树和为负，返回0）。</p>
<h5 data-id="heading-45">核心思路</h5>
<ol>
<li>
<p>问题拆解：需要同时完成「判断子树是否为BST」和「计算BST子树和」，两个需求都需要<strong>子树的信息支撑</strong>；</p>
</li>
<li>
<p>后序遍历的优势：后序位置可获取子树的返回信息，能基于子树结果判断当前子树是否为BST、计算和值；</p>
</li>
<li>
<p>四元信息推导：从需求倒推递归需要返回的4个关键信息（缺一不可）：</p>
<ul>
<li>
<p><code>isBST</code>：当前子树是否为合法BST；</p>
</li>
<li>
<p><code>minVal</code>：当前子树的最小值（BST判断的关键）；</p>
</li>
<li>
<p><code>maxVal</code>：当前子树的最大值（BST判断的关键）；</p>
</li>
<li>
<p><code>sumVal</code>：当前子树的节点和（计算最大和的关键）。</p>
</li>
</ul>
</li>
<li>
<p>非BST隔离：非BST子树返回无效最值（<code>Infinity/-Infinity</code>），避免父节点误判。</p>
</li>
</ol>
<h5 data-id="heading-46">优化版实现代码（100%通过所有测试用例）</h5>
<pre><code class="hljs language-JavaScript" lang="JavaScript">
<span class="hljs-comment">/**
 * 找到二叉树中合法BST子树的最大键值和，负和返回0
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">TreeNode</span>} root 二叉树根节点
 * <span class="hljs-doctag">@return</span> {<span class="hljs-type">number</span>} 最大键值和/0
 */</span>
<span class="hljs-keyword">var</span> maxSumBST = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) {
    <span class="hljs-keyword">let</span> maxSum = -<span class="hljs-title class_">Infinity</span>; <span class="hljs-comment">// 初始负无穷，兼容负权值BST</span>

    <span class="hljs-comment">// 后序遍历，返回四元信息[isBST, minVal, maxVal, sumVal]</span>
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">postOrder</span> = (<span class="hljs-params">node</span>) =&gt; {
        <span class="hljs-keyword">if</span> (!node) <span class="hljs-keyword">return</span> [<span class="hljs-literal">true</span>, <span class="hljs-title class_">Infinity</span>, -<span class="hljs-title class_">Infinity</span>, <span class="hljs-number">0</span>]; <span class="hljs-comment">// 空节点固定返回</span>
        <span class="hljs-comment">// 递归获取左右子树信息</span>
        <span class="hljs-keyword">const</span> [lBST, lMin, lMax, lSum] = <span class="hljs-title function_">postOrder</span>(node.<span class="hljs-property">left</span>);
        <span class="hljs-keyword">const</span> [rBST, rMin, rMax, rSum] = <span class="hljs-title function_">postOrder</span>(node.<span class="hljs-property">right</span>);

        <span class="hljs-comment">// 仅合法BST时处理，否则返回无效信息</span>
        <span class="hljs-keyword">if</span> (lBST &amp;&amp; rBST &amp;&amp; node.<span class="hljs-property">val</span> &gt; lMax &amp;&amp; node.<span class="hljs-property">val</span> &lt; rMin) {
            <span class="hljs-keyword">const</span> curSum = lSum + node.<span class="hljs-property">val</span> + rSum;
            maxSum = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(maxSum, curSum);
            <span class="hljs-keyword">return</span> [<span class="hljs-literal">true</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(lMin, node.<span class="hljs-property">val</span>), <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(rMax, node.<span class="hljs-property">val</span>), curSum];
        }

        <span class="hljs-comment">// 非BST返回无效信息，彻底隔离</span>
        <span class="hljs-keyword">return</span> [<span class="hljs-literal">false</span>, <span class="hljs-title class_">Infinity</span>, -<span class="hljs-title class_">Infinity</span>, <span class="hljs-number">0</span>];
    };

    <span class="hljs-title function_">postOrder</span>(root);
    <span class="hljs-comment">// 有合法BST则取max(maxSum,0)，无则返回0</span>
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(maxSum, <span class="hljs-number">0</span>);
};
</code></pre>
<h5 data-id="heading-47">核心解题心法</h5>
<p><strong>「从需求倒推条件，从条件倒推数据，让子问题的返回值支撑父问题的所有操作」</strong>，这一思路适用于所有树的子树问题。</p>
<h3 data-id="heading-48">五、BST通用解题心法（精华总结）</h3>
<p>通过以上知识点和题型分析，提炼出3条BST通用解题心法，掌握后可应对99%的BST题目：</p>
<h4 data-id="heading-49">心法1：紧抓「左小右大」和「中序有序」两大核心特性</h4>
<ul>
<li>
<p>涉及<strong>查找、插入、删除、合法性验证</strong>等基础操作，优先用「左小右大」特性引导遍历，减少无效操作；</p>
</li>
<li>
<p>涉及<strong>有序性问题</strong>（第K小、累加、排序、区间查询等），优先利用「中序遍历有序」特性，将BST转化为有序序列处理。</p>
</li>
</ul>
<h4 data-id="heading-50">心法2：树的子树问题，优先考虑后序遍历+自定义返回信息</h4>
<ul>
<li>
<p>一旦题目要求「基于子树结果判断当前节点/子树」（如1373题、平衡树判断），必须用后序遍历；</p>
</li>
<li>
<p>自定义返回信息的推导逻辑：<strong>需求→判断条件→所需数据</strong>，确保子问题的返回值能支撑父问题的所有判断和计算，无冗余、无缺失。</p>
</li>
</ul>
<h4 data-id="heading-51">心法3：BST的构造/组合问题，利用「根节点拆分+乘法原理」</h4>
<ul>
<li>
<p>构造BST时，任意节点都可作为根节点，只需拆分左右子树的节点数/值范围；</p>
</li>
<li>
<p>组合数计算用动态规划（卡特兰数），组合生成用递归+笛卡尔积，复用子问题结果避免重复计算。</p>
</li>
</ul>
<h3 data-id="heading-52">总结</h3>
<p>二叉搜索树是算法学习的重点，其核心价值在于「<strong>高效的有序操作能力</strong>」。从基础的「左小右大」定义，到中序遍历的有序性，再到后序遍历的信息收集，所有知识点和题型都围绕这两个核心特性展开。</p>
<p>学习BST的关键不是死记硬背代码，而是<strong>理解特性背后的逻辑，掌握解题心法的推导过程</strong>：比如从需求倒推递归的返回信息，从特性引导遍历的方向。通过练习基础操作、经典有序问题、进阶构造和子树问题，逐步形成BST的解题思维，最终能灵活应对各类高频考点和面试难题。</p>
<p>掌握BST后，后续可深入学习<strong>平衡二叉树</strong>（红黑树、AVL树），理解如何解决BST链状化导致的效率降低问题，进一步完善树形数据结构的知识体系。</p>
</div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[从“回答者”进化为“研究员”：全面解析 Deep Research]]></title>    <link>https://juejin.cn/post/7602216700747956224</link>    <guid>https://juejin.cn/post/7602216700747956224</guid>    <pubDate>2026-02-03T10:20:58.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602216700747956224" data-draft-id="7602246300453322787" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="从“回答者”进化为“研究员”：全面解析 Deep Research"/> <meta itemprop="keywords" content="程序员"/> <meta itemprop="datePublished" content="2026-02-03T10:20:58.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="京东云开发者"/> <meta itemprop="url" content="https://juejin.cn/user/2634854380340008"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            从“回答者”进化为“研究员”：全面解析 Deep Research
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2634854380340008/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    京东云开发者
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T10:20:58.000Z" title="Tue Feb 03 2026 10:20:58 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读21分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">1、背景</h2>
<p>在 AI 问世的两年里，我们习惯了把它当作一个超级百科全书：如果你问它一个事实，它会给出答案；如果你给它一段文字，它会帮你总结。然而，当我们面对“分析某行业未来五年的趋势”或“撰写一份详尽的技术竞品调研报告”这样复杂的任务时，传统的 LLM 往往显得力不从心——它们缺乏深度，容易产生幻觉，且受限于上下文长度。</p>
<p>Deep Research正是为了解决这一痛点而生。它不再是一个简单的聊天机器人，而是具备自主推理能力的“AI 研究员”。</p>
<p>我将会在下面的内容中深入剖析 Deep Research 的运行机制、其背后的工程挑战以及它如何通过“ReAct 范式”重塑信息获取的方式。</p>
<h2 data-id="heading-1">2、什么是 Deep Research</h2>
<p>Deep Research 是 专为网页浏览、数据分析和复杂任务处理而优化的全新功能。与普通 LLM “问什么答什么”的被动模式不同，Deep Research 具备<strong>主动规划</strong>和<strong>深度推理</strong>的能力。</p>
<p><strong>它的核心特征可以概括为：</strong></p>
<p>1.自主性（Autonomy）： 它可以一边思考，一边“查资料”。它不仅是检索信息，还能自主判断信息是否足够，如果不足，它会主动调整搜索关键词再次检索。</p>
<p>2.长链条推理（Long-chain Reasoning）： 基于 LLM的推理能力，它能将一个模糊的庞大需求拆解为多个子步骤，分阶段执行。</p>
<p>3.专业报告生成： 最终输出的不是零散的对话，而是包含逻辑摘要、清晰引用来源和完整文档的专业级研究报告。</p>
<p><strong>为什么我们需要它？</strong> 当前的信息需求往往需要跨越多个来源、阅读大量非结构化数据。Deep Research 实际上降低了“海量信息收集”<strong>与</strong>“高质量推理整合”之间的壁垒，尤其擅长挖掘那些需要浏览数十个网页才能拼凑出的小众或非直观信息。</p>
<h2 data-id="heading-2">3、核心原理：从 DeepSearch 到 DeepResearch</h2>
<p>要理解 Deep Research，通过两个层级来看：底层的搜索循环（DeepSearch）和上层的报告框架（DeepResearch）。</p>
<h3 data-id="heading-3">3.1 核心引擎：DeepSearch（循环与迭代）</h3>
<p>DeepSearch 的本质是一个“搜索 - 阅读 - 推理”的无限循环。这与我们熟悉的 <strong>ReAct Agent</strong> 范式高度相似，但通过强化学习（RL）不仅学会了推理，更学会了“搜索策略”：</p>
<p>•搜索（Search）： 探索互联网，获取原始信息。</p>
<p>•阅读（Read）： 对特定网页进行详尽分析，提取关键片段。</p>
<p>•推理（Think）： 这是最关键的一步。模型会评估当前收集到的信息是否足以回答问题。如果不够，它会决定是将问题拆解为更小的子问题，还是尝试全新的搜索关键词。</p>
<p>这种  →  →  →  →  的模式，让 AI 具备了“自我纠错”和“追根究底”的能力。</p>
<p>﻿</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7e6b379a54fc4d3f9432aaaf2fc12943~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqs5Lic5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770718858&amp;x-signature=ph%2BGqOLgE3Oj%2BLSW1%2Bvjo%2BNq1Vk%3D" alt="" loading="lazy"/></p>
<p>﻿﻿</p>
<h3 data-id="heading-4">3.2 上层框架：DeepResearch（结构化输出）</h3>
<p>DeepSearch 负责找答案，而 DeepResearch 负责写报告。它在 DeepSearch 的基础上增加了一个<strong>结构化框架</strong>：</p>
<p>1.用户意图理解 &amp; 目录生成（TOC）： 接收指令后，首先生成报告目录（如引言、方法论、相关工作、结论）。</p>
<p>2.分章节执行： 系统性地将 DeepSearch 引擎应用到报告的每一个章节中。每个章节都是一个独立的研究任务。</p>
<p>3.全局整合： 最后将所有章节内容整合，进行连贯性润色，生成最终报告。</p>
<p>整个执行过程通常耗时 5 到 30 分钟，这在以前的即时问答中是不可想象的，但对于深度研究来说，却是极高的效率。</p>
<p>﻿</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6ea07a0788d040fc9bf941dcaa476acb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqs5Lic5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770718858&amp;x-signature=Hy4jUl8GoCzFUsA6qwpXQF7N%2F14%3D" alt="" loading="lazy"/></p>
<p>﻿﻿</p>
<p>让 LLM 在自身推理过程中与搜索引擎交替交互。用户输入query，LLM产生TOC，然后进入循环：查找、读取和推理，直到达到结束的条件，然后再通过LLM做总结，最终给用户输出完整的研究报告（ →  →  →  →  ）的模式，已经非常接近我们熟悉的 ReAct Agent 范式。不同的是，这里的 Agent 不依赖提示词，而是通过 RL 真正“学会了”搜索策略。实质上就是一个 “带搜索能力的 ReAct Agent”，只不过不再依赖提示词工程，而是直接通过强化学习学会何时搜索、何时推理。注意，它是主动认知到何时需要检索信息，这是一个非常显著的特点和不同。</p>
<h2 data-id="heading-5">4、 工程化挑战与解决方案</h2>
<p>﻿</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7fc47547a948485ca5dfb41326ce9987~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqs5Lic5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770718858&amp;x-signature=xEyHaOumuSZuUPpoLpFHBxsjSuY%3D" alt="" loading="lazy"/></p>
<p>﻿﻿</p>
<p>Deep Research 之所以能超越普通的 RAG（检索增强生成），在于它解决了一系列棘手的工程问题。通过对技术细节的复盘，我们可以了解到其背后的技术实现。</p>
<h3 data-id="heading-6">4.1 解决“垃圾进，垃圾出”：URL 排序与清洗</h3>
<h4 data-id="heading-7">4.1.1 问题</h4>
<p>Deep Research 在一次任务中可能扫描数百个 URL。如果把这些内容一股脑塞给 LLM，不仅浪费 Token，还会导致模型“瞎选”答案。在每一次 DeepReSearch 漫长过程中，你可能会从搜索引擎结果页（SERP）里收集一堆 URL，每打开一个网页，又能顺藤摸瓜找出不少新链接，就算是去重后，也是轻轻松松几百个网址。同样的，一股脑儿全塞给 LLM 肯定不行，浪费宝贵的上下文长度不说，更要命的是，我们发现 LLM 基本上就是瞎选。所以，得想办法引导 LLM 去挑出那些最有可能包含答案的 URL。</p>
<h4 data-id="heading-8">4.1.2 解决方案：两阶段重排序（Re-ranking）</h4>
<p>URL 排序打分评测是 Deep Research 系统中的关键技术环节，它直接影响到信息获取的效率和质量。系统采用了多层次、多维度的排序策略，确保能够从海量的搜索结果中快速定位最有价值的信息源。​</p>
<p>综合评分机制是 URL 排序的核心。系统会综合考虑多个因素：最后更新时间、域名出现的频率、网页路径结构，以及最重要的与问题的语义相关性，算出一个综合评分​。这种多维度的评分机制能够全面评估 URL 的价值，避免了单一维度排序的局限性。​</p>
<p>具体的评分因素包括：​</p>
<p>1.<strong>频率信号：</strong> 如果某个 URL 在不同的信息源中多次出现，它的权重就会更高。另外，如果某个域名在搜索结果中经常出现，来自这个域名的 URL 也会被加分。因为一般来说，热门域名往往包含更权威的内容。​</p>
<p>2.<strong>路径结构：</strong> 会分析 URL 的路径结构，来判断哪些内容是聚集在一起的。如果多个网址都属于同一个路径层级，它们的分数会更高；但路径越深，分数加成会逐渐减少。​</p>
<p>3.<strong>语义相关性：</strong> 使用 小模型（例如：jina-reranker-v2-base-multilingual）或者大模型 来评估问题和每个 URL 的文本信息（例如标题和摘要）的语义相关性，这是一个典型的重排序问题​。每个 URL 的文本信息来自搜索引擎结果页（SERP）API 返回的标题和摘要，以及页面上 URL 的锚文本。​</p>
<p>4.<strong>最后更新时间：</strong> 有些查询对时效性要求很高，所以一般来说，越新的 URL 价值越高。系统采用一套组合拳，综合考虑 SERP API 提供的筛选功能、HTTP Header 信息分析、元数据提取、内容模式识别等，最终给出一个带有置信度评分的时间戳。​</p>
<p>5.<strong>受限内容识别：</strong> 某些社交媒体平台的内容是受限的，或者需要付费才能访问。系统会积极维护一份黑名单，把这些有问题的 URL 和域名都记录下来，降低它们的排名，避免在这些无法访问的内容上浪费计算资源。​</p>
<p>6.<strong>域名多样性：</strong> 为了提高结果的多样性，避免陷入 "局部最优"，系统采用 "探索 - 利用" 的策略：从每个域名下选择排名 Top K 的 URL。</p>
<p><strong>粗排和精排：</strong></p>
<p>•粗排： 快速筛选，追求召回率。</p>
<p>•精排： 针对粗排结果进行深度评估。这里通常采用基于重排模型（Cross-Encoder）或基于 LLM 的重排序。利用 LLM 的语义理解能力，甚至使用滑动窗口算法（从后向前滑动），对候选段落进行相关性打分，确保只有含金量最高的信息进入下一步。</p>
<p>粗排检索效率较快，但是召回的内容并不一定强相关。而精排效率较低，因此适合在粗排的基础上进行进一步优化。重排的任务就是评估这些上下文的相关性，优先考虑那些最有可能提供准确和相关信息的内容。</p>
<p>重排方法主要分为以下两类：</p>
<p><strong>基于重排模型：</strong> 这些模型可以输出文档与查询之间的相关性；够针对一个查询和文档对，输出它们的相似度分数。我们利用这个分数对文档按照与查询的相关性进行重新排序。解决传统检索方法（如BM25、向量检索）的局限性，例如语义模糊性、长尾关键词漏检、多模态意图理解不足等问题。优化检索结果的Top-K排序，提升后续LLM生成答案的准确性和效率</p>
<p><strong>基于 LLM：</strong> 由于大模型可以更全面地捕捉语义信息，也可被用于重排序。使用 Prompt 的方式引导 LLM 进行重排序。直接利用 LLM 的语义理解能力对所有候选段落进行相关性程度排名。如果文档的数量通常非常大，而 LLM 可能无法一次性处理所有的文本数据。使用滑动窗口算法原理，滑顺序是从后向前的，将前一个窗口中的前两个段落参与下一个窗口的重排序。</p>
<h3 data-id="heading-9">4.2 解决“大海捞针”与“上下文丢失”：长网页内容提取</h3>
<h4 data-id="heading-10">4.2.1 问题</h4>
<p>读取网页内容后，我们需要把它作为一条知识，放到 Agent 的上下文里，供它推理。虽然把全部内容一股脑塞进 LLM 的上下文是最省事的办法，但考虑到 Token 成本和生成速度，这肯定不是最好的选择。在实际应用里，我们需要找出内容中与问题最相关的部分，只把这些部分作为知识添加到 Agent 的上下文里。</p>
<p>我们一边是问题（原始查询或“信息差”问题），另一边是大量的 Markdown 内容，其中大部分内容都是无关紧要的。我们需要选出与问题最相关的片段。</p>
<p><strong>有限数量文档中的有限数量的文本块：</strong> 假设每个块大约有 500 个 Token，那么一个典型的长网页文档大约有 20 万 Token（中位数）到 100 万 Token。我们每一步抓取 4-5 个 URL，这样大概会产生几百个文本块。也就是说，几百个向量和几百个余弦相似度。在内存里就能轻松处理，根本不需要向量数据库。</p>
<p><strong>我们需要连续的文本块来形成有效的知识摘要：</strong> 我们不能接受由分散的句子组成的摘要。更有用的知识摘要，更能保持文本的连贯性。这样 LLM 更容易从知识源中复制和引用，也能减少“幻觉”。</p>
<p>网页内容动辄数万 Token，且充满噪音。如何提取有效信息且保持上下文连贯？</p>
<h4 data-id="heading-11">4.2.2 解决方案：迟分算法（Late Chunking）</h4>
<p>传统的 RAG 会直接把文档切块（Chunking）然后向量化，但这会导致切块丢失全局上下文（例如一个代词“它”在切块后不知道指代谁）。</p>
<p>•<strong>Late Chunking（迟分）：</strong> 这是一个极其精妙的优化。它不急着切块，而是先用支持超长上下文的模型（如 jina-embeddings-v3）对整个文档进行编码，保留全局语义。</p>
<p>长文档切块，有俩个问题，第一个问题是：文本块分割得准不准，这不仅关系到搜索结果好不好读，还关系到做 RAG 的时候，给 LLM 喂进去的文本块是不是正好，不多不少；第二个问题是：每个分块里的上下文信息容易丢失。文档切完之后，下一步就是把每个分块拿去批量向量化。但这么做容易把原文档里的全局上下文信息给丢了。</p>
<p>迟分（Late Chunking）主要就是解决第二个问题 —— 上下文丢失。它不是用来找最佳断点或者语义边界的。该用正则表达式，启发式方法，或者其他技术来分块，还是得用。</p>
<p>但迟分不一样的地方是，它不是一切完就立马把每个块拿去向量化，而是先把整个文档在一个上下文窗口里编码了（jina-embeddings-v3最新 SOTA 向量模型，支持 8192 Token 的长输入），然后再根据边界线索去进行均值池化操作。</p>
<p>它的工作原理类似于一维卷积（Conv1D）。这个过程首先把一个长文档分割成固定长度的块，然后用开启了迟分的 jina-embeddings-v3 向量化这些文本块。计算完每个块和问题之间的相似度分数后，一个滑动窗口会在这些相似度分数上移动，以找到平均值最高的窗口。</p>
<p>用迟分和类似“一维卷积”的平均池化，挑出跟问题最相关的段落。</p>
<p>•<strong>均值池化：</strong> 在生成向量后，再根据边界线索进行切分和均值池化。 这就像是先读完一整本书理解了全意，再回过头去摘录段落，而不是每读一段就摘录一段。这样提取出的“知识块”既精准又保留了上下文，极大减少了 LLM 的幻觉。</p>
<h3 data-id="heading-12">4.3 解决“写不长”：突破 Token 输出限制</h3>
<h4 data-id="heading-13">4.3.1 问题</h4>
<p><strong>上下文窗口的根本性限制：</strong> 大部分模型，例如：DeepSeek-V3，单次输出通常限制在 8K Token（约 8000 字）以内，难以一次性生成数万字的详尽报告。（可能有人会提出好多模型输出几万字或者几十万字，例如GPT-5和Claude Opus等，但是又会出现下面"上下文腐烂" 现象的问题）。</p>
<p><strong>"上下文腐烂" 现象：</strong> 当智能体开始频繁调用多次工具，每次调用返回的 "观察结果" 都会追加到对话历史中，导致上下文长度爆炸式增长。这不仅带来高昂的计算成本，更会导致 "上下文腐烂" (Context Rot)—— 随着上下文变长，模型性能反而下降。​</p>
<p>具体表现为：​</p>
<p>1.性能下降：随着上下文长度增加，模型性能会明显下降。Anthropic 把这个现象称为 "上下文腐烂"（context rot）。具体表现是模型开始重复输出、推理速度变慢、回答质量下降​。​</p>
<p>2.注意力分散：Agent 的上下文随时间推移必然熵增，导致注意力机制分散。​</p>
<p>3.信息利用效率降低：研究发现，当相关信息位于长输入上下文的开头或结尾时，模型的性能表现最佳，而当信息被放置在中间位置时，性能会显著下降。此外，在长上下文任务中，模型有时会倾向于直接依赖其预训练的参数知识来回答问题，而不是有效利用所提供的外部长文本，这进一步加剧了性能的下降​。</p>
<h4 data-id="heading-14">4.3.2 解决方案：双层级 Agent 架构（Planner + Workers）</h4>
<p>Deep Research 实际上采用了一种“规划-执行”的分离架构：</p>
<p>•规划 Agent (Planner)： 它是“包工头”。负责理解任务，生成详细的 JSON 格式大纲，并分配每个章节的字数预算。</p>
<p>•执行 Agent 集群 (Workers)： 它是“建筑工”。多个 Agent 并行工作，每个 Agent 认领一个章节的标题，独立去搜索、阅读和写作。</p>
<p>•聚合器： 最后由一个模块像拼积木一样将各章节拼接，并进行逻辑顺滑和长度控制。</p>
<p>﻿</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a5f949f5fa5b49d39c36d8af8eb0e9d9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqs5Lic5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770718858&amp;x-signature=m3NX1YnrKG%2BnlYhrOL4F0rEDe0w%3D" alt="" loading="lazy"/></p>
<p>﻿﻿</p>
<p><strong>双层架构的核心设计包括：​</strong></p>
<p>1.监督者层级：作为系统的 "大脑"，负责将模糊需求转化为可执行计划。在 prompts.py 中定义的结构化提示模板指导规划器完成三项核心任务：需求澄清（通过 clarify_with_user 节点实现）、子主题分解（最大支持 5 个并行子任务）、以及资源分配（根据主题复杂度选择模型与工具）。​</p>
<p>2.执行者层级：负责具体的信息检索、内容提取和初步分析工作。执行者层级包含多个专门的 Agent，如搜索 Agent、阅读 Agent、分析 Agent 等，每个 Agent 负责特定的任务。​</p>
<p>3.状态机控制：基于 LangGraph 构建的状态机实现了复杂流程的精确控制。状态机能够跟踪研究过程的每个步骤，确保任务执行的有序性和完整性。​</p>
<p><strong>上下文管理的创新方案：​</strong></p>
<p>为了缓解上下文腐烂问题，系统采用了多种上下文管理策略：​</p>
<p>1.上下文卸载技术：系统采用 "上下文卸载"来缓解上下文污染，这能帮 agent 保持在正确轨道上。上下文卸载就是把信息存在语言模型的 "活跃上下文窗口" 之外。把关键信息卸载出去，只在需要时检索，我们就避免了模型工作内存的 "过载"​。​</p>
<p>2.分级存储架构：在于引入分级存储架构。通过将信息按照重要性和使用频率进行分级存储，系统能够在有限的上下文中保留最重要的信息，同时在需要时快速检索其他信息。​</p>
<p>3.智能剪枝策略：系统采用上下文剪枝技术。这个技巧是在 RAG 的基础上做的优化。它的核心是在将检索到的信息交给主模型之前，先进行一次 "剪枝"。具体做法是：先检索出相关文档，然后使用一个更小、更快的模型，让它读一遍这些文档，这个小模型的任务是，根据用户的原始问题，只从文档中提取最核心、最相关的信息​。</p>
<p><strong>长文档处理的技术突破：​</strong>​</p>
<p>1.分段处理策略：系统将长文档分成多个段落或章节，每个部分独立处理，然后通过监督者层级进行整合。这种方法避免了一次性处理整个长文档带来的上下文限制问题。​</p>
<p>2.增量生成机制：系统采用增量生成的方式处理长篇报告。监督者层级负责制定整体结构和各部分的生成顺序，执行者层级按照顺序逐步生成各部分内容。这种方式不仅避免了输出长度限制，还提高了生成内容的连贯性。​</p>
<p>3.智能整合算法：在各部分内容生成后，监督者层级会对内容进行智能整合。这包括检查逻辑一致性、消除重复内容、优化章节顺序等，确保最终报告的质量。</p>
<h3 data-id="heading-15">4.4 生成内容打分</h3>
<p>Deep Research 在生成内容的质量控制方面采用了多层次、多维度的评分和优化机制，确保最终输出的内容既准确又有价值。​</p>
<p>自适应评估框架是内容评分的基础。包括两个互补的评估框架来评估 DRA 能力：RACE（基于参考的自适应标准驱动评估框架，具有动态加权）用于评估生成研究报告的质量，FACT（事实丰富性和引用可信度框架）用于评估信息检索有效性和引用准确性​。​</p>
<p><strong>RACE 框架的核心特点包括：​</strong></p>
<p>1.动态权重分配：对于每个任务，评判 LLM 通过多次试验获得每个维度的权重，并取平均值作为最终权重，确保评估与任务意图一致​。所有维度的生成标准被聚合到一个综合列表中，评判 LLM 然后根据每个标准分析目标报告和参考报告，为两份报告生成每个标准的分数列表，用于最终得分计算。​</p>
<p>2.多维度评估：框架首先基于领域知识确立四个顶层评测维度：全面性（COMP）、洞察力 / 深度（DEPTH）、指令遵循（INST）和可读性（READ）。对于每个具体任务，评判 LLM 会动态计算各维度的权重，并为每个维度生成一组定制化的评测标准。​</p>
<p>3.自适应逐点质量评估：评估模块包含自适应逐点质量评估和主动事实核查两大核心组件，既解决了 "判分死板" 的问题，又实现了 "全面查错" 的目标。自适应逐点质量评估打破了固定维度的限制，为每个任务量身定制评分标准。该组件首先保留 4 个通用评估维度，同时针对每个具体任务自动生成 1-3 个专属评估维度。​</p>
<p>主动事实核查机制确保了内容的准确性。系统不会只傻傻地检查报告里标出来的引用来源，而是会像一个侦探一样主动去网上搜索交叉验证报告里的每一个说法，不管你有没有给出处，这就保证了评分的绝对严格​。​</p>
<p><strong>这种机制的实现包括：</strong> ​</p>
<p>1.自动识别关键陈述：系统会自动识别报告中的关键陈述和数据，包括事实性描述、数值数据、因果关系等。​</p>
<p>2.多源交叉验证：对于每个关键陈述，系统会从多个独立来源进行验证，确保其准确性。​</p>
<p>3.置信度评估：系统会为每个验证结果给出置信度评分，高置信度的内容会被保留，低置信度的内容会被标记为需要进一步核实。​</p>
<p><strong>内容修改与优化策略：</strong> 基于评分结果，系统会采用多种策略对内容进行修改和优化：​</p>
<p>1.基于评分的自动修正：当系统发现内容存在事实错误或逻辑问题时，会自动进行修正。这种修正不是简单的替换，而是基于多个可靠来源的信息进行综合判断。​</p>
<p>2.人工干预机制：对于复杂的问题或存在争议的内容，系统会提示用户进行人工干预，确保最终内容的准确性和客观性。​</p>
<p>3.风格一致性优化：系统会检查整篇报告的语言风格、术语使用、格式规范等，确保全文的一致性和专业性。​</p>
<p>4.结构优化：根据内容的逻辑关系，系统会对报告的结构进行优化，确保章节安排合理、层次分明。</p>
<h2 data-id="heading-16">5、 Deep Research vs Manus</h2>
<p>Manus 更像是一个高度工程化的 Agent 平台，它整合了大量工具（浏览器、代码解释器等），强在“调度”。而 Deep Research 是模型层面和架构层面的进化，它通过强化学习或者架构优化让模型了解“如何搜索”和“如何推理”的策略，是一种更原生和自主的智能。所以Deep Research可以进行撰写文献综述、市场与竞品分析、行业研报、投融资研报、市场调研、新闻热点追踪、生活决策等，也可以在检索时沉淀有用信息。</p>
<h2 data-id="heading-17">6、总结</h2>
<p>Deep Research是我在25年年中接触的，当时感觉就很惊艳，感觉正在跨越到一个新的门槛：从信息的搬运工，变成了信息的加工者。它不再需要用户费尽心思想 Prompt，也不需要用户去点击一个个的链接。它展示了 AI 作为一个“思考者”的潜力——它知道自己不知道什么，并且知道去哪里找到答案。对于使用者而言，这意味着我们可以将最耗时的“信息收集与整理”阶段外包给 AI，从而专注于更高维度的决策与创新。</p>
<p>后面会继续写我怎么在真实业务中利用DeepResearch的能力，最后祝大家早安、午安、晚安。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Android ViewModel 的简单用法]]></title>    <link>https://juejin.cn/post/7602205524719009826</link>    <guid>https://juejin.cn/post/7602205524719009826</guid>    <pubDate>2026-02-03T10:31:09.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602205524719009826" data-draft-id="7602246300452995107" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Android ViewModel 的简单用法"/> <meta itemprop="keywords" content="Android,Android Jetpack"/> <meta itemprop="datePublished" content="2026-02-03T10:31:09.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Yen"/> <meta itemprop="url" content="https://juejin.cn/user/4037062426633214"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Android ViewModel 的简单用法
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4037062426633214/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Yen
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T10:31:09.000Z" title="Tue Feb 03 2026 10:31:09 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    1
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">一、ViewModel 概述</h2>
<h3 data-id="heading-1">1.1 什么是 ViewModel</h3>
<p>ViewModel 是 Android Jetpack 架构组件之一，用于<strong>以生命周期感知的方式存储和管理 UI 相关数据</strong>。</p>
<h3 data-id="heading-2">1.2 主要特性</h3>
<ul>
<li><strong>生命周期感知</strong>：自动管理数据生命周期</li>
<li><strong>配置变更存活</strong>：屏幕旋转等配置变更时数据不会丢失</li>
<li><strong>UI 数据存储</strong>：专门为 UI 准备和管理数据</li>
<li><strong>分离关注点</strong>：帮助实现 MVVM 架构模式</li>
</ul>
<h2 data-id="heading-3">二、ViewModel 的核心作用</h2>
<h3 data-id="heading-4">2.1 解决的主要问题</h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 传统方式的问题：数据在配置变更时丢失</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span>() {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> counter = <span class="hljs-number">0</span>  <span class="hljs-comment">// 旋转屏幕时会重置！</span>
    
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> {
        <span class="hljs-comment">// ...</span>
    }
}
</code></pre>
<h3 data-id="heading-5">2.2 ViewModel 的优势</h3>






























<table><thead><tr><th>特性</th><th>传统方式</th><th>ViewModel</th></tr></thead><tbody><tr><td>配置变更</td><td>数据丢失</td><td><strong>数据保留</strong></td></tr><tr><td>生命周期</td><td>手动管理</td><td><strong>自动管理</strong></td></tr><tr><td>内存泄漏</td><td>易发生</td><td><strong>不易发生</strong></td></tr><tr><td>测试难度</td><td>困难</td><td><strong>容易测试</strong></td></tr></tbody></table>
<h2 data-id="heading-6">三、基本用法</h2>
<h3 data-id="heading-7">3.1 添加依赖</h3>
<pre><code class="hljs language-gradle" lang="gradle">// build.gradle (app)
dependencies {
    implementation "androidx.lifecycle:lifecycle-viewmodel-ktx:2.6.0"
    // 或使用最新版本
}
</code></pre>
<h3 data-id="heading-8">3.2 创建 ViewModel</h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 1. 简单 ViewModel</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyViewModel</span> : <span class="hljs-type">ViewModel</span>() {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> _counter = MutableLiveData(<span class="hljs-number">0</span>)
    <span class="hljs-keyword">val</span> counter: LiveData&lt;<span class="hljs-built_in">Int</span>&gt; = _counter
    
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span></span> {
        _counter.value = (_counter.value ?: <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>
    }
    
    <span class="hljs-comment">// ViewModel 销毁时的清理工作</span>
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCleared</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">super</span>.onCleared()
        <span class="hljs-comment">// 释放资源</span>
    }
}

<span class="hljs-comment">// 2. 带参数的 ViewModel（需要使用 Factory）</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">UserViewModel</span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> userId: String) : ViewModel() {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> _user = MutableLiveData&lt;User&gt;()
    <span class="hljs-keyword">val</span> user: LiveData&lt;User&gt; = _user
    
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">loadUser</span><span class="hljs-params">()</span></span> {
        <span class="hljs-comment">// 加载用户数据</span>
    }
}
</code></pre>
<h3 data-id="heading-9">3.3 在 Activity/Fragment 中使用</h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// Activity 中使用</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span>() {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> viewModel: MyViewModel
    
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> {
        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)
        
        <span class="hljs-comment">// 获取 ViewModel 实例</span>
        viewModel = ViewModelProvider(<span class="hljs-keyword">this</span>).<span class="hljs-keyword">get</span>(MyViewModel::<span class="hljs-keyword">class</span>.java)
        
        <span class="hljs-comment">// 观察 LiveData</span>
        viewModel.counter.observe(<span class="hljs-keyword">this</span>) { count -&gt;
            updateCounterUI(count)
        }
        
        <span class="hljs-comment">// 触发数据变化</span>
        button.setOnClickListener {
            viewModel.increment()
        }
    }
}

<span class="hljs-comment">// Fragment 中使用</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFragment</span> : <span class="hljs-type">Fragment</span>() {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> viewModel: MyViewModel <span class="hljs-keyword">by</span> viewModels()  <span class="hljs-comment">// Kotlin 扩展方式</span>
    
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onViewCreated</span><span class="hljs-params">(view: <span class="hljs-type">View</span>, savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> {
        <span class="hljs-keyword">super</span>.onViewCreated(view, savedInstanceState)
        
        viewModel.counter.observe(viewLifecycleOwner) { count -&gt;
            <span class="hljs-comment">// 更新 UI</span>
        }
    }
}
</code></pre>
<h2 data-id="heading-10">四、ViewModel 生命周期</h2>
<h3 data-id="heading-11">4.1 生命周期示意图</h3>
<pre><code class="hljs language-text" lang="text">Activity/Fragment Created
        ↓
ViewModel Created (首次创建)
        ↓
Activity/Fragment Started
        ↓
Activity/Fragment Resumed
        ↓
← 屏幕旋转等配置变更 →
（Activity/Fragment 销毁重建，但 ViewModel 保留）
        ↓
Activity/Fragment Destroyed（非配置变更）
        ↓
ViewModel onCleared() 调用
</code></pre>
<h3 data-id="heading-12">4.2 生命周期感知示例</h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyViewModel</span> : <span class="hljs-type">ViewModel</span>() {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> _state = MutableLiveData(ViewModelState.IDLE)
    
    <span class="hljs-keyword">init</span> {
        <span class="hljs-comment">// ViewModel 创建时调用</span>
        loadInitialData()
    }
    
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCleared</span><span class="hljs-params">()</span></span> {
        <span class="hljs-comment">// ViewModel 销毁时调用（当 Activity/Fragment 永久销毁时）</span>
        cleanupResources()
        <span class="hljs-keyword">super</span>.onCleared()
    }
}
</code></pre>
<h2 data-id="heading-13">五、ViewModelFactory</h2>
<h3 data-id="heading-14">5.1 为什么需要 Factory</h3>
<p>当 ViewModel 需要参数时，必须使用 ViewModelProvider.Factory</p>
<h3 data-id="heading-15">5.2 自定义 Factory</h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 1. 创建 Factory</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">UserViewModelFactory</span>(
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> userId: String,
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> repository: UserRepository
) : ViewModelProvider.Factory {
    
    <span class="hljs-meta">@Suppress(<span class="hljs-string">"UNCHECKED_CAST"</span>)</span>
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T : ViewModel&gt;</span> <span class="hljs-title">create</span><span class="hljs-params">(modelClass: <span class="hljs-type">Class</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span>: T {
        <span class="hljs-keyword">if</span> (modelClass.isAssignableFrom(UserViewModel::<span class="hljs-keyword">class</span>.java)) {
            <span class="hljs-keyword">return</span> UserViewModel(userId, repository) <span class="hljs-keyword">as</span> T
        }
        <span class="hljs-keyword">throw</span> IllegalArgumentException(<span class="hljs-string">"Unknown ViewModel class"</span>)
    }
}

<span class="hljs-comment">// 2. 使用 Factory</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">UserActivity</span> : <span class="hljs-type">AppCompatActivity</span>() {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> viewModel: UserViewModel
    
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> {
        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)
        
        <span class="hljs-keyword">val</span> userId = intent.getStringExtra(<span class="hljs-string">"USER_ID"</span>) ?: <span class="hljs-string">""</span>
        <span class="hljs-keyword">val</span> repository = UserRepository()
        <span class="hljs-keyword">val</span> factory = UserViewModelFactory(userId, repository)
        
        viewModel = ViewModelProvider(<span class="hljs-keyword">this</span>, factory).<span class="hljs-keyword">get</span>(UserViewModel::<span class="hljs-keyword">class</span>.java)
    }
}
</code></pre>
<h2 data-id="heading-16">六、ViewModel 的作用域</h2>
<h3 data-id="heading-17">6.1 不同的作用域</h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 1. Activity 作用域 - 同一个 Activity 的多个 Fragment 共享</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">SharedActivity</span> : <span class="hljs-type">AppCompatActivity</span>() {
    <span class="hljs-keyword">val</span> sharedViewModel: SharedViewModel <span class="hljs-keyword">by</span> viewModels()
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">FragmentA</span> : <span class="hljs-type">Fragment</span>() {
    <span class="hljs-comment">// 获取 Activity 级别的 ViewModel</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> activityViewModel: SharedViewModel <span class="hljs-keyword">by</span> activityViewModels()
}

<span class="hljs-comment">// 2. Fragment 作用域 - 仅限于单个 Fragment</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFragment</span> : <span class="hljs-type">Fragment</span>() {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> fragmentViewModel: MyViewModel <span class="hljs-keyword">by</span> viewModels()
}

<span class="hljs-comment">// 3. Navigation Graph 作用域</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">NavFragment</span> : <span class="hljs-type">Fragment</span>() {
    <span class="hljs-comment">// 需要在 nav_graph.xml 中声明</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> navViewModel: NavViewModel <span class="hljs-keyword">by</span> navGraphViewModels(R.id.nav_graph)
}
</code></pre>
<h3 data-id="heading-18">6.2 Navigation 组件中的 ViewModel</h3>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-comment">&lt;!-- navigation/nav_graph.xml --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">navigation</span> 
    <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span>
    <span class="hljs-attr">xmlns:app</span>=<span class="hljs-string">"http://schemas.android.com/apk/res-auto"</span>
    <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/nav_graph"</span>
    <span class="hljs-attr">app:viewModelScope</span>=<span class="hljs-string">"true"</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- ... --&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">navigation</span>&gt;</span>
</code></pre>
<h2 data-id="heading-19">七、ViewModel 与 LiveData/StateFlow 结合</h2>
<h3 data-id="heading-20">7.1 配合 LiveData</h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserViewModel</span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> repository: UserRepository) : ViewModel() {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> _users = MutableLiveData&lt;List&lt;User&gt;&gt;()
    <span class="hljs-keyword">val</span> users: LiveData&lt;List&lt;User&gt;&gt; = _users
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> _loading = MutableLiveData(<span class="hljs-literal">false</span>)
    <span class="hljs-keyword">val</span> loading: LiveData&lt;<span class="hljs-built_in">Boolean</span>&gt; = _loading
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> _error = MutableLiveData&lt;String?&gt;()
    <span class="hljs-keyword">val</span> error: LiveData&lt;String?&gt; = _error
    
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">loadUsers</span><span class="hljs-params">()</span></span> {
        _loading.value = <span class="hljs-literal">true</span>
        viewModelScope.launch {
            <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">val</span> result = repository.getUsers()
                _users.value = result
                _error.value = <span class="hljs-literal">null</span>
            } <span class="hljs-keyword">catch</span> (e: Exception) {
                _error.value = e.message
            } <span class="hljs-keyword">finally</span> {
                _loading.value = <span class="hljs-literal">false</span>
            }
        }
    }
}
</code></pre>
<h3 data-id="heading-21">7.2 配合 StateFlow（推荐）</h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserViewModel</span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> repository: UserRepository) : ViewModel() {
    <span class="hljs-comment">// 私有可变的 StateFlow</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> _uiState = MutableStateFlow(UserUiState())
    <span class="hljs-comment">// 公开只读的 StateFlow</span>
    <span class="hljs-keyword">val</span> uiState: StateFlow&lt;UserUiState&gt; = _uiState.asStateFlow()
    
    <span class="hljs-comment">// 密封类定义 UI 状态</span>
    <span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserUiState</span>(
        <span class="hljs-keyword">val</span> users: List&lt;User&gt; = emptyList(),
        <span class="hljs-keyword">val</span> loading: <span class="hljs-built_in">Boolean</span> = <span class="hljs-literal">false</span>,
        <span class="hljs-keyword">val</span> error: String? = <span class="hljs-literal">null</span>
    )
    
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">loadUsers</span><span class="hljs-params">()</span></span> {
        _uiState.update { it.copy(loading = <span class="hljs-literal">true</span>, error = <span class="hljs-literal">null</span>) }
        viewModelScope.launch {
            repository.getUsers()
                .onSuccess { users -&gt;
                    _uiState.update { it.copy(users = users, loading = <span class="hljs-literal">false</span>) }
                }
                .onFailure { error -&gt;
                    _uiState.update { 
                        it.copy(error = error.message, loading = <span class="hljs-literal">false</span>) 
                    }
                }
        }
    }
}
</code></pre>
<h2 data-id="heading-22">八、最佳实践</h2>
<h3 data-id="heading-23">8.1 推荐的架构模式</h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 1. ViewModel 负责业务逻辑</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductViewModel</span>(
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> getProductsUseCase: GetProductsUseCase,
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> savedStateHandle: SavedStateHandle
) : ViewModel() {
    
    <span class="hljs-comment">// 2. 使用 StateFlow 管理状态</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> _state = MutableStateFlow(ProductState())
    <span class="hljs-keyword">val</span> state = _state.asStateFlow()
    
    <span class="hljs-comment">// 3. 使用 SavedStateHandle 保存临时状态</span>
    <span class="hljs-keyword">var</span> searchQuery: String
        <span class="hljs-keyword">get</span>() = savedStateHandle[<span class="hljs-string">"search_query"</span>] ?: <span class="hljs-string">""</span>
        <span class="hljs-keyword">set</span>(value) { savedStateHandle[<span class="hljs-string">"search_query"</span>] = value }
    
    <span class="hljs-comment">// 4. 使用协程处理异步操作</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">loadProducts</span><span class="hljs-params">()</span></span> {
        viewModelScope.launch {
            _state.update { it.copy(isLoading = <span class="hljs-literal">true</span>) }
            <span class="hljs-keyword">val</span> result = getProductsUseCase(searchQuery)
            _state.update { it.copy(
                products = result,
                isLoading = <span class="hljs-literal">false</span>
            ) }
        }
    }
}

<span class="hljs-comment">// 5. 数据类定义状态</span>
<span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductState</span>(
    <span class="hljs-keyword">val</span> products: List&lt;Product&gt; = emptyList(),
    <span class="hljs-keyword">val</span> isLoading: <span class="hljs-built_in">Boolean</span> = <span class="hljs-literal">false</span>,
    <span class="hljs-keyword">val</span> error: String? = <span class="hljs-literal">null</span>
)
</code></pre>
<h3 data-id="heading-24">8.2 注意事项</h3>
<ol>
<li><strong>不要持有 Context 引用</strong>（如果需要，使用 AndroidViewModel）</li>
<li><strong>避免直接暴露 MutableLiveData/MutableStateFlow</strong></li>
<li><strong>使用单向数据流</strong>（UI → ViewModel → Repository）</li>
<li><strong>正确处理配置变更</strong>（使用 SavedStateHandle）</li>
<li><strong>及时清理资源</strong>（重写 onCleared 方法）</li>
</ol>
<h3 data-id="heading-25">8.3 使用 AndroidViewModel（需要 Context 时）</h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAndroidViewModel</span>(
    application: Application,
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> repository: MyRepository
) : AndroidViewModel(application) {
    
    <span class="hljs-comment">// 可以安全地使用 application context</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> context = getApplication&lt;Application&gt;().applicationContext
    
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span> {
        <span class="hljs-comment">// 使用 context</span>
        <span class="hljs-keyword">val</span> packageName = context.packageName
    }
}
</code></pre>
<h2 data-id="heading-26">九、测试 ViewModel</h2>
<h3 data-id="heading-27">9.1 单元测试示例</h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-meta">@RunWith(JUnit4::class)</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">UserViewModelTest</span> {
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> viewModel: UserViewModel
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> mockRepository = mockk&lt;UserRepository&gt;()
    
    <span class="hljs-meta">@Before</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span></span> {
        viewModel = UserViewModel(mockRepository)
    }
    
    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> myTest = runTest {</span>
        <span class="hljs-comment">// Given</span>
        <span class="hljs-keyword">val</span> mockUsers = listOf(User(<span class="hljs-string">"1"</span>, <span class="hljs-string">"John"</span>))
        coEvery { mockRepository.getUsers() } returns Result.success(mockUsers)
        
        <span class="hljs-comment">// When</span>
        viewModel.loadUsers()
        
        <span class="hljs-comment">// Then</span>
        viewModel.uiState.test {
            <span class="hljs-keyword">val</span> initialState = awaitItem()
            assertTrue(initialState.loading)
            
            <span class="hljs-keyword">val</span> finalState = awaitItem()
            assertFalse(finalState.loading)
            assertEquals(mockUsers, finalState.users)
        }
    }
}
</code></pre>
<h2 data-id="heading-28">十、总结</h2>
<p>ViewModel 是 Android 架构的核心组件：</p>
<ol>
<li><strong>管理 UI 数据</strong>的生命周期</li>
<li><strong>在配置变更时保留数据</strong></li>
<li><strong>促进关注点分离</strong>（UI 逻辑 vs 业务逻辑）</li>
<li><strong>便于测试</strong>（不依赖 Android 组件）</li>
<li><strong>支持数据共享</strong>（在 Fragment 之间）</li>
</ol>
<p>正确使用 ViewModel 可以大大提高应用的可维护性、可测试性和稳定性。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[中断的理解与代码实现]]></title>    <link>https://juejin.cn/post/7602440800295813166</link>    <guid>https://juejin.cn/post/7602440800295813166</guid>    <pubDate>2026-02-03T10:24:25.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602440800295813166" data-draft-id="7601144981171372082" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="中断的理解与代码实现"/> <meta itemprop="keywords" content="嵌入式"/> <meta itemprop="datePublished" content="2026-02-03T10:24:25.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="RobotMu"/> <meta itemprop="url" content="https://juejin.cn/user/2684353293115578"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            中断的理解与代码实现
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2684353293115578/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    RobotMu
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T10:24:25.000Z" title="Tue Feb 03 2026 10:24:25 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">什么是中断</h2>
<h3 data-id="heading-1">中断定义</h3>
<p>中断是指在主程序运行过程中，出现了特定的中断触发条件（<strong>中断源</strong>），使得 CPU 暂停当前正在运行的程序，转而去处理中断程序，处理完成后又返回原来被暂停的位置继续运行。</p>
<h3 data-id="heading-2">具象理解</h3>
<p>中断和生活中的中断差不多，比如我们正在闲适地看书呢（<code>主程序</code>），突然导师发来一条消息（<code>中断源</code>），说论文写怎么样了，这时候就不得不放下书本夹好书签，赶紧转去写论文（<code>处理中断</code>）好跟老师交差，然后再重新享受读书时光（<code>返回主程序继续执行</code>）。</p>
<p>中断系统的好处是效率更高，<strong>只有出现中断触发条件</strong>，才会去执行中断。</p>
<p>还是上面的例子，你的计划是在导师催促写论文之前看会书，没有中断机制的系统 belike：</p>
<blockquote>
<p>只能边看书边捧着手机打开聊天框，盯着老师的头像反复查看有没有消息过来（<strong>轮询</strong>）</p>
</blockquote>
<p>但是有中断就不一样啦，只管看书就行，收到导师消息再处理就可以啦。</p>
<h3 data-id="heading-3">中断优先级</h3>
<p>中断也是有优先级的，好比看书的时候同时来了两件事，<em>一边是导师的Push信息，一边是好哥们的海克斯大乱斗邀请</em>，你选哪个先处理？在这个例子中前者的<strong>优先级明显更高，所以会优先处理</strong>。这就是优先的概念。</p>
<h4 data-id="heading-4">抢占 / 响应优先级</h4>
<p>优先级分为两种：抢占优先级和响应优先级，<strong>抢占可以理解成能不能插队，响应则是怎么排队</strong>。两种优先级都遵循<strong>数字越小，优先级越高</strong>的规律，且<strong>抢占优先级高于响应优先级</strong>，或者说先比较抢占再比较响应。</p>
<p><strong>在<code>CPU</code>的世界里没有先来后到，完全按轻重缓急来决定执行顺序。</strong></p>
<blockquote>
<p>这里我们以医院叫号的例子来理解，每一位来医院就诊的病人在系统中都有两种信息，第一条信息表示患者是急诊还是常规就诊（<strong>抢占优先级</strong>），第二条信息表示患者的具体病情（<strong>响应优先级</strong>）。</p>
<p>诊室里有位病人正在就诊中，走的常规就诊通道，但这时候突然送来了一位急诊患者，<strong>情况更加紧急</strong>，就会打断当前患者的就诊过程优先治疗；当多名患者都是急诊或常规就诊时，具体的就诊顺序就由第二条信息决定，比如一位患者感冒一位患者骨折，则骨折患者优先叫号。但是如果感冒患者已经在就诊中，骨折患者是<strong>没法插队</strong>的。</p>
</blockquote>
<h3 data-id="heading-5">中断嵌套</h3>
<p>还有一种现象叫中断嵌套，中断嵌套就是你正看书呢，然后收到了好哥们的大乱斗邀请，转到玩游戏中去了，打着打着收到了老师的消息 ...</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/05121ae673e040c09f425fc60f299e74~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgUm9ib3RNdQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770719067&amp;x-signature=PAlLnUGusn9%2FUnAtb3z26ynskic%3D" alt="image.png" loading="lazy"/></p>
<hr/>
<h2 data-id="heading-6">EXTI 外部中断学习笔记</h2>
<h3 data-id="heading-7">EXTI 简介</h3>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5a0a173dc3d049b2836bc6cfc527a7c6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgUm9ib3RNdQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770719067&amp;x-signature=gcUT%2BzVPfEw9PFODtSGHrN2IEHM%3D" alt="image.png" loading="lazy"/></p>
<ul>
<li>
<p>第三点：上升沿指低电平变为高电平触发中断（下降沿相反）；双边沿指只要电平发生变化，就触发中断；<strong>软件触发</strong>是指<code>CPU</code>主动让<code>EXTI</code>假装被触发了一次，然后<strong>完整地走一遍正常触发中断</strong>的流程，区别如下：</p>
<blockquote>
<p>正常流程：电平变化 --- 触发中断 --- 执行中断程序</p>
<p>软件触发：代码设置 --- 触发中断 --- 执行中断程序</p>
</blockquote>
</li>
<li>
<p>第四点：相同的<code>Pin</code>不能同时触发中断是由内部硬件结构决定的，STM32里只有<code>16</code>条<code>EXTI</code>线，不是<code>PA0</code>一条，<code>PB0</code>一条，而是所有的<code>x0</code>引脚共用<code>EXTI0</code>。<em>就像只有一个插座，但是有多个插头都可以插</em>。</p>
</li>
<li>
<p>第六点：当中断条件触发时，既可以选择触发中断，也可以选择触发一个事件，此时外部中断的信号不会通向<code>CPU</code>，而是通向其他外设，用来触发其他外设的操作。</p>
<blockquote>
<p>这里的事件是什么还没搞清楚，只知道<strong>不是我们想的自己编写的函数</strong></p>
</blockquote>
</li>
</ul>
<hr/>
<h3 data-id="heading-8">STM32之编写中断函数</h3>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/197364c363b8482a9e66ae7ffc044e87~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgUm9ib3RNdQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770719067&amp;x-signature=zyeO1b1LVNnY%2BCF40rua7C0EIXA%3D" alt="image-20260202194433449.png" loading="lazy"/></p>
<p>在编写中断函数时，借助内部的结构图可以更好地理清思绪，<strong>逻辑上就是搭建一个完整的从<code>GPIO</code>外设到<code>NVIC</code>的链路。</strong></p>
<h4 data-id="heading-9">具体步骤</h4>
<blockquote>
<ol>
<li>配置RCC，把我们这里涉及的外设的时钟都打开；</li>
<li>配置GPIO，选择我们的端口为输入模式；</li>
<li>配置AFIO，选择我们用的这一路GPIO，连接到后面的EXTI；</li>
<li>配置EXTI，选择边沿触发方式，比如上升沿，下降沿或者双边沿；还有选择触发相应方式，可以选择<strong>中断响应（一般都是这个）</strong> 和事件响应；</li>
<li>配置NVIC，给我们这个中断选择一个合适的优先级；</li>
</ol>
<p>最后通过NVIC，外部中断信号就能进入CPU了；</p>
</blockquote>
<p>通过<strong>对射式红外传感器计次</strong>的具体代码实现可以看得更清楚：</p>
<pre><code class="hljs language-c" lang="c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"stm32f10x.h"</span>                  <span class="hljs-comment">// Device header</span></span>

<span class="hljs-type">uint16_t</span> CountSensor_Count;

<span class="hljs-type">void</span> <span class="hljs-title function_">CountSensor_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
	<span class="hljs-comment">// 1、配置RCC，把我们这里涉及的外设的时钟都打开（GPIO AFIO EXTI NVIC)</span>
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);
	<span class="hljs-comment">// EXTI和NVIC两个外设的时钟是一直开着的，不需要设置</span>
	
    <span class="hljs-comment">// 2、配置GPIO，和前面一样</span>
	GPIO_InitTypeDef GPIO_InitStruct;
	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPU;
	GPIO_InitStruct.GPIO_Pin = GPIO_Pin_14;
	GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOB, &amp;GPIO_InitStruct);
	
    <span class="hljs-comment">// 3、配置AFIO，选择我们用的这一路GPIO，连接到后面的EXTI</span>
	GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource14);
	
    <span class="hljs-comment">// 4、配置EXTI，选择边沿触发方式，选择触发响应方式等</span>
	EXTI_InitTypeDef EXTI_InitStruct;
	EXTI_InitStruct.EXTI_Line = EXTI_Line14; 				<span class="hljs-comment">//	EXTI14号线 </span>
	EXTI_InitStruct.EXTI_LineCmd = ENABLE; 					<span class="hljs-comment">// 	开启中断</span>
	EXTI_InitStruct.EXTI_Mode = EXTI_Mode_Interrupt; 		<span class="hljs-comment">// 	响应方式为中断响应</span>
	EXTI_InitStruct.EXTI_Trigger = EXTI_Trigger_Falling; 	<span class="hljs-comment">// 	下降沿</span>
	EXTI_Init(&amp;EXTI_InitStruct);
	
    <span class="hljs-comment">// 5、配置NVIC，给我们这个中断选择一个合适的优先级</span>
	
	<span class="hljs-comment">// 在配置中断之前，先指定一下中断的分组，这里选了2位抢占2位响应</span>
	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
	
	NVIC_InitTypeDef  NVIC_InitStruct;
	NVIC_InitStruct.NVIC_IRQChannel = EXTI15_10_IRQn; <span class="hljs-comment">// 因为我们设置的EXTI14</span>
	NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE;
	NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = <span class="hljs-number">1</span>; <span class="hljs-comment">// 抢占优先级</span>
	NVIC_InitStruct.NVIC_IRQChannelSubPriority = <span class="hljs-number">1</span>; <span class="hljs-comment">// 响应优先级</span>
	NVIC_Init(&amp;NVIC_InitStruct);
	
}

<span class="hljs-type">uint16_t</span> <span class="hljs-title function_">CountSensor_Get</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
	<span class="hljs-keyword">return</span> CountSensor_Count;
}


<span class="hljs-comment">// 中断函数的名字都是固定，建议直接从启动文件（Start第一个）复制</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">EXTI15_10_IRQHandler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
	<span class="hljs-keyword">if</span>(EXTI_GetITStatus(EXTI_Line14) == SET) <span class="hljs-comment">// 判断标志位</span>
	{
		CountSensor_Count++;
		EXTI_ClearITPendingBit(EXTI_Line14); <span class="hljs-comment">// 清除标志位</span>
	}
}

</code></pre>
<h4 data-id="heading-10">代码小记</h4>
<ul>
<li>
<p>和使用<code>GPIO</code>外设是一样的流程，都是<strong>打开时钟然后初始化</strong>，而<code>EXTI</code>和<code>NVIC</code>的时钟本来就是开着的，所以没有打开时钟这一步；</p>
</li>
<li>
<p>初始化都是同样的套路，甚至名字形式上也是统一的，<strong>除了<code>AFIO</code>的配置外，另外<code>NVIC</code>初始化之前</strong>需要指定优先级的分组类型。其套路如下：</p>
</li>
</ul>
<pre><code class="hljs language-c" lang="c"><span class="hljs-comment">// 根据要配置的外设来定义结构体变量</span>
Which__InitTypeDef  Which_InitStruct;

<span class="hljs-comment">// 用.的方式访问结构体数据（这里会自动弹出，不用死记）</span>
Which_InitStruct.Which = ... ;
...
Which_InitStruct.Which = ... ;

<span class="hljs-comment">// 对结构体变量取值作为参数传入Init函数（这里的参数根据自动弹出的提示来填就行，有时候不止一个，比如GPIO）</span>
Which_Init(&amp;Which_InitStruct);
</code></pre>
<ul>
<li>
<p>配置完各个外设之后就是写中断函数，需要注意中断函数的头是固定的（两个<code>void</code>），对应的<strong>函数名也是固定</strong>的，需要根据我们使用的<code>EXTI</code>线路来对应选择，比如我们使用了<code>EXTI14</code>号线，对应的就是<code>EXTI15_10_IRQHandler</code>;</p>
</li>
<li>
<p>和标志位有关的四个函数</p>
</li>
</ul>
<pre><code class="hljs language-c" lang="c">FlagStatus <span class="hljs-title function_">EXTI_GetFlagStatus</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> EXTI_Line)</span>;
<span class="hljs-type">void</span> <span class="hljs-title function_">EXTI_ClearFlag</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> EXTI_Line)</span>;
ITStatus <span class="hljs-title function_">EXTI_GetITStatus</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> EXTI_Line)</span>;
<span class="hljs-type">void</span> <span class="hljs-title function_">EXTI_ClearITPendingBit</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> EXTI_Line)</span>;
</code></pre>
<blockquote>
<p><code>EXTI</code>线触发之后（<code>Flag</code>标志位），会分成两条路径走，<strong>一种是事件，一种是中断</strong>；</p>
<p>前两个函数处理的标志位是用于说明某条<code>EXTI</code>线是否被触发过，后两个函数处理的标志位是用于说明某条<code>EXTI</code>线是否被配置为中断，并且真的走了中断这条路；</p>
<p><strong>经验法则</strong>：在中断函数中推荐用后两个函数。</p>
</blockquote>
<ul>
<li>关于中断函数</li>
</ul>

<pre><code class="hljs language-scss" lang="scss">void <span class="hljs-built_in">EXTI15_10_IRQHandler</span>(void)
{
    <span class="hljs-built_in">if</span>(EXTI_GetITStatus(EXTI_Line14) == SET) <span class="hljs-comment">// 判断标志位</span>
    {
        CountSensor_Count++;
        <span class="hljs-built_in">EXTI_ClearITPendingBit</span>(EXTI_Line14); <span class="hljs-comment">// 清除标志位</span>
    }
}
</code></pre>
<p>为什么这里要判断一下中断标志位呢？因为<code>EXTI 10 ~ 15</code>号线，共用同一个中断入口，我们需要判断是不是14号线触发的，然后执行相应的逻辑，<strong>再清除对应的标志位</strong>（不清除就卡死在中断里了！！）。</p>
<p>其内部活动类似下面：</p>
<blockquote>
<p>CPU：我被叫进 EXTI15_10 中断了</p>
<p>CPU：先看看是不是 14 号线在叫我</p>
<p>如果是：执行和 14 号线相关的逻辑 + 把 14 号线的小红灯关掉</p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[OoderAgent实战指南：入境游旅行社游客集合通知邮件发送全流程]]></title>    <link>https://juejin.cn/post/7602401081265700900</link>    <guid>https://juejin.cn/post/7602401081265700900</guid>    <pubDate>2026-02-03T10:44:41.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602401081265700900" data-draft-id="7602411521072168979" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="OoderAgent实战指南：入境游旅行社游客集合通知邮件发送全流程"/> <meta itemprop="keywords" content="人工智能"/> <meta itemprop="datePublished" content="2026-02-03T10:44:41.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="OneCodeCN"/> <meta itemprop="url" content="https://juejin.cn/user/1427583415622366"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            OoderAgent实战指南：入境游旅行社游客集合通知邮件发送全流程
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1427583415622366/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    OneCodeCN
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T10:44:41.000Z" title="Tue Feb 03 2026 10:44:41 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>本指南以入境游旅行社游客集合通知邮件自动发送为真实业务场景，从基础程序开发到AI Agent化部署、技能桥接全链路拆解OoderAgent的落地方法，充分发挥其低代码、高适配、轻量化部署的优势，适配旅行社无专业服务器、依赖简易设备（NAS/公共办公电脑）的实际办公环境，实现高频业务操作的AI化提效。</p>
<h2 data-id="heading-0">核心业务需求</h2>
<p>为旅行社当天报团的入境游散客发送集合通知邮件，满足以下核心要求：</p>
<ol>
<li>邮件接收人：从Excel表格中读取游客邮箱列数据；</li>
<li>核心信息：支持自然语言输入集合地点、时间，无需固定格式；</li>
<li>发件规范：强制使用旅行社统一对外邮箱，保障品牌一致性；</li>
<li>操作便捷：一线工作人员无需技术背景，自然语言指令即可触发执行。</li>
</ol>
<p>播放</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fcloud.tencent.com%2Fdeveloper%2Fvideo%2F85033" target="_blank" title="https://cloud.tencent.com/developer/video/85033" ref="nofollow noopener noreferrer">OoderAgent 实战指南，10分钟做一个真实应用，P2P服务，零服务依赖</a></p>
<p>OneCode 的视频</p>
<p>视频内容</p>
<h2 data-id="heading-1">实战四步走：从程序开发到AI Agent落地</h2>
<h3 data-id="heading-2">第一步：基础邮件发送程序开发&amp;本地测试启动</h3>
<h4 data-id="heading-3">核心开发要点</h4>
<ol>
<li>Excel数据解析：开发表格读取模块，指定游客邮箱列的解析规则，兼容xlsx/csv等常用格式，支持空值过滤、格式校验；</li>
<li>自然语言信息提取：嵌入基础语义解析逻辑，从输入中提取地点、时间核心字段，无需固定关键词排序；</li>
<li>企业邮箱对接：配置旅行社统一邮箱的SMTP/IMAP协议，完成发件人身份认证、邮件模板（标题/正文）标准化；</li>
<li>批量发送功能：实现邮件批量推送，附带发送状态反馈（成功/失败/数量）。</li>
</ol>
<h4 data-id="heading-4">本地测试验证</h4>
<p>开发完成后本地运行程序，输入测试指令验证核心功能：</p>
<p>测试指令：为我的游客发送集合通知邮件，游客wxl，地点颐和园东宫门，时间下午两点</p>
<p>验证结果：成功识别邮箱、地点、时间，完成批量邮件发送（示例中成功发送5封），无发送异常、信息解析错误。</p>
<h4 data-id="heading-5">开发价值</h4>
<p>完成业务功能的基础闭环，熟手开发+测试仅需5分钟，快速验证技术可行性，为后续Agent化部署打基础。</p>
<h3 data-id="heading-6">第二步：程序调整为「远程Excel部署」</h3>
<h4 data-id="heading-7">核心调整内容</h4>
<ol>
<li>取消本地Excel文件依赖，开发远程文件访问模块，支持旅行社常用的云存储（百度网盘/企业微信云盘/OneDrive）、局域网共享文件夹（NAS/办公电脑）的Excel文件读取；</li>
<li>增加远程文件实时同步&amp;版本校验，确保读取的是最新的游客报名表格，避免数据滞后；</li>
<li>配置远程文件访问权限，仅授权指定工作人员操作，保障游客信息隐私安全。</li>
</ol>
<h4 data-id="heading-8">调整意义</h4>
<p>解决旅行社「多人协作、跨设备办公」的痛点，一线销售/计调无需将Excel表格拷贝到指定设备，远程更新表格后程序可直接读取，提升数据同步效率。</p>
<h3 data-id="heading-9">第三步：服务发布到SkillCenter&amp;远程部署</h3>
<h4 data-id="heading-10">核心部署操作</h4>
<ol>
<li>SkillCenter适配：将邮件发送程序封装为标准化技能服务（Skill），按照OoderAgent的Skill开发规范，定义服务入口、参数格式（自然语言/结构化）、返回结果类型；</li>
<li>轻量化部署：依托旅行社现有简易设备（NAS设备、公共打印机电脑/办公主机）完成SkillCenter部署，无需专业服务器，满足低硬件成本要求；</li>
<li>服务注册与配置：将邮件发送Skill注册到SkillCenter，配置服务名称、触发关键词、权限管理规则。</li>
</ol>
<h4 data-id="heading-11">部署核心目的</h4>
<ol>
<li>满足企业统一邮箱多人操作需求：将发件程序集中部署后，所有工作人员通过统一入口调用，避免个人配置企业邮箱导致的账号泄露、发件格式不统一问题；</li>
<li>保障高频操作稳定性：集合通知发送为旅行社高频业务，集中部署后可实现7*24小时服务可用，避免本地程序因设备故障、关机导致的服务中断；</li>
<li>实现集中化管理：管理员可在SkillCenter统一监控服务运行状态、调用记录、发送数据，便于业务统计和问题排查。</li>
</ol>
<h3 data-id="heading-12">第四步：本地Skills桥接程序开发+游客反馈表单制作</h3>
<h4 data-id="heading-13">模块1：本地Skills桥接程序开发</h4>
<ol>
<li>核心功能：实现本地操作端（电脑/平板）与远程SkillCenter的无缝桥接，支持IDE、CLI、网页端多方式调用，桥接过程零配置、零成本；</li>
<li>自然语言触发适配：桥接程序嵌入OoderAgent的语义交互能力，工作人员无需输入代码/指令格式，直接用自然语言对话即可触发SkillCenter的邮件发送服务；</li>
<li>操作反馈同步：将SkillCenter的邮件发送状态（成功/失败/数量）实时同步到本地操作端，工作人员可即时确认执行结果。</li>
</ol>
<h4 data-id="heading-14">模块2：游客反馈表单制作</h4>
<ol>
<li>表单设计：围绕入境游游客需求，设计简易反馈表单，包含是否收到邮件、集合信息是否清晰、是否有行程疑问、其他需求等核心问题，支持多语言（中/英/日/韩等）适配；</li>
<li>表单挂载：将反馈表单链接嵌入集合通知邮件的正文末尾，方便游客一键打开填写；</li>
<li>反馈数据同步：开发表单数据收集模块，将游客反馈实时同步到旅行社的业务管理表（Excel/小程序），便于计调及时处理游客疑问。</li>
</ol>
<h4 data-id="heading-15">最终落地效果</h4>
<p>一线工作人员仅需在对话框输入自然语言指令，即可完成「远程读取游客邮箱→自动发送集合通知→实时获取发送状态」全流程，无需任何技术操作，真正实现AI提效、零门槛使用。</p>
<h2 data-id="heading-16">场景核心价值：OoderAgent为何适配旅行社行业？</h2>
<h3 data-id="heading-17">1. 贴合入境游行业通讯刚需</h3>
<p>入境游游客的互联网账号体系以邮件为核心，是海外游客最常用、最信任的通讯方式，相比微信/短信，邮件通知的触达率、正式性更高，契合散客预订的业务场景。</p>
<h3 data-id="heading-18">2. 最低成本的AI落地方案</h3>
<p>无需采购专业服务器、无需招聘专职技术人员，依托旅行社现有NAS/办公电脑即可完成全链路部署，Skill桥接过程零成本，一线人员无需培训即可上手，解决中小旅行社「想做AI提效但预算有限、技术能力不足」的痛点。</p>
<h3 data-id="heading-19">3. 高频业务的标准化&amp;稳定性提效</h3>
<p>集合通知发送、行程提醒等属于旅行社高频重复操作，通过OoderAgent实现程序标准化+部署集中化+操作轻量化，既避免了人工发送的漏发、错发问题，又解放了工作人员的时间，使其聚焦于游客服务等核心工作。</p>
<h2 data-id="heading-20">OoderAgent的技术价值：不止于「低代码提效」</h2>
<p>本次实战的核心是业务场景的AI Agent化落地，但OoderAgent的技术价值远不止于低成本的操作提效，其核心竞争力体现在两大底层能力：</p>
<ol>
<li>P2P核心通讯能力：为SkillCenter与本地操作端、远程设备与服务端的连接提供稳定、高速的通讯支持，保障轻量化部署下的服务稳定性，无需依赖第三方云服务；</li>
<li>前沿Skills技术生态：将常用业务字段（地点、时间、游客信息等）抽象配置到Skills模板中，支持网页端可视化配置，后续可快速适配旅行社其他业务（如行程变更通知、签证材料提醒），仅需修改模板参数即可实现新Skill的快速开发，具备极强的业务扩展性。</li>
</ol>
<h2 data-id="heading-21">最终测试验证：全流程自然语言触发</h2>
<p>测试指令：为我的游客发送集合通知邮件，游客wxl，地点颐和园东宫门，时间下午两点</p>
<p>全流程执行结果：</p>
<ol>
<li>自动从远程Excel中读取游客wxl的邮箱数据；</li>
<li>精准提取「颐和园东宫门、下午两点」核心信息；</li>
<li>通过旅行社统一邮箱批量发送5封集合通知邮件；</li>
<li>本地操作端实时反馈「发送成功」状态；</li>
<li>游客可通过邮件内链接填写反馈表单，数据同步至旅行社业务表。</li>
</ol>
<p>执行效率：指令输入后秒级触发，全程无需人工干预，相比人工逐封发送邮件，效率提升10倍以上。</p>
<h2 data-id="heading-22">行业延伸适配</h2>
<p>本实战方案可快速适配旅行社其他高频邮件通知场景：</p>
<ul>
<li>签证材料补交通知</li>
<li>行程变更/天气提醒通知</li>
<li>团费尾款缴纳通知</li>
<li>返程航班确认通知</li>
</ul>
<p>仅需在SkillCenter中修改Skills模板的核心字段和邮件模板，即可实现新场景的快速落地，真正实现「一次开发、多次复用」。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[一种轻量级进程间服务隔离方法实践]]></title>    <link>https://juejin.cn/post/7602188264115306511</link>    <guid>https://juejin.cn/post/7602188264115306511</guid>    <pubDate>2026-02-03T10:45:11.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602188264115306511" data-draft-id="7602216700747972608" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="一种轻量级进程间服务隔离方法实践"/> <meta itemprop="keywords" content="程序员"/> <meta itemprop="datePublished" content="2026-02-03T10:45:11.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="京东云开发者"/> <meta itemprop="url" content="https://juejin.cn/user/2634854380340008"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            一种轻量级进程间服务隔离方法实践
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2634854380340008/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    京东云开发者
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T10:45:11.000Z" title="Tue Feb 03 2026 10:45:11 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">系统的复杂性</h2>
<p>我们团队负责的系统是分布式微服务部署架构，随着业务的不断发展壮大和多条线场景化的持续建设丰富，系统的业务逻辑越来越多，功能逻辑也越来越复杂。</p>
<p>﻿</p>
<h3 data-id="heading-1">系统早期单个应用的一个用户故事地图</h3>
<p>﻿</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/77eb8d5b7a5b499eb0a68f2bba921796~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqs5Lic5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770720311&amp;x-signature=punYw5iRhe8%2FhxgLLoqj947jGSs%3D" alt="" loading="lazy"/></p>
<p>﻿﻿</p>
<p>﻿</p>
<h3 data-id="heading-2">系统交互</h3>
<p>﻿</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ed397964ee1f42ccadf1ca50ace0e55f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqs5Lic5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770720311&amp;x-signature=Tq9T1jyCXWgXoEBwDLP9UepAVyo%3D" alt="" loading="lazy"/></p>
<p>﻿﻿</p>
<p>﻿</p>
<p>﻿</p>
<p>﻿</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9e505874bd1d469ba518d3b180e30cfe~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqs5Lic5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770720311&amp;x-signature=LfbGMb3ZkYMBiFOJM%2Byk%2BOPspOU%3D" alt="" loading="lazy"/></p>
<p>﻿﻿</p>
<p>﻿</p>
<p>﻿</p>
<h3 data-id="heading-3">物理模型（库表）的复杂性</h3>
<p>﻿</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9c6ef7725857482f80ad2e298c3dd60f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqs5Lic5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770720311&amp;x-signature=EQ3%2FbJKCZtaZ67ZvUscJW65ZfQk%3D" alt="" loading="lazy"/></p>
<p>﻿﻿</p>
<p>﻿</p>
<h3 data-id="heading-4">一个子系统的代码沉淀</h3>
<p>﻿</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d783aa32b3294b5a8cb2cc440d3c45ad~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqs5Lic5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770720311&amp;x-signature=dOUD5lqX6WFreOGRrh7%2BLa%2BX8y0%3D" alt="" loading="lazy"/></p>
<p>﻿﻿</p>
<p>﻿</p>
<p>﻿</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0b896831ad0a40fba2779abbc35f4c53~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqs5Lic5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770720311&amp;x-signature=zV9qYM7pFqfd0xAbM0gyI0Orc%2Bo%3D" alt="" loading="lazy"/></p>
<p>﻿﻿</p>
<p>﻿</p>
<p>在应用部署方面，目前现状我们的一个应用对应一个coding代码地址，部署以一个应用为单位发起部署申请，应用下有多个集群，集群下有多个分组，也区分灰度环境、正式线上环境。通过不同的部署编排，使用不同的代码版本部署不同的环境。</p>
<p>﻿</p>
<p>系统的复杂性来自多个方面：业务流程复杂性、架构复杂性、代码实现复杂性、物理模型（库表）的复杂性、监控运维的复杂性等。本文重点不是系统复杂性的治理，而是在现有基础上，如何低成本轻量级方式服务隔离，在大促为系统的稳定性中发挥作用。</p>
<p>﻿</p>
<p>一个容器中部署的应用进程内，提供了各种各样的服务，以在库应用为例，包含了盘点、变更、补货、移库、盘盈亏、预包等相对独立的功能，每个功能又有自己的单据-任务-结果整套业务流程。既有RESTful服务，也有JSF服务，还有MQ消息处理，另外还有定时任务。这些资源虽有线程池隔离，但CPU、内存等资源仍是共享资源，在负载高的时候，比如CPU满载或内存OOM时，会造成服务卡顿，RT时间长，影响服务响应和功能使用。</p>
<p>﻿</p>
<h2 data-id="heading-5">方案</h2>
<h3 data-id="heading-6">方案一：应用拆分</h3>
<p>按业务域、技术域对进行拆分，比如在库应用按盘点、变更、移库、补货等拆分为单独的应用，不仅应用部署做了拆分，对应的数据库层面也按域进行拆分，盘点相关的表，例如盘点单主档、盘点单明细、盘点任务主档、盘点任务明细、盘点结果独立到单独的库中，可以按逻辑库独立，也可以独立到单独的数据库实例中，后者的隔离效果更好。在代码层面，可以将在库coding按域拆分出来单独的代码库，也可以不独立，保持共享代码库，只是在编译时按moudle进行按需集成，例如为盘点应用编译时，包含盘点moudle、公共module，其他不需要的moudle，比如变更module、补货module则不需要参与编译集成。</p>
<p>﻿</p>
<h3 data-id="heading-7">方案二：使用Hystrix进行服务隔离</h3>
<p>Hystrix 主要实现的是‌进程内隔离‌，具体来说，它通过线程池隔离和信号量隔离两种机制，在单个应用进程内部对依赖服务的调用进行资源隔离和故障控制‌。</p>
<h4 data-id="heading-8">‌线程池隔离‌</h4>
<p>Hystrix 为每个依赖服务分配独立的线程池，不同服务的调用请求在各自的线程池中执行，避免因某个服务故障或延迟耗尽整个应用的线程资源‌，这种隔离方式类似于“舱壁隔离”，将故障限制在特定范围内‌。</p>
<p>﻿</p>
<h4 data-id="heading-9">‌信号量隔离‌</h4>
<p>通过控制并发请求的线程数（信号量阈值）实现隔离，适用于耗时短、并发量高的场景（如读缓存）‌。信号量隔离是同步阻塞方式，不涉及线程切换，开销较低‌。</p>
<p>﻿</p>
<h3 data-id="heading-10">方案三：轻量级进程间服务服务隔离</h3>
<p>既不拆分应用，也不需要引入Sping Cloud Hystrix组件，不侵入业务代码，在部署层面实现服务隔离，属于应用内分组机器实例隔离，也是进程间服务隔离。数据库和代码库层面不需要隔离，仍采用共享模式。</p>
<p>以在库为例，为盘点、补货、变更等创建不同的业务分组，当然处于高可用考虑，会为盘点、补货、变更等每个业务分组，又会横跨多个机房分组，不如中云信机房分组、有孚机房分组。</p>
<p>﻿</p>
<p>本文探索实践的方案三示意图如下：</p>
<p>﻿</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/841edfbd0b3647318728cdbc4be9cbd1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqs5Lic5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770720311&amp;x-signature=qGPtxKg26wGmApf0IcSIleJRo%2FQ%3D" alt="" loading="lazy"/></p>
<p>﻿﻿</p>
<p>﻿</p>
<h3 data-id="heading-11">方案简单对比和选择</h3>









































<table><thead><tr><th><strong>方案</strong></th><th><strong>隔离粒度</strong></th><th><strong>隔离效果</strong></th><th><strong>代码侵入性</strong></th><th><strong>实现成本</strong></th><th><strong>落地风险</strong></th><th><strong>落地速度</strong></th></tr></thead><tbody><tr><td>方案一：应用拆分</td><td>应用间隔离</td><td>高</td><td>高</td><td>高</td><td>高</td><td>慢</td></tr><tr><td>方案二：使用Hystrix进行服务隔离</td><td>线程间隔离</td><td>低</td><td>中</td><td>中</td><td>中</td><td>中</td></tr><tr><td>方案三：轻量级进程间服务服务隔离</td><td>进程间隔离</td><td>中</td><td>低</td><td>低</td><td>低</td><td>快</td></tr></tbody></table>
<p>﻿</p>
<p>本文旨在探索一个轻量级的进程级服务隔离方法，短平快，易落地，见效快，可以在大促中快速发挥作用，保障系统的稳定性。</p>
<p>在方案选择上，本文选择方案三进行实操落地。选择方案三，是因为方案三很牛吗？不是的，相比之下方案一和方案二方案更为成熟，行业落地经验更为丰富。</p>
<p>之所以选择方案三，是在众多的因素考量中折中选择，在不同的场景下，采用合适的方案解决相应的痛点，够用 + 1，easy + 1。</p>
<p>方案二和三之间并无冲突，其实可以结合搭配使用。</p>
<p>﻿</p>
<h2 data-id="heading-12">实操</h2>
<h3 data-id="heading-13">隔离部署分组</h3>
<p>配置集合</p>
<p>通过配置集合，实现分组间共享配置，方便多分组管理。</p>
<p>﻿</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/412c1f699fb3488095955e8f6414e9da~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqs5Lic5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770720311&amp;x-signature=5TUJzy6rLn9gWLfvATZdRJQG13g%3D" alt="" loading="lazy"/></p>
<p>﻿﻿</p>
<p>﻿</p>
<p>﻿</p>
<p>跨机房多机房部署</p>
<p>通过多机房部署实现服务高可用。</p>
<p>﻿</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8b8b2f77310045f68e35841fe3af0cb1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqs5Lic5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770720311&amp;x-signature=aarBbL%2FJT1FG6Rcyto%2FiI2LpNhw%3D" alt="" loading="lazy"/></p>
<p>﻿﻿</p>
<p>﻿</p>
<h3 data-id="heading-14">隔离NP域名</h3>
<p>按域隔离的RESTful，创建单独的NP域名。</p>
<p>﻿</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6df1f7d96c9a463e8642d0582324900b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqs5Lic5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770720311&amp;x-signature=AslAPY9D2n2Gs30%2BQvIYp3NFSJU%3D" alt="" loading="lazy"/></p>
<p>﻿﻿</p>
<p>﻿</p>
<p>﻿</p>
<p>﻿</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ddc01c0d0f1446c1aaa3ee518ce56089~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqs5Lic5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770720311&amp;x-signature=VEJSFrMrcT%2F5FbUv950l4cP1ipY%3D" alt="" loading="lazy"/></p>
<p>﻿﻿</p>
<p>﻿</p>
<p>﻿</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4307c2a34ade48d48c3d50c462c4c5e3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqs5Lic5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770720311&amp;x-signature=Or32upHCJa4Zewo5meEYViVpEnY%3D" alt="" loading="lazy"/></p>
<p>﻿﻿</p>
<p>﻿</p>
<h3 data-id="heading-15">NGINX拆分流量</h3>
<p>拆分upstream，按照不同域RESTful方法的规则进行路由拆分配置。</p>
<p>﻿</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/22f3b762331e4b2691fbf3814f86c10e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqs5Lic5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770720311&amp;x-signature=2KPYiQiRb4BBTeCMsufutHl0gNA%3D" alt="" loading="lazy"/></p>
<p>﻿﻿</p>
<p>﻿</p>
<p>﻿</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e6914810603d4b3ba8434e283afa7648~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqs5Lic5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770720311&amp;x-signature=%2FziMn5f89QrQFU%2FF3s3jVTiqZL4%3D" alt="" loading="lazy"/></p>
<p>﻿﻿</p>
<h3 data-id="heading-16">JSF服务隔离</h3>
<p>别名拆分，通过别名隔离服务，调用方无需改动。</p>
<p>﻿</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3bff9677f0ac4033903756c3ca05afc0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqs5Lic5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770720311&amp;x-signature=FMtvOgHDkWieTs7%2F%2F0L8jqRbBsk%3D" alt="" loading="lazy"/></p>
<p>﻿﻿</p>
<p>﻿</p>
<p>﻿</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/740ff0c882694018bed1aee648d11e98~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqs5Lic5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770720311&amp;x-signature=TZ87O9Gw8EaKFTxGAsiMKJXCsGY%3D" alt="" loading="lazy"/></p>
<p>﻿﻿</p>
<p>﻿</p>
<p>﻿</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0a02b702d21b41468bf310d6baef270b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqs5Lic5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770720311&amp;x-signature=k8UiNVGRShgJVYYmU%2BPTsfncZ%2Fs%3D" alt="" loading="lazy"/></p>
<p>﻿﻿</p>
<p>随着服务隔离，同时兼顾机器资源利用率，拆分后的单域内机器数量少于拆分前机器数量，JSF业务线程池大小可适当调大，JSF的单机限流阈值也适当调大。</p>
<p>﻿</p>
<h3 data-id="heading-17">MQ消息队列隔离</h3>
<p>在变更的yml中，只保留变更相关的TOPIC，其他置为NONE。</p>
<p>﻿</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7c3aebfe1b1b47fda66540a08aa3bcf9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqs5Lic5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770720311&amp;x-signature=otDvQ0LECL2jXh3S1A2%2FdgY%2BGdY%3D" alt="" loading="lazy"/></p>
<p>﻿﻿</p>
<p>﻿</p>
<p>在盘点的yml中，只保留盘点相关的TOPIC，其他置为NONE。</p>
<p>﻿</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2a67f64be9dc48ab9ea27f6ab0be64eb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqs5Lic5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770720311&amp;x-signature=oE3y06n9NAI3s0sBwR7BN7wMFu0%3D" alt="" loading="lazy"/></p>
<p>﻿﻿</p>
<p>﻿</p>
<p>其他分组按此调整配置。</p>
<p>﻿</p>
<h2 data-id="heading-18">落地效果</h2>
<h3 data-id="heading-19">RESTFul服务</h3>
<p>对应的logbook自然地按域拆分，方便查询定位流量机器。</p>
<p>﻿</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5421c33b9cf04d0099a1036d0abf5b18~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqs5Lic5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770720311&amp;x-signature=SbgoyT0A2ZYXLjHIm4ePzTzKe7w%3D" alt="" loading="lazy"/></p>
<p>﻿﻿</p>
<p>﻿</p>
<p>﻿</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/38e1a7c58722454bb669ee6dd4ceb24b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqs5Lic5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770720311&amp;x-signature=MrfaLsz6EGrEktWnzbWeQy%2BCiJE%3D" alt="" loading="lazy"/></p>
<p>﻿﻿</p>
<p>﻿</p>
<h3 data-id="heading-20">JSF服务</h3>
<p>通过隔离的JSF别名实现流量路由到的机器。</p>
<p>﻿</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ed47ad3963f1473aaa1dab8687758578~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqs5Lic5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770720311&amp;x-signature=ZhbNuPq9oAld7B4i4WORAspQqPA%3D" alt="" loading="lazy"/></p>
<p>﻿﻿</p>
<p>﻿</p>
<h2 data-id="heading-21">未来演进</h2>
<p>目前，在应用稳定方面，探索并实践落地了一种轻量级进程间服务隔离单元化部署方法，在库和库存按业务域拆分服务部署单元化分组，在库按盘点、补货、变更、导出导出、通用服务部署，库存按库存查询、库容服务、高时效、worker服务等作为独立部署的部署单元，控制爆炸半径，每个部署单元都是双机房高可用，保障系统的稳定性。</p>
<p>未来，随着系统的长期发展，系统复杂性需按域合理拆分治理，业务单元化，服务单元化，系统演进与业务发展齐头并进，相互促进，使系统始终保持在健康的水位，可持续发展</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Amazon Kinesis vs. SQS: Differences & Comparison]]></title>    <link>https://juejin.cn/post/7602225961096052770</link>    <guid>https://juejin.cn/post/7602225961096052770</guid>    <pubDate>2026-02-03T10:49:37.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602225961096052770" data-draft-id="7602188264115372047" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Amazon Kinesis vs. SQS: Differences &amp; Comparison"/> <meta itemprop="keywords" content="AWS"/> <meta itemprop="datePublished" content="2026-02-03T10:49:37.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="AutoMQ"/> <meta itemprop="url" content="https://juejin.cn/user/2878958479084707"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Amazon Kinesis vs. SQS: Differences &amp; Comparison
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2878958479084707/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    AutoMQ
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T10:49:37.000Z" title="Tue Feb 03 2026 10:49:37 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p># Amazon Kinesis vs. SQS: Differences &amp; Comparison</p>
<p>## Overview</p>
<p>Amazon Web Services \(AWS) offers multiple messaging and streaming services, with Amazon Kinesis and Amazon Simple Queue Service \(SQS) being two of the most widely used options. While both facilitate data movement between application components, they serve fundamentally different purposes and excel in different scenarios. This comprehensive comparison explores their key differences, use cases, and technical considerations.</p>
<p>Before diving into the detailed comparison, the key finding is that Kinesis is optimized for real-time, high-volume data streaming with multiple consumers, while SQS excels at reliable message queuing for decoupling application components with simpler operational requirements.</p>
<p>## Core Concepts and Architecture</p>
<p>### Amazon Kinesis</p>
<p>Kinesis is a platform for streaming data on AWS, allowing real-time processing of high-volume data streams. It's built on the concept of persistent data streams composed of shards, which represent the base throughput unit.</p>
<p>Key components include:</p>
<p>- **Data Streams** : Core service for capturing and storing streaming data</p>
<p>- **Shards** : Base throughput units \(1MB/sec input, 2MB/sec output per shard)</p>
<p>- **Records** : Data units with partition keys for distribution across shards</p>
<p>- **Retention** : Data persists for 24 hours by default, configurable up to 365 days</p>
<p>![](./amazon-kinesis-vs-sqs-differences-comparison/1.webp)</p>
<p>### Amazon SQS</p>
<p>SQS is a fully managed message queuing service designed to decouple and scale microservices, distributed systems, and serverless applications. It provides a simple queue model with guaranteed at-least-once delivery.</p>
<p>Key components include:</p>
<p>- **Queues** : Standard \(high throughput) or FIFO \(ordered delivery)</p>
<p>- **Messages** : Individual data units \(up to 256KB each)</p>
<p>- **Visibility Timeout** : Period during which messages are invisible after being retrieved</p>
<p>- **Retention** : Messages persist up to 4 days by default, configurable from 1 minute to 14 days</p>
<p>![](./amazon-kinesis-vs-sqs-differences-comparison/2.webp)</p>
<p>## Key Differences</p>
<p>### Purpose and Design Philosophy</p>
<p>| **Aspect**| **Kinesis**| **SQS**|</p>
<p>| - | - | - |</p>
<p>| Primary Purpose| Real-time data streaming and analytics| Message queuing and application decoupling|</p>
<p>| Design Focus| High-volume streaming data processing| Reliable message delivery between components|</p>
<p>| Processing Model| Stream processing with multiple consumers| Queue processing with individual consumers|</p>
<p>| Data Lifecycle| Persistent with configurable retention| Deleted after successful processing|</p>
<p>Kinesis is primarily designed for real-time data streaming applications that need to process and analyze large volumes of continuous data. SQS, on the other hand, focuses on reliable message queuing to decouple application components and ensure message delivery.</p>
<p>### Data Model and Consumption Patterns</p>
<p>Kinesis maintains data streams that can be read by multiple consumers simultaneously, allowing for different applications to process the same data independently. With SQS, each message is typically processed by a single consumer and then deleted from the queue.</p>
<p>### Message Ordering and Delivery Guarantees</p>
<p>Kinesis preserves the ordering of records at the shard level, meaning records with the same partition key will be processed in order. SQS offers two queue types:</p>
<p>- **Standard queues** : High throughput with at-least-once delivery but no guaranteed order</p>
<p>- **FIFO queues** : Exactly-once processing with guaranteed ordering but lower throughput</p>
<p>### Scalability Characteristics</p>
<p>| **Feature**| **Kinesis**| **SQS**|</p>
<p>| - | - | - |</p>
<p>| Scaling Model| Manual provisioning or on-demand| Fully automatic|</p>
<p>| Throughput Limits| 1MB/s in, 2MB/s out per shard| 3,000 msgs/sec standard, 30,000 msgs/sec high throughput|</p>
<p>| Maximum Message Size| 1MB| 256KB|</p>
<p>| Operational Overhead| Higher \(shard management)| Lower \(fully managed)|</p>
<p>Kinesis requires explicit capacity planning through shard provisioning, whereas SQS scales automatically to match demand. However, Kinesis can achieve higher overall throughput with appropriate shard allocation.</p>
<p>## Use Cases</p>
<p>### When to Use Kinesis</p>
<p>- **Real-time Analytics** : Processing streaming data for immediate insights</p>
<p>- **IoT Data Processing** : Handling large-scale data from IoT devices</p>
<p>- **Log and Event Data Collection** : Centralized collection of logs and events</p>
<p>- **Clickstream Analysis** : Processing website user activity in real-time</p>
<p>- **Multiple Consumer Applications** : When multiple applications need to process the same data</p>
<p>### When to Use SQS</p>
<p>- **Application Decoupling** : Separating components of distributed applications</p>
<p>- **Task Queues** : Managing job processing and workload distribution</p>
<p>- **Batch Processing** : Queuing items for batch processing workflows</p>
<p>- **Microservice Communication** : Reliable messaging between microservices</p>
<p>- **Load Leveling** : Smoothing out traffic spikes to backend systems</p>
<p>### Hybrid Approaches</p>
<p>Some architectures benefit from using both services together:</p>
<p>- Using Kinesis for initial high-volume data capture and SQS for specific processing tasks</p>
<p>- Implementing Kinesis for real-time processing and SQS for task distribution to workers</p>
<p>## Implementation Details</p>
<p>### Configuration and Management</p>
<p>#### Kinesis Configuration</p>
<p>```</p>
<p># AWS CLI example for creating a Kinesis stream</p>
<p>aws kinesis create-stream --stream-name MyDataStream --shard-count 5</p>
<p>```</p>
<p>Considerations:</p>
<p>- Shard count determines throughput capacity and cost</p>
<p>- Partition key design affects data distribution across shards</p>
<p>- Enhanced fan-out for high-demand consumers requires explicit configuration</p>
<p>- Consumer applications often use Kinesis Client Library \(KCL) with DynamoDB for checkpointing</p>
<p>#### SQS Configuration</p>
<p>```</p>
<p># AWS CLI example for creating an SQS queue</p>
<p>aws sqs create-queue --queue-name MyQueue --attributes DelaySeconds=0,MaximumMessageSize=262144</p>
<p>```</p>
<p>Considerations:</p>
<p>- Queue type selection \(Standard vs. FIFO) based on ordering requirements</p>
<p>- Appropriate visibility timeout to prevent duplicate processing</p>
<p>- Dead-letter queue configuration for handling failed message processing</p>
<p>- Message retention period based on application requirements</p>
<p>### Integration with AWS Ecosystem</p>
<p>#### Kinesis Integrations</p>
<p>Kinesis integrates seamlessly with many AWS services:</p>
<p>- **Lambda** : For serverless stream processing</p>
<p>- **Firehose** : For delivery to S3, Redshift, Elasticsearch, or Splunk</p>
<p>- **Analytics** : For SQL queries against streaming data</p>
<p>- **Data Warehouse Services** : Direct integration with Redshift and S3</p>
<p>#### SQS Integrations</p>
<p>SQS works well with:</p>
<p>- **Lambda** : Direct invocation when messages arrive</p>
<p>- **EC2/ECS** : For traditional worker patterns</p>
<p>- **Step Functions** : For complex workflows</p>
<p>- **EventBridge** : For event-driven architectures</p>
<p>### Best Practices</p>
<p>#### Kinesis Best Practices</p>
<p>- Use shard-level metrics to monitor performance and identify hotspots</p>
<p>- Monitor IteratorAge metric to prevent data loss from expired iterators</p>
<p>- Implement proper exception handling for "poison messages" that can cause batch failures</p>
<p>- Design partition keys to distribute data evenly across shards</p>
<p>- Consider enhanced fan-out for high-throughput consumers</p>
<p>#### SQS Best Practices</p>
<p>- Configure appropriate visibility timeout based on expected processing time</p>
<p>- Implement dead-letter queues to capture and analyze failed messages</p>
<p>- Use batch operations \(SendMessageBatch, ReceiveMessage with MaxNumberOfMessages) for efficiency</p>
<p>- Implement exponential backoff for handling throttling conditions</p>
<p>- Consider long polling to reduce empty responses and API calls</p>
<p>## Cost and Comparison</p>
<p>### Pricing and Cost Optimization</p>
<p>| **Aspect**| **Kinesis**| **SQS**|</p>
<p>| - | - | - |</p>
<p>| Pricing Model| Pay per shard-hour or on-demand| Pay per million requests|</p>
<p>| Small Volume Cost| Higher cost floor| More cost-effective|</p>
<p>| Large Volume Cost| More efficient at very high throughput| Can become expensive at extreme scales|</p>
<p>| Cost Estimation| Based on shard count and data volume| Based on request count and retention|</p>
<p>At small data volumes \(1GB/day), SQS is significantly less expensive \(<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.20</mn><mi mathvariant="normal">/</mi><mi>m</mi><mi>o</mi><mi>n</mi><mi>t</mi><mi>h</mi><mi>v</mi><mi>s</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">0.20/month vs. </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mord">0.20/</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">s</span><span class="mord">.</span></span></span></span></span>10.82/month for Kinesis). However, as volume increases to 1TB/day, Kinesis becomes more cost-effective \(<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>158</mn><mi mathvariant="normal">/</mi><mi>m</mi><mi>o</mi><mi>n</mi><mi>t</mi><mi>h</mi><mi>v</mi><mi>s</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">158/month vs. </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mord">158/</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">s</span><span class="mord">.</span></span></span></span></span>201/month for SQS).</p>
<p>### Comparison with Alternative Solutions</p>
<p>#### Kinesis vs. Confluent \(Kafka)</p>
<p>| **Aspect**| **Kinesis**| **Confluent**|</p>
<p>| - | - | - |</p>
<p>| Focus| Streaming data service| Complete streaming platform|</p>
<p>| Data Model| Streams &amp; Shards| Distributed commit logs \(topics)|</p>
<p>| Retention| Up to 365 days| Unlimited potential retention|</p>
<p>| Ecosystem| AWS services integration| Rich connector ecosystem|</p>
<p>| Management| Fully managed by AWS| Self-managed or Confluent Cloud|</p>
<p>Confluent offers greater flexibility and unlimited retention compared to Kinesis' maximum 365-day retention. However, Kinesis provides tighter integration with AWS services and lower operational overhead.</p>
<p>#### Kinesis vs. Redpanda</p>
<p>Redpanda offers higher performance than Kinesis with fewer resources due to its C\+\+ foundation and efficient design. It excels in self-hosted environments with three times fewer nodes than traditional Kafka setups. However, Kinesis benefits from being a fully managed AWS service with automatic scaling and tight AWS ecosystem integration.</p>
<p>## Decision Framework</p>
<p>When choosing between these services, consider:</p>
<p>1. **Data Characteristics** :</p>
<p>    - Volume: High-volume streaming data favors Kinesis</p>
<p>    - Ordering: If strict ordering is required, use Kinesis or SQS FIFO</p>
<p>    - Retention: Long retention needs favor Kinesis</p>
<p>2. **Consumption Pattern** :</p>
<p>    - Single consumer: SQS is simpler</p>
<p>    - Multiple consumers: Kinesis allows multiple applications to process the same data</p>
<p>3. **Operational Preferences** :</p>
<p>    - Fully managed with minimal configuration: SQS</p>
<p>    - Control over scaling and processing: Kinesis</p>
<p>4. **Integration Requirements** :</p>
<p>    - Deep AWS integration: Both work well</p>
<p>    - Event-driven architectures: SQS often simpler</p>
<p>    - Real-time analytics pipeline: Kinesis preferred</p>
<p>## Conclusion</p>
<p>Amazon Kinesis and SQS serve different but complementary purposes in distributed architectures. Kinesis excels at high-volume, real-time data streaming with multiple consumers, while SQS provides simple, reliable message queuing for decoupling application components.</p>
<p>Many modern architectures leverage both: Kinesis for capturing and processing high-volume streaming data and SQS for reliable task distribution and application decoupling. Understanding their distinct characteristics and selecting the right service \(or combination) for your specific use case is essential for building efficient, scalable, and cost-effective cloud-native applications.</p>
<p>If you find this content helpful, you might also be interested in our product [AutoMQ](<a href="https://link.juejin.cn?target=https%3A%2F%2Fautomq.com%2F" target="_blank" title="https://automq.com/" ref="nofollow noopener noreferrer">automq.com/</a>). AutoMQ is a cloud-native alternative to Kafka by decoupling durability to S3 and EBS. 10x Cost-Effective. No Cross-AZ Traffic Cost. Autoscale in seconds. Single-digit ms latency. AutoMQ now is [source code available](<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FAutoMQ%2Fautomq" target="_blank" title="https://github.com/AutoMQ/automq" ref="nofollow noopener noreferrer">github.com/AutoMQ/auto…</a>) on github. Big Companies Worldwide are Using AutoMQ. Check the following case studies to learn more:</p>
<p>- [Grab: Driving Efficiency with AutoMQ in DataStreaming Platform](<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DIB8sh639Rsg" target="_blank" title="https://www.youtube.com/watch?v=IB8sh639Rsg" ref="nofollow noopener noreferrer">www.youtube.com/watch?v=IB8…</a>)</p>
<p>- [Palmpay Uses AutoMQ to Replace Kafka, Optimizing Costs by 50%\+](<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.automq.com%2Fblog%2Fpalmpay-uses-automq-to-replace-kafka" target="_blank" title="https://www.automq.com/blog/palmpay-uses-automq-to-replace-kafka" ref="nofollow noopener noreferrer">www.automq.com/blog/palmpa…</a>)</p>
<p>- [AutoMQ help Geely Auto\(Fortune Global 500) solve the pain points of Kafka elasticity in the V2X scenario](<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.automq.com%2Fblog%2Fautomq-help-geely-auto-solve-the-pain-points-of-kafka-elasticity-in-the-v2x-scenario" target="_blank" title="https://www.automq.com/blog/automq-help-geely-auto-solve-the-pain-points-of-kafka-elasticity-in-the-v2x-scenario" ref="nofollow noopener noreferrer">www.automq.com/blog/automq…</a>)</p>
<p>- [How Asia’s Quora Zhihu uses AutoMQ to reduce Kafka cost and maintenance complexity](<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.automq.com%2Fblog%2Fhow-asias-quora-zhihu-use-automq-to-reduce-kafka-cost-and-maintenance-complexity" target="_blank" title="https://www.automq.com/blog/how-asias-quora-zhihu-use-automq-to-reduce-kafka-cost-and-maintenance-complexity" ref="nofollow noopener noreferrer">www.automq.com/blog/how-as…</a>)</p>
<p>- [XPENG Motors Reduces Costs by 50%\+ by Replacing Kafka with AutoMQ](<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.automq.com%2Fblog%2Fxpeng-motors-reduces-costs-by-50-by-replacing-kafka-with-automq" target="_blank" title="https://www.automq.com/blog/xpeng-motors-reduces-costs-by-50-by-replacing-kafka-with-automq" ref="nofollow noopener noreferrer">www.automq.com/blog/xpeng-…</a>)</p>
<p>- [Asia's GOAT, Poizon uses AutoMQ Kafka to build observability platform for massive data\(30 GB/s)](<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.automq.com%2Fblog%2Fasiax27s-goat-poizon-uses-automq-kafka-to-build-a-new-generation-observability-platform-for-massive-data" target="_blank" title="https://www.automq.com/blog/asiax27s-goat-poizon-uses-automq-kafka-to-build-a-new-generation-observability-platform-for-massive-data" ref="nofollow noopener noreferrer">www.automq.com/blog/asiax2…</a>)</p>
<p>- [AutoMQ Helps CaoCao Mobility Address Kafka Scalability During Holidays](<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.automq.com%2Fblog%2Fautomq-helps-caocao-mobility-address-kafka-scalability-issues-during-mid-autumn-and-national-day" target="_blank" title="https://www.automq.com/blog/automq-helps-caocao-mobility-address-kafka-scalability-issues-during-mid-autumn-and-national-day" ref="nofollow noopener noreferrer">www.automq.com/blog/automq…</a>)</p>
<p>- [JD.com](<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.automq.com%2Fblog%2Fjdcom-automq-cubefs-trillion-scale-kafka-messaging)%255C%255B" target="_blank" title="https://www.automq.com/blog/jdcom-automq-cubefs-trillion-scale-kafka-messaging)%5C%5B" ref="nofollow noopener noreferrer">www.automq.com/blog/jdcom-…</a> x AutoMQ x CubeFS: A Cost-Effective Journey at Trillion-Scale Kafka Messaging](<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.automq.com%2Fblog%2Fjdcom-automq-cubefs-trillion-scale-kafka-messaging" target="_blank" title="https://www.automq.com/blog/jdcom-automq-cubefs-trillion-scale-kafka-messaging" ref="nofollow noopener noreferrer">www.automq.com/blog/jdcom-…</a>)</p>
<p>![](./amazon-kinesis-vs-sqs-differences-comparison/3.webp)</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Amazon Kinesis vs. SQS: Differences & Comparison]]></title>    <link>https://juejin.cn/post/7602225961096069154</link>    <guid>https://juejin.cn/post/7602225961096069154</guid>    <pubDate>2026-02-03T10:50:44.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602225961096069154" data-draft-id="7602246300453716003" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Amazon Kinesis vs. SQS: Differences &amp; Comparison"/> <meta itemprop="keywords" content="AWS"/> <meta itemprop="datePublished" content="2026-02-03T10:50:44.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="AutoMQ"/> <meta itemprop="url" content="https://juejin.cn/user/2878958479084707"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Amazon Kinesis vs. SQS: Differences &amp; Comparison
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2878958479084707/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    AutoMQ
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T10:50:44.000Z" title="Tue Feb 03 2026 10:50:44 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p># Amazon Kinesis vs. SQS: Differences &amp; Comparison</p>
<p>## Overview</p>
<p>Amazon Web Services \(AWS) offers multiple messaging and streaming services, with Amazon Kinesis and Amazon Simple Queue Service \(SQS) being two of the most widely used options. While both facilitate data movement between application components, they serve fundamentally different purposes and excel in different scenarios. This comprehensive comparison explores their key differences, use cases, and technical considerations.</p>
<p>Before diving into the detailed comparison, the key finding is that Kinesis is optimized for real-time, high-volume data streaming with multiple consumers, while SQS excels at reliable message queuing for decoupling application components with simpler operational requirements.</p>
<p>## Core Concepts and Architecture</p>
<p>### Amazon Kinesis</p>
<p>Kinesis is a platform for streaming data on AWS, allowing real-time processing of high-volume data streams. It's built on the concept of persistent data streams composed of shards, which represent the base throughput unit.</p>
<p>Key components include:</p>
<p>- **Data Streams** : Core service for capturing and storing streaming data</p>
<p>- **Shards** : Base throughput units \(1MB/sec input, 2MB/sec output per shard)</p>
<p>- **Records** : Data units with partition keys for distribution across shards</p>
<p>- **Retention** : Data persists for 24 hours by default, configurable up to 365 days</p>
<p>![](./amazon-kinesis-vs-sqs-differences-comparison/1.webp)</p>
<p>### Amazon SQS</p>
<p>SQS is a fully managed message queuing service designed to decouple and scale microservices, distributed systems, and serverless applications. It provides a simple queue model with guaranteed at-least-once delivery.</p>
<p>Key components include:</p>
<p>- **Queues** : Standard \(high throughput) or FIFO \(ordered delivery)</p>
<p>- **Messages** : Individual data units \(up to 256KB each)</p>
<p>- **Visibility Timeout** : Period during which messages are invisible after being retrieved</p>
<p>- **Retention** : Messages persist up to 4 days by default, configurable from 1 minute to 14 days</p>
<p>![](./amazon-kinesis-vs-sqs-differences-comparison/2.webp)</p>
<p>## Key Differences</p>
<p>### Purpose and Design Philosophy</p>
<p>| **Aspect**| **Kinesis**| **SQS**|</p>
<p>| - | - | - |</p>
<p>| Primary Purpose| Real-time data streaming and analytics| Message queuing and application decoupling|</p>
<p>| Design Focus| High-volume streaming data processing| Reliable message delivery between components|</p>
<p>| Processing Model| Stream processing with multiple consumers| Queue processing with individual consumers|</p>
<p>| Data Lifecycle| Persistent with configurable retention| Deleted after successful processing|</p>
<p>Kinesis is primarily designed for real-time data streaming applications that need to process and analyze large volumes of continuous data. SQS, on the other hand, focuses on reliable message queuing to decouple application components and ensure message delivery.</p>
<p>### Data Model and Consumption Patterns</p>
<p>Kinesis maintains data streams that can be read by multiple consumers simultaneously, allowing for different applications to process the same data independently. With SQS, each message is typically processed by a single consumer and then deleted from the queue.</p>
<p>### Message Ordering and Delivery Guarantees</p>
<p>Kinesis preserves the ordering of records at the shard level, meaning records with the same partition key will be processed in order. SQS offers two queue types:</p>
<p>- **Standard queues** : High throughput with at-least-once delivery but no guaranteed order</p>
<p>- **FIFO queues** : Exactly-once processing with guaranteed ordering but lower throughput</p>
<p>### Scalability Characteristics</p>
<p>| **Feature**| **Kinesis**| **SQS**|</p>
<p>| - | - | - |</p>
<p>| Scaling Model| Manual provisioning or on-demand| Fully automatic|</p>
<p>| Throughput Limits| 1MB/s in, 2MB/s out per shard| 3,000 msgs/sec standard, 30,000 msgs/sec high throughput|</p>
<p>| Maximum Message Size| 1MB| 256KB|</p>
<p>| Operational Overhead| Higher \(shard management)| Lower \(fully managed)|</p>
<p>Kinesis requires explicit capacity planning through shard provisioning, whereas SQS scales automatically to match demand. However, Kinesis can achieve higher overall throughput with appropriate shard allocation.</p>
<p>## Use Cases</p>
<p>### When to Use Kinesis</p>
<p>- **Real-time Analytics** : Processing streaming data for immediate insights</p>
<p>- **IoT Data Processing** : Handling large-scale data from IoT devices</p>
<p>- **Log and Event Data Collection** : Centralized collection of logs and events</p>
<p>- **Clickstream Analysis** : Processing website user activity in real-time</p>
<p>- **Multiple Consumer Applications** : When multiple applications need to process the same data</p>
<p>### When to Use SQS</p>
<p>- **Application Decoupling** : Separating components of distributed applications</p>
<p>- **Task Queues** : Managing job processing and workload distribution</p>
<p>- **Batch Processing** : Queuing items for batch processing workflows</p>
<p>- **Microservice Communication** : Reliable messaging between microservices</p>
<p>- **Load Leveling** : Smoothing out traffic spikes to backend systems</p>
<p>### Hybrid Approaches</p>
<p>Some architectures benefit from using both services together:</p>
<p>- Using Kinesis for initial high-volume data capture and SQS for specific processing tasks</p>
<p>- Implementing Kinesis for real-time processing and SQS for task distribution to workers</p>
<p>## Implementation Details</p>
<p>### Configuration and Management</p>
<p>#### Kinesis Configuration</p>
<p>```</p>
<p># AWS CLI example for creating a Kinesis stream</p>
<p>aws kinesis create-stream --stream-name MyDataStream --shard-count 5</p>
<p>```</p>
<p>Considerations:</p>
<p>- Shard count determines throughput capacity and cost</p>
<p>- Partition key design affects data distribution across shards</p>
<p>- Enhanced fan-out for high-demand consumers requires explicit configuration</p>
<p>- Consumer applications often use Kinesis Client Library \(KCL) with DynamoDB for checkpointing</p>
<p>#### SQS Configuration</p>
<p>```</p>
<p># AWS CLI example for creating an SQS queue</p>
<p>aws sqs create-queue --queue-name MyQueue --attributes DelaySeconds=0,MaximumMessageSize=262144</p>
<p>```</p>
<p>Considerations:</p>
<p>- Queue type selection \(Standard vs. FIFO) based on ordering requirements</p>
<p>- Appropriate visibility timeout to prevent duplicate processing</p>
<p>- Dead-letter queue configuration for handling failed message processing</p>
<p>- Message retention period based on application requirements</p>
<p>### Integration with AWS Ecosystem</p>
<p>#### Kinesis Integrations</p>
<p>Kinesis integrates seamlessly with many AWS services:</p>
<p>- **Lambda** : For serverless stream processing</p>
<p>- **Firehose** : For delivery to S3, Redshift, Elasticsearch, or Splunk</p>
<p>- **Analytics** : For SQL queries against streaming data</p>
<p>- **Data Warehouse Services** : Direct integration with Redshift and S3</p>
<p>#### SQS Integrations</p>
<p>SQS works well with:</p>
<p>- **Lambda** : Direct invocation when messages arrive</p>
<p>- **EC2/ECS** : For traditional worker patterns</p>
<p>- **Step Functions** : For complex workflows</p>
<p>- **EventBridge** : For event-driven architectures</p>
<p>### Best Practices</p>
<p>#### Kinesis Best Practices</p>
<p>- Use shard-level metrics to monitor performance and identify hotspots</p>
<p>- Monitor IteratorAge metric to prevent data loss from expired iterators</p>
<p>- Implement proper exception handling for "poison messages" that can cause batch failures</p>
<p>- Design partition keys to distribute data evenly across shards</p>
<p>- Consider enhanced fan-out for high-throughput consumers</p>
<p>#### SQS Best Practices</p>
<p>- Configure appropriate visibility timeout based on expected processing time</p>
<p>- Implement dead-letter queues to capture and analyze failed messages</p>
<p>- Use batch operations \(SendMessageBatch, ReceiveMessage with MaxNumberOfMessages) for efficiency</p>
<p>- Implement exponential backoff for handling throttling conditions</p>
<p>- Consider long polling to reduce empty responses and API calls</p>
<p>## Cost and Comparison</p>
<p>### Pricing and Cost Optimization</p>
<p>| **Aspect**| **Kinesis**| **SQS**|</p>
<p>| - | - | - |</p>
<p>| Pricing Model| Pay per shard-hour or on-demand| Pay per million requests|</p>
<p>| Small Volume Cost| Higher cost floor| More cost-effective|</p>
<p>| Large Volume Cost| More efficient at very high throughput| Can become expensive at extreme scales|</p>
<p>| Cost Estimation| Based on shard count and data volume| Based on request count and retention|</p>
<p>At small data volumes \(1GB/day), SQS is significantly less expensive \(<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.20</mn><mi mathvariant="normal">/</mi><mi>m</mi><mi>o</mi><mi>n</mi><mi>t</mi><mi>h</mi><mi>v</mi><mi>s</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">0.20/month vs. </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mord">0.20/</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">s</span><span class="mord">.</span></span></span></span></span>10.82/month for Kinesis). However, as volume increases to 1TB/day, Kinesis becomes more cost-effective \(<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>158</mn><mi mathvariant="normal">/</mi><mi>m</mi><mi>o</mi><mi>n</mi><mi>t</mi><mi>h</mi><mi>v</mi><mi>s</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">158/month vs. </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mord">158/</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">s</span><span class="mord">.</span></span></span></span></span>201/month for SQS).</p>
<p>### Comparison with Alternative Solutions</p>
<p>#### Kinesis vs. Confluent \(Kafka)</p>
<p>| **Aspect**| **Kinesis**| **Confluent**|</p>
<p>| - | - | - |</p>
<p>| Focus| Streaming data service| Complete streaming platform|</p>
<p>| Data Model| Streams &amp; Shards| Distributed commit logs \(topics)|</p>
<p>| Retention| Up to 365 days| Unlimited potential retention|</p>
<p>| Ecosystem| AWS services integration| Rich connector ecosystem|</p>
<p>| Management| Fully managed by AWS| Self-managed or Confluent Cloud|</p>
<p>Confluent offers greater flexibility and unlimited retention compared to Kinesis' maximum 365-day retention. However, Kinesis provides tighter integration with AWS services and lower operational overhead.</p>
<p>#### Kinesis vs. Redpanda</p>
<p>Redpanda offers higher performance than Kinesis with fewer resources due to its C\+\+ foundation and efficient design. It excels in self-hosted environments with three times fewer nodes than traditional Kafka setups. However, Kinesis benefits from being a fully managed AWS service with automatic scaling and tight AWS ecosystem integration.</p>
<p>## Decision Framework</p>
<p>When choosing between these services, consider:</p>
<p>1. **Data Characteristics** :</p>
<p>    - Volume: High-volume streaming data favors Kinesis</p>
<p>    - Ordering: If strict ordering is required, use Kinesis or SQS FIFO</p>
<p>    - Retention: Long retention needs favor Kinesis</p>
<p>2. **Consumption Pattern** :</p>
<p>    - Single consumer: SQS is simpler</p>
<p>    - Multiple consumers: Kinesis allows multiple applications to process the same data</p>
<p>3. **Operational Preferences** :</p>
<p>    - Fully managed with minimal configuration: SQS</p>
<p>    - Control over scaling and processing: Kinesis</p>
<p>4. **Integration Requirements** :</p>
<p>    - Deep AWS integration: Both work well</p>
<p>    - Event-driven architectures: SQS often simpler</p>
<p>    - Real-time analytics pipeline: Kinesis preferred</p>
<p>## Conclusion</p>
<p>Amazon Kinesis and SQS serve different but complementary purposes in distributed architectures. Kinesis excels at high-volume, real-time data streaming with multiple consumers, while SQS provides simple, reliable message queuing for decoupling application components.</p>
<p>Many modern architectures leverage both: Kinesis for capturing and processing high-volume streaming data and SQS for reliable task distribution and application decoupling. Understanding their distinct characteristics and selecting the right service \(or combination) for your specific use case is essential for building efficient, scalable, and cost-effective cloud-native applications.</p>
<p>If you find this content helpful, you might also be interested in our product [AutoMQ](<a href="https://link.juejin.cn?target=https%3A%2F%2Fautomq.com%2F" target="_blank" title="https://automq.com/" ref="nofollow noopener noreferrer">automq.com/</a>). AutoMQ is a cloud-native alternative to Kafka by decoupling durability to S3 and EBS. 10x Cost-Effective. No Cross-AZ Traffic Cost. Autoscale in seconds. Single-digit ms latency. AutoMQ now is [source code available](<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FAutoMQ%2Fautomq" target="_blank" title="https://github.com/AutoMQ/automq" ref="nofollow noopener noreferrer">github.com/AutoMQ/auto…</a>) on github. Big Companies Worldwide are Using AutoMQ. Check the following case studies to learn more:</p>
<p>- [Grab: Driving Efficiency with AutoMQ in DataStreaming Platform](<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DIB8sh639Rsg" target="_blank" title="https://www.youtube.com/watch?v=IB8sh639Rsg" ref="nofollow noopener noreferrer">www.youtube.com/watch?v=IB8…</a>)</p>
<p>- [Palmpay Uses AutoMQ to Replace Kafka, Optimizing Costs by 50%\+](<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.automq.com%2Fblog%2Fpalmpay-uses-automq-to-replace-kafka" target="_blank" title="https://www.automq.com/blog/palmpay-uses-automq-to-replace-kafka" ref="nofollow noopener noreferrer">www.automq.com/blog/palmpa…</a>)</p>
<p>- [AutoMQ help Geely Auto\(Fortune Global 500) solve the pain points of Kafka elasticity in the V2X scenario](<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.automq.com%2Fblog%2Fautomq-help-geely-auto-solve-the-pain-points-of-kafka-elasticity-in-the-v2x-scenario" target="_blank" title="https://www.automq.com/blog/automq-help-geely-auto-solve-the-pain-points-of-kafka-elasticity-in-the-v2x-scenario" ref="nofollow noopener noreferrer">www.automq.com/blog/automq…</a>)</p>
<p>- [How Asia’s Quora Zhihu uses AutoMQ to reduce Kafka cost and maintenance complexity](<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.automq.com%2Fblog%2Fhow-asias-quora-zhihu-use-automq-to-reduce-kafka-cost-and-maintenance-complexity" target="_blank" title="https://www.automq.com/blog/how-asias-quora-zhihu-use-automq-to-reduce-kafka-cost-and-maintenance-complexity" ref="nofollow noopener noreferrer">www.automq.com/blog/how-as…</a>)</p>
<p>- [XPENG Motors Reduces Costs by 50%\+ by Replacing Kafka with AutoMQ](<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.automq.com%2Fblog%2Fxpeng-motors-reduces-costs-by-50-by-replacing-kafka-with-automq" target="_blank" title="https://www.automq.com/blog/xpeng-motors-reduces-costs-by-50-by-replacing-kafka-with-automq" ref="nofollow noopener noreferrer">www.automq.com/blog/xpeng-…</a>)</p>
<p>- [Asia's GOAT, Poizon uses AutoMQ Kafka to build observability platform for massive data\(30 GB/s)](<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.automq.com%2Fblog%2Fasiax27s-goat-poizon-uses-automq-kafka-to-build-a-new-generation-observability-platform-for-massive-data" target="_blank" title="https://www.automq.com/blog/asiax27s-goat-poizon-uses-automq-kafka-to-build-a-new-generation-observability-platform-for-massive-data" ref="nofollow noopener noreferrer">www.automq.com/blog/asiax2…</a>)</p>
<p>- [AutoMQ Helps CaoCao Mobility Address Kafka Scalability During Holidays](<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.automq.com%2Fblog%2Fautomq-helps-caocao-mobility-address-kafka-scalability-issues-during-mid-autumn-and-national-day" target="_blank" title="https://www.automq.com/blog/automq-helps-caocao-mobility-address-kafka-scalability-issues-during-mid-autumn-and-national-day" ref="nofollow noopener noreferrer">www.automq.com/blog/automq…</a>)</p>
<p>- [JD.com](<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.automq.com%2Fblog%2Fjdcom-automq-cubefs-trillion-scale-kafka-messaging)%255C%255B" target="_blank" title="https://www.automq.com/blog/jdcom-automq-cubefs-trillion-scale-kafka-messaging)%5C%5B" ref="nofollow noopener noreferrer">www.automq.com/blog/jdcom-…</a> x AutoMQ x CubeFS: A Cost-Effective Journey at Trillion-Scale Kafka Messaging](<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.automq.com%2Fblog%2Fjdcom-automq-cubefs-trillion-scale-kafka-messaging" target="_blank" title="https://www.automq.com/blog/jdcom-automq-cubefs-trillion-scale-kafka-messaging" ref="nofollow noopener noreferrer">www.automq.com/blog/jdcom-…</a>)</p>
<p>![](./amazon-kinesis-vs-sqs-differences-comparison/3.webp)</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Amazon Kinesis vs. SQS: Differences & Comparison]]></title>    <link>https://juejin.cn/post/7602188264115388431</link>    <guid>https://juejin.cn/post/7602188264115388431</guid>    <pubDate>2026-02-03T10:52:22.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602188264115388431" data-draft-id="7602246300453732387" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Amazon Kinesis vs. SQS: Differences &amp; Comparison"/> <meta itemprop="keywords" content="AWS"/> <meta itemprop="datePublished" content="2026-02-03T10:52:22.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="AutoMQ"/> <meta itemprop="url" content="https://juejin.cn/user/2878958479084707"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Amazon Kinesis vs. SQS: Differences &amp; Comparison
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2878958479084707/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    AutoMQ
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T10:52:22.000Z" title="Tue Feb 03 2026 10:52:22 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p># Amazon Kinesis vs. SQS: Differences &amp; Comparison</p>
<p>## Overview</p>
<p>Amazon Web Services \(AWS) offers multiple messaging and streaming services, with Amazon Kinesis and Amazon Simple Queue Service \(SQS) being two of the most widely used options. While both facilitate data movement between application components, they serve fundamentally different purposes and excel in different scenarios. This comprehensive comparison explores their key differences, use cases, and technical considerations.</p>
<p>Before diving into the detailed comparison, the key finding is that Kinesis is optimized for real-time, high-volume data streaming with multiple consumers, while SQS excels at reliable message queuing for decoupling application components with simpler operational requirements.</p>
<p>## Core Concepts and Architecture</p>
<p>### Amazon Kinesis</p>
<p>Kinesis is a platform for streaming data on AWS, allowing real-time processing of high-volume data streams. It's built on the concept of persistent data streams composed of shards, which represent the base throughput unit.</p>
<p>Key components include:</p>
<p>- **Data Streams** : Core service for capturing and storing streaming data</p>
<p>- **Shards** : Base throughput units \(1MB/sec input, 2MB/sec output per shard)</p>
<p>- **Records** : Data units with partition keys for distribution across shards</p>
<p>- **Retention** : Data persists for 24 hours by default, configurable up to 365 days</p>
<p>![](./amazon-kinesis-vs-sqs-differences-comparison/1.webp)</p>
<p>### Amazon SQS</p>
<p>SQS is a fully managed message queuing service designed to decouple and scale microservices, distributed systems, and serverless applications. It provides a simple queue model with guaranteed at-least-once delivery.</p>
<p>Key components include:</p>
<p>- **Queues** : Standard \(high throughput) or FIFO \(ordered delivery)</p>
<p>- **Messages** : Individual data units \(up to 256KB each)</p>
<p>- **Visibility Timeout** : Period during which messages are invisible after being retrieved</p>
<p>- **Retention** : Messages persist up to 4 days by default, configurable from 1 minute to 14 days</p>
<p>![](./amazon-kinesis-vs-sqs-differences-comparison/2.webp)</p>
<p>## Key Differences</p>
<p>### Purpose and Design Philosophy</p>
<p>| **Aspect**| **Kinesis**| **SQS**|</p>
<p>| - | - | - |</p>
<p>| Primary Purpose| Real-time data streaming and analytics| Message queuing and application decoupling|</p>
<p>| Design Focus| High-volume streaming data processing| Reliable message delivery between components|</p>
<p>| Processing Model| Stream processing with multiple consumers| Queue processing with individual consumers|</p>
<p>| Data Lifecycle| Persistent with configurable retention| Deleted after successful processing|</p>
<p>Kinesis is primarily designed for real-time data streaming applications that need to process and analyze large volumes of continuous data. SQS, on the other hand, focuses on reliable message queuing to decouple application components and ensure message delivery.</p>
<p>### Data Model and Consumption Patterns</p>
<p>Kinesis maintains data streams that can be read by multiple consumers simultaneously, allowing for different applications to process the same data independently. With SQS, each message is typically processed by a single consumer and then deleted from the queue.</p>
<p>### Message Ordering and Delivery Guarantees</p>
<p>Kinesis preserves the ordering of records at the shard level, meaning records with the same partition key will be processed in order. SQS offers two queue types:</p>
<p>- **Standard queues** : High throughput with at-least-once delivery but no guaranteed order</p>
<p>- **FIFO queues** : Exactly-once processing with guaranteed ordering but lower throughput</p>
<p>### Scalability Characteristics</p>
<p>| **Feature**| **Kinesis**| **SQS**|</p>
<p>| - | - | - |</p>
<p>| Scaling Model| Manual provisioning or on-demand| Fully automatic|</p>
<p>| Throughput Limits| 1MB/s in, 2MB/s out per shard| 3,000 msgs/sec standard, 30,000 msgs/sec high throughput|</p>
<p>| Maximum Message Size| 1MB| 256KB|</p>
<p>| Operational Overhead| Higher \(shard management)| Lower \(fully managed)|</p>
<p>Kinesis requires explicit capacity planning through shard provisioning, whereas SQS scales automatically to match demand. However, Kinesis can achieve higher overall throughput with appropriate shard allocation.</p>
<p>## Use Cases</p>
<p>### When to Use Kinesis</p>
<p>- **Real-time Analytics** : Processing streaming data for immediate insights</p>
<p>- **IoT Data Processing** : Handling large-scale data from IoT devices</p>
<p>- **Log and Event Data Collection** : Centralized collection of logs and events</p>
<p>- **Clickstream Analysis** : Processing website user activity in real-time</p>
<p>- **Multiple Consumer Applications** : When multiple applications need to process the same data</p>
<p>### When to Use SQS</p>
<p>- **Application Decoupling** : Separating components of distributed applications</p>
<p>- **Task Queues** : Managing job processing and workload distribution</p>
<p>- **Batch Processing** : Queuing items for batch processing workflows</p>
<p>- **Microservice Communication** : Reliable messaging between microservices</p>
<p>- **Load Leveling** : Smoothing out traffic spikes to backend systems</p>
<p>### Hybrid Approaches</p>
<p>Some architectures benefit from using both services together:</p>
<p>- Using Kinesis for initial high-volume data capture and SQS for specific processing tasks</p>
<p>- Implementing Kinesis for real-time processing and SQS for task distribution to workers</p>
<p>## Implementation Details</p>
<p>### Configuration and Management</p>
<p>#### Kinesis Configuration</p>
<p>```</p>
<p># AWS CLI example for creating a Kinesis stream</p>
<p>aws kinesis create-stream --stream-name MyDataStream --shard-count 5</p>
<p>```</p>
<p>Considerations:</p>
<p>- Shard count determines throughput capacity and cost</p>
<p>- Partition key design affects data distribution across shards</p>
<p>- Enhanced fan-out for high-demand consumers requires explicit configuration</p>
<p>- Consumer applications often use Kinesis Client Library \(KCL) with DynamoDB for checkpointing</p>
<p>#### SQS Configuration</p>
<p>```</p>
<p># AWS CLI example for creating an SQS queue</p>
<p>aws sqs create-queue --queue-name MyQueue --attributes DelaySeconds=0,MaximumMessageSize=262144</p>
<p>```</p>
<p>Considerations:</p>
<p>- Queue type selection \(Standard vs. FIFO) based on ordering requirements</p>
<p>- Appropriate visibility timeout to prevent duplicate processing</p>
<p>- Dead-letter queue configuration for handling failed message processing</p>
<p>- Message retention period based on application requirements</p>
<p>### Integration with AWS Ecosystem</p>
<p>#### Kinesis Integrations</p>
<p>Kinesis integrates seamlessly with many AWS services:</p>
<p>- **Lambda** : For serverless stream processing</p>
<p>- **Firehose** : For delivery to S3, Redshift, Elasticsearch, or Splunk</p>
<p>- **Analytics** : For SQL queries against streaming data</p>
<p>- **Data Warehouse Services** : Direct integration with Redshift and S3</p>
<p>#### SQS Integrations</p>
<p>SQS works well with:</p>
<p>- **Lambda** : Direct invocation when messages arrive</p>
<p>- **EC2/ECS** : For traditional worker patterns</p>
<p>- **Step Functions** : For complex workflows</p>
<p>- **EventBridge** : For event-driven architectures</p>
<p>### Best Practices</p>
<p>#### Kinesis Best Practices</p>
<p>- Use shard-level metrics to monitor performance and identify hotspots</p>
<p>- Monitor IteratorAge metric to prevent data loss from expired iterators</p>
<p>- Implement proper exception handling for "poison messages" that can cause batch failures</p>
<p>- Design partition keys to distribute data evenly across shards</p>
<p>- Consider enhanced fan-out for high-throughput consumers</p>
<p>#### SQS Best Practices</p>
<p>- Configure appropriate visibility timeout based on expected processing time</p>
<p>- Implement dead-letter queues to capture and analyze failed messages</p>
<p>- Use batch operations \(SendMessageBatch, ReceiveMessage with MaxNumberOfMessages) for efficiency</p>
<p>- Implement exponential backoff for handling throttling conditions</p>
<p>- Consider long polling to reduce empty responses and API calls</p>
<p>## Cost and Comparison</p>
<p>### Pricing and Cost Optimization</p>
<p>| **Aspect**| **Kinesis**| **SQS**|</p>
<p>| - | - | - |</p>
<p>| Pricing Model| Pay per shard-hour or on-demand| Pay per million requests|</p>
<p>| Small Volume Cost| Higher cost floor| More cost-effective|</p>
<p>| Large Volume Cost| More efficient at very high throughput| Can become expensive at extreme scales|</p>
<p>| Cost Estimation| Based on shard count and data volume| Based on request count and retention|</p>
<p>At small data volumes \(1GB/day), SQS is significantly less expensive \(<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.20</mn><mi mathvariant="normal">/</mi><mi>m</mi><mi>o</mi><mi>n</mi><mi>t</mi><mi>h</mi><mi>v</mi><mi>s</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">0.20/month vs. </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mord">0.20/</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">s</span><span class="mord">.</span></span></span></span></span>10.82/month for Kinesis). However, as volume increases to 1TB/day, Kinesis becomes more cost-effective \(<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>158</mn><mi mathvariant="normal">/</mi><mi>m</mi><mi>o</mi><mi>n</mi><mi>t</mi><mi>h</mi><mi>v</mi><mi>s</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">158/month vs. </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mord">158/</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">s</span><span class="mord">.</span></span></span></span></span>201/month for SQS).</p>
<p>### Comparison with Alternative Solutions</p>
<p>#### Kinesis vs. Confluent \(Kafka)</p>
<p>| **Aspect**| **Kinesis**| **Confluent**|</p>
<p>| - | - | - |</p>
<p>| Focus| Streaming data service| Complete streaming platform|</p>
<p>| Data Model| Streams &amp; Shards| Distributed commit logs \(topics)|</p>
<p>| Retention| Up to 365 days| Unlimited potential retention|</p>
<p>| Ecosystem| AWS services integration| Rich connector ecosystem|</p>
<p>| Management| Fully managed by AWS| Self-managed or Confluent Cloud|</p>
<p>Confluent offers greater flexibility and unlimited retention compared to Kinesis' maximum 365-day retention. However, Kinesis provides tighter integration with AWS services and lower operational overhead.</p>
<p>#### Kinesis vs. Redpanda</p>
<p>Redpanda offers higher performance than Kinesis with fewer resources due to its C\+\+ foundation and efficient design. It excels in self-hosted environments with three times fewer nodes than traditional Kafka setups. However, Kinesis benefits from being a fully managed AWS service with automatic scaling and tight AWS ecosystem integration.</p>
<p>## Decision Framework</p>
<p>When choosing between these services, consider:</p>
<p>1. **Data Characteristics** :</p>
<p>    - Volume: High-volume streaming data favors Kinesis</p>
<p>    - Ordering: If strict ordering is required, use Kinesis or SQS FIFO</p>
<p>    - Retention: Long retention needs favor Kinesis</p>
<p>2. **Consumption Pattern** :</p>
<p>    - Single consumer: SQS is simpler</p>
<p>    - Multiple consumers: Kinesis allows multiple applications to process the same data</p>
<p>3. **Operational Preferences** :</p>
<p>    - Fully managed with minimal configuration: SQS</p>
<p>    - Control over scaling and processing: Kinesis</p>
<p>4. **Integration Requirements** :</p>
<p>    - Deep AWS integration: Both work well</p>
<p>    - Event-driven architectures: SQS often simpler</p>
<p>    - Real-time analytics pipeline: Kinesis preferred</p>
<p>## Conclusion</p>
<p>Amazon Kinesis and SQS serve different but complementary purposes in distributed architectures. Kinesis excels at high-volume, real-time data streaming with multiple consumers, while SQS provides simple, reliable message queuing for decoupling application components.</p>
<p>Many modern architectures leverage both: Kinesis for capturing and processing high-volume streaming data and SQS for reliable task distribution and application decoupling. Understanding their distinct characteristics and selecting the right service \(or combination) for your specific use case is essential for building efficient, scalable, and cost-effective cloud-native applications.</p>
<p>If you find this content helpful, you might also be interested in our product [AutoMQ](<a href="https://link.juejin.cn?target=https%3A%2F%2Fautomq.com%2F" target="_blank" title="https://automq.com/" ref="nofollow noopener noreferrer">automq.com/</a>). AutoMQ is a cloud-native alternative to Kafka by decoupling durability to S3 and EBS. 10x Cost-Effective. No Cross-AZ Traffic Cost. Autoscale in seconds. Single-digit ms latency. AutoMQ now is [source code available](<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FAutoMQ%2Fautomq" target="_blank" title="https://github.com/AutoMQ/automq" ref="nofollow noopener noreferrer">github.com/AutoMQ/auto…</a>) on github. Big Companies Worldwide are Using AutoMQ. Check the following case studies to learn more:</p>
<p>- [Grab: Driving Efficiency with AutoMQ in DataStreaming Platform](<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DIB8sh639Rsg" target="_blank" title="https://www.youtube.com/watch?v=IB8sh639Rsg" ref="nofollow noopener noreferrer">www.youtube.com/watch?v=IB8…</a>)</p>
<p>- [Palmpay Uses AutoMQ to Replace Kafka, Optimizing Costs by 50%\+](<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.automq.com%2Fblog%2Fpalmpay-uses-automq-to-replace-kafka" target="_blank" title="https://www.automq.com/blog/palmpay-uses-automq-to-replace-kafka" ref="nofollow noopener noreferrer">www.automq.com/blog/palmpa…</a>)</p>
<p>- [AutoMQ help Geely Auto\(Fortune Global 500) solve the pain points of Kafka elasticity in the V2X scenario](<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.automq.com%2Fblog%2Fautomq-help-geely-auto-solve-the-pain-points-of-kafka-elasticity-in-the-v2x-scenario" target="_blank" title="https://www.automq.com/blog/automq-help-geely-auto-solve-the-pain-points-of-kafka-elasticity-in-the-v2x-scenario" ref="nofollow noopener noreferrer">www.automq.com/blog/automq…</a>)</p>
<p>- [How Asia’s Quora Zhihu uses AutoMQ to reduce Kafka cost and maintenance complexity](<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.automq.com%2Fblog%2Fhow-asias-quora-zhihu-use-automq-to-reduce-kafka-cost-and-maintenance-complexity" target="_blank" title="https://www.automq.com/blog/how-asias-quora-zhihu-use-automq-to-reduce-kafka-cost-and-maintenance-complexity" ref="nofollow noopener noreferrer">www.automq.com/blog/how-as…</a>)</p>
<p>- [XPENG Motors Reduces Costs by 50%\+ by Replacing Kafka with AutoMQ](<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.automq.com%2Fblog%2Fxpeng-motors-reduces-costs-by-50-by-replacing-kafka-with-automq" target="_blank" title="https://www.automq.com/blog/xpeng-motors-reduces-costs-by-50-by-replacing-kafka-with-automq" ref="nofollow noopener noreferrer">www.automq.com/blog/xpeng-…</a>)</p>
<p>- [Asia's GOAT, Poizon uses AutoMQ Kafka to build observability platform for massive data\(30 GB/s)](<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.automq.com%2Fblog%2Fasiax27s-goat-poizon-uses-automq-kafka-to-build-a-new-generation-observability-platform-for-massive-data" target="_blank" title="https://www.automq.com/blog/asiax27s-goat-poizon-uses-automq-kafka-to-build-a-new-generation-observability-platform-for-massive-data" ref="nofollow noopener noreferrer">www.automq.com/blog/asiax2…</a>)</p>
<p>- [AutoMQ Helps CaoCao Mobility Address Kafka Scalability During Holidays](<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.automq.com%2Fblog%2Fautomq-helps-caocao-mobility-address-kafka-scalability-issues-during-mid-autumn-and-national-day" target="_blank" title="https://www.automq.com/blog/automq-helps-caocao-mobility-address-kafka-scalability-issues-during-mid-autumn-and-national-day" ref="nofollow noopener noreferrer">www.automq.com/blog/automq…</a>)</p>
<p>- [JD.com](<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.automq.com%2Fblog%2Fjdcom-automq-cubefs-trillion-scale-kafka-messaging)%255C%255B" target="_blank" title="https://www.automq.com/blog/jdcom-automq-cubefs-trillion-scale-kafka-messaging)%5C%5B" ref="nofollow noopener noreferrer">www.automq.com/blog/jdcom-…</a> x AutoMQ x CubeFS: A Cost-Effective Journey at Trillion-Scale Kafka Messaging](<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.automq.com%2Fblog%2Fjdcom-automq-cubefs-trillion-scale-kafka-messaging" target="_blank" title="https://www.automq.com/blog/jdcom-automq-cubefs-trillion-scale-kafka-messaging" ref="nofollow noopener noreferrer">www.automq.com/blog/jdcom-…</a>)</p>
<p>![](./amazon-kinesis-vs-sqs-differences-comparison/3.webp)</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[用 AgentScope Java 开家 AI 奶茶店]]></title>    <link>https://juejin.cn/post/7602057555451822134</link>    <guid>https://juejin.cn/post/7602057555451822134</guid>    <pubDate>2026-02-02T07:17:41.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602057555451822134" data-draft-id="7601728622824898603" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="用 AgentScope Java 开家 AI 奶茶店"/> <meta itemprop="keywords" content="Agent"/> <meta itemprop="datePublished" content="2026-02-02T07:17:41.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="阿里云云原生"/> <meta itemprop="url" content="https://juejin.cn/user/3808363977648493"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            用 AgentScope Java 开家 AI 奶茶店
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3808363977648493/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    阿里云云原生
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-02T07:17:41.000Z" title="Mon Feb 02 2026 07:17:41 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-02
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读9分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>作者：屿山</p>
<p>AgentScope 是阿里云推出的一款以开发者为核心，专注于智能体开发的开源框架 <strong>。</strong> 它的核心目标是解决智能体在构建、运行和管理中的难题，提供一套覆盖“开发、部署、调优”全生命周期的生产级解决方案，让智能体应用的开发更简单、运行更稳定、效果持续优化。</p>
<h2 data-id="heading-0">前言</h2>
<p>去年 12 月份，社区正式发布了 AgentScope Java 1.0 版本，面向 Java 开发者提供企业级 Agentic 应用构建的能力。在过去的一个多月，社区快速迭代到了 1.0.7 版本，在这 7 个小版本中，我们更新了很多实用的能力，比如：</p>
<ul>
<li>添加全面的 Ollama 集成，支持聊天和 embedding 功能</li>
<li>新增了对 Agent Skill 的支持</li>
<li>内置的文件操作工具和多模态工具</li>
<li>工具调用 HITL </li>
<li>上下文自动压缩</li>
<li>HTTP 请求和响应内容压缩</li>
<li>MySQL 会话存储</li>
<li>集成 Nacos 的 A2A 架构</li>
<li>集成 Higress 的工具搜索</li>
<li>……</li>
</ul>
<p>至此 AgentScope Java 以 ReActAgent 为核心，配合众多强大的能力，已经能够胜任大多数场景的任务。面对如此多的能力，很多同学在社区反馈光看文档和单一功能的 Example 还是不够效率，不能快速地用好这些能力。为此我们用 AgentScope Java 开了一家奶茶店，来作为一个综合的 Example，为大家演示如何更好地使用 AgentScope Java。</p>
<h2 data-id="heading-1">这家店能干啥？</h2>
<p>首先我们先一起看看这家店能干啥：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/16d7969383f640c1aa2087a4d22f8586~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770621461&amp;x-signature=cdkj6EWfzYlJTaC0lxKBwHZxVmM%3D" alt="image.png" loading="lazy"/></p>
<ul>
<li><strong>奶茶推荐</strong>：基于 RAG 知识库检索并结合用户偏好分析，回答有理有据，猜你喜欢。</li>
<li><strong>智能下单</strong>：不需要繁琐的表单，自然语言直接下单，Agent 自动识别产品、甜度、冰量。</li>
<li><strong>订单查询 &amp; 用户反馈</strong>：查单、投诉、建议，一站式搞定。</li>
<li><strong>记住你的喜好</strong>：集成 Mem0 长期记忆服务，熟客无须多言，做更懂你的奶茶店。</li>
</ul>
<h2 data-id="heading-2">这家店怎么做的？</h2>
<h3 data-id="heading-3">架构解析</h3>
<p>首先在总体结构上我们采用了 <strong>Supervisor-Worker</strong> 架构，同时集成了一些生态组件来达到最终的效果。</p>
<p>其中 AgentScope 多智能体服务层是由一个 Supervisor Agent 和两个 Sub Agent 构成的智能体系统，负责处理店内大大小小的事项；MCP Server 负责处理具体的业务逻辑，可以直接基于传统的业务系统改造；Nacos 负责 Agent 和 MCP 的动态注册和发现；数据持久层负责数据的持久化，包括知识库、会话、记忆、业务数据等。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/32f07a081f16470a8cde91ea6c40f043~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770621461&amp;x-signature=9UIuRmMm9XisBgZ9cIEvtmymA6w%3D" alt="image.png" loading="lazy"/></p>
<p>接下来我们一点一点地来拆解这家店，特别是多智能体服务层。</p>
<ul>
<li><strong>Supervisor Agent</strong>：相当于门店经理，负责接待客户，判断客户意图（点单？咨询？投诉？），然后把活派给对应的子 Agent。</li>
<li><strong>Business Sub Agent</strong>：勤劳的店员，专门处理订单创建、查询、修改以及投诉等业务事项。</li>
<li><strong>Consult Sub Agent</strong>：贴心的客服，接入了 RAG 知识库，能够进行产品推荐，问啥答啥。</li>
</ul>
<h3 data-id="heading-4">能力解析</h3>
<p>在这一部分我们来介绍为了实现上述的效果，我们要用到哪些能力，以及要如何进行开发。当然这边我们只能展示一些关键部分的代码片段，完整实现可以移步 agentscope-java/agentscope-examples/boba-tea-shop <strong>[</strong> <strong>1]</strong> 。</p>
<h4 data-id="heading-5">ReActAgent：能思考会行动</h4>
<p>为了能处理店内大大小小的事项，我们就需要一个能思考会行动的 Agent，而一个符合 Reasoning and Acting 范式的 Agent 能很好地完成这个任务。为了构建这个 Agent 如果不借助框架的话我们需要至少完成以下事项：</p>
<ul>
<li>对接适配各个模型厂商的 API</li>
<li>构建 Reasoning 和 Acting 调用的循环</li>
<li>支持工具的注册和调用</li>
</ul>
<p>而在 AgentScope Java 中我们只需要进行一些配置便可以组装出一个 ReActAgent，由 AgentScope 完成上述的事项，同时我们原生支持了多家厂商的协议，包括 DashScope、Anthropic、Gemini、OpenAI。</p>
<pre><code class="hljs language-scss" lang="scss">DashScopeChatModel<span class="hljs-selector-class">.Builder</span> builder =
    DashScopeChatModel<span class="hljs-selector-class">.builder</span>()
            <span class="hljs-selector-class">.apiKey</span>(dashscopeApiKey)
            <span class="hljs-selector-class">.modelName</span>(dashscopeModelName)
            <span class="hljs-selector-class">.formatter</span>(new DashScopeChatFormatter());
DashScopeChatModel model = builder<span class="hljs-selector-class">.build</span>();
ReActAgent agent = ReActAgent<span class="hljs-selector-class">.builder</span>()
    <span class="hljs-selector-class">.name</span>("supervisor_agent")
    <span class="hljs-selector-class">.sysPrompt</span>(sysPrompt)
    <span class="hljs-selector-class">.toolkit</span>(toolkit)      <span class="hljs-comment">// 挂载工具</span>
    <span class="hljs-selector-class">.model</span>(model)          <span class="hljs-comment">// 配置大模型</span>
    <span class="hljs-selector-class">.memory</span>(memory)        <span class="hljs-comment">// 短期记忆模块</span>
    <span class="hljs-selector-class">.longTermMemory</span>(longTermMemory)  <span class="hljs-comment">//长期记忆模块</span>
    <span class="hljs-selector-class">.build</span>();
</code></pre>
<h4 data-id="heading-6">集成 Nacos 的 A2A 架构：专业的事情让专业的 Agent 来做</h4>
<p>当我们对 AI 应用的需求从单一的对话交互转向复杂的现实世界问题解决，单体智能系统（Single-Agent Systems）的局限性日益凸显。</p>
<ul>
<li>上下文窗口大小和注意力稀释</li>
<li>幻觉难以自我觉察和纠正</li>
<li>专业化能力不足</li>
<li>……</li>
</ul>
<p>为了解决这些问题大家都在逐步探索多智能体架构，我们也借奶茶店这个场景为大家演示如何用 AgentScope Java 开发多智能体系统中 Agent AS Tool 的模式。为了实现这个效果，我们原本需要基于 A2A Java SDK 来构建对应的 Client 和 Server，同时还需要进行一些事件和通讯的适配与对接，繁碎的同时还没有动态注册发现的能力。</p>
<p>所以为了更加便捷地落地 A2A 架构，AgentScope 提供了 A2A extension 来完成 A2A Java SDK 适配和对接，并且集成了 Nacos 来实现动态的 Agent 注册和发现。于是现在在 AgentScope Java 中只需要少量代码就可以完成 A2A 架构的落地。</p>
<p>首先是子 Agent 的注册，只需要定义客制化的内容即可，主要是子 Agent 自身所需要的模型、工具等组件的配置，其他部分由框架搞定。</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-keyword">@Bean</span>
public AgentRunner agentRunner(
        AgentPromptConfig promptConfig,
        ConsultTools consultTools,
        Knowledge knowledge,
        Model model) {
    Toolkit toolkit = new <span class="hljs-built_in">NacosToolkit</span>();
    toolkit<span class="hljs-selector-class">.registerTool</span>(consultTools);
    AutoContextConfig autoContextConfig =
            AutoContextConfig<span class="hljs-selector-class">.builder</span>()<span class="hljs-selector-class">.tokenRatio</span>(<span class="hljs-number">0.4</span>)<span class="hljs-selector-class">.lastKeep</span>(<span class="hljs-number">10</span>)<span class="hljs-selector-class">.build</span>();
    <span class="hljs-comment">// Use AutoContextMemory, support context auto compression</span>
    AutoContextMemory memory = new <span class="hljs-built_in">AutoContextMemory</span>(autoContextConfig, model);
    ReActAgent<span class="hljs-selector-class">.Builder</span> builder =
            ReActAgent<span class="hljs-selector-class">.builder</span>()
                    <span class="hljs-selector-class">.name</span>("consult_agent")
                    <span class="hljs-selector-class">.sysPrompt</span>(promptConfig.getConsultAgentInstruction())
                    <span class="hljs-selector-class">.memory</span>(memory)
                    <span class="hljs-selector-class">.hooks</span>(List.of(new MonitoringHook()))
                    <span class="hljs-selector-class">.model</span>(model)
                    <span class="hljs-selector-class">.toolkit</span>(toolkit)
                    <span class="hljs-selector-class">.knowledge</span>(knowledge)
                    <span class="hljs-selector-class">.ragMode</span>(RAGMode.AGENTIC);
    return new <span class="hljs-built_in">CustomAgentRunner</span>(builder);
}
</code></pre>
<p>而对于 Supervisor Agent 来说由于集成了 Nacos，只需要构建一个 AiService 然后做一些简单的配置就可以完成子 Agent 的发现。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Bean</span>
<span class="hljs-keyword">public</span> AiService <span class="hljs-title function_">nacosA2aService</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> NacosException {
    <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();
    properties.put(PropertyKeyConst.SERVER_ADDR, serverAddress);
    properties.put(PropertyKeyConst.NAMESPACE, namespace);
    <span class="hljs-keyword">return</span> AiFactory.createAiService(properties);
}
<span class="hljs-meta">@Bean</span>
<span class="hljs-keyword">public</span> A2aAgent <span class="hljs-title function_">consultAgent</span><span class="hljs-params">(AiService a2aService)</span> {
    <span class="hljs-keyword">return</span> A2aAgent.builder()
            .name(<span class="hljs-string">"consult_agent"</span>)
            .agentCardResolver(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NacosAgentCardResolver</span>(a2aService))
            .build();
}
</code></pre>
<p>然后再把子 Agent 注册成一个工具，便可以像使用普通工具一样调用子 Agent。</p>
<pre><code class="hljs language-less" lang="less"><span class="hljs-variable">@Tool</span>(description =
    <span class="hljs-string">"Agent for handling consultation-related requests, can process all"</span>
        + <span class="hljs-string">" consultation-related requests, requires passing the complete context in"</span>
        + <span class="hljs-string">" the context parameter"</span>)
public String <span class="hljs-built_in">callConsultAgent</span>(
        <span class="hljs-variable">@ToolParam</span>(name = <span class="hljs-string">"context"</span>, description = <span class="hljs-string">"Complete context"</span>) String context,
        <span class="hljs-variable">@ToolParam</span>(name = <span class="hljs-string">"userId"</span>, description = <span class="hljs-string">"User's UserId"</span>) String userId) {
    <span class="hljs-selector-tag">Msg</span> <span class="hljs-selector-tag">msg</span> = <span class="hljs-selector-tag">Msg</span><span class="hljs-selector-class">.builder</span>()<span class="hljs-selector-class">.content</span>(TextBlock.<span class="hljs-built_in">builder</span>().<span class="hljs-built_in">text</span>(context).<span class="hljs-built_in">build</span>())<span class="hljs-selector-class">.build</span>();
    <span class="hljs-selector-tag">A2aAgent</span> <span class="hljs-selector-tag">consultAgent</span> = <span class="hljs-selector-tag">consultAgentProvider</span><span class="hljs-selector-class">.getObject</span>();
    <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">combineAgentResponse</span>(consultAgent.<span class="hljs-built_in">call</span>(msg).<span class="hljs-built_in">block</span>());
}
</code></pre>
<h4 data-id="heading-7">集成 Nacos 的 MCP 调用：动态注册&amp;发现</h4>
<p>MCP 几乎已经成为了远程工具调用的事实标准，很多传统的业务系统也会提供 MCP 的 Endpoint 来使 Agent 能够触达真实业务场景。传统的 MCP 工具的注册方式是一个固定的 Endpoint，在灵活性和高可用上都不能完全满足需求。所以 AgentScope 在传统注册方式的基础上也集成了 Nacos 来实现 MCP 的动态发现。只需要在Business Sub Agent 中通过集成的 NacosMcpServerManager 加上几行代码便可以轻松完成 MCP 工具的注册。</p>
<pre><code class="hljs language-ini" lang="ini">Toolkit <span class="hljs-attr">toolkit</span> = new NacosToolkit()<span class="hljs-comment">;</span>
NacosMcpServerManager <span class="hljs-attr">mcpServerManager</span> = new NacosMcpServerManager(aiService)<span class="hljs-comment">;</span>
NacosMcpClientWrapper <span class="hljs-attr">mcpClientWrapper</span> =
        NacosMcpClientBuilder.create("business-mcp-server", mcpServerManager).build()<span class="hljs-comment">;</span>
toolkit.registerMcpClient(mcpClientWrapper).block()<span class="hljs-comment">;</span>
</code></pre>
<h4 data-id="heading-8">会话持久化：重启不丢失</h4>
<p>会话通常包含了和模型的多轮对话，与记忆等有状态的内容绑定，如果只存储在内存中，在多实例部署或者重启场景下都会导致丢失或者错乱。所以 AgentScope 提供了基于 MySQL 的会话存储能力，能够随时接着上次聊天继续聊，同一会话无缝衔接，不同会话互相隔离。要在 AgentScope 中启用这个能力只需要部署一个 MySql 数据库，然后创建 MysqlSession 实例，在需要的地方 load 即可恢复到之前的状态，继续对话。</p>
<pre><code class="hljs language-ini" lang="ini">MysqlSession <span class="hljs-attr">mysqlSession</span> =
        new MysqlSession(dataSource, System.getenv("DB_NAME"), null, true)<span class="hljs-comment">;</span>
ReActAgent <span class="hljs-attr">agent</span> = createAgent(toolkit, memory)<span class="hljs-comment">;</span>
agent.loadIfExists(mysqlSession, sessionId)<span class="hljs-comment">;</span>
</code></pre>
<h4 data-id="heading-9">Mem0 长期记忆：记住每一位顾客</h4>
<p>Mem0 是一个长期记忆服务框架，帮助 Agent 持续优化长期记忆，可以使用商业化版本也可以自行部署。在奶茶店的场景下，他能够帮助 Agent 不只拥有当前会话的记忆，还能跨会话记住用户关于饮品、甜度、冰量等偏好。自行对接 Mem0 需要维护与它的通讯以及注入 Agent 的方式和时机。在 AgentScope 中，则只需要配置 Mem0 的BaseUrl 以及 apiKey 即可。</p>
<pre><code class="hljs language-scss" lang="scss">Mem0LongTermMemory longTermMemory =
    Mem0LongTermMemory<span class="hljs-selector-class">.builder</span>()
            <span class="hljs-selector-class">.agentName</span>("BusinessAgent")
            <span class="hljs-selector-class">.userId</span>(userId)
            <span class="hljs-selector-class">.apiBaseUrl</span>("https://api.mem0.ai")
            <span class="hljs-selector-class">.apiKey</span>(System.getenv("MEM0_API_KEY"))
            <span class="hljs-selector-class">.build</span>();
</code></pre>
<h4 data-id="heading-10">AutoContextMemory：上下文压缩</h4>
<p>现在的大模型的上下文窗口大小已经从早期的 4k 扩展至 100k 甚至 1M，但其中要存放历史交互、外部知识库检索结果、复杂的任务指令、中间推理步骤以及工具调用的返回结果等等，在复杂的场景中依旧存在着上下文大小焦虑。同时随着上下文窗口的暴涨，模型在检索和利用中间位置关键信息的效果和性能会显著下降。所以我们往往会考虑对上下文进行压缩，但是如果是简单的压缩很有可能会导致有效信息的损失，为了压缩而损失了准确性是不可取的。所以 AgentScope 推出了AutoContextMemory，它是框架提供的智能上下文内存管理组件，通过自动压缩、卸载和摘要对话历史，在成本控制和信息保留之间找到最佳平衡，具体的原理可以参考我们之前发布的文章<a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzIzOTU0NTQ0MA%3D%3D%26mid%3D2247556750%26idx%3D1%26sn%3D65b82a8da8595494dd6e1adbe605e649%26scene%3D21%23wechat_redirect" target="_blank" title="https://mp.weixin.qq.com/s?__biz=MzIzOTU0NTQ0MA==&amp;mid=2247556750&amp;idx=1&amp;sn=65b82a8da8595494dd6e1adbe605e649&amp;scene=21#wechat_redirect" ref="nofollow noopener noreferrer">《AgentScope AutoContextMemory：告别Agent上下文焦虑》</a>。要使用该能力同样只需要配置一些简单参数即可。</p>
<pre><code class="hljs language-scss" lang="scss">AutoContextConfig autoContextConfig =
        AutoContextConfig<span class="hljs-selector-class">.builder</span>()<span class="hljs-selector-class">.tokenRatio</span>(<span class="hljs-number">0.4</span>)<span class="hljs-selector-class">.lastKeep</span>(<span class="hljs-number">10</span>)<span class="hljs-selector-class">.build</span>();
<span class="hljs-comment">// Use AutoContextMemory, support context auto compression</span>
AutoContextMemory memory = new <span class="hljs-built_in">AutoContextMemory</span>(autoContextConfig, model);
</code></pre>
<h3 data-id="heading-11">快速开始</h3>
<p>为了让大家能够快速体验，同时方便大家拿奶茶店练手，我们提供了多种便捷的部署方式：</p>
<h4 data-id="heading-12">本地开发推荐</h4>
<pre><code class="hljs language-perl" lang="perl"><span class="hljs-comment"># 配置环境变量</span>
cp <span class="hljs-keyword">local</span>-env.example <span class="hljs-keyword">local</span>-env.sh
vim <span class="hljs-keyword">local</span>-env.sh
<span class="hljs-comment"># 一键启动</span>
source <span class="hljs-keyword">local</span>-env.sh &amp;&amp; ./<span class="hljs-keyword">local</span>-deploy.sh start
</code></pre>
<h4 data-id="heading-13">K8s 生产推荐</h4>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-meta"># 配置变量</span>
vim values.yaml
<span class="hljs-meta"># Helm 一键部署</span>
helm install agentscope helm/ --<span class="hljs-keyword">namespace</span> <span class="hljs-title">agentscope</span>
</code></pre>
<h4 data-id="heading-14">Docker 极简</h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 配置环境变量</span>
<span class="hljs-built_in">cp</span> docker-env.example .<span class="hljs-built_in">env</span>
<span class="hljs-comment"># 容器一把梭</span>
docker-compose up -d
</code></pre>
<h4 data-id="heading-15">云产品（AgentRun）部署</h4>
<p>如果想使用云产品部署，可以使用 AgentRun，直接拉取镜像部署，所需要配置的环境变量参考 README.md 文档。</p>
<h2 data-id="heading-16">最后的最后</h2>
<p>这个奶茶店的例子只是 AgentScope Java 能力的冰山一角，用来带大家快速入门。AgentScope Java 框架还支持更多玩法，所有的核心能力都有对应的 Example，欢迎大家体验：</p>
<ul>
<li>实时人类介入</li>
<li>PlanNotebook，先规划后执行</li>
<li>结构化输出</li>
<li>AI 狼人杀</li>
<li>……</li>
</ul>
<p>同时社区也在快速演进中，欢迎大家参与讨论和贡献 🚀</p>
<p><strong>Star 一下不迷路！</strong> ⭐</p>
<p>项目地址：AgentScope Java <strong>[</strong> <strong>2]</strong></p>
<p>Demo 地址：<code>agentscope-examples/boba-tea-shop</code></p>
<p>"Talk is cheap, show me the agents."</p>
<p>快来 Clone 下来跑一把，体验一下 AI 给你点奶茶的快感吧！</p>
<p><strong>相关链接：</strong></p>
<p>[1] agentscope-java/agentscope-examples/boba-tea-shop</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fagentscope-ai%2Fagentscope-java%2Ftree%2Fmain%2Fagentscope-examples%2Fboba-tea-shop" target="_blank" title="https://github.com/agentscope-ai/agentscope-java/tree/main/agentscope-examples/boba-tea-shop" ref="nofollow noopener noreferrer">github.com/agentscope-…</a></p>
<p>[2] AgentScope Java</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fagentscope-ai%2Fagentscope-java" target="_blank" title="https://github.com/agentscope-ai/agentscope-java" ref="nofollow noopener noreferrer">github.com/agentscope-…</a></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Next.js第二十五章(CSS方案)]]></title>    <link>https://juejin.cn/post/7601715462921535498</link>    <guid>https://juejin.cn/post/7601715462921535498</guid>    <pubDate>2026-02-01T21:58:39.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7601715462921535498" data-draft-id="7601441797118443571" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Next.js第二十五章(CSS方案)"/> <meta itemprop="keywords" content="前端,Next.js"/> <meta itemprop="datePublished" content="2026-02-01T21:58:39.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="小满zs"/> <meta itemprop="url" content="https://juejin.cn/user/2463384809252397"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Next.js第二十五章(CSS方案)
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2463384809252397/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    小满zs
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-01T21:58:39.000Z" title="Sun Feb 01 2026 21:58:39 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-01
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    1
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">Next.js CSS方案</h2>
<p>在Next.js可以使用多种Css方案，包括：</p>
<ul>
<li>Tailwind CSS(个人推荐)</li>
<li>CSS Modules(创建css模块化，类似于Vue的单文件组件)</li>
<li>Next.js内置Sass(css预处理器)</li>
<li>全局Css(全局的css，可以全局使用)</li>
<li>Style(内联样式)</li>
<li>css-in-js(类似于React的styled-components，不推荐)</li>
</ul>
<h4 data-id="heading-1">Tailwind CSS</h4>
<p>Tailwind CSS(css原子化)，他是一个css框架，可以让你快速构建网页，他提供了大量的css类，你只需要使用这些类，就可以快速构建网页。</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Ftailwindcss.com%2F" target="_blank" title="https://tailwindcss.com/" ref="nofollow noopener noreferrer">Tailwind CSS</a></p>
<h5 data-id="heading-2">安装教程</h5>
<pre><code class="hljs language-bash" lang="bash">npx create-next-app@latest my-project
</code></pre>
<p>当我们去创建<code>Next.js</code>项目的时候，选择<code>customize settings(自定义选项)</code> 那么就会出现<code>Tailwind CSS</code>的选项，我们选择<code>Yes</code>即可。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/eccfac37d4584e6ca81bef570e16f0d4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5ruhenM=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770588077&amp;x-signature=bSPfhdHEHQDVvUeo%2FJa2ZKlvy4k%3D" alt="image.png" loading="lazy"/></p>
<p>那么如果我在当时忘记选择<code>Tailwind CSS</code>，我该怎么安装呢？</p>
<h5 data-id="heading-3">在 Next.js 中安装并使用 Tailwind CSS</h5>
<p>下面是如何在 Next.js 项目中集成 Tailwind CSS 的详细流程：</p>
<h6 data-id="heading-4">1. 创建你的 Next.js 项目</h6>
<p>如果还没有项目，可以使用 Create Next App 快速初始化：</p>
<pre><code class="hljs language-bash" lang="bash">npx create-next-app@latest my-project --typescript --eslint --app
<span class="hljs-built_in">cd</span> my-project
</code></pre>
<h6 data-id="heading-5">2. 安装 Tailwind CSS 及相关依赖</h6>
<p>通过 npm 安装 <code>tailwindcss</code>、<code>@tailwindcss/postcss</code> 以及 <code>postcss</code> 依赖：</p>
<pre><code class="hljs language-bash" lang="bash">npm install tailwindcss @tailwindcss/postcss postcss
</code></pre>
<h6 data-id="heading-6">3. 配置 PostCSS 插件</h6>
<p>在项目根目录下创建 <code>postcss.config.mjs</code> 文件，并添加如下内容：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> config = {
  <span class="hljs-attr">plugins</span>: {
    <span class="hljs-string">"@tailwindcss/postcss"</span>: {},
  },
};
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> config;
</code></pre>
<h6 data-id="heading-7">4. 导入 Tailwind CSS</h6>
<p>在 <code>./app/globals.css</code> 文件中添加 Tailwind CSS 的导入：</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-keyword">@import</span> <span class="hljs-string">"tailwindcss"</span>;
</code></pre>
<h6 data-id="heading-8">5. 启动开发服务</h6>
<p>运行开发服务：</p>
<pre><code class="hljs language-bash" lang="bash">npm run dev
</code></pre>
<h6 data-id="heading-9">6. 在项目中开始使用 Tailwind</h6>
<p>现在可以直接在组件或页面中使用 Tailwind CSS 的工具类来进行样式编写。例如：</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Home</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"text-3xl font-bold underline"</span>&gt;</span>
      Hello world!
    <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>
  )
}
</code></pre>
<p>这样即可在项目中使用 Tailwind CSS 原子类来快速开发样式。</p>
<h5 data-id="heading-10">FAQ</h5>
<p>这么多类名我记不住怎么办？</p>
<p>答：你不需要特意去记忆，tailwindCss的类名都是简称，例如<code>backdround-color:red</code> 你可以简写为<code>bg-red-500</code>。另外就是官网也提供文档可以查询，再其次就是还提供了<code>vscode</code>插件，可以自动补全类名。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3e4548071e9747ff9e76261c8ae40d7a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5ruhenM=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770588077&amp;x-signature=j4D5qszb2BQMyV9Ox87vsxjWFT8%3D" alt="image.png" loading="lazy"/></p>
<h4 data-id="heading-11">CSS Modules</h4>
<p>CSS Modules 是一种 CSS 模块化方案，可以让你在组件中使用CSS模块化，类似于Vue的单文件组件(scoped)。</p>
<p>Next.js已经内置了对CSS Modules的支持，你只需要在创建文件的时候新增<code>.module.css</code>后缀即可。例如<code>index.module.css</code>。</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-comment">/** index.module.css */</span>
<span class="hljs-selector-class">.container</span> {
  <span class="hljs-attribute">background-color</span>: red;
}
</code></pre>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-comment">/** index.tsx */</span>
<span class="hljs-keyword">import</span> styles <span class="hljs-keyword">from</span> <span class="hljs-string">'./index.module.css'</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Home</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.container}</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Home<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  )
}
</code></pre>
<p>你会发现他编译出来的类名，就会生成一个唯一的hash值，这样就可以避免类名冲突。</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"index-module__ifV0vq__test"</span>&gt;</span>小满zs Page<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
</code></pre>
<h4 data-id="heading-12">Next.js内置Sass</h4>
<p>Next.js已经内置了对Sass的支持，但是依赖还需要手动安装，不过配置项它都内置了，只需要安装一下即可。</p>
<pre><code class="hljs language-bash" lang="bash">npm install --save-dev sass
</code></pre>
<p>另外Next.js还支持配置全局sass变量，只需要在<code>next.config.js</code>中配置即可。</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> { <span class="hljs-title class_">NextConfig</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'next'</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">config</span>: <span class="hljs-title class_">NextConfig</span> = {
  <span class="hljs-attr">reactCompiler</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">reactStrictMode</span>: <span class="hljs-literal">false</span>,
  <span class="hljs-attr">cacheComponents</span>:<span class="hljs-literal">false</span>,
  <span class="hljs-attr">sassOptions</span>:{
    <span class="hljs-attr">additionalData</span>: <span class="hljs-string">`$color: blue;`</span>, <span class="hljs-comment">// 全局变量</span>
  }
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> config
</code></pre>
<h4 data-id="heading-13">全局Css</h4>
<p>全局CSS，就是把所有样式应用到全局路由/组件，那应该怎么搞呢?</p>
<p>在根目录下创建<code>globals.css</code>文件，然后添加全局样式。</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-comment">/** app/globals.css */</span>
<span class="hljs-selector-tag">body</span> {
  <span class="hljs-attribute">background-color</span>: red;
}
<span class="hljs-selector-class">.flex</span>{
    <span class="hljs-attribute">display</span>: flex;
    <span class="hljs-attribute">justify-content</span>: center;
    <span class="hljs-attribute">align-items</span>: center;
}
</code></pre>
<p>在<code>layout.tsx</code>文件中引入<code>globals.css</code>文件。</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-comment">//app/layout.tsx</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">'./globals.css'</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">RootLayout</span>(<span class="hljs-params">{ children }: { children: React.ReactNode }</span>) {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>{children}<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span>
  )
}
</code></pre>
<h4 data-id="heading-14">Style</h4>
<p>Style，就是内联样式，就是直接在组件中使用style属性来定义样式。</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Home</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">backgroundColor:</span> '<span class="hljs-attr">red</span>' }}&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Home<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  )
}
</code></pre>
<h4 data-id="heading-15">css-in-js</h4>
<p>css-in-js，就是把css + js + html混合在一起，拨入styled-components，不推荐很多人接受不了这种写法。</p>
<h5 data-id="heading-16">1.安装启用styled-components</h5>
<pre><code class="hljs language-bash" lang="bash">npm install styled-components
</code></pre>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> { <span class="hljs-title class_">NextConfig</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'next'</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">config</span>: <span class="hljs-title class_">NextConfig</span> = {
  <span class="hljs-attr">compiler</span>:{
    <span class="hljs-attr">styledComponents</span>:<span class="hljs-literal">true</span> <span class="hljs-comment">// 启用styled-components</span>
  }
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> config
</code></pre>
<h5 data-id="heading-17">2.创建style-component注册表</h5>
<p>使用styled-componentsAPI 创建一个全局注册表组件，用于收集渲染过程中生成的所有 CSS 样式规则，以及一个返回这些规则的函数。最后，使用该useServerInsertedHTML钩子将注册表中收集的样式注入到<code>&lt;head&gt;</code>根布局的 HTML 标签中。</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-comment">//lib/registry.ts</span>
<span class="hljs-string">'use client'</span>
 
<span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">import</span> { useServerInsertedHTML } <span class="hljs-keyword">from</span> <span class="hljs-string">'next/navigation'</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">ServerStyleSheet</span>, <span class="hljs-title class_">StyleSheetManager</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'styled-components'</span>
 
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">StyledComponentsRegistry</span>(<span class="hljs-params">{
  children,
}: {
  children: React.ReactNode
}</span>) {
  <span class="hljs-comment">// Only create stylesheet once with lazy initial state</span>
  <span class="hljs-comment">// x-ref: https://reactjs.org/docs/hooks-reference.html#lazy-initial-state</span>
  <span class="hljs-keyword">const</span> [styledComponentsStyleSheet] = <span class="hljs-title function_">useState</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerStyleSheet</span>())
 
  <span class="hljs-title function_">useServerInsertedHTML</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> styles = styledComponentsStyleSheet.<span class="hljs-title function_">getStyleElement</span>()
    styledComponentsStyleSheet.<span class="hljs-property">instance</span>.<span class="hljs-title function_">clearTag</span>()
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;&gt;</span>{styles}<span class="hljs-tag">&lt;/&gt;</span></span>
  })
 
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">window</span> !== <span class="hljs-string">'undefined'</span>) <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;&gt;</span>{children}<span class="hljs-tag">&lt;/&gt;</span></span>
 
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">StyleSheetManager</span> <span class="hljs-attr">sheet</span>=<span class="hljs-string">{styledComponentsStyleSheet.instance}</span>&gt;</span>
      {children}
    <span class="hljs-tag">&lt;/<span class="hljs-name">StyleSheetManager</span>&gt;</span></span>
  )
}
</code></pre>
<h5 data-id="heading-18">3.注册style-component注册表</h5>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-comment">//app/layout.tsx</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">StyledComponentsRegistry</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./lib/registry'</span>
 
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">RootLayout</span>(<span class="hljs-params">{
  children,
}: {
  children: React.ReactNode
}</span>) {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">StyledComponentsRegistry</span>&gt;</span>{children}<span class="hljs-tag">&lt;/<span class="hljs-name">StyledComponentsRegistry</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span>
  )
}
</code></pre>
<h5 data-id="heading-19">4.使用styled-components</h5>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-string">'use client'</span>;
<span class="hljs-keyword">import</span> styled <span class="hljs-keyword">from</span> <span class="hljs-string">'styled-components'</span>;
<span class="hljs-keyword">const</span> <span class="hljs-title class_">StyledButton</span> = styled.<span class="hljs-property">button</span><span class="hljs-string">`
  background-color: red;
  color: white;
  padding: 10px 20px;
  border-radius: 5px;
`</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Home</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">StyledButton</span>&gt;</span>Click me<span class="hljs-tag">&lt;/<span class="hljs-name">StyledButton</span>&gt;</span></span>
  )
}
</code></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Agent Skills：构建可复用 AI 编程知识库的最佳实践]]></title>    <link>https://juejin.cn/post/7602100217656229930</link>    <guid>https://juejin.cn/post/7602100217656229930</guid>    <pubDate>2026-02-02T09:22:11.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602100217656229930" data-draft-id="7602069205467709486" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Agent Skills：构建可复用 AI 编程知识库的最佳实践"/> <meta itemprop="keywords" content="Agent"/> <meta itemprop="datePublished" content="2026-02-02T09:22:11.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="unravel2025"/> <meta itemprop="url" content="https://juejin.cn/user/1116759541421880"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Agent Skills：构建可复用 AI 编程知识库的最佳实践
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1116759541421880/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    unravel2025
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-02T09:22:11.000Z" title="Mon Feb 02 2026 09:22:11 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-02
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    43
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读15分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在 AI 辅助编程的时代，<code>AGENTS.md</code> 已成为开发者向 AI 工具传递项目上下文的重要文件。
然而，随着项目增多，维护多个项目的 <code>AGENTS.md</code> 文件变得愈发困难——重复的知识、分散的更新、难以同步。新的Agent Skills开放标准针对这些问题有很好的解决方案</p>
<h2 data-id="heading-0">AGENTS.md 的痛点与 Agent Skills 的诞生</h2>
<h3 data-id="heading-1">AGENTS.md 的困境</h3>
<p>传统上，开发者会在每个项目中创建 <code>AGENTS.md</code> 文件，用于记录：</p>
<ul>
<li>项目特定的编码规范</li>
<li>首选的 Swift/SwiftUI 方法</li>
<li>重构策略</li>
<li>Swift Concurrency 使用模式</li>
</ul>
<p>在实践中存在三个核心问题：</p>
<p>第一，知识同步成本高。当在 A 项目中发现 AI 生成了错误代码并更新 <code>AGENTS.md</code> 后，相同的问题修复需要手动同步到 B、C、D 项目，维护成本线性增长。</p>
<p>第二，通用知识与项目知识混杂。<code>AGENTS.md</code> 本应聚焦项目特有逻辑，却不得不包含大量通用编程最佳实践（如 Swift Concurrency 使用规范），导致文件臃肿。</p>
<p>第三，缺乏标准化分享机制。即使想开源自己的 <code>AGENTS.md</code> 帮助他人，其格式也不适合直接分享——它天然为项目特定而设计，而非领域通用。</p>
<h3 data-id="heading-2">Agent Skills 的核心理念</h3>
<p>Agent Skills 是一个开放格式（open format），旨在将 AI Agent 的能力模块化、可复用化。官方定义为：</p>
<blockquote>
<p>Agent Skills 是一种为 AI Agent 提供新能力和专业知识的开放格式。单个 Skill 可包含指令、脚本和资源文件夹，使 Agent 能更准确地执行特定任务。</p>
</blockquote>
<p>其核心优势在于领域专业知识的封装与复用。你可以将 Swift Concurrency、SwiftUI 架构、代码重构等领域的最佳实践打包成独立 Skill，在所有项目中共享。</p>
<p>一句话总结：<code>AGENTS.md</code> 是项目级知识库，而 Agent Skills 是跨项目、领域级的知识库。</p>
<h2 data-id="heading-3">Agent Skills 核心概念详解</h2>
<h3 data-id="heading-4">什么是 Agent Skills？</h3>
<p>Agent Skills 由三个核心要素构成：</p>
<ol>
<li>指令系统（Instructions）：指导 Agent 何时、如何使用该 Skill</li>
<li>参考资源（References）：详细的领域知识文档</li>
<li>可执行脚本（Scripts）：自动化工具或工作流</li>
</ol>
<p>这种结构使 Skill 具备：</p>
<ul>
<li>领域专业性：深度覆盖特定技术栈</li>
<li>可复用性：一次创建，多项目使用</li>
<li>工具兼容性：已被 Codex、Gemini、Claude、Cursor 等主流工具支持</li>
</ul>
<h3 data-id="heading-5">技术生态现状</h3>
<p>Agent Skills 已被广泛采纳：</p>
<ul>
<li>Codex CLI：通过 <code>/skills</code> 命令管理</li>
<li>Cursor AI：集成 openskills CLI</li>
<li>Gemini/Claude：原生支持 Skill 格式</li>
</ul>
<p>这意味着开发者可以立即投入使用，无需等待生态成熟。</p>
<h2 data-id="heading-6">实战案例：Swift Concurrency Skill 深度剖析</h2>
<h3 data-id="heading-7">Skill 结构设计</h3>
<pre><code class="hljs language-bash" lang="bash">swift-concurrency/
├── SKILL.md                    <span class="hljs-comment"># 主技能文件：决策树入口</span>
└── references/
    ├── async-await-basics.md   <span class="hljs-comment"># async/await 基础语法</span>
    ├── tasks.md                <span class="hljs-comment"># Task 生命周期、取消机制、优先级</span>
    ├── sendable.md             <span class="hljs-comment"># 隔离域与 Sendable 协议</span>
    ├── actors.md               <span class="hljs-comment"># Actor 隔离、全局 Actor、可重入性</span>
    ├── async-sequences.md      <span class="hljs-comment"># AsyncSequence 与 AsyncStream 模式</span>
    ├── threading.md            <span class="hljs-comment"># 线程与 Task 对比、挂起点</span>
    ├── memory-management.md    <span class="hljs-comment"># 循环引用、weak self、隔离析构</span>
    ├── core-data.md            <span class="hljs-comment"># Core Data 集成模式</span>
    ├── performance.md          <span class="hljs-comment"># 使用 Xcode Instruments 优化</span>
    ├── testing.md              <span class="hljs-comment"># 并发代码测试策略</span>
    ├── migration.md            <span class="hljs-comment"># Swift 6 迁移分步指南</span>
    ├── glossary.md             <span class="hljs-comment"># 术语与概念词汇表</span>
    └── linting.md              <span class="hljs-comment"># 严格并发 Lint 规则</span>
</code></pre>
<p>结构解析：</p>
<ul>
<li><code>SKILL.md</code> 是智能路由层，类似 API Gateway，根据问题类型分发到对应的参考文档</li>
<li><code>references/</code> 是知识库层，每篇文档聚焦单一主题，深度讲解</li>
<li>这种分层设计使 Agent 能精准定位所需知识，避免上下文过载</li>
</ul>
<h3 data-id="heading-8">代码示例：决策树实现</h3>
<p><code>SKILL.md</code> 中的决策树是 Skill 的核心智能。以下是一个简化的实现示例：</p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section"># Swift Concurrency Skill - 主决策树</span>

<span class="hljs-section">## 何时使用该 Skill</span>
当开发者提及以下关键词时激活：
<span class="hljs-bullet">-</span> "Swift Concurrency", "async/await", "actors", "tasks"
<span class="hljs-bullet">-</span> "迁移到 Swift 6"
<span class="hljs-bullet">-</span> "数据竞争" 或 "线程安全"
<span class="hljs-bullet">-</span> "@MainActor", "Sendable"
<span class="hljs-bullet">-</span> "并发代码架构" 或 "性能优化"

<span class="hljs-section">## 决策路径</span>

<span class="hljs-section">### 1. 刚开始编写异步代码？</span>
<span class="hljs-code">```bash
# Agent 执行动作：读取基础文档
openskills read swift-concurrency/references/async-await-basics.md
</span></code></pre>
<ul>
<li>需要并行操作？→ 读取 <code>tasks.md</code> (async let, TaskGroup)</li>
</ul>
<ol start="2">
<li>需要保护共享可变状态？</li>
</ol>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 评估项目类型</span>
<span class="hljs-keyword">if</span> 项目使用类（class）管理状态:
    openskills <span class="hljs-built_in">read</span> swift-concurrency/references/actors.md
<span class="hljs-keyword">else</span>:
    openskills <span class="hljs-built_in">read</span> swift-concurrency/references/sendable.md
</code></pre>
<ol start="3">
<li>管理异步操作生命周期？</li>
</ol>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 区分结构化并发与流式数据</span>
<span class="hljs-keyword">if</span> 需求是结构化任务管理:
    openskills <span class="hljs-built_in">read</span> swift-concurrency/references/tasks.md
<span class="hljs-keyword">elif</span> 需求是流式数据处理:
    openskills <span class="hljs-built_in">read</span> swift-concurrency/references/async-sequences.md
</code></pre>
<ol start="4">
<li>性能分析与调试？</li>
</ol>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 引导使用 Instruments</span>
openskills <span class="hljs-built_in">read</span> swift-concurrency/references/performance.md
</code></pre>
<p>项目配置检查清单
在应用建议前，Agent 必须检查：</p>
<ul>
<li>Swift 版本（6.0+？）</li>
<li>是否启用 <code>StrictConcurrency=complete</code></li>
<li>是否设置 <code>nonisolatednonsendingbydefault</code></li>
<li>默认 Actor 隔离策略</li>
</ul>
<pre><code class="hljs language-markdown" lang="markdown">
<span class="hljs-strong">**注释说明**</span>：
<span class="hljs-bullet">-</span> 决策树本质是<span class="hljs-strong">**条件路由表**</span>，将自然语言问题映射到具体文档
<span class="hljs-bullet">-</span> <span class="hljs-code">`openskills read`</span> 是 Agent 与 Skill 的<span class="hljs-strong">**标准交互接口**</span>
<span class="hljs-bullet">-</span> 项目配置检查确保建议<span class="hljs-strong">**因地制宜**</span>，避免生搬硬套

<span class="hljs-section">## Agent 如何使用 Skills：技术实现原理</span>

<span class="hljs-section">### 安装与同步机制</span>

Agent Skills 通过 <span class="hljs-code">`openskills`</span> CLI 工具管理，其工作流程分为三步：

<span class="hljs-strong">**步骤 1：安装 Skill**</span>
<span class="hljs-code">```bash
# 从 GitHub 安装公开 Skill
openskills install avdlee/Swift-Concurrency-Agent-Skill
</span></code></pre>
<p>技术原理：该命令会：</p>
<ol>
<li>克隆 GitHub 仓库到本地 Skill 存储目录（<code>~/.skills</code> 或项目 <code>.skills</code>）</li>
<li>解析 <code>SKILL.md</code> 提取元数据（名称、描述、触发关键词）</li>
<li>注册 Skill 到全局索引</li>
</ol>
<p>步骤 2：同步到 AGENTS.md</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 将已安装 Skills 注入项目 AGENTS.md</span>
openskills <span class="hljs-built_in">sync</span>
</code></pre>
<p>该命令会自动化修改 <code>AGENTS.md</code>，插入 Skill 引用区块。生成的内容如下：</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">skills_system</span> <span class="hljs-attr">priority</span>=<span class="hljs-string">"1"</span>&gt;</span>

## 可用 Skills

<span class="hljs-comment">&lt;!-- SKILLS_TABLE_START --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">usage</span>&gt;</span>
当用户请求任务时，检查以下可用 Skills 是否能更有效完成工作。Skills 提供专业能力和领域知识。

使用方法：
- 调用：Bash("openskills read <span class="hljs-tag">&lt;<span class="hljs-name">skill-name</span>&gt;</span>")
- Skill 内容将加载，包含完成任务的具体指令
- 输出中提供基础目录，用于解析捆绑资源（references/, scripts/, assets/）

使用注意：
- 仅使用 <span class="hljs-tag">&lt;<span class="hljs-name">available_skills</span>&gt;</span> 下列出的 Skills
- 不要调用已加载到上下文的 Skill
- 每次 Skill 调用是无状态的
<span class="hljs-tag">&lt;/<span class="hljs-name">usage</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">available_skills</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">skill</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>swift-concurrency<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>'Swift Concurrency 最佳实践、模式和实现的专家指导。使用场景：(1) 提及 Swift Concurrency、async/await、actors 或 tasks，(2) "使用 Swift Concurrency" 或 "现代并发模式"，(3) 迁移到 Swift 6，(4) 数据竞争或线程安全问题，(5) 将闭包重构为 async/await，(6) @MainActor、Sendable 或 Actor 隔离，(7) 并发代码架构或性能优化，(8) 并发相关 Lint 警告（SwiftLint 等）'<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">location</span>&gt;</span>project<span class="hljs-tag">&lt;/<span class="hljs-name">location</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">skill</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">available_skills</span>&gt;</span>
<span class="hljs-comment">&lt;!-- SKILLS_TABLE_END --&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">skills_system</span>&gt;</span>
</code></pre>
<p>技术解析：</p>
<ul>
<li>使用 XML 格式 是为了兼容不同 Agent 的解析器</li>
<li><code>priority="1"</code> 确保 Skill 系统被优先评估</li>
<li><code>&lt;description&gt;</code> 是触发器（Trigger），Agent 通过自然语言匹配决定是否调用</li>
<li><code>Bash("openskills read ...")</code> 是标准调用接口，解耦 Agent 与 Skill 实现</li>
</ul>
<h3 data-id="heading-9">Agent 的决策流程</h3>
<p>当用户提问时，Agent 的内部工作流程如下：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 伪代码：Agent 决策逻辑</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">handle_user_prompt</span>(<span class="hljs-params">prompt: <span class="hljs-built_in">str</span>, skills: <span class="hljs-type">List</span>[Skill]</span>):
    <span class="hljs-comment"># 1. 解析用户意图（Embedding + 关键词匹配）</span>
    intent = extract_intent(prompt)
    
    <span class="hljs-comment"># 2. 遍历可用 Skills，计算相关性得分</span>
    <span class="hljs-keyword">for</span> skill <span class="hljs-keyword">in</span> skills:
        <span class="hljs-comment"># 匹配 Skill 描述中的关键词</span>
        <span class="hljs-keyword">if</span> skill.description.contains_any(intent.keywords):
            score = calculate_relevance(skill.description, intent)
            <span class="hljs-keyword">if</span> score &gt; THRESHOLD:
                <span class="hljs-comment"># 3. 动态加载 Skill 上下文</span>
                skill_content = execute_bash(<span class="hljs-string">f"openskills read <span class="hljs-subst">{skill.name}</span>"</span>)
                
                <span class="hljs-comment"># 4. 决策树路由</span>
                decision_path = parse_decision_tree(skill_content.SKILL.md)
                target_doc = decision_path.evaluate(intent)
                
                <span class="hljs-comment"># 5. 读取具体知识文档</span>
                reference_doc = execute_bash(
                    <span class="hljs-string">f"openskills read <span class="hljs-subst">{skill.name}</span>/references/<span class="hljs-subst">{target_doc}</span>"</span>
                )
                
                <span class="hljs-comment"># 6. 生成带引用的回答</span>
                <span class="hljs-keyword">return</span> generate_answer(
                    prompt, 
                    context=reference_doc,
                    citations=[target_doc]  <span class="hljs-comment"># 引用来源</span>
                )
    
    <span class="hljs-comment"># 无匹配 Skill，使用通用知识</span>
    <span class="hljs-keyword">return</span> generate_answer(prompt, context=general_knowledge)
</code></pre>
<p>关键设计亮点：</p>
<ul>
<li>延迟加载（Lazy Loading）：Skill 内容在需要时才加载，避免上下文窗口浪费</li>
<li>无状态调用：每次调用都是独立的，Skill 内部无复杂状态管理，降低耦合</li>
<li>可溯源性：Agent 必须明确引用参考文档，实现知识审计</li>
</ul>
<h2 data-id="heading-10">领域专业知识的重要性：Skill 质量的基石</h2>
<h3 data-id="heading-11">为什么需要领域专家？</h3>
<p>Agent Skills 的质量取决于创建者的领域深度。其 Swift Concurrency Skill 的优势源于：</p>
<ul>
<li>对 Swift 6 新特性的深度理解（如 Default Actor Isolation）</li>
<li>实际项目中的踩坑经验（如不必要的 <code>@MainActor</code>）</li>
</ul>
<h3 data-id="heading-12">反模式：浅层知识与过度设计</h3>
<p>一些开源 Skill 的问题：</p>
<p>问题 1：缺乏深度</p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section"># 反例：浅层 Skill</span>
<span class="hljs-section">## 使用 async/await</span>
<span class="hljs-bullet">-</span> 用 async 标记异步函数
<span class="hljs-bullet">-</span> 用 await 调用异步函数
</code></pre>
<p>这种 Skill 只是语法复述，无法解决实际问题（如线程安全、性能优化）。</p>
<p>问题 2：过度武断</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-comment">// 反例：强制架构风格</span>
<span class="hljs-comment">// Skill 建议：所有 ViewModel 必须遵循 MVVM</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyViewModel</span>: <span class="hljs-title class_">ObservableObject</span> { <span class="hljs-comment">/* ... */</span> } 
<span class="hljs-comment">// 但如果用户项目使用 TCA 或 Elm，此建议就是错误的</span>
</code></pre>
<p>最佳实践原则：</p>
<ul>
<li>Skill 应聚焦 "最佳实践" 而非 "个人偏好"</li>
<li>应解决 "How to do it right" 而非 "How I do it"</li>
<li>提供 "配置感知" 能力，根据项目实际设置调整建议</li>
</ul>
<h3 data-id="heading-13">配置感知的实现</h3>
<p>Swift Concurrency Skill 会先评估项目配置：</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-comment">// Skill 决策逻辑示例：评估项目 Swift 版本</span>
<span class="hljs-keyword">func</span> <span class="hljs-title function_">evaluateProjectSettings</span>() -&gt; <span class="hljs-type">ConcurrencyStrategy</span> {
    <span class="hljs-keyword">let</span> swiftVersion <span class="hljs-operator">=</span> readSwiftVersion() <span class="hljs-comment">// 读取 // swift-tools-version: 6.0</span>
    <span class="hljs-keyword">let</span> concurrencyChecks <span class="hljs-operator">=</span> buildSettings[<span class="hljs-string">"SWIFT_STRICT_CONCURRENCY"</span>] <span class="hljs-comment">// 严格并发设置</span>
    <span class="hljs-keyword">let</span> actorIsolation <span class="hljs-operator">=</span> buildSettings[<span class="hljs-string">"SWIFT_DEFAULT_ACTOR_ISOLATION"</span>] <span class="hljs-comment">// 默认 Actor 隔离</span>
    
    <span class="hljs-keyword">if</span> swiftVersion <span class="hljs-operator">&gt;=</span> .v6_0 <span class="hljs-operator">&amp;&amp;</span> concurrencyChecks <span class="hljs-operator">==</span> <span class="hljs-string">"complete"</span> {
        <span class="hljs-comment">// Swift 6 + 完整严格并发检查</span>
        <span class="hljs-keyword">return</span> .swift6Strict
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> actorIsolation <span class="hljs-operator">==</span> <span class="hljs-string">"mainActor"</span> {
        <span class="hljs-comment">// 默认主 Actor 隔离，可省略多余 @MainActor</span>
        <span class="hljs-keyword">return</span> .mainActorDefault
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> .legacy
    }
}

<span class="hljs-comment">// 根据评估结果，Skill 会生成差异化建议</span>
<span class="hljs-keyword">switch</span> evaluateProjectSettings() {
<span class="hljs-keyword">case</span> .swift6Strict:
    <span class="hljs-comment">// 建议：利用编译时检查，减少运行时保护</span>
    suggest(<span class="hljs-string">"优先使用 Sendable 和 Actor 隔离，减少 DispatchQueue"</span>)
<span class="hljs-keyword">case</span> .mainActorDefault:
    <span class="hljs-comment">// 建议：移除冗余注解</span>
    suggest(<span class="hljs-string">"全局已默认 @MainActor，可移除显式标记"</span>)
<span class="hljs-keyword">case</span> .legacy:
    <span class="hljs-comment">// 建议：保守的向后兼容方案</span>
    suggest(<span class="hljs-string">"逐步迁移，先启用 StrictConcurrency=minimal"</span>)
}
</code></pre>
<p>这种上下文感知能力使 Skill 建议精准而非教条。</p>
<h2 data-id="heading-14">如何使用 Agent Skills：多工具实践</h2>
<h3 data-id="heading-15">使用 openskills CLI（Cursor AI）</h3>
<p>安装 Skill：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 安装 Swift Concurrency Skill</span>
openskills install avdlee/Swift-Concurrency-Agent-Skill

<span class="hljs-comment"># 查看已安装 Skills</span>
openskills list
</code></pre>
<p>同步到项目：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 自动更新 AGENTS.md</span>
openskills <span class="hljs-built_in">sync</span>

<span class="hljs-comment"># 可指定输出文件</span>
openskills <span class="hljs-built_in">sync</span> --output .cursor/agents.md
</code></pre>
<p>在对话中使用：</p>
<pre><code class="hljs language-markdown" lang="markdown">用户：帮我分析当前项目的 Swift Concurrency 使用是否合理  

Agent 内部：
<span class="hljs-bullet">1.</span> 匹配到关键词 "Swift Concurrency" → 触发 swift-concurrency Skill
<span class="hljs-bullet">2.</span> 执行 <span class="hljs-code">`openskills read swift-concurrency`</span>
<span class="hljs-bullet">3.</span> 读取 SKILL.md，决策树指向 "analyze-project"
<span class="hljs-bullet">4.</span> 执行分析脚本（如有）
<span class="hljs-bullet">5.</span> 生成带引用的报告
</code></pre>
<h3 data-id="heading-16">实用 Prompt 示例</h3>
<p>以下是可直接使用的 Skill 调用示例：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 示例 1：检查冗余 @MainActor</span>
<span class="hljs-string">"使用 swift-concurrency Skill，找出项目中不必要的 @MainActor 使用"</span>

<span class="hljs-comment"># 示例 2：后台任务优化</span>
<span class="hljs-string">"分析当前项目，识别可移动到后台线程的同步代码，使用 Swift Concurrency 重构"</span>

<span class="hljs-comment"># 示例 3：迁移辅助</span>
<span class="hljs-string">"帮我将文件 NetworkManager.swift 从 GCD 迁移到 Swift Concurrency，使用 Skill 指导"</span>

<span class="hljs-comment"># 示例 4：性能分析</span>
<span class="hljs-string">"使用 Skill 的性能模块，分析 async let 和 TaskGroup 的使用效率"</span>

<span class="hljs-comment"># 示例 5：Lint 规则</span>
<span class="hljs-string">"根据 Skill 的 linting.md，检查项目是否符合严格并发 Lint 规则"</span>
</code></pre>
<h2 data-id="heading-17">深入原理性分析</h2>
<h3 data-id="heading-18">Agent Skills 的架构设计哲学</h3>
<p>Agent Skills 的设计遵循三大原则：</p>
<p>原则一：关注点分离（Separation of Concerns）</p>
<ul>
<li><code>AGENTS.md</code> = 项目特定上下文（如业务逻辑、架构决策）</li>
<li><code>Skill</code> = 领域通用知识（如语言特性、框架最佳实践）</li>
</ul>
<p>原则二：知识的层次化封装</p>
<pre><code class="hljs language-markdown" lang="markdown">用户提问
<span class="hljs-code">    ↓
意图识别（Agent 通用能力）
    ↓
Skill 路由（SKILL.md 决策树）
    ↓
知识检索（References 文档）
    ↓
答案生成（带引用）
</span></code></pre>
<p>这种分层使知识从扁平文本升级为结构化知识图谱。</p>
<p>原则三：工具无关性（Tool Agnostic）</p>
<p>通过标准化 <code>openskills read</code> 接口，Skill 创建者无需关心 Agent 实现细节。这是类 Unix 哲学：做一件事，做好，并能与其他工具组合。</p>
<h3 data-id="heading-19">与 RAG（检索增强生成）的对比</h3>
<p>Agent Skills 本质上是一种手动优化的 RAG 系统：</p>








































<table><thead><tr><th align="left">特性</th><th align="left">传统 RAG</th><th align="left">Agent Skills</th></tr></thead><tbody><tr><td align="left">知识组织</td><td align="left">自动分块，可能不连贯</td><td align="left">人工结构化，逻辑清晰</td></tr><tr><td align="left">检索方式</td><td align="left">向量相似度搜索</td><td align="left">规则/决策树路由</td></tr><tr><td align="left">上下文控制</td><td align="left">自动注入，可能冗余</td><td align="left">按需加载，精确控制</td></tr><tr><td align="left">可解释性</td><td align="left">黑盒，难以追溯</td><td align="left">显式引用，可审计</td></tr><tr><td align="left">维护成本</td><td align="left">低（自动化）</td><td align="left">中等（需人工维护）</td></tr><tr><td align="left">回答质量</td><td align="left">一般，可能 hallucinate</td><td align="left">高，专家级深度</td></tr></tbody></table>
<p>适用场景：</p>
<ul>
<li>RAG：通用知识、快速原型</li>
<li>Agent Skills：专业领域、生产环境、团队协作</li>
</ul>
<h2 data-id="heading-20">个人见解与总结</h2>
<h3 data-id="heading-21">核心观点</h3>
<p>Agent Skills 不仅是技术工具，更是编程知识管理的范式升级。它解决了 AI 辅助开发中的三个根本矛盾：</p>
<ol>
<li>
<p>通用性与特异性的矛盾</p>
<ul>
<li><code>AGENTS.md</code> 试图两者兼顾，结果两头不讨好</li>
<li>Skill 将通用知识提取、封装、复用，让项目文件回归本质</li>
</ul>
</li>
<li>
<p>深度与广度的矛盾</p>
<ul>
<li>大模型虽有广度，但缺乏领域深度</li>
<li>Skill 引入人类专家知识，弥补模型能力边界</li>
</ul>
</li>
<li>
<p>个人与团队的矛盾</p>
<ul>
<li>个人 <code>AGENTS.md</code> 难以团队协作</li>
<li>Skill 可版本化、共享、共建，形成团队知识资产</li>
</ul>
</li>
</ol>
<h3 data-id="heading-22">最佳实践建议</h3>
<p>总结如下实践指南：</p>
<p>对于 Skill 使用者：</p>
<ul>
<li>优先使用官方/专家 Skill：如苹果工程师维护的 Swift  Skill，比社区版更可靠</li>
<li>定期更新 Skills：<code>openskills update avdlee/Swift-Concurrency-Agent-Skill</code></li>
<li>小步验证：先让 Skill 分析单个文件，再扩展到整个项目</li>
<li>审查引用：检查 Skill 建议的引用文档，理解其逻辑，而非盲信</li>
</ul>
<p>对于 Skill 创建者：</p>
<ul>
<li>聚焦单一领域：一个 Skill 只解决一个问题（如只做并发，不做架构）</li>
<li>编写决策树：SKILL.md 必须是决策指南，而非平铺文档</li>
<li>提供可运行示例：在 <code>scripts/</code> 目录提供验证脚本，如：</li>
</ul>
<pre><code class="hljs language-bash" lang="bash">  <span class="hljs-comment"># scripts/validate-actor-isolation.sh</span>
  <span class="hljs-comment"># 自动扫描 @MainActor 冗余情况</span>
</code></pre>
<ul>
<li>版本兼容：明确 Skill 支持的 Swift/Xcode 版本范围</li>
</ul>
<p>对于团队负责人：</p>
<ul>
<li>建立内部 Skill 市场：将团队编码规范封装为 Skill</li>
<li>CI 集成：在 PR 检查中运行 Skill 分析，如：</li>
</ul>
<pre><code class="hljs language-yaml" lang="yaml">  <span class="hljs-comment"># .github/workflows/ai-review.yml</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Run</span> <span class="hljs-string">Swift</span> <span class="hljs-string">Concurrency</span> <span class="hljs-string">Skill</span> <span class="hljs-string">Audit</span>
    <span class="hljs-attr">run:</span> <span class="hljs-string">|
      openskills install team/swift-concurrency-skill
      openskills run audit --skill swift-concurrency --path Sources/
</span></code></pre>
<h3 data-id="heading-23">与传统文档的对比</h3>
<p>Agent Skills 不是取代文档，而是增强：</p>
<pre><code class="hljs language-diff" lang="diff"><span class="hljs-deletion">- 传统文档：人读 → 理解 → 应用（慢、易错）</span>
<span class="hljs-addition">+ Agent Skills：Agent 读 → 直接应用 + 人读 → 学习（快、准确）</span>
</code></pre>
<p>Skill 的双重价值：</p>
<ol>
<li>运行时：Agent 实时指导编码</li>
<li>学习时：开发者阅读参考文档，提升技能</li>
</ol>
<h2 data-id="heading-24">扩展场景与创新应用</h2>
<h3 data-id="heading-25">多 Skill 协同工作</h3>
<p>真实项目中常需多个 Skills 协同：</p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section"># 复杂场景：重构遗留代码</span>
用户："将这个 VIPER 模块重构为 SwiftUI + Concurrency"

Agent 工作流：
<span class="hljs-bullet">1.</span> 加载 swift-architecture-skill (理解 VIPER)
<span class="hljs-bullet">2.</span> 加载 swiftui-skill (理解 SwiftUI 最佳实践)
<span class="hljs-bullet">3.</span> 加载 swift-concurrency-skill (理解并发迁移)
<span class="hljs-bullet">4.</span> 加载 testing-skill (确保重构后覆盖测试)

协同决策：
<span class="hljs-bullet">-</span> Architecture Skill: "VIPER → TCA 或 MVVM"
<span class="hljs-bullet">-</span> SwiftUI Skill: "使用 @StateObject 和 @EnvironmentObject"
<span class="hljs-bullet">-</span> Concurrency Skill: "将 Interactor 的回调改为 async/await"
<span class="hljs-bullet">-</span> Testing Skill: "为新的 ViewModel 编写异步测试"

最终输出：集成各 Skill 建议的综合重构方案
</code></pre>
<p>技术挑战：多 Skill 可能冲突。解决方案：</p>
<ul>
<li>Skill 优先级：<code>&lt;skills_system priority="1"&gt;</code> 控制加载顺序</li>
<li>冲突仲裁：Agent 需识别矛盾建议，请求人工澄清</li>
</ul>
<h3 data-id="heading-26">企业级应用场景</h3>
<p>场景一：金融 App 合规检查</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 创建内部 Skill：financial-compliance-skill</span>
/references
  ├── data-encryption.md      <span class="hljs-comment"># 数据加密规范</span>
  ├── audit-logging.md        <span class="hljs-comment"># 审计日志要求</span>
  └── api-security.md         <span class="hljs-comment"># API 安全标准</span>

<span class="hljs-comment"># 在 CI 中强制检查</span>
openskills run compliance-check --skill financial-compliance
<span class="hljs-comment"># 不通过则阻断 PR 合并</span>
</code></pre>
<p>场景二：跨平台知识库</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-comment"># multi-platform-skill.yaml</span>
<span class="hljs-attr">name:</span> <span class="hljs-string">multi-platform-ui</span>
<span class="hljs-attr">references:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">shared-state-management.md</span>  <span class="hljs-comment"># 通用状态管理</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">ios/</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">swiftui-patterns.md</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">android/</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">composable-patterns.md</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">web/</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">react-patterns.md</span>

<span class="hljs-comment"># Agent 根据项目类型自动路由</span>
</code></pre>
<p>场景三：动态 Skill 生成</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 从内部文档自动生成 Skill</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">generate_skill_from_docs</span>(<span class="hljs-params">doc_path: <span class="hljs-built_in">str</span></span>):
    <span class="hljs-comment"># 1. 解析 Markdown 文档</span>
    <span class="hljs-comment"># 2. 提取决策树（基于标题层次）</span>
    <span class="hljs-comment"># 3. 生成 SKILL.md</span>
    <span class="hljs-comment"># 4. 打包为 GitHub 仓库</span>
    <span class="hljs-keyword">pass</span>

<span class="hljs-comment"># 例如：将团队 Notion 知识库转为 Skill</span>
generate_skill_from_docs(<span class="hljs-string">"https://notion.so/team-guide"</span>)
</code></pre>
<h3 data-id="heading-27">AI 原生开发工作流</h3>
<p>展望未来，Skill 可能成为可交易的编程知识资产：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"skill_marketplace"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"swift-concurrency-expert"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"author"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Apple Engineer"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"price"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"$9.99/month"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"metrics"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">"accuracy"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">98.5</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"adoption"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">12000</span>+<span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"reviews"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">4.9</span>/<span class="hljs-number">5</span>
      <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"updates"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"与 Swift 版本同步发布"</span>
    <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"rxswift-migration-kit"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"author"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"ReactiveX Team"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"price"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Free"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"purpose"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"从 RxSwift 迁移到 Combine/Swift Concurrency"</span>
    <span class="hljs-punctuation">}</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p>这种模式将人类专家知识与AI 效率结合，创造新的知识经济形态。</p>
<h2 data-id="heading-28">参考资料与进一步学习</h2>
<h3 data-id="heading-29">官方资源</h3>
<ol>
<li>
<p>Agent Skills 官网：<a href="https://link.juejin.cn?target=https%3A%2F%2Fagentskills.io%2Fhome" target="_blank" title="https://agentskills.io/home" ref="nofollow noopener noreferrer">agentskills.io/home</a></p>
<ul>
<li>官方规范、示例和工具链</li>
</ul>
</li>
<li>
<p>openskills CLI：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fnumman-ali%2Fopenskills" target="_blank" title="https://github.com/numman-ali/openskills" ref="nofollow noopener noreferrer">github.com/numman-ali/…</a></p>
<ul>
<li>Skill 管理命令行工具</li>
</ul>
</li>
<li>
<p>Swift Concurrency Skill：</p>
<ul>
<li>GitHub：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FAvdLee%2FSwift-Concurrency-Agent-Skill" target="_blank" title="https://github.com/AvdLee/Swift-Concurrency-Agent-Skill" ref="nofollow noopener noreferrer">github.com/AvdLee/Swif…</a></li>
</ul>
</li>
</ol>
<h3 data-id="heading-30">相关技术文档</h3>
<ol>
<li>
<p>Swift Concurrency：</p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fswiftlang%2Fswift-evolution%2Fblob%2Fmain%2Fproposals%2F0296-async-await.md" target="_blank" title="https://github.com/swiftlang/swift-evolution/blob/main/proposals/0296-async-await.md" ref="nofollow noopener noreferrer">SE-0296: async/await</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fswiftlang%2Fswift-evolution%2Fblob%2Fmain%2Fproposals%2F0306-actors.md" target="_blank" title="https://github.com/swiftlang/swift-evolution/blob/main/proposals/0306-actors.md" ref="nofollow noopener noreferrer">SE-0306: Actors</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fswiftlang%2Fswift-evolution%2Fblob%2Fmain%2Fproposals%2F0337-support-incremental-migration-to-concurrency-checking.md" target="_blank" title="https://github.com/swiftlang/swift-evolution/blob/main/proposals/0337-support-incremental-migration-to-concurrency-checking.md" ref="nofollow noopener noreferrer">SE-0337: Strict Concurrency</a></li>
</ul>
</li>
<li>
<p>Default Actor Isolation in Swift 6：<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.avanderlee.com%2Fconcurrency%2Fdefault-actor-isolation-in-swift-6-2%2F" target="_blank" title="https://www.avanderlee.com/concurrency/default-actor-isolation-in-swift-6-2/" ref="nofollow noopener noreferrer">www.avanderlee.com/concurrency…</a></p>
</li>
</ol>
<h3 data-id="heading-31">社区资源</h3>
<ul>
<li>Cursor AI 文档：<a href="https://link.juejin.cn?target=https%3A%2F%2Fcursor.com%2Fcn" target="_blank" title="https://cursor.com/cn" ref="nofollow noopener noreferrer">cursor.com/cn</a></li>
<li>Codex CLI 指南：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fopenai%2Fcodex" target="_blank" title="https://github.com/openai/codex" ref="nofollow noopener noreferrer">github.com/openai/code…</a></li>
<li>AI Development Blog：<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.avanderlee.com%2Fai-development%2F" target="_blank" title="https://www.avanderlee.com/ai-development/" ref="nofollow noopener noreferrer">www.avanderlee.com/ai-developm…</a></li>
</ul>
<h2 data-id="heading-32">最终总结</h2>
<p>Agent Skills 标志着 AI 辅助编程从手工提示工程迈向系统化知识工程。它不仅是文件格式的革新，更是开发范式的进化：</p>
<ol>
<li>对开发者：从重复教 AI 基础知识，到专注项目逻辑</li>
<li>对团队：从口头规范，到可执行、可验证的知识资产</li>
<li>对社区：从散落博客，到标准化、可组合的专家系统</li>
</ol>
<p>行动清单</p>
<p>立即开始尝试 Agent Skills：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 1. 安装 openskills</span>
pip install openskills

<span class="hljs-comment"># 2. 安装第一个 Skill</span>
openskills install avdlee/Swift-Concurrency-Agent-Skill

<span class="hljs-comment"># 3. 同步到你的项目</span>
<span class="hljs-built_in">cd</span> your-project
openskills <span class="hljs-built_in">sync</span>

<span class="hljs-comment"># 4. 在 Cursor/Codex 中提问</span>
<span class="hljs-string">"使用 Skill 优化我的并发代码"</span>

<span class="hljs-comment"># 5. 观察效果，逐步构建自己的 Skills</span>
</code></pre>
<p>未来已来，Agent Skills 让 AI 真正理解你的领域，而非仅仅是模式匹配。</p>
<h2 data-id="heading-33">学习资料</h2>
<ol>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.avanderlee.com%2Fai-development%2Fagent-skills-replacing-agents-md-with-reusable-ai-knowledge%2F" target="_blank" title="https://www.avanderlee.com/ai-development/agent-skills-replacing-agents-md-with-reusable-ai-knowledge/" ref="nofollow noopener noreferrer">www.avanderlee.com/ai-developm…</a></li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[用一个小 Demo，带你入门安卓 Clean Architecture]]></title>    <link>https://juejin.cn/post/7601486204174123058</link>    <guid>https://juejin.cn/post/7601486204174123058</guid>    <pubDate>2026-02-02T00:10:42.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7601486204174123058" data-draft-id="7601028900886462510" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="用一个小 Demo，带你入门安卓 Clean Architecture"/> <meta itemprop="keywords" content="Android"/> <meta itemprop="datePublished" content="2026-02-02T00:10:42.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="潜龙勿用之化骨龙"/> <meta itemprop="url" content="https://juejin.cn/user/2313028195058471"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            用一个小 Demo，带你入门安卓 Clean Architecture
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2313028195058471/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    潜龙勿用之化骨龙
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-02T00:10:42.000Z" title="Mon Feb 02 2026 00:10:42 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-02
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    1
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">前言：为什么你的代码越来越难维护？</h2>
<p>你是否遇到过这些问题：</p>
<ul>
<li>业务逻辑直接写在 <code>Activity / Fragment</code> 里</li>
<li>UI、网络、数据库代码混在一起，牵一发而动全身</li>
<li>一个接口字段改动，整个项目到处报错</li>
<li>想写单元测试，却发现严重依赖 Android Framework</li>
</ul>
<p>如果你对以上情况并不陌生，那么问题往往不是你写得不够努力，而是<strong>项目缺乏清晰的架构设计</strong>。</p>
<p><strong>Clean Architecture（整洁架构）</strong>，正是为了解决这些问题而提出的一种架构思想。</p>
<hr/>
<h2 data-id="heading-1">什么是 Clean Architecture？</h2>
<p><strong>Clean Architecture 不是一个框架，而是一种设计原则。</strong></p>
<p>它的核心目标可以总结为一句话：</p>
<blockquote>
<p><strong>让核心业务逻辑独立于 UI、框架和实现细节。</strong></p>
</blockquote>
<p>也就是说：</p>
<ul>
<li>UI 可以随意更换（XML → Compose）</li>
<li>网络库可以替换（Retrofit → Ktor）</li>
<li>数据来源可以变化（API → 本地数据库）</li>
</ul>
<p>👉 <strong>但业务逻辑几乎不用改动。</strong></p>
<h3 data-id="heading-2">核心原则：依赖倒置（Dependency Rule）</h3>
<p>Clean Architecture 最重要的一条规则是：</p>
<blockquote>
<p><strong>代码的依赖方向，只能从外层指向内层。</strong></p>
</blockquote>
<ul>
<li>内层：业务规则（最稳定）</li>
<li>外层：UI、网络、数据库（最容易变化）</li>
</ul>
<p>📌 内层永远不知道外层的存在</p>
<hr/>
<h2 data-id="heading-3">Clean Architecture 的分层结构</h2>
<p>在 Android 项目中，Clean Architecture 通常可以拆分为三层：</p>
<h3 data-id="heading-4">1️⃣ Presentation（表现层）</h3>
<p><strong>职责：负责 UI 展示和用户交互</strong></p>
<p>常见组件：</p>
<ul>
<li>Activity / Fragment</li>
<li>Jetpack Compose</li>
<li>ViewModel</li>
</ul>
<p>特点：</p>
<ul>
<li>不包含业务规则</li>
<li>只负责管理 UI State</li>
<li>通过 UseCase 调用业务逻辑</li>
</ul>
<hr/>
<h3 data-id="heading-5">2️⃣ Domain（领域层）⭐ 核心层</h3>
<p><strong>职责：定义业务规则和业务模型</strong></p>
<p>包含内容：</p>
<ul>
<li>Entity / Model</li>
<li>UseCase</li>
<li>Repository 接口（抽象）</li>
</ul>
<p>特点：</p>
<ul>
<li>纯 Kotlin</li>
<li>不依赖 Android</li>
<li>不依赖任何第三方库</li>
<li>是整个项目中最稳定的一层</li>
</ul>
<p>📌 这一层承载了项目真正的“业务价值”。</p>
<hr/>
<h3 data-id="heading-6">3️⃣ Data（数据层）</h3>
<p><strong>职责：负责数据从哪里来、如何获取</strong></p>
<p>包含内容：</p>
<ul>
<li>网络请求（API）</li>
<li>本地数据库</li>
<li>Repository 的具体实现</li>
</ul>
<p>特点：</p>
<ul>
<li>实现 Domain 层定义的接口</li>
<li>可以自由切换数据来源</li>
<li>是变化最频繁的一层</li>
</ul>
<hr/>
<h2 data-id="heading-7"><code>CleanArc</code> 项目实践</h2>
<p>接下来，我们通过一个简单的示例项目 <strong>CleanArc</strong>，来看看 Clean Architecture 在真实 Android 项目中是如何落地的。</p>
<p>🎯 项目目标很简单：</p>
<blockquote>
<p><strong>从服务器获取用户列表，并将其展示在界面上</strong></p>
</blockquote>
<hr/>
<h2 data-id="heading-8">Data 层：数据的来源（How）</h2>
<p>Data 层只关心一件事：</p>
<blockquote>
<p><strong>我如何把数据拿到？</strong></p>
</blockquote>
<h3 data-id="heading-9">Repository 实现</h3>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fef8074fe1054699ac8efe7c6a05d763~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5r2c6b6Z5Yu_55So5LmL5YyW6aqo6b6Z:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770595842&amp;x-signature=lqKvt7SKd04u0kQeYPBAAW20%2B5A%3D" alt="image.png" loading="lazy"/></p>
<p>📌 在本项目中，<strong>异常是在 Repository 层中被处理的</strong>。
Repository 最清楚异常的来源，因此在这里将技术异常转换为业务可理解的结果。</p>
<hr/>
<h2 data-id="heading-10">Domain 层：核心业务逻辑（What）</h2>
<p>Domain 层只关心：</p>
<blockquote>
<p><strong>我要做什么，而不是怎么做</strong></p>
</blockquote>
<h3 data-id="heading-11">Repository 接口（契约）</h3>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3f08b4c0205348018e7c1292f2088c0d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5r2c6b6Z5Yu_55So5LmL5YyW6aqo6b6Z:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770595842&amp;x-signature=e8Bqwbao19ASJKDPPyrIur3mgwE%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-12">UseCase：业务行为的封装</h3>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ae2d99513b8241d5924ace93bb3ce7a7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5r2c6b6Z5Yu_55So5LmL5YyW6aqo6b6Z:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770595842&amp;x-signature=pvp%2BCgOUrf4hLr1BrFR%2Ffvdo6Vs%3D" alt="image.png" loading="lazy"/></p>
<p>📌 UseCase 不负责捕获异常
📌 它只组合和执行业务规则
📌 Domain 层因此保持高度纯净</p>
<hr/>
<h2 data-id="heading-13">Presentation 层：UI 展示（Show）</h2>
<p>Presentation 层负责将数据转换为用户可感知的界面状态。</p>
<h3 data-id="heading-14">ViewModel</h3>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9bbd9eaec32c4841a6c79bb816acd6d6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5r2c6b6Z5Yu_55So5LmL5YyW6aqo6b6Z:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770595842&amp;x-signature=euHVIi8Y1TQ8ErOtOU6iLEY10Tw%3D" alt="image.png" loading="lazy"/></p>
<p>特点：</p>
<ul>
<li>ViewModel 不直接依赖 Repository</li>
<li>只通过 UseCase 与 Domain 层交互</li>
<li>专注于 UI State 管理</li>
</ul>
<p>UI（Compose / XML）只需根据 State 渲染界面。</p>
<hr/>
<h2 data-id="heading-15">关于异常处理：为什么放在 Repository 层？</h2>
<p>在本项目中，<strong>异常处理主要集中在 Repository（Data 层）中完成</strong>，而不是在 UseCase 层统一 try-catch。</p>
<p>原因包括：</p>
<ul>
<li>Repository 最了解异常的真实来源（网络、数据库、解析）</li>
<li>可以在这里将技术异常转换为业务错误</li>
<li>避免将 Retrofit、HTTP Code 等细节泄露到 Domain 层</li>
<li>保持 Domain 层的纯净和稳定</li>
</ul>
<p>这种做法在 Android 工程实践中非常常见，也更利于长期维护。</p>
<hr/>
<h2 data-id="heading-16">依赖注入：将各层连接起来</h2>
<p>为了将接口和实现解耦，本项目使用 <strong>Koin</strong> 进行依赖注入：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/63423494b6e641cdb2a498afcff35225~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5r2c6b6Z5Yu_55So5LmL5YyW6aqo6b6Z:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770595842&amp;x-signature=LqcB7EogJ0HZofg2eX1uyv2YdY0%3D" alt="image.png" loading="lazy"/></p>
<p>通过依赖注入：</p>
<ul>
<li>Domain 层只定义接口</li>
<li>Data 层提供实现</li>
<li>Presentation 层只消费能力</li>
<li>各层之间无直接耦合</li>
</ul>
<hr/>
<h2 data-id="heading-17">总结</h2>
<p>通过 <code>CleanArc</code> 这个示例项目，我们可以看到 Clean Architecture 带来的价值：</p>
<ul>
<li>✅ <strong>关注点分离</strong>：UI、业务、数据各司其职</li>
<li>✅ <strong>可测试性强</strong>：UseCase 和 ViewModel 易于单元测试</li>
<li>✅ <strong>高可维护性</strong>：修改数据来源不会影响业务层</li>
<li>✅ <strong>适合长期演进的项目</strong></li>
</ul>
<p>Clean Architecture 对于中大型项目来说，它能显著降低维护成本，让代码结构更加清晰、可控。</p>
<hr/>
<h2 data-id="heading-18">示例代码</h2>
<p>📦 项目完整代码已上传至 GitHub：</p>
<p>👉 <strong>CleanArc 示例项目</strong>
🔗 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FThirdPrince%2FCleanArc" target="_blank" title="https://github.com/ThirdPrince/CleanArc" ref="nofollow noopener noreferrer">github.com/yourname/Cl…</a></p>
<p>欢迎 Star ⭐。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[读完书容易忘？这个开源 AI 应用能帮你！]]></title>    <link>https://juejin.cn/post/7601706140200108095</link>    <guid>https://juejin.cn/post/7601706140200108095</guid>    <pubDate>2026-02-02T02:17:52.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7601706140200108095" data-draft-id="7601464318409785386" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="读完书容易忘？这个开源 AI 应用能帮你！"/> <meta itemprop="keywords" content="前端,程序员,开源"/> <meta itemprop="datePublished" content="2026-02-02T02:17:52.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="ssshooter"/> <meta itemprop="url" content="https://juejin.cn/user/3122268751795101"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            读完书容易忘？这个开源 AI 应用能帮你！
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3122268751795101/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    ssshooter
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-02T02:17:52.000Z" title="Mon Feb 02 2026 02:17:52 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-02
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>其实我们不必回避看完书就忘的问题，因为大多数人看书都是会忘的。其实人类的大脑就是这么设计的，它会过滤掉大部分不重要的信息，只保留下重要的信息。如果真的想要记住一本书重要的知识，需要反复阅读，反复思考，反复练习。</p>
<p>在前 AI 时代，做读书笔记是一件非常耗费精力的事情，但是有大模型之后，我们可以在做笔记这件事上偷偷懒。</p>
<p><strong>注意：做笔记可以偷懒，但是思考和反复回看是绝对不能偷懒的。</strong></p>
<p>那么有什么好用的工具呢？朋友们，有的！欢迎使用 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FSSShooter%2Febook-to-mindmap" target="_blank" title="https://github.com/SSShooter/ebook-to-mindmap" ref="nofollow noopener noreferrer">ebook-to-mindmap</a>！简单来说，你可以通过 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FSSShooter%2Febook-to-mindmap" target="_blank" title="https://github.com/SSShooter/ebook-to-mindmap" ref="nofollow noopener noreferrer">ebook-to-mindmap</a> 把 pdf 或 epub 格式的电子书转换为分章节的思维导图或者文字总结。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ae8178b399294c2aaf146488bd9c4d41~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc3NzaG9vdGVy:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770603472&amp;x-signature=NEDv08BQW0EsCQIDi4Sp%2FUQFIiA%3D" alt="思维导图模式" loading="lazy"/></p>
<p>点击<a href="https://link.juejin.cn?target=https%3A%2F%2Febook2me-next.mind-elixir.com%2F" target="_blank" title="https://ebook2me-next.mind-elixir.com/" ref="nofollow noopener noreferrer">这里</a>即可立即体验。整个网页应用功能比较简洁，大家可以直接上手，当然，下面我也会比较详细地介绍一下这个应用的使用方法🤗</p>
<h2 data-id="heading-0">模型配置</h2>
<p>使用 ebook-to-mindmap 的第一步是配置模型。它和很多 AI 应用一样，都是选择 <strong>byok</strong>（Bring Your Own Key）的模式，你可以在这里配置你自己的大模型。</p>
<p>这里还是要强调一下，在 ebook-to-mindmap 填写 Key 时不必担心 Key 泄露，因为 <strong>Key 只是保存在你自己的浏览器里</strong>，请求也是直接从你的浏览器发送到大模型提供商的服务器的。你可以在浏览器的开发者工具里查看网络请求，确认这一点。同时，<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FSSShooter%2Febook-to-mindmap" target="_blank" title="https://github.com/SSShooter/ebook-to-mindmap" ref="nofollow noopener noreferrer">ebook-to-mindmap</a> 作为一个开源项目你可以随时检视它的代码，还可以自己部署一个属于你的 ebook-to-mindmap。</p>
<p>说回模型的选择，可能很多人会担心使用 ebook-to-mindmap 的花费太高，其实倒也不必，毕竟现阶段还是能找到很多免费或者低价的大模型。我的首推还是 <a href="https://link.juejin.cn?target=https%3A%2F%2Fopenrouter.ai%2F" target="_blank" title="https://openrouter.ai/" ref="nofollow noopener noreferrer"><strong>openrouter</strong></a>，你只需要充值 10 刀，就能获得一个较大的免费模型（其中包括一些 deepseek 变体、最近小米的新模型、之前一段时间还有 grok）使用额度，基本上一天让它处理好几本书都没问题了。其他详细推荐可以参考<a href="https://link.juejin.cn?target=https%3A%2F%2Fssshooter.com%2Fai-services-guide%2F" target="_blank" title="https://ssshooter.com/ai-services-guide/" ref="nofollow noopener noreferrer">免费和付费 AI API 选择指南</a>。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b7df7825c97547888d450112acbe2869~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc3NzaG9vdGVy:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770603472&amp;x-signature=S1Rf%2FUOaLRPoqInIfZ2pREa8UJ4%3D" alt="model list" loading="lazy"/></p>
<p>在获取到 Key 后如上图填写信息即可。</p>
<p>你还可以配置多个模型，点击左侧的星星后会成为默认模型，后续处理时默认使用星标的模型：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fb539405ba5f4eb4838d981a0a99f21a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc3NzaG9vdGVy:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770603472&amp;x-signature=xT%2BODB72MtLSA3KS3iUt12ABcf4%3D" alt="model list" loading="lazy"/></p>
<h2 data-id="heading-1">生成笔记</h2>
<p>配置模型后，在主页选择电子书即可。之后 ebook-to-mindmap 会自动识别电子书的格式，然后开始识别章节：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5bb41bd7f5f241f08b87cebb770c4d64~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc3NzaG9vdGVy:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770603472&amp;x-signature=74t4%2B3dFb9pX1NN098zcbdcp4GU%3D" alt="AI 总结页面" loading="lazy"/></p>
<blockquote>
<p>[!TIP]
提示：如果 epub 无法获取到章节，可以在设置里勾选使用 Spine 获取章节</p>
</blockquote>
<p>章节识别成功后，选择你需要总结的章节，或者使用分组功能（可以使用快捷键 Ctrl + G）把零碎的章节组合成分组一起发送给 AI 处理。</p>
<p>一切准备好后，点击开始解释按钮即可开始生成笔记。</p>
<p>默认情况下，ebook-to-mindmap 会生成<strong>思维导图</strong>，你也可以点击小齿轮切换到<strong>文字总结</strong>模式：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b3406b66a9484e2dae227d066545f242~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc3NzaG9vdGVy:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770603472&amp;x-signature=hUmw%2FJq3eIlmjk4MvzKt63STog8%3D" alt="模式切换" loading="lazy"/></p>
<blockquote>
<p>[!TIP]
虽然有整书思维导图生成功能，但是如果书的内容比较长，AI 可能吃不下这么长的上下文，所以建议还是分章节生成，最后系统会自动拼接</p>
</blockquote>
<p>生成笔记如果想要中途取消，放心点取消就好，<strong>之前处于完成状态的章节会被缓存</strong>，不用担心之后需要再浪费 Token 重新生成。</p>
<h2 data-id="heading-2">提示词</h2>
<p>举个例子吧，你在提示词列表里添加一个“小·红书风格”提示词，在生成环节选择这个提示词，就能直接生成小红书风格的笔记。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9977cb633e3f4ef685ba3dd47198c004~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc3NzaG9vdGVy:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770603472&amp;x-signature=5joPgw9qpFUe8rY1R4mM8CfCpyA%3D" alt="小红书风格" loading="lazy"/></p>
<p>不止小红书风格，你也可以让 AI 只简单地提取该章节最重要的 5 个观点，帮助你对整本书的主要内容有一个简要的了解。</p>
<p>你还可以使用“反论法”提示词：</p>
<pre><code class="hljs">选取本章的核心论点或思想，并探索它的对立面。如果作者要为相反的观点辩护，他们需要证明什么？文本中是否有无意间支持反面观点的蛛丝马迹？
</code></pre>
<p>参考<a href="https://link.juejin.cn?target=https%3A%2F%2Fssshooter.com%2Fnotebooklm-prompt%2F" target="_blank" title="https://ssshooter.com/notebooklm-prompt/" ref="nofollow noopener noreferrer">分享几条有意思的 NotebookLM 提示词</a>这篇文章，里面有几个有趣的提示词，或许能让你眼前一亮。</p>
<h2 data-id="heading-3">内容管理</h2>
<p>ebook-to-mindmap 充满了下载按钮，是的，你生成的数据必须还是属于你的！你可以很轻易地把数据拿出来！</p>
<p>导出的文字内容可能是 markdown 文件或是思维导图 json 文件。</p>
<p>markdown 文件可以直接阅读，或者导入到 Obsidian、Notion 等笔记软件再细化修改。</p>
<p>思维导图 json 文件可以使用 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FSSShooter%2Fmind-elixir-core" target="_blank" title="https://github.com/SSShooter/mind-elixir-core" ref="nofollow noopener noreferrer">mind-elixir-core</a> 等前端库渲染，当然，如果你是技术人员，理解 json 数据的结构你也可以随意修改和渲染。</p>
<p>思维导图亦可导出为图片，点击思维导图页面右上角的下载按钮即可。</p>
<h2 data-id="heading-4">格式选择</h2>
<p>最后谈谈电子书格式的问题，ebook-to-mindmap 支持 pdf 和 epub 格式的电子书，但是这两种格式如何选择呢？</p>
<p>或许大家都会比较喜欢看 pdf，因为看起来比较工整，但是使用 ebook-to-mindmap，我还是比较<strong>推荐 epub 格式</strong>的电子书。</p>
<p>稍微讲一下 pdf 和 epub 的原理吧。</p>
<p>pdf 的特点是在任何设备上看起来都一样，这就很容易想到，其实 pdf 的排版是非常固定的，而且更重要的是，pdf 的排版是没有语义的。也就是说，人类能看到一个标题是加粗黑字，但是 pdf 本身并不知道这是一个标题，它只是知道这一块区域的文字是加粗黑字的。</p>
<p>更严重的问题是 pdf 如果有一些复杂的排版，例如在角落嵌入一段文字，在解释的时候就很难理解那段文字的意义。所以，大模型理解 pdf 的难度会比较大。</p>
<p>而 epub 格式就不一样，它更像是一张网页，有语义，有结构，有层次，就跟 HTML 差不多。但缺点就是人类看来这样的排版有点粗糙，在不同的阅读器上显示效果也不同。在某些落后的 epub 阅读器上阅读时可能会觉得排版很有年代感。但是大模型不在乎排版，有清晰的结构就能得到好的输出结果。</p>
<h2 data-id="heading-5">写在最后</h2>
<p>总的来说，<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FSSShooter%2Febook-to-mindmap" target="_blank" title="https://github.com/SSShooter/ebook-to-mindmap" ref="nofollow noopener noreferrer">ebook-to-mindmap</a> 是一个能帮你快速复习或者把书本变薄的工具。在这个信息爆炸的时代，高效地获取和整理知识变得越来越重要。希望这个小工具能成为你阅读路上的得力助手，让你把更多的时间花在深度思考和理解上，而不是机械地摘抄。</p>
<p>如果你觉得这个项目对你有帮助，欢迎在 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FSSShooter%2Febook-to-mindmap" target="_blank" title="https://github.com/SSShooter/ebook-to-mindmap" ref="nofollow noopener noreferrer">GitHub</a> 上点个 Star ⭐️ 支持一下！如果你有任何建议或发现了 bug，也欢迎提 Issue 或者加入讨论。</p>
<p>Happy Reading!</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[我为什么讨厌继承？]]></title>    <link>https://juejin.cn/post/7601384029611425807</link>    <guid>https://juejin.cn/post/7601384029611425807</guid>    <pubDate>2026-02-02T01:26:08.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7601384029611425807" data-draft-id="7597722671084699682" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="我为什么讨厌继承？"/> <meta itemprop="keywords" content="Android,Kotlin,设计模式"/> <meta itemprop="datePublished" content="2026-02-02T01:26:08.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="RockByte"/> <meta itemprop="url" content="https://juejin.cn/user/1046390797768519"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            我为什么讨厌继承？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1046390797768519/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    RockByte
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-02T01:26:08.000Z" title="Mon Feb 02 2026 01:26:08 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-02
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:2;font-weight:400;font-size:15px;overflow-x:hidden;color:#333;letter-spacing:1.2px}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1:first-child,.markdown-body h2:first-child,.markdown-body h3:first-child,.markdown-body h4:first-child,.markdown-body h5:first-child,.markdown-body h6:first-child{margin-top:-1.5rem;margin-bottom:1rem}.markdown-body h1:before,.markdown-body h2:before,.markdown-body h3:before,.markdown-body h4:before,.markdown-body h5:before,.markdown-body h6:before{content:"#";display:inline-block;color:#3eaf7c;padding-right:.23em}.markdown-body h1{position:relative;font-size:2.5rem;margin-bottom:5px}.markdown-body h1:before{font-size:2.5rem}.markdown-body h2{padding-bottom:.5rem;font-size:2.2rem;border-bottom:1px solid #ececec}.markdown-body h3{font-size:1.5rem;padding-bottom:0}.markdown-body h4{font-size:1.25rem}.markdown-body h5{font-size:1rem}.markdown-body h6{margin-top:5px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body strong{color:#3eaf7c}.markdown-body img{max-width:100%;border-radius:2px;display:block;margin:auto}.markdown-body hr{border:none;border-top:1px solid #3eaf7c;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;overflow-x:auto;padding:.2rem .5rem;margin:0;color:#3eaf7c;font-size:.85em;background-color:rgba(27,31,35,.05);border-radius:3px}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75;border:.5rem solid #3eaf7c}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{font-weight:500;text-decoration:none;color:#3eaf7c;margin:0 5px}.markdown-body a:active,.markdown-body a:hover{text-decoration:none;border-bottom:1.5px solid #3eaf7c}.markdown-body a[href^=http]:after{content:url("data:image/svg+xml;base64,PHN2ZyBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB3aWR0aD0iMTQiIGhlaWdodD0iMTQiPjxkZWZzPjxzdHlsZS8+PC9kZWZzPjxwYXRoIGQ9Ik04MzIgMTI4SDY0MHY2NGgxNDYuNzUyTDUyMS4zNzYgNDU3LjM3Nmw0NS4yNDggNDUuMjQ4TDgzMiAyMzcuMjQ4VjM4NGg2NFYxMjh6IiBmaWxsPSIjM2VhZjdjIi8+PHBhdGggZD0iTTc2OCA4MzJIMTkyVjI1NmgzNTJ2LTY0SDE2MGEzMiAzMiAwIDAwLTMyIDMydjY0MGEzMiAzMiAwIDAwMzIgMzJoNjQwYTMyIDMyIDAgMDAzMi0zMlY0ODBoLTY0djM1MnoiIGZpbGw9IiMzZWFmN2MiLz48L3N2Zz4=");margin-left:2px}.markdown-body a[href^="#"]:before{content:"#"}.markdown-body table{display:inline-block!important;font-size:13px;width:auto;max-width:100%;overflow:auto;border:1px solid #3eaf7c;border-collapse:collapse}.markdown-body thead{background:#3eaf7c;color:#fff;text-align:left}.markdown-body tr:nth-child(2n){background-color:rgba(153,255,188,.1)}.markdown-body td,.markdown-body th{padding:4px 8px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#7b7878;padding:1px 23px;border-left:.5rem solid;border-color:#42b983;background-color:rgba(66,184,131,.1);position:relative;margin:14px 8px 0}.markdown-body blockquote:before{display:inline-block;position:absolute;content:url("data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjUiIGhlaWdodD0iMjUiIHZpZXdCb3g9IjAgMCAyNyAyNyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxLjg2MiAxLjg2MikiIGZpbGwtcnVsZT0ibm9uemVybyIgZmlsbD0ibm9uZSI+PGNpcmNsZSBzdHJva2U9IiNGRkYiIHN0cm9rZS13aWR0aD0iMS43MjQiIGZpbGw9IiM0MkI5ODMiIGN4PSIxMS42MzgiIGN5PSIxMS42MzgiIHI9IjExLjYzOCIvPjxwYXRoIGQ9Ik0xNC45NzggNi4yN0E1LjAwNiA1LjAwNiAwIDAwNi42NyA5LjQ2OGE0LjkwMSA0LjkwMSAwIDAwMS43NzMgNC4zNjJjLjMyMy4yNTguNTE0LjY0Ny41MjIgMS4wNnYxLjA2YTIuNjg1IDIuNjg1IDAgMDA1LjM3IDB2LTEuMDA4Yy4wMDItLjM5OC4xNzMtLjc3Ny40Ny0xLjA0MmE1LjAyMyA1LjAyMyAwIDAwLjE3My03LjYzem0tMy4zMzcgMTAuOTY3YTEuMzA0IDEuMzA0IDAgMDEtMS4yODYtMS4yODd2LS4yNzhoMi41NzJ2LjI2MWMwIC43MTMtLjU3MyAxLjI5NC0xLjI4NiAxLjMwNHptMi4yNi00LjQxNWMtLjQ0LjM4My0uNzUuODkzLS44ODcgMS40NmgtMi43NDZhMi44NjggMi44NjggMCAwMC0uOTM4LTEuNTNoLS4wMThhMy40NzYgMy40NzYgMCAwMS0xLjI2OS0zLjE0NSAzLjYxNSAzLjYxNSAwIDAxNy4xOTYuNCAzLjY1IDMuNjUgMCAwMS0xLjMzOCAyLjgxNXoiIGZpbGw9IiNGRkYiLz48L2c+PC9zdmc+");width:25px;height:25px;left:-16px;top:12px}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body details{outline:none;border:none;border-left:4px solid #3eaf7c;padding-left:10px;margin-left:4px}.markdown-body details summary{cursor:pointer;border:none;outline:none;background:#fff;margin:0 -17px}.markdown-body details summary::-webkit-details-marker{color:#3eaf7c}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body ol li::marker{color:#3eaf7c}.markdown-body ul li{list-style:none;padding-left:10px}.markdown-body ul li::marker{content:"•";color:#3eaf7c}.markdown-body ul li.task-list-item:before{content:"";margin-right:0}.markdown-body input[type=checkbox]{vertical-align:text-bottom;box-shadow:inset 0 0 0 10px #fff}.markdown-body input[type=checkbox]:before{content:url("data:image/svg+xml;base64,PHN2ZyBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB3aWR0aD0iMTYiIGhlaWdodD0iMTYiPjxkZWZzPjxzdHlsZS8+PC9kZWZzPjxwYXRoIGQ9Ik04NzcuMDU2IDE0Ni45NDR2NzMwLjExMkgxNDYuOTQ0VjE0Ni45NDRoNzMwLjExMnptMC0xMDQuMjc3SDE0Ni45NDRjLTU3LjYyOCAwLTEwNC4yNzcgNDYuNjQ5LTEwNC4yNzcgMTA0LjI3N3Y3MzAuMTEyYzAgNTcuNjI4IDQ2LjY0OSAxMDQuMjc3IDEwNC4yNzcgMTA0LjI3N2g3MzAuMTEyYzU3LjYyOCAwIDEwNC4yNzctNDYuNjQ5IDEwNC4yNzctMTA0LjI3N1YxNDYuOTQ0YzAtNTcuNjI4LTQ2LjY0OS0xMDQuMjc3LTEwNC4yNzctMTA0LjI3N3oiIGZpbGw9IiMzZWFmN2MiLz48L3N2Zz4=");position:relative;top:-2px;right:2px}.markdown-body input[type=checkbox]:checked:before{content:url("data:image/svg+xml;base64,PHN2ZyBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB3aWR0aD0iMTUiIGhlaWdodD0iMTUiPjxkZWZzPjxzdHlsZS8+PC9kZWZzPjxwYXRoIGQ9Ik05MTAuMjA4IDBIMTEzLjc2QTExNC4xMTIgMTE0LjExMiAwIDAwLS4wMzIgMTEzLjc5MlY5MTAuMjRjMCA2Mi41OTIgNTEuMiAxMTMuNzkyIDExMy43OTIgMTEzLjc5Mmg3OTYuNDQ4YzYyLjU5MiAwIDExMy43OTItNTEuMiAxMTMuNzkyLTExMy43OTJWMTEzLjc5MkMxMDI0IDUxLjIgOTcyLjggMCA5MTAuMjA4IDB6bS01MTIgNzk2LjQ0OEwxMTMuNzYgNTEybDc5LjY0OC03OS42NDggMjA0LjggMjA0LjhMODMwLjU2IDIwNC44bDc5LjY0OCA3OS42NDgtNTEyIDUxMnoiIGZpbGw9IiMzZWFmN2MiLz48L3N2Zz4=");position:relative;top:-2px;right:2px}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="xcode">.markdown-body pre,.markdown-body pre&gt;code.hljs{background:#fff;color:#000}.xml .hljs-meta{color:silver}.hljs-comment,.hljs-quote{color:#007400}.hljs-attribute,.hljs-keyword,.hljs-literal,.hljs-name,.hljs-selector-tag,.hljs-tag{color:#aa0d91}.hljs-template-variable,.hljs-variable{color:#3f6e74}.hljs-code,.hljs-meta-string,.hljs-string{color:#c41a16}.hljs-link,.hljs-regexp{color:#0e0eff}.hljs-bullet,.hljs-number,.hljs-symbol,.hljs-title{color:#1c00cf}.hljs-meta,.hljs-section{color:#643820}.hljs-built_in,.hljs-builtin-name,.hljs-class .hljs-title,.hljs-params,.hljs-type{color:#5c2699}.hljs-attr{color:#836c28}.hljs-subst{color:#000}.hljs-formula{background-color:#eee;font-style:italic}.hljs-addition{background-color:#baeeba}.hljs-deletion{background-color:#ffc8bd}.hljs-selector-class,.hljs-selector-id{color:#9b703f}.hljs-doctag,.hljs-strong{font-weight:700}.hljs-emphasis{font-style:italic}</style><p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bc52bda5809d440d95f07706efade322~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgUm9ja0J5dGU=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770600367&amp;x-signature=ZyRqsw2fw2gZi2bCF8Q3zCyZp0s%3D" alt="a.png" loading="lazy"/></p>
<p>我在之前的一篇文章<a href="https://juejin.cn/post/7599910677578874880" target="_blank" title="https://juejin.cn/post/7599910677578874880">精通 Rust 宏 — 第一个宏</a>中提到过，我讨厌继承。</p>
<p>第二天中午我同事跑过来问我，这东西现在语言都有，你有什么讨厌的？</p>
<p>我问他，你还记得面向对象的三要素吗？</p>
<p>他说：封装，继承...，然后...，多态！</p>
<p>我上大学学习 Java 的时候，很多相关书籍都会讲解这三要素，以现在的我看来，封装和多态是必要的。</p>
<p>但是继承...</p>
<h2 data-id="heading-0">继承有什么问题</h2>
<p>在我刚参加工作的第三年，我参与到了中国移动和地图 App 的开发工作中，当时我负责改造该 App 的核心网络请求模块。</p>
<p>那个时候还没有流行使用 <strong>OkHttp</strong> ，更没有 <strong>Retrofit</strong> 这种优秀的网络开源库，整体还是使用原始的 <strong>HttpConnection</strong> 去完成网络请求，自己封装里面的实现逻辑。</p>
<p>我当时理解完需求之后，整理了网络库需要满足的功能，大概如下：</p>
<ol>
<li>完成对数据的序列化和反序列化。</li>
<li>完成对数据的加密解密。</li>
<li>返回纯文本的数据结构。</li>
<li>返回 <strong>JSONObject</strong> 的数据结构。</li>
<li>返回基于 Java 对象的数据结构。</li>
</ol>
<p>自然而然，我想到了这种方案，</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9df7fb263a9e461783f7fc1d063d6c53~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgUm9ja0J5dGU=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770600367&amp;x-signature=ztQz%2Bhn6xW3F3SsPMMju1nbSdqQ%3D" alt="0.png" loading="lazy"/></p>
<ol>
<li>首先，<code>BaseHttp</code> 作为基类，负责序列化和反序列化和加解密，因为从目前看来，一个请求一定会有这两个需求。</li>
<li><code>TextHttp</code> 继承 <code>BaseHttp</code>，将其字节码转换成文本。</li>
<li><code>JsonHttp</code> 继承 <code>TextHttp</code>，将文本转换成 <code>JSONObject</code> 结构。</li>
<li>以此类推。。。</li>
</ol>
<p>一开始，这样做非常方便，例如：如果一个请求只需要获取文本内容，那么就直接继承 <code>TextHttp</code>。</p>
<p>也就是说，一个请求需要实现哪些能力，那么就继承那个基类就好了。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2c539669eb55469188b91007dca066fa~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgUm9ja0J5dGU=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770600367&amp;x-signature=v4mDSqZMlKuOBHMc64o12DtnOM0%3D" alt="1.png" loading="lazy"/></p>
<p>而使用这个网络库的人，只需要按照 API 文档中的 API 名称，用这个请求就行了，例如 <code>Sell</code> -&gt; <code>SellHttp</code>，<code>Login</code> -&gt; <code>LoginHttp</code>，用起来会非常方便！</p>
<p>但是后续改动，让我越来越 Hold 不住这种继承链了：有的 API 需要鉴权，有的不需要；部分 API 会有不同的 Header；有的 API 返回结果加密方式和之前的不一样。</p>
<p>慢慢的，我发现我的继承链越来越长，为了让我的 API 使用保持简洁，甚至出现了类似菱形继承的情况（这里不是说 Java 可以菱形继承）：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ce3846fd44c94469a6115242e3c0464b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgUm9ja0J5dGU=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770600367&amp;x-signature=uniKjDNCZDHCXM0ScheHQB6xABc%3D" alt="2.png" loading="lazy"/></p>
<p>实际上 <code>SHACryptJsonHttp</code> 包括其基类有大量相似的代码，只是鉴权方式问题，导致我不得不重新改写整个继承链（这里只是一个示例，真实情况比这个复杂的多）。</p>
<p>后面这种问题越来越多，虽然同事们用起来非常方便（对照文档直接 <code>new</code> 即可），但是对我的维护造成了巨大负担，同时也会犯一些非常低级的错误，例如搞错了鉴权方式！</p>
<p>为什么会这样呢？</p>
<h2 data-id="heading-1">一句话总结</h2>
<p>“继承”这个特性，本来想干三件事，结果三件事互相打架，最后搞得谁都不开心。</p>
<p>好的，我来换个思路解释，以 Java 这种语言为例：</p>
<p>比如你写一个 <code>Animal</code> 类，再写一个 <code>Dog</code> 类继承它，这样 <code>Dog</code> 就自动有了 <code>Animal</code> 的所有方法和属性。</p>
<p>听起来很美好，对吧？（当时我就是这么认为的）</p>
<p>但问题来了——<strong>我们其实用“继承”做了三件完全不同的事</strong>，而这三件事根本不是一回事！</p>
<h3 data-id="heading-2">第一件事：分类 —— 这东西属于哪一类</h3>
<p>比如：“正方形是一种矩形”，“狗是一种动物”。</p>
<p>这是从<strong>现实世界逻辑</strong>出发的，叫“本体论”（别被名字吓到，就是“分类”的意思）。</p>
<p>这合理啊，正方形确实是矩形的一种特殊情况。</p>
<h3 data-id="heading-3">第二件事： 能替换吗 —— 程序能不能当同一种东西用</h3>
<p>比如：如果一个函数要求传入一个 <code>Rectangle</code>（矩形），那我能传一个 <code>Square</code>（正方形）进去吗？</p>
<p>如果可以，就叫“可替换”，这是<strong>程序正确性</strong>的问题。</p>
<p>但现实中不行！因为矩形可以改宽高，而正方形一改宽高就不是正方形了。</p>
<p>所以：<strong>虽然“正方形是矩形”在数学上成立，但在代码里不能随便替换！</strong></p>
<blockquote>
<p>这就是著名的 <strong>“正方形-矩形悖论”</strong> —— 看似合理，实则坑人。</p>
</blockquote>
<h3 data-id="heading-4">第三件事：  省代码 —— 别重复写一样的代码</h3>
<p>比如：<code>Dog</code> 和 <code>Cat</code> 都有 <code>eat()</code> 方法，于是让它们都继承 <code>Animal</code>，把 <code>eat()</code> 写在父类里。</p>
<p>这纯粹是为了<strong>偷懒/复用代码</strong>，跟“是不是动物”没关系。</p>
<p>好处：少写代码。</p>
<p>风险：万一以后某个“动物”不吃东西（比如机器人宠物），你就得硬改，或者搞一个新的继承链，破坏设计。</p>
<h2 data-id="heading-5">问题来了</h2>
<p>Java <strong>只给了你一个“继承”关键字</strong>，却让你同时干这三件事。</p>
<p>结果：</p>
<ul>
<li>你以为你在“分类”（正方形是矩形），</li>
<li>但程序要求你“能替换”（正方形必须能当矩形用），</li>
<li>而你实际只是为了“省代码”（不想重复写宽高设置）。</li>
</ul>
<p><strong>三件事混在一起，必然出问题！</strong></p>
<p>就像公司里面的团队，虽然大家都属于同一个组，但是如果目标不一致，这必然导致开发问题！</p>
<h2 data-id="heading-6">那怎么办</h2>
<p>这是我后来，才学到的知识。</p>
<p><strong>别用“继承”干所有事！分开处理：</strong></p>





















<table><thead><tr><th>你想干啥</th><th>正确做法</th></tr></thead><tbody><tr><td><strong>想分类？</strong></td><td>用<strong>领域模型</strong>画图就行，别非塞进代码继承树里。</td></tr><tr><td><strong>想保证能替换？</strong></td><td>用<strong>接口（Interface）</strong> 或 <strong>协议（Protocol）</strong> ，明确约定行为。</td></tr><tr><td><strong>想省代码？</strong></td><td>用<strong>组合（Composition）</strong> + <strong>委托（Delegation）</strong> ，比如让 <code>Dog</code> 里面“包含”一个 <code>Eater</code> 对象，而不是继承 <code>Animal</code>。</td></tr></tbody></table>
<p>还记得那句经典的建议吗：“<strong>优先使用组合，而不是继承。</strong> ”</p>
<p>来，举个例子，假设你要做“交通工具”系统：</p>
<ul>
<li>
<p><strong>错误做法（用继承干三件事）</strong>：</p>
<pre><code class="hljs language-Java" lang="Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vehicle</span> { <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">()</span> {} }
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Vehicle</span> { }      <span class="hljs-comment">// 是Vehicle，能替换，还复用了move()</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Airplane</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Vehicle</span> { } <span class="hljs-comment">// 同上</span>
</code></pre>
<p>→ 这就是我早期开发 Http 框架时候的做法。问题来了，如果以后加个 <code>Hovercraft</code>（气垫船），它既能走陆地又能走水，继承哪个？</p>
</li>
<li>
<p><strong>正确做法（分开处理）：</strong></p>
<pre><code class="hljs language-Java" lang="Java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Drivable</span> { <span class="hljs-keyword">void</span> <span class="hljs-title function_">drive</span><span class="hljs-params">()</span>; }
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Flyable</span> { <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span>; }

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Drivable</span> { ... }
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Airplane</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Flyable</span> { ... }
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Hovercraft</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Drivable</span>, Floatable { ... } <span class="hljs-comment">// 多实现，灵活！</span>
</code></pre>
<p>→ 分类归分类（你是车还是飞机），行为归行为（你会开还是会飞），代码复用靠组合</p>
<p><em>Java 实现委派会有些麻烦，如果是 Kotlin，就方便多了！</em></p>
</li>
</ul>
<h2 data-id="heading-7">总结</h2>
<p>“继承”就像一把瑞士军刀，本来想切菜、开瓶、剪线都行，结果发现：<strong>切菜时刀片会弹出来割手，开瓶时螺丝刀又碍事。</strong></p>
<p>所以聪明人怎么做？</p>
<p><strong>切菜用菜刀，开瓶用开瓶器，剪线用剪刀。各干各的，互不干扰。</strong></p>
<p>编程也一样：</p>
<p><strong>别指望“继承”解决所有问题，该用接口用接口，该用组合用组合。</strong></p>
<p>这样，代码才清爽，bug 才少，而你，我的朋友，才睡得着觉！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[1个月双线作战：AI公文助手从0到1开发，与国产化适配的"踩坑"全记录]]></title>    <link>https://juejin.cn/post/7601576716016058431</link>    <guid>https://juejin.cn/post/7601576716016058431</guid>    <pubDate>2026-02-02T02:18:37.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7601576716016058431" data-draft-id="7601419065128943635" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="1个月双线作战：AI公文助手从0到1开发，与国产化适配的&quot;踩坑&quot;全记录"/> <meta itemprop="keywords" content="前端,GitHub,Vue.js"/> <meta itemprop="datePublished" content="2026-02-02T02:18:37.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="徐小夕"/> <meta itemprop="url" content="https://juejin.cn/user/3808363978429613"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            1个月双线作战：AI公文助手从0到1开发，与国产化适配的"踩坑"全记录
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3808363978429613/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    徐小夕
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-02T02:18:37.000Z" title="Mon Feb 02 2026 02:18:37 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-02
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读12分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>全职创业2年零1个月，接下来和大家分享一下我们最近做了AI协同产品 <strong>JitWord</strong> 的研发历程。</p>
<h2 data-id="heading-0">为什么要在1个月内攻坚两个硬骨头？</h2>
<p>说实话，启动这次迭代前，团队内部是有分歧的。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4574c195c39540fe937a3b5930f3092e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5b6Q5bCP5aSV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770603516&amp;x-signature=0F7DqBttEtLHbG50wfrtyqfpMmY%3D" alt="2026-01-30 21.09.31.gif" loading="lazy"/></p>
<p>一方面，<strong>AI公文助手</strong> 是很多政企客户反复提的需求——他们想要 Word 那种严谨的公文排版，又想要AI的生成能力，还要能在线协同；另一方面，<strong>国产化适配</strong>是信创大背景下的必选项，涉及国产操作系统、国产浏览器、甚至国产芯片的兼容性问题。</p>
<p>这两个需求，任何一个单独做都要扒层皮。但市场不等人，我们决定在1个月内"双线作战"。</p>
<p>这篇文章记录了我们如何从0搭建AI公文助手模块，以及在国产化适配过程中遇到的那些让人头秃的坑。希望能给同样面临信创改造或富文本技术选型的同学一些参考。</p>
<hr/>
<h2 data-id="heading-1">JitWord 是什么？（如果你第一次听说）</h2>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c27c99c39e2041bea6a4299a63de9bbd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5b6Q5bCP5aSV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770603516&amp;x-signature=TvYn4Hgg2QXp8TsnOLgNm%2FdFK5Q%3D" alt="2026-01-29 11.02.48.gif" loading="lazy"/></p>
<p>简单给新朋友介绍一下。<strong>JitWord</strong> 是我们团队开发的<strong>协同AI文档引擎</strong>，定位是"<strong>让Web文档拥有桌面级体验</strong>"，打造“<strong>云端Office</strong>”办公体验。</p>
<p>核心能力包括：</p>
<ul>
<li><strong>多人实时协同</strong>：基于CRDT算法，支持Word级别的冲突解决</li>
<li><strong>AI辅助创作</strong>：内置AI续写、润色、总结，支持自定义Prompt</li>
<li><strong>数学公式渲染</strong>：自研公式引擎，支持LaTeX到Word的无损转换（之前文章有详细讲过）</li>
<li><strong>一键导出Word</strong>：不只是PDF，是真正的<code>.docx</code>格式，导出后还能在Office里二次编辑</li>
</ul>





























<table><thead><tr><th>项目</th><th>描述</th></tr></thead><tbody><tr><td><strong>产品名称</strong></td><td>JitWord 协同AI文档</td></tr><tr><td><strong>技术栈</strong></td><td>Vue3 + NestJS + CRDT + WebSocket</td></tr><tr><td><strong>核心功能</strong></td><td>实时协同、AI写作、公文处理、Word导出</td></tr><tr><td><strong>适用场景</strong></td><td>企业文档中台、科研协作、政务办公</td></tr><tr><td><strong>版本状态</strong></td><td>V2.1（AI公文助手 + 国产化适配版）</td></tr></tbody></table>
<p>最近我们也开源了一版sdk，大家可以轻松本地使用和集成：</p>
<p>github地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FMrXujiang%2Fjitword-sdk" target="_blank" title="https://github.com/MrXujiang/jitword-sdk" ref="nofollow noopener noreferrer">github.com/MrXujiang/j…</a></p>
<hr/>
<h2 data-id="heading-2">第一部分：AI公文助手从0到1</h2>
<h3 data-id="heading-3">1.1 需求拆解：公文场景的残酷现实</h3>
<p>做传统富文本编辑器的朋友可能不知道，<strong>公文排版是中文排版的地狱模式</strong>。</p>
<ul>
<li><strong>红头文件</strong>：要严格遵循 GB/T 9704-2012 国家标准，版头、发文字号、签发人都有固定位置</li>
<li><strong>多层嵌套结构</strong>：一、（一）、1.（1）、①，这五种层级格式不能乱</li>
<li><strong>表格与附件</strong>：公文里的表格必须能跨页重复表头，附件说明有特定格式</li>
<li><strong>严格的页面设置</strong>：A4纸张、上白边37mm±1mm、下白边35mm±1mm...</li>
</ul>
<p>我们调研了市面上几乎所有的Web Office方案，发现要么是简单的表单模板（灵活性不够），要么是把PDF转图片（无法二次编辑）。所以决定自己实现一套<strong>结构化公文引擎</strong>。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5dd37f0f375143758977f135091c3e3f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5b6Q5bCP5aSV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770603516&amp;x-signature=H9Y9GhCVMjioaPSdYBUILLGByOE%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-4">1.2 技术架构：如何把AI塞进公文流程？</h3>
<p>我们采用了 <strong>模板引擎 + AI生成 + 人工调整</strong> 的三段式架构：</p>
<pre><code class="hljs language-scss" lang="scss">┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│ 公文模板库  │────▶│  AI解析层   │────▶│ 编辑渲染层  │
│ (.docx解析) │     │ (LLM+规则)  │     │ (结构化编辑)│
└─────────────┘     └─────────────┘     └─────────────┘
       │                                        │
       │    ┌─────────────┐                     │
       │◄───│  导出引擎   │◄────────────────────┘
       │    │(Word/PDF)   │
       │    └─────────────┘
</code></pre>
<p><strong>关键技术决策：</strong></p>
<ul>
<li><strong>模板解析</strong>：目前了复用 mammoth.js，但是它的样式映射太粗粒度，后面规划重写。</li>
<li><strong>AI提示词工程</strong>：公文写作不是 Creative Writing，而是 Constraint Writing。我们让AI先分析模板结构，再填充内容，最后做<strong>格式合规性检查</strong>（比如检查发文字号是否符合"国发〔2024〕1号"这种格式）。</li>
<li><strong>编辑器选型</strong>：基础还是ProseMirror，但重写了NodeSpec来支持"公文块"（OfficialBlock）概念。每个公文块是一个不可随意拆分的逻辑单元，比如"主送机关"是一个块，"正文"是一个块。</li>
</ul>
<h3 data-id="heading-5">1.3 核心代码：公文模板的JSON Schema设计</h3>
<p>这是我们定义的公文结构规范（节选）：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// types/document.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">OfficialDocument</span> {
  <span class="hljs-attr">version</span>: <span class="hljs-string">'GB/T-9704-2012'</span>;
  <span class="hljs-attr">header</span>: {
    <span class="hljs-attr">issuingBody</span>: <span class="hljs-built_in">string</span>;     <span class="hljs-comment">// 发文机关</span>
    <span class="hljs-attr">documentNumber</span>: <span class="hljs-built_in">string</span>;  <span class="hljs-comment">// 发文字号</span>
    <span class="hljs-attr">urgencyLevel</span>: <span class="hljs-string">'特急'</span> | <span class="hljs-string">'加急'</span> | <span class="hljs-string">'平急'</span>;
  };
  <span class="hljs-attr">body</span>: <span class="hljs-title class_">OfficialBlock</span>[];  <span class="hljs-comment">// 正文，由多个公文块组成</span>
  attachments?: <span class="hljs-title class_">Attachment</span>[];
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">OfficialBlock</span> {
  <span class="hljs-attr">type</span>: <span class="hljs-string">'redHeader'</span> | <span class="hljs-string">'recipient'</span> | <span class="hljs-string">'text'</span> | <span class="hljs-string">'level1'</span> | <span class="hljs-string">'level2'</span> | <span class="hljs-string">'table'</span>;
  <span class="hljs-attr">content</span>: <span class="hljs-built_in">string</span> | <span class="hljs-title class_">TableContent</span>;
  <span class="hljs-attr">style</span>: {
    <span class="hljs-attr">fontFamily</span>: <span class="hljs-string">'仿宋_GB2312'</span> | <span class="hljs-string">'黑体'</span> | <span class="hljs-string">'楷体_GB2312'</span>;  <span class="hljs-comment">// 信创字体</span>
    <span class="hljs-attr">fontSize</span>: <span class="hljs-built_in">number</span>;       <span class="hljs-comment">// 三号=16pt，小三=15pt...</span>
    <span class="hljs-attr">lineHeight</span>: <span class="hljs-built_in">number</span>;     <span class="hljs-comment">// 28-30磅固定值</span>
  };
}
</code></pre>
<p><strong>遇到的坑：</strong> 仿宋_GB2312 这个字体在Mac和Linux上表现差异巨大。Windows上看着好好的文档，在国产系统（基于Linux）上打开后行高会乱掉。解决方案是<strong>用CSS的<code>line-height: fixed</code> + 字体fallback栈</strong>，并且在导出Word时重新计算行高。</p>
<h3 data-id="heading-6">1.4 AI生成流程的优化</h3>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/693d88b4a428488d80064f9e3dd43b7c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5b6Q5bCP5aSV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770603516&amp;x-signature=lTmc3Igu8KhHzPB1AvBZAWYONZs%3D" alt="image.png" loading="lazy"/></p>
<p>最初我们直接把"写一篇关于XX的通知"扔给GPT-5，结果生成的内容总是<strong>太口语化</strong>，而且格式经常出错。</p>
<p>优化后的流程是：</p>
<ol>
<li><strong>模板匹配</strong>：先根据用户选择的公文类型（通知、通报、请示、报告等），加载对应的Prompt模板</li>
<li><strong>结构化生成</strong>：要求AI输出JSON格式，而不是Markdown</li>
<li><strong>规则校验层</strong>：用正则表达式校验公文要素是否齐全（比如通知必须有"特此通知"结尾，请示必须有"妥否，请批复"）</li>
</ol>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// ai/officialWriter.ts</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">generateOfficialDoc</span>(<span class="hljs-params">params: GenerationParams</span>) {
  <span class="hljs-keyword">const</span> template = <span class="hljs-title function_">loadTemplate</span>(params.<span class="hljs-property">type</span>);
  
  <span class="hljs-keyword">const</span> structuredPrompt = <span class="hljs-string">`
  你是一个严谨的公文写作助手。请根据以下信息，生成符合GB/T 9704-2012的公文内容。
  必须输出为JSON格式，字段定义如下：<span class="hljs-subst">${JSON_SCHEMA}</span>
  
  用户输入：<span class="hljs-subst">${params.topic}</span>
  要求：<span class="hljs-subst">${params.requirements}</span>
  `</span>;
  
  <span class="hljs-keyword">const</span> raw = <span class="hljs-keyword">await</span> llm.<span class="hljs-title function_">generate</span>(structuredPrompt);
  <span class="hljs-keyword">const</span> doc = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(raw);
  
  <span class="hljs-comment">// 规则校验</span>
  <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">validateOfficialFormat</span>(doc)) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'生成内容不符合公文规范，请重试'</span>);
  }
  
  <span class="hljs-keyword">return</span> doc;
}
</code></pre>
<p><strong>效果：</strong> 生成一份标准通知的时间从人工30分钟缩短到AI 10秒 + 人工审核2分钟，<strong>效率提升90%</strong>。</p>
<hr/>
<h2 data-id="heading-7">第二部分：国产化适配的"踩坑"全记录</h2>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/167b10c864d34b5c985e00c026bbfb87~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5b6Q5bCP5aSV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770603516&amp;x-signature=cZmP%2BjqFSi63bH9GLxIkXEeK7MI%3D" alt="image.png" loading="lazy"/></p>
<p>如果说AI公文助手是"从0到1的创造"，那国产化适配就是"从能用到好用的磨砺"。</p>
<p>我们的目标是让 <strong>JitWord</strong> 能在<strong>统信UOS</strong>、<strong>麒麟OS</strong>等国产操作系统，以及<strong>360安全浏览器</strong>、<strong>奇安信可信浏览器</strong>等国产Chromium内核浏览器上稳定运行。</p>
<h3 data-id="heading-8">2.1 踩坑一：WebSocket连接的诡异断开</h3>
<p><strong>现象：</strong> 在麒麟V10系统上，协同编辑总是过几分钟就断开，提示"网络异常"，但用户明明能正常刷网页。</p>
<p><strong>排查过程：</strong></p>
<ol>
<li>首先排查Nginx配置，以为是<code>proxy_read_timeout</code>太短，改成3600秒，无效。</li>
<li>检查浏览器Network面板，发现国产浏览器的某些安全策略会<strong>主动断开静默的WebSocket连接</strong>。</li>
<li>最后发现是<strong>奇安信可信浏览器</strong>内置了"长连接保护"策略，超过5分钟没有数据交互就会自动断开。</li>
</ol>
<p><strong>解决方案：</strong></p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 心跳机制加强版</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReliableWebSocket</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-attr">ws</span>: <span class="hljs-title class_">WebSocket</span>;
  <span class="hljs-keyword">private</span> <span class="hljs-attr">heartbeatInterval</span>: <span class="hljs-title class_">NodeJS</span>.<span class="hljs-property">Timer</span>;
  
  <span class="hljs-comment">// 国产浏览器的心跳间隔要更短</span>
  <span class="hljs-keyword">private</span> heartbeatDelay = <span class="hljs-title function_">isDomesticBrowser</span>() ? <span class="hljs-number">10000</span> : <span class="hljs-number">30000</span>; 
  
  <span class="hljs-title function_">connect</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">ws</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(url);
    
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">heartbeatInterval</span> = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-comment">// 发送空操作或ping帧，保持连接活性</span>
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">send</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">'heartbeat'</span>, <span class="hljs-attr">timestamp</span>: <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() });
    }, <span class="hljs-variable language_">this</span>.<span class="hljs-property">heartbeatDelay</span>);
  }
}
</code></pre>
<h3 data-id="heading-9">2.2 踩坑二：富文本编辑器的输入法冲突</h3>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/81e820b56dfb4f80a49f33a48b9d9297~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5b6Q5bCP5aSV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770603516&amp;x-signature=8oVyUX2qMJJqURsbadkubgoLO3E%3D" alt="协同.png" loading="lazy"/></p>
<p>这是让我最想骂街的坑。</p>
<p><strong>现象：</strong> 在统信UOS + 搜狗输入法（国产版）下，输入中文时，编辑器光标会乱跳，甚至吞字。</p>
<p><strong>根因分析：</strong>
国产操作系统的输入法架构和Windows差异很大。我们用的ProseMirror在处理<code>beforeinput</code>事件时，和一些国产输入法的Composition事件冲突。具体表现为：输入法开始合成（compositionstart）时，ProseMirror尝试更新选区，导致输入法丢失了上下文。</p>
<p><strong>解决方案：</strong>
不得不patch了ProseMirror的view模块，在合成输入期间<strong>暂停所有远程协同更新</strong>：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// patches/prosemirror-view.ts</span>
<span class="hljs-keyword">let</span> isComposing = <span class="hljs-literal">false</span>;

editorView.<span class="hljs-property">dom</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'compositionstart'</span>, <span class="hljs-function">() =&gt;</span> {
  isComposing = <span class="hljs-literal">true</span>;
  <span class="hljs-comment">// 暂停接收远程操作，避免光标跳动</span>
  collaboration.<span class="hljs-title function_">pauseSync</span>();
});

editorView.<span class="hljs-property">dom</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'compositionend'</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
  isComposing = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">const</span> finalData = e.<span class="hljs-property">data</span>;
  
  <span class="hljs-comment">// 延迟恢复同步，等待输入法插入完成</span>
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    collaboration.<span class="hljs-title function_">resumeSync</span>();
  }, <span class="hljs-number">100</span>);
});
</code></pre>
<h3 data-id="heading-10">2.3 踩坑三：字体渲染与导出</h3>
<p><strong>现象：</strong> 同样的"仿宋"，在Windows上叫"仿宋"，在国产系统上可能叫"FangSong"、"Fangsong"、或者"Source Han Serif CN"。公文要求必须用仿宋_GB2312，但这个字体在某些国产系统上没有预装。</p>
<p><strong>解决方案三部曲：</strong></p>
<ol>
<li><strong>前端降级方案</strong>：CSS设置<code>font-family: 'FangSong_GB2312', 'Source Han Serif CN', 'Noto Serif CJK SC', serif;</code></li>
<li><strong>后端字体嵌入</strong>：导出Word时，如果检测目标系统缺少字体，用Java操作POI把字体文件嵌入到生成的docx中</li>
<li><strong>Web字体预加载</strong>：在编辑器初始化时，异步加载WOFF2格式的仿宋字体文件，确保所见即所得</li>
</ol>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 导出Word时的字体嵌入逻辑（Java实现）</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">embedFonts</span><span class="hljs-params">(XWPFDocument doc, String[] requiredFonts)</span> {
    <span class="hljs-keyword">for</span> (String fontName : requiredFonts) {
        <span class="hljs-keyword">if</span> (!systemHasFont(fontName)) {
            <span class="hljs-type">InputStream</span> <span class="hljs-variable">fontStream</span> <span class="hljs-operator">=</span> getClass().getResourceAsStream(<span class="hljs-string">"/fonts/"</span> + fontName + <span class="hljs-string">".ttf"</span>);
            doc.embedFont(fontName, fontStream);
        }
    }
}
</code></pre>
<hr/>
<h2 data-id="heading-11">性能优化：让国产硬件也能流畅运行</h2>
<p>说实话，很多国产终端的硬件配置（特别是信创笔记本）不如主流Windows本。我们在1个月内做了以下针对性优化：</p>
<h3 data-id="heading-12">虚拟滚动 + 分层渲染</h3>
<p>公文通常很长（几十页很正常），我们在ProseMirror基础上实现了<strong>虚拟滚动</strong>，只渲染可视区域内的DOM节点。同时把静态内容（已经定稿的段落）标记为<code>contenteditable: false</code>，减少MutationObserver的开销。</p>
<h3 data-id="heading-13">AI生成的防抖处理</h3>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/50c819b59c114b23ad6a9f4c5c9262e9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5b6Q5bCP5aSV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770603516&amp;x-signature=hPXZ%2BjQN2bm0AyFTdOWiymRsTsQ%3D" alt="02.gif" loading="lazy"/></p>
<p>当AI生成大段文本时，不能直接一次性插入编辑器（会导致卡顿）。我们改成了<strong>逐句插入 + requestAnimationFrame</strong>：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">insertAIGeneratedContent</span>(<span class="hljs-params">content: <span class="hljs-built_in">string</span></span>) {
  <span class="hljs-keyword">const</span> sentences = content.<span class="hljs-title function_">split</span>(<span class="hljs-regexp">/([。！？])/</span>);  <span class="hljs-comment">// 按句分割</span>
  
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; sentences.<span class="hljs-property">length</span>; i += <span class="hljs-number">2</span>) {
    <span class="hljs-keyword">const</span> sentence = sentences[i] + (sentences[i+<span class="hljs-number">1</span>] || <span class="hljs-string">''</span>);
    
    <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> {
      <span class="hljs-title function_">requestAnimationFrame</span>(<span class="hljs-function">() =&gt;</span> {
        editor.<span class="hljs-title function_">insertText</span>(sentence);
        <span class="hljs-title function_">resolve</span>(<span class="hljs-literal">null</span>);
      });
    });
    
    <span class="hljs-comment">// 每5句暂停一下，让UI线程喘息</span>
    <span class="hljs-keyword">if</span> (i % <span class="hljs-number">5</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">await</span> <span class="hljs-title function_">sleep</span>(<span class="hljs-number">10</span>);
  }
}
</code></pre>
<hr/>
<h2 data-id="heading-14">最终效果与场景展示</h2>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c7f8d77799e4421faf9ed181c0d61178~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5b6Q5bCP5aSV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770603516&amp;x-signature=X8RxFKvtlJ7fbU0n%2FocY3YDX39U%3D" alt="2026-01-15 10.52.12.gif" loading="lazy"/></p>
<h3 data-id="heading-15">公文助手实际应用场景</h3>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8647f345b8fc4ff081a7824a206b87a5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5b6Q5bCP5aSV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770603516&amp;x-signature=OESMbmwDRP7ot7YAUZOidCFwnX8%3D" alt="jitword-gw.png" loading="lazy"/></p>
<p><strong>场景1：政府机关的请示报告</strong></p>
<ul>
<li>输入："关于申请信息化建设经费的请示"</li>
<li>AI生成：自动匹配"请示"模板，生成红头、发文字号、正文、结尾语</li>
<li>人工调整：只需填写具体金额和项目明细</li>
<li>导出：直接生成符合省级办公厅格式要求的Word文件</li>
</ul>
<p><strong>场景2：国企的发文通知</strong></p>
<ul>
<li>协同：办公室主任起草，分管领导在线批注修改，法务审核合规性</li>
<li>留痕：所有修改记录保存，满足公文归档的审计要求</li>
<li>套红：一键生成带红色抬头的正式公文版式</li>
</ul>
<h3 data-id="heading-16">国产化适配验证环境</h3>
<p>我们在以下环境完成了完整测试：</p>
<ul>
<li><strong>操作系统</strong>：统信UOS 1060、麒麟V10 SP1、中科方德</li>
<li><strong>CPU架构</strong>：x86_64、ARM64（鲲鹏920、飞腾2000）</li>
<li><strong>浏览器</strong>：360安全浏览器v13、奇安信可信浏览器、火狐中国浏览器</li>
</ul>
<hr/>
<h2 data-id="heading-17">技术总结与反思</h2>
<p>这1个月的"双线作战"，最大的收获不是功能本身，而是对<strong>信创环境下的Web开发</strong>有了更深理解：</p>
<ol>
<li>
<p><strong>不要相信浏览器的UserAgent</strong>：国产浏览器都伪装成Chrome，但行为可能完全不同。必须做特性检测（feature detection）而非浏览器嗅探。</p>
</li>
<li>
<p><strong>富文本编辑器要"防御性编程"</strong>：输入法、选区、滚动这些在标准浏览器上稳定的功能，在特殊环境下可能有各种奇奇怪怪的表现。代码要更保守，try-catch要更密集。</p>
</li>
<li>
<p><strong>AI生成必须后接规则校验</strong>：大模型有幻觉，公文又是极其严谨的体裁。AI负责"快"，规则引擎负责"准"，两者结合才能实用。</p>
</li>
<li>
<p><strong>字体和排版是信创隐形大坑</strong>：中西文混排、行高计算、字体回退，这些细节决定了产品看起来是"业余demo"还是"正式产品"。</p>
</li>
</ol>
<hr/>
<h2 data-id="heading-18">如何集成和体验？</h2>
<p><strong>JitWord</strong> 目前主要面向<strong>企业级用户</strong>和<strong>开发者集成</strong>。</p>
<ul>
<li><strong>在线演示</strong>：如果你想看看AI公文助手的实际效果，可以访问我们的演示环境（文中不放链接了，掘金私信我或评论获取）</li>
<li><strong>私有化部署</strong>：支持国产服务器私有化部署，适配信创环境</li>
<li><strong>SDK集成</strong>：提供JavaScript SDK，可以Embed到你的业务系统中</li>
</ul>
<p>如果你也是<strong>正在做信创改造的技术负责人</strong>，或者<strong>需要公文处理能力的产品经理</strong>，欢迎评论区交流踩坑经验。国产化这条路，大家互相搀扶才能走得快一点。</p>
<p>我们也开源了一版sdk，大家可以轻松本地使用和集成：</p>
<p>github地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FMrXujiang%2Fjitword-sdk" target="_blank" title="https://github.com/MrXujiang/jitword-sdk" ref="nofollow noopener noreferrer">github.com/MrXujiang/j…</a></p>
<hr/>
<h2 data-id="heading-19">未来规划</h2>
<p>这1个月的攻坚只是开始，接下来的 roadmap 包括：</p>
<ul>
<li><strong>智能校对</strong>：接入NLP模型，自动检查公文中的政治术语准确性、数字逻辑一致性（比如"2024年"不能写成"2024年度"在某些语境下）</li>
<li><strong>手写签批</strong>：对接国产手写板和签章系统，实现移动端批公文</li>
<li><strong>更多公文类型</strong>：从现在的通知、请示、报告，扩展到会议纪要、函、议案等15种法定公文</li>
</ul>
<hr/>
<p><strong>技术栈彩蛋</strong> 🎯</p>
<p>如果你在关注相关技术方向，这是我们用的核心栈，也是目前市面上比较热门的技术方向：</p>
<ul>
<li><strong>Vue3</strong> + <strong>Vite</strong> + <strong>TypeScript</strong>（前端）</li>
<li><strong>NestJS</strong> + <strong>TypeORM</strong>（后端，支持国产数据库适配）🚀</li>
<li><strong>ProseMirror</strong>（编辑器内核，深度定制）</li>
<li><strong>Yjs</strong>（CRDT协同算法）🧩</li>
<li><strong>Docker</strong> + <strong>K8s</strong>（部署）</li>
</ul>
<hr/>
<p>觉得有用的话，点个赞或者收藏吧。信创适配这条路很长，希望这篇文章能帮你少走些弯路。有任何技术问题，评论区留言，我看到都会回复。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[春哥的Agent通关秘籍02：搭建环境及语言选择]]></title>    <link>https://juejin.cn/post/7601419065128239123</link>    <guid>https://juejin.cn/post/7601419065128239123</guid>    <pubDate>2026-02-02T00:07:51.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7601419065128239123" data-draft-id="7601419065128222739" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="春哥的Agent通关秘籍02：搭建环境及语言选择"/> <meta itemprop="keywords" content="前端,后端,Python"/> <meta itemprop="datePublished" content="2026-02-02T00:07:51.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="摸鱼的春哥"/> <meta itemprop="url" content="https://juejin.cn/user/1714893870865303"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            春哥的Agent通关秘籍02：搭建环境及语言选择
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1714893870865303/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    摸鱼的春哥
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-02T00:07:51.000Z" title="Mon Feb 02 2026 00:07:51 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-02
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;font-weight:400;line-height:2;font-size:17px;overflow-x:hidden;color:#000}.markdown-body strong{padding:1px;color:#ee3f4d}.markdown-body em{padding:0 2px;color:#f33b1f}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{position:relative;margin-top:30px;margin-bottom:20px;line-height:1.5;font-weight:700}.markdown-body h1{text-align:center;padding-bottom:5px;font-size:32px;color:#ac1f18}.markdown-body h1:after{content:"";display:block;margin:4px auto 0;width:100px;height:2px;border-bottom:2px solid #f33b1f}.markdown-body h2{font-size:28px;border-bottom:1px solid #f33b1f}.markdown-body h2:before{content:"# "!important;color:#f33b1f}.markdown-body h3{font-size:24px;padding-left:9px;border-left:6px solid #f33b1f}.markdown-body h4{font-size:20px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #bbb;margin:16px 0}.markdown-body code{word-break:break-word;overflow-x:auto;background-color:#f9f1db;color:#ee2746;border-radius:2px;font-size:16px;padding:1px 2px}.markdown-body code,.markdown-body pre{font-family:-apple-system,-apple-system-body,BlinkMacSystemFont,Segoe UI,Helvetica,Arial,PingFang SC,思源黑体 CN,思源黑体,JetBrains Mono,Fira Code,Menlo,Ubuntu Mono,Consolas,sans-serif}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{margin:12px 0!important;border-radius:3px;font-size:15px;padding:16px 12px;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f7f7f7}.markdown-body a{text-decoration:none;color:#1781b5;padding:0 2px;border-bottom:1px solid #1781b5}.markdown-body a:active,.markdown-body a:hover{border-bottom:2px solid #f33b1f;color:#ac1f18}.markdown-body blockquote{color:#3d3d3d;background-color:#fff9f9;padding:6px 16px;margin:16px 0;border-left:3px solid #f07c82}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:6px 0}.markdown-body ol,.markdown-body ul{padding-left:30px}.markdown-body ol li,.markdown-body ul li{margin-bottom:6px}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:6px}.markdown-body ol li{padding-left:6px}.markdown-body ::marker{color:#f33b1f}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}.markdown-body .task-list-item input[type=checkbox]{position:relative}.markdown-body .task-list-item input[type=checkbox]:before{content:"";position:absolute;top:0;left:0;right:0;bottom:0;background:#fff;border:1px solid #f07c82;border-radius:3px;box-sizing:border-box;z-index:1}.markdown-body .task-list-item input[type=checkbox]:checked:after{content:"✓";position:absolute;top:-5px;left:0;right:0;bottom:0;width:0;height:0;color:#f33b1f;font-size:16px;font-weight:700;z-index:2}.markdown-body table{display:inline-block!important;font-size:14px;width:auto;max-width:100%;overflow:auto;border-spacing:0;border-collapse:collapse}.markdown-body table thead{background:#fff9f9;color:#000;text-align:left;font-size:15px}.markdown-body table tr:nth-child(2n){background-color:#fcfcfc}.markdown-body table tr:hover{background-color:#fff9f9}.markdown-body table td,.markdown-body table th{padding:12px 7px;line-height:24px;border:1px solid #f9f1db}.markdown-body table td{min-width:120px}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="monokai">.markdown-body pre,.markdown-body pre&gt;code.hljs{background:#272822;color:#ddd}.hljs-keyword,.hljs-literal,.hljs-name,.hljs-selector-tag,.hljs-strong,.hljs-tag{color:#f92672}.hljs-code{color:#66d9ef}.hljs-class .hljs-title{color:#fff}.hljs-attribute,.hljs-link,.hljs-regexp,.hljs-symbol{color:#bf79db}.hljs-addition,.hljs-built_in,.hljs-builtin-name,.hljs-bullet,.hljs-emphasis,.hljs-section,.hljs-selector-attr,.hljs-selector-pseudo,.hljs-string,.hljs-subst,.hljs-template-tag,.hljs-template-variable,.hljs-title,.hljs-type,.hljs-variable{color:#a6e22e}.hljs-comment,.hljs-deletion,.hljs-meta,.hljs-quote{color:#75715e}.hljs-doctag,.hljs-keyword,.hljs-literal,.hljs-section,.hljs-selector-id,.hljs-selector-tag,.hljs-title,.hljs-type{font-weight:700}</style><p>很多想学 AI 开发的朋友，往往倒在了第一步：配环境。</p>
<p>我们要做的不是简单的“安装软件”，而是构建一个专业的数字化工作台。</p>
<p>在这篇文章中，我们将解释为什么 Python 是不二之选，为什么我们需要 Conda，并带你从零开始跑通第一行 AI 代码（以 DeepSeek 为例）。</p>
<h2 data-id="heading-0">一、为什么是 Python</h2>
<p>虽然 Java、Go、JavaScript 也能写 AI 应用，但是。</p>
<p>在 AI Agent 开发领域，Python 是绝对的“第一公民”，它拥有无法撼动的优势：</p>
<ul>
<li>
<p>统治级的生态：几乎所有主流 AI 框架（PyTorch, LangChain, CrewAI）都优先发布 Python 版。</p>
</li>
<li>
<p>胶水语言：Agent 的核心是“连接”——连接大模型、连接 API、连接本地文件。Python 写这种连接逻辑最快。</p>
</li>
<li>
<p>门槛低：它的语法接近英语，让你能把精力集中在“设计智能体逻辑”上，而不是纠结语法细节。</p>
</li>
</ul>
<p>结论：想做 AI Agent，首选 Python。</p>
<p>尤其是学习的话，先学 python，面向最先进最全面的工具链是最优选，等python这块熟悉原理了，再按诉求辐射到自己需要的场景和语言也是非常方便的。</p>
<p><img src="https://pic.zhangshichun.top/pic/20260131131848180.png" alt="" loading="lazy"/></p>
<h2 data-id="heading-1">二、 为什么要用 Miniconda？</h2>
<p>很多新手会直接去 Python 官网下载安装包，这其实是个“大坑”。</p>
<p>在开发中，我们需要管理各种复杂的库（依赖）。为了防止项目 A 的库和项目 B 的库打架（版本冲突），我们需要 <strong>“虚拟环境”</strong>。</p>
<p>为什么不用 <code>Docker</code> ？</p>
<ul>
<li>Docker虽然隔离性最好，但对初学者来说，操作文件和调试太麻烦，阻碍学习心流。</li>
<li>乱七八糟的环境问题会让初学者信心受挫，容易被打断学习进程。</li>
</ul>
<p><code>Miniconda</code> 有哪些优势？</p>
<p><code>Miniconda</code> 是一个轻量级的环境管理工具。</p>
<ul>
<li>
<p>它可以帮你一键切换 Python 版本（3.10, 3.11, 3.12 随意切）。</p>
</li>
<li>
<p>它能创建独立的“沙盒”，让你随意折腾而不破坏电脑系统。</p>
</li>
<li>
<p>它对文件系统的操作比 <code>docker</code> 方便一万倍，不需要挂载什么<code>volumes</code>映射，对初学者连贯学习更方便。</p>
</li>
</ul>
<p><img src="https://pic.zhangshichun.top/pic/20260131133124958.png" alt="" loading="lazy"/></p>
<h2 data-id="heading-2">三、 手把手搭建环境</h2>
<h3 data-id="heading-3">第一步：安装 Miniconda及环境变量</h3>
<p>访问 Miniconda 官网 下载对应系统的安装包。地址：<a href="https://link.juejin.cn?target=docs.conda.io%2Fen%2Flatest%2Fminiconda.html" target="_blank" title="docs.conda.io/en/latest/miniconda.html" ref="nofollow noopener noreferrer">docs.conda.io/en/latest/m…</a></p>
<p>安装之后，记得把安装文件夹下<code>condabin</code>目录加入到环境变量里。（针对windows用户哈）</p>
<p>比如我的，就是把 <code>D:\miniconda\condabin</code> 加入到环境变量。</p>
<p><img src="https://pic.zhangshichun.top/pic/20260131155507332.png" alt="" loading="lazy"/></p>
<p>以 <code>cmd</code> 能执行：</p>
<pre><code class="hljs language-bash" lang="bash">conda --version
</code></pre>
<p><img src="https://pic.zhangshichun.top/pic/20260201093046760.png" alt="" loading="lazy"/></p>
<p>输出<code>25.11.1</code>这样的版本号就代表环境变量配置ok。</p>
<h3 data-id="heading-4">第二步：创建 AI 专属环境</h3>
<p>打开你的终端（Windows 用户推荐 PowerShell，Mac 用户用 Terminal），输入以下命令：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 1. 创建一个名为 ai_agent 的环境，指定使用 Python 3.11（稳定性最佳）</span>
conda create -n ai_agent python=3.11 -y

<span class="hljs-comment"># 2. 激活环境（看到命令行前缀变成 (ai_agent) 即成功）</span>
conda activate ai_agent
</code></pre>
<p>这里 <code>powerShell</code> 可能会遇到一个坑：执行完 <code>conda activate ai_agent</code> 后没反应。</p>
<ul>
<li>
<p>原因：PowerShell 的安全策略默认比较严格，禁止运行未签名的脚本（Conda 的激活脚本本质上是一段 PowerShell 脚本）。</p>
</li>
<li>
<p>解决方法：你需要赋予 PowerShell 执行权限。</p>
<ul>
<li>
<p>以管理员身份打开 PowerShell。</p>
</li>
<li>
<p>运行以下命令：</p>
</li>
</ul>
<pre><code class="hljs language-bash" lang="bash">Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser
</code></pre>
<ul>
<li>输入 Y 确认</li>
<li>重新运行 <code>conda init powershell</code>，然后重启 PowerShell 窗口。</li>
</ul>
</li>
</ul>
<p>分别执行以下代码后：</p>
<pre><code class="hljs language-css" lang="css">conda activate ai_agent
python <span class="hljs-attr">--version</span>
</code></pre>
<p><img src="https://pic.zhangshichun.top/pic/20260201093259212.png" alt="" loading="lazy"/>
如果能成功显示python的版本号代表ok。</p>
<h2 data-id="heading-5">四、接入Deepseek大模型</h2>
<p><code>deepseek</code> 被称为性价比之王。原因在于token单价非常划算，而且对于国内用户来说网络条件支持也是极好的，所以非常适合学习选择。</p>
<p>访问 <a href="https://link.juejin.cn?target=https%3A%2F%2Fplatform.deepseek.com%2Fusage" target="_blank" title="https://platform.deepseek.com/usage" ref="nofollow noopener noreferrer">platform.deepseek.com/usage</a> 可以非常便捷地完成注册和充值，2-3块钱就足够用很久很久了。</p>
<p>然后在 <code>api keys</code> 页面创建一个 <code>API Key</code>，复制这个key，我们接下来会用到。</p>
<h3 data-id="heading-6">4.1 安装核心库</h3>
<p>随便创建一个学习用的文件夹，在该文件夹里打开命令行，执行以下命令：</p>
<pre><code class="hljs language-bash" lang="bash">conda activate ai_agent
pip install openai python-dotenv pydantic
</code></pre>
<h3 data-id="heading-7">4.2 配置你的key</h3>
<p>永远不要把 API Key 直接写在代码里！ 一旦你不小心截图或把代码上传 GitHub，Key 就会泄露。</p>
<p>我们在项目根目录下创建一个名为 .env 的文件（注意前面有个点），内容如下：</p>
<pre><code class="hljs language-.env" lang=".env"># 这里的 Key 仅作示例，请替换为你自己的
DEEP_SEEK_API_KEY=sk-xxxx
DEEP_SEEK_API_URL=https://api.deepseek.com
</code></pre>
<h3 data-id="heading-8">4.3 3. 编写“Hello World”测试脚本</h3>
<p>新建一个文件 check_env.py，粘贴以下代码。这段代码会自动读取 .env 里的配置来连接 DeepSeek。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> os
<span class="hljs-keyword">from</span> dotenv <span class="hljs-keyword">import</span> load_dotenv
<span class="hljs-keyword">from</span> openai <span class="hljs-keyword">import</span> OpenAI

<span class="hljs-comment"># 1. 加载环境变量</span>
load_dotenv()

<span class="hljs-comment"># 2. 从环境读取配置</span>
api_key = os.getenv(<span class="hljs-string">"DEEP_SEEK_API_KEY"</span>)
base_url = os.getenv(<span class="hljs-string">"DEEP_SEEK_API_URL"</span>)

<span class="hljs-built_in">print</span>(<span class="hljs-string">"正在检查环境配置..."</span>)

<span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> api_key:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"❌ 错误：未找到 API KEY，请检查 .env 文件"</span>)
<span class="hljs-keyword">else</span>:
    <span class="hljs-comment"># 为了安全，只打印前几位和后几位</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"✅ API Key 读取成功: <span class="hljs-subst">{api_key[:<span class="hljs-number">6</span>]}</span>******<span class="hljs-subst">{api_key[-<span class="hljs-number">4</span>:]}</span>"</span>)

<span class="hljs-comment"># 3. 尝试发起一次真实的对话请求</span>
<span class="hljs-keyword">try</span>:
    <span class="hljs-comment"># DeepSeek 兼容 OpenAI SDK，只需替换 base_url</span>
    client = OpenAI(api_key=api_key, base_url=base_url)
    
    response = client.chat.completions.create(
        model=<span class="hljs-string">"deepseek-chat"</span>,  <span class="hljs-comment"># DeepSeek 的模型名称</span>
        messages=[
            {<span class="hljs-string">"role"</span>: <span class="hljs-string">"system"</span>, <span class="hljs-string">"content"</span>: <span class="hljs-string">"你是一个有用的AI助手"</span>},
            {<span class="hljs-string">"role"</span>: <span class="hljs-string">"user"</span>, <span class="hljs-string">"content"</span>: <span class="hljs-string">"你好，请用一句话证明你已经连接成功了。"</span>},
        ]
    )
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"\n🎉 连接成功！大模型回复："</span>)
    <span class="hljs-built_in">print</span>(response.choices[<span class="hljs-number">0</span>].message.content)
    
<span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"\n❌ 连接失败: <span class="hljs-subst">{e}</span>"</span>)
</code></pre>
<h3 data-id="heading-9">4.4 运行验证</h3>
<p>在终端运行：</p>
<pre><code class="hljs">python check_env.py
</code></pre>
<p>如果你看到 “🎉 连接成功！” 以及 DeepSeek 的回复，恭喜你！你已经拥有了一个可以随时调用的 AI 大脑，并且搭建好了专业的 Python 开发环境。
<img src="https://pic.zhangshichun.top/pic/20260201093415136.png" alt="" loading="lazy"/></p>
<h2 data-id="heading-10">下一步预告</h2>
<p>环境搭好了，只会聊天可不行。</p>
<p>在下一篇 《AI Agent 编程入门 03：结构化输出》 中，我们将学习如何通过 Prompt 工程 和 结构化数据（JSON），强迫 AI 不再“胡言乱语”，而是像程序一样精准输出我们需要的数据格式。</p>
<p>敬请期待！</p>
<p><img src="https://pic.zhangshichun.top/pic/ScreenShot_2026-01-26_082327_821.png" alt="" loading="lazy"/></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[从模板到实战：写一个 IntelliJ 平台插件（以 I18n Toolkit 为例）]]></title>    <link>https://juejin.cn/post/7601435429409456162</link>    <guid>https://juejin.cn/post/7601435429409456162</guid>    <pubDate>2026-02-02T01:59:28.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7601435429409456162" data-draft-id="7601313474720579619" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="从模板到实战：写一个 IntelliJ 平台插件（以 I18n Toolkit 为例）"/> <meta itemprop="keywords" content="IntelliJ IDEA,WebStorm,Vue.js"/> <meta itemprop="datePublished" content="2026-02-02T01:59:28.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="叶落阁主"/> <meta itemprop="url" content="https://juejin.cn/user/2189882891714206"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            从模板到实战：写一个 IntelliJ 平台插件（以 I18n Toolkit 为例）
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2189882891714206/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    叶落阁主
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-02T01:59:28.000Z" title="Mon Feb 02 2026 01:59:28 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-02
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">从模板到实战：写一个 IntelliJ 平台插件（以 I18n Toolkit 为例）</h2>
<p>如果你想为 JetBrains IDE（IntelliJ IDEA、WebStorm、Rider 等）写一个插件，最省心的起点就是官方模板 <code>intellij-platform-plugin-template</code>。本文以开源插件 <strong>I18n Toolkit</strong> 为例，结合真实代码，讲清楚从克隆模板、跑起来，到实现核心功能的完整路径。</p>
<blockquote>
<p>示例仓库：I18n Toolkit（开源）
<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fyelog%2Fi18n-toolkit" target="_blank" title="https://github.com/yelog/i18n-toolkit" ref="nofollow noopener noreferrer">github.com/yelog/i18n-…</a></p>
<p>模板仓库：IntelliJ Platform Plugin Template
<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FJetBrains%2Fintellij-platform-plugin-template" target="_blank" title="https://github.com/JetBrains/intellij-platform-plugin-template" ref="nofollow noopener noreferrer">github.com/JetBrains/i…</a></p>
</blockquote>
<hr/>
<h3 data-id="heading-1">一、准备环境</h3>
<p>在插件开发中，IDE 版本、JDK 版本和 Gradle 版本强相关。I18n Toolkit 的约束来自项目配置：</p>
<ul>
<li><strong>JDK</strong>：21</li>
<li><strong>Gradle</strong>：9.2.1（必须使用 <code>./gradlew</code>）</li>
<li><strong>IntelliJ Platform</strong>：2025.2.5</li>
</ul>
<p>建议：<strong>始终使用 Gradle Wrapper</strong>，避免本机 Gradle 版本与项目不一致。</p>
<hr/>
<h3 data-id="heading-2">二、从模板开始：克隆 + 初始化</h3>
<h4 data-id="heading-3">1. 克隆模板</h4>
<pre><code class="hljs language-bash" lang="bash">git <span class="hljs-built_in">clone</span> https://github.com/JetBrains/intellij-platform-plugin-template
<span class="hljs-built_in">cd</span> intellij-platform-plugin-template
</code></pre>
<h4 data-id="heading-4">2. 初始化项目信息</h4>
<p>你需要修改几个关键文件：</p>
<ul>
<li><code>settings.gradle.kts</code>：项目名称</li>
<li><code>gradle.properties</code>：插件名、版本、ID、平台版本等</li>
<li><code>src/main/resources/META-INF/plugin.xml</code>：插件 ID、名称、描述、扩展点</li>
<li><code>README.md</code>：保留 <code>&lt;!-- Plugin description --&gt;</code> 标记区域</li>
</ul>
<p>模板自带脚本也能一键替换变量，但手工改更直观。</p>
<h4 data-id="heading-5">3. 启动开发 IDE</h4>
<pre><code class="hljs language-bash" lang="bash">./gradlew runIde
</code></pre>
<p>此命令会启动一个 <strong>IDE 沙箱环境</strong>，插件会自动加载在这个测试 IDE 中。</p>
<hr/>
<h3 data-id="heading-6">三、项目结构速览</h3>
<p>插件主要结构是固定的：</p>
<pre><code class="hljs language-bash" lang="bash">src/
├── main/
│   ├── kotlin/…                 <span class="hljs-comment"># Kotlin 源码</span>
│   └── resources/
│       └── META-INF/plugin.xml  <span class="hljs-comment"># 插件描述文件</span>
└── <span class="hljs-built_in">test</span>/                         <span class="hljs-comment"># 测试</span>
</code></pre>
<p>I18n Toolkit 的代码划分更细，按功能分包：</p>
<ul>
<li><code>service/</code>：缓存与核心数据</li>
<li><code>scanner/</code>：翻译文件扫描</li>
<li><code>parser/</code>：多格式解析</li>
<li><code>completion/</code> / <code>annotator/</code> / <code>reference/</code>：补全、诊断、导航</li>
<li><code>searcheverywhere/</code> / <code>statusbar/</code>：搜索与状态栏</li>
</ul>
<p>这样的结构非常适合插件类项目：入口清晰、扩展点映射明确。</p>
<hr/>
<h3 data-id="heading-7">四、核心功能如何实现：I18n Toolkit 代码拆解</h3>
<p>下面从核心功能视角，拆解这款插件的实现方式，并补充关键类与关键流程的实现细节，方便你对 IntelliJ 平台 API 的落点有更清晰的映射。</p>
<h4 data-id="heading-8">0. 启动与更新链路：ProjectActivity + VFS 监听</h4>
<p>插件运行期的“数据生命周期”由两条链路保证稳定：</p>
<ul>
<li><strong>启动初始化</strong>：<code>I18nProjectActivity</code> 实现 <code>ProjectActivity</code>，在项目打开时初始化缓存；同时替换 <code>QuickJavaDoc</code> Action，确保 i18n key 悬停/快捷文档体验一致。</li>
<li><strong>动态加载</strong>：<code>I18nDynamicPluginListener</code> 支持插件动态加载/卸载，无需重启 IDE；加载时对所有已打开项目初始化缓存并刷新 UI。</li>
<li><strong>VFS 变更监听</strong>：<code>I18nFileListener</code> 基于 <code>AsyncFileListener</code> 监听创建/修改/删除/移动/复制事件，仅处理 i18n 翻译文件，触发 <code>I18nCacheService.invalidateFile()</code> → <code>refresh()</code> → <code>I18nUiRefresher.refresh()</code> 的刷新链路。</li>
</ul>
<p>示例代码（启动与监听）：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">I18nProjectActivity</span> : <span class="hljs-type">ProjectActivity</span> {
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">execute</span><span class="hljs-params">(project: <span class="hljs-type">Project</span>)</span></span> {
        I18nCacheService.getInstance(project).initialize()
        installQuickDocOverride()
    }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">I18nFileListener</span> : <span class="hljs-type">AsyncFileListener</span> {
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">prepareChange</span><span class="hljs-params">(events: <span class="hljs-type">MutableList</span>&lt;<span class="hljs-type">out</span> <span class="hljs-type">VFileEvent</span>&gt;)</span></span>: AsyncFileListener.ChangeApplier? {
        <span class="hljs-keyword">val</span> relevantEvents = events.filter { e -&gt;
            <span class="hljs-keyword">val</span> file = e.file ?: <span class="hljs-keyword">return</span><span class="hljs-symbol">@filter</span> <span class="hljs-literal">false</span>
            e <span class="hljs-keyword">is</span> VFileContentChangeEvent || e <span class="hljs-keyword">is</span> VFileCreateEvent ||
                e <span class="hljs-keyword">is</span> VFileDeleteEvent || e <span class="hljs-keyword">is</span> VFileMoveEvent || e <span class="hljs-keyword">is</span> VFileCopyEvent
        }.filter { e -&gt; e.file?.let(I18nDirectoryScanner::isTranslationFile) == <span class="hljs-literal">true</span> }
        <span class="hljs-keyword">if</span> (relevantEvents.isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">object</span> : AsyncFileListener.ChangeApplier {
            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">afterVfsChange</span><span class="hljs-params">()</span></span> {
                ProjectManager.getInstance().openProjects.forEach { project -&gt;
                    relevantEvents.forEach { it.file?.let { f -&gt;
                        I18nCacheService.getInstance(project).invalidateFile(f)
                    } }
                }
            }
        }
    }
}
</code></pre>
<h4 data-id="heading-9">1. 统一缓存中心：I18nCacheService</h4>
<p>插件需要频繁获取翻译数据，<strong>缓存服务</strong>是第一优先级：</p>
<ul>
<li>项目启动时初始化</li>
<li>扫描目录 → 解析文件 → 生成 TranslationData</li>
<li>提供 API：按 key 查找、按语言过滤、查找所有翻译</li>
<li>文件变更时刷新缓存并刷新 UI</li>
</ul>
<p>这让补全、导航、搜索等功能都能基于同一份数据源。</p>
<p>实现细节补充：</p>
<ul>
<li><code>initialize()</code> 用 <code>initialized</code> 标记避免重复初始化，实际核心逻辑在 <code>refresh()</code>。</li>
<li><code>refresh()</code> 包裹在 <code>ReadAction.compute</code> 中，确保 PSI 读取安全；同时维护 <code>keyToFiles</code> 方便后续 quick fix 快速定位。</li>
<li><code>TranslationData</code> 内部结构是 <code>key -&gt; locale -&gt; TranslationEntry</code>，并提供 <code>getTranslation()</code> 默认回退策略（<code>zh_CN</code> → <code>zh</code> → <code>en</code> → 首个可用值）。</li>
<li><code>getTranslationStrict()</code> 基于 <code>I18nLocaleUtils.buildLocaleCandidates()</code> 进行严格 locale 匹配，不做全局回退。</li>
</ul>
<p>示例代码（缓存刷新核心流程）：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">refresh</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> translationFiles = I18nDirectoryScanner.scanForTranslationFiles(project)
    keyToFiles.clear()
    <span class="hljs-keyword">val</span> <span class="hljs-keyword">data</span> = ReadAction.compute&lt;TranslationData, RuntimeException&gt; {
        <span class="hljs-keyword">val</span> result = TranslationData(I18nFrameworkDetector.detect(project))
        translationFiles.forEach { file -&gt;
            <span class="hljs-keyword">val</span> pathInfo = I18nKeyGenerator.parseFilePath(file, project.basePath ?: <span class="hljs-string">""</span>)
            <span class="hljs-keyword">val</span> entries = TranslationFileParser.parse(project, file, pathInfo.keyPrefix, pathInfo.locale)
            entries.forEach { (key, entry) -&gt;
                result.addEntry(entry)
                keyToFiles.getOrPut(key) { mutableSetOf() }.add(entry)
            }
        }
        result
    }
    translationData = <span class="hljs-keyword">data</span>
}
</code></pre>
<h4 data-id="heading-10">2. 目录扫描：I18nDirectoryScanner</h4>
<p>扫描逻辑有两个重点：</p>
<ul>
<li>只扫描标准 i18n 目录：<code>locales</code> / <code>i18n</code> / <code>messages</code> / <code>lang</code> 等</li>
<li>排除目录：<code>node_modules</code>、<code>dist</code>、<code>build</code>、隐藏目录</li>
</ul>
<p>这样可以有效避免无关文件的解析成本。</p>
<p>实现细节补充：</p>
<ul>
<li><code>I18nDirectories.STANDARD_DIRS</code> 维护标准目录白名单；扫描使用 <code>VfsUtil.iterateChildrenRecursively</code>。</li>
<li>目录过滤逻辑同时跳过隐藏目录（以 <code>.</code> 开头）以及 <code>node_modules</code>、<code>dist</code>、<code>build</code>。</li>
<li>识别文件类型来自 <code>TranslationFileType</code>，支持 <code>json/yaml/yml/toml/js/mjs/cjs/ts/mts/cts/properties</code>。</li>
</ul>
<p>示例代码（扫描与类型识别）：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">object</span> I18nDirectoryScanner {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> excludedDirNames = setOf(<span class="hljs-string">"node_modules"</span>, <span class="hljs-string">"dist"</span>, <span class="hljs-string">"build"</span>)
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">scanForTranslationFiles</span><span class="hljs-params">(project: <span class="hljs-type">Project</span>)</span></span>: List&lt;VirtualFile&gt; {
        <span class="hljs-keyword">val</span> baseDir = project.guessProjectDir() ?: <span class="hljs-keyword">return</span> emptyList()
        <span class="hljs-keyword">val</span> translationFiles = mutableListOf&lt;VirtualFile&gt;()
        findI18nDirectories(baseDir).forEach { dir -&gt;
            VfsUtil.iterateChildrenRecursively(dir, ::shouldTraverse) { file -&gt;
                <span class="hljs-keyword">val</span> ext = file.extension?.lowercase()
                <span class="hljs-keyword">if</span> (!file.isDirectory &amp;&amp; ext <span class="hljs-keyword">in</span> TranslationFileType.allExtensions()) {
                    translationFiles.add(file)
                }
                <span class="hljs-literal">true</span>
            }
        }
        <span class="hljs-keyword">return</span> translationFiles
    }
}
</code></pre>
<h4 data-id="heading-11">3. 多格式解析：TranslationFileParser</h4>
<p>插件支持：</p>
<ul>
<li>JSON / YAML / TOML</li>
<li>Properties</li>
<li>JS / TS（对象字面量）</li>
</ul>
<p>解析方式是“<strong>尽可能利用 PSI</strong>”：</p>
<ul>
<li>JSON / JS / TS：走 PSI 结构，能拿到精确 offset</li>
<li>YAML / TOML：用第三方 parser，offset 为估算值</li>
</ul>
<p>这解释了为什么 YAML / TOML 的定位可能稍有偏差，但实际效果可接受。</p>
<p>实现细节补充：</p>
<ul>
<li><strong>JSON</strong>：用 <code>JsonFile</code> / <code>JsonObject</code> 递归解析，<code>TranslationEntry.offset</code> 精确定位到 key 的 <code>textOffset</code>。</li>
<li><strong>JS/TS</strong>：解析 <code>export default</code>、变量声明与表达式语句，提取对象字面量中的字符串值。</li>
<li><strong>YAML/TOML</strong>：使用 SnakeYAML / toml4j 解析结构，offset 通过累加长度估算。</li>
<li><strong>Properties</strong>：按行扫描 <code>key=value</code>，过滤注释行并记录行内 offset。</li>
</ul>
<p>示例代码（JSON / JS/TS 解析片段）：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">parseJsonObject</span><span class="hljs-params">(obj: <span class="hljs-type">JsonObject</span>, prefix: <span class="hljs-type">String</span>, locale: <span class="hljs-type">String</span>, file: <span class="hljs-type">VirtualFile</span>, <span class="hljs-keyword">out</span>: <span class="hljs-type">MutableMap</span>&lt;<span class="hljs-type">String</span>, TranslationEntry&gt;)</span></span> {
    obj.propertyList.forEach { prop -&gt;
        <span class="hljs-keyword">val</span> key = prop.name
        <span class="hljs-keyword">val</span> fullKey = <span class="hljs-keyword">if</span> (prefix.isEmpty()) key <span class="hljs-keyword">else</span> <span class="hljs-string">"<span class="hljs-variable">$prefix</span><span class="hljs-variable">$key</span>"</span>
        <span class="hljs-keyword">when</span> (<span class="hljs-keyword">val</span> value = prop.value) {
            <span class="hljs-keyword">is</span> JsonStringLiteral -&gt; <span class="hljs-keyword">out</span>[fullKey] = TranslationEntry(fullKey, value.value, locale, file, prop.nameElement.textOffset, prop.nameElement.textLength)
            <span class="hljs-keyword">is</span> JsonObject -&gt; parseJsonObject(value, <span class="hljs-string">"<span class="hljs-variable">$fullKey</span>."</span>, locale, file, <span class="hljs-keyword">out</span>)
        }
    }
}

<span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">parseJsExpression</span><span class="hljs-params">(expr: <span class="hljs-type">JSExpression</span>?, prefix: <span class="hljs-type">String</span>, locale: <span class="hljs-type">String</span>, file: <span class="hljs-type">VirtualFile</span>, <span class="hljs-keyword">out</span>: <span class="hljs-type">MutableMap</span>&lt;<span class="hljs-type">String</span>, TranslationEntry&gt;)</span></span> {
    <span class="hljs-keyword">if</span> (expr <span class="hljs-keyword">is</span> JSObjectLiteralExpression) {
        expr.properties.forEach { prop -&gt;
            <span class="hljs-keyword">val</span> key = prop.name ?: <span class="hljs-keyword">return</span><span class="hljs-symbol">@forEach</span>
            <span class="hljs-keyword">val</span> fullKey = <span class="hljs-keyword">if</span> (prefix.isEmpty()) key <span class="hljs-keyword">else</span> <span class="hljs-string">"<span class="hljs-variable">$prefix</span><span class="hljs-variable">$key</span>"</span>
            <span class="hljs-keyword">val</span> value = prop.value <span class="hljs-keyword">as</span>? JSLiteralExpression
            value?.stringValue?.let { <span class="hljs-keyword">out</span>[fullKey] = TranslationEntry(fullKey, it, locale, file, prop.textOffset, key.length) }
        }
    }
}
</code></pre>
<h4 data-id="heading-12">4. Key 前缀生成：I18nKeyGenerator</h4>
<p>i18n 目录结构通常体现模块或业务层级，例如：</p>
<pre><code class="hljs language-bash" lang="bash">src/views/mes/locales/lang/zh_CN/order.ts
</code></pre>
<p>插件通过路径自动推导：</p>
<ul>
<li>locale：<code>zh_CN</code></li>
<li>keyPrefix：<code>mes.order.</code></li>
</ul>
<p>这样在代码里写 <code>t('create')</code>，也能正确定位到 <code>mes.order.create</code>。</p>
<p>实现细节补充：</p>
<ul>
<li><code>parseFilePath()</code> 区分 <strong>views 模式</strong> 与 <strong>标准模式</strong>：views 模式会把业务单元与模块组合为前缀。</li>
<li>对 <code>message/messages</code> 目录进行特殊处理：避免把它作为 module 前缀（常见于 Spring Message）。</li>
<li>当路径里找不到 locale 时，会回退到文件名判断 locale。</li>
</ul>
<p>示例代码（路径解析与前缀生成）：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">parseFilePath</span><span class="hljs-params">(file: <span class="hljs-type">VirtualFile</span>, projectBasePath: <span class="hljs-type">String</span>)</span></span>: PathInfo {
    <span class="hljs-keyword">val</span> relativePath = file.path.removePrefix(projectBasePath).removePrefix(<span class="hljs-string">"/"</span>)
    <span class="hljs-keyword">val</span> parts = relativePath.split(<span class="hljs-string">"/"</span>)
    <span class="hljs-keyword">val</span> fileName = file.nameWithoutExtension
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">when</span> {
        isViewsLocalePattern(parts) -&gt; parseViewsLocalePattern(parts, fileName)
        isStandardLocalePattern(parts) -&gt; parseStandardLocalePattern(parts, fileName)
        <span class="hljs-keyword">else</span> -&gt; PathInfo(locale = extractLocale(parts, fileName), module = <span class="hljs-literal">null</span>, businessUnit = <span class="hljs-literal">null</span>, keyPrefix = <span class="hljs-string">""</span>)
    }
}
</code></pre>
<h4 data-id="heading-13">5. 框架检测：I18nFrameworkDetector</h4>
<p>插件会自动识别 i18n 框架：</p>
<ul>
<li>vue-i18n</li>
<li>react-i18next</li>
<li>next-intl</li>
<li>@nuxtjs/i18n</li>
<li>react-intl</li>
<li>Spring Message（检测 <code>pom.xml</code> 或 <code>build.gradle</code>）</li>
</ul>
<p>如果识别成功，可自动决定语义规则和函数习惯，减少配置。</p>
<p>实现细节补充：</p>
<ul>
<li><strong>Spring 检测</strong>：直接读取 <code>pom.xml</code> / <code>build.gradle(.kts)</code> 文本，判断关键依赖字符串。</li>
<li><strong>JS/TS 检测</strong>：通过 PSI 解析 <code>package.json</code>，遍历 <code>dependencies / devDependencies / peerDependencies</code>。</li>
</ul>
<p>示例代码（依赖检测）：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">parsePackageJson</span><span class="hljs-params">(project: <span class="hljs-type">Project</span>, file: <span class="hljs-type">VirtualFile</span>)</span></span>: I18nFramework {
    <span class="hljs-keyword">val</span> psiFile = PsiManager.getInstance(project).findFile(file) <span class="hljs-keyword">as</span>? JsonFile ?: <span class="hljs-keyword">return</span> I18nFramework.UNKNOWN
    <span class="hljs-keyword">val</span> rootObject = psiFile.topLevelValue <span class="hljs-keyword">as</span>? JsonObject ?: <span class="hljs-keyword">return</span> I18nFramework.UNKNOWN
    <span class="hljs-keyword">val</span> deps = mutableSetOf&lt;String&gt;()
    listOf(<span class="hljs-string">"dependencies"</span>, <span class="hljs-string">"devDependencies"</span>, <span class="hljs-string">"peerDependencies"</span>).forEach { depType -&gt;
        (rootObject.findProperty(depType)?.value <span class="hljs-keyword">as</span>? JsonObject)?.propertyList?.forEach { deps.add(it.name) }
    }
    <span class="hljs-keyword">return</span> I18N_PACKAGES.firstOrNull { deps.contains(it) }?.let(I18nFramework::fromPackageName) ?: I18nFramework.UNKNOWN
}
</code></pre>
<h4 data-id="heading-14">6. Inlay 提示：I18nInlayHintsProvider</h4>
<p>这类体验是插件“可感知度”最高的部分：</p>
<ul>
<li>在 <code>t('key')</code> 后面显示翻译内容</li>
<li>支持 Vue template 的注入代码</li>
<li>缓存已处理位置，避免重复插入</li>
<li>可设置为“仅显示翻译”或“key + 翻译”模式</li>
</ul>
<p>这套逻辑结合了 PSI + Inlay API + InjectedLanguageManager。</p>
<p>实现细节补充：</p>
<ul>
<li><code>globalProcessedHints</code> 以 <code>filePath:modStamp:offset</code> 为 key 去重，避免多语言实例重复插入提示。</li>
<li>Vue 模板插值中的 <code>{{ t('key') }}</code> 使用 <code>InjectedLanguageManager</code> 处理 injected PSI。</li>
<li>先用 <code>I18nNamespaceResolver.getFullKey()</code> 拼接命名空间，再做翻译匹配。</li>
<li>若显示语言存在但缺失该 key，会显示 <code>Missing translation for 'locale'</code> 的提示文案。</li>
</ul>
<p>示例代码（Inlay 去重与渲染）：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">val</span> hintKey = <span class="hljs-string">"<span class="hljs-variable">$filePath</span>:<span class="hljs-variable">$modStamp</span>:<span class="hljs-variable">$offset</span>"</span>
<span class="hljs-keyword">if</span> (globalProcessedHints.putIfAbsent(hintKey, <span class="hljs-literal">true</span>) != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>

<span class="hljs-keyword">val</span> presentation = factory.roundWithBackground(
    factory.smallText(<span class="hljs-string">" → <span class="hljs-variable">$translationText</span>"</span>)
)
sink.addInlineElement(offset, <span class="hljs-literal">true</span>, presentation, <span class="hljs-literal">false</span>)
</code></pre>
<h4 data-id="heading-15">7. 缺失 Key 诊断 + 快速修复</h4>
<p>缺失 key 会被标红，并提供一键创建：</p>
<ul>
<li><code>I18nKeyAnnotator</code> 负责提示错误</li>
<li><code>CreateI18nKeyQuickFix</code> 根据 key 自动选择目标文件</li>
<li>支持 JSON / JS / TS / Properties 直接写入</li>
</ul>
<p>尤其是“根据 key 前缀和兄弟 key 自动选择文件”的逻辑，极大提升了体验。</p>
<p>实现细节补充：</p>
<ul>
<li><code>I18nKeyAnnotator</code> 使用 <code>I18nFunctionResolver</code> 获取可配置的 i18n 函数名（默认 <code>t/$t/i18n/translate/...</code>）。</li>
<li>只高亮字符串内容本身（排除引号），并挂载 <code>CreateI18nKeyQuickFix</code>。</li>
<li><code>CreateI18nKeyQuickFix</code> 先尝试 <strong>最长前缀匹配</strong>，失败后再用 <strong>兄弟 key</strong> 反推文件。</li>
<li>实际写入通过 <code>WriteCommandAction</code> + PSI 操作完成，写入后用 <code>OpenFileDescriptor</code> 定位并把光标放在引号之间。</li>
</ul>
<p>示例代码（缺失 Key 高亮范围）：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">val</span> elementRange = literalExpr.textRange
<span class="hljs-keyword">val</span> keyStartOffset = elementRange.startOffset + <span class="hljs-number">1</span>
<span class="hljs-keyword">val</span> keyEndOffset = keyStartOffset + partialKey.length
<span class="hljs-keyword">val</span> highlightRange = TextRange(keyStartOffset, keyEndOffset)
holder.newAnnotation(HighlightSeverity.ERROR, <span class="hljs-string">"Unresolved i18n key: '<span class="hljs-variable">$fullKey</span>'"</span>)
    .range(highlightRange)
    .textAttributes(DefaultLanguageHighlighterColors.INVALID_STRING_ESCAPE)
    .withFix(CreateI18nKeyQuickFix(fullKey))
    .create()
</code></pre>
<h4 data-id="heading-16">8. Search Everywhere 集成</h4>
<p>插件在 Search Everywhere 中新增 <strong>I18n</strong> 标签：</p>
<ul>
<li>key 和翻译都支持模糊搜索</li>
<li>Enter：复制 key</li>
<li>Ctrl+Enter：跳转到翻译文件</li>
<li>结果排序有评分策略（前缀匹配 &gt; 包含匹配）</li>
</ul>
<p>这让翻译搜索真正成为“IDE 级别”的能力。</p>
<p>实现细节补充：</p>
<ul>
<li>搜索结果以 “key + 多语言翻译” 合并为一个条目。</li>
<li>评分策略在 <code>calculateMatchScore()</code> 中实现：前缀匹配最高，其次是包含匹配与 value 匹配。</li>
<li>Enter 复制 key，Ctrl+Enter 直接打开翻译文件，行为明确且稳定。</li>
</ul>
<p>示例代码（搜索评分片段）：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">calculateMatchScore</span><span class="hljs-params">(key: <span class="hljs-type">String</span>, entries: <span class="hljs-type">Collection</span>&lt;<span class="hljs-type">TranslationEntry</span>&gt;, tokens: <span class="hljs-type">List</span>&lt;<span class="hljs-type">String</span>&gt;, compactQuery: <span class="hljs-type">String</span>)</span></span>: <span class="hljs-built_in">Int</span> {
    <span class="hljs-keyword">val</span> keyLower = key.lowercase()
    <span class="hljs-keyword">val</span> keyMatchesAll = tokens.isNotEmpty() &amp;&amp; tokens.all { keyLower.contains(it) }
    <span class="hljs-keyword">var</span> score = <span class="hljs-number">0</span>
    <span class="hljs-keyword">if</span> (keyMatchesAll) score += <span class="hljs-number">100</span>
    <span class="hljs-keyword">if</span> (tokens.isNotEmpty() &amp;&amp; keyLower.startsWith(tokens.first())) score += <span class="hljs-number">1000</span>
    <span class="hljs-keyword">return</span> score
}
</code></pre>
<h4 data-id="heading-17">9. 状态栏语言切换 + 翻译编辑</h4>
<ul>
<li>状态栏小部件支持显示与切换当前语言</li>
<li>翻译弹窗支持多语言编辑，并可实时写入文件</li>
</ul>
<p>这些 UI 功能用到 <code>StatusBarWidget</code> 和 <code>JBPopupFactory</code>，是典型插件 UI 技术。</p>
<p>实现细节补充：</p>
<ul>
<li><code>I18nStatusBarWidget</code> 通过 <code>ListPopup</code> 提供语言列表与“Go to Settings”入口，切换语言后触发 UI refresh。</li>
<li><code>I18nTranslationEditPopup</code> 使用 <code>Alarm</code> 做 300ms 防抖，编辑后实时写回文件。</li>
<li><code>I18nTranslationWriter</code> 根据文件类型分别替换 JSON/JS/Properties 内容，并处理引号与转义。</li>
</ul>
<p>示例代码（状态栏切换与写回）：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">val</span> step = <span class="hljs-keyword">object</span> : BaseListPopupStep&lt;PopupItem&gt;(<span class="hljs-string">"I18n Toolkit"</span>, allItems) {
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onChosen</span><span class="hljs-params">(selectedValue: <span class="hljs-type">PopupItem</span>?, finalChoice: <span class="hljs-type">Boolean</span>)</span></span>: PopupStep&lt;*&gt;? {
        <span class="hljs-keyword">if</span> (selectedValue <span class="hljs-keyword">is</span> PopupItem.LocaleItem) {
            settings.state.displayLocale = selectedValue.locale
            I18nUiRefresher.refresh(project)
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.onChosen(selectedValue, finalChoice)
    }
}

WriteCommandAction.runWriteCommandAction(project, <span class="hljs-string">"Update i18n Translation"</span>, <span class="hljs-literal">null</span>, Runnable {
    <span class="hljs-keyword">val</span> document = FileDocumentManager.getInstance().getDocument(entry.file) ?: <span class="hljs-keyword">return</span><span class="hljs-symbol">@Runnable</span>
    document.replaceString(valueStart, lineEnd, newValue)
})
</code></pre>
<hr/>
<h3 data-id="heading-18">五、插件功能如何挂载：plugin.xml 扩展点</h3>
<p>所有功能都需要通过 <code>plugin.xml</code> 注册：</p>
<ul>
<li><code>projectService</code>：缓存服务</li>
<li><code>inlayProvider</code>：内联提示</li>
<li><code>annotator</code>：错误提示</li>
<li><code>completion.contributor</code>：补全</li>
<li><code>psi.referenceContributor</code>：导航</li>
<li><code>searchEverywhereContributor</code>：搜索</li>
<li><code>statusBarWidgetFactory</code>：状态栏</li>
</ul>
<p>这里是 IntelliJ 平台插件开发的核心：</p>
<blockquote>
<p><strong>一切功能都是“扩展点 + 实现类”的组合。</strong></p>
</blockquote>
<hr/>
<h3 data-id="heading-19">六、构建、测试与发布</h3>
<p>常用命令：</p>
<pre><code class="hljs language-bash" lang="bash">./gradlew runIde          <span class="hljs-comment"># 本地运行</span>
./gradlew buildPlugin     <span class="hljs-comment"># 构建分发包</span>
./gradlew <span class="hljs-built_in">test</span>            <span class="hljs-comment"># 运行测试</span>
./gradlew check           <span class="hljs-comment"># 测试 + 覆盖率</span>
./gradlew verifyPlugin    <span class="hljs-comment"># 插件兼容性验证</span>
</code></pre>
<p>如果要发布到 JetBrains Marketplace，补齐签名配置即可。</p>
<hr/>
<h3 data-id="heading-20">七、总结：从模板到可用插件的关键路径</h3>
<p><strong>模板给你骨架，真正的价值来自你的“功能设计”与“用户体验”。</strong></p>
<p>I18n Toolkit 的实现告诉我们：</p>
<ul>
<li>缓存与解析是插件性能的核心</li>
<li>IntelliJ 扩展点体系决定功能边界</li>
<li>体验要足够“IDE 级”，才能真正提升开发效率</li>
</ul>
<p>如果你也想写一个生产力插件，不妨从这个开源项目入手，读一遍核心类，跑一遍 <code>runIde</code>，就能快速进入实战状态。</p>
<hr/>
<p>如果你对该插件感兴趣或想参与贡献：</p>
<ul>
<li>模板项目：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FJetBrains%2Fintellij-platform-plugin-template" target="_blank" title="https://github.com/JetBrains/intellij-platform-plugin-template" ref="nofollow noopener noreferrer">github.com/JetBrains/i…</a></li>
<li>插件仓库：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fyelog%2Fi18n-toolkit" target="_blank" title="https://github.com/yelog/i18n-toolkit" ref="nofollow noopener noreferrer">github.com/yelog/i18n-…</a></li>
</ul>
<p>祝你玩得开心，写出属于自己的 JetBrains 插件！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[速通-微信小程序]]></title>    <link>https://juejin.cn/post/7601822421609889819</link>    <guid>https://juejin.cn/post/7601822421609889819</guid>    <pubDate>2026-02-02T08:07:47.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7601822421609889819" data-draft-id="7602069205467185198" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="速通-微信小程序"/> <meta itemprop="keywords" content="前端,微信小程序,微信"/> <meta itemprop="datePublished" content="2026-02-02T08:07:47.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="慈様ya"/> <meta itemprop="url" content="https://juejin.cn/user/3281384295639245"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            速通-微信小程序
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3281384295639245/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    慈様ya
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-02T08:07:47.000Z" title="Mon Feb 02 2026 08:07:47 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-02
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    2
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读17分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">速通-微信小程序🟢</h2>
<p>2026年1月，最近又空闲了，没错我 <code>叒叒</code> 没有工作了，最近一段时间好迷茫啊，</p>
<p>因为学历问题，外面大城市不好找工作(没有面试机会)，这个三线小城市基本上本人面试成功率80%</p>
<p>目前小地方公司，又出现发不起工资的情况，所以 ………… 种种原因，后面还是要计划，出去找一下！</p>
<p><strong>正好，</strong> 最近就利用空闲时间学习一下 <code>微信小程序吧！</code> 总不能一直摸鱼，玩到过年吧，blog 也好久没🆙🆙🆙</p>
<ul>
<li>一方面，是因为AI 的出现，不得不说，AI真的很厉害，任何问题都能轻松的解决，省去了很多时间！</li>
<li>另一方面，最近在准备自考相关的学历提升，工作，生活，等后面，写个年总吧……</li>
</ul>
<p><strong>运气不错，</strong> 最近有幸接了一个私活，<code>WX小程序相关的</code> 仔细想想，也是小程序</p>
<ul>
<li>更方便，被大众市场需求，能接到更多需求，觉得是一个方向，对于个体开发者！！开始学习！！！</li>
</ul>
<hr/>
<p><strong>本篇文章及后续学习参考：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1834y1676P%3Fspm_id_from%3D333.788.videopod.episodes%26vd_source%3D19e007a1660dfd5c8f1744e56d027bf4%26p%3D2" target="_blank" title="https://www.bilibili.com/video/BV1834y1676P?spm_id_from=333.788.videopod.episodes&amp;vd_source=19e007a1660dfd5c8f1744e56d027bf4&amp;p=2" ref="nofollow noopener noreferrer">黑马—微信小程序简介</a></p>
<h2 data-id="heading-1">WX小程序-简介</h2>
<p><strong>小程序与普通网页开发的区别：</strong></p>
<p><strong>运行环境不同：</strong></p>
<ul>
<li>
<p><strong>普通网页</strong>：运行在 Chrome 等浏览器内核中，</p>
<p>依赖完整的 DOM（文档对象模型）和 BOM（浏览器对象模型）</p>
<p>跨浏览器兼容性是核心痛点（比如不同浏览器对 CSS 属性的支持差异）</p>
</li>
<li>
<p><strong>小程序</strong>：运行在微信内置的双线程环境，无 DOM/BOM，</p>
<p>所有能力由微信桥接层提供，兼容性完全由微信保障，无需适配多浏览器</p>
</li>
</ul>
<p><strong>开发模式不同：</strong></p>
<ul>
<li>
<p><strong>普通网页</strong>：可调用浏览器提供的 DOM/BOM API</p>
<p>如：<code>document.getElementById</code>、<code>window.location</code>，也能使用前端框架的API</p>
</li>
<li>
<p><strong>小程序</strong>：<strong>完全禁止 DOM/BOM API</strong>，只能使用微信专属 API</p>
<p>如：<code>wx.request</code>发起网络请求、<code>wx.scanCode</code>调用扫码、<code>wx.pay</code>发起支付</p>
<p>这些 API 直接对接微信生态能力，体验接近原生 App，<code>小程序开发需要熟悉微信 API 文档</code>；</p>
</li>
</ul>
<p><strong>API 不同：</strong></p>
<ul>
<li>
<p><strong>普通网页</strong>：开发工具仅需 <code>浏览器 + 代码编辑器 如 VS Code</code></p>
<p>调试用浏览器 F12，上线只需将文件上传至服务器，无平台审核；</p>
</li>
<li>
<p><strong>小程序</strong>：必须遵循微信的标准流程：</p>
<p>申请小程序开发账号、安装微信开发者工具、</p>
<p>创建并配置小程序项目创建并配置小程序项目、</p>
<p>调试依赖开发者工具的模拟器 / 真机预览，上线需经过微信平台审核(1-3 个工作日)</p>
</li>
</ul>
<p><strong>🧊体验小程序：</strong> 可使用手机微信(6.7.2 及以上版本)扫码下方小程序码，体验小程序，相关组件模块：</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fi-blog.csdnimg.cn%2Fdirect%2Fa6360f35808e4d6f919e03315f1e500c.png" target="_blank" title="https://i-blog.csdnimg.cn/direct/a6360f35808e4d6f919e03315f1e500c.png" ref="nofollow noopener noreferrer">i-blog.csdnimg.cn/direct/a636…</a></p>
<h2 data-id="heading-2">第一个微信小程序：</h2>
<h3 data-id="heading-3">注册小程序开发账号：</h3>
<p>使用浏览器打开 <a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2F" target="_blank" title="https://mp.weixin.qq.com/" ref="nofollow noopener noreferrer">mp.weixin.qq.com/</a> 网址，</p>
<p>点击右上角的“<strong>立即注册</strong>”即可进入到小程序开发账号的注册流程，<strong>此处就不详细介绍：</strong></p>
<ul>
<li>
<p><strong>选择注册账号的类型：</strong> 小程序；</p>
</li>
<li>
<p><strong>填写账号信息，邮箱注册：</strong> 注意，每个邮箱仅可以申请一个小程序！<code>邮箱认证！</code></p>
</li>
<li>
<p><strong>选择小程序主体类型：信息登记</strong>  按需求填写即可，学习阶段建议：<code>中国大陆</code> / <code>个人</code></p>
<p>个人与企业主体的差异直接决定了小程序的 <strong>功能权限、审核难度、法律责任和商业变现能力</strong></p>
</li>
</ul>
<p>个人主体：仅需 <strong>身份证 + 微信实名认证</strong>，无需营业执照，流程 5 分钟完成，<strong>限制多</strong>：</p>
<ul>
<li>不可开通 <strong>微信支付、云开发、敏感接口</strong> <code>如手机号快速验证、unionID</code>  等…………</li>
<li>仅 1 个管理员账号，同一身份证最多注册 <strong>5 个</strong> 小程序</li>
</ul>
<p>企业主体：需 <strong>营业执照 + 法人身份证 + 对公账户 / 法人微信认证</strong>，</p>
<ul>
<li>部分行业需行业资质，如<code>食品</code>、<code>医疗</code>， <strong>全功能、审核严格</strong>，同一企业最多注册 <strong>50 个</strong> 小程序；</li>
</ul>
<hr/>
<p><strong>获取小程序APPID：</strong> 🆗经过上面的操作，已经成功注册了小程序账号，接下来：<a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2F" target="_blank" title="https://mp.weixin.qq.com/" ref="nofollow noopener noreferrer">⌨️登录，微信公众平台</a></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/84e2c730ef1f456ab47a96dffb05bdf8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oWI5qeYeWE=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770624503&amp;x-signature=K%2Besir5sRwNUfUf3jOeFIeh9Xd4%3D" alt="image-20260129153600067.png" loading="lazy"/>
<strong>开发与服务——开发设置：</strong> 时间推移，可能会有所变化，影响不大！</p>
<p><strong>AppID 小程序唯一标识：</strong></p>
<p>AppID 是微信给每个小程序分配的<strong>全球唯一字符串</strong></p>
<p>如 <code>wx8407df8e55ebb60d</code> 相当于小程序的 “身份证号”，<strong>公开可暴露</strong></p>
<ul>
<li>
<p><strong>新建项目必备</strong>：在微信开发者工具中创建项目时，必须填入 AppID，</p>
<p>工具会根据 AppID 关联对应的小程序账号，区分<strong>测试号</strong>和<strong>正式号</strong>，加载对应的权限与配置</p>
</li>
<li>
<p><strong>微信生态唯一标识</strong>：小程序调用微信所有 API 如：扫码、定位、登录时，</p>
<p>必须携带 AppID，微信服务器通过 AppID 识别 “是哪个小程序在请求”</p>
</li>
</ul>
<p><strong>AppSecret 小程序密钥：</strong></p>
<p>AppSecret 是小程序的 <strong>私密鉴权密钥</strong>，相当于 “登录密码”，<strong>绝对不可暴露</strong></p>
<p>仅存储在，后端服务，核心作用是<strong>身份鉴权</strong>，生成：<strong>调用微信敏感 API 核心凭证 <code>access_token</code></strong></p>
<h3 data-id="heading-4">安装微信开发者工具：</h3>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fdevtools%2Fdownload.html" target="_blank" title="https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html" ref="nofollow noopener noreferrer">下载|安装开发者工具：</a> <strong>官方推荐使用的小程序开发工具🪄🪄🪄</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e485169645184332ab58db057e05e217~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oWI5qeYeWE=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770624503&amp;x-signature=J8g3DwH1kmXaXDxyHX%2F9U5lMMXY%3D" alt="PixPin_2026-01-29_16-29-31.gif" loading="lazy"/></p>
<p><strong>↗️点击右上角【设置】</strong> 可以对开发工具进行设置：样式、默认路径、服务代理等等，</p>
<p><strong>🌐代理设置：</strong> 建议使用：<code>不使用任何代理</code> 因为，不同人的电脑可能存在一些配置|魔法工具！！</p>
<p>而微信小程序，开发中有很多需要和微信进行通信的，勾选此配置，更能保证，微信API 通知稳定！</p>
<h3 data-id="heading-5">创建微信小程序项目：</h3>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/590ba1700f804abeadd551f3aaef0eef~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oWI5qeYeWE=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770624503&amp;x-signature=zgfsdRirwB6i8ZpruKv7xqmvUWU%3D" alt="PixPin_2026-01-29_17-17-56.gif" loading="lazy"/></p>
<p><strong>AppID小程序唯一标识（如截图中的<code>wx5ed...29d6</code>）</strong></p>
<p><strong>后端服务 + 语言后端服务选 “不使用云服务”，语言选 <code>JavaScript</code></strong></p>
<ul>
<li>
<p><strong>不使用云服务</strong>：适合后端开发者，因为需要 <strong>自建后端服务</strong> 对接小程序，</p>
<p>云服务是微信提供的云端后端，无需自建服务器， <strong>适合纯前端开发者</strong></p>
</li>
<li>
<p><strong>JavaScript</strong>：小程序原生开发的默认语言，入门门槛低，适合新手；<strong>页面如此：</strong></p>
</li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/89a888d55f524302b9779620ce4a2479~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oWI5qeYeWE=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770624503&amp;x-signature=Q2UuMQwgAoBqWRBkus318KWpW7U%3D" alt="PixPin_2026-01-29_17-31-14.gif" loading="lazy"/>
<code>不详细介绍了，摸索着去体验吧！！！</code></p>
<h3 data-id="heading-6">小程序代码的构成：</h3>
<pre><code class="hljs language-tcl" lang="tcl">WSM01/
├── pages/                # 页面模块目录（核心），每个页面一个独立子文件夹
│   ├── index/            # 首页（默认页面），包含4个核心文件
│   │   ├── index.wxml    # 页面结构
│   │   ├── index.wxss    # 页面样式
│   │   ├── index.js      # 页面逻辑
│   │   └── index.json    # 页面配置
│   └── logs/             # 日志页面（默认生成，可删除/修改）
├── utils/                # 通用工具类目录（对应Java的utils包）
├── app.js                # 全局逻辑文件（对应Java的全局入口类）
├── app.json              # 全局配置文件（核心，对应Java的application.yml）
├── app.wxss              # 全局样式文件（对应Java的全局样式/公共CSS）
├── project.config.json   # 开发者工具项目配置（对应Java的pom.xml/gradle配置）
├── project.private.config.json # 私有配置（如个人开发偏好，无需关注）
└── sitemap.json          # 微信搜索索引配置（SEO相关）
</code></pre>
<h4 data-id="heading-7">全局核心文件</h4>
<p>全局文件位于项目根目录，<strong>作用于整个小程序</strong>，是项目启动和运行的基础，必须存在且命名固定；</p>
<p><strong>app.js</strong> 逻辑文件</p>
<ul>
<li>
<p>小程序<strong>全局入口</strong>，管理全局生命周期、全局数据、全局方法</p>
</li>
<li>
<p>通过<code>App({})</code>函数定义全局实例，包含</p>
<p><code>onLaunch</code>（小程序启动时执行，仅 1 次）<code>onShow</code>（小程序前台显示时执行）等生命周期；</p>
<p>存放全局数据，如后端接口基础地址 <code>globalData: { baseUrl: "https://xx.xx.x.xx:8080" }</code></p>
</li>
</ul>
<p><strong>app.json</strong> 配置文件</p>
<ul>
<li>小程序<strong>全局配置核心</strong>，决定页面路由、窗口样式、tabBar 等，<strong>严格 JSON 格式</strong></li>
<li><code>pages</code>：页面路由数组 <strong>第一个元素为默认首页</strong>，新增页面<code>必须在这里注册，工具会自动生成页面文件</code></li>
<li><code>window</code>：全局窗口样式：导航栏标题、背景色、文字颜色；</li>
<li><code>sitemapLocation：</code> 用来指明 <code>sitemap.json</code> 文件位置</li>
<li><code>tabBar</code>：底部导航栏：多页面切换时配置；</li>
</ul>
<p><strong>app.wxss</strong> 样式文件，全局样式表，所有页面均可继承使用；</p>
<ul>
<li>语法：基于 CSS，支持<code>rpx</code>适配单位，<strong>无作用域</strong>，所有页面生效；</li>
<li>存放公共样式，如按钮默认样式、全局字体、颜色变量，避免重复编写样式；</li>
</ul>
<h4 data-id="heading-8">页面模块目录</h4>
<p><strong><code>pages/</code></strong> 目录是小程序的<strong>页面容器</strong>，<strong>每个页面对应一个独立子文件夹</strong> <code>如: 截图中的index、logs</code></p>
<p>文件夹名称建议与页面功能一致 如：<code>home</code>、<code>order</code> <strong>每个页面必须包含 1-4 个核心文件</strong></p>
<p><strong>xxx.wxml</strong> 结构文件，页面视图层，定义页面结构 <code>对应HTML</code></p>
<p><strong>xxx.wxss</strong> 样式文件，页面视图层，定义页面专属样式 <code>对应 CSS</code></p>
<p><strong>xxx.js</strong> 逻辑文件，页面逻辑层，管理页面生命周期、数据、交互、响应；</p>
<p><strong>xxx.json</strong> 页面配置文件页面专属配置，覆盖全局配置 app.json，优先级最高！</p>
<h4 data-id="heading-9">通用工具 / 配置文件</h4>
<p><strong>工具封装、开发者工具配置、搜索优化</strong>，非核心业务文件，但能提升开发效率和项目规范性</p>
<p><strong>utils/</strong> 通用工具类目录</p>
<ul>
<li>存放可复用的 JS 工具函数</li>
<li>如：<code>日期格式化、接口请求封装、数据校验</code></li>
</ul>
<p><strong>sitemap.json</strong> 微信搜索索引配置，控制小程序是否允许：<code>被微信搜索收录</code></p>
<p><strong>project.config.json</strong> 开发者工具项目配置：保存，开发者工具的个性化设置🔧</p>
<ul>
<li>如 AppID、项目名称、编译模式，<strong>提交代码时建议保留</strong>，确保团队开发环境一致；</li>
</ul>
<p><strong>project.private.config.json</strong> 私有配置，存放个人开发偏好：<code>如编辑器主题、快捷键</code> <strong>无需提交代码</strong></p>
<h3 data-id="heading-10">小程序基本使用：</h3>
<h4 data-id="heading-11">app.json 操作：</h4>
<p><strong>app.json</strong> 基础操作，大致如此，不同版本可能会存在差异，影响不大！</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"pages"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
    <span class="hljs-string">"pages/index/index"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-string">"pages/logs/logs"</span>
  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"window"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"navigationBarTextStyle"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"black"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"navigationBarTitleText"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Weixin"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"navigationBarBackgroundColor"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"#ffffff"</span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  
  <span class="hljs-attr">"style"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"v2"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"componentFramework"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"glass-easel"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"sitemapLocation"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"sitemap.json"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"lazyCodeLoading"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"requiredComponents"</span>
<span class="hljs-punctuation">}</span>

</code></pre>
<ul>
<li><strong>style：</strong> 指定小程序的 <strong>样式版本</strong>，<code>v2</code>是微信推出的 <strong>新版样式标准</strong></li>
<li><strong>sitemapLocation：</strong> 指定小程序 <strong>搜索索引配置文件</strong> 路径，控制小程序页面允许被微信搜索收录；</li>
<li><strong>lazyCodeLoading：</strong> 小程序的 <strong>代码懒加载策略</strong>，<code>requiredComponents</code> <strong>仅在自定义组件时使用；</strong></li>
</ul>
<h5 data-id="heading-12">pages：</h5>
<p><strong>小程序的页面路由由<code>app.json</code>的<code>pages</code>数组自动管理</strong>，无需手动配置路由映射；</p>
<p><strong>默认首页</strong>：数组<strong>第一个元素</strong>（<code>pages/index/index</code>）是小程序启动时的默认首页；</p>
<p><strong>自动生成页面</strong>：若在<code>pages</code>中新增页面路径，微信开发者工具会 <strong>自动生成该页面的 4 个核心文件</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e5d524a5708e443d8ce908f8cf1fbfe2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oWI5qeYeWE=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770624503&amp;x-signature=40vKJmFVoOhfuZugQf4lOW2FDtE%3D" alt="PixPin_2026-01-29_21-06-29.gif" loading="lazy"/></p>
<h5 data-id="heading-13">window:</h5>
<p>控制小程序  <strong>顶部导航栏（窗口）</strong> 的全局样式，所有页面默认继承该配置，</p>
<p>若页面有单独的<code>xxx.json</code>配置，会覆盖此处的对应属性；</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2343785272f14a0fb269452928cbcc9a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oWI5qeYeWE=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770624503&amp;x-signature=g2Ktxotd4pn6r4pJb%2B%2F5RYDVWVk%3D" alt="PixPin_2026-01-29_21-52-24.gif" loading="lazy"/></p>
<h4 data-id="heading-14">project.config.json 操作：</h4>
<p><code>project.config.json</code> 是项目配置文件，用来记录我们对小程序开发工具所做的个性化配置；</p>
<p><strong>appid：</strong> 保存的是小程序的账号 ID，<code>如果导入的项目，需要到这边更换，自己小程序的ID！！</code></p>
<p><strong>projectname：</strong> 设置保存的是项目名称，注意项目名称，<code>并不是小程序名称！</code></p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"compileType"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"miniprogram"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"libVersion"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"trial"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"packOptions"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"ignore"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"include"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"setting"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
      <span class="hljs-comment">//...省略展示...</span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"condition"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"editorSetting"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"tabIndent"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"auto"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"tabSize"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"appid"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"wx8407df8e55ebb60d"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"simulatorPluginLibVersion"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<h5 data-id="heading-15">setting：</h5>
<p><strong>setting 中保存了编译相关的配置：</strong> 开发者工具的个性化设置；</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/61e11befdad3477cad927c14add47f33~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oWI5qeYeWE=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770624503&amp;x-signature=CpGWt%2Bj0D5HfnhudSQtcgGbQH7o%3D" alt="PixPin_2026-01-29_22-03-25.gif" loading="lazy"/></p>
<h3 data-id="heading-16">小程序宿主环境：</h3>
<p><strong>宿主环境</strong>  <code>host environment</code> 指的是程序运行所<strong>必须的依赖环境</strong></p>
<p><code>Android系统</code> 和 <code>iOS系统</code>是两个不同的宿主环境。安卓版的微信 App 是不能在 iOS 环境下运行的；</p>
<p><strong>微信</strong>是小程序的宿主环境，小程序借助宿主环境提供的能力，可以完成许多普通网页无法完成的功能；</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e535c9d832aa42e882b67df899b73cf0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oWI5qeYeWE=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770624503&amp;x-signature=3jDD9hLbvIub1pmIPKMbN915GYU%3D" alt="image-20260130010428829.png" loading="lazy"/></p>
<p><strong>小程序宿主环境包含的内容：</strong> <code>通信模型(了解)、运行机制(了解)、组件、API</code></p>
<h4 data-id="heading-17">通信模型</h4>
<p><strong>小程序中 <code>通信的主体</code> 是渲染层和逻辑层，</strong></p>
<p><strong>其中：</strong> WXML 模板和 WXSS 样式工作在渲染层、JS脚本工作在逻辑层</p>
<p><strong>小程序中的通信模型分为两部分：</strong> 渲染层和逻辑层之间的通信，由微信客户端进行转发；</p>
<p>逻辑层和第三方服务器之间的数据通信，由，微信客户端进行转发；</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e7387e7ce63246598a356cd926286bff~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oWI5qeYeWE=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770624503&amp;x-signature=SuvftzO12JUoGmSVQ1GV9MkyVKk%3D" alt="image-20260130015740435.png" loading="lazy"/></p>
<h4 data-id="heading-18">运行机制</h4>
<p><strong>小程序启动的过程</strong></p>
<pre><code class="hljs language-scss" lang="scss">把小程序的代码包下载到本地
解析 app<span class="hljs-selector-class">.json</span> 全局配置文件
执行 app<span class="hljs-selector-class">.js</span> 小程序入口文件，调用 <span class="hljs-built_in">App</span>() 创建小程序实例
渲染小程序首页
小程序启动完成
</code></pre>
<p><strong>页面渲染的过程</strong></p>
<pre><code class="hljs language-scss" lang="scss">加载解析页面的 <span class="hljs-selector-class">.json</span> 配置文件
加载页面的 <span class="hljs-selector-class">.wxml</span> 模板和 <span class="hljs-selector-class">.wxss</span> 样式
执行页面的 <span class="hljs-selector-class">.js</span> 文件，调用 <span class="hljs-built_in">Page</span>() 创建页面实例
页面渲染完成
</code></pre>
<h4 data-id="heading-19">组件</h4>
<p>小程序中的组件也是由 <strong>宿主环境提供</strong> 的，官方把小程序的组件分为了 <strong>9 大类</strong></p>
<p><code>视图容器、基础内容、表单组件、导航组件、</code> 媒体组件、map 地图组件</p>
<p>canvas 画布组件、开放能力、无障碍访问；</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fcomponent%2Fcover-image.html" target="_blank" title="https://developers.weixin.qq.com/miniprogram/dev/component/cover-image.html" ref="nofollow noopener noreferrer">小程序组件介绍！！！</a></p>
<h5 data-id="heading-20">视图容器：</h5>
<p><strong>view</strong> 普通视图区域，类似于 HTML 中的 div，是一个块级元素，常用来 <code>实现页面的布局效果</code></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/aa277ede91cd4bbd9b5035bf6c735b37~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oWI5qeYeWE=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770624503&amp;x-signature=vhu1ZTZXOaH5uoN2l%2BanD44sulM%3D" alt="PixPin_2026-01-30_13-00-28.gif" loading="lazy"/></p>
<p><strong>scroll-view</strong>  可滚动的视图区域，常用来实现滚动列表效果，如：列表、菜单…………</p>
<p>支持<strong>横向 / 纵向滚动</strong>、滚动到底部 / 顶部触发事件，是实现 “上拉加载更多” 的核心组件</p>
<p><code>scroll-x</code> <code>true</code>/<code>false</code>是否允许横向滚动，<code>scroll-y</code> <code>true</code>/<code>false</code>是否允许纵向滚动；</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ee6c1fb8f4de455ea0b520fbb07c47cf~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oWI5qeYeWE=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770624503&amp;x-signature=0BeZsnRMvhUvZSVlR2opqWJTe9A%3D" alt="PixPin_2026-01-30_13-05-35.gif" loading="lazy"/></p>
<p><strong>swiper 和 swiper-item</strong> 轮播图容器组件 和 轮播图 item 组件；</p>
<p><code>swiper</code>是<strong>轮播图容器</strong>，<code>swiper-item</code>是<strong>轮播项</strong>（必须作为<code>swiper</code>的直接子元素）</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/455df2c49e734d7e9d7466468865c0fb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oWI5qeYeWE=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770624503&amp;x-signature=O07LBUQ4F34jzyVONW1aB5nxSxQ%3D" alt="image-20260130131238374.png" loading="lazy"/></p>
<h5 data-id="heading-21"><strong>基础组件：</strong></h5>
<p><strong>text 文本组件：</strong>  类似于 HTML 中的 span 标签，是一个行内元素；</p>
<p><strong>rich-text 富文本组件：</strong> 支持把 HTML 字符串渲染为 WXML 结构；</p>
<ul>
<li>通过 rich-text 组件的 nodes 属性节点，把 HTML 字符串渲染为对应的 UI 结构；</li>
</ul>
<p><strong>image 图片组件：</strong> image 组件默认宽度约 300px、高度约 240px</p>
<p><strong>button 按钮组件：</strong> 功能比 HTML 中的 button 按钮丰富；type 指定不同类型；</p>
<ul>
<li>通过 open-type 属性可以调用微信提供的各种功能（客服、转发、获取用户授权、获取用户信息等）</li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d337ce35fcf64152b71143ddf1990f09~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oWI5qeYeWE=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770624503&amp;x-signature=dvabN4srSWk9mEUrH3B3rfzekeg%3D" alt="image-20260130132853264.png" loading="lazy"/></p>
<h4 data-id="heading-22">API</h4>
<p>小程序中的 API 是由宿主环境提供的，通过这些丰富的小程序 API，开发者可以方便调用 <strong>微信能力</strong></p>
<p><strong>小程序官方把 API 分为了如下 3 大类：</strong> <code>事件监听API、同步API、异步API</code></p>
<p><strong>事件监听 API：</strong></p>
<ul>
<li>特点：以 on 开头，用来监听某些事件的触发</li>
<li>举例：<code>wx.onWindowResize(function callback)</code> 监听窗口尺寸变化的事件</li>
<li>类似于HTML中的，<code>windows.onclick()</code> 等函数，是组件和用户交互产生处理的操作；</li>
</ul>
<p><strong>同步 API：</strong></p>
<ul>
<li>特点1：以 <code>Sync 结尾的 API</code> 都是同步 API</li>
<li>同步 API 的执行结果，可以通过函数返回值直接获取，</li>
<li>如果执行出错会抛出异常，需用<code>try-catch</code>捕获，适合轻量、无 IO 阻塞的本地操作；</li>
<li>举例：<code>wx.setStorageSync('key', 'value')</code> 向本地存储中写入内容；</li>
<li><code>wx.clearStorageSync</code> 清空本地存储</li>
</ul>
<p><strong>异步 API：复杂能力的 “核心入口”</strong></p>
<ul>
<li>无固定后缀，<strong>异步执行</strong>，需通过<code>success</code>/<code>fail</code>回调、<code>Promise</code> 或<code>async/await</code>获取结果</li>
<li>举例：<code>wx.request()</code> 发起网络数据请求，通过 <code>success 回调函数</code> 接收数据；</li>
<li>类似于 jQuery 中的 <code>$.ajax(options)</code> 函数</li>
</ul>
<h2 data-id="heading-23"><strong>协同工作和发布</strong></h2>
<p>在中大型的公司里，人员的分工非常仔细：</p>
<p>同一个小程序项目，一般会有不同岗位、不同角色的员工同时参与设计与开发</p>
<p>此时出于管理需要，我们 <strong>迫切需要对</strong> 不同岗位、不同角色的 <strong>员工的权限进行边界的划分</strong></p>
<h3 data-id="heading-24"><strong>小程序成员管理</strong></h3>
<p><strong>小程序成员管理体现在<code>管理员</code>对小程序<code>项目成员</code>及<code>体验成员</code>的管理：</strong> 在添加成员时候可以进行分配；</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fe1825a6f3d3457cba2cafcade00ab00~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oWI5qeYeWE=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770624503&amp;x-signature=T0vRqomzWHm986qW8K%2BC%2F42J1M0%3D" alt="image-20260130142141197.png" loading="lazy"/></p>
<p>微信小程序后台的角色体系是 <strong>分级管控</strong> 的，不同角色对应不同的操作权限</p>
<p>核心分为<code>「管理员」</code> <code>「项目成员（运营者 / 开发者 / 数据分析者）」</code> <code>「体验者」</code>三大类；</p>
<p><strong>管理员 最高权限（超级管理员）全平台操作</strong></p>

























<table><thead><tr><th><strong>角色核心</strong></th><th><strong>权限等级</strong></th><th><strong>操作范围</strong></th></tr></thead><tbody><tr><td><strong>运营者</strong></td><td>运营级权限</td><td>提交审核、版本发布（需管理员授权）<br/>用户反馈处理、模板消息配置<br/>推广设置、小程序码生成</td></tr><tr><td><strong>开发者</strong></td><td>开发级权限</td><td>代码上传、版本管理、开发设置（域名 / 服务器配置）<br/>云开发管理、接口权限配置，体验版管理、开发者工具绑定</td></tr><tr><td><strong>数据分析者</strong></td><td>只读权限</td><td>仅数据查看操作，包括：用户访问统计、行为分析<br/>交易数据、留存率等核心指标，无任何修改 / 配置权限</td></tr></tbody></table>
<p><strong>体验者</strong> 最低权限（仅体验）仅能扫码体验「体验版」小程序，无任何后台操作权限</p>
<h3 data-id="heading-25"><strong>小程序的版本</strong></h3>
<p><strong>软件开发过程中，根据时间节点的不同，会产出不同的软件版本，例如</strong></p>





















<table><thead><tr><th>开发版本</th><th>使用开发者工具，可将代码上传到开发版本中。  <br/>开发版本只保留每人最新的一份上传的代码  点击提交审核，<br/>可将代码提交审核。开发版本可删除，不影响线上版本和审核中版本的代码。</th></tr></thead><tbody><tr><td>体验版本</td><td>可以选择某个开发版本作为体验版，并且选取一份体验版。</td></tr><tr><td>审核中的版本</td><td>只能有一份代码处于审核中。<br/>有审核结果后可以发布到线上，也可直接重新提交审核，覆盖原审核版本</td></tr><tr><td>线上版本</td><td>线上所有用户使用的代码版本，该版本代码在新版本代码发布后被覆盖更新</td></tr></tbody></table>
<p>一个小程序的发布上线，一般要经过 <code>上传代码 -&gt; 提交审核 -&gt; 发布</code> 这三个步骤</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0d158a94c11d4ba3a2a4bd718ece6e15~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oWI5qeYeWE=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770624503&amp;x-signature=hX%2Bx3gCpZ0T%2FCXEg%2BXnACFpr5Yo%3D" alt="PixPin_2026-01-30_14-29-44.gif" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b09f66f9cc9144738e457b4a03f35d6f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oWI5qeYeWE=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770624503&amp;x-signature=3XecpW88PQXcIA%2FR0qCCxJ6vnng%3D" alt="image-20260130143024732.png" loading="lazy"/></p>
<p><strong>登录小程序管理后台 -&gt; 管理 -&gt; 版本管理 -&gt; 开发版本，即可查看刚才提交上传的版本了：</strong></p>
<p><strong>选择版本，提交申请：</strong> 第一次提交需要小程序进行备案，此处个人学习就不展示了；</p>
<p><strong>审核通过之后，管理员的微信中会收到小程序通过审核的通知，</strong></p>
<ul>
<li>此时在审核版本的列表中，点击 <code>发布</code> 按钮之后，</li>
<li>即可把“审核通过”的版本发布为<code>线上版本</code></li>
<li>供所有小程序用户访问和使用</li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/56c6efa7ce5344fdb9115e3ffb328130~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oWI5qeYeWE=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770624503&amp;x-signature=AQOyeIp3brwcTxCz31qzLpT98ls%3D" alt="image-20260130143208905-1769756686277.png" loading="lazy"/></p>
<h3 data-id="heading-26">推广码：</h3>
<p><strong>发布上线之后，可以，选择设置打印出小程序推广码：</strong></p>
<p>登录小程序管理后台 -&gt; 设置 -&gt; 基本设置 -&gt; 基本信息 -&gt; 小程序码及线下物料下载；</p>
<p><strong>小程序运营数据</strong></p>
<ul>
<li>
<p><strong>方式一：</strong> 在<code>小程序后台</code> 查看，登录小程序管理后台，</p>
<p>点击侧边栏的“统计”点击相应的 tab 可以看到相关的数据</p>
</li>
<li>
<p><strong>方式二：</strong>  搜索 <code>小程序数据助手</code> ，查看已发布的小程序相关的数据；</p>
</li>
</ul>
<h2 data-id="heading-27">相关文档：</h2>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1834y1676P%3Fspm_id_from%3D333.788.videopod.episodes%26vd_source%3D19e007a1660dfd5c8f1744e56d027bf4%26p%3D2" target="_blank" title="https://www.bilibili.com/video/BV1834y1676P?spm_id_from=333.788.videopod.episodes&amp;vd_source=19e007a1660dfd5c8f1744e56d027bf4&amp;p=2" ref="nofollow noopener noreferrer">黑马—小程序简介_哔哩哔哩_bilibili</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fm0_64875238%2Farticle%2Fdetails%2F127796691%3Fops_request_misc%3Delastic_search_misc%26request_id%3D4c6789a9299d3347e64d6c17839bce60%26biz_id%3D0%26utm_medium%3Ddistribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-127796691-null-null.142%255Ev102%255Epc_search_result_base8%26utm_term%3D%25E5%25BE%25AE%25E4%25BF%25A1%25E5%25B0%258F%25E7%25A8%258B%25E5%25BA%258F%26spm%3D1018.2226.3001.4187" target="_blank" title="https://blog.csdn.net/m0_64875238/article/details/127796691?ops_request_misc=elastic_search_misc&amp;request_id=4c6789a9299d3347e64d6c17839bce60&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-127796691-null-null.142%5Ev102%5Epc_search_result_base8&amp;utm_term=%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F&amp;spm=1018.2226.3001.4187" ref="nofollow noopener noreferrer">微信小程序开发（超详细保姆式教程）-CSDN博客</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fweixin_53812239%2Farticle%2Fdetails%2F139720191%3Fops_request_misc%3Delastic_search_misc%26request_id%3Dc1a5e738633bd1e7da34a5b28a8351d0%26biz_id%3D0%26utm_medium%3Ddistribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-139720191-null-null.142%255Ev102%255Epc_search_result_base8%26utm_term%3D%25E5%25B0%258F%25E7%25A8%258B%25E5%25BA%258F%25E6%25B5%258B%25E8%25AF%2595%25E5%258F%25B7%25E5%25A6%2582%25E4%25BD%2595%25E6%25B3%25A8%25E9%2594%2580%26spm%3D1018.2226.3001.4187" target="_blank" title="https://blog.csdn.net/weixin_53812239/article/details/139720191?ops_request_misc=elastic_search_misc&amp;request_id=c1a5e738633bd1e7da34a5b28a8351d0&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-139720191-null-null.142%5Ev102%5Epc_search_result_base8&amp;utm_term=%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B5%8B%E8%AF%95%E5%8F%B7%E5%A6%82%E4%BD%95%E6%B3%A8%E9%94%80&amp;spm=1018.2226.3001.4187" ref="nofollow noopener noreferrer">关于小程序测试账号如何移除_小程序测试号怎么删除-CSDN博客</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fweixin_43474701%2Farticle%2Fdetails%2F122213203%3Fops_request_misc%3Delastic_search_misc%26request_id%3Dc1a5e738633bd1e7da34a5b28a8351d0%26biz_id%3D0%26utm_medium%3Ddistribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-122213203-null-null.142%255Ev102%255Epc_search_result_base8%26utm_term%3D%25E5%25B0%258F%25E7%25A8%258B%25E5%25BA%258F%25E6%25B5%258B%25E8%25AF%2595%25E5%258F%25B7%25E5%25A6%2582%25E4%25BD%2595%25E6%25B3%25A8%25E9%2594%2580%26spm%3D1018.2226.3001.4187" target="_blank" title="https://blog.csdn.net/weixin_43474701/article/details/122213203?ops_request_misc=elastic_search_misc&amp;request_id=c1a5e738633bd1e7da34a5b28a8351d0&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-122213203-null-null.142%5Ev102%5Epc_search_result_base8&amp;utm_term=%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B5%8B%E8%AF%95%E5%8F%B7%E5%A6%82%E4%BD%95%E6%B3%A8%E9%94%80&amp;spm=1018.2226.3001.4187" ref="nofollow noopener noreferrer">微信注销时没有解除小程序运营者身份而不让注销：解除接口测试号_微信注销提示小程序接口-CSDN博客</a></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Flutter-实现Tabs吸顶的PageView效果]]></title>    <link>https://juejin.cn/post/7601728622824095787</link>    <guid>https://juejin.cn/post/7601728622824095787</guid>    <pubDate>2026-02-02T02:51:02.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7601728622824095787" data-draft-id="7601464318410014762" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Flutter-实现Tabs吸顶的PageView效果"/> <meta itemprop="keywords" content="前端,Flutter,Android"/> <meta itemprop="datePublished" content="2026-02-02T02:51:02.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="鹏多多"/> <meta itemprop="url" content="https://juejin.cn/user/747323639737191"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Flutter-实现Tabs吸顶的PageView效果
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/747323639737191/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    鹏多多
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-02T02:51:02.000Z" title="Mon Feb 02 2026 02:51:02 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-02
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:2;font-weight:400;font-size:15px;overflow-x:hidden;color:#333;letter-spacing:1.2px}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1:first-child,.markdown-body h2:first-child,.markdown-body h3:first-child,.markdown-body h4:first-child,.markdown-body h5:first-child,.markdown-body h6:first-child{margin-top:-1.5rem;margin-bottom:1rem}.markdown-body h1:before,.markdown-body h2:before,.markdown-body h3:before,.markdown-body h4:before,.markdown-body h5:before,.markdown-body h6:before{content:"#";display:inline-block;color:#3eaf7c;padding-right:.23em}.markdown-body h1{position:relative;font-size:2.5rem;margin-bottom:5px}.markdown-body h1:before{font-size:2.5rem}.markdown-body h2{padding-bottom:.5rem;font-size:2.2rem;border-bottom:1px solid #ececec}.markdown-body h3{font-size:1.5rem;padding-bottom:0}.markdown-body h4{font-size:1.25rem}.markdown-body h5{font-size:1rem}.markdown-body h6{margin-top:5px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body strong{color:#3eaf7c}.markdown-body img{max-width:100%;border-radius:2px;display:block;margin:auto}.markdown-body hr{border:none;border-top:1px solid #3eaf7c;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;overflow-x:auto;padding:.2rem .5rem;margin:0;color:#3eaf7c;font-size:.85em;background-color:rgba(27,31,35,.05);border-radius:3px}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75;border:.5rem solid #3eaf7c}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{font-weight:500;text-decoration:none;color:#3eaf7c;margin:0 5px}.markdown-body a:active,.markdown-body a:hover{text-decoration:none;border-bottom:1.5px solid #3eaf7c}.markdown-body a[href^=http]:after{content:url("data:image/svg+xml;base64,PHN2ZyBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB3aWR0aD0iMTQiIGhlaWdodD0iMTQiPjxkZWZzPjxzdHlsZS8+PC9kZWZzPjxwYXRoIGQ9Ik04MzIgMTI4SDY0MHY2NGgxNDYuNzUyTDUyMS4zNzYgNDU3LjM3Nmw0NS4yNDggNDUuMjQ4TDgzMiAyMzcuMjQ4VjM4NGg2NFYxMjh6IiBmaWxsPSIjM2VhZjdjIi8+PHBhdGggZD0iTTc2OCA4MzJIMTkyVjI1NmgzNTJ2LTY0SDE2MGEzMiAzMiAwIDAwLTMyIDMydjY0MGEzMiAzMiAwIDAwMzIgMzJoNjQwYTMyIDMyIDAgMDAzMi0zMlY0ODBoLTY0djM1MnoiIGZpbGw9IiMzZWFmN2MiLz48L3N2Zz4=");margin-left:2px}.markdown-body a[href^="#"]:before{content:"#"}.markdown-body table{display:inline-block!important;font-size:13px;width:auto;max-width:100%;overflow:auto;border:1px solid #3eaf7c;border-collapse:collapse}.markdown-body thead{background:#3eaf7c;color:#fff;text-align:left}.markdown-body tr:nth-child(2n){background-color:rgba(153,255,188,.1)}.markdown-body td,.markdown-body th{padding:4px 8px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#7b7878;padding:1px 23px;border-left:.5rem solid;border-color:#42b983;background-color:rgba(66,184,131,.1);position:relative;margin:14px 8px 0}.markdown-body blockquote:before{display:inline-block;position:absolute;content:url("data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjUiIGhlaWdodD0iMjUiIHZpZXdCb3g9IjAgMCAyNyAyNyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxLjg2MiAxLjg2MikiIGZpbGwtcnVsZT0ibm9uemVybyIgZmlsbD0ibm9uZSI+PGNpcmNsZSBzdHJva2U9IiNGRkYiIHN0cm9rZS13aWR0aD0iMS43MjQiIGZpbGw9IiM0MkI5ODMiIGN4PSIxMS42MzgiIGN5PSIxMS42MzgiIHI9IjExLjYzOCIvPjxwYXRoIGQ9Ik0xNC45NzggNi4yN0E1LjAwNiA1LjAwNiAwIDAwNi42NyA5LjQ2OGE0LjkwMSA0LjkwMSAwIDAwMS43NzMgNC4zNjJjLjMyMy4yNTguNTE0LjY0Ny41MjIgMS4wNnYxLjA2YTIuNjg1IDIuNjg1IDAgMDA1LjM3IDB2LTEuMDA4Yy4wMDItLjM5OC4xNzMtLjc3Ny40Ny0xLjA0MmE1LjAyMyA1LjAyMyAwIDAwLjE3My03LjYzem0tMy4zMzcgMTAuOTY3YTEuMzA0IDEuMzA0IDAgMDEtMS4yODYtMS4yODd2LS4yNzhoMi41NzJ2LjI2MWMwIC43MTMtLjU3MyAxLjI5NC0xLjI4NiAxLjMwNHptMi4yNi00LjQxNWMtLjQ0LjM4My0uNzUuODkzLS44ODcgMS40NmgtMi43NDZhMi44NjggMi44NjggMCAwMC0uOTM4LTEuNTNoLS4wMThhMy40NzYgMy40NzYgMCAwMS0xLjI2OS0zLjE0NSAzLjYxNSAzLjYxNSAwIDAxNy4xOTYuNCAzLjY1IDMuNjUgMCAwMS0xLjMzOCAyLjgxNXoiIGZpbGw9IiNGRkYiLz48L2c+PC9zdmc+");width:25px;height:25px;left:-16px;top:12px}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body details{outline:none;border:none;border-left:4px solid #3eaf7c;padding-left:10px;margin-left:4px}.markdown-body details summary{cursor:pointer;border:none;outline:none;background:#fff;margin:0 -17px}.markdown-body details summary::-webkit-details-marker{color:#3eaf7c}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body ol li::marker{color:#3eaf7c}.markdown-body ul li{list-style:none;padding-left:10px}.markdown-body ul li::marker{content:"•";color:#3eaf7c}.markdown-body ul li.task-list-item:before{content:"";margin-right:0}.markdown-body input[type=checkbox]{vertical-align:text-bottom;box-shadow:inset 0 0 0 10px #fff}.markdown-body input[type=checkbox]:before{content:url("data:image/svg+xml;base64,PHN2ZyBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB3aWR0aD0iMTYiIGhlaWdodD0iMTYiPjxkZWZzPjxzdHlsZS8+PC9kZWZzPjxwYXRoIGQ9Ik04NzcuMDU2IDE0Ni45NDR2NzMwLjExMkgxNDYuOTQ0VjE0Ni45NDRoNzMwLjExMnptMC0xMDQuMjc3SDE0Ni45NDRjLTU3LjYyOCAwLTEwNC4yNzcgNDYuNjQ5LTEwNC4yNzcgMTA0LjI3N3Y3MzAuMTEyYzAgNTcuNjI4IDQ2LjY0OSAxMDQuMjc3IDEwNC4yNzcgMTA0LjI3N2g3MzAuMTEyYzU3LjYyOCAwIDEwNC4yNzctNDYuNjQ5IDEwNC4yNzctMTA0LjI3N1YxNDYuOTQ0YzAtNTcuNjI4LTQ2LjY0OS0xMDQuMjc3LTEwNC4yNzctMTA0LjI3N3oiIGZpbGw9IiMzZWFmN2MiLz48L3N2Zz4=");position:relative;top:-2px;right:2px}.markdown-body input[type=checkbox]:checked:before{content:url("data:image/svg+xml;base64,PHN2ZyBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB3aWR0aD0iMTUiIGhlaWdodD0iMTUiPjxkZWZzPjxzdHlsZS8+PC9kZWZzPjxwYXRoIGQ9Ik05MTAuMjA4IDBIMTEzLjc2QTExNC4xMTIgMTE0LjExMiAwIDAwLS4wMzIgMTEzLjc5MlY5MTAuMjRjMCA2Mi41OTIgNTEuMiAxMTMuNzkyIDExMy43OTIgMTEzLjc5Mmg3OTYuNDQ4YzYyLjU5MiAwIDExMy43OTItNTEuMiAxMTMuNzkyLTExMy43OTJWMTEzLjc5MkMxMDI0IDUxLjIgOTcyLjggMCA5MTAuMjA4IDB6bS01MTIgNzk2LjQ0OEwxMTMuNzYgNTEybDc5LjY0OC03OS42NDggMjA0LjggMjA0LjhMODMwLjU2IDIwNC44bDc5LjY0OCA3OS42NDgtNTEyIDUxMnoiIGZpbGw9IiMzZWFmN2MiLz48L3N2Zz4=");position:relative;top:-2px;right:2px}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="agate">.markdown-body pre,.markdown-body pre&gt;code.hljs{background:#333;color:#fff}.hljs-name,.hljs-strong{font-weight:700}.hljs-code,.hljs-emphasis{font-style:italic}.hljs-tag{color:#62c8f3}.hljs-selector-class,.hljs-selector-id,.hljs-template-variable,.hljs-variable{color:#ade5fc}.hljs-bullet,.hljs-string{color:#a2fca2}.hljs-attribute,.hljs-built_in,.hljs-builtin-name,.hljs-quote,.hljs-section,.hljs-title,.hljs-type{color:#ffa}.hljs-bullet,.hljs-number,.hljs-symbol{color:#d36363}.hljs-keyword,.hljs-literal,.hljs-selector-tag{color:#fcc28c}.hljs-code,.hljs-comment,.hljs-deletion{color:#888}.hljs-link,.hljs-regexp{color:#c6b4f0}.hljs-meta{color:#fc9b9b}.hljs-deletion{background-color:#fc9b9b;color:#333}.hljs-addition{background-color:#a2fca2;color:#333}.hljs a{color:inherit}.hljs a:focus,.hljs a:hover{color:inherit;text-decoration:underline}</style><h2 data-id="heading-0">1. 效果预览</h2>
<p>在 Flutter 开发中，创建具有吸顶 Tabs 的 PageView 效果可以极大地提升用户界面的交互性和用户体验。今天，我们就通过一段具体的代码来深入了解如何实现这一功能。效果预览如下：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6e668bebeb3147a293aa730227c4e2dc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6bmP5aSa5aSa:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770605462&amp;x-signature=o%2FXaSEucD7rt17hi5dJSe3f%2BxEw%3D" alt="预览图" loading="lazy"/></p>
<h2 data-id="heading-1">2. 结构分析</h2>
<p>我们从整体上看这段代码，它定义了一个名为CeilingTabsPageView的有状态组件。这个组件的作用就是构建出一个带有吸顶 Tabs 的页面，用户可以通过滑动 PageView 在不同的页面内容间切换。</p>
<ol>
<li>引入必要的库</li>
</ol>
<pre><code class="hljs language-dart" lang="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">'package:extended_nested_scroll_view/extended_nested_scroll_view.dart'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'package:flutter/material.dart'</span>;
</code></pre>
<p>代码开头引入了两个重要的库。</p>
<ul>
<li>
<p>package:flutter/material.dart：Flutter 的核心 UI库，它提供了各种构建用户界面的基本组件和工具，比如我们后续会用到的Container、Row、Text等。</p>
</li>
<li>
<p>package:extended_nested_scroll_view/extended_nested_scroll_view.dart：为我们实现吸顶效果提供了关键支持，ExtendedNestedScrollView这个特殊的组件就来自于它。</p>
</li>
</ul>
<ol start="2">
<li>定义CeilingTabsPageView组件</li>
</ol>
<pre><code class="hljs language-dart" lang="dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CeilingTabsPageView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>{
  <span class="hljs-keyword">const</span> CeilingTabsPageView({Key? key}) : <span class="hljs-keyword">super</span>(key: key);

  <span class="hljs-meta">@override</span>
  State&lt;CeilingTabsPageView&gt; createState() =&gt; CeilingTabsPageViewState();
}
</code></pre>
<p>这里定义了CeilingTabsPageView组件，它是一个有状态的组件。有状态组件意味着它在运行过程中可以根据用户操作或者其他事件改变自身状态。而createState方法返回了CeilingTabsPageViewState实例，这个实例负责管理组件的状态和构建具体的 UI。</p>
<ol start="3">
<li>CeilingTabsPageViewState类的详细解析</li>
</ol>
<pre><code class="hljs language-dart" lang="dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CeilingTabsPageViewState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">CeilingTabsPageView</span>&gt; </span>{
<span class="hljs-comment">/// <span class="markdown">控制器</span></span>
<span class="hljs-keyword">late</span> PageController _pageController;

<span class="hljs-built_in">int</span> pageIndex = <span class="hljs-number">0</span>;

 <span class="hljs-comment">/// <span class="markdown">字体样式</span></span>
TextStyle myTextStyle = <span class="hljs-keyword">const</span> TextStyle(
      color: Colors.white, fontWeight: FontWeight.w600, fontSize: <span class="hljs-number">20</span>);

  <span class="hljs-comment">/// <span class="markdown">生命周期</span></span>
  <span class="hljs-meta">@override</span>
  <span class="hljs-keyword">void</span> initState() {
    <span class="hljs-keyword">super</span>.initState();
    _pageController = PageController(initialPage: pageIndex);
  }

 <span class="hljs-comment">/// <span class="markdown">页面滑动回调</span></span>
  <span class="hljs-keyword">void</span> handlePageChange(<span class="hljs-built_in">int</span> index) {
    setState(() {
      pageIndex = index;
    });
  }
 
<span class="hljs-comment">/// <span class="markdown">Tabs点击</span></span>
  <span class="hljs-keyword">void</span> handleTabClick(<span class="hljs-built_in">int</span> index) {
    setState(() {
      pageIndex = index;
      _pageController.jumpToPage(index); <span class="hljs-comment">// 直接跳转至指定页面</span>
    });
  }
</code></pre>
<ul>
<li>生命周期方法：initState方法在组件首次插入到 Widget 树时调用，在这里我们只是简单地调用了父类的initState方法，暂时没有额外的初始化操作，但它为我们后续可能需要的初始化工作提供了位置。</li>
<li>状态变量：pageIndex用于记录当前 PageView 显示的页面索引，初始值为 0，表示默认显示第一个页面。</li>
<li>控制器：_pageController是PageView的控制器</li>
<li>字体样式定义：myTextStyle定义了一种字体样式，包括白色字体颜色、中等加粗的字重和 20 的字体大小，后续在多个文本组件中会使用到这个样式。</li>
<li>页面滑动回调函数：当 PageView 发生滑动时，handlePageChange函数会被调用。它通过setState方法来更新pageIndex的值，setState方法会触发组件的重新构建，从而确保 UI 能够反映出页面索引的变化。</li>
<li>Tabs点击：点击Tabs的回调函数</li>
</ul>
<ol start="4">
<li>构建 UI 的核心方法</li>
</ol>
<pre><code class="hljs language-dart" lang="dart"><span class="hljs-meta">@override</span>
Widget build(BuildContext context) {
  <span class="hljs-comment">/// <span class="markdown">最大宽度</span></span>
  <span class="hljs-built_in">double</span> maxW = MediaQuery.of(context).size.width;

  <span class="hljs-comment">/// <span class="markdown">最大高度</span></span>
  <span class="hljs-built_in">double</span> maxH = MediaQuery.of(context).size.height;

  <span class="hljs-keyword">return</span> SizedBox(
    width: maxW,
    height: maxH,
    child: ExtendedNestedScrollView(
        headerSliverBuilder: (BuildContext context, <span class="hljs-built_in">bool</span> innerBoxIsScrolled) {
          <span class="hljs-keyword">return</span> [
            SliverToBoxAdapter(
                child: Column(
                    crossAxisAlignment: CrossAxisAlignment.center,
                    children: [bannerWidget(maxW), tabsWidget(maxW)]))
          ];
        },
        <span class="hljs-comment">// 需要固定吸顶的高度</span>
        pinnedHeaderSliverHeightBuilder: () {
          <span class="hljs-keyword">return</span> <span class="hljs-number">40</span>;
        },
        onlyOneScrollInBody: <span class="hljs-keyword">true</span>,
        body: SizedBox(
          width: maxW,
          height: maxH,
          child: pageViewWidget(maxW, maxH),
        )),
  );
}
</code></pre>
<ul>
<li>获取屏幕尺寸：通过MediaQuery.of(context).size.width和MediaQuery.of(context).size.height获取当前设备屏幕的宽度maxW和高度maxH，这两个值对于构建适配不同屏幕尺寸的 UI 非常重要。</li>
<li>使用ExtendedNestedScrollView：这是实现吸顶效果的关键组件。</li>
<li>headerSliverBuilder：这个回调函数用于构建顶部的内容。它返回一个包含SliverToBoxAdapter的列表，SliverToBoxAdapter又包含了一个Column，Column中依次排列着bannerWidget和tabsWidget。这就定义了顶部的布局结构，先显示一个 Banner，再显示 Tabs。</li>
<li>pinnedHeaderSliverHeightBuilder：这个回调函数指定了需要固定吸顶的高度为 40。也就是说，tabsWidget部分会在用户滚动页面时固定在顶部，不会随着页面内容一起滚动。</li>
<li>onlyOneScrollInBody：设置为true表示在页面主体部分只允许一个滚动行为，避免了滚动冲突。
body：这里设置页面的主体内容为pageViewWidget，也就是我们的 PageView 部分。</li>
</ul>
<ol start="5">
<li>各个部件的构建方法</li>
</ol>
<p><strong>bannerWidget</strong></p>
<pre><code class="hljs language-dart" lang="dart">Widget bannerWidget(<span class="hljs-built_in">double</span> maxW) {
  <span class="hljs-keyword">return</span> Container(
      width: maxW,
      height: <span class="hljs-number">200</span>,
      alignment: Alignment.center,
      color: Colors.red.shade300,
      child: Text(<span class="hljs-string">'Banner'</span>, style: myTextStyle));
}
</code></pre>
<p>这个方法构建了一个Container作为 Banner。它的宽度为屏幕宽度maxW，高度为 200，背景颜色为浅红色（Colors.red.shade300），并且在容器中心显示了 “Banner” 字样，使用之前定义好的myTextStyle字体样式。</p>
<p><strong>tabsWidget</strong></p>
<pre><code class="hljs language-dart" lang="dart">Widget tabsWidget(<span class="hljs-built_in">double</span> maxW) {
  <span class="hljs-keyword">return</span> Container(
    width: maxW,
    height: <span class="hljs-number">40</span>,
    color: Colors.blue.shade400,
    child: Row(
      children: [
        Expanded(
            child: GestureDetector(
              onTap: () {
                handleTabClick(<span class="hljs-number">0</span>);
              },
              child: Container(
                alignment: Alignment.center,
                child: Text(<span class="hljs-string">'Tab 1'</span>, style: myTextStyle),
              ),
            ),
          ),
          Expanded(
            child: GestureDetector(
              onTap: () {
                handleTabClick(<span class="hljs-number">1</span>);
              },
              child: Container(
                alignment: Alignment.center,
                child: Text(<span class="hljs-string">'Tab 2'</span>, style: myTextStyle),
              ),
            ),
          )
      ],
    ),
  );
}
</code></pre>
<p>tabsWidget构建了 Tabs 部分。同样是一个宽度为屏幕宽度maxW、高度为 40 的Container，背景颜色为浅蓝色（Colors.blue.shade400）。在这个容器内部，通过Row布局将空间分为两部分，每部分都包含一个Expanded包裹的Container，分别显示 “Tab 1” 和 “Tab 2”，同样使用myTextStyle字体样式。Expanded组件的作用是让两个 Tab 平分容器的宽度。并且添加了GestureDetector来处理点击事件。</p>
<p><strong>pageViewWidget</strong></p>
<pre><code class="hljs language-dart" lang="dart">Widget pageViewWidget(<span class="hljs-built_in">double</span> maxW, <span class="hljs-built_in">double</span> maxH) {
  <span class="hljs-keyword">return</span> SingleChildScrollView(
      primary: <span class="hljs-keyword">true</span>,
      physics: <span class="hljs-keyword">const</span> BouncingScrollPhysics(),
      child: SizedBox(
        width: maxW,
        height: maxH,
        child: PageView(
        controller: _pageController,
            onPageChanged: (index) {
              setState(() {
                pageIndex = index;
              });
            },
          children: [
            Container(
                width: maxW,
                height: <span class="hljs-number">1000</span>,
                color: Colors.amberAccent,
                alignment: Alignment.topCenter,
                child: Text(<span class="hljs-string">'Page1'</span>, style: myTextStyle)),
            Container(
                width: maxW,
                height: <span class="hljs-number">1000</span>,
                color: Colors.deepPurpleAccent,
                alignment: Alignment.topCenter,
                child: Text(<span class="hljs-string">'Page2'</span>, style: myTextStyle))
          ],
        ),
      ));
}
</code></pre>
<p>pageViewWidget构建了 PageView。它被包裹在SingleChildScrollView中，设置primary为true表示这是主要的滚动视图，physics设置为BouncingScrollPhysics以实现类似于 iOS 的弹性滚动效果。在SizedBox内部是一个PageView，包含两个页面，每个页面都是一个宽度为屏幕宽度maxW、高度为 1000 的Container，分别显示 “Page1” 和 “Page2”，背景颜色也各不相同，同样使用myTextStyle字体样式。并且把控制器绑定上，添加了onPageChanged回调事件。</p>
<h2 data-id="heading-2">3. 完整代码</h2>
<ul>
<li>main.dart</li>
</ul>
<pre><code class="hljs language-dart" lang="dart"><span class="hljs-keyword">const</span> CeilingTabsPageView()
</code></pre>
<ul>
<li>ceilingTabsPageView.dart</li>
</ul>
<pre><code class="hljs language-dart" lang="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">'package:extended_nested_scroll_view/extended_nested_scroll_view.dart'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'package:flutter/material.dart'</span>;

<span class="hljs-comment">/// <span class="markdown">吸顶Tabs的PageView</span></span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CeilingTabsPageView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>{
  <span class="hljs-keyword">const</span> CeilingTabsPageView({Key? key}) : <span class="hljs-keyword">super</span>(key: key);

  <span class="hljs-meta">@override</span>
  State&lt;CeilingTabsPageView&gt; createState() =&gt; CeilingTabsPageViewState();
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CeilingTabsPageViewState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">CeilingTabsPageView</span>&gt; </span>{
  <span class="hljs-keyword">late</span> PageController _pageController;

  <span class="hljs-built_in">int</span> pageIndex = <span class="hljs-number">0</span>;

  <span class="hljs-comment">/// <span class="markdown">字体样式</span></span>
  TextStyle myTextStyle = <span class="hljs-keyword">const</span> TextStyle(
      color: Colors.white, fontWeight: FontWeight.w600, fontSize: <span class="hljs-number">20</span>);

  <span class="hljs-comment">/// <span class="markdown">生命周期</span></span>
  <span class="hljs-meta">@override</span>
  <span class="hljs-keyword">void</span> initState() {
    <span class="hljs-keyword">super</span>.initState();
    _pageController = PageController(initialPage: pageIndex);
  }

  <span class="hljs-comment">/// <span class="markdown">页面滑动回调</span></span>
  <span class="hljs-keyword">void</span> handlePageChange(<span class="hljs-built_in">int</span> index) {
    setState(() {
      pageIndex = index;
    });
  }

  <span class="hljs-comment">/// <span class="markdown">Tabs点击</span></span>
  <span class="hljs-keyword">void</span> handleTabClick(<span class="hljs-built_in">int</span> index) {
    setState(() {
      pageIndex = index;
      _pageController.jumpToPage(index); <span class="hljs-comment">// 直接跳转至指定页面</span>
    });
  }

  <span class="hljs-comment">/// <span class="markdown">构建UI</span></span>
  <span class="hljs-meta">@override</span>
  Widget build(BuildContext context) {
    <span class="hljs-comment">/// <span class="markdown">最大宽度</span></span>
    <span class="hljs-built_in">double</span> maxW = MediaQuery.of(context).size.width;

    <span class="hljs-comment">/// <span class="markdown">最大高度</span></span>
    <span class="hljs-built_in">double</span> maxH = MediaQuery.of(context).size.height;

    <span class="hljs-keyword">return</span> SizedBox(
      width: maxW,
      height: maxH,
      child: ExtendedNestedScrollView(
          headerSliverBuilder: (BuildContext context, <span class="hljs-built_in">bool</span> innerBoxIsScrolled) {
            <span class="hljs-keyword">return</span> [
              SliverToBoxAdapter(
                  child: Column(
                      crossAxisAlignment: CrossAxisAlignment.center,
                      children: [bannerWidget(maxW), tabsWidget(maxW)]))
            ];
          },
          <span class="hljs-comment">// 需要固定吸顶的高度</span>
          pinnedHeaderSliverHeightBuilder: () {
            <span class="hljs-keyword">return</span> <span class="hljs-number">40</span>;
          },
          onlyOneScrollInBody: <span class="hljs-keyword">true</span>,
          body: SizedBox(
            width: maxW,
            height: maxH,
            child: pageViewWidget(maxW, maxH),
          )),
    );
  }

  <span class="hljs-comment">/// <span class="markdown">Banner部件</span></span>
  Widget bannerWidget(<span class="hljs-built_in">double</span> maxW) {
    <span class="hljs-keyword">return</span> Container(
        width: maxW,
        height: <span class="hljs-number">200</span>,
        alignment: Alignment.center,
        color: Colors.red.shade300,
        child: Text(<span class="hljs-string">'Banner'</span>, style: myTextStyle));
  }

  <span class="hljs-comment">/// <span class="markdown">Tabs部件</span></span>
  Widget tabsWidget(<span class="hljs-built_in">double</span> maxW) {
    <span class="hljs-keyword">return</span> Container(
      width: maxW,
      height: <span class="hljs-number">40</span>,
      color: Colors.blue.shade400,
      child: Row(
        children: [
          Expanded(
            child: GestureDetector(
              onTap: () {
                handleTabClick(<span class="hljs-number">0</span>);
              },
              child: Container(
                alignment: Alignment.center,
                child: Text(<span class="hljs-string">'Tab 1'</span>, style: myTextStyle),
              ),
            ),
          ),
          Expanded(
            child: GestureDetector(
              onTap: () {
                handleTabClick(<span class="hljs-number">1</span>);
              },
              child: Container(
                alignment: Alignment.center,
                child: Text(<span class="hljs-string">'Tab 2'</span>, style: myTextStyle),
              ),
            ),
          )
        ],
      ),
    );
  }

  <span class="hljs-comment">/// <span class="markdown">pageView部件</span></span>
  Widget pageViewWidget(<span class="hljs-built_in">double</span> maxW, <span class="hljs-built_in">double</span> maxH) {
    <span class="hljs-keyword">return</span> SingleChildScrollView(
        primary: <span class="hljs-keyword">true</span>,
        physics: <span class="hljs-keyword">const</span> BouncingScrollPhysics(),
        child: SizedBox(
          width: maxW,
          height: maxH,
          child: PageView(
            controller: _pageController,
            onPageChanged: (index) {
              setState(() {
                pageIndex = index;
              });
            },
            children: [
              Container(
                  width: maxW,
                  height: <span class="hljs-number">1000</span>,
                  color: Colors.amberAccent,
                  alignment: Alignment.topCenter,
                  child: Text(<span class="hljs-string">'Page1'</span>, style: myTextStyle)),
              Container(
                  width: maxW,
                  height: <span class="hljs-number">1000</span>,
                  color: Colors.deepPurpleAccent,
                  alignment: Alignment.topCenter,
                  child: Text(<span class="hljs-string">'Page2'</span>, style: myTextStyle))
            ],
          ),
        ));
  }
}
</code></pre>
<h2 data-id="heading-3">4. 总结</h2>
<p>通过这段代码，我们成功地在 Flutter 中实现了一个具有吸顶 Tabs 的 PageView 效果。从引入必要的库，到定义组件和管理状态，再到构建具体的 UI 部件，每一步都紧密配合。ExtendedNestedScrollView组件的使用是实现吸顶效果的核心，而各个部件的合理布局和样式设置则让整个页面看起来更加美观和易于交互。</p>
<p>希望这篇文章能帮助你理解并在自己的 Flutter 项目中运用类似的功能。</p>
<hr/>
<blockquote>
<p>本次分享就到这儿啦，我是鹏多多，深耕前端的技术创作者，如果您看了觉得有帮助，欢迎评论，关注，点赞，转发，我们下次见~</p>
</blockquote>
<p>PS：在本页按F12，在console中输入document.getElementsByClassName('panel-btn')[0].click();有惊喜哦~</p>
<p><code>往期文章</code></p>
<ul>
<li><a href="https://juejin.cn/post/7583910637958807571" target="_blank" title="https://juejin.cn/post/7583910637958807571">flutter使用package_info_plus库获取应用信息的教程</a></li>
<li><a href="https://juejin.cn/post/7588680081327259690" target="_blank" title="https://juejin.cn/post/7588680081327259690">Flutter下拉刷新上拉加载侧拉刷新插件：easy_refresh全面使用指南</a></li>
<li><a href="https://juejin.cn/post/7583226204036513833" target="_blank" title="https://juejin.cn/post/7583226204036513833">flutter-使用EventBus实现组件间数据通信</a></li>
<li><a href="https://juejin.cn/post/7582808491582619684" target="_blank" title="https://juejin.cn/post/7582808491582619684">Flutter输入框TextField的属性与实战用法全面解析+示例</a></li>
<li><a href="https://juejin.cn/post/7581693431740448831" target="_blank" title="https://juejin.cn/post/7581693431740448831">Flutter自定义日历table_calendar完全指南+案例</a></li>
<li><a href="https://juejin.cn/post/7580389111921786943" target="_blank" title="https://juejin.cn/post/7580389111921786943">flutter-屏幕自适应插件flutter_screenutil教程全指南</a></li>
<li><a href="https://juejin.cn/post/7579101504289882166" target="_blank" title="https://juejin.cn/post/7579101504289882166">flutter-使用url_launcher打开链接/应用/短信/邮件和评分跳转等</a></li>
<li><a href="https://juejin.cn/post/7570923924365230143" target="_blank" title="https://juejin.cn/post/7570923924365230143">flutter图片选择库multi_image_picker_plus和image_picker的对比和使用解析</a></li>
<li><a href="https://juejin.cn/post/7568136081302978623" target="_blank" title="https://juejin.cn/post/7568136081302978623">解锁flutter弹窗新姿势：dialog-flutter_smart_dialog插件解读+案例</a></li>
<li><a href="https://juejin.cn/post/7559089440901545999" target="_blank" title="https://juejin.cn/post/7559089440901545999">flutter-切换状态显示不同组件10种实现方案全解析</a></li>
<li><a href="https://juejin.cn/post/7555079970491318308" target="_blank" title="https://juejin.cn/post/7555079970491318308">flutter-详解控制组件显示的两种方式Offstage与Visibility</a></li>
<li><a href="https://juejin.cn/post/7535358416182788122" target="_blank" title="https://juejin.cn/post/7535358416182788122">flutter-使用AnimatedDefaultTextStyle实现文本动画</a></li>
<li><a href="https://juejin.cn/post/7537339432291434496" target="_blank" title="https://juejin.cn/post/7537339432291434496">flutter-使用SafeArea组件处理各机型的安全距离</a></li>
<li><a href="https://juejin.cn/spost/7537593417099149321" target="_blank" title="https://juejin.cn/spost/7537593417099149321">flutter-实现渐变色边框背景以及渐变色文字</a></li>
<li><a href="https://juejin.cn/post/7543474419240370185" target="_blank" title="https://juejin.cn/post/7543474419240370185">flutter-使用confetti制作炫酷纸屑爆炸粒子动画</a></li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Vue-性能优化利器：Keep-Alive]]></title>    <link>https://juejin.cn/post/7601486204174581810</link>    <guid>https://juejin.cn/post/7601486204174581810</guid>    <pubDate>2026-02-02T01:35:22.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7601486204174581810" data-draft-id="7601441797118853171" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Vue-性能优化利器：Keep-Alive"/> <meta itemprop="keywords" content="前端,面试,Vue.js"/> <meta itemprop="datePublished" content="2026-02-02T01:35:22.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="发现一只大呆瓜"/> <meta itemprop="url" content="https://juejin.cn/user/180747382561607"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Vue-性能优化利器：Keep-Alive
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/180747382561607/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    发现一只大呆瓜
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-02T01:35:22.000Z" title="Mon Feb 02 2026 01:35:22 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-02
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h3 data-id="heading-0">前言</h3>
<p>在后台管理系统或长列表页面中，我们经常遇到这样的需求：从列表进入详情页，返回时希望列表滚动位置、搜索条件都能完美保留。Vue 内置的 <code>&lt;KeepAlive&gt;</code> 正是为此而生。本文将带你从基础用法出发，直击其背后的缓存算法原理。</p>
<hr/>
<h2 data-id="heading-1">一、 什么是 Keep-Alive？</h2>
<p><code>&lt;KeepAlive&gt;</code> 是一个内置组件，用于<strong>缓存不活动的组件实例</strong>，而不是销毁它们。</p>
<ul>
<li><strong>核心价值</strong>：保留组件状态、避免重复渲染 DOM、提升用户体验。</li>
<li><strong>应用场景</strong>：表单多步骤切换、列表页返回流、详情页页签切换。</li>
</ul>
<hr/>
<h2 data-id="heading-2">二、 基础实战：结合 Vue Router 实现按需缓存</h2>
<p>在 Vue 中，我们通常结合路由的 <code>meta</code> 字段和 <code>&lt;router-view&gt;</code> 的插槽语法来实现。</p>
<h3 data-id="heading-3">1. 路由配置</h3>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// src/router/index.ts</span>
<span class="hljs-keyword">import</span> { createRouter, createWebHistory, <span class="hljs-title class_">RouteRecordRaw</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue-router'</span>;

<span class="hljs-keyword">const</span> <span class="hljs-attr">routes</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">RouteRecordRaw</span>&gt; = [
    {
      <span class="hljs-attr">path</span>: <span class="hljs-string">'/your-path'</span>,
      <span class="hljs-attr">name</span>: <span class="hljs-string">'YourComponentName'</span>,
      <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'./views/YourComponent.vue'</span>),
      <span class="hljs-attr">meta</span>: {
        <span class="hljs-attr">keepAlive</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// 设置需要缓存</span>
      }
    }
];
</code></pre>
<h3 data-id="heading-4">2. 宿主容器配置</h3>
<p>在 <code>App.vue</code> 或主布局文件中，接着在对应<code>&lt;router-view&gt;</code>的中插入<code>&lt;keep-alive&gt;</code>，并设置<code>include</code>属性来匹配需要缓存的组件</p>
<p>代码段</p>
<pre><code class="hljs language-vue" lang="vue">  // includeComponents为对应的组件文件名称
  &lt;router-view v-slot="{ Component }"&gt;
    &lt;KeepAlive :include="includeComponents"&gt;
      &lt;component :is="Component" /&gt;
    &lt;/KeepAlive&gt;
  &lt;/router-view&gt;
</code></pre>
<hr/>
<h2 data-id="heading-5">三、 特有的生命周期钩子</h2>
<p>一旦组件被缓存，其正常的销毁流程将被“冻结”，取而代之的是两个专属钩子：</p>
<ul>
<li><strong><code>activated</code></strong>：组件<strong>被激活</strong>（初始化渲染或从缓存中恢复）时调用。此时可重新获取数据或重置滚动位置。</li>
<li><strong><code>deactivated</code></strong>：组件<strong>被停用</strong>（离开当前路由）时调用。此时可清理定时器或取消未完成的请求。</li>
</ul>
<blockquote>
<p><strong>⚠️ 注意</strong>：由于组件被缓存，<code>onBeforeUnmount</code> 和 <code>onUnmounted</code>（Vue 2 中的 <code>beforeDestroy</code> 和 <code>destroyed</code>）<strong>不会</strong>被触发。</p>
</blockquote>
<hr/>
<h2 data-id="heading-6">四、 深度进阶：Keep-Alive 的底层原理</h2>
<p><code>&lt;KeepAlive&gt;</code> 本质上是一个“无渲染组件”，它不渲染多余的 DOM，而是直接操作组件的 VNode。</p>
<h3 data-id="heading-7">1. 内存中的 Map 缓存</h3>
<p><code>Keep-Alive</code> 内部维护了一个 <code>cache</code> 对象（Map 结构）和一个 <code>keys</code> 队列（Array 结构）：</p>
<ul>
<li><strong>Cache</strong>：键是组件的 <code>key</code>，值是组件的 <code>vnode</code> 实例。</li>
<li><strong>Keys</strong>：记录缓存组件的顺序。</li>
</ul>
<h3 data-id="heading-8">2. 渲染函数逻辑</h3>
<p>当 <code>render</code> 函数执行时：</p>
<ol>
<li>获取内部包裹的组件节点。</li>
<li>查找 <code>cache</code> 中是否存在该组件的实例。</li>
<li><strong>存在</strong>：直接从缓存中获取实例，并更新该 key 在 <code>keys</code> 队列中的位置（移到最后）。</li>
<li><strong>不存在</strong>：将其加入缓存。</li>
</ol>
<h3 data-id="heading-9">3. LRU 缓存策略</h3>
<p>如果缓存的组件过多，内存会爆炸吗？不会。 Vue 使用了 <strong>LRU (Least Recently Used) 最近最少使用</strong> 算法。当缓存数量超过 <code>max</code> 属性设定的阈值时，Vue 会自动销毁 <code>keys</code> 队列中最久没被访问过的那个组件实例。</p>
<hr/>
<h2 data-id="heading-10">五、 总结</h2>
<ol>
<li><strong>组件名称 (name)</strong> ：<code>include</code> 匹配的是组件定义的 <code>name</code> 选项。在 Vue 3 <code>&lt;script setup&gt;</code> 中，如果你没有显式定义 <code>name</code>，Vue 会根据文件名自动生成，建议显式定义以防匹配失效。</li>
<li><strong>多级嵌套路由</strong>：如果你的 <code>&lt;router-view&gt;</code> 层级很深，每一层都需要配置 <code>&lt;KeepAlive&gt;</code> 才能保证整条路径上的状态都被保留。</li>
<li><strong>Key 的重要性</strong>：在 <code>&lt;component :is&gt;</code> 上绑定正确的 <code>:key</code>，能有效防止在切换相同组件不同参数（如 <code>/detail/1</code> 到 <code>/detail/2</code>）时出现缓存混乱。</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[性能优化之⽹络层⾯优化--让你的⽹站跑得⽐快递员还快]]></title>    <link>https://juejin.cn/post/7601606188618367014</link>    <guid>https://juejin.cn/post/7601606188618367014</guid>    <pubDate>2026-02-02T00:37:32.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7601606188618367014" data-draft-id="7592622563546972195" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="性能优化之⽹络层⾯优化--让你的⽹站跑得⽐快递员还快"/> <meta itemprop="keywords" content="前端,Vue.js,JavaScript"/> <meta itemprop="datePublished" content="2026-02-02T00:37:32.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="destinying"/> <meta itemprop="url" content="https://juejin.cn/user/896842287549703"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            性能优化之⽹络层⾯优化--让你的⽹站跑得⽐快递员还快
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/896842287549703/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    destinying
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-02T00:37:32.000Z" title="Mon Feb 02 2026 00:37:32 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-02
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    44
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">⽹络层⾯优化：让你的⽹站跑得⽐快递员还快</h2>
<blockquote>
<p>前言：本⽂纯属真实经历，如有雷同，纯属你也踩过坑。</p>
</blockquote>
<h3 data-id="heading-1">1. 浏览器缓存：别让⽤户重复下载你的"祖传代码"</h3>
<p>兄弟们，有没有遇到过这种情况？你明明已经优化过代码了，⽤户还是说"⽹站怎么还是那个样⼦？"然后你⼀脸懵逼地发现：浏览器缓存还在使⽤你上个月写的"屎⼭代码"。</p>
<p><strong>浏览器缓存就像是那个记性超好的前女友</strong>，你改了什么她都记得，但就是不愿意承认你已经变了。</p>
<h4 data-id="heading-2">1.1 LocalStorage ⼀把梭？快住手！</h4>
<p>很多同学喜欢把什么东西都往 LocalStorage ⾥塞，恨不得把整个项⽬都存进去。听我⼀句劝，LocalStorage 就像你的钱包，别什么都往⾥塞，否则哪天爆了就尴尬了。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// ❌ 错误示范</span>
<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">'整个项目'</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(yourProject))

<span class="hljs-comment">// ✅ 正确姿势：封装一下，加上过期时间</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Storage</span> {
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">set</span>(<span class="hljs-params">key, value, expire = <span class="hljs-number">7</span> * <span class="hljs-number">24</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span></span>) {
    <span class="hljs-keyword">const</span> data = {
      value,
      <span class="hljs-attr">expire</span>: <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() + expire
    }
    <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(key, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data))
  }

  <span class="hljs-keyword">static</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">key</span>) {
    <span class="hljs-keyword">const</span> data = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(key))
    <span class="hljs-keyword">if</span> (!data) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() &gt; data.<span class="hljs-property">expire</span>) {
      <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">removeItem</span>(key)
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>
    }
    <span class="hljs-keyword">return</span> data.<span class="hljs-property">value</span>
  }
}

<span class="hljs-comment">// 使用起来更优雅</span>
<span class="hljs-title class_">Storage</span>.<span class="hljs-title function_">set</span>(<span class="hljs-string">'userInfo'</span>, { <span class="hljs-attr">name</span>: <span class="hljs-string">'张三'</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">18</span> })
<span class="hljs-keyword">const</span> user = <span class="hljs-title class_">Storage</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">'userInfo'</span>)
</code></pre>
<h4 data-id="heading-3">1.2 SessionStorage 是"露⽔情缘"</h4>
<p>关掉标签页就拜拜，不多废话。适合存那些"⽤完即弃"的数据，⽐如表单暂存。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 表单暂存示例，防止用户误操作丢失数据</span>
<span class="hljs-keyword">const</span> form = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'#myForm'</span>)

<span class="hljs-comment">// 输入时自动保存</span>
form.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'input'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">const</span> formData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormData</span>(form)
  sessionStorage.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">'formData'</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">fromEntries</span>(formData)))
})

<span class="hljs-comment">// 页面加载时恢复</span>
<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'load'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">const</span> saved = sessionStorage.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">'formData'</span>)
  <span class="hljs-keyword">if</span> (saved) {
    <span class="hljs-keyword">const</span> data = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(saved)
    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(data).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> {
      form.<span class="hljs-property">elements</span>[key].<span class="hljs-property">value</span> = data[key]
    })
  }
})

<span class="hljs-comment">// 提交后清除</span>
form.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'submit'</span>, <span class="hljs-function">() =&gt;</span> {
  sessionStorage.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">'formData'</span>)
})
</code></pre>
<h4 data-id="heading-4">1.3 IndexedDB？那是真的猛</h4>
<p>当你需要存点⼤东西的时候，⽐如离线缓存、图片啥的，IndexedDB 才是你的菜。虽然 API 设计得像迷宫，但好歹是个迷宫⾥有宝藏的那种。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// ⼿写 IndexedDB 简直折磨，推荐⽤ idb 这个库</span>
<span class="hljs-keyword">import</span> { openDB } <span class="hljs-keyword">from</span> <span class="hljs-string">'idb'</span>

<span class="hljs-comment">// 初始化数据库</span>
<span class="hljs-keyword">const</span> db = <span class="hljs-keyword">await</span> <span class="hljs-title function_">openDB</span>(<span class="hljs-string">'myDB'</span>, <span class="hljs-number">1</span>, {
  <span class="hljs-title function_">upgrade</span>(<span class="hljs-params">db</span>) {
    <span class="hljs-keyword">if</span> (!db.<span class="hljs-property">objectStoreNames</span>.<span class="hljs-title function_">contains</span>(<span class="hljs-string">'images'</span>)) {
      db.<span class="hljs-title function_">createObjectStore</span>(<span class="hljs-string">'images'</span>, { <span class="hljs-attr">keyPath</span>: <span class="hljs-string">'id'</span> })
    }
  }
})

<span class="hljs-comment">// 存储图片</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">saveImage</span>(<span class="hljs-params">id, blob</span>) {
  <span class="hljs-keyword">await</span> db.<span class="hljs-title function_">put</span>(<span class="hljs-string">'images'</span>, { id, blob, <span class="hljs-attr">timestamp</span>: <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() })
}

<span class="hljs-comment">// 读取图片</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getImage</span>(<span class="hljs-params">id</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> db.<span class="hljs-title function_">get</span>(<span class="hljs-string">'images'</span>, id)
}
</code></pre>
<h4 data-id="heading-5">1.4 Cache API：PWA 的灵魂</h4>
<p>想做 PWA？Cache API 必须得会。它能让你在离线状态下也能访问⽹站，简直是⽹络开⼩差时的救命稻草。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// sw.js</span>
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CACHE_NAME</span> = <span class="hljs-string">'my-cache-v1'</span>
<span class="hljs-keyword">const</span> urlsToCache = [
  <span class="hljs-string">'/'</span>,
  <span class="hljs-string">'/styles/main.css'</span>,
  <span class="hljs-string">'/scripts/main.js'</span>,
  <span class="hljs-string">'/images/logo.png'</span>
]

<span class="hljs-comment">// 安装时缓存静态资源</span>
self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'install'</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
  event.<span class="hljs-title function_">waitUntil</span>(
    caches.<span class="hljs-title function_">open</span>(<span class="hljs-variable constant_">CACHE_NAME</span>)
      .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">cache</span>) =&gt;</span> cache.<span class="hljs-title function_">addAll</span>(urlsToCache))
      .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> self.<span class="hljs-title function_">skipWaiting</span>())
  )
})

<span class="hljs-comment">// 拦截请求，优先从缓存读取</span>
self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'fetch'</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
  event.<span class="hljs-title function_">respondWith</span>(
    caches.<span class="hljs-title function_">match</span>(event.<span class="hljs-property">request</span>)
      .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> {
        <span class="hljs-comment">// 缓存命中直接返回，否则⾛网络</span>
        <span class="hljs-keyword">return</span> response || <span class="hljs-title function_">fetch</span>(event.<span class="hljs-property">request</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> {
          <span class="hljs-comment">// 把新资源缓存起来</span>
          <span class="hljs-keyword">return</span> caches.<span class="hljs-title function_">open</span>(<span class="hljs-variable constant_">CACHE_NAME</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cache</span> =&gt;</span> {
            cache.<span class="hljs-title function_">put</span>(event.<span class="hljs-property">request</span>, response.<span class="hljs-title function_">clone</span>())
            <span class="hljs-keyword">return</span> response
          })
        })
      })
  )
})

<span class="hljs-comment">// 更新缓存</span>
self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'activate'</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> cacheWhitelist = [<span class="hljs-variable constant_">CACHE_NAME</span>]
  event.<span class="hljs-title function_">waitUntil</span>(
    caches.<span class="hljs-title function_">keys</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">cacheNames</span>) =&gt;</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(
        cacheNames.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">cacheName</span>) =&gt;</span> {
          <span class="hljs-keyword">if</span> (cacheWhitelist.<span class="hljs-title function_">indexOf</span>(cacheName) === -<span class="hljs-number">1</span>) {
            <span class="hljs-keyword">return</span> caches.<span class="hljs-title function_">delete</span>(cacheName)
          }
        })
      )
    })
  )
})
</code></pre>
<h4 data-id="heading-6">1.5 小贴士</h4>
<ul>
<li>给缓存加点过期时间，别让⽤户的手机变成了你的"垃圾场"</li>
<li>敏感数据别存缓存，不然哪天被抓包了别怪我没提醒你</li>
<li>定期清理缓存，就像打扫房间⼀样重要</li>
</ul>
<h3 data-id="heading-7">2. 资源压缩：让体积缩⽔，让速度起飞</h3>
<p>说真的，资源压缩是最简单也最有效的优化手段。⽤好了，能减少 70%+ 的传输体积；⽤不好，⽤户加载时就像在等快递。</p>
<h4 data-id="heading-8">2.1 Gzip/Brotli 压缩</h4>
<p>这个主要是后端和运维配置的，但前端也要知道原理。Gzip 能压缩到原体积的 30-40%，Brotli 更强，能到 20-30%。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// Vite 开发环境也开启压缩</span>
<span class="hljs-comment">// vite.config.js</span>
<span class="hljs-keyword">import</span> { defineConfig } <span class="hljs-keyword">from</span> <span class="hljs-string">'vite'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>({
  <span class="hljs-attr">server</span>: {
    <span class="hljs-attr">headers</span>: {
      <span class="hljs-string">'Content-Encoding'</span>: <span class="hljs-string">'gzip'</span>
    }
  }
})
</code></pre>
<p><strong>告诉后端大佬：</strong></p>
<ul>
<li>HTML、CSS、JS、JSON 都要开启 Gzip/Brotli</li>
<li>图片、视频这类已经压缩过的文件就不用再压了</li>
<li>生产环境优先用 Brotli，兼容性用 Gzip</li>
</ul>
<h4 data-id="heading-9">2.2 代码压缩：Tree Shaking + 压缩工具</h4>
<p>现代构建工具（Vite、Webpack）都内置了这些功能，配置好就行。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// vite.config.js</span>
<span class="hljs-keyword">import</span> { defineConfig } <span class="hljs-keyword">from</span> <span class="hljs-string">'vite'</span>
<span class="hljs-keyword">import</span> vue <span class="hljs-keyword">from</span> <span class="hljs-string">'@vitejs/plugin-vue'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>({
  <span class="hljs-attr">plugins</span>: [<span class="hljs-title function_">vue</span>()],

  <span class="hljs-attr">build</span>: {
    <span class="hljs-comment">// 开启 CSS 代码分割</span>
    <span class="hljs-attr">cssCodeSplit</span>: <span class="hljs-literal">true</span>,

    <span class="hljs-comment">// 设置 chunk 大小警告阈值（kb）</span>
    <span class="hljs-attr">chunkSizeWarningLimit</span>: <span class="hljs-number">1000</span>,

    <span class="hljs-comment">// 压缩配置</span>
    <span class="hljs-attr">minify</span>: <span class="hljs-string">'terser'</span>,
    <span class="hljs-attr">terserOptions</span>: {
      <span class="hljs-attr">compress</span>: {
        <span class="hljs-attr">drop_console</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 生产环境去掉 console</span>
        <span class="hljs-attr">drop_debugger</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// 生产环境去掉 debugger</span>
      }
    },

    <span class="hljs-attr">rollupOptions</span>: {
      <span class="hljs-attr">output</span>: {
        <span class="hljs-comment">// 开启 Tree Shaking</span>
        <span class="hljs-attr">treeshake</span>: <span class="hljs-literal">true</span>
      }
    }
  }
})
</code></pre>
<h4 data-id="heading-10">2.3 图片压缩：体积减半，体验翻倍</h4>
<p>很多同学直接把设计师给的原图放上去，一张图好几 MB，⽤户加载要等半天。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// vite-plugin-imagemin：自动压缩图片</span>
<span class="hljs-keyword">import</span> { defineConfig } <span class="hljs-keyword">from</span> <span class="hljs-string">'vite'</span>
<span class="hljs-keyword">import</span> viteImagemin <span class="hljs-keyword">from</span> <span class="hljs-string">'vite-plugin-imagemin'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>({
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-title function_">viteImagemin</span>({
      <span class="hljs-attr">gifsicle</span>: { <span class="hljs-attr">optimizationLevel</span>: <span class="hljs-number">7</span> },
      <span class="hljs-attr">optipng</span>: { <span class="hljs-attr">optimizationLevel</span>: <span class="hljs-number">7</span> },
      <span class="hljs-attr">mozjpeg</span>: { <span class="hljs-attr">quality</span>: <span class="hljs-number">80</span> },
      <span class="hljs-attr">pngquant</span>: { <span class="hljs-attr">quality</span>: [<span class="hljs-number">0.8</span>, <span class="hljs-number">0.9</span>] },
      <span class="hljs-attr">svgo</span>: {
        <span class="hljs-attr">plugins</span>: [
          { <span class="hljs-attr">name</span>: <span class="hljs-string">'removeViewBox'</span> },
          { <span class="hljs-attr">name</span>: <span class="hljs-string">'removeEmptyAttrs'</span> }
        ]
      }
    })
  ]
})
</code></pre>
<p><strong>更简单的方法：用在线工具</strong></p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Ftinypng.com%2F" target="_blank" title="https://tinypng.com/" ref="nofollow noopener noreferrer">TinyPNG</a>：免费，压缩效果好</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fsquoosh.app%2F" target="_blank" title="https://squoosh.app/" ref="nofollow noopener noreferrer">Squoosh</a>：Google 出品，功能强大</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fimageoptim.com%2F" target="_blank" title="https://imageoptim.com/" ref="nofollow noopener noreferrer">ImageOptim</a>：Mac 专用，拖进去就行</li>
</ul>
<h4 data-id="heading-11">2.4 WebP 格式：新时代的图片格式</h4>
<p>WebP 比传统格式（JPG、PNG）小 25-35%，质量还更好。</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-comment">&lt;!-- 传统写法 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"image.jpg"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">"示例图片"</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 优化写法：支持 WebP 用 WebP，不支持降级到 JPG --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">picture</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">srcset</span>=<span class="hljs-string">"image.webp"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"image/webp"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"image.jpg"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">"示例图片"</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">picture</span>&gt;</span>
</code></pre>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 自动转 WebP：vite-plugin-webp</span>
<span class="hljs-keyword">import</span> { defineConfig } <span class="hljs-keyword">from</span> <span class="hljs-string">'vite'</span>
<span class="hljs-keyword">import</span> webp <span class="hljs-keyword">from</span> <span class="hljs-string">'vite-plugin-webp'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>({
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-title function_">webp</span>({
      <span class="hljs-attr">quality</span>: <span class="hljs-number">80</span>,
      <span class="hljs-attr">enablePlugin</span>: <span class="hljs-literal">true</span>
    })
  ]
})
</code></pre>
<h4 data-id="heading-12">2.5 雪碧图 vs SVG Sprite</h4>
<p>过去常用雪碧图，现在更推荐 SVG Sprite。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// vite-plugin-svg-icons</span>
<span class="hljs-keyword">import</span> { createSvgIconsPlugin } <span class="hljs-keyword">from</span> <span class="hljs-string">'vite-plugin-svg-icons'</span>
<span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">'path'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>({
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-title function_">createSvgIconsPlugin</span>({
      <span class="hljs-attr">iconDirs</span>: [path.<span class="hljs-title function_">resolve</span>(process.<span class="hljs-title function_">cwd</span>(), <span class="hljs-string">'src/assets/icons'</span>)],
      <span class="hljs-attr">symbolId</span>: <span class="hljs-string">'icon-[name]'</span>
    })
  ]
})
</code></pre>
<pre><code class="hljs language-vue" lang="vue">&lt;!-- 在组件中使用 --&gt;
&lt;svg&gt;
  &lt;use xlink:href="#icon-user" /&gt;
&lt;/svg&gt;
</code></pre>
<h4 data-id="heading-13">2.6 按需加载：只加载需要的</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// ❌ 一次性加载所有组件</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Button</span>, <span class="hljs-title class_">Input</span>, <span class="hljs-title class_">Select</span>, <span class="hljs-title class_">Table</span>, <span class="hljs-title class_">Form</span>, ... } <span class="hljs-keyword">from</span> <span class="hljs-string">'element-ui'</span>

<span class="hljs-comment">// ✅ 按需加载</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Button</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'element-ui'</span>

<span class="hljs-comment">// 或者用动态导入</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">Table</span> = (<span class="hljs-params"/>) =&gt; <span class="hljs-keyword">import</span>(<span class="hljs-string">'element-ui/lib/table'</span>)

<span class="hljs-comment">// Vue 路由懒加载</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">Home</span> = (<span class="hljs-params"/>) =&gt; <span class="hljs-keyword">import</span>(<span class="hljs-string">'@/views/Home.vue'</span>)
<span class="hljs-keyword">const</span> <span class="hljs-title function_">About</span> = (<span class="hljs-params"/>) =&gt; <span class="hljs-keyword">import</span>(<span class="hljs-string">'@/views/About.vue'</span>)

<span class="hljs-keyword">const</span> routes = [
  { <span class="hljs-attr">path</span>: <span class="hljs-string">'/'</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">Home</span> },
  { <span class="hljs-attr">path</span>: <span class="hljs-string">'/about'</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">About</span> }
]
</code></pre>
<h3 data-id="heading-14">3. DNS 缓存：让你的⽹址解析⽐点外卖还快</h3>
<p>DNS 解析就像是查电话本，你每次访问⽹站都要先查⼀下 IP 地址。但如果每次都要查，那就太慢了。</p>
<h4 data-id="heading-15">3.1 DNS 预取（DNS Prefetching）</h4>
<p>提前告诉浏览器"嘿，等下⼉可能要去这个域名，先把电话查好"。</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-comment">&lt;!-- 在 HTML head 中添加 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"dns-prefetch"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://cdn.example.com"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"dns-prefetch"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://api.example.com"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"dns-prefetch"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://static.example.com"</span>&gt;</span>
</code></pre>
<p><strong>使用场景：</strong></p>
<ul>
<li>CDN 域名</li>
<li>第三方 API 域名</li>
<li>统计分析域名（如 Google Analytics）</li>
<li>字体服务域名（如 Google Fonts）</li>
</ul>
<h4 data-id="heading-16">3.2 预连接（Preconnect）</h4>
<p>预连接比 DNS 预取更进一步，它不仅解析 DNS，还会建立 TCP 连接和 TLS 握手。</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-comment">&lt;!-- 适用于必定会使用的域名 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"preconnect"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://cdn.example.com"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"preconnect"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://api.example.com"</span>&gt;</span>
</code></pre>
<p><strong>注意：</strong> 不要滥用，每个预连接都会消耗资源。只用于必定会加载的域名。</p>
<h4 data-id="heading-17">3.3 域名收敛</h4>
<p>一个网站用太多域名会降低性能。HTTP/1.1 时代需要域名分片来突破浏览器并发限制，现在 HTTP/2 多路复用反而收敛更好。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// ❌ 太多域名</span>
&lt;img src=<span class="hljs-string">"https://cdn1.example.com/a.jpg"</span>&gt;
&lt;img src="https://cdn2.example.com/b.jpg"&gt;
&lt;img src="https://cdn3.example.com/c.jpg"&gt;

// ✅ 收敛到 1-2 个域名
&lt;img src="https://cdn.example.com/a.jpg"&gt;
&lt;img src="https://cdn.example.com/b.jpg"&gt;
&lt;img src="https://cdn.example.com/c.jpg"&gt;
</code></pre>
<p><strong>实战经验：</strong></p>
<ul>
<li>静态资源用 1 个 CDN 域名</li>
<li>API 用 1 个域名</li>
<li>总共不超过 2-3 个域名</li>
</ul>
<h3 data-id="heading-18">4. CDN：让你的⽹站遍布全球</h3>
<p>CDN 是什么？简单说，就是把你的⽹站复制到世界各地，让⽤户访问最近的节点。</p>
<h4 data-id="heading-19">4.1 CDN 的好处</h4>
<ul>
<li><strong>速度提升</strong>：⽤户访问就近节点，延迟降低</li>
<li><strong>减轻服务器压力</strong>：流量分摊到各个节点</li>
<li><strong>提升可用性</strong>：某个节点挂了，其他节点还能⽤</li>
</ul>
<h4 data-id="heading-20">4.2 前端资源文件名 hash 策略</h4>
<p>这是前端使用 CDN 的关键！只有文件名带了 hash，才能放心设置长期缓存。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// webpack.config.js</span>
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">output</span>: {
    <span class="hljs-attr">filename</span>: <span class="hljs-string">'[name].[contenthash:8].js'</span>,
    <span class="hljs-attr">chunkFilename</span>: <span class="hljs-string">'[name].[contenthash:8].chunk.js'</span>
  },
  <span class="hljs-attr">module</span>: {
    <span class="hljs-attr">rules</span>: [
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(png|jpg|gif)$/</span>,
        <span class="hljs-attr">type</span>: <span class="hljs-string">'asset/resource'</span>,
        <span class="hljs-attr">generator</span>: {
          <span class="hljs-attr">filename</span>: <span class="hljs-string">'images/[name].[contenthash:8][ext]'</span>
        }
      }
    ]
  }
}
</code></pre>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// vite.config.js</span>
<span class="hljs-keyword">import</span> { defineConfig } <span class="hljs-keyword">from</span> <span class="hljs-string">'vite'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>({
  <span class="hljs-attr">build</span>: {
    <span class="hljs-attr">rollupOptions</span>: {
      <span class="hljs-attr">output</span>: {
        <span class="hljs-attr">entryFileNames</span>: <span class="hljs-string">'assets/[name].[hash].js'</span>,
        <span class="hljs-attr">chunkFileNames</span>: <span class="hljs-string">'assets/[name].[hash].js'</span>,
        <span class="hljs-attr">assetFileNames</span>: <span class="hljs-string">'assets/[name].[hash].[ext]'</span>
      }
    }
  }
})
</code></pre>
<h4 data-id="heading-21">4.3 Cloudflare Workers 前端实战</h4>
<p>现在的 CDN 不止是存静态资源，还能在边缘节点运⾏代码。Cloudflare Workers 咱们前端可以自己写。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// Cloudflare Workers 示例：边缘图片压缩</span>
<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'fetch'</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {
  event.<span class="hljs-title function_">respondWith</span>(<span class="hljs-title function_">handleRequest</span>(event.<span class="hljs-property">request</span>))
})

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleRequest</span>(<span class="hljs-params">request</span>) {
  <span class="hljs-keyword">const</span> url = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(request.<span class="hljs-property">url</span>)

  <span class="hljs-comment">// 检测是否是图片请求</span>
  <span class="hljs-keyword">if</span> (url.<span class="hljs-property">pathname</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\.(jpg|jpeg|png|webp)$/</span>)) {
    <span class="hljs-comment">// 检查 URL 参数</span>
    <span class="hljs-keyword">const</span> quality = <span class="hljs-built_in">parseInt</span>(url.<span class="hljs-property">searchParams</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">'quality'</span>)) || <span class="hljs-number">80</span>
    <span class="hljs-keyword">const</span> format = url.<span class="hljs-property">searchParams</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">'format'</span>) || <span class="hljs-string">'webp'</span>

    <span class="hljs-comment">// 从源站获取图片</span>
    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(request)

    <span class="hljs-comment">// 转换图片格式和压缩（使用 WebAssembly 实现的图片处理库）</span>
    <span class="hljs-keyword">const</span> image = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">arrayBuffer</span>()
    <span class="hljs-keyword">const</span> compressed = <span class="hljs-keyword">await</span> <span class="hljs-title function_">compressImage</span>(image, { quality, format })

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Response</span>(compressed, {
      <span class="hljs-attr">headers</span>: {
        <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">`image/<span class="hljs-subst">${format}</span>`</span>,
        <span class="hljs-string">'Cache-Control'</span>: <span class="hljs-string">'public, max-age=31536000'</span>
      }
    })
  }

  <span class="hljs-keyword">return</span> <span class="hljs-title function_">fetch</span>(request)
}

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">compressImage</span>(<span class="hljs-params">imageBuffer, options</span>) {
  <span class="hljs-comment">// 使用前端熟悉的库（如 sharp-wasm）</span>
  <span class="hljs-keyword">const</span> sharp = <span class="hljs-built_in">require</span>(<span class="hljs-string">'sharp-wasm'</span>)
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-title function_">sharp</span>(imageBuffer)
    .<span class="hljs-title function_">webp</span>({ <span class="hljs-attr">quality</span>: options.<span class="hljs-property">quality</span> })
    .<span class="hljs-title function_">toBuffer</span>()
}
</code></pre>
<h4 data-id="heading-22">4.4 实战案例</h4>
<p>之前一个视频⽹站，⽤户遍布全球。没⽤ CDN 的时候，国外⽤户加载要 30 秒；⽤了 CDN 之后，⼤部分地区 3 秒内加载完成。这提升，⾹！</p>
<h4 data-id="heading-23">4.5 注意事项</h4>
<ul>
<li>CDN 节点的缓存要及时更新，不然你改了 bug ⽤户还是看旧版</li>
<li>HTTPS 证书要配好，CDN 和源站都要配</li>
<li>⽇志收集要考虑 CDN 的影响，不然统计数据会偏</li>
<li>告诉运维大佬：静态资源（带 hash 的）可以设置长期缓存，index.html 不要缓存</li>
</ul>
<h3 data-id="heading-24">5. 渲染层⾯优化：让页⾯流畅如丝</h3>
<p>网络层面的优化让资源加载更快，但渲染层面的优化让用户体验更好。</p>
<h4 data-id="heading-25">5.1 关键渲染路径优化</h4>
<p>浏览器渲染页面的流程：DOM → CSSOM → Render Tree → Layout → Paint</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-comment">&lt;!-- ❌ 阻塞渲染的写法 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"large.css"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"app.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span> <span class="hljs-comment">&lt;!-- 阻塞后续内容 --&gt;</span>

<span class="hljs-comment">&lt;!-- ✅ 优化写法 --&gt;</span>
<span class="hljs-comment">&lt;!-- 内联关键 CSS --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
  <span class="hljs-comment">/* 首屏必需的样式 */</span>
  <span class="hljs-selector-class">.header</span> { <span class="hljs-attribute">height</span>: <span class="hljs-number">60px</span>; <span class="hljs-attribute">background</span>: <span class="hljs-number">#333</span>; }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 非关键样式异步加载 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"preload"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"non-critical.css"</span> <span class="hljs-attr">as</span>=<span class="hljs-string">"style"</span> <span class="hljs-attr">onload</span>=<span class="hljs-string">"this.onload=null;this.rel='stylesheet'"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">noscript</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"non-critical.css"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">noscript</span>&gt;</span>

<span class="hljs-comment">&lt;!-- JS 放到底部或异步加载 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"app.js"</span> <span class="hljs-attr">defer</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"analytics.js"</span> <span class="hljs-attr">async</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<h4 data-id="heading-26">5.2 图片懒加载：只加载用户能看到的</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// Intersection Observer API（现代浏览器支持）</span>
<span class="hljs-keyword">const</span> lazyImages = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">'img.lazy'</span>)

<span class="hljs-keyword">const</span> imageObserver = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntersectionObserver</span>(<span class="hljs-function">(<span class="hljs-params">entries, observer</span>) =&gt;</span> {
  entries.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">entry</span> =&gt;</span> {
    <span class="hljs-keyword">if</span> (entry.<span class="hljs-property">isIntersecting</span>) {
      <span class="hljs-keyword">const</span> img = entry.<span class="hljs-property">target</span>
      img.<span class="hljs-property">src</span> = img.<span class="hljs-property">dataset</span>.<span class="hljs-property">src</span>
      img.<span class="hljs-property">classList</span>.<span class="hljs-title function_">remove</span>(<span class="hljs-string">'lazy'</span>)
      observer.<span class="hljs-title function_">unobserve</span>(img)
    }
  })
})

lazyImages.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">img</span> =&gt;</span> imageObserver.<span class="hljs-title function_">observe</span>(img))
</code></pre>
<pre><code class="hljs language-html" lang="html"><span class="hljs-comment">&lt;!-- HTML 使用方式 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"lazy"</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">"image.jpg"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">"示例图片"</span>&gt;</span>
</code></pre>
<pre><code class="hljs language-vue" lang="vue">&lt;!-- Vue 懒加载组件 --&gt;
&lt;template&gt;
  &lt;img v-lazy="imageUrl" alt="示例图片"&gt;
&lt;/template&gt;

&lt;script&gt;
import { lazyLoad } from '@/directives/lazyLoad'

export default {
  directives: {
    lazy: lazyLoad
  },
  data() {
    return {
      imageUrl: 'https://example.com/image.jpg'
    }
  }
}
&lt;/script&gt;
</code></pre>
<h4 data-id="heading-27">5.3 虚拟列表：长列表性能救星</h4>
<p>如果列表有几千条数据，全部渲染会让页面卡顿。虚拟列表只渲染可见区域的项目。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// vue-virtual-scroller 示例</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">RecycleScroller</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue-virtual-scroller'</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">'vue-virtual-scroller/dist/vue-virtual-scroller.css'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">components</span>: {
    <span class="hljs-title class_">RecycleScroller</span>
  },
  <span class="hljs-title function_">data</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">items</span>: <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>({ <span class="hljs-attr">length</span>: <span class="hljs-number">10000</span> }, <span class="hljs-function">(<span class="hljs-params">_, i</span>) =&gt;</span> ({
        <span class="hljs-attr">id</span>: i,
        <span class="hljs-attr">text</span>: <span class="hljs-string">`Item <span class="hljs-subst">${i}</span>`</span>
      }))
    }
  }
}
</code></pre>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;RecycleScroller
    class="scroller"
    :items="items"
    :item-size="50"
    key-field="id"
  &gt;
    &lt;template #default="{ item }"&gt;
      &lt;div class="item"&gt;{{ item.text }}&lt;/div&gt;
    &lt;/template&gt;
  &lt;/RecycleScroller&gt;
&lt;/template&gt;

&lt;style&gt;
.scroller {
  height: 400px;
}

.item {
  height: 50px;
  line-height: 50px;
  border-bottom: 1px solid #eee;
}
&lt;/style&gt;
</code></pre>
<h4 data-id="heading-28">5.4 防抖和节流：优化高频事件</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 防抖：只执行最后一次</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">fn, delay</span>) {
  <span class="hljs-keyword">let</span> timer
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) {
    <span class="hljs-built_in">clearTimeout</span>(timer)
    timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args), delay)
  }
}

<span class="hljs-comment">// 节流：固定时间执行一次</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">fn, delay</span>) {
  <span class="hljs-keyword">let</span> lastTime = <span class="hljs-number">0</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) {
    <span class="hljs-keyword">const</span> now = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>()
    <span class="hljs-keyword">if</span> (now - lastTime &gt;= delay) {
      lastTime = now
      fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args)
    }
  }
}

<span class="hljs-comment">// 使用示例</span>
<span class="hljs-keyword">const</span> searchInput = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'search'</span>)

<span class="hljs-comment">// 搜索输入防抖</span>
searchInput.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'input'</span>, <span class="hljs-title function_">debounce</span>(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'搜索:'</span>, e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>)
}, <span class="hljs-number">300</span>))

<span class="hljs-comment">// 滚动节流</span>
<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'scroll'</span>, <span class="hljs-title function_">throttle</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'滚动位置:'</span>, <span class="hljs-variable language_">window</span>.<span class="hljs-property">scrollY</span>)
}, <span class="hljs-number">100</span>))
</code></pre>
<h4 data-id="heading-29">5.5 代码分割：按需加载</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 路由懒加载</span>
<span class="hljs-keyword">const</span> routes = [
  {
    <span class="hljs-attr">path</span>: <span class="hljs-string">'/home'</span>,
    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'@/views/Home.vue'</span>)
  },
  {
    <span class="hljs-attr">path</span>: <span class="hljs-string">'/about'</span>,
    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'@/views/About.vue'</span>)
  }
]

<span class="hljs-comment">// 组件懒加载</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">components</span>: {
    <span class="hljs-title class_">HeavyComponent</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'@/components/HeavyComponent.vue'</span>)
  }
}

<span class="hljs-comment">// 条件加载</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">loadModule</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">if</span> (needsFeature) {
    <span class="hljs-keyword">const</span> <span class="hljs-variable language_">module</span> = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'@/features/advanced'</span>)
    <span class="hljs-variable language_">module</span>.<span class="hljs-title function_">doSomething</span>()
  }
}
</code></pre>
<h4 data-id="heading-30">5.6 减少 DOM 操作</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// ❌ 频繁操作 DOM</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) {
  <span class="hljs-keyword">const</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">'div'</span>)
  div.<span class="hljs-property">textContent</span> = <span class="hljs-string">`Item <span class="hljs-subst">${i}</span>`</span>
  <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(div)
}

<span class="hljs-comment">// ✅ 使用 DocumentFragment</span>
<span class="hljs-keyword">const</span> fragment = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createDocumentFragment</span>()

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) {
  <span class="hljs-keyword">const</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">'div'</span>)
  div.<span class="hljs-property">textContent</span> = <span class="hljs-string">`Item <span class="hljs-subst">${i}</span>`</span>
  fragment.<span class="hljs-title function_">appendChild</span>(div)
}

<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(fragment)

<span class="hljs-comment">// ✅ 或者使用 innerHTML 一次性插入</span>
<span class="hljs-keyword">let</span> html = <span class="hljs-string">''</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) {
  html += <span class="hljs-string">`&lt;div&gt;Item <span class="hljs-subst">${i}</span>&lt;/div&gt;`</span>
}
<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">innerHTML</span> = html
</code></pre>
<h4 data-id="heading-31">5.7 使用 CSS3 动画代替 JS 动画</h4>
<pre><code class="hljs language-css" lang="css"><span class="hljs-comment">/* ❌ JS 动画（性能差） */</span>
<span class="hljs-selector-class">.element</span> {
  <span class="hljs-attribute">transition</span>: none;
}

<span class="hljs-comment">/* ✅ CSS3 动画（性能好） */</span>
<span class="hljs-selector-class">.element</span> {
  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">100px</span>);
  <span class="hljs-attribute">transition</span>: transform <span class="hljs-number">0.3s</span> ease;
}

<span class="hljs-comment">/* 更好的：使用 will-change 提示浏览器优化 */</span>
<span class="hljs-selector-class">.element</span> {
  <span class="hljs-attribute">will-change</span>: transform;
}
</code></pre>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// ❌ JS 实现动画</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">animate</span>(<span class="hljs-params">element</span>) {
  <span class="hljs-keyword">let</span> position = <span class="hljs-number">0</span>
  <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
    position += <span class="hljs-number">10</span>
    element.<span class="hljs-property">style</span>.<span class="hljs-property">left</span> = position + <span class="hljs-string">'px'</span>
  }, <span class="hljs-number">16</span>)
}

<span class="hljs-comment">// ✅ 使用 CSS3</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">animate</span>(<span class="hljs-params">element</span>) {
  element.<span class="hljs-property">style</span>.<span class="hljs-property">transform</span> = <span class="hljs-string">'translateX(100px)'</span>
  element.<span class="hljs-property">style</span>.<span class="hljs-property">transition</span> = <span class="hljs-string">'transform 0.3s ease'</span>
}
</code></pre>
<h4 data-id="heading-32">5.8 Web Worker：把繁重计算放到后台线程</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// main.js</span>
<span class="hljs-keyword">const</span> worker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(<span class="hljs-string">'./worker.js'</span>)

worker.<span class="hljs-title function_">postMessage</span>({ <span class="hljs-attr">data</span>: largeData })

worker.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'计算结果:'</span>, e.<span class="hljs-property">data</span>.<span class="hljs-property">result</span>)
}
</code></pre>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// worker.js</span>
self.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">heavyCalculation</span>(e.<span class="hljs-property">data</span>.<span class="hljs-property">data</span>)
  self.<span class="hljs-title function_">postMessage</span>({ result })
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">heavyCalculation</span>(<span class="hljs-params">data</span>) {
  <span class="hljs-comment">// 耗时计算</span>
  <span class="hljs-keyword">return</span> data.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b, <span class="hljs-number">0</span>)
}
</code></pre>
<h3 data-id="heading-33">综合实战：打造一套完整的前端性能优化方案</h3>
<p>讲了这么多，怎么组合起来用？来个真实案例，纯前端操作：</p>
<h4 data-id="heading-34">项目结构</h4>
<pre><code class="hljs language-arduino" lang="arduino">my-project/
├── <span class="hljs-keyword">public</span>/
│   ├── index.html
│   └── favicon.ico
├── src/
│   ├── assets/
│   │   ├── images/
│   │   └── styles/
│   ├── components/
│   ├── utils/
│   │   ├── cache.js
│   │   └── request.js
│   ├── sw.js
│   └── main.js
└── vite.config.js
</code></pre>
<h4 data-id="heading-35">完整配置（vite.config.js）</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> { defineConfig } <span class="hljs-keyword">from</span> <span class="hljs-string">'vite'</span>
<span class="hljs-keyword">import</span> vue <span class="hljs-keyword">from</span> <span class="hljs-string">'@vitejs/plugin-vue'</span>
<span class="hljs-keyword">import</span> viteImagemin <span class="hljs-keyword">from</span> <span class="hljs-string">'vite-plugin-imagemin'</span>
<span class="hljs-keyword">import</span> webp <span class="hljs-keyword">from</span> <span class="hljs-string">'vite-plugin-webp'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>({
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-title function_">vue</span>(),
    <span class="hljs-title function_">viteImagemin</span>({
      <span class="hljs-attr">gifsicle</span>: { <span class="hljs-attr">optimizationLevel</span>: <span class="hljs-number">7</span> },
      <span class="hljs-attr">optipng</span>: { <span class="hljs-attr">optimizationLevel</span>: <span class="hljs-number">7</span> },
      <span class="hljs-attr">mozjpeg</span>: { <span class="hljs-attr">quality</span>: <span class="hljs-number">80</span> },
      <span class="hljs-attr">svgo</span>: {
        <span class="hljs-attr">plugins</span>: [
          { <span class="hljs-attr">name</span>: <span class="hljs-string">'removeViewBox'</span> },
          { <span class="hljs-attr">name</span>: <span class="hljs-string">'removeEmptyAttrs'</span> }
        ]
      }
    }),
    <span class="hljs-title function_">webp</span>({
      <span class="hljs-attr">quality</span>: <span class="hljs-number">80</span>
    })
  ],

  <span class="hljs-attr">build</span>: {
    <span class="hljs-attr">rollupOptions</span>: {
      <span class="hljs-attr">output</span>: {
        <span class="hljs-attr">entryFileNames</span>: <span class="hljs-string">'assets/[name].[hash].js'</span>,
        <span class="hljs-attr">chunkFileNames</span>: <span class="hljs-string">'assets/[name].[hash].js'</span>,
        <span class="hljs-attr">assetFileNames</span>: <span class="hljs-string">'assets/[name].[hash].[ext]'</span>
      }
    },
    <span class="hljs-attr">cssCodeSplit</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">minify</span>: <span class="hljs-string">'terser'</span>,
    <span class="hljs-attr">terserOptions</span>: {
      <span class="hljs-attr">compress</span>: {
        <span class="hljs-attr">drop_console</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">drop_debugger</span>: <span class="hljs-literal">true</span>
      }
    }
  }
})
</code></pre>
<h4 data-id="heading-36">HTML 优化（index.html）</h4>
<pre><code class="hljs language-html" lang="html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"zh-CN"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span>&gt;</span>

  <span class="hljs-comment">&lt;!-- DNS 预取 --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"dns-prefetch"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://cdn.example.com"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"preconnect"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://cdn.example.com"</span>&gt;</span>

  <span class="hljs-comment">&lt;!-- 内联关键 CSS --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
    <span class="hljs-comment">/* 首屏必需的样式 */</span>
  <span class="hljs-selector-tag">body</span> { <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>; <span class="hljs-attribute">font-family</span>: -apple-system, BlinkMacSystemFont, sans-serif; }
  <span class="hljs-selector-class">.header</span> { <span class="hljs-attribute">height</span>: <span class="hljs-number">60px</span>; <span class="hljs-attribute">background</span>: <span class="hljs-number">#333</span>; <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>; }
  <span class="hljs-selector-class">.loading</span> { <span class="hljs-attribute">position</span>: fixed; <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>; <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>; <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>, -<span class="hljs-number">50%</span>); }
  </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>

  <span class="hljs-comment">&lt;!-- 非关键样式异步加载 --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"preload"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/assets/style.[hash].css"</span> <span class="hljs-attr">as</span>=<span class="hljs-string">"style"</span> <span class="hljs-attr">onload</span>=<span class="hljs-string">"this.onload=null;this.rel='stylesheet'"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">noscript</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/assets/style.[hash].css"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">noscript</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"loading"</span>&gt;</span>加载中...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

  <span class="hljs-comment">&lt;!-- 脚本异步加载 --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/assets/main.[hash].js"</span> <span class="hljs-attr">defer</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<h4 data-id="heading-37">性能监控（utils/performance.js）</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">trackPerformance</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">if</span> (<span class="hljs-string">'PerformanceObserver'</span> <span class="hljs-keyword">in</span> <span class="hljs-variable language_">window</span>) {
    <span class="hljs-comment">// 监控资源加载</span>
    <span class="hljs-keyword">const</span> resourceObserver = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PerformanceObserver</span>(<span class="hljs-function">(<span class="hljs-params">list</span>) =&gt;</span> {
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> entry <span class="hljs-keyword">of</span> list.<span class="hljs-title function_">getEntries</span>()) {
        <span class="hljs-keyword">if</span> (entry.<span class="hljs-property">transferSize</span> === <span class="hljs-number">0</span>) {
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`✓ 缓存命中: <span class="hljs-subst">${entry.name}</span>`</span>)
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`✗ 网络加载: <span class="hljs-subst">${entry.name}</span> (<span class="hljs-subst">${(entry.transferSize / <span class="hljs-number">1024</span>).toFixed(<span class="hljs-number">2</span>)}</span>KB)`</span>)
        }
      }
    })
    resourceObserver.<span class="hljs-title function_">observe</span>({ <span class="hljs-attr">entryTypes</span>: [<span class="hljs-string">'resource'</span>] })

    <span class="hljs-comment">// 监控长任务</span>
    <span class="hljs-keyword">const</span> longTaskObserver = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PerformanceObserver</span>(<span class="hljs-function">(<span class="hljs-params">list</span>) =&gt;</span> {
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> entry <span class="hljs-keyword">of</span> list.<span class="hljs-title function_">getEntries</span>()) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">`⚠️ 长任务: <span class="hljs-subst">${entry.name}</span> (<span class="hljs-subst">${entry.duration}</span>ms)`</span>)
      }
    })
    longTaskObserver.<span class="hljs-title function_">observe</span>({ <span class="hljs-attr">entryTypes</span>: [<span class="hljs-string">'longtask'</span>] })
  }
}

<span class="hljs-comment">// 在 main.js 中调用</span>
<span class="hljs-title function_">trackPerformance</span>()
</code></pre>
<h3 data-id="heading-38">总结</h3>
<p>性能优化不是⼀蹴⽽就的，需要持续迭代。记住⼏个原则：</p>
<ol>
<li><strong>能缓存的尽量缓存</strong>，让⽤户少等⼏秒</li>
<li><strong>能压缩的尽量压缩</strong>，体积小了传输就快</li>
<li><strong>DNS 预取和预连接</strong>，提前做好准备</li>
<li><strong>CDN 是神器</strong>，让全球用户都能快速访问</li>
<li><strong>渲染优化很重要</strong>，加载快不等于体验好</li>
<li><strong>懒加载和按需加载</strong>，只加载用户需要的</li>
<li><strong>监控要跟上</strong>，不然你都不知道优化有没有⽤</li>
</ol>
<p>最后，如果你觉得这篇⽂章对你有帮助，<strong>点个赞呗</strong>！如果觉得有问题，<strong>评论区喷我</strong>，我抗揍。</p>
<hr/></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[小伙伴们心心念念的倒水解谜游戏实战，终于来了...]]></title>    <link>https://juejin.cn/post/7601313474720153635</link>    <guid>https://juejin.cn/post/7601313474720153635</guid>    <pubDate>2026-02-02T00:48:34.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7601313474720153635" data-draft-id="7601313474720137251" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="小伙伴们心心念念的倒水解谜游戏实战，终于来了..."/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2026-02-02T00:48:34.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="亿元程序员"/> <meta itemprop="url" content="https://juejin.cn/user/1972988307323236"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            小伙伴们心心念念的倒水解谜游戏实战，终于来了...
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1972988307323236/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    亿元程序员
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-02T00:48:34.000Z" title="Mon Feb 02 2026 00:48:34 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-02
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/29de9e6a984a4a4aa4df459288678379~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lq_5YWD56iL5bqP5ZGY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770598115&amp;x-signature=G%2FXNaaGLi4TdRAs8FfKrk0gG4GI%3D" alt="我倒我倒我倒倒倒" loading="lazy"/></p>
<h2 data-id="heading-0">引言</h2>
<p><strong>哈喽大家好</strong>，我是亿元程序员。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cf088b4ce51345908d692577786c920c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lq_5YWD56iL5bqP5ZGY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770598115&amp;x-signature=PnIKqmnheiGfbJyT7VvFI9iaTDs%3D" alt="亿元Cocos小游戏实战合集" loading="lazy"/></p>
<p><strong>笔者的</strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FFOi5gCiGzF3LnT03DpPMXA" target="_blank" title="https://mp.weixin.qq.com/s/FOi5gCiGzF3LnT03DpPMXA" ref="nofollow noopener noreferrer">《亿元Cocos小游戏实战合集》</a>，从更新的第一天开始，就有许多小伙伴问到，什么时候更新一期倒水解谜的游戏实战？</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ab9e7c3d6748450fa7490c5ffb4454cb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lq_5YWD56iL5bqP5ZGY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770598115&amp;x-signature=hKLeTWubroIfDcCYpjau81otyMo%3D" alt="快更新，别逼我催你" loading="lazy"/></p>
<p><strong>其实</strong>笔者早有计划，再加上小伙伴们的强烈需求，这一期，<strong>小伙伴们心心念念的倒水解谜游戏实战，终于来了...</strong></p>
<p><strong>言归正传</strong>，本期带大家一起来看看，在<code>Cocos</code>游戏开发中，<strong>倒水解谜游戏的核心部分</strong>，并加入到我的<a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FFOi5gCiGzF3LnT03DpPMXA" target="_blank" title="https://mp.weixin.qq.com/s/FOi5gCiGzF3LnT03DpPMXA" ref="nofollow noopener noreferrer">《亿元Cocos小游戏实战合集》</a>中去。</p>
<p><strong>本文源工程可在文末获取，小伙伴们自行前往。</strong></p>
<h2 data-id="heading-1">什么是倒水解谜游戏？</h2>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0f0be8ff2226494b8fa12c8dc1dfb1aa~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lq_5YWD56iL5bqP5ZGY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770598115&amp;x-signature=ODNeeAjVtQJarPM5ApbihZKQ2Lc%3D" alt="简单易上手，看了就想玩" loading="lazy"/></p>
<p><strong>可能</strong>有很多小伙伴还不知道这类游戏，简单介绍一下:</p>
<blockquote>
<p><strong>倒水解谜游戏</strong>是一类以 “倒水 / 液体转移” 为核心玩法的休闲益智游戏。</p>
<p><strong>玩家</strong>需通过容器间的倾倒操作达成特定目标（如液体颜色统一、精确容量分配），核心考验逻辑推理与步骤规划能力。</p>
</blockquote>
<p><strong>通俗</strong>的理解，和我们在学校时，通过水杯倒来倒去得到指定毫升数的水相类似(<strong>瞎掰的</strong>)。</p>
<p><strong>既然是倒水游戏，水是重要的一个游戏元素，那它是怎么实现的呢？</strong></p>
<h2 data-id="heading-2">水的效果</h2>
<p><strong>关于</strong>水的效果，其实有比较多的实现方法，既可以通过美术妹子实现，也可以通过<code>Shader</code>实现，甚至还能用<code>Graphics</code>组件画！</p>
<blockquote>
<p><strong>美术妹子:</strong> “一边凉快去。”</p>
</blockquote>
<p><strong>既然</strong>上面的方法行不通，我们只能通过<code>Shader</code>来实现了，至于<code>Graphics</code>，小伙伴们可以自行挑战一下。</p>
<p><strong>1. 资源准备</strong></p>
<p><strong>简单准备</strong>一张杯子形状的图片和对应杯子形状纯白<code>Mask</code>。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bf71a45c8ac64d048d31b17177d08ba4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lq_5YWD56iL5bqP5ZGY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770598115&amp;x-signature=CDO4xmo1DmheVfBf6HE5B1oALYY%3D" alt="铁粉友情助攻" loading="lazy"/></p>
<p><strong>简单</strong>拼一下<code>UI</code>。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/aa6d2bff3d1a4af5844bc33ae90ebab4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lq_5YWD56iL5bqP5ZGY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770598115&amp;x-signature=pL%2B8RNzG3FL4ZXL2lZDaFU%2B5sz8%3D" alt="最喜欢拼UI了，没有之一" loading="lazy"/></p>
<p><strong>通过</strong>资源管理器通过<code>右键-&gt;创建-&gt;传统无光照着色器(Effect)</code>创建一个<code>Shader</code>。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/03680798a0fd4b14ad594d52a0f49c5d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lq_5YWD56iL5bqP5ZGY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770598115&amp;x-signature=tNcoUZQbyFJdUKZM%2FJTT0Lrjazw%3D" alt="手把手" loading="lazy"/></p>
<p><strong>和上面一样</strong>创建一个材质，将对应的<code>Effect</code>改成我们自己创建的并且勾选<code>USE_TEXTURE</code>。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e23eb2a414ea4f4980dcb44325ccc9ad~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lq_5YWD56iL5bqP5ZGY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770598115&amp;x-signature=7%2FVEsals2pdHg6fl%2FDN2mKyJr9w%3D" alt="脚把脚" loading="lazy"/></p>
<p><strong>然后</strong>把材质拖到我们杯子的<code>Mask</code>的<code>Sprite</code>上，实际要在代码中动态创建，不然会共用同一个材质。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e376e6f4dccd4daf99923ed0e00f58b0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lq_5YWD56iL5bqP5ZGY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770598115&amp;x-signature=lWBqdDcx6qz07mCY%2BnjSlIEZW00%3D" alt="演示用" loading="lazy"/></p>
<p><strong>2. 水的颜色</strong></p>
<p><strong>搜索</strong><code>sprite</code>找到<code>builtin-sprite</code>，双击打开把内容复制到我们创建的<code>Shader</code>中去当做模板。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e71416a7877e4116a6f69e2b2b0e2ac2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lq_5YWD56iL5bqP5ZGY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770598115&amp;x-signature=u8UpHItdjW3riX77udfCOfbTv0c%3D" alt="" loading="lazy"/></p>
<p><strong>想要修改</strong>水的颜色，我们可以找到最下面的片段着色器，将<code>color</code>改成红色<code>vec4(1,0,0,1);</code>，分别对应<code>RGBA</code>。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/367df1ec96394ccfb82a6760e4cc8b4e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lq_5YWD56iL5bqP5ZGY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770598115&amp;x-signature=BvNTWo8kiKf30hP8culPvtrlrOk%3D" alt="硬编码" loading="lazy"/></p>
<p><strong>效果如下：</strong></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/295c29b774e648e6a829aa683040c3b0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lq_5YWD56iL5bqP5ZGY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770598115&amp;x-signature=O6Q%2F1vQyutTWAlgWwqw2TRv%2FOpY%3D" alt="火红的烧杯" loading="lazy"/></p>
<p><strong>3. 水的分层</strong></p>
<p><strong>想要实现</strong>水的分层，我们可以通过简单<code>UV</code>划分，下半部分为蓝色，上半部分为红色，实际项目可以通过实际水的高度去划分。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0238e81c8e8d4e0c9673093ee235a6d3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lq_5YWD56iL5bqP5ZGY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770598115&amp;x-signature=68cFqdwS2etEZs3ewyihOhoViHM%3D" alt="还是硬编码" loading="lazy"/></p>
<p><strong>效果如下：</strong></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/925c4eb260814533b72413501194dbaf~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lq_5YWD56iL5bqP5ZGY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770598115&amp;x-signature=wgp2S%2FCssA04nH45Ky5hhOTGktE%3D" alt="自古红蓝出CP" loading="lazy"/></p>
<p><strong>4. 水的波纹</strong></p>
<p><strong>水倒下时</strong>，会在杯子中形成波纹，我们可以通过下面的公式来实现。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/50f60e03f62140e0b31544c2eb4996a2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lq_5YWD56iL5bqP5ZGY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770598115&amp;x-signature=%2BdYMAjEHuFnB6qremfz6cZt%2BNBw%3D" alt="非必要情况下别记" loading="lazy"/></p>
<p><strong>测试Shader</strong>如下，当<code>UV</code>高于指定高度时，形成波纹。使用<code>cc_time</code>时，需要在片段开始时引入<code>#include &lt;cc-global&gt;</code>。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c4a575f1f74f41cdadb3155d90130059~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lq_5YWD56iL5bqP5ZGY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770598115&amp;x-signature=x9aGLPekg1KQ6zDMjYH582kAs88%3D" alt="依旧是硬编码" loading="lazy"/></p>
<p><strong>效果如下：</strong></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fc3e7ceea1eb4ee58554b22e2782a64b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lq_5YWD56iL5bqP5ZGY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770598115&amp;x-signature=IhjzVt09G2FF0HSolUqJ63mDDrk%3D" alt="火辣辣的波纹" loading="lazy"/></p>
<p><strong>5. 水的倾斜</strong></p>
<p><strong>水的倾斜</strong>可以通过下面的函数进行。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/48606754b5364293a23a049aed96f7c8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lq_5YWD56iL5bqP5ZGY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770598115&amp;x-signature=aRBZDVlrw6oqdSMoPT2wXnD8vqs%3D" alt="AI一个接一个不吱声" loading="lazy"/></p>
<p><strong>效果如下：</strong></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b637f2323bee4affb877df0d24d7489a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lq_5YWD56iL5bqP5ZGY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770598115&amp;x-signature=yeMrkQHCZrTtixGIT4upXUYxlJQ%3D" alt="还真有效果" loading="lazy"/></p>
<p><strong>相信</strong>通过上面的内容，大家都已经学会了如何在<code>Shader</code>中模拟水的效果。</p>
<p><strong>那我们要怎么样在实际游戏中进行通过代码控制动态结合呢？</strong></p>
<h2 data-id="heading-3">动态传值到Shader</h2>
<p><strong>想要</strong>通过代码动态传值到<code>Shader</code>，我们通常要通过以下几个步骤。</p>
<p><strong>1.Properties</strong></p>
<blockquote>
<p><strong>properties</strong>用于将<code>Shader</code>中定义的<code>uniform</code>进行别名映射。</p>
<p><strong>这个映射</strong>可以是某个<code>uniform</code>的完整映射，也可以是具体某个分量的映射（使用<code>target</code>参数）。</p>
</blockquote>
<p><strong>代码示例如下，</strong><code>colors</code>和<code>heights</code>可以传<code>vec4</code>数组，<code>iResult</code>是<code>vec2</code>，其余是数值。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/848fcd802eac4d1c995752d86dd5a4cb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lq_5YWD56iL5bqP5ZGY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770598115&amp;x-signature=LANbMk6hm3pO99gyHjGXmSR7%2FD0%3D" alt="很简单的" loading="lazy"/></p>
<p><strong>2.uniform</strong></p>
<p><strong>uniform</strong>是<code>GLSL</code>中的关键字，声明的变量表示全局统一变量:</p>
<ul>
<li>
<p><strong>它的值</strong>在一次绘制调用中保持不变（对所有像素 / 顶点都相同）。</p>
</li>
<li>
<p><strong>可以从</strong><code>CPU</code>端（游戏逻辑代码）直接赋值，<code>GPU</code>端（着色器）只读。</p>
</li>
<li>
<p><strong>常用于</strong>传递动态参数（如颜色、角度、纹理等）。</p>
</li>
</ul>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9226353ddc3048c3b8b196069663c573~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lq_5YWD56iL5bqP5ZGY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770598115&amp;x-signature=IMwen5uFDf0ULJ0AqRoRtPqaKAM%3D" alt="一一对应" loading="lazy"/></p>
<p><strong>3.setProperty</strong></p>
<p><strong>在TypeScript中</strong>可以使用<code>Material</code>类的<code>setProperty</code>方法进行设置，代码示例如下：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cbdd1e18e2a74f7e83e89bf901d04467~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lq_5YWD56iL5bqP5ZGY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770598115&amp;x-signature=Isf3Ov3nozgDzXcWSY4fZKSOXP4%3D" alt="这应该是很熟悉了吧" loading="lazy"/></p>
<p><strong>4.使用</strong></p>
<p><strong>完成</strong>上述步骤后，可以直接使用，非常简单。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8e93b8a3929543e694f2c3f65ee6cbbc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lq_5YWD56iL5bqP5ZGY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770598115&amp;x-signature=cdLdOMskN3LirW0MogtyuDrUOdg%3D" alt="使用很简单" loading="lazy"/></p>
<p><strong>以上</strong>就是倒水解谜游戏的核心部分，其余简单的代码逻辑由于篇幅问题就不再赘述，可以通过源码查看。</p>
<p><strong>相信小伙伴们学废之后，可以完成到下面的效果。</strong></p>
<h2 data-id="heading-4">效果演示</h2>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5e9221acb85744e0991287e295114077~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lq_5YWD56iL5bqP5ZGY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770598115&amp;x-signature=5poLf1I0EM4Ui2PnlvZCFr1qbzY%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-5">结语</h2>
<p>**那么问题来了，**倒水解谜类游戏已经过去了这么久，其变种依旧非常火爆。</p>
<p><strong>小伙伴们知道为什么吗？</strong></p>
<p>本文<strong>实战完整源码</strong>已集成到<a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FFOi5gCiGzF3LnT03DpPMXA" target="_blank" title="https://mp.weixin.qq.com/s/FOi5gCiGzF3LnT03DpPMXA" ref="nofollow noopener noreferrer">亿元Cocos小游戏实战合集（6/10）</a>，内含体验链接，有疑问笔者手把手讲解。</p>
<hr/>
<p><strong>我是"亿元程序员"，一位有着8年游戏行业经验的主程。在游戏开发中，希望能给到您帮助, 也希望通过您能帮助到大家。</strong></p>
<p>AD:笔者线上的小游戏《打螺丝闯关》《贪吃蛇掌机经典》《重力迷宫球》《填色之旅》《方块掌机经典》大家可以自行点击搜索体验。</p>
<p>实不相瞒，想要个<strong>赞</strong>和<strong>爱心</strong>！请把该文章<strong>分享</strong>给你觉得有需要的其他小伙伴。谢谢！</p>
<p>推荐文章：</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FFOi5gCiGzF3LnT03DpPMXA" target="_blank" title="https://mp.weixin.qq.com/s/FOi5gCiGzF3LnT03DpPMXA" ref="nofollow noopener noreferrer">亿元Cocos小游戏实战合集</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FXLCknL3fJDubec2GW6KLFA" target="_blank" title="https://mp.weixin.qq.com/s/XLCknL3fJDubec2GW6KLFA" ref="nofollow noopener noreferrer">Cocos游戏如何接入安卓穿山甲广告变现？</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F3_VrSld4KnDKY_7hxjSoKg" target="_blank" title="https://mp.weixin.qq.com/s/3_VrSld4KnDKY_7hxjSoKg" ref="nofollow noopener noreferrer">你知道和不知道的微信小游戏常用API整理，赶紧收藏用起来~</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F0Lj24VHJ-pL8z82hHqQLiA" target="_blank" title="https://mp.weixin.qq.com/s/0Lj24VHJ-pL8z82hHqQLiA" ref="nofollow noopener noreferrer">Cocos游戏如何快速接入抖音小游戏广告变现？</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FZ7DusUJA2v1IFZDFtBsueg" target="_blank" title="https://mp.weixin.qq.com/s/Z7DusUJA2v1IFZDFtBsueg" ref="nofollow noopener noreferrer">如何在CocosCreator3.8中实现割绳子游戏效果</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F3BzzFBzeVAO-a6LPTeFTrA" target="_blank" title="https://mp.weixin.qq.com/s/3BzzFBzeVAO-a6LPTeFTrA" ref="nofollow noopener noreferrer">如何在CocosCreator3.8中实现动态切割模型？</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FZIph332u_r24OTY4r6_jow" target="_blank" title="https://mp.weixin.qq.com/s/ZIph332u_r24OTY4r6_jow" ref="nofollow noopener noreferrer">Cocos游戏开发中的贴花效果</a></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[JFR：Spring Boot 应用的性能诊断利器]]></title>    <link>https://juejin.cn/post/7601486204174139442</link>    <guid>https://juejin.cn/post/7601486204174139442</guid>    <pubDate>2026-02-02T00:12:33.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7601486204174139442" data-draft-id="7601374668961546290" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="JFR：Spring Boot 应用的性能诊断利器"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-02-02T00:12:33.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="风象南"/> <meta itemprop="url" content="https://juejin.cn/user/2524134428655159"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            JFR：Spring Boot 应用的性能诊断利器
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2524134428655159/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    风象南
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-02T00:12:33.000Z" title="Mon Feb 02 2026 00:12:33 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-02
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    33
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>GC 停顿、内存泄漏、接口响应变慢——线上服务出问题的时候，你是否也曾对着监控面板发呆，不知道根因在哪？</p>
<p>今天聊聊 Java 自带的性能诊断神器 JFR（Java Flight Recorder），配合 Spring Boot 使用，效果翻倍。</p>
<h2 data-id="heading-0">JFR 是什么</h2>
<p>JFR 是 JDK 内置的性能采集工具，知道的人不多，但用过的人都说是「真香」。</p>
<p>几个核心优势：</p>
<ul>
<li><strong>开销可控</strong>：通过事件开关控制采集粒度，精准场景下开销可压到极低</li>
<li><strong>事件丰富</strong>：GC、线程、IO、锁、CPU、异常……100+ 种事件类型</li>
<li><strong>历史回溯</strong>：录制文件可以离线分析，事后定位没问题</li>
<li><strong>持续录制</strong>：支持后台常驻，出问题随时有数据兜底</li>
</ul>
<blockquote>
<p>JDK 8 及之前 JFR 是商业特性，JDK 9+ 免费开源。</p>
</blockquote>
<p>生产环境启用前建议确认：磁盘空间充足、开启了 JFR 权限控制、采集的事件范围符合需求。</p>
<h2 data-id="heading-1">Spring Boot 启用 JFR</h2>
<h4 data-id="heading-2">方式一：启动参数（最简单）</h4>
<pre><code class="hljs language-bash" lang="bash">java -XX:StartFlightRecording:filename=recording.jfr,duration=60s -jar app.jar
</code></pre>
<p>更多参数配置：</p>
<pre><code class="hljs language-bash" lang="bash">java -XX:StartFlightRecording=\
    filename=app-recording.jfr,\
    dumponexit=<span class="hljs-literal">true</span>,\
    maxsize=500M,\
    maxage=1d,\
    settings=profile -jar app.jar
</code></pre>
<p>参数说明：</p>





























<table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td><code>filename</code></td><td>录制文件保存路径</td></tr><tr><td><code>dumponexit</code></td><td>JVM 退出时自动 dump</td></tr><tr><td><code>maxsize</code></td><td>单文件最大 size</td></tr><tr><td><code>maxage</code></td><td>最老数据的保留时间</td></tr><tr><td><code>settings</code></td><td>模板（production/profile）</td></tr></tbody></table>
<h4 data-id="heading-3">方式二：API 动态控制</h4>
<p>Spring Boot 可以通过 JMX 远程控制 JFR 开始/停止：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JfrController</span> {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">MBeanServer</span> <span class="hljs-variable">mBeanServer</span> <span class="hljs-operator">=</span> ManagementFactory.getPlatformMBeanServer();
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">JFR_BEAN_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">"com.oracle.jdk:jfrType=FlightRecorder"</span>;

    <span class="hljs-meta">@PostMapping("/jfr/start")</span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">start</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> String filename)</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-type">ObjectName</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectName</span>(JFR_BEAN_NAME);
        Map&lt;String, String&gt; settings = Map.of(
            <span class="hljs-string">"jdk.JavaMonitorEnter#enabled"</span>, <span class="hljs-string">"true"</span>,
            <span class="hljs-string">"jdk.SocketRead#enabled"</span>, <span class="hljs-string">"true"</span>
        );
        mBeanServer.invoke(name, <span class="hljs-string">"startRecording"</span>,
            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]{filename, settings},
            <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]{String.class.getName(), Map.class.getName()}
        );
        <span class="hljs-keyword">return</span> <span class="hljs-string">"started: "</span> + filename;
    }

    <span class="hljs-meta">@PostMapping("/jfr/stop")</span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">stop</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-type">ObjectName</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectName</span>(JFR_BEAN_NAME);
        mBeanServer.invoke(name, <span class="hljs-string">"stopRecording"</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]{}, <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]{});
        <span class="hljs-keyword">return</span> <span class="hljs-string">"stopped"</span>;
    }
}
</code></pre>
<h4 data-id="heading-4">方式三：Actuator 集成</h4>
<p>Spring Boot Actuator 也能暴露 JFR 端点：</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">management:</span>
  <span class="hljs-attr">endpoints:</span>
    <span class="hljs-attr">web:</span>
      <span class="hljs-attr">exposure:</span>
        <span class="hljs-attr">include:</span> <span class="hljs-string">health,info,jfr</span>
  <span class="hljs-attr">jfr:</span>
    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span>
    <span class="hljs-attr">directory:</span> <span class="hljs-string">/var/log/jfr</span>
</code></pre>
<hr/>
<h2 data-id="heading-5">录制文件怎么分析</h2>
<h4 data-id="heading-6">JDK Mission Control (JMC)</h4>
<p>这是官方提供的 GUI 分析工具，JDK 11+ 自带。</p>
<pre><code class="hljs language-bash" lang="bash">jmc
</code></pre>
<p>打开录制文件后，重点看这几个视图：</p>
<p><strong>1. Recording View</strong> - 事件列表和分布
<strong>2. Code Path</strong> - 热点方法调用链
<strong>3. Memory</strong> - GC 和对象分配
<strong>4. Threads</strong> - 锁竞争、线程状态
<strong>5. I/O</strong> - 文件和网络延迟</p>
<h4 data-id="heading-7">命令行快速分析</h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 概览</span>
jfr summary recording.jfr

<span class="hljs-comment"># 只看某类事件</span>
jfr <span class="hljs-built_in">print</span> --events <span class="hljs-string">"jdk.GC*,jdk.JavaMonitorEnter"</span> recording.jfr

<span class="hljs-comment"># 找出耗时最长的调用</span>
jfr <span class="hljs-built_in">print</span> --events <span class="hljs-string">"jdk.ExecutionSample"</span> recording.jfr | <span class="hljs-built_in">head</span> -30
</code></pre>
<h4 data-id="heading-8">代码分析脚本</h4>
<p>写个脚本批量处理多个录制文件：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JfrAnalyzer</span> {

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-type">var</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(args[<span class="hljs-number">0</span>]);
        Map&lt;String, Long&gt; durations = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();
        Map&lt;String, Integer&gt; counts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();

        <span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> RecordingFile.open(file)) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> event : rs) {
                <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> event.getEventType().getName();
                counts.merge(name, <span class="hljs-number">1</span>, Integer::sum);
                <span class="hljs-keyword">if</span> (event.hasValue(<span class="hljs-string">"duration"</span>)) {
                    <span class="hljs-type">long</span> <span class="hljs-variable">ns</span> <span class="hljs-operator">=</span> event.getDuration(<span class="hljs-string">"duration"</span>).toNanos();
                    durations.merge(name, ns, Long::sum);
                }
            }
        }

        <span class="hljs-comment">// 打印结果</span>
        System.out.println(<span class="hljs-string">"=== Most Frequent ==="</span>);
        counts.entrySet().stream()
            .sorted((a, b) -&gt; b.getValue() - a.getValue())
            .limit(<span class="hljs-number">10</span>).forEach(e -&gt;
                System.out.printf(<span class="hljs-string">"  %s: %d%n"</span>, e.getKey(), e.getValue()));

        System.out.println(<span class="hljs-string">"=== Slowest ==="</span>);
        durations.entrySet().stream()
            .sorted((a, b) -&gt; (<span class="hljs-type">int</span>)(b.getValue() - a.getValue()))
            .limit(<span class="hljs-number">10</span>).forEach(e -&gt;
                System.out.printf(<span class="hljs-string">"  %s: %d ms%n"</span>, e.getKey(), e.getValue() / <span class="hljs-number">1_000_000</span>));
    }
}
</code></pre>
<h2 data-id="heading-9">实战场景</h2>
<h4 data-id="heading-10">GC 停顿排查</h4>
<pre><code class="hljs language-bash" lang="bash">java -XX:StartFlightRecording:\
    filename=gc.jfr,\
    events=<span class="hljs-string">"jdk.GC*,jdk.YoungGarbageCollection,jdk.OldGarbageCollection"</span> -jar app.jar
</code></pre>
<p>JMC 里重点看：</p>
<ul>
<li>GC Pause 总时长和频率</li>
<li>Young GC 频率是否过高</li>
<li>对象晋升（Promotion）是否频繁</li>
</ul>
<h4 data-id="heading-11">接口慢请求定位</h4>
<p>先写个简单的耗时日志 AOP：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Aspect</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TimingAspect</span> {

    <span class="hljs-meta">@Around("@annotation(GetMapping)")</span>
    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">trace</span><span class="hljs-params">(ProceedingJoinPoint p)</span> <span class="hljs-keyword">throws</span> Throwable {
        <span class="hljs-type">var</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">return</span> p.proceed();
        } <span class="hljs-keyword">finally</span> {
            <span class="hljs-type">var</span> <span class="hljs-variable">cost</span> <span class="hljs-operator">=</span> System.currentTimeMillis() - start;
            <span class="hljs-keyword">if</span> (cost &gt; <span class="hljs-number">1000</span>) {
                System.out.printf(<span class="hljs-string">"[SLOW] %s: %d ms%n"</span>, p.getSignature(), cost);
            }
        }
    }
}
</code></pre>
<p>慢请求出现后，配合 JFR 定位具体瓶颈：</p>

























<table><thead><tr><th>JFR 事件</th><th>对应问题</th></tr></thead><tbody><tr><td><code>jdk.ExecutionSample</code></td><td>CPU 热点</td></tr><tr><td><code>jdk.FileRead/Write</code></td><td>磁盘 IO 慢</td></tr><tr><td><code>jdk.SocketRead/Write</code></td><td>网络 IO 慢</td></tr><tr><td><code>jdk.JavaMonitorEnter</code></td><td>锁等待</td></tr></tbody></table>
<h4 data-id="heading-12">内存泄漏</h4>
<p>开启对象分配事件：</p>
<pre><code class="hljs">jdk.ObjectAllocationInNewTLAB
jdk.ObjectAllocationOutsideTLAB
jdk.OldGarbageCollection
</code></pre>
<p>老年代回收频率异常升高 + 堆大小持续增长，基本就是泄漏了。配合 <code>jfr print --events "jdk.OldGarbageCollection"</code> 看回收模式，再导出堆 dump 定位泄漏对象。</p>
<h2 data-id="heading-13">生产环境注意事项</h2>
<h4 data-id="heading-14">1. 资源限制</h4>
<pre><code class="hljs language-bash" lang="bash">-XX:FlightRecorderOptions=maxchunksize=100M,memorysize=50M
</code></pre>
<h4 data-id="heading-15">2. 持续录制 + 轮转</h4>
<pre><code class="hljs language-bash" lang="bash">java -XX:StartFlightRecording=\
    filename=/opt/jfr/app.jfr,\
    dumponexit=<span class="hljs-literal">true</span>,\
    maxage=7d,\
    maxsize=1G,\
    settings=production -jar app.jar
</code></pre>
<h4 data-id="heading-16">3. 权限控制</h4>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-string">export</span> <span class="hljs-string">COM_SUN_JDK_JFR_OPTIONS="security-manager=true"</span>
</code></pre>
<h4 data-id="heading-17">4. 告警联动</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Scheduled(fixedRate = 60000)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">alertIfNeeded</span><span class="hljs-params">()</span> {
    <span class="hljs-comment">// 读取 JFR 事件，异常时推送到告警平台</span>
}
</code></pre>
<h2 data-id="heading-18">总结</h2>
<p>JFR 不是什么新东西，但确实是「平时用不上，出事能救命」的工具。</p>
<p>Spring Boot 集成后，启用成本不高。生产环境按需开启，配合资源限制和轮转策略，遇到问题直接看录制文件，比猜日志高效得多。</p>
<p>几个建议：</p>
<ul>
<li>先记几个常用 JFR 事件名，用到再查文档</li>
<li>持续录制 + 7 天轮转，出问题有数据可查</li>
<li>配合 JMC 可视化，分析效率更高</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[@empjs/valtio - 让你像写 Vue 响应式一样写 React 状态]]></title>    <link>https://juejin.cn/post/7601445395478593570</link>    <guid>https://juejin.cn/post/7601445395478593570</guid>    <pubDate>2026-02-02T02:18:18.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7601445395478593570" data-draft-id="7601477334933192710" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="@empjs/valtio - 让你像写 Vue 响应式一样写 React 状态"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2026-02-02T02:18:18.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="KenXu"/> <meta itemprop="url" content="https://juejin.cn/user/483440843559406"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            @empjs/valtio - 让你像写 Vue 响应式一样写 React 状态
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/483440843559406/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    KenXu
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-02T02:18:18.000Z" title="Mon Feb 02 2026 02:18:18 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-02
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读10分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p><strong>如果你正在经历：</strong> Zustand 替代了 Redux 的繁琐，但还是觉得不够"直觉"？从 Vue 转 React 后，怀念 <code>data.count++</code> 这种自然的写法？ <strong>@empjs/valtio</strong> 可能是你的答案。它让 React 状态管理回归"改变数据就自动更新"的本能，同时把常用功能（撤销/重做、计算属性、本地存储）从 <strong>4~5 个安装步骤简化为 1 行配置</strong>。</p>
</blockquote>
<hr/>
<h2 data-id="heading-0">📖 目录</h2>
<ol>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fclaude.ai%2Fchat%2Fb05d6238-e287-40bb-b349-6f17a24857a9%231-%25E4%25B8%2589%25E5%2588%2586%25E9%2592%259F%25E7%2590%2586%25E8%25A7%25A3" target="_blank" title="https://claude.ai/chat/b05d6238-e287-40bb-b349-6f17a24857a9#1-%E4%B8%89%E5%88%86%E9%92%9F%E7%90%86%E8%A7%A3" ref="nofollow noopener noreferrer">三分钟理解：Redux → Zustand → Valtio 的演变</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fclaude.ai%2Fchat%2Fb05d6238-e287-40bb-b349-6f17a24857a9%232-%25E6%25A0%25B8%25E5%25BF%2583%25E4%25BD%2593%25E9%25AA%258C" target="_blank" title="https://claude.ai/chat/b05d6238-e287-40bb-b349-6f17a24857a9#2-%E6%A0%B8%E5%BF%83%E4%BD%93%E9%AA%8C" ref="nofollow noopener noreferrer">核心体验：一个计数器的三种写法</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fclaude.ai%2Fchat%2Fb05d6238-e287-40bb-b349-6f17a24857a9%233-%25E4%25B8%25BA%25E4%25BB%2580%25E4%25B9%2588%25E9%259C%2580%25E8%25A6%2581%25E5%25A2%259E%25E5%25BC%25BA%25E7%2589%2588" target="_blank" title="https://claude.ai/chat/b05d6238-e287-40bb-b349-6f17a24857a9#3-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%A2%9E%E5%BC%BA%E7%89%88" ref="nofollow noopener noreferrer">为什么需要增强版？原版 Valtio 的"最后一公里"</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fclaude.ai%2Fchat%2Fb05d6238-e287-40bb-b349-6f17a24857a9%234-%25E5%25AE%259E%25E6%2588%2598%25E5%25AF%25B9%25E6%25AF%2594" target="_blank" title="https://claude.ai/chat/b05d6238-e287-40bb-b349-6f17a24857a9#4-%E5%AE%9E%E6%88%98%E5%AF%B9%E6%AF%94" ref="nofollow noopener noreferrer">实战对比：同一个功能，代码量差多少？</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fclaude.ai%2Fchat%2Fb05d6238-e287-40bb-b349-6f17a24857a9%235-%25E8%25AF%25BB%25E5%2586%2599%25E9%2593%2581%25E5%25BE%258B" target="_blank" title="https://claude.ai/chat/b05d6238-e287-40bb-b349-6f17a24857a9#5-%E8%AF%BB%E5%86%99%E9%93%81%E5%BE%8B" ref="nofollow noopener noreferrer">读写铁律：snap 和 store 不能混用</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fclaude.ai%2Fchat%2Fb05d6238-e287-40bb-b349-6f17a24857a9%236-%25E5%2586%2585%25E5%25BB%25BA%25E6%25AD%25A6%25E5%2599%25A8%25E5%25BA%2593" target="_blank" title="https://claude.ai/chat/b05d6238-e287-40bb-b349-6f17a24857a9#6-%E5%86%85%E5%BB%BA%E6%AD%A6%E5%99%A8%E5%BA%93" ref="nofollow noopener noreferrer">内建武器库：17 个方法全解析</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fclaude.ai%2Fchat%2Fb05d6238-e287-40bb-b349-6f17a24857a9%237-%25E5%2585%25A8%25E5%25B1%2580-vs-%25E5%25B1%2580%25E9%2583%25A8" target="_blank" title="https://claude.ai/chat/b05d6238-e287-40bb-b349-6f17a24857a9#7-%E5%85%A8%E5%B1%80-vs-%E5%B1%80%E9%83%A8" ref="nofollow noopener noreferrer">全局 vs 局部：什么时候用哪个？</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fclaude.ai%2Fchat%2Fb05d6238-e287-40bb-b349-6f17a24857a9%238-%25E5%25BE%25AE%25E5%2589%258D%25E7%25AB%25AF%25E5%259C%25BA%25E6%2599%25AF" target="_blank" title="https://claude.ai/chat/b05d6238-e287-40bb-b349-6f17a24857a9#8-%E5%BE%AE%E5%89%8D%E7%AB%AF%E5%9C%BA%E6%99%AF" ref="nofollow noopener noreferrer">微前端场景：像传普通 props 一样传 store</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fclaude.ai%2Fchat%2Fb05d6238-e287-40bb-b349-6f17a24857a9%239-%25E9%2581%25BF%25E5%259D%2591%25E6%258C%2587%25E5%258D%2597" target="_blank" title="https://claude.ai/chat/b05d6238-e287-40bb-b349-6f17a24857a9#9-%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97" ref="nofollow noopener noreferrer">避坑指南：5 个新手常犯错误</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fclaude.ai%2Fchat%2Fb05d6238-e287-40bb-b349-6f17a24857a9%2310-%25E5%25BF%25AB%25E9%2580%259F%25E5%2586%25B3%25E7%25AD%2596%25E8%25A1%25A8" target="_blank" title="https://claude.ai/chat/b05d6238-e287-40bb-b349-6f17a24857a9#10-%E5%BF%AB%E9%80%9F%E5%86%B3%E7%AD%96%E8%A1%A8" ref="nofollow noopener noreferrer">快速决策表：30 秒选对方案</a></li>
</ol>
<hr/>
<h2 data-id="heading-1">1. 三分钟理解</h2>
<h3 data-id="heading-2">React 状态管理的三代演变</h3>
<p>想象你在管理一家奶茶店的库存：</p>
<p><strong>Redux（第一代）—— 严格的仓库管理制度</strong></p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-comment">// 每次改库存都要填表、盖章、走流程</span>
<span class="hljs-title function_ invoke__">dispatch</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">'UPDATE_MILK_TEA'</span>, <span class="hljs-attr">payload</span>: { <span class="hljs-attr">count</span>: <span class="hljs-number">10</span> } })
<span class="hljs-comment">// 优点：流程清晰，适合大团队协作</span>
<span class="hljs-comment">// 缺点：改个数字要写三个文件（action、reducer、connect）</span>
</code></pre>
<p><strong>Zustand（第二代）—— 简化的库存本子</strong></p>
<pre><code class="hljs language-dart" lang="dart"><span class="hljs-comment">// 把表格简化成一个记账本</span>
<span class="hljs-keyword">const</span> useStore = create(<span class="hljs-keyword">set</span> =&gt; ({
  count: <span class="hljs-number">0</span>,
  increase: () =&gt; <span class="hljs-keyword">set</span>(state =&gt; ({ count: state.count + <span class="hljs-number">1</span> }))
}))
<span class="hljs-comment">// 优点：只要一个文件，API 很少</span>
<span class="hljs-comment">// 缺点：还是要定义"动作函数"，不能直接改数字</span>
</code></pre>
<p><strong>Valtio（第三代）—— 像改普通变量一样</strong></p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-comment">// 就像在白板上直接擦掉旧数字写新数字</span>
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">state</span> = <span class="hljs-title function_ invoke__">proxy</span>({ <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> })
state.count++  <span class="hljs-comment">// 就这么简单！UI 自动更新</span>
<span class="hljs-comment">// 优点：最接近 Vue 的 reactive，零学习成本</span>
<span class="hljs-comment">// 缺点：太"自由"了，缺少统一管理</span>
</code></pre>
<h3 data-id="heading-3">为什么 Vue 开发者会爱上它？</h3>
<p>如果你熟悉 Vue 3 的 <code>reactive</code>，那么 Valtio 的 <code>proxy</code> 几乎是同一个概念：</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-comment">&lt;!-- Vue 3 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>({ <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> })
state.<span class="hljs-property">count</span>++  <span class="hljs-comment">// 直接改，视图自动更新</span>
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<pre><code class="hljs language-php" lang="php"><span class="hljs-comment">// Valtio (React)</span>
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">state</span> = <span class="hljs-title function_ invoke__">proxy</span>({ <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> })
state.count++  <span class="hljs-comment">// 同样直接改，组件自动重渲染</span>
</code></pre>
<p>两者底层都用了 JavaScript 的 <code>Proxy</code> 机制来追踪变化，这就是为什么 Valtio 常被称为"React 世界的 Vue 响应式"。</p>
<hr/>
<h2 data-id="heading-4">2. 核心体验</h2>
<h3 data-id="heading-5">同一个计数器，三种库的写法</h3>
<p><strong>Redux Toolkit（约 20 行）</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// store.ts</span>
<span class="hljs-keyword">import</span> { createSlice } <span class="hljs-keyword">from</span> <span class="hljs-string">'@reduxjs/toolkit'</span>
<span class="hljs-keyword">const</span> counterSlice = <span class="hljs-title function_">createSlice</span>({
  <span class="hljs-attr">name</span>: <span class="hljs-string">'counter'</span>,
  <span class="hljs-attr">initialState</span>: { <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> },
  <span class="hljs-attr">reducers</span>: { <span class="hljs-attr">increment</span>: <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> { state.<span class="hljs-property">count</span> += <span class="hljs-number">1</span> } }
})

<span class="hljs-comment">// 组件</span>
<span class="hljs-keyword">import</span> { useSelector, useDispatch } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-redux'</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">useSelector</span>(<span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> state.<span class="hljs-property">counter</span>.<span class="hljs-property">count</span>)
  <span class="hljs-keyword">const</span> dispatch = <span class="hljs-title function_">useDispatch</span>()
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> dispatch(increment())}&gt;
    {count}
  <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
}
</code></pre>
<p><strong>Zustand（约 12 行）</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> { create } <span class="hljs-keyword">from</span> <span class="hljs-string">'zustand'</span>
<span class="hljs-keyword">const</span> useStore = <span class="hljs-title function_">create</span>(<span class="hljs-function"><span class="hljs-params">set</span> =&gt;</span> ({
  <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,
  <span class="hljs-attr">increment</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">set</span>(<span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> ({ <span class="hljs-attr">count</span>: state.<span class="hljs-property">count</span> + <span class="hljs-number">1</span> }))
}))

<span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> { count, increment } = <span class="hljs-title function_">useStore</span>()
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{increment}</span>&gt;</span>{count}<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
}
</code></pre>
<p><strong>@empjs/valtio（约 7 行）</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> { createStore } <span class="hljs-keyword">from</span> <span class="hljs-string">'@empjs/valtio'</span>
<span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>({ <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> })

<span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> snap = store.<span class="hljs-title function_">useSnapshot</span>()
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> store.set('count', snap.count + 1)}&gt;
    {snap.count}
  <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
}
</code></pre>
<h3 data-id="heading-6">量化对比</h3>



































<table><thead><tr><th>指标</th><th align="center">Redux Toolkit</th><th align="center">Zustand</th><th align="center">@empjs/valtio</th></tr></thead><tbody><tr><td><strong>代码行数</strong></td><td align="center">~20 行</td><td align="center">~12 行</td><td align="center"><strong>~7 行</strong></td></tr><tr><td><strong>需要定义"动作"</strong></td><td align="center">是（reducer）</td><td align="center">是（函数）</td><td align="center"><strong>否</strong></td></tr><tr><td><strong>TypeScript 类型推断</strong></td><td align="center">需手写 RootState</td><td align="center">需手写泛型</td><td align="center"><strong>自动推导</strong></td></tr><tr><td><strong>添加撤销/重做</strong></td><td align="center">装 redux-undo</td><td align="center">自己实现</td><td align="center"><strong>1 行配置</strong></td></tr></tbody></table>
<hr/>
<h2 data-id="heading-7">3. 为什么需要增强版？</h2>
<h3 data-id="heading-8">原版 Valtio 的优势与边界</h3>
<p>原版 Valtio 只有两个核心 API：</p>
<ul>
<li><code>proxy(data)</code> — 创建响应式对象</li>
<li><code>useSnapshot(state)</code> — 在组件里读取数据</li>
</ul>
<p>这种极简主义是优点也是局限：</p>
<p><strong>优点：</strong> 学习成本几乎为零，写起来最自然<br/>
<strong>局限：</strong> 生产环境需要的"工程化能力"都要自己加</p>
<h3 data-id="heading-9">原版缺失的"最后一公里"</h3>



































<table><thead><tr><th>缺失的能力</th><th>原版方案</th><th>@empjs/valtio 方案</th></tr></thead><tbody><tr><td><strong>统一写入口</strong></td><td>自己封装 <code>set</code>/<code>update</code> 函数</td><td><code>createStore</code> 内建 17 个方法</td></tr><tr><td><strong>撤销/重做</strong></td><td>装 <code>valtio-history</code> 并手动接入</td><td><code>createStore({ history })</code> 一行开启</td></tr><tr><td><strong>计算属性</strong></td><td>装 <code>derive-valtio</code> 并配置</td><td><code>createStore({ derive })</code> 自动计算</td></tr><tr><td><strong>本地存储</strong></td><td>自己写 <code>localStorage</code> 逻辑</td><td><code>store.persist('key')</code> 一行搞定</td></tr><tr><td><strong>多实例隔离</strong></td><td><code>useRef(proxy(...))</code> + 手动清理</td><td><code>useStore(init)</code> 自动管理生命周期</td></tr></tbody></table>
<h3 data-id="heading-10">典型痛点场景</h3>
<p><strong>场景 1：想加个"撤销"功能</strong></p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-comment">// 原版：需要安装新包 + 多处改造</span>
npm install valtio-history
import { proxyWithHistory } <span class="hljs-keyword">from</span> <span class="hljs-string">'valtio-history'</span>
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">state</span> = <span class="hljs-title function_ invoke__">proxyWithHistory</span>({ <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> })
<span class="hljs-comment">// 然后在组件里手动调 state.value.count、state.undo()</span>

<span class="hljs-comment">// 增强版：配置一下就行</span>
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">store</span> = <span class="hljs-title function_ invoke__">createStore</span>({ <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> }, { <span class="hljs-attr">history</span>: <span class="hljs-literal">true</span> })
snap.<span class="hljs-title function_ invoke__">undo</span>()  <span class="hljs-comment">// 直接用</span>
</code></pre>
<p><strong>场景 2：表单需要"全名"自动拼接</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 原版：需要装 derive-valtio + 单独维护派生逻辑</span>
npm install derive-valtio
<span class="hljs-keyword">import</span> { derive } <span class="hljs-keyword">from</span> <span class="hljs-string">'derive-valtio'</span>
<span class="hljs-keyword">const</span> derived = <span class="hljs-title function_">derive</span>({ <span class="hljs-attr">fullName</span>: <span class="hljs-function"><span class="hljs-params">get</span> =&gt;</span> ... })

<span class="hljs-comment">// 增强版：写在配置里</span>
<span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(
  { <span class="hljs-attr">firstName</span>: <span class="hljs-string">''</span>, <span class="hljs-attr">lastName</span>: <span class="hljs-string">''</span> },
  {
    <span class="hljs-attr">derive</span>: <span class="hljs-function">(<span class="hljs-params">get, p</span>) =&gt;</span> ({
      <span class="hljs-attr">fullName</span>: <span class="hljs-string">`<span class="hljs-subst">${get(p).firstName}</span> <span class="hljs-subst">${get(p).lastName}</span>`</span>.<span class="hljs-title function_">trim</span>()
    })
  }
)
</code></pre>
<hr/>
<h2 data-id="heading-11">4. 实战对比</h2>
<h3 data-id="heading-12">案例：用户信息表单（带撤销、计算属性、持久化）</h3>
<p><strong>原版 Valtio（约 35 行）</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// ① 安装依赖</span>
<span class="hljs-comment">// npm install valtio valtio-history derive-valtio</span>

<span class="hljs-comment">// ② 创建状态</span>
<span class="hljs-keyword">import</span> { proxy } <span class="hljs-keyword">from</span> <span class="hljs-string">'valtio'</span>
<span class="hljs-keyword">import</span> { proxyWithHistory } <span class="hljs-keyword">from</span> <span class="hljs-string">'valtio-history'</span>
<span class="hljs-keyword">const</span> state = <span class="hljs-title function_">proxyWithHistory</span>({ <span class="hljs-attr">firstName</span>: <span class="hljs-string">''</span>, <span class="hljs-attr">lastName</span>: <span class="hljs-string">''</span> })

<span class="hljs-comment">// ③ 手写派生逻辑</span>
<span class="hljs-keyword">import</span> { derive } <span class="hljs-keyword">from</span> <span class="hljs-string">'derive-valtio'</span>
<span class="hljs-keyword">const</span> derived = <span class="hljs-title function_">derive</span>({
  <span class="hljs-attr">fullName</span>: <span class="hljs-function"><span class="hljs-params">get</span> =&gt;</span> 
    <span class="hljs-string">`<span class="hljs-subst">${get(state.value).firstName}</span> <span class="hljs-subst">${get(state.value).lastName}</span>`</span>.<span class="hljs-title function_">trim</span>()
})

<span class="hljs-comment">// ④ 手写持久化</span>
<span class="hljs-keyword">import</span> { useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">const</span> saved = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">'user'</span>)
  <span class="hljs-keyword">if</span> (saved) <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(state.<span class="hljs-property">value</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(saved))
  <span class="hljs-keyword">const</span> unsub = <span class="hljs-title function_">subscribe</span>(state, <span class="hljs-function">() =&gt;</span> 
    <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">'user'</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(state.<span class="hljs-property">value</span>))
  )
  <span class="hljs-keyword">return</span> unsub
}, [])

<span class="hljs-comment">// ⑤ 组件使用</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Form</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> snap = <span class="hljs-title function_">useSnapshot</span>(state)
  <span class="hljs-keyword">const</span> derivedSnap = <span class="hljs-title function_">useSnapshot</span>(derived)
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{snap.value.firstName}</span> 
             <span class="hljs-attr">onChange</span>=<span class="hljs-string">{e</span> =&gt;</span> state.value.firstName = e.target.value} /&gt;
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>全名：{derivedSnap.fullName}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> snap.undo()}&gt;撤销<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/&gt;</span></span>
  )
}
</code></pre>
<p><strong>@empjs/valtio（约 18 行）</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// ① 一次性配置</span>
<span class="hljs-keyword">import</span> { createStore } <span class="hljs-keyword">from</span> <span class="hljs-string">'@empjs/valtio'</span>

<span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(
  { <span class="hljs-attr">firstName</span>: <span class="hljs-string">''</span>, <span class="hljs-attr">lastName</span>: <span class="hljs-string">''</span> },
  {
    <span class="hljs-attr">history</span>: { <span class="hljs-attr">limit</span>: <span class="hljs-number">50</span> },  <span class="hljs-comment">// 撤销功能</span>
    <span class="hljs-attr">derive</span>: <span class="hljs-function">(<span class="hljs-params">get, p</span>) =&gt;</span> ({    <span class="hljs-comment">// 计算属性</span>
      <span class="hljs-attr">fullName</span>: <span class="hljs-string">`<span class="hljs-subst">${get(p).firstName}</span> <span class="hljs-subst">${get(p).lastName}</span>`</span>.<span class="hljs-title function_">trim</span>()
    })
  }
)
store.<span class="hljs-title function_">persist</span>(<span class="hljs-string">'user-form'</span>)   <span class="hljs-comment">// 持久化</span>

<span class="hljs-comment">// ② 直接用</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Form</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> snap = store.<span class="hljs-title function_">useSnapshot</span>()
  <span class="hljs-keyword">const</span> derived = store.<span class="hljs-property">derived</span>.<span class="hljs-title function_">useSnapshot</span>()
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{snap.value.firstName}</span>
             <span class="hljs-attr">onChange</span>=<span class="hljs-string">{e</span> =&gt;</span> store.value.firstName = e.target.value} /&gt;
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>全名：{derived.fullName}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> snap.undo()}&gt;撤销<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/&gt;</span></span>
  )
}
</code></pre>
<h3 data-id="heading-13">代码量对比</h3>





























<table><thead><tr><th>维度</th><th align="center">原版</th><th align="center">增强版</th><th align="center">减少</th></tr></thead><tbody><tr><td><strong>总行数</strong></td><td align="center">~35 行</td><td align="center">~18 行</td><td align="center"><strong>48%</strong></td></tr><tr><td><strong>需要安装的包</strong></td><td align="center">3 个</td><td align="center">1 个</td><td align="center"><strong>66%</strong></td></tr><tr><td><strong>接入步骤</strong></td><td align="center">5 步</td><td align="center">1 步</td><td align="center"><strong>80%</strong></td></tr></tbody></table>
<hr/>
<h2 data-id="heading-14">5. 读写铁律</h2>
<blockquote>
<p><strong>记住一句话：读用 snap，写用 store。</strong> 这不是代码风格，是响应式系统的硬性要求。</p>
</blockquote>
<h3 data-id="heading-15">为什么有这个规则？</h3>
<p>Valtio 的响应式依赖 React 的 <code>useSnapshot</code> 来收集"谁用了哪些字段"。直接读 <code>store.xxx</code> 不会触发这个收集机制，组件就不会在数据变化时重新渲染。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// ❌ 错误：读 store 不会触发重渲染</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Bad</span>(<span class="hljs-params"/>) {
  store.<span class="hljs-title function_">useSnapshot</span>()  <span class="hljs-comment">// 虽然调了 hook，但没用返回值</span>
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>{store.count}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span>  <span class="hljs-comment">// 读的是 proxy，不是 snap</span>
  <span class="hljs-comment">// 结果：count 变了，页面不更新</span>
}

<span class="hljs-comment">// ✅ 正确：读 snap，写 store</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Good</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> snap = store.<span class="hljs-title function_">useSnapshot</span>()
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>{snap.count}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>  {/* 读 snap */}
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> store.set('count', snap.count + 1)}&gt;  {/* 写 store */}
        +1
      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/&gt;</span></span>
  )
}
</code></pre>
<h3 data-id="heading-16">带历史功能时的规则</h3>
<p>如果开启了 <code>history</code> 配置，状态会被包在 <code>.value</code> 里：</p>

























<table><thead><tr><th>操作</th><th>写法</th></tr></thead><tbody><tr><td><strong>读当前值</strong></td><td><code>snap.value.firstName</code></td></tr><tr><td><strong>写入新值</strong></td><td><code>store.value.firstName = 'Alice'</code></td></tr><tr><td><strong>撤销</strong></td><td><code>snap.undo()</code></td></tr><tr><td><strong>重做</strong></td><td><code>snap.redo()</code></td></tr></tbody></table>
<h3 data-id="heading-17">用类型保证不犯错</h3>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">import</span> { <span class="hljs-keyword">type</span> <span class="hljs-title class_">EmpStore</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@empjs/valtio'</span>

<span class="hljs-keyword">const</span> initialState = { <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">''</span> }
<span class="hljs-keyword">type</span> <span class="hljs-title class_">State</span> = <span class="hljs-keyword">typeof</span> initialState

<span class="hljs-comment">// 子组件只依赖这个类型，TypeScript 会强制你用 store 的方法</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> <span class="hljs-title class_">Store</span> = <span class="hljs-title class_">EmpStore</span>&lt;<span class="hljs-title class_">State</span>&gt;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">ChildComponent</span>(<span class="hljs-params">{ store }: { store: Store }</span>) {
  <span class="hljs-keyword">const</span> snap = store.<span class="hljs-title function_">useSnapshot</span>()
  <span class="hljs-comment">// snap.count = 1  // ❌ TypeScript 报错：snap 是只读的</span>
  store.<span class="hljs-title function_">set</span>(<span class="hljs-string">'count'</span>, <span class="hljs-number">1</span>)  <span class="hljs-comment">// ✅ 必须通过 store 的方法</span>
}
</code></pre>
<hr/>
<h2 data-id="heading-18">6. 内建武器库</h2>
<p><code>createStore</code> / <code>useStore</code> 返回的对象有 <strong>17 个方法</strong>，分四大类：</p>
<h3 data-id="heading-19">📖 读取类（3 个）</h3>

























<table><thead><tr><th>方法</th><th>用途</th><th>示例</th></tr></thead><tbody><tr><td><code>useSnapshot()</code></td><td>组件内读取数据（Hook）</td><td><code>const snap = store.useSnapshot()</code></td></tr><tr><td><code>getSnapshot()</code></td><td>非组件场景读取（如回调）</td><td><code>console.log(store.getSnapshot())</code></td></tr><tr><td><code>toJSON()</code></td><td>序列化为纯对象</td><td><code>const data = store.toJSON()</code></td></tr></tbody></table>
<h3 data-id="heading-20">✏️ 写入类（6 个）</h3>








































<table><thead><tr><th>方法</th><th>用途</th><th>示例</th></tr></thead><tbody><tr><td><code>set(key, value)</code></td><td>改单个字段</td><td><code>store.set('count', 10)</code></td></tr><tr><td><code>update(partial)</code></td><td>批量改多个字段</td><td><code>store.update({ count: 10, name: 'Alice' })</code></td></tr><tr><td><code>setNested(path, value)</code></td><td>改深层路径</td><td><code>store.setNested('user.address.city', '北京')</code></td></tr><tr><td><code>delete(key)</code></td><td>删除某个字段</td><td><code>store.delete('tempData')</code></td></tr><tr><td><code>reset(state?)</code></td><td>重置为初始状态</td><td><code>store.reset()</code></td></tr><tr><td><code>fromJSON(json)</code></td><td>从对象恢复状态</td><td><code>store.fromJSON(savedData)</code></td></tr></tbody></table>
<h3 data-id="heading-21">👂 订阅类（3 个）</h3>

























<table><thead><tr><th>方法</th><th>用途</th><th>示例</th></tr></thead><tbody><tr><td><code>subscribe(fn)</code></td><td>监听所有变化</td><td><code>store.subscribe(() =&gt; console.log('变了'))</code></td></tr><tr><td><code>subscribeKey(key, fn)</code></td><td>只监听某个字段</td><td><code>store.subscribeKey('count', val =&gt; ...)</code></td></tr><tr><td><code>subscribeKeys(keys, fn)</code></td><td>监听多个字段</td><td><code>store.subscribeKeys(['a', 'b'], ...)</code></td></tr></tbody></table>
<h3 data-id="heading-22">🔧 工具类（5 个）</h3>



































<table><thead><tr><th>方法</th><th>用途</th><th>示例</th></tr></thead><tbody><tr><td><code>ref(value)</code></td><td>标记为非响应式（如 DOM）</td><td><code>store.set('dom', store.ref(divElement))</code></td></tr><tr><td><code>batch(fn)</code></td><td>批量更新，只触发一次渲染</td><td><code>store.batch(() =&gt; { ... })</code></td></tr><tr><td><code>clone()</code></td><td>深拷贝当前状态</td><td><code>const copy = store.clone()</code></td></tr><tr><td><code>persist(key)</code></td><td>开启 localStorage 持久化</td><td><code>store.persist('my-data')</code></td></tr><tr><td><code>debug()</code></td><td>在控制台打印每次变更</td><td><code>store.debug()</code></td></tr></tbody></table>
<hr/>
<h2 data-id="heading-23">7. 全局 vs 局部</h2>
<h3 data-id="heading-24">什么时候用 <code>createStore</code>（全局单例）？</h3>
<p><strong>特征：</strong> 数据需要跨组件共享，整个应用生命周期内只有一份</p>
<p><strong>典型场景：</strong></p>
<ul>
<li>当前登录用户信息</li>
<li>主题配置（深色/浅色模式）</li>
<li>全局加载状态</li>
<li>购物车数据</li>
</ul>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 在单独文件里创建</span>
<span class="hljs-keyword">import</span> { createStore } <span class="hljs-keyword">from</span> <span class="hljs-string">'@empjs/valtio'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> themeStore = <span class="hljs-title function_">createStore</span>({
  <span class="hljs-attr">mode</span>: <span class="hljs-string">'light'</span>,
  <span class="hljs-attr">primaryColor</span>: <span class="hljs-string">'#1890ff'</span>
})

<span class="hljs-comment">// 任何组件都可以用</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Header</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> snap = themeStore.<span class="hljs-title function_">useSnapshot</span>()
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">background:</span> <span class="hljs-attr">snap.primaryColor</span> }}&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
}
</code></pre>
<h3 data-id="heading-25">什么时候用 <code>useStore</code>（每实例独立）？</h3>
<p><strong>特征：</strong> 每个组件实例需要自己的独立状态，互不干扰</p>
<p><strong>典型场景：</strong></p>
<ul>
<li>表单（页面上可能有多个表单）</li>
<li>代码编辑器（每个 Tab 一个编辑器）</li>
<li>画板工具（多画布场景）</li>
<li>计数器组件（同页面多个实例）</li>
</ul>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> { useStore } <span class="hljs-keyword">from</span> <span class="hljs-string">'@empjs/valtio'</span>

<span class="hljs-keyword">function</span> <span class="hljs-title function_">FormBlock</span>(<span class="hljs-params">{ initialLabel }: { initialLabel: string }</span>) {
  <span class="hljs-comment">// 每个 &lt;FormBlock&gt; 实例都有自己的 store</span>
  <span class="hljs-keyword">const</span> [snap, store] = <span class="hljs-title function_">useStore</span>({ <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">label</span>: initialLabel })
  
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{snap.label}: {snap.count}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> store.set('count', snap.count + 1)}&gt;
        +1
      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> store.reset()}&gt;重置<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  )
}

<span class="hljs-comment">// 两个实例，状态完全隔离</span>
&lt;<span class="hljs-title class_">FormBlock</span> initialLabel=<span class="hljs-string">"表单 A"</span> /&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">FormBlock</span> <span class="hljs-attr">initialLabel</span>=<span class="hljs-string">"表单 B"</span> /&gt;</span></span>
</code></pre>
<h3 data-id="heading-26">惰性初始化（适合昂贵计算）</h3>
<pre><code class="hljs language-less" lang="less"><span class="hljs-comment">// 传函数而不是对象，只有第一次渲染时才执行</span>
<span class="hljs-selector-tag">const</span> <span class="hljs-selector-attr">[snap, store]</span> = <span class="hljs-selector-tag">useStore</span>(() =&gt; ({
  <span class="hljs-attribute">data</span>: <span class="hljs-built_in">expensiveComputation</span>(),  <span class="hljs-comment">// 只在组件挂载时算一次</span>
  <span class="hljs-attribute">timestamp</span>: Date.<span class="hljs-built_in">now</span>()
}))
</code></pre>
<hr/>
<h2 data-id="heading-27">8. 微前端场景</h2>
<h3 data-id="heading-28">传统方案的问题</h3>





















<table><thead><tr><th>方案</th><th>问题</th></tr></thead><tbody><tr><td><strong>全局单例</strong></td><td>子应用和主应用版本不一致就炸，构建顺序有依赖</td></tr><tr><td><strong>事件总线</strong></td><td>类型弱，调试困难，边界不清晰</td></tr><tr><td><strong>postMessage</strong></td><td>只能传序列化数据，丢失类型和方法</td></tr></tbody></table>
<h3 data-id="heading-29">@empjs/valtio 的方案：当普通 prop 传</h3>
<p><strong>核心思想：</strong> store 本身就是一个普通对象，可以像任何 React props 一样传递</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// ===== 共享类型定义（放在独立的 npm 包里） =====</span>
<span class="hljs-keyword">import</span> { <span class="hljs-keyword">type</span> <span class="hljs-title class_">EmpStore</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@empjs/valtio'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> initialState = { <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'shared'</span>, <span class="hljs-attr">loading</span>: <span class="hljs-literal">false</span> }
<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> <span class="hljs-title class_">State</span> = <span class="hljs-keyword">typeof</span> initialState
<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> <span class="hljs-title class_">SharedStore</span> = <span class="hljs-title class_">EmpStore</span>&lt;<span class="hljs-title class_">State</span>&gt;

<span class="hljs-comment">// ===== 主应用（主机） =====</span>
<span class="hljs-keyword">import</span> { useStore } <span class="hljs-keyword">from</span> <span class="hljs-string">'@empjs/valtio'</span>
<span class="hljs-keyword">import</span> { initialState, <span class="hljs-keyword">type</span> <span class="hljs-title class_">SharedStore</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@my-company/shared-types'</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">RemoteChild</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'remote-app/Child'</span>  <span class="hljs-comment">// Module Federation</span>

<span class="hljs-keyword">function</span> <span class="hljs-title function_">Host</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> [snap, store] = useStore&lt;<span class="hljs-title class_">State</span>&gt;(initialState)
  
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>主应用<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>主应用的计数：{snap.count}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      
      {/* 像普通 prop 一样传给子应用 */}
      <span class="hljs-tag">&lt;<span class="hljs-name">RemoteChild</span> <span class="hljs-attr">store</span>=<span class="hljs-string">{store}</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  )
}

<span class="hljs-comment">// ===== 子应用（独立构建，独立部署） =====</span>
<span class="hljs-keyword">import</span> { <span class="hljs-keyword">type</span> <span class="hljs-title class_">SharedStore</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@my-company/shared-types'</span>

<span class="hljs-keyword">function</span> <span class="hljs-title function_">RemoteChild</span>(<span class="hljs-params">{ store }: { store: SharedStore }</span>) {
  <span class="hljs-keyword">const</span> snap = store.<span class="hljs-title function_">useSnapshot</span>()
  
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>子应用<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>看到的主应用数据：{snap.count}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> store.set('count', snap.count + 1)}&gt;
        子应用也能改
      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  )
}
</code></pre>
<h3 data-id="heading-30">为什么这样好？</h3>

























<table><thead><tr><th>优势</th><th>说明</th></tr></thead><tbody><tr><td><strong>零耦合</strong></td><td>子应用不需要知道主应用的运行时，只依赖类型定义</td></tr><tr><td><strong>类型安全</strong></td><td>TypeScript 全程保护，改了类型定义，双方都能感知</td></tr><tr><td><strong>调试简单</strong></td><td>就是普通的 props，React DevTools 直接能看</td></tr><tr><td><strong>版本独立</strong></td><td>主应用升级不影响子应用，子应用可以独立发版</td></tr></tbody></table>
<h3 data-id="heading-31">状态层次示意图</h3>
<pre><code class="hljs language-css" lang="css">主应用
├── 全局 store（createStore）
│   ├── 用户信息
│   └── 主题配置
│       └── 通过 props 传给子应用 ──┐
│                                   ↓
└── 子应用 <span class="hljs-selector-tag">A</span>                     接收 store
    ├── 使用主应用的 store（共享状态）
    └── 自己的 store（useStore）
        ├── 表单数据（局部）
        └── 编辑器状态（局部）
</code></pre>
<hr/>
<h2 data-id="heading-32">9. 避坑指南</h2>
<h3 data-id="heading-33">❌ 错误 1：读 store 而不是 snap</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 错误</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Bad</span>(<span class="hljs-params"/>) {
  store.<span class="hljs-title function_">useSnapshot</span>()  <span class="hljs-comment">// 虽然调了，但没用返回值</span>
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>{store.count}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span>  <span class="hljs-comment">// 不会触发重渲染</span>
}

<span class="hljs-comment">// 正确</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Good</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> snap = store.<span class="hljs-title function_">useSnapshot</span>()
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>{snap.count}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span>
}
</code></pre>
<p><strong>为什么错：</strong> Valtio 的响应式机制依赖 <code>useSnapshot</code> 的返回值来追踪"谁读了哪些字段"，直接读 <code>store</code> 不会被追踪。</p>
<h3 data-id="heading-34">❌ 错误 2：键名和方法重名</h3>
<pre><code class="hljs language-dart" lang="dart"><span class="hljs-comment">// 错误：键名叫 set，和 store.set() 冲突</span>
<span class="hljs-keyword">const</span> store = createStore({
  <span class="hljs-keyword">set</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(),  <span class="hljs-comment">// ❌ 冲突！</span>
  update: <span class="hljs-number">123</span>      <span class="hljs-comment">// ❌ 也冲突！</span>
})

<span class="hljs-comment">// 正确：换个名字</span>
<span class="hljs-keyword">const</span> store = createStore({
  tagSet: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(),  <span class="hljs-comment">// ✅</span>
  version: <span class="hljs-number">123</span>        <span class="hljs-comment">// ✅</span>
})
</code></pre>
<p><strong>为什么错：</strong> <code>store.set</code> / <code>store.update</code> 是内建方法，用同名键会被覆盖。</p>
<h3 data-id="heading-35">❌ 错误 3：传非 proxy 对象给 useSnapshot</h3>
<pre><code class="hljs language-php" lang="php"><span class="hljs-comment">// 错误</span>
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">plainObj</span> = { count: <span class="hljs-number">0</span> }
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">snap</span> = <span class="hljs-title function_ invoke__">useSnapshot</span>(plainObj)  <span class="hljs-comment">// ❌ 报错</span>

<span class="hljs-comment">// 正确</span>
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">store</span> = <span class="hljs-title function_ invoke__">createStore</span>({ <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> })
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">snap</span> = store.<span class="hljs-title function_ invoke__">useSnapshot</span>()  <span class="hljs-comment">// ✅</span>
</code></pre>
<p><strong>报错信息：</strong> "Please use proxy object"</p>
<h3 data-id="heading-36">❌ 错误 4：在 derive 里写副作用</h3>
<pre><code class="hljs language-dart" lang="dart"><span class="hljs-comment">// 错误</span>
<span class="hljs-keyword">const</span> store = createStore(
  { a: <span class="hljs-number">1</span>, b: <span class="hljs-number">2</span> },
  {
    derive: (<span class="hljs-keyword">get</span>, p) =&gt; {
      console.log(<span class="hljs-string">'计算中'</span>)  <span class="hljs-comment">// ❌ 副作用</span>
      fetch(<span class="hljs-string">'/api'</span>)          <span class="hljs-comment">// ❌ 异步请求</span>
      <span class="hljs-keyword">return</span> { sum: <span class="hljs-keyword">get</span>(p).a + <span class="hljs-keyword">get</span>(p).b }
    }
  }
)

<span class="hljs-comment">// 正确</span>
<span class="hljs-keyword">const</span> store = createStore(
  { a: <span class="hljs-number">1</span>, b: <span class="hljs-number">2</span> },
  {
    derive: (<span class="hljs-keyword">get</span>, p) =&gt; ({
      sum: <span class="hljs-keyword">get</span>(p).a + <span class="hljs-keyword">get</span>(p).b  <span class="hljs-comment">// ✅ 纯计算</span>
    })
  }
)
</code></pre>
<p><strong>为什么错：</strong> <code>derive</code> 会被频繁调用（每次依赖变化都调），副作用会重复执行且难以控制。</p>
<h3 data-id="heading-37">❌ 错误 5：忘记 .value（开启历史功能时）</h3>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-comment">// 开启历史后，状态被包在 .value 里</span>
<span class="hljs-type">const</span> store = <span class="hljs-built_in">createStore</span>({ count: <span class="hljs-number">0</span> }, { history: <span class="hljs-literal">true</span> })

<span class="hljs-comment">// 错误</span>
<span class="hljs-type">const</span> snap = store.<span class="hljs-built_in">useSnapshot</span>()
console.<span class="hljs-built_in">log</span>(snap.count)  <span class="hljs-comment">// ❌ undefined</span>

<span class="hljs-comment">// 正确</span>
<span class="hljs-type">const</span> snap = store.<span class="hljs-built_in">useSnapshot</span>()
console.<span class="hljs-built_in">log</span>(snap.value.count)  <span class="hljs-comment">// ✅</span>
store.value.count++             <span class="hljs-comment">// ✅ 写入也要加 .value</span>
</code></pre>
<hr/>
<h2 data-id="heading-38">10. 快速决策表</h2>























































<table><thead><tr><th>你的场景</th><th>推荐方案</th><th>示例代码</th></tr></thead><tbody><tr><td><strong>全局配置（主题/语言/用户）</strong></td><td><code>createStore</code></td><td><code>const themeStore = createStore({ mode: 'light' })</code></td></tr><tr><td><strong>多个独立表单</strong></td><td><code>useStore</code></td><td><code>const [snap, store] = useStore({ name: '' })</code></td></tr><tr><td><strong>需要撤销/重做</strong></td><td><code>createStore</code> + <code>history</code></td><td><code>createStore(init, { history: { limit: 50 } })</code></td></tr><tr><td><strong>需要计算属性（如全名）</strong></td><td><code>createStore</code> + <code>derive</code></td><td><code>createStore(init, { derive: (get, p) =&gt; ({ ... }) })</code></td></tr><tr><td><strong>需要本地持久化</strong></td><td>任意 store + <code>.persist()</code></td><td><code>store.persist('my-data-key')</code></td></tr><tr><td><strong>微前端：主应用 → 子应用</strong></td><td>主应用 <code>useStore</code>，props 传入</td><td><code>&lt;RemoteChild store={store} /&gt;</code></td></tr><tr><td><strong>微前端：子应用内部</strong></td><td>子应用自行 <code>useStore</code></td><td>与主应用完全隔离</td></tr><tr><td><strong>批量更新避免多次渲染</strong></td><td><code>store.batch()</code></td><td><code>store.batch(() =&gt; { store.set(...); store.set(...) })</code></td></tr><tr><td><strong>表单多次改值卡顿</strong></td><td><code>store.batch()</code></td><td>输入框 onChange 里包一层 batch</td></tr></tbody></table>
<hr/>
<h2 data-id="heading-39">总结：三句话记住 @empjs/valtio</h2>
<ol>
<li><strong>像 Vue 一样写 React 状态</strong> —— <code>state.count++</code> 就能自动更新 UI</li>
<li><strong>从 4~5 步简化到 1 步</strong> —— 历史、计算属性、持久化都是一行配置</li>
<li><strong>微前端友好</strong> —— store 当普通 props 传，无需全局单例和事件总线</li>
</ol>
<hr/>
<p><strong>参考资料：</strong></p>
<ul>
<li>📚 官方文档：<a href="https://link.juejin.cn?target=https%3A%2F%2Fvaltio.empjs.dev%2F" target="_blank" title="https://valtio.empjs.dev/" ref="nofollow noopener noreferrer">valtio.empjs.dev</a></li>
<li>🔧 API 手册：<a href="https://link.juejin.cn?target=https%3A%2F%2Fvaltio.empjs.dev%2Fmanual" target="_blank" title="https://valtio.empjs.dev/manual" ref="nofollow noopener noreferrer">valtio.empjs.dev/manual</a></li>
<li>🐙 GitHub：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FefoxTeam%2Femp%2Ftree%2Fmain%2Fpackages%2Fvaltio" target="_blank" title="https://github.com/efoxTeam/emp/tree/main/packages/valtio" ref="nofollow noopener noreferrer">@empjs/valtio</a></li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[PHP 现在可以零成本构建原生 iOS 和 Android 应用 NativePHP for Mobile v3 发布]]></title>    <link>https://juejin.cn/post/7601843004958359598</link>    <guid>https://juejin.cn/post/7601843004958359598</guid>    <pubDate>2026-02-01T23:46:49.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7601843004958359598" data-draft-id="7601444617695608842" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="PHP 现在可以零成本构建原生 iOS 和 Android 应用 NativePHP for Mobile v3 发布"/> <meta itemprop="keywords" content="后端,PHP"/> <meta itemprop="datePublished" content="2026-02-01T23:46:49.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="BingoGo"/> <meta itemprop="url" content="https://juejin.cn/user/993614242266077"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            PHP 现在可以零成本构建原生 iOS 和 Android 应用 NativePHP for Mobile v3 发布
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/993614242266077/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    BingoGo
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-01T23:46:49.000Z" title="Sun Feb 01 2026 23:46:49 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-01
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">PHP 现在可以零成本构建原生 iOS 和 Android 应用 NativePHP for Mobile v3 发布</h2>
<p>NativePHP for Mobile 从 v3 版本开始，核心框架采用 MIT 协议免费开源。Laravel/PHP 开发者现在可以零成本构建原生 iOS 和 Android 应用。</p>
<p>如果使用 nativePHP 开发移动应用的话，可以看<a href="https://link.juejin.cn?target=https%3A%2F%2Fnativephp-doc.catchadmin.com" target="_blank" title="https://nativephp-doc.catchadmin.com" ref="nofollow noopener noreferrer">nativephp mobile v3 中文文档</a></p>
<h3 data-id="heading-1">插件化架构</h3>
<p>v3 版本最大的变化是引入了模块化插件系统。此前版本中集成在核心包里的原生功能，现在被拆分成独立的插件。</p>
<p>每个插件都是一个独立的 Composer 包，包含 Swift 和 Kotlin 代码、权限清单以及原生依赖。开发者只需安装实际用到的插件，这些插件会在构建过程中直接编译进应用。</p>
<p>插件安装非常简单，通过 <code>composer require</code> 安装包后，在 <code>NativeServiceProvider</code> 中注册即可。只有注册的插件才会被编译进最终的二进制文件，这样可以保持应用体积精简，也有助于通过应用商店审核。</p>
<h4 data-id="heading-2">创建插件</h4>
<p>插件本质上就是 Composer 包，只是多了一些额外配置。通过添加 <code>nativephp.json</code> 文件，开发者可以定义 PHP 类、视图文件、桥接函数、原生依赖（CocoaPods、Swift Packages、Gradle）、权限声明、JavaScript 文件等。</p>
<p>NativePHP 核心提供了构建钩子、生命周期钩子、服务提供者注册等机制，让插件开发体验更加顺畅。</p>
<p>插件可以发布到 Packagist，也可以作为项目内部代码使用，无需发布到公共仓库。这意味着应用的 Laravel 代码库可以包含构建原生应用所需的一切。</p>
<h3 data-id="heading-3">免费核心</h3>
<p>新架构将核心包精简到最小化，应用只需包含实际使用的功能。这让应用默认就更小、更高效，也避免了应用商店审核时因包含未使用功能而被拒的问题。</p>
<p>NativePHP 团队将 v3 版本命名为 NativePHP Air，并将其转为 MIT 开源协议。v3 之前的版本仍然遵循原有的 Business Source License。</p>
<p>核心框架开源后，社区可以参与贡献，团队欢迎针对 iOS 和 Android 核心应用的 PR。</p>
<h4 data-id="heading-4">免费插件</h4>
<p>以下插件完全免费开源（MIT 协议）：</p>
<ul>
<li><strong>Browser</strong> - 浏览器功能</li>
<li><strong>Camera</strong> - 相机调用</li>
<li><strong>Device</strong> - 设备信息获取</li>
<li><strong>Dialog</strong> - 原生对话框</li>
<li><strong>File</strong> - 文件操作</li>
<li><strong>Microphone</strong> - 麦克风调用</li>
<li><strong>Network</strong> - 网络状态检测</li>
<li><strong>Share</strong> - 系统分享功能</li>
<li><strong>System</strong> - 系统信息</li>
</ul>
<h4 data-id="heading-5">付费插件</h4>
<p>以下功能需要单独购买插件（一次性付费，可用于无限项目）：</p>
<ul>
<li><strong>Biometrics</strong> - 生物识别（Face ID、指纹）</li>
<li><strong>Geolocation</strong> - 地理位置</li>
<li><strong>Push Notifications</strong> - 推送通知（基于 Firebase）</li>
<li><strong>Scanner</strong> - 扫描器</li>
<li><strong>Secure Storage</strong> - 安全存储</li>
</ul>
<h3 data-id="heading-6">插件市场</h3>
<p>插件市场（Plugin Marketplace）将所有 NativePHP 插件集中展示，开发者可以发现免费和付费插件。</p>
<p>未来几周，市场将向第三方开发者开放，届时开发者可以在 nativephp.com 上架自己的插件，甚至可以销售自己开发的插件。例如相机滤镜插件、支付网关集成、社交登录包等。</p>
<h3 data-id="heading-7">Jump：即时设备测试</h3>
<p>在真机上测试应用通常是一个缓慢且繁琐的过程，需要安装数 GB 的软件、模拟器和框架。而且，没有 Mac 就无法为 iPhone 构建和测试应用。</p>
<p>Jump 改变了这一切。</p>
<p>Jump 是一个安装在手机上的应用（支持 Android 和 iOS），可以在真机上测试 NativePHP 应用，无需编译任何东西，也不需要开启开发者模式。</p>
<p>只需运行 <code>native:jump</code> Artisan 命令，打开手机上的 Jump 应用扫描二维码，Laravel 应用就会直接加载到设备上，连接到本地开发服务器。</p>
<pre><code class="hljs language-shell" lang="shell">php artisan native:jump
<span class="hljs-meta prompt_">
# </span><span class="bash">或者</span>

./native jump
</code></pre>
<p>NativePHP 构建速度很快，本地开发环境的改动几乎可以实时反映到设备上。未来还计划支持完整的 HMR（热模块替换）。</p>
<p>Jump 应用完全免费，<code>nativephp/mobile</code> v3 已包含运行 Jump 所需的一切。</p>
<p>Jump 包含所有官方 NativePHP 插件（包括付费插件），开发者可以免费试用和学习所有功能。唯一的限制是 Jump 无法测试第三方插件。</p>
<h3 data-id="heading-8">Mimi：AI 辅助编码</h3>
<p>Mimi（取自北欧智慧之神 Mimir）是 NativePHP 提供的 AI 辅助编码功能，可以让 AI 模型帮助编写 NativePHP 应用：</p>
<ul>
<li>直接在浏览器中创建新的 NativePHP 项目（移动端也可以）</li>
<li>用自然语言描述想要构建的内容，支持语音输入</li>
<li>直接在 Jump 中测试应用</li>
<li>连接 GitHub 仓库，立即获取所有应用代码</li>
</ul>
<p>这是从想法到可运行移动应用的最快路径，完全基于 Laravel。</p>
<h3 data-id="heading-9">升级指南</h3>
<p>如果已经安装了 <code>nativephp/mobile</code>，升级到 v3 的步骤如下：</p>
<ol>
<li>从 <code>composer.json</code> 中移除 NativePHP 仓库（<code>https://nativephp.composer.sh</code>）</li>
<li>运行 <code>composer remove nativephp/mobile</code> 卸载旧版本</li>
<li>运行 <code>composer require nativephp/mobile</code> 从 Packagist 安装 v3</li>
<li>安装应用中使用的功能对应的插件</li>
</ol>
<p>除了注册新插件外，应用代码基本不需要修改。安装插件后可以使用以下命令注册：</p>
<pre><code class="hljs language-shell" lang="shell">php artisan native:plugin:register vendor/plugin
<span class="hljs-meta prompt_">
# </span><span class="bash">或者</span>

./native plugin:register vendor/plugin
</code></pre>
<h3 data-id="heading-10">快速开始</h3>
<p>NativePHP for Mobile v3 现已发布。在手机上安装 Jump，然后在开发环境中运行以下命令：</p>
<pre><code class="hljs language-shell" lang="shell">laravel new my-mobile-app
cd my-mobile-app
composer require nativephp/mobile
php artisan native:jump
</code></pre>
<p>这里面有几个小坑</p>
<ul>
<li>PHP 要求 <code>&gt;=8.3</code></li>
<li>在 windows 上测试，需要先安装 <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.7-zip.org%2F" target="_blank" title="https://www.7-zip.org/" ref="nofollow noopener noreferrer">7-zip</a></li>
<li>我在 IOS 手机测试得，使用 <code>php artisan native:jump</code> 之后会弹出一个二维码，用手机上的 Jump 扫描即可。这个 Jump 目前只能在 <code>TestFlight</code> 上安装，打开这个<a href="https://link.juejin.cn?target=https%3A%2F%2Ftestflight.apple.com%2Fjoin%2FRuzFs4rJ" target="_blank" title="https://testflight.apple.com/join/RuzFs4rJ" ref="nofollow noopener noreferrer">安装链接</a>即可。</li>
</ul>
<p>很完美，至少从安装上到测试效果都很快了。效果图如下：</p>
<p><img src="https://image.catchadmin.com/202602011330904.png" alt="Laravel 现在可以零成本构建原生 iOS 和 Android 应用 NativePHP for Mobile v3 发布" loading="lazy"/></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fcatchadmin.com%2Fpost%2F2026-02%2Fnativephp-mobile-free" target="_blank" title="https://catchadmin.com/post/2026-02/nativephp-mobile-free" ref="nofollow noopener noreferrer">原文 PHP 现在可以零成本构建原生 iOS 和 Android 应用 NativePHP for Mobile v3 发布</a></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[从零起步学习Redis || 第五章：利用Redis构造分布式全局唯一ID]]></title>    <link>https://juejin.cn/post/7602447286607462409</link>    <guid>https://juejin.cn/post/7602447286607462409</guid>    <pubDate>2026-02-03T09:20:52.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602447286607462409" data-draft-id="7602463463104905262" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="从零起步学习Redis || 第五章：利用Redis构造分布式全局唯一ID"/> <meta itemprop="keywords" content="Redis"/> <meta itemprop="datePublished" content="2026-02-03T09:20:52.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="茶杯梦轩"/> <meta itemprop="url" content="https://juejin.cn/user/195039473183699"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            从零起步学习Redis || 第五章：利用Redis构造分布式全局唯一ID
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/195039473183699/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    茶杯梦轩
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T09:20:52.000Z" title="Tue Feb 03 2026 09:20:52 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>​</p>
<h3 data-id="heading-0">前言：</h3>
<p>最近国庆假期，有点放松了，好久没写博客，今天学习了利用Redis构造分布式全局唯一ID，正好整理一下所学内容。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/42f046c42c054f3b8883fad45debfcde~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Iy25p2v5qKm6L2p:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770715252&amp;x-signature=wkwL4DcVGXIyY4xOPQVYYY22gY8%3D" alt="" loading="lazy"/><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/>​编辑</p>
<h3 data-id="heading-1">问题分析：</h3>
<p>在复杂分布式系统中，往往需要对大量的数据和消息进行唯一标识。数据日渐增长，对数据分库分表后需要有一个唯一ID来标识一条数据或消息，数据库的自增ID显然不能满足需求；特别一点的如订单、骑手、优惠券也都需要有唯一ID做标识。此时一个能够生成全局唯一ID的系统是非常必要的。概括下来，那业务系统对ID号的要求有哪些呢？</p>
<ol>
<li><strong>全局唯一性：</strong> 生成的ID必须在整个系统范围内绝对唯一，不允许出现任何重复。</li>
<li><strong>写入性能优化（趋势递增）：</strong> 为了在如MySQL InnoDB（使用B-tree索引）等数据库中-tree索引）等数据库中实现高效的写入性能，ID应具备<strong>整体趋势递增</strong>的特性（新ID通常比旧ID大），避免插入时索引结构的频繁分裂调整。</li>
<li><strong>严格顺序性（单调递增）：</strong> 在需要严格时间或逻辑顺序的场景（如事务版本号、增量消息、排序等），ID必须具备<strong>单调递增</strong>的特性，确保新生成的ID一定大于之前生成的所有ID。</li>
<li><strong>信息安全（非连续/无规律）：</strong> 为了防止恶意用户通过连续ID推测业务量、爬取数据或获取敏感信息（如订单量），ID应设计成<strong>非连续、无明显规律、不可预测</strong>的形式。</li>
</ol>
<p>上述123对应三类不同的场景，3和4需求还是互斥的，无法使用同一个方案满足。</p>
<h3 data-id="heading-2">方案一：UUID生成</h3>
<p>UUID(Universally Unique Identifier)的标准型式包含32个16进制数字，以连字号分为五段，形式为8-4-4-4-12的36个字符，示例：<code>550e8400-e29b-41d4-a716-446655440000</code></p>
<p>优点：</p>
<ul>
<li>性能非常高：本地生成，没有网络消耗。</li>
</ul>
<p>缺点：</p>
<ul>
<li>不易于存储：UUID太长，16字节128位，通常以36长度的字符串表示，很多场景不适用。</li>
<li>信息不安全：基于MAC地址生成UUID的算法可能会造成MAC地址泄露</li>
<li>ID作为主键时在特定的环境会存在一些问题，比如做DB主键的场景下，UUID就非常不适用（Mysql中的主键id要求尽量要短）</li>
</ul>
<h3 data-id="heading-3">方案二：利用Redis构造全局唯一ID</h3>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/efe2d39d36b74fa39d8d2786fca78085~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Iy25p2v5qKm6L2p:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770715252&amp;x-signature=2nt1YFPHNwfiewoXNlkRud4T4S4%3D" alt="" loading="lazy"/><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/>​编辑</p>
<p>由图可看得，我们设计的ID一共分为三部分：</p>
<p>1.<strong>符号位</strong>：永远为0，标识我们的ID是一个整数。</p>
<p>2.<strong>时间戳</strong>：从自定义时间开始，按秒计算。那么32位我们大约可以使用60多年。</p>
<p>3.<strong>序列号</strong>：同一时间内下单进行自增。在时间戳相等的形况下的区分不同的订单。</p>
<pre><code class="hljs language-ini" lang="ini">    public long nextId(String keyPrefix) {
        //1.生成时间戳
        LocalDateTime <span class="hljs-attr">now</span> = LocalDateTime.now()<span class="hljs-comment">;</span>
        long <span class="hljs-attr">nowhSecond</span> = now.toEpochSecond(Zone<span class="hljs-literal">Off</span>set.UTC)<span class="hljs-comment">;</span>
        long <span class="hljs-attr">timestamp</span> = nowhSecond - BEGIN_TIMESTAMP<span class="hljs-comment">;</span>
        //2.生成序列号
        //1.获取日期，精确到天
        String <span class="hljs-attr">date</span> = now.format(DateTimeFormatter.ofPattern(<span class="hljs-string">"yyyy:MM:dd"</span>))<span class="hljs-comment">;</span>
        Long <span class="hljs-attr">count</span> = stringRedisTemplate.opsForValue().increment(<span class="hljs-string">"icr:"</span> + keyPrefix + <span class="hljs-string">":"</span> + date)<span class="hljs-comment">;</span>
      
        return (timestamp &lt;&lt; COUNT_BITS) | count<span class="hljs-comment">;</span>
    }
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>最后的return为了提高效率，使用了位运算。</p>
<h4 data-id="heading-4">优点：</h4>
<p>高位为时间，低位为序列，保证整体在递增</p>
<p>以服务的形式生成id，减小对数据库的压力</p>
<h4 data-id="heading-5">缺点：</h4>
<p>如果机器的时间回拨，可能会导致id出现重复</p>
<h4 data-id="heading-6">解决方案：</h4>
<p>通过Redis保存<strong>最后一次生成ID的逻辑时间戳</strong>（而非依赖物理时间），确保逻辑时间<strong>只增不减</strong>。即使物理时间回拨，逻辑时间仍延续上次的值，从而保证ID的唯一性和有序性。</p>
<p><strong>1. 优化ID结构（必选）</strong></p>
<p>为解决分布式环境下的唯一性（不同机器可能生成相同时间戳+序列号），需在ID中增加<strong>机器ID</strong>（或数据中心ID）。推荐结构（64位Long类型，兼容Java的<code>long</code>）：</p>
<pre><code class="hljs">符号位（1位） + 时间戳（41位） + 机器ID（10位） + 序列号（12位）
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<ul>
<li>符号位：固定为0（保证ID为正数）；</li>
<li>时间戳：相对于某个epoch（如2020-01-01）的毫秒数，可使用约69年；</li>
<li>机器ID：每个实例唯一（通过配置文件/环境变量/ZooKeeper获取）；</li>
<li>序列号：每毫秒内的自增值（0-4095，支持每秒409.6万次ID生成）。</li>
</ul>
<p><strong>2. 关键组件：Redis存储逻辑时间</strong></p>
<p>用Redis的<strong>String类型</strong>存储两个关键值：</p>
<ul>
<li><code>last_timestamp</code>：最后一次生成ID的逻辑时间戳（毫秒）；</li>
<li><code>sequence</code>：当前毫秒内的序列号（0-4095）。</li>
</ul>
<p>通过<strong>Lua脚本</strong>保证这两个值的原子更新（避免并发 race condition）。</p>
<h4 data-id="heading-7"><strong>3. 具体实现步骤（Java+Redis）</strong></h4>
<h5 data-id="heading-8"><strong>（1）Lua脚本：原子生成逻辑时间戳和序列号：</strong></h5>
<p>Lua脚本是Redis原子操作的核心，用于处理时间回拨、序列号溢出等场景。</p>
<h5 data-id="heading-9"><strong>（2）Java客户端实现</strong></h5>
<p>通过Redisson或Jedis调用Lua脚本，处理返回结果，构造最终ID。</p>
<ul>
<li>
<p><strong>逻辑时间戳</strong>：Redis中保存的<code>last_timestamp</code>是<strong>逻辑时间</strong>，仅增不减。即使物理时间回拨，逻辑时间仍延续上次的值，保证ID的有序性。</p>
</li>
<li>
<p><strong>时间回拨处理</strong>：</p>
<ul>
<li>回拨未超过阈值（如1秒）：使用逻辑时间继续生成ID，序列号递增。若序列号溢出，则递增逻辑时间（如<code>last_timestamp+1</code>），重置序列号。</li>
<li>回拨超过阈值：拒绝生成ID，抛出异常（需报警通知管理员处理，如系统时间被恶意修改）。</li>
</ul>
</li>
</ul>
<p>由于该项方案技术实现较为复杂，我这里没有实现</p>
<h3 data-id="heading-10">方案三：Leaf-segment方案</h3>
<p><strong>批量获取ID进行处理</strong>。在上文我们简单的对数据库进行优化的时候，<strong>优化问题基本都来源于高并发下数据库高频的读写操作。而LEAF数据库方案也是针对这个方面进行优化的</strong>。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1e39ccc5c1e0419282d602f76c66fe36~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Iy25p2v5qKm6L2p:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770715252&amp;x-signature=tTH2EgD7PiOfBJd6ljLq5O6%2BLvE%3D" alt="" loading="lazy"/><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/>​编辑</p>
<p>我们可以把图中的leaf简单的理解为是一个生成全局唯一ID的服务。那么整个LEAF数据库的思想就是：leaf服务提前就拿好一批号端，例如从0-1000。那么我在生成唯一ID的时候，压力就从数据库转到了Leaf这个服务里面。</p>
<p>优点：</p>
<p>将生成id的功能作为服务，方便后续扩展和维护</p>
<p>容灾性强，即使数据库挂掉，服务中因为保存了一部分号段，短时间内仍可进行服务</p>
<p>满足递增要求</p>
<p>缺点：</p>
<p>在号段用完后，突然出现大量请求，服务器压力增大</p>
<h4 data-id="heading-11">解决方案：双buffer优化</h4>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Ftech.meituan.com%2F2017%2F04%2F21%2Fmt-leaf.html" title="https://tech.meituan.com/2017/04/21/mt-leaf.html" target="_blank" ref="nofollow noopener noreferrer">Leaf——美团点评分布式ID生成系统 - 美团技术团队</a></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3b8087b430384157b2c1894e3a89772b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Iy25p2v5qKm6L2p:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770715252&amp;x-signature=1eDrko9fsdChGjBhVfl1MkpwkKc%3D" alt="" loading="lazy"/><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/>​编辑</p>
<p>我们并不会等到号段全部用完之后再去请求新的号段。美团给出的技术方案是当号段消费到某个点时就异步的把下一个号段加载到内存中。而不需要等到号段用尽的时候才去更新号段。</p>
<p>一开始先用A号段，等 A号段消耗10%的时候，就向数据库请求新号段。之后当前号段消耗完之后就可以进行快速的切换。如此循环往复。</p>
<h3 data-id="heading-12">总结：</h3>
<p>三个方案各有千秋，大家可以根据结合自身项目的情况选择合适的方案为项目赋能</p>
<p>​</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[【LLM】为什么现在的LLM都是Decoder-only架构]]></title>    <link>https://juejin.cn/post/7602420156396961835</link>    <guid>https://juejin.cn/post/7602420156396961835</guid>    <pubDate>2026-02-03T09:36:47.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602420156396961835" data-draft-id="7602059064521392171" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="【LLM】为什么现在的LLM都是Decoder-only架构"/> <meta itemprop="keywords" content="LLM"/> <meta itemprop="datePublished" content="2026-02-03T09:36:47.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="xincheng_q"/> <meta itemprop="url" content="https://juejin.cn/user/1240728657471079"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            【LLM】为什么现在的LLM都是Decoder-only架构
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1240728657471079/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    xincheng_q
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T09:36:47.000Z" title="Tue Feb 03 2026 09:36:47 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:14px;overflow-x:hidden;color:var(--cyanosis-base-color);transition:color .35s;--cyanosis-base-color:#353535;--cyanosis-title-color:#005bb7;--cyanosis-strong-color:#2196f3;--cyanosis-em-color:#4fc3f7;--cyanosis-del-color:#ccc;--cyanosis-link-color:#3da8f5;--cyanosis-linkh-color:#007fff;--cyanosis-border-color:#bedcff;--cyanosis-border-color-2:#ececec;--cyanosis-bg-color:#fff;--cyanosis-blockquote-color:#8c8c8c;--cyanosis-blockquote-bg-color:#f0fdff;--cyanosis-code-color:#c2185b;--cyanosis-code-bg-color:#fff4f4;--cyanosis-code-pre-color:#f8f8f8;--cyanosis-table-border-color:#c3e0fd;--cyanosis-table-th-color:#dff0ff;--cyanosis-table-tht-color:#005bb7;--cyanosis-table-tr-nc-color:#f7fbff;--cyanosis-table-trh-color:#e0edf7;--cyanosis-slct-title-color:#005bb7;--cyanosis-slct-titlebg-color:rgba(175,207,247,0.25);--cyanosis-slct-text-color:#c80000;--cyanosis-slct-bg-color:rgba(175,207,247,0.25);--cyanosis-slct-del-color:#999;--cyanosis-slct-elbg-color:#e8ebec;--cyanosis-slct-codebg-color:#ffeaeb;--cyanosis-slct-prebg-color:rgba(160,200,255,0.25)}.markdown-body.__dark{--cyanosis-base-color:#cacaca;--cyanosis-title-color:#ddd;--cyanosis-strong-color:#fe9900;--cyanosis-em-color:#ffd28e;--cyanosis-del-color:#ccc;--cyanosis-link-color:#ffb648;--cyanosis-linkh-color:#fe9900;--cyanosis-border-color:#ffe3ba;--cyanosis-border-color-2:#ffcb7b;--cyanosis-bg-color:#2f2f2f;--cyanosis-blockquote-color:#c7c7c7;--cyanosis-blockquote-bg-color:rgba(255,199,116,0.1);--cyanosis-code-color:#000;--cyanosis-code-bg-color:#ffcb7b;--cyanosis-code-pre-color:rgba(255,227,185,0.5);--cyanosis-table-border-color:#fe9900;--cyanosis-table-th-color:#ffb648;--cyanosis-table-tht-color:#000;--cyanosis-table-tr-nc-color:#6d5736;--cyanosis-table-trh-color:#947443;--cyanosis-slct-title-color:#000;--cyanosis-slct-titlebg-color:#fe9900;--cyanosis-slct-text-color:#00c888;--cyanosis-slct-bg-color:rgba(175,207,247,0.25);--cyanosis-slct-del-color:#999;--cyanosis-slct-elbg-color:#000;--cyanosis-slct-codebg-color:#ffcb7b;--cyanosis-slct-prebg-color:rgba(160,200,255,0.25)}.markdown-body h1{padding-bottom:4px;font-size:30px}.markdown-body h1,.markdown-body h2{margin-top:36px;margin-bottom:10px;line-height:1.5;color:var(--cyanosis-title-color);transition:color .35s}.markdown-body h2{position:relative;padding-left:10px;padding-right:10px;padding-bottom:10px;font-size:24px;border-bottom:1px solid var(--cyanosis-border-color-2)}.markdown-body h2:before{content:"「";position:absolute;top:-6px;left:-14px}.markdown-body h2:after{content:"」";position:relative;top:6px;right:auto}.markdown-body h3{position:relative;padding-bottom:0;margin-top:30px;margin-bottom:10px;font-size:20px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body h3:before{content:"»";padding-right:6px;color:var(--cyanosis-strong-color)}.markdown-body h4{margin-top:24px;font-size:16px}.markdown-body h4,.markdown-body h5{padding-bottom:0;margin-bottom:10px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body h5{margin-top:18px;font-size:14px}.markdown-body h6{padding-bottom:0;margin-top:12px;margin-bottom:10px;font-size:12px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body p{line-height:inherit;margin-top:16px;margin-bottom:16px}.markdown-body img{max-width:100%}.markdown-body hr{position:relative;width:98%;height:1px;margin-top:32px;margin-bottom:32px;background-image:linear-gradient(90deg,var(--cyanosis-link-color),rgba(255,0,0,.3),hsla(0,0%,100%,.1),rgba(255,0,0,.3),var(--cyanosis-link-color));border-width:0;overflow:visible}.markdown-body hr:after{content:"";position:absolute;margin:auto;left:0;right:0;bottom:0;top:0;display:inline-block;width:60px;height:20px;background-color:var(--cyanosis-bg-color);background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAgCAYAAABgrToAAAADoklEQVRYR82XTYgcRRTHf2933Q1RjAa9eFO8JHoJ8RQVBQ2iBwXBET0YEUTXNVmNQtTpmeqaWV0XNRq/o4KoECSCEPSg4CF+BYUkIIiCoCJCPIhC/Ihh2Z0nVV27VnZnenumW9i6ddV7//frV69fVQurfMgq56NawFTPAU6QyomqXrw6wIZeyhCPebA5buNR+akKyGoAjd6BshthnYdSjqNcRVuOlIUsD2j0SuA94IwuMHdh5ZUykOUBXfSGbmKI54EtAeYIHSZoy5dl4JxvNYBOKdW1KE8BQ8AkVk6WhasWsAiN0TX9gveXQaPP+Aytpc4u+bMI06JNohsYYYYOR2lJWtS3OKDRfcAtQfgDoI6Vo4UCGb0OmAEuDvZvYmVbEd/igC3dzDz7gQu8sPA9kJDK27mBmjqBeLjTg90PDFOjWawFFQd06kZHEfaj3LAIpTRpSXsZ5E06zEYP9sDimnAApYaV2SLZG/wjMeqAkijwW4xQJ5Gf/ZzRC8OW3hiBTGGlURRswW55Bh/Ssxljrwew8l1PQaM14GngvGDzBUKdDsMeTtgU5o8B92PFlUf3YXUrHa7Fys6lBqcCGnX15YQ2A18FyPd7Crd1A3M8C1wdbH4DD3hWeP6IEXbQkG97ajR1HPFnuPP5jFFq1OWX7hl8WM9l1AO648uNfwLk7tytMeogty+xeQ4rO3r6bdcx1nuwOGsHmaXGtPzae4uzGnLH1kQkvpdZGrHjssBZJrL+pqS05KWc8tgITAPXRzYvYOXe/C2OV43eDcRBDtIhoS2f9wzc0Cv8Wls+zoFzUC5zF0U241h5uZtPfptp6OUM8wbK+cH5GEpCS17P3fJei0Z3+npTxryJ8CPzbKMtn/ZyWbkPGl0PuFPkmkjkcb4h4R2ZLwRq1H0ALmvjkf2HwK1Y+T1PY2XABe/sHJ6MxN5lnoSpnC/UGbsTaI5phK2R7x6s3Ffk5YoDOrWm3onwJHBmEP86bPmBrsGaenNoIdnxCH+gPEhLXi0Cl1VBvyPVLSh7gEuC62yAfOIUqabWEaaiucMIk6RyqJ+Q/QM69V26jjW86Gvov/EaoyT8zRCn+Xq7PVrbx0nuYUaO9wM3WAbjCE1NEUw09Um4UV+2OKfYfu5/S19gsAzGKqm6LE5FrShbdS0ku465DjDwKA/oQht19ejqbaEVuRbiLhuHByYLjtUAZpDutzP7cYdHsPJXWbjyNVgFwQoa1WXwf4Jd9YD/Ap80+yE7+u9aAAAAAElFTkSuQmCC);background-repeat:no-repeat;background-size:auto 100%;background-position-x:center;transition:background-color .5s}.markdown-body code{padding:.065em .4em;font-size:.87em;color:var(--cyanosis-code-color);word-break:break-word;overflow-x:auto;background-color:var(--cyanosis-code-bg-color);border-radius:2px}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{display:block;padding:16px 12px;margin:0;font-size:12px;color:#333;word-break:normal;overflow-x:auto;background:var(--cyanosis-code-pre-color)}.markdown-body pre&gt;code::-webkit-scrollbar{width:4px;height:4px}.markdown-body pre&gt;code::-webkit-scrollbar-track{background-color:var(--cyanosis-border-color)}.markdown-body pre&gt;code::-webkit-scrollbar-thumb{background-color:var(--cyanosis-strong-color);border-radius:10px}.markdown-body a{position:relative;text-decoration:none;color:var(--cyanosis-link-color);border-bottom:1px solid var(--cyanosis-border-color)}.markdown-body a:hover{border-bottom-color:var(--cyanosis-linkh-color)}.markdown-body a:active,.markdown-body a:hover{color:var(--cyanosis-linkh-color)}.markdown-body a:after{position:absolute;content:"";top:100%;left:0;width:100%;opacity:0;border-bottom:1px solid var(--cyanosis-border-color);transition:top .3s,opacity .3s;transform:translateZ(0)}.markdown-body a:hover:after{top:0;opacity:1;border-bottom-color:var(--cyanosis-linkh-color)}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid var(--cyanosis-table-border-color);border-spacing:0;border-collapse:collapse}.markdown-body table thead{color:#000;text-align:left;font-size:14px;background:#f6f6f6}.markdown-body table tr:nth-child(2n){background-color:var(--cyanosis-table-tr-nc-color)}.markdown-body table tr:hover{background-color:var(--cyanosis-table-trh-color)}.markdown-body table td,.markdown-body table th{padding:12px 8px;line-height:24px;border:1px solid var(--cyanosis-table-border-color)}.markdown-body table th{color:var(--cyanosis-table-tht-color);background-color:var(--cyanosis-table-th-color)}.markdown-body table td{min-width:120px}.markdown-body blockquote{color:var(--cyanosis-blockquote-color);border-left:4px solid var(--cyanosis-strong-color);background-color:var(--cyanosis-blockquote-bg-color);padding:1px 20px;margin:22px 0;transition:color .35s}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body b,.markdown-body blockquote&gt;b,.markdown-body blockquote&gt;strong,.markdown-body strong{color:var(--cyanosis-strong-color)}.markdown-body em,.markdown-body i{color:var(--cyanosis-em-color)}.markdown-body del{color:var(--cyanosis-del-color)}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:4px}.markdown-body ol li{padding-left:6px}.markdown-body details&gt;summary{outline:none;color:var(--cyanosis-title-color);font-size:20px;font-weight:bolder;border-bottom:1px solid var(--cyanosis-border-color);cursor:pointer}.markdown-body details&gt;p{padding:10px 20px;margin:10px 0 0;color:#666;background-color:var(--cyanosis-blockquote-bg-color);border:2px dashed var(--cyanosis-strong-color)}.markdown-body h1::selection,.markdown-body h2::selection,.markdown-body h3::selection,.markdown-body h4::selection,.markdown-body h5::selection,.markdown-body h6::selection{color:var(--cyanosis-slct-title-color);background-color:var(--cyanosis-slct-titlebg-color)}.markdown-body ol li::selection,.markdown-body p::selection,.markdown-body ul li::selection{color:var(--cyanosis-slct-text-color);background-color:var(--cyanosis-slct-bg-color)}.markdown-body a::selection,.markdown-body b::selection,.markdown-body em::selection,.markdown-body i::selection,.markdown-body strong::selection{background-color:var(--cyanosis-slct-elbg-color)}.markdown-body del::selection{color:var(--cyanosis-slct-del-color);background-color:var(--cyanosis-slct-elbg-color)}.markdown-body table thead th::selection{background-color:transparent}.markdown-body table tbody td::selection{background-color:var(--cyanosis-slct-bg-color)}.markdown-body code::selection{background-color:var(--cyanosis-slct-codebg-color)}.markdown-body pre&gt;code::selection{background-color:var(--cyanosis-slct-prebg-color)}.markdown-body .contains-task-list{padding-left:14px;list-style:none}.markdown-body .contains-task-list input[type=checkbox]{position:relative}.markdown-body .contains-task-list input[type=checkbox]:before{content:"";position:absolute;top:0;left:0;right:0;bottom:0;width:inherit;height:inherit;background:#f0f8ff;border:1px solid #add6ff;border-radius:2px;box-sizing:border-box;z-index:1}.markdown-body .contains-task-list input[type=checkbox]:checked:after{content:"✓";position:absolute;top:-12px;left:0;right:0;bottom:0;width:0;height:0;color:#f55;font-size:20px;font-weight:700;z-index:2}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="atelier-lakeside-light">.hljs-comment,.hljs-quote{color:#5a7b8c}.hljs-attribute,.hljs-link,.hljs-name,.hljs-regexp,.hljs-selector-class,.hljs-selector-id,.hljs-tag,.hljs-template-variable,.hljs-variable{color:#d22d72}.hljs-built_in,.hljs-builtin-name,.hljs-literal,.hljs-meta,.hljs-number,.hljs-params,.hljs-type{color:#935c25}.hljs-bullet,.hljs-string,.hljs-symbol{color:#568c3b}.hljs-section,.hljs-title{color:#257fad}.hljs-keyword,.hljs-selector-tag{color:#6b6bb8}.markdown-body pre,.markdown-body pre&gt;code.hljs{background:#ebf8ff;color:#516d7b}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">LLM为什么Decoder only架构</h2>
<blockquote>
<p>参考：
苏剑林-<a href="https://link.juejin.cn?target=https%3A%2F%2Fkexue.fm%2Farchives%2F9529" target="_blank" title="https://kexue.fm/archives/9529" ref="nofollow noopener noreferrer">kexue.fm/archives/95…</a></p>
</blockquote>
<p>先给出苏神的答案：</p>
<p>LLM之所以主要都用Decoder-only架构，除了训练效率和工程实现上的优势外，在理论上是因为Encoder的双向注意力会存在低秩问题，这可能会削弱模型表达能力，就生成任务而言，引入双向注意力并无实质好处。而Encoder-Decoder架构之所以能够在某些场景下表现更好，大概只是因为它多了一倍参数。所以，在同等参数量、同等推理成本下，Decoder-only架构就是最优选择了。</p>
<hr/>
<blockquote>
<p>这里给出三个理由，更多的可以参考<a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2FTFATS%2Farticle%2Fdetails%2F133100383" target="_blank" title="https://blog.csdn.net/TFATS/article/details/133100383" ref="nofollow noopener noreferrer">为什么现在的LLM都是Decoder only的架构？_为什么decoder-only的模型这么火-CSDN博客</a></p>
</blockquote>
<p><strong>1.Encoder的双向注意力会存在低秩问题，可能会削弱模型的表达能力</strong></p>
<p><strong>2.decoder-only支持一直复用KV-Cache，对多轮对话更友好，因为每个token的表示只和它之前的输入有关，而encoder-decoder和PrefixLM就难以做到</strong></p>
<p><strong>3.decoder-only 模型在没有任何 tuning 数据的情况下、zero-shot 表现最好，而 encoder-decoder 则需要在一定量的标注数据上做 multitask finetuning 才能激发最佳性能。</strong></p>
<blockquote>
<p>Decoder-only训练的时候做的就是生成任务，在 Zero-shot 场景下，Prompt 往往符合自然语言的流动习惯，天生就是为了把话接下去而设计的。</p>
</blockquote>
<hr/>
<p>然后我们进行更本质地探索，为什么说Encoder的双向注意力会存在低秩问题呢？</p>
<h3 data-id="heading-1">低秩问题探讨</h3>
<p>Transformer一开始是用于做seq2seq任务的，即包含Encoder和Decoder两个部分。Encoder在抽取序列中某一个词的特征时，可以看到<strong>整个序列中的信息</strong>（完形填空）。而Decoder中因为有mask机制的存在，使得其在编码某一个词的特种功能时，只能<strong>看到自身和它之前的文本信息</strong>（生成任务）。</p>
<blockquote>
<p>Decoder 采用Causal Mask（因果掩码）方法，第一行只能看1个，第N行看N个，是一个下三角矩阵。（满秩）</p>
</blockquote>
<p>decoder-only架构通过mask机制，在物理上锁死了矩阵的秩，防止它<strong>坍塌。</strong></p>
<h3 data-id="heading-2">注意力</h3>
<p>下面的图为注意力的矩阵。<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>t</mi><mi>t</mi><mi>n</mi><mtext>（</mtext><mi>Q</mi><mo separator="true">,</mo><mi>K</mi><mo separator="true">,</mo><mi>V</mi><mtext>）</mtext><mo>=</mo><mi>s</mi><mi>o</mi><mi>f</mi><mi>t</mi><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>Q</mi><msup><mi>K</mi><mi>T</mi></msup><mi mathvariant="normal">/</mi><msqrt><mrow><mo stretchy="false">(</mo><msub><mi>d</mi><mi>k</mi></msub><mo stretchy="false">)</mo></mrow></msqrt><mo stretchy="false">)</mo><mo>∗</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">Attn（Q,K,V）=softmax(QK^T/\sqrt{(d_k)})*V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"/><span class="mord mathnormal">A</span><span class="mord mathnormal">tt</span><span class="mord mathnormal">n</span><span class="mord cjk_fallback">（</span><span class="mord mathnormal">Q</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord cjk_fallback">）</span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:1.24em;vertical-align:-0.305em;"/><span class="mord mathnormal">so</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">t</span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">Q</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.935em;"><span class="svg-align" style="top:-3.2em;"><span class="pstrut" style="height:3.2em;"/><span class="mord" style="padding-left:1em;"><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-2.895em;"><span class="pstrut" style="height:3.2em;"/><span class="hide-tail" style="min-width:1.02em;height:1.28em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="1.28em" viewbox="0 0 400000 1296" preserveaspectratio="xMinYMin slice"><path d="M263,681c0.7,0,18,39.7,52,119&#10;c34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120&#10;c340,-704.7,510.7,-1060.3,512,-1067&#10;l0 -0&#10;c4.7,-7.3,11,-11,19,-11&#10;H40000v40H1012.3&#10;s-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232&#10;c-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1&#10;s-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26&#10;c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z&#10;M1001 80h400000v40h-400000z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.305em;"><span/></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"/><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"/></span><span class="base"><span class="strut" style="height:0.6833em;"/><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></span> Q,K都是一个低秩矩阵，即<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi><mo>=</mo><mi>n</mi><mo>×</mo><mi>d</mi><mo separator="true">,</mo><mi>K</mi><mo>=</mo><mi>n</mi><mo>×</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">Q=n\times d, K=n\times d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"/><span class="mord mathnormal">Q</span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"/><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"/><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"/></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"/><span class="mord mathnormal">d</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"/><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"/><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"/></span><span class="base"><span class="strut" style="height:0.6944em;"/><span class="mord mathnormal">d</span></span></span></span></span> =&gt; Attn矩阵大小为<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>×</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">n\times n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"/><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"/><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"/></span><span class="base"><span class="strut" style="height:0.4306em;"/><span class="mord mathnormal">n</span></span></span></span></span></p>
<blockquote>
<p>这里的n可以理解为seq_len，d理解为hidden dimension, 在代码实现中，<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi><mo separator="true">,</mo><mi>K</mi><mo separator="true">,</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">Q,K,V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"/><span class="mord mathnormal">Q</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></span>都是输入<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"/><span class="mord mathnormal">x</span></span></span></span></span>通过Linear变换得到，即<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>e</mi><mi>l</mi><mi>f</mi><mi mathvariant="normal">.</mi><mi>q</mi><mo>=</mo><mi>L</mi><mi>i</mi><mi>n</mi><mi>e</mi><mi>a</mi><mi>r</mi><mo stretchy="false">(</mo><mi>d</mi><mo separator="true">,</mo><mi>d</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>Q</mi><mo>=</mo><mi>s</mi><mi>e</mi><mi>l</mi><mi>e</mi><mi mathvariant="normal">.</mi><mi>q</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><msub><mi>x</mi><mrow><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi></mrow></msub><mo>=</mo><mo stretchy="false">[</mo><mi>B</mi><mo separator="true">,</mo><mi>L</mi><mo separator="true">,</mo><mi>d</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">self.q=Linear(d, d), Q=sele.q(x), (x_{size}=[B,L,d])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"/><span class="mord mathnormal">se</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mord mathnormal">L</span><span class="mord mathnormal">in</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord mathnormal">d</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord mathnormal">Q</span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mord mathnormal">se</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">ze</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord mathnormal">L</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord mathnormal">d</span><span class="mclose">])</span></span></span></span></span></p>
</blockquote>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/92c1689bcc0f4919ac382d2a4a44f821~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgeGluY2hlbmdfcQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770716206&amp;x-signature=2tlkmFiv%2B7WozkF1U4Vt%2Bo5TxYM%3D" alt="" loading="lazy"/></p>
<blockquote>
<p>如何理解这张图，设 A 为 Decoder 的 Attention 权重矩阵。<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mrow><mi>i</mi><mi>i</mi></mrow></msub></mrow><annotation encoding="application/x-tex">A_{ii}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"/><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ii</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span></span></span></span></span> 代表第 i 个 Token 对自身的注意力。decoder的mask策略就是把 j&gt;i的部分（上三角）给mask掉</p>
</blockquote>
<p>对于Decoder的attn矩阵来说，是一个下三角矩阵。而三角矩阵的行列式永远等于对角线上的元素的乘积。</p>
<p>又Attention矩阵的对角线元素<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mrow><mi>i</mi><mi>i</mi></mrow></msub></mrow><annotation encoding="application/x-tex">A_{ii}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"/><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ii</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span></span></span></span></span>是通过softmax计算得到的概率值。即<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>e</mi><mi>x</mi></msup><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">e^x&gt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7035em;vertical-align:-0.0391em;"/><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord">0</span></span></span></span></span>(softmax的输出恒大于0)，这意味着attn矩阵的对角元素非0 =》 <strong>Decoder-only 的 Attention 矩阵在数学上必然是满秩的。</strong></p>
<p>行列式不为0 =&gt; 满秩矩阵 <strong>=&gt; 表征能力更强 =&gt; 不会出现低秩坍塌（low rank）</strong></p>
<blockquote>
<p>那满秩意味着什么？</p>
</blockquote>
<p>满秩意味着，每个位置的token都能保留其独特的几何位置信息，信息没有损失，表征更丰富。</p>
<blockquote>
<p><strong>满秩（Rank</strong> <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"/><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span></span> <strong>）：</strong> 表达能力最强，能区分 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"/><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span></span> 个不同的特征。</p>
<p><strong>低秩（Rank 1）：</strong> 极端情况下，所有行都一样，矩阵变成秩为 1。这意味着模型失去了区分不同位置 Token 的能力，所有 Token 的表示趋同</p>
</blockquote>
<p>如果是bert这种双向注意力，其attn矩阵为稠密矩阵（下图第一个子图）。在深度网络中，双向注意力易出现同质化smoothing。即随着层数的加深，大家看到的上下文越来越像，矩阵A可能趋向每一行都差不多（比如每行都关注某一个特殊的token）。一旦行与行之间变得相似（线性相关）矩阵的秩就会下降（low rank）</p>
<blockquote>
<p>从第一性原理来看，表达能力本质上是<strong>模型能够区分不同输入状态的能力</strong>。
满秩能够 抵抗“表征坍塌” (Preventing Rank Collapse)</p>
<ul>
<li><strong>Encoder（双向）：</strong>  它是全连通图。在深度网络中，如果没有残差连接，双向注意力会倾向于让所有 Token 的 Embedding 趋同（过平滑）。从矩阵角度看，其每一行越来越像，矩阵的秩迅速萎缩。一旦秩下降，模型就会丢失局部细节，只能记住模糊的全局统计特征。</li>
<li><strong>Decoder（单向）：</strong>  强制性的下三角结构像一道“防火墙”。无论网络多深，第 1 个词永远只看自己，第 2 个词看 1 和 2……这种<strong>层次化的信息流动</strong>强制保证了每个位置的表征在数学上必须是独立的。<strong>满秩保证了模型在每一层都保留了最大化的信息熵。</strong></li>
</ul>
</blockquote>
<hr/>
<p>下面链接一下attn coding的具体实现：</p>
<h4 data-id="heading-3">缩放点积注意力(Pytorch实现）</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> torch  
<span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn  
<span class="hljs-keyword">import</span> torch.nn.functional <span class="hljs-keyword">as</span> F  
<span class="hljs-keyword">import</span> math  

<span class="hljs-keyword">def</span> <span class="hljs-title function_">scaled_dot_product_attention</span>(<span class="hljs-params">query, key, value, mask=<span class="hljs-literal">None</span></span>):  
    <span class="hljs-string">"""  
    query: (batch, n_heads, seq_len, d_k)  
    key:   (batch, n_heads, seq_len, d_k)  
    value: (batch, n_heads, seq_len, d_v)  
    mask:  (batch, 1, seq_len, seq_len) - 用于遮盖 Padding 或 Decoder 的后续 Token  
    """</span>  
    d_k = query.size(-<span class="hljs-number">1</span>)  
    
    <span class="hljs-comment"># 1. 计算注意力得分: Q * K^T  </span>
    <span class="hljs-comment"># scores 形状: (batch, n_heads, seq_len, seq_len)  </span>
    scores = torch.matmul(query, key.transpose(-<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>)) / math.sqrt(d_k)  
    
    <span class="hljs-comment"># 2. 如果有 Mask，将 Mask 为 0 的位置填为极小值，Softmax 后变为 0  </span>
    <span class="hljs-keyword">if</span> mask <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:  
        scores = scores.masked_fill(mask == <span class="hljs-number">0</span>, -<span class="hljs-number">1e9</span>)  
    
    <span class="hljs-comment"># 3. Softmax 归一化得到注意力权重  </span>
    p_attn = F.softmax(scores, dim=-<span class="hljs-number">1</span>)  
    
    <span class="hljs-comment"># 4. 权重乘以 Value 向量  </span>
    <span class="hljs-keyword">return</span> torch.matmul(p_attn, value), p_attn
</code></pre>
<h4 data-id="heading-4">多头注意力 (Multi-Head Attention)</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MultiHeadAttention</span>(nn.Module):  
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, d_model, n_heads</span>):  
        <span class="hljs-built_in">super</span>(MultiHeadAttention, self).__init__()  
        <span class="hljs-keyword">assert</span> d_model % n_heads == <span class="hljs-number">0</span>  
        
        self.d_k = d_model // n_heads  
        self.n_heads = n_heads  
        
        <span class="hljs-comment"># 定义四个线性层：W_q, W_k, W_v 和 最后的输出投影 W_o  </span>
        self.linears = nn.ModuleList([nn.Linear(d_model, d_model) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>)])  
        
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, query, key, value, mask=<span class="hljs-literal">None</span></span>):  
        batch_size = query.size(<span class="hljs-number">0</span>)  
        
        <span class="hljs-comment"># 1. 线性变换投影并切分为 n_heads 个头  </span>
        <span class="hljs-comment"># (batch, seq_len, d_model) -&gt; (batch, n_heads, seq_len, d_k)  </span>
        query, key, value = [  
            l(x).view(batch_size, -<span class="hljs-number">1</span>, self.n_heads, self.d_k).transpose(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)  
            <span class="hljs-keyword">for</span> l, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(self.linears, (query, key, value))  
        ]  
        
        <span class="hljs-comment"># 2. 应用缩放点积注意力  </span>
        x, self.attn = scaled_dot_product_attention(query, key, value, mask=mask)  
        
        <span class="hljs-comment"># 3. 将多头合并 (Concat)  </span>
        <span class="hljs-comment"># (batch, n_heads, seq_len, d_k) -&gt; (batch, seq_len, d_model)  </span>
        x = x.transpose(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>).contiguous().view(batch_size, -<span class="hljs-number">1</span>, self.n_heads * self.d_k)  
        
        <span class="hljs-comment"># 4. 最后一次线性投影  </span>
        <span class="hljs-keyword">return</span> self.linears[-<span class="hljs-number">1</span>](x)
</code></pre>
<ol>
<li>
<p><strong>为什么除以 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msqrt><msub><mi>d</mi><mi>k</mi></msub></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{d_k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.1828em;"/><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8572em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"/><span class="mord" style="padding-left:0.833em;"><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span></span></span><span style="top:-2.8172em;"><span class="pstrut" style="height:3em;"/><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="1.08em" viewbox="0 0 400000 1080" preserveaspectratio="xMinYMin slice"><path d="M95,702&#10;c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14&#10;c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54&#10;c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10&#10;s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429&#10;c69,-144,104.5,-217.7,106.5,-221&#10;l0 -0&#10;c5.3,-9.3,12,-14,20,-14&#10;H400000v40H845.2724&#10;s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7&#10;c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z&#10;M834 80h400000v40h-400000z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1828em;"><span/></span></span></span></span></span></span></span></span>？</strong><br/>
如果 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">d_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"/><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span></span></span></span></span> 很大，点积的结果会变得很大，导致 Softmax 进入梯度极小的区域（饱和区）。除以根号 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">d_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"/><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span></span></span></span></span> 可以让方差保持在 1 左右，训练更稳定。</p>
</li>
<li>
<p><strong>Mask 的实现：</strong></p>
<ul>
<li>在 <strong>Encoder</strong> 中，Mask 用于遮盖补零的 Token（Padding Mask）。</li>
<li>在 <strong>Decoder</strong> 中，Mask 是一个下三角矩阵（Causal Mask），防止模型在预测当前词时“偷看”未来的词。</li>
</ul>
</li>
<li>
<p><strong>Dimension 重排 (View &amp; Transpose)：</strong><br/>
多头注意力的精髓在于将 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mrow><mi>m</mi><mi>o</mi><mi>d</mi><mi>e</mi><mi>l</mi></mrow></msub></mrow><annotation encoding="application/x-tex">d_{model}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"/><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span></span></span></span></span> 拆开。通过 <code>transpose(1, 2)</code>，我们将 <code>n_heads</code> 维度提前，这样在计算点积时，每个头之间是完全独立的并行计算。</p>
</li>
</ol>
<p>代码调用方式：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 假设 d_model=512, 8个头, 序列长度为10, batch大小为2  </span>
mha = MultiHeadAttention(d_model=<span class="hljs-number">512</span>, n_heads=<span class="hljs-number">8</span>)  
x = torch.randn(<span class="hljs-number">2</span>, <span class="hljs-number">10</span>, <span class="hljs-number">512</span>)  

<span class="hljs-comment"># 自注意力计算 (Self-Attention)  </span>
output = mha(x, x, x, mask=<span class="hljs-literal">None</span>)  
<span class="hljs-built_in">print</span>(output.shape) <span class="hljs-comment"># 输出应为 torch.Size([2, 10, 512])</span>
</code></pre>
<hr/>
<p>那为什么说下三角矩阵的行列式不为0，就意味着满秩呢？这里涉及到线性代数的相关基础计算，这里总结了矩阵的秩和行列式之间的关联：</p>
<h3 data-id="heading-5">矩阵的秩和行列式的关联</h3>
<h4 data-id="heading-6">秩的定义</h4>
<p>矩阵的秩：本质上是列向量（或行向量）线性无关向量的最大个数。反映了矩阵所代表的线性变换将空间压缩的程度。</p>
<p>如果一个矩阵的秩等于行数/列数，那么其代表的变换是<strong>满秩</strong>的，意味着<strong>不会将空间压缩到更低的维度</strong>。（表征更丰富，没有被拍扁了）</p>
<p><del>怎么和三体里面的知识联动了</del></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ec6041089d7c40aeb414089c63ca16f0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgeGluY2hlbmdfcQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770716206&amp;x-signature=JRr%2Fx%2F8xjb7x0A1fOj2go9yqBK4%3D" alt="" loading="lazy"/></p>
<h4 data-id="heading-7">计算秩</h4>
<p>行阶梯形矩阵中非零行的行数就是矩阵的秩。</p>
<p>而矩阵的秩的计算，最常用的是通过行阶梯矩阵来实现。即矩阵通过初等行变换（交换，某行乘以非零常数）化为行阶梯矩阵。行阶梯矩阵的特点是：</p>
<ul>
<li>非零行都在零行之上。</li>
<li>每行第一个非零元素（称为主元或先导元素）所在的列，在该主元下方所有元素都是零。</li>
<li>主元所在的列，其右侧的行的主元必须在更靠右的位置。</li>
</ul>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c87abd1034b647dbb94550ad1c97613c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgeGluY2hlbmdfcQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770716206&amp;x-signature=cfm9h83YbXOpICoTLPM5YPkfRxs%3D" alt="" loading="lazy"/></p>
<p>行列式是一个标量值，它反映了方阵所代表的线性变换对空间体积的伸缩比例。</p>
<ul>
<li>二维空间： 对于 2×22×2 矩阵，其行列式的绝对值代表了由其列向量（或行向量）所张成的平行四边形的面积。</li>
<li>三维空间： 对于 3×33×3 矩阵，其行列式的绝对值代表了由其列向量（或行向量）所张成的平行六面体的体积。</li>
<li>更高维度： 推广到 n 维空间，行列式的绝对值代表了由其列向量（或行向量）所张成的 n 维“平行体”的体积。</li>
</ul>
<p>此外，行列式的正负表示了变换是否改变了空间的定向（例如，是否发生了翻转）。如果行列式为零，则意味着变换将空间压缩到了更低的维度，体积变为零。</p>
<h4 data-id="heading-8"><strong>矩阵的秩和行列式之间的关联</strong></h4>
<ul>
<li>行列式为零 &lt;=&gt; 矩阵不可逆</li>
</ul>
<p>如果一个方阵的行列式为零意味着它所代表的线性变换将 n<em>n</em> 维空间压缩到了一个更低的维度（例如，将三维空间压缩成一个平面或一条线）。当空间被压缩时，不同的原始向量可能会被映射到相同的目标向量，导致变换是不可逆的</p>
<ul>
<li>矩阵不可逆 &lt;=&gt; 矩阵的列向量（或行向量）线性相关</li>
</ul>
<p>如果一个矩阵的列向量是线性相关的，这意味着其中至少有一个列向量可以通过其他列向量的线性组合来表示。在这种情况下，这些列向量无法张成整个 n 维空间，它们只能张成一个更低的子空间。当向量无法张成整个空间时，变换会“丢失信息”，导致不可逆</p>
<ul>
<li>矩阵的列向量（或行向量）线性相关 &lt;=&gt; 矩阵的秩小于其维数</li>
</ul>
<p>矩阵的秩定义为线性无关列向量的最大个数。如果列向量线性相关，则线性无关的列向量数量会少于矩阵的列数，从而导致秩小于矩阵的维数。</p>
<p><strong>我们可以得到以下重要的等价关系（对于 n×n 方阵A）</strong></p>
<ol>
<li><strong>det(A)=0</strong> (行列式为零)</li>
<li><strong>矩阵 A 不可逆</strong> (没有逆矩阵)</li>
<li><strong>矩阵 A 的列向量（或行向量）线性相关</strong></li>
<li><strong>rank(A)&lt;n</strong> (秩小于矩阵的维数，即不满秩)</li>
<li><strong>线性方程组 Ax=0 有非零解</strong> (齐次线性方程组有无穷多解)</li>
</ol>
<p><strong>反之，如果行列式不为零，则这些条件全部取反：</strong></p>
<ol>
<li><strong>det(A)≠0</strong> (行列式不为零)</li>
<li><strong>矩阵 A 可逆</strong> (存在逆矩阵)</li>
<li><strong>矩阵 A 的列向量（或行向量）线性无关</strong></li>
<li><strong>rank(A)=n</strong> (秩等于矩阵的维数，即满秩)</li>
<li><strong>线性方程组 Ax=0 只有零解</strong> (齐次线性方程组只有唯一零解)</li>
</ol>
<p><strong>总结</strong>：</p>
<ul>
<li>行列式为0 &lt;=&gt; 矩阵不满秩</li>
<li>行列式不为0 =&gt; 满秩</li>
</ul>
<hr/>
<p>好的，了解完行列式和矩阵的秩的关联之后，你应该彻底懂了，而什么Encoder的双向注意力会导致低秩问题了，而decoder-only的架构具备更强的表征能力。</p>
<p>这里在讨论一下更广义的低秩问题：</p>
<h3 data-id="heading-9">Low-Rank Bottleneck</h3>
<p>LLM 中更广义的“低秩问题”（Low-Rank Bottleneck）通常指的是<strong>Softmax Bottleneck</strong>，这直接影响模型的能力。在LLM的输出层，需要生成一个词表大小(<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"/><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></span>)的概率分布, <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>=</mo><mi>s</mi><mi>o</mi><mi>f</mi><mi>t</mi><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>H</mi><mo>⋅</mo><msup><mi>W</mi><mi>T</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p=softmax(H\cdot W^T)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"/><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mord mathnormal">so</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">t</span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222em;"/><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"/></span><span class="base"><span class="strut" style="height:1.0913em;vertical-align:-0.25em;"/><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
<p>H是隐藏层，size为<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>×</mo><mi>d</mi><mo separator="true">,</mo><mi>d</mi><mtext>即</mtext><mi>h</mi><mi>i</mi><mi>d</mi><mi>d</mi><mi>e</mi><mi>n</mi><mi>d</mi><mi>i</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>s</mi><mi>i</mi><mi>o</mi><mi>n</mi><mtext>，如</mtext><mn>4096</mn></mrow><annotation encoding="application/x-tex">B\times d, d即hidden dimension，如4096</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"/><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222em;"/><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"/></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"/><span class="mord mathnormal">d</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord mathnormal">d</span><span class="mord cjk_fallback">即</span><span class="mord mathnormal">hi</span><span class="mord mathnormal">dd</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">d</span><span class="mord mathnormal">im</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mord cjk_fallback">，如</span><span class="mord">4096</span></span></span></span></span></p>
<p>W是输出嵌入矩阵，size为<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo>×</mo><mi>d</mi><mo separator="true">,</mo><mi>V</mi><mtext>即词表大小，如</mtext><mn>100</mn><mi>k</mi></mrow><annotation encoding="application/x-tex">V\times d, V即词表大小，如100k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"/><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222em;"/><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"/></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"/><span class="mord mathnormal">d</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord cjk_fallback">即词表大小，如</span><span class="mord">100</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span></span></p>
<p>最终logits矩阵的秩受限于中间维度，因为<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mo>&lt;</mo><mo>&lt;</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">d &lt;&lt; V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.0391em;"/><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">&lt;&lt;</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:0.6833em;"/><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></span>，所以输出的logits矩阵是一个低秩矩阵</p>
<p>而自然语言的真实分布是非常复杂的，理论上可能需要满秩（Rank V）才能完美拟合。用一个低秩矩阵去强行拟合一个高秩的真实数据分布，就是<strong>低秩瓶颈</strong>。</p>
<p>当出现低秩问题时，LLM主要表现为表达多样性能力的下降：</p>
<ul>
<li><strong>困惑度（Perplexity）无法继续下降：</strong> 模型在训练集上已经拟合不动了，因为它的几何空间不够大，无法将复杂的语言模式区分开。</li>
<li><strong>退化与重复（Degeneracy）：</strong> 模型生成的文本容易陷入循环或重复。因为在低秩投影下，原本应该有细微差别的两个词（例如“高兴”和“愉悦”），在低维空间里重叠了，模型无法区分它们的语境差异。</li>
<li><strong>多义词理解变差：</strong> 比如 context 变了，但模型输出的概率分布没变，因为它缺乏足够的维度来编码这种上下文的变换。</li>
</ul>
<blockquote>
<p>说到复读机问题，那么为什么decoder-only中的attn矩阵明明是满秩的，按道理来说表征应该更丰富，不会陷入到低维坍塌中，可是我们初期在使用LLM的时候，会经常看到他重复输出一些无意义的内容。</p>
</blockquote>
<p>这里给出Gemini的回答：</p>
<p><strong>Attention矩阵满秩（Full Rank）只代表模型具备“区分不同token位置”的能力（表达能力），并不代表模型会“主动选择多样化”的输出（行为策略）。</strong></p>
<p>可以从以下三个维度来分析：</p>
<h4 data-id="heading-10">1. 自回归</h4>
<p>GPT的本质是一个自回归模型（Autoregressive Model），其生成公式为：<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>t</mi></msub><mi mathvariant="normal">∣</mi><msub><mi>x</mi><mrow><mo>&lt;</mo><mi>t</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(x_t | x_{&lt;t})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mrel mtight">&lt;</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1774em;"><span/></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
<blockquote>
<p>自回归（Auto + Regression）,<strong>用“自己已经生成的结果”，继续预测后面的结果</strong></p>
</blockquote>
<blockquote>
<p>非自回归模型, <strong>BERT</strong>。 BERT是一个基于 Transformer Encoder 的预训练语言模型。它的核心目标是<strong>理解文本，而不是生成文本</strong>。（双向注意力，训练的目的是 填空）</p>
</blockquote>
<ul>
<li>
<p><strong>正反馈循环（Positive Feedback Loop）：</strong></p>
<p>当你生成了一个token（比如“是”），这个token立刻变成了下一个时间步的<strong>输入</strong>。</p>
<p>如果模型在训练数据中见过很多重复的模式（比如列表、代码缩进、强调句），或者模型对当前语境的判断出现了“不确定性坍缩”，它可能会认为“重复上一个词”是概率最安全的选择。</p>
</li>
<li>
<p><strong>吸引子（Attractor State）：</strong></p>
<p>一旦模型生成了 <code>A, A</code>，输入变成了 <code>...A, A</code>。</p>
<p>在Attention机制中，Query (当前token) 会去和 Keys (历史token) 做点积。如果历史中充斥着大量的 <code>A</code>，Query <code>A</code> 和 Key <code>A</code> 的相似度极高。</p>
<p>这将导致 Attention Score 更加集中在这些重复的 token 上，输出概率分布 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mrow><mi>n</mi><mi>e</mi><mi>x</mi><mi>t</mi></mrow></msub><mo>=</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(x_{next}=A)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">x</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mord mathnormal">A</span><span class="mclose">)</span></span></span></span></span> 进一步接近 1.0。</p>
<p>这就形成了一个动力学系统中的<strong>强吸引子</strong>——一旦掉进去，就出不来了。</p>
</li>
</ul>
<h4 data-id="heading-11">2. 线性代数视角：满秩与“各向异性”</h4>
<p>“满秩”是指 Decoder 的 Masked Attention Matrix（下三角矩阵）理论上是满秩的（对角线非零即可逆）。</p>
<ul>
<li>
<p><strong>满秩 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo mathvariant="normal">≠</mo></mrow><annotation encoding="application/x-tex">\neq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"/><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"/><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"/></span></span></span></span><span class="mrel">=</span></span></span></span></span></span> 均匀分布：</strong></p>
<p>矩阵满秩只意味着行向量线性无关，意味着模型<strong>有能力</strong>关注到每一个历史时刻。但是，<strong>Attention 的核心是 Softmax</strong>。</p>
<p><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>Attention</mtext><mo stretchy="false">(</mo><mi>Q</mi><mo separator="true">,</mo><mi>K</mi><mo separator="true">,</mo><mi>V</mi><mo stretchy="false">)</mo><mo>=</mo><mtext>Softmax</mtext><mo stretchy="false">(</mo><mfrac><mrow><mi>Q</mi><msup><mi>K</mi><mi>T</mi></msup></mrow><msqrt><msub><mi>d</mi><mi>k</mi></msub></msqrt></mfrac><mo stretchy="false">)</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">\text{Attention}(Q, K, V) = \text{Softmax}(\frac{QK^T}{\sqrt{d_k}})V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mord text"><span class="mord">Attention</span></span><span class="mopen">(</span><span class="mord mathnormal">Q</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:1.6275em;vertical-align:-0.538em;"/><span class="mord text"><span class="mord">Softmax</span></span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"/><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0895em;"><span style="top:-2.5864em;"><span class="pstrut" style="height:3em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord sqrt mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8622em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"/><span class="mord mtight" style="padding-left:0.833em;"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3488em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"/><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1512em;"><span/></span></span></span></span></span></span></span><span style="top:-2.8222em;"><span class="pstrut" style="height:3em;"/><span class="hide-tail mtight" style="min-width:0.853em;height:1.08em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="1.08em" viewbox="0 0 400000 1080" preserveaspectratio="xMinYMin slice"><path d="M95,702&#10;c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14&#10;c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54&#10;c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10&#10;s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429&#10;c69,-144,104.5,-217.7,106.5,-221&#10;l0 -0&#10;c5.3,-9.3,12,-14,20,-14&#10;H400000v40H845.2724&#10;s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7&#10;c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z&#10;M834 80h400000v40h-400000z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1778em;"><span/></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"/><span class="frac-line" style="border-bottom-width:0.04em;"/></span><span style="top:-3.4461em;"><span class="pstrut" style="height:3em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">Q</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9191em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"/><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.538em;"><span/></span></span></span></span><span class="mclose nulldelimiter"/></span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></span></p>
</li>
<li>
<p><strong>Softmax 的稀疏化倾向：</strong></p>
<p>Softmax 是一个指数函数，它会极大地放大 Logits 之间的微小差异。</p>
<p>假设 Context 中有 100 个 token，如果第 99 个 token 和当前的 Query 相似度稍微高一点（比如点积是 10，其他是 5），经过 Softmax 后，第 99 个 token 的权重可能接近 0.99，而其他 99 个 token 的权重之和不到 0.01。</p>
<p><strong>虽然矩阵在数学上是满秩的，但在数值上，它退化成了一个极其稀疏的矩阵（接近 One-hot）。</strong> 这导致模型实际上“看不见”其他的上下文，只能看到那个引发它复读的 token。</p>
</li>
</ul>
<h4 data-id="heading-12">3. 几何视角：表示空间的坍缩 (Representation Collapse)</h4>
<p>这是更深层的解释，涉及到 Embedding 空间的几何形状。</p>
<ul>
<li>
<p><strong>锥形效应 (The Cone Effect)：</strong></p>
<p>研究发现，深层 Transformer 的 Token Embedding 往往存在<strong>各向异性（Anisotropy）</strong> 。即所有的 Token 向量都挤在向量空间的一个狭窄圆锥体内。</p>
</li>
<li>
<p><strong>余弦相似度的失效：</strong></p>
<p>当所有向量都挤在一起时，它们之间的余弦相似度都很高。为了区分它们，模型必须极度依赖局部的最近邻关系。</p>
<p>当出现重复时，重复的 token 在空间中是重叠的。模型为了“省力”（最小化损失），倾向于直接复制最近的强信号，而不是去从长距离上下文中推理复杂的语义。</p>
</li>
</ul>
<p>所以，复读机不是“由于矩阵缺秩导致无法访问历史信息”，而是“<strong>由于概率分布的峰值化（Peaking）和自回归的惯性，导致模型主动选择了重复</strong>”。</p>
<p>这也是为什么在推理阶段，我们必须引入<strong>工程手段</strong>来打破这个循环，例如：</p>
<ol>
<li><strong>Temperature &gt; 0：</strong> 强制展平概率分布，增加随机性。</li>
<li><strong>Repetition Penalty（重复惩罚）：</strong> 人为降低已出现 token 的 Logits。</li>
<li><strong>Top-P / Top-K Sampling：</strong> 截断长尾，但也防止单纯的 Argmax 陷入局部最优。</li>
</ol>
<h3 data-id="heading-13">总结</h3>
<p>所以，为什么现在的LLM都是Decoder-only架构？</p>
<ol>
<li><strong>因果律（Causal Mask）</strong>  导致了 <strong>数学上的下三角结构</strong>。</li>
<li><strong>下三角结构 + Softmax</strong> 保证了 <strong>矩阵永远满秩</strong>。</li>
<li><strong>满秩</strong> 确保了 <strong>特征空间的维度不坍塌</strong>，从而让模型能够承载更大规模的知识</li>
</ol>
<p>Encoder 的双向注意力虽然在“获取上下文”上更直观，但由于缺乏结构性约束，在大规模参数下容易陷入低秩陷阱（过平滑）。而 <strong>Decoder-only 架构通过“舍弃”未来的视野，换取了数学上更稳健、秩更高、表达力更持久的表征空间。</strong> 这正是为什么 GPT 系列（Decoder-only）能扩展到千亿、万亿参数而不断裂，而 BERT 系列（Encoder）在扩大规模时边际效应递减更快的原因之一。</p>
<hr/>
<p>了解完低秩坍塌的问题之后，你是否疑惑，为什么低秩矩阵会出现坍塌，但是LoRA（低秩矩阵）在大模型微调中还那么火呢？请参考<a href="https://juejin.cn/post/7602064004317708351" target="_blank" title="https://juejin.cn/post/7602064004317708351">【LLM】为什么LoRA中低秩矩阵是一个优势？</a></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[🎇2025 AI/Vibe Coding 对我的影响 | 年终征文获奖公示]]></title>    <link>https://juejin.cn/post/7602216700747792384</link>    <guid>https://juejin.cn/post/7602216700747792384</guid>    <pubDate>2026-02-03T09:50:21.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602216700747792384" data-draft-id="7602205524718911522" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="🎇2025 AI/Vibe Coding 对我的影响 | 年终征文获奖公示"/> <meta itemprop="keywords" content="前端,人工智能,Trae"/> <meta itemprop="datePublished" content="2026-02-03T09:50:21.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="掘金酱"/> <meta itemprop="url" content="https://juejin.cn/user/1556564194374926"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            🎇2025 AI/Vibe Coding 对我的影响 | 年终征文获奖公示
            <!----> <!----></h1> <div class="container team-follow" data-v-d326b38e="" data-v-61fb5e44=""><div class="left" data-v-d326b38e=""><a href="/team/7255271989291450420/posts" data-v-d326b38e=""><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b3e5e62bb3a4eff89269d51825c4a1f~tplv-k3u1fbpfcp-watermark.image?" class="icon" data-v-d326b38e=""/></a> <div class="content" data-v-d326b38e=""><div style="display: flex" data-v-d326b38e=""><a href="/team/7255271989291450420/posts" data-v-d326b38e=""><p class="title-line" data-v-d326b38e=""><span title="掘金运营团队" class="title" data-v-d326b38e="">掘金运营团队</span> <img src="//lf-web-assets.juejin.cn/obj/juejin-web/xitu_juejin_web/255e400027b783cbad76dc41527e7695.svg" alt="team icon" class="team-icon" data-v-d326b38e=""/></p></a></div> <div class="meta-box team" data-v-d326b38e="" data-v-61fb5e44=""><time datetime="2026-02-03T09:50:21.000Z" title="Tue Feb 03 2026 09:50:21 GMT+0000 (Coordinated Universal Time)" class="time" data-v-d326b38e="" data-v-61fb5e44="">
                2026-02-03
              </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-d326b38e="" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-d326b38e="" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-d326b38e="" data-v-61fb5e44=""/></svg> <span class="views-count" style="display:none;" data-v-d326b38e="" data-v-61fb5e44="">
                3
              </span> <span class="read-time" data-v-d326b38e="" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-d326b38e="" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-d326b38e="" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-d326b38e="" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-d326b38e="" data-v-61fb5e44=""/></svg>
                阅读3分钟
              </span> <!----> <!----></div></div></div> <button class="jj-follow-button follow-btn" style="display:none;" data-v-b60b2868="" data-v-d326b38e=""><span data-v-b60b2868="" data-v-d326b38e=""><i class="byte-icon byte-icon--plus" data-v-d326b38e=""><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 48 48"><path fill="none" d="M0 0h48v48H0z"/><path d="M24.7 4c.4 0 .6 0 .8.1.2.1.3.2.4.4.1.2.1.3.1.8V22h16.7c.4 0 .6 0 .8.1.2.1.3.2.4.4.1.2.1.3.1.8v1.4c0 .4 0 .6-.1.8-.1.2-.2.3-.4.4-.2.1-.3.1-.8.1H26v16.7c0 .4 0 .6-.1.8-.1.2-.2.3-.4.4-.2.1-.3.1-.8.1h-1.4c-.4 0-.6 0-.8-.1-.2-.1-.3-.2-.4-.4-.1-.2-.1-.3-.1-.8V26H5.3c-.4 0-.6 0-.8-.1-.2-.1-.3-.2-.4-.4-.1-.2-.1-.3-.1-.8v-1.4c0-.4 0-.6.1-.8.1-.2.2-.3.4-.4.2-.1.3-.1.8-.1H22V5.3c0-.4 0-.6.1-.8.1-.2.2-.3.4-.4.2-.1.3-.1.8-.1h1.4z"/></svg></i>
        关注
      </span></button></div> <div class="team-user block-hidden" data-v-61fb5e44=""><div class="avatar jj-avatar avatar" data-v-03256cc6="" data-v-61fb5e44=""><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8AQMAAAAAMksxAAAAA1BMVEUAAACnej3aAAAAAXRSTlMAQObYZgAAAA5JREFUKM9jGAWjAAcAAAIcAAE27nY6AAAAAElFTkSuQmCC" alt="avatar" class="lazy avatar-img" data-v-5244ef91="" data-v-03256cc6=""/> </div> <!----> <span class="position ellipsis" data-v-61fb5e44="">
              ❤首席客服君 @掘金
            </span></div> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:14px;overflow-x:hidden;color:var(--cyanosis-base-color);transition:color .35s;--cyanosis-base-color:#353535;--cyanosis-title-color:#005bb7;--cyanosis-strong-color:#2196f3;--cyanosis-em-color:#4fc3f7;--cyanosis-del-color:#ccc;--cyanosis-link-color:#3da8f5;--cyanosis-linkh-color:#007fff;--cyanosis-border-color:#bedcff;--cyanosis-border-color-2:#ececec;--cyanosis-bg-color:#fff;--cyanosis-blockquote-color:#8c8c8c;--cyanosis-blockquote-bg-color:#f0fdff;--cyanosis-code-color:#c2185b;--cyanosis-code-bg-color:#fff4f4;--cyanosis-code-pre-color:#f8f8f8;--cyanosis-table-border-color:#c3e0fd;--cyanosis-table-th-color:#dff0ff;--cyanosis-table-tht-color:#005bb7;--cyanosis-table-tr-nc-color:#f7fbff;--cyanosis-table-trh-color:#e0edf7;--cyanosis-slct-title-color:#005bb7;--cyanosis-slct-titlebg-color:rgba(175,207,247,0.25);--cyanosis-slct-text-color:#c80000;--cyanosis-slct-bg-color:rgba(175,207,247,0.25);--cyanosis-slct-del-color:#999;--cyanosis-slct-elbg-color:#e8ebec;--cyanosis-slct-codebg-color:#ffeaeb;--cyanosis-slct-prebg-color:rgba(160,200,255,0.25)}.markdown-body.__dark{--cyanosis-base-color:#cacaca;--cyanosis-title-color:#ddd;--cyanosis-strong-color:#fe9900;--cyanosis-em-color:#ffd28e;--cyanosis-del-color:#ccc;--cyanosis-link-color:#ffb648;--cyanosis-linkh-color:#fe9900;--cyanosis-border-color:#ffe3ba;--cyanosis-border-color-2:#ffcb7b;--cyanosis-bg-color:#2f2f2f;--cyanosis-blockquote-color:#c7c7c7;--cyanosis-blockquote-bg-color:rgba(255,199,116,0.1);--cyanosis-code-color:#000;--cyanosis-code-bg-color:#ffcb7b;--cyanosis-code-pre-color:rgba(255,227,185,0.5);--cyanosis-table-border-color:#fe9900;--cyanosis-table-th-color:#ffb648;--cyanosis-table-tht-color:#000;--cyanosis-table-tr-nc-color:#6d5736;--cyanosis-table-trh-color:#947443;--cyanosis-slct-title-color:#000;--cyanosis-slct-titlebg-color:#fe9900;--cyanosis-slct-text-color:#00c888;--cyanosis-slct-bg-color:rgba(175,207,247,0.25);--cyanosis-slct-del-color:#999;--cyanosis-slct-elbg-color:#000;--cyanosis-slct-codebg-color:#ffcb7b;--cyanosis-slct-prebg-color:rgba(160,200,255,0.25)}.markdown-body h1{padding-bottom:4px;font-size:30px}.markdown-body h1,.markdown-body h2{margin-top:36px;margin-bottom:10px;line-height:1.5;color:var(--cyanosis-title-color);transition:color .35s}.markdown-body h2{position:relative;padding-left:10px;padding-right:10px;padding-bottom:10px;font-size:24px;border-bottom:1px solid var(--cyanosis-border-color-2)}.markdown-body h2:before{content:"「";position:absolute;top:-6px;left:-14px}.markdown-body h2:after{content:"」";position:relative;top:6px;right:auto}.markdown-body h3{position:relative;padding-bottom:0;margin-top:30px;margin-bottom:10px;font-size:20px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body h3:before{content:"»";padding-right:6px;color:var(--cyanosis-strong-color)}.markdown-body h4{margin-top:24px;font-size:16px}.markdown-body h4,.markdown-body h5{padding-bottom:0;margin-bottom:10px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body h5{margin-top:18px;font-size:14px}.markdown-body h6{padding-bottom:0;margin-top:12px;margin-bottom:10px;font-size:12px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body p{line-height:inherit;margin-top:16px;margin-bottom:16px}.markdown-body img{max-width:100%}.markdown-body hr{position:relative;width:98%;height:1px;margin-top:32px;margin-bottom:32px;background-image:linear-gradient(90deg,var(--cyanosis-link-color),rgba(255,0,0,.3),hsla(0,0%,100%,.1),rgba(255,0,0,.3),var(--cyanosis-link-color));border-width:0;overflow:visible}.markdown-body hr:after{content:"";position:absolute;margin:auto;left:0;right:0;bottom:0;top:0;display:inline-block;width:60px;height:20px;background-color:var(--cyanosis-bg-color);background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAgCAYAAABgrToAAAADoklEQVRYR82XTYgcRRTHf2933Q1RjAa9eFO8JHoJ8RQVBQ2iBwXBET0YEUTXNVmNQtTpmeqaWV0XNRq/o4KoECSCEPSg4CF+BYUkIIiCoCJCPIhC/Ihh2Z0nVV27VnZnenumW9i6ddV7//frV69fVQurfMgq56NawFTPAU6QyomqXrw6wIZeyhCPebA5buNR+akKyGoAjd6BshthnYdSjqNcRVuOlIUsD2j0SuA94IwuMHdh5ZUykOUBXfSGbmKI54EtAeYIHSZoy5dl4JxvNYBOKdW1KE8BQ8AkVk6WhasWsAiN0TX9gveXQaPP+Aytpc4u+bMI06JNohsYYYYOR2lJWtS3OKDRfcAtQfgDoI6Vo4UCGb0OmAEuDvZvYmVbEd/igC3dzDz7gQu8sPA9kJDK27mBmjqBeLjTg90PDFOjWawFFQd06kZHEfaj3LAIpTRpSXsZ5E06zEYP9sDimnAApYaV2SLZG/wjMeqAkijwW4xQJ5Gf/ZzRC8OW3hiBTGGlURRswW55Bh/Ssxljrwew8l1PQaM14GngvGDzBUKdDsMeTtgU5o8B92PFlUf3YXUrHa7Fys6lBqcCGnX15YQ2A18FyPd7Crd1A3M8C1wdbH4DD3hWeP6IEXbQkG97ajR1HPFnuPP5jFFq1OWX7hl8WM9l1AO648uNfwLk7tytMeogty+xeQ4rO3r6bdcx1nuwOGsHmaXGtPzae4uzGnLH1kQkvpdZGrHjssBZJrL+pqS05KWc8tgITAPXRzYvYOXe/C2OV43eDcRBDtIhoS2f9wzc0Cv8Wls+zoFzUC5zF0U241h5uZtPfptp6OUM8wbK+cH5GEpCS17P3fJei0Z3+npTxryJ8CPzbKMtn/ZyWbkPGl0PuFPkmkjkcb4h4R2ZLwRq1H0ALmvjkf2HwK1Y+T1PY2XABe/sHJ6MxN5lnoSpnC/UGbsTaI5phK2R7x6s3Ffk5YoDOrWm3onwJHBmEP86bPmBrsGaenNoIdnxCH+gPEhLXi0Cl1VBvyPVLSh7gEuC62yAfOIUqabWEaaiucMIk6RyqJ+Q/QM69V26jjW86Gvov/EaoyT8zRCn+Xq7PVrbx0nuYUaO9wM3WAbjCE1NEUw09Um4UV+2OKfYfu5/S19gsAzGKqm6LE5FrShbdS0ku465DjDwKA/oQht19ejqbaEVuRbiLhuHByYLjtUAZpDutzP7cYdHsPJXWbjyNVgFwQoa1WXwf4Jd9YD/Ap80+yE7+u9aAAAAAElFTkSuQmCC);background-repeat:no-repeat;background-size:auto 100%;background-position-x:center;transition:background-color .5s}.markdown-body code{padding:.065em .4em;font-size:.87em;color:var(--cyanosis-code-color);word-break:break-word;overflow-x:auto;background-color:var(--cyanosis-code-bg-color);border-radius:2px}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{display:block;padding:16px 12px;margin:0;font-size:12px;color:#333;word-break:normal;overflow-x:auto;background:var(--cyanosis-code-pre-color)}.markdown-body pre&gt;code::-webkit-scrollbar{width:4px;height:4px}.markdown-body pre&gt;code::-webkit-scrollbar-track{background-color:var(--cyanosis-border-color)}.markdown-body pre&gt;code::-webkit-scrollbar-thumb{background-color:var(--cyanosis-strong-color);border-radius:10px}.markdown-body a{position:relative;text-decoration:none;color:var(--cyanosis-link-color);border-bottom:1px solid var(--cyanosis-border-color)}.markdown-body a:hover{border-bottom-color:var(--cyanosis-linkh-color)}.markdown-body a:active,.markdown-body a:hover{color:var(--cyanosis-linkh-color)}.markdown-body a:after{position:absolute;content:"";top:100%;left:0;width:100%;opacity:0;border-bottom:1px solid var(--cyanosis-border-color);transition:top .3s,opacity .3s;transform:translateZ(0)}.markdown-body a:hover:after{top:0;opacity:1;border-bottom-color:var(--cyanosis-linkh-color)}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid var(--cyanosis-table-border-color);border-spacing:0;border-collapse:collapse}.markdown-body table thead{color:#000;text-align:left;font-size:14px;background:#f6f6f6}.markdown-body table tr:nth-child(2n){background-color:var(--cyanosis-table-tr-nc-color)}.markdown-body table tr:hover{background-color:var(--cyanosis-table-trh-color)}.markdown-body table td,.markdown-body table th{padding:12px 8px;line-height:24px;border:1px solid var(--cyanosis-table-border-color)}.markdown-body table th{color:var(--cyanosis-table-tht-color);background-color:var(--cyanosis-table-th-color)}.markdown-body table td{min-width:120px}.markdown-body blockquote{color:var(--cyanosis-blockquote-color);border-left:4px solid var(--cyanosis-strong-color);background-color:var(--cyanosis-blockquote-bg-color);padding:1px 20px;margin:22px 0;transition:color .35s}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body b,.markdown-body blockquote&gt;b,.markdown-body blockquote&gt;strong,.markdown-body strong{color:var(--cyanosis-strong-color)}.markdown-body em,.markdown-body i{color:var(--cyanosis-em-color)}.markdown-body del{color:var(--cyanosis-del-color)}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:4px}.markdown-body ol li{padding-left:6px}.markdown-body details&gt;summary{outline:none;color:var(--cyanosis-title-color);font-size:20px;font-weight:bolder;border-bottom:1px solid var(--cyanosis-border-color);cursor:pointer}.markdown-body details&gt;p{padding:10px 20px;margin:10px 0 0;color:#666;background-color:var(--cyanosis-blockquote-bg-color);border:2px dashed var(--cyanosis-strong-color)}.markdown-body h1::selection,.markdown-body h2::selection,.markdown-body h3::selection,.markdown-body h4::selection,.markdown-body h5::selection,.markdown-body h6::selection{color:var(--cyanosis-slct-title-color);background-color:var(--cyanosis-slct-titlebg-color)}.markdown-body ol li::selection,.markdown-body p::selection,.markdown-body ul li::selection{color:var(--cyanosis-slct-text-color);background-color:var(--cyanosis-slct-bg-color)}.markdown-body a::selection,.markdown-body b::selection,.markdown-body em::selection,.markdown-body i::selection,.markdown-body strong::selection{background-color:var(--cyanosis-slct-elbg-color)}.markdown-body del::selection{color:var(--cyanosis-slct-del-color);background-color:var(--cyanosis-slct-elbg-color)}.markdown-body table thead th::selection{background-color:transparent}.markdown-body table tbody td::selection{background-color:var(--cyanosis-slct-bg-color)}.markdown-body code::selection{background-color:var(--cyanosis-slct-codebg-color)}.markdown-body pre&gt;code::selection{background-color:var(--cyanosis-slct-prebg-color)}.markdown-body .contains-task-list{padding-left:14px;list-style:none}.markdown-body .contains-task-list input[type=checkbox]{position:relative}.markdown-body .contains-task-list input[type=checkbox]:before{content:"";position:absolute;top:0;left:0;right:0;bottom:0;width:inherit;height:inherit;background:#f0f8ff;border:1px solid #add6ff;border-radius:2px;box-sizing:border-box;z-index:1}.markdown-body .contains-task-list input[type=checkbox]:checked:after{content:"✓";position:absolute;top:-12px;left:0;right:0;bottom:0;width:0;height:0;color:#f55;font-size:20px;font-weight:700;z-index:2}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="atom-one-dark">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#abb2bf;background:#282c34}.hljs-comment,.hljs-quote{color:#5c6370;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#c678dd}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e06c75}.hljs-literal{color:#56b6c2}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#98c379}.hljs-built_in,.hljs-class .hljs-title{color:#e6c07b}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#d19a66}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#61aeee}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}</style><p>🎉2025年 “AI/Vibe Coding 对我的影响” 年终征文 正式落幕啦！</p>
<p>本期活动共有 <strong>300＋</strong> 位用户参与这场专属社区的年终“围炉夜话”，感谢每位掘友的付出！</p>
<p>从智能体（Agent）的横空出世到多模态技术的经验突破，技术愈加深入地流淌进我们的工作和生活。掘友们每一次的记录，都共同塑造着专属于社区的AI“数字年轮”</p>
<blockquote>
<p>由于瓜分奖池用户较多，详细的名单公示如下：<a href="https://link.juejin.cn?target=https%3A%2F%2Fbytedance.larkoffice.com%2Fsheets%2FK5WVsTzDYhXuevt0MTycORMpnDe%3Fsheet%3D7dUioD" target="_blank" title="https://bytedance.larkoffice.com/sheets/K5WVsTzDYhXuevt0MTycORMpnDe?sheet=7dUioD" ref="nofollow noopener noreferrer">2025年度技术总结征文活动_获奖名单</a></p>
</blockquote>
<blockquote>
<p>如何快速找到自己：进入飞书表格后，使用 Ctr+F 搜索自己的用户名或 用户id，选择“所有工作表”（ 用户 id 即掘金主页 <a href="https://juejin.cn/XXXXXX" title="https://juejin.cn/XXXXXX" target="_blank">juejin.cn/XXXXXX</a> 最后的一串数字）。之前打开过本表同学请刷新表单，奖项或有增补，以最新的表格为准。</p>
</blockquote>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d61cfa5b44d8423f8b052b03531f9e61~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5o6Y6YeR6YWx:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770717020&amp;x-signature=3dbGt%2BJueJkvGmME5EiiQ3Mtv%2Fs%3D" alt="image.png" loading="lazy"/></p>
<h2 data-id="heading-0">活动奖品</h2>
<blockquote>
<p><em>文章将根据<strong>专家评审得分</strong>（占比70%）和<strong>文章热度</strong>（占比30%）得分加权计算。<strong>未获得官方推荐</strong>的文章不参与奖项评选。</em></p>
</blockquote>





























































<table><thead><tr><th>奖项名称</th><th>奖项设置</th><th>获奖人数</th><th>奖品名称</th><th>奖品图</th></tr></thead><tbody><tr><td><strong>优秀文章奖</strong></td><td>文章Top 10</td><td>10名</td><td>小熊（Bear）电烧烤炉 多功能料理锅电烤炉 DKL-D12A1</td><td><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cfe1f14ebbba4ef4b00c4f1c9f804a58~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5o6Y6YeR6YWx:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770717020&amp;x-signature=Fgdh9PCNn0n6eCu3r1BzH3m7UaE%3D" alt="image.png" loading="lazy"/></td></tr><tr><td><strong>掘金达人奖</strong></td><td>文章Top 11-40</td><td>30名</td><td>稀土掘金 Yoyo抱枕新版-450g</td><td><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b0994f46b5f64a0983edcae0dcaf582b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5o6Y6YeR6YWx:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770717020&amp;x-signature=Dtkb6BXzf2GkIr%2BhZWGezpph%2FD0%3D" alt="" loading="lazy"/></td></tr><tr><td><strong>阳光普照奖</strong></td><td>文章Top 41-100</td><td>60名</td><td>稀土掘金 x ByteMall 联名盲盒</td><td><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2a503e8c6651439081513b9eebf0e548~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5o6Y6YeR6YWx:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770717020&amp;x-signature=tBnvDswwowSpUXLvDpOZiAaQovI%3D" alt="" loading="lazy"/></td></tr><tr><td><strong>TRAE特别赛道鼓励奖（叠加）</strong></td><td>TOP1-10</td><td>10名</td><td>价值200元 TRAE连帽卫衣+抱枕</td><td><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3df35e973e984ffabc678b056123c053~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5o6Y6YeR6YWx:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770717020&amp;x-signature=%2FiZv%2FHVCGoQsRPOtgHHy5JEOTxw%3D" alt="" loading="lazy"/><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a9cdcce418454a83810d84be38fcfc78~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5o6Y6YeR6YWx:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770717020&amp;x-signature=G9PFHdpe%2Ffs%2BbWW1FpuZZMbOu8g%3D" alt="" loading="lazy"/></td></tr><tr><td><strong>TRAE特别赛道鼓励奖（叠加）</strong></td><td>TOP11-30</td><td>20名</td><td>价值100元 TRAE圆领卫衣</td><td><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cea27183efa24e44b251b24b35ba9434~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5o6Y6YeR6YWx:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770717020&amp;x-signature=kgBITZcwHe4pmsyqsM5OLs9LmN4%3D" alt="" loading="lazy"/></td></tr><tr><td><strong>TRAE特别赛道鼓励奖（叠加）</strong></td><td>TOP31-50</td><td>20名</td><td>价值50元 TRAE单肩包</td><td><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/148795305e4248a684ba2a4c95709a06~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5o6Y6YeR6YWx:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770717020&amp;x-signature=f6GeeqUoV19XppWnd44PqaPb5LU%3D" alt="" loading="lazy"/></td></tr><tr><td><strong>TRAE特别赛道鼓励奖（叠加）</strong></td><td>TOP51-100</td><td>50名</td><td>TRAE小鼠标垫</td><td><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/23f8a2ea09714ea1ac2d9b8a41ce3248~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5o6Y6YeR6YWx:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770717020&amp;x-signature=xzAw7f1sal2tg6Rb4tJjBnqabWE%3D" alt="" loading="lazy"/></td></tr></tbody></table>
<h2 data-id="heading-1">领奖方式</h2>
<ul>
<li>获得上述奖项的掘友近期请注意 <strong>[系统消息]</strong> （预计2026年2月3日23:00前下发），请于 <strong>2026 年 2 月 9 日 23 点</strong> 之前在相关问卷中填写信息，过期将视为放弃奖品。</li>
<li>奖品将于问卷截止日期后的 30 个工作日内完成发放。</li>
</ul>
<p><strong>若对获奖名单有疑问，请先自查文章，确认无以下原因后，可点击联系 <a href="https://juejin.cn/user/3806975299161875" target="_blank" title="https://juejin.cn/user/3806975299161875">Sweet_Ystar</a> 进行申诉。</strong> 申诉处理时间2026年2月3日-2026年2月9日，过时维持原结果。</p>
<ol>
<li>
<p>文章须为<strong>原创文章</strong>，内容符合<a href="https://juejin.cn/book/6844733795329900551/section/6844733795380232199" target="_blank" title="https://juejin.cn/book/6844733795329900551/section/6844733795380232199">掘金社区的内容标准和规范</a>。</p>
</li>
<li>
<p>本次征文<strong>不限制文章题材</strong>，可以是你对行业的总结和见解，也可以是你对行业未来发展的预测，本次活动不接受下面几种文章：</p>
<ol>
<li>资源聚合类文章，例如 Awesome-List；</li>
<li>翻译类文章和利用AI生产文章；</li>
<li>与本次主题无关的文章；</li>
<li>学习笔记/知识点汇总类文章；</li>
<li>有失中立性、公正性的内容，比如由公司或者公司的代理机构（如公关公司）所撰写，单纯希望宣传自己的商业产品或者公司的内容；</li>
<li>内容与活动主题不符、非原创内容，有洗稿、营销软文、广告、抄袭嫌疑的文章。</li>
</ol>
</li>
<li>
<p>刷赞、刷量等有作弊行为的文章，直接取消比赛资格，不参与评选；</p>
</li>
<li>
<p>AI代写文章、AI聊天记录等不计入活动（AI检测超过<strong>70%</strong> 取消文章获奖资格）；</p>
</li>
<li>
<p>活动文章需要选择话题：<a href="https://juejin.cn/theme/detail/7586482726807535666?contentType=1" target="_blank" title="https://juejin.cn/theme/detail/7586482726807535666?contentType=1">juejin.cn/theme/detai…</a></p>
</li>
<li>
<p>获奖作品，著作权归作者所有，掘金拥有使用权；</p>
</li>
</ol>
<h5 data-id="heading-2"><em>活动期间，若发布文章内容与选择标签不符（无相关性）、AI撰稿痕迹≥50%，则取消该用户所有文章获奖资格。</em></h5></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[JavaScript面向对象编程的演变]]></title>    <link>https://juejin.cn/post/7602259669730885659</link>    <guid>https://juejin.cn/post/7602259669730885659</guid>    <pubDate>2026-02-03T06:15:59.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602259669730885659" data-draft-id="7602252722373771315" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="JavaScript面向对象编程的演变"/> <meta itemprop="keywords" content="前端,JavaScript"/> <meta itemprop="datePublished" content="2026-02-03T06:15:59.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="wuhen_n"/> <meta itemprop="url" content="https://juejin.cn/user/4149996261738233"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            JavaScript面向对象编程的演变
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4149996261738233/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    wuhen_n
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T06:15:59.000Z" title="Tue Feb 03 2026 06:15:59 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    10
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>JavaScript 是产生“类”的？又是如何演变成“面向对象”的？Class语法糖背后隐藏着什么秘密？本篇文章将完整梳理 JavaScript 面向对象编程的发展历程。</p>
</blockquote>
<h2 data-id="heading-0">前言：为什么JavaScript需要面向对象？</h2>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">var</span> name = <span class="hljs-string">'张三'</span>;
<span class="hljs-keyword">var</span> age = <span class="hljs-number">25</span>;
<span class="hljs-keyword">var</span> job = <span class="hljs-string">'工程师'</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHello</span>(<span class="hljs-params">person</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'你好，我是'</span> + person.<span class="hljs-property">name</span>);
}
</code></pre>
<p>在早期的 JavaScript 代码中，我们通常采用的是过程式编程。但随着应用复杂度增加，我们需要更好的代码组织方式，因此面向对象编程应运而生。</p>
<h2 data-id="heading-1">工厂模式：面向对象的雏形</h2>
<h3 data-id="heading-2">什么是工厂模式？</h3>
<p><strong>工厂模式</strong> 是最简单的创建对象的方式，它就像一个“工厂”一样批量生产对象。我们来看一个简单的工厂模式示例：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 创建Person对象的工厂</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">createPerson</span>(<span class="hljs-params">name, age, job</span>) {
    <span class="hljs-comment">// 1. 创建一个新对象</span>
    <span class="hljs-keyword">var</span> obj = {};
    
    <span class="hljs-comment">// 2. 添加属性</span>
    obj.<span class="hljs-property">name</span> = name;
    obj.<span class="hljs-property">age</span> = age;
    obj.<span class="hljs-property">job</span> = job;
    
    <span class="hljs-comment">// 3. 添加方法</span>
    obj.<span class="hljs-property">sayHello</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'你好，我是'</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">'，今年'</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> + <span class="hljs-string">'岁'</span>);
    };
    
    obj.<span class="hljs-property">work</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">'正在工作：'</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">job</span>);
    };
    
    <span class="hljs-comment">// 4. 返回对象</span>
    <span class="hljs-keyword">return</span> obj;
}

<span class="hljs-comment">// 使用工厂模式创建对象</span>
<span class="hljs-keyword">var</span> person1 = <span class="hljs-title function_">createPerson</span>(<span class="hljs-string">'张三'</span>, <span class="hljs-number">25</span>, <span class="hljs-string">'前端工程师'</span>);
<span class="hljs-keyword">var</span> person2 = <span class="hljs-title function_">createPerson</span>(<span class="hljs-string">'李四'</span>, <span class="hljs-number">30</span>, <span class="hljs-string">'后端工程师'</span>);

person1.<span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// 你好，我是张三，今年25岁</span>
person2.<span class="hljs-title function_">work</span>();     <span class="hljs-comment">// 李四正在工作：后端工程师</span>

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person1.<span class="hljs-property">sayHello</span> === person2.<span class="hljs-property">sayHello</span>); <span class="hljs-comment">// false</span>
</code></pre>
<p>但这种方式存在一个问题：每个对象都有独立的方法副本，浪费内存。</p>
<h3 data-id="heading-3">工厂模式的优点</h3>
<ol>
<li>简单易懂</li>
<li>可以创建多个相似对象</li>
<li>封装了创建过程</li>
</ol>
<h3 data-id="heading-4">工厂模式的缺点</h3>
<ol>
<li>无法识别对象类型：<code>person1 instanceof createPerson;  // false</code></li>
<li>方法重复创建，内存浪费</li>
</ol>
<h2 data-id="heading-5">构造函数模式：引入"类型"概念</h2>
<h3 data-id="heading-6">什么是构造函数？</h3>
<p><strong>构造函数</strong>通过 <code>new</code> 关键字创建对象，解决了工厂模式的类型识别问题。我们来看一个简单的示例：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 构造函数模式</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age, job</span>) {
    <span class="hljs-comment">// 1. 创建一个新对象（隐式：this = {}）</span>
    <span class="hljs-comment">// 2. 设置原型链（隐式：this.__proto__ = Person.prototype）</span>
    <span class="hljs-comment">// 3. 添加属性</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">job</span> = job;
    
    <span class="hljs-comment">// 4. 添加方法（仍然有问题）</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">sayHello</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'你好，我是'</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);
    };
    <span class="hljs-comment">// 5. 返回this（隐式：return this）</span>
}

<span class="hljs-comment">// 使用new关键字创建对象（实例）</span>
<span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">'张三'</span>, <span class="hljs-number">25</span>, <span class="hljs-string">'工程师'</span>);
<span class="hljs-keyword">var</span> person2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">'李四'</span>, <span class="hljs-number">30</span>, <span class="hljs-string">'设计师'</span>);

person1.<span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// 你好，我是张三</span>
person2.<span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// 你好，我是李四</span>

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person1 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>); <span class="hljs-comment">// true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person1 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>); <span class="hljs-comment">// true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person1.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Person</span>); <span class="hljs-comment">// true</span>

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person1.<span class="hljs-property">sayHello</span> === person2.<span class="hljs-property">sayHello</span>); <span class="hljs-comment">// false</span>
</code></pre>
<p>从上述代码中，我们可以看出：构造函数模式中，可以识别对象类型了；但每个实例仍有独立的方法副本，内存浪费问题仍然存在。</p>
<h3 data-id="heading-7">new操作符的工作原理</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myNew</span>(<span class="hljs-params">constructor, ...args</span>) {
    <span class="hljs-comment">// 1. 创建一个新对象</span>
    <span class="hljs-keyword">const</span> obj = {};
    <span class="hljs-comment">// 2. 设置原型链：将新对象的__proto__指向构造函数的prototype</span>
    obj.<span class="hljs-property">__proto__</span> = constructor.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;
    <span class="hljs-comment">// const obj = Object.create(Constructor.prototype);  // 这种写法也是可以的</span>
    
    <span class="hljs-comment">// 3. 绑定this并执行构造函数</span>
    <span class="hljs-keyword">const</span> result = constructor.<span class="hljs-title function_">apply</span>(obj, args);
    
    <span class="hljs-comment">// 4. 返回结果（如果构造函数返回对象，则返回该对象，否则返回新对象）</span>
    <span class="hljs-keyword">return</span> result <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span> ? result : obj;
}
</code></pre>
<h2 data-id="heading-8">原型模式：解决方法共享问题</h2>
<p>原型模式的处理方法是：将方法定义在原型上，实现共享。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age</span>) {
    <span class="hljs-comment">// 属性定义在实例上（每个实例独立）</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;
}

<span class="hljs-comment">// 方法定义在原型上（所有实例共享）</span>
<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHello</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'你好，我是'</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">'，今年'</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> + <span class="hljs-string">'岁'</span>);
};

<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">work</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">'正在工作'</span>);
};

<span class="hljs-comment">// 创建实例</span>
<span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">'张三'</span>, <span class="hljs-number">25</span>);
<span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">'李四'</span>, <span class="hljs-number">30</span>);

p1.<span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// 你好，我是张三，今年25岁</span>
p2.<span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// 你好，我是李四，今年30岁</span>

<span class="hljs-comment">// 现在方法是共享的！</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-property">sayHello</span> === p2.<span class="hljs-property">sayHello</span>); <span class="hljs-comment">// true</span>
</code></pre>
<h3 data-id="heading-9">原型模式带来的问题</h3>
<ol>
<li>所有实例都会共享引用类型属性，如果在原型上定义引用类型，一个数据修改时，所有对象对应的数据都会修改</li>
<li>所有实例共享相同的原型属性，无法动态传递初始化参数</li>
</ol>
<h2 data-id="heading-10">组合继承：结合构造函数和原型的优点</h2>
<h3 data-id="heading-11">组合继承的实现</h3>
<p>组合继承的实现：使用构造函数定义实例属性，使用原型定义共享方法。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">colors</span> = [<span class="hljs-string">'red'</span>, <span class="hljs-string">'blue'</span>];
}

<span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);
};

<span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params">name, age</span>) {
    <span class="hljs-title class_">Parent</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name); <span class="hljs-comment">// 第一次调用：继承实例属性</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;
}

<span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent</span>(); <span class="hljs-comment">// 第二次调用：继承原型方法</span>
<span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Child</span>; <span class="hljs-comment">// 修复constructor指向</span>
</code></pre>
<blockquote>
<p>组合继承是JavaScript中最常用的继承模式。</p>
</blockquote>
<h3 data-id="heading-12">组合继承的缺点</h3>
<p>父类构造函数被调用了两次：</p>
<ol>
<li><code>Parent.call(this, name);</code>  第一次调用：继承实例属性</li>
<li><code>Child.prototype = new Parent();</code>  第二次调用：继承原型方法</li>
</ol>
<h2 data-id="heading-13">寄生组合继承：最理想的继承方式</h2>
<h3 data-id="heading-14">寄生组合继承的实现</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">inheritPrototype</span>(<span class="hljs-params">child, parent</span>) {
    <span class="hljs-comment">// 创建父类原型的副本</span>
    <span class="hljs-keyword">const</span> prototype = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(parent.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);
    
    <span class="hljs-comment">// 修复constructor指向</span>
    prototype.<span class="hljs-property">constructor</span> = child;
    
    <span class="hljs-comment">// 将副本设置为子类的原型</span>
    child.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = prototype;
}

<span class="hljs-comment">// 父类</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Animal</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">colors</span> = [<span class="hljs-string">'red'</span>, <span class="hljs-string">'blue'</span>];
}

<span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'我是：'</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);
};

<span class="hljs-comment">// 子类</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Dog</span>(<span class="hljs-params">name, age</span>) {
    <span class="hljs-comment">// 继承实例属性（只调用一次父类构造函数）</span>
    <span class="hljs-title class_">Animal</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;
}

<span class="hljs-comment">// 继承原型方法（不使用new Parent()，避免第二次调用）</span>
<span class="hljs-title function_">inheritPrototype</span>(<span class="hljs-title class_">Dog</span>, <span class="hljs-title class_">Animal</span>);

<span class="hljs-comment">// 添加子类特有方法</span>
<span class="hljs-title class_">Dog</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">bark</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">'在叫：汪汪！'</span>);
};
</code></pre>
<h2 data-id="heading-15">Class语法：ES6的语法糖</h2>
<h3 data-id="heading-16">Class的基本语法</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {
    <span class="hljs-comment">// 构造函数（对应ES5的构造函数）</span>
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, age</span>) {
        <span class="hljs-comment">// 实例属性</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">_secret</span> = <span class="hljs-string">'这是我的秘密'</span>; <span class="hljs-comment">// 约定俗成的"私有"属性</span>
    }
    
    <span class="hljs-comment">// 实例方法（自动添加到原型上）</span>
    <span class="hljs-title function_">introduce</span>(<span class="hljs-params"/>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`大家好，我是<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span>，今年<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.age}</span>岁`</span>);
    }
    <span class="hljs-title function_">eat</span>(<span class="hljs-params">food</span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span>正在吃<span class="hljs-subst">${food}</span>`</span>);
    }
    
    <span class="hljs-comment">// getter和setter</span>
    <span class="hljs-keyword">get</span> <span class="hljs-title function_">secret</span>() {
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_secret</span>;
    }
    
    <span class="hljs-keyword">set</span> <span class="hljs-title function_">secret</span>(<span class="hljs-params">value</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">_secret</span> = value;
    }
    
    <span class="hljs-comment">// 静态方法（类方法）</span>
    <span class="hljs-keyword">static</span> <span class="hljs-title function_">createAnonymous</span>(<span class="hljs-params"/>) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">'匿名'</span>, <span class="hljs-number">0</span>);
    }
}
</code></pre>
<h3 data-id="heading-17">Class语法背后的原型原理</h3>
<p>Class 语法只是语法糖，底层仍然是原型继承，其本质是一个函数：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> {
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
    }
    
    <span class="hljs-title function_">speak</span>(<span class="hljs-params"/>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">' makes a noise.'</span>);
    }
}
<span class="hljs-comment">// Class实际上是一个函数</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Animal</span>); <span class="hljs-comment">// function</span>
</code></pre>
<h3 data-id="heading-18">extends 继承</h3>
<h4 data-id="heading-19">extends 基本语法</h4>
<p>在 ES6 的 <code>class</code> 语法糖中，通过 <code>extends</code> 语法糖实现继承。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> {
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) {
        <span class="hljs-variable language_">super</span>(name);
    }
    
    <span class="hljs-title function_">speak</span>(<span class="hljs-params"/>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">' barks.'</span>);
    }
}
</code></pre>
<h4 data-id="heading-20">extends 继承的本质</h4>
<p><code>extends</code> 继承的本质，就等价于ES5的寄生组合继承：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">AnimalES5</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
}

<span class="hljs-title class_">AnimalES5</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">speak</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">' makes a noise.'</span>);
};

<span class="hljs-keyword">function</span> <span class="hljs-title function_">DogES5</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-title class_">AnimalES5</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name);
}

<span class="hljs-comment">// 设置原型链</span>
<span class="hljs-title class_">DogES5</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">AnimalES5</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);
<span class="hljs-title class_">DogES5</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">DogES5</span>;

<span class="hljs-title class_">DogES5</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">speak</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">' barks.'</span>);
};
</code></pre>
<h3 data-id="heading-21">Class的高级特性</h3>
<h4 data-id="heading-22">类表达式</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">MyClass</span> = <span class="hljs-keyword">class</span> {
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">value</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value;
    }
    
    <span class="hljs-title function_">getValue</span>(<span class="hljs-params"/>) {
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>;
    }
};

<span class="hljs-keyword">const</span> obj1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>(<span class="hljs-number">42</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj1.<span class="hljs-title function_">getValue</span>()); <span class="hljs-comment">// 42</span>
</code></pre>
<h4 data-id="heading-23">私有字段</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BankAccount</span> {
    <span class="hljs-comment">// 私有字段（以#开头）</span>
    #balance = <span class="hljs-number">0</span>;
    
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">owner</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">owner</span> = owner;
    }
    
    <span class="hljs-comment">// 通过公开方法访问私有字段</span>
    <span class="hljs-title function_">getBalance</span>(<span class="hljs-params"/>) {
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.#balance;
    }
}

<span class="hljs-keyword">const</span> account = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BankAccount</span>(<span class="hljs-string">'张三'</span>);

<span class="hljs-comment">// console.log(account.#balance); // SyntaxError: 属性 "#balance" 在类 "BankAccount" 外部不可访问。</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(account.<span class="hljs-title function_">getBalance</span>()); <span class="hljs-comment">// 500</span>
</code></pre>
<h4 data-id="heading-24">静态块</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Config</span> {
    <span class="hljs-keyword">static</span> dbConfig;
    <span class="hljs-keyword">static</span> apiConfig;
    
    <span class="hljs-comment">// 静态初始化块</span>
    <span class="hljs-keyword">static</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'初始化静态配置...'</span>);
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">dbConfig</span> = {
            <span class="hljs-attr">host</span>: <span class="hljs-string">'localhost'</span>,
            <span class="hljs-attr">port</span>: <span class="hljs-number">3306</span>,
            <span class="hljs-attr">username</span>: <span class="hljs-string">'root'</span>
        };
        
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">apiConfig</span> = {
            <span class="hljs-attr">baseUrl</span>: <span class="hljs-string">'https://api.example.com'</span>,
            <span class="hljs-attr">timeout</span>: <span class="hljs-number">5000</span>
        };
    }
    
    <span class="hljs-keyword">static</span> <span class="hljs-title function_">getConfig</span>(<span class="hljs-params"/>) {
        <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">db</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">dbConfig</span>,
            <span class="hljs-attr">api</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">apiConfig</span>
        };
    }
}
</code></pre>
<h4 data-id="heading-25">类的访问器属性</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Temperature</span> {
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">celsius</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">celsius</span> = celsius;
    }
    
    <span class="hljs-keyword">get</span> <span class="hljs-title function_">fahrenheit</span>() {
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">celsius</span> * <span class="hljs-number">1.8</span> + <span class="hljs-number">32</span>;
    }
    
    <span class="hljs-keyword">set</span> <span class="hljs-title function_">fahrenheit</span>(<span class="hljs-params">value</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">celsius</span> = (value - <span class="hljs-number">32</span>) / <span class="hljs-number">1.8</span>;
    }
    
    <span class="hljs-comment">// 只读属性</span>
    <span class="hljs-keyword">get</span> <span class="hljs-title function_">kelvin</span>() {
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">celsius</span> + <span class="hljs-number">273.15</span>;
    }
}
</code></pre>
<h4 data-id="heading-26">Mixin模式（多重继承的替代方案）</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">FlyMixin</span> = (<span class="hljs-params">BaseClass</span>) =&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">extends</span> <span class="hljs-title class_">BaseClass</span> {
    <span class="hljs-title function_">fly</span>(<span class="hljs-params"/>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span> is flying!`</span>);
    }
};

<span class="hljs-keyword">const</span> <span class="hljs-title function_">SwimMixin</span> = (<span class="hljs-params">BaseClass</span>) =&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">extends</span> <span class="hljs-title class_">BaseClass</span> {
    <span class="hljs-title function_">swim</span>(<span class="hljs-params"/>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span> is swimming!`</span>);
    }
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> {
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
    }
    
    <span class="hljs-title function_">eat</span>(<span class="hljs-params"/>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span> is eating`</span>);
    }
}

<span class="hljs-comment">// 应用Mixin</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Duck</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">SwimMixin</span>(<span class="hljs-title class_">FlyMixin</span>(<span class="hljs-title class_">Animal</span>)) {
    <span class="hljs-title function_">quack</span>(<span class="hljs-params"/>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span> says: Quack!`</span>);
    }
}
</code></pre>
<h2 data-id="heading-27">面向对象编程的演进路线</h2>
<pre><code class="hljs language-text" lang="text">工厂模式 → 构造函数模式 → 原型模式 → 组合继承 → 寄生组合继承 → Class语法
    ↓        ↓           ↓         ↓           ↓           ↓
创建对象    识别类型    共享方法    结合优点     最优方案       语法糖
</code></pre>
<h2 data-id="heading-28">结语</h2>
<p>面向对象编程是 JavaScript 发展的重要里程碑。理解从工厂模式到 Class 语法的演进过程，不仅能让我们写出更好的代码，还能在遇到问题时快速定位和解决。对于文章中错误的地方或者有任何问题，欢迎在评论区留言讨论！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[HTML常用元素以及意义]]></title>    <link>https://juejin.cn/post/7602201748230144019</link>    <guid>https://juejin.cn/post/7602201748230144019</guid>    <pubDate>2026-02-03T06:19:00.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602201748230144019" data-draft-id="7602100217655885866" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="HTML常用元素以及意义"/> <meta itemprop="keywords" content="HTML"/> <meta itemprop="datePublished" content="2026-02-03T06:19:00.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="hypnos_xy"/> <meta itemprop="url" content="https://juejin.cn/user/1259383317872089"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            HTML常用元素以及意义
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1259383317872089/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    hypnos_xy
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T06:19:00.000Z" title="Tue Feb 03 2026 06:19:00 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    7
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读9分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1:first-child,.markdown-body h2:first-child,.markdown-body h3:first-child,.markdown-body h4:first-child,.markdown-body h5:first-child,.markdown-body h6:first-child{margin-top:-1.5rem;margin-bottom:1rem}.markdown-body h1:before,.markdown-body h2:before,.markdown-body h3:before,.markdown-body h4:before,.markdown-body h5:before,.markdown-body h6:before{content:"#";display:inline-block;color:#3eaf7c;padding-right:.23em}.markdown-body h1{position:relative;font-size:2.5rem;margin-bottom:5px}.markdown-body h1:before{font-size:2.5rem}.markdown-body h2{padding-bottom:.5rem;font-size:2.2rem;border-bottom:1px solid #ececec}.markdown-body h3{font-size:1.5rem;padding-bottom:0}.markdown-body h4{font-size:1.25rem}.markdown-body h5{font-size:1rem}.markdown-body h6{margin-top:5px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body strong{color:#3eaf7c}.markdown-body img{max-width:100%;border-radius:2px;display:block;margin:auto;border:3px solid rgba(62,175,124,.2)}.markdown-body hr{border:none;border-top:1px solid #3eaf7c;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;overflow-x:auto;padding:.2rem .5rem;margin:0;color:#3eaf7c;font-weight:700;font-size:.85em;background-color:rgba(27,31,35,.05);border-radius:3px}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75;border-radius:6px;border:2px solid #3eaf7c}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{font-weight:500;text-decoration:none;color:#3eaf7c}.markdown-body a:active,.markdown-body a:hover{border-bottom:1.5px solid #3eaf7c}.markdown-body a:before{content:"⇲"}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #3eaf7c}.markdown-body thead{background:#3eaf7c;color:#fff;text-align:left}.markdown-body tr:nth-child(2n){background-color:rgba(62,175,124,.2)}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:.5rem solid;border-color:#42b983;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body details{outline:none;border:none;border-left:4px solid #3eaf7c;padding-left:10px;margin-left:4px}.markdown-body details summary{cursor:pointer;border:none;outline:none;background:#fff;margin:0 -17px}.markdown-body details summary::-webkit-details-marker{color:#3eaf7c}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body ol li::marker{color:#3eaf7c}.markdown-body ul li{list-style:none}.markdown-body ul li:before{content:"•";margin-right:4px;color:#3eaf7c}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">HTML 常用元素</h2>
<h3 data-id="heading-1">！DOCTYPE</h3>
<p>主要就是告诉标准通用标记语言解析器应该使用什么样的文档类型定义 Document Type Definition（DTD）来解析文档
常见的声明：</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">HTML</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">"-//W3C//DTD HTML 4.01//EN"</span> <span class="hljs-string">"http://www.w3.org/TR/html4/strict.dtd"</span>&gt;</span>
<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">"-//W3C//DTD XHTML 1.0 Transitional//EN"</span> <span class="hljs-string">"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"</span>&gt;</span>
</code></pre>
<h3 data-id="heading-2">head</h3>
<p><strong><code>&lt;head&gt;</code></strong>  元素包含机器可读的文档相关信息（元数据），如文档的标题、脚本和样式表</p>
<h3 data-id="heading-3">meta</h3>
<p><strong><code>&lt;meta&gt;</code></strong>  元素表示那些不能由其他 HTML 元相关（meta-related）元素表示的元数据信息。</p>
<pre><code class="hljs language-html" lang="html">
<span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"author"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"aaa@mail.abc.com"</span>&gt;</span>
<span class="hljs-comment">&lt;!-- SEO --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"description"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"描述描述描述描述描述"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"keywords"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"关键字关键字关键字关键字关键字"</span>&gt;</span>
<span class="hljs-comment">&lt;!-- 视口 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span>&gt;</span>
</code></pre>
<h3 data-id="heading-4">title</h3>
<p><strong><code>&lt;title&gt;</code> 元素</strong> 定义文档的标题，显示在浏览器的标题栏或标签页上。它只应该包含文本，若是包含有标签，则它包含的任何标签都将被忽略。</p>
<h3 data-id="heading-5">style</h3>
<p><strong><code>&lt;style&gt;</code></strong>  元素包含文档的样式信息或文档的部分内容。其中的 CSS 会应用于包含 <code>&lt;style&gt;</code> 元素的文档内容</p>
<h3 data-id="heading-6">script</h3>
<p><strong><code>&lt;script&gt;</code></strong>  元素用于嵌入可执行代码或数据，这通常用作嵌入或者引用 JavaScript 代码。<code>&lt;script&gt;</code> 元素也能在其他语言中使用。</p>
<p>属性：</p>
<ul>
<li><code>async</code>:对于普通脚本，如果存在 <code>async</code> 属性，那么普通脚本会被并行请求，并尽快解析和执行。该属性能够消除<strong>解析阻塞的 Javascript</strong>。解析阻塞的 Javascript 会导致浏览器必须加载并且执行脚本，之后才能继续解析</li>
<li><code>defer</code>:这个布尔属性的设置是为了向浏览器表明，该脚本是要在文档被解析后，但在触发 <code>DOMContentLoaded</code> 事件之前执行的。</li>
<li><strong><code>type</code></strong> 该属性表示所代表的脚本类型</li>
</ul>
<ol>
<li>
<p>属性未设置（默认），一个空字符串，或一个 JavaScript MIME 类型:text/javascript、application/json</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span>
</code></pre>
</li>
<li>
<p><code>module</code> 此值导致代码被视为 JavaScript 模块。其中的代码内容会延后处理。</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"module"</span>&gt;</span><span class="javascript">
    <span class="hljs-comment">// 支持 ES6 模块化语法</span>
    <span class="hljs-keyword">import</span> { myFunction } <span class="hljs-keyword">from</span> <span class="hljs-string">'./module.js'</span>;
    <span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> myVar = <span class="hljs-number">10</span>;
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
</li>
<li>
<p><code>importmap</code>此值代表元素体内包含导入映射（importmap）表。导入映射表是一个 JSON 对象，开发者可以用它来控制浏览器在导入 javaScript 模块时如何解析模块标识符。</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"importmap"</span>&gt;</span><span class="javascript">
{
  <span class="hljs-string">"imports"</span>: {
    <span class="hljs-string">"vue"</span>: <span class="hljs-string">"https://unpkg.com/vue@3/dist/vue.esm-browser.js"</span>
  }
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
</li>
</ol>
<h3 data-id="heading-7">link</h3>
<p><strong><code>&lt;link&gt;</code></strong>  元素规定了当前文档与某个外部资源的关系。该元素最常用于链接样式表，此外也可以被用来创建站点图标（比如 PC 端的“favicon”图标和移动设备上用以显示在主屏幕的图标) 。</p>
<ul>
<li><code>rel</code> 设定为 <code>preload</code>，表示浏览器应该预加载该资源,<code>preload</code>告诉浏览器立即下载指定的资源，因为该资源将在当前页面中很快被使用。它优先于<code>prefetch</code>，因为当前页面需要它。</li>
<li><code>rel</code> 设定为 <code>prefetch</code>，<code>prefetch</code>用于在浏览器空闲时加载可能在未来页面中使用的资源（例如，用户可能点击的链接）。</li>
<li><code>rel</code> 设定为 <code>dns-prefetch</code>,<code>dns-prefetch</code>：仅提前进行DNS解析。</li>
</ul>
<pre><code class="hljs language-html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"dns-prefetch"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://cdn.example.com"</span>&gt;</span>
</code></pre>
<blockquote>
<p>src和href的区别：</p>
<p><strong>src (源)</strong>：嵌入外部资源到当前文档中，把东西"拿进来"成为文档的一部分，src资源通常需要被浏览器<strong>解析/执行</strong>，替代原有的内容</p>
<p><strong>href (超文本引用)</strong>：建立当前文档与其他资源的关联，和外部资源"手拉手"，相当于资源的引用，<code>href</code>的资源保持独立，不被嵌入</p>
</blockquote>
<h3 data-id="heading-8">a</h3>
<ul>
<li><code>href</code> 超链接所指向的 URL。链接不限于基于 HTTP 的 URL——它们可以使用浏览器支持的任何 URL 协议：
带 <code>tel:</code> URL 的电话号码。
带 <code>mailto:</code> URL 的电子邮件地址。
带 <code>sms:</code> URL 的短信。
带 <code>javascript:</code> URL 的可执行代码。
如果 web 浏览器不支持其他 URL 方案，网站可以使用 <code>registerProtocolHandler()</code>。</li>
<li><code>target</code>该属性指定在何处显示链接的 URL，作为浏览上下文的名称（标签、窗口或 <code>&lt;iframe&gt;</code>）。以下关键词对加载 URL 的位置有特殊含义：
<code>_self</code>：当前浏览上下文。（默认）
<code>_blank</code>：通常在新标签页打开，但用户可以通过配置选择在新窗口打开。
<code>_parent</code>：当前浏览环境的父级浏览上下文。如果没有父级框架，行为与 <code>_self</code> 相同。
<code>_top</code>：最顶级的浏览上下文（当前浏览上下文中最“高”的祖先）。如果没有祖先，行为与 <code>_self</code> 相同。</li>
</ul>
<h3 data-id="heading-9">语义化元素</h3>
<ol>
<li><strong><code>&lt;article&gt;</code></strong> 元素表示文档、页面、应用或网站中具有独立分发或复用意义的自包含内容块，例如论坛帖子、杂志或报纸文章、博客条目、产品卡片、用户评论、交互式组件等独立内容项。</li>
<li><strong><code>&lt;aside&gt;</code></strong> 元素用于表示文档中内容仅与主内容间接相关的部分。通常以侧边栏或提示框的形式呈现。</li>
<li><strong><code>&lt;summary&gt;</code> 元素</strong> 指定了 <code>&lt;details&gt;</code>元素展开盒子的内容的摘要，标题或图例。点击 <code>&lt;summary&gt;</code> 元素可以切换父元素 <code>&lt;details&gt;</code> 开启和关闭的状态。</li>
<li><strong><code>&lt;details&gt;</code></strong>  元素可创建一个组件，仅在被切换成展开状态时，它才会显示内含的信息。<code>&lt;summary&gt;</code>元素可为该部件提供概要或者标签。</li>
<li><strong><code>&lt;dialog&gt;</code></strong>  元素表示一个对话框或其他交互式组件，例如一个可关闭警告、检查器或者窗口。</li>
<li><strong><code>&lt;fieldset&gt;</code></strong>  元素用于对表单中的控制元素进行分组（也包括 label 元素）。</li>
<li><strong><code>&lt;legend&gt;</code></strong>  元素表示其父元素 <code>&lt;fieldset&gt;</code> 内容的标题。</li>
<li><strong><code>&lt;figure&gt;</code></strong>  元素代表一段独立的内容，可能包含 <code>&lt;figcaption&gt;</code>元素定义的说明元素。该插图、标题和其中的内容通常作为一个独立的引用单元。</li>
<li><strong><code>&lt;figcaption&gt;</code></strong> 元素是用来描述其父节点 <code>&lt;figure&gt;</code> 元素里的其余内容的标题或说明。为 <code>&lt;figure&gt;</code> 提供一个无障碍描述</li>
<li><strong><code>&lt;footer&gt;</code></strong>  元素表示其最近的祖先分段内容的页脚或分段根元素。<code>&lt;footer&gt;</code> 通常包含有关该部分作者、版权数据或相关文档链接的信息。</li>
<li><strong><code>&lt;header&gt;</code></strong> 元素表示介绍性内容，通常是一组介绍性或导航性辅助内容。它可能包含一些标题元素，也可能包含徽标、搜索表单、作者姓名和其他元素。</li>
<li><strong><code>&lt;label&gt;</code> 元素</strong>（标签）表示用户界面中某个元素的说明。</li>
<li><strong><code>&lt;main&gt;</code> 元素</strong>呈现了文档的 <code>&lt;body&gt;</code> 或应用的主体部分。主体部分由与文档直接相关，或者扩展于文档的中心主题、应用的主要功能部分的内容组成。</li>
<li><strong><code>&lt;menu&gt;</code></strong>  元素在 HTML 规范中被描述为 <code>&lt;ul&gt;</code>的语义替代，但浏览器将其视为与 <code>&lt;ul&gt;</code>没有区别（并通过无障碍树暴露）。它表示一个无序列表（由 <code>&lt;li&gt;</code> 元素表示）。</li>
<li><strong><code>&lt;nav&gt;</code>元素</strong>表示页面的一部分，其目的是在当前文档或其他文档中提供导航链接。导航部分的常见示例是菜单，目录和索引。</li>
<li><strong><code>&lt;progress&gt;</code></strong>  元素用来显示一项任务的完成进度。虽然规范中没有规定该元素具体如何显示，浏览器开发商可以自己决定，但通常情况下，该元素都显示为一个进度条形式。</li>
<li><strong><code>&lt;section&gt;</code> 元素</strong> 表示 HTML 文档中一个通用独立章节，它没有更具体的语义元素来表示。一般来说会包含一个标题。</li>
<li><strong><code>&lt;time&gt;</code></strong> 元素用来表示一个特定的时间段。该元素可包含 <code>datetime</code> 属性，用于将日期转换为机器可读格式，从而获得更好的搜索引擎结果或自定义功能（如提醒）</li>
</ol>
<h3 data-id="heading-10">其他元素</h3>
<ol>
<li><strong><code>&lt;form&gt;</code> 元素</strong>表示文档中的一个区域，此区域包含交互控件，用于向 Web 服务器提交信息。</li>
<li><strong><code>&lt;button&gt;</code> 元素</strong>表示一个可点击的按钮，可以用在表单或文档其他需要使用简单标准按钮的地方。</li>
<li><strong><code>&lt;canvas&gt;</code></strong> 元素可被用来通过 JavaScript绘制图形及图形动画</li>
<li><strong><code>&lt;div&gt;</code></strong>  元素是流式内容的通用容器。</li>
<li><strong><code>&lt;iframe&gt;</code></strong>  表示嵌套的浏览上下文。它能够将另一个 HTML 页面嵌入到当前页面中</li>
<li><strong><code>&lt;img&gt;</code></strong> 元素将一张图像嵌入文档。</li>
<li><strong><code>&lt;input&gt;</code></strong>  元素用于为基于 Web 的表单创建交互式控件，以便接受来自用户的数据。取决于设备和用户代理不同，表单可以使用各种类型的输入数据和控件。<code>&lt;input&gt;</code> 元素是目前 HTML 中最强大、最复杂的元素之一，因为它有大量的输入类型和属性组合。</li>
<li><strong><code>&lt;li&gt;</code></strong> 元素用于表示列表中的项目。它必须包含在一个父元素中：有序列表（<code>&lt;ol&gt;</code>）、无序列表（<code>&lt;ul&gt;</code>）或菜单（<code>&lt;menu&gt;</code>）。在菜单和无序列表中，列表项通常使用项目符号显示。在有序列表中，通常在左侧显示一个升序计数器，如数字或字母。</li>
<li><strong><code>&lt;ol&gt;</code> 元素</strong> 表示有序列表，通常渲染为一个带编号的列表。</li>
<li><strong><code>&lt;ul&gt;</code></strong>  元素表示无序的项目列表，通常渲染为项目符号列表。</li>
<li><strong><code>&lt;option&gt;</code></strong>  元素用于定义包含在 <code>&lt;select&gt;</code>、<code>&lt;optgroup&gt;</code>或 <code>&lt;datalist&gt;</code> 元素中的一项。</li>
<li><strong><code>&lt;p&gt;</code></strong> 元素表示文本的一个段落。在视觉媒体中，段落通常表现为用空行和/或首行缩进与相邻段落分隔的文本块，但 HTML 段落可以是相关内容的任何结构分组，如图像或表格字段。</li>
<li><strong><code>&lt;select&gt;</code> 元素</strong> 表示一个提供选项菜单的控件：</li>
<li><strong><code>&lt;span&gt;</code></strong> 元素是一个通用的行级容器，本身不具备特殊含义</li>
<li><strong><code>&lt;style&gt;</code></strong>  元素包含文档的样式信息或文档的部分内容。其中的 CSS 会应用于包含 <code>&lt;style&gt;</code> 元素的文档内容。</li>
<li><code>&lt;template&gt;</code>元素是一种用于保存客户端内容机制，该内容在加载页面时不会呈现，但随后可以 (原文为 may be) 在运行时使用 JavaScript 实例化</li>
<li><strong><code>&lt;textarea&gt;</code></strong> 元素是一个多行纯文本编辑控件，适用于允许用户输入大量自由格式文本的场景</li>
<li><strong><code>&lt;video&gt;</code></strong> 元素用于在文档中嵌入媒体播放器，用于支持文档内的视频播放。</li>
<li><strong><code>&lt;table&gt;</code></strong>  元素表示表格数据——即在一个由包含数据的行和列组成的二维表格中呈现的信息。<strong><code>&lt;tbody&gt;</code></strong>、<strong><code>&lt;td&gt;</code></strong>、<strong><code>&lt;tr&gt;</code></strong>、<strong><code>&lt;tfoot&gt;</code></strong>、<strong><code>&lt;thead&gt;</code></strong></li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[使用dataZoom控制滚动条处理echart数据过多显示混乱的问题]]></title>    <link>https://juejin.cn/post/7602158221852180495</link>    <guid>https://juejin.cn/post/7602158221852180495</guid>    <pubDate>2026-02-03T06:31:28.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602158221852180495" data-draft-id="7602073088427737103" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="使用dataZoom控制滚动条处理echart数据过多显示混乱的问题"/> <meta itemprop="keywords" content="前端,JavaScript,Vue.js"/> <meta itemprop="datePublished" content="2026-02-03T06:31:28.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="wangpq"/> <meta itemprop="url" content="https://juejin.cn/user/2172290705137415"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            使用dataZoom控制滚动条处理echart数据过多显示混乱的问题
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2172290705137415/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    wangpq
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T06:31:28.000Z" title="Tue Feb 03 2026 06:31:28 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">问题描述</h2>
<p>echarts图表的y轴上数据过多,每一行数据高度太短，拥挤在一起，导致图表显示不全。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d8731041d8dc4df8a1fc4b077254990b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd2FuZ3Bx:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770705088&amp;x-signature=kQPMRwcNpLlYGd3aBhxw8vSoxNU%3D" alt="7bbc5be6-f30f-4d36-982b-be0c8aa85aad.png" loading="lazy"/></p>
<h2 data-id="heading-1">需求回顾</h2>
<p>项目页面【景区销售排行】模块显示前10条数据，点击【查看全部】弹框显示所有数据。</p>
<p>下图为页面中排行模块的样子：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a332d31f12034962b29c59e6a7b629b6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd2FuZ3Bx:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770705088&amp;x-signature=rJkXApYu6Wugiv8sw6xgLTyX5YY%3D" alt="d4859e09-185c-41eb-a5d6-e9e9f3ef0770.png" loading="lazy"/></p>
<h2 data-id="heading-2">问题解决</h2>
<p>1、处理弹框中图表数据过多显示混乱的问题；</p>
<p>2、弹框中初始数据默认和页面一致，10条显示。</p>
<h2 data-id="heading-3">如何解决</h2>
<p>在使用 ECharts 创建图表时，如果你发现 Y 轴上的数据过多，导致图表显示不全，你可以通过设置滚动条来改善这一情况。ECharts 提供了 <code>dataZoom</code> 组件来实现这一功能，它可以让你在 X 轴或 Y 轴上添加滚动条。可点击查看echart文档 <a href="https://link.juejin.cn?target=https%3A%2F%2Fecharts.apache.org%2Fzh%2Foption.html%23dataZoom" target="_blank" title="https://echarts.apache.org/zh/option.html#dataZoom" ref="nofollow noopener noreferrer">dataZoom</a> 。</p>
<p>具体步骤：</p>
<p>打开到源代码，找到与<code>tooltip</code>,<code>grid</code>,<code>xAxis</code>,<code>yAxis</code>,<code>series</code>,<code>legend</code>等同级的地方，添加如下<code>dataZoom</code>组件参数，</p>
<pre><code class="hljs language-js" lang="js">{
    tooltip : {},
    dataZoom : [
        {
            <span class="hljs-attr">type</span>: <span class="hljs-string">"slider"</span>,  <span class="hljs-comment">// slider表示这里的是滑动条型数据区域缩放组件，如果是inside，表示内置型数据区域缩放组件</span>
            <span class="hljs-attr">yAxisIndex</span>: <span class="hljs-number">0</span>, <span class="hljs-comment">// 控制y轴滚动对象，[0] 可简写为0</span>
            <span class="hljs-attr">zoomLock</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 是否锁定选择区域（或叫做数据窗口）的大小,如果设置为 `true` 则锁定选择区域的大小，也就是说，只能平移，不能缩放</span>
            <span class="hljs-attr">width</span>: <span class="hljs-number">10</span>, <span class="hljs-comment">// dataZoom-slider 组件的宽度。竖直布局默认 30，水平布局默认自适应</span>
            <span class="hljs-attr">right</span>: <span class="hljs-number">10</span>, <span class="hljs-comment">// dataZoom-slider组件离容器右侧的距离, 值可以是像 `20` 这样的具体像素值，可以是像 '20%' 这样相对于容器宽度的百分比。</span>
            <span class="hljs-attr">top</span>: <span class="hljs-number">0</span>, <span class="hljs-comment">// dataZoom-slider组件离容器上侧的距离。</span>
            <span class="hljs-attr">bottom</span>: <span class="hljs-number">0</span>, <span class="hljs-comment">// dataZoom-slider组件离容器底侧的距离。</span>
            <span class="hljs-attr">startValue</span>: <span class="hljs-number">0</span>, <span class="hljs-comment">// 数据窗口范围的起始数值, 0代表数组索引值，第1条数据</span>
            <span class="hljs-attr">endValue</span>: <span class="hljs-number">9</span>, <span class="hljs-comment">// 数据窗口范围的结束数值, 9代表数组索引值，第10条数据</span>
            <span class="hljs-attr">handleSize</span>: <span class="hljs-number">0</span>, <span class="hljs-comment">// 两边手柄尺寸</span>
            <span class="hljs-attr">showDetail</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 拖拽时是否显示滚动条两侧的文字，默认为true</span>
        },
    ]
}
</code></pre>
<p>修改后，效果如下图：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1b942276fbc34e5ca27ee9caeb48c500~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd2FuZ3Bx:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770705088&amp;x-signature=AHeBptYxQYKS9Wvf7ru986dI1NU%3D" alt="90a35cd0-4274-43f8-9499-e8031aca6966.png" loading="lazy"/></p>
<p>如果想改变一下echarts图表中滚动条的样式，可以增加一些参数，如下：</p>
<pre><code class="hljs language-js" lang="js">{
    series : [],
    dataZoom : [
        {
                <span class="hljs-attr">type</span>: <span class="hljs-string">"slider"</span>, <span class="hljs-comment">// slider表示这里的是滑动条型数据区域缩放组件，如果是inside，表示内置型数据区域缩放组件</span>
                <span class="hljs-attr">realtime</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 拖动时，是否实时更新系列的视图。如果设置为 `false`，则只在拖拽结束的时候更新，默认为true</span>
                <span class="hljs-attr">startValue</span>: <span class="hljs-number">0</span>, <span class="hljs-comment">// 数据窗口范围的起始数值, 0代表数组索引值，第1条数据</span>
                <span class="hljs-attr">endValue</span>: <span class="hljs-number">9</span>, <span class="hljs-comment">// 数据窗口范围的结束数值, 9代表数组索引值，第10条数据</span>
                <span class="hljs-attr">width</span>: <span class="hljs-number">10</span>, <span class="hljs-comment">// dataZoom-slider 组件的宽度。竖直布局默认 30，水平布局默认自适应</span>
                <span class="hljs-attr">height</span>: <span class="hljs-string">"90%"</span>, <span class="hljs-comment">// dataZoom-slider 组件的高度。水平布局默认 30，竖直布局默认自适应。</span>
                <span class="hljs-attr">top</span>: <span class="hljs-string">"5%"</span>, <span class="hljs-comment">// dataZoom-slider组件离容器上侧的距离。</span>
                <span class="hljs-attr">right</span>: <span class="hljs-number">0</span>,  <span class="hljs-comment">// dataZoom-slider组件离容器右侧的距离, 值可以是像 `20` 这样的具体像素值，可以是像 '20%' 这样相对于容器宽度的百分比。</span>
                <span class="hljs-comment">// orient: 'vertical', // 设置横向还是纵向, 但是官方不太建议如此使用，建议使用 yAxisIndex 具体指明</span>
                <span class="hljs-attr">yAxisIndex</span>: [<span class="hljs-number">0</span>], <span class="hljs-comment">// 控制y轴滚动对象，[0] 可简写为0</span>
                <span class="hljs-attr">fillerColor</span>: <span class="hljs-string">"#0093ff"</span>, <span class="hljs-comment">// 滚动条选中范围的填充颜色</span>
                <span class="hljs-attr">borderColor</span>: <span class="hljs-string">"rgba(17, 100, 210, 0.12)"</span>,  <span class="hljs-comment">// 滚动条边框颜色</span>
                <span class="hljs-attr">backgroundColor</span>: <span class="hljs-string">"#cfcfcf"</span>, <span class="hljs-comment">// 滚动组件的背景颜色,及两边未选中的滑动条区域的颜色</span>
                <span class="hljs-attr">handleSize</span>: <span class="hljs-number">0</span>, <span class="hljs-comment">// 两边手柄尺寸</span>
                <span class="hljs-attr">showDataShadow</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 是否在 `dataZoom-silder` 组件中显示数据阴影。数据阴影可以简单地反应数据走势。默认auto</span>
                <span class="hljs-attr">showDetail</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 拖拽时是否显示滚动条两侧的文字，默认为true</span>
                <span class="hljs-attr">zoomLock</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 是否锁定选择区域（或叫做数据窗口）的大小,如果设置为 `true` 则锁定选择区域的大小，也就是说，只能平移，不能缩放</span>
                <span class="hljs-comment">// 移动手柄的样式配置</span>
                <span class="hljs-attr">moveHandleStyle</span>: {
                  <span class="hljs-attr">opacity</span>: <span class="hljs-number">0</span>, <span class="hljs-comment">// 这里opacity设置为0，相当于设置moveHandleSize为0</span>
                },
        }
    ]
}
</code></pre>
<p>实现效果如下图：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8e34b3b0b1e44443a8b4342e0d613e78~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd2FuZ3Bx:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770705088&amp;x-signature=rllzPikqHrBUacIoP3qvfVzuSZQ%3D" alt="b45f0844-9a43-4ec1-8247-7c19d7dd15f4.png" loading="lazy"/></p>
<p><strong>这里想重点提一下<code>startValue</code>,<code>endValue</code>，我通过这两个值来控制echart图表中可见视野内可展示的数据条数。</strong></p>
<p>从文档中可以看到，我们其实还可以使用<code>start</code>,<code>end</code>来控制数据窗口范围，并且<code>start</code>,<code>end</code>优先级大于<code>startValue</code>和<code>endValue</code>。</p>
<p><code>start</code>,<code>end</code>表示的是数据窗口范围的起始和结束百分比，是一个百分比数值，number类型，范围是：0 ~ 100。表示 0% ~ 100%。</p>
<p><code>startValue</code>,<code>endValue</code>表示的是数据窗口范围的起始和结束数值，类型为<code>[number,string,Date]</code>,一般设置为number类型的数组索引值即可，同时还可以设置为数组值本身。至于Date类型，不清楚，没去研究，有兴趣的可以自己去发现。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cbbe2078ba2047debda438315b74f362~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd2FuZ3Bx:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770705088&amp;x-signature=S8WKTv29YFny%2B3jb3uCArevGAH0%3D" alt="2dd75f0e-c029-4401-98f6-593329743f41.png" loading="lazy"/></p>
<p>在我的项目中，我最终选择了<code>startValue</code>,<code>endValue</code> 来精确控制显示条数，而不是<code>start</code>,<code>end</code>，虽然后者也能解决拥挤的问题，但是没法精确到条数，导致弹框中的图表显示可能跟页面汇总的不一致，如果没有我这里这样的场景，其实用他们哪一个，就看你自己的意愿了。</p>
<h2 data-id="heading-4">题外话</h2>
<p>我们在渲染图表X轴或者Y轴上的数据时，如果发现渲染的数据跟实际传的数据顺序相反，可在轴数据设置中增加<code>inverse: true</code>, inverse表示是否是反向坐标轴，默认值为false。</p>
<pre><code class="hljs language-js" lang="js">{
    <span class="hljs-attr">yAxis</span>: [
        {
            <span class="hljs-attr">inverse</span>: <span class="hljs-literal">true</span>,
            <span class="hljs-attr">data</span>: [],
            <span class="hljs-attr">axisLabel</span>: {}
        }
    ],
    <span class="hljs-attr">xAxis</span>: [
        {
            <span class="hljs-attr">inverse</span>: <span class="hljs-literal">true</span>,
            <span class="hljs-attr">data</span>: [],
            <span class="hljs-attr">axisLabel</span>: {}
        }
    ]
}
</code></pre>
<p>我们项目中前同事在开发的时候，编写的图表插件中并没有设置<code>inverse: true</code>，他发现渲染的数据都是反的，所以将传入的数据都使用数组的reverse方法倒序排列了一遍，达到了同样的效果。
不过后来我开发弹框页面的时候，这里引出了一个问题，按照我们上面提到的<code>startValue</code>,<code>endValue</code>设置</p>
<pre><code class="hljs language-js" lang="js">{
    <span class="hljs-attr">startValue</span>: <span class="hljs-number">0</span>, <span class="hljs-comment">// 数据窗口范围的起始数值, 0代表数组索引值，第1条数据</span>
    <span class="hljs-attr">endValue</span>: <span class="hljs-number">9</span>, <span class="hljs-comment">// 数据窗口范围的结束数值, 9代表数组索引值，第10条数据</span>
}
</code></pre>
<p>刚打开弹框，我们可以看到，图表中滚动条已经到底了，不是我们预想的从顶部开始，就算将<code>startValue</code>,<code>endValue</code>的值反过来设置同样如此。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a94b2ca5f50446658b4ac7cc753b2164~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd2FuZ3Bx:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770705088&amp;x-signature=CIXv363ukFoFHNVL%2BYoNQMdKnVQ%3D" alt="b04a4dcb-4b9f-4334-b263-3afdcbc2eb23.png" loading="lazy"/></p>
<p>那该怎么办呢？不绕弯子了，请看下面大屏幕，哦，不对，看下面代码：</p>
<pre><code class="hljs language-js" lang="js">{
    <span class="hljs-attr">startValue</span>: seriesData.<span class="hljs-property">length</span> - <span class="hljs-number">10</span>, <span class="hljs-comment">// seriesData为图表数组数据</span>
    <span class="hljs-attr">endValue</span>: seriesData.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>,
}
</code></pre>
<p>看到这，大家应该已经明白了吧。好了，不再惹人嫌了，今天就讲到这里，下回再见。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Vue3/React 结合 pdfjs 实现拖拽盖章签名等操作，支持 PDF多页展示，导出图片与 PDF]]></title>    <link>https://juejin.cn/post/7602177588443643923</link>    <guid>https://juejin.cn/post/7602177588443643923</guid>    <pubDate>2026-02-03T06:38:49.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602177588443643923" data-draft-id="7602154171109392447" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Vue3/React 结合 pdfjs 实现拖拽盖章签名等操作，支持 PDF多页展示，导出图片与 PDF"/> <meta itemprop="keywords" content="前端,JavaScript"/> <meta itemprop="datePublished" content="2026-02-03T06:38:49.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="普罗米修斯基"/> <meta itemprop="url" content="https://juejin.cn/user/2436983109989272"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Vue3/React 结合 pdfjs 实现拖拽盖章签名等操作，支持 PDF多页展示，导出图片与 PDF
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2436983109989272/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    普罗米修斯基
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T06:38:49.000Z" title="Tue Feb 03 2026 06:38:49 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{color:#595959;font-size:15px;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(60,10,30,.04) 3%,transparent 0),linear-gradient(1turn,rgba(60,10,30,.04) 3%,transparent 0);background-size:20px 20px;background-position:50%}.markdown-body p{color:#595959;font-size:15px;line-height:2;font-weight:400}.markdown-body p+p{margin-top:16px}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{padding:30px 0;margin:0;color:#135ce0}.markdown-body h1{position:relative;text-align:center;font-size:22px;margin:50px 0}.markdown-body h1:before{position:absolute;content:"";top:-10px;left:50%;width:32px;height:32px;transform:translateX(-50%);background-size:100% 100%;opacity:.36;background-repeat:no-repeat;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABfVBMVEX///8Ad/8AgP8AgP8AgP8Aff8AgP8Af/8AgP8AVf8Af/8Af/8AgP8AgP8Af/8Afv8AAP8Afv8Afv8Aef8AgP8AdP8Afv8AgP8AgP8Acf8Ae/8AgP8Af/8AgP8Af/8Af/8AfP8Afv8AgP8Af/8Af/8Afv8Afv8AgP8Afv8AgP8Af/8Af/8AgP8AgP8Afv8AgP8Af/8AgP8AgP8AgP8Ae/8Afv8Af/8AgP8Af/8AgP8Af/8Af/8Aff8Af/8Abf8AgP8Af/8AgP8Af/8Af/8Afv8AgP8AgP8Afv8Afv8AgP8Af/8Aff8AgP8Afv8AgP8Aff8AgP8AfP8AgP8Ae/8AgP8Af/8AgP8AgP8AgP8Afv8AgP8AgP8AgP8Afv8AgP8AgP8AgP8AgP8AgP8Af/8AgP8Af/8Af/8Aev8Af/8AgP8Aff8Afv8AgP8AgP8AgP8Af/8AgP8Af/8Af/8AgP8Afv8AgP8AgP8AgP8AgP8Af/8AeP8Af/8Af/8Af//////rzEHnAAAAfXRSTlMAD7CCAivatxIDx5EMrP19AXdLEwgLR+6iCR/M0yLRzyFF7JupSXn8cw6v60Q0QeqzKtgeG237HMne850/6Qeq7QaZ+WdydHtj+OM3qENCMRYl1B3K2U7wnlWE/mhlirjkODa9FN/BF7/iNV/2kASNZpX1Wlf03C4stRGxgUPclqoAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEaBzgZ4yeM3AAAAT9JREFUOMvNUldbwkAQvCAqsSBoABE7asSOBRUVVBQNNuy9996789+9cMFAMHnVebmdm+/bmdtbQv4dOFOW2UjPzgFyLfo6nweKfIMOBYWwFtmMPGz2Yj2pJI0JDq3udJW6VVbmKa9I192VQFV1ktXUAl5NB0cd4KpnORqsEO2ZIRpF9gJfE9Dckqq0KuZt7UAH5+8EPF3spjsRpCeQNO/tA/qDwIDA+OCQbBoKA8NOdjMySgcZGVM6jwcgRuUiSs0nlPFNSrEpJfU0jTLD6llqbvKxei7OzvkFNQohi0vAsj81+MoqsCaoPOQFgus/1LyxichW+hS2JWCHZ7VlF9jb187pIAYcHiViHAMnp5mTjJ8B5xeEXF4B1ze/fTh/C0h398DDI9HB07O8ci+vRBdvdGnfP4gBuM8vw7X/G3wDmFhFZEdxzjMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDEtMjZUMDc6NTY6MjUrMDE6MDA67pVWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAxLTI2VDA3OjU2OjI1KzAxOjAwS7Mt6gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAWdEVYdFRpdGxlAGp1ZWppbl9sb2dvIGNvcHlxapmKAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC)}.markdown-body h2{position:relative;font-size:20px;border-left:4px solid;padding:0 0 0 10px;margin:30px 0}.markdown-body h3{font-size:16px}.markdown-body ul{list-style:disc outside;margin-left:2em;margin-top:1em}.markdown-body li{line-height:2;color:#595959}.markdown-body img.loaded{margin:0 auto;display:block}.markdown-body blockquote{background:#fff9f9;margin:2em 0;padding:2px 20px;border-left:4px solid #b2aec5}.markdown-body blockquote p{color:#666;line-height:2}.markdown-body a{color:#036aca;border-bottom:1px solid rgba(3,106,202,.8);font-weight:400;text-decoration:none}.markdown-body em strong,.markdown-body strong{color:#036aca}.markdown-body hr{border-top:1px solid #135ce0}.markdown-body pre{overflow:auto}.markdown-body code,.markdown-body pre{overflow:auto;position:relative;line-height:1.75;font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body table{border-collapse:collapse;margin:1rem 0;overflow-x:auto}.markdown-body table td,.markdown-body table th{border:1px solid #dfe2e5;padding:.6em 1em}.markdown-body table tr{border-top:1px solid #dfe2e5}.markdown-body table tr:nth-child(2n){background-color:#f6f8fa}</style><style data-highlight="" data-highlight-key="a11y-dark">.hljs-comment,.hljs-quote{color:#d4d0ab}.hljs-deletion,.hljs-name,.hljs-regexp,.hljs-selector-class,.hljs-selector-id,.hljs-tag,.hljs-template-variable,.hljs-variable{color:#ffa07a}.hljs-built_in,.hljs-builtin-name,.hljs-link,.hljs-literal,.hljs-meta,.hljs-number,.hljs-params,.hljs-type{color:#f5ab35}.hljs-attribute{color:gold}.hljs-addition,.hljs-bullet,.hljs-string,.hljs-symbol{color:#abe338}.hljs-section,.hljs-title{color:#00e0e0}.hljs-keyword,.hljs-selector-tag{color:#dcc6e0}.markdown-body pre,.markdown-body pre&gt;code.hljs{background:#2b2b2b;color:#f8f8f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}@media screen and (-ms-high-contrast:active){.hljs-addition,.hljs-attribute,.hljs-built_in,.hljs-builtin-name,.hljs-bullet,.hljs-comment,.hljs-link,.hljs-literal,.hljs-meta,.hljs-number,.hljs-params,.hljs-quote,.hljs-string,.hljs-symbol,.hljs-type{color:highlight}.hljs-keyword,.hljs-selector-tag{font-weight:700}}</style><h2 data-id="heading-0">PDF 拖拽盖章平台</h2>
<p>在 AI 能基本实现百分之九十以上的前端代码时，不知道写这种前端工具还有没有人看？</p>
<p>我用相对详细的方式，完整拆解一个「PDF 拖拽盖章平台」的实现过程，覆盖多页渲染、拖拽盖章、撤销/还原、导出图片与 PDF、性能优化（懒渲染）等关键环节。示例包含 React 与 Vue3 两套实现，逻辑一致、写法不同。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a726d02e5fb644cbafbae67084e980bb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pmu572X57Gz5L-u5pav5Z-6:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770705531&amp;x-signature=%2FXkja9GFA%2BkQA6KitKjPTNhjWkU%3D" alt="CPT2602031359-1000x523.gif" loading="lazy"/></p>
<h3 data-id="heading-1">目标与约束</h3>
<p><strong>目标</strong></p>
<ul>
<li>支持上传多页 PDF。</li>
<li>在预览区域拖拽印章，支持骑缝章。</li>
<li>支持撤销 / 还原。</li>
<li>支持导出图片和 PDF。</li>
<li>大文件也能流畅渲染，不“卡成 PPT”。</li>
</ul>
<p><strong>主要约束</strong></p>
<ul>
<li>浏览器对 canvas 尺寸有上限（不同浏览器略有差异）。</li>
<li>长图导出容易失败，需要降级方案。</li>
<li>大 PDF 一次性渲染会阻塞主线程。</li>
</ul>
<hr/>
<h3 data-id="heading-2">核心思路：统一坐标系 + 多页 canvas</h3>
<p>这里的关键是：<strong>把整份 PDF 当成一张“虚拟长画布”</strong>。</p>
<ul>
<li>每一页各有一个 <code>canvas</code>，显示真实页面内容。</li>
<li>所有盖章坐标都以“整份文档坐标系”为准。</li>
<li>每页只要知道自己在整份文档中的位置（<code>pagePositions</code>），就能把盖章正确映射回去。</li>
</ul>
<p>这样做有两个好处：</p>
<ol>
<li><strong>骑缝章天然支持</strong>：印章跨页，坐标也能跨页。</li>
<li><strong>导出更稳定</strong>：导出时可自由选择“整图”或“逐页”。</li>
</ol>
<h4 data-id="heading-3">核心依赖</h4>
<ul>
<li><code>pdfjs-dist</code>：解析与渲染 PDF</li>
<li><code>pdf-lib</code>：导出带印章的 PDF（图片型 PDF）</li>
</ul>
<p>安装示例：</p>
<pre><code class="hljs language-bash" lang="bash">pnpm add pdfjs-dist pdf-lib
</code></pre>
<hr/>
<hr/>
<h3 data-id="heading-4">PDF 解析与页面尺寸获取</h3>
<p>先读取文档并计算每页尺寸。这里只取尺寸，不渲染，避免一开始就卡死。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> loadingTask = pdfjsLib.<span class="hljs-title function_">getDocument</span>({ <span class="hljs-attr">data</span>: arrayBuffer });
<span class="hljs-keyword">const</span> pdf = <span class="hljs-keyword">await</span> loadingTask.<span class="hljs-property">promise</span>;
<span class="hljs-keyword">const</span> pages = [];
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> pageIndex = <span class="hljs-number">1</span>; pageIndex &lt;= pdf.<span class="hljs-property">numPages</span>; pageIndex += <span class="hljs-number">1</span>) {
  <span class="hljs-keyword">const</span> page = <span class="hljs-keyword">await</span> pdf.<span class="hljs-title function_">getPage</span>(pageIndex);
  <span class="hljs-keyword">const</span> viewport = page.<span class="hljs-title function_">getViewport</span>({ <span class="hljs-attr">scale</span>: <span class="hljs-variable constant_">PAGE_SCALE</span> });
  pages.<span class="hljs-title function_">push</span>({ <span class="hljs-attr">width</span>: viewport.<span class="hljs-property">width</span>, <span class="hljs-attr">height</span>: viewport.<span class="hljs-property">height</span> });
}
</code></pre>
<p>拿到 <code>pages</code> 后，就能计算整份文档尺寸和每页偏移量。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> docSize = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">const</span> width = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(...pdfPages.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">page</span>) =&gt;</span> page.<span class="hljs-property">width</span>));
  <span class="hljs-keyword">const</span> height = pdfPages.<span class="hljs-title function_">reduce</span>(
    <span class="hljs-function">(<span class="hljs-params">sum, page, index</span>) =&gt;</span> sum + page.<span class="hljs-property">height</span> + (index &lt; pdfPages.<span class="hljs-property">length</span> - <span class="hljs-number">1</span> ? <span class="hljs-variable constant_">PAGE_GAP</span> : <span class="hljs-number">0</span>),
    <span class="hljs-number">0</span>
  );
  <span class="hljs-keyword">return</span> { width, height };
}, [pdfPages]);

<span class="hljs-keyword">const</span> pagePositions = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">let</span> offsetY = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">return</span> pdfPages.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">page, index</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> pos = { <span class="hljs-attr">x</span>: (docSize.<span class="hljs-property">width</span> - page.<span class="hljs-property">width</span>) / <span class="hljs-number">2</span>, <span class="hljs-attr">y</span>: offsetY };
    offsetY += page.<span class="hljs-property">height</span> + (index &lt; pdfPages.<span class="hljs-property">length</span> - <span class="hljs-number">1</span> ? <span class="hljs-variable constant_">PAGE_GAP</span> : <span class="hljs-number">0</span>);
    <span class="hljs-keyword">return</span> pos;
  });
}, [pdfPages, docSize.<span class="hljs-property">width</span>]);
</code></pre>
<p><strong>解释：</strong></p>
<ul>
<li><code>docSize</code> 是整个虚拟画布大小。</li>
<li><code>pagePositions</code> 是每页在虚拟画布中的左上角坐标。</li>
</ul>
<hr/>
<h3 data-id="heading-5">预览区滚动与布局</h3>
<p>多页 PDF 不可能全部撑开，所以预览区必须做“内部滚动”。</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-class">.pdf-stage</span> {
  <span class="hljs-attribute">max-height</span>: <span class="hljs-built_in">clamp</span>(<span class="hljs-number">520px</span>, <span class="hljs-number">70vh</span>, <span class="hljs-number">820px</span>);
  <span class="hljs-attribute">overflow</span>: auto;
}
</code></pre>
<p>这样页面滚动只发生在 PDF 区域内，用户体验会舒服很多。</p>
<hr/>
<h3 data-id="heading-6">拖拽盖章实现</h3>
<h4 data-id="heading-7">坐标换算</h4>
<p>拖拽时需要把屏幕坐标转换成“文档坐标”。关键点就是 <code>overlay</code> 的矩形位置。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> rect = overlayRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">getBoundingClientRect</span>();
<span class="hljs-keyword">const</span> x = event.<span class="hljs-property">clientX</span> - rect.<span class="hljs-property">left</span> - template.<span class="hljs-property">width</span> / <span class="hljs-number">2</span>;
<span class="hljs-keyword">const</span> y = event.<span class="hljs-property">clientY</span> - rect.<span class="hljs-property">top</span> - template.<span class="hljs-property">height</span> / <span class="hljs-number">2</span>;

<span class="hljs-keyword">const</span> nextStamp = {
  <span class="hljs-attr">instanceId</span>: <span class="hljs-title function_">buildInstanceId</span>(template.<span class="hljs-property">id</span>),
  <span class="hljs-attr">src</span>: template.<span class="hljs-property">src</span>,
  <span class="hljs-attr">width</span>: template.<span class="hljs-property">width</span>,
  <span class="hljs-attr">height</span>: template.<span class="hljs-property">height</span>,
  <span class="hljs-attr">x</span>: <span class="hljs-title function_">clamp</span>(x, <span class="hljs-number">0</span>, docSize.<span class="hljs-property">width</span> - template.<span class="hljs-property">width</span>),
  <span class="hljs-attr">y</span>: <span class="hljs-title function_">clamp</span>(y, <span class="hljs-number">0</span>, docSize.<span class="hljs-property">height</span> - template.<span class="hljs-property">height</span>),
};
</code></pre>
<h4 data-id="heading-8">实时拖动 + 撤销栈</h4>
<p>拖动过程中只更新“临时状态”，拖动结束再写入历史栈，保证撤销栈干净。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 实时更新</span>
<span class="hljs-title function_">updateLiveStamps</span>(<span class="hljs-function">(<span class="hljs-params">prev</span>) =&gt;</span> prev.<span class="hljs-title function_">map</span>(...));

<span class="hljs-comment">// 拖动结束写入历史</span>
<span class="hljs-keyword">if</span> (drag.<span class="hljs-property">moved</span>) <span class="hljs-title function_">commitStamps</span>(liveStampsRef.<span class="hljs-property">current</span>);
</code></pre>
<p><strong>好处：</strong> 撤销时不是“细碎步进”，而是一次拖动一个记录。</p>
<hr/>
<h3 data-id="heading-9">性能优化：懒渲染 + 队列</h3>
<p>渲染 PDF 是最容易卡顿的地方。解决方案是：</p>
<ul>
<li><strong>IntersectionObserver</strong>：只有当页面进入视口时才渲染。</li>
<li><strong>渲染队列</strong>：保证渲染顺序，不并发拖慢主线程。</li>
<li><strong>预渲染前两页</strong>：首屏更快。</li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> observer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntersectionObserver</span>(
  <span class="hljs-function">(<span class="hljs-params">entries</span>) =&gt;</span> {
    entries.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">entry</span>) =&gt;</span> {
      <span class="hljs-keyword">if</span> (!entry.<span class="hljs-property">isIntersecting</span>) <span class="hljs-keyword">return</span>;
      <span class="hljs-keyword">const</span> index = <span class="hljs-title class_">Number</span>(entry.<span class="hljs-property">target</span>.<span class="hljs-property">dataset</span>.<span class="hljs-property">index</span>);
      <span class="hljs-title function_">queueRender</span>(index);
    });
  },
  { <span class="hljs-attr">root</span>: stageElement, <span class="hljs-attr">rootMargin</span>: <span class="hljs-string">'240px 0px'</span>, <span class="hljs-attr">threshold</span>: <span class="hljs-number">0.1</span> }
);
</code></pre>
<p>渲染队列逻辑：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">renderPage</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">index</span>) =&gt; {
  <span class="hljs-keyword">const</span> page = <span class="hljs-keyword">await</span> pdfDoc.<span class="hljs-title function_">getPage</span>(index + <span class="hljs-number">1</span>);
  <span class="hljs-keyword">const</span> viewport = page.<span class="hljs-title function_">getViewport</span>({ <span class="hljs-attr">scale</span>: <span class="hljs-variable constant_">PAGE_SCALE</span> });
  <span class="hljs-keyword">const</span> canvas = canvasRefs.<span class="hljs-property">current</span>[index];
  <span class="hljs-keyword">const</span> ctx = canvas.<span class="hljs-title function_">getContext</span>(<span class="hljs-string">'2d'</span>);
  canvas.<span class="hljs-property">width</span> = viewport.<span class="hljs-property">width</span>;
  canvas.<span class="hljs-property">height</span> = viewport.<span class="hljs-property">height</span>;
  <span class="hljs-keyword">await</span> page.<span class="hljs-title function_">render</span>({ <span class="hljs-attr">canvasContext</span>: ctx, viewport }).<span class="hljs-property">promise</span>;
};
</code></pre>
<p>这样渲染压力被“分散到用户滚动过程”，不会一次性卡死。</p>
<hr/>
<h3 data-id="heading-10">导出图片（长图 + 逐页降级）</h3>
<p>导出长图时，浏览器对 canvas 尺寸限制很严格。如果文档太长，直接导出会失败，因此需要检测并降级。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> isTooLarge =
  docSize.<span class="hljs-property">width</span> &gt; <span class="hljs-variable constant_">MAX_EXPORT_DIMENSION</span> ||
  docSize.<span class="hljs-property">height</span> &gt; <span class="hljs-variable constant_">MAX_EXPORT_DIMENSION</span> ||
  docSize.<span class="hljs-property">width</span> * docSize.<span class="hljs-property">height</span> &gt; <span class="hljs-variable constant_">MAX_EXPORT_PIXELS</span>;

<span class="hljs-keyword">if</span> (isTooLarge) {
  <span class="hljs-comment">// 改为逐页导出</span>
}
</code></pre>
<p>逐页导出时，要把全局印章坐标换算到当前页坐标，这样骑缝章也不会丢。</p>
<hr/>
<h3 data-id="heading-11">导出 PDF（完整文件）</h3>
<p>导出 PDF 用 <code>pdf-lib</code> 做合成：</p>
<ol>
<li>每一页画布（含印章）转为 PNG。</li>
<li>插入到新 PDF 页。</li>
<li>生成 PDF 并下载。</li>
</ol>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> pdfDocument = <span class="hljs-keyword">await</span> <span class="hljs-title class_">PDFDocument</span>.<span class="hljs-title function_">create</span>();
<span class="hljs-keyword">const</span> pngImage = <span class="hljs-keyword">await</span> pdfDocument.<span class="hljs-title function_">embedPng</span>(pngBytes);
<span class="hljs-keyword">const</span> pdfPage = pdfDocument.<span class="hljs-title function_">addPage</span>([page.<span class="hljs-property">width</span>, page.<span class="hljs-property">height</span>]);
pdfPage.<span class="hljs-title function_">drawImage</span>(pngImage, { <span class="hljs-attr">x</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">width</span>: page.<span class="hljs-property">width</span>, <span class="hljs-attr">height</span>: page.<span class="hljs-property">height</span> });
</code></pre>
<p>下载逻辑：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> pdfBytes = <span class="hljs-keyword">await</span> pdfDocument.<span class="hljs-title function_">save</span>();
<span class="hljs-keyword">const</span> blob = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Blob</span>([pdfBytes], { <span class="hljs-attr">type</span>: <span class="hljs-string">'application/pdf'</span> });
<span class="hljs-keyword">const</span> url = <span class="hljs-variable constant_">URL</span>.<span class="hljs-title function_">createObjectURL</span>(blob);
link.<span class="hljs-property">download</span> = <span class="hljs-string">`盖章结果-<span class="hljs-subst">${<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().toISOString().slice(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>)}</span>.pdf`</span>;
link.<span class="hljs-property">href</span> = url;
link.<span class="hljs-title function_">click</span>();
</code></pre>
<blockquote>
<p>导出的 PDF 为“图片型 PDF”，兼容性高，但文字不可搜索。如果要保留矢量文字，需要更复杂的“原 PDF 叠加”方案。</p>
</blockquote>
<hr/>
<h3 data-id="heading-12">扩展方向</h3>
<ol>
<li><strong>矢量 PDF 导出</strong>：直接在原 PDF 叠加印章（更复杂，但可保留文字可搜索）。</li>
<li><strong>通用库封装</strong>：提炼核心逻辑为 <code>core</code>，React/Vue 只是适配层。</li>
<li><strong>企业场景扩展</strong>：模板库、权限管理、批量盖章。</li>
</ol>
<hr/>
<p>如果你准备上线到业务系统，建议在此基础上增加：</p>
<ul>
<li>盖章操作日志</li>
<li>导出前的预检查（页数、尺寸）</li>
<li>失败重试和导出进度提示</li>
</ul>
<p>这样体验会更接近商业级工具。</p>
<h3 data-id="heading-13">项目地址</h3>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fyilujian%2Fpdfstamp" target="_blank" title="https://github.com/yilujian/pdfstamp" ref="nofollow noopener noreferrer">github pdfstamp</a></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[简单 RAG 入门（01）]]></title>    <link>https://juejin.cn/post/7602211941513871414</link>    <guid>https://juejin.cn/post/7602211941513871414</guid>    <pubDate>2026-02-03T08:07:03.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602211941513871414" data-draft-id="7602411521071153171" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="简单 RAG 入门（01）"/> <meta itemprop="keywords" content="后端,Agent,人工智能"/> <meta itemprop="datePublished" content="2026-02-03T08:07:03.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="zone7739"/> <meta itemprop="url" content="https://juejin.cn/user/3245414054115741"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            简单 RAG 入门（01）
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3245414054115741/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    zone7739
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T08:07:03.000Z" title="Tue Feb 03 2026 08:07:03 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    24
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">前言</h2>
<p>在学习 RAG 之前，我们先来对比一下 RAG 和 AI Agent 的概念，只有先了解这些概念，才能继续往前推进。</p>
<h2 data-id="heading-1">什么是RAG</h2>
<p>简单来说就是允许你查阅书本，再来回答问题。</p>
<p>标准一点来说（也是简化过的）：</p>
<ol>
<li>用户问一个问题</li>
<li>把这个问题的字符串向量化</li>
<li>然后根据【问题向量】去向量数据库查找相似的知识点</li>
<li>把查到的知识和问题一起传递给大模型</li>
<li>大模型根据查到的知识点来回答问题</li>
</ol>
<p>当然了，这个流程也是简化过的，不过不用在意，这个只是便于你理解这个概念。</p>
<p>还有你需要知道的是：RAG 可以解决一些时效性的问题和幻觉问题。相比 Fing-turning 微调，RAG 更节省成本，而且数据可以溯源，可以知道相关的知识点源自哪个文档。</p>
<h2 data-id="heading-2">什么是AI Agent</h2>
<p>如果把 RAG 比作是查知识库，那么 AI Agent 就是可以执行具体任务的助手。主要包括这几个特点：</p>
<ol>
<li>规划：规划步骤，比如说买机票可以先查日期，再查天气，然后买机票</li>
<li>记忆：可以记住聊天上下文</li>
<li>工具使用：可以决定使用查天气的 API 还是执行一段 Python 代码</li>
<li>执行：规划好之后，可以执行具体的任务，并根据结果来执行下一步任务</li>
</ol>
<h2 data-id="heading-3">主流RAG框架</h2>
<p>目前主流的 RAG 框架有 LlamaIndex、langchain、Dify 等，我这边选择前面两个来做个示例：</p>
<p>大模型也分别选了 千问和 DeepSeek 来做展示：</p>
<h3 data-id="heading-4">环境准备</h3>
<h4 data-id="heading-5">1. Python 环境要求</h4>
<ul>
<li>Python 3.8 或更高版本（推荐 3.10+）</li>
<li>建议使用虚拟环境</li>
</ul>
<h4 data-id="heading-6">2. 安装依赖包</h4>
<p><strong>LlamaIndex 示例所需依赖：</strong></p>
<pre><code class="hljs language-bash" lang="bash">pip install llama-index
pip install llama-index-llms-dashscope
pip install llama-index-embeddings-dashscope
pip install dashscope
pip install python-dotenv
</code></pre>
<p><strong>LangChain 示例所需依赖：</strong></p>
<pre><code class="hljs language-bash" lang="bash">pip install langchain
pip install langchain-community
pip install langchain-huggingface
pip install langchain-deepseek
pip install langchain-text-splitters
pip install python-dotenv
pip install sentence-transformers  <span class="hljs-comment"># HuggingFace embeddings 依赖</span>
</code></pre>
<p><strong>一键安装所有依赖：</strong></p>
<pre><code class="hljs language-bash" lang="bash">pip install llama-index llama-index-llms-dashscope llama-index-embeddings-dashscope \
            dashscope langchain langchain-community langchain-huggingface \
            langchain-deepseek langchain-text-splitters python-dotenv sentence-transformers
</code></pre>
<h4 data-id="heading-7">3. API Key 配置</h4>
<p>创建 <code>.env</code> 文件，放到项目根目录：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-comment"># DeepSeek API 配置</span>
<span class="hljs-attr">DEEPSEEK_API_KEY</span>=sk-xxx
<span class="hljs-comment"># 千问</span>
<span class="hljs-attr">DASHSCOPE_API_KEY</span>=sk-yyy
</code></pre>
<p><strong>如何获取 API Key：</strong></p>
<ul>
<li>DeepSeek: <a href="https://link.juejin.cn?target=https%3A%2F%2Fplatform.deepseek.com%2F" target="_blank" title="https://platform.deepseek.com/" ref="nofollow noopener noreferrer">platform.deepseek.com/</a></li>
<li>千问(DashScope): <a href="https://link.juejin.cn?target=https%3A%2F%2Fdashscope.aliyun.com%2F" target="_blank" title="https://dashscope.aliyun.com/" ref="nofollow noopener noreferrer">dashscope.aliyun.com/</a></li>
</ul>
<h3 data-id="heading-8">LlamaIndex 示例（千问）</h3>
<p><strong>文件名：</strong> <code>01_LlamaIndex.py</code></p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> os
<span class="hljs-keyword">from</span> llama_index.llms.dashscope <span class="hljs-keyword">import</span> DashScope, DashScopeGenerationModels
<span class="hljs-keyword">from</span> llama_index.embeddings.dashscope <span class="hljs-keyword">import</span> DashScopeEmbedding
<span class="hljs-keyword">from</span> llama_index.core <span class="hljs-keyword">import</span> VectorStoreIndex, SimpleDirectoryReader, Settings

<span class="hljs-keyword">from</span> dotenv <span class="hljs-keyword">import</span> load_dotenv

os.environ[<span class="hljs-string">'USER_AGENT'</span>] = <span class="hljs-string">'my-rag-app/1.0'</span>
load_dotenv()
DATA_DIR = <span class="hljs-string">"./data"</span>

<span class="hljs-comment"># 1. 配置 LLM</span>
Settings.llm = DashScope(
    model_name=DashScopeGenerationModels.QWEN_MAX,
    api_key=os.getenv(<span class="hljs-string">"DASHSCOPE_API_KEY"</span>)
)

<span class="hljs-comment"># 2. 设置嵌入模型</span>
Settings.embed_model = DashScopeEmbedding(
    model_name=<span class="hljs-string">'text-embedding-v2'</span>,
    api_key=os.getenv(<span class="hljs-string">"DASHSCOPE_API_KEY"</span>),
    timeout=<span class="hljs-number">60</span>,  <span class="hljs-comment"># 增加超时时间</span>
    max_retries=<span class="hljs-number">5</span>  <span class="hljs-comment"># 增加重试次数</span>
)

<span class="hljs-comment"># 3. 加载与索引</span>
<span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(DATA_DIR):
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"错误：未找到路径 <span class="hljs-subst">{DATA_DIR}</span>"</span>)
<span class="hljs-keyword">else</span>:
    <span class="hljs-comment"># 建议直接使用绝对路径，避免相对路径带来的困扰</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"正在加载文档..."</span>)
    documents = SimpleDirectoryReader(DATA_DIR).load_data()

    <span class="hljs-built_in">print</span>(<span class="hljs-string">"正在创建索引（此步涉及 Embedding 接口调用）..."</span>)
    index = VectorStoreIndex.from_documents(documents)

    <span class="hljs-comment"># 4. 查询</span>
    query_engine = index.as_query_engine()

    <span class="hljs-built_in">print</span>(<span class="hljs-string">"正在提问..."</span>)
    response = query_engine.query(<span class="hljs-string">"2026春运时间是什么时候？"</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"AI 回答结果：\n<span class="hljs-subst">{response}</span>"</span>)
</code></pre>
<p><strong>运行方式：</strong></p>
<pre><code class="hljs language-bash" lang="bash">python 01_LlamaIndex.py
</code></pre>
<p><strong>运行结果：</strong></p>
<pre><code class="hljs language-erlang" lang="erlang">正在加载文档...
正在创建索引（此步涉及 Embedding 接口调用）...
正在提问...
AI 回答结果：
<span class="hljs-number">2026</span>年春运的时间是从<span class="hljs-number">2</span>月<span class="hljs-number">2</span>日至<span class="hljs-number">3</span>月<span class="hljs-number">13</span>日。
</code></pre>
<h3 data-id="heading-9">LangChain 示例（DeepSeek）</h3>
<p><strong>文件名：</strong> <code>02_LangChain_DeepSeek.py</code></p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> os
<span class="hljs-keyword">from</span> dotenv <span class="hljs-keyword">import</span> load_dotenv

os.environ[<span class="hljs-string">'USER_AGENT'</span>] = <span class="hljs-string">'my-rag-app/1.0'</span>
load_dotenv()

<span class="hljs-comment"># 1. 加载数据</span>
<span class="hljs-keyword">from</span> langchain_community.document_loaders <span class="hljs-keyword">import</span> TextLoader

<span class="hljs-comment"># 随便复制一些即时新闻放到 txt 文件中，例如：https://baike.baidu.com/item/2026%E5%B9%B4%E6%98%A5%E8%BF%90/66941026?fromModule=home_hotspot</span>
loader = TextLoader(
    file_path=<span class="hljs-string">"data/a.txt"</span>,
    encoding=<span class="hljs-string">"utf-8"</span>  <span class="hljs-comment"># 如果是中文文件，确保使用 utf-8 编码</span>
)

docs = loader.load()

<span class="hljs-comment"># 2. 文档分块</span>
<span class="hljs-keyword">from</span> langchain_text_splitters <span class="hljs-keyword">import</span> RecursiveCharacterTextSplitter

text_splitter = RecursiveCharacterTextSplitter(chunk_size=<span class="hljs-number">1000</span>, chunk_overlap=<span class="hljs-number">200</span>)
all_splits = text_splitter.split_documents(docs)

<span class="hljs-comment"># 3. 设置嵌入模型</span>
<span class="hljs-comment"># 使用本地 HuggingFace 模型（推荐，免费且稳定），可能需要科学网络</span>
<span class="hljs-keyword">from</span> langchain_huggingface <span class="hljs-keyword">import</span> HuggingFaceEmbeddings

embeddings = HuggingFaceEmbeddings(
    model_name=<span class="hljs-string">"BAAI/bge-small-zh-v1.5"</span>,  <span class="hljs-comment"># 中文模型</span>
    model_kwargs={<span class="hljs-string">'device'</span>: <span class="hljs-string">'cpu'</span>},
    encode_kwargs={<span class="hljs-string">'normalize_embeddings'</span>: <span class="hljs-literal">True</span>}
)

<span class="hljs-comment"># 4. 存到向量数据库中，为了方便测试，这里使用内存数据库</span>
<span class="hljs-keyword">from</span> langchain_core.vectorstores <span class="hljs-keyword">import</span> InMemoryVectorStore

vector_store = InMemoryVectorStore(embeddings)
vector_store.add_documents(all_splits)

<span class="hljs-comment"># 5. 构建用户查询，针对前面的即时新闻提问</span>
question = <span class="hljs-string">"2026春运时间是什么时候？"</span>

<span class="hljs-comment"># 6. 在向量数据库中搜索最相似的文档</span>
retrived_docs = vector_store.similarity_search(question, k=<span class="hljs-number">3</span>)
docs_content = <span class="hljs-string">"\n\n"</span>.join(doc.page_content <span class="hljs-keyword">for</span> doc <span class="hljs-keyword">in</span> retrived_docs)

<span class="hljs-comment"># 7. 构建提示模板</span>
<span class="hljs-keyword">from</span> langchain_core.prompts <span class="hljs-keyword">import</span> ChatPromptTemplate

prompt = ChatPromptTemplate.from_template(
    <span class="hljs-string">"""
    基于以下上下文回答问题。如果没有结果，就说没有找到对应信息。
                上下文: {context}
                问题: {question}
                回答:
    """</span>
)

<span class="hljs-comment"># 8. 把结果和问题都发给大模型，生成答案</span>
<span class="hljs-keyword">from</span> langchain_deepseek <span class="hljs-keyword">import</span> ChatDeepSeek

llm = ChatDeepSeek(
    model=<span class="hljs-string">"deepseek-chat"</span>,  <span class="hljs-comment"># DeepSeek API 支持的模型名称</span>
    temperature=<span class="hljs-number">0.7</span>,  <span class="hljs-comment"># 随机性</span>
    max_tokens=<span class="hljs-number">2048</span>,  <span class="hljs-comment"># 最大输出长度</span>
    api_key=os.getenv(<span class="hljs-string">"DEEPSEEK_API_KEY"</span>)  <span class="hljs-comment"># 从环境变量加载API key</span>
)

answer = llm.invoke(prompt.<span class="hljs-built_in">format</span>(question=question, context=docs_content))
<span class="hljs-built_in">print</span>(answer.content)  <span class="hljs-comment"># 只打印回答内容</span>
</code></pre>
<p><strong>运行方式：</strong></p>
<pre><code class="hljs language-bash" lang="bash">python 02_LangChain_DeepSeek.py
</code></pre>
<p><strong>运行结果：</strong></p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-number">2026</span><span class="hljs-string">年春运时间为2026年2月2日至2026年3月13日。</span>
</code></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Vue 3 路由守卫中安全使用 Composition API 的最佳实践]]></title>    <link>https://juejin.cn/post/7602188264113864719</link>    <guid>https://juejin.cn/post/7602188264113864719</guid>    <pubDate>2026-02-03T07:04:28.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602188264113864719" data-draft-id="7602158221852327951" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Vue 3 路由守卫中安全使用 Composition API 的最佳实践"/> <meta itemprop="keywords" content="前端,架构"/> <meta itemprop="datePublished" content="2026-02-03T07:04:28.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="大象的鼻子那么长"/> <meta itemprop="url" content="https://juejin.cn/user/2277843821926871"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Vue 3 路由守卫中安全使用 Composition API 的最佳实践
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2277843821926871/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    大象的鼻子那么长
  </span> <!----> <!----> <div class="vip-level" data-v-cd7d0a50="" data-v-292f6e48=""><span class="tooltip" data-v-cd7d0a50=""><div class="byte-tooltip byte-tooltip--dark" style="display:none;">
        VIP.4 融会贯通
      </div><span class="byte-tooltip__wrapper"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8AQMAAAAAMksxAAAAA1BMVEUAAACnej3aAAAAAXRSTlMAQObYZgAAAA5JREFUKM9jGAWjAAcAAAIcAAE27nY6AAAAAElFTkSuQmCC" alt="VIP.4 融会贯通" title="VIP.4 融会贯通" class="lazy" style="aspect-ratio:NaN;" data-v-5244ef91="" data-v-cd7d0a50=""/></span></span></div> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T07:04:28.000Z" title="Tue Feb 03 2026 07:04:28 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    4
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读12分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p><strong>日期</strong>: 2026-02-03<br/>
<strong>标签</strong>: Vue 3, Composition API, Router Guards, 架构设计, 最佳实践</p>
</blockquote>
<h2 data-id="heading-0">📋 目录</h2>
<ul>
<li><a href="#%E8%83%8C%E6%99%AF%E4%B8%8E%E9%97%AE%E9%A2%98" title="#%E8%83%8C%E6%99%AF%E4%B8%8E%E9%97%AE%E9%A2%98">背景与问题</a></li>
<li><a href="#%E6%A0%B8%E5%BF%83%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90" title="#%E6%A0%B8%E5%BF%83%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90">核心问题分析</a></li>
<li><a href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1" title="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1">解决方案设计</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" title="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">代码实现</a></li>
<li><a href="#%E6%9E%B6%E6%9E%84%E4%BC%98%E5%8C%96%E6%80%9D%E8%80%83" title="#%E6%9E%B6%E6%9E%84%E4%BC%98%E5%8C%96%E6%80%9D%E8%80%83">架构优化思考</a></li>
<li><a href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93" title="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93">最佳实践总结</a></li>
</ul>
<hr/>
<h2 data-id="heading-1">背景与问题</h2>
<h3 data-id="heading-2">业务场景</h3>
<p>在企业级 SaaS 应用中，我们需要在用户登录后进行多种认证检查：</p>
<ol>
<li><strong>用户类型认证</strong>：个人用户需激活、企业用户需完成认证</li>
<li><strong>密码过期检查</strong>：强制用户定期更新密码</li>
<li><strong>权限验证</strong>：不同用户类型访问不同功能模块</li>
</ol>
<p>最初的实现采用了"认证服务中心"（VerificationCenter）的设计模式，通过规则引擎统一管理所有认证逻辑。</p>
<h3 data-id="heading-3">遇到的问题</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// ❌ 错误示例：在路由守卫中直接调用 Composition API</span>
router.<span class="hljs-title function_">afterEach</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span></span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> { checkAndShowAuthDialog } = <span class="hljs-title function_">useUserTypeAuth</span>()
  <span class="hljs-title function_">checkAndShowAuthDialog</span>()
})
</code></pre>
<p><strong>报错信息</strong>：</p>
<pre><code class="hljs language-php" lang="php">SyntaxError: Must be called at the top of a `setup` <span class="hljs-function"><span class="hljs-keyword">function</span>
<span class="hljs-title">at</span> <span class="hljs-title">useI18n</span> (<span class="hljs-params">vue-i18n.js:<span class="hljs-number">314</span>:<span class="hljs-number">17</span></span>)
<span class="hljs-title">at</span> <span class="hljs-title">useConfirm</span> (<span class="hljs-params">useConfirm.ts:<span class="hljs-number">165</span>:<span class="hljs-number">17</span></span>)
<span class="hljs-title">at</span> <span class="hljs-title">useUserTypeAuth</span> (<span class="hljs-params">useUserTypeAuth.ts:<span class="hljs-number">72</span>:<span class="hljs-number">23</span></span>)
</span></code></pre>
<h3 data-id="heading-4">问题根源</h3>
<p>Vue 3 的 Composition API（如 <code>useI18n</code>、<code>useRouter</code>、<code>useRoute</code>）<strong>必须在 Vue 组件的 <code>setup</code> 函数顶层调用</strong>，而路由守卫运行在 Vue 组件上下文之外，直接调用会触发运行时错误。</p>
<hr/>
<h2 data-id="heading-5">核心问题分析</h2>
<h3 data-id="heading-6">1. Composition API 的上下文限制</h3>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// Vue 3 内部实现（简化版）</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">currentInstance</span>: <span class="hljs-title class_">ComponentInternalInstance</span> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getCurrentInstance</span>(<span class="hljs-params"/>): <span class="hljs-title class_">ComponentInternalInstance</span> | <span class="hljs-literal">null</span> {
  <span class="hljs-keyword">return</span> currentInstance
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useRouter</span>(<span class="hljs-params"/>): <span class="hljs-title class_">Router</span> {
  <span class="hljs-keyword">const</span> instance = <span class="hljs-title function_">getCurrentInstance</span>()
  <span class="hljs-keyword">if</span> (!instance) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Must be called at the top of a setup function'</span>)
  }
  <span class="hljs-keyword">return</span> instance.<span class="hljs-property">appContext</span>.<span class="hljs-property">config</span>.<span class="hljs-property">globalProperties</span>.<span class="hljs-property">$router</span>
}
</code></pre>
<p><strong>关键点</strong>：</p>
<ul>
<li>Composition API 依赖 <code>currentInstance</code> 获取 Vue 实例上下文</li>
<li>路由守卫执行时 <code>currentInstance</code> 为 <code>null</code></li>
<li>直接调用会抛出异常</li>
</ul>
<h3 data-id="heading-7">2. 架构过度设计的反思</h3>
<p>原有的 VerificationCenter 架构：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 规则引擎模式</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">VerificationRule</span> {
  <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>
  <span class="hljs-attr">when</span>: (<span class="hljs-string">'login'</span> | <span class="hljs-string">'appReady'</span> | <span class="hljs-string">'routeChange'</span>)[]
  <span class="hljs-attr">shouldRun</span>: <span class="hljs-function">(<span class="hljs-params">ctx: VerificationContext</span>) =&gt;</span> <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">boolean</span>&gt;
  <span class="hljs-attr">run</span>: <span class="hljs-function">(<span class="hljs-params">ctx: VerificationContext</span>) =&gt;</span> <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt;
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">VerificationCenter</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-attr">rules</span>: <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">VerificationRule</span>&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()
  
  <span class="hljs-title function_">register</span>(<span class="hljs-params">rule: VerificationRule</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">rules</span>.<span class="hljs-title function_">set</span>(rule.<span class="hljs-property">id</span>, rule)
  }
  
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">trigger: <span class="hljs-built_in">string</span></span>) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> rule <span class="hljs-keyword">of</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">rules</span>.<span class="hljs-title function_">values</span>()) {
      <span class="hljs-keyword">if</span> (rule.<span class="hljs-property">when</span>.<span class="hljs-title function_">includes</span>(trigger)) {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">await</span> rule.<span class="hljs-title function_">shouldRun</span>(ctx)) {
          <span class="hljs-keyword">await</span> rule.<span class="hljs-title function_">run</span>(ctx)
        }
      }
    }
  }
}
</code></pre>
<p><strong>问题分析</strong>：</p>
<ul>
<li>✅ <strong>优点</strong>：高度抽象、易扩展、规则解耦</li>
<li>❌ <strong>缺点</strong>：
<ul>
<li>只有 3 个规则，不需要如此复杂的架构</li>
<li>增加认知负担，新人难以理解</li>
<li>调用链路长，调试困难</li>
<li>性能开销（函数调用、对象创建）</li>
<li><strong>违反 YAGNI 原则</strong>（You Aren't Gonna Need It）</li>
</ul>
</li>
</ul>
<hr/>
<h2 data-id="heading-8">解决方案设计</h2>
<h3 data-id="heading-9">设计原则</h3>
<ol>
<li><strong>简单性优于灵活性</strong>：当前需求简单，不需要过度设计</li>
<li><strong>SOLID 原则</strong>：单一职责、开闭原则</li>
<li><strong>上下文隔离</strong>：路由守卫专用函数不依赖 Vue 上下文</li>
</ol>
<h3 data-id="heading-10">架构对比</h3>
<h4 data-id="heading-11">方案一：直接调用（✅ 采用）</h4>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 路由守卫中直接调用</span>
router.<span class="hljs-title function_">afterEach</span>(<span class="hljs-function">(<span class="hljs-params">to</span>) =&gt;</span> {
  <span class="hljs-title function_">checkAuthInRouterGuard</span>()
  <span class="hljs-title function_">checkPasswordExpiredInRouterGuard</span>(router)
})
</code></pre>
<p><strong>优点</strong>：</p>
<ul>
<li>代码简洁直观</li>
<li>调用链路清晰</li>
<li>易于调试和维护</li>
<li>性能最优</li>
</ul>
<h4 data-id="heading-12">方案二：保留规则引擎（❌ 放弃）</h4>
<p><strong>缺点</strong>：</p>
<ul>
<li>过度设计，增加复杂度</li>
<li>不符合当前业务规模</li>
<li>维护成本高</li>
</ul>
<h3 data-id="heading-13">技术方案</h3>
<p><strong>核心思路</strong>：为路由守卫创建独立的、不依赖 Composition API 的函数。</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 设计模式：Adapter Pattern（适配器模式）</span>
<span class="hljs-comment">// 将依赖 Composition API 的逻辑适配为独立函数</span>

<span class="hljs-comment">// 1. 组件内使用（依赖 Composition API）</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useUserTypeAuth</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> router = <span class="hljs-title function_">useRouter</span>()  <span class="hljs-comment">// ✅ 在 setup 中调用</span>
  <span class="hljs-keyword">const</span> { t } = <span class="hljs-title function_">useI18n</span>()      <span class="hljs-comment">// ✅ 在 setup 中调用</span>
  <span class="hljs-comment">// ...</span>
}

<span class="hljs-comment">// 2. 路由守卫使用（不依赖 Composition API）</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">checkAuthInRouterGuard</span>(<span class="hljs-params"/>): <span class="hljs-built_in">void</span> {
  <span class="hljs-comment">// ✅ 直接从 store 获取数据，不依赖 Vue 上下文</span>
  <span class="hljs-keyword">const</span> userType = <span class="hljs-title function_">getUserTypeFromStore</span>()
  <span class="hljs-keyword">const</span> user = <span class="hljs-title function_">getUserFromStore</span>()
  
  <span class="hljs-comment">// ✅ 使用安全的 i18n 包装器</span>
  <span class="hljs-keyword">const</span> t = <span class="hljs-title function_">getSafeI18n</span>()
  
  <span class="hljs-comment">// ✅ 动态导入 router 实例</span>
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleAction</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"/>) =&gt; {
    <span class="hljs-keyword">const</span> { <span class="hljs-attr">default</span>: router } = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'~/router'</span>)
    <span class="hljs-keyword">await</span> router.<span class="hljs-title function_">push</span>(<span class="hljs-string">'/profile'</span>)
  }
}
</code></pre>
<hr/>
<h2 data-id="heading-14">代码实现</h2>
<h3 data-id="heading-15">1. 安全的 i18n 包装器</h3>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// src/composables/ui/useConfirm.ts</span>

<span class="hljs-comment">/**
 * 安全获取 i18n 翻译函数
 * <span class="hljs-doctag">@description</span> 尝试调用 useI18n()，失败则返回 fallback 翻译
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">getSafeI18n</span>(<span class="hljs-params"/>): <span class="hljs-function">(<span class="hljs-params">key: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">string</span> {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> { t } = <span class="hljs-title function_">useI18n</span>()
    <span class="hljs-keyword">return</span> t
  } <span class="hljs-keyword">catch</span> {
    <span class="hljs-comment">// 路由守卫等非 Vue 组件上下文中使用 fallback</span>
    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">key: <span class="hljs-built_in">string</span></span>) =&gt;</span> {
      <span class="hljs-keyword">const</span> <span class="hljs-attr">fallbacks</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt; = {
        <span class="hljs-string">'common.confirmTitle'</span>: <span class="hljs-string">'提示'</span>,
        <span class="hljs-string">'common.ok'</span>: <span class="hljs-string">'确定'</span>,
        <span class="hljs-string">'common.cancel'</span>: <span class="hljs-string">'取消'</span>,
        <span class="hljs-string">'common.closeWindow'</span>: <span class="hljs-string">'关闭窗口'</span>,
        <span class="hljs-string">'ui.confirm.cancelTask'</span>: <span class="hljs-string">'取消任务'</span>,
        <span class="hljs-string">'ui.confirm.continueOperation'</span>: <span class="hljs-string">'继续操作'</span>,
      }
      <span class="hljs-keyword">return</span> fallbacks[key] || key
    }
  }
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useConfirm</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> t = <span class="hljs-title function_">getSafeI18n</span>() <span class="hljs-comment">// ✅ 安全调用</span>
  
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">confirm</span> = (<span class="hljs-params">message: <span class="hljs-built_in">string</span>, options?: ConfirmOptions</span>) =&gt; {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">ElMessageBox</span>.<span class="hljs-title function_">confirm</span>(message, {
      <span class="hljs-attr">title</span>: options?.<span class="hljs-property">title</span> || <span class="hljs-title function_">t</span>(<span class="hljs-string">'common.confirmTitle'</span>),
      <span class="hljs-attr">confirmButtonText</span>: options?.<span class="hljs-property">okBtnText</span> || <span class="hljs-title function_">t</span>(<span class="hljs-string">'common.ok'</span>),
      <span class="hljs-attr">cancelButtonText</span>: <span class="hljs-title function_">t</span>(<span class="hljs-string">'common.cancel'</span>),
      <span class="hljs-attr">type</span>: options?.<span class="hljs-property">type</span> || <span class="hljs-string">'info'</span>,
      <span class="hljs-comment">// ...</span>
    })
  }
  
  <span class="hljs-keyword">return</span> { confirm, alert }
}
</code></pre>
<p><strong>设计亮点</strong>：</p>
<ul>
<li><strong>优雅降级</strong>：有 Vue 上下文时使用 <code>useI18n()</code>，否则使用 fallback</li>
<li><strong>零侵入</strong>：不影响现有组件的使用方式</li>
<li><strong>类型安全</strong>：保持完整的 TypeScript 类型推导</li>
</ul>
<h3 data-id="heading-16">2. 用户认证检查（路由守卫专用）</h3>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// src/composables/auth/useUserTypeAuth.ts</span>

<span class="hljs-comment">/**
 * 路由守卫中检查用户认证状态
 * <span class="hljs-doctag">@description</span> 不依赖 Composition API，可在路由守卫中安全调用
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">checkAuthInRouterGuard</span>(<span class="hljs-params"/>): <span class="hljs-built_in">void</span> {
  <span class="hljs-comment">// 1. 从 store 获取数据（不依赖 Vue 上下文）</span>
  <span class="hljs-keyword">const</span> userType = <span class="hljs-title function_">getUserTypeFromStore</span>()
  
  <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">needsAuthPrompt</span>(userType)) {
    <span class="hljs-keyword">return</span>
  }
  
  <span class="hljs-keyword">const</span> user = <span class="hljs-title function_">getUserFromStore</span>()
  <span class="hljs-keyword">if</span> (!user) {
    <span class="hljs-keyword">return</span>
  }
  
  <span class="hljs-comment">// 2. 使用安全的 confirm（内部使用 getSafeI18n）</span>
  <span class="hljs-keyword">const</span> { confirm } = <span class="hljs-title function_">useConfirm</span>()
  <span class="hljs-keyword">const</span> t = <span class="hljs-title function_">getSafeI18n</span>()
  
  <span class="hljs-comment">// 3. 获取提示配置</span>
  <span class="hljs-keyword">const</span> config = <span class="hljs-title function_">getAuthPromptMessage</span>(userType, user, t)
  
  <span class="hljs-keyword">if</span> (!config.<span class="hljs-property">content</span>) {
    <span class="hljs-keyword">return</span>
  }
  
  <span class="hljs-comment">// 4. 显示确认对话框</span>
  <span class="hljs-built_in">void</span> (<span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">if</span> (config.<span class="hljs-property">showConfirmBtn</span>) {
        <span class="hljs-keyword">await</span> <span class="hljs-title function_">confirm</span>(config.<span class="hljs-property">content</span>, {
          <span class="hljs-attr">title</span>: config.<span class="hljs-property">title</span>,
          <span class="hljs-attr">type</span>: <span class="hljs-string">'warning'</span>,
          <span class="hljs-attr">buttons</span>: [
            {
              <span class="hljs-attr">text</span>: config.<span class="hljs-property">confirmText</span>,
              <span class="hljs-attr">type</span>: <span class="hljs-string">'primary'</span>,
              <span class="hljs-attr">customClass</span>: <span class="hljs-string">'customer-button-default customer-primary-button customer-button'</span>,
              <span class="hljs-attr">onClick</span>: <span class="hljs-keyword">async</span> () =&gt; {
                <span class="hljs-comment">// ✅ 动态导入 router，避免循环依赖</span>
                <span class="hljs-keyword">const</span> { <span class="hljs-attr">default</span>: router } = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'~/router'</span>)
                <span class="hljs-keyword">await</span> <span class="hljs-title function_">executeAuthActionForService</span>(userType, user, router)
              },
            },
            {
              <span class="hljs-attr">text</span>: config.<span class="hljs-property">cancelText</span>,
              <span class="hljs-attr">type</span>: <span class="hljs-string">'default'</span>,
              <span class="hljs-attr">customClass</span>: <span class="hljs-string">'trans-bg-btn'</span>,
            },
          ],
        })
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// 企业认证审核中：仅显示提示，使用文字按钮</span>
        <span class="hljs-keyword">await</span> <span class="hljs-title function_">confirm</span>(config.<span class="hljs-property">content</span>, {
          <span class="hljs-attr">title</span>: config.<span class="hljs-property">title</span>,
          <span class="hljs-attr">type</span>: <span class="hljs-string">'warning'</span>,
          <span class="hljs-attr">buttons</span>: [
            {
              <span class="hljs-attr">text</span>: config.<span class="hljs-property">confirmText</span>,
              <span class="hljs-attr">type</span>: <span class="hljs-string">'primary'</span>,
              <span class="hljs-attr">link</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// ✅ 文字按钮样式</span>
            },
          ],
        })
      }
    } <span class="hljs-keyword">catch</span> {
      <span class="hljs-comment">// 用户取消操作</span>
    }
  })()
}

<span class="hljs-comment">// ==================== 辅助函数 ====================</span>

<span class="hljs-comment">/**
 * 从 Store 获取用户类型
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">getUserTypeFromStore</span>(<span class="hljs-params"/>): <span class="hljs-built_in">number</span> {
  <span class="hljs-keyword">const</span> userStore = <span class="hljs-title function_">useUserStoreWithOut</span>()
  <span class="hljs-keyword">return</span> userStore.<span class="hljs-property">userInfo</span>?.<span class="hljs-property">userType</span> ?? <span class="hljs-number">0</span>
}

<span class="hljs-comment">/**
 * 从 Store 获取用户信息
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">getUserFromStore</span>(<span class="hljs-params"/>): <span class="hljs-built_in">any</span> {
  <span class="hljs-keyword">const</span> userStore = <span class="hljs-title function_">useUserStoreWithOut</span>()
  <span class="hljs-keyword">return</span> userStore.<span class="hljs-property">userInfo</span>
}

<span class="hljs-comment">/**
 * 判断是否需要显示认证提示
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">needsAuthPrompt</span>(<span class="hljs-params">userType: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">boolean</span> {
  <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">NEEDS_AUTH_PROMPT_USER_TYPES</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]
  <span class="hljs-keyword">return</span> <span class="hljs-variable constant_">NEEDS_AUTH_PROMPT_USER_TYPES</span>.<span class="hljs-title function_">includes</span>(userType)
}

<span class="hljs-comment">/**
 * 获取认证提示消息配置
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">getAuthPromptMessage</span>(<span class="hljs-params">
  userType: <span class="hljs-built_in">number</span>,
  user: <span class="hljs-built_in">any</span>,
  t: (key: <span class="hljs-built_in">string</span>) =&gt; <span class="hljs-built_in">string</span>,
</span>): <span class="hljs-title class_">AuthPromptConfig</span> {
  <span class="hljs-comment">// 个人用户：未激活</span>
  <span class="hljs-keyword">if</span> (userType === <span class="hljs-number">1</span> &amp;&amp; user.<span class="hljs-property">userStatus</span> === <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">title</span>: <span class="hljs-title function_">t</span>(<span class="hljs-string">'register.personalActivation'</span>),
      <span class="hljs-attr">content</span>: <span class="hljs-title function_">t</span>(<span class="hljs-string">'register.personalActivationTip'</span>),
      <span class="hljs-attr">confirmText</span>: <span class="hljs-title function_">t</span>(<span class="hljs-string">'register.goActivate'</span>),
      <span class="hljs-attr">cancelText</span>: <span class="hljs-title function_">t</span>(<span class="hljs-string">'common.cancel'</span>),
      <span class="hljs-attr">showConfirmBtn</span>: <span class="hljs-literal">true</span>,
    }
  }
  
  <span class="hljs-comment">// 企业用户：认证审核中</span>
  <span class="hljs-keyword">if</span> ([<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>].<span class="hljs-title function_">includes</span>(userType) &amp;&amp; user.<span class="hljs-property">verificationStatus</span> === <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">title</span>: <span class="hljs-title function_">t</span>(<span class="hljs-string">'register.enterpriseCertification'</span>),
      <span class="hljs-attr">content</span>: <span class="hljs-title function_">t</span>(<span class="hljs-string">'register.enterpriseCertificationPendingTip'</span>),
      <span class="hljs-attr">confirmText</span>: <span class="hljs-title function_">t</span>(<span class="hljs-string">'common.ok'</span>),
      <span class="hljs-attr">cancelText</span>: <span class="hljs-string">''</span>,
      <span class="hljs-attr">showConfirmBtn</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// ✅ 仅显示提示，不需要确认按钮</span>
    }
  }
  
  <span class="hljs-comment">// 企业用户：认证被拒绝</span>
  <span class="hljs-keyword">if</span> ([<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>].<span class="hljs-title function_">includes</span>(userType) &amp;&amp; user.<span class="hljs-property">verificationStatus</span> === <span class="hljs-number">3</span>) {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">title</span>: <span class="hljs-title function_">t</span>(<span class="hljs-string">'register.enterpriseCertification'</span>),
      <span class="hljs-attr">content</span>: <span class="hljs-title function_">t</span>(<span class="hljs-string">'register.enterpriseCertificationRejectedTip'</span>),
      <span class="hljs-attr">confirmText</span>: <span class="hljs-title function_">t</span>(<span class="hljs-string">'register.goResubmit'</span>),
      <span class="hljs-attr">cancelText</span>: <span class="hljs-title function_">t</span>(<span class="hljs-string">'common.cancel'</span>),
      <span class="hljs-attr">showConfirmBtn</span>: <span class="hljs-literal">true</span>,
    }
  }
  
  <span class="hljs-keyword">return</span> { <span class="hljs-attr">title</span>: <span class="hljs-string">''</span>, <span class="hljs-attr">content</span>: <span class="hljs-string">''</span>, <span class="hljs-attr">confirmText</span>: <span class="hljs-string">''</span>, <span class="hljs-attr">cancelText</span>: <span class="hljs-string">''</span>, <span class="hljs-attr">showConfirmBtn</span>: <span class="hljs-literal">false</span> }
}
</code></pre>
<p><strong>设计亮点</strong>：</p>
<ul>
<li><strong>职责分离</strong>：数据获取、逻辑判断、UI 展示分离</li>
<li><strong>可测试性</strong>：纯函数设计，易于单元测试</li>
<li><strong>动态导入</strong>：避免循环依赖，按需加载</li>
<li><strong>错误处理</strong>：优雅处理用户取消操作</li>
</ul>
<h3 data-id="heading-17">3. 密码过期检查（路由守卫专用）</h3>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// src/composables/auth/usePasswordExpired.ts</span>

<span class="hljs-comment">/**
 * 路由守卫中检查密码过期并显示重置弹窗
 * <span class="hljs-doctag">@description</span> 不依赖 Composition API，可在路由守卫中安全调用
 * <span class="hljs-doctag">@param</span> <span class="hljs-variable">routerInstance</span> - 路由实例
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">checkPasswordExpiredInRouterGuard</span>(<span class="hljs-params">routerInstance: Router</span>): <span class="hljs-built_in">void</span> {
  <span class="hljs-keyword">const</span> route = routerInstance.<span class="hljs-property">currentRoute</span>.<span class="hljs-property">value</span>

  <span class="hljs-comment">// 1. 跳过 blank 布局页面（登录、注册等）</span>
  <span class="hljs-keyword">const</span> isBlank = route?.<span class="hljs-property">meta</span>?.<span class="hljs-property">layout</span> === <span class="hljs-string">'blank'</span>
  <span class="hljs-keyword">if</span> (isBlank) <span class="hljs-keyword">return</span>

  <span class="hljs-comment">// 2. 只在内部页面检查</span>
  <span class="hljs-keyword">const</span> category = route?.<span class="hljs-property">meta</span>?.<span class="hljs-property">category</span>
  <span class="hljs-keyword">if</span> (category !== <span class="hljs-string">'internal'</span>) <span class="hljs-keyword">return</span>

  <span class="hljs-comment">// 3. 检查 sessionStorage 标记</span>
  <span class="hljs-keyword">const</span> forceTokenReset = sessionStorage.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">'vc_force_reset_pwd'</span>) === <span class="hljs-string">'1'</span>
  <span class="hljs-keyword">const</span> forceSelfReset = sessionStorage.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">'vc_force_reset_pwd_self'</span>) === <span class="hljs-string">'1'</span>

  <span class="hljs-keyword">if</span> (forceTokenReset || forceSelfReset) {
    <span class="hljs-title function_">showResetPasswordDialogStandalone</span>(routerInstance)
  }
}

<span class="hljs-comment">/**
 * 显示密码重置弹窗（独立函数，不依赖 Composition API）
 * <span class="hljs-doctag">@param</span> <span class="hljs-variable">routerInstance</span> - 路由实例
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">showResetPasswordDialogStandalone</span>(<span class="hljs-params">routerInstance: Router</span>): <span class="hljs-built_in">void</span> {
  <span class="hljs-keyword">const</span> container = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">'div'</span>)
  <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(container)

  <span class="hljs-comment">// ✅ 使用 createApp 动态挂载组件</span>
  <span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>({
    <span class="hljs-title function_">render</span>(<span class="hljs-params"/>) {
      <span class="hljs-keyword">const</span> useTokenMode = sessionStorage.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">'vc_force_reset_pwd'</span>) === <span class="hljs-string">'1'</span>
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">h</span>(<span class="hljs-title class_">ResetPassWord</span>, {
        <span class="hljs-attr">size</span>: <span class="hljs-string">'large'</span>,
        <span class="hljs-attr">force</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">useToken</span>: useTokenMode,
        <span class="hljs-attr">onSuccess</span>: <span class="hljs-function">() =&gt;</span> {
          <span class="hljs-comment">// 清理标记</span>
          <span class="hljs-keyword">try</span> {
            sessionStorage.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">'vc_force_reset_pwd'</span>)
            sessionStorage.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">'vc_force_reset_pwd_self'</span>)
            sessionStorage.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">'vc_pwd_reset_token'</span>)
            sessionStorage.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">'vc_origin_password'</span>)
          } <span class="hljs-keyword">catch</span> {}
          
          <span class="hljs-comment">// 清理登录状态</span>
          common.<span class="hljs-title function_">setWindowKeyValue</span>(<span class="hljs-string">'pwd_reset_token'</span>, <span class="hljs-literal">undefined</span>)
          common.<span class="hljs-title function_">removeLoginAuthToken</span>()
          <span class="hljs-variable language_">window</span>.<span class="hljs-property">sessionStorage</span>.<span class="hljs-title function_">clear</span>()
          
          <span class="hljs-comment">// 跳转到登录页</span>
          routerInstance.<span class="hljs-title function_">replace</span>(<span class="hljs-title class_">RouteConfig</span>.<span class="hljs-property">Login</span>.<span class="hljs-property">path</span>)
          
          <span class="hljs-comment">// 卸载组件</span>
          app.<span class="hljs-title function_">unmount</span>()
          <span class="hljs-keyword">if</span> (container.<span class="hljs-property">parentNode</span>)
            container.<span class="hljs-property">parentNode</span>.<span class="hljs-title function_">removeChild</span>(container)
        },
        <span class="hljs-attr">onClose</span>: <span class="hljs-function">() =&gt;</span> {
          app.<span class="hljs-title function_">unmount</span>()
          <span class="hljs-keyword">if</span> (container.<span class="hljs-property">parentNode</span>)
            container.<span class="hljs-property">parentNode</span>.<span class="hljs-title function_">removeChild</span>(container)
        },
      })
    },
  })

  <span class="hljs-comment">// ✅ 注入全局 i18n（从 window 获取，避免依赖 useI18n）</span>
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">if</span> ((<span class="hljs-variable language_">window</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>).<span class="hljs-property">i18n</span>) {
      app.<span class="hljs-title function_">use</span>((<span class="hljs-variable language_">window</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>).<span class="hljs-property">i18n</span>)
    }
  } <span class="hljs-keyword">catch</span> {}

  app.<span class="hljs-title function_">mount</span>(container)

  <span class="hljs-comment">// ✅ 监听路由变化，自动关闭弹窗</span>
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> unwatch = routerInstance.<span class="hljs-title function_">afterEach</span>(<span class="hljs-function">(<span class="hljs-params">to: <span class="hljs-built_in">any</span></span>) =&gt;</span> {
      <span class="hljs-keyword">const</span> isBlank = to?.<span class="hljs-property">meta</span>?.<span class="hljs-property">layout</span> === <span class="hljs-string">'blank'</span>
      <span class="hljs-keyword">if</span> (isBlank) {
        <span class="hljs-keyword">try</span> {
          sessionStorage.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">'vc_force_reset_pwd'</span>)
          sessionStorage.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">'vc_force_reset_pwd_self'</span>)
        } <span class="hljs-keyword">catch</span> {}
        app.<span class="hljs-title function_">unmount</span>()
        <span class="hljs-keyword">if</span> (container.<span class="hljs-property">parentNode</span>)
          container.<span class="hljs-property">parentNode</span>.<span class="hljs-title function_">removeChild</span>(container)
        <span class="hljs-title function_">unwatch</span>()
      }
    })
  } <span class="hljs-keyword">catch</span> {}
}
</code></pre>
<p><strong>设计亮点</strong>：</p>
<ul>
<li><strong>动态挂载</strong>：使用 <code>createApp</code> + <code>h()</code> 渲染函数动态创建组件实例</li>
<li><strong>生命周期管理</strong>：自动清理 DOM 和事件监听器</li>
<li><strong>全局 i18n 注入</strong>：从 <code>window</code> 获取全局 i18n 实例，避免依赖 <code>useI18n()</code></li>
<li><strong>路由监听</strong>：自动响应路由变化，关闭弹窗</li>
</ul>
<h3 data-id="heading-18">4. 路由守卫集成</h3>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// src/router/index.ts</span>

<span class="hljs-keyword">import</span> { createRouter, createWebHashHistory } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue-router'</span>
<span class="hljs-keyword">import</span> { checkPasswordExpiredInRouterGuard } <span class="hljs-keyword">from</span> <span class="hljs-string">'~/composables/auth/usePasswordExpired'</span>
<span class="hljs-keyword">import</span> { checkAuthInRouterGuard } <span class="hljs-keyword">from</span> <span class="hljs-string">'~/composables/auth/useUserTypeAuth'</span>

<span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>({
  <span class="hljs-attr">history</span>: <span class="hljs-title function_">createWebHashHistory</span>(),
  routes,
})

<span class="hljs-comment">// ==================== 路由后置守卫 ====================</span>
router.<span class="hljs-title function_">afterEach</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span></span>) =&gt;</span> {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-comment">// Keep-Alive 缓存管理</span>
    <span class="hljs-keyword">const</span> keepAliveStore = <span class="hljs-title function_">useKeepAliveStoreWithOut</span>()
    <span class="hljs-keyword">if</span> (to.<span class="hljs-property">meta</span>?.<span class="hljs-property">keepAlive</span> &amp;&amp; to.<span class="hljs-property">name</span>) {
      keepAliveStore.<span class="hljs-title function_">addCachedView</span>(to.<span class="hljs-property">name</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>)
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">from</span>.<span class="hljs-property">meta</span>?.<span class="hljs-property">noCache</span> &amp;&amp; <span class="hljs-keyword">from</span>.<span class="hljs-property">name</span>) {
      keepAliveStore.<span class="hljs-title function_">deleteCachedView</span>(<span class="hljs-keyword">from</span>.<span class="hljs-property">name</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>)
    }

    <span class="hljs-comment">// 重置滚动位置</span>
    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">scrollTo</span>({ <span class="hljs-attr">top</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">left</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">behavior</span>: <span class="hljs-string">'auto'</span> })

    <span class="hljs-comment">// 停止进度条</span>
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
      nprogressManager.<span class="hljs-title function_">done</span>()
      <span class="hljs-title class_">CmcLoadingService</span>.<span class="hljs-title function_">closeAll</span>()
    }, <span class="hljs-number">300</span>)

    <span class="hljs-comment">// ==================== 认证检查 ====================</span>
    <span class="hljs-comment">// 跳过 blank 布局页面（登录、注册等）</span>
    <span class="hljs-keyword">if</span> (to.<span class="hljs-property">meta</span>?.<span class="hljs-property">layout</span> !== <span class="hljs-string">'blank'</span>) {
      <span class="hljs-comment">// ✅ 用户认证检查（不依赖 Composition API）</span>
      <span class="hljs-title function_">checkAuthInRouterGuard</span>()

      <span class="hljs-comment">// ✅ 密码过期检查（不依赖 Composition API）</span>
      <span class="hljs-title function_">checkPasswordExpiredInRouterGuard</span>(router)
    }
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'路由后置守卫执行失败:'</span>, error)
  }
})

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router
</code></pre>
<p><strong>设计亮点</strong>：</p>
<ul>
<li><strong>清晰的职责划分</strong>：缓存管理、滚动控制、认证检查分离</li>
<li><strong>错误边界</strong>：统一的 try-catch 错误处理</li>
<li><strong>条件执行</strong>：根据路由元信息决定是否执行检查</li>
</ul>
<hr/>
<h2 data-id="heading-19">架构优化思考</h2>
<h3 data-id="heading-20">1. YAGNI 原则的实践</h3>
<p><strong>You Aren't Gonna Need It（你不会需要它）</strong></p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// ❌ 过度设计：为未来可能的需求预留扩展</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">VerificationCenter</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-attr">rules</span>: <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">VerificationRule</span>&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()
  <span class="hljs-keyword">private</span> <span class="hljs-attr">middleware</span>: <span class="hljs-title class_">Middleware</span>[] = []
  <span class="hljs-keyword">private</span> <span class="hljs-attr">eventBus</span>: <span class="hljs-title class_">EventEmitter</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventEmitter</span>()
  
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">trigger: <span class="hljs-built_in">string</span>, ctx: VerificationContext</span>) {
    <span class="hljs-comment">// 复杂的规则引擎逻辑</span>
    <span class="hljs-comment">// 中间件机制</span>
    <span class="hljs-comment">// 事件发布订阅</span>
  }
}

<span class="hljs-comment">// ✅ 简单设计：满足当前需求即可</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">checkAuthInRouterGuard</span>(<span class="hljs-params"/>): <span class="hljs-built_in">void</span> {
  <span class="hljs-comment">// 直接实现业务逻辑</span>
}
</code></pre>
<p><strong>反思</strong>：</p>
<ul>
<li>当前只有 3 个认证规则，不需要规则引擎</li>
<li>未来如果真的需要扩展（如增加到 10+ 规则），再重构也不迟</li>
<li>过早优化是万恶之源</li>
</ul>
<h3 data-id="heading-21">2. 简单性 vs 灵活性</h3>








































<table><thead><tr><th>维度</th><th>规则引擎（复杂）</th><th>直接调用（简单）</th></tr></thead><tbody><tr><td><strong>代码行数</strong></td><td>~500 行</td><td>~200 行</td></tr><tr><td><strong>认知负担</strong></td><td>高（需理解规则引擎）</td><td>低（直接阅读业务逻辑）</td></tr><tr><td><strong>调试难度</strong></td><td>困难（调用链长）</td><td>简单（调用链短）</td></tr><tr><td><strong>扩展性</strong></td><td>高（添加规则）</td><td>中（直接添加函数）</td></tr><tr><td><strong>性能</strong></td><td>中（函数调用开销）</td><td>高（直接调用）</td></tr><tr><td><strong>适用场景</strong></td><td>10+ 规则</td><td>3-5 规则</td></tr></tbody></table>
<p><strong>结论</strong>：在当前业务规模下，简单性优于灵活性。</p>
<h3 data-id="heading-22">3. 上下文隔离的设计模式</h3>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 设计模式：Adapter Pattern（适配器模式）</span>

<span class="hljs-comment">// 1. 组件内使用（依赖 Vue 上下文）</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useUserTypeAuth</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> router = <span class="hljs-title function_">useRouter</span>()  <span class="hljs-comment">// 依赖 Vue 上下文</span>
  <span class="hljs-keyword">const</span> { t } = <span class="hljs-title function_">useI18n</span>()      <span class="hljs-comment">// 依赖 Vue 上下文</span>
  
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">checkAndShowAuthDialog</span>: <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-comment">// 组件内逻辑</span>
    }
  }
}

<span class="hljs-comment">// 2. 路由守卫使用（不依赖 Vue 上下文）</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">checkAuthInRouterGuard</span>(<span class="hljs-params"/>): <span class="hljs-built_in">void</span> {
  <span class="hljs-comment">// 适配器：将依赖 Vue 上下文的逻辑转换为独立函数</span>
  <span class="hljs-keyword">const</span> userType = <span class="hljs-title function_">getUserTypeFromStore</span>()  <span class="hljs-comment">// 直接访问 store</span>
  <span class="hljs-keyword">const</span> t = <span class="hljs-title function_">getSafeI18n</span>()                  <span class="hljs-comment">// 安全的 i18n 包装器</span>
  
  <span class="hljs-comment">// 业务逻辑</span>
}
</code></pre>
<p><strong>设计原则</strong>：</p>
<ul>
<li><strong>单一职责</strong>：每个函数只做一件事</li>
<li><strong>依赖倒置</strong>：依赖抽象（store、全局对象）而非具体实现（Vue 实例）</li>
<li><strong>开闭原则</strong>：对扩展开放（可添加新的检查函数），对修改封闭（不影响现有逻辑）</li>
</ul>
<h3 data-id="heading-23">4. 错误处理策略</h3>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// ✅ 优雅降级</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">getSafeI18n</span>(<span class="hljs-params"/>): <span class="hljs-function">(<span class="hljs-params">key: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">string</span> {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> { t } = <span class="hljs-title function_">useI18n</span>()
    <span class="hljs-keyword">return</span> t
  } <span class="hljs-keyword">catch</span> {
    <span class="hljs-comment">// 降级到 fallback 翻译</span>
    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">key: <span class="hljs-built_in">string</span></span>) =&gt;</span> fallbacks[key] || key
  }
}

<span class="hljs-comment">// ✅ 静默失败（用户取消操作）</span>
<span class="hljs-built_in">void</span> (<span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">await</span> <span class="hljs-title function_">confirm</span>(config.<span class="hljs-property">content</span>, options)
  } <span class="hljs-keyword">catch</span> {
    <span class="hljs-comment">// 用户取消，不需要处理</span>
  }
})()

<span class="hljs-comment">// ✅ 全局错误边界</span>
router.<span class="hljs-title function_">afterEach</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span></span>) =&gt;</span> {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-title function_">checkAuthInRouterGuard</span>()
    <span class="hljs-title function_">checkPasswordExpiredInRouterGuard</span>(router)
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'路由后置守卫执行失败:'</span>, error)
    <span class="hljs-comment">// 不阻断路由导航</span>
  }
})
</code></pre>
<p><strong>原则</strong>：</p>
<ul>
<li><strong>优雅降级</strong>：功能不可用时提供 fallback</li>
<li><strong>静默失败</strong>：用户主动取消的操作不需要错误提示</li>
<li><strong>全局边界</strong>：关键路径添加 try-catch，防止整个应用崩溃</li>
</ul>
<hr/>
<h2 data-id="heading-24">最佳实践总结</h2>
<h3 data-id="heading-25">✅ Do's（推荐做法）</h3>
<ol>
<li>
<p><strong>为路由守卫创建独立函数</strong></p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// ✅ 独立函数，不依赖 Composition API</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">checkAuthInRouterGuard</span>(<span class="hljs-params"/>): <span class="hljs-built_in">void</span> {
  <span class="hljs-keyword">const</span> userType = <span class="hljs-title function_">getUserTypeFromStore</span>()
  <span class="hljs-comment">// ...</span>
}
</code></pre>
</li>
<li>
<p><strong>使用安全的 i18n 包装器</strong></p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// ✅ 优雅降级</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">getSafeI18n</span>(<span class="hljs-params"/>): <span class="hljs-function">(<span class="hljs-params">key: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">string</span> {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> { t } = <span class="hljs-title function_">useI18n</span>()
    <span class="hljs-keyword">return</span> t
  } <span class="hljs-keyword">catch</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">key: <span class="hljs-built_in">string</span></span>) =&gt;</span> fallbacks[key] || key
  }
}
</code></pre>
</li>
<li>
<p><strong>动态导入避免循环依赖</strong></p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// ✅ 按需加载</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">handleAction</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-keyword">const</span> { <span class="hljs-attr">default</span>: router } = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'~/router'</span>)
  <span class="hljs-keyword">await</span> router.<span class="hljs-title function_">push</span>(<span class="hljs-string">'/profile'</span>)
}
</code></pre>
</li>
<li>
<p><strong>从 Store 获取数据，不依赖 Vue 实例</strong></p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// ✅ 直接访问 store</span>
<span class="hljs-keyword">const</span> userStore = <span class="hljs-title function_">useUserStoreWithOut</span>()
<span class="hljs-keyword">const</span> userType = userStore.<span class="hljs-property">userInfo</span>?.<span class="hljs-property">userType</span>
</code></pre>
</li>
<li>
<p><strong>使用 createApp 动态挂载组件</strong></p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// ✅ 独立的 Vue 应用实例</span>
<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>({
  <span class="hljs-title function_">render</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">h</span>(<span class="hljs-title class_">ResetPassWord</span>, { <span class="hljs-comment">/* props */</span> })
  }
})
app.<span class="hljs-title function_">mount</span>(container)
</code></pre>
</li>
</ol>
<h3 data-id="heading-26">❌ Don'ts（避免做法）</h3>
<ol>
<li>
<p><strong>不要在路由守卫中直接调用 Composition API</strong></p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// ❌ 会报错</span>
router.<span class="hljs-title function_">afterEach</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">const</span> router = <span class="hljs-title function_">useRouter</span>()  <span class="hljs-comment">// 错误！</span>
  <span class="hljs-keyword">const</span> { t } = <span class="hljs-title function_">useI18n</span>()     <span class="hljs-comment">// 错误！</span>
})
</code></pre>
</li>
<li>
<p><strong>不要过度设计</strong></p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// ❌ 3 个规则不需要规则引擎</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">VerificationCenter</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-attr">rules</span>: <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">VerificationRule</span>&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()
  <span class="hljs-comment">// 复杂的规则引擎逻辑</span>
}
</code></pre>
</li>
<li>
<p><strong>不要忽略错误处理</strong></p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// ❌ 没有错误边界</span>
router.<span class="hljs-title function_">afterEach</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-title function_">checkAuth</span>()  <span class="hljs-comment">// 如果出错会导致路由导航失败</span>
})

<span class="hljs-comment">// ✅ 添加错误边界</span>
router.<span class="hljs-title function_">afterEach</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-title function_">checkAuth</span>()
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error)
  }
})
</code></pre>
</li>
<li>
<p><strong>不要忘记清理副作用</strong></p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// ❌ 没有清理 DOM 和事件监听器</span>
<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">Component</span>)
app.<span class="hljs-title function_">mount</span>(container)

<span class="hljs-comment">// ✅ 清理副作用</span>
<span class="hljs-keyword">const</span> unwatch = router.<span class="hljs-title function_">afterEach</span>(<span class="hljs-function">() =&gt;</span> {
  app.<span class="hljs-title function_">unmount</span>()
  container.<span class="hljs-title function_">remove</span>()
  <span class="hljs-title function_">unwatch</span>()
})
</code></pre>
</li>
</ol>
<h3 data-id="heading-27">📊 性能优化建议</h3>
<ol>
<li>
<p><strong>避免不必要的检查</strong></p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// ✅ 提前返回</span>
<span class="hljs-keyword">if</span> (to.<span class="hljs-property">meta</span>?.<span class="hljs-property">layout</span> === <span class="hljs-string">'blank'</span>) <span class="hljs-keyword">return</span>
<span class="hljs-keyword">if</span> (to.<span class="hljs-property">meta</span>?.<span class="hljs-property">category</span> !== <span class="hljs-string">'internal'</span>) <span class="hljs-keyword">return</span>
</code></pre>
</li>
<li>
<p><strong>使用 sessionStorage 缓存标记</strong></p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// ✅ 避免重复检查</span>
<span class="hljs-keyword">const</span> forceReset = sessionStorage.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">'vc_force_reset_pwd'</span>) === <span class="hljs-string">'1'</span>
<span class="hljs-keyword">if</span> (!forceReset) <span class="hljs-keyword">return</span>
</code></pre>
</li>
<li>
<p><strong>动态导入按需加载</strong></p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// ✅ 只在需要时加载</span>
<span class="hljs-keyword">const</span> { <span class="hljs-attr">default</span>: router } = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'~/router'</span>)
</code></pre>
</li>
</ol>
<h3 data-id="heading-28">🧪 可测试性建议</h3>
<ol>
<li>
<p><strong>纯函数设计</strong></p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// ✅ 易于测试</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">needsAuthPrompt</span>(<span class="hljs-params">userType: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">boolean</span> {
  <span class="hljs-keyword">return</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>].<span class="hljs-title function_">includes</span>(userType)
}

<span class="hljs-comment">// 测试</span>
<span class="hljs-title function_">expect</span>(<span class="hljs-title function_">needsAuthPrompt</span>(<span class="hljs-number">1</span>)).<span class="hljs-title function_">toBe</span>(<span class="hljs-literal">true</span>)
<span class="hljs-title function_">expect</span>(<span class="hljs-title function_">needsAuthPrompt</span>(<span class="hljs-number">5</span>)).<span class="hljs-title function_">toBe</span>(<span class="hljs-literal">false</span>)
</code></pre>
</li>
<li>
<p><strong>依赖注入</strong></p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// ✅ 可注入 mock router</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">checkPasswordExpiredInRouterGuard</span>(<span class="hljs-params">
  routerInstance: Router
</span>): <span class="hljs-built_in">void</span> {
  <span class="hljs-comment">// 使用注入的 router 实例</span>
}
</code></pre>
</li>
<li>
<p><strong>职责分离</strong></p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// ✅ 数据获取、逻辑判断、UI 展示分离</span>
<span class="hljs-keyword">const</span> userType = <span class="hljs-title function_">getUserTypeFromStore</span>()      <span class="hljs-comment">// 数据层</span>
<span class="hljs-keyword">const</span> needsAuth = <span class="hljs-title function_">needsAuthPrompt</span>(userType)  <span class="hljs-comment">// 逻辑层</span>
<span class="hljs-keyword">if</span> (needsAuth) <span class="hljs-title function_">showAuthDialog</span>()              <span class="hljs-comment">// UI 层</span>
</code></pre>
</li>
</ol>
<hr/>
<h2 data-id="heading-29">总结</h2>
<h3 data-id="heading-30">核心要点</h3>
<ol>
<li>
<p><strong>理解 Composition API 的上下文限制</strong></p>
<ul>
<li>必须在 Vue 组件的 <code>setup</code> 函数顶层调用</li>
<li>路由守卫运行在 Vue 上下文之外</li>
</ul>
</li>
<li>
<p><strong>为路由守卫创建独立函数</strong></p>
<ul>
<li>不依赖 <code>useRouter</code>、<code>useI18n</code> 等 Composition API</li>
<li>从 Store 或全局对象获取数据</li>
<li>使用安全的 i18n 包装器</li>
</ul>
</li>
<li>
<p><strong>遵循 YAGNI 原则</strong></p>
<ul>
<li>不要过度设计</li>
<li>简单性优于灵活性</li>
<li>满足当前需求即可</li>
</ul>
</li>
<li>
<p><strong>优雅的错误处理</strong></p>
<ul>
<li>优雅降级（fallback）</li>
<li>静默失败（用户取消）</li>
<li>全局错误边界</li>
</ul>
</li>
</ol>
<h3 data-id="heading-31">适用场景</h3>
<ul>
<li>✅ 路由守卫中需要使用 i18n、router 等 Composition API</li>
<li>✅ 需要在非 Vue 组件上下文中执行 Vue 相关逻辑</li>
<li>✅ 需要动态挂载组件（如弹窗、通知）</li>
<li>✅ 需要简化过度设计的架构</li>
</ul>
<h3 data-id="heading-32">参考资源</h3>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fvuejs.org%2Fguide%2Fextras%2Fcomposition-api-faq.html" target="_blank" title="https://vuejs.org/guide/extras/composition-api-faq.html" ref="nofollow noopener noreferrer">Vue 3 Composition API 官方文档</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Frouter.vuejs.org%2Fguide%2Fadvanced%2Fnavigation-guards.html" target="_blank" title="https://router.vuejs.org/guide/advanced/navigation-guards.html" ref="nofollow noopener noreferrer">Vue Router 官方文档</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FYou_aren%2527t_gonna_need_it" target="_blank" title="https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it" ref="nofollow noopener noreferrer">YAGNI 原则</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FSOLID" target="_blank" title="https://en.wikipedia.org/wiki/SOLID" ref="nofollow noopener noreferrer">SOLID 原则</a></li>
</ul>
<hr/>
<h2 data-id="heading-33">附录：完整代码示例</h2>
<h3 data-id="heading-34">项目结构</h3>
<pre><code class="hljs language-bash" lang="bash">src/
├── composables/
│   ├── auth/
│   │   ├── useUserTypeAuth.ts          <span class="hljs-comment"># 用户认证（组件 + 路由守卫）</span>
│   │   └── usePasswordExpired.ts       <span class="hljs-comment"># 密码过期（组件 + 路由守卫）</span>
│   └── ui/
│       └── useConfirm.ts               <span class="hljs-comment"># 确认对话框（安全 i18n）</span>
├── components/
│   └── ResetPassWord/
│       └── index.vue                   <span class="hljs-comment"># 密码重置组件</span>
├── router/
│   └── index.ts                        <span class="hljs-comment"># 路由配置（集成认证检查）</span>
└── store/
    └── core/
        └── user.ts                     <span class="hljs-comment"># 用户状态管理</span>
</code></pre>
<h3 data-id="heading-35">关键文件</h3>
<p>完整代码已在上文的"代码实现"章节中展示，此处不再重复。</p>
<hr/>
<p><strong>感谢阅读！如果这篇文章对你有帮助，欢迎分享和讨论。</strong></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[[Nuxt 4 实战] 躺着也能拿流量：Sitemap、Robots 与结构化数据的全自动 SEO 指南]]></title>    <link>https://juejin.cn/post/7602211941513560118</link>    <guid>https://juejin.cn/post/7602211941513560118</guid>    <pubDate>2026-02-03T07:28:18.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602211941513560118" data-draft-id="7602411521070710803" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="[Nuxt 4 实战] 躺着也能拿流量：Sitemap、Robots 与结构化数据的全自动 SEO 指南"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2026-02-03T07:28:18.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="sonicsunsky"/> <meta itemprop="url" content="https://juejin.cn/user/1750078241119406"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            [Nuxt 4 实战] 躺着也能拿流量：Sitemap、Robots 与结构化数据的全自动 SEO 指南
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1750078241119406/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    sonicsunsky
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T07:28:18.000Z" title="Tue Feb 03 2026 07:28:18 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    8
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">前言</h2>
<p>做独立开发，最怕的是“自我感动”——辛辛苦苦开发上线，结果只有自己访问。</p>
<p>对于 <strong>SonicToolLab</strong> 这种工具站，SEO（搜索引擎优化）是生存的根本。我们需要让 Google 知道我们有哪些工具，并且在搜索结果中展示得“漂亮”。</p>
<p>如果你还在手动写 <code>sitemap.xml</code> 或者手搓 JSON-LD 结构化数据，那就太 Out 了。Nuxt 4 配合官方的 SEO 模块，可以把这些枯燥的工作变成<strong>全自动化</strong>。</p>
<h2 data-id="heading-1">📦 1. 一站式解决方案：Nuxt SEO Kit</h2>
<p>以前我们需要安装 <code>nuxt-simple-sitemap</code>、<code>nuxt-simple-robots</code>、<code>nuxt-schema-org</code> 等一堆插件。现在，官方推出了一个“全家桶”：<strong>@nuxtjs/seo</strong>。</p>
<p>它不仅整合了上述所有功能，还提供了 best-practice 的默认配置。</p>
<h3 data-id="heading-2">安装</h3>
<pre><code class="hljs language-bash" lang="bash">npx nuxi module add seo

</code></pre>
<h3 data-id="heading-3">配置 <code>nuxt.config.ts</code></h3>
<p>你只需要配置站点的基本信息，其他的模块会自动读取：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineNuxtConfig</span>({
  <span class="hljs-attr">modules</span>: [<span class="hljs-string">'@nuxtjs/seo'</span>],
  
  <span class="hljs-attr">site</span>: {
    <span class="hljs-attr">url</span>: <span class="hljs-string">'[https://sonictoollab.dpdns.org](https://sonictoollab.dpdns.org)'</span>, <span class="hljs-comment">// 你的线上域名</span>
    <span class="hljs-attr">name</span>: <span class="hljs-string">'SonicToolLab'</span>,
    <span class="hljs-attr">description</span>: <span class="hljs-string">'开发者首选的免费在线工具箱'</span>,
    <span class="hljs-attr">defaultLocale</span>: <span class="hljs-string">'zh-CN'</span>, <span class="hljs-comment">// 默认语言</span>
  },

  <span class="hljs-comment">// 可选：针对子模块的细粒度配置</span>
  <span class="hljs-attr">sitemap</span>: {
    <span class="hljs-comment">// 比如排除某些测试页面</span>
    <span class="hljs-attr">exclude</span>: [<span class="hljs-string">'/test/**'</span>, <span class="hljs-string">'/admin/**'</span>]
  }
})

</code></pre>
<p>就这一步，你已经拥有了自动生成的 <code>/sitemap.xml</code> 和 <code>/robots.txt</code>。</p>
<h2 data-id="heading-4">🗺️ 2. Sitemap 的自动化与动态路由陷阱</h2>
<p>启动项目后，访问 <code>http://localhost:3000/sitemap.xml</code>，你会发现所有静态页面（pages 目录下的文件）都已经躺在里面了。</p>
<p><strong>但在 Nuxt 中，动态路由（Dynamic Routes）是个坑。</strong>
假如你有 <code>/tools/[name].vue</code>，Sitemap 模块默认可能不知道 <code>[name]</code> 具体有哪些值（json, base64, image-compress...），导致这些关键页面没被收录。</p>
<h3 data-id="heading-5">解决方案：手动喂数据</h3>
<p>我们需要在配置里明确告诉 Sitemap 有哪些动态页面：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// nuxt.config.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineNuxtConfig</span>({
  <span class="hljs-attr">sitemap</span>: {
    <span class="hljs-attr">sources</span>: [
      <span class="hljs-comment">// 假如你的工具列表是存放在 API 或当个文件里的</span>
      <span class="hljs-string">'/api/sitemap-urls'</span> 
    ],
    <span class="hljs-comment">// 或者直接硬编码（适合工具数量不多的情况）</span>
    <span class="hljs-attr">urls</span>: [
      <span class="hljs-string">'/tools/json-formatter'</span>,
      <span class="hljs-string">'/tools/image-to-base64'</span>,
      <span class="hljs-string">'/tools/qrcode-generator'</span>
    ]
  }
})

</code></pre>
<p>这样，Google 爬虫就能顺着 Sitemap 爬取到每一个具体的工具页。</p>
<h2 data-id="heading-6">🤖 3. 结构化数据 (Schema.org) 的魔力</h2>
<p>你有没有见过 Google 搜索结果里，有些网站带有<strong>星级评分</strong>、<strong>软件价格</strong>或者<strong>问答列表</strong>？这就是<strong>富文本搜索结果 (Rich Snippets)</strong>。</p>
<p>对于工具站，我们必须告诉搜索引擎：“我这是一个 <strong>SoftwareApplication</strong>”。</p>
<p>在 Nuxt 中，使用 <code>useSchemaOrg</code> 组合式函数即可轻松实现：</p>
<pre><code class="hljs language-vue" lang="vue">&lt;script setup lang="ts"&gt;
useSchemaOrg([
  defineWebSite({
    name: 'SonicToolLab',
  }),
  defineSoftwareApplication({
    name: 'SonicToolLab',
    applicationCategory: 'DeveloperApplication',
    operatingSystem: 'Web',
    offers: {
      price: '0',
      priceCurrency: 'CNY',
    },
    aggregateRating: {
      ratingValue: '4.9',
      ratingCount: '88',
    },
  })
])
&lt;/script&gt;

</code></pre>
<p>加上这段代码后，你的网站在 Google 眼里就不再是一堆 HTML，而是一个“免费、评分 4.9 的开发者应用”，这能大幅提升点击率（CTR）。</p>
<h2 data-id="heading-7">🖼️ 4. 社交分享卡片 (OG Image)</h2>
<p>当用户把你的链接分享到 Twitter、Discord 或者微信时，如果没有一张漂亮的预览图，点击率会大打折扣。</p>
<p><code>@nuxtjs/seo</code> 内置了 <strong>OG Image</strong> 生成功能。它甚至可以在服务端<strong>动态绘制图片</strong>（类似 Canvas），把当前页面的标题画在图片上。</p>
<pre><code class="hljs language-vue" lang="vue">&lt;script setup&gt;
defineOgImageComponent('NuxtSeo', {
  title: '在线 JSON 格式化工具',
  description: '免费、快速、支持深色模式',
  theme: '#00dc82', // Nuxt 绿
  colorMode: 'dark',
})
&lt;/script&gt;

</code></pre>
<p>当你部署后，每个页面都会自动生成一张独一无二的分享卡片。</p>
<h2 data-id="heading-8">总结</h2>
<p>做 SEO 就像种树，最好的时间是十年前，其次是<strong>现在</strong>。</p>
<p>通过引入 <code>@nuxtjs/seo</code>，我们在 <strong>SonicToolLab</strong> 中实现了：</p>
<ol>
<li><strong>自动化的 Sitemap</strong>（确保收录）</li>
<li><strong>标准的 Robots.txt</strong>（引导爬虫）</li>
<li><strong>语义化的 Schema</strong>（提升展示效果）</li>
<li><strong>动态的 OG Image</strong>（提升社交分享点击）</li>
</ol>
<p>这一套组合拳打下来，基本上涵盖了技术 SEO 的 90%。剩下的，就是在这个架子上填充优质的内容了。</p>
<p>👉 <strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fsonictoollab.dpdns.org" target="_blank" title="https://sonictoollab.dpdns.org" ref="nofollow noopener noreferrer">SonicToolLab 在线体验</a></strong></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[[Nuxt 4 实战] 突破 Cloudflare 1MB 限制：如何从服务端构建中彻底剔除巨型依赖]]></title>    <link>https://juejin.cn/post/7602411521070891027</link>    <guid>https://juejin.cn/post/7602411521070891027</guid>    <pubDate>2026-02-03T07:41:01.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602411521070891027" data-draft-id="7602411521070858259" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="[Nuxt 4 实战] 突破 Cloudflare 1MB 限制：如何从服务端构建中彻底剔除巨型依赖"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2026-02-03T07:41:01.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="sonicsunsky"/> <meta itemprop="url" content="https://juejin.cn/user/1750078241119406"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            [Nuxt 4 实战] 突破 Cloudflare 1MB 限制：如何从服务端构建中彻底剔除巨型依赖
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1750078241119406/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    sonicsunsky
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T07:41:01.000Z" title="Tue Feb 03 2026 07:41:01 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    8
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">前言</h2>
<p>在开发 <strong>SonicToolLab</strong> 的过程中，我遇到了一个让独立开发者非常头疼的问题：<strong>部署失败</strong>。</p>
<p>当我引入了 <code>jspdf</code> (生成 PDF)、<code>xlsx</code> (处理 Excel) 和 <code>@faker-js/faker</code> (生成模拟数据) 后，Cloudflare Pages 部署时直接报错：</p>
<blockquote>
<p><code>Error: Script startup exceeded CPU time limit</code> 或 <code>Worker bundle size exceeded 1MB limit</code></p>
</blockquote>
<p>这是因为 Nuxt 是同构框架。虽然我们心里清楚：“这些库只在浏览器里用，服务器不需要运行”，但在构建时，Nitro 引擎可能会因为某些静态导入（Static Import），把这些几百 KB 的巨型库打包进了 <code>server/index.mjs</code>。</p>
<p>今天分享一个<strong>终极解决方案</strong>：利用 Nitro 的 <code>alias</code> 配置，通过“偷梁换柱”的方式，让这些库在服务端彻底消失。</p>
<h2 data-id="heading-1">🚨 1. 问题复现：为什么服务端包会变大？</h2>
<p>假设你有一个工具页 <code>pages/pdf-tool.vue</code>：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 即使你在 setup 中没调用，静态导入也可能导致打包工具将其分析为服务端依赖</span>
<span class="hljs-keyword">import</span> { jsPDF } <span class="hljs-keyword">from</span> <span class="hljs-string">"jspdf"</span>; 

<span class="hljs-keyword">const</span> <span class="hljs-title function_">generate</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-keyword">const</span> doc = <span class="hljs-keyword">new</span> <span class="hljs-title function_">jsPDF</span>();
  doc.<span class="hljs-title function_">save</span>(<span class="hljs-string">"test.pdf"</span>);
}
</code></pre>
<p>当你运行 <code>pnpm build</code> 后，检查 <code>.output/server/index.mjs</code>，你会惊讶地发现 <code>jspdf</code> 的源码竟然被完整打包进去了！</p>
<p>对于 Cloudflare 这种 Serverless 环境，每一 KB 都是宝贵的。这些无用的代码不仅占空间，还会拖慢 Cold Start（冷启动）速度。</p>
<h2 data-id="heading-2">✂️ 2. 终极一刀：Nitro Alias 替换法</h2>
<p>我们不能简单地依赖 Tree-shaking，最稳妥的方法是告诉 Nitro 打包器： <strong>“当你在服务端遇到这些库时，用一个空文件替换它。”</strong></p>
<h3 data-id="heading-3">第一步：创建一个 Mock 文件</h3>
<p>在 <code>server/utils</code> 下创建一个简单的 <code>mock.ts</code>。它的作用是提供一个空的导出，防止服务端运行时因为“找不到模块”而报错。</p>
<p>TypeScript</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// server/utils/mock.ts</span>
<span class="hljs-comment">// 导出一个 Proxy，这样无论代码尝试访问什么属性都不会报错，只会返回 undefined</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>({}, {
  <span class="hljs-attr">get</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-function">() =&gt;</span> {}, <span class="hljs-comment">// 所有方法都返回空函数</span>
});
</code></pre>
<h3 data-id="heading-4">第二步：配置 nuxt.config.ts</h3>
<p>这是核心操作。利用 <code>nitro.alias</code> 将那些<strong>纯客户端</strong>的巨型库映射到上面的 Mock 文件。</p>
<p>TypeScript</p>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-comment">// nuxt.config.ts</span>
<span class="hljs-function"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title">defineNuxtConfig</span><span class="hljs-params">({
  nitro: {
    <span class="hljs-comment">// 🔥 核心配置：使用别名在服务端将这些库替换为空模块</span>
    <span class="hljs-comment">// 彻底从 Server Worker 中剔除，防止体积超标</span>
    alias: {
      <span class="hljs-string">"@faker-js/faker"</span>: <span class="hljs-string">"./server/utils/mock.ts"</span>,
      <span class="hljs-string">"jspdf"</span>: <span class="hljs-string">"./server/utils/mock.ts"</span>,
      <span class="hljs-string">"pdfjs-dist"</span>: <span class="hljs-string">"./server/utils/mock.ts"</span>,
      <span class="hljs-string">"upng-js"</span>: <span class="hljs-string">"./server/utils/mock.ts"</span>,
      <span class="hljs-string">"jszip"</span>: <span class="hljs-string">"./server/utils/mock.ts"</span>,
      <span class="hljs-comment">// 其他只需要在浏览器运行的大型库都可以在这里加</span>
    }
  }
})</span>
</span></code></pre>
<p><strong>原理说明：</strong></p>
<p>当 Nitro 构建服务端 Bundle 时，一旦看到 <code>import ... from 'jspdf'</code>，它不再去 <code>node_modules</code> 里找几百 KB 的源码，而是直接引用了只有几行代码的 <code>./server/utils/mock.ts</code>。</p>
<p><strong>注意：</strong> 这不会影响客户端（Client Bundle）。浏览器端依然会正常加载完整的库。</p>
<h2 data-id="heading-5">📦 3. 配合动态导入 (Dynamic Import)</h2>
<p>除了配置 Alias，我们在写代码时也应该尽量避免在 <code>&lt;script setup&gt;</code> 顶层直接 import 巨型库。</p>
<p><strong>优化前的写法（容易导致 Hydration 问题）：</strong></p>
<p>TypeScript</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">JSZip</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'jszip'</span> <span class="hljs-comment">// ❌ 可能会影响首屏加载</span>
</code></pre>
<p><strong>优化后的写法：</strong></p>
<p>TypeScript</p>
<pre><code class="hljs language-dart" lang="dart"><span class="hljs-keyword">const</span> handleDownload = <span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-comment">// ✅ 只有当用户点击按钮时，浏览器才去加载 JSZip</span>
  <span class="hljs-keyword">const</span> { <span class="hljs-keyword">default</span>: JSZip } = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'jszip'</span>)
  <span class="hljs-keyword">const</span> zip = <span class="hljs-keyword">new</span> JSZip()
  <span class="hljs-comment">// ...</span>
}
</code></pre>
<p>结合 <code>nitro.alias</code> + <code>await import()</code>，你的工具站将达到体积优化的巅峰。</p>
<h2 data-id="heading-6">📊 4. 效果对比</h2>
<p>在 <strong>SonicToolLab</strong> 应用该策略前后，<code>.output/server/index.mjs</code> 的体积变化惊人：</p>
<ul>
<li><strong>优化前：</strong> 2.4 MB (Cloudflare 无法部署)</li>
<li><strong>优化后：</strong> 480 KB (秒部署，且冷启动极快)</li>
</ul>
<p>特别是 <code>@faker-js/faker</code> 这种包含大量文本数据的库，一旦剔除，减重效果立竿见影。</p>
<h2 data-id="heading-7">⚠️ 5. 避坑指南</h2>
<p>虽然 Alias 很好用，但有一个<strong>绝对前提</strong>：</p>
<p><strong>你的服务端代码（API 接口、SSR 渲染逻辑）绝对不能真正使用这些库。</strong></p>
<p>如果你在 <code>server/api/generate-pdf.ts</code> 里确实需要用到 <code>jspdf</code> 来生成文件，那你<strong>不能</strong>把它 Mock 掉。</p>
<p><strong>本方案仅适用于：</strong></p>
<p>库只在浏览器（Vue 组件）中使用，但因为构建工具的机制被误打包进服务端的场景。</p>
<h2 data-id="heading-8">总结</h2>
<p>Cloudflare Pages 虽然免费且强大，但资源限制是硬伤。对于 Nuxt 开发者来说，学会<strong>管理服务端依赖</strong>是一门必修课。</p>
<p>通过简单的 <code>mock.ts</code> 和 <code>nitro.alias</code> 配置，我们成功给服务端“抽脂”，让 <strong>SonicToolLab</strong> 在边缘节点上跑得飞快。</p>
<p>👉 <strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fsonictoollab.dpdns.org%2F" target="_blank" title="https://sonictoollab.dpdns.org/" ref="nofollow noopener noreferrer">SonicToolLab 在线体验</a></strong></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[[Nuxt 4 实战] 细节决定成败：深色模式动画、骨架屏与 404 页面的艺术]]></title>    <link>https://juejin.cn/post/7602211941513740342</link>    <guid>https://juejin.cn/post/7602211941513740342</guid>    <pubDate>2026-02-03T07:52:23.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602211941513740342" data-draft-id="7602191709389684778" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="[Nuxt 4 实战] 细节决定成败：深色模式动画、骨架屏与 404 页面的艺术"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2026-02-03T07:52:23.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="sonicsunsky"/> <meta itemprop="url" content="https://juejin.cn/user/1750078241119406"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            [Nuxt 4 实战] 细节决定成败：深色模式动画、骨架屏与 404 页面的艺术
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1750078241119406/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    sonicsunsky
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T07:52:23.000Z" title="Tue Feb 03 2026 07:52:23 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    15
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">前言</h2>
<p>在开发 <strong>SonicToolLab</strong> 时，我发现用户对工具站的耐受度其实很低。</p>
<ul>
<li>如果点击转换按钮后界面卡死，用户会以为网页坏了。</li>
<li>如果在晚上打开网页被亮瞎眼，用户会直接关闭。</li>
<li>如果输错网址看到原生丑陋的 404，用户会觉得这个站很“水”。</li>
</ul>
<p>今天这一篇，我们不聊复杂的算法，只聊<strong>体验</strong>。如何利用 <strong>Nuxt UI</strong> 提供的组件，花 20% 的时间提升 80% 的质感。</p>
<h2 data-id="heading-1">🌗 1. 丝滑的深色模式 (Dark Mode)</h2>
<p>Nuxt UI 基于 Tailwind CSS，天生支持深色模式。但要做到“好用”，有几个关键步骤。</p>
<h3 data-id="heading-2">步骤一：配置 Color Mode</h3>
<p>虽然 Nuxt UI 默认集成了 <code>@nuxtjs/color-mode</code>，但我建议在 <code>nuxt.config.ts</code> 中显式配置一下，确保它使用 <code>class</code> 策略（给 <code>html</code> 标签加 <code>dark</code> 类名）。</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// nuxt.config.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineNuxtConfig</span>({
  <span class="hljs-attr">colorMode</span>: {
    <span class="hljs-attr">classSuffix</span>: <span class="hljs-string">''</span>, <span class="hljs-comment">// 配合 Tailwind，去掉了默认的 -mode 后缀</span>
    <span class="hljs-attr">preference</span>: <span class="hljs-string">'system'</span>, <span class="hljs-comment">// 默认跟随系统</span>
    <span class="hljs-attr">fallback</span>: <span class="hljs-string">'light'</span> <span class="hljs-comment">// 兜底策略</span>
  }
})
</code></pre>
<h3 data-id="heading-3">步骤二：封装切换组件</h3>
<p>不要把切换逻辑散落在各处。我封装了一个通用的 <code>&lt;ColorModeButton /&gt;</code>。</p>
<p><strong>难点：Hydration Mismatch（水合不匹配）</strong></p>
<p>服务端渲染时不知道用户的系统是黑还是白，可能会导致图标闪烁（服务端渲染了月亮，客户端变成了太阳）。</p>
<p><strong>解法：</strong> 使用 <code>&lt;ClientOnly&gt;</code> 包裹按钮，或者使用 <code>v-if</code> 等待挂载。</p>
<p>Code snippet</p>
<pre><code class="hljs language-ini" lang="ini">&lt;script setup&gt;
const <span class="hljs-attr">colorMode</span> = useColorMode()

// 计算属性：判断当前是否为暗色
const <span class="hljs-attr">isDark</span> = computed({
  get () {
    return <span class="hljs-attr">colorMode.value</span> === <span class="hljs-string">'dark'</span>
  },
  set () {
    // 切换模式
    <span class="hljs-attr">colorMode.preference</span> = colorMode.value === <span class="hljs-string">'dark'</span> ? <span class="hljs-string">'light'</span> : <span class="hljs-string">'dark'</span>
  }
})
&lt;/script&gt;

&lt;template&gt;
  &lt;ClientOnly&gt;
    &lt;UButton
      :<span class="hljs-attr">icon</span>=<span class="hljs-string">"isDark ? 'i-heroicons-moon-20-solid' : 'i-heroicons-sun-20-solid'"</span>
      <span class="hljs-attr">color</span>=<span class="hljs-string">"gray"</span>
      <span class="hljs-attr">variant</span>=<span class="hljs-string">"ghost"</span>
      <span class="hljs-attr">aria-label</span>=<span class="hljs-string">"切换主题"</span>
      @<span class="hljs-attr">click</span>=<span class="hljs-string">"isDark = !isDark"</span>
    /&gt;
    
    &lt;template <span class="hljs-comment">#fallback&gt;</span>
      &lt;div <span class="hljs-attr">class</span>=<span class="hljs-string">"w-8 h-8"</span> /&gt; 
    &lt;/template&gt;
  &lt;/ClientOnly&gt;
&lt;/template&gt;
</code></pre>
<h2 data-id="heading-4">⏳ 2. 拒绝白屏：Loading 状态与骨架屏</h2>
<p>工具站经常需要请求 API（比如汇率、Whois 信息）。在数据回来之前，千万不要留白。</p>
<h3 data-id="heading-5">全局加载条</h3>
<p>Nuxt 内置了 <code>&lt;NuxtLoadingIndicator /&gt;</code>。在 <code>app.vue</code> 顶部加上它：</p>
<p>Code snippet</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">NuxtLoadingIndicator</span> <span class="hljs-attr">color</span>=<span class="hljs-string">"#34d399"</span> /&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">NuxtLayout</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">NuxtPage</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">NuxtLayout</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
</code></pre>
<p>这样，路由切换时顶部会有进度条，给用户“由于我在加载，请稍等”的反馈。</p>
<h3 data-id="heading-6">局部骨架屏 (Skeleton)</h3>
<p>Nuxt UI 提供了 <code>USkeleton</code> 组件。配合 <code>useFetch</code> 的 <code>status</code> 非常好用。</p>
<p>Code snippet</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">const</span> { data, status } = <span class="hljs-keyword">await</span> <span class="hljs-title function_">useFetch</span>(<span class="hljs-string">'/api/tools/list'</span>, { <span class="hljs-attr">lazy</span>: <span class="hljs-literal">true</span> })
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"grid grid-cols-3 gap-4"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"status === 'pending'"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">UCard</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"i in 6"</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">"i"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"flex items-center gap-4"</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">USkeleton</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"h-12 w-12 rounded-full"</span> /&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"space-y-2"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">USkeleton</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"h-4 w-[200px]"</span> /&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">USkeleton</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"h-4 w-[150px]"</span> /&gt;</span>
          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">UCard</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-else</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">ToolCard</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"tool in data"</span> <span class="hljs-attr">:tool</span>=<span class="hljs-string">"tool"</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
</code></pre>
<p>这种体验比一个旋转的 Spinner 要高级得多，因为它提前勾勒出了页面的布局。</p>
<h2 data-id="heading-7">🚧 3. 自定义 404 页面</h2>
<p>Nuxt 默认的错误页面是黑底白字的调试风，上线后如果用户输错网址看到这个，会非常出戏。</p>
<p>在项目根目录创建 <code>error.vue</code>（注意不是在 <code>pages</code> 里，是根目录）。</p>
<p>Code snippet</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"ts"</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">const</span> props = <span class="hljs-title function_">defineProps</span>({
  <span class="hljs-attr">error</span>: <span class="hljs-title class_">Object</span>
})

<span class="hljs-keyword">const</span> <span class="hljs-title function_">handleError</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-comment">// 清除错误并跳回首页</span>
  <span class="hljs-title function_">clearError</span>({ <span class="hljs-attr">redirect</span>: <span class="hljs-string">'/'</span> })
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"h-screen flex flex-col items-center justify-center text-center p-4"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"text-9xl font-bold text-primary-500"</span>&gt;</span>404<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
    
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"text-xl mt-4 text-gray-500 dark:text-gray-400"</span>&gt;</span>
      糟糕，你仿佛来到了知识的荒原...
    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"text-sm mt-2 mb-8 text-gray-400"</span>&gt;</span>
      错误信息：{{ error?.message }}
    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">UButton</span> 
      <span class="hljs-attr">size</span>=<span class="hljs-string">"xl"</span> 
      <span class="hljs-attr">icon</span>=<span class="hljs-string">"i-heroicons-home"</span>
      @<span class="hljs-attr">click</span>=<span class="hljs-string">"handleError"</span>
    &gt;</span>
      带我回首页
    <span class="hljs-tag">&lt;/<span class="hljs-name">UButton</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
</code></pre>
<p>这样，即使用户迷路了，也能通过一个友好的按钮找回方向，大大降低了跳出率。</p>
<h2 data-id="heading-8">总结</h2>
<p>UI/UX 的打磨是没有尽头的，但在 <strong>SonicToolLab</strong> 的开发中，以上三点是性价比最高的投入：</p>
<ol>
<li><strong>Dark Mode</strong> 照顾了开发者的眼睛（这是你的核心用户群）。</li>
<li><strong>Skeleton</strong> 缓解了等待的焦虑。</li>
<li><strong>Custom 404</strong> 挽留了迷路的用户。</li>
</ol>
<p>把这些细节做好，你的网站就从“一个简单的 Demo”进化成了“一个成熟的产品”。</p>
<p>👉 <strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fsonictoollab.dpdns.org%2F" target="_blank" title="https://sonictoollab.dpdns.org/" ref="nofollow noopener noreferrer">SonicToolLab 在线体验</a></strong></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[配置tauri2项目mac应用支持访问摄像头和麦克风权限]]></title>    <link>https://juejin.cn/post/7602420156396388395</link>    <guid>https://juejin.cn/post/7602420156396388395</guid>    <pubDate>2026-02-03T08:13:48.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602420156396388395" data-draft-id="7602211941513904182" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="配置tauri2项目mac应用支持访问摄像头和麦克风权限"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2026-02-03T08:13:48.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="1024小神"/> <meta itemprop="url" content="https://juejin.cn/user/70007368988926"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            配置tauri2项目mac应用支持访问摄像头和麦克风权限
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/70007368988926/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    1024小神
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T08:13:48.000Z" title="Tue Feb 03 2026 08:13:48 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>大家好，我的开源项目PakePlus可以将网页/Vue/React项目打包为桌面/手机应用并且小于5M只需几分钟，官网地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fpakeplus.com" target="_blank" title="https://pakeplus.com" ref="nofollow noopener noreferrer">pakeplus.com</a></p><p><img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ecbdd6f223d4c8189c2eeba12b04800~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" width="2048" loading="lazy"/></p><p/>
<p>tauri2项目想要在html和js中访问摄像头和麦克风的话，在windows上是默认就可以的，但是在mac上就会报错：</p>
<blockquote>
<p>In the application using the navigator. MediaDevices. GetUserMedia cannot authorize the microphone。<br/>
navigator.mediaDevices is undefined</p>
</blockquote>
<p>解决办法就是给mac添加相应的权限，官方文档：<a data-link-icon="https://csdnimg.cn/release/blog_editor_html/release2.4.5/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=PBP8" data-link-title="https://tauri.app/distribute/macos-application-bundle/#_top" href="https://link.juejin.cn?target=https%3A%2F%2Ftauri.app%2Fdistribute%2Fmacos-application-bundle%2F%23_top" title="https://tauri.app/distribute/macos-application-bundle/#_top" target="_blank" ref="nofollow noopener noreferrer">tauri.app/distribute/…</a></p>
<p>操作也很简单，就是创建一个Info.plist文件：</p>
<p><img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ded8f1f7c5414ec6899933610692efd0~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" width="1816" loading="lazy"/></p>
<p>文件内容：</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"UTF-8"</span>?&gt;</span>
<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">plist</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">"-//Apple//DTD PLIST 1.0//EN"</span> <span class="hljs-string">"http://www.apple.com/DTDs/PropertyList-1.0.dtd"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">plist</span> <span class="hljs-attr">version</span>=<span class="hljs-string">"1.0"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dict</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>NSCameraUsageDescription<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>Request camera access for WebRTC<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>NSMicrophoneUsageDescription<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>Request microphone access for WebRTC<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dict</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">plist</span>&gt;</span></code></pre>
<p>然后在mac config中配置：</p>
<p><img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/200602bd1f1e421bae27310079937b68~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" width="2076" loading="lazy"/></p>
<p>再重新启动应用，就会弹窗提示授权，授权之后就可以访问了</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[关于build-logic的一次小尝试]]></title>    <link>https://juejin.cn/post/7602161364892860416</link>    <guid>https://juejin.cn/post/7602161364892860416</guid>    <pubDate>2026-02-03T05:48:01.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602161364892860416" data-draft-id="7602146335216369704" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="关于build-logic的一次小尝试"/> <meta itemprop="keywords" content="Android"/> <meta itemprop="datePublished" content="2026-02-03T05:48:01.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Z_Quintaz"/> <meta itemprop="url" content="https://juejin.cn/user/4300945219391063"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            关于build-logic的一次小尝试
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4300945219391063/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Z_Quintaz
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T05:48:01.000Z" title="Tue Feb 03 2026 05:48:01 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在Android Gradle Plugin 升级到9.0后，谷歌官方会推荐我们使用build-logic。通过统一构造plugin，在多个module中，可以对他们的build.gradle进行统一管理，减少重复代码，十分方便。</p>
<h3 data-id="heading-0">创建build-logic文件夹</h3>
<ol>
<li>
<p>在根目录下新建文件夹，"<strong>build-logic</strong>"。</p>
</li>
<li>
<p>在build-logic文件夹下，新建gradle文件"settings.gradle.kts"。</p>
</li>
</ol>
<pre><code class="hljs language-kotlin" lang="kotlin">    pluginManagement {
        repositories {
            maven { url = uri(<span class="hljs-string">"https://maven.aliyun.com/repository/public"</span>) }
            maven { url = uri(<span class="hljs-string">"https://maven.aliyun.com/repository/google"</span>) }
            maven { url = uri(<span class="hljs-string">"https://maven.aliyun.com/repository/central"</span>) }
            maven { url = uri(<span class="hljs-string">"https://maven.aliyun.com/repository/gradle-plugin"</span>) }
            google {
                content {
                    includeGroupByRegex(<span class="hljs-string">"com\.android.*"</span>)
                    includeGroupByRegex(<span class="hljs-string">"com\.google.*"</span>)
                    includeGroupByRegex(<span class="hljs-string">"androidx.*"</span>)
                }
            }
            mavenCentral()
            gradlePluginPortal()
        }
    }
    dependencyResolutionManagement {
        repositoriesMode.<span class="hljs-keyword">set</span>(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
        repositories {
            maven { url = uri(<span class="hljs-string">"https://maven.aliyun.com/repository/public"</span>) }
            maven { url = uri(<span class="hljs-string">"https://maven.aliyun.com/repository/google"</span>) }
            maven { url = uri(<span class="hljs-string">"https://maven.aliyun.com/repository/central"</span>) }
            google()
            mavenCentral()
        }
        <span class="hljs-comment">// 注意这个，添加libs的映射关系</span>
        versionCatalogs {
            create(<span class="hljs-string">"libs"</span>) {
                from(files(<span class="hljs-string">"../gradle/libs.versions.toml"</span>))
            }
        }
    }

    rootProject.name = <span class="hljs-string">"build-logic"</span>
    <span class="hljs-comment">// 等会添加</span>
    <span class="hljs-comment">// include(":convention")</span>
</code></pre>
<ol start="3">
<li>在根目录中的"settings.gradle.kts"中，将我们的这个"build-logic"加入gradle中。</li>
</ol>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-code">    pluginManagement {
</span>
<span class="hljs-code">        includeBuild("build-logic")
</span>
<span class="hljs-code">        repositories {
            /// ...
        }
    }
</span></code></pre>
<ol start="4">
<li>编译一下项目，应该可以看到，build-logic被Android Studio识别成了模块，说明是正常了</li>
</ol>
<h3 data-id="heading-1">新建convention模块</h3>
<ol>
<li>
<p>在build-logic文件夹下，新建文件夹"<strong>convention</strong>"。</p>
</li>
<li>
<p>在"convention"文件夹中，新建build.gradle.kts文件</p>
</li>
</ol>
<pre><code class="hljs language-kotlin" lang="kotlin">    <span class="hljs-keyword">import</span> org.jetbrains.kotlin.gradle.dsl.JvmTarget

    plugins {
        `kotlin-dsl`
    }

    group = <span class="hljs-string">"com.zq.myapplication.buildlogic.convention"</span>

    java {
        sourceCompatibility = JavaVersion.VERSION_17
        targetCompatibility = JavaVersion.VERSION_17
    }

    kotlin {
        compilerOptions {
            jvmTarget = JvmTarget.JVM_17
        }
    }

    dependencies {
        <span class="hljs-comment">// TODO 用来添加模块中用到的依赖</span>
    }


    gradlePlugin {
        plugins {
    		<span class="hljs-comment">// TODO 用来注册</span>
        }
    }
</code></pre>
<ol start="3">
<li>在根目录gradle文件夹下的<strong>libs.versions.toml</strong>文件中，添加用到的plugin依赖，注意是library下。</li>
</ol>
<pre><code class="hljs language-ini" lang="ini">    <span class="hljs-section">[libraries]</span>
    <span class="hljs-comment">#build-logic</span>
    <span class="hljs-attr">android-gradlePlugin</span> = { group = <span class="hljs-string">"com.android.tools.build"</span>, name = <span class="hljs-string">"gradle-api"</span>, version.ref = <span class="hljs-string">"androidGradlePlugin"</span> }
    <span class="hljs-attr">android-tools-common</span> = { group = <span class="hljs-string">"com.android.tools"</span>, name = <span class="hljs-string">"common"</span>, version.ref = <span class="hljs-string">"androidTools"</span> }
    <span class="hljs-attr">kotlin-gradlePlugin</span> = { group = <span class="hljs-string">"org.jetbrains.kotlin"</span>, name = <span class="hljs-string">"kotlin-gradle-plugin"</span>, version.ref = <span class="hljs-string">"kotlin"</span> }
    <span class="hljs-attr">compose-gradlePlugin</span> = { module = <span class="hljs-string">"org.jetbrains.kotlin:compose-compiler-gradle-plugin"</span>, version.ref = <span class="hljs-string">"kotlin"</span> }
    <span class="hljs-attr">kotlin-gradlePlugin</span> = { group = <span class="hljs-string">"org.jetbrains.kotlin"</span>, name = <span class="hljs-string">"kotlin-gradle-plugin"</span>, version.ref = <span class="hljs-string">"kotlin"</span> }
    <span class="hljs-attr">ksp-gradlePlugin</span> = { group = <span class="hljs-string">"com.google.devtools.ksp"</span>, name = <span class="hljs-string">"com.google.devtools.ksp.gradle.plugin"</span>, version.ref = <span class="hljs-string">"ksp"</span> }

    <span class="hljs-section">[plugins]</span>
    ...
</code></pre>
<ol start="4">
<li>在"convention"下的build.gradle.kts中，添加依赖</li>
</ol>
<pre><code class="hljs language-kotlin" lang="kotlin">    dependencies {
    	<span class="hljs-comment">// 注意这边只需要compileOnly就行</span>
        compileOnly(libs.android.gradlePlugin)
        compileOnly(libs.android.tools.common)
        compileOnly(libs.compose.gradlePlugin)
        compileOnly(libs.kotlin.gradlePlugin)
        compileOnly(libs.ksp.gradlePlugin)
    }
</code></pre>
<ol start="5">
<li>
<p>在"convention"下新建文件夹src/main/kotlin，给后续添加文件使用</p>
</li>
<li>
<p>在"build-logic"的settings.gradle.kts下，将convention模块添加</p>
</li>
</ol>
<pre><code class="hljs language-scss" lang="scss">    pluginManagement {
        repositories {
            <span class="hljs-comment">// ...</span>
        }
    }
    dependencyResolutionManagement {
        repositoriesMode<span class="hljs-selector-class">.set</span>(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
        repositories {
            <span class="hljs-comment">// ...</span>
        }
        versionCatalogs {
            <span class="hljs-built_in">create</span>("libs") {
                <span class="hljs-built_in">from</span>(files("../gradle/libs.versions.toml"))
            }
        }
    }

    rootProject<span class="hljs-selector-class">.name</span> = "build-logic"
    <span class="hljs-comment">// 添加convention模块</span>
    <span class="hljs-built_in">include</span>(":convention")
</code></pre>
<ol start="7">
<li>再次编译一下项目，convention模块通过。</li>
</ol>
<h3 data-id="heading-2">添加application的plugin类</h3>
<ol>
<li>在convention模块中新建一个类<strong>AndroidApplicationConventionPlugin</strong></li>
</ol>
<pre><code class="hljs language-kotlin" lang="kotlin">    <span class="hljs-keyword">class</span> <span class="hljs-title class_">AndroidApplicationConventionPlugin</span>: <span class="hljs-type">Plugin</span>&lt;<span class="hljs-type">Project</span>&gt; {
        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">apply</span><span class="hljs-params">(target: <span class="hljs-type">Project</span>)</span></span> {
            with(target) {
                <span class="hljs-comment">// 引入，标记为application</span>
                apply(plugin = <span class="hljs-string">"com.android.application"</span>)

                <span class="hljs-comment">// application 的 android { }</span>
                extensions.configure&lt;ApplicationExtension&gt; {
                    defaultConfig.targetSdk = <span class="hljs-number">36</span>
                }
            }
        }
    }
</code></pre>
<ol start="2">
<li>前往libs.versions.toml文件中，在[plugin]下添加一个自定义的id</li>
</ol>
<pre><code class="hljs language-ini" lang="ini">    <span class="hljs-section">[plugins]</span>
    <span class="hljs-attr">android-application</span> = { id = <span class="hljs-string">"com.android.application"</span>, version.ref = <span class="hljs-string">"androidGradlePlugin"</span> }
    /// ...
    <span class="hljs-comment"># build-logic</span>
    <span class="hljs-attr">myapplication-android-application</span> = { id = <span class="hljs-string">"myapplication.android.application"</span> }
</code></pre>
<ol start="3">
<li>我们需要将这个id,跟我们实际的类AndroidApplicationConventionPlugin，进行一个绑定的方法。在convention模块下的build.gradle.kts中，添加映射关系。</li>
</ol>
<pre><code class="hljs language-ini" lang="ini">    gradlePlugin {
        plugins {
            register("androidApplication") {
                <span class="hljs-attr">id</span> = libs.plugins.myapplication.android.application.get().pluginId
                <span class="hljs-attr">implementationClass</span> = <span class="hljs-string">"AndroidApplicationConventionPlugin"</span>
            }
        }
    }
</code></pre>
<ol start="4">
<li>最后编译一下项目</li>
</ol>
<h3 data-id="heading-3">使用自定义plugin</h3>
<p>在app的build.gradle.kts中进行使用， 这样就可以了</p>
<pre><code class="hljs language-scss" lang="scss">plugins {
    <span class="hljs-built_in">alias</span>(libs.plugins.myapplication.android.application)
}
</code></pre>
<h3 data-id="heading-4">Tips</h3>
<ol>
<li>关于对application和library的区分，以及使用</li>
</ol>
<pre><code class="hljs language-javascript" lang="javascript">    <span class="hljs-comment">// application 的 android { }</span>
    extensions.<span class="hljs-property">configure</span>&lt;<span class="hljs-title class_">ApplicationExtension</span>&gt; {

    }

    <span class="hljs-comment">// 当我依赖了application时，会执行下面方法</span>
    pluginManager.<span class="hljs-title function_">withPlugin</span>(<span class="hljs-params"><span class="hljs-string">"com.android.application"</span></span>) {

    }
</code></pre>
<pre><code class="hljs language-javascript" lang="javascript">    <span class="hljs-comment">// library 的 android { }</span>
    extensions.<span class="hljs-property">configure</span>&lt;<span class="hljs-title class_">LibraryExtension</span>&gt; {

    }

    <span class="hljs-comment">// 当我依赖了library时，会执行下面方法</span>
    pluginManager.<span class="hljs-title function_">withPlugin</span>(<span class="hljs-params"><span class="hljs-string">"com.android.library"</span></span>) {

    }
</code></pre>
<ol start="2">
<li>
<p>Android Gradle Plugin 9.0中，默认gradle.properties中会开启buildInKotlin, 从而我们不需要主动依赖"org.jetbrains.kotlin.android"。</p>
</li>
<li>
<p>在自定义plugin中，应用plugin时，不需要加版本号，gradle会自动查找</p>
</li>
</ol>
<pre><code class="hljs language-ini" lang="ini">    apply(<span class="hljs-attr">plugin</span> = <span class="hljs-string">"com.android.application"</span>)
</code></pre>
<p>但是要注意，需要你在根目录的build.gradle.kts中添加，可能才能生效</p>
<pre><code class="hljs language-kotlin" lang="kotlin">    [plugins]
    room = { id = <span class="hljs-string">"androidx.room"</span>, version.ref = <span class="hljs-string">"room"</span> }


    plugins {
        alias(libs.plugins.room) apply <span class="hljs-literal">false</span>
    }


    <span class="hljs-keyword">class</span> <span class="hljs-title class_">AndroidRoomConventionPlugin</span> : <span class="hljs-type">Plugin</span>&lt;<span class="hljs-type">Project</span>&gt; {

        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">apply</span><span class="hljs-params">(target: <span class="hljs-type">Project</span>)</span></span> {
            with(target) {
                apply(plugin = <span class="hljs-string">"androidx.room"</span>)
                apply(plugin = <span class="hljs-string">"com.google.devtools.ksp"</span>)

                <span class="hljs-comment">// 让room生成kotlin</span>
                extensions.configure&lt;KspExtension&gt; {
                    arg(<span class="hljs-string">"room.generateKotlin"</span>, <span class="hljs-string">"true"</span>)
                }

                <span class="hljs-comment">// room存储生成的文件</span>
                extensions.configure&lt;RoomExtension&gt; {
                    schemaDirectory(<span class="hljs-string">"<span class="hljs-variable">$projectDir</span>/schemas"</span>)
                }

                dependencies {
                    <span class="hljs-string">"implementation"</span>(libs.findLibrary(<span class="hljs-string">"room-runtime"</span>).<span class="hljs-keyword">get</span>())
                    <span class="hljs-string">"implementation"</span>(libs.findLibrary(<span class="hljs-string">"room-ktx"</span>).<span class="hljs-keyword">get</span>())
                    <span class="hljs-string">"implementation"</span>(libs.findLibrary(<span class="hljs-string">"room-paging"</span>).<span class="hljs-keyword">get</span>())
                    <span class="hljs-string">"ksp"</span>(libs.findLibrary(<span class="hljs-string">"room-compiler"</span>).<span class="hljs-keyword">get</span>())
                }
            }
        }
    }
</code></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item>  </channel></rss>