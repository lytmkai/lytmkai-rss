<?xml version="1.0" encoding="UTF-8"?><rss version="2.0">  <channel>      <title>掘金文章推荐</title>      <link>https://juejin.cn/recommended?sort=newest</link>      <description>一个帮助开发者成长的社区</description>      <generator>python juejin_recom.py @Pi20</generator>      <item>    <title><![CDATA[为什么说 AI 赋能前端开发，已经不是选择题，而是必然趋势？]]></title>    <link>https://juejin.cn/post/7584292514959654921</link>    <guid>https://juejin.cn/post/7584292514959654921</guid>    <pubDate>2025-12-16T15:04:37.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584292514959654921" data-draft-id="7584262116389290010" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="为什么说 AI 赋能前端开发，已经不是选择题，而是必然趋势？"/> <meta itemprop="keywords" content="前端,架构,AI编程"/> <meta itemprop="datePublished" content="2025-12-16T15:04:37.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="西陵"/> <meta itemprop="url" content="https://juejin.cn/user/4353721774379054"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            为什么说 AI 赋能前端开发，已经不是选择题，而是必然趋势？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4353721774379054/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    西陵
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-16T15:04:37.000Z" title="Tue Dec 16 2025 15:04:37 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-16
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    10
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>首发于公众号 <a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FcqfeTj6GhIIv7Ief5554Ow" target="_blank" title="https://mp.weixin.qq.com/s/cqfeTj6GhIIv7Ief5554Ow" ref="nofollow noopener noreferrer">code进化论</a>，欢迎关注。</p>
<h2 data-id="heading-0">前言</h2>
<p>这几年 AI 在前端开发里的能力几乎是肉眼可见地进化”。从最早只能帮我们做做代码补全、提示几个参数，例如早期的 comate。到后来能够独立生成一个完整的 React/Vue 组件，连逻辑、样式和交互都能自动写好，例如 cursor 和 claude。再到现在，AI 已经能根据一句自然语言去搭建整个前端项目，自动创建页面、路由、接口层，甚至跑通基础业务流程，例如 <a href="https://link.juejin.cn?target=https%3A%2F%2Fv0.dev%2F" target="_blank" title="https://v0.dev/" ref="nofollow noopener noreferrer">v0</a> 和 <a href="https://link.juejin.cn?target=https%3A%2F%2Fbolt.new%2F" target="_blank" title="https://bolt.new/" ref="nofollow noopener noreferrer">bolt.new</a>。AI 的角色正在从“聪明的编辑器”变成“能独立干活的虚拟工程师”，让前端开发的门槛降低、效率提升，也让更多的精力能够投入到真正有价值的产品设计和体验创新上。</p>
<h2 data-id="heading-1">AI赋能下的范式迁移</h2>
<p>在当前 AI 的发展之下，AI 赋能开发当前还处于最初级的阶段，这里引用了<a href="https://link.juejin.cn?target=https%3A%2F%2Fdoc.iamkasong.com%2Fdocs%2F%25E7%25AC%25AC%25E4%25B8%2580%25E8%25AF%25BE%2520%25E9%259D%25A2%25E5%2590%2591%25E6%259C%25AA%25E6%259D%25A5%25E7%259A%2584%25E5%2589%258D%25E7%25AB%25AF%25E5%258F%2591%25E5%25B1%2595%25E8%25B7%25AF%25E5%25BE%2584.html" target="_blank" title="https://doc.iamkasong.com/docs/%E7%AC%AC%E4%B8%80%E8%AF%BE%20%E9%9D%A2%E5%90%91%E6%9C%AA%E6%9D%A5%E7%9A%84%E5%89%8D%E7%AB%AF%E5%8F%91%E5%B1%95%E8%B7%AF%E5%BE%84.html" ref="nofollow noopener noreferrer">卡颂老师画的一张图</a>：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/59fb4816eebc45779e287a5a3dfa4791~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6KW_6Zm1:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766502536&amp;x-signature=F3Vs7o4Jd92RiXUFF%2FWmbPzSawA%3D" alt="image.png" loading="lazy"/></p>
<p>当前阶段正处于开发范式的迁移阶段，这里可以回想一下前端开发发展的历程：</p>
<ul>
<li>手写 JS、HTML 代码，手动处理浏览器之间的差异点。</li>
<li>引入 jQuery 统一 DOM 操作，抹平浏览器的差异性。</li>
<li>引入 React、Vue 等前端框架，以数据驱动为核心，将开发者从命令式的开发转为声明式开发。</li>
<li>….</li>
</ul>
<p>现阶段的 AI 也是如此，开发范式的发展到了一定阶段后就会涌现出新的开发技术来降低门槛。</p>
<h2 data-id="heading-2">前端开发角色的转变</h2>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e9b9f49e3c894191a4f2d7d973a88429~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6KW_6Zm1:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766502536&amp;x-signature=A2WOMH4ev4BPzJ%2FeRvYVB72upks%3D" alt="image.png" loading="lazy"/></p>
<p>在 AI 时代下，前端开发的角色会逐步进行转变，如图所示：</p>
<ul>
<li>
<p><strong>前端工程师</strong></p>
<p>传统意义上的前端工程师掌握 HTML/CSS/JavaScript，能够把设计稿还原成交互界面，熟悉常见框架（如 React/Vue/Angular）和工程化工具（打包、CI、测试）。他们的价值体现在把产品需求转化为稳定、可维护的用户界面，同时需要关注浏览器兼容、性能优化等。</p>
</li>
<li>
<p><strong>使用AI工具的前端</strong></p>
<p>进入 AI 赋能阶段，前端工程师会把 AI 当成放大效率的助手，利用 AI 的代码补全、组件开发、自动化测试生成等能力提高开发效率。结果是同样的工作可以更快交付，工程师把节省下来的时间投入到更高价值的工作上——比如深挖业务逻辑、做复杂的交互设计、或者搭建更稳健的架构。重要变化不是工具本身，而是将工作重心从写代码转向写提示词、review AI 代码、架构决策与业务理解。</p>
</li>
<li>
<p><strong>会开发AI工具的前端</strong></p>
<p>前端工程师开始参与或主导 AI 工具的开发，能把前端场景抽象成可复用的 AI 提效工具。</p>
</li>
<li>
<p><strong>技术全面的专业前端人才</strong></p>
<p>前端工程师不再只负责前端页面的开发，而需要具备更广的技术视野，逐步向“大前端 / 全栈式”方向演用AI进。AI 能帮助工程师把代码在不同技术栈之间快速迁移，但工程师必须具备跨技术领域的理解能力，才能评估、修改和维护 AI 生成的多端代码。因此前端需要掌握后端基础、Node 服务开发、跨端框架、小程序、移动端等多方向知识，使自己从单一前端角色成长为能够处理多端、多栈、多场景的技术型人才。</p>
</li>
</ul>
<h2 data-id="heading-3">AI 如何赋能前端</h2>
<h3 data-id="heading-4">前端开发流程</h3>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0c2f48ab73174294b4ed70b1ac23d6d0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6KW_6Zm1:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766502536&amp;x-signature=2ALGd91%2BA9pqrjLXQbib28ENgEY%3D" alt="image.png" loading="lazy"/></p>
<p>理想情况下，如果我们的提示词足够精确，从需求的理解到最后的代码开发，AI 都能帮我们完成开发，开发者唯一要做的就是对生成的结果进行 review，并优化提示词。</p>
<p>对于小型的项目来说这即将成为现实，说残酷点就是只会切图的前端工程师即将失业，但是对于复杂的大型项目来说这条路还很长很长，那现阶段作为前端开发工程师的我们该如何规划，化被动为主动，将 AI 能力内化？</p>
<h3 data-id="heading-5">AI如何开发提效</h3>
<h4 data-id="heading-6">初级阶段</h4>
<p>初级阶段开发者只需要会简单的使用 AI 能力即可：</p>
<ul>
<li>
<p>代码补全&amp;优化</p>
<p>例如 storybook 示例、单测代码等。</p>
</li>
<li>
<p>使用 AI 完成静态页面、纯 UI 组件等功能开发。</p>
<p>例如使用AI + 截图或者AI + Figma Mcp 完成 UI 开发。</p>
</li>
<li>
<p>….</p>
</li>
</ul>
<h4 data-id="heading-7">中级阶段</h4>
<p>该阶段开发者需要理解 <code>AI 提示词工程</code>，开发者需要通过合理的 rules 来约束 AI 的行为，确保其在执行复杂编码任务时的每一步操作都安全、可控且符合预期。例如当前业界接受度比较高的 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FNeekChaw%2FRIPER-5" target="_blank" title="https://github.com/NeekChaw/RIPER-5" ref="nofollow noopener noreferrer">RIPER-5</a> 规范，这个阶段 AI 可以帮助开发者完成：</p>
<ul>
<li>
<p>通过设置 rules 完成代码的初步 cr。</p>
</li>
<li>
<p>自动重构与技术债治理。</p>
<p>例如重复逻辑抽离、hooks 拆分、package 循环依赖分析&amp;解决。</p>
</li>
<li>
<p>接口对齐与类型推导</p>
</li>
<li>
<p>按照规范完成功能模块的开发&amp;迭代。</p>
</li>
<li>
<p>…</p>
</li>
</ul>
<h4 data-id="heading-8">高级阶段</h4>
<p>在高级阶段，AI 赋能前端开发不再局限于单点效率提升，而是进入能力工程化阶段。开发者一方面需要持续扩展 AI 在工程中的参与深度，另一方面针对 AI 幻觉、上下文限制和行为不确定性等固有缺陷进行系统性治理，并将实践经验沉淀为<code>可复用的工程能力</code>，从而构建稳定、可演进的智能开发体系，并可在团队及社区进行分享。</p>
<p>在 claude code 中已经提出并支持了相关能力，如下所示：</p>
<ul>
<li>Agent Skills</li>
<li>Sub Agent</li>
<li>Plugin</li>
</ul>
<p>详细介绍可查看<a href="https://link.juejin.cn?target=https%3A%2F%2Fcode.claude.com%2Fdocs%2Fzh-CN%2Fsub-agents" target="_blank" title="https://code.claude.com/docs/zh-CN/sub-agents" ref="nofollow noopener noreferrer">官方文档</a>。</p>
<h2 data-id="heading-9">总结</h2>
<p>本篇文章主要介绍了未来 AI 的发展的趋势，以及前端角色的转变，对前端工程师来说 AI 既是一种挑战也是一种机遇，挑战是指未来 AI 将会全面替代初级前端工程师，机遇则是 AI 也能够赋能前端工程师变成一个更全面的人才。最后也介绍了 AI 赋能前端开发提效的三个阶段，从 AI 的基本使用到 AI 能力工程化逐步提升，在后面的系列文章中作者会分享更多 AI 赋能开发的实战技巧和相关理论知识。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[【项目踩坑实录】并发环境下，Glide缓存引起的图片加载异常]]></title>    <link>https://juejin.cn/post/7584320417306492979</link>    <guid>https://juejin.cn/post/7584320417306492979</guid>    <pubDate>2025-12-16T15:36:54.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584320417306492979" data-draft-id="7584279552433242150" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="【项目踩坑实录】并发环境下，Glide缓存引起的图片加载异常"/> <meta itemprop="keywords" content="Android,Debug,Glide"/> <meta itemprop="datePublished" content="2025-12-16T15:36:54.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Lei_official"/> <meta itemprop="url" content="https://juejin.cn/user/2351234021066314"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            【项目踩坑实录】并发环境下，Glide缓存引起的图片加载异常
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2351234021066314/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Lei_official
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-16T15:36:54.000Z" title="Tue Dec 16 2025 15:36:54 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-16
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>在现实主义者身上，并不是奇迹产生信仰，而是信仰产生奇迹。——《卡拉马佐夫兄弟》</p>
</blockquote>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/533f755d7e0a46a0bdf2510cf43fae57~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTGVpX29mZmljaWFs:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766504213&amp;x-signature=p2PFiQEVbnTBMSJn7zRJ6qspX5w%3D" alt="glide_logo.png" loading="lazy"/></p>
<h2 data-id="heading-0">背景简述</h2>
<p>在维护智能手表主题管理功能时，我遇到过一个十分有趣的bug，从测试首次发现问题时感到十分困惑且不解，到自己我不断尝试并成功复现，直至最终找到根本原因与解决方案，历经一周左右时间。虽然是存在已久的历史问题，但仍有记录和总结的意义，同时也警醒自己在设计并发模块时，一定要心存敬意、考虑周全。</p>
<h2 data-id="heading-1">问题现象</h2>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/14ca16b34a864ee2a66ea2fb0b2033bf~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTGVpX29mZmljaWFs:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766504213&amp;x-signature=VnZB9oMnSBbmDU13iJp9AsFfn4g%3D" alt="" loading="lazy"/></p>
<p>问题的表现如上，用户编辑相册表盘后，返回到表盘列表页，预期是可以展示出新设置的相册表盘的预览图，但实际效果却是，图片确实有刷新出来，但又没有完全刷新，只展示了上半部分，下半部分是黑色。</p>
<h2 data-id="heading-2">技术设计方案</h2>
<p>这个模块是我中途接手的，在初期接手时就惊讶其功能复杂之高、逻辑嵌套之深。为了更好地理解问题，有必要介绍一下这个功能的技术方案设计。</p>
<p>暂且称之为“手表主题模块”，用来管理智能手表主题的样式，用户可以自定义智能手表上的字体、颜色、布局、背景图等，当用户完成设置后，生成当前配置下的预览图，并保存在应用数据目录下（<code>Android/data/packageName/files/aaa_111.png</code>），其它页面（例如表盘列表页）监听到预览图变化的事件后，更新 UI，展示出最新的预览图。</p>
<ul>
<li><code>WatchThemePreviewManager</code>：单例类，提供接口更新并保存预览图png，并通知监听者。</li>
<li><code>WatchThemeView</code>：继承自 <code>FrameLayout</code>，是预览图的展示View，在 <code>onAttachedToWindow()/onDetachedFromWindow()</code> 中进行注册/反注册，监听预览图变化。</li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4d08452cee8d4e2f82eb89082ce43f47~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTGVpX29mZmljaWFs:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766504213&amp;x-signature=V%2BWVETUFSlrIwo39qXdVMgLgsI8%3D" alt="用户操作流程图.png" loading="lazy"/></p>
<p>预期效果是，用户在APP中操作完主题样式设置后，其它所有展示这个手表表盘的页面，都会加载新的样式图。绝大多数场景下，的确表现如预期所想。但测试偶尔会发现前文图中的bug，新的预览图只展示了上半部分，其下半部分是纯黑色。查看应用数据目录后，发现生成的图片是完整的，并不存在缺失现象；从日志中也可以看到回调确实发生了，结果让人百思不得其解。</p>
<h2 data-id="heading-3">归结为2个问题</h2>
<ul>
<li>Q1：为什么图片只展示了局部，另一部分是纯黑的？</li>
<li>Q2：为什么回调发生后，没有把正常的图片刷新出来？</li>
</ul>
<h2 data-id="heading-4">最终分析结论</h2>
<p>略去中间繁琐的分析过程（无非就是在关键节点增加日志、打断点逐步调试等），直接将结论奉上。</p>
<ul>
<li>A1：使用 Glide 显示 png 文件时，文件虽然存在，但其内容尚未完全写入。</li>
<li>A2：Glide 加载同名文件，命中磁盘缓存，不会重新读取文件。</li>
</ul>
<h2 data-id="heading-5">Q1：图片加载不完整的原因</h2>
<p>虽然已经在代码里考虑到，当 png 文件保存完成（大约300ms）后，才回调通知监听者。但存在极限场景，即在“表盘编辑页”编辑后，快速返回到上一级的“表盘列表页”，由于“表盘列表页”在<code>onRestart()</code>时刷新界面，会读取到最新的预览图png路径，文件此时已存在，但尚未完成写入，因此 Glide 加载到的是只写入部分内容的 png，从而发生了图中的错误场景。</p>
<h2 data-id="heading-6">A1：解决方案-先写tmp文件再rename</h2>
<p>实践中，对于这种保存数据到文件的场景，一般采用“保存临时文件-&gt;rename”的方案，先把数据写入到临时文件f.tmp中，写入完成后，再将其rename为f，可以避免外部发生“读取部分文件”的场景。</p>
<p>这里还使用了 <code>FileOutputStream.flush()</code> 和 <code>FileOutputStream.fd.sync()</code>，对于 <strong>高频写入&amp;读取</strong> 的场景，这样做可以保障文件被迅速推给内核和落盘持久化。但 <code>sync()</code> 函数有性能损耗，在工程中慎用。</p>
<p>样例代码如下：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">/**
 * 原子性保存图片文件，外部不会读取到一部份文件
 */</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">saveBitmapToFileAtomic</span><span class="hljs-params">(bitmap: <span class="hljs-type">Bitmap</span>, path: <span class="hljs-type">String</span>)</span></span>: <span class="hljs-built_in">Boolean</span> {
    <span class="hljs-keyword">val</span> dst = File(path)
    dst.parentFile?.mkdirs()

    <span class="hljs-keyword">val</span> tmp = File(dst.parentFile, dst.name + <span class="hljs-string">".tmp"</span>)

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">try</span> {
        FileOutputStream(tmp).use { <span class="hljs-keyword">out</span> -&gt;
            <span class="hljs-keyword">if</span> (!bitmap.compress(Bitmap.CompressFormat.PNG, <span class="hljs-number">100</span>, <span class="hljs-keyword">out</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
            <span class="hljs-keyword">out</span>.flush() <span class="hljs-comment">// 把文件推给内核</span>
            <span class="hljs-keyword">out</span>.fd.sync() <span class="hljs-comment">// 把文件强制落盘（更稳，但更慢，勿大批量调用），适用于写完立刻读的场景</span>
        }

        <span class="hljs-comment">// renameTo 在同一分区通常是“原子替换”效果：读者要么看到旧文件，要么看到新完整文件</span>
        <span class="hljs-keyword">if</span> (dst.exists()) dst.delete()
        tmp.renameTo(dst)
    } <span class="hljs-keyword">catch</span> (e: Exception) {
        tmp.delete()
        <span class="hljs-literal">false</span>
    }
}
</code></pre>
<h2 data-id="heading-7">Q2：回调后没有触发重新加载图片的原因</h2>
<p>对于同一个 ImageView，使用 Glide 加载同名文件，如果不增加文件签名校验，会导致直接复用前一次产生的缓存。这也就解释了，为什么当真正完成 png 文件保存后，回调触发时，预览图并没有刷新为正常版本。</p>
<h2 data-id="heading-8">A2：解决方案-增加signature</h2>
<p>解决方法是，在调用 Glide 加载图片时，使用 <code>signature()</code> 函数，用于在原有的缓存Key计算方法上增加唯一性校验，其内部使用参数的 <code>equals()</code> 和 <code>hashCode()</code> 实现。接口文档如下：</p>
<pre><code class="hljs language-plaintext" lang="plaintext">public RequestOptions signature(@NonNull Key signature)

Sets some additional data to be mixed in to the memory and disk cache keys allowing the caller more control over when cached data is invalidated.

Note - The signature does not replace the cache key, it is purely additive.

Parameters:
signature - A unique non-null Key representing the current state of the model that will be mixed in to the cache key.

Returns:
This request builder.

See Also:
ObjectKey
</code></pre>
<p>因此，在使用Glide为此 ImageView 加载图片时，对于文件名不变但内容可能发生变化的场景，建议进一步增加签名校验，常见的 signature 参数有 <code>file.lastModified()</code>、文件字节数、md5等。</p>
<p>这里我使用 <code>文件长度_更新时间</code>，作为唯一key，可以解决文件内容更新的问题。</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">loadPngIntoImageView</span><span class="hljs-params">(imageView: <span class="hljs-type">ImageView</span>, pngFile: <span class="hljs-type">File</span>)</span></span> {
    glide.with(context)
        .load(pngFile)
        .signature(ObjectKey(<span class="hljs-string">"<span class="hljs-subst">${file.length()}</span>_<span class="hljs-subst">${file.lastModified()}</span>"</span>)) <span class="hljs-comment">// 文件长度_更新时间戳，解决文件更新问题</span>
        <span class="hljs-comment">// 略</span>
        .into(imageView)
}
</code></pre>
<h2 data-id="heading-9">写在最后的反思</h2>
<ol>
<li>这种“先写tmp文件，然后重命名”的模式，适用于大多数写文件的场景。笔者之前开发apk下载工具时，也处理过类似问题，没有下载完成的apk文件，也会被资源管理器识别成安装包，但解析必定失败。</li>
<li>缓存虽好，使用要谨慎。使用Glide加载图片文件，在启用缓存的情况下，如果文件名不变但文件内容发生变化，是不会读取更新后的内容的。</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[springboot 项目 从jdk 8 升级到jdk21 会面临哪些问题]]></title>    <link>https://juejin.cn/post/7584307643000078379</link>    <guid>https://juejin.cn/post/7584307643000078379</guid>    <pubDate>2025-12-16T13:31:59.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584307643000078379" data-draft-id="7584273076646166534" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="springboot 项目 从jdk 8 升级到jdk21 会面临哪些问题"/> <meta itemprop="keywords" content="后端,Java"/> <meta itemprop="datePublished" content="2025-12-16T13:31:59.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="提前退休的java猿"/> <meta itemprop="url" content="https://juejin.cn/user/465848660928872"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            springboot 项目 从jdk 8 升级到jdk21 会面临哪些问题
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/465848660928872/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    提前退休的java猿
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-16T13:31:59.000Z" title="Tue Dec 16 2025 13:31:59 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-16
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">前言</h2>
<p>兄弟们最近上班没时间写博客啊，今天又来水一篇！</p>
<p>Spring Boot 项目从 JDK 8 升级到 JDK 21（长期支持版 LTS），会面临哪些问题。 主要就是<strong>API变更、框架适配、第三方依赖、构建工具配置</strong> 问题。</p>
<blockquote>
<p>推荐阅读: <a href="https://juejin.cn/user/2634854380340008/posts" target="_blank" title="https://juejin.cn/user/2634854380340008/posts">JDK从8升级到21的问题集（京东云）</a></p>
</blockquote>
<h2 data-id="heading-1">springboot项目从1.8到21面临的问题</h2>
<h3 data-id="heading-2">一、JDK API 变更导致的问题</h3>
<p>JDK 8 到 21 有大量 API 废弃、移除或行为变更，核心影响点：</p>
<h4 data-id="heading-3">1. 已移除的 API</h4>
<ul>
<li><code>sun.misc.BASE64Encoder/Decoder</code>：JDK 8 中已标记废弃，JDK 16 + 移除，需替换为<code>java.util.Base64</code>；</li>
<li><code>Thread.stop()</code>、<code>Thread.suspend()</code>：JDK 11 + 严格限制，调用会抛 UnsupportedOperationException；</li>
<li><code>com.sun.image.codec.jpeg.JPEGCodec</code>：JDK 9 + 移除，需替换为<code>ImageIO</code>；</li>
<li><code>java.security.acl</code>包：JDK 17 + 标记为废弃，JDK 21 中部分类移除，需改用<code>java.security.Policy</code>。</li>
</ul>
<h4 data-id="heading-4">2. 模块化限制（JPMS）</h4>
<p>JDK 9 + 引入模块系统，默认不允许访问<code>sun.*</code>、<code>com.sun.*</code>等内部 API：</p>
<ul>
<li>
<p>问题表现：运行时抛<code>IllegalAccessError</code>或<code>ModuleNotFoundException</code>；</p>
</li>
<li>
<p>解决方案：</p>
<ul>
<li>替换内部 API 为标准 API（如<code>sun.misc.Unsafe</code>替换为<code>VarHandle</code>）；</li>
<li>若必须使用，需在启动参数中添加<code>--add-exports</code>（如<code>--add-exports java.base/sun.misc=ALL-UNNAMED</code>）。</li>
</ul>
</li>
</ul>
<h4 data-id="heading-5">3. 日期时间 API（可选）</h4>
<p>JDK 8 的<code>Date/Calendar</code>未移除，但 JDK 1.8 引入的<code>java.time</code>（JSR 310）在 21 中更完善，若项目仍用旧 API，需注意：</p>
<ul>
<li><code>SimpleDateFormat</code>的线程安全问题未解决，但 JDK 21 无变更；</li>
<li>推荐逐步替换为<code>LocalDateTime</code>、<code>ZonedDateTime</code>等。</li>
</ul>
<h4 data-id="heading-6">4. 字符串与集合 API 变更</h4>
<ul>
<li><code>String.trim()</code>：JDK 11 + 行为不变，但<code>String.strip()</code>（去除 Unicode 空白）成为推荐替代；</li>
<li><code>Collections.singletonMap()</code>：JDK 9 + 新增<code>Map.of()</code>、<code>List.of()</code>等不可变集合工厂方法，旧代码兼容，但需注意不可变集合的特性（不支持修改）。</li>
</ul>
<h3 data-id="heading-7">二、Maven版本兼容</h3>
<p>JDK 21 对构建工具版本有最低要求，旧版本构建工具无法识别 JDK 21 的编译参数：</p>
<p><strong>Maven</strong>：需升级到 3.8.0+（推荐 3.8.5+），且<code>maven-compiler-plugin</code>需升级到 3.10.0+（否则无法编译 JDK 21 代码）。</p>
<pre><code class="hljs language-pom.xml" lang="pom.xml">&lt;plugin&gt;
    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; 
    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; 
    &lt;version&gt;3.13.0&lt;/version&gt; 
    &lt;configuration&gt; 
        &lt;release&gt;21&lt;/release&gt;&lt;!-- 统一使用release参数 --&gt; 
    &lt;/configuration&gt; 
&lt;/plugin&gt;

</code></pre>
<h3 data-id="heading-8">三、Spring Boot 框架本身和中间件版本</h3>
<h4 data-id="heading-9">1. Spring Boot 版本必须升级</h4>
<p>JDK 21 仅支持<strong>Spring Boot 3.1+</strong> （官方明确：Spring Boot 3.0 支持 JDK 17，3.1 开始支持 JDK 21），若项目当前是 Spring Boot 2.x（仅支持 JDK 8-17），需先升级到 Spring Boot 3.x，这会带来连锁变更：</p>
<ul>
<li>
<p><strong>Spring Boot 3.x 核心变更</strong>：</p>
<ul>
<li>基于 Spring Framework 6.x，要求 Java 17+（JDK 21 兼容）；</li>
<li>移除对<code>javax.*</code>包的支持，全面迁移到<code>jakarta.*</code>（如<code>jakarta.servlet</code>替代<code>javax.servlet</code>，<code>jakarta.persistence</code>替代<code>javax.persistence</code>）；</li>
<li>自动配置类、starter 依赖有调整（如<code>spring-boot-starter-web</code>底层依赖 Tomcat 10+，而 Tomcat 10 + 也基于 Jakarta EE 9）。</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li><strong>内嵌容器</strong>：Tomcat 9（JDK 8）→ Tomcat 10+（JDK 17+），Tomcat 10 + 的 Servlet API 从<code>javax.servlet</code>迁移到<code>jakarta.servlet</code>，若项目中有自定义 Servlet/Filter/Listener，需修改包名；</li>
<li><strong>日志框架</strong>：Spring Boot 3.x 默认使用 Logback 1.4+，Logback 1.4 + 要求 JDK 11+，需确认日志配置文件（如<code>logback.xml</code>）是否适配；</li>
<li><strong>缓存、事务等注解</strong>：<code>@Transactional</code>、<code>@Cacheable</code>等注解底层依赖的 API 无大变更，但需确认 Spring Framework 6.x 的行为变更（如事务传播机制、缓存管理器适配）。</li>
</ul>
</blockquote>
<h4 data-id="heading-10">2、第三方依赖兼容问题</h4>
<p>这是升级中最常见的 “坑”，大量第三方库在 JDK 21 下无法运行：</p>
<h5 data-id="heading-11">1. 数据库驱动</h5>
<ul>
<li><strong>MySQL 驱动</strong>：<code>mysql-connector-java</code> 8.0.28 + 才支持 JDK 17+，需升级到 8.0.30+（适配 JDK 21）；</li>
<li><strong>Oracle 驱动</strong>：ojdbc8 仅支持 JDK 8-11，需升级到 ojdbc11（支持 JDK 11-21）；</li>
<li><strong>PostgreSQL 驱动</strong>：42.2.x 仅支持 JDK 8，需升级到 42.5+（支持 JDK 17+）。</li>
</ul>
<h5 data-id="heading-12">2. 中间件客户端</h5>
<ul>
<li><strong>Redis</strong>：<code>jedis</code> 3.7.x 仅支持 JDK 8，需升级到 4.0+（支持 JDK 11+）；</li>
<li><strong>Kafka</strong>：<code>kafka-clients</code> 2.8.x 支持 JDK 8，3.0 + 支持 JDK 11+，需升级到 3.4+（适配 JDK 21）；</li>
<li><strong>Elasticsearch</strong>：7.17.x 支持 JDK 8-17，8.x 支持 JDK 17+，需升级客户端到 8.x（适配 JDK 21）。</li>
</ul>
<h5 data-id="heading-13">3. 其他常用库</h5>
<ul>
<li><strong>MyBatis</strong>：3.5.9 + 支持 JDK 17+，需升级（旧版本 3.5.6 以下在 JDK 21 中会抛类加载异常）；</li>
<li><strong>FastJSON</strong>：1.2.83 以下存在 JDK 17 + 兼容问题，需升级到 2.0+（FastJSON2）；</li>
<li><strong>Apache Commons</strong>：<code>commons-lang3</code>需升级到 3.12.0+，<code>commons-collections4</code>需升级到 4.4+；</li>
<li><strong>Lombok</strong>：1.18.20 以下不支持 JDK 16+，需升级到 1.18.30+（适配 JDK 21），且需在 Maven 中配置<code>lombok.version</code>为最新版。</li>
</ul>
<h3 data-id="heading-14">四、运行时与启动参数问题</h3>
<h4 data-id="heading-15">1. JVM 参数变更</h4>
<ul>
<li>JDK 8 的<code>-XX:+UseConcMarkSweepGC</code>（CMS 垃圾收集器）在 JDK 14 中废弃，JDK 21 中移除，需替换为<code>-XX:+UseG1GC</code>（默认）或<code>-XX:+UseZGC</code>（JDK 15 + 正式支持，低延迟）；</li>
<li><code>-XX:+UseParallelGC</code>仍可用，但推荐适配新 GC；</li>
<li>JDK 11 + 移除<code>-XX:+UseCGroupMemoryLimitForHeap</code>，需改用<code>-XX:+UseContainerSupport</code>（默认开启）。</li>
</ul>
<h4 data-id="heading-16">2. 模块化启动参数</h4>
<p>若项目未适配模块化，需添加启动参数避免模块冲突：</p>
<pre><code class="hljs language-css" lang="css">java <span class="hljs-attr">--add-modules</span> <span class="hljs-attribute">ALL</span>-MODULE-PATH \
     <span class="hljs-attr">--add-exports</span> java<span class="hljs-selector-class">.base</span>/sun<span class="hljs-selector-class">.misc</span>=<span class="hljs-attribute">ALL</span>-UNNAMED \
     -jar your-app<span class="hljs-selector-class">.jar</span>
</code></pre>
<h2 data-id="heading-17">总结</h2>
<p>主要的风险点：spring boot 需要升级到<strong>Spring Boot 3.1+</strong> ，大版的升级就涉及到很多中间件需要跟着升级，其次就是一些API可能被移除了，这块编译就阶段就能解决。还有就是我们maven版本和编译插件需要升级。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[出海别再 1:1 抄站了:《毛选》给我的 6 条底层思考]]></title>    <link>https://juejin.cn/post/7584286241488273448</link>    <guid>https://juejin.cn/post/7584286241488273448</guid>    <pubDate>2025-12-16T14:03:41.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584286241488273448" data-draft-id="7584286241488240680" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="出海别再 1:1 抄站了:《毛选》给我的 6 条底层思考"/> <meta itemprop="keywords" content="产品,创业,AI编程"/> <meta itemprop="datePublished" content="2025-12-16T14:03:41.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="孟健AI编程"/> <meta itemprop="url" content="https://juejin.cn/user/4212984287073895"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            出海别再 1:1 抄站了:《毛选》给我的 6 条底层思考
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4212984287073895/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    孟健AI编程
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-16T14:03:41.000Z" title="Tue Dec 16 2025 14:03:41 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-16
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读14分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>大家好，我是孟健。</p>
<p>好久不见。前段时间我被甲流 <strong>H3N2</strong> 放倒了，恢复了两周才缓过来，体感不亚于新冠。冬季流感高发，大家注意防护，别硬扛。</p>
<p>躺着休息的这段时间，我一直在想一个问题：</p>
<p><strong>创业到底有没有一套可复用的底层方法论？有没有一种“更底层的思维”，能在不确定性里给我们一个稳定的指南针？</strong></p>
<p>思来想去，我发现答案很朴素：去读《毛选》。</p>
<p>它告诉你<strong>如何认识世界、如何分析问题、如何组织行动</strong>。</p>
<p>把它抽象成方法论，再放回到商业与出海的语境里，会非常好用。</p>
<p>这篇文章我想把自己的实战体会，和《毛选》里几条核心思维做一个对应，供你参考：</p>
<ul>
<li>
<p><strong>实事求是</strong>：用调查替代臆想，让决策对齐现实</p>
</li>
<li>
<p><strong>阶级分析</strong>：看清利益结构，决定团结谁、合作谁、对抗谁</p>
</li>
<li>
<p><strong>主要矛盾</strong>：抓住“牵一发而动全身”的关键问题，避免眉毛胡子一把抓</p>
</li>
<li>
<p><strong>对立统一</strong>：辩证看优劣，把不利条件转化为有利条件</p>
</li>
<li>
<p><strong>持久战</strong>：以时间换空间，在正确战场长期积累优势</p>
</li>
<li>
<p><strong>从群众中来，到群众中去</strong>：用 MVP + 反馈闭环，把认知落到实践里</p>
</li>
</ul>
<h3 data-id="heading-0">01｜实事求是：创业最稀缺的不是聪明，是“事实”</h3>
<p>毛选的思想框架，建立在四个字的基石上面——实事求是。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4cd319a2c81a4ab3b9ce3682e298e54e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a2f5YGlQUnnvJbnqIs=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766498621&amp;x-signature=BEKnxCrPgstZ7vQrzyPT2RcwFdc%3D" alt="" loading="lazy"/></p>
<p>“实事”就是客观存在着的一切事物，“是”就是客观事物的内部联系，也就是规律性，“求”就是去研究。</p>
<p>实事求是，本质上就是要求我们的思想必须和客观现实精准对应起来。</p>
<p>这听起来理所当然，但是实际并不容易做到。</p>
<p>之前我分享过快思考慢思考，人类的大脑偏向于耗能低的快思考来做决策，也就是说依赖直觉、经验、情绪等等来做判断。</p>
<p>我们经常看到某个人成功了，或者商业模式成功了，就急于去复制它的表象。</p>
<p>在做出海的时候，这种例子太多了，很多人会去 1:1 复制别人的站点，像素级对齐。</p>
<p>但是，我们忽略了它能够成功的“实事”是什么，它的市场环境、用户基础、内部环节之间的“是”。</p>
<p>真正的实事求是，第一步是放下预设的立场和答案，这是一种“空杯心态”，承认自己的无知。</p>
<p>我们需要询问的是“事实究竟是什么”，而不是“我认为/希望事实是什么”。</p>
<p>我们出海做产品的第一步就是去挖掘需求，很容易没有“空杯心态”。</p>
<p>比如，在看到一个“background remove”这个关键词，想当然的认为这就是一个简单的需求，不就是去除背景吗？</p>
<p>你去深入看一下，就知道这是 Photoshop 的核心功能，它围绕这个事情做了多么大量的工作，市场上有多少竞品。</p>
<p>我们团队有的时候做内页的需求，想当然的就是根据关键词让 AI 去生成页面，这是肯定不行的。</p>
<p>第一，AI 的知识库是老旧的，你给他一个关键词，他未必能够深入理解背后的需求，基本上出来的都是废话幻觉。</p>
<p>第二，google 每天都在更新信息，一个词背后可能是一个讨论、一个事件、一个工具等等，你在没有调查之前，根本不知道这个词是什么东西。</p>
<p>没有调查，就没有发言权。我们出海去做产品，肯定要研究市场，研究竞品。斩断一切的臆想和揣测，而且不能太表面的调研。</p>
<p>调研是有方式方法的，查资料要去查一手资料，而不是 AI 总结的幻觉资料。很多人现在都借助 AI 分析需求，这是不好的。</p>
<p>在我们的出海去分析需求的时候，要去 Reddit、Twitter、Facebook、Youtube 等等多种渠道，理解这个需求背后的第一手资料背景，才能深刻明白真正的用户需求。</p>
<p>基于实事求是的思想，去理解需求，我们的调研是深刻的，而不是表面的，是真实的，而不是臆测的，这就是洞察，久而久之，我们就有了洞见。</p>
<p>可以说，掌握了实事求是，就能做到，无论外界环境多么复杂多变，都能找到通往正确方向的道路。</p>
<h3 data-id="heading-1">02｜阶级分析：看清利益结构，才能做出正确站位</h3>
<p>毛选的第二个思想是阶级分析，也就是分清谁是我们的敌人，谁是我们的朋友。这一点非常重要，天下熙熙，皆为利来，在商业世界中，所有的人或事都绑定在利益上面。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b6fd9c8f437241fca61b07b205fc91ce~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a2f5YGlQUnnvJbnqIs=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766498621&amp;x-signature=quAh5ddJBu2f%2FqWPX%2BieuxzRAps%3D" alt="" loading="lazy"/></p>
<p>每个人的核心诉求和利益都不一样，我们在推动事情和做决策之前，先要划分利益群体，比如对于平台型产品来说，平台方、大 V 创作者、中小创作者、普通用户、广告商，他们就是不同利益阶级的群体。</p>
<p>在我们那个爆发的站点产品上线后，其实有一系列竞争者出现，也有一系列希望合作的邮件出现。这个时候，就需要站在利益的角度，思考如何去做决策，总体的指导思想就是团结朋友，打击敌人。</p>
<p>我之前完全不熟悉海外 Affliate 的这套玩法，在产品上线后，倒闭自己完全将 Affliate 的方式研究透彻，现在我来自于 Affliate 的收入已经超过了千刀，而且已经正式迁移至 Affliate 平台当中，建立了长期的合作关系。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6a47172e362c441b8604d8b5c9db6054~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a2f5YGlQUnnvJbnqIs=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766498621&amp;x-signature=eRw6B2TkbPxEl4pjeL5FIxPI4fY%3D" alt="" loading="lazy"/></p>
<p>在我 SEO 排名下降的那段时间，我的收益不降反增，因为排名上升的是我的盟友，通过 Affliate 过来的用户价值远远大于所谓 SEO 排名的流量，这就打了一场很好的防御战。</p>
<p>在现在，我的 SEO 又重回了前三的排名位置，这个战略与阶级分析的思维方法是不谋而合的。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bcb453c3e5994960a58515ed282b998c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a2f5YGlQUnnvJbnqIs=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766498621&amp;x-signature=d%2Fq6LDYZq2vsA7deN8TNQccJH48%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-2">03｜抓主要矛盾：0-1 阶段，先解决“活下去”</h3>
<p>毛选的第三个思想，是抓住主要矛盾。做出海应用，我们面临的场景是复杂多变的，各种各样的细节和矛盾错综复杂，到底应该从何处着手，如果缺乏一个清晰的优先级，就会陷入眉毛胡子一把抓的困境。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7f97503f172849179e5b8ba9c59a18db~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a2f5YGlQUnnvJbnqIs=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766498621&amp;x-signature=Pp1fi2REtpNLMnNFuNBM86T4yyg%3D" alt="" loading="lazy"/></p>
<p>那么，如何判断什么是主要矛盾呢？标准只有一个：看哪个矛盾的存在和发展，规定或影响了其他矛盾的存在和发展。主要矛盾往往就是牵一发而动全身。</p>
<p>在抗日战争时期，有中华民族和帝国主义的民族矛盾，有国内的阶级矛盾，有国民党内部的派系矛盾等等，哪个是主要矛盾？毫无疑问，是民族矛盾，如果这个问题不解决，其他矛盾无从谈起。这就是战略思维。</p>
<p>对于我们初步尝试 0-1 创业的出海业务来说，面临无数问题，有人说 Reddit 非常重要，有人说必须要做 Twitter，有人说应该去美国开个公司，有人说需要办个港卡...</p>
<p>这个时候，就要想清楚什么是主要矛盾，0-1 阶段是生存阶段，所有其他人的建议和经验都是外在表象，0-1 要考虑的首要问题是生存问题，是 PMF 的问题，是能不能活下去的问题。</p>
<p>所以想通了这一点，我们就可以把目标定为 3 个月赚到千刀，那么以上提到的所有事情都是锦上添花，并不是关键因素。那我们需要从结果反推，如何达成目标？所有能想到的关键因素就是主要矛盾。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a8f50f5a61ce4baa8245fbfb01b250d0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a2f5YGlQUnnvJbnqIs=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766498621&amp;x-signature=W%2B%2B3%2F7cpYLXEnvqYby%2Bn0O1nBvU%3D" alt="" loading="lazy"/></p>
<p>团队经过 AARRR 模型的反复推演，就可以得出在 0-1 阶段最重要的动作，实际上可以归纳为两个：市场+效率。只要我们选对市场，把效率最大化，利用 AI 编程的杠杆上 100 个站，理论上最有可能达到目标。</p>
<p>这样一拆解，就十分清晰了，主要动作有两个，一个是提升市场洞察力，一个是提升 AI 编程效率，以量变产生质变是核心的战略。当然肯定也不是盲目上站，必然是要经过不断复盘才能够成长，那么细致的 SOP 也就出来了，只要不断执行：找需求-做需求-运营外链-复盘，这个闭环反复做，就可以达成目标。</p>
<p>所以说，抓住主要矛盾是一个很好的方法论，这需要我们有一定的领导意识和战略意识，才能拨开迷雾，看清事情的本质，这和第一性原理有异曲同工之处。</p>
<h3 data-id="heading-3">04｜对立统一：把劣势当变量，而不是定论</h3>
<p>毛选的第四个思想，是矛盾的对立统一法则。其实我们中华传统文化早就已经产生智慧，中庸之道，太极，都是在讲我们不能静止、孤立、片面地看待问题，任何矛盾的双方，相互排斥、相互斗争，又相互依存，相互联结。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/31102bc4b83c4b09955d35931785e049~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a2f5YGlQUnnvJbnqIs=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766498621&amp;x-signature=AR5zILQq%2FO6yLnbRIbR0hJQX4lk%3D" alt="" loading="lazy"/></p>
<p>所谓阴阳既是对立，又是统一，没有绝对的光芒，也没有绝对的黑暗。在商业市场上，买方希望加个越低越好，卖方希望价格越高越好，看似对立，又必须相互依存，才能共生。</p>
<p>这是一种哲学思想，又是我们看待问题的高度，解决矛盾的目的不是为了消灭某一方，而是要双方在一个更高的水平上达成新的平衡。</p>
<p>从出海创业的这个角度来说，我们的优势劣势本身就是一个对立统一体，在市场上，我们跟大公司竞争，在很多方面都处于劣势，但相对来说，劣势也是优势，所谓“船小好调头”，决策流程、执行力、市场反应灵活，这就是劣势中的有利条件。</p>
<p>其实，我们创业的失败和成功也是一个对立统一的关系，你会发现很多互联网创业成功的大佬，都是连续创业者，屡败屡战，失败并不是一个可怕的事情，关键在于我们能否在创业失败中进行复盘，吸取教训，东山再起。</p>
<h3 data-id="heading-4">05｜《论持久战》：以时间换空间，在正确战场长期积累</h3>
<p>毛选的第五个思想是《论持久战》，这是一部伟大的著作，它揭示了以弱胜强的底层逻辑，为所有劣势地位的奋斗者提供了一部战略宝典。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d1326779d6e84c5fb22496c3a510b4b2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a2f5YGlQUnnvJbnqIs=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766498621&amp;x-signature=5Cwww%2BPTpxWILJmDklAmV684KB0%3D" alt="" loading="lazy"/></p>
<p>它的核心思想是，反对速胜论和亡国论的悲观，主张在客观认识敌我优劣的基础上，通过发挥主观能动性，打一场有计划、有步骤，以时间换空间的持久战。</p>
<p>这个结论需要清醒地认识，速胜是不可能的，因为敌强我弱。亡国也是不可能的，因为敌小我大，敌退步我进步，敌寡助我多助，这奠定了最坚实的认知基础。</p>
<p>这个思维模型告诉我们，当面对一个强大的对手时，不要被其表面的强大所吓到，也不要被自己的弱小所迷惑。必须非常深入的分析，对方的强大背后，有哪些固有的、难以克服的弱点？自身的弱小之中，蕴含着哪些可以被利用、决定未来的优势？</p>
<p>对于出海创业来说，持久战的思想尤为重要。我们个体创业，天然在某些方面存在劣势，如果你去在主战场与巨头证明硬刚，无异于以卵击石。</p>
<p>我们目前看出海的细分市场，实际上正是“巨头看不上”的边缘市场，但是这个市场的蛋糕足够大，我们能够通过灵活的优势，快速抢占这个市场。</p>
<p>所谓“新词”的逻辑，就是以时间和效率优势，快速抢占新的市场，抢占谷歌每天 15%的新检索算力，从而构建了它的商业模式。</p>
<p>所谓“长尾词”的逻辑，就是农村包围城市战略，以小博大，通过细分垂直需求关键词域名，逐步占领长尾词市场，积少成多，以小博大，在持久战中能够超越竞争对手。</p>
<p>这个战略，更考验战略定力和执行的坚韧，也就是所谓的耐心和坚持。所以我常常说，创业不是一般人能够做的，因为大多数人只想赚快钱，只想一夜暴富，很难持久地去做一件事。</p>
<p>我们做创业，需要脚踏实地，一步一个脚印，将目标拆解，踏踏实实地走好每一步。在困难的时候，有坚持下去的勇气和方法，在顺利的时候，保持清醒和谦逊。</p>
<h3 data-id="heading-5">06｜从群众中来，到群众中去：用 MVP + 反馈闭环逼近真相</h3>
<p>毛选的第六个思想，是从群众中来，到群众中去。我们做产品，对这个体会可能会更加深刻，这里的“群众”就是我们的用户。所有的需求，一定不能是凭脑袋空想出来的。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/28b6bc6b29e948db95dd8551d3a7f26d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a2f5YGlQUnnvJbnqIs=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766498621&amp;x-signature=t2%2FSA3UJ7rbp4VCIWPE1gf%2FWi9g%3D" alt="" loading="lazy"/></p>
<p>其实在精益创业中，有很大的篇幅是介绍了我们应该怎样进行用户研究，用户访谈，从而提炼出真正的需求。对于出海业务，用户访谈可能是一个难题，这就更需要我们拥有产品 Sense。</p>
<p>SEO 相对来说就是一个科学的方法论，通过关键词的分析，来拆解用户背后的诉求，至少这个 idea 不是凭空创造出来的，它是真正的用户需求。</p>
<p>然后我们凭借自己的调研，对于 Serp 站点的深入体验和思考分析，确定用户的实际需求，这个过程，就是从群众中来。最后，我们通过实验的方式，做出产品进行市场验证，就是所谓的“到群众中去”。</p>
<p>一旦我们的 MVP 产品有了初始用户，我们可以通过邮件的方式收到用户反馈，亦或是评价、评论的方式，从多方面收集用户诉求，这样就形成了每一次产品的迭代优化，随着每一次的迭代，我们就深化产品认知，决策完善一步。</p>
<p>这个闭环就是：**实践、认知、再实践、再认知。**你不可能在行动之前就掌握全部真理，很多事情只有去做了，才能真正明白。所以，要敢于实践，敢于试错。</p>
<h3 data-id="heading-6">写在最后：把方法论变成你的行动清单</h3>
<p>回到开头那个问题：创业有没有一套底层思维？</p>
<p>我的答案是：有。至少对我而言，《毛选》给了我一套非常强的“问题解决框架”：</p>
<ul>
<li>
<p><strong>实事求是</strong>：用调查研究搞清楚事实</p>
</li>
<li>
<p><strong>阶级分析</strong>：用利益地图决定合作与竞争</p>
</li>
<li>
<p><strong>主要矛盾</strong>：把主要精力投入到“牵一发而动全身”的关键问题</p>
</li>
<li>
<p><strong>对立统一</strong>：辩证看利弊，把不利因素转化为有利条件</p>
</li>
<li>
<p><strong>持久战</strong>：长期坚持，有目标、有阶段、脚踏实地</p>
</li>
<li>
<p><strong>从群众中来，到群众中去</strong>：用 MVP 最快获得反馈，不断试错与复盘</p>
</li>
</ul>
<p>如果你愿意，欢迎在评论区告诉我：你当下出海/创业的<strong>主要矛盾</strong>是什么？</p>
<p>好了，今天就分享到这里。咱们下期再见！</p>
<hr/>
<p>🚀 想要与更多AI爱好者交流，共同成长吗？</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FZ4k_5_waWJbRRo5lZBZmog" target="_blank" title="https://mp.weixin.qq.com/s/Z4k_5_waWJbRRo5lZBZmog" ref="nofollow noopener noreferrer">和一群志同道合的人，持续精进 AI 的每一天</a></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[当时序数据不再“只是时间”：金仓数据库如何在复杂场景中拉开与 InfluxDB 的差距]]></title>    <link>https://juejin.cn/post/7584287969214791699</link>    <guid>https://juejin.cn/post/7584287969214791699</guid>    <pubDate>2025-12-16T14:28:37.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584287969214791699" data-draft-id="7584307643000307755" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="当时序数据不再“只是时间”：金仓数据库如何在复杂场景中拉开与 InfluxDB 的差距"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2025-12-16T14:28:37.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="我是杰尼"/> <meta itemprop="url" content="https://juejin.cn/user/4200579899599495"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            当时序数据不再“只是时间”：金仓数据库如何在复杂场景中拉开与 InfluxDB 的差距
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4200579899599495/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    我是杰尼
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-16T14:28:37.000Z" title="Tue Dec 16 2025 14:28:37 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-16
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">当时序数据不再“只是时间”：金仓数据库如何在复杂场景中拉开与 InfluxDB 的差距</h2>
<h3 data-id="heading-1">一、时序数据库的“第二阶段”已经到来</h3>
<p>在很长一段时间里，时序数据库的核心问题只有一个：
<strong>如何高效存储按时间不断增长的数据点？</strong></p>
<p>InfluxDB 正是在这一阶段脱颖而出的代表产品。其专门为时间序列设计的存储模型、简洁的写入接口以及良好的初期性能，使其在监控和物联网领域被大量采用。</p>
<p>但随着业务系统逐渐成熟，企业对时序数据的诉求正在发生变化：</p>
<ul>
<li>数据量不再是百万、千万，而是<strong>持续增长的百亿级</strong></li>
<li>查询不再只是画图，而是<strong>实时分析、异常定位、智能决策</strong></li>
<li>时序数据不再独立存在，而是要与<strong>业务数据、设备数据、空间信息</strong>结合</li>
</ul>
<p>这意味着，时序数据库正在进入一个新的阶段——
<strong>从“专用存储工具”向“核心数据能力”的转变。</strong></p>
<p>也正是在这一阶段，金仓数据库（KingbaseES）与 InfluxDB 的差距开始被不断放大。</p>
<hr/>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b6bdfa05de7c446491c79ba14269cdd3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oiR5piv5p2w5bC8:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766500117&amp;x-signature=gu2xDu4i1y8OZDe8RJ%2FqqBVovoU%3D" alt="在这里插入图片描述" loading="lazy"/></p>
<h3 data-id="heading-2">二、写入不是终点：高并发之下的可持续能力</h3>
<p>写入性能，往往是评价时序数据库的第一指标。但真正重要的，并不是“单次跑分有多高”，而是：</p>
<blockquote>
<p>在设备规模不断扩大、写入长期持续的情况下，系统是否还能稳定、高效地运行？</p>
</blockquote>
<p>在基于 TSBS 的测试中，模拟了从小规模设备到千万级设备的持续写入压力。测试结果呈现出一个非常清晰的趋势：</p>
<ul>
<li>在小规模写入场景下，两者性能接近</li>
<li>随着设备数量和指标数量增长，金仓的写入吞吐优势逐步显现</li>
<li>在千万级设备压力下，金仓的写入性能达到 InfluxDB 的 <strong>2 倍以上</strong></li>
</ul>
<p>这背后反映的，并不是简单的“写得快”，而是：</p>
<ul>
<li>并发调度能力</li>
<li>存储结构对高基数数据的适应性</li>
<li>分区与索引策略的可扩展性</li>
</ul>
<p>在真实生产系统中，这些因素往往比单次写入延迟更重要。</p>
<hr/>
<h3 data-id="heading-3">三、真正决定上限的，是复杂查询能力</h3>
<p>如果说写入能力决定系统能否“活下来”，那么查询能力决定的，就是系统是否“有价值”。</p>
<p>在大量企业实践中，时序查询往往会经历三个阶段：</p>
<ol>
<li><strong>基础查询</strong>：单指标、短时间窗口</li>
<li><strong>分析查询</strong>：多设备、多指标、分组聚合</li>
<li><strong>业务查询</strong>：最新状态、异常筛选、跨维度分析</li>
</ol>
<h4 data-id="heading-4">1. 简单查询阶段：差距不明显</h4>
<p>在单设备、单指标的聚合查询中，金仓与 InfluxDB 的性能都能保持在毫秒级，整体体验差距有限。</p>
<p>这也是很多团队在早期使用 InfluxDB 时感觉“性能很好”的原因。</p>
<hr/>
<h4 data-id="heading-5">2. 分析查询阶段：优势开始显现</h4>
<p>当查询涉及多设备、多指标，并且需要进行分组统计时，金仓的优势逐步体现。</p>
<p>在典型的“多设备多指标一小时统计”测试中：</p>
<ul>
<li>金仓的响应速度通常为 InfluxDB 的 <strong>3～4 倍</strong></li>
<li>随着时间窗口拉长，这一差距仍能保持稳定</li>
</ul>
<p>这说明，在数据量和计算复杂度同时增长的情况下，金仓的执行计划和资源调度更加高效。</p>
<hr/>
<h4 data-id="heading-6">3. 业务级查询：数量级差距的出现</h4>
<p>在最接近真实业务的查询场景中，两者的性能差距呈现出数量级放大。</p>
<p>例如：</p>
<ul>
<li><strong>Last Point 查询</strong>（获取每个设备的最新数据）</li>
<li><strong>阈值筛选查询</strong>（找出某时间段内超限的设备）</li>
<li><strong>状态统计查询</strong>（按设备维度汇总运行状态）</li>
</ul>
<p>在测试中，面对数百台设备的数据：</p>
<ul>
<li>金仓的查询耗时维持在百毫秒级</li>
<li>InfluxDB 的查询耗时则可能达到数秒甚至十秒以上</li>
</ul>
<p>在部分场景下，性能差距超过 <strong>70 倍</strong>。</p>
<p>对于实时告警、智能调度和自动控制系统而言，这种差距直接决定了系统是否“可用”。</p>
<hr/>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/45b0fe36c4864590bbed424ee0e6f87d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oiR5piv5p2w5bC8:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766500117&amp;x-signature=VV7PogJYf4LvlHAOATJEYUwZgV4%3D" alt="在这里插入图片描述" loading="lazy"/></p>
<h3 data-id="heading-7">四、架构差异：为什么 InfluxDB 会在复杂场景中“吃力”</h3>
<p>从根本上看，这种性能差距并非偶然，而是架构设计目标不同所导致的必然结果。</p>
<h4 data-id="heading-8">1. 专用模型 vs 通用执行引擎</h4>
<p>InfluxDB 的设计初衷是围绕时间序列进行高度优化，适合指标型数据的快速写入与简单聚合。</p>
<p>而金仓的时序能力，构建在成熟的关系型数据库内核之上，具备：</p>
<ul>
<li>完整的查询优化器</li>
<li>多种索引与执行策略</li>
<li>成熟的并发控制与事务机制</li>
</ul>
<p>当查询逻辑变复杂时，这种通用能力反而成为优势。</p>
<hr/>
<h4 data-id="heading-9">2. SQL 生态带来的长期收益</h4>
<p>金仓原生支持标准 SQL，这一点在企业级场景中意义重大：</p>
<ul>
<li>可直接复用 BI、报表、分析工具</li>
<li>支持复杂关联查询与子查询</li>
<li>统一技术栈，降低学习和维护成本</li>
</ul>
<p>相比之下，InfluxDB 的专用查询语言在简单场景下足够高效，但在复杂分析和系统集成中，往往需要额外的适配和开发工作。</p>
<hr/>
<h3 data-id="heading-10">五、存储与成本：被忽视但极其关键的维度</h3>
<p>在海量时序数据场景中，存储成本往往是长期运营中最大的隐性支出。</p>
<p>金仓在数据生命周期管理方面提供了：</p>
<ul>
<li>自动时间分区</li>
<li>灵活的数据保留策略</li>
<li>高压缩比的历史数据存储</li>
<li>冷热数据分级管理</li>
</ul>
<p>在实际测试中，针对工业传感器类数据，金仓可实现 <strong>1:4 左右的压缩比</strong>，在数据规模持续增长的情况下，这种优势会被不断放大。</p>
<hr/>
<h3 data-id="heading-11">六、从“时序”到“融合”：业务价值的真正释放</h3>
<p>企业真正关心的，并不是“时序数据本身”，而是它所承载的业务含义。</p>
<p>金仓支持在同一数据库内，对以下数据进行统一分析：</p>
<ul>
<li>时序数据</li>
<li>设备与业务主数据</li>
<li>JSON 文档型信息</li>
<li>空间地理数据</li>
</ul>
<p>这使得许多复杂分析场景得以简化，例如：</p>
<blockquote>
<p>“统计过去一周内，某区域内运行异常的设备数量及分布情况”</p>
</blockquote>
<p>在 InfluxDB 中，这通常需要多系统协作完成；而在金仓中，一条 SQL 即可完成。</p>
<hr/>
<h3 data-id="heading-12">七、结语：时序数据库竞争的真正分水岭</h3>
<p>InfluxDB 在时序数据库发展早期，起到了重要推动作用。但随着业务复杂度和数据规模的持续提升，企业对数据库的期待已经发生根本变化。</p>
<p>金仓数据库所展现的优势，并不仅是“跑得更快”，而是：</p>
<ul>
<li>在复杂查询下依然可控、稳定</li>
<li>在企业生态中易于融合</li>
<li>在长期运营中成本可预期</li>
</ul>
<p>当时序数据从“记录状态”走向“驱动决策”，数据库的角色也必须随之进化。</p>
<p>而这，正是金仓在复杂时序场景中逐步领先的根本原因。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[国产时序数据库崛起：金仓凭什么在复杂场景中碾压InfluxDB]]></title>    <link>https://juejin.cn/post/7584073390694973455</link>    <guid>https://juejin.cn/post/7584073390694973455</guid>    <pubDate>2025-12-16T14:33:12.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584073390694973455" data-draft-id="7584243498528505856" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="国产时序数据库崛起：金仓凭什么在复杂场景中碾压InfluxDB"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2025-12-16T14:33:12.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="码事漫谈"/> <meta itemprop="url" content="https://juejin.cn/user/1972974802965230"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            国产时序数据库崛起：金仓凭什么在复杂场景中碾压InfluxDB
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1972974802965230/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    码事漫谈
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-16T14:33:12.000Z" title="Tue Dec 16 2025 14:33:12 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-16
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    1
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在物联网、工业互联网与智能运维高速发展的当下，时序数据的处理需求正呈指数级增长。从设备监控到智能决策，企业对数据库的要求早已不再局限于“能写能查”，而是追求高吞吐、低延迟、强一致性以及多维度分析能力。过去，InfluxDB凭借先发优势和简洁架构，成为时序数据库的代表。然而，随着数据量级从“万”跃升至“千万”，其性能瓶颈日益凸显。</p>
<p>一场国产数据库与国际开源方案之间的较量悄然展开。金仓数据库（KingbaseES）以全面领先的性能表现，正在重新定义时序数据库的能力边界。</p>
<hr/>
<h2 data-id="heading-0"><strong>性能全面领先：从写入到分析，金仓全面胜出</strong></h2>
<p>基于业界公认的TSBS（Time Series Benchmark Suite）基准测试，金仓与InfluxDB在多轮对比中展开正面交锋。结果显示：在小规模、简单查询场景下，两者表现接近；但在大规模、复杂分析的真实业务环境中，金仓展现出压倒性优势。</p>
<h3 data-id="heading-1"><strong>写入性能：高并发下稳定领先</strong></h3>
<p>模拟从100台到1000万台设备的数据写入压力，金仓在设备规模达到4000台（每台10个指标）时，写入性能已达InfluxDB的162%。在千万级设备极限测试中，这一优势进一步扩大<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1d6d605a72ef42b293962b0fe5f5b935~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56CB5LqL5ryr6LCI:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766500392&amp;x-signature=VE24Ow2%2FbGW10%2FjtnJhTzPoe%2BgY%3D" alt="在这里插入图片描述" loading="lazy"/>
至267%。这意味着，面对高并发、持续写入的海量时序数据，金仓具备更强的扩展能力与稳定性。</p>
<h3 data-id="heading-2"><strong>查询性能：复杂分析场景下碾压式领先</strong></h3>
<p>在查询性能方面，金仓的优势尤为明显，尤其在多维度聚合、跨设备分析等高复杂度查询中：</p>
<ul>
<li><strong>简单聚合查询（如单设备短时间窗口聚合）</strong>：两者响应时间接近，毫秒级完成。</li>
<li><strong>中等复杂度查询（如多指标聚合、跨设备分组）</strong>：金仓响应速度为InfluxDB的3~4倍。</li>
<li><strong>高复杂度关联分析（如Last Point查询、高负载设备筛选）</strong>：金仓性能领先可达数十倍。例如，在“查询某时段内每台设备的最后读数”场景中，金仓耗时仅147毫秒，而InfluxDB超过10秒，性能差距超过70倍。</li>
</ul>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1f8c8cef3efe40108458094b4bbd2014~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56CB5LqL5ryr6LCI:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766500392&amp;x-signature=WjrsrT6OkNB6GYXOqT4HuLGfO%2Bc%3D" alt="在这里插入图片描述" loading="lazy"/></p>
<hr/>
<h2 data-id="heading-3"><strong>不止于快：金仓的企业级能力与融合优势</strong></h2>
<p>金仓的优势不仅体现在“跑得快”，更在于其面向企业级应用的深度设计。相比InfluxDB，金仓在以下几个关键维度实现了质的飞跃。</p>
<h3 data-id="heading-4"><strong>1. 完整SQL生态，降低开发与迁移成本</strong></h3>
<p>金仓基于成熟的关系型数据库内核，原生支持标准SQL、存储过程、事务（ACID）与多表关联查询。企业无需学习新的查询语言，现有SQL工具和业务系统可直接对接，极大降低开发与运维成本。相比之下，InfluxDB需使用InfluxQL或Flux语言，集成成本高，且在金融、工控等对一致性要求高的场景中难以胜任。</p>
<h3 data-id="heading-5"><strong>2. 高效存储与生命周期管理</strong></h3>
<p>金仓内置时序组件，支持按时间自动分区、冷热数据分级存储与高压缩比存储。实测显示，其对工业传感器数据可实现高达1:4的压缩比，显著降低存储成本。同时，冷热数据分离机制也提升了查询效率与系统响应速度。</p>
<h3 data-id="heading-6"><strong>3. 多模融合，打破数据孤岛</strong></h3>
<p>金仓首创“时序+”多模融合架构，支持在同一数据库中对时序数据、空间地理信息（GIS）、JSON文档等多种数据类型进行联合查询。例如，在智慧交通场景中，用户可通过一条SQL实现“查询过去一周在机场周边频繁出现的车辆”，而这类时空联合查询在InfluxDB中几乎无法原生支持。</p>
<hr/>
<h2 data-id="heading-7"><strong>实战验证：从测试场走向核心生产系统</strong></h2>
<p>金仓的时序能力已在多个关键行业中落地，成功替代或优于原有方案，成为支撑核心业务的数据底座。</p>
<h3 data-id="heading-8"><strong>案例一：智慧港口</strong></h3>
<p>在某大型港口集团的智能调度系统中，系统需处理日均数十亿条GPS轨迹数据。金仓在写入吞吐量、查询响应速度与系统稳定性方面全面优于InfluxDB，最终成为其核心引擎，支撑集卡调度、区域统计等关键功能。</p>
<h3 data-id="heading-9"><strong>案例二：新能源风电</strong></h3>
<p>某新能源企业需管理上千台风机的运行状态数据。金仓不仅实现每秒数十万点数据的高效写入，还能与设备元数据无缝融合，支持“设备-状态-告警”一体化查询。测试显示，其复杂分析查询性能为InfluxDB的2~70倍，预计可节省超百万元存储成本。</p>
<hr/>
<h2 data-id="heading-10"><strong>结语：从“记录”到“洞察”，金仓定义下一代时序数据库</strong></h2>
<p>InfluxDB或许仍适用于轻量级监控场景，但当企业迈向实时分析、智能决策、系统融合的新阶段，金仓提供了更强大、更成熟、更可控的选择。</p>
<p>它不仅是一个更快的时序数据库，更是一个融合时序、关系、空间等多模数据能力的统一平台。选择金仓，不只是选择一款数据库，更是选择一种面向未来的数据基础设施。</p>
<p>在数据驱动的新时代，金仓正以“洞察未来”的能力，引领国产数据库走向更广阔的舞台。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[这 10 个 MySQL 高级用法，让你的代码又快又好看]]></title>    <link>https://juejin.cn/post/7584266184882552866</link>    <guid>https://juejin.cn/post/7584266184882552866</guid>    <pubDate>2025-12-16T14:50:50.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584266184882552866" data-draft-id="7576487832089788431" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="这 10 个 MySQL 高级用法，让你的代码又快又好看"/> <meta itemprop="keywords" content="后端,MySQL"/> <meta itemprop="datePublished" content="2025-12-16T14:50:50.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="刘大华"/> <meta itemprop="url" content="https://juejin.cn/user/3507878440995946"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            这 10 个 MySQL 高级用法，让你的代码又快又好看
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3507878440995946/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    刘大华
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-16T14:50:50.000Z" title="Tue Dec 16 2025 14:50:50 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-16
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>大家好，我是大华！</p>
<p>MySQL 有很多高级但实用的功能，能让你的查询变得更简洁、更高效。</p>
<p>今天分享 10 个我在工作中经常使用的 SQL 技巧，不用死记硬背，掌握了就能立刻提升你的数据库操作水平！</p>
<h3 data-id="heading-0">1. CTE（<code>WITH</code> 子句）——让复杂查询变清晰</h3>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-comment">-- 传统子查询，难以阅读</span>
<span class="hljs-keyword">SELECT</span> nickname 
<span class="hljs-keyword">FROM</span> system_users 
<span class="hljs-keyword">WHERE</span> dept_id <span class="hljs-keyword">IN</span> (
    <span class="hljs-keyword">SELECT</span> id <span class="hljs-keyword">FROM</span> system_dept <span class="hljs-keyword">WHERE</span> `name` <span class="hljs-operator">=</span> <span class="hljs-string">'IT部'</span>
);

<span class="hljs-comment">-- 使用CTE，逻辑清晰</span>
<span class="hljs-keyword">WITH</span> ny_depts <span class="hljs-keyword">AS</span> (
    <span class="hljs-keyword">SELECT</span> id <span class="hljs-keyword">FROM</span> system_dept <span class="hljs-keyword">WHERE</span> `name` <span class="hljs-operator">=</span> <span class="hljs-string">'IT部'</span>
)
<span class="hljs-keyword">SELECT</span> u.nickname
<span class="hljs-keyword">FROM</span> system_users u
<span class="hljs-keyword">JOIN</span> ny_depts nd <span class="hljs-keyword">ON</span> u.dept_id <span class="hljs-operator">=</span> nd.id;
</code></pre>
<p><strong>解释：</strong></p>
<ul>
<li><code>WITH ny_depts AS (...)</code>：先创建一个临时结果集，叫 <code>ny_depts</code>，里面只包含“IT部”的部门名称。</li>
<li><code>SELECT u.nickname FROM system_users u JOIN ny_depts...</code>：再从用户表中找出那些部门ID在<code>ny_depts</code>里的员工昵称。</li>
</ul>
<p><strong>好处</strong>：把找部门和找人分成两步，逻辑更清楚，比嵌套子查询好读多了。</p>
<hr/>
<h3 data-id="heading-1">2. 窗口函数 —— 不分组也能统计</h3>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">SELECT</span> 
    name,
    department,
    salary,
    <span class="hljs-built_in">RANK</span>() <span class="hljs-keyword">OVER</span> (<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> department <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> salary <span class="hljs-keyword">DESC</span>) <span class="hljs-keyword">AS</span> rank_in_dept,
    <span class="hljs-built_in">AVG</span>(salary) <span class="hljs-keyword">OVER</span> (<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> department) <span class="hljs-keyword">AS</span> avg_salary
<span class="hljs-keyword">FROM</span> employees;
</code></pre>
<p><strong>解释：</strong></p>
<ul>
<li><code>PARTITION BY department</code>：按部门“分组”，但<strong>不合并行</strong>，每行仍然保留。</li>
<li><code>RANK() OVER (...)</code>：在每个部门内部，按薪水从高到低排名（相同薪水并列）。</li>
<li><code>AVG(salary) OVER (...)</code>：计算每个部门的平均工资，并显示在每一行里。</li>
</ul>
<p><strong>对比 GROUP BY</strong>：<code>GROUP BY</code> 会把多行合并成一行，而窗口函数保留原始行，同时加上统计值。</p>
<hr/>
<h3 data-id="heading-2">3. 条件聚合 —— 一行查出多个统计</h3>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">SELECT</span> 
    <span class="hljs-keyword">YEAR</span>(created_at) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">year</span>,
    <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">AS</span> total,
    <span class="hljs-built_in">COUNT</span>(<span class="hljs-keyword">CASE</span> <span class="hljs-keyword">WHEN</span> status <span class="hljs-operator">=</span> <span class="hljs-string">'completed'</span> <span class="hljs-keyword">THEN</span> <span class="hljs-number">1</span> <span class="hljs-keyword">END</span>) <span class="hljs-keyword">AS</span> completed,
    <span class="hljs-built_in">SUM</span>(<span class="hljs-keyword">CASE</span> <span class="hljs-keyword">WHEN</span> status <span class="hljs-operator">=</span> <span class="hljs-string">'completed'</span> <span class="hljs-keyword">THEN</span> amount <span class="hljs-keyword">ELSE</span> <span class="hljs-number">0</span> <span class="hljs-keyword">END</span>) <span class="hljs-keyword">AS</span> revenue
<span class="hljs-keyword">FROM</span> orders
<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">YEAR</span>(created_at);
</code></pre>
<p><strong>解释：</strong></p>
<ul>
<li><code>YEAR(created_at)</code>：提取订单年份。</li>
<li><code>COUNT(*)</code>：该年总订单数。</li>
<li><code>COUNT(CASE WHEN status = 'completed' THEN 1 END)</code>：
如果状态是 <code>'completed'</code>，就返回 <code>1</code>，否则返回 <code>NULL</code>；</li>
<li><code>COUNT()</code> 只统计非 <code>NULL</code> 值，所以这行就是“完成的订单数”。</li>
<li><code>SUM(CASE WHEN ... THEN amount ELSE 0 END)</code>：只对完成的订单求金额总和。</li>
</ul>
<p><strong>关键</strong>：不用写多个子查询，一条语句搞定全年报表！</p>
<hr/>
<h3 data-id="heading-3">4. 自连接 —— 同一张表自己连自己</h3>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">SELECT</span> e1.name, e2.name
<span class="hljs-keyword">FROM</span> employees e1
<span class="hljs-keyword">JOIN</span> employees e2 
  <span class="hljs-keyword">ON</span> e1.department <span class="hljs-operator">=</span> e2.department
  <span class="hljs-keyword">AND</span> e1.id <span class="hljs-operator">&lt;</span> e2.id  
  <span class="hljs-keyword">AND</span> <span class="hljs-built_in">ABS</span>(e1.salary <span class="hljs-operator">-</span> e2.salary) <span class="hljs-operator">&lt;=</span> e1.salary <span class="hljs-operator">*</span> <span class="hljs-number">0.1</span>;
</code></pre>
<p><strong>解释：</strong></p>
<ul>
<li><code>employees e1 JOIN employees e2</code>：把员工表当成两个副本（e1 和 e2）来连接。</li>
<li><code>e1.department = e2.department</code>：只找同一个部门的人。</li>
<li><code>e1.id &lt; e2.id</code>：避免重复配对（比如 Alice-Bob 和 Bob-Alice 只保留一个）。</li>
<li><code>ABS(...)</code>：计算两人薪水差是否 ≤ 10%。</li>
</ul>
<p><strong>用途</strong>：找“相似记录”“配对关系”“上下级”等场景非常有用。</p>
<hr/>
<h3 data-id="heading-4">5. <code>EXISTS</code> 替代 <code>IN</code> —— 更高效的存在判断</h3>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">SELECT</span> name <span class="hljs-keyword">FROM</span> customers c
<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">EXISTS</span> (
    <span class="hljs-keyword">SELECT</span> <span class="hljs-number">1</span> <span class="hljs-keyword">FROM</span> orders o 
    <span class="hljs-keyword">WHERE</span> o.customer_id <span class="hljs-operator">=</span> c.id <span class="hljs-keyword">AND</span> o.amount <span class="hljs-operator">&gt;</span> <span class="hljs-number">1000</span>
);
</code></pre>
<p><strong>解释：</strong></p>
<ul>
<li>对每一位客户 <code>c</code>，检查是否存在一笔订单满足：
<ul>
<li>订单的 <code>customer_id</code> 等于这个客户的 <code>id</code></li>
<li>订单金额 &gt; 1000</li>
</ul>
</li>
<li><code>SELECT 1</code>：这里不需要返回具体字段，只要知道“有没有”就行，所以用 <code>1</code> 最轻量。</li>
<li><strong>为什么快？</strong>：一旦找到一条匹配订单，就立刻停止搜索，不像 <code>IN</code> 可能要加载全部订单 ID。</li>
</ul>
<p>注意：如果子查询可能返回 <code>NULL</code>，<code>IN</code> 会失效（因为 <code>x IN (..., NULL)</code> 永远为 <code>UNKNOWN</code>），而 <code>EXISTS</code> 不受影响。</p>
<hr/>
<h3 data-id="heading-5">6. JSON 函数 —— 轻松读取 JSON 字段</h3>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">SELECT</span> 
    name,
    profile<span class="hljs-operator">-</span><span class="hljs-operator">&gt;&gt;</span><span class="hljs-string">'$.address.city'</span> <span class="hljs-keyword">AS</span> city,
    JSON_EXTRACT(profile, <span class="hljs-string">'$.age'</span>) <span class="hljs-keyword">AS</span> age
<span class="hljs-keyword">FROM</span> users
<span class="hljs-keyword">WHERE</span> profile<span class="hljs-operator">-</span><span class="hljs-operator">&gt;&gt;</span><span class="hljs-string">'$.city'</span> <span class="hljs-operator">=</span> <span class="hljs-string">'Beijing'</span>;
</code></pre>
<p><strong>解释：</strong></p>
<ul>
<li><code>profile</code> 是一个 JSON 类型字段，比如：<code>{"address": {"city": "Beijing"}, "age": 30}</code></li>
<li><code>profile-&gt;&gt;'$.address.city'</code>：
<ul>
<li><code>-&gt;&gt;</code> 是简写，等价于 <code>JSON_UNQUOTE(JSON_EXTRACT(...))</code></li>
<li>返回字符串 <code>"Beijing"</code>（去掉引号）</li>
</ul>
</li>
<li><code>JSON_EXTRACT(profile, '$.age')</code>：返回 <code>30</code>（带类型，可能是数字）</li>
<li><code>WHERE profile-&gt;&gt;'$.city' = 'Beijing'</code>：筛选城市是北京的用户。</li>
</ul>
<p><strong>适用场景</strong>：用户偏好、动态表单、日志等结构不固定的字段。</p>
<hr/>
<h3 data-id="heading-6">7. 生成列 —— 数据库自动帮你算</h3>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> products (
    id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY,
    width <span class="hljs-type">DECIMAL</span>(<span class="hljs-number">10</span>,<span class="hljs-number">2</span>),
    height <span class="hljs-type">DECIMAL</span>(<span class="hljs-number">10</span>,<span class="hljs-number">2</span>),
    area <span class="hljs-type">DECIMAL</span>(<span class="hljs-number">10</span>,<span class="hljs-number">2</span>) <span class="hljs-keyword">AS</span> (width <span class="hljs-operator">*</span> height) STORED
);

<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> products (id, width, height) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>);
</code></pre>
<p><strong>解释：</strong></p>
<ul>
<li><code>area DECIMAL(...) AS (width * height) STORED</code>：
<ul>
<li>这是一个“存储型生成列”，数据库会自动计算 <code>width * height</code> 并存下来。</li>
<li>如果不加 <code>STORED</code>，就是“虚拟列”（每次查询时计算，不占存储）。</li>
</ul>
</li>
<li>插入时只需给 <code>width</code> 和 <code>height</code>，<code>area</code> 自动变成 <code>50</code>。</li>
</ul>
<p><strong>优势</strong>：避免应用层重复计算，还能给 <code>area</code> 加索引加速查询！</p>
<hr/>
<h3 data-id="heading-7">8. 多表更新 —— 一条语句更新关联数据</h3>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">UPDATE</span> customers c
<span class="hljs-keyword">JOIN</span> (
    <span class="hljs-keyword">SELECT</span> customer_id, <span class="hljs-built_in">SUM</span>(amount) <span class="hljs-keyword">AS</span> total
    <span class="hljs-keyword">FROM</span> orders
    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> customer_id
) o <span class="hljs-keyword">ON</span> c.id <span class="hljs-operator">=</span> o.customer_id
<span class="hljs-keyword">SET</span> c.total_spent <span class="hljs-operator">=</span> o.total;
</code></pre>
<p><strong>解释：</strong></p>
<ul>
<li>子查询 <code>o</code>：先按客户 ID 统计每个人的总消费。</li>
<li><code>UPDATE customers c JOIN o ...</code>：把客户表和统计结果连接起来。</li>
<li><code>SET c.total_spent = o.total</code>：直接把统计值写回客户表。</li>
</ul>
<p><strong>好处</strong>：不用在程序里循环“查一个、改一个”，减少网络开销，保证原子性。</p>
<hr/>
<h3 data-id="heading-8">9. <code>GROUP_CONCAT</code> —— 多行变一行</h3>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">SELECT</span> 
    department,
    GROUP_CONCAT(name <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> salary <span class="hljs-keyword">DESC</span> SEPARATOR <span class="hljs-string">', '</span>) <span class="hljs-keyword">AS</span> members
<span class="hljs-keyword">FROM</span> employees
<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department;
</code></pre>
<p><strong>解释：</strong></p>
<ul>
<li><code>GROUP BY department</code>：按部门分组。</li>
<li><code>GROUP_CONCAT(name ...)</code>：把每个部门的所有员工名字拼成一个字符串。</li>
<li><code>ORDER BY salary DESC</code>：按薪水从高到低排序后再拼接。</li>
<li><code>SEPARATOR ', '</code>：用逗号加空格分隔名字。</li>
</ul>
<p><strong>典型用途</strong>：导出名单、展示标签、汇总明细等。</p>
<p>默认最多拼 1024 字符，可通过 <code>SET SESSION group_concat_max_len = 1000000;</code> 调大。</p>
<hr/>
<h3 data-id="heading-9">10. <code>INSERT ... ON DUPLICATE KEY UPDATE</code> —— 智能插入/更新</h3>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> page_views (page_url, view_date, view_count)
<span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'/home'</span>, CURDATE(), <span class="hljs-number">1</span>)
<span class="hljs-keyword">ON</span> DUPLICATE KEY <span class="hljs-keyword">UPDATE</span> 
    view_count <span class="hljs-operator">=</span> view_count <span class="hljs-operator">+</span> <span class="hljs-number">1</span>;
</code></pre>
<p><strong>解释：</strong></p>
<ul>
<li>尝试插入一条新记录：页面 <code>/home</code>，今天日期，访问次数为 1。</li>
<li>如果因为<strong>唯一索引冲突</strong>（比如 <code>(page_url, view_date)</code> 是唯一键）导致插入失败：
<ul>
<li>就执行 <code>ON DUPLICATE KEY UPDATE</code> 部分</li>
<li>把原有的 <code>view_count</code> 加 1</li>
</ul>
</li>
<li><strong>效果</strong>：第一次访问创建记录，之后每次访问自动 +1，完美实现计数器！</li>
</ul>
<p><strong>前提</strong>：表必须有主键或唯一索引，否则不会触发更新。</p>
<hr/>
<blockquote>
<p>本文首发于公众号：程序员刘大华，专注分享前后端开发的实战笔记。关注我，少走弯路，一起进步！</p>
</blockquote>
<h4 data-id="heading-10">📌往期精彩</h4>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F6V83qjR6u0nyfzL-14xYAw" target="_blank" title="https://mp.weixin.qq.com/s/6V83qjR6u0nyfzL-14xYAw" ref="nofollow noopener noreferrer">《async/await 到底要不要加 try-catch？异步错误处理最佳实践》</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FbgLoyqb3VLgn3xXAok3kcQ" target="_blank" title="https://mp.weixin.qq.com/s/bgLoyqb3VLgn3xXAok3kcQ" ref="nofollow noopener noreferrer">《如何查看 SpringBoot 当前线程数？3 种方法亲测有效》</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2Fp0n2mN5RDDDaIWuHHVRUZQ" target="_blank" title="https://mp.weixin.qq.com/s/p0n2mN5RDDDaIWuHHVRUZQ" ref="nofollow noopener noreferrer">《Java 开发必看：什么时候用 for，什么时候用 Stream？》</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FDpjuafW3agyhLEQYif3zJA" target="_blank" title="https://mp.weixin.qq.com/s/DpjuafW3agyhLEQYif3zJA" ref="nofollow noopener noreferrer">《别再乱 new ArrayList！8 大 Java 容器选型案例，一篇看懂》</a></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[前端如何实现RAG？一文带你速通，使用RAG实现长期记忆]]></title>    <link>https://juejin.cn/post/7584297353419522048</link>    <guid>https://juejin.cn/post/7584297353419522048</guid>    <pubDate>2025-12-16T13:40:50.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584297353419522048" data-draft-id="7584073390694793231" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="前端如何实现RAG？一文带你速通，使用RAG实现长期记忆"/> <meta itemprop="keywords" content="前端,AI编程,Node.js"/> <meta itemprop="datePublished" content="2025-12-16T13:40:50.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="天天扭码"/> <meta itemprop="url" content="https://juejin.cn/user/3349589831715801"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            前端如何实现RAG？一文带你速通，使用RAG实现长期记忆
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3349589831715801/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    天天扭码
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-16T13:40:50.000Z" title="Tue Dec 16 2025 13:40:50 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-16
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读10分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>作为前端开发者，我们经常遇到一个痛点：<strong>AI 助手无法记住跨会话的历史记录</strong>。本文将从前端的视角出发，深度解析 RAG（检索增强生成）的工作原理，并结合实际项目代码，详细剖析如何使用 <strong>LlamaIndex.js + DeepSeek + Qdrant</strong> 实现 AI 助手的永久记忆。</p>
<h2 data-id="heading-0">一、为什么我们需要 RAG？</h2>
<p>当我调用 DeepSeek API 搭建 AI 对话平台时，很快发现一个致命缺陷：如果用户关闭网页再次进入，AI 会立刻“失忆”。解决这个问题，传统上有几种方案，但都有明显弊端：</p>






























<table><thead><tr><th><strong>方案</strong></th><th><strong>描述</strong></th><th><strong>弊端分析</strong></th></tr></thead><tbody><tr><td><strong>1. 完整上下文传递</strong></td><td>在系统提示词中加入全部历史对话。</td><td><strong>高昂成本与限制</strong>：大量上下文极易超出 LLM 的 Token 上限，导致巨额消耗，且长文本会稀释 AI 的注意力。</td></tr><tr><td><strong>2. 对话摘要记录</strong></td><td>每次对话后，生成一个摘要并不断修改。</td><td><strong>信息丢失与准确性</strong>：摘要有最大长度限制，且 AI 自动生成的摘要难以保证准确性，少量文字无法存储海量信息。</td></tr><tr><td><strong>3. 模型微调（Fine-tuning）</strong></td><td>使用对话记录对模型进行微调。</td><td><strong>高门槛与高成本</strong>：对前端开发者而言，实现难度、资金投入和时间成本过高。</td></tr><tr><td><strong>4. RAG 检索</strong></td><td>每次对话时，检索与当前问题最相关的历史记录作为上下文。</td><td><strong>优异的长期记忆方案</strong>：通过向量化实现语义匹配，精准高效地注入相关记忆。</td></tr></tbody></table>
<p><strong>结论：</strong> RAG 是目前最经济高效、可控性最高的长期记忆实现方案。</p>
<hr/>
<h2 data-id="heading-1">二、什么是 RAG（检索增强生成）？</h2>
<p>RAG 的全称是 <strong>Retrieval-Augmented Generation</strong>。它不是一个新的模型，而是一种<strong>架构</strong>或<strong>框架</strong>，用于提升大型语言模型（LLM）回答的<strong>准确性、时效性</strong>和<strong>知识深度</strong>。</p>
<p>RAG 专门解决 LLM 的两大核心限制：<strong>知识时效性</strong>（模型知识截止于训练数据）和<strong>上下文窗口限制</strong>（短期记忆）。</p>
<h3 data-id="heading-2">核心工作原理</h3>
<p>RAG 的核心思想是：<strong>在 LLM 生成回复之前，先去外部的、特定的知识库中找到相关的“参考资料”，然后将这些资料作为证据提供给 LLM。</strong></p>
<p>RAG 流程分为两大阶段：</p>
<h4 data-id="heading-3">1. 索引阶段 (Indexing) — 知识的存储与向量化</h4>
<p>这个阶段是<strong>预先完成</strong>的，目标是将您的私有数据（例如本项目中的历史对话记录）转换为 LLM 可以快速查找的格式。</p>
<ul>
<li><strong>分块 (Chunking)</strong> ：将长的对话记录或文档切分成较小的、语义完整的片段。</li>
<li><strong>嵌入 (Embedding)</strong> ：使用嵌入模型（如 DeepSeek Embeddings）将每个文本块转换成<strong>数值向量</strong>。</li>
<li><strong>存储 (Storage)</strong> ：将这些向量及其对应的原始文本存储在<strong>向量数据库</strong>（如 Qdrant）中。</li>
</ul>
<h4 data-id="heading-4">2. 运行时阶段 (Runtime) — 记忆的检索与生成</h4>
<p>这个阶段在<strong>每次用户提问时实时发生</strong>：</p>
<ul>
<li><strong>问题嵌入</strong>：将用户当前的问题转换为查询向量。</li>
<li><strong>检索</strong>：系统在向量数据库中进行<strong>相似性搜索</strong>，快速找到与查询向量最相似的 <strong>Top K</strong> 个历史对话记录。</li>
<li><strong>提示词增强 (Augmentation)</strong> ：将用户原始问题与检索到的相关记录一起打包，形成一个 <strong>“增强的提示词”（Augmented Prompt）</strong> 。</li>
<li><strong>生成 (Generation)</strong> ：将增强提示词发送给 DeepSeek Chat API，模型根据上下文生成最终答案。</li>
</ul>
<hr/>
<h2 data-id="heading-5">三、如何实现 RAG？（项目实战流程）</h2>
<p>项目github连接——<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FObjecteee%2FaiKnowedge%2Ftree%2Fmain%2Frag%2FLlamaIndex" target="_blank" title="https://github.com/Objecteee/aiKnowedge/tree/main/rag/LlamaIndex" ref="nofollow noopener noreferrer">github.com/Objecteee/a…</a></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3f7c3e07337443bd9ea5d87c9052314d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSp5aSp5omt56CB:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766497249&amp;x-signature=DvW9DBbxqDyOkpHY8oQMkhhamNE%3D" alt="GIF 2025-12-16 21-18-35.gif" loading="lazy"/></p>
<p>我们可以看到发送给ai的提示词已经通过RAG检索到了相似的对话记录,我整理了一下格式如下——</p>
<pre><code class="hljs language-swift" lang="swift">
{

  <span class="hljs-string">"dataType"</span>: <span class="hljs-string">"ChatHistoryContext"</span>,

  <span class="hljs-string">"sourceJsonType"</span>: <span class="hljs-string">"debug"</span>,

  <span class="hljs-string">"systemInstruction"</span>: <span class="hljs-string">"你是一个智能助手。请基于以下提供的背景信息（Context）来回答用户的问题。这些背景信息可能包含相关的知识文档或过去的历史对话记录。如果背景信息与问题无关，请忽略它。"</span>,

  <span class="hljs-string">"contextType"</span>: <span class="hljs-string">"历史对话记录 (Historical Conversation Records)"</span>,

  <span class="hljs-string">"parsedConversations"</span>: [

    {

      <span class="hljs-string">"id"</span>: <span class="hljs-number">1</span>,

      <span class="hljs-string">"role"</span>: <span class="hljs-string">"User"</span>,

      <span class="hljs-string">"content"</span>: <span class="hljs-string">"我们刚刚在玩什么游戏"</span>

    },

    {

      <span class="hljs-string">"id"</span>: <span class="hljs-number">1</span>,

      <span class="hljs-string">"role"</span>: <span class="hljs-string">"Assistant"</span>,

      <span class="hljs-string">"content"</span>: <span class="hljs-string">"根据我们的对话记录，我们并没有在玩具体的游戏哦～ <span class="hljs-subst">\n</span>你之前连续发送了几次“你好”和“1”，我都在热情回应你的招呼呢！😊 <span class="hljs-subst">\n</span><span class="hljs-subst">\n</span>如果你想玩点什么，我可以陪你玩猜谜、成语接龙、脑筋急转弯，或者你提议其他小游戏也可以～ 来试试吗？"</span>

    },

    {

      <span class="hljs-string">"id"</span>: <span class="hljs-number">2</span>,

      <span class="hljs-string">"role"</span>: <span class="hljs-string">"User"</span>,

      <span class="hljs-string">"content"</span>: <span class="hljs-string">"你好，我们玩过互相说1的游戏么"</span>

    },

    {

      <span class="hljs-string">"id"</span>: <span class="hljs-number">2</span>,

      <span class="hljs-string">"role"</span>: <span class="hljs-string">"Assistant"</span>,

      <span class="hljs-string">"content"</span>: <span class="hljs-string">"是的，我们之前玩过这个游戏！😊 <span class="hljs-subst">\n</span>你让我在你输入“1”时只回复“1”，不加其他内容。 <span class="hljs-subst">\n</span>需要再玩一次吗？"</span>

    },

    {

      <span class="hljs-string">"id"</span>: <span class="hljs-number">3</span>,

      <span class="hljs-string">"role"</span>: <span class="hljs-string">"User"</span>,

      <span class="hljs-string">"content"</span>: <span class="hljs-string">"你好啊"</span>

    },

    {

      <span class="hljs-string">"id"</span>: <span class="hljs-number">3</span>,

      <span class="hljs-string">"role"</span>: <span class="hljs-string">"Assistant"</span>,

      <span class="hljs-string">"content"</span>: <span class="hljs-string">"你好啊！😊 今天看起来特别有活力呢～ <span class="hljs-subst">\n</span>有什么想聊的，或者需要我帮忙的吗？"</span>

    },

    {

      <span class="hljs-string">"id"</span>: <span class="hljs-number">4</span>,

      <span class="hljs-string">"role"</span>: <span class="hljs-string">"User"</span>,

      <span class="hljs-string">"content"</span>: <span class="hljs-string">"你好"</span>

    },

    {

      <span class="hljs-string">"id"</span>: <span class="hljs-number">4</span>,

      <span class="hljs-string">"role"</span>: <span class="hljs-string">"Assistant"</span>,

      <span class="hljs-string">"content"</span>: <span class="hljs-string">"你好！😊 很高兴见到你！有什么我可以帮助你的吗？"</span>

    },

    {

      <span class="hljs-string">"id"</span>: <span class="hljs-number">5</span>,

      <span class="hljs-string">"role"</span>: <span class="hljs-string">"User"</span>,

      <span class="hljs-string">"content"</span>: <span class="hljs-string">"你好"</span>

    },

    {

      <span class="hljs-string">"id"</span>: <span class="hljs-number">5</span>,

      <span class="hljs-string">"role"</span>: <span class="hljs-string">"Assistant"</span>,

      <span class="hljs-string">"content"</span>: <span class="hljs-string">"你好！😊 很高兴见到你！有什么我可以帮助你的吗？"</span>

    }

  ],

  <span class="hljs-string">"summary"</span>: <span class="hljs-string">"这段数据是 RAG 系统用于增强 LLM 上下文的调试信息。它包含了 AI 的系统指令和五组结构化的用户/助手历史对话记录。"</span>

}

</code></pre>
<p>要构建 RAG 系统，无论技术栈如何，都必须遵循以下三个核心阶段。我们将结合项目源码（<code>rag/LlamaIndex</code>）来具体分析实现细节。</p>
<h3 data-id="heading-6">项目概览：这套 RAG 在做什么</h3>
<p>这套系统的目标不是“把最近 N 条对话塞给模型”，而是：</p>
<ul>
<li><strong>长期记忆</strong>：把每一轮对话（User+Assistant）写入向量库，之后通过<strong>语义检索</strong>召回相关片段作为上下文。</li>
<li><strong>短期记忆</strong>：从 SQLite 取最近 <strong>5 条</strong>（用于“继续”“上面那个”这类指代保持连贯）。</li>
<li><strong>生成</strong>：将“系统指令 + RAG 召回上下文”组成 <code>systemPrompt</code>，再加上短期历史与当前问题，调用 DeepSeek Chat 生成回答。</li>
</ul>
<p>关键入口在：</p>
<ul>
<li>后端 RAG 服务：<code>rag/LlamaIndex/backend/services/ragService.js</code></li>
<li>后端对话接口：<code>rag/LlamaIndex/backend/server.js</code></li>
<li>前端调试输出：<code>rag/LlamaIndex/frontend/src/App.jsx</code></li>
</ul>
<hr/>
<h3 data-id="heading-7">RAG 实现剖析：第一阶段（知识库构建）</h3>
<h4 data-id="heading-8">1. 数据摄取（Loaders）</h4>
<p>目前的知识库来源是 <code>backend/data/</code> 目录下的文件，启动时加载：</p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-keyword">const</span> documents = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> SimpleDirectoryReader().loadData({
  directoryPath: path.<span class="hljs-keyword">join</span>(__dirname, <span class="hljs-string">"../data"</span>),
});
</code></pre>
<p>位置：<code>rag/LlamaIndex/backend/services/ragService.js:56-59</code></p>
<p>这意味着：只要往 <code>backend/data/</code> 放入新文档（如 <code>.md</code>），重建索引或首次初始化时就会被纳入向量库。</p>
<hr/>
<h4 data-id="heading-9">2. 切片逻辑（Chunking）——当前实现与重要说明</h4>
<h5 data-id="heading-10">当前实现是什么？</h5>
<p>当前<strong>没有显式写切片器</strong>（Splitter），而是依赖 LlamaIndex 在 <code>VectorStoreIndex.fromDocuments(...)</code> 内部的默认切片策略（通常是句子/段落优先的 splitter + 默认 chunkSize/overlap）。</p>
<p>真实触发点：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">index</span> = await VectorStoreIndex.fromDocuments(documents, {
  storageContext,
})<span class="hljs-comment">;</span>
</code></pre>
<p>位置：<code>rag/LlamaIndex/backend/services/ragService.js:105-108</code></p>
<h5 data-id="heading-11">这意味着什么？</h5>
<ul>
<li>
<p><strong>切片确实发生了</strong>，但参数目前由 LlamaIndex 默认值决定。</p>
</li>
<li>
<p>现在系统的“切片质量”主要取决于：</p>
<ul>
<li>文档本身的结构（是否有清晰标题/段落）</li>
<li>LlamaIndex 默认 splitter 策略</li>
</ul>
</li>
</ul>
<h5 data-id="heading-12">切片优化方案（建议按阶段演进）</h5>
<ul>
<li><strong>结构化切片</strong>（推荐优先级最高）：按标题（如 Markdown 的 <code>#</code>/<code>##</code>）、段落分隔符、代码块边界切，减少“跨主题混片”。</li>
<li><strong>Overlap 增大</strong>：如果经常出现“关键句刚好切断”，增加 overlap 可以减少信息断裂。</li>
<li><strong>语义切片</strong>：对长文档先做主题边界识别，再切 chunk，减少噪声召回。</li>
<li><strong>专门为对话记忆设计切片</strong>：现在是一轮对话写成一个 Document（见长期记忆部分），这类数据天然短而密，通常不需要再细切；但如果一轮回答很长，可考虑把一轮对话拆为多段并共享 metadata（如同一 <code>conversationId</code>）。</li>
</ul>
<hr/>
<h4 data-id="heading-13">3. 向量化（Embedding）与存储（Vector Store）</h4>
<h5 data-id="heading-14">向量化模型（Embedding Model）</h5>
<p>这里<strong>不是 DeepSeek Embedding API</strong>，而是本地 HuggingFace Embedding：</p>
<pre><code class="hljs language-arduino" lang="arduino">Settings.embedModel = <span class="hljs-keyword">new</span> <span class="hljs-built_in">HuggingFaceEmbedding</span>({
  modelType: <span class="hljs-string">"Xenova/all-MiniLM-L6-v2"</span>,
  quantized: <span class="hljs-literal">false</span>
});
</code></pre>
<p>位置：<code>rag/LlamaIndex/backend/services/ragService.js:40-43</code></p>
<p>同时为网络环境设置了镜像（用于模型下载）：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">env.remoteHost</span> = <span class="hljs-string">"https://hf-mirror.com"</span><span class="hljs-comment">;</span>
<span class="hljs-attr">env.remoteTemplate</span> = <span class="hljs-string">"{model}/resolve/{revision}/{file}"</span><span class="hljs-comment">;</span>
</code></pre>
<p>位置：<code>rag/LlamaIndex/backend/services/ragService.js:7-8</code></p>
<h5 data-id="heading-15">存储模式：Local / Qdrant</h5>
<p>通过环境变量切换：</p>
<ul>
<li><code>VECTOR_STORE_TYPE=local</code>：落在本地 JSON</li>
<li><code>VECTOR_STORE_TYPE=qdrant</code>：落在 Qdrant（失败会 fallback 到 local）</li>
</ul>
<p>逻辑位置：<code>rag/LlamaIndex/backend/services/ragService.js:63-81</code></p>
<p>Local 模式下的持久化目录是：</p>
<ul>
<li><code>rag/LlamaIndex/backend/storage/</code></li>
</ul>
<h5 data-id="heading-16">如何查看“向量化存储内容”</h5>
<p>在 Local 模式下，最直接可读的文件是：</p>
<ul>
<li><code>backend/storage/doc_store.json</code>：原始文本（切片/对话记忆）内容</li>
<li><code>backend/storage/index_store.json</code>：索引结构信息</li>
<li><code>backend/storage/vector_store_default.json</code>（或类似）：向量本体（大量数值，不太适合人读，但可以确认存在与规模）</li>
</ul>
<p>写入持久化发生在长期记忆写入时（见后文），位置：<code>rag/LlamaIndex/backend/services/ragService.js:159-190</code></p>
<hr/>
<h3 data-id="heading-17">RAG 实现剖析：第二阶段（运行时检索）</h3>
<p>当用户每次提问时，会执行一次向量召回。</p>
<h4 data-id="heading-18">1. 召回逻辑：TopK 相似检索</h4>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">retriever</span> = index.asRetriever({ similarityTopK: <span class="hljs-number">5</span> })<span class="hljs-comment">;</span>
const <span class="hljs-attr">nodes</span> = await retriever.retrieve(queryText)<span class="hljs-comment">;</span>
return nodes.map(<span class="hljs-attr">node</span> =&gt; node.node.text).join(<span class="hljs-string">"\n\n"</span>)<span class="hljs-comment">;</span>
</code></pre>
<p>位置：<code>rag/LlamaIndex/backend/services/ragService.js:135-141</code></p>
<p>这里的关键点：</p>
<ul>
<li><strong>TopK=5</strong>：每次最多取 5 条“最相近片段”</li>
<li>返回的是纯文本拼接，作为后续 System Prompt 的“背景信息”</li>
</ul>
<h4 data-id="heading-19">2. 召回的数据来源：知识库 + 历史对话</h4>
<p>因为把“历史对话”也写进了同一个向量索引（见长期记忆写入），所以检索结果可能混合：</p>
<ul>
<li><code>backend/data/</code> 里的知识文档切片</li>
<li>用户历史对话（<code>User:...\nAssistant:...</code>）</li>
</ul>
<p>这也是为什么你在浏览器 Console 看到的 <code>systemPrompt</code> 背景信息里会出现很多轮对话文本。</p>
<hr/>
<h3 data-id="heading-20">RAG 实现剖析：第三阶段（生成回复）</h3>
<h4 data-id="heading-21">1. 增强提示词（System Prompt）的构造规则</h4>
<p>非流式接口 <code>/api/chat</code> 的 System Prompt 组装：</p>
<pre><code class="hljs language-ini" lang="ini">let <span class="hljs-attr">systemPrompt</span> = <span class="hljs-string">"你是一个智能助手。"</span><span class="hljs-comment">;</span>
if (context) {
  systemPrompt += `请基于以下提供的背景信息（Context）来回答用户的问题。这些背景信息可能包含相关的知识文档或过去的历史对话记录。如果背景信息与问题无关，请忽略它。\n背景信息：\n${context}`<span class="hljs-comment">;</span>
}
const <span class="hljs-attr">systemMessage</span> = { role: <span class="hljs-string">'system'</span>, content: systemPrompt }<span class="hljs-comment">;</span>
</code></pre>
<p>位置：<code>rag/LlamaIndex/backend/server.js:100-112</code></p>
<p><strong>组成结论（非常关键）</strong> ：</p>
<ul>
<li><code>systemPrompt</code> = “基础系统指令” + “RAG 检索出来的 context（可为空）”</li>
<li><code>systemPrompt</code> <strong>不包含</strong> SQLite 的最近 5 条对话，它们是作为单独 message 插入的（下一段）</li>
</ul>
<h4 data-id="heading-22">2. 最终发送给模型的消息列表组成</h4>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">dbHistory</span> = chatHistoryService.getHistory(sessionId, <span class="hljs-number">5</span>)<span class="hljs-comment">;</span>

const <span class="hljs-attr">finalMessages</span> = [
  systemMessage,
  ...dbHistory,
  { role: <span class="hljs-string">'user'</span>, content: lastMsg.content }
]<span class="hljs-comment">;</span>
</code></pre>
<p>位置：<code>rag/LlamaIndex/backend/server.js:90-118</code></p>
<p>所以项目中“喂给模型的上下文”来自两条管线：</p>
<ul>
<li><strong>长期记忆（RAG）</strong> ：进 <code>systemPrompt</code></li>
<li><strong>短期记忆（SQLite 最近 5 条）</strong> ：以 <code>messages</code> 数组形式送入模型（更接近“对话上下文”）</li>
</ul>
<h4 data-id="heading-23">3. 将系统提示词暴露给浏览器 Console</h4>
<h5 data-id="heading-24">非流式：直接回传给前端</h5>
<pre><code class="hljs language-php" lang="php">res.<span class="hljs-title function_ invoke__">json</span>({
  <span class="hljs-attr">role</span>: <span class="hljs-string">'assistant'</span>,
  <span class="hljs-attr">content</span>: responseContent,
  <span class="hljs-attr">systemPrompt</span>: systemPrompt
});
</code></pre>
<p>位置：<code>rag/LlamaIndex/backend/server.js:136-142</code></p>
<p>前端打印：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">group</span>(<span class="hljs-string">"🔍 [DeepSeek Chat] RAG Debug Info"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"User Prompt:"</span>, ...);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"System Prompt (with RAG Context):"</span>, response.<span class="hljs-property">data</span>.<span class="hljs-property">systemPrompt</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">groupEnd</span>();
</code></pre>
<p>位置：<code>rag/LlamaIndex/frontend/src/App.jsx:60-85</code></p>
<h5 data-id="heading-25">流式：在 SSE 开头先发一条 debug 包</h5>
<pre><code class="hljs language-typescript" lang="typescript">res.<span class="hljs-title function_">write</span>(<span class="hljs-string">`data: <span class="hljs-subst">${<span class="hljs-built_in">JSON</span>.stringify({ <span class="hljs-keyword">type</span>: <span class="hljs-string">'debug'</span>, systemPrompt })}</span>\n\n`</span>);
</code></pre>
<p>位置：<code>rag/LlamaIndex/backend/server.js:198-213</code></p>
<p>前端解析：</p>
<pre><code class="hljs language-ini" lang="ini">if (<span class="hljs-attr">parsed.type</span> === <span class="hljs-string">'debug'</span> &amp;&amp; parsed.systemPrompt) {
  console.group("🔍 <span class="hljs-section">[DeepSeek Chat Stream]</span> RAG Debug Info")<span class="hljs-comment">;</span>
  console.log("User Prompt:", ...)<span class="hljs-comment">;</span>
  console.log("System Prompt (with RAG Context):", parsed.systemPrompt)<span class="hljs-comment">;</span>
  console.groupEnd()<span class="hljs-comment">;</span>
  continue<span class="hljs-comment">;</span>
}
</code></pre>
<p>位置：<code>rag/LlamaIndex/frontend/src/App.jsx:127-137</code></p>
<p>这实现了要的：在浏览器控制台完整观察“系统提示词 + 用户提示词”。</p>
<hr/>
<h3 data-id="heading-26">长期记忆（Long-term Memory）在您项目里是怎么实现的？</h3>
<h4 data-id="heading-27">1. 写入规则：每轮对话结束就写入向量库</h4>
<p>当 <code>/api/chat</code> 拿到模型回答后，会调用：</p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-keyword">await</span> ragService.insertChatLog(lastMsg.content, responseContent);
</code></pre>
<p>位置：<code>rag/LlamaIndex/backend/server.js:133-135</code></p>
<h4 data-id="heading-28">2. 写入内容格式：User + Assistant 合并成一个 Document</h4>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">text</span> = `User: <span class="hljs-variable">${userMsg}</span>\nAssistant: <span class="hljs-variable">${assistantMsg}</span>`<span class="hljs-comment">;</span>
const <span class="hljs-attr">doc</span> = new Document({ text, metadata: { type: <span class="hljs-string">'conversation'</span>, timestamp: ... }})<span class="hljs-comment">;</span>
await index.insert(doc)<span class="hljs-comment">;</span>
</code></pre>
<p>位置：<code>rag/LlamaIndex/backend/services/ragService.js:148-158</code></p>
<h4 data-id="heading-29">3. 持久化规则：Local 模式写到 storage/*.json</h4>
<p>插入后会持久化（Local）：</p>
<pre><code class="hljs language-scss" lang="scss">await storageContext<span class="hljs-selector-class">.docStore</span><span class="hljs-selector-class">.persist</span>(...doc_store.json)
await storageContext<span class="hljs-selector-class">.indexStore</span><span class="hljs-selector-class">.persist</span>(...index_store.json)
for (...) await store<span class="hljs-selector-class">.persist</span>(...vector_store_${key}.json)
</code></pre>
<p>位置：<code>rag/LlamaIndex/backend/services/ragService.js:159-190</code></p>
<hr/>
<h3 data-id="heading-30">与“标准三阶段 RAG”相比：项目有哪些关键差异？</h3>
<ul>
<li><strong>Embedding 不是 DeepSeek Embedding API</strong>：是本地 <code>HuggingFaceEmbedding</code>（更稳定、成本低，但模型选择需要自己评估准确率），见 <code>ragService.js:40-43</code>。</li>
<li><strong>Prompt 不仅有 RAG Context</strong>：额外注入了 SQLite 最近 5 条短期历史（作为 messages），见 <code>server.js:90-118</code>。</li>
<li><strong>长期记忆不是“拉历史记录 N 条”</strong> ：是把对话写入向量库，后续靠相似检索召回，见 <code>insertChatLog</code> 与 <code>retrieveContext</code>。</li>
<li><strong>可观测性加强</strong>：系统提示词会同时在后端终端打印（<code>server.js:105-109</code>/<code>183-187</code>）并在浏览器 Console 打印（<code>App.jsx:70-77</code>/<code>129-137</code>）。</li>
</ul>
<h2 data-id="heading-31">总结</h2>
<p>OK，就写到这儿了。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Netty（13）Netty中的事件和回调机制]]></title>    <link>https://juejin.cn/post/7584071941025693711</link>    <guid>https://juejin.cn/post/7584071941025693711</guid>    <pubDate>2025-12-16T12:19:46.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584071941025693711" data-draft-id="7584286241488093224" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Netty（13）Netty中的事件和回调机制"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2025-12-16T12:19:46.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Victor356"/> <meta itemprop="url" content="https://juejin.cn/user/3492507879476878"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Netty（13）Netty中的事件和回调机制
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3492507879476878/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Victor356
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-16T12:19:46.000Z" title="Tue Dec 16 2025 12:19:46 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-16
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读2分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在Netty中，事件和回调机制是实现异步和事件驱动编程的重要组成部分。Netty使用ChannelPipeline和ChannelHandler来处理事件和回调。</p>
<ol>
<li>事件：
Netty中的事件包括连接建立、数据接收、数据发送、连接关闭等。在处理这些事件时，通常需要实现ChannelHandler接口，并重写相应的方法来处理事件。下面是一个简单的示例代码：</li>
</ol>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span> {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-comment">// 连接建立事件</span>
        System.out.println(<span class="hljs-string">"Connection established"</span>);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-comment">// 数据接收事件</span>
        System.out.println(<span class="hljs-string">"Received data: "</span> + msg);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelReadComplete</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-comment">// 数据接收完成事件</span>
        System.out.println(<span class="hljs-string">"Data reception complete"</span>);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-comment">// 异常事件</span>
        System.out.println(<span class="hljs-string">"Exception caught: "</span> + cause.getMessage());
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelInactive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-comment">// 连接关闭事件</span>
        System.out.println(<span class="hljs-string">"Connection closed"</span>);
    }
}
</code></pre>
<p>在上面的示例中，我们创建了一个自定义的ChannelHandler类MyHandler，并重写了channelActive()、channelRead()、channelReadComplete()、exceptionCaught()和channelInactive()方法来处理连接建立、数据接收、数据接收完成、异常和连接关闭事件。</p>
<ol start="2">
<li>回调：
Netty中的回调机制通常用于异步操作的结果通知。当某个异步操作完成时，会调用相应的回调方法来处理操作的结果。下面是一个简单的示例代码：</li>
</ol>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">import</span> io.netty.channel.ChannelFuture;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelFutureListener;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span> {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-comment">// 异步操作</span>
        <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">future</span> <span class="hljs-operator">=</span> ctx.writeAndFlush(<span class="hljs-string">"Hello, Netty!"</span>);

        <span class="hljs-comment">// 注册回调</span>
        future.addListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelFutureListener</span>() {
            <span class="hljs-meta">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operationComplete</span><span class="hljs-params">(ChannelFuture future)</span> <span class="hljs-keyword">throws</span> Exception {
                <span class="hljs-keyword">if</span> (future.isSuccess()) {
                    System.out.println(<span class="hljs-string">"Data sent successfully"</span>);
                } <span class="hljs-keyword">else</span> {
                    System.out.println(<span class="hljs-string">"Failed to send data"</span>);
                }
            }
        });
    }
}
</code></pre>
<p>在上面的示例中，我们在channelActive()方法中执行了一个异步操作ctx.writeAndFlush()，并通过addListener()方法注册了一个回调监听器ChannelFutureListener。当异步操作完成时，会调用回调方法operationComplete()来处理操作的结果。</p>
<p>通过事件和回调机制，Netty能够高效地处理各种网络事件和异步操作。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Netty（14）如何处理Netty中的异常和错误？]]></title>    <link>https://juejin.cn/post/7584266184882241570</link>    <guid>https://juejin.cn/post/7584266184882241570</guid>    <pubDate>2025-12-16T12:21:05.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584266184882241570" data-draft-id="7584243498528260096" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Netty（14）如何处理Netty中的异常和错误？"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2025-12-16T12:21:05.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Victor356"/> <meta itemprop="url" content="https://juejin.cn/user/3492507879476878"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Netty（14）如何处理Netty中的异常和错误？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3492507879476878/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Victor356
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-16T12:21:05.000Z" title="Tue Dec 16 2025 12:21:05 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-16
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读2分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在Netty中，可以通过实现ChannelHandler的exceptionCaught()方法来处理异常和错误。该方法会在发生异常时被调用，可以在其中进行异常处理和错误处理逻辑。下面是一个示例代码：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span> {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-comment">// 异常处理逻辑</span>
        System.out.println(<span class="hljs-string">"Exception caught: "</span> + cause.getMessage());

        <span class="hljs-comment">// 发生异常时，关闭连接</span>
        ctx.close();
    }
}
</code></pre>
<p>在上面的示例中，我们创建了一个自定义的ChannelHandler类MyHandler，并重写了exceptionCaught()方法来处理异常。在异常处理逻辑中，我们可以根据具体的业务需求进行相应的处理，比如打印异常信息、记录日志、发送错误响应等。</p>
<p>在异常处理逻辑中，我们也可以选择关闭连接来终止与客户端的通信。通过调用ctx.close()方法，可以主动关闭与客户端的连接，释放相关的资源。</p>
<p>另外，为了更好地捕获异常和错误，还可以使用ChannelFuture的addListener()方法来注册回调监听器，以便在异步操作失败时处理异常。下面是一个示例代码：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">import</span> io.netty.channel.ChannelFuture;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelFutureListener;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span> {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-comment">// 异步操作</span>
        <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">future</span> <span class="hljs-operator">=</span> ctx.writeAndFlush(<span class="hljs-string">"Hello, Netty!"</span>);

        <span class="hljs-comment">// 注册回调</span>
        future.addListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelFutureListener</span>() {
            <span class="hljs-meta">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operationComplete</span><span class="hljs-params">(ChannelFuture future)</span> <span class="hljs-keyword">throws</span> Exception {
                <span class="hljs-keyword">if</span> (future.isSuccess()) {
                    System.out.println(<span class="hljs-string">"Data sent successfully"</span>);
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-comment">// 异常处理逻辑</span>
                    System.out.println(<span class="hljs-string">"Failed to send data: "</span> + future.cause().getMessage());

                    <span class="hljs-comment">// 发生异常时，关闭连接</span>
                    future.channel().close();
                }
            }
        });
    }
}
</code></pre>
<p>在上面的示例中，我们在channelActive()方法中执行了一个异步操作ctx.writeAndFlush()，并通过addListener()方法注册了一个回调监听器ChannelFutureListener。当异步操作完成时，会调用回调方法operationComplete()来处理操作的结果。如果操作失败，我们可以在回调方法中处理异常，并关闭连接。</p>
<p>通过合理处理异常和错误，可以提高Netty应用程序的稳定性和可靠性。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[JUnit 5 中的 @ClassTemplate 实战指南]]></title>    <link>https://juejin.cn/post/7584295332340252735</link>    <guid>https://juejin.cn/post/7584295332340252735</guid>    <pubDate>2025-12-16T12:52:01.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584295332340252735" data-draft-id="7584289165754105910" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="JUnit 5 中的 @ClassTemplate 实战指南"/> <meta itemprop="keywords" content="Java,后端"/> <meta itemprop="datePublished" content="2025-12-16T12:52:01.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="程序猿DD"/> <meta itemprop="url" content="https://juejin.cn/user/131597123993358"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            JUnit 5 中的 @ClassTemplate 实战指南
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/131597123993358/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    程序猿DD
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-16T12:52:01.000Z" title="Tue Dec 16 2025 12:52:01 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-16
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>当你在本地、测试环境和 CI 中跑同一组测试时，是否遇到过这样的困惑：同一段业务逻辑在不同配置、不同 Locale 下的表现不尽相同，但你又不想为每种场景复制一堆几乎一样的测试类？如果把所有分支逻辑都塞进一个测试方法里，又会让测试变得臃肿难以维护。有没有一种方式，可以让测试代码保持简洁，却能优雅地在多种“环境切面”下重复执行整套测试？这正是 JUnit 5 中 <code>@ClassTemplate</code> 想要解决的问题。本文就从这个现实场景出发，带你深入理解 Class Template 的执行机制、扩展点设计以及一个实用的多 Locale 示例。</p>
<h2 data-id="heading-0">1. 引言</h2>
<p>有些测试需要在不同的环境中运行。<code>@ClassTemplate</code> 注解可以帮我们做到这一点：它会让整个测试类在多种不同配置下被重复执行。</p>
<p>在这篇教程中，我们会先讨论为什么会有“类模板（Class Template）”这种机制，以及 JUnit 是如何执行它们的；接着会看看它在整体执行模型中的位置；最后，我们会拆解类模板的结构、背后的提供者（provider），并通过一个示例，在不复制任何测试代码的前提下，让同一个测试类在多个 Locale 环境下运行。</p>
<h2 data-id="heading-1">2. 什么是 <code>@ClassTemplate</code></h2>
<p>简单回顾一下，<code>@ClassTemplate</code> 会把一个测试类变成“模板类”，让它按照不同的调用上下文（invocation context）多次执行。提供者负责提供这些上下文，每一个上下文都会触发一次独立的执行，拥有各自的生命周期和扩展。</p>
<p>在实践中，这让我们可以<strong>在不同环境或配置下多次运行同一个测试类，同时保持测试代码本身的简单性</strong>。我们可以改变运行时的环境配置，而不用复制测试类，或者在单个测试方法里加入复杂的分支逻辑。</p>
<h3 data-id="heading-2">2.1. Class Template 如何执行</h3>
<p>一个类模板由两部分组成：<strong>模板类本身，以及为其提供调用上下文的提供者</strong>。模板类在外观上就像一个普通的 JUnit 测试类，但 <code>@ClassTemplate</code> 注解会告诉 JUnit 不要直接运行它，而是等待提供者来定义该类的具体执行方式。</p>
<p>一旦 JUnit 识别出某个类是类模板，提供者就会返回一个或多个上下文，每个上下文都定义了一次完整的执行。对于每个上下文，<strong>JUnit 都会创建一个新的测试实例，应用对应的扩展，并执行生命周期方法和测试方法</strong>。这样，测试类可以专注于业务逻辑本身，而由提供者来塑造运行时环境。</p>
<h3 data-id="heading-3">2.2. Class Template 与 Method Template 对比</h3>
<p>在继续之前，值得先对比一下类模板和方法模板（method template）之间的区别。两者都支持重复执行，但关注的层级不同。方法模板会在不同输入下重复执行<strong>同一个测试方法</strong>；而类模板则会重复执行<strong>整个测试类</strong>，包括它的生命周期回调、扩展以及配置。</p>
<p>因此，当变化点主要体现在整体环境层面——例如 Locale、特性开关或系统级配置——而不是单个方法参数时，<strong>类模板会更加合适</strong>。</p>
<h2 data-id="heading-4">3. 调用上下文提供者</h2>
<p>接下来，我们看看“调用上下文提供者（invocation context provider）”。<strong>这个扩展负责为类模板提供执行上下文</strong>。它需要实现 <code>ClassTemplateInvocationContextProvider</code> 接口，该接口定义了两个核心方法，用来决定提供者如何参与测试执行。</p>
<p>下面我们分别来看。</p>
<h3 data-id="heading-5">3.1. <code>supportsClassTemplate()</code> 方法</h3>
<p>在 JUnit 使用某个提供者之前，它会先检查该提供者是否适用于当前正在发现的测试类。这个检查就是通过 <code>supportsClassTemplate()</code> 方法完成的：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">supportsClassTemplate</span><span class="hljs-params">(ExtensionContext context)</span> {
    <span class="hljs-keyword">return</span> context.getTestClass()
        .map(aClass -&gt; aClass.isAnnotationPresent(ClassTemplate.class))
        .orElse(<span class="hljs-literal">false</span>);
}
</code></pre>
<p>JUnit 会对每一个已注册的提供者调用这个方法。只有返回 <code>true</code> 的提供者才会对当前类模板生效。通过这种机制，JUnit 可以<strong>避免提供者被意外激活，避免在无关测试上运行扩展，同时也允许多个提供者并存而互不干扰</strong>。</p>
<h3 data-id="heading-6">3.2. <code>provideClassTemplateInvocationContexts()</code> 方法</h3>
<p>一旦某个提供者被激活，JUnit 就会调用 <code>provideClassTemplateInvocationContexts()</code>，以获取描述模板执行方式的上下文：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> Stream&lt;ClassTemplateInvocationContext&gt; <span class="hljs-title function_">provideClassTemplateInvocationContexts</span><span class="hljs-params">(ExtensionContext context)</span> {
    <span class="hljs-keyword">return</span> Stream.of(invocationContext(<span class="hljs-string">"A"</span>), invocationContext(<span class="hljs-string">"B"</span>));
}
</code></pre>
<p><strong>每一个上下文都代表了一次对测试类的完整执行</strong>。单个提供者可以提供一个或多个上下文；如果同时有多个提供者处于激活状态，JUnit 会把它们提供的流拼接起来。每个上下文都可以添加自己的扩展或配置，从而让提供者可以对该次执行的环境进行精细控制。</p>
<p>从这里开始，<strong>JUnit 会为每个上下文创建一个新的测试类实例，应用对应的扩展，并完整运行生命周期方法和测试方法各一次</strong>。</p>
<h2 data-id="heading-7">4. 实用示例</h2>
<p>为了更直观地理解这些概念，我们来构造一个示例：编写一个测试，用来验证在多个 JVM Locale 下的日期格式化逻辑。由于 Locale 会影响整个执行环境，这类需求非常适合用类模板来实现。我们只保留<strong>一个</strong>测试类，然后让提供者在不同配置下多次执行它。</p>
<h3 data-id="heading-8">4.1. 日期格式化逻辑</h3>
<p>首先，从一个小工具类开始，它使用当前 JVM 默认 Locale 来格式化日期。只要默认 Locale 发生变化，它的输出就会随之改变：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DateFormatter</span> {

    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">format</span><span class="hljs-params">(LocalDate date)</span> {
        <span class="hljs-type">DateTimeFormatter</span> <span class="hljs-variable">formatter</span> <span class="hljs-operator">=</span> DateTimeFormatter.ofLocalizedDate(FormatStyle.LONG)
            .withLocale(Locale.getDefault());

        <span class="hljs-keyword">return</span> date.format(formatter);
    }
}
</code></pre>
<p>有了这个类之后，我们就可以在多种不同的配置下验证它的行为，而这些配置都由类模板来提供。</p>
<h3 data-id="heading-9">4.2. 提供者与扩展</h3>
<p>为了支撑上述需求，我们首先需要一个扩展，用来在单次执行期间设置默认 Locale：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LocaleExtension</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeforeEachCallback</span>, AfterEachCallback {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Locale locale;
    <span class="hljs-keyword">private</span> Locale previous;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeEach</span><span class="hljs-params">(ExtensionContext context)</span> {
        previous = Locale.getDefault();
        Locale.setDefault(locale);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterEach</span><span class="hljs-params">(ExtensionContext context)</span> {
        Locale.setDefault(previous);
    }
}
</code></pre>
<p>这个扩展会在每次测试之前暂时替换 JVM 的默认 Locale，并在测试结束后恢复原有值。<strong>在不同执行之间唯一变化的，就是传入该扩展的 <code>Locale</code> 实例。</strong></p>
<p>接下来，提供者会通过 <code>provideClassTemplateInvocationContexts()</code> 方法来提供不同的上下文。每个上下文都由 <code>invocationContext()</code> 方法创建，该方法通过 <code>getDisplayName()</code> 指定显示名，并通过 <code>getAdditionalExtensions()</code> 安装对应的 <code>LocaleExtension</code>：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DateLocaleClassTemplateProvider</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ClassTemplateInvocationContextProvider</span> {

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> Stream&lt;ClassTemplateInvocationContext&gt; <span class="hljs-title function_">provideClassTemplateInvocationContexts</span><span class="hljs-params">(ExtensionContext context)</span> {
        <span class="hljs-keyword">return</span> Stream.of(Locale.US, Locale.GERMANY, Locale.ITALY, Locale.JAPAN)
            .map(<span class="hljs-built_in">this</span>::invocationContext);
    }

    <span class="hljs-keyword">private</span> ClassTemplateInvocationContext <span class="hljs-title function_">invocationContext</span><span class="hljs-params">(Locale locale)</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassTemplateInvocationContext</span>() {

            <span class="hljs-meta">@Override</span>
            <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getDisplayName</span><span class="hljs-params">(<span class="hljs-type">int</span> invocationIndex)</span> {
                <span class="hljs-keyword">return</span> <span class="hljs-string">"Locale: "</span> + locale.getDisplayName();
            }

            <span class="hljs-meta">@Override</span>
            <span class="hljs-keyword">public</span> List&lt;Extension&gt; <span class="hljs-title function_">getAdditionalExtensions</span><span class="hljs-params">()</span> {
                <span class="hljs-keyword">return</span> List.of(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LocaleExtension</span>(locale));
            }
        };
    }
}
</code></pre>
<p>通过这样的配置，我们就得到了互不相同的执行环境，最终会对同一个测试类执行四次测试。</p>
<h3 data-id="heading-10">4.3. Class Template 测试</h3>
<p>此时，类模板的整体配置已经就位，我们就可以专注于编写一个测试方法了。JUnit 会通过前面配置好的提供者，为每个上下文执行一次这个方法：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">DateFormatter</span> <span class="hljs-variable">formatter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DateFormatter</span>();

<span class="hljs-meta">@Test</span>
<span class="hljs-keyword">void</span> <span class="hljs-title function_">givenDefaultLocale_whenFormattingDate_thenMatchesLocalizedOutput</span><span class="hljs-params">()</span> {
    <span class="hljs-type">LocalDate</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> LocalDate.of(<span class="hljs-number">2025</span>, <span class="hljs-number">9</span>, <span class="hljs-number">30</span>);

    <span class="hljs-type">DateTimeFormatter</span> <span class="hljs-variable">expectedFormatter</span> <span class="hljs-operator">=</span> DateTimeFormatter.ofLocalizedDate(FormatStyle.LONG)
        .withLocale(Locale.getDefault());

    <span class="hljs-type">String</span> <span class="hljs-variable">expected</span> <span class="hljs-operator">=</span> date.format(expectedFormatter);
    <span class="hljs-type">String</span> <span class="hljs-variable">formatted</span> <span class="hljs-operator">=</span> formatter.format(date);

    LOG.info(<span class="hljs-string">"Locale: {}, Expected: {}, Formatted: {}"</span>, Locale.getDefault(), expected, formatted);

    assertEquals(expected, formatted);
}
</code></pre>
<p>在每次执行中，测试都会基于当前默认 Locale 计算预期值，并与 <code>DateFormatter</code> 的输出进行比较。<strong>类模板和提供者负责在每次执行之间切换环境设置</strong>，因此测试代码本身可以保持简单、干净，不需要任何分支逻辑。</p>
<h3 data-id="heading-11">4.4. 测试输出</h3>
<p>最后，当我们运行这组测试时，同一个测试类会在每个 Locale 下执行一次，而每次的格式化结果都不相同：</p>
<pre><code class="hljs language-text" lang="text">Locale: en_US, Expected: September 30, 2025, Formatted: September 30, 2025
Locale: de_DE, Expected: 30. September 2025, Formatted: 30. September 2025
Locale: it_IT, Expected: 30 settembre 2025, Formatted: 30 settembre 2025
Locale: ja_JP, Expected: 2025年9月30日, Formatted: 2025年9月30日
</code></pre>
<p>可以看到，每一行都对应于一个调用上下文。测试代码在这些运行之间完全没有变化；变化的只是由提供者和扩展配置出来的执行环境。</p>
<h2 data-id="heading-12">5. 总结</h2>
<p>在本文中，我们从基础概念出发，进一步深入了 <code>@ClassTemplate</code> 的使用方式，重点考察了提供者如何为单个测试类提供多个执行上下文。通过 Locale 示例，我们看到提供者和扩展可以在不修改测试代码的前提下灵活地切换测试环境。这使得类模板<strong>成为处理全局设置或配置级行为测试的一种干净而优雅的解决方案</strong>。感谢阅读，如果您对Java内容感兴趣，也可以关注我的<a href="https://link.juejin.cn?target=https%3A%2F%2Fspring4all.com%2Ftags%2Fjava" target="_blank" title="https://spring4all.com/tags/java" ref="nofollow noopener noreferrer">Java专题</a>内容。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Vercel AI SDK：构建现代 Web AI 应用指南]]></title>    <link>https://juejin.cn/post/7584289165754155062</link>    <guid>https://juejin.cn/post/7584289165754155062</guid>    <pubDate>2025-12-16T12:52:07.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584289165754155062" data-draft-id="7584273076646264838" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Vercel AI SDK：构建现代 Web AI 应用指南"/> <meta itemprop="keywords" content="前端,AIGC"/> <meta itemprop="datePublished" content="2025-12-16T12:52:07.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="奇舞精选"/> <meta itemprop="url" content="https://juejin.cn/user/4388906147515367"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Vercel AI SDK：构建现代 Web AI 应用指南
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4388906147515367/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    奇舞精选
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-16T12:52:07.000Z" title="Tue Dec 16 2025 12:52:07 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-16
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">简介</h2>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/41660f289c874d41be4751f8d93e894e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aWH6Iie57K-6YCJ:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766494327&amp;x-signature=5h0WgpbEX%2FvyTrgAiVHcTwL2TUE%3D" alt="" loading="lazy"/>
随着大语言模型（LLM）越来越普及，将它们集成到 Web 应用、聊天机器人等场景中成为很多开发者的诉求。但不同模型提供商（DeepSeek、OpenAI、Anthropic、Google 等）在接口、请求方式、返回格式等方面差异很大。 此外，不同 Web 框架（React／Next.js、Vue／Nuxt、Node.js 等）也带来了兼容性和工程复杂性。</p>
<p>Vercel 推出的 Vercel AI SDK，旨在通过 <strong>统一 API + 框架无关 UI 组件 + 多模型适配器</strong> 的设计，将 “调用 LLM + 构建对话/生成 UI” 的复杂性封装起来，让开发者可以更专注于业务逻辑，而不必过多关注模型和框架差异。换句话说，Vercel AI SDK 是为“把 AI（LLM）接入现代 Web 应用” — 从原型到生产 — 提供一种标准、方便、高效的“中间层/基础设施”。如果你在做 ChatBot、知识库问答等项目时，Vercel AI SDK 能大幅降低上下游集成和工程复杂度。</p>
<p>当前，Vercel AI SDK 最新版本为 <strong>AI SDK 6</strong>，不过目前它处于 <strong>Beta 阶段</strong>。如果你不想用 Beta 版本，可以继续使用稳定版，即 AI SDK 5。</p>
<p>Vercel AI SDK 官网：<a href="https://link.juejin.cn?target=https%3A%2F%2Fai-sdk.dev%2F" target="_blank" title="https://ai-sdk.dev/" ref="nofollow noopener noreferrer">ai-sdk.dev</a></p>
<p>Vercel AI SDK 开源地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fvercel%2Fai" target="_blank" title="https://github.com/vercel/ai" ref="nofollow noopener noreferrer">github.com/vercel/ai</a></p>
<h2 data-id="heading-1">核心模块</h2>
<p><strong>AI SDK Core</strong></p>
<p>提供统一 API 用于调用语言模型／生成文本、结构化对象／数组、工具调用、流式响应等。通过统一接口屏蔽不同模型 Provider 的差异。SDK 本身不绑死任何模型，而是通过 Provider 机制适配众多模型提供商 (LLM)。如官方支持 DeepSeek、OpenAI、Anthropic、Google、xAI Grok 等，还支持自定义 Provider。</p>
<p><strong>AI SDK UI</strong></p>
<p>提供面向前端／前端框架 (React、Vue、Svelte、Angular 等) 的 hooks 或组件 (如 <code>useChat</code>, <code>useCompletion</code> 等)，方便构建聊天界面、生成式 UI、流式聊天界面、Agent UI 等。可以在多种前端架构中复用。</p>
<h2 data-id="heading-2">各库 (Package) 功能职责与适用场景</h2>
<h3 data-id="heading-3"><code>ai</code> — Core SDK</h3>
<ul>
<li>Core 核心包，提供统一、框架无关的 API，用于调用任意兼容 Provider 的 LLM</li>
<li>支持基础用例：文本生成、结构化数据生成、流式响应 (streaming)</li>
<li>支持多模型，通过 Provider Adapter 机制，如 <code>@ai-sdk/openai</code>) 来适配各家模型，将它们在统一的接口下抽象。</li>
</ul>
<p><strong>何时使用</strong><code>ai</code>：</p>
<ul>
<li>你需要后端 / API route 等调用 LLM、生成文本、结构化输出、执行工具调用 (例如调用外部 API、数据库、文件系统等)，并将结果处理、存储、转发</li>
<li>构建 “Workflow / 后端服务 / CLI 工具 ” 等，不需要前端 UI</li>
<li>跨 Provider (DeepSeek / OpenAI / Google / Anthropic ) 编写通用逻辑，不想为每个提供商写独立处理。</li>
</ul>
<p><strong>如何安装 / 依赖</strong>：</p>
<pre><code class="hljs language-bash" lang="bash">npm install ai
</code></pre>
<h3 data-id="heading-4"><code>@ai-sdk/openai</code> — OpenAI Provider 适配包</h3>
<ul>
<li>“模型 Provider 适配包” — 用于当你希望使用 OpenAI (或兼容 OpenAI API) 作为 LLM Provider 时，把 OpenAI 整合进 Core；它实现了 Provider 接口。</li>
<li>提供对 OpenAI 规范功能的封装。</li>
</ul>
<p><strong>何时使用</strong><code>@ai-sdk/openai</code>：</p>
<ul>
<li>你计划用 OpenAI 的模型 (GPT-4, GPT-4o, GPT-5, 其他 OpenAI 模型) 作为你的 LLM。</li>
<li>你计划用 兼容 OpenAI 接口规范的模型作为你的 LLM。</li>
</ul>
<p><strong>如何安装</strong>：</p>
<pre><code class="hljs language-bash" lang="bash">npm install @ai-sdk/openai
</code></pre>
<p>同时你还需要 <code>ai</code> (core) 才能一起使用。</p>
<p><strong>示例</strong>：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> { generateText } <span class="hljs-keyword">from</span> <span class="hljs-string">'ai'</span>;
<span class="hljs-keyword">import</span> { openai } <span class="hljs-keyword">from</span> <span class="hljs-string">'@ai-sdk/openai'</span>;

<span class="hljs-keyword">const</span> { text } = <span class="hljs-keyword">await</span> <span class="hljs-title function_">generateText</span>({
  <span class="hljs-attr">model</span>: <span class="hljs-title function_">openai</span>(<span class="hljs-string">'gpt-4o'</span>),
  <span class="hljs-attr">prompt</span>: <span class="hljs-string">'介绍一下 Vercel AI SDK'</span>,
});
</code></pre>
<h3 data-id="heading-5"><code>@ai-sdk/react</code> — React UI 层</h3>
<ul>
<li>为 React 应用 (包括基于 React 的框架，如 Next.js) 提供 UI 层抽象 (hooks / 组件)，方便在前端构建聊天 UI /生成 UI /流式 UI。</li>
<li>常见提供的 hook 包括 <code>useChat</code>, <code>useCompletion</code>, <code>useObject</code> 等 —— 它们封装了状态管理 (Messages 列表、用户输入、提交、Request/Response 状态)、UI 更新、与后端 (或由 <code>ai</code> 包提供的 API) 的交互流程。</li>
<li>支持与 <code>ai</code> + Provider 组合使用，通过前端 + 后端 构建完整的 ChatBot 应用。</li>
</ul>
<p><strong>何时使用</strong><code>@ai-sdk/react</code>：</p>
<ul>
<li>你在做前端项目 (SPA / 静态网页 / Next.js / React) 并希望直接给用户展示交互界面 (聊天框、对话、生成内容、流式输出等)。</li>
<li>想快速构建 UI，不用自己从头管理请求 / 响应 /消息列表 /状态 /loading /streaming/ UI 更新。</li>
</ul>
<p><strong>如何安装</strong>：</p>
<pre><code class="hljs language-bash" lang="bash">npm install @ai-sdk/react
</code></pre>
<p><strong>示例 (React / Next.js)</strong>：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> { messages, sendMessage, status, error } = <span class="hljs-title function_">useChat</span>({
  <span class="hljs-attr">transport</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextStreamChatTransport</span>({
    <span class="hljs-attr">api</span>: <span class="hljs-string">"/api/chat"</span>,
  }),
});
</code></pre>
<p>后端（Next.js API route）使用 <code>ai</code> + <code>@ai-sdk/openai</code> 产生响应。</p>
<h2 data-id="heading-6">根据项目需求选择包</h2>
<ul>
<li>如果你的项目 <strong>只需要后端 / 对 LLM 进行调用 / 生成文本</strong> —— 只安装 <code>ai</code> + 对应 Provider (例如 <code>@ai-sdk/openai</code>)。</li>
<li>如果你的项目 <strong>涉及前端 / 用户交互 / Chat UI /对话界面 /生成 UI</strong> —— 那建议也加上 <code>@ai-sdk/react</code> (或视你前端框架为 <code>@ai-sdk/vue</code>, <code>@ai-sdk/svelte</code> 等) 来处理 UI/交互逻辑。</li>
<li><code>@ai-sdk/openai</code> (或其他 Provider 包) 是必须的，否则 <code>ai</code> 就不知道用哪家模型服务。</li>
</ul>
<h2 data-id="heading-7">快速上手</h2>
<p>以下是一个示例 "利用 Vercel AI SDK 构建简单聊天" 的实践。</p>
<h3 data-id="heading-8">步骤 1: 创建 Next.js 项目</h3>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 创建一个新的 Next.js 项目</span>
npx create-next-app@latest ai-chatbot

<span class="hljs-comment"># 进入项目目录</span>
<span class="hljs-built_in">cd</span> ai-chatbot
</code></pre>
<p>在创建过程中，选择以下选项：</p>
<ul>
<li>✅ TypeScript</li>
<li>✅ ESLint</li>
<li>✅ Tailwind CSS</li>
<li>✅ App Router</li>
<li>🔘 src/ directory (可选)</li>
<li>✅ Turbopack (可选)</li>
</ul>
<h3 data-id="heading-9">步骤 2: 安装 Vercel AI SDK 依赖</h3>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 安装核心包和 OpenAI Provider</span>
npm install ai @ai-sdk/openai @ai-sdk/react

<span class="hljs-comment"># 或者使用其他 Provider，例如:</span>
<span class="hljs-comment"># npm install ai @ai-sdk/anthropic @ai-sdk/react  # Anthropic Claude</span>
<span class="hljs-comment"># npm install ai @ai-sdk/google @ai-sdk/react     # Google Gemini</span>
</code></pre>
<h3 data-id="heading-10">步骤 3: 配置环境变量</h3>
<p>在项目根目录创建 <code>.env.local</code> 文件（这里我们使用Kimi）：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># OpenAI API Key</span>
OPENAI_API_KEY=your_kimi_api_key_here

<span class="hljs-comment"># 如果使用兼容 OpenAI 的服务（如 Kimi），可以配置基础 URL</span>
OPENAI_BASE_URL=https://api.moonshot.cn/v1
</code></pre>
<h3 data-id="heading-11">步骤 4: 创建后端 API Route</h3>
<p>创建文件 <code>app/api/chat/route.ts</code>：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">import</span> { openai } <span class="hljs-keyword">from</span> <span class="hljs-string">'@ai-sdk/openai'</span>;
<span class="hljs-keyword">import</span> { streamText } <span class="hljs-keyword">from</span> <span class="hljs-string">'ai'</span>;

<span class="hljs-comment">// 允许流式响应最多 30 秒</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> maxDuration = <span class="hljs-number">30</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">POST</span>(<span class="hljs-params">req: Request</span>) {
  <span class="hljs-comment">// 从请求体中提取消息</span>
  <span class="hljs-keyword">const</span> { messages } = <span class="hljs-keyword">await</span> req.<span class="hljs-title function_">json</span>();

  <span class="hljs-comment">// 调用 LLM 生成流式响应</span>
  <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">streamText</span>({
    <span class="hljs-attr">model</span>: <span class="hljs-title function_">openai</span>(<span class="hljs-string">'gpt-4o'</span>),
    messages
  });

  <span class="hljs-comment">// 返回流式响应</span>
  <span class="hljs-keyword">return</span> result.<span class="hljs-title function_">toTextStreamResponse</span>();
}
</code></pre>
<p><strong>如果使用 Kimi（兼容 OpenAI API）</strong>：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">import</span> { createOpenAI } <span class="hljs-keyword">from</span> <span class="hljs-string">"@ai-sdk/openai"</span>;
<span class="hljs-keyword">import</span> { streamText, convertToModelMessages } <span class="hljs-keyword">from</span> <span class="hljs-string">"ai"</span>;

<span class="hljs-comment">// 创建 Kimi Provider (Moonshot AI)</span>
<span class="hljs-keyword">const</span> kimiClient = <span class="hljs-title function_">createOpenAI</span>({
  <span class="hljs-attr">baseURL</span>: <span class="hljs-string">"https://api.moonshot.cn/v1"</span>,
  <span class="hljs-attr">apiKey</span>: process.<span class="hljs-property">env</span>.<span class="hljs-property">KIMI_API_KEY</span>,
});

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> maxDuration = <span class="hljs-number">30</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">POST</span>(<span class="hljs-params">req: Request</span>) {
  <span class="hljs-keyword">const</span> { messages } = <span class="hljs-keyword">await</span> req.<span class="hljs-title function_">json</span>();

  <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">streamText</span>({
    <span class="hljs-attr">model</span>: kimiClient.<span class="hljs-title function_">chat</span>(<span class="hljs-string">"moonshot-v1-8k"</span>),
    <span class="hljs-attr">messages</span>: <span class="hljs-title function_">convertToModelMessages</span>(messages),
  });
  <span class="hljs-keyword">return</span> result.<span class="hljs-title function_">toTextStreamResponse</span>();
}

</code></pre>
<h3 data-id="heading-12">步骤 5: 创建前端聊天页面</h3>
<p>修改 <code>app/page.tsx</code>：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-string">"use client"</span>;

<span class="hljs-keyword">import</span> { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;
<span class="hljs-keyword">import</span> { useChat } <span class="hljs-keyword">from</span> <span class="hljs-string">"@ai-sdk/react"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">TextStreamChatTransport</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"ai"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">ChatPage</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> [input, setInput] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">""</span>);
  <span class="hljs-keyword">const</span> { messages, sendMessage, status, error } = <span class="hljs-title function_">useChat</span>({
    <span class="hljs-attr">transport</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextStreamChatTransport</span>({
      <span class="hljs-attr">api</span>: <span class="hljs-string">"/api/chat"</span>,
    }),
  });

  <span class="hljs-keyword">const</span> isLoading = status === <span class="hljs-string">"streaming"</span> || status === <span class="hljs-string">"submitted"</span>;

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">main</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"flex min-h-screen flex-col items-center justify-between p-8"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"w-full max-w-2xl flex flex-col h-[80vh]"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"text-3xl font-bold mb-6 text-center"</span>&gt;</span>AI 聊天助手<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>

        {/* 消息列表 */}
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"flex-1 overflow-y-auto mb-4 space-y-4 p-4 bg-gray-50 rounded-lg"</span>&gt;</span>
          {messages.length === 0 &amp;&amp; (
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"text-center text-gray-500 mt-10"</span>&gt;</span>
              开始对话吧！向 AI 助手提问任何问题。
            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
          )}

          {messages.map((message) =&gt; {
            // 提取文本内容
            const textContent = message.parts
              ?.filter((part) =&gt; part.type === "text")
              .map((part) =&gt; part.text)
              .join("") || "";

            return (
              <span class="hljs-tag">&lt;<span class="hljs-name">div</span>
                <span class="hljs-attr">key</span>=<span class="hljs-string">{message.id}</span>
                <span class="hljs-attr">className</span>=<span class="hljs-string">{</span>`<span class="hljs-attr">flex</span> ${
                  <span class="hljs-attr">message.role</span> === <span class="hljs-string">"user"</span> ? "<span class="hljs-attr">justify-end</span>" <span class="hljs-attr">:</span> "<span class="hljs-attr">justify-start</span>"
                }`}
              &gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">div</span>
                  <span class="hljs-attr">className</span>=<span class="hljs-string">{</span>`<span class="hljs-attr">max-w-</span>[<span class="hljs-attr">80</span>%] <span class="hljs-attr">rounded-lg</span> <span class="hljs-attr">px-4</span> <span class="hljs-attr">py-2</span> ${
                    <span class="hljs-attr">message.role</span> === <span class="hljs-string">"user"</span>
                      ? "<span class="hljs-attr">bg-blue-500</span> <span class="hljs-attr">text-white</span>"
                      <span class="hljs-attr">:</span> "<span class="hljs-attr">bg-white</span> <span class="hljs-attr">text-gray-800</span> <span class="hljs-attr">border</span> <span class="hljs-attr">border-gray-200</span>"
                  }`}
                &gt;</span>
                  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"text-xs font-semibold mb-1 opacity-70"</span>&gt;</span>
                    {message.role === "user" ? "你" : "AI 助手"}
                  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
                  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"whitespace-pre-wrap"</span>&gt;</span>{textContent}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
              <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
            );
          })}

          {isLoading &amp;&amp; (
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"flex justify-start"</span>&gt;</span>
              <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"bg-white text-gray-800 border border-gray-200 rounded-lg px-4 py-2"</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"flex space-x-2"</span>&gt;</span>
                  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"w-2 h-2 bg-gray-400 rounded-full animate-bounce"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
                  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>
                    <span class="hljs-attr">className</span>=<span class="hljs-string">"w-2 h-2 bg-gray-400 rounded-full animate-bounce"</span>
                    <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">animationDelay:</span> "<span class="hljs-attr">0.1s</span>" }}
                  &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
                  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>
                    <span class="hljs-attr">className</span>=<span class="hljs-string">"w-2 h-2 bg-gray-400 rounded-full animate-bounce"</span>
                    <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">animationDelay:</span> "<span class="hljs-attr">0.2s</span>" }}
                  &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
              <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
          )}

          {error &amp;&amp; (
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"text-center text-red-500 p-4 bg-red-50 rounded-lg"</span>&gt;</span>
              错误：{error.message}
            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
          )}
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        {/* 输入表单 */}
        <span class="hljs-tag">&lt;<span class="hljs-name">form</span>
          <span class="hljs-attr">onSubmit</span>=<span class="hljs-string">{(e)</span> =&gt;</span> {
            e.preventDefault();
            if (input.trim()) {
              sendMessage({ text: input });
              setInput("");
            }
          }}
          className="flex gap-2"
        &gt;
          <span class="hljs-tag">&lt;<span class="hljs-name">input</span>
            <span class="hljs-attr">value</span>=<span class="hljs-string">{input}</span>
            <span class="hljs-attr">onChange</span>=<span class="hljs-string">{(e)</span> =&gt;</span> setInput(e.target.value)}
            placeholder="输入消息..."
            disabled={isLoading}
            className="flex-1 px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 disabled:bg-gray-100"
          /&gt;
          <span class="hljs-tag">&lt;<span class="hljs-name">button</span>
            <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>
            <span class="hljs-attr">disabled</span>=<span class="hljs-string">{isLoading</span> || !<span class="hljs-attr">input.trim</span>()}
            <span class="hljs-attr">className</span>=<span class="hljs-string">"px-6 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 disabled:bg-gray-300 disabled:cursor-not-allowed transition-colors"</span>
          &gt;</span>
            {isLoading ? "发送中..." : "发送"}
          <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span></span>
  );
}
</code></pre>
<h3 data-id="heading-13">步骤 6: 运行项目</h3>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 启动开发服务器</span>
npm run dev
</code></pre>
<p>访问 <code>http://localhost:3000</code>，你就可以看到一个完整的 AI 聊天界面了！效果展示：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/06ad1c4c89f849958f3db15eb42cb9f9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aWH6Iie57K-6YCJ:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766494327&amp;x-signature=JjAue6YF%2Ft93qsIO4NuFYnfB8v8%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-14">总结</h2>
<p>Vercel AI SDK 是目前 Web / JavaScript / TypeScript 生态中，将大语言模型 (LLM) 与现代前端 + 后端框架 (Next.js, React, Vue, Svelte, Node.js, Serverless 等) 整合得最完整、最方便、最全面的开源 SDK 之一。</p>
<ul>
<li>对于想快速构建聊天机器人、生成式应用、agent、文档分析、RAG 系统、多模态应用等的人来说，它大幅降低了技术门槛和工程成本；</li>
<li>对于需要支持多模型、多 provider、跨框架、跨运行时 (server / edge / frontend) 的项目，它提供了稳定、统一、可维护、可扩展的基础设施；</li>
<li>对于只是想在短时间内做原型 / MVP / demo，也非常友好。</li>
</ul>
<p>当然，对于极度定制、高性能、特殊模型 / 极端场景，你仍可能需要绕开 SDK，自己构建更底层或更专门化的方案。如果你 <strong>刚开始做 AI + Web 应用</strong> —— Vercel AI SDK 是一个非常推荐的 “最好实践 / 起点 / 基础设施”。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[GELab-Zero 技术解析：当豆包联手中兴，开源界如何守住端侧 AI 的“最后防线”？]]></title>    <link>https://juejin.cn/post/7584289165754171446</link>    <guid>https://juejin.cn/post/7584289165754171446</guid>    <pubDate>2025-12-16T12:52:58.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584289165754171446" data-draft-id="7584273076646281222" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="GELab-Zero 技术解析：当豆包联手中兴，开源界如何守住端侧 AI 的“最后防线”？"/> <meta itemprop="keywords" content="前端,AIGC"/> <meta itemprop="datePublished" content="2025-12-16T12:52:58.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="奇舞精选"/> <meta itemprop="url" content="https://juejin.cn/user/4388906147515367"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            GELab-Zero 技术解析：当豆包联手中兴，开源界如何守住端侧 AI 的“最后防线”？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4388906147515367/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    奇舞精选
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-16T12:52:58.000Z" title="Tue Dec 16 2025 12:52:58 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-16
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读23分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">引言</h2>
<p><strong>2025年12月，AI 端侧领域迎来了两大里程碑式突破，标志着端侧智能助手从"能不能用"迈向"能否规模化落地"的关键阶段。</strong></p>
<p>一方面，<strong>字节跳动豆包团队</strong>发布了豆包手机助手技术预览版，首次在手机端实现了持久化本地记忆与跨应用操作能力。特别是其与<strong>中兴手机</strong>的深度合作，通过系统级授权（如 nubia M153 工程样机）实现了语音、侧边键直接唤醒的便捷交互，引发了行业关于"互联网巨头+手机厂商"生态合作模式的热烈讨论。</p>
<p>近日，<strong>阶跃星辰</strong>开源了 <strong>GELab-Zero-4B-preview</strong> 模型及配套工程基建，实现了 4B 级参数模型在主流安卓设备上的轻量化部署。作为开源模型提供方，阶跃选择了赋能开发者的路线，通过提供完整的推理工程基建，解决安卓生态碎片化的难题。</p>
<p>本文将聚焦于开源界的代表作——<strong>GELab-Zero</strong>，通过一个真实的任务执行案例（Session ID: <code>1fe9db3f-92c8-4ae9-89bc-1d035d4bf59b</code>），深入剖析其技术架构、工作原理以及如何在消费级设备上实现 SOTA 级的 GUI 操作能力。</p>
<hr/>
<h2 data-id="heading-1">技术背景：端侧 AI 的战国时代</h2>
<h3 data-id="heading-2">1. 行业格局：三条路线的角逐</h3>
<p>当前手机端侧智能助手领域形成了多元化的竞争格局，主要厂商的技术路线和行业定位各有特色：</p>

































<table><thead><tr><th align="left">厂商类型</th><th align="left">代表厂商/产品</th><th align="left">模型规模</th><th align="left">技术路线特点</th><th align="left">行业定位</th></tr></thead><tbody><tr><td align="left"><strong>手机厂商</strong></td><td align="left"><strong>OPPO</strong> (AndesVL)<br/><strong>vivo</strong> (BlueLM)<br/><strong>华为</strong> (小艺)<br/><strong>荣耀</strong> (MagicGUI)</td><td align="left">0.6B-7B+</td><td align="left"><strong>系统级整合</strong>：多采用多模态模型，深度整合系统底层（如华为 NPU+鸿蒙，OPPO 潮汐引擎）。强调硬件协同与专属体验。</td><td align="left"><strong>系统级智能助理</strong><br/>打造"高效&amp;专属"的差异化体验</td></tr><tr><td align="left"><strong>互联网巨头</strong></td><td align="left"><strong>字节跳动</strong> (豆包)</td><td align="left">未公开</td><td align="left"><strong>轻量化工具+生态合作</strong>：具备端侧持久记忆和跨 App 操作能力。依赖与厂商（如中兴）的合作获得系统级权限。</td><td align="left"><strong>轻量化工具型助手</strong><br/>通过生态合作覆盖多品牌</td></tr><tr><td align="left"><strong>开源模型方</strong></td><td align="left"><strong>阶跃星辰</strong> (GELab-Zero)</td><td align="left">4B</td><td align="left"><strong>开源基建+通用兼容</strong>：提供完整的推理工程基建，解决 ADB 连接、依赖安装等"脏活累活"。支持一键部署。</td><td align="left"><strong>开发者赋能平台</strong><br/>降低端侧 Agent 开发门槛</td></tr></tbody></table>
<h3 data-id="heading-3">2. 深度案例解析：豆包 x 中兴 nubia 的集成机制</h3>
<p>豆包手机助手在中兴 nubia M153 工程机上的实现，展示了**"互联网巨头软件 + 手机厂商硬件"**的典型合作模式：</p>
<h4 data-id="heading-4">A. 集成方式：系统级深度植入 (System-Level Integration)</h4>
<p>不同于普通 App，豆包通过与中兴 OS (MyOS) 的底层打通，实现了硬件级的接管：</p>
<ul>
<li><strong>硬件入口绑定</strong>：将物理<strong>侧边键</strong>映射为 AI 唤醒键，支持熄屏状态下一键直达。</li>
<li><strong>权限白名单</strong>：突破了传统 Accessibility 服务易被后台查杀的限制，获得了<strong>系统级保活</strong>权限，确保持续的感知能力。</li>
</ul>
<h4 data-id="heading-5">B. 模型运行架构：端云协同 (Cloud-Edge Collaboration)</h4>
<ul>
<li><strong>端侧 (On-Device)</strong>：
<ul>
<li><strong>Secure Memory (安全记忆)</strong>：核心差异化功能。利用 Android Keystore 对用户敏感数据（如家庭地址、支付习惯）进行<strong>本地加密存储</strong>，确保隐私不离端。</li>
<li><strong>Executor (执行引擎)</strong>：运行在手机本地的轻量级服务，负责将指令转化为具体的点击/滑动操作。</li>
</ul>
</li>
<li><strong>云端 (Cloud)</strong>：
<ul>
<li><strong>Reasoning Engine (推理大脑)</strong>：处理复杂的长程任务规划（如"跨 App 比价"），利用云端大模型的算力优势进行决策，然后将操作流下发给端侧执行。</li>
</ul>
</li>
</ul>
<h4 data-id="heading-6">C. 交互闭环</h4>
<ol>
<li><strong>感知</strong>：通过无障碍服务 (Accessibility API) 实时获取屏幕 UI 树信息。</li>
<li><strong>决策</strong>：端侧记忆 + 屏幕信息 + 用户指令 -&gt; 云端推理 -&gt; 下发操作流。</li>
<li><strong>执行</strong>：调用系统级 API 模拟用户操作，遇到敏感场景（如支付）自动降级为"请求用户确认"。</li>
</ol>
<h3 data-id="heading-7">3. GUI Agent 的技术演进</h3>
<h3 data-id="heading-8">移动端 Agent 的三大技术路径</h3>
<p>在移动端 Agent 领域，目前主要存在三种技术实现路径：</p>
<h4 data-id="heading-9">1. <strong>API 接口方案</strong></h4>
<ul>
<li><strong>优势</strong>：精确可靠，延迟低</li>
<li><strong>劣势</strong>：需要 App 厂商深度适配，开发成本高，难以规模化</li>
<li><strong>代表</strong>：需要每个 App 提供专门的 Agent API</li>
</ul>
<h4 data-id="heading-10">2. <strong>辅助功能（Accessibility）方案</strong></h4>
<ul>
<li><strong>优势</strong>：可以获取 UI 树结构，理解界面元素</li>
<li><strong>劣势</strong>：依赖系统权限，部分应用限制访问，兼容性问题多</li>
<li><strong>代表</strong>：Android Accessibility Service</li>
</ul>
<h4 data-id="heading-11">3. <strong>GUI 视觉方案</strong>（GELab-Zero 采用）</h4>
<ul>
<li><strong>优势</strong>：
<ul>
<li><strong>通用兼容</strong>：无需 App 厂商适配，支持所有应用</li>
<li><strong>零成本接入</strong>：基于截屏和坐标操作，开箱即用</li>
<li><strong>真实用户视角</strong>：与人类操作方式一致</li>
</ul>
</li>
<li><strong>劣势</strong>：对视觉理解能力要求高，需要强大的多模态模型</li>
<li><strong>代表</strong>：GELab-Zero、Anthropic Computer Use</li>
</ul>
<h3 data-id="heading-12">为什么选择 GUI 方案？</h3>
<p>移动应用生态具有以下特点：</p>
<ol>
<li><strong>高度碎片化</strong>：中国市场有超过 <strong>数百万个</strong> Android 应用</li>
<li><strong>快速迭代</strong>：应用 UI 频繁更新，API 方案难以维护</li>
<li><strong>权限限制</strong>：许多应用限制 Accessibility 访问</li>
<li><strong>用户习惯</strong>：基于视觉的交互更接近真实用户行为</li>
</ol>
<p>因此，<strong>GUI 方案已成为当前阶段应对复杂移动生态、实现 Agent 能力规模化的最佳路径</strong>。</p>
<h3 data-id="heading-13">行业现状与挑战</h3>
<h4 data-id="heading-14">当前 GUI Agent 面临的核心问题</h4>
<ol>
<li>
<p><strong>工程门槛高</strong></p>
<ul>
<li>多设备 ADB 连接管理</li>
<li>依赖安装和权限配置</li>
<li>推理服务部署（本地 LLM）</li>
<li>任务编排与轨迹回放</li>
<li>可视化调试工具</li>
</ul>
</li>
<li>
<p><strong>模型能力要求高</strong></p>
<ul>
<li>需要强大的视觉理解能力</li>
<li>多步骤任务规划</li>
<li>上下文记忆</li>
<li>异常处理</li>
</ul>
</li>
<li>
<p><strong>隐私安全顾虑</strong></p>
<ul>
<li>云端 API 需要上传截图</li>
<li>用户操作数据泄露风险</li>
<li>敏感信息暴露</li>
</ul>
</li>
</ol>
<h4 data-id="heading-15">主流 Benchmark 的局限性</h4>
<p>当前主流基准测试（如 AndroidWorld）多聚焦于<strong>生产力应用</strong>（邮件、日历），但用户日常高频使用的其实是<strong>生活服务类应用</strong>：</p>
<ul>
<li>🍔 外卖（美团、饿了么）</li>
<li>🚗 打车（滴滴、高德）</li>
<li>🛒 购物（淘宝、京东）</li>
<li>💬 社交（微信、抖音）</li>
<li>💰 支付（支付宝、微信支付）</li>
</ul>
<p>这些场景更能体现 GUI Agent 的实用价值，但缺乏针对性的评估标准。</p>
<h3 data-id="heading-16">GELab-Zero 的技术突破</h3>
<p>针对上述挑战，GELab-Zero 提供了完整的解决方案：</p>
<h4 data-id="heading-17">1. <strong>完整工程基础设施</strong></h4>
<pre><code class="hljs">一键部署脚本
自动设备管理
多设备任务分发
完整日志系统
Streamlit 可视化界面
</code></pre>
<h4 data-id="heading-18">2. <strong>轻量级本地模型</strong></h4>
<ul>
<li><strong>4B 参数</strong>：在消费级硬件（16GB RAM）上流畅运行</li>
<li><strong>多模态能力</strong>：同时理解图像和文本</li>
<li><strong>高准确率</strong>：AndroidDaily 静态测试达到 <strong>73.4%</strong>（超越 GPT-4o 的 19.6%）</li>
</ul>
<h4 data-id="heading-19">3. <strong>完全本地化</strong></h4>
<ul>
<li>所有推理在本地完成（Ollama/vLLM）</li>
<li>截图和日志存储在本地</li>
<li>无需网络传输，保护隐私</li>
</ul>
<h4 data-id="heading-20">4. <strong>真实场景基准</strong></h4>
<ul>
<li><strong>AndroidDaily</strong>：235 个端到端任务</li>
<li>覆盖六大生活场景：食、行、购、住、讯、娱</li>
<li>75.86% 成功率（真实移动场景）</li>
</ul>
<h3 data-id="heading-21">与其他方案的对比</h3>















































<table><thead><tr><th>维度</th><th>API 方案</th><th>Accessibility</th><th>GUI 方案 (GELab-Zero)</th></tr></thead><tbody><tr><td><strong>兼容性</strong></td><td>❌ 需要适配</td><td>⚠️ 部分限制</td><td>✅ 通用兼容</td></tr><tr><td><strong>开发成本</strong></td><td>❌ 高</td><td>⚠️ 中</td><td>✅ 低</td></tr><tr><td><strong>隐私保护</strong></td><td>⚠️ 依赖服务商</td><td>✅ 本地</td><td>✅ 完全本地</td></tr><tr><td><strong>推理速度</strong></td><td>✅ 快</td><td>✅ 快</td><td>⚠️ 中等</td></tr><tr><td><strong>准确性</strong></td><td>✅ 高</td><td>✅ 高</td><td>✅ 高（73.4%）</td></tr><tr><td><strong>可维护性</strong></td><td>❌ 低</td><td>⚠️ 中</td><td>✅ 高</td></tr></tbody></table>
<hr/>
<h2 data-id="heading-22">一、项目概览</h2>
<h3 data-id="heading-23">1.1 核心价值主张</h3>
<p>GELab-Zero 解决了移动端 Agent 落地的三大核心挑战：</p>
<ol>
<li><strong>隐私安全</strong>：完全本地化部署，所有数据处理在本地完成，无需上传云端</li>
<li><strong>即插即用</strong>：提供完整的工程基础设施，开箱即用，无需复杂配置</li>
<li><strong>通用兼容</strong>：基于 GUI 操作，无需 App 厂商适配，支持所有应用</li>
</ol>
<h3 data-id="heading-24">1.2 技术栈组成</h3>
<ul>
<li><strong>模型层</strong>：GELab-Zero-4B-preview（基于 Qwen3-VL-4B-Instruct 微调的 4B 参数多模态视觉模型）</li>
<li><strong>推理服务</strong>：Ollama / vLLM（本地推理）</li>
<li><strong>设备控制</strong>：ADB（Android Debug Bridge）</li>
<li><strong>任务编排</strong>：LocalServer + PU Client</li>
<li><strong>可视化</strong>：Streamlit Web 界面</li>
</ul>
<h3 data-id="heading-25">1.3 开源价值深度解析：商业巨头阴影下的"守火人"</h3>
<p>在字节跳动豆包等商业产品展现出强大的系统级统治力时，GELab-Zero 这样的开源项目并非毫无意义的"重复造轮子"，而是构建了另一条必不可少的技术护城河。虽然在流畅度和系统权限上不如商业产品，但其独特价值在于：</p>
<ol>
<li>
<p><strong>打破"围墙花园"（针对存量市场）</strong>
商业产品（如豆包+中兴）依赖于排他性的厂商合作与私有系统 API。GELab-Zero 证明了<strong>纯视觉方案（Visual-based）<strong>的可行性——即使没有任何厂商特权，仅凭屏幕截图也能实现复杂的 Agent 交互。这意味着它能在数以亿计的</strong>存量旧手机</strong>上运行，而不是强迫用户购买特定的新款"AI 手机"。</p>
</li>
<li>
<p><strong>数据主权的"最后防线"（针对敏感场景）</strong>
商业助手虽然强调"端侧隐私"，但为了追求极致效果，核心的长程推理（Reasoning）往往仍依赖云端大模型（Cloud-Edge Collaboration）。GELab-Zero 是真正的<strong>全链路本地化（Local-First）</strong>，从模型权重到推理过程完全掌握在用户手中。对于<strong>金融审计、医疗数据处理、企业内网办公</strong>等对数据外泄零容忍的场景，这是唯一的选择。</p>
</li>
<li>
<p><strong>透明可控的"白盒"基座（针对开发者）</strong>
对于学术界和开发者，商业助手是"黑盒"，只能调用，无法探究其决策逻辑。GELab-Zero 提供了从数据采集（AndroidDaily）、动作定义（ActTree）到模型训练的完整**白盒（White-box）**流程。它是研究 Agent 幻觉、优化多步推理机制的最佳实验台，为行业建立了公开透明的技术标准。</p>
</li>
</ol>
<hr/>
<h2 data-id="heading-26">二、系统架构深度解析</h2>
<h3 data-id="heading-27">2.1 整体架构图</h3>
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e449caaac2a14ee29499325dee486ae8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aWH6Iie57K-6YCJ:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766494378&amp;x-signature=r72fl3npN5PyYiLCZ8FMFHC44NI%3D" loading="lazy"/>
<h3 data-id="heading-28">2.2 核心组件详解</h3>
<h4 data-id="heading-29">2.2.1 LocalServer（任务编排服务器）</h4>
<p><strong>职责</strong>：</p>
<ul>
<li>接收用户任务指令</li>
<li>管理任务执行状态</li>
<li>协调视觉理解和设备控制</li>
<li>记录完整执行轨迹</li>
</ul>
<p><strong>关键配置</strong>：</p>
<pre><code class="hljs language-python" lang="python">tmp_server_config = {
    <span class="hljs-string">"log_dir"</span>: <span class="hljs-string">"running_log/server_log/os-copilot-local-eval-logs/traces"</span>,
    <span class="hljs-string">"image_dir"</span>: <span class="hljs-string">"running_log/server_log/os-copilot-local-eval-logs/images"</span>,
    <span class="hljs-string">"debug"</span>: <span class="hljs-literal">False</span>
}
</code></pre>
<h4 data-id="heading-30">2.2.2 GELab-Zero-4B-preview 模型与架构</h4>
<p><strong>三层架构设计</strong>：
GELab-Zero 采用了类似 MobiAgent 的三层架构，以确保复杂任务的执行能力：</p>
<ol>
<li><strong>Planner (规划师)</strong>：负责任务拆解和整体流程控制。</li>
<li><strong>Decider (决策者)</strong>：根据当前屏幕状态决定具体操作。</li>
<li><strong>Ground (执行者)</strong>：将决策转化为具体的坐标点击或文本输入。</li>
</ol>
<p><strong>模型特性</strong>：</p>
<ul>
<li><strong>参数规模</strong>：4B（40 亿参数），专为消费级硬件优化。</li>
<li><strong>性能表现</strong>：在 ScreenSpot、OSWorld、Android World 等多个基准测试中拿下同尺寸 SOTA。</li>
<li><strong>多模态输入</strong>：手机截图 + 任务描述 + 历史操作。</li>
</ul>
<p><strong>基座模型</strong>：
该模型是基于 <strong>Qwen3-VL-4B-Instruct</strong> 进行微调的。选择 Qwen3-VL 作为基座是因为其在小参数量级下展现出了卓越的视觉理解和指令遵循能力，非常适合端侧部署场景。</p>
<p><strong>技术亮点：ActTree 任务分发</strong>
为了提升效率，系统引入了 <strong>多设备任务分发系统</strong>。通过 ActTree 结构记录并复用历史操作轨迹，大幅减少重复推理。在模拟真实用户习惯（80% 请求集中在 20% 任务）的测试中，<strong>动作复用率可达 60%-85%</strong>，带来 2 到 3 倍的性能提升。</p>
<p><strong>推理配置</strong>：</p>
<pre><code class="hljs language-python" lang="python">local_model_config = {
    <span class="hljs-string">"model_name"</span>: <span class="hljs-string">"gelab-zero-4b-preview"</span>,
    <span class="hljs-string">"model_provider"</span>: <span class="hljs-string">"local"</span>,
    <span class="hljs-string">"args"</span>: {
        <span class="hljs-string">"temperature"</span>: <span class="hljs-number">0.1</span>,      <span class="hljs-comment"># 低温度保证稳定性</span>
        <span class="hljs-string">"top_p"</span>: <span class="hljs-number">0.95</span>,
        <span class="hljs-string">"frequency_penalty"</span>: <span class="hljs-number">0.0</span>,
        <span class="hljs-string">"max_tokens"</span>: <span class="hljs-number">4096</span>,
    }
}
</code></pre>
<h4 data-id="heading-31">2.2.3 动作空间定义</h4>
<p>系统支持 9 类基础操作：</p>























































<table><thead><tr><th>动作类型</th><th>说明</th><th>参数</th></tr></thead><tbody><tr><td><strong>CLICK</strong></td><td>点击屏幕坐标</td><td>point (x,y)</td></tr><tr><td><strong>TYPE</strong></td><td>输入文本</td><td>value (文本内容), point (输入框位置)</td></tr><tr><td><strong>SLIDE</strong></td><td>滑动操作</td><td>point1 (起点), point2 (终点)</td></tr><tr><td><strong>LONGPRESS</strong></td><td>长按操作</td><td>point (坐标)</td></tr><tr><td><strong>AWAKE</strong></td><td>唤醒应用</td><td>value (应用名称)</td></tr><tr><td><strong>WAIT</strong></td><td>等待</td><td>value (秒数)</td></tr><tr><td><strong>INFO</strong></td><td>询问用户</td><td>value (问题内容)</td></tr><tr><td><strong>COMPLETE</strong></td><td>任务完成</td><td>return (结果报告)</td></tr><tr><td><strong>ABORT</strong></td><td>终止任务</td><td>value (终止原因)</td></tr></tbody></table>
<p><strong>坐标系统</strong>：</p>
<ul>
<li>原点：左上角 (0, 0)</li>
<li>X 轴：向右递增</li>
<li>Y 轴：向下递增</li>
<li>取值范围：0-1000（归一化坐标）</li>
</ul>
<hr/>
<h2 data-id="heading-32">三、实战案例：淘宝购书任务全流程解析</h2>
<h3 data-id="heading-33">3.1 任务背景</h3>
<p><strong>任务描述</strong>：去淘宝帮我买本书<br/>
<strong>Session ID</strong>：<code>1fe9db3f-92c8-4ae9-89bc-1d035d4bf59b</code><br/>
<strong>执行时间</strong>：2025-12-05 18:41:39 - 18:46:55<br/>
<strong>总步骤数</strong>：9 步<br/>
<strong>模型配置</strong>：gelab-zero-4b-preview (本地推理)
<strong>设备环境</strong>：MacBook Pro (Apple M3 Pro, 18GB RAM)
<strong>量化说明</strong>：因 18GB 统一内存运行 FP16 原生模型会触发系统卡死，本案例使用了 Int8 量化模型 (<code>q8_0</code>) 进行推理。</p>
<h3 data-id="heading-34">3.2 完整执行流程</h3>
<h4 data-id="heading-35">步骤 1：应用唤醒（AWAKE）</h4>
<p><strong>模型思考</strong>：</p>
<blockquote>
<p>"我看到的是手机主屏幕。任务是去淘宝买书。第一步就是要打开淘宝应用。我看到屏幕上有'京东'应用，但任务明确要求使用'淘宝'。因此，我需要先启动淘宝应用。"</p>
</blockquote>
<p><strong>执行动作</strong>：</p>
<pre><code class="hljs language-makefile" lang="makefile"><span class="hljs-section">action: AWAKE</span>
<span class="hljs-section">value: 淘宝</span>
</code></pre>
<p><strong>推理耗时</strong>：20.43 秒</p>
<p><strong>关键技术点</strong>：</p>
<ul>
<li>模型能够区分不同的电商应用（京东 vs 淘宝）</li>
<li>准确理解任务指令中的应用要求</li>
<li>使用 AWAKE 指令直接唤醒应用，而非手动查找点击</li>
</ul>
<hr/>
<h4 data-id="heading-36">步骤 2：搜索框定位（CLICK）</h4>
<p><strong>模型思考</strong>：</p>
<blockquote>
<p>"我看到当前是淘宝的首页。任务目标是购买一本书。为了找到书，我需要使用搜索功能。我观察到页面顶部有一个搜索框，里面有'干脆面'的提示文字。我需要点击这个搜索框来激活它。"</p>
</blockquote>
<p><strong>执行动作</strong>：</p>
<pre><code class="hljs language-makefile" lang="makefile"><span class="hljs-section">action: CLICK</span>
<span class="hljs-section">point: 375,117</span>
</code></pre>
<p><strong>推理耗时</strong>：20.69 秒</p>
<p><strong>关键技术点</strong>：</p>
<ul>
<li>准确识别搜索框的视觉位置</li>
<li>理解需要先激活搜索框才能输入</li>
<li>坐标精准定位（屏幕中上部区域）</li>
</ul>
<hr/>
<h4 data-id="heading-37">步骤 3：文本输入（TYPE）</h4>
<p><strong>模型思考</strong>：</p>
<blockquote>
<p>"我看到当前界面是淘宝的搜索页面，键盘已经弹起，光标在搜索框中。任务目标是购买一本书。现在我需要输入要搜索的关键词。为了找到书，我应该在搜索框中输入'书'。"</p>
</blockquote>
<p><strong>执行动作</strong>：</p>
<pre><code class="hljs language-makefile" lang="makefile"><span class="hljs-section">action: TYPE</span>
<span class="hljs-section">value: 书</span>
<span class="hljs-section">point: 213,132</span>
</code></pre>
<p><strong>推理耗时</strong>：22.23 秒</p>
<p><strong>关键技术点</strong>：</p>
<ul>
<li>识别输入框的激活状态（键盘弹起）</li>
<li>提取任务关键词（"买书" → 搜索"书"）</li>
<li>TYPE 动作需要同时提供文本内容和输入框位置</li>
</ul>
<hr/>
<h4 data-id="heading-38">步骤 4：执行搜索（CLICK）</h4>
<p><strong>模型思考</strong>：</p>
<blockquote>
<p>"我看到当前界面是淘宝的搜索页面，搜索框里已经输入了'书'。任务目标是购买一本书，现在需要执行搜索来查看有哪些书可以选。因此，我应该点击搜索框旁边的橙色'搜索'按钮。"</p>
</blockquote>
<p><strong>执行动作</strong>：</p>
<pre><code class="hljs language-makefile" lang="makefile"><span class="hljs-section">action: CLICK</span>
<span class="hljs-section">point: 896,130</span>
</code></pre>
<p><strong>推理耗时</strong>：21.06 秒</p>
<p><strong>关键技术点</strong>：</p>
<ul>
<li>识别"搜索"按钮的视觉特征（橙色、位置）</li>
<li>理解搜索流程的完整性（输入 → 点击搜索）</li>
<li>右上角按钮的精准点击</li>
</ul>
<hr/>
<h4 data-id="heading-39">步骤 5：信息询问（INFO）</h4>
<p><strong>模型思考</strong>：</p>
<blockquote>
<p>"我看到当前界面是'书'的搜索结果页。任务目标是购买一本书，但用户没有指定具体书名。为了继续任务，我需要知道用户想买哪一本书。因此，我应该向用户询问。"</p>
</blockquote>
<p><strong>执行动作</strong>：</p>
<pre><code class="hljs language-makefile" lang="makefile"><span class="hljs-section">action: INFO</span>
<span class="hljs-section">value: 请问您想买哪本书？</span>
</code></pre>
<p><strong>用户回复</strong>：我想买明朝那些事</p>
<p><strong>推理耗时</strong>：20.63 秒</p>
<p><strong>关键技术点</strong>：</p>
<ul>
<li><strong>主动信息获取</strong>：模型意识到任务信息不完整</li>
<li><strong>交互式决策</strong>：通过 INFO 动作暂停执行，等待用户输入</li>
<li><strong>上下文理解</strong>：记住用户回复，继续执行后续步骤</li>
</ul>
<hr/>
<h4 data-id="heading-40">步骤 6：弹窗处理（CLICK）</h4>
<p><strong>模型思考</strong>：</p>
<blockquote>
<p>"我看到当前界面是'书'的搜索结果页，但有一个'淘宝双12'的消费券弹窗覆盖在上面，阻碍了后续操作。任务目标是购买《明朝那些事》，所以必须先处理掉这个弹窗。我观察到弹窗下方有一个'X'关闭按钮。"</p>
</blockquote>
<p><strong>执行动作</strong>：</p>
<pre><code class="hljs language-makefile" lang="makefile"><span class="hljs-section">action: CLICK</span>
<span class="hljs-section">point: 500,710</span>
</code></pre>
<p><strong>推理耗时</strong>：22.28 秒</p>
<p><strong>关键技术点</strong>：</p>
<ul>
<li><strong>干扰识别</strong>：准确判断弹窗是阻碍因素</li>
<li><strong>优先级处理</strong>：先清除障碍再继续主任务</li>
<li><strong>细节关注</strong>：定位关闭按钮的位置</li>
</ul>
<hr/>
<h4 data-id="heading-41">步骤 7：商品选择（CLICK）</h4>
<p><strong>模型思考</strong>：</p>
<blockquote>
<p>"我看到当前界面是'书'的搜索结果列表。任务目标是购买《明朝那些事》。列表中的第一个商品就是'新版全9册 明朝那些事儿全套1-9册'，这正是我要找的书。"</p>
</blockquote>
<p><strong>执行动作</strong>：</p>
<pre><code class="hljs language-makefile" lang="makefile"><span class="hljs-section">action: CLICK</span>
<span class="hljs-section">point: 258,445</span>
</code></pre>
<p><strong>推理耗时</strong>：19.94 秒</p>
<p><strong>关键技术点</strong>：</p>
<ul>
<li><strong>商品匹配</strong>：从搜索结果中识别目标商品</li>
<li><strong>文本理解</strong>："明朝那些事" = "明朝那些事儿"（近义词匹配）</li>
<li><strong>视觉定位</strong>：在商品列表中准确定位目标</li>
</ul>
<hr/>
<h4 data-id="heading-42">步骤 8：立即购买（CLICK）</h4>
<p><strong>模型思考</strong>：</p>
<blockquote>
<p>"我看到当前界面是《明朝那些事儿》的商品详情页。任务目标是购买这本书。为了继续购买流程，我需要点击页面底部的'立即购买'按钮。"</p>
</blockquote>
<p><strong>执行动作</strong>：</p>
<pre><code class="hljs language-makefile" lang="makefile"><span class="hljs-section">action: CLICK</span>
<span class="hljs-section">point: 836,946</span>
</code></pre>
<p><strong>推理耗时</strong>：19.32 秒</p>
<p><strong>关键技术点</strong>：</p>
<ul>
<li><strong>页面理解</strong>：识别商品详情页的布局结构</li>
<li><strong>按钮定位</strong>：准确找到底部购买按钮</li>
<li><strong>流程推进</strong>：理解电商购物的标准流程</li>
</ul>
<hr/>
<h4 data-id="heading-43">步骤 9：任务完成（COMPLETE）</h4>
<p><strong>模型思考</strong>：</p>
<blockquote>
<p>"我看到当前界面是订单确认页。任务是购买一本书，我已经完成了商品选择、加入购物车、进入结算的所有步骤。现在页面显示了收货地址、商品信息和支付金额243元。由于这是涉及金钱交易的最后一步，我应该在这里停止操作，并向用户报告订单的详细信息。"</p>
</blockquote>
<p><strong>执行动作</strong>：</p>
<pre><code class="hljs language-diff" lang="diff">action: COMPLETE
return: 我已完成购书流程并到达订单确认页面。
订单详情如下：
<span class="hljs-deletion">- 商品：正版《明朝那些事儿》全套1-9册</span>
<span class="hljs-deletion">- 收货地址：xxx xxxxxxxxxx</span>
<span class="hljs-deletion">- 支付金额：¥243</span>
<span class="hljs-deletion">- 支付方式：先用后付</span>
请您确认以上信息无误后，可以点击页面底部的"先用后付，确认收货后付款 ¥243"按钮继续完成支付。
</code></pre>
<p><strong>推理耗时</strong>：25.83 秒</p>
<p><strong>关键技术点</strong>：</p>
<ul>
<li><strong>安全边界</strong>：在支付前停止，不执行敏感操作</li>
<li><strong>信息提取</strong>：从订单页面提取关键信息</li>
<li><strong>完整汇报</strong>：向用户清晰报告任务完成状态和后续操作建议</li>
</ul>
<hr/>
<h3 data-id="heading-44">3.3 性能统计</h3>





























<table><thead><tr><th>指标</th><th>数值</th></tr></thead><tbody><tr><td><strong>总步骤数</strong></td><td>9 步</td></tr><tr><td><strong>总执行时间</strong></td><td>~5 分钟 16 秒</td></tr><tr><td><strong>平均每步推理时间</strong></td><td>~21 秒</td></tr><tr><td><strong>成功率</strong></td><td>100% (完成到订单确认页)</td></tr><tr><td><strong>用户交互次数</strong></td><td>1 次 (询问书名)</td></tr></tbody></table>
<hr/>
<h2 data-id="heading-45">四、技术亮点与创新</h2>
<h3 data-id="heading-46">4.1 多模态推理能力</h3>
<p>GELab-Zero 的 4B 模型展现了强大的视觉-语言理解能力：</p>
<ol>
<li>
<p><strong>视觉元素识别</strong>：</p>
<ul>
<li>搜索框、按钮、商品列表</li>
<li>弹窗、键盘状态</li>
<li>文字内容（商品名、价格、地址）</li>
</ul>
</li>
<li>
<p><strong>语义理解</strong>：</p>
<ul>
<li>任务目标拆解（"买书" → 搜索 → 选择 → 购买）</li>
<li>近义词匹配（"明朝那些事" ≈ "明朝那些事儿"）</li>
<li>上下文连贯性（记住用户指定的书名）</li>
</ul>
</li>
<li>
<p><strong>逻辑推理</strong>：</p>
<ul>
<li>判断任务完成度</li>
<li>识别阻碍因素（弹窗）</li>
<li>决定何时询问用户、何时停止操作</li>
</ul>
</li>
</ol>
<h3 data-id="heading-47">4.2 安全性设计</h3>
<ol>
<li>
<p><strong>敏感操作保护</strong>：</p>
<ul>
<li>在支付前停止，不执行金融交易</li>
<li>使用 COMPLETE 动作汇报结果，由用户确认</li>
</ul>
</li>
<li>
<p><strong>完全本地化</strong>：</p>
<ul>
<li>所有推理在本地完成</li>
<li>截图和日志存储在本地</li>
<li>无需网络传输用户数据</li>
</ul>
</li>
<li>
<p><strong>轨迹可追溯</strong>：</p>
<ul>
<li>每一步操作都有完整日志</li>
<li>包含模型思考过程（CoT）</li>
<li>可通过 Streamlit 可视化查看</li>
</ul>
</li>
</ol>
<h3 data-id="heading-48">4.3 工程化设计</h3>
<ol>
<li>
<p><strong>模块化架构</strong>：</p>
<ul>
<li>Server 层、Client 层、Frontend 层分离</li>
<li>易于扩展和维护</li>
</ul>
</li>
<li>
<p><strong>日志系统</strong>：</p>
<pre><code class="hljs language-python" lang="python">{
    <span class="hljs-string">"session_id"</span>: <span class="hljs-string">"唯一标识"</span>,
    <span class="hljs-string">"timestamp"</span>: <span class="hljs-string">"时间戳"</span>,
    <span class="hljs-string">"message"</span>: {
        <span class="hljs-string">"environment"</span>: {
            <span class="hljs-string">"image"</span>: <span class="hljs-string">"截图路径"</span>,
            <span class="hljs-string">"user_comment"</span>: <span class="hljs-string">"用户反馈"</span>
        },
        <span class="hljs-string">"action"</span>: {
            <span class="hljs-string">"cot"</span>: <span class="hljs-string">"思考过程"</span>,
            <span class="hljs-string">"explain"</span>: <span class="hljs-string">"动作解释"</span>,
            <span class="hljs-string">"action"</span>: <span class="hljs-string">"动作类型"</span>,
            ...
        },
        <span class="hljs-string">"llm_cost"</span>: {
            <span class="hljs-string">"llm_time"</span>: <span class="hljs-string">"推理耗时"</span>,
            ...
        }
    }
}
</code></pre>
</li>
<li>
<p><strong>可视化工具</strong>：</p>
<ul>
<li>Streamlit Web 界面</li>
<li>展示完整执行轨迹</li>
<li>在截图上标记操作点位</li>
</ul>
</li>
</ol>
<hr/>
<h2 data-id="heading-49">五、性能优化建议</h2>
<h3 data-id="heading-50">5.1 推理速度优化</h3>
<p><strong>当前瓶颈</strong>：平均每步 ~21 秒</p>
<p><strong>优化方案</strong>：</p>
<ol>
<li>
<p><strong>模型量化（关键！）</strong>：
实测发现，在 Apple M3 Pro (18GB RAM) 等中端配置上，直接运行 FP16 模型可能导致内存溢出甚至系统卡死。<strong>强烈建议使用 Int8 或 Int4 量化版本</strong>。</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># INT8 量化（本案例使用，兼顾速度与精度，适合 16GB+ 内存）</span>
ollama create -q q8_0 gelab-zero-4b-preview

<span class="hljs-comment"># INT4 量化（速度最快，适合 8GB/12GB 内存）</span>
ollama create -q Q4_K_M gelab-zero-4b-preview
</code></pre>
</li>
<li>
<p><strong>图像尺寸调整</strong>：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-string">"resize_config"</span>: {
    <span class="hljs-string">"is_resize"</span>: <span class="hljs-literal">True</span>,
    <span class="hljs-string">"target_image_size"</span>: (<span class="hljs-number">756</span>, <span class="hljs-number">756</span>)  <span class="hljs-comment"># 降低分辨率</span>
}
</code></pre>
</li>
<li>
<p><strong>硬件升级（立竿见影）</strong>：
如果预算允许，升级硬件是提升体验最直接的方式：</p>
<ul>
<li><strong>Apple Silicon 用户</strong>：建议使用 M3 Max / M4 Max 芯片（配备 36GB+ 统一内存），可流畅运行 FP16 原版模型，推理延迟有望降低至 <strong>3-5秒/步</strong>。</li>
<li><strong>NVIDIA GPU 用户</strong>：使用 RTX 4090 (24GB) 或 A100 (40GB/80GB) 部署，结合 vLLM 推理加速框架，可实现亚秒级响应。</li>
</ul>
</li>
<li>
<p><strong>批处理推理</strong>：</p>
<ul>
<li>对于多设备任务，使用批处理提升吞吐量</li>
</ul>
</li>
</ol>
<h3 data-id="heading-51">5.2 准确性提升</h3>
<ol>
<li>
<p><strong>温度参数调整</strong>：</p>
<ul>
<li>当前：0.1（偏保守）</li>
<li>建议：0.0（完全确定性）或 0.05（平衡）</li>
</ul>
</li>
<li>
<p><strong>Prompt 优化</strong>：</p>
<ul>
<li>增加任务相关的示例</li>
<li>细化动作空间的描述</li>
</ul>
</li>
<li>
<p><strong>多模态融合</strong>：</p>
<ul>
<li>结合 OCR 提取文字</li>
<li>使用 UI 层次结构信息</li>
</ul>
</li>
</ol>
<hr/>
<h2 data-id="heading-52">六、应用场景拓展</h2>
<h3 data-id="heading-53">6.1 个人助手场景</h3>
<ul>
<li><strong>购物助手</strong>：比价、下单、跟踪物流</li>
<li><strong>出行助手</strong>：打车、订票、导航</li>
<li><strong>社交助手</strong>：自动回复、消息转发</li>
</ul>
<h3 data-id="heading-54">6.2 企业应用场景</h3>
<ul>
<li><strong>自动化测试</strong>：App UI 自动化测试</li>
<li><strong>数据采集</strong>：竞品分析、价格监控</li>
<li><strong>RPA</strong>：重复性任务自动化</li>
</ul>
<h3 data-id="heading-55">6.3 研究方向</h3>
<ul>
<li><strong>多设备协同</strong>：同时控制多台手机</li>
<li><strong>长期记忆</strong>：跨 Session 的任务记忆</li>
<li><strong>多模态输入</strong>：语音指令、手势控制</li>
</ul>
<hr/>
<h2 data-id="heading-56">七、总结与展望</h2>
<h3 data-id="heading-57">7.1 核心优势：为什么是 GELab-Zero？</h3>
<ol>
<li><strong>工程基建的胜利</strong>：覆盖主流 Android 9+ 及 RAM 4GB 以上设备。通过完整的推理工程基建，解决了多设备 ADB 连接、依赖安装等繁琐流程，让开发者从"脏活累活"中解放出来。</li>
<li><strong>隐私与安全的平衡</strong>：类似于豆包手机助手的端侧持久记忆理念，GELab-Zero 坚持完全本地化运行，所有数据在本地闭环，规避了云端隐私泄露风险。</li>
<li><strong>真实场景的打磨</strong>：基于 <strong>AndroidDaily</strong> 自建评测基准，聚焦现代生活六大核心维度（食、行、购、住、讯、娱），在真实复杂任务中（如跨 App 比价、多商品采购）准确率达到 <strong>73.4%</strong>。</li>
</ol>
<h3 data-id="heading-58">7.2 行业发展趋势</h3>
<p>随着 2025 年末端侧 AI 的集中爆发，未来几年我们将看到以下趋势：</p>
<ol>
<li><strong>技术融合</strong>：端侧模型参数将持续增长，3B/4B 模型通过蒸馏技术将逼近 8B 通用模型效果。硬件上，NPU 的普及和存内计算技术将进一步降低功耗。</li>
<li><strong>交互变革</strong>：从单一的触控交互向<strong>语音+视觉+意图理解</strong>的多模态交互演进。正如豆包与中兴的合作所示，系统级入口（侧边键、耳机唤醒）将成为兵家必争之地。</li>
<li><strong>主动服务</strong>：AI 将从"被动工具"转向"主动助理"。具备长期记忆能力的 Agent 将能记住用户的偏好（如"帮我整理下周行程"），并在合适的时机主动提供服务（如"自动比价并领券"）。</li>
</ol>
<h3 data-id="heading-59">7.3 结语：商业闭环与开源价值的思考</h3>
<p>虽然从商业化成熟度和用户体验来看，<strong>豆包手机助手</strong>凭借与手机厂商的系统级深度绑定（如中兴 Nubia），在保活能力、权限获取和交互便捷性上占据了绝对优势，这代表了"极致产品体验"的方向。</p>
<p>但 <strong>GELab-Zero</strong> 的开源价值恰恰在于其<strong>独立性与普惠性</strong>：</p>
<ol>
<li><strong>技术民主化</strong>：它证明了不依赖手机厂商的系统级后门（Backdoor）或特权 API，仅凭纯视觉方案（Visual-based），也能在通用 Android 设备上实现高可用性的 Agent。这为非手机厂商的开发者打开了一扇窗。</li>
<li><strong>隐私底线</strong>：在巨头们纷纷将数据上传云端进行"混合计算"的当下，GELab-Zero 坚守的"全本地推理"（Local Inference）为医疗、金融等高敏感场景提供了一个可信的替代方案。</li>
<li><strong>标准定义者</strong>：它所定义的 ActTree 动作空间、AndroidDaily 评测标准，极有可能成为未来移动端 Agent 开发的行业事实标准。</li>
</ol>
<p>如果说豆包是 iOS 式的封闭花园精品，那么 GELab-Zero 正致力于成为移动端 Agent 时代的 Android——虽然粗糙，但充满无限可能。对于开发者而言，它提供了一个绝佳的实验平台，让你现在就能在自己的电脑和手机上，构建出能够理解世界、操作应用的下一代 AI Agent。</p>
<hr/>
<h2 data-id="heading-60">八、参考资料</h2>
<ol>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fstepfun-ai%2Fgelab-zero" target="_blank" title="https://github.com/stepfun-ai/gelab-zero" ref="nofollow noopener noreferrer">github.com/stepfun-ai/…</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fhuggingface.co%2Fstepfun-ai%2FGELab-Zero-4B-preview" target="_blank" title="https://huggingface.co/stepfun-ai/GELab-Zero-4B-preview" ref="nofollow noopener noreferrer">huggingface.co/stepfun-ai/…</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.modelscope.cn%2Fmodels%2FQwen%2FQwen3-VL-4B-Instruct" target="_blank" title="https://www.modelscope.cn/models/Qwen/Qwen3-VL-4B-Instruct" ref="nofollow noopener noreferrer">www.modelscope.cn/models/Qwen…</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fhuggingface.co%2Fdatasets%2Fstepfun-ai%2FAndroidDaily" target="_blank" title="https://huggingface.co/datasets/stepfun-ai/AndroidDaily" ref="nofollow noopener noreferrer">huggingface.co/datasets/st…</a></li>
<li><strong>论文</strong>：GUI Exploration Lab: Enhancing Screen Navigation in Agents via Multi-Turn Reinforcement Learning (NeurIPS 2025)</li>
<li><a href="https://juejin.cn/post/7579088065697611816" target="_blank" title="https://juejin.cn/post/7579088065697611816">juejin.cn/post/757908…</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DeoY4EIcbFck" target="_blank" title="https://www.youtube.com/watch?v=eoY4EIcbFck" ref="nofollow noopener noreferrer">www.youtube.com/watch?v=eoY…</a></li>
</ol>
<hr/>
<h2 data-id="heading-61">附录：</h2>
<h3 data-id="heading-62">A.1 单任务执行脚本</h3>
<pre><code class="hljs language-python" lang="python">项目中的示例：
python examples/run_single_task.py
</code></pre>
<h3 data-id="heading-63">A.2 轨迹可视化启动</h3>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 仅本机访问</span>
streamlit run --server.address 127.0.0.1 --server.port 33503 --server.headless <span class="hljs-literal">true</span> visualization/main_page.py

<span class="hljs-comment"># 局域网访问</span>
streamlit run --server.address 0.0.0.0 --server.port 33503 --server.headless <span class="hljs-literal">true</span> visualization/main_page.py
</code></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[从概念开始开始C++管道编程]]></title>    <link>https://juejin.cn/post/7584287969214054419</link>    <guid>https://juejin.cn/post/7584287969214054419</guid>    <pubDate>2025-12-16T11:07:33.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584287969214054419" data-draft-id="7584295332339695679" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="从概念开始开始C++管道编程"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2025-12-16T11:07:33.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="码事漫谈"/> <meta itemprop="url" content="https://juejin.cn/user/1972974802965230"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            从概念开始开始C++管道编程
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1972974802965230/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    码事漫谈
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-16T11:07:33.000Z" title="Tue Dec 16 2025 11:07:33 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-16
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读10分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">第一章：管道编程的核心概念</h2>
<h3 data-id="heading-1">1.1 什么是管道？</h3>
<p><strong>管道</strong>是UNIX和类UNIX系统中最古老、最基础的进程间通信（IPC）机制之一。你可以将它想象成现实世界中的水管：数据像水流一样从一个进程"流"向另一个进程。</p>
<p><strong>核心特征</strong>：</p>
<ul>
<li><strong>半双工通信</strong>：数据只能单向流动（要么从A到B，要么从B到A）</li>
<li><strong>字节流导向</strong>：没有消息边界，数据是连续的字节流</li>
<li><strong>基于文件描述符</strong>：使用与文件操作相同的接口</li>
<li><strong>内核缓冲区</strong>：数据在内核缓冲区中暂存</li>
</ul>
<h3 data-id="heading-2">1.2 管道的工作原理</h3>
<p>让我们通过一个简单的比喻来理解管道的工作原理：</p>
<p>想象两个进程要通过管道通信：</p>
<pre><code class="hljs language-css" lang="css">进程<span class="hljs-selector-tag">A</span>（写端） → <span class="hljs-selector-attr">[内核缓冲区]</span> → 进程<span class="hljs-selector-tag">B</span>（读端）
</code></pre>
<p><strong>内核缓冲区的作用</strong>：</p>
<ol>
<li>当进程A写入数据时，数据先进入内核缓冲区</li>
<li>进程B从缓冲区读取数据</li>
<li>如果缓冲区空，读操作会阻塞（等待数据）</li>
<li>如果缓冲区满，写操作会阻塞（等待空间）</li>
</ol>
<p><strong>匿名管道的关键限制</strong>：</p>
<ul>
<li>只能用于有"亲缘关系"的进程间通信（通常是父子进程或兄弟进程）</li>
<li>生命周期随进程结束而结束</li>
<li>无法在无关进程间使用</li>
</ul>
<h2 data-id="heading-3">第二章：入门实践——创建第一个管道</h2>
<h3 data-id="heading-4">2.1 理解文件描述符</h3>
<p>在深入代码之前，必须理解<strong>文件描述符</strong>的概念：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// 每个进程都有这三个标准文件描述符：</span>
<span class="hljs-comment">// 0 - 标准输入（stdin）   → 通常从键盘读取</span>
<span class="hljs-comment">// 1 - 标准输出（stdout）  → 通常输出到屏幕</span>
<span class="hljs-comment">// 2 - 标准错误（stderr）  → 错误信息输出</span>

<span class="hljs-comment">// 当创建管道时，系统会分配两个新的文件描述符：</span>
<span class="hljs-comment">// pipefd[0] - 用于读取的端</span>
<span class="hljs-comment">// pipefd[1] - 用于写入的端</span>
</code></pre>
<h3 data-id="heading-5">2.2 创建第一个管道程序</h3>
<p>让我们从最简单的例子开始：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span>   <span class="hljs-comment">// pipe(), fork(), read(), write()</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span>   <span class="hljs-comment">// strlen()</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span> <span class="hljs-comment">// wait()</span></span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-type">int</span> pipefd[<span class="hljs-number">2</span>];  <span class="hljs-comment">// 管道文件描述符数组</span>
    <span class="hljs-type">char</span> buffer[<span class="hljs-number">100</span>];
    
    <span class="hljs-comment">// 步骤1：创建管道</span>
    <span class="hljs-comment">// pipe() 返回0表示成功，-1表示失败</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pipe</span>(pipefd) == <span class="hljs-number">-1</span>) {
        std::cerr &lt;&lt; <span class="hljs-string">"管道创建失败"</span> &lt;&lt; std::endl;
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    }
    
    <span class="hljs-comment">// 步骤2：创建子进程</span>
    <span class="hljs-type">pid_t</span> pid = fork();
    
    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">-1</span>) {
        std::cerr &lt;&lt; <span class="hljs-string">"进程创建失败"</span> &lt;&lt; std::endl;
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    }
    
    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) {
        <span class="hljs-comment">// 子进程代码</span>
        <span class="hljs-comment">// 关闭不需要的写端</span>
        <span class="hljs-built_in">close</span>(pipefd[<span class="hljs-number">1</span>]);
        
        <span class="hljs-comment">// 从管道读取数据</span>
        <span class="hljs-type">int</span> bytes_read = <span class="hljs-built_in">read</span>(pipefd[<span class="hljs-number">0</span>], buffer, <span class="hljs-built_in">sizeof</span>(buffer));
        <span class="hljs-keyword">if</span> (bytes_read &gt; <span class="hljs-number">0</span>) {
            std::cout &lt;&lt; <span class="hljs-string">"子进程收到: "</span> &lt;&lt; buffer &lt;&lt; std::endl;
        }
        
        <span class="hljs-built_in">close</span>(pipefd[<span class="hljs-number">0</span>]);
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// 父进程代码</span>
        <span class="hljs-comment">// 关闭不需要的读端</span>
        <span class="hljs-built_in">close</span>(pipefd[<span class="hljs-number">0</span>]);
        
        <span class="hljs-type">const</span> <span class="hljs-type">char</span>* message = <span class="hljs-string">"Hello from parent!"</span>;
        
        <span class="hljs-comment">// 向管道写入数据</span>
        <span class="hljs-built_in">write</span>(pipefd[<span class="hljs-number">1</span>], message, <span class="hljs-built_in">strlen</span>(message));
        
        <span class="hljs-comment">// 关闭写端，表示数据发送完毕</span>
        <span class="hljs-built_in">close</span>(pipefd[<span class="hljs-number">1</span>]);
        
        <span class="hljs-comment">// 等待子进程结束</span>
        <span class="hljs-built_in">wait</span>(<span class="hljs-literal">nullptr</span>);
    }
    
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<h3 data-id="heading-6">2.3 关键原理分析</h3>
<p><strong>为什么需要关闭不用的描述符？</strong></p>
<ol>
<li><strong>资源管理</strong>：每个进程都有文件描述符限制，及时关闭避免泄漏</li>
<li><strong>正确终止</strong>：读进程需要知道何时没有更多数据
<ul>
<li>所有写端关闭 → 读端返回0（EOF）</li>
<li>否则读端会一直等待</li>
</ul>
</li>
</ol>
<p><strong>管道的阻塞行为</strong>：</p>
<ul>
<li><strong>读阻塞</strong>：当管道空且仍有写端打开时，读操作会阻塞</li>
<li><strong>写阻塞</strong>：当管道满（默认64KB），写操作会阻塞</li>
<li><strong>非阻塞模式</strong>：可以通过fcntl()设置O_NONBLOCK</li>
</ul>
<h2 data-id="heading-7">第三章：中级应用——双向通信与复杂管道</h2>
<h3 data-id="heading-8">3.1 实现双向通信</h3>
<p>单个管道只能单向通信，要实现双向通信，我们需要两个管道：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">BidirectionalPipe</span> {
<span class="hljs-keyword">private</span>:
    <span class="hljs-type">int</span> parent_to_child[<span class="hljs-number">2</span>];  <span class="hljs-comment">// 父→子管道</span>
    <span class="hljs-type">int</span> child_to_parent[<span class="hljs-number">2</span>];  <span class="hljs-comment">// 子→父管道</span>
    
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">BidirectionalPipe</span>() {
        <span class="hljs-comment">// 创建两个管道</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pipe</span>(parent_to_child) == <span class="hljs-number">-1</span> || <span class="hljs-built_in">pipe</span>(child_to_parent) == <span class="hljs-number">-1</span>) {
            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">"管道创建失败"</span>);
        }
    }
    
    ~<span class="hljs-built_in">BidirectionalPipe</span>() {
        <span class="hljs-built_in">closeAll</span>();
    }
    
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">parentWrite</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; message)</span> </span>{
        <span class="hljs-built_in">write</span>(parent_to_child[<span class="hljs-number">1</span>], message.<span class="hljs-built_in">c_str</span>(), message.<span class="hljs-built_in">length</span>());
    }
    
    <span class="hljs-function">std::string <span class="hljs-title">parentRead</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-type">char</span> buffer[<span class="hljs-number">256</span>];
        <span class="hljs-type">int</span> n = <span class="hljs-built_in">read</span>(child_to_parent[<span class="hljs-number">0</span>], buffer, <span class="hljs-built_in">sizeof</span>(buffer)<span class="hljs-number">-1</span>);
        <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">0</span>) {
            buffer[n] = <span class="hljs-string">'\0'</span>;
            <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">string</span>(buffer);
        }
        <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;
    }
    
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">childWrite</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; message)</span> </span>{
        <span class="hljs-built_in">write</span>(child_to_parent[<span class="hljs-number">1</span>], message.<span class="hljs-built_in">c_str</span>(), message.<span class="hljs-built_in">length</span>());
    }
    
    <span class="hljs-function">std::string <span class="hljs-title">childRead</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-type">char</span> buffer[<span class="hljs-number">256</span>];
        <span class="hljs-type">int</span> n = <span class="hljs-built_in">read</span>(parent_to_child[<span class="hljs-number">0</span>], buffer, <span class="hljs-built_in">sizeof</span>(buffer)<span class="hljs-number">-1</span>);
        <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">0</span>) {
            buffer[n] = <span class="hljs-string">'\0'</span>;
            <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">string</span>(buffer);
        }
        <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;
    }
    
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">closeParentSide</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-built_in">close</span>(parent_to_child[<span class="hljs-number">1</span>]);  <span class="hljs-comment">// 关闭父进程的写端</span>
        <span class="hljs-built_in">close</span>(child_to_parent[<span class="hljs-number">0</span>]);  <span class="hljs-comment">// 关闭父进程的读端</span>
    }
    
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">closeChildSide</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-built_in">close</span>(parent_to_child[<span class="hljs-number">0</span>]);  <span class="hljs-comment">// 关闭子进程的读端</span>
        <span class="hljs-built_in">close</span>(child_to_parent[<span class="hljs-number">1</span>]);  <span class="hljs-comment">// 关闭子进程的写端</span>
    }
    
<span class="hljs-keyword">private</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">closeAll</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-built_in">close</span>(parent_to_child[<span class="hljs-number">0</span>]);
        <span class="hljs-built_in">close</span>(parent_to_child[<span class="hljs-number">1</span>]);
        <span class="hljs-built_in">close</span>(child_to_parent[<span class="hljs-number">0</span>]);
        <span class="hljs-built_in">close</span>(child_to_parent[<span class="hljs-number">1</span>]);
    }
};
</code></pre>
<h3 data-id="heading-9">3.2 管道链的实现</h3>
<p>管道链是UNIX shell中<code>|</code>操作符的基础，让我们实现一个简单的版本：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;array&gt;</span></span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Pipeline</span> {
<span class="hljs-keyword">private</span>:
    <span class="hljs-comment">// 存储多个命令</span>
    std::vector&lt;std::vector&lt;std::string&gt;&gt; commands;
    
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addCommand</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;std::string&gt;&amp; cmd)</span> </span>{
        commands.<span class="hljs-built_in">push_back</span>(cmd);
    }
    
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>{
        std::vector&lt;<span class="hljs-type">int</span>&gt; prev_pipe_read;  <span class="hljs-comment">// 前一个管道的读端</span>
        
        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; commands.<span class="hljs-built_in">size</span>(); ++i) {
            <span class="hljs-type">int</span> pipefd[<span class="hljs-number">2</span>];
            
            <span class="hljs-comment">// 如果不是最后一个命令，创建管道</span>
            <span class="hljs-keyword">if</span> (i &lt; commands.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) {
                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pipe</span>(pipefd) == <span class="hljs-number">-1</span>) {
                    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">"管道创建失败"</span>);
                }
            }
            
            <span class="hljs-type">pid_t</span> pid = fork();
            
            <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) {
                <span class="hljs-comment">// 子进程代码</span>
                
                <span class="hljs-comment">// 设置输入重定向（从上一个管道读取）</span>
                <span class="hljs-keyword">if</span> (!prev_pipe_read.<span class="hljs-built_in">empty</span>()) {
                    <span class="hljs-built_in">dup2</span>(prev_pipe_read[<span class="hljs-number">0</span>], STDIN_FILENO);
                    <span class="hljs-built_in">close</span>(prev_pipe_read[<span class="hljs-number">0</span>]);
                }
                
                <span class="hljs-comment">// 设置输出重定向（写入下一个管道）</span>
                <span class="hljs-keyword">if</span> (i &lt; commands.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) {
                    <span class="hljs-built_in">dup2</span>(pipefd[<span class="hljs-number">1</span>], STDOUT_FILENO);
                    <span class="hljs-built_in">close</span>(pipefd[<span class="hljs-number">0</span>]);
                    <span class="hljs-built_in">close</span>(pipefd[<span class="hljs-number">1</span>]);
                }
                
                <span class="hljs-comment">// 准备exec参数</span>
                std::vector&lt;<span class="hljs-type">char</span>*&gt; args;
                <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; arg : commands[i]) {
                    args.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(arg.<span class="hljs-built_in">c_str</span>()));
                }
                args.<span class="hljs-built_in">push_back</span>(<span class="hljs-literal">nullptr</span>);
                
                <span class="hljs-comment">// 执行命令</span>
                <span class="hljs-built_in">execvp</span>(args[<span class="hljs-number">0</span>], args.<span class="hljs-built_in">data</span>());
                
                <span class="hljs-comment">// exec失败才执行到这里</span>
                <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-comment">// 父进程代码</span>
                
                <span class="hljs-comment">// 关闭不再需要的描述符</span>
                <span class="hljs-keyword">if</span> (!prev_pipe_read.<span class="hljs-built_in">empty</span>()) {
                    <span class="hljs-built_in">close</span>(prev_pipe_read[<span class="hljs-number">0</span>]);
                }
                
                <span class="hljs-keyword">if</span> (i &lt; commands.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) {
                    <span class="hljs-built_in">close</span>(pipefd[<span class="hljs-number">1</span>]);  <span class="hljs-comment">// 父进程不需要写端</span>
                    prev_pipe_read = {pipefd[<span class="hljs-number">0</span>]};  <span class="hljs-comment">// 保存读端用于下一个进程</span>
                }
            }
        }
        
        <span class="hljs-comment">// 父进程等待所有子进程</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; commands.<span class="hljs-built_in">size</span>(); ++i) {
            <span class="hljs-built_in">wait</span>(<span class="hljs-literal">nullptr</span>);
        }
    }
};

<span class="hljs-comment">// 使用示例</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    Pipeline pipeline;
    
    <span class="hljs-comment">// 模拟: ls -l | grep ".cpp" | wc -l</span>
    pipeline.<span class="hljs-built_in">addCommand</span>({<span class="hljs-string">"ls"</span>, <span class="hljs-string">"-l"</span>});
    pipeline.<span class="hljs-built_in">addCommand</span>({<span class="hljs-string">"grep"</span>, <span class="hljs-string">"\\.cpp"</span>});
    pipeline.<span class="hljs-built_in">addCommand</span>({<span class="hljs-string">"wc"</span>, <span class="hljs-string">"-l"</span>});
    
    pipeline.<span class="hljs-built_in">execute</span>();
    
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<h3 data-id="heading-10">3.3 命名管道（FIFO）的深入理解</h3>
<p><strong>命名管道与匿名管道的区别</strong>：</p>






























<table><thead><tr><th>特性</th><th>匿名管道</th><th>命名管道（FIFO）</th></tr></thead><tbody><tr><td>持久性</td><td>进程结束即消失</td><td>文件系统中有实体文件</td></tr><tr><td>进程关系</td><td>必须有亲缘关系</td><td>任意进程都可访问</td></tr><tr><td>创建方式</td><td>pipe()系统调用</td><td>mkfifo()函数</td></tr><tr><td>访问控制</td><td>基于文件描述符继承</td><td>基于文件权限</td></tr></tbody></table>
<p><strong>创建和使用命名管道</strong>：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">NamedPipe</span> {
<span class="hljs-keyword">private</span>:
    std::string path;
    <span class="hljs-type">int</span> fd;
    
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">NamedPipe</span>(<span class="hljs-type">const</span> std::string&amp; pipePath) : <span class="hljs-built_in">path</span>(pipePath) {
        <span class="hljs-comment">// 创建命名管道（如果不存在）</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">mkfifo</span>(path.<span class="hljs-built_in">c_str</span>(), <span class="hljs-number">0666</span>) == <span class="hljs-number">-1</span>) {
            <span class="hljs-comment">// 如果已存在，忽略EEXIST错误</span>
            <span class="hljs-keyword">if</span> (errno != EEXIST) {
                <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">"无法创建命名管道"</span>);
            }
        }
    }
    
    <span class="hljs-comment">// 作为读取者打开</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">openForReading</span><span class="hljs-params">(<span class="hljs-type">bool</span> nonblock = <span class="hljs-literal">false</span>)</span> </span>{
        <span class="hljs-type">int</span> flags = O_RDONLY;
        <span class="hljs-keyword">if</span> (nonblock) flags |= O_NONBLOCK;
        
        fd = <span class="hljs-built_in">open</span>(path.<span class="hljs-built_in">c_str</span>(), flags);
        <span class="hljs-keyword">if</span> (fd == <span class="hljs-number">-1</span>) {
            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">"无法打开命名管道进行读取"</span>);
        }
    }
    
    <span class="hljs-comment">// 作为写入者打开</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">openForWriting</span><span class="hljs-params">(<span class="hljs-type">bool</span> nonblock = <span class="hljs-literal">false</span>)</span> </span>{
        <span class="hljs-type">int</span> flags = O_WRONLY;
        <span class="hljs-keyword">if</span> (nonblock) flags |= O_NONBLOCK;
        
        fd = <span class="hljs-built_in">open</span>(path.<span class="hljs-built_in">c_str</span>(), flags);
        <span class="hljs-keyword">if</span> (fd == <span class="hljs-number">-1</span>) {
            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">"无法打开命名管道进行写入"</span>);
        }
    }
    
    <span class="hljs-comment">// 读取数据</span>
    <span class="hljs-function">std::string <span class="hljs-title">readData</span><span class="hljs-params">(<span class="hljs-type">size_t</span> max_size = <span class="hljs-number">1024</span>)</span> </span>{
        <span class="hljs-type">char</span> buffer[max_size];
        <span class="hljs-type">ssize_t</span> bytes = <span class="hljs-built_in">read</span>(fd, buffer, max_size - <span class="hljs-number">1</span>);
        <span class="hljs-keyword">if</span> (bytes &gt; <span class="hljs-number">0</span>) {
            buffer[bytes] = <span class="hljs-string">'\0'</span>;
            <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">string</span>(buffer);
        }
        <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;
    }
    
    <span class="hljs-comment">// 写入数据</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">writeData</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; data)</span> </span>{
        <span class="hljs-built_in">write</span>(fd, data.<span class="hljs-built_in">c_str</span>(), data.<span class="hljs-built_in">length</span>());
    }
    
    ~<span class="hljs-built_in">NamedPipe</span>() {
        <span class="hljs-keyword">if</span> (fd != <span class="hljs-number">-1</span>) {
            <span class="hljs-built_in">close</span>(fd);
        }
        <span class="hljs-comment">// 可以选择是否删除管道文件</span>
        <span class="hljs-comment">// unlink(path.c_str());</span>
    }
};
</code></pre>
<h2 data-id="heading-11">第四章：高级主题——性能与并发</h2>
<h3 data-id="heading-12">4.1 非阻塞管道操作</h3>
<p>非阻塞管道在某些场景下非常有用，比如同时监控多个管道：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">NonBlockingPipe</span> {
<span class="hljs-keyword">private</span>:
    <span class="hljs-type">int</span> pipefd[<span class="hljs-number">2</span>];
    
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">NonBlockingPipe</span>() {
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pipe</span>(pipefd) == <span class="hljs-number">-1</span>) {
            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">"管道创建失败"</span>);
        }
        
        <span class="hljs-comment">// 设置为非阻塞模式</span>
        <span class="hljs-built_in">setNonBlocking</span>(pipefd[<span class="hljs-number">0</span>]);
        <span class="hljs-built_in">setNonBlocking</span>(pipefd[<span class="hljs-number">1</span>]);
    }
    
<span class="hljs-keyword">private</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setNonBlocking</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span> </span>{
        <span class="hljs-type">int</span> flags = <span class="hljs-built_in">fcntl</span>(fd, F_GETFL, <span class="hljs-number">0</span>);
        <span class="hljs-keyword">if</span> (flags == <span class="hljs-number">-1</span>) {
            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">"获取文件状态失败"</span>);
        }
        
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fcntl</span>(fd, F_SETFL, flags | O_NONBLOCK) == <span class="hljs-number">-1</span>) {
            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">"设置非阻塞模式失败"</span>);
        }
    }
    
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// 非阻塞读取</span>
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">tryRead</span><span class="hljs-params">(std::string&amp; result)</span> </span>{
        <span class="hljs-type">char</span> buffer[<span class="hljs-number">1024</span>];
        <span class="hljs-type">ssize_t</span> bytes = <span class="hljs-built_in">read</span>(pipefd[<span class="hljs-number">0</span>], buffer, <span class="hljs-built_in">sizeof</span>(buffer) - <span class="hljs-number">1</span>);
        
        <span class="hljs-keyword">if</span> (bytes &gt; <span class="hljs-number">0</span>) {
            buffer[bytes] = <span class="hljs-string">'\0'</span>;
            result = buffer;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bytes == <span class="hljs-number">-1</span> &amp;&amp; errno == EAGAIN) {
            <span class="hljs-comment">// 没有数据可读（非阻塞模式）</span>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
        
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 错误或EOF</span>
    }
};
</code></pre>
<h3 data-id="heading-13">4.2 使用select实现多路复用</h3>
<p>当需要同时监控多个管道时，select是一个非常有效的工具：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/select.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">PipeMonitor</span> {
<span class="hljs-keyword">private</span>:
    std::vector&lt;<span class="hljs-type">int</span>&gt; read_fds;  <span class="hljs-comment">// 需要监控的读描述符</span>
    
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addPipe</span><span class="hljs-params">(<span class="hljs-type">int</span> read_fd)</span> </span>{
        read_fds.<span class="hljs-built_in">push_back</span>(read_fd);
    }
    
    <span class="hljs-comment">// 监控所有管道，返回有数据可读的管道列表</span>
    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">monitor</span><span class="hljs-params">(<span class="hljs-type">int</span> timeout_sec = <span class="hljs-number">0</span>)</span> </span>{
        fd_set read_set;
        <span class="hljs-built_in">FD_ZERO</span>(&amp;read_set);
        
        <span class="hljs-type">int</span> max_fd = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> fd : read_fds) {
            <span class="hljs-built_in">FD_SET</span>(fd, &amp;read_set);
            <span class="hljs-keyword">if</span> (fd &gt; max_fd) max_fd = fd;
        }
        
        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">timeval</span> timeout;
        timeout.tv_sec = timeout_sec;
        timeout.tv_usec = <span class="hljs-number">0</span>;
        
        <span class="hljs-comment">// 使用select等待数据</span>
        <span class="hljs-type">int</span> ready = <span class="hljs-built_in">select</span>(max_fd + <span class="hljs-number">1</span>, &amp;read_set, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>, 
                          timeout_sec &gt;= <span class="hljs-number">0</span> ? &amp;timeout : <span class="hljs-literal">nullptr</span>);
        
        std::vector&lt;<span class="hljs-type">int</span>&gt; ready_fds;
        <span class="hljs-keyword">if</span> (ready &gt; <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> fd : read_fds) {
                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">FD_ISSET</span>(fd, &amp;read_set)) {
                    ready_fds.<span class="hljs-built_in">push_back</span>(fd);
                }
            }
        }
        
        <span class="hljs-keyword">return</span> ready_fds;
    }
};
</code></pre>
<h3 data-id="heading-14">4.3 零拷贝技术：splice()</h3>
<p>Linux提供了高级的系统调用来优化管道性能，避免不必要的数据拷贝：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">HighPerformancePipe</span> {
<span class="hljs-keyword">private</span>:
    <span class="hljs-type">int</span> pipefd[<span class="hljs-number">2</span>];
    
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">HighPerformancePipe</span>() {
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pipe</span>(pipefd) == <span class="hljs-number">-1</span>) {
            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">"管道创建失败"</span>);
        }
    }
    
    <span class="hljs-comment">// 使用splice实现零拷贝数据传输</span>
    <span class="hljs-comment">// 将数据从一个文件描述符直接移动到管道</span>
    <span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">transferFrom</span><span class="hljs-params">(<span class="hljs-type">int</span> source_fd, <span class="hljs-type">size_t</span> len)</span> </span>{
        <span class="hljs-comment">// splice从source_fd读取数据，直接写入管道</span>
        <span class="hljs-comment">// 避免了用户空间的内存拷贝</span>
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">splice</span>(source_fd, <span class="hljs-literal">nullptr</span>,        <span class="hljs-comment">// 源文件描述符</span>
                     pipefd[<span class="hljs-number">1</span>], <span class="hljs-literal">nullptr</span>,         <span class="hljs-comment">// 目标管道写端</span>
                     len,                        <span class="hljs-comment">// 传输长度</span>
                     SPLICE_F_MOVE | SPLICE_F_MORE);
    }
    
    <span class="hljs-comment">// 将数据从管道直接传输到目标文件描述符</span>
    <span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">transferTo</span><span class="hljs-params">(<span class="hljs-type">int</span> dest_fd, <span class="hljs-type">size_t</span> len)</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">splice</span>(pipefd[<span class="hljs-number">0</span>], <span class="hljs-literal">nullptr</span>,        <span class="hljs-comment">// 源管道读端</span>
                     dest_fd, <span class="hljs-literal">nullptr</span>,          <span class="hljs-comment">// 目标文件描述符</span>
                     len,
                     SPLICE_F_MOVE | SPLICE_F_MORE);
    }
};
</code></pre>
<h2 data-id="heading-15">第五章：最佳实践与错误处理</h2>
<h3 data-id="heading-16">5.1 RAII包装器</h3>
<p>为了避免资源泄漏，使用RAII（资源获取即初始化）模式管理管道：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">PipeRAII</span> {
<span class="hljs-keyword">private</span>:
    <span class="hljs-type">int</span> pipefd[<span class="hljs-number">2</span>];
    <span class="hljs-type">bool</span> valid;
    
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">PipeRAII</span>() : <span class="hljs-built_in">valid</span>(<span class="hljs-literal">false</span>) {
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pipe</span>(pipefd) == <span class="hljs-number">0</span>) {
            valid = <span class="hljs-literal">true</span>;
        }
    }
    
    ~<span class="hljs-built_in">PipeRAII</span>() {
        <span class="hljs-keyword">if</span> (valid) {
            <span class="hljs-built_in">close</span>(pipefd[<span class="hljs-number">0</span>]);
            <span class="hljs-built_in">close</span>(pipefd[<span class="hljs-number">1</span>]);
        }
    }
    
    <span class="hljs-comment">// 删除拷贝构造函数和赋值运算符</span>
    <span class="hljs-built_in">PipeRAII</span>(<span class="hljs-type">const</span> PipeRAII&amp;) = <span class="hljs-keyword">delete</span>;
    PipeRAII&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> PipeRAII&amp;) = <span class="hljs-keyword">delete</span>;
    
    <span class="hljs-comment">// 允许移动语义</span>
    <span class="hljs-built_in">PipeRAII</span>(PipeRAII&amp;&amp; other) <span class="hljs-keyword">noexcept</span> 
        : pipefd{other.pipefd[<span class="hljs-number">0</span>], other.pipefd[<span class="hljs-number">1</span>]}, 
          <span class="hljs-built_in">valid</span>(other.valid) {
        other.valid = <span class="hljs-literal">false</span>;
    }
    
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">readEnd</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> valid ? pipefd[<span class="hljs-number">0</span>] : <span class="hljs-number">-1</span>; }
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">writeEnd</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> valid ? pipefd[<span class="hljs-number">1</span>] : <span class="hljs-number">-1</span>; }
    
    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">bool</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> valid; }
};

<span class="hljs-comment">// 使用智能指针管理</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">SafePipeManager</span> {
<span class="hljs-keyword">private</span>:
    std::unique_ptr&lt;PipeRAII&gt; pipe;
    
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">SafePipeManager</span>() : <span class="hljs-built_in">pipe</span>(std::<span class="hljs-built_in">make_unique</span>&lt;PipeRAII&gt;()) {
        <span class="hljs-keyword">if</span> (!*pipe) {
            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">"管道创建失败"</span>);
        }
    }
    
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendData</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; data)</span> </span>{
        <span class="hljs-keyword">if</span> (pipe) {
            <span class="hljs-built_in">write</span>(pipe-&gt;<span class="hljs-built_in">writeEnd</span>(), data.<span class="hljs-built_in">c_str</span>(), data.<span class="hljs-built_in">length</span>());
        }
    }
};
</code></pre>
<h3 data-id="heading-17">5.2 常见错误与处理</h3>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RobustPipe</span> {
<span class="hljs-keyword">private</span>:
    <span class="hljs-type">int</span> pipefd[<span class="hljs-number">2</span>];
    
    <span class="hljs-comment">// 安全读取函数</span>
    <span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">safeRead</span><span class="hljs-params">(<span class="hljs-type">void</span>* buf, <span class="hljs-type">size_t</span> count)</span> </span>{
        <span class="hljs-type">ssize_t</span> bytes_read;
        <span class="hljs-keyword">do</span> {
            bytes_read = <span class="hljs-built_in">read</span>(pipefd[<span class="hljs-number">0</span>], buf, count);
        } <span class="hljs-keyword">while</span> (bytes_read == <span class="hljs-number">-1</span> &amp;&amp; errno == EINTR);  <span class="hljs-comment">// 处理信号中断</span>
        
        <span class="hljs-keyword">return</span> bytes_read;
    }
    
    <span class="hljs-comment">// 安全写入函数</span>
    <span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">safeWrite</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* buf, <span class="hljs-type">size_t</span> count)</span> </span>{
        <span class="hljs-type">ssize_t</span> bytes_written;
        <span class="hljs-type">size_t</span> total_written = <span class="hljs-number">0</span>;
        <span class="hljs-type">const</span> <span class="hljs-type">char</span>* ptr = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt;(buf);
        
        <span class="hljs-keyword">while</span> (total_written &lt; count) {
            <span class="hljs-keyword">do</span> {
                bytes_written = <span class="hljs-built_in">write</span>(pipefd[<span class="hljs-number">1</span>], ptr + total_written, 
                                     count - total_written);
            } <span class="hljs-keyword">while</span> (bytes_written == <span class="hljs-number">-1</span> &amp;&amp; errno == EINTR);
            
            <span class="hljs-keyword">if</span> (bytes_written == <span class="hljs-number">-1</span>) {
                <span class="hljs-comment">// 处理真正的错误</span>
                <span class="hljs-keyword">if</span> (errno == EPIPE) {
                    std::cerr &lt;&lt; <span class="hljs-string">"管道断裂：读端已关闭"</span> &lt;&lt; std::endl;
                }
                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
            }
            
            total_written += bytes_written;
        }
        
        <span class="hljs-keyword">return</span> total_written;
    }
    
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">RobustPipe</span>() {
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pipe</span>(pipefd) == <span class="hljs-number">-1</span>) {
            <span class="hljs-comment">// 检查具体错误</span>
            <span class="hljs-keyword">switch</span> (errno) {
                <span class="hljs-keyword">case</span> EMFILE:
                    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">"进程文件描述符耗尽"</span>);
                <span class="hljs-keyword">case</span> ENFILE:
                    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">"系统文件描述符耗尽"</span>);
                <span class="hljs-keyword">default</span>:
                    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">"未知管道创建错误"</span>);
            }
        }
        
        <span class="hljs-comment">// 设置管道缓冲区大小（可选）</span>
        <span class="hljs-type">int</span> size = <span class="hljs-number">65536</span>;  <span class="hljs-comment">// 64KB</span>
        <span class="hljs-built_in">fcntl</span>(pipefd[<span class="hljs-number">0</span>], F_SETPIPE_SZ, size);
    }
};
</code></pre>
<h2 data-id="heading-18">第六章：实战应用案例</h2>
<h3 data-id="heading-19">6.1 日志收集系统</h3>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">LogCollector</span> {
<span class="hljs-keyword">private</span>:
    <span class="hljs-type">int</span> log_pipe[<span class="hljs-number">2</span>];
    std::queue&lt;std::string&gt; log_queue;
    std::mutex queue_mutex;
    std::condition_variable queue_cv;
    std::thread worker_thread;
    <span class="hljs-type">bool</span> running;
    
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">worker</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-type">char</span> buffer[<span class="hljs-number">4096</span>];
        
        <span class="hljs-keyword">while</span> (running) {
            <span class="hljs-type">ssize_t</span> bytes = <span class="hljs-built_in">read</span>(log_pipe[<span class="hljs-number">0</span>], buffer, <span class="hljs-built_in">sizeof</span>(buffer) - <span class="hljs-number">1</span>);
            
            <span class="hljs-keyword">if</span> (bytes &gt; <span class="hljs-number">0</span>) {
                buffer[bytes] = <span class="hljs-string">'\0'</span>;
                <span class="hljs-function">std::string <span class="hljs-title">log_entry</span><span class="hljs-params">(buffer)</span></span>;
                
                {
                    <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(queue_mutex)</span></span>;
                    log_queue.<span class="hljs-built_in">push</span>(log_entry);
                }
                queue_cv.<span class="hljs-built_in">notify_one</span>();
            }
        }
    }
    
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">LogCollector</span>() : <span class="hljs-built_in">running</span>(<span class="hljs-literal">true</span>) {
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pipe</span>(log_pipe) == <span class="hljs-number">-1</span>) {
            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">"日志管道创建失败"</span>);
        }
        
        worker_thread = std::<span class="hljs-built_in">thread</span>(&amp;LogCollector::worker, <span class="hljs-keyword">this</span>);
    }
    
    ~<span class="hljs-built_in">LogCollector</span>() {
        running = <span class="hljs-literal">false</span>;
        <span class="hljs-built_in">close</span>(log_pipe[<span class="hljs-number">1</span>]);  <span class="hljs-comment">// 关闭写端，使读端退出</span>
        <span class="hljs-keyword">if</span> (worker_thread.<span class="hljs-built_in">joinable</span>()) {
            worker_thread.<span class="hljs-built_in">join</span>();
        }
        <span class="hljs-built_in">close</span>(log_pipe[<span class="hljs-number">0</span>]);
    }
    
    <span class="hljs-comment">// 写入日志</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">log</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; message)</span> </span>{
        <span class="hljs-built_in">write</span>(log_pipe[<span class="hljs-number">1</span>], message.<span class="hljs-built_in">c_str</span>(), message.<span class="hljs-built_in">length</span>());
    }
    
    <span class="hljs-comment">// 获取日志（线程安全）</span>
    <span class="hljs-function">std::string <span class="hljs-title">getLog</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(queue_mutex)</span></span>;
        queue_cv.<span class="hljs-built_in">wait</span>(lock, [<span class="hljs-keyword">this</span>] { <span class="hljs-keyword">return</span> !log_queue.<span class="hljs-built_in">empty</span>(); });
        
        std::string log = log_queue.<span class="hljs-built_in">front</span>();
        log_queue.<span class="hljs-built_in">pop</span>();
        <span class="hljs-keyword">return</span> log;
    }
};
</code></pre>
<h2 data-id="heading-20">总结</h2>
<p>管道编程是C++系统编程的重要部分，掌握它需要：</p>
<ol>
<li><strong>理解基本原理</strong>：文件描述符、缓冲区、阻塞行为</li>
<li><strong>掌握核心API</strong>：pipe(), fork(), dup2(), read(), write()</li>
<li><strong>学会高级技术</strong>：非阻塞IO、多路复用、零拷贝</li>
<li><strong>遵循最佳实践</strong>：RAII管理、错误处理、资源清理</li>
</ol>
<p>管道不仅是一种技术，更是一种设计哲学——它鼓励我们创建模块化、可组合的程序，这正是UNIX哲学的核心理念之一。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[VS Code 1.107 更新：多智能体协同与开发体验升级]]></title>    <link>https://juejin.cn/post/7584307642999537707</link>    <guid>https://juejin.cn/post/7584307642999537707</guid>    <pubDate>2025-12-16T11:13:08.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584307642999537707" data-draft-id="7584287969214070803" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="VS Code 1.107 更新：多智能体协同与开发体验升级"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2025-12-16T11:13:08.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="码事漫谈"/> <meta itemprop="url" content="https://juejin.cn/user/1972974802965230"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            VS Code 1.107 更新：多智能体协同与开发体验升级
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1972974802965230/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    码事漫谈
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-16T11:13:08.000Z" title="Tue Dec 16 2025 11:13:08 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-16
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>2025 年 12 月 10 日，微软正式发布了 VS Code 1.107 版本，这次更新堪称年度最重磅！<strong>多智能体协同开发</strong>成为核心亮点，彻底重构了开发者与 AI 协作的模式。想象一下，你可以同时部署多个 AI 助手分工合作：一个负责代码审查，一个处理单元测试，还有一个在后台默默重构 legacy 代码——这不再是科幻场景！</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d52455df60c84e1f86b5d74f160b2dbb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56CB5LqL5ryr6LCI:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766488388&amp;x-signature=eNiPuTrnir8zmc9yYe7V5ZexRlY%3D" alt="image.png" loading="lazy"/></p>
<h2 data-id="heading-0">多智能体协同：开发效率的革命性突破</h2>
<h3 data-id="heading-1">Agent HQ：你的 AI 团队指挥中心</h3>
<p>VS Code 1.107 引入了全新的 <strong>Agent HQ</strong> 概念，将所有智能体统一管理。现在，GitHub Copilot 不再是孤军奋战，你可以创建、配置多个自定义智能体，并让它们协同完成复杂任务。</p>
<p>最惊艳的是 <strong>会话管理功能</strong>！所有智能体会话都整合到聊天视图中，你能一目了然地看到每个任务的状态、进度和文件更改统计。右键点击会话，还能选择在编辑器标签页或新窗口中打开，灵活度拉满。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0cf7048587a944f4871619e7940eb0db~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56CB5LqL5ryr6LCI:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766488388&amp;x-signature=3yONxuXphV23qvW%2F%2FInRYHVFjNo%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-2">背景智能体：让 AI 在后台默默干活</h3>
<p><strong>背景智能体</strong> 彻底改变了工作流！以前用 Copilot 时，你必须等待它完成当前任务才能继续工作。现在，只需点击 <strong>Continue in</strong> 按钮，就能将任务无缝转移到后台智能体，自己继续专注于其他编码工作。</p>
<p>更厉害的是 <strong>Git 工作树隔离</strong> 技术！每个背景智能体都能在独立的 Git 工作树中运行，多个智能体同时修改代码也不会冲突。完成后，你可以一键将更改合并回主工作区，简直是多任务处理的终极解决方案！</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/597edcc556e942c685e12af746a53c21~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56CB5LqL5ryr6LCI:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766488388&amp;x-signature=ley2Th5PgZStx67vL9F2T8YHUWA%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-3">组织级智能体共享：团队协作新范式</h3>
<p>对于企业用户，1.107 版本带来了 <strong>组织级智能体共享</strong>（实验性功能）。管理员可以在 GitHub 组织级别定义智能体，团队成员无需手动导入就能直接使用。启用方法很简单：</p>
<ul>
<li>打开设置 <code>github.copilot.chat.customAgents.showOrganizationAndEnterpriseAgents</code></li>
<li>将其设为 <code>true</code></li>
</ul>
<p>从此，团队知识库、编码规范、最佳实践都能通过自定义智能体轻松传承，新人上手速度至少提升 50%！</p>
<h2 data-id="heading-4">聊天体验升级：AI 交互更自然</h2>
<h3 data-id="heading-5">语言模型管理：一键切换你的 "AI 大脑"</h3>
<p>面对越来越多的 AI 模型选择，VS Code 新增了 <strong>语言模型编辑器</strong>。在这里，你可以：</p>
<ul>
<li>查看所有可用模型的能力、上下文长度和计费信息</li>
<li>按提供商、能力（工具调用、视觉、智能体）筛选</li>
<li>隐藏不常用模型，让界面更清爽</li>
</ul>
<p>只需按下 <code>Ctrl+Shift+P</code> 并输入 <strong>Chat: Manage Language Models</strong>，就能打开这个强大的管理中心。</p>
<h3 data-id="heading-6">动态内容抓取：连 SPA 网站也能轻松解析</h3>
<p><code>#fetch</code> 工具现在支持 <strong>动态网页内容抓取</strong>！无论是 React、Vue 构建的单页应用，还是 Jira 这样的动态系统，都能准确获取内容。AI 现在能直接分析你公司的内部文档系统，回答问题不再局限于本地代码！</p>
<h3 data-id="heading-7">敏感文件编辑：安全与便捷的完美平衡</h3>
<p>修改 <code>package.json</code> 或 <code>settings.json</code> 这类敏感文件时，VS Code 会自动显示 <strong>差异对比视图</strong>，让你清晰看到每一处变更。再也不用担心 AI 误改配置导致项目崩溃了！</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d09085ede19746aba3d4ca78bf7ac859~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56CB5LqL5ryr6LCI:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766488388&amp;x-signature=Cl9QvjzYaYeW1hVQhVwlO93C3FQ%3D" alt="image.png" loading="lazy"/></p>
<h2 data-id="heading-8">编辑器体验优化：细节之处见真章</h2>
<h3 data-id="heading-9">按需悬停提示：告别干扰，专注编码</h3>
<p>终于可以告别烦人的自动悬停提示了！在设置中将 <code>editor.hover.enabled</code> 设为 <code>onKeyboardModifier</code>，悬停信息只会在按住特定修饰键时才显示。默认情况下：</p>
<ul>
<li>如果多光标修饰键是 <code>Ctrl/Cmd</code>，则按住 <code>Alt</code> 显示悬停</li>
<li>如果多光标修饰键是 <code>Alt</code>，则按住 <code>Ctrl</code> 显示悬停</li>
</ul>
<p>这个小改进，却能让编码专注度提升一个档次！</p>
<h3 data-id="heading-10">TypeScript 7.0 预览：原生重构，性能飞跃</h3>
<p>VS Code 1.107 带来了 <strong>TypeScript 7.0 预览支持</strong>！这个完全用原生代码重写的版本，性能提升堪称革命性。目前已支持自动导入、重命名和引用代码透镜，安装 <a href="https://link.juejin.cn?target=https%3A%2F%2Fmarketplace.visualstudio.com%2Fitems%3FitemName%3DTypeScriptTeam.native-preview" target="_blank" title="https://marketplace.visualstudio.com/items?itemName=TypeScriptTeam.native-preview" ref="nofollow noopener noreferrer">TypeScript (Native Preview)</a> 扩展即可体验。</p>
<p>根据微软官方数据，TypeScript 7.0 的类型检查速度比 5.0 快 <strong>3-5 倍</strong>，大型项目的编译时间将大幅缩短！</p>
<h2 data-id="heading-11">终端增强：命令行效率倍增</h2>
<h3 data-id="heading-12">终端输出捕获：历史命令随时回溯</h3>
<p>现在，聊天中的终端命令输出会完整保存在 <code>xterm.js</code> 终端中，即使终端已关闭也能随时查看。这意味着你可以：</p>
<ul>
<li>对比不同命令的执行结果</li>
<li>追溯智能体运行的脚本输出</li>
<li>分享完整的错误信息给同事</li>
</ul>
<h3 data-id="heading-13">一键允许所有命令：信任智能体，解放双手</h3>
<p>在聊天中运行终端命令时，新增了 <strong>Allow All Commands in this Session</strong> 选项。启用后，当前会话中的所有终端命令都会自动批准，无需反复确认。对于信任的智能体，这能节省大量交互时间！</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/101390277e4a45e084db64c5abb4fbba~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56CB5LqL5ryr6LCI:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766488388&amp;x-signature=PHDwOisPS0GAyIAcTOLs9k4%2FqFM%3D" alt="image.png" loading="lazy"/></p>
<h2 data-id="heading-14">企业级特性：安全与管理并重</h2>
<h3 data-id="heading-15">智能体工具权限控制：精细管理 AI 能力</h3>
<p>企业管理员现在可以通过 <code>chat.tools.eligibleForAutoApproval</code> 设置，精确控制哪些智能体工具允许自动批准。对于 <code>runTask</code> 这类高危操作，可以强制要求人工确认，安全性大大提升！</p>
<h3 data-id="heading-16">GitHub 企业策略支持：云端开发无缝衔接</h3>
<p>使用 GitHub Codespaces 的团队，现在能自动应用企业策略。无论是 MCP 注册表配置还是智能体权限，都能在云端开发环境中保持一致，开发体验无缝衔接。</p>
<h2 data-id="heading-17">总结：AI 驱动开发的未来已来</h2>
<p>VS Code 1.107 版本通过 <strong>多智能体协同</strong>、<strong>背景任务处理</strong> 和 <strong>组织级智能体共享</strong>，将 AI 辅助开发推向了新阶段。它不仅是工具的升级，更是开发范式的转变——从 "开发者使用 AI" 到 "开发者指挥 AI 团队"。</p>
<p>最令人兴奋的是，这仅仅是开始。随着 TypeScript 7.0 的成熟和更多 AI 能力的整合，VS Code 正在朝着 "开发者思维放大器" 的方向快速进化。</p>
<p>立即通过 <strong>帮助 &gt; 检查更新</strong> 升级到 1.107 版本，或访问 <a href="https://link.juejin.cn?target=https%3A%2F%2Fcode.visualstudio.com%2F" target="_blank" title="https://code.visualstudio.com/" ref="nofollow noopener noreferrer">VS Code 官网</a> 下载最新安装包，体验这场开发效率的革命！</p>
<blockquote>
<p><strong>提示</strong>：想抢先体验未来功能？可以安装 <a href="https://link.juejin.cn?target=https%3A%2F%2Fcode.visualstudio.com%2Finsiders%2F" target="_blank" title="https://code.visualstudio.com/insiders/" ref="nofollow noopener noreferrer">Insiders 版本</a>，每天获取最新更新！</p>
</blockquote>
<p>Happy Coding！🚀</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[如何查看、生成 github 开源项目star 图表]]></title>    <link>https://juejin.cn/post/7584071941025628175</link>    <guid>https://juejin.cn/post/7584071941025628175</guid>    <pubDate>2025-12-16T11:44:14.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584071941025628175" data-draft-id="7584266920641314867" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="如何查看、生成 github 开源项目star 图表"/> <meta itemprop="keywords" content="前端,开源,ECharts"/> <meta itemprop="datePublished" content="2025-12-16T11:44:14.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="玄魂"/> <meta itemprop="url" content="https://juejin.cn/user/571401774834093"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            如何查看、生成 github 开源项目star 图表
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/571401774834093/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    玄魂
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-16T11:44:14.000Z" title="Tue Dec 16 2025 11:44:14 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-16
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">声明</h2>
<blockquote>
<p>重要声明：本应用基于 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fstar-history%2Fstar-history" target="_blank" title="https://github.com/star-history/star-history" ref="nofollow noopener noreferrer">star-history/star-history</a> 改造升级，我们将持续加入更多数据分析能力，感谢原作者！本文档也在原仓库文档的基础上进行改写与完善。</p>
</blockquote>
<p>新的仓库地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fxuanhun%2Fgithub-data-analysis-" target="_blank" title="https://github.com/xuanhun/github-data-analysis-" ref="nofollow noopener noreferrer">github-data-analysis-</a></p>
<p>新项目更新了图表实现方式（<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.visactor.com%2Fvchart" target="_blank" title="https://www.visactor.com/vchart" ref="nofollow noopener noreferrer">@visactor/vchart</a>)，加入mongodb 进行数据缓存，以减少对 GitHub API 的调用次数，提升性能。
加入了dark 主题，多语言等</p>
<hr/>
<h2 data-id="heading-1">在 GitHub README 中加入实时的 Star 历史图</h2>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/041f8a08a9774fcab14c4357c201a1d3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg546E6a2C:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766490254&amp;x-signature=rdN8T4QV2avDcMW%2BdRGWZvLD47U%3D" alt="image.png" loading="lazy"/></p>
<p>我们支持把实时的 Star 历史图嵌入到你的 GitHub README 中。上图是我们自己的项目 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fvisactor%2Fvchart" target="_blank" title="https://github.com/visactor/vchart" ref="nofollow noopener noreferrer">GitHub 数据分析</a> 的截图。</p>
<p>这个功能非常好用：在站点页面查询仓库后，会生成一段代码片段，你只需要把它复制到你的 README（或任何站点/博客）即可。</p>
<img width="1302" height="903" alt="image转存失败，建议直接上传图片文件" src="" loading="lazy"/>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/08dceed37e9948188d51a9ddf51ec87b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg546E6a2C:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766490254&amp;x-signature=6uw%2Fvjwbd5l5IJ6Ixy3Ltu1PDUY%3D" alt="image.png" loading="lazy"/>
下面介绍该功能的设计背景与具体用法。</p>
<h3 data-id="heading-2">使用 <code>&lt;iframe /&gt;</code> 方式嵌入</h3>
<p>在调研常见的网页嵌入实现后，我们选择使用 <code>&lt;iframe /&gt;</code> 作为嵌入容器：它无需后端即可展示原始图表，并且可以与实时数据交互。</p>
<p>由于 GitHub API 对匿名调用有严格限流，我们需要用户提供自己生成的 Token 来提升限额。</p>
<h4 data-id="heading-3"><code>iframe</code> 嵌入的使用步骤</h4>
<ol>
<li>
<p>打开 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgitdata.xuanhun520.com%2F" target="_blank" title="https://gitdata.xuanhun520.com/" ref="nofollow noopener noreferrer">gitdata.xuanhun520.com</a> 并查询目标仓库；</p>
</li>
<li>
<p>点击图表下方的 <code>Embed</code> 按钮；</p>
</li>
<li>
<p>输入你的个人访问 Token；</p>
<img width="745" height="596" alt="image转存失败，建议直接上传图片文件" src="" loading="lazy"/>
</li>
</ol>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3c4b955faf39498bbfba4b6b866e183a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg546E6a2C:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766490254&amp;x-signature=fCwUkjsMQ2OZi%2B9YqBg99s6dOD4%3D" alt="image.png" loading="lazy"/>
4.  点击 <code>Copy</code> 按钮，把代码粘贴到你的站点或博客即可；</p>
<h3 data-id="heading-4">使用 SVG 静态图片嵌入（用于 README）</h3>
<p><code>iframe</code> 嵌入很强大，但也有两点限制：</p>
<ol>
<li>GitHub 的 Markdown 风格不允许渲染 <code>&lt;iframe /&gt;</code>，因此无法直接把交互图嵌到 README；</li>
<li>需要提供个人 Token。虽然我们不在服务器端存储 Token，但在网页源码中仍可看到它，这在公共场景下并不理想。</li>
</ol>
<p>因此，我们提供了基于图片链接的 SVG 方案，适合在公共页面（例如仓库 README）中展示最新星图。</p>
<h4 data-id="heading-5">在 GitHub README 中添加图表的步骤</h4>
<ol>
<li>
<p>打开 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgitdata.xuanhun520.com" target="_blank" title="https://gitdata.xuanhun520.com" ref="nofollow noopener noreferrer">gitdata.xuanhun520.com</a> 并查询仓库；</p>
</li>
<li>
<p>滚动到操作按钮下方的图片嵌入区域；</p>
</li>
</ol>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/107047db28f84d0ba6c4cc2fa79b247a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg546E6a2C:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766490254&amp;x-signature=Yk3833YHxok%2BY8VsIXlm7VMWAPg%3D" alt="image.png" loading="lazy"/>
3.  点击 <code>Copy</code> 按钮；</p>
<ol start="4">
<li>
<p>将代码粘贴到你的仓库 README 中；</p>
</li>
<li>
<p>搞定 😎</p>
</li>
</ol>
<p>示例链接（按日期模式展示）：</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgitdata.xuanhun520.com%2Fapi%2Fstarimg%3Frepos%3Dvisactor%2Fvchart%26type%3DDate%26theme%3Ddark" target="_blank" title="https://gitdata.xuanhun520.com/api/starimg?repos=visactor/vchart&amp;type=Date&amp;theme=dark" ref="nofollow noopener noreferrer">gitdata.xuanhun520.com/api/starimg…</a></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9d3deef95f4e4689b18a313ca46dc75d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg546E6a2C:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766490254&amp;x-signature=4vmt40xt5AfN5fie7mHPIXOj28s%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-6">结论</h3>
<p>我们提供两种把实时星图嵌入网页的方式：</p>
<ul>
<li>如果你希望在私有网络页面中放置可自适应且可交互的图表，请使用 <code>&lt;iframe /&gt;</code> 嵌入；</li>
<li>如果你希望在公共页面（例如 GitHub README）中展示最新的星图，请使用 SVG 图片链接方式，例如：</li>
</ul>

<pre><code class="hljs language-bash" lang="bash">https://gitdata.xuanhun520.com/api/starimg?repos=visactor/vchart&amp;<span class="hljs-built_in">type</span>=Date&amp;theme=dark
</code></pre>
<hr/>
<h3 data-id="heading-7">下一步</h3>
<ul>
<li>多语言</li>
<li>加入更多数据分析能力，例如：仓库 forks 历史图、贡献者活动图等；</li>
<li>加入用户认证功能，以支持私有仓库的分析；</li>
<li>加入更多可视化形式，例如信息图，动态图表等</li>
</ul>
<h3 data-id="heading-8">欢迎star</h3>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fxuanhun%2Fgithub-data-analysis-" target="_blank" title="https://github.com/xuanhun/github-data-analysis-" ref="nofollow noopener noreferrer">star it </a></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/398616932b064d5d87643629d0207605~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg546E6a2C:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766490254&amp;x-signature=5JYziidoTbedFxoX5a0eIoxi9Tc%3D" alt="image.png" loading="lazy"/></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[ruoyi集成dmn规则引擎]]></title>    <link>https://juejin.cn/post/7583878719543738377</link>    <guid>https://juejin.cn/post/7583878719543738377</guid>    <pubDate>2025-12-15T10:22:59.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7583878719543738377" data-draft-id="7583871118949236786" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="ruoyi集成dmn规则引擎"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2025-12-15T10:22:59.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="代码次位面"/> <meta itemprop="url" content="https://juejin.cn/user/1535333867720295"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            ruoyi集成dmn规则引擎
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1535333867720295/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    代码次位面
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-15T10:22:59.000Z" title="Mon Dec 15 2025 10:22:59 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-15
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读2分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">环境说明</h2>
<p>基于RuoYi-Vue2q前端如何集成DMN组件<br/>
版本号:3.9.0<br/>
更多关于ruoyi集成工作流，请访问<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.ruoyiflow.com%2Fproduct%2F3" target="_blank" title="https://www.ruoyiflow.com/product/3" ref="nofollow noopener noreferrer">若依工作流</a></p>
<h2 data-id="heading-1">集成步骤</h2>
<ul>
<li>安装依赖</li>
</ul>
<pre><code class="hljs language-shell" lang="shell">npm install dmn-js dmn-js-properties-panel --save
npm install --save dmn-moddle
</code></pre>
<ul>
<li>vue.config.js增加dmn.js配置, 在transpileDependencies，alias 进行设置</li>
</ul>
<pre><code class="hljs language-shell" lang="shell">lias: {
    '@': resolve('src'),
    'lezer-feel$': resolve('node_modules/lezer-feel/dist/index.js'),
    '@camunda/feel-builtins$': resolve('node_modules/@camunda/feel-builtins/dist/index.js'),
    'feelers$': resolve('node_modules/feelers/dist/index.js'),
    'feelin$': resolve('node_modules/feelin/dist/index.cjs'),
    '@bpmn-io/feel-lint$': resolve('node_modules/@bpmn-io/feel-lint/dist/index.js'),
    '@bpmn-io/lezer-feel$': resolve('node_modules/@bpmn-io/lezer-feel/dist/index.js'),
    // dmn-moddle 使用 ES 模块，webpack4 需要指向 CJS 版本
    'dmn-moddle$': resolve('node_modules/dmn-moddle/dist/index.cjs')
    }

  transpileDependencies: [
    'quill', 
    'bpmn-js', 
    'diagram-js',
    'bpmn-js-properties-panel',
    '@bpmn-io/properties-panel',
    '@bpmn-io/feel-editor',
    '@bpmn-io/feel-lint', 
    '@bpmn-io/lezer-feel', 
    'feelers', 
    //以下是dmn-js需要的配置，主要是因为dmn-js 使用了 ES6+ 语法，但 webpack 未转译 node_modules 中的这些文件
    'lezer-feel',
    'dmn-js',
    'dmn-js-properties-panel',
    'dmn-js-boxed-expression',
    'dmn-js-decision-table',
    'dmn-js-literal-expression',
    'dmn-js-shared',
    'dmn-moddle'],
</code></pre>
<ul>
<li>前端页面编码</li>
</ul>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;el-container class="dmn-modeler-container"&gt;
    &lt;!-- 头部操作区域 --&gt;
    &lt;el-header class="dmn-header"&gt;
      &lt;div class="header-content"&gt;
        &lt;div class="header-title"&gt;
          &lt;h3&gt;DMN 决策表建模器&lt;/h3&gt;
        &lt;/div&gt;
        &lt;div class="header-actions"&gt;
          &lt;el-button-group&gt;
            &lt;el-button icon="el-icon-folder-opened" @click="openFile"&gt;导入&lt;/el-button&gt;
            &lt;el-button icon="el-icon-download" @click="downloadDiagram"&gt;导出&lt;/el-button&gt;
            &lt;el-button icon="el-icon-document" type="primary" @click="saveDiagram"&gt;部署&lt;/el-button&gt;
          &lt;/el-button-group&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/el-header&gt;
    
    &lt;!-- 主要内容区域 --&gt;
    &lt;el-main class="dmn-main"&gt;
      &lt;div class="dmn-content"&gt;
        &lt;!-- DMN 画布区域 --&gt;
        &lt;div class="canvas-container"&gt;
          &lt;div id="canvas" class="dmn-canvas" v-loading="initializing"&gt;&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/el-main&gt;
    
    &lt;!-- 文件输入 --&gt;
    &lt;input 
      ref="fileInput" 
      type="file" 
      accept=".dmn,.xml" 
      style="display: none" 
      @change="handleFileImport"
    /&gt;
  &lt;/el-container&gt;
&lt;/template&gt;

&lt;script&gt;
import DmnModeler from 'dmn-js/lib/Modeler'
import FileSaver from 'file-saver'
import { deployDmnTable } from '@/api/camunda/dmn'

// 样式引入
// 基础样式
import 'dmn-js/dist/assets/diagram-js.css'
// DMN 字体样式
import 'dmn-js/dist/assets/dmn-font/css/dmn.css'
// 决策表相关样式（确保决策表正确显示）
import 'dmn-js/dist/assets/dmn-js-shared.css'
import 'dmn-js/dist/assets/dmn-js-decision-table.css'
import 'dmn-js/dist/assets/dmn-js-decision-table-controls.css'
// DRD (Decision Requirements Diagram) 视图样式
import 'dmn-js/dist/assets/dmn-js-drd.css'

export default {
  name: 'CamundaDmnModeler',
  data() {
    return {
      dmnModeler: null,
      canUndo: false,
      canRedo: false,
      isInitialized: false, // 标记是否初始化成功
      initializing: false, // 初始化或导入中的 loading 状态
      initPromise: null // 记录初始化 Promise，便于后续等待
    }
  },
  mounted() {
    this.$nextTick(() =&gt; {
      this.initModeler()
    })
  },
  beforeDestroy() {
    if (this.dmnModeler) {
      this.dmnModeler.destroy()
      this.dmnModeler = null
    }
    this.initPromise = null
  },
  methods: {
    // 生成随机决策表ID
    generateDecisionId() {
      const randomNum = Math.floor(Math.random() * 10000)
      return `Decision_${randomNum}`
    },

    initModeler() {
      if (this.initializing &amp;&amp; this.initPromise) {
        return this.initPromise
      }

      try {
        // 如果已有实例，先销毁重新创建，避免残留状态
        if (this.dmnModeler) {
          try {
            this.dmnModeler.destroy()
          } catch (destroyErr) {
            console.warn('销毁旧的 DMN Modeler 失败:', destroyErr)
          }
        }

        this.dmnModeler = new DmnModeler({
          container: '#canvas'
        })
        this.initializing = true
        this.isInitialized = false
        
        // 加载空白决策表 - 使用标准的 DMN 1.3 格式
        // 根据 dmn-moddle 11.0.0，使用正确的命名空间
        const decisionId = this.generateDecisionId()
        const decisionTableId = 'DecisionTable_' + Date.now()
        const diagramXML = `&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;definitions xmlns="https://www.omg.org/spec/DMN/20191111/MODEL/" xmlns:dmndi="http://www.omg.org/spec/DMN/20180521/DMNDI" xmlns:di="http://www.omg.org/spec/DMN/20180521/DI/" xmlns:dc="http://www.omg.org/spec/DMN/20180521/DC/" id="Definitions_1" name="决策表" namespace="http://camunda.org/schema/1.0/dmn"&gt;
  &lt;decision id="${decisionId}" name="决策表"&gt;
    &lt;decisionTable id="${decisionTableId}" hitPolicy="UNIQUE"&gt;
      &lt;input id="Input_1" label="输入"&gt;
        &lt;inputExpression id="InputExpression_1" typeRef="string"&gt;
          &lt;text&gt;&lt;/text&gt;
        &lt;/inputExpression&gt;
      &lt;/input&gt;
      &lt;output id="Output_1" label="输出" typeRef="string" /&gt;
    &lt;/decisionTable&gt;
  &lt;/decision&gt;
  &lt;dmndi:DMNDI&gt;
    &lt;dmndi:DMNDiagram id="DMNDiagram_1"&gt;
      &lt;dmndi:DMNShape id="DMNShape_${decisionId}" dmnElementRef="${decisionId}"&gt;
        &lt;dc:Bounds x="100" y="100" width="300" height="200" /&gt;
      &lt;/dmndi:DMNShape&gt;
    &lt;/dmndi:DMNDiagram&gt;
  &lt;/dmndi:DMNDI&gt;
&lt;/definitions&gt;`

        // 使用箭头函数确保 this 上下文正确
        const initTask = this.dmnModeler.importXML(diagramXML)
        this.initPromise = initTask
        initTask.then(() =&gt; {
          // 只有在 importXML 成功后才标记为已初始化
          this.isInitialized = true
          this.initializing = false
          this.$message.success('决策表初始化成功')
          
          // 确保 dmnModeler 已完全初始化后再访问服务
          if (this.dmnModeler &amp;&amp; typeof this.dmnModeler.get === 'function') {
            // 等待 DOM 更新
            this.$nextTick(() =&gt; {
              // 监听撤销重做状态
              const eventBus = this.dmnModeler.get('eventBus')
              if (eventBus) {
                eventBus.on('commandStack.changed', () =&gt; {
                  if (this.dmnModeler &amp;&amp; typeof this.dmnModeler.get === 'function') {
                    const commandStack = this.dmnModeler.get('commandStack')
                    if (commandStack) {
                      this.canUndo = commandStack.canUndo()
                      this.canRedo = commandStack.canRedo()
                    }
                  }
                })
              }
              
            })
          }
        }).catch(err =&gt; {
          console.error('初始化失败:', err)
          console.error('XML 内容:', diagramXML)
          this.isInitialized = false
          this.initializing = false
          this.$message.error('决策表初始化失败: ' + (err.message || '未知错误'))
          // 如果初始化失败，清空 dmnModeler，避免使用不完整的状态
          if (this.dmnModeler) {
            try {
              this.dmnModeler.destroy()
            } catch (e) {
              console.warn('销毁失败的 modeler:', e)
            }
            this.dmnModeler = null
          }
          throw err
        }).finally(() =&gt; {
          // 保持 initPromise 只代表最近一次初始化
          if (this.initPromise === initTask) {
            this.initPromise = null
          }
        })

        return initTask
      } catch (err) {
        console.error('创建 DMN Modeler 失败:', err)
        this.$message.error('创建决策表建模器失败: ' + (err.message || '未知错误'))
        this.initializing = false
        this.isInitialized = false
        this.initPromise = null
        throw err
      }
    },

    async ensureModelerReady() {
      debugger
      if (this.isInitialized &amp;&amp; this.dmnModeler &amp;&amp; typeof this.dmnModeler.get === 'function') {
        return true
      }
      if (!this.initializing || !this.initPromise) {
        try {
          await this.initModeler()
        } catch (err) {
          console.error('重新初始化决策表建模器失败:', err)
          return false
        }
      }
      if (this.initPromise) {
        try {
          await this.initPromise
        } catch (err) {
          console.error('等待决策表建模器初始化失败:', err)
          return false
        }
      }
      return this.isInitialized &amp;&amp; this.dmnModeler &amp;&amp; typeof this.dmnModeler.get === 'function'
    },

    // 确保XML包含必要的命名空间
    ensureDmnNamespace(xml) {
      // 检查是否包含正确的 DMN 1.3 命名空间
      // MODEL 命名空间应该是 https://www.omg.org/spec/DMN/20191111/MODEL/
      if (xml.indexOf('xmlns="https://www.omg.org/spec/DMN/20191111/MODEL/"') === -1 &amp;&amp; 
          xml.indexOf('xmlns:dmn="https://www.omg.org/spec/DMN/20191111/MODEL/"') === -1) {
        // 如果缺少默认命名空间，尝试添加
        if (xml.indexOf('&lt;definitions') !== -1) {
          // 替换 definitions 标签，添加默认命名空间
          xml = xml.replace(
            /&lt;definitions([^&gt;]*)&gt;/,
            '&lt;definitions$1 xmlns="https://www.omg.org/spec/DMN/20191111/MODEL/" xmlns:dmndi="http://www.omg.org/spec/DMN/20180521/DMNDI" xmlns:di="http://www.omg.org/spec/DMN/20180521/DI/" xmlns:dc="http://www.omg.org/spec/DMN/20180521/DC/"&gt;'
          )
        } else if (xml.indexOf('&lt;dmn:definitions') !== -1) {
          // 如果使用 dmn: 前缀，也添加命名空间
          xml = xml.replace(
            /&lt;dmn:definitions([^&gt;]*)&gt;/,
            '&lt;dmn:definitions$1 xmlns:dmn="https://www.omg.org/spec/DMN/20191111/MODEL/" xmlns:dmndi="http://www.omg.org/spec/DMN/20180521/DMNDI" xmlns:di="http://www.omg.org/spec/DMN/20180521/DI/" xmlns:dc="http://www.omg.org/spec/DMN/20180521/DC/"&gt;'
          )
        }
      }
      return xml
    },

    // 从 XML 中提取第一个 decision 的 name 属性
    extractDecisionName(xml) {
      if (!xml || typeof xml !== 'string') {
        return null
      }
      try {
        if (typeof window !== 'undefined' &amp;&amp; window.DOMParser) {
          const parser = new DOMParser()
          const doc = parser.parseFromString(xml, 'text/xml')
          const parserError = doc.getElementsByTagName('parsererror')
          if (parserError &amp;&amp; parserError.length) {
            console.warn('DOMParser 解析 DMN XML 出错，退回正则解析')
          } else {
            // 先尝试不带命名空间的 decision
            let decisionEl = doc.getElementsByTagName('decision')[0]
            if (!decisionEl) {
              // 再尝试带命名空间的 decision
              decisionEl = doc.getElementsByTagNameNS('https://www.omg.org/spec/DMN/20191111/MODEL/', 'decision')[0]
            }
            if (decisionEl) {
              const name = decisionEl.getAttribute('name')
              if (name) {
                return name
              }
            }
          }
        }
      } catch (err) {
        console.warn('DOMParser 提取决策名称失败:', err)
      }

      // 正则后备方案，兼容单引号或双引号
      const match = xml.match(/&lt;\s*(?:dmn:)?decision\b[^&gt;]*\bname=['"]([^'"]+)['"]/i)
      if (match &amp;&amp; match[1]) {
        return match[1]
      }
      return null
    },

    async saveDiagram() {
      try {
        // const ready = await this.ensureModelerReady()
        // if (!ready) {
        //   this.$message.error('决策表建模器未初始化，请稍后再试')
        //   return
        // }
        
        const modeler = this.dmnModeler
        // if (!modeler || typeof modeler.get !== 'function') {
        //   this.$message.error('决策表建模器不可用，请刷新页面后重试')
        //   return
        // }

        const { xml } = await modeler.saveXML({ 
          format: true,
          preamble: true
        })
        
        // 确保XML包含必要的命名空间
        const processedXml = this.ensureDmnNamespace(xml)
        
        // 获取决策表名称：优先读取 XML 中 decision 的 name
        let decisionName = this.extractDecisionName(processedXml)
        
        if (!decisionName) {
          try {
            const elementRegistry = modeler.get('elementRegistry')
            if (elementRegistry) {
              // 尝试从决策表中获取名称
              const decisions = elementRegistry.filter(el =&gt; el.type === 'dmn:Decision')
              if (decisions.length &gt; 0) {
                const decision = decisions[0]
                const bo = decision.businessObject || decision
                decisionName = bo.name || bo.id || decisionName
              }
            }
          } catch (e) {
            console.warn('从 elementRegistry 获取决策表名称失败:', e)
          }
        }

        if (!decisionName) {
          decisionName = 'decision_' + Date.now()
        }
        
        // 准备部署参数
        const deployData = {
          decisionName: decisionName,
          dmnXml: processedXml,
          tenantId: '',
          description: '决策表部署'
        }
        
        // 调用部署API
        this.$message.info('正在部署决策表...')
        const response = await deployDmnTable(deployData)
        
        this.$message.success(`决策表部署成功！决策名称: ${decisionName}`)
        
        console.log('Deployment response:', response)
        // 跳转到决策表列表页面
        this.$router.push('/dmn/list')
        
      } catch (err) {
        console.error('Deployment error:', err)
        const errorMessage = err.response?.data?.message || err.message || '部署失败'
        this.$message.error('部署失败: ' + errorMessage)
      }
    },

    async downloadDiagram() {
      try {
        // const ready = await this.ensureModelerReady()
        // if (!ready) {
        //   this.$message.error('决策表建模器未初始化，请稍后再试')
        //   return
        // }
        
        const modeler = this.dmnModeler
        // if (!modeler || typeof modeler.get !== 'function') {
        //   this.$message.error('决策表建模器不可用，请刷新页面后重试')
        //   return
        // }

        const { xml } = await modeler.saveXML({ 
          format: true,
          preamble: true
        })
        // 确保XML包含必要的命名空间
        const processedXml = this.ensureDmnNamespace(xml)
        const blob = new Blob([processedXml], { type: 'application/xml' })
        FileSaver.saveAs(blob, 'decision-table.dmn')
      } catch (err) {
        this.$message.error('导出失败: ' + (err.message || '未知错误'))
      }
    },

    openFile() {
      this.$refs.fileInput.click()
    },
    
    async handleFileImport(event) {
      const file = event.target.files[0]
      if (!file) return
      
      // const ready = await this.ensureModelerReady()
      // if (!ready) {
      //   this.$message.error('决策表建模器初始化失败，请刷新页面后重试')
      //   return
      // }
      
      const reader = new FileReader()
      reader.onload = (e) =&gt; {
        try {
          const xml = e.target.result
          this.initializing = true
          const modeler = this.dmnModeler
          // if (!modeler || typeof modeler.get !== 'function') {
          //   this.initializing = false
          //   this.$message.error('决策表建模器不可用，请刷新页面后重试')
          //   return
          // }
          modeler.importXML(xml).then(() =&gt; {
            this.isInitialized = true
            this.initializing = false
            this.$message.success('文件导入成功')
          }).catch(error =&gt; {
            console.error('文件导入失败:', error)
            this.isInitialized = false
            this.initializing = false
            this.$message.error('文件导入失败: ' + (error.message || '未知错误'))
          })
        } catch (error) {
          console.error('文件读取失败:', error)
          this.initializing = false
          this.$message.error('文件读取失败: ' + (error.message || '未知错误'))
        }
      }
      reader.readAsText(file)
      
      // 清空文件输入
      event.target.value = ''
    }
  }
}
&lt;/script&gt;

&lt;style scoped&gt;
.dmn-modeler-container {
  width: 100%;
  height: 100vh;
  min-width: 900px;
  display: flex;
  flex-direction: column;
}

/* 头部样式 */
.dmn-header {
  background-color: #f5f7fa;
  border-bottom: 1px solid #e4e7ed;
  padding: 0 20px;
  height: 60px !important;
  display: flex;
  align-items: center;
}

.header-content {
  width: 100%;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.header-title h3 {
  margin: 0;
  color: #303133;
  font-size: 18px;
  font-weight: 500;
}

.header-actions {
  display: flex;
  gap: 15px;
  flex-wrap: wrap;
}

.header-actions .el-button-group {
  margin-right: 0;
}

.header-actions .el-button-group .el-button {
  margin-right: 0;
}

/* 主内容区域样式 */
.dmn-main {
  padding: 0;
  height: calc(100vh - 60px);
  overflow: hidden;
}

.dmn-content {
  display: flex;
  height: 100%;
  width: 100%;
}

/* 画布容器样式 */
.canvas-container {
  flex: 1;
  position: relative;
  display: flex;
  flex-direction: column;
  min-width: 0; /* 允许 flex 子元素缩小 */
}

.dmn-canvas {
  width: 100%;
  height: 100%;
  border: 1px solid #dcdfe6;
  background-color: #fff;
}

&lt;/style&gt;

</code></pre>
<h2 data-id="heading-2">最终页面展示</h2>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8a96e614955d4819805d2fc81d5ca3c0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Luj56CB5qyh5L2N6Z2i:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766398979&amp;x-signature=Mz%2BtwnNwYlHxCrRajjgE55UwMz0%3D" alt="dmn1.png" loading="lazy"/></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[三分钟搞懂 Kotlin Flow 中的背压]]></title>    <link>https://juejin.cn/post/7583325900294995968</link>    <guid>https://juejin.cn/post/7583325900294995968</guid>    <pubDate>2025-12-15T01:22:45.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7583325900294995968" data-draft-id="7576676694784835618" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="三分钟搞懂 Kotlin Flow 中的背压"/> <meta itemprop="keywords" content="Kotlin,Android"/> <meta itemprop="datePublished" content="2025-12-15T01:22:45.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="RockByte"/> <meta itemprop="url" content="https://juejin.cn/user/1046390797768519"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            三分钟搞懂 Kotlin Flow 中的背压
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1046390797768519/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    RockByte
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-15T01:22:45.000Z" title="Mon Dec 15 2025 01:22:45 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-15
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:14px;overflow-x:hidden;color:var(--cyanosis-base-color);transition:color .35s;--cyanosis-base-color:#353535;--cyanosis-title-color:#005bb7;--cyanosis-strong-color:#2196f3;--cyanosis-em-color:#4fc3f7;--cyanosis-del-color:#ccc;--cyanosis-link-color:#3da8f5;--cyanosis-linkh-color:#007fff;--cyanosis-border-color:#bedcff;--cyanosis-border-color-2:#ececec;--cyanosis-bg-color:#fff;--cyanosis-blockquote-color:#8c8c8c;--cyanosis-blockquote-bg-color:#f0fdff;--cyanosis-code-color:#c2185b;--cyanosis-code-bg-color:#fff4f4;--cyanosis-code-pre-color:#f8f8f8;--cyanosis-table-border-color:#c3e0fd;--cyanosis-table-th-color:#dff0ff;--cyanosis-table-tht-color:#005bb7;--cyanosis-table-tr-nc-color:#f7fbff;--cyanosis-table-trh-color:#e0edf7;--cyanosis-slct-title-color:#005bb7;--cyanosis-slct-titlebg-color:rgba(175,207,247,0.25);--cyanosis-slct-text-color:#c80000;--cyanosis-slct-bg-color:rgba(175,207,247,0.25);--cyanosis-slct-del-color:#999;--cyanosis-slct-elbg-color:#e8ebec;--cyanosis-slct-codebg-color:#ffeaeb;--cyanosis-slct-prebg-color:rgba(160,200,255,0.25)}.markdown-body.__dark{--cyanosis-base-color:#cacaca;--cyanosis-title-color:#ddd;--cyanosis-strong-color:#fe9900;--cyanosis-em-color:#ffd28e;--cyanosis-del-color:#ccc;--cyanosis-link-color:#ffb648;--cyanosis-linkh-color:#fe9900;--cyanosis-border-color:#ffe3ba;--cyanosis-border-color-2:#ffcb7b;--cyanosis-bg-color:#2f2f2f;--cyanosis-blockquote-color:#c7c7c7;--cyanosis-blockquote-bg-color:rgba(255,199,116,0.1);--cyanosis-code-color:#000;--cyanosis-code-bg-color:#ffcb7b;--cyanosis-code-pre-color:rgba(255,227,185,0.5);--cyanosis-table-border-color:#fe9900;--cyanosis-table-th-color:#ffb648;--cyanosis-table-tht-color:#000;--cyanosis-table-tr-nc-color:#6d5736;--cyanosis-table-trh-color:#947443;--cyanosis-slct-title-color:#000;--cyanosis-slct-titlebg-color:#fe9900;--cyanosis-slct-text-color:#00c888;--cyanosis-slct-bg-color:rgba(175,207,247,0.25);--cyanosis-slct-del-color:#999;--cyanosis-slct-elbg-color:#000;--cyanosis-slct-codebg-color:#ffcb7b;--cyanosis-slct-prebg-color:rgba(160,200,255,0.25)}.markdown-body h1{padding-bottom:4px;font-size:30px}.markdown-body h1,.markdown-body h2{margin-top:36px;margin-bottom:10px;line-height:1.5;color:var(--cyanosis-title-color);transition:color .35s}.markdown-body h2{position:relative;padding-left:10px;padding-right:10px;padding-bottom:10px;font-size:24px;border-bottom:1px solid var(--cyanosis-border-color-2)}.markdown-body h2:before{content:"「";position:absolute;top:-6px;left:-14px}.markdown-body h2:after{content:"」";position:relative;top:6px;right:auto}.markdown-body h3{position:relative;padding-bottom:0;margin-top:30px;margin-bottom:10px;font-size:20px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body h3:before{content:"»";padding-right:6px;color:var(--cyanosis-strong-color)}.markdown-body h4{margin-top:24px;font-size:16px}.markdown-body h4,.markdown-body h5{padding-bottom:0;margin-bottom:10px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body h5{margin-top:18px;font-size:14px}.markdown-body h6{padding-bottom:0;margin-top:12px;margin-bottom:10px;font-size:12px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body p{line-height:inherit;margin-top:16px;margin-bottom:16px}.markdown-body img{max-width:100%}.markdown-body hr{position:relative;width:98%;height:1px;margin-top:32px;margin-bottom:32px;background-image:linear-gradient(90deg,var(--cyanosis-link-color),rgba(255,0,0,.3),hsla(0,0%,100%,.1),rgba(255,0,0,.3),var(--cyanosis-link-color));border-width:0;overflow:visible}.markdown-body hr:after{content:"";position:absolute;margin:auto;left:0;right:0;bottom:0;top:0;display:inline-block;width:60px;height:20px;background-color:var(--cyanosis-bg-color);background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAgCAYAAABgrToAAAADoklEQVRYR82XTYgcRRTHf2933Q1RjAa9eFO8JHoJ8RQVBQ2iBwXBET0YEUTXNVmNQtTpmeqaWV0XNRq/o4KoECSCEPSg4CF+BYUkIIiCoCJCPIhC/Ihh2Z0nVV27VnZnenumW9i6ddV7//frV69fVQurfMgq56NawFTPAU6QyomqXrw6wIZeyhCPebA5buNR+akKyGoAjd6BshthnYdSjqNcRVuOlIUsD2j0SuA94IwuMHdh5ZUykOUBXfSGbmKI54EtAeYIHSZoy5dl4JxvNYBOKdW1KE8BQ8AkVk6WhasWsAiN0TX9gveXQaPP+Aytpc4u+bMI06JNohsYYYYOR2lJWtS3OKDRfcAtQfgDoI6Vo4UCGb0OmAEuDvZvYmVbEd/igC3dzDz7gQu8sPA9kJDK27mBmjqBeLjTg90PDFOjWawFFQd06kZHEfaj3LAIpTRpSXsZ5E06zEYP9sDimnAApYaV2SLZG/wjMeqAkijwW4xQJ5Gf/ZzRC8OW3hiBTGGlURRswW55Bh/Ssxljrwew8l1PQaM14GngvGDzBUKdDsMeTtgU5o8B92PFlUf3YXUrHa7Fys6lBqcCGnX15YQ2A18FyPd7Crd1A3M8C1wdbH4DD3hWeP6IEXbQkG97ajR1HPFnuPP5jFFq1OWX7hl8WM9l1AO648uNfwLk7tytMeogty+xeQ4rO3r6bdcx1nuwOGsHmaXGtPzae4uzGnLH1kQkvpdZGrHjssBZJrL+pqS05KWc8tgITAPXRzYvYOXe/C2OV43eDcRBDtIhoS2f9wzc0Cv8Wls+zoFzUC5zF0U241h5uZtPfptp6OUM8wbK+cH5GEpCS17P3fJei0Z3+npTxryJ8CPzbKMtn/ZyWbkPGl0PuFPkmkjkcb4h4R2ZLwRq1H0ALmvjkf2HwK1Y+T1PY2XABe/sHJ6MxN5lnoSpnC/UGbsTaI5phK2R7x6s3Ffk5YoDOrWm3onwJHBmEP86bPmBrsGaenNoIdnxCH+gPEhLXi0Cl1VBvyPVLSh7gEuC62yAfOIUqabWEaaiucMIk6RyqJ+Q/QM69V26jjW86Gvov/EaoyT8zRCn+Xq7PVrbx0nuYUaO9wM3WAbjCE1NEUw09Um4UV+2OKfYfu5/S19gsAzGKqm6LE5FrShbdS0ku465DjDwKA/oQht19ejqbaEVuRbiLhuHByYLjtUAZpDutzP7cYdHsPJXWbjyNVgFwQoa1WXwf4Jd9YD/Ap80+yE7+u9aAAAAAElFTkSuQmCC);background-repeat:no-repeat;background-size:auto 100%;background-position-x:center;transition:background-color .5s}.markdown-body code{padding:.065em .4em;font-size:.87em;color:var(--cyanosis-code-color);word-break:break-word;overflow-x:auto;background-color:var(--cyanosis-code-bg-color);border-radius:2px}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{display:block;padding:16px 12px;margin:0;font-size:12px;color:#333;word-break:normal;overflow-x:auto;background:var(--cyanosis-code-pre-color)}.markdown-body pre&gt;code::-webkit-scrollbar{width:4px;height:4px}.markdown-body pre&gt;code::-webkit-scrollbar-track{background-color:var(--cyanosis-border-color)}.markdown-body pre&gt;code::-webkit-scrollbar-thumb{background-color:var(--cyanosis-strong-color);border-radius:10px}.markdown-body a{position:relative;text-decoration:none;color:var(--cyanosis-link-color);border-bottom:1px solid var(--cyanosis-border-color)}.markdown-body a:hover{border-bottom-color:var(--cyanosis-linkh-color)}.markdown-body a:active,.markdown-body a:hover{color:var(--cyanosis-linkh-color)}.markdown-body a:after{position:absolute;content:"";top:100%;left:0;width:100%;opacity:0;border-bottom:1px solid var(--cyanosis-border-color);transition:top .3s,opacity .3s;transform:translateZ(0)}.markdown-body a:hover:after{top:0;opacity:1;border-bottom-color:var(--cyanosis-linkh-color)}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid var(--cyanosis-table-border-color);border-spacing:0;border-collapse:collapse}.markdown-body table thead{color:#000;text-align:left;font-size:14px;background:#f6f6f6}.markdown-body table tr:nth-child(2n){background-color:var(--cyanosis-table-tr-nc-color)}.markdown-body table tr:hover{background-color:var(--cyanosis-table-trh-color)}.markdown-body table td,.markdown-body table th{padding:12px 8px;line-height:24px;border:1px solid var(--cyanosis-table-border-color)}.markdown-body table th{color:var(--cyanosis-table-tht-color);background-color:var(--cyanosis-table-th-color)}.markdown-body table td{min-width:120px}.markdown-body blockquote{color:var(--cyanosis-blockquote-color);border-left:4px solid var(--cyanosis-strong-color);background-color:var(--cyanosis-blockquote-bg-color);padding:1px 20px;margin:22px 0;transition:color .35s}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body b,.markdown-body blockquote&gt;b,.markdown-body blockquote&gt;strong,.markdown-body strong{color:var(--cyanosis-strong-color)}.markdown-body em,.markdown-body i{color:var(--cyanosis-em-color)}.markdown-body del{color:var(--cyanosis-del-color)}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:4px}.markdown-body ol li{padding-left:6px}.markdown-body details&gt;summary{outline:none;color:var(--cyanosis-title-color);font-size:20px;font-weight:bolder;border-bottom:1px solid var(--cyanosis-border-color);cursor:pointer}.markdown-body details&gt;p{padding:10px 20px;margin:10px 0 0;color:#666;background-color:var(--cyanosis-blockquote-bg-color);border:2px dashed var(--cyanosis-strong-color)}.markdown-body h1::selection,.markdown-body h2::selection,.markdown-body h3::selection,.markdown-body h4::selection,.markdown-body h5::selection,.markdown-body h6::selection{color:var(--cyanosis-slct-title-color);background-color:var(--cyanosis-slct-titlebg-color)}.markdown-body ol li::selection,.markdown-body p::selection,.markdown-body ul li::selection{color:var(--cyanosis-slct-text-color);background-color:var(--cyanosis-slct-bg-color)}.markdown-body a::selection,.markdown-body b::selection,.markdown-body em::selection,.markdown-body i::selection,.markdown-body strong::selection{background-color:var(--cyanosis-slct-elbg-color)}.markdown-body del::selection{color:var(--cyanosis-slct-del-color);background-color:var(--cyanosis-slct-elbg-color)}.markdown-body table thead th::selection{background-color:transparent}.markdown-body table tbody td::selection{background-color:var(--cyanosis-slct-bg-color)}.markdown-body code::selection{background-color:var(--cyanosis-slct-codebg-color)}.markdown-body pre&gt;code::selection{background-color:var(--cyanosis-slct-prebg-color)}.markdown-body .contains-task-list{padding-left:14px;list-style:none}.markdown-body .contains-task-list input[type=checkbox]{position:relative}.markdown-body .contains-task-list input[type=checkbox]:before{content:"";position:absolute;top:0;left:0;right:0;bottom:0;width:inherit;height:inherit;background:#f0f8ff;border:1px solid #add6ff;border-radius:2px;box-sizing:border-box;z-index:1}.markdown-body .contains-task-list input[type=checkbox]:checked:after{content:"✓";position:absolute;top:-12px;left:0;right:0;bottom:0;width:0;height:0;color:#f55;font-size:20px;font-weight:700;z-index:2}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="xcode">.markdown-body pre,.markdown-body pre&gt;code.hljs{background:#fff;color:#000}.xml .hljs-meta{color:silver}.hljs-comment,.hljs-quote{color:#007400}.hljs-attribute,.hljs-keyword,.hljs-literal,.hljs-name,.hljs-selector-tag,.hljs-tag{color:#aa0d91}.hljs-template-variable,.hljs-variable{color:#3f6e74}.hljs-code,.hljs-meta-string,.hljs-string{color:#c41a16}.hljs-link,.hljs-regexp{color:#0e0eff}.hljs-bullet,.hljs-number,.hljs-symbol,.hljs-title{color:#1c00cf}.hljs-meta,.hljs-section{color:#643820}.hljs-built_in,.hljs-builtin-name,.hljs-class .hljs-title,.hljs-params,.hljs-type{color:#5c2699}.hljs-attr{color:#836c28}.hljs-subst{color:#000}.hljs-formula{background-color:#eee;font-style:italic}.hljs-addition{background-color:#baeeba}.hljs-deletion{background-color:#ffc8bd}.hljs-selector-class,.hljs-selector-id{color:#9b703f}.hljs-doctag,.hljs-strong{font-weight:700}.hljs-emphasis{font-style:italic}</style><p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/593a6d2a7d204736a202ff46eb495300~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgUm9ja0J5dGU=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766366565&amp;x-signature=n69WJc8IuUGvUhJiommxN3H5tyY%3D" alt="0.jpg" loading="lazy"/></p>
<p>你有没有遇到过这样的情况：数据源发送得太快，你的应用根本处理不过来，结果要么卡顿要么崩溃？</p>
<p>针对这种情况，Kotlin <code>Flow</code> 提供了一些内置的方法，让你的生产者和消费者能步调一致。在这篇文章里，我们会聊聊：</p>
<ol>
<li>背压（Backpressure）是什么意思？</li>
<li>默认的“等一等”模式是怎么工作的？</li>
<li>什么时候用 <code>buffer()</code> 加个小队列？</li>
<li><code>conflate()</code> 怎么跳过旧数据？</li>
<li><code>collectLatest { }</code> 为什么会在新数据到来时停止旧任务？</li>
<li>如何根据自己的情况选择合适的方案？</li>
</ol>
<h2 data-id="heading-0">背压（Backpressure）是什么</h2>
<p><strong>背压</strong> 就是确保快速的数据发送方不会把慢速的接收方给压垮。要是没有这玩意儿，内存里可能会堆满未处理的数据，或者花时间处理已经过时的信息。</p>
<p>举个简单的例子。</p>
<p>我们知道，Android 屏幕的刷新率是一个固定值，<code>60</code> fps，<code>90</code> fps，好一点的收集 <code>120</code> fps，想象一下我们写的 UI 从流那里收集数据，如果这个数据发送发每秒钟超过了 <code>200</code> 次，那么其实其中有好几十次是没用的，因为这些数据根本不会渲染在屏幕上。</p>
<p>实际上接收方的数据，只要保持 <code>60</code> 次/秒就很够用了。</p>
<p>此时，你就需要背压！</p>
<p>背压的好处有：</p>
<ul>
<li>控制内存使用</li>
<li>避免做无用功</li>
<li>让应用性能更稳定</li>
</ul>
<h2 data-id="heading-1">默认的“等一等”模式</h2>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ceda4839984a48c99228a3e92599e692~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgUm9ja0J5dGU=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766366565&amp;x-signature=UTK2Q2fdnNWkB5b5Bg75wb83QBs%3D" alt="1.png" loading="lazy"/></p>
<p>默认情况下，当你这么写代码时：</p>
<pre><code class="hljs language-Kotlin" lang="Kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    flow {
        (<span class="hljs-number">1.</span><span class="hljs-number">.3</span>).forEach {
            timeLog(<span class="hljs-string">"Send <span class="hljs-variable">$it</span>"</span>)
            emit(it)
            delay(<span class="hljs-number">100</span>)            <span class="hljs-comment">// 快速发送方</span>
        }
    }.collect { value -&gt;
        timeLog(<span class="hljs-string">"Processing <span class="hljs-variable">$value</span>"</span>)
        delay(<span class="hljs-number">300</span>)             <span class="hljs-comment">// 慢速处理方</span>
    }
}

<span class="hljs-comment">// output:</span>
<span class="hljs-comment">// 20:22:19.647 Send 1</span>
<span class="hljs-comment">// 20:22:19.701 Processing 1</span>
<span class="hljs-comment">// 20:22:20.142 Send 2</span>
<span class="hljs-comment">// 20:22:20.143 Processing 2</span>
<span class="hljs-comment">// 20:22:20.564 Send 3</span>
<span class="hljs-comment">// 20:22:20.564 Processing 3</span>
</code></pre>
<p><strong>发送方</strong>（<code>emit</code>）会暂停，直到 <strong>处理方</strong>（<code>collect</code>）处理完上一个值。这里没有队列，每个值都是一次发送、一次处理。</p>
<h2 data-id="heading-2">buffer：加个小队列</h2>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2fe89428f2274e69b78a2b23b0e348b7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgUm9ja0J5dGU=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766366565&amp;x-signature=l26s4106hXnpRlLbK3o5wdGkLg0%3D" alt="2.png" loading="lazy"/></p>
<p>如果你想让发送方稍微提前一点，可以这样：</p>
<pre><code class="hljs language-Kotlin" lang="Kotlin">flow {
<span class="hljs-comment">//...</span>
}
.buffer(capacity = <span class="hljs-number">2</span>)
.collect { value -&gt;
<span class="hljs-comment">//...    </span>
}

<span class="hljs-comment">// output:</span>
<span class="hljs-comment">// 20:27:03.368 Send 1</span>
<span class="hljs-comment">// 20:27:03.418 Processing 1</span>
<span class="hljs-comment">// 20:27:03.529 Send 2</span>
<span class="hljs-comment">// 20:27:03.639 Send 3</span>
<span class="hljs-comment">// 20:27:03.732 Processing 2</span>
<span class="hljs-comment">// 20:27:04.470 Processing 3</span>
</code></pre>
<p><em>整体时间变快了！</em></p>
<ul>
<li>现在发送方最多可以把 <code>2</code> 个元素放入一个小队列中。</li>
<li>一旦队列满了，它就会再次暂停。</li>
</ul>
<p>这就给了你一个 <strong>有限队列</strong>：你仍然会处理每一个元素，但可以平滑处理速度上的突发波动。</p>
<h2 data-id="heading-3">conflate：跳过旧数据</h2>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e115b3dfe7874c41a64b1d6e0c958bdd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgUm9ja0J5dGU=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766366565&amp;x-signature=acYkkwsGQLMewTnJQOn6tNNMK3U%3D" alt="3.png" loading="lazy"/></p>
<p>当你只关心最新数据时（比如更新进度条），可以这样写：</p>
<pre><code class="hljs language-Kotlin" lang="Kotlin">flow { ... }
.conflate()
.collect { value -&gt; ... }

<span class="hljs-comment">// output:</span>
<span class="hljs-comment">// 20:30:45.745 Send 1</span>
<span class="hljs-comment">// 20:30:45.813 Processing 1</span>
<span class="hljs-comment">// 20:30:45.930 Send 2</span>
<span class="hljs-comment">// 20:30:46.039 Send 3</span>
<span class="hljs-comment">// 20:30:46.133 Processing 3</span>
</code></pre>
<ul>
<li>如果处理方正忙，只有 <strong>最新的</strong> 未处理项会被保留。</li>
<li>旧的项会被丢弃，所以你永远不会处理过时的更新。</li>
</ul>
<blockquote>
<p><strong>注意</strong>：<code>conflate()</code> 不会停止当前正在进行的工作；它只是在下一次读取时跳过旧值。</p>
</blockquote>
<h2 data-id="heading-4">collectLatest：取消旧任务</h2>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5c5e4db0599841cca90b2f1eb0a0c597~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgUm9ja0J5dGU=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766366565&amp;x-signature=cXhLnC1G98uWA4zIWrhe4OEqXTk%3D" alt="4.png" loading="lazy"/></p>
<p>如果你希望在新数据到来时立即取消正在进行的任务，可以这样：</p>
<pre><code class="hljs language-Kotlin" lang="Kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    flow {
        (<span class="hljs-number">1.</span><span class="hljs-number">.3</span>).forEach {
            timeLog(<span class="hljs-string">"Send <span class="hljs-variable">$it</span>"</span>)
            emit(it)
            delay(<span class="hljs-number">100</span>)            
        }
    }.collectLatest { value -&gt;
        timeLog(<span class="hljs-string">"Start process <span class="hljs-variable">$value</span>"</span>)
        delay(<span class="hljs-number">300</span>)             
        timeLog(<span class="hljs-string">"Complete process <span class="hljs-variable">$value</span>"</span>)
    }
}

<span class="hljs-comment">// output:</span>
<span class="hljs-comment">// 09:31:32.919 Send 1</span>
<span class="hljs-comment">// 09:31:32.979 Start process 1</span>
<span class="hljs-comment">// 09:31:33.090 Send 2</span>
<span class="hljs-comment">// 09:31:33.093 Start process 2</span>
<span class="hljs-comment">// 09:31:33.195 Send 3</span>
<span class="hljs-comment">// 09:31:33.195 Start process 3</span>
<span class="hljs-comment">// 09:31:33.498 Complete process 3</span>
</code></pre>
<p><em>你会发现，只有 <code>3</code> 完成了任务。</em></p>
<ul>
<li>每当有新的 <code>emit</code> 发生时，正在处理前一个值的代码块会立刻被丢弃。</li>
<li>只有当发送方停止发送后，你才会完成对 <strong>最后一个</strong> 值的处理。</li>
</ul>
<p>这种模式非常适合 <strong>“边输入边搜索”</strong> 的场景——用户继续输入时，你可以立即放弃之前的搜索请求。</p>
<h2 data-id="heading-5">抉择指南</h2>
<ul>
<li><code>collect</code><br/>
<em>作用</em>：发送方和处理方逐个等待，一一对应<br/>
<em>适用场景</em>：你需要按顺序处理 <strong>每一个</strong> 值</li>
<li><code>buffer</code><br/>
<em>作用</em>：创建一个容量为 <code>n</code> 的小队列；不会丢弃任何元素<br/>
<em>适用场景</em>：你想有一点缓冲能力，但仍需处理所有元素</li>
<li><code>conflate</code><br/>
<em>作用</em>：如果处理方正忙，只保留 <strong>最新的</strong> 元素<br/>
<em>适用场景</em>：你需要最新数据，但仍希望完成当前正在处理的任务</li>
<li><code>collectLatest</code><br/>
<em>作用</em>：新数据一到就立即取消正在进行的任务<br/>
<em>适用场景</em>：只有 <strong>最新结果</strong> 有意义；其他一切都可以立刻丢弃</li>
</ul>
<hr/>
<p>下次当你觉得 Flow 太快或太慢时，问问自己：</p>
<ol>
<li>我是否需要处理每一个值？</li>
<li>一个小队列会有帮助吗？</li>
<li>是否只有最新数据才重要？</li>
<li>新数据到来时，我是否应该取消旧任务？</li>
</ol>
<p>选择最简单的、能满足需求的选项，Kotlin <code>Flow</code> 会替你处理其余的一切。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[用 Trae + MCP 让 AI 自动测试页面]]></title>    <link>https://juejin.cn/post/7583898823921008682</link>    <guid>https://juejin.cn/post/7583898823921008682</guid>    <pubDate>2025-12-15T12:10:47.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7583898823921008682" data-draft-id="7581649704884191247" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="用 Trae + MCP 让 AI 自动测试页面"/> <meta itemprop="keywords" content="AI编程"/> <meta itemprop="datePublished" content="2025-12-15T12:10:47.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="谎言西西里"/> <meta itemprop="url" content="https://juejin.cn/user/332466136029851"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            用 Trae + MCP 让 AI 自动测试页面
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/332466136029851/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    谎言西西里
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-15T12:10:47.000Z" title="Mon Dec 15 2025 12:10:47 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-15
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{color:#383838;font-size:15px;line-height:30px;letter-spacing:2px;word-break:break-word;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Open Sans,Helvetica Neue,sans-serif;scroll-behavior:smooth;background-image:linear-gradient(0deg,transparent 24%,rgba(201,195,195,.329) 25%,hsla(0,8%,80.4%,.05) 26%,transparent 27%,transparent 74%,hsla(0,5.2%,81%,.185) 75%,rgba(180,176,176,.05) 76%,transparent 77%,transparent),linear-gradient(90deg,transparent 24%,rgba(204,196,196,.226) 25%,hsla(0,4%,66.1%,.05) 26%,transparent 27%,transparent 74%,hsla(0,5.2%,81%,.185) 75%,rgba(180,176,176,.05) 76%,transparent 77%,transparent);background-color:#fff;background-size:50px 50px;padding-bottom:60px}.markdown-body ::selection{color:#fff;background-color:#a862ea}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{margin:24px 0 12px;color:#a862ea}.markdown-body h1{line-height:2;font-size:1.4em}.markdown-body h1~p:first-of-type:first-letter{color:#a862ea;float:left;font-size:2em;margin-right:.4em;font-weight:bolder}.markdown-body h2{font-size:1.2em}.markdown-body h3{font-size:1.1em}.markdown-body ol,.markdown-body ul{padding-left:2em}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;padding-left:.2em}.markdown-body ol li::marker,.markdown-body ul li::marker{color:#a862ea}.markdown-body ol li.task-list-item,.markdown-body ul li.task-list-item{list-style:none}.markdown-body ol li.task-list-item ol,.markdown-body ol li.task-list-item ul,.markdown-body ul li.task-list-item ol,.markdown-body ul li.task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:10px}.markdown-body a,.markdown-body code,.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6,.markdown-body li,.markdown-body p{opacity:.85;vertical-align:baseline;transition:all .1s ease}.markdown-body a:hover,.markdown-body code:hover,.markdown-body h1:hover,.markdown-body h2:hover,.markdown-body h3:hover,.markdown-body h4:hover,.markdown-body h5:hover,.markdown-body h6:hover,.markdown-body li:hover,.markdown-body p:hover{opacity:1}.markdown-body a{display:inline-block;color:#a862ea;cursor:pointer;text-decoration:none;position:relative}.markdown-body a:after{content:"";position:absolute;width:98%;height:1px;bottom:0;left:0;transform:scaleX(0);background-color:#a862ea;transform-origin:bottom right;transition:transform .3s ease-in-out}.markdown-body a:hover:after{transform:scaleX(1);transform-origin:bottom left}.markdown-body a:active,.markdown-body a:link{color:#a862ea}.markdown-body img{max-width:100%;user-select:none;margin:1em 0;transition:transform .2s ease 0s;background-color:#f8f5ff;box-shadow:0 0 10px #e7daff}.markdown-body img:hover{opacity:1;box-shadow:0 0 20px #e7daff;transform:translateY(-1px)}.markdown-body blockquote{padding:.5em 1em;margin:12px 0;border-top-left-radius:2px;border-bottom-left-radius:2px;border-left:3px solid #a862ea;background-color:#f8f5ff}.markdown-body blockquote&gt;p{margin:0}.markdown-body .math{font-style:italic;margin:12px 0;padding:.5em 1em;background-color:#f8f5ff}.markdown-body .math&gt;p{margin:0}.markdown-body code{padding:2px .4em;overflow-x:auto;color:#a862ea;font-weight:700;word-break:break-word;font-family:Operator Mono,Consolas,Monaco,Menlo,monospace;background-color:#f8f5ff}.markdown-body pre{margin:2em 0}.markdown-body pre&gt;code{display:block;padding:1.5em;word-break:normal;font-size:.9em;font-style:normal;font-weight:400;font-family:Operator Mono,Consolas,Monaco,Menlo,monospace;line-height:18px;color:#383838;border-radius:2px;scroll-behavior:smooth;box-shadow:0 0 10px #e7daff}.markdown-body pre&gt;code:hover{box-shadow:0 0 20px #e7daff}.markdown-body pre&gt;code::-webkit-scrollbar{height:6px;background-color:#f8f5ff}.markdown-body pre&gt;code::-webkit-scrollbar-thumb{background-color:#e7daff;border-bottom-left-radius:3px;border-bottom-right-radius:3px}.markdown-body hr{margin:2em 0;border-top:1px solid #a862ea}.markdown-body table{width:100%;font-size:12px;max-width:100%;overflow:auto;border-collapse:collapse}.markdown-body thead{color:#a862ea;background:#f8f5ff}.markdown-body td,.markdown-body th{padding:.5em;border:1px solid #e7daff}.markdown-body tr{background-color:#f8f5ff}@media (max-width:720px){.markdown-body{font-size:12px}}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">前言</h2>
<p>想必大家在前段时间关于 <strong>“豆包手机”</strong> 一定有所耳闻，说实话在看过了不少博主的体验和测评之后呀，不禁有点感叹现代的AI发展了🤯。</p>
<p>但是有一个让我比较好奇的功能🤔，那就是 <strong>AI Agent是如何通过用户提供的提示词来直接操控应用的呢？</strong>
毕竟对于大多数人来说 AI 还停留在聊天对话的阶段，是什么东西让 AI 突然拥有了自己的 “手”与“眼” 呢？</p>
<p>因此我就去稍微了解了一下与这方面有关的一些知识，结果碰到了 <code>mcp协议</code> 和 <code>playwright</code>。</p>
<p>于是我抱着一颗学徒的心，来试试在目前很火的 AI 编译器 <strong>Trae</strong> 来看看会摩擦出怎样的火花🔥。</p>
<h2 data-id="heading-1">一、什么是 MCP（Model Context Protocol）？</h2>
<h3 data-id="heading-2">定义：</h3>
<p>MCP 协议是一个<strong>开放、标准化的通信协议</strong>，而它的核心作用是：</p>
<blockquote>
<p><strong>让大语言模型能够安全、结构化地调用外部工具、访问上下文数据，并与真实世界交互。</strong></p>
</blockquote>
<p>说白了，<strong>MCP 是给 AI 装上“手”和“眼”的接口。</strong></p>
<p>在 MCP 出现之前，AI 编程助手存在严重局限：</p>
<ul>
<li><strong>只能沟通，不能实施</strong>：虽然 AI 可以帮助生成代码，但是不能直接运行、测试或验证它是否真的达到了需要的效果。</li>
<li><strong>信息获取步骤复杂</strong>：AI 并不知道我们本地有哪些文件、依赖等等，大多数时候需要手动操作来提供给它。</li>
</ul>
<p>但是通过 MCP 这个“桥梁”，让 AI 作为客户端通过标准协议，连接一个或多个 MCP Server从而把<strong>外部程序</strong>（比如 Playwright、Shell 脚本等）接入到 AI 编译器中，让 AI 能调用它们。</p>
<p>例如：<strong>“模型 + 工具生态”协同</strong>
<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7fb68ab9a3fc4321aa5510b8f5e1cf8b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6LCO6KiA6KW_6KW_6YeM:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766405447&amp;x-signature=MgUSrQgDXCybSASpatSkpPrd1Ow%3D" alt="tongyi-mermaid-2025-12-15-184415.png" loading="lazy"/></p>
<p>在这整个过程中，用户仅仅只是向 AI Agent 下达了测试登录的命令，在此之后的过程都无需人工干预，AI 可以自主协调多个工具完成闭环。</p>
<p><strong>AI 就像公司的 CEO，通过 MCP 协议向多个部门（MCP Server）下达命令</strong></p>
<p>如果你想得到更官方的解释，可以去官网<a href="https://link.juejin.cn?target=https%3A%2F%2Fmodelcontextprotocol.io%2Fdocs%2Fgetting-started%2Fintro" target="_blank" title="https://modelcontextprotocol.io/docs/getting-started/intro" ref="nofollow noopener noreferrer">What is the Model Context Protocol (MCP)?</a></p>
<h2 data-id="heading-3">二、什么是 Playwright？</h2>
<p><strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fplaywright.nodejs.cn%2F" target="_blank" title="https://playwright.nodejs.cn/" ref="nofollow noopener noreferrer">Playwright</a></strong> 是由 Microsoft 开发的 <strong>现代化端到端（E2E）Web 测试工具</strong>，用于自动化 Chromium、WebKit 和 Firefox 浏览器的 Node.js/Python/Java/.NET 库。</p>
<p>但是由于 <strong>AI + MCP</strong> 的存在，我们并不需要精通这个工具，把事情交给AI，让我们更注重于功能。</p>
<h2 data-id="heading-4">三、MCP + Playwright 的协同</h2>
<p>下述示例都是通过使用 Trae 来实现的</p>
<h3 data-id="heading-5">前期工作：</h3>
<p>打开我们的 <strong>Trae</strong> 编辑器</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/dc0e072cdb764925bb62e240922b2798~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6LCO6KiA6KW_6KW_6YeM:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766405447&amp;x-signature=ha7hnjUKnBlq5zdJx6eelvtYysU%3D" alt="image.png" loading="lazy"/></p>
<p>在设置页面找到 MCP</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d3895986df5a41a5849509f98f62dcf4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6LCO6KiA6KW_6KW_6YeM:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766405447&amp;x-signature=GGN1nB6TnF3Bi9ZcuSBc1jyNwq0%3D" alt="image.png" loading="lazy"/></p>
<p>点击右边的 <strong>添加</strong> 按钮，这里有两种方法添加，<strong>从市场添加 / 手动添加</strong>，这里我们点击从市场添加即可</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/16ff7bfae4054c328826d0650c8eab7d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6LCO6KiA6KW_6KW_6YeM:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766405447&amp;x-signature=x2Si4lUB0IE9Ba%2F7zFKSyezTgOU%3D" alt="image.png" loading="lazy"/></p>
<p>在市场这里可以添加任何你需要的 <strong>MCP Server</strong>，并且可以输入你需要配置的 MCP Server 信息。这里我们添加 <code>playwright</code></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7a41ef842a6f47fe87bc4d1559d74f77~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6LCO6KiA6KW_6KW_6YeM:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766405447&amp;x-signature=PdZis9IKBSUyh9mnsZGO4ibbAE8%3D" alt="2025-12-15.gif" loading="lazy"/></p>
<p>安装好后回到主页面上，在 TRAE 智能体聊天框中选择 <code>@Builder with MCP</code></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/117d264a3cc74bc599a9c56ab6c4ba37~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6LCO6KiA6KW_6KW_6YeM:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766405447&amp;x-signature=2qYRBHdMhD0IQmHlHE2qvfkGoFI%3D" alt="image.png" loading="lazy"/></p>
<blockquote>
<p>注：</p>
<p>不要忘记 playwright 只适配 Chromium、WebKit 和 Firefox浏览器，各位只需提前安装好其一即可</p>
</blockquote>
<h3 data-id="heading-6">示例一：让 AI 自动访问页面</h3>
<p>给 AI 提示词：</p>
<pre><code class="hljs language-markdown" lang="markdown">请帮我测试掘金网站的插件页面：
<span class="hljs-bullet">    1.</span> 打开 https://juejin.cn/
<span class="hljs-bullet">    2.</span> 点击顶部导航栏的"插件"按钮
<span class="hljs-bullet">    3.</span> 等待页面加载完成
<span class="hljs-bullet">    4.</span> 截图并保存到当前目录
</code></pre>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8b6fc7eea1524e49a3b03d1463358e6c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6LCO6KiA6KW_6KW_6YeM:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766405447&amp;x-signature=25oMtNgfLETI8vJDGE3TG3yyc7o%3D" alt="image.png" loading="lazy"/></p>
<p>最后实现结果：
<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/22aa8f38bc5c4056a06bca6dc681fe8a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6LCO6KiA6KW_6KW_6YeM:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766405447&amp;x-signature=jWzCGeVq1FR433W5ea%2FPeqF3vQU%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-7">示例二：让 AI 自动测试页面</h3>
<p>现在我test文件夹下有一个 <code>1.html</code>文件，给 AI 提示词让它帮我测试页面的基本效果。</p>
<pre><code class="hljs language-markdown" lang="markdown">请确认 1.html 文件的以下能力：
<span class="hljs-bullet">    1.</span> 测试是否能正确通过文件路径加载本地 HTML。
<span class="hljs-bullet">    2.</span> 测试 fill和click是否精准。
<span class="hljs-bullet">    3.</span> 通过验证结果文本，确保页面逻辑正常运行且被测试工具正确捕获。
<span class="hljs-bullet">    4.</span> 通过截图提供最终的视觉证据。
</code></pre>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8a3f6f41c8ff4f859aa2eb8727f97e57~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6LCO6KiA6KW_6KW_6YeM:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766405447&amp;x-signature=ke4gSzoD67v0w0GzpjCZF06VT1U%3D" alt="动画.gif" loading="lazy"/></p>
<h2 data-id="heading-8">四、这代表未来</h2>





















<table><thead><tr><th>传统开发</th><th>AI + MCP + Playwright</th></tr></thead><tbody><tr><td>写代码 → 手动测试 → 调试 → 修复</td><td>描述需求 → AI 生成 + 自动测试 + 自动修复</td></tr><tr><td>测试是“事后”行为</td><td>测试是“内建”能力</td></tr><tr><td>人做机械性验证</td><td>AI 做闭环验证</td></tr></tbody></table>
<blockquote>
<p>这正是 <strong>“Agentic AI”（智能体式开发）</strong> 的核心：AI 不再只是生成代码，而是能<strong>自主执行、验证、迭代</strong>。</p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[JWorker——一套简单易用的基于鸿蒙 Worker 的双向 RPC 通讯机制]]></title>    <link>https://juejin.cn/post/7583260493851557929</link>    <guid>https://juejin.cn/post/7583260493851557929</guid>    <pubDate>2025-12-15T00:29:27.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7583260493851557929" data-draft-id="7583260493851263017" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="JWorker——一套简单易用的基于鸿蒙 Worker 的双向 RPC 通讯机制"/> <meta itemprop="keywords" content="HarmonyOS,ArkTS,TypeScript"/> <meta itemprop="datePublished" content="2025-12-15T00:29:27.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="江澎涌"/> <meta itemprop="url" content="https://juejin.cn/user/1820446986338504"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            JWorker——一套简单易用的基于鸿蒙 Worker 的双向 RPC 通讯机制
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1820446986338504/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    江澎涌
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-15T00:29:27.000Z" title="Mon Dec 15 2025 00:29:27 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-15
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">零、JWorker</h2>
<p><strong>JWorker 是一套简单易用的基于鸿蒙 Worker 的双向 RPC 通讯机制。</strong></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d6fda4257dbe4aac9ecae9d1b97bb4b4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5rGf5r6O5raM:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766363366&amp;x-signature=Qyt8awOG6G6qKBSbJqBTWZ06YV8%3D" alt="structure.png" loading="lazy"/></p>
<p>传统的 Worker 通讯基于事件监听和消息传递，缺乏原生的 <code>Promise/async-await</code> 支持，导致逻辑割裂。<strong>JWorker 通过双向 RPC 机制，让主 Worker 可以 await 子 Worker 的执行结果，子 Worker 也可以 await 主 Worker 的响应，将跨 Worker 通讯简化为像调用本地异步函数，消除回调嵌套，保持代码线性流畅。</strong></p>
<h2 data-id="heading-1">一、安装</h2>
<p>运行 <code>ohpm install jworker</code> 安装 JWorker 库</p>
<h2 data-id="heading-2">二、常规使用</h2>
<p>JWorker 是基于鸿蒙 Worker 封装的一套 RPC 通讯机制，所以在正式使用之前需要先添加和配置 Worker 的 ets 文件。可以按照<a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.huawei.com%2Fconsumer%2Fcn%2Fdoc%2Fharmonyos-guides%2Fworker-introduction" target="_blank" title="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/worker-introduction" ref="nofollow noopener noreferrer">鸿蒙官方 Worker</a> 的使用文档进行添加配置，这里就不再赘述。</p>
<blockquote>
<p>“常规使用” 示例完整代码 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FzincPower%2FJWorker%2Ftree%2Fmain%2Fsample%2Fsrc%2Fmain%2Fets%2Fworker%2Fsimple" target="_blank" title="https://github.com/zincPower/JWorker/tree/main/sample/src/main/ets/worker/simple" ref="nofollow noopener noreferrer">传送门</a></p>
</blockquote>
<h3 data-id="heading-3">1、创建 JWorker</h3>
<p><strong>主 Worker 中</strong>使用 <code>createJWorker(workerPath: string)</code> 创建 <code>JWorker</code> 实例，然后调用 <code>JWorker.start()</code> 启动 <code>JWorker</code> 。 完整代码如下：</p>
<blockquote>
<p><code>JWorker.start()</code> 内部会启动 Worker 文件，并关联消息接收、退出接收等回调。</p>
</blockquote>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// 将 Worker 的文件路径传给 createJWorker 方法，会返回 JWorker 实例</span>
<span class="hljs-variable language_">this</span>.<span class="hljs-property">worker</span> = <span class="hljs-title function_">createJWorker</span>(<span class="hljs-string">"sample/ets/worker/simple/SimpleWorker.ets"</span>)
<span class="hljs-comment">// 启动 JWorker</span>
<span class="hljs-variable language_">this</span>.<span class="hljs-property">worker</span>.<span class="hljs-title function_">start</span>()
</code></pre>
<p><strong>子 Worker 中</strong>使用 <code>initJWorker()</code> 获取 <code>SubWorker</code> 实例。完整代码如下：</p>
<blockquote>
<p><code>initJWorker()</code> 内部会让 <code>SubWorker</code> 关联子 Worker 的消息接收等回调。</p>
</blockquote>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">const</span> worker = <span class="hljs-title function_">initJWorker</span>()
</code></pre>
<h3 data-id="heading-4">2、双向 RPC 通讯</h3>
<p><strong>JWorker 的通讯是基于 Channel</strong> ，所以主子 Worker 的通讯需要先添加<strong>相同名称的 Channel</strong>。</p>
<p><strong>主 Worker</strong> 通过 <code>JWorker.addChannel(channelName: string, channel: Channel)</code> 方法进行添加通讯 Channel 。</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// 创建通讯渠道 MainSimpleChannel ，需要继承 Channel </span>
<span class="hljs-variable language_">this</span>.<span class="hljs-property">simpleWorkerChannel</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MainSimpleChannel</span>()
<span class="hljs-comment">// 添加渠道名为 “SimpleWorkerChannel” 的通讯 Channel </span>
<span class="hljs-variable language_">this</span>.<span class="hljs-property">worker</span>.<span class="hljs-title function_">addChannel</span>(<span class="hljs-string">"SimpleWorkerChannel"</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">simpleWorkerChannel</span>)
</code></pre>
<p><strong>子 Worker</strong> 通过 <code>JWorkerChannel(channelName: string, channel: Channel)</code> 方法进行添加通讯 Channel 。</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// 添加渠道名为 “SimpleWorkerChannel” 的通讯 Channel</span>
<span class="hljs-comment">// 同样 SubSimpleChannel 也需要继承 Channel</span>
<span class="hljs-title class_">JWorkerChannel</span>(<span class="hljs-string">"SimpleWorkerChannel"</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubSimpleChannel</span>(worker))
</code></pre>
<p><strong>主 Worker 和子 Worker 通过相同的渠道名称建立通讯通道</strong>，<code>MainSimpleChannel</code> 和 <code>SubSimpleChannel</code> 通讯规则如下：</p>
<ul>
<li>通过 <code>handleMessage(methodName: string, data: any): Promise&lt;any&gt;</code> 接收对方的调用消息，返回值会返回到调用点；</li>
<li>通过 <code>send(methodName: string, data?: any, transfer?: ArrayBuffer[]) =&gt; Promise&lt;any&gt;</code> 可以主动调用对方方法并携带参数，对方处理完的返回值会以 <code>Promise&lt;any&gt;</code> 类型返回到调用点。</li>
</ul>
<p><strong>主 Worker 调用子 Worker 的逻辑</strong>，通过注册的 <code>simpleWorkerChannel</code> 调用 <code>send</code> 方法发送即可。</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// ============== 主 Worker 中进行发送 ==============</span>
<span class="hljs-keyword">const</span> user = {
  <span class="hljs-string">"name"</span>: <span class="hljs-string">"jiangpengyong"</span>,
  <span class="hljs-string">"year"</span>: <span class="hljs-number">1994</span>,
  <span class="hljs-string">"height"</span>: <span class="hljs-number">170.0</span>,
  <span class="hljs-string">"address"</span>: {
    <span class="hljs-string">"country"</span>: <span class="hljs-string">"China"</span>,
    <span class="hljs-string">"province"</span>: <span class="hljs-string">"GuangDong"</span>,
    <span class="hljs-string">"city"</span>: <span class="hljs-string">"Guangzhou"</span>,
  },
} <span class="hljs-keyword">as</span> <span class="hljs-title class_">User</span>
<span class="hljs-comment">// 第一个参数为调用方法名称，第二个参数为调用方法的参数</span>
<span class="hljs-comment">// response 为子 Worker 处理的结果</span>
<span class="hljs-keyword">const</span> response = (<span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">simpleWorkerChannel</span>?.<span class="hljs-title function_">send</span>(<span class="hljs-string">"sayHello"</span>, user)) <span class="hljs-keyword">as</span> <span class="hljs-title class_">Any</span>
<span class="hljs-title class_">Log</span>.<span class="hljs-title function_">i</span>(<span class="hljs-variable constant_">TAG</span>, <span class="hljs-string">`【发送有处理的消息】子 Worker 回复 response=<span class="hljs-subst">${<span class="hljs-built_in">JSON</span>.stringify(response)}</span>`</span>)

<span class="hljs-comment">// ============== 子 Worker 中进行接收处理 ==============</span>
<span class="hljs-comment">// 通过 SubSimpleChannel 接收调用方法名称和参数，处理后返回结果</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SubSimpleChannel</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Channel</span> {
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">handleMessage</span>(<span class="hljs-attr">methodName</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">data</span>: <span class="hljs-title class_">Any</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">Any</span>&gt; {
    <span class="hljs-keyword">switch</span> (methodName) {
      <span class="hljs-comment">// 处理主 Worker 调用的 “sayHello” 方法，将 data 转为 User 类型并获取对应数据，返回一个 string 结果</span>
      <span class="hljs-keyword">case</span> <span class="hljs-string">"sayHello"</span>: {
        <span class="hljs-keyword">const</span> user = data <span class="hljs-keyword">as</span> <span class="hljs-title class_">User</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">`Hello, <span class="hljs-subst">${user.name}</span>. I'm replying to you from the sub-worker.`</span>
      }
      <span class="hljs-comment">// 省略其他方法</span>
    }
  }
}

<span class="hljs-comment">// ============== 最终会在 Log 中看到以下输出 ==============</span>
<span class="hljs-comment">// 【发送有处理的消息】子 Worker 回复 response="Hello, jiangpengyong. I'm replying to you from the sub-worker."</span>
</code></pre>
<p><strong>子 Worker 调用主 Worker 的逻辑</strong>，也是同样的流程，通过注册的 <code>SubSimpleChannel</code> 调用 <code>send</code> 方法发送即可。</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// ============== 子 Worker 调用主 Worker 的逻辑 ==============</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SubSimpleChannel</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Channel</span> {
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">handleMessage</span>(<span class="hljs-attr">methodName</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">data</span>: <span class="hljs-title class_">Any</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">Any</span>&gt; {
    <span class="hljs-keyword">switch</span> (methodName) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">"getUserDes"</span>: {
        <span class="hljs-comment">// 调用主 Worker 的 “getUserInfo” 方法，此处没有携带参数，会返回 User 类型</span>
        <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">send</span>(<span class="hljs-string">"getUserInfo"</span>) <span class="hljs-keyword">as</span> <span class="hljs-title class_">User</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">`name: <span class="hljs-subst">${user.name}</span>, height: <span class="hljs-subst">${user.height}</span>`</span>
      }
      <span class="hljs-comment">// 省略其他逻辑</span>
    }
  }
}

<span class="hljs-comment">// ============== 主 Worker 处理逻辑 ==============</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainSimpleChannel</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Channel</span> {
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">handleMessage</span>(<span class="hljs-attr">methodName</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">data</span>: <span class="hljs-title class_">Any</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">Any</span>&gt; {
    <span class="hljs-keyword">switch</span> (methodName) {
      <span class="hljs-comment">// 接收到子 Worker 的请求处理，处理完之后返回数据</span>
      <span class="hljs-keyword">case</span> <span class="hljs-string">"getUserInfo"</span>: {
        <span class="hljs-keyword">return</span> {
          <span class="hljs-string">"name"</span>: <span class="hljs-string">"江澎涌"</span>,
          <span class="hljs-string">"year"</span>: <span class="hljs-number">1994</span>,
          <span class="hljs-string">"height"</span>: <span class="hljs-number">170.0</span>,
          <span class="hljs-string">"address"</span>: {
            <span class="hljs-string">"country"</span>: <span class="hljs-string">"中国"</span>,
            <span class="hljs-string">"province"</span>: <span class="hljs-string">"广东"</span>,
            <span class="hljs-string">"city"</span>: <span class="hljs-string">"普宁"</span>,
          },
        } <span class="hljs-keyword">as</span> <span class="hljs-title class_">User</span>
      }
    }
  }
}
</code></pre>
<blockquote>
<p>Channel 中包含了 <code>send(methodName: string, data?: any, transfer?: ArrayBuffer[]) =&gt; Promise&lt;any&gt;</code> 方法，可以在 “ Channel 内部主动调用” 或是 “外部代码通过 Channel 实例主动调用”，<code>await</code> 数据返回即可。</p>
</blockquote>
<h3 data-id="heading-5">3、传递 ArrayBuffer 数据</h3>
<p>Worker 在传递 ArrayBuffer 时，为了不拷贝 ArrayBuffer 数据，可以考虑将 ArrayBuffer 使用权移交给对方，JWorker 也同样提供这一能力。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/aff8632ddf2f4a149f4f8424f42dcaf7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5rGf5r6O5raM:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766363366&amp;x-signature=%2Fyu2vdb5l5doeJvIPBjnqr4DdW0%3D" alt="transfer_data.png" loading="lazy"/></p>
<p>上图则是一个完整的移交 ArrayBuffer 使用权的全流程</p>
<p><strong>调用点传递 ArrayBuffer 类型数据</strong></p>
<p>无论是 “主 Worker 主动调用子 Worker 方法”，还是 “子 Worker 主动调用主 Worker 方法”，都是使用 Channel 的 <code>send</code> 方法。</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-title function_">send</span>(<span class="hljs-attr">methodName</span>: <span class="hljs-built_in">string</span>, data?: <span class="hljs-built_in">any</span>, transfer?: <span class="hljs-title class_">ArrayBuffer</span>[]) =&gt; <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">any</span>&gt;
</code></pre>
<p><code>send</code> 的第三个参数 <code>transfer</code> 持有第二个参数 <code>data</code> 中需要移交使用权的 ArrayBuffer 对象，JWorker 会负责移交使用权。</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// ============== 发送方代码（此处为主 Worker ） ==============</span>
<span class="hljs-keyword">const</span> uint8Array = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getContext</span>(<span class="hljs-variable language_">this</span>).<span class="hljs-property">resourceManager</span>.<span class="hljs-title function_">getRawFileContent</span>(<span class="hljs-string">"image1.jpeg"</span>)
<span class="hljs-keyword">const</span> arrayBuffer = uint8Array.<span class="hljs-property">buffer</span>
<span class="hljs-comment">// 此处将 arrayBuffer 使用权移交给子 Worker ，所以将 arrayBuffer 放置到了第三个参数</span>
<span class="hljs-comment">// 值得注意，移交后的 arrayBuffer ，主 Worker 不可再使用，否则会报错</span>
<span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">simpleWorkerChannel</span>.<span class="hljs-title function_">send</span>(<span class="hljs-string">"cropImage"</span>, arrayBuffer, [arrayBuffer]) <span class="hljs-keyword">as</span> <span class="hljs-title class_">ArrayBuffer</span> | <span class="hljs-literal">undefined</span>

<span class="hljs-comment">// ============== 接收方代码（此处为子 Worker ） ==============</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SubSimpleChannel</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Channel</span> {
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">handleMessage</span>(<span class="hljs-attr">methodName</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">data</span>: <span class="hljs-title class_">Any</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">Any</span>&gt; {
    <span class="hljs-keyword">switch</span> (methodName) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">"cropImage"</span>: {
        <span class="hljs-comment">// 接收 ArrayBuffer 的代码没有特别的要求，和接收普通类型的逻辑一样，只需要转为对应的类型进行处理即可</span>
        <span class="hljs-keyword">const</span> arrayBuffer = data <span class="hljs-keyword">as</span> <span class="hljs-title class_">ArrayBuffer</span>
        <span class="hljs-keyword">const</span> cropPixelMap = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">cropImage</span>(arrayBuffer)
        <span class="hljs-keyword">const</span> cropArrayBuffer = <span class="hljs-keyword">await</span> <span class="hljs-title class_">PixelMapConverter</span>.<span class="hljs-title function_">pixelMapToArrayBuffer</span>(cropPixelMap)
        <span class="hljs-comment">// 省略其他逻辑</span>
      }
    }
  }
}
</code></pre>
<p><strong>返回值传递 ArrayBuffer 类型数据</strong></p>
<p>在处理完逻辑后，返回数据给调用方，此时存在返回数据携带 ArrayBuffer 类型数据的场景。为此 JWorker 提供了 <code>TransferData</code> 类型，支持该场景的数据传递，具体操作如下：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// ============== 继续上面的代码 ==============</span>
<span class="hljs-comment">// ============== 接收方代码（此处为子 Worker ） ==============</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SubSimpleChannel</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Channel</span> {
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">handleMessage</span>(<span class="hljs-attr">methodName</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">data</span>: <span class="hljs-title class_">Any</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">Any</span>&gt; {
    <span class="hljs-keyword">switch</span> (methodName) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">"cropImage"</span>: {
        <span class="hljs-comment">// 省略重复代码</span>
        <span class="hljs-comment">// 返回值如果需要移交 ArrayBuffer 使用权，则使用 TransferData 类进行包裹</span>
        <span class="hljs-comment">// 第一个参数为返回数据，第二个参数为需要移交使用权的 ArrayBuffer 列表</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransferData</span>(cropArrayBuffer, [cropArrayBuffer])
      }
    }
  }
}

<span class="hljs-comment">// ============== 发送方代码（此处为主 Worker ） ==============</span>
<span class="hljs-comment">// 调用点接收到的数据类型是已经去掉 TransferData 包裹的真实数据</span>
<span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">simpleWorkerChannel</span>.<span class="hljs-title function_">send</span>(<span class="hljs-string">"cropImage"</span>, arrayBuffer, [arrayBuffer]) <span class="hljs-keyword">as</span> <span class="hljs-title class_">ArrayBuffer</span> | <span class="hljs-literal">undefined</span>
<span class="hljs-keyword">if</span> (response) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">cropPixelMap</span> = <span class="hljs-keyword">await</span> <span class="hljs-title class_">PixelMapConverter</span>.<span class="hljs-title function_">arrayBufferToPixelMap</span>(response)
}
</code></pre>
<h3 data-id="heading-6">4、关闭 JWorker</h3>
<p>在 JWorker 中提供了两种关闭 Worker 的方式，分别为 <strong>主 Worker 进行关闭</strong> 和 <strong>子 Worker 进行关闭</strong> 。<strong>推荐使用子 Worker 进行关闭</strong>，因为项目可以更好控制子 Worker 的生命周期和释放相应资源。</p>
<p><strong>主 Worker 进行关闭</strong></p>
<p>通过调用 <code>JWorker</code> 实例的 <code>release()</code> 方法进行释放。</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// 创建 JWorker 对象</span>
<span class="hljs-variable language_">this</span>.<span class="hljs-property">worker</span> = <span class="hljs-title function_">createJWorker</span>(<span class="hljs-string">"sample/ets/worker/simple/SimpleWorker.ets"</span>)
<span class="hljs-comment">// 进行开启 JWorker 、添加 Channel 等操作</span>

<span class="hljs-comment">// 关闭 JWorker</span>
<span class="hljs-variable language_">this</span>.<span class="hljs-property">worker</span>?.<span class="hljs-title function_">release</span>()
</code></pre>
<p><strong>子 Worker 进行关闭</strong></p>
<p>通过调用 <code>SubWorker</code> 对象的 <code>release()</code> 方法进行释放。</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// 在子 Worker 中构建 subWorker</span>
<span class="hljs-keyword">const</span> worker = <span class="hljs-title function_">initJWorker</span>()
<span class="hljs-comment">// 添加需要的 Channel 操作</span>

<span class="hljs-comment">// 在需要释放的时候调用</span>
<span class="hljs-comment">// 1、可以将 worker 传递给 Channel ，Channel 内部可以根据需要进行调用释放</span>
<span class="hljs-comment">// 2、可以全局持有，在需要的时候进行释放</span>
worker.<span class="hljs-title function_">release</span>()
</code></pre>
<h3 data-id="heading-7">5、值得注意</h3>
<p>如果 <code>JWorker</code> 对象未开启（即未调用 <code>JWorker.start()</code> 方法或已关闭），此时使用添加在该 JWorker 的 Channel 进行发送消息会立马得到一个 <code>undefined</code> 数据。</p>
<p>如果通过 <code>JWorker</code> 的 Channel 发送了消息，在未得到回复前对该 <code>JWorker</code> 进行关闭，则会让调用点立马得到一个 <code>undefined</code> 数据。</p>
<p><strong>所以为了程序的健壮，调用点的类型转换最好增加对 <code>undefined</code> 的判断。</strong></p>
<h2 data-id="heading-8">三、多个 Worker</h2>
<h3 data-id="heading-9">1、项目主 Worker 开多个子 Worker</h3>
<p><code>JWorker</code> 项目支持开启多个 Worker ，使用 <code>createJWorker(workerPath: string)</code> 方法传入不同的路径，管理好返回 <code>JWorker</code> 对象即可。</p>
<blockquote>
<p>“项目主 Worker 开多个子 Worker” 示例完整代码 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FzincPower%2FJWorker%2Ftree%2Fmain%2Fsample%2Fsrc%2Fmain%2Fets%2Fworker%2Fmainmultiworker" target="_blank" title="https://github.com/zincPower/JWorker/tree/main/sample/src/main/ets/worker/mainmultiworker" ref="nofollow noopener noreferrer">传送门</a></p>
</blockquote>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/85be0b25cb7b4c16989ea08b3dfa2509~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5rGf5r6O5raM:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766363366&amp;x-signature=F0Jnyg6FHA6jqIfXeHuoKfyNGXI%3D" alt="main_multi_worker.png" loading="lazy"/></p>
<p>假设项目需要构建上图的使用场景，可以通过以下代码创建 <code>JWorker</code> 实例。</p>
<ul>
<li>可以使用不同的 Worker ets 文件，也可以使用同一个 Worker ets 文件可以开启多个 <code>JWorker</code> 实例。</li>
<li>通过管理好 <code>JWorker</code> 实例，添加渠道后进行各自 Worker 通讯。</li>
</ul>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// worker0 和 worker1、worker2 使用不同的 Worker ets 文件进行开启不同的 JWorker 实例</span>
<span class="hljs-variable language_">this</span>.<span class="hljs-property">worker0</span> = <span class="hljs-title function_">createJWorker</span>(<span class="hljs-string">"sample/ets/worker/simple/SimpleWorker.ets"</span>)
<span class="hljs-variable language_">this</span>.<span class="hljs-property">worker0</span>.<span class="hljs-title function_">start</span>()
<span class="hljs-variable language_">this</span>.<span class="hljs-property">simpleWorkerChannel</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MainSimpleChannel</span>()
<span class="hljs-variable language_">this</span>.<span class="hljs-property">worker0</span>.<span class="hljs-title function_">addChannel</span>(<span class="hljs-string">"SimpleWorkerChannel"</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">simpleWorkerChannel</span>)

<span class="hljs-comment">// worker1 和 worker2 使用相同的 Worker ets 文件进行开启不同的 JWorker 实例 </span>
<span class="hljs-variable language_">this</span>.<span class="hljs-property">worker1</span> = <span class="hljs-title function_">createJWorker</span>(<span class="hljs-string">"sample/ets/worker/mainmultiworker/MainMultiWorker.ets"</span>)
<span class="hljs-variable language_">this</span>.<span class="hljs-property">worker1Channel</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MainMultiChannel</span>()
<span class="hljs-variable language_">this</span>.<span class="hljs-property">worker1</span>.<span class="hljs-title function_">addChannel</span>(<span class="hljs-string">"multiChannel"</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">worker1Channel</span>)
<span class="hljs-variable language_">this</span>.<span class="hljs-property">worker1</span>.<span class="hljs-title function_">start</span>()

<span class="hljs-variable language_">this</span>.<span class="hljs-property">worker2</span> = <span class="hljs-title function_">createJWorker</span>(<span class="hljs-string">"sample/ets/worker/mainmultiworker/MainMultiWorker.ets"</span>)
<span class="hljs-variable language_">this</span>.<span class="hljs-property">worker2Channel</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MainMultiChannel</span>()
<span class="hljs-variable language_">this</span>.<span class="hljs-property">worker2</span>.<span class="hljs-title function_">addChannel</span>(<span class="hljs-string">"multiChannel"</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">worker2Channel</span>)
<span class="hljs-variable language_">this</span>.<span class="hljs-property">worker2</span>.<span class="hljs-title function_">start</span>()
</code></pre>
<h3 data-id="heading-10">2、子 Worker 开多个子 Worker</h3>
<p><code>JWorker</code> 同样支持在子 Worker 中开启多个 <code>JWorker</code> ，可以进行如下图所示的创建和管理。</p>
<blockquote>
<p>“子 Worker 开多个子 Worker” 示例完整代码 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FzincPower%2FJWorker%2Ftree%2Fmain%2Fsample%2Fsrc%2Fmain%2Fets%2Fworker%2Fsubmultiworker" target="_blank" title="https://github.com/zincPower/JWorker/tree/main/sample/src/main/ets/worker/submultiworker" ref="nofollow noopener noreferrer">传送门</a></p>
</blockquote>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6ad99bd5488f42b38fe7133536e5fa0d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5rGf5r6O5raM:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766363366&amp;x-signature=Y4omM%2BPnwoOrW9nj4ZB7yfIFuWI%3D" alt="sub_multi_worker.png" loading="lazy"/></p>
<p>可以在子 Worker 需要创建子 Worker 的地方调用 <code>createJWorker</code> 方法创建 <code>JWorker</code> ，然后进行启动和添加相应 Channel 进行通讯。<strong>使用方式和之前的完全相同。</strong></p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ParentSubChannel</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Channel</span> {
  <span class="hljs-comment">// 省略其他逻辑</span>

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">worker: SubWorker</span>) {
    <span class="hljs-comment">// 省略其他逻辑</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">startChildrenWorker</span>()
  }

  <span class="hljs-keyword">private</span> <span class="hljs-title function_">startChildrenWorker</span>(<span class="hljs-params"/>) {
    <span class="hljs-comment">// 创建三个 JWorker 并开启，添加对应 Channel </span>
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">childWorker1</span> == <span class="hljs-literal">undefined</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">childWorker1</span> = <span class="hljs-title function_">createJWorker</span>(<span class="hljs-string">"sample/ets/worker/submultiworker/ChildWorker.ets"</span>)
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">childWorker1Channel</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChildMainChannel</span>()
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">childWorker1</span>.<span class="hljs-title function_">addChannel</span>(<span class="hljs-string">"childChannel"</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">childWorker1Channel</span>)
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">childWorker1</span>.<span class="hljs-title function_">start</span>()
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">childWorker2</span> == <span class="hljs-literal">undefined</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">childWorker2</span> = <span class="hljs-title function_">createJWorker</span>(<span class="hljs-string">"sample/ets/worker/submultiworker/ChildWorker.ets"</span>)
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">childWorker2Channel</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChildMainChannel</span>()
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">childWorker2</span>.<span class="hljs-title function_">addChannel</span>(<span class="hljs-string">"childChannel"</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">childWorker2Channel</span>)
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">childWorker2</span>.<span class="hljs-title function_">start</span>()
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">childWorker3</span> == <span class="hljs-literal">undefined</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">childWorker3</span> = <span class="hljs-title function_">createJWorker</span>(<span class="hljs-string">"sample/ets/worker/submultiworker/ChildWorker.ets"</span>)
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">childWorker3Channel</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChildMainChannel</span>()
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">childWorker3</span>.<span class="hljs-title function_">addChannel</span>(<span class="hljs-string">"childChannel"</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">childWorker3Channel</span>)
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">childWorker3</span>.<span class="hljs-title function_">start</span>()
    }
  }
}
</code></pre>
<p><strong>值得注意</strong></p>
<p>这种情况下需要控制好 Worker 的关闭顺序，应该让项目的主 Worker 通知子 Worker 进行关闭他创建的子 Worker ，然后在关闭自身。具体操作如下：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// 项目主 Worker 调用子 Worker 的 exit 方法</span>
<span class="hljs-variable language_">this</span>.<span class="hljs-property">workerChannel</span>?.<span class="hljs-title function_">send</span>(<span class="hljs-string">"exit"</span>)

<span class="hljs-comment">// 子 Worker 接收到主 Worker 的 “exit” 调用，则调用子 Worker 创建的子 Worker 的 “exit” 方法进行退出，并等待所有的子 Worker 处理完再退出自身</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ParentSubChannel</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Channel</span> {
  <span class="hljs-comment">// 省略其他逻辑</span>
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">handleMessage</span>(<span class="hljs-params">methodName: <span class="hljs-built_in">string</span>, data: Any</span>) {
    <span class="hljs-keyword">switch</span> (methodName) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">"exit"</span>: {
        <span class="hljs-comment">// 等待所有子 Worker 退出完成</span>
        <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([<span class="hljs-variable language_">this</span>.<span class="hljs-property">childWorker1Channel</span>?.<span class="hljs-title function_">send</span>(<span class="hljs-string">"exit"</span>), <span class="hljs-variable language_">this</span>.<span class="hljs-property">childWorker2Channel</span>?.<span class="hljs-title function_">send</span>(<span class="hljs-string">"exit"</span>), <span class="hljs-variable language_">this</span>.<span class="hljs-property">childWorker3Channel</span>?.<span class="hljs-title function_">send</span>(<span class="hljs-string">"exit"</span>)])
        <span class="hljs-title class_">Log</span>.<span class="hljs-title function_">i</span>(<span class="hljs-variable constant_">TAG</span>, <span class="hljs-string">"【exit】"</span>)
        <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">worker</span>?.<span class="hljs-title function_">release</span>()
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">worker</span> = <span class="hljs-literal">undefined</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">childWorker1</span> = <span class="hljs-literal">undefined</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">childWorker1Channel</span> = <span class="hljs-literal">undefined</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">childWorker2</span> = <span class="hljs-literal">undefined</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">childWorker2Channel</span> = <span class="hljs-literal">undefined</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">childWorker3</span> = <span class="hljs-literal">undefined</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">childWorker3Channel</span> = <span class="hljs-literal">undefined</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>
      }
      <span class="hljs-attr">default</span>: {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>
      }
    }
  }
}

<span class="hljs-comment">// 子 Worker 的子 Worker 接收到 “exit” 的调用，退出自身</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChildSubChannel</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Channel</span> {
  <span class="hljs-comment">// 省略其他逻辑</span>
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">handleMessage</span>(<span class="hljs-params">methodName: <span class="hljs-built_in">string</span>, data: Any</span>) {
    <span class="hljs-keyword">if</span> (methodName == <span class="hljs-string">"exit"</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">worker</span>.<span class="hljs-title function_">release</span>()
      <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>
  }
}
</code></pre>
<h2 data-id="heading-11">四、作者博客</h2>
<p>掘金：<a href="https://juejin.im/user/5c3033ef51882524ec3a88ba/posts" target="_blank" title="https://juejin.im/user/5c3033ef51882524ec3a88ba/posts">juejin.im/user/5c3033…</a></p>
<p>csdn：<a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fweixin_37625173" target="_blank" title="https://blog.csdn.net/weixin_37625173" ref="nofollow noopener noreferrer">blog.csdn.net/weixin_3762…</a></p>
<p>公众号：微信搜索 "江澎涌"</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[JavaScript 性能与优化：数据结构和算法]]></title>    <link>https://juejin.cn/post/7583727768543412260</link>    <guid>https://juejin.cn/post/7583727768543412260</guid>    <pubDate>2025-12-15T08:22:34.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7583727768543412260" data-draft-id="7583591656178024484" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="JavaScript 性能与优化：数据结构和算法"/> <meta itemprop="keywords" content="前端,算法,数据结构"/> <meta itemprop="datePublished" content="2025-12-15T08:22:34.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="1024肥宅"/> <meta itemprop="url" content="https://juejin.cn/user/588993964030574"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            JavaScript 性能与优化：数据结构和算法
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/588993964030574/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    1024肥宅
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-15T08:22:34.000Z" title="Mon Dec 15 2025 08:22:34 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-15
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读12分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h4 data-id="heading-0">引言</h4>
<p>在JavaScript开发中, 正确的数据结构和算法选择对应用性能有着决定性的影响。随着Web应用日益复杂, 处理的数据量不断增长, 优化代码性能变得至关重要。本文将深入探讨JavaScript中关键数据结构和算法的实现、优化策略以及其在实际项目中的应用。</p>
<h4 data-id="heading-1">一、JavaScript中数据结构的选择策略</h4>
<h5 data-id="heading-2">1.1 数组与对象的选择</h5>
<p>在JavaScript中, 数组和对象是最常用的数据结构, 但它们在不同场景下的性能特征差异显著。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 数组和对象性能对比示例</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">DataStructureSelector</span> {
  <span class="hljs-comment">// 数组: 适合顺序访问和索引访问</span>
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">arrayPerformanceTest</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">const</span> arr = [];
    <span class="hljs-keyword">const</span> size = <span class="hljs-number">1000000</span>;

    <span class="hljs-comment">// 测试插入性能</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">"数组插入"</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) {
      arr.<span class="hljs-title function_">push</span>(i);
    }
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">"数组插入"</span>);

    <span class="hljs-comment">// 测试随机访问性能</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">"数组随机访问"</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) {
      <span class="hljs-keyword">const</span> index = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * size);
      <span class="hljs-keyword">const</span> _ = arr[index];
    }
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">"数组随机访问"</span>);
  }

  <span class="hljs-comment">// 对象: 适合键值对查找</span>
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">objectPerformanceTest</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">const</span> obj = {};
    <span class="hljs-keyword">const</span> size = <span class="hljs-number">1000000</span>;

    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">"对象插入"</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) {
      obj[<span class="hljs-string">`key<span class="hljs-subst">${i}</span>`</span>] = i;
    }
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">"对象插入"</span>);

    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">"对象查找"</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) {
      <span class="hljs-keyword">const</span> key = <span class="hljs-string">`key<span class="hljs-subst">${<span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * size)}</span>`</span>;
      <span class="hljs-keyword">const</span> _ = obj[key];
    }
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">"对象查找"</span>);
  }
}

<span class="hljs-comment">// 性能测试</span>
<span class="hljs-title class_">DataStructureSelector</span>.<span class="hljs-title function_">arrayPerformanceTest</span>();
<span class="hljs-title class_">DataStructureSelector</span>.<span class="hljs-title function_">objectPerformanceTest</span>();
<span class="hljs-comment">// 数组插入: 24.589ms</span>
<span class="hljs-comment">// 数组随机访问: 0.172ms</span>
<span class="hljs-comment">// 对象插入: 933.765ms</span>
<span class="hljs-comment">// 对象查找: 0.512ms</span>
</code></pre>
<h5 data-id="heading-3">1.2 Map与Set的优势</h5>
<p>ES6引入的Map和Set提供了更专业的键值对和集合操作。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MapSetPerformance</span> {
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">compareMapVsObject</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">const</span> size = <span class="hljs-number">1000000</span>;

    <span class="hljs-comment">// Object测试</span>
    <span class="hljs-keyword">const</span> obj = {};
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">"Object设置"</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) {
      obj[i] = <span class="hljs-string">`value<span class="hljs-subst">${i}</span>`</span>;
    }
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">"Object设置"</span>);

    <span class="hljs-comment">// Map测试</span>
    <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">"Map设置"</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) {
      map.<span class="hljs-title function_">set</span>(i, <span class="hljs-string">`value<span class="hljs-subst">${i}</span>`</span>);
    }
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">"Map设置"</span>);

    <span class="hljs-comment">// 查找性能比较</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">"Object查找"</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) {
      <span class="hljs-keyword">const</span> key = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * size);
      <span class="hljs-keyword">const</span> _ = obj[key];
    }
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">"Object查找"</span>);

    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">"Map查找"</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) {
      <span class="hljs-keyword">const</span> key = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * size);
      <span class="hljs-keyword">const</span> _ = map.<span class="hljs-title function_">get</span>(key);
    }
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">"Map查找"</span>);
  }

  <span class="hljs-keyword">static</span> <span class="hljs-title function_">setOperations</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">const</span> setA = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]);
    <span class="hljs-keyword">const</span> setB = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>]);

    <span class="hljs-comment">// 并集</span>
    <span class="hljs-keyword">const</span> union = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([...setA, ...setB]);

    <span class="hljs-comment">// 交集</span>
    <span class="hljs-keyword">const</span> intersection = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([...setA].<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> setB.<span class="hljs-title function_">has</span>(x)));

    <span class="hljs-comment">// 差集</span>
    <span class="hljs-keyword">const</span> difference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([...setA].<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> !setB.<span class="hljs-title function_">has</span>(x)));

    <span class="hljs-keyword">return</span> { union, intersection, difference };
  }
}

<span class="hljs-title class_">MapSetPerformance</span>.<span class="hljs-title function_">compareMapVsObject</span>();
<span class="hljs-title class_">MapSetPerformance</span>.<span class="hljs-title function_">setOperations</span>();
<span class="hljs-comment">// Object设置: 192.252ms</span>
<span class="hljs-comment">// Map设置: 329.439ms</span>
<span class="hljs-comment">// Object查找: 1.574ms</span>
<span class="hljs-comment">// Map查找: 2.983ms</span>
</code></pre>
<h4 data-id="heading-4">二、链表及其变体实现</h4>
<h5 data-id="heading-5">2.1 单向链表</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">value, next = <span class="hljs-literal">null</span></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">next</span> = next;
  }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedList</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = <span class="hljs-literal">null</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span> = <span class="hljs-literal">null</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> = <span class="hljs-number">0</span>;
  }

  <span class="hljs-comment">// 添加节点到末尾</span>
  <span class="hljs-title function_">append</span>(<span class="hljs-params">value</span>) {
    <span class="hljs-keyword">const</span> newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(value);

    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = newNode;
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span> = newNode;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>.<span class="hljs-property">next</span> = newNode;
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span> = newNode;
    }

    <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>++;
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;
  }

  <span class="hljs-comment">// 添加节点到开头</span>
  <span class="hljs-title function_">prepend</span>(<span class="hljs-params">value</span>) {
    <span class="hljs-keyword">const</span> newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(value, <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = newNode;

    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span> = newNode;
    }

    <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>++;
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;
  }

  <span class="hljs-comment">// 删除节点</span>
  <span class="hljs-title function_">delete</span>(<span class="hljs-params">value</span>) {
    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;

    <span class="hljs-keyword">let</span> deletedNode = <span class="hljs-literal">null</span>;

    <span class="hljs-comment">// 如果头节点就是要删除的节点</span>
    <span class="hljs-keyword">while</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">value</span> === value) {
      deletedNode = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>;
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>--;
    }

    <span class="hljs-keyword">let</span> currentNode = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;

    <span class="hljs-comment">// 遍历删除匹配的节点</span>
    <span class="hljs-keyword">if</span> (currentNode !== <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">while</span> (currentNode.<span class="hljs-property">next</span>) {
        <span class="hljs-keyword">if</span> (currentNode.<span class="hljs-property">next</span>.<span class="hljs-property">value</span> === value) {
          deletedNode = currentNode.<span class="hljs-property">next</span>;
          currentNode.<span class="hljs-property">next</span> = currentNode.<span class="hljs-property">next</span>.<span class="hljs-property">next</span>;
        } <span class="hljs-keyword">else</span> {
          currentNode = currentNode.<span class="hljs-property">next</span>;
        }
      }
    }

    <span class="hljs-comment">// 更新尾节点</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>.<span class="hljs-property">value</span> === value) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span> = currentNode;
    }

    <span class="hljs-keyword">return</span> deletedNode;
  }

  <span class="hljs-comment">// 查找节点</span>
  <span class="hljs-title function_">find</span>(<span class="hljs-params">value</span>) {
    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;

    <span class="hljs-keyword">let</span> currentNode = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;

    <span class="hljs-keyword">while</span> (currentNode) {
      <span class="hljs-keyword">if</span> (currentNode.<span class="hljs-property">value</span> === value) {
        <span class="hljs-keyword">return</span> currentNode;
      }

      currentNode = currentNode.<span class="hljs-property">next</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }

  <span class="hljs-comment">// 反转链表</span>
  <span class="hljs-title function_">reverse</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">let</span> currentNode = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;
    <span class="hljs-keyword">let</span> prevNode = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">let</span> nextNode = <span class="hljs-literal">null</span>;

    <span class="hljs-keyword">while</span> (currentNode) {
      nextNode = currentNode.<span class="hljs-property">next</span>;
      currentNode.<span class="hljs-property">next</span> = prevNode;

      prevNode = currentNode;
      currentNode = nextNode;
    }

    <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = prevNode;

    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;
  }

  <span class="hljs-comment">// 转换为数组</span>
  <span class="hljs-title function_">toArray</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">const</span> nodes = [];
    <span class="hljs-keyword">let</span> currentNode = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;

    <span class="hljs-keyword">while</span> (currentNode) {
      nodes.<span class="hljs-title function_">push</span>(currentNode.<span class="hljs-property">value</span>);
      currentNode = currentNode.<span class="hljs-property">next</span>;
    }

    <span class="hljs-keyword">return</span> nodes;
  }
}
</code></pre>
<h5 data-id="heading-6">2.2 双向链表</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DoublyListNode</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">value, next = <span class="hljs-literal">null</span>, prev = <span class="hljs-literal">null</span></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">next</span> = next;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">prev</span> = prev;
  }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">DoublyLinkedList</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = <span class="hljs-literal">null</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span> = <span class="hljs-literal">null</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> = <span class="hljs-number">0</span>;
  }
  
  <span class="hljs-comment">// 在末尾添加节点</span>
  <span class="hljs-title function_">append</span>(<span class="hljs-params">value</span>) {
    <span class="hljs-keyword">const</span> newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DoublyListNode</span>(value);
    
    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = newNode;
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span> = newNode;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>.<span class="hljs-property">next</span> = newNode;
      newNode.<span class="hljs-property">prev</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>;
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span> = newNode;
    }
    
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>++;
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;
  }
  
  <span class="hljs-comment">// 在开头添加节点</span>
  <span class="hljs-title function_">prepend</span>(<span class="hljs-params">value</span>) {
    <span class="hljs-keyword">const</span> newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DoublyListNode</span>(value, <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>);
    
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">prev</span> = newNode;
    }
    
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = newNode;
    
    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span> = newNode;
    }
    
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>++;
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;
  }
  
  <span class="hljs-comment">// 删除节点</span>
  <span class="hljs-title function_">delete</span>(<span class="hljs-params">value</span>) {
    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    
    <span class="hljs-keyword">let</span> deletedNode = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">let</span> currentNode = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;
    
    <span class="hljs-keyword">while</span> (currentNode) {
      <span class="hljs-keyword">if</span> (currentNode.<span class="hljs-property">value</span> === value) {
        deletedNode = currentNode;
        
        <span class="hljs-keyword">if</span> (deletedNode === <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>) {
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = deletedNode.<span class="hljs-property">next</span>;
          
          <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>) {
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">prev</span> = <span class="hljs-literal">null</span>;
          }
          
          <span class="hljs-keyword">if</span> (deletedNode === <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>) {
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span> = <span class="hljs-literal">null</span>;
          }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (deletedNode === <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>) {
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span> = deletedNode.<span class="hljs-property">prev</span>;
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>.<span class="hljs-property">next</span> = <span class="hljs-literal">null</span>;
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">const</span> prevNode = deletedNode.<span class="hljs-property">prev</span>;
          <span class="hljs-keyword">const</span> nextNode = deletedNode.<span class="hljs-property">next</span>;
          
          prevNode.<span class="hljs-property">next</span> = nextNode;
          nextNode.<span class="hljs-property">prev</span> = prevNode;
        }
        
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>--;
      }
      
      currentNode = currentNode.<span class="hljs-property">next</span>;
    }
    
    <span class="hljs-keyword">return</span> deletedNode;
  }
  
  <span class="hljs-comment">// 从尾部遍历</span>
  <span class="hljs-title function_">reverseTraversal</span>(<span class="hljs-params">callback</span>) {
    <span class="hljs-keyword">let</span> currentNode = <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>;
    
    <span class="hljs-keyword">while</span> (currentNode) {
      <span class="hljs-title function_">callback</span>(currentNode.<span class="hljs-property">value</span>);
      currentNode = currentNode.<span class="hljs-property">prev</span>;
    }
  }
}
</code></pre>
<h4 data-id="heading-7">三、栈和队列的优化实现</h4>
<h5 data-id="heading-8">3.1 栈的实现</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span> = [];
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> = <span class="hljs-number">0</span>;
  }
  
  <span class="hljs-comment">// 入栈</span>
  <span class="hljs-title function_">push</span>(<span class="hljs-params">element</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>] = element;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++;
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>;
  }
  
  <span class="hljs-comment">// 出栈</span>
  <span class="hljs-title function_">pop</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
    
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>--;
    <span class="hljs-keyword">const</span> deletedItem = <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>];
    <span class="hljs-keyword">delete</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>];
    <span class="hljs-keyword">return</span> deletedItem;
  }
  
  <span class="hljs-comment">// 查看栈顶元素</span>
  <span class="hljs-title function_">peek</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> - <span class="hljs-number">1</span>];
  }
  
  <span class="hljs-comment">// 检查栈是否为空</span>
  <span class="hljs-title function_">isEmpty</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> === <span class="hljs-number">0</span>;
  }
  
  <span class="hljs-comment">// 获取栈大小</span>
  <span class="hljs-title function_">size</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>;
  }
  
  <span class="hljs-comment">// 清空栈</span>
  <span class="hljs-title function_">clear</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span> = [];
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> = <span class="hljs-number">0</span>;
  }
  
  <span class="hljs-comment">// 栈的应用：括号匹配</span>
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">isBalancedParentheses</span>(<span class="hljs-params">str</span>) {
    <span class="hljs-keyword">const</span> stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>();
    <span class="hljs-keyword">const</span> parenthesesMap = {
      <span class="hljs-string">')'</span>: <span class="hljs-string">'('</span>,
      <span class="hljs-string">'}'</span>: <span class="hljs-string">'{'</span>,
      <span class="hljs-string">']'</span>: <span class="hljs-string">'['</span>
    };
    
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> char <span class="hljs-keyword">of</span> str) {
      <span class="hljs-keyword">if</span> (char === <span class="hljs-string">'('</span> || char === <span class="hljs-string">'{'</span> || char === <span class="hljs-string">'['</span>) {
        stack.<span class="hljs-title function_">push</span>(char);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (char === <span class="hljs-string">')'</span> || char === <span class="hljs-string">'}'</span> || char === <span class="hljs-string">']'</span>) {
        <span class="hljs-keyword">if</span> (stack.<span class="hljs-title function_">isEmpty</span>() || stack.<span class="hljs-title function_">pop</span>() !== parenthesesMap[char]) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
      }
    }
    
    <span class="hljs-keyword">return</span> stack.<span class="hljs-title function_">isEmpty</span>();
  }
}
</code></pre>
<h5 data-id="heading-9">3.2 队列的实现</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Queue</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span> = {};
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">frontIndex</span> = <span class="hljs-number">0</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">backIndex</span> = <span class="hljs-number">0</span>;
  }
  
  <span class="hljs-comment">// 入队</span>
  <span class="hljs-title function_">enqueue</span>(<span class="hljs-params">element</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">backIndex</span>] = element;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">backIndex</span>++;
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">backIndex</span> - <span class="hljs-variable language_">this</span>.<span class="hljs-property">frontIndex</span>;
  }
  
  <span class="hljs-comment">// 出队</span>
  <span class="hljs-title function_">dequeue</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">frontIndex</span> === <span class="hljs-variable language_">this</span>.<span class="hljs-property">backIndex</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
    
    <span class="hljs-keyword">const</span> element = <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">frontIndex</span>];
    <span class="hljs-keyword">delete</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">frontIndex</span>];
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">frontIndex</span>++;
    <span class="hljs-keyword">return</span> element;
  }
  
  <span class="hljs-comment">// 查看队首元素</span>
  <span class="hljs-title function_">peek</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">frontIndex</span> === <span class="hljs-variable language_">this</span>.<span class="hljs-property">backIndex</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">frontIndex</span>];
  }
  
  <span class="hljs-comment">// 队列大小</span>
  <span class="hljs-title function_">size</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">backIndex</span> - <span class="hljs-variable language_">this</span>.<span class="hljs-property">frontIndex</span>;
  }
  
  <span class="hljs-comment">// 是否为空</span>
  <span class="hljs-title function_">isEmpty</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">size</span>() === <span class="hljs-number">0</span>;
  }
  
  <span class="hljs-comment">// 清空队列</span>
  <span class="hljs-title function_">clear</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span> = {};
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">frontIndex</span> = <span class="hljs-number">0</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">backIndex</span> = <span class="hljs-number">0</span>;
  }
}

<span class="hljs-comment">// 循环队列实现</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">CircularQueue</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">k</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span> = k;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">queue</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(k);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">headIndex</span> = <span class="hljs-number">0</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> = <span class="hljs-number">0</span>;
  }
  
  <span class="hljs-title function_">enQueue</span>(<span class="hljs-params">value</span>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isFull</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    
    <span class="hljs-keyword">const</span> tailIndex = (<span class="hljs-variable language_">this</span>.<span class="hljs-property">headIndex</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>) % <span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">queue</span>[tailIndex] = value;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }
  
  <span class="hljs-title function_">deQueue</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isEmpty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">headIndex</span> = (<span class="hljs-variable language_">this</span>.<span class="hljs-property">headIndex</span> + <span class="hljs-number">1</span>) % <span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>--;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }
  
  <span class="hljs-title class_">Front</span>() {
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isEmpty</span>()) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">queue</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">headIndex</span>];
  }
  
  <span class="hljs-title class_">Rear</span>() {
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isEmpty</span>()) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
    <span class="hljs-keyword">const</span> tailIndex = (<span class="hljs-variable language_">this</span>.<span class="hljs-property">headIndex</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> - <span class="hljs-number">1</span>) % <span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">queue</span>[tailIndex];
  }
  
  <span class="hljs-title function_">isEmpty</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> === <span class="hljs-number">0</span>;
  }
  
  <span class="hljs-title function_">isFull</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> === <span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span>;
  }
}
</code></pre>
<h4 data-id="heading-10">四、树结构的深度优化</h4>
<h5 data-id="heading-11">4.1 二叉树实现</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">value</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">left</span> = <span class="hljs-literal">null</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">right</span> = <span class="hljs-literal">null</span>;
  }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">BinaryTree</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">root</span> = <span class="hljs-literal">null</span>;
  }
  
  <span class="hljs-comment">// 插入节点</span>
  <span class="hljs-title function_">insert</span>(<span class="hljs-params">value</span>) {
    <span class="hljs-keyword">const</span> newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(value);
    
    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">root</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">root</span> = newNode;
      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;
    }
    
    <span class="hljs-keyword">let</span> currentNode = <span class="hljs-variable language_">this</span>.<span class="hljs-property">root</span>;
    
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
      <span class="hljs-keyword">if</span> (value &lt; currentNode.<span class="hljs-property">value</span>) {
        <span class="hljs-keyword">if</span> (!currentNode.<span class="hljs-property">left</span>) {
          currentNode.<span class="hljs-property">left</span> = newNode;
          <span class="hljs-keyword">break</span>;
        }
        currentNode = currentNode.<span class="hljs-property">left</span>;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">if</span> (!currentNode.<span class="hljs-property">right</span>) {
          currentNode.<span class="hljs-property">right</span> = newNode;
          <span class="hljs-keyword">break</span>;
        }
        currentNode = currentNode.<span class="hljs-property">right</span>;
      }
    }
    
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;
  }
  
  <span class="hljs-comment">// 深度优先遍历：前序</span>
  <span class="hljs-title function_">preOrderTraversal</span>(<span class="hljs-params">node = <span class="hljs-variable language_">this</span>.root, result = []</span>) {
    <span class="hljs-keyword">if</span> (node) {
      result.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">value</span>);
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">preOrderTraversal</span>(node.<span class="hljs-property">left</span>, result);
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">preOrderTraversal</span>(node.<span class="hljs-property">right</span>, result);
    }
    <span class="hljs-keyword">return</span> result;
  }
  
  <span class="hljs-comment">// 深度优先遍历：中序</span>
  <span class="hljs-title function_">inOrderTraversal</span>(<span class="hljs-params">node = <span class="hljs-variable language_">this</span>.root, result = []</span>) {
    <span class="hljs-keyword">if</span> (node) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">inOrderTraversal</span>(node.<span class="hljs-property">left</span>, result);
      result.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">value</span>);
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">inOrderTraversal</span>(node.<span class="hljs-property">right</span>, result);
    }
    <span class="hljs-keyword">return</span> result;
  }
  
  <span class="hljs-comment">// 深度优先遍历：后序</span>
  <span class="hljs-title function_">postOrderTraversal</span>(<span class="hljs-params">node = <span class="hljs-variable language_">this</span>.root, result = []</span>) {
    <span class="hljs-keyword">if</span> (node) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">postOrderTraversal</span>(node.<span class="hljs-property">left</span>, result);
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">postOrderTraversal</span>(node.<span class="hljs-property">right</span>, result);
      result.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">value</span>);
    }
    <span class="hljs-keyword">return</span> result;
  }
  
  <span class="hljs-comment">// 广度优先遍历</span>
  <span class="hljs-title function_">levelOrderTraversal</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">root</span>) <span class="hljs-keyword">return</span> [];
    
    <span class="hljs-keyword">const</span> result = [];
    <span class="hljs-keyword">const</span> queue = [<span class="hljs-variable language_">this</span>.<span class="hljs-property">root</span>];
    
    <span class="hljs-keyword">while</span> (queue.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">const</span> levelSize = queue.<span class="hljs-property">length</span>;
      <span class="hljs-keyword">const</span> currentLevel = [];
      
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; levelSize; i++) {
        <span class="hljs-keyword">const</span> currentNode = queue.<span class="hljs-title function_">shift</span>();
        currentLevel.<span class="hljs-title function_">push</span>(currentNode.<span class="hljs-property">value</span>);
        
        <span class="hljs-keyword">if</span> (currentNode.<span class="hljs-property">left</span>) {
          queue.<span class="hljs-title function_">push</span>(currentNode.<span class="hljs-property">left</span>);
        }
        <span class="hljs-keyword">if</span> (currentNode.<span class="hljs-property">right</span>) {
          queue.<span class="hljs-title function_">push</span>(currentNode.<span class="hljs-property">right</span>);
        }
      }
      
      result.<span class="hljs-title function_">push</span>(currentLevel);
    }
    
    <span class="hljs-keyword">return</span> result;
  }
  
  <span class="hljs-comment">// 查找节点</span>
  <span class="hljs-title function_">find</span>(<span class="hljs-params">value</span>) {
    <span class="hljs-keyword">let</span> currentNode = <span class="hljs-variable language_">this</span>.<span class="hljs-property">root</span>;
    
    <span class="hljs-keyword">while</span> (currentNode) {
      <span class="hljs-keyword">if</span> (value === currentNode.<span class="hljs-property">value</span>) {
        <span class="hljs-keyword">return</span> currentNode;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value &lt; currentNode.<span class="hljs-property">value</span>) {
        currentNode = currentNode.<span class="hljs-property">left</span>;
      } <span class="hljs-keyword">else</span> {
        currentNode = currentNode.<span class="hljs-property">right</span>;
      }
    }
    
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }
}
</code></pre>
<h5 data-id="heading-12">4.2 平衡二叉搜索树(AVL树)</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AVLNode</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">value</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">left</span> = <span class="hljs-literal">null</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">right</span> = <span class="hljs-literal">null</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">height</span> = <span class="hljs-number">1</span>;
  }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">AVLTree</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">root</span> = <span class="hljs-literal">null</span>;
  }
  
  <span class="hljs-comment">// 获取节点高度</span>
  <span class="hljs-title function_">getHeight</span>(<span class="hljs-params">node</span>) {
    <span class="hljs-keyword">return</span> node ? node.<span class="hljs-property">height</span> : <span class="hljs-number">0</span>;
  }
  
  <span class="hljs-comment">// 获取平衡因子</span>
  <span class="hljs-title function_">getBalanceFactor</span>(<span class="hljs-params">node</span>) {
    <span class="hljs-keyword">return</span> node ? <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getHeight</span>(node.<span class="hljs-property">left</span>) - <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getHeight</span>(node.<span class="hljs-property">right</span>) : <span class="hljs-number">0</span>;
  }
  
  <span class="hljs-comment">// 右旋转</span>
  <span class="hljs-title function_">rightRotate</span>(<span class="hljs-params">y</span>) {
    <span class="hljs-keyword">const</span> x = y.<span class="hljs-property">left</span>;
    <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">T2</span> = x.<span class="hljs-property">right</span>;
    
    x.<span class="hljs-property">right</span> = y;
    y.<span class="hljs-property">left</span> = <span class="hljs-variable constant_">T2</span>;
    
    y.<span class="hljs-property">height</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getHeight</span>(y.<span class="hljs-property">left</span>), <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getHeight</span>(y.<span class="hljs-property">right</span>)) + <span class="hljs-number">1</span>;
    x.<span class="hljs-property">height</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getHeight</span>(x.<span class="hljs-property">left</span>), <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getHeight</span>(x.<span class="hljs-property">right</span>)) + <span class="hljs-number">1</span>;
    
    <span class="hljs-keyword">return</span> x;
  }
  
  <span class="hljs-comment">// 左旋转</span>
  <span class="hljs-title function_">leftRotate</span>(<span class="hljs-params">x</span>) {
    <span class="hljs-keyword">const</span> y = x.<span class="hljs-property">right</span>;
    <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">T2</span> = y.<span class="hljs-property">left</span>;
    
    y.<span class="hljs-property">left</span> = x;
    x.<span class="hljs-property">right</span> = <span class="hljs-variable constant_">T2</span>;
    
    x.<span class="hljs-property">height</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getHeight</span>(x.<span class="hljs-property">left</span>), <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getHeight</span>(x.<span class="hljs-property">right</span>)) + <span class="hljs-number">1</span>;
    y.<span class="hljs-property">height</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getHeight</span>(y.<span class="hljs-property">left</span>), <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getHeight</span>(y.<span class="hljs-property">right</span>)) + <span class="hljs-number">1</span>;
    
    <span class="hljs-keyword">return</span> y;
  }
  
  <span class="hljs-comment">// 插入节点</span>
  <span class="hljs-title function_">insert</span>(<span class="hljs-params">value</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">root</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_insertNode</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">root</span>, value);
  }
  
  <span class="hljs-title function_">_insertNode</span>(<span class="hljs-params">node, value</span>) {
    <span class="hljs-keyword">if</span> (!node) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AVLNode</span>(value);
    
    <span class="hljs-keyword">if</span> (value &lt; node.<span class="hljs-property">value</span>) {
      node.<span class="hljs-property">left</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_insertNode</span>(node.<span class="hljs-property">left</span>, value);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value &gt; node.<span class="hljs-property">value</span>) {
      node.<span class="hljs-property">right</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_insertNode</span>(node.<span class="hljs-property">right</span>, value);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> node; <span class="hljs-comment">// 不允许重复值</span>
    }
    
    <span class="hljs-comment">// 更新高度</span>
    node.<span class="hljs-property">height</span> = <span class="hljs-number">1</span> + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getHeight</span>(node.<span class="hljs-property">left</span>),
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getHeight</span>(node.<span class="hljs-property">right</span>)
    );
    
    <span class="hljs-comment">// 获取平衡因子</span>
    <span class="hljs-keyword">const</span> balance = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getBalanceFactor</span>(node);
    
    <span class="hljs-comment">// 平衡调整</span>
    <span class="hljs-comment">// 左左情况</span>
    <span class="hljs-keyword">if</span> (balance &gt; <span class="hljs-number">1</span> &amp;&amp; value &lt; node.<span class="hljs-property">left</span>.<span class="hljs-property">value</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">rightRotate</span>(node);
    }
    
    <span class="hljs-comment">// 右右情况</span>
    <span class="hljs-keyword">if</span> (balance &lt; -<span class="hljs-number">1</span> &amp;&amp; value &gt; node.<span class="hljs-property">right</span>.<span class="hljs-property">value</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">leftRotate</span>(node);
    }
    
    <span class="hljs-comment">// 左右情况</span>
    <span class="hljs-keyword">if</span> (balance &gt; <span class="hljs-number">1</span> &amp;&amp; value &gt; node.<span class="hljs-property">left</span>.<span class="hljs-property">value</span>) {
      node.<span class="hljs-property">left</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">leftRotate</span>(node.<span class="hljs-property">left</span>);
      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">rightRotate</span>(node);
    }
    
    <span class="hljs-comment">// 右左情况</span>
    <span class="hljs-keyword">if</span> (balance &lt; -<span class="hljs-number">1</span> &amp;&amp; value &lt; node.<span class="hljs-property">right</span>.<span class="hljs-property">value</span>) {
      node.<span class="hljs-property">right</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">rightRotate</span>(node.<span class="hljs-property">right</span>);
      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">leftRotate</span>(node);
    }
    
    <span class="hljs-keyword">return</span> node;
  }
  
  <span class="hljs-comment">// 查找最小值节点</span>
  <span class="hljs-title function_">findMinNode</span>(<span class="hljs-params">node</span>) {
    <span class="hljs-keyword">while</span> (node &amp;&amp; node.<span class="hljs-property">left</span>) {
      node = node.<span class="hljs-property">left</span>;
    }
    <span class="hljs-keyword">return</span> node;
  }
}
</code></pre>
<h4 data-id="heading-13">五、LRU缓存机制实现</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">capacity</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span> = capacity;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = { <span class="hljs-attr">key</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">value</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">prev</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span> };
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span> = { <span class="hljs-attr">key</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">value</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">prev</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span> };
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>.<span class="hljs-property">prev</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;
  }
  
  <span class="hljs-comment">// 添加节点到链表头部</span>
  <span class="hljs-title function_">_addToHead</span>(<span class="hljs-params">node</span>) {
    node.<span class="hljs-property">prev</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;
    node.<span class="hljs-property">next</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>.<span class="hljs-property">prev</span> = node;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span> = node;
  }
  
  <span class="hljs-comment">// 移除节点</span>
  <span class="hljs-title function_">_removeNode</span>(<span class="hljs-params">node</span>) {
    <span class="hljs-keyword">const</span> prev = node.<span class="hljs-property">prev</span>;
    <span class="hljs-keyword">const</span> next = node.<span class="hljs-property">next</span>;
    prev.<span class="hljs-property">next</span> = next;
    next.<span class="hljs-property">prev</span> = prev;
  }
  
  <span class="hljs-comment">// 移动到头部</span>
  <span class="hljs-title function_">_moveToHead</span>(<span class="hljs-params">node</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_removeNode</span>(node);
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_addToHead</span>(node);
  }
  
  <span class="hljs-comment">// 移除尾部节点</span>
  <span class="hljs-title function_">_popTail</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">const</span> res = <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>.<span class="hljs-property">prev</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_removeNode</span>(res);
    <span class="hljs-keyword">return</span> res;
  }
  
  <span class="hljs-comment">// 获取缓存</span>
  <span class="hljs-title function_">get</span>(<span class="hljs-params">key</span>) {
    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">has</span>(key)) {
      <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
    }
    
    <span class="hljs-keyword">const</span> node = <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">get</span>(key);
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_moveToHead</span>(node);
    <span class="hljs-keyword">return</span> node.<span class="hljs-property">value</span>;
  }
  
  <span class="hljs-comment">// 设置缓存</span>
  <span class="hljs-title function_">put</span>(<span class="hljs-params">key, value</span>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">has</span>(key)) {
      <span class="hljs-keyword">const</span> node = <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">get</span>(key);
      node.<span class="hljs-property">value</span> = value;
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_moveToHead</span>(node);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">const</span> newNode = {
        key,
        value,
        <span class="hljs-attr">prev</span>: <span class="hljs-literal">null</span>,
        <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span>
      };
      
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">set</span>(key, newNode);
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_addToHead</span>(newNode);
      
      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-property">size</span> &gt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span>) {
        <span class="hljs-keyword">const</span> tail = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_popTail</span>();
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">delete</span>(tail.<span class="hljs-property">key</span>);
      }
    }
  }
  
  <span class="hljs-comment">// 获取所有缓存键（按使用顺序）</span>
  <span class="hljs-title function_">getKeys</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">const</span> keys = [];
    <span class="hljs-keyword">let</span> node = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>;
    
    <span class="hljs-keyword">while</span> (node !== <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>) {
      keys.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">key</span>);
      node = node.<span class="hljs-property">next</span>;
    }
    
    <span class="hljs-keyword">return</span> keys;
  }
  
  <span class="hljs-comment">// 清空缓存</span>
  <span class="hljs-title function_">clear</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">clear</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>.<span class="hljs-property">prev</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;
  }
}

<span class="hljs-comment">// LRU缓存使用示例</span>
<span class="hljs-keyword">const</span> lruCache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LRUCache</span>(<span class="hljs-number">3</span>);

<span class="hljs-comment">// 添加数据</span>
lruCache.<span class="hljs-title function_">put</span>(<span class="hljs-string">'user1'</span>, { <span class="hljs-attr">name</span>: <span class="hljs-string">'Alice'</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">25</span> });
lruCache.<span class="hljs-title function_">put</span>(<span class="hljs-string">'user2'</span>, { <span class="hljs-attr">name</span>: <span class="hljs-string">'Bob'</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">30</span> });
lruCache.<span class="hljs-title function_">put</span>(<span class="hljs-string">'user3'</span>, { <span class="hljs-attr">name</span>: <span class="hljs-string">'Charlie'</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">35</span> });

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'当前缓存键:'</span>, lruCache.<span class="hljs-title function_">getKeys</span>()); <span class="hljs-comment">// ['user3', 'user2', 'user1']</span>

<span class="hljs-comment">// 访问user1，将其移动到最前面</span>
lruCache.<span class="hljs-title function_">get</span>(<span class="hljs-string">'user1'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'访问user1后:'</span>, lruCache.<span class="hljs-title function_">getKeys</span>()); <span class="hljs-comment">// ['user1', 'user3', 'user2']</span>

<span class="hljs-comment">// 添加新数据，超出容量</span>
lruCache.<span class="hljs-title function_">put</span>(<span class="hljs-string">'user4'</span>, { <span class="hljs-attr">name</span>: <span class="hljs-string">'David'</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">40</span> });
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'添加user4后:'</span>, lruCache.<span class="hljs-title function_">getKeys</span>()); <span class="hljs-comment">// ['user4', 'user1', 'user3']</span>
</code></pre>
<h4 data-id="heading-14">六、图的算法实现</h4>
<h5 data-id="heading-15">6.1 图的表示和遍历</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Graph</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">isDirected = <span class="hljs-literal">false</span></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">vertices</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">isDirected</span> = isDirected;
  }
  
  <span class="hljs-comment">// 添加顶点</span>
  <span class="hljs-title function_">addVertex</span>(<span class="hljs-params">vertex</span>) {
    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">vertices</span>.<span class="hljs-title function_">has</span>(vertex)) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">vertices</span>.<span class="hljs-title function_">set</span>(vertex, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>());
    }
  }
  
  <span class="hljs-comment">// 添加边</span>
  <span class="hljs-title function_">addEdge</span>(<span class="hljs-params">vertex1, vertex2</span>) {
    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">vertices</span>.<span class="hljs-title function_">has</span>(vertex1)) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">addVertex</span>(vertex1);
    }
    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">vertices</span>.<span class="hljs-title function_">has</span>(vertex2)) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">addVertex</span>(vertex2);
    }
    
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">vertices</span>.<span class="hljs-title function_">get</span>(vertex1).<span class="hljs-title function_">add</span>(vertex2);
    
    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">isDirected</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">vertices</span>.<span class="hljs-title function_">get</span>(vertex2).<span class="hljs-title function_">add</span>(vertex1);
    }
  }
  
  <span class="hljs-comment">// 深度优先遍历</span>
  <span class="hljs-title function_">dfs</span>(<span class="hljs-params">startVertex, callback</span>) {
    <span class="hljs-keyword">const</span> visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();
    
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">dfsVisit</span> = (<span class="hljs-params">vertex</span>) =&gt; {
      visited.<span class="hljs-title function_">add</span>(vertex);
      callback &amp;&amp; <span class="hljs-title function_">callback</span>(vertex);
      
      <span class="hljs-keyword">const</span> neighbors = <span class="hljs-variable language_">this</span>.<span class="hljs-property">vertices</span>.<span class="hljs-title function_">get</span>(vertex);
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> neighbor <span class="hljs-keyword">of</span> neighbors) {
        <span class="hljs-keyword">if</span> (!visited.<span class="hljs-title function_">has</span>(neighbor)) {
          <span class="hljs-title function_">dfsVisit</span>(neighbor);
        }
      }
    };
    
    <span class="hljs-title function_">dfsVisit</span>(startVertex);
  }
  
  <span class="hljs-comment">// 广度优先遍历</span>
  <span class="hljs-title function_">bfs</span>(<span class="hljs-params">startVertex, callback</span>) {
    <span class="hljs-keyword">const</span> visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([startVertex]);
    <span class="hljs-keyword">const</span> queue = [startVertex];
    
    <span class="hljs-keyword">while</span> (queue.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">const</span> vertex = queue.<span class="hljs-title function_">shift</span>();
      callback &amp;&amp; <span class="hljs-title function_">callback</span>(vertex);
      
      <span class="hljs-keyword">const</span> neighbors = <span class="hljs-variable language_">this</span>.<span class="hljs-property">vertices</span>.<span class="hljs-title function_">get</span>(vertex);
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> neighbor <span class="hljs-keyword">of</span> neighbors) {
        <span class="hljs-keyword">if</span> (!visited.<span class="hljs-title function_">has</span>(neighbor)) {
          visited.<span class="hljs-title function_">add</span>(neighbor);
          queue.<span class="hljs-title function_">push</span>(neighbor);
        }
      }
    }
  }
  
  <span class="hljs-comment">// 最短路径（BFS）</span>
  <span class="hljs-title function_">shortestPath</span>(<span class="hljs-params">startVertex, endVertex</span>) {
    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">vertices</span>.<span class="hljs-title function_">has</span>(startVertex) || !<span class="hljs-variable language_">this</span>.<span class="hljs-property">vertices</span>.<span class="hljs-title function_">has</span>(endVertex)) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }
    
    <span class="hljs-keyword">const</span> visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([startVertex]);
    <span class="hljs-keyword">const</span> queue = [startVertex];
    <span class="hljs-keyword">const</span> predecessors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
    <span class="hljs-keyword">const</span> distances = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
    
    distances.<span class="hljs-title function_">set</span>(startVertex, <span class="hljs-number">0</span>);
    
    <span class="hljs-keyword">while</span> (queue.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">const</span> vertex = queue.<span class="hljs-title function_">shift</span>();
      
      <span class="hljs-keyword">if</span> (vertex === endVertex) {
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_buildPath</span>(predecessors, startVertex, endVertex);
      }
      
      <span class="hljs-keyword">const</span> neighbors = <span class="hljs-variable language_">this</span>.<span class="hljs-property">vertices</span>.<span class="hljs-title function_">get</span>(vertex);
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> neighbor <span class="hljs-keyword">of</span> neighbors) {
        <span class="hljs-keyword">if</span> (!visited.<span class="hljs-title function_">has</span>(neighbor)) {
          visited.<span class="hljs-title function_">add</span>(neighbor);
          predecessors.<span class="hljs-title function_">set</span>(neighbor, vertex);
          distances.<span class="hljs-title function_">set</span>(neighbor, distances.<span class="hljs-title function_">get</span>(vertex) + <span class="hljs-number">1</span>);
          queue.<span class="hljs-title function_">push</span>(neighbor);
        }
      }
    }
    
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }
  
  <span class="hljs-title function_">_buildPath</span>(<span class="hljs-params">predecessors, start, end</span>) {
    <span class="hljs-keyword">const</span> path = [end];
    <span class="hljs-keyword">let</span> current = end;
    
    <span class="hljs-keyword">while</span> (current !== start) {
      current = predecessors.<span class="hljs-title function_">get</span>(current);
      path.<span class="hljs-title function_">unshift</span>(current);
    }
    
    <span class="hljs-keyword">return</span> path;
  }
  
  <span class="hljs-comment">// 拓扑排序（仅适用于有向无环图）</span>
  <span class="hljs-title function_">topologicalSort</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">isDirected</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'拓扑排序仅适用于有向图'</span>);
    }
    
    <span class="hljs-keyword">const</span> visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();
    <span class="hljs-keyword">const</span> stack = [];
    
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">visit</span> = (<span class="hljs-params">vertex</span>) =&gt; {
      visited.<span class="hljs-title function_">add</span>(vertex);
      
      <span class="hljs-keyword">const</span> neighbors = <span class="hljs-variable language_">this</span>.<span class="hljs-property">vertices</span>.<span class="hljs-title function_">get</span>(vertex);
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> neighbor <span class="hljs-keyword">of</span> neighbors) {
        <span class="hljs-keyword">if</span> (!visited.<span class="hljs-title function_">has</span>(neighbor)) {
          <span class="hljs-title function_">visit</span>(neighbor);
        }
      }
      
      stack.<span class="hljs-title function_">push</span>(vertex);
    };
    
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> vertex <span class="hljs-keyword">of</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">vertices</span>.<span class="hljs-title function_">keys</span>()) {
      <span class="hljs-keyword">if</span> (!visited.<span class="hljs-title function_">has</span>(vertex)) {
        <span class="hljs-title function_">visit</span>(vertex);
      }
    }
    
    <span class="hljs-keyword">return</span> stack.<span class="hljs-title function_">reverse</span>();
  }
}
</code></pre>
<h5 data-id="heading-16">6.2 Dijkstra最短路径算法</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">WeightedGraph</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">adjacencyList</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
  }
  
  <span class="hljs-title function_">addVertex</span>(<span class="hljs-params">vertex</span>) {
    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">adjacencyList</span>.<span class="hljs-title function_">has</span>(vertex)) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">adjacencyList</span>.<span class="hljs-title function_">set</span>(vertex, []);
    }
  }
  
  <span class="hljs-title function_">addEdge</span>(<span class="hljs-params">vertex1, vertex2, weight</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">adjacencyList</span>.<span class="hljs-title function_">get</span>(vertex1).<span class="hljs-title function_">push</span>({ <span class="hljs-attr">node</span>: vertex2, weight });
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">adjacencyList</span>.<span class="hljs-title function_">get</span>(vertex2).<span class="hljs-title function_">push</span>({ <span class="hljs-attr">node</span>: vertex1, weight });
  }
  
  <span class="hljs-title function_">dijkstra</span>(<span class="hljs-params">start, end</span>) {
    <span class="hljs-keyword">const</span> nodes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>();
    <span class="hljs-keyword">const</span> distances = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
    <span class="hljs-keyword">const</span> previous = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
    <span class="hljs-keyword">const</span> path = [];
    
    <span class="hljs-comment">// 初始化</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> vertex <span class="hljs-keyword">of</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">adjacencyList</span>.<span class="hljs-title function_">keys</span>()) {
      <span class="hljs-keyword">if</span> (vertex === start) {
        distances.<span class="hljs-title function_">set</span>(vertex, <span class="hljs-number">0</span>);
        nodes.<span class="hljs-title function_">enqueue</span>(vertex, <span class="hljs-number">0</span>);
      } <span class="hljs-keyword">else</span> {
        distances.<span class="hljs-title function_">set</span>(vertex, <span class="hljs-title class_">Infinity</span>);
        nodes.<span class="hljs-title function_">enqueue</span>(vertex, <span class="hljs-title class_">Infinity</span>);
      }
      previous.<span class="hljs-title function_">set</span>(vertex, <span class="hljs-literal">null</span>);
    }
    
    <span class="hljs-keyword">while</span> (!nodes.<span class="hljs-title function_">isEmpty</span>()) {
      <span class="hljs-keyword">const</span> smallest = nodes.<span class="hljs-title function_">dequeue</span>().<span class="hljs-property">value</span>;
      
      <span class="hljs-keyword">if</span> (smallest === end) {
        <span class="hljs-comment">// 构建路径</span>
        <span class="hljs-keyword">let</span> current = end;
        <span class="hljs-keyword">while</span> (current) {
          path.<span class="hljs-title function_">unshift</span>(current);
          current = previous.<span class="hljs-title function_">get</span>(current);
        }
        <span class="hljs-keyword">break</span>;
      }
      
      <span class="hljs-keyword">if</span> (smallest &amp;&amp; distances.<span class="hljs-title function_">get</span>(smallest) !== <span class="hljs-title class_">Infinity</span>) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> neighbor <span class="hljs-keyword">of</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">adjacencyList</span>.<span class="hljs-title function_">get</span>(smallest)) {
          <span class="hljs-keyword">const</span> candidate = distances.<span class="hljs-title function_">get</span>(smallest) + neighbor.<span class="hljs-property">weight</span>;
          
          <span class="hljs-keyword">if</span> (candidate &lt; distances.<span class="hljs-title function_">get</span>(neighbor.<span class="hljs-property">node</span>)) {
            distances.<span class="hljs-title function_">set</span>(neighbor.<span class="hljs-property">node</span>, candidate);
            previous.<span class="hljs-title function_">set</span>(neighbor.<span class="hljs-property">node</span>, smallest);
            nodes.<span class="hljs-title function_">enqueue</span>(neighbor.<span class="hljs-property">node</span>, candidate);
          }
        }
      }
    }
    
    <span class="hljs-keyword">return</span> path.<span class="hljs-property">length</span> &gt; <span class="hljs-number">1</span> ? path : [];
  }
}

<span class="hljs-comment">// 优先队列实现</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">PriorityQueue</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">values</span> = [];
  }
  
  <span class="hljs-title function_">enqueue</span>(<span class="hljs-params">value, priority</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">values</span>.<span class="hljs-title function_">push</span>({ value, priority });
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">sort</span>();
  }
  
  <span class="hljs-title function_">dequeue</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">values</span>.<span class="hljs-title function_">shift</span>();
  }
  
  <span class="hljs-title function_">sort</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">values</span>.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a.<span class="hljs-property">priority</span> - b.<span class="hljs-property">priority</span>);
  }
  
  <span class="hljs-title function_">isEmpty</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">values</span>.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>;
  }
}
</code></pre>
<h4 data-id="heading-17">七、散列表与哈希函数</h4>
<h5 data-id="heading-18">7.1 自定义散列表实现</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">HashTable</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">size = <span class="hljs-number">53</span></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(size);
  }
  
  <span class="hljs-comment">// 哈希函数</span>
  <span class="hljs-title function_">_hash</span>(<span class="hljs-params">key</span>) {
    <span class="hljs-keyword">let</span> total = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PRIME</span> = <span class="hljs-number">31</span>;
    
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(key.<span class="hljs-property">length</span>, <span class="hljs-number">100</span>); i++) {
      <span class="hljs-keyword">const</span> char = key[i];
      <span class="hljs-keyword">const</span> value = char.<span class="hljs-title function_">charCodeAt</span>(<span class="hljs-number">0</span>) - <span class="hljs-number">96</span>;
      total = (total * <span class="hljs-variable constant_">PRIME</span> + value) % <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>.<span class="hljs-property">length</span>;
    }
    
    <span class="hljs-keyword">return</span> total;
  }
  
  <span class="hljs-comment">// 二次哈希解决冲突</span>
  <span class="hljs-title function_">_hash2</span>(<span class="hljs-params">key</span>) {
    <span class="hljs-keyword">let</span> total = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PRIME</span> = <span class="hljs-number">37</span>;
    
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(key.<span class="hljs-property">length</span>, <span class="hljs-number">100</span>); i++) {
      <span class="hljs-keyword">const</span> char = key[i];
      <span class="hljs-keyword">const</span> value = char.<span class="hljs-title function_">charCodeAt</span>(<span class="hljs-number">0</span>) - <span class="hljs-number">96</span>;
      total = (total * <span class="hljs-variable constant_">PRIME</span> + value) % <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>.<span class="hljs-property">length</span>;
    }
    
    <span class="hljs-keyword">return</span> total || <span class="hljs-number">1</span>; <span class="hljs-comment">// 确保不为0</span>
  }
  
  <span class="hljs-comment">// 双重散列解决冲突</span>
  <span class="hljs-title function_">_doubleHash</span>(<span class="hljs-params">key, attempt</span>) {
    <span class="hljs-keyword">const</span> hash1 = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_hash</span>(key);
    <span class="hljs-keyword">const</span> hash2 = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_hash2</span>(key);
    <span class="hljs-keyword">return</span> (hash1 + attempt * hash2) % <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>.<span class="hljs-property">length</span>;
  }
  
  <span class="hljs-comment">// 设置键值对</span>
  <span class="hljs-title function_">set</span>(<span class="hljs-params">key, value</span>) {
    <span class="hljs-keyword">let</span> attempt = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> index = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_doubleHash</span>(key, attempt);
    
    <span class="hljs-comment">// 处理冲突</span>
    <span class="hljs-keyword">while</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[index] &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[index][<span class="hljs-number">0</span>] !== key) {
      attempt++;
      index = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_doubleHash</span>(key, attempt);
      
      <span class="hljs-keyword">if</span> (attempt &gt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>.<span class="hljs-property">length</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'哈希表已满'</span>);
      }
    }
    
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[index] = [key, value];
  }
  
  <span class="hljs-comment">// 获取值</span>
  <span class="hljs-title function_">get</span>(<span class="hljs-params">key</span>) {
    <span class="hljs-keyword">let</span> attempt = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> index = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_doubleHash</span>(key, attempt);
    
    <span class="hljs-keyword">while</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[index]) {
      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[index][<span class="hljs-number">0</span>] === key) {
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[index][<span class="hljs-number">1</span>];
      }
      attempt++;
      index = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_doubleHash</span>(key, attempt);
    }
    
    <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
  }
  
  <span class="hljs-comment">// 获取所有键</span>
  <span class="hljs-title function_">keys</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">const</span> keysArr = [];
    
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>.<span class="hljs-property">length</span>; i++) {
      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[i]) {
        keysArr.<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[i][<span class="hljs-number">0</span>]);
      }
    }
    
    <span class="hljs-keyword">return</span> keysArr;
  }
  
  <span class="hljs-comment">// 获取所有值</span>
  <span class="hljs-title function_">values</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">const</span> valuesArr = [];
    
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>.<span class="hljs-property">length</span>; i++) {
      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[i]) {
        <span class="hljs-comment">// 避免重复值</span>
        <span class="hljs-keyword">if</span> (!valuesArr.<span class="hljs-title function_">includes</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[i][<span class="hljs-number">1</span>])) {
          valuesArr.<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">keyMap</span>[i][<span class="hljs-number">1</span>]);
        }
      }
    }
    
    <span class="hljs-keyword">return</span> valuesArr;
  }
}
</code></pre>
<h4 data-id="heading-19">八、排序算法优化</h4>
<h5 data-id="heading-20">8.1 快速排序优化</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SortingAlgorithms</span> {
  <span class="hljs-comment">// 快速排序（原地排序）</span>
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">quickSort</span>(<span class="hljs-params">arr, left = <span class="hljs-number">0</span>, right = arr.length - <span class="hljs-number">1</span></span>) {
    <span class="hljs-keyword">if</span> (left &lt; right) {
      <span class="hljs-keyword">const</span> pivotIndex = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">partition</span>(arr, left, right);
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">quickSort</span>(arr, left, pivotIndex - <span class="hljs-number">1</span>);
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">quickSort</span>(arr, pivotIndex + <span class="hljs-number">1</span>, right);
    }
    <span class="hljs-keyword">return</span> arr;
  }
  
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">partition</span>(<span class="hljs-params">arr, left, right</span>) {
    <span class="hljs-keyword">const</span> pivot = arr[<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((left + right) / <span class="hljs-number">2</span>)];
    <span class="hljs-keyword">let</span> i = left;
    <span class="hljs-keyword">let</span> j = right;
    
    <span class="hljs-keyword">while</span> (i &lt;= j) {
      <span class="hljs-keyword">while</span> (arr[i] &lt; pivot) {
        i++;
      }
      <span class="hljs-keyword">while</span> (arr[j] &gt; pivot) {
        j--;
      }
      <span class="hljs-keyword">if</span> (i &lt;= j) {
        [arr[i], arr[j]] = [arr[j], arr[i]];
        i++;
        j--;
      }
    }
    
    <span class="hljs-keyword">return</span> i;
  }
  
  <span class="hljs-comment">// 归并排序</span>
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">mergeSort</span>(<span class="hljs-params">arr</span>) {
    <span class="hljs-keyword">if</span> (arr.<span class="hljs-property">length</span> &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> arr;
    
    <span class="hljs-keyword">const</span> mid = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(arr.<span class="hljs-property">length</span> / <span class="hljs-number">2</span>);
    <span class="hljs-keyword">const</span> left = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">mergeSort</span>(arr.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, mid));
    <span class="hljs-keyword">const</span> right = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">mergeSort</span>(arr.<span class="hljs-title function_">slice</span>(mid));
    
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">merge</span>(left, right);
  }
  
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">left, right</span>) {
    <span class="hljs-keyword">const</span> result = [];
    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>;
    
    <span class="hljs-keyword">while</span> (i &lt; left.<span class="hljs-property">length</span> &amp;&amp; j &lt; right.<span class="hljs-property">length</span>) {
      <span class="hljs-keyword">if</span> (left[i] &lt; right[j]) {
        result.<span class="hljs-title function_">push</span>(left[i]);
        i++;
      } <span class="hljs-keyword">else</span> {
        result.<span class="hljs-title function_">push</span>(right[j]);
        j++;
      }
    }
    
    <span class="hljs-keyword">return</span> result.<span class="hljs-title function_">concat</span>(left.<span class="hljs-title function_">slice</span>(i), right.<span class="hljs-title function_">slice</span>(j));
  }
  
  <span class="hljs-comment">// 堆排序</span>
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">heapSort</span>(<span class="hljs-params">arr</span>) {
    <span class="hljs-keyword">const</span> n = arr.<span class="hljs-property">length</span>;
    
    <span class="hljs-comment">// 构建最大堆</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(n / <span class="hljs-number">2</span>) - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">heapify</span>(arr, n, i);
    }
    
    <span class="hljs-comment">// 一个个提取元素</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) {
      [arr[<span class="hljs-number">0</span>], arr[i]] = [arr[i], arr[<span class="hljs-number">0</span>]];
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">heapify</span>(arr, i, <span class="hljs-number">0</span>);
    }
    
    <span class="hljs-keyword">return</span> arr;
  }
  
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">heapify</span>(<span class="hljs-params">arr, n, i</span>) {
    <span class="hljs-keyword">let</span> largest = i;
    <span class="hljs-keyword">const</span> left = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>;
    <span class="hljs-keyword">const</span> right = <span class="hljs-number">2</span> * i + <span class="hljs-number">2</span>;
    
    <span class="hljs-keyword">if</span> (left &lt; n &amp;&amp; arr[left] &gt; arr[largest]) {
      largest = left;
    }
    
    <span class="hljs-keyword">if</span> (right &lt; n &amp;&amp; arr[right] &gt; arr[largest]) {
      largest = right;
    }
    
    <span class="hljs-keyword">if</span> (largest !== i) {
      [arr[i], arr[largest]] = [arr[largest], arr[i]];
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">heapify</span>(arr, n, largest);
    }
  }
  
  <span class="hljs-comment">// 性能比较</span>
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">performanceTest</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">const</span> sizes = [<span class="hljs-number">1000</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">100000</span>];
    
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> size <span class="hljs-keyword">of</span> sizes) {
      <span class="hljs-keyword">const</span> arr = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>({ <span class="hljs-attr">length</span>: size }, <span class="hljs-function">() =&gt;</span> 
        <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * size)
      );
      
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`\n测试数组大小: <span class="hljs-subst">${size}</span>`</span>);
      
      <span class="hljs-comment">// 快速排序</span>
      <span class="hljs-keyword">const</span> arr1 = [...arr];
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">'快速排序'</span>);
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">quickSort</span>(arr1);
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">'快速排序'</span>);
      
      <span class="hljs-comment">// 归并排序</span>
      <span class="hljs-keyword">const</span> arr2 = [...arr];
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">'归并排序'</span>);
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">mergeSort</span>(arr2);
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">'归并排序'</span>);
      
      <span class="hljs-comment">// 堆排序</span>
      <span class="hljs-keyword">const</span> arr3 = [...arr];
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">'堆排序'</span>);
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">heapSort</span>(arr3);
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">'堆排序'</span>);
      
      <span class="hljs-comment">// 内置排序</span>
      <span class="hljs-keyword">const</span> arr4 = [...arr];
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">'内置排序'</span>);
      arr4.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">'内置排序'</span>);
    }
  }
}
</code></pre>
<h4 data-id="heading-21">九、搜索算法优化</h4>
<h5 data-id="heading-22">9.1 二分查找及其变体</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SearchAlgorithms</span> {
  <span class="hljs-comment">// 标准二分查找</span>
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">binarySearch</span>(<span class="hljs-params">arr, target</span>) {
    <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> right = arr.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;
    
    <span class="hljs-keyword">while</span> (left &lt;= right) {
      <span class="hljs-keyword">const</span> mid = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((left + right) / <span class="hljs-number">2</span>);
      
      <span class="hljs-keyword">if</span> (arr[mid] === target) {
        <span class="hljs-keyword">return</span> mid;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[mid] &lt; target) {
        left = mid + <span class="hljs-number">1</span>;
      } <span class="hljs-keyword">else</span> {
        right = mid - <span class="hljs-number">1</span>;
      }
    }
    
    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
  }
  
  <span class="hljs-comment">// 查找第一个等于目标值的位置</span>
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">binarySearchFirst</span>(<span class="hljs-params">arr, target</span>) {
    <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> right = arr.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;
    <span class="hljs-keyword">let</span> result = -<span class="hljs-number">1</span>;
    
    <span class="hljs-keyword">while</span> (left &lt;= right) {
      <span class="hljs-keyword">const</span> mid = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((left + right) / <span class="hljs-number">2</span>);
      
      <span class="hljs-keyword">if</span> (arr[mid] &gt;= target) {
        <span class="hljs-keyword">if</span> (arr[mid] === target) {
          result = mid;
        }
        right = mid - <span class="hljs-number">1</span>;
      } <span class="hljs-keyword">else</span> {
        left = mid + <span class="hljs-number">1</span>;
      }
    }
    
    <span class="hljs-keyword">return</span> result;
  }
  
  <span class="hljs-comment">// 查找最后一个等于目标值的位置</span>
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">binarySearchLast</span>(<span class="hljs-params">arr, target</span>) {
    <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> right = arr.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;
    <span class="hljs-keyword">let</span> result = -<span class="hljs-number">1</span>;
    
    <span class="hljs-keyword">while</span> (left &lt;= right) {
      <span class="hljs-keyword">const</span> mid = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((left + right) / <span class="hljs-number">2</span>);
      
      <span class="hljs-keyword">if</span> (arr[mid] &lt;= target) {
        <span class="hljs-keyword">if</span> (arr[mid] === target) {
          result = mid;
        }
        left = mid + <span class="hljs-number">1</span>;
      } <span class="hljs-keyword">else</span> {
        right = mid - <span class="hljs-number">1</span>;
      }
    }
    
    <span class="hljs-keyword">return</span> result;
  }
  
  <span class="hljs-comment">// 查找第一个大于等于目标值的位置</span>
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">binarySearchCeil</span>(<span class="hljs-params">arr, target</span>) {
    <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> right = arr.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;
    <span class="hljs-keyword">let</span> result = -<span class="hljs-number">1</span>;
    
    <span class="hljs-keyword">while</span> (left &lt;= right) {
      <span class="hljs-keyword">const</span> mid = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((left + right) / <span class="hljs-number">2</span>);
      
      <span class="hljs-keyword">if</span> (arr[mid] &gt;= target) {
        result = mid;
        right = mid - <span class="hljs-number">1</span>;
      } <span class="hljs-keyword">else</span> {
        left = mid + <span class="hljs-number">1</span>;
      }
    }
    
    <span class="hljs-keyword">return</span> result;
  }
  
  <span class="hljs-comment">// 插值查找（适用于均匀分布的有序数组）</span>
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">interpolationSearch</span>(<span class="hljs-params">arr, target</span>) {
    <span class="hljs-keyword">let</span> low = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> high = arr.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;
    
    <span class="hljs-keyword">while</span> (low &lt;= high &amp;&amp; target &gt;= arr[low] &amp;&amp; target &lt;= arr[high]) {
      <span class="hljs-keyword">if</span> (low === high) {
        <span class="hljs-keyword">return</span> arr[low] === target ? low : -<span class="hljs-number">1</span>;
      }
      
      <span class="hljs-comment">// 计算插值位置</span>
      <span class="hljs-keyword">const</span> pos = low + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(
        ((target - arr[low]) * (high - low)) / (arr[high] - arr[low])
      );
      
      <span class="hljs-keyword">if</span> (arr[pos] === target) {
        <span class="hljs-keyword">return</span> pos;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[pos] &lt; target) {
        low = pos + <span class="hljs-number">1</span>;
      } <span class="hljs-keyword">else</span> {
        high = pos - <span class="hljs-number">1</span>;
      }
    }
    
    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
  }
}
</code></pre>
<h4 data-id="heading-23">十、实际应用场景</h4>
<h5 data-id="heading-24">10.1 虚拟DOM diff算法中的优化</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">VNode</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">tag, props, children</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">tag</span> = tag;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span> = props || {};
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">children</span> = children || [];
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">key</span> = props &amp;&amp; props.<span class="hljs-property">key</span>;
  }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">VirtualDOM</span> {
  <span class="hljs-comment">// 简化的diff算法</span>
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">diff</span>(<span class="hljs-params">oldVNode, newVNode</span>) {
    <span class="hljs-comment">// 如果标签不同，直接替换</span>
    <span class="hljs-keyword">if</span> (oldVNode.<span class="hljs-property">tag</span> !== newVNode.<span class="hljs-property">tag</span>) {
      <span class="hljs-keyword">return</span> { <span class="hljs-attr">type</span>: <span class="hljs-string">'REPLACE'</span>, <span class="hljs-attr">node</span>: newVNode };
    }
    
    <span class="hljs-comment">// 如果都有key且不同，移动节点</span>
    <span class="hljs-keyword">if</span> (oldVNode.<span class="hljs-property">key</span> !== newVNode.<span class="hljs-property">key</span>) {
      <span class="hljs-keyword">return</span> { <span class="hljs-attr">type</span>: <span class="hljs-string">'REORDER'</span>, <span class="hljs-attr">moves</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">calculateMoves</span>(oldVNode, newVNode) };
    }
    
    <span class="hljs-comment">// 比较属性</span>
    <span class="hljs-keyword">const</span> propsPatches = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">diffProps</span>(oldVNode.<span class="hljs-property">props</span>, newVNode.<span class="hljs-property">props</span>);
    
    <span class="hljs-comment">// 比较子节点</span>
    <span class="hljs-keyword">const</span> childrenPatches = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">diffChildren</span>(oldVNode.<span class="hljs-property">children</span>, newVNode.<span class="hljs-property">children</span>);
    
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">type</span>: <span class="hljs-string">'UPDATE'</span>,
      <span class="hljs-attr">props</span>: propsPatches,
      <span class="hljs-attr">children</span>: childrenPatches
    };
  }
  
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">diffProps</span>(<span class="hljs-params">oldProps, newProps</span>) {
    <span class="hljs-keyword">const</span> patches = {};
    <span class="hljs-keyword">const</span> allKeys = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([
      ...<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(oldProps),
      ...<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(newProps)
    ]);
    
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">of</span> allKeys) {
      <span class="hljs-keyword">if</span> (oldProps[key] !== newProps[key]) {
        patches[key] = newProps[key];
      }
    }
    
    <span class="hljs-keyword">return</span> patches;
  }
  
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">diffChildren</span>(<span class="hljs-params">oldChildren, newChildren</span>) {
    <span class="hljs-keyword">const</span> patches = [];
    <span class="hljs-keyword">const</span> len = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(oldChildren.<span class="hljs-property">length</span>, newChildren.<span class="hljs-property">length</span>);
    
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) {
      <span class="hljs-keyword">const</span> oldChild = oldChildren[i];
      <span class="hljs-keyword">const</span> newChild = newChildren[i];
      
      <span class="hljs-keyword">if</span> (!oldChild &amp;&amp; newChild) {
        patches.<span class="hljs-title function_">push</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">'INSERT'</span>, <span class="hljs-attr">node</span>: newChild });
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldChild &amp;&amp; !newChild) {
        patches.<span class="hljs-title function_">push</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">'REMOVE'</span> });
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldChild &amp;&amp; newChild) {
        patches.<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">diff</span>(oldChild, newChild));
      }
    }
    
    <span class="hljs-keyword">return</span> patches;
  }
  
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">calculateMoves</span>(<span class="hljs-params">oldNode, newNode</span>) {
    <span class="hljs-comment">// 简化的移动计算，实际实现更复杂</span>
    <span class="hljs-keyword">return</span> [];
  }
}
</code></pre>
<h5 data-id="heading-25">10.2 状态管理中的优化</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">OptimizedStore</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">reducer, initialState</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = initialState;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reducer</span> = reducer;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">listeners</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">isDispatching</span> = <span class="hljs-literal">false</span>;
  }
  
  <span class="hljs-title function_">getState</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">isDispatching</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'不能在reducer执行中获取状态'</span>);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>;
  }
  
  <span class="hljs-title function_">dispatch</span>(<span class="hljs-params">action</span>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">isDispatching</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'不能在reducer执行中dispatch'</span>);
    }
    
    <span class="hljs-keyword">try</span> {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">isDispatching</span> = <span class="hljs-literal">true</span>;
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">reducer</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>, action);
    } <span class="hljs-keyword">finally</span> {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">isDispatching</span> = <span class="hljs-literal">false</span>;
    }
    
    <span class="hljs-comment">// 通知所有监听器</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">listeners</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">listener</span> =&gt;</span> <span class="hljs-title function_">listener</span>());
  }
  
  <span class="hljs-title function_">subscribe</span>(<span class="hljs-params">listener</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">listeners</span>.<span class="hljs-title function_">add</span>(listener);
    
    <span class="hljs-comment">// 返回取消订阅的函数</span>
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">listeners</span>.<span class="hljs-title function_">delete</span>(listener);
    };
  }
  
  <span class="hljs-comment">// 选择器优化：记忆化</span>
  <span class="hljs-title function_">createSelector</span>(<span class="hljs-params">...funcs</span>) {
    <span class="hljs-keyword">const</span> resultFunc = funcs.<span class="hljs-title function_">pop</span>();
    <span class="hljs-keyword">const</span> dependencies = funcs;
    <span class="hljs-keyword">let</span> lastArgs = [];
    <span class="hljs-keyword">let</span> lastResult;
    
    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> {
      <span class="hljs-keyword">if</span> (lastArgs.<span class="hljs-property">length</span> === args.<span class="hljs-property">length</span> &amp;&amp; 
          lastArgs.<span class="hljs-title function_">every</span>(<span class="hljs-function">(<span class="hljs-params">arg, i</span>) =&gt;</span> arg === args[i])) {
        <span class="hljs-keyword">return</span> lastResult;
      }
      
      <span class="hljs-keyword">const</span> dependenciesResults = dependencies.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> <span class="hljs-title function_">fn</span>(...args));
      lastResult = <span class="hljs-title function_">resultFunc</span>(...dependenciesResults);
      lastArgs = args;
      
      <span class="hljs-keyword">return</span> lastResult;
    };
  }
}
</code></pre>
<h4 data-id="heading-26">总结</h4>
<p>JavaScript性能优化离不开对数据结构和算法的深入理解。本文涵盖了从基础数据结构到高级算法优化的完整体系，包括：</p>
<ol>
<li><strong>数据结构选择策略:</strong> 根据不同场景选择最合适的数据结构</li>
<li><strong>链表及其变体:</strong> 单向链表、双向链表的实现与应用</li>
<li><strong>栈和队列:</strong> 基础实现及其在算法中的应用</li>
<li><strong>树结构:</strong> 二叉树、平衡树的实现与遍历优化</li>
<li><strong>缓存机制:</strong> LRU缓存的实现原理</li>
<li><strong>图算法:</strong> 遍历、最短路径等核心算法</li>
<li><strong>散列表:</strong> 哈希函数设计与冲突解决</li>
<li><strong>排序搜索:</strong> 各类算法的性能比较与优化</li>
<li><strong>实际应用:</strong> 在前端框架和状态管理中的实践</li>
</ol>
<p>在实际开发中，需要根据具体场景选择合适的数据结构和算法。对于大多数前端应用，合理使用Map、Set等内置数据结构，结合适当的算法优化，就能显著提升性能。对于复杂场景，则需要深入理解各种数据结构的特性，做出最优选择。</p>
<p>记住，没有绝对最优的数据结构，只有在特定场景下的最适合选择。持续学习和实践，才能在性能优化这条道路上越走越远。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[数据点的“社交距离”：衡量它们之间的相似与差异]]></title>    <link>https://juejin.cn/post/7583403164578431018</link>    <guid>https://juejin.cn/post/7583403164578431018</guid>    <pubDate>2025-12-15T01:37:53.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7583403164578431018" data-draft-id="7583284454165643283" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="数据点的“社交距离”：衡量它们之间的相似与差异"/> <meta itemprop="keywords" content="Python,数据分析,数据挖掘"/> <meta itemprop="datePublished" content="2025-12-15T01:37:53.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="databook"/> <meta itemprop="url" content="https://juejin.cn/user/3526889035006702"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            数据点的“社交距离”：衡量它们之间的相似与差异
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3526889035006702/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    databook
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-15T01:37:53.000Z" title="Mon Dec 15 2025 01:37:53 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-15
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读11分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{color:#595959;font-size:15px;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(60,10,30,.04) 3%,transparent 0),linear-gradient(1turn,rgba(60,10,30,.04) 3%,transparent 0);background-size:20px 20px;background-position:50%}.markdown-body p{color:#595959;font-size:15px;line-height:2;font-weight:400}.markdown-body p+p{margin-top:16px}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{padding:30px 0;margin:0;color:#135ce0}.markdown-body h1{position:relative;text-align:center;font-size:22px;margin:50px 0}.markdown-body h1:before{position:absolute;content:"";top:-10px;left:50%;width:32px;height:32px;transform:translateX(-50%);background-size:100% 100%;opacity:.36;background-repeat:no-repeat;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABfVBMVEX///8Ad/8AgP8AgP8AgP8Aff8AgP8Af/8AgP8AVf8Af/8Af/8AgP8AgP8Af/8Afv8AAP8Afv8Afv8Aef8AgP8AdP8Afv8AgP8AgP8Acf8Ae/8AgP8Af/8AgP8Af/8Af/8AfP8Afv8AgP8Af/8Af/8Afv8Afv8AgP8Afv8AgP8Af/8Af/8AgP8AgP8Afv8AgP8Af/8AgP8AgP8AgP8Ae/8Afv8Af/8AgP8Af/8AgP8Af/8Af/8Aff8Af/8Abf8AgP8Af/8AgP8Af/8Af/8Afv8AgP8AgP8Afv8Afv8AgP8Af/8Aff8AgP8Afv8AgP8Aff8AgP8AfP8AgP8Ae/8AgP8Af/8AgP8AgP8AgP8Afv8AgP8AgP8AgP8Afv8AgP8AgP8AgP8AgP8AgP8Af/8AgP8Af/8Af/8Aev8Af/8AgP8Aff8Afv8AgP8AgP8AgP8Af/8AgP8Af/8Af/8AgP8Afv8AgP8AgP8AgP8AgP8Af/8AeP8Af/8Af/8Af//////rzEHnAAAAfXRSTlMAD7CCAivatxIDx5EMrP19AXdLEwgLR+6iCR/M0yLRzyFF7JupSXn8cw6v60Q0QeqzKtgeG237HMne850/6Qeq7QaZ+WdydHtj+OM3qENCMRYl1B3K2U7wnlWE/mhlirjkODa9FN/BF7/iNV/2kASNZpX1Wlf03C4stRGxgUPclqoAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEaBzgZ4yeM3AAAAT9JREFUOMvNUldbwkAQvCAqsSBoABE7asSOBRUVVBQNNuy9996789+9cMFAMHnVebmdm+/bmdtbQv4dOFOW2UjPzgFyLfo6nweKfIMOBYWwFtmMPGz2Yj2pJI0JDq3udJW6VVbmKa9I192VQFV1ktXUAl5NB0cd4KpnORqsEO2ZIRpF9gJfE9Dckqq0KuZt7UAH5+8EPF3spjsRpCeQNO/tA/qDwIDA+OCQbBoKA8NOdjMySgcZGVM6jwcgRuUiSs0nlPFNSrEpJfU0jTLD6llqbvKxei7OzvkFNQohi0vAsj81+MoqsCaoPOQFgus/1LyxichW+hS2JWCHZ7VlF9jb187pIAYcHiViHAMnp5mTjJ8B5xeEXF4B1ze/fTh/C0h398DDI9HB07O8ci+vRBdvdGnfP4gBuM8vw7X/G3wDmFhFZEdxzjMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDEtMjZUMDc6NTY6MjUrMDE6MDA67pVWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAxLTI2VDA3OjU2OjI1KzAxOjAwS7Mt6gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAWdEVYdFRpdGxlAGp1ZWppbl9sb2dvIGNvcHlxapmKAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC)}.markdown-body h2{position:relative;font-size:20px;border-left:4px solid;padding:0 0 0 10px;margin:30px 0}.markdown-body h3{font-size:16px}.markdown-body ul{list-style:disc outside;margin-left:2em;margin-top:1em}.markdown-body li{line-height:2;color:#595959}.markdown-body img.loaded{margin:0 auto;display:block}.markdown-body blockquote{background:#fff9f9;margin:2em 0;padding:2px 20px;border-left:4px solid #b2aec5}.markdown-body blockquote p{color:#666;line-height:2}.markdown-body a{color:#036aca;border-bottom:1px solid rgba(3,106,202,.8);font-weight:400;text-decoration:none}.markdown-body em strong,.markdown-body strong{color:#036aca}.markdown-body hr{border-top:1px solid #135ce0}.markdown-body pre{overflow:auto}.markdown-body code,.markdown-body pre{overflow:auto;position:relative;line-height:1.75;font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body table{border-collapse:collapse;margin:1rem 0;overflow-x:auto}.markdown-body table td,.markdown-body table th{border:1px solid #dfe2e5;padding:.6em 1em}.markdown-body table tr{border-top:1px solid #dfe2e5}.markdown-body table tr:nth-child(2n){background-color:#f6f8fa}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在数据分析的世界里， <strong>“距离”</strong> 不仅仅是地图上两点之间的路程。</p>
<p><strong>距离</strong> ，本质上是衡量两个事物 <strong>“相似度”</strong> 的尺子。</p>
<ul>
<li>距离越近 = 相似度越高</li>
<li>距离越远 = 差异越大</li>
</ul>
<p>如果你想做<strong>用户画像聚类</strong>、想做<strong>商品推荐系统</strong>，或者想识别<strong>信用卡欺诈交易</strong>，你首先要选对这把**“尺子”**。</p>
<p>本文将带你全面了解数据分析中常用的各种距离度量，从最直观的欧氏距离到复杂的时间序列距离。</p>
<p>为了方便理解，我将它们分为了五大门派。</p>
<h2 data-id="heading-0">1. 第一门派：几何空间的测量者</h2>
<p>这一类距离最符合我们的直觉，通常用于处理数值型数据（比如身高、体重、经纬度）。</p>
<h3 data-id="heading-1">1.1. 欧氏距离：最直观的“直线距离”</h3>
<p><strong>欧氏距离</strong>就是我们常说的 <strong>“直线距离”</strong>。</p>
<p>在二维平面上，两点间的欧氏距离就是连接它们的直线长度。</p>
<p><strong>应用场景：</strong></p>
<ul>
<li><strong>外卖配送：</strong> 假设你是无人机送外卖，不受道路限制，直接飞过去，这就是欧氏距离。</li>
<li><strong>K-Means 聚类：</strong> 最常用的距离度量。</li>
</ul>
<hr/>
<p>代码示例：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-comment"># 后面的代码示例多次用到 distance，不再重复引用了</span>
<span class="hljs-keyword">from</span> scipy.spatial <span class="hljs-keyword">import</span> distance

<span class="hljs-comment"># 两个用户的特征：[活跃时长(小时), 消费金额(元)]</span>
user_A = [<span class="hljs-number">2.5</span>, <span class="hljs-number">300</span>]
user_B = [<span class="hljs-number">3.0</span>, <span class="hljs-number">350</span>]

d_euclidean = distance.euclidean(user_A, user_B)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"欧氏距离: <span class="hljs-subst">{d_euclidean:<span class="hljs-number">.2</span>f}</span>"</span>)

<span class="hljs-comment"># 运行结果：</span>
<span class="hljs-string">'''
欧氏距离: 50.00
'''</span>
</code></pre>
<p>图形化效果如下：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a1e0dca9dfc0439e82ca48beebf418b9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgZGF0YWJvb2s=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766367473&amp;x-signature=1tT5s%2BA7uZw65lJnPVelYh48Fp4%3D" alt="" loading="lazy"/></p>
<p><strong>注意</strong>：欧氏距离对数据的<strong>尺度敏感</strong>！如果特征的单位不同（如年龄和收入），直接计算会导致收入特征主导距离计算。</p>
<h3 data-id="heading-2">1.2. 曼哈顿距离：城市街区的走法</h3>
<p>想象在纽约曼哈顿的街道上行走，你不能斜穿大楼，只能沿着街道走。<strong>曼哈顿距离</strong>就是这种 <strong>“城市街区距离”</strong>。</p>
<p><strong>应用场景：</strong></p>
<ul>
<li><strong>城市物流：</strong> 真实的快递员配送路径估算。</li>
<li><strong>高维数据：</strong> 在某些高维数据中，曼哈顿距离比欧氏距离更能抗干扰（Robust）。</li>
</ul>
<p>代码示例：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 外卖配送示例：从餐厅到顾客的路径</span>
restaurant = np.array([<span class="hljs-number">3</span>, <span class="hljs-number">7</span>])  <span class="hljs-comment"># 坐标(3,7)</span>
customer = np.array([<span class="hljs-number">8</span>, <span class="hljs-number">2</span>])  <span class="hljs-comment"># 坐标(8,2)</span>

euclidean = distance.euclidean(restaurant, customer)
manhattan = distance.cityblock(restaurant, customer)

<span class="hljs-built_in">print</span>(<span class="hljs-string">f"餐厅到顾客的直线距离（欧氏）: <span class="hljs-subst">{euclidean:<span class="hljs-number">.2</span>f}</span>"</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"餐厅到顾客的街区距离（曼哈顿）: <span class="hljs-subst">{manhattan:<span class="hljs-number">.2</span>f}</span>"</span>)

<span class="hljs-comment"># 运行结果：</span>
<span class="hljs-string">'''
餐厅到顾客的直线距离（欧氏）: 7.07
餐厅到顾客的街区距离（曼哈顿）: 10.00
'''</span>
</code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6e80494d57e14f8896c677cdf0ebd357~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgZGF0YWJvb2s=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766367473&amp;x-signature=gilGF96oIG88ploqGGXcdOukPkw%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-3">1.3. 切比雪夫距离：棋盘上的王者</h3>
<p>也就是国际象棋中“国王”移动的步数。国王可以横着走、竖着走，也能斜着走，且步数都算 1。</p>
<p>它只在乎数值差最大的那个维度。</p>
<p><strong>应用场景：</strong></p>
<ul>
<li><strong>仓储物流：</strong> 龙门吊抓取货物，横向移动和纵向移动可以同时进行，时间取决于最远的那个方向。</li>
</ul>
<p>代码示例：</p>
<pre><code class="hljs language-python" lang="python">d_chebyshev = distance.chebyshev(user_A, user_B)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"切比雪夫距离: <span class="hljs-subst">{d_chebyshev:<span class="hljs-number">.2</span>f}</span>"</span>)
</code></pre>
<h3 data-id="heading-4">1.4. 闵可夫斯基距离：距离的通用公式</h3>
<p>它是上面三种距离的“爸爸”。通过一个参数 <code>p</code> 来控制：</p>
<ul>
<li>当 p=1 时，就是<strong>曼哈顿距离</strong>。</li>
<li>当 p=2 时，就是<strong>欧氏距离</strong>。</li>
<li>当 p=∞ 时，就是<strong>切比雪夫距离</strong>。</li>
</ul>
<p><strong>应用场景：</strong> 当你不确定用哪种几何距离时，可以调节 p 值来寻找最优解。</p>
<p>代码示例：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 对比不同p值的效果</span>
point1 = np.array([<span class="hljs-number">0</span>, <span class="hljs-number">0</span>])
point2 = np.array([<span class="hljs-number">3</span>, <span class="hljs-number">4</span>])

p_values = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>]
distances = []

<span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> p_values:
    dist = distance.minkowski(point1, point2, p)
    distances.append(dist)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"p=<span class="hljs-subst">{p}</span>: 距离=<span class="hljs-subst">{dist:<span class="hljs-number">.2</span>f}</span>"</span>)

<span class="hljs-comment"># 运行结果：</span>
<span class="hljs-string">'''
p=1: 距离=7.00
p=2: 距离=5.00
p=3: 距离=4.50
p=5: 距离=4.17
p=10: 距离=4.02
'''</span>
</code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/095df22d5b554f24bc7ef03c71783af1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgZGF0YWJvb2s=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766367473&amp;x-signature=WUjXEAcZvDYAiRmDoR9ebJ7MJjQ%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-5">2. 第二门派：方向与相关性的探索者</h2>
<p>这一类距离不关心 <strong>“数值大小”</strong>，更关心 <strong>“趋势方向”</strong> 或 <strong>“统计关系”</strong>。</p>
<h3 data-id="heading-6">2.1. 余弦距离：关注方向而非大小</h3>
<p><strong>余弦距离</strong>衡量的是两个向量方向的差异，而不是它们的大小差异。</p>
<p>这在<strong>文本分析</strong>中特别有用，因为文档的长度不同，但主题可能相似。</p>
<p><strong>应用场景：</strong></p>
<ul>
<li><strong>文本相似度（热点）：</strong> 比如比较两篇文章。文章 A 只有 100 字，文章 B 有 10000 字，虽然词频数值差很大，但如果它们都在讲“人工智能”，它们的方向（角度）是一致的。</li>
<li><strong>推荐系统：</strong> 用户打分偏好。</li>
</ul>
<p>代码示例：（用几个简单的新闻标题来计算余弦相似度）</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 文本向量（假设是词频）：[AI, 苹果, 股票]</span>
doc_1 = [<span class="hljs-number">10</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>]  <span class="hljs-comment"># 科技财经文</span>
doc_2 = [<span class="hljs-number">20</span>, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>] <span class="hljs-comment"># 长篇科技财经文（方向一致）</span>
doc_3 = [<span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">0</span>]  <span class="hljs-comment"># 水果文</span>

<span class="hljs-comment"># 余弦距离 = 1 - 余弦相似度</span>
<span class="hljs-comment"># 接近0，表示非常相似</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"同类文章余弦距离: <span class="hljs-subst">{distance.cosine(doc_1, doc_2):<span class="hljs-number">.2</span>f}</span>"</span>)

<span class="hljs-comment"># 接近1，表示无关</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"不同类文章余弦距离: <span class="hljs-subst">{distance.cosine(doc_1, doc_3):<span class="hljs-number">.2</span>f}</span>"</span>)

<span class="hljs-comment"># 运行结果：</span>
<span class="hljs-string">'''
同类文章余弦距离: 0.00
不同类文章余弦距离: 1.00
'''</span>
</code></pre>
<h3 data-id="heading-7">2.2. 相关系数距离：衡量线性关系</h3>
<p>基于<strong>皮尔逊相关系数</strong>的距离，衡量两个变量之间线性相关性的差异。</p>
<p><strong>应用场景：</strong></p>
<ul>
<li><strong>股票分析：</strong> 衡量两只股票的走势是否同步。如果一支涨另一支也涨，它们的相关距离就很小，哪怕一个股价是 10 元，另一个是 1000 元。</li>
</ul>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 两只股票过去5天的涨跌幅</span>
stock_A = [<span class="hljs-number">0.1</span>, -<span class="hljs-number">0.2</span>, <span class="hljs-number">0.3</span>, <span class="hljs-number">0.1</span>, <span class="hljs-number">0.0</span>]
stock_B = [<span class="hljs-number">0.2</span>, -<span class="hljs-number">0.4</span>, <span class="hljs-number">0.6</span>, <span class="hljs-number">0.2</span>, <span class="hljs-number">0.0</span>] <span class="hljs-comment"># 走势完全也就是2倍关系</span>

d_correlation = distance.correlation(stock_A, stock_B)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"相关系数距离: <span class="hljs-subst">{d_correlation:<span class="hljs-number">.2</span>f}</span>"</span>)

<span class="hljs-comment"># 运行结果</span>
<span class="hljs-string">'''
相关系数距离: 0.00
'''</span>
</code></pre>
<p>可以尝试调整调整<code>stock_A</code>和<code>stock_B</code>的数值，再看看相关系数的变化。</p>
<h3 data-id="heading-8">2.3. 马氏距离：考虑数据分布的距离</h3>
<p><strong>马氏距离</strong>考虑了数据的协方差结构，是一种尺度无关且排除了特征相关性的距离度量。</p>
<p><strong>应用场景：</strong></p>
<ul>
<li><strong>异常检测：</strong> 假设你统计人的身高和体重。如果你用欧氏距离，一个 190cm、50kg 的人可能离中心点不远。但考虑到身高体重的正相关性（高的人通常重），这个数据点在马氏距离下就会非常远（非常异常）。</li>
</ul>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 需要先计算协方差矩阵的逆</span>
np.random.seed(<span class="hljs-number">42</span>)
height = np.random.normal(<span class="hljs-number">170</span>, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>)  <span class="hljs-comment"># 20个身高样本</span>
weight = height * <span class="hljs-number">0.5</span> + np.random.normal(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">20</span>)  <span class="hljs-comment"># 体重与身高相关</span>
data = np.column_stack([height, weight])

cov_matrix = np.cov(data.T)
inv_cov_matrix = np.linalg.inv(cov_matrix)

point_1 = [<span class="hljs-number">170</span>, <span class="hljs-number">60</span>] <span class="hljs-comment"># 正常点</span>
point_2 = [<span class="hljs-number">190</span>, <span class="hljs-number">50</span>] <span class="hljs-comment"># 异常点（又高又瘦）</span>

d_mah_1 = distance.mahalanobis(point_1, np.mean(data, axis=<span class="hljs-number">0</span>), inv_cov_matrix)
d_mah_2 = distance.mahalanobis(point_2, np.mean(data, axis=<span class="hljs-number">0</span>), inv_cov_matrix)

<span class="hljs-built_in">print</span>(<span class="hljs-string">f"正常点马氏距离: <span class="hljs-subst">{d_mah_1:<span class="hljs-number">.2</span>f}</span>"</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"异常点马氏距离: <span class="hljs-subst">{d_mah_2:<span class="hljs-number">.2</span>f}</span>"</span>) <span class="hljs-comment"># 距离会很大</span>

<span class="hljs-comment"># 运行结果：</span>
<span class="hljs-string">'''
正常点马氏距离: 4.93
异常点马氏距离: 9.06
'''</span>
</code></pre>
<h2 data-id="heading-9">3. 第三门派：集合与分类的裁判</h2>
<p>当数据不是数字，而是分类、标签或字符串时，我们用这些。</p>
<h3 data-id="heading-10">3.1. 杰卡德距离：集合的相似度</h3>
<p>杰卡德距离衡量两个集合的差异程度，通过计算交集与并集的比例得到。</p>
<p><strong>应用场景：</strong></p>
<ul>
<li><strong>电商推荐：</strong> 用户 A 买了 {苹果, 香蕉}，用户 B 买了 {苹果, 香蕉, 西瓜}。通过杰卡德距离计算他们的购买重合度，进而推荐商品。</li>
</ul>
<pre><code class="hljs language-python" lang="python">d_jaccard = distance.jaccard([<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]) <span class="hljs-comment"># boolean vector</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"杰卡德距离: <span class="hljs-subst">{d_jaccard:<span class="hljs-number">.2</span>f}</span>"</span>)

<span class="hljs-comment"># 运行结果：</span>
<span class="hljs-string">'''
杰卡德距离: 0.33
'''</span>
</code></pre>
<h3 data-id="heading-11">3.2. 汉明距离：字符串的差异度量</h3>
<p><strong>汉明距离</strong>衡量两个等长字符串在对应位置上不同字符的数量。</p>
<p><strong>应用场景：</strong></p>
<ul>
<li><strong>拼写纠错：</strong> "banana" 和 "banane"，只有一个字母不同，汉明距离为 1。</li>
<li><strong>信息编码：</strong> 通信中检测数据传输是否出错。</li>
</ul>
<pre><code class="hljs language-python" lang="python">d_hamming = distance.hamming([<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>])
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"汉明距离: <span class="hljs-subst">{d_hamming:<span class="hljs-number">.2</span>f}</span>"</span>) <span class="hljs-comment"># 输出比例，有些库输出个数</span>

<span class="hljs-comment"># 运行结果：</span>
<span class="hljs-string">'''
汉明距离: 0.33
'''</span>
</code></pre>
<h3 data-id="heading-12">3.3. 编辑距离：字符串转换的代价</h3>
<p><strong>编辑距离</strong>（<code>Levenshtein</code>距离）衡量将一个字符串转换为另一个字符串所需的最少单字符编辑操作次数（插入、删除、替换）。</p>
<p><strong>应用场景：</strong></p>
<ul>
<li><strong>搜索引擎：</strong> 你输错单词时，百度/谷歌提示“您是不是要找...”，就是通过编辑距离找到最接近的正确词。</li>
</ul>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 注：标准库无此函数，通常用 pip install Levenshtein 或自定义</span>
<span class="hljs-comment"># 这里用简单的逻辑演示概念</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">simple_levenshtein</span>(<span class="hljs-params">s1, s2</span>):
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s1) &lt; <span class="hljs-built_in">len</span>(s2):
        <span class="hljs-keyword">return</span> simple_levenshtein(s2, s1)
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s2) == <span class="hljs-number">0</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(s1)
    previous_row = <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s2) + <span class="hljs-number">1</span>)
    <span class="hljs-keyword">for</span> i, c1 <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(s1):
        current_row = [i + <span class="hljs-number">1</span>]
        <span class="hljs-keyword">for</span> j, c2 <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(s2):
            insertions = previous_row[j + <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>
            deletions = current_row[j] + <span class="hljs-number">1</span>
            substitutions = previous_row[j] + (c1 != c2)
            current_row.append(<span class="hljs-built_in">min</span>(insertions, deletions, substitutions))
        previous_row = current_row
    <span class="hljs-keyword">return</span> previous_row[-<span class="hljs-number">1</span>]

<span class="hljs-built_in">print</span>(<span class="hljs-string">f"编辑距离 ('kitten', 'sitting'): <span class="hljs-subst">{simple_levenshtein(<span class="hljs-string">'kitten'</span>, <span class="hljs-string">'sitting'</span>)}</span>"</span>)

<span class="hljs-comment"># 运行结果：</span>
<span class="hljs-string">'''
编辑距离 ('kitten', 'sitting'): 3
'''</span>
</code></pre>
<h2 data-id="heading-13">4. 第四门派：分布差异的鉴定师</h2>
<p>用于衡量两个“概率分布”（比如两个直方图）有多像。这在机器学习和生成式 AI 中非常火。</p>
<h3 data-id="heading-14">4.1. KL 散度：衡量概率分布差异</h3>
<p><strong>KL散度</strong>衡量一个概率分布与另一个参考分布之间的差异，但不是对称的。</p>
<p><strong>应用场景：</strong></p>
<ul>
<li><strong>机器学习训练：</strong> 衡量模型预测的概率分布与真实标签分布之间的差异（Loss Function）。</li>
</ul>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> scipy.stats <span class="hljs-keyword">import</span> entropy
p = [<span class="hljs-number">0.1</span>, <span class="hljs-number">0.9</span>] <span class="hljs-comment"># 真实分布</span>
q = [<span class="hljs-number">0.2</span>, <span class="hljs-number">0.8</span>] <span class="hljs-comment"># 预测分布</span>
kl_div = entropy(p, q)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"KL散度: <span class="hljs-subst">{kl_div:<span class="hljs-number">.4</span>f}</span>"</span>)

<span class="hljs-comment"># 运行结果：</span>
<span class="hljs-string">'''
KL散度: 0.0367
'''</span>
</code></pre>
<h3 data-id="heading-15">4.2. JS 散度：衡量概率分布差异-对称</h3>
<p><strong>JS散度</strong>是<strong>KL散度</strong>的对称版本，值域固定。</p>
<p><strong>应用场景：</strong></p>
<ul>
<li><strong>GAN (生成对抗网络)：</strong> 早期用于衡量生成图片分布与真实图片分布的相似度。</li>
</ul>
<pre><code class="hljs language-python" lang="python">d_js = distance.jensenshannon(p, q)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"JS散度: <span class="hljs-subst">{d_js:<span class="hljs-number">.4</span>f}</span>"</span>)

<span class="hljs-comment"># 运行结果：</span>
<span class="hljs-string">'''
JS散度: 0.0998
'''</span>
</code></pre>
<h3 data-id="heading-16">4.3. Wasserstein 距离：地球搬运距离</h3>
<p><strong>Wasserstein距离</strong>衡量将一个概率分布"搬运"成另一个所需的最小工作量，直观理解是将一堆沙子变成指定形状所需的最小移动距离。</p>
<p><strong>应用场景：</strong></p>
<ul>
<li><strong>图像生成 (WGAN)：</strong> 即使两个分布完全不重叠（KL 散度会失效），Wasserstein 距离也能给出合理的数值，指导 AI 学习。</li>
</ul>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> scipy.stats <span class="hljs-keyword">import</span> wasserstein_distance
d_wasserstein = wasserstein_distance([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>])
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"Wasserstein距离: <span class="hljs-subst">{d_wasserstein:<span class="hljs-number">.2</span>f}</span>"</span>)

<span class="hljs-comment"># 运行结果：</span>
<span class="hljs-string">'''
Wasserstein距离: 5.00
'''</span>
</code></pre>
<h2 data-id="heading-17">5. 第五门派：时间序列的变形者</h2>
<h3 data-id="heading-18">5.1. DTW 距离：时间序列的弹性匹配</h3>
<p><strong>动态时间规整</strong>（<code>DTW</code>）距离允许时间轴伸缩弯曲，用于衡量两个时间序列的相似性，即使它们在时间轴上不完全对齐。</p>
<p><strong>应用场景：</strong></p>
<ul>
<li><strong>语音识别/股票分析：</strong> 两个人读同一个单词 "Hello"。
<ul>
<li>人 A：H-e-l-l-o (语速快)</li>
<li>人 B：H-e-e-e-l-l-o-o (语速慢)</li>
<li>欧氏距离会认为这完全不同，但 DTW 会把时间轴“对齐”，发现它们其实很像。</li>
</ul>
</li>
</ul>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 简单的DTW概念代码（实际应用推荐使用 fastdtw 库）</span>
<span class="hljs-keyword">from</span> scipy.spatial.distance <span class="hljs-keyword">import</span> euclidean

<span class="hljs-keyword">def</span> <span class="hljs-title function_">dtw_distance</span>(<span class="hljs-params">s1, s2</span>):
    n, m = <span class="hljs-built_in">len</span>(s1), <span class="hljs-built_in">len</span>(s2)
    dtw_matrix = np.zeros((n+<span class="hljs-number">1</span>, m+<span class="hljs-number">1</span>))
    dtw_matrix[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>:] = np.inf
    dtw_matrix[<span class="hljs-number">1</span>:, <span class="hljs-number">0</span>] = np.inf

    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n+<span class="hljs-number">1</span>):
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, m+<span class="hljs-number">1</span>):
            cost = <span class="hljs-built_in">abs</span>(s1[i-<span class="hljs-number">1</span>] - s2[j-<span class="hljs-number">1</span>])
            dtw_matrix[i, j] = cost + <span class="hljs-built_in">min</span>(dtw_matrix[i-<span class="hljs-number">1</span>, j],    <span class="hljs-comment"># 插入</span>
                                          dtw_matrix[i, j-<span class="hljs-number">1</span>],    <span class="hljs-comment"># 删除</span>
                                          dtw_matrix[i-<span class="hljs-number">1</span>, j-<span class="hljs-number">1</span>])  <span class="hljs-comment"># 匹配</span>
    <span class="hljs-keyword">return</span> dtw_matrix[n, m]

ts_1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]
ts_2 = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>] <span class="hljs-comment"># 同样趋势，但多了重复（慢动作）</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"DTW距离: <span class="hljs-subst">{dtw_distance(ts_1, ts_2)}</span>"</span>)

<span class="hljs-comment"># 运行结果：</span>
<span class="hljs-string">'''
DTW距离: 0.0
'''</span>
</code></pre>
<h2 data-id="heading-19">6. 总结：如何选择你的“尺子”？</h2>
<p>面对新数据，别盲目选欧氏距离，参考下面的建议：</p>
<ol>
<li><strong>普通数值数据，看绝对大小：</strong> 选 <strong>欧氏</strong> 或 <strong>曼哈顿</strong>。</li>
<li><strong>看重方向/喜好，忽略绝对数值：</strong> 选 <strong>余弦距离</strong>（如文本、推荐）。</li>
<li><strong>看重趋势变化，忽略数值大小：</strong> 选 <strong>相关系数距离</strong>（如股票）。</li>
<li><strong>数据相关性强，且有离群点：</strong> 选 <strong>马氏距离</strong>。</li>
<li><strong>集合、标签类数据：</strong> 选 <strong>杰卡德</strong> 或 <strong>汉明</strong>。</li>
<li><strong>概率分布对比（AI 模型）：</strong> 选 <strong>KL</strong> 或 <strong>Wasserstein</strong>。</li>
<li><strong>长短不一的时间序列：</strong> 选 <strong>DTW</strong>。</li>
</ol>
<p>文中代码中大部分的<strong>距离</strong>关键是掌握其<strong>概念</strong>和<strong>应用场景</strong>，至于其距离算法的实现，<code>scipy</code>库中大部分都有封装好的函数，即使没有，也可以用其他库来代替。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[如何避免MySQL死锁？资深DBA的9条黄金法则]]></title>    <link>https://juejin.cn/post/7583799807593840674</link>    <guid>https://juejin.cn/post/7583799807593840674</guid>    <pubDate>2025-12-15T09:47:30.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7583799807593840674" data-draft-id="7576487832089722895" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="如何避免MySQL死锁？资深DBA的9条黄金法则"/> <meta itemprop="keywords" content="后端,MySQL"/> <meta itemprop="datePublished" content="2025-12-15T09:47:30.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="刘大华"/> <meta itemprop="url" content="https://juejin.cn/user/3507878440995946"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            如何避免MySQL死锁？资深DBA的9条黄金法则
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3507878440995946/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    刘大华
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-15T09:47:30.000Z" title="Mon Dec 15 2025 09:47:30 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-15
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>大家好，我是大华！</p>
<p>死锁是数据库里很常见的问题：两个或多个事务互相等待对方释放锁，结果谁也动不了。</p>
<p>MySQL的InnoDB引擎会自己自动检测死锁，并且回滚其中一个事务来解决，但这种情况如果经常遇到的话，会很影响性能和用户体验。</p>
<p>其实，只要注意一些设计细节，就能大大减少甚至避免死锁。</p>
<p>下面是几个最实用的方法：</p>
<hr/>
<h3 data-id="heading-0">1. 事务要短，动作要快</h3>
<p>事务越长，锁住数据的时间就越久，别人就越容易“撞上”你。</p>
<p><strong>正确做法</strong>：只在事务里做必要的数据库操作，别把业务逻辑（比如调接口、算数据）塞进去。</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-comment">-- 不推荐：事务中混杂业务逻辑</span>
<span class="hljs-keyword">START</span> TRANSACTION;
<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;
<span class="hljs-comment">-- 假设此处有耗时的业务处理...</span>
<span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> balance <span class="hljs-operator">=</span> balance <span class="hljs-operator">-</span> <span class="hljs-number">100</span> <span class="hljs-keyword">WHERE</span> user_id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;
<span class="hljs-keyword">UPDATE</span> orders <span class="hljs-keyword">SET</span> status <span class="hljs-operator">=</span> <span class="hljs-string">'paid'</span> <span class="hljs-keyword">WHERE</span> user_id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;
<span class="hljs-keyword">COMMIT</span>;

<span class="hljs-comment">-- 推荐：事务只包含必要数据库操作</span>
<span class="hljs-keyword">START</span> TRANSACTION;
<span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> balance <span class="hljs-operator">=</span> balance <span class="hljs-operator">-</span> <span class="hljs-number">100</span> <span class="hljs-keyword">WHERE</span> user_id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;
<span class="hljs-keyword">UPDATE</span> orders <span class="hljs-keyword">SET</span> status <span class="hljs-operator">=</span> <span class="hljs-string">'paid'</span> <span class="hljs-keyword">WHERE</span> user_id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;
<span class="hljs-keyword">COMMIT</span>;
</code></pre>
<hr/>
<h3 data-id="heading-1">2. 所有事务按同一个顺序操作表</h3>
<p>这是避免死锁最有效的一招！</p>
<p>比如：如果多个事务都要改 <code>users</code> 和 <code>orders</code> 表，那就<strong>统一先改 users，再改 orders</strong>。不要有的先改 users，有的先改 orders。</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-comment">-- 所有地方都这样写：</span>
<span class="hljs-keyword">UPDATE</span> users <span class="hljs-keyword">SET</span> ... <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;
<span class="hljs-keyword">UPDATE</span> orders <span class="hljs-keyword">SET</span> ... <span class="hljs-keyword">WHERE</span> user_id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;
</code></pre>
<p>只要顺序一致，就不会出现“A等B、B等A”的循环等待。</p>
<hr/>
<h3 data-id="heading-2">3. 给表加合适的索引</h3>
<p>InnoDB 的行锁是靠索引来实现的。如果查询没用到索引，MySQL 就可能锁住整张表（或很多无关的行），大大增加死锁风险。</p>
<p><strong>建议</strong>：</p>
<ul>
<li>经常用来查或更新的字段（比如 <code>user_id</code>）要建索引。</li>
<li>用 <code>EXPLAIN</code> 看看 SQL 是否命中索引。</li>
</ul>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">CREATE</span> INDEX idx_user_id <span class="hljs-keyword">ON</span> orders(user_id);
</code></pre>
<hr/>
<h3 data-id="heading-3">4. 别用太高的隔离级别（除非必要）</h3>
<p>MySQL 默认是 <code>REPEATABLE READ</code>，它会加“间隙锁”，防止幻读，但也更容易死锁。</p>
<p>如果你的业务能接受“读已提交”（比如允许看到别人刚提交的数据），可以改成：</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
</code></pre>
<p>这样锁的范围更小，死锁概率更低。</p>
<hr/>
<h3 data-id="heading-4">5. 显式加锁时要小心</h3>
<p>如果你要用 <code>SELECT ... FOR UPDATE</code> 锁行，一定要确保：</p>
<ul>
<li>条件能命中索引；</li>
<li>锁的行尽量少；</li>
<li>事务尽快结束。</li>
</ul>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-comment">-- 安全：通过主键或索引锁定一行</span>
<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> accounts <span class="hljs-keyword">WHERE</span> user_id <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span>;
</code></pre>
<p>如果 <code>user_id</code> 没索引，这条语句可能锁住成千上万行！</p>
<hr/>
<h3 data-id="heading-5">6. 应用层要有重试机制</h3>
<p>死锁偶尔还是会发生。这时候，应用应该：</p>
<ul>
<li>捕获死锁错误（MySQL 错误码 1213 或 SQLSTATE '40001'）；</li>
<li>自动重试几次（比如最多 2~3 次）；</li>
<li>每次重试前等一小会儿（比如 100ms、200ms…）。</li>
</ul>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 伪代码示例</span>
<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) {
    <span class="hljs-keyword">try</span> {
        doDatabaseUpdate();
        <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 成功就退出</span>
    } <span class="hljs-keyword">catch</span> (DeadlockException e) {
        sleep(<span class="hljs-number">100</span> * (i + <span class="hljs-number">1</span>)); <span class="hljs-comment">// 等一下再试</span>
    }
}
</code></pre>
<hr/>
<h3 data-id="heading-6">7. 大批量更新要分批做</h3>
<p>一次更新几万行？这很容易锁住大量数据，引发死锁或卡顿。</p>
<p><strong>正确做法</strong>：每次只改 500~1000 行，改完提交，再继续。</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-comment">-- 分批更新</span>
<span class="hljs-keyword">UPDATE</span> large_table <span class="hljs-keyword">SET</span> status <span class="hljs-operator">=</span> <span class="hljs-string">'done'</span>
<span class="hljs-keyword">WHERE</span> create_time <span class="hljs-operator">&lt;</span> <span class="hljs-string">'2023-01-01'</span> <span class="hljs-keyword">AND</span> status <span class="hljs-operator">!=</span> <span class="hljs-string">'done'</span>
LIMIT <span class="hljs-number">1000</span>;
<span class="hljs-comment">-- 循环执行，直到没有数据可更新</span>
</code></pre>
<hr/>
<h3 data-id="heading-7">8. 避免热点数据被频繁修改</h3>
<p>比如一个全局计数器，所有请求都去 <code>UPDATE counter SET value = value + 1</code>，那这一行就成了堵点。</p>
<p><strong>解决办法</strong>：用分桶计数。</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-comment">-- 把计数分散到 10 个桶里</span>
<span class="hljs-keyword">UPDATE</span> counter_buckets <span class="hljs-keyword">SET</span> <span class="hljs-keyword">value</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">value</span> <span class="hljs-operator">+</span> <span class="hljs-number">1</span> 
<span class="hljs-keyword">WHERE</span> name <span class="hljs-operator">=</span> <span class="hljs-string">'views'</span> <span class="hljs-keyword">AND</span> bucket <span class="hljs-operator">=</span> <span class="hljs-built_in">FLOOR</span>(RAND() <span class="hljs-operator">*</span> <span class="hljs-number">10</span>);

<span class="hljs-comment">-- 查总数时再加起来</span>
<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">SUM</span>(<span class="hljs-keyword">value</span>) <span class="hljs-keyword">FROM</span> counter_buckets <span class="hljs-keyword">WHERE</span> name <span class="hljs-operator">=</span> <span class="hljs-string">'views'</span>;
</code></pre>
<hr/>
<h3 data-id="heading-8">9. 出问题了怎么查？</h3>
<p>看最近一次死锁详情：</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">SHOW</span> ENGINE INNODB STATUS;
</code></pre>
<p>找<code>LATEST DETECTED DEADLOCK</code>部分。</p>
<p>查当前正在运行的事务（MySQL 8.0+）：</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> performance_schema.data_locks;
<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> information_schema.INNODB_TRX;
</code></pre>
<hr/>
<h3 data-id="heading-9">总结</h3>
<p>1.<strong>事务要短</strong>：别拖着不提交。
2.<strong>顺序要一致</strong>：所有人按相同顺序改表。
3.<strong>索引要到位</strong>：避免锁太多无关数据。
4.<strong>出错要重试</strong>：应用层兜底处理死锁。
5.<strong>大批量要分批</strong>：别一次锁太多行。</p>
<p>死锁没法完全杜绝，但只要做好这些，基本就不会再被它困扰了！</p>
<blockquote>
<p>本文首发于公众号：程序员刘大华，专注分享前后端开发的实战笔记。关注我，少走弯路，一起进步！</p>
</blockquote>
<h4 data-id="heading-10">📌往期精彩</h4>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F6V83qjR6u0nyfzL-14xYAw" target="_blank" title="https://mp.weixin.qq.com/s/6V83qjR6u0nyfzL-14xYAw" ref="nofollow noopener noreferrer">《async/await 到底要不要加 try-catch？异步错误处理最佳实践》</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FbgLoyqb3VLgn3xXAok3kcQ" target="_blank" title="https://mp.weixin.qq.com/s/bgLoyqb3VLgn3xXAok3kcQ" ref="nofollow noopener noreferrer">《如何查看 SpringBoot 当前线程数？3 种方法亲测有效》</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2Fp0n2mN5RDDDaIWuHHVRUZQ" target="_blank" title="https://mp.weixin.qq.com/s/p0n2mN5RDDDaIWuHHVRUZQ" ref="nofollow noopener noreferrer">《Java 开发必看：什么时候用 for，什么时候用 Stream？》</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FDpjuafW3agyhLEQYif3zJA" target="_blank" title="https://mp.weixin.qq.com/s/DpjuafW3agyhLEQYif3zJA" ref="nofollow noopener noreferrer">《别再乱 new ArrayList！8 大 Java 容器选型案例，一篇看懂》</a></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Node.js 编程实战：Cookie与Session深度解析]]></title>    <link>https://juejin.cn/post/7583618094175322158</link>    <guid>https://juejin.cn/post/7583618094175322158</guid>    <pubDate>2025-12-15T02:04:42.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7583618094175322158" data-draft-id="7583613222344638490" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Node.js 编程实战：Cookie与Session深度解析"/> <meta itemprop="keywords" content="后端,Node.js,Trae"/> <meta itemprop="datePublished" content="2025-12-15T02:04:42.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="程序员爱钓鱼"/> <meta itemprop="url" content="https://juejin.cn/user/2799775299157614"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Node.js 编程实战：Cookie与Session深度解析
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2799775299157614/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    程序员爱钓鱼
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-15T02:04:42.000Z" title="Mon Dec 15 2025 02:04:42 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-15
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>在 Web 应用中，HTTP 协议本身是无状态的。服务器无法仅凭一次请求就判断“当前用户是谁、之前做过什么操作”。为了解决状态保持的问题，Cookie 与 Session 成为了 Web 开发中最基础、也最重要的机制之一。本文将结合 Node.js，系统讲解 Cookie 与 Session 的工作原理、使用方式以及常见实践。</p>
</blockquote>
<hr/>
<h2 data-id="heading-0">一、为什么需要 Cookie 与 Session</h2>
<p>HTTP 是一种无状态协议，每一次请求都是独立的：</p>
<ul>
<li>服务器不会记住上一次请求的用户</li>
<li>不同请求之间默认没有任何关联</li>
<li>用户登录状态无法自动保持</li>
</ul>
<p>如果没有状态机制，就无法实现登录、购物车、个性化配置等功能。Cookie 与 Session 的出现，正是为了在“无状态协议”之上，构建“有状态的应用体验”。</p>
<hr/>
<h2 data-id="heading-1">二、Cookie 的基本概念</h2>
<p>Cookie 是服务器发送给浏览器的一小段数据，浏览器会将其保存在本地，并在后续请求中自动携带回服务器。</p>
<p>Cookie 的特点包括：</p>
<ul>
<li>存储在客户端（浏览器）</li>
<li>每次请求都会随 HTTP 头一起发送</li>
<li>大小有限（通常不超过 4KB）</li>
<li>可以设置过期时间、作用域和安全属性</li>
</ul>
<p>从本质上看，Cookie 是服务器在客户端保存状态信息的一种方式。</p>
<hr/>
<h2 data-id="heading-2">三、Node.js 中操作 Cookie</h2>
<h3 data-id="heading-3">1. 设置 Cookie</h3>
<p>在 Node.js 原生 <code>http</code> 模块中，可以通过响应头设置 Cookie。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">"http"</span>);

<span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {
  res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">"Set-Cookie"</span>, <span class="hljs-string">"username=nodejs; Max-Age=3600"</span>);
  res.<span class="hljs-title function_">end</span>(<span class="hljs-string">"Cookie set"</span>);
});

server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);
</code></pre>
<p>上面的代码会在浏览器中保存一个名为 <code>username</code> 的 Cookie，有效期为一小时。</p>
<hr/>
<h3 data-id="heading-4">2. 读取 Cookie</h3>
<p>浏览器发送的 Cookie 会出现在请求头中。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> cookie = req.<span class="hljs-property">headers</span>.<span class="hljs-property">cookie</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cookie);
</code></pre>
<p>如果有多个 Cookie，它们会以分号分隔的形式出现，需要手动解析。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">parseCookie</span>(<span class="hljs-params">cookieStr = <span class="hljs-string">""</span></span>) {
  <span class="hljs-keyword">const</span> cookies = {};
  cookieStr.<span class="hljs-title function_">split</span>(<span class="hljs-string">";"</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> {
    <span class="hljs-keyword">const</span> [key, value] = item.<span class="hljs-title function_">split</span>(<span class="hljs-string">"="</span>);
    <span class="hljs-keyword">if</span> (key &amp;&amp; value) {
      cookies[key.<span class="hljs-title function_">trim</span>()] = value.<span class="hljs-title function_">trim</span>();
    }
  });
  <span class="hljs-keyword">return</span> cookies;
}
</code></pre>
<hr/>
<h2 data-id="heading-5">四、Cookie 的常见属性</h2>
<p>Cookie 并不仅仅是键值对，还可以设置多种属性来增强安全性和控制范围。</p>
<ul>
<li><code>Max-Age / Expires</code>：控制 Cookie 过期时间</li>
<li><code>Path</code>：限制 Cookie 生效的路径</li>
<li><code>Domain</code>：限制 Cookie 生效的域名</li>
<li><code>HttpOnly</code>：禁止 JavaScript 访问 Cookie</li>
<li><code>Secure</code>：仅在 HTTPS 连接下发送</li>
</ul>
<p>合理设置这些属性，是 Web 安全的重要一环。</p>
<hr/>
<h2 data-id="heading-6">五、Session 的核心思想</h2>
<p>Session 是服务器端保存用户状态的一种机制。
与 Cookie 不同，Session 的核心数据存储在服务器中。</p>
<p>常见的工作流程是：</p>
<ol>
<li>用户第一次访问服务器</li>
<li>服务器创建一个 Session，并生成 Session ID</li>
<li>服务器将 Session ID 通过 Cookie 发送给客户端</li>
<li>客户端后续请求携带该 Session ID</li>
<li>服务器根据 Session ID 查找对应的 Session 数据</li>
</ol>
<p>Session 解决了 Cookie 数据暴露在客户端的问题。</p>
<hr/>
<h2 data-id="heading-7">六、Node.js 中的简单 Session 实现</h2>
<p>下面是一个基于内存的简易 Session 示例，用于理解原理。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">"http"</span>);
<span class="hljs-keyword">const</span> crypto = <span class="hljs-built_in">require</span>(<span class="hljs-string">"crypto"</span>);

<span class="hljs-keyword">const</span> sessions = {};

<span class="hljs-keyword">function</span> <span class="hljs-title function_">generateSessionId</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">return</span> crypto.<span class="hljs-title function_">randomBytes</span>(<span class="hljs-number">16</span>).<span class="hljs-title function_">toString</span>(<span class="hljs-string">"hex"</span>);
}

<span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {
  <span class="hljs-keyword">let</span> sid;

  <span class="hljs-keyword">const</span> cookies = <span class="hljs-title function_">parseCookie</span>(req.<span class="hljs-property">headers</span>.<span class="hljs-property">cookie</span>);
  sid = cookies.<span class="hljs-property">sid</span>;

  <span class="hljs-keyword">if</span> (!sid || !sessions[sid]) {
    sid = <span class="hljs-title function_">generateSessionId</span>();
    sessions[sid] = { <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> };
    res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">"Set-Cookie"</span>, <span class="hljs-string">`sid=<span class="hljs-subst">${sid}</span>; HttpOnly`</span>);
  }

  sessions[sid].<span class="hljs-property">count</span>++;
  res.<span class="hljs-title function_">end</span>(<span class="hljs-string">`Visit count: <span class="hljs-subst">${sessions[sid].count}</span>`</span>);
});

server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);
</code></pre>
<p>这个例子展示了 Session 的基本流程，但并不适合生产环境。</p>
<hr/>
<h2 data-id="heading-8">七、Cookie 与 Session 的区别</h2>
<p>从设计角度来看，两者的差异非常明显：</p>
<ul>
<li>Cookie 存储在客户端，Session 存储在服务器</li>
<li>Cookie 容量小，Session 理论上更灵活</li>
<li>Cookie 更容易被篡改，Session 相对安全</li>
<li>Session 通常依赖 Cookie 传递 Session ID</li>
</ul>
<p>在实际开发中，它们往往是配合使用的，而不是二选一。</p>
<hr/>
<h2 data-id="heading-9">八、生产环境中的 Session 管理</h2>
<p>在真实项目中，Session 通常不会存储在内存中，而是使用：</p>
<ul>
<li>Redis</li>
<li>数据库</li>
<li>分布式缓存系统</li>
</ul>
<p>这样可以支持：</p>
<ul>
<li>服务重启不丢失 Session</li>
<li>多实例部署下的 Session 共享</li>
<li>更好的性能与扩展性</li>
</ul>
<p>在 Node.js 项目中，Express 通常会搭配 <code>express-session</code> 与 Redis 一起使用。</p>
<hr/>
<h2 data-id="heading-10">九、Cookie 与 Session 的安全实践</h2>
<p>在涉及登录和用户身份的场景中，安全尤为重要：</p>
<ul>
<li>Session ID 必须足够随机，防止猜测</li>
<li>Cookie 应设置 <code>HttpOnly</code>，防止 XSS</li>
<li>使用 HTTPS 并开启 <code>Secure</code> 属性</li>
<li>定期清理过期 Session</li>
<li>避免在 Cookie 中存储敏感信息</li>
</ul>
<p>这些细节直接决定了系统的安全等级。</p>
<hr/>
<h2 data-id="heading-11">十、总结</h2>
<p>通过本文，你应该已经掌握：</p>
<ul>
<li>Cookie 与 Session 出现的背景</li>
<li>Cookie 的基本原理与 Node.js 实现方式</li>
<li>Session 的核心思想与运行流程</li>
<li>两者的差异与使用场景</li>
<li>实际项目中的安全与架构建议</li>
</ul>
<p>Cookie 与 Session 是 Node.js Web 开发中绕不开的基础知识。理解它们的原理，比单纯会用框架更重要，也为后续学习认证系统、权限控制和分布式架构打下坚实基础。</p>
<hr/></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[AgentScope Java 1.0：从模型到应用，AI Agent 全生命周期管理利器！]]></title>    <link>https://juejin.cn/post/7583910637957611539</link>    <guid>https://juejin.cn/post/7583910637957611539</guid>    <pubDate>2025-12-15T09:46:44.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7583910637957611539" data-draft-id="7583615094363815990" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="AgentScope Java 1.0：从模型到应用，AI Agent 全生命周期管理利器！"/> <meta itemprop="keywords" content="Java,云原生"/> <meta itemprop="datePublished" content="2025-12-15T09:46:44.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="阿里云云原生"/> <meta itemprop="url" content="https://juejin.cn/user/3808363977648493"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            AgentScope Java 1.0：从模型到应用，AI Agent 全生命周期管理利器！
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3808363977648493/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    阿里云云原生
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-15T09:46:44.000Z" title="Mon Dec 15 2025 09:46:44 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-15
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读13分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>作者：亦盏</p>
<h2 data-id="heading-0">AgentScope 简介</h2>
<p>AgentScope 是阿里巴巴推出的一款以开发者为核心，专注于智能体开发的开源框架，是继 ModelScope（魔搭社区）后在 Agent 层的战略产品。它的核心目标是解决智能体在构建、运行和管理中的难题，提供一套覆盖“开发、部署、调优”全生命周期的生产级解决方案，让智能体应用的开发更简单、运行更稳定、效果更卓越。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6c118a37647241b1893e0e5747440f79~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766396803&amp;x-signature=Nc2fHBcTJPl7TPLyvyAIXGwQRE4%3D" alt="图片" loading="lazy"/></p>
<p><strong>近期 AgentScope 迎来了 12 月版本的重大更新</strong>，这是一次面向生产级智能体应用的基建大升级，让智能体从“实验室原型”走向“业务落地”。<strong>本次更新围绕三大核心主线：</strong> 开箱即用的智能体，即刻赋能多种真实场景；基建增强让智能体“变聪明”的底层能力全面升级；运行时 × 多语言 × 前端，三位一体交付生产就绪的智能体。</p>
<p>一直以来，Java 语言在金融、政务、电商等领域开发中都占着主导地位，开发者社区对于 AgentScope Java 版本的呼声也非常高，AgentScope 本次也重磅发布了 Java 的 1.0 版本，拥抱企业开发主流技术栈。</p>
<h2 data-id="heading-1">AgentScope Java 1.0 重磅发布</h2>
<p>今天，我们很高兴地宣布 AgentScope Java 1.0 版本正式发布了，面向 Java 开发者提供企业级 Agentic 应用构建的能力。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/baa988a8c2bb49048d8340894e4f4527~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766396803&amp;x-signature=wUxY2bFxf92eRxIpEWm9EDhl3dg%3D" alt="图片" loading="lazy"/></p>
<p><strong>首先在开发范式上，</strong> AgentScope 采用领先的 ReAct（推理-行动）模式，支持高效的工具调用，并允许开发者对 Agent 执行过程进行实时介入，实现了自主性与可控性的完美平衡。</p>
<p><strong>其次，它提供了开箱即用的企业级能力。</strong> 框架提供安全沙箱保障代码执行安全，通过精细的上下文工程优化模型交互效果。作为 Java 框架，它易于集成到现有企业技术栈中，并具备高性能架构，确保生产环境的稳定可靠。</p>
<p><strong>最后，它拥有完善的开发与优化生态。</strong> 提供从开发态可视化调试、A/B 测试到评估与强化学习的完整工具链，构成了 Agent 开发、部署、调优的闭环，助力持续提升 Agent 效果。</p>
<h3 data-id="heading-2">领先的开发范式</h3>
<p>在构建复杂的 AI Agent 应用时，开发者普遍面临众多挑战：僵化的工作流难以适应多变的任务、运行中的Agent 无法实时干预、海量工具导致管理混乱与性能瓶颈、模型输出格式不稳定等等。如何系统性地解决这些痛点，是提升开发效率和应用稳定性的关键。AgentScope 采用领先的 ReAct 范式，赋予 LLM 自主规划能力，并提供实时介入控制、高效的工具调用体系。此外，它还内置任务规划、结构化输出等强大工具，支持高效开发生产级应用。</p>
<ol>
<li>
<p><strong>领先的 ReAct 范式</strong>，赋予Agent自主规划能力。</p>
<ol>
<li>工作流（Workflow）模式：在这种模式下，LLM 与工具（Tool）的协作路径由开发者预先定义，开发者对系统的执行流程有完全的控制权，这保证了任务执行的稳定性和确定性。但是他的缺点是架构僵化，当业务逻辑变得复杂时，维护成本激增，而且无法享受 LLM 持续进化所带来的能力提升。</li>
<li>ReAct 范式：与 Workflow 相反，ReAct 赋予了 LLM 自主控制权。LLM 扮演大脑的角色，能够动态地进行推理（Reasoning）和规划，自主决定何时、如何调用工具来执行操作（Action），从而主导任务的完成。随着 LLM 在理解、规划和工具使用等关键能力上日趋成熟，这种高度自主的 Agent 架构已成为复杂应用场景下的首选。</li>
</ol>
</li>
<li>
<p><strong>实时的介入控制</strong>，让 Agent 运行全程可控。传统 Agent 一旦启动便无法安全干预，AgentScope 基于异步架构，实现了强大的实时介入机制。</p>
<ol>
<li>安全中断：支持随时暂停 Agent，并自动保存其上下文和工具状态，确保任务能无缝恢复。</li>
<li>实时打断：当任务偏离预期或耗时过长时，用户可立即终止，避免资源浪费。</li>
<li>灵活定制：开发者可以自定义中断处理逻辑，实现更精细化的管理。</li>
</ol>
</li>
<li>
<p><strong>高效的工具调用</strong>，随着可调用工具数量的激增，Agent 面临着工具管理复杂、执行效率低、上下文紧张的问题。AgentScope 构建了一套高效、可靠的工具管理体系。</p>
<ol>
<li>工具注册：提供标准化的注册接口，支持自动提取工具的 JSON Schema，提供参数预设和工具函数后处理接口，降低集成门槛。</li>
<li>便捷管理：AgentScope 通过结构化的组织方式和动态控制机制来高效支持工具的使用。工具组（Tool Group）按照功能对工具进行分类（例如浏览器、地图服务等），使 Agent 能够根据当前任务按需激活相关工具，从而有效缓解上下文窗口的压力；元工具（Meta-Tool）允许 Agent 在运行时动态启用或停用整个工具组，实现更加智能化的工具管理。</li>
<li>高效执行：采用统一接口处理所有工具调用，无论同步、异步或流式输出，在 AgentScope 中将被统一为异步流式返回，降低工具函数返回的处理复杂度。同时支持工具的并行调用，大幅提升运行效率。</li>
</ol>
</li>
<li>
<p><strong>强大的内置工具</strong>：AgentScope 内置了许多开箱即用的强大工具，开箱即用，加速生产级应用开发。</p>
<ol>
<li>PlanNoteBook 工具提供了强大的任务规划与执行能力。支持开发者手动定义结构化计划，也允许 Agent 在运行时自主创建和管理计划。通过 PlanNotebook 提供完整的计划管理功能，包括创建、修改、暂停、恢复和切换多个计划，引导 Agent 有序执行复杂计划。</li>
<li>结构化输出：传统的做法是在 Prompt 中写格式要求，要求模型“请按照以下 JSON 格式输出”，不断尝试和优化提示词，经常需要在外部代码中做二次解析和格式校验。AgentScope 通过内置工具确保 LLM 的输出严格遵循预定义的 JSON 格式，彻底告别繁琐的提示词调试和二次解析。</li>
</ol>
</li>
</ol>
<h3 data-id="heading-3">企业级能力</h3>
<p>AgentScope 提供了安全工具沙箱和上下文工程能力，解决了安全与效果的核心痛点，确保 Agent 的输出效果满足生产标准。依托于 Java 在企业应用开发市场的强大生态，通过标准的 A2A 和 MCP 协议，提供了灵活的集成与被集成方案，这使得 Agent 既能作为独立服务嵌入现有系统，也能成为连接和调度其他服务的智能中枢。开发者无需关心底层集成细节，专注于业务逻辑即可快速构建生产级 Agent 应用。最后，依托于 AgentScope Runtime 提供的能力，支持将 Agent 一键部署到阿里云百炼和函数计算平台，为您的 Agent 应用提供商业级的产品化保障。</p>
<ol>
<li>
<p><strong>安全沙箱</strong></p>
<ol>
<li>Agent 在执行工具调用或自动化任务时，可能访问敏感资源或引发不可控行为，需要沙箱提供安全隔离环境。AgentScope Runtime Sandbox 支持开发者将自定义工具部署在高度隔离的受控环境中安全运行，防止对系统造成意外影响或安全风险。</li>
<li>内置多种开箱即用的沙箱：GUI 沙箱提供完整桌面环境，支持鼠标、键盘和屏幕操作；文件系统沙箱实现隔离的文件读写与管理；移动端沙箱基于 Android 模拟器，支持点击、滑动、输入和截屏等真实移动交互。兼顾了安全性、灵活性与多平台覆盖，全面支撑工具执行、浏览器自动化、训练评测等复杂场景。</li>
</ol>
</li>
<li>
<p><strong>上下文工程</strong></p>
<ol>
<li>RAG：内置基于 Embedding 的标准实现，支持企业在面对复杂的多元业务数据情况下，私有化部署自有的知识库体系，实现对数据的完全自主可控；集成阿里云百炼企业级知识库，借助商业化产品获得更强大的检索与重排序能力。</li>
<li>Memory：AgentScope 定义了对短期、长期记忆的抽象，支持语义搜索与多租户隔离，提供自动管理、Agent 主动调用、混合模式三种控制方式。通过 ReMe 项目提供了记忆的最佳实践方案，让 Agent 能够理解用户偏好、提升任务表现和更聪明地使用工具，显著提升业务场景下的智能问答准确性与上下文连贯性，实现越用越好用。</li>
</ol>
</li>
<li>
<p><strong>易于集成</strong></p>
<ol>
<li>MCP 集成：基于 AgentScope Java 开源生态，现有的 HTTP 业务系统无需改动业务逻辑代码，通过简单配置即可被 Agent 无缝集成，快速成为 Agent 可调用的“手脚”，极大地扩展了 Agent 的能力边界。</li>
<li>A2A 集成：复杂的任务通常需要多个 Agent 协同工作。AgentScope Java 支持将描述 Agent 自身能力的 Agent Card 注册到 Nacos 等服务中心，调用方 Agent 只需连接 Nacos，即可自动发现并调用其他 Agent 的能力。这使得分布式 Multi Agent 系统的构建与协作变得像调用普通微服务一样简单。</li>
</ol>
</li>
<li>
<p>高性能</p>
<ol>
<li>轻量化：核心库仅依赖 Reactor Core、Jackson 和 SLF4J、RAG、长期记忆等能力通过可选扩展按需引入，目前基于厂商原生 SDK 实现模型调用，未来将基于 OkHttp 与 Jackson 原生实现，进一步精简内核依赖。</li>
<li>异步化：针对 AI 应用交互具有持续时间长、多轮次上下文依赖的特点，支持引入消息队列 RocketMQ 作为异步消息中枢，实现任务解耦与非阻塞调用，提升 Agent 的吞吐能力和响应速度。</li>
<li>Native 优化：联合 JVM 团队适配了 GraalVM 和 Leyden，将 Java 应用启动速度提升 3 到 10 倍，实现了 Agent 200ms 内冷启动，为 AI 应用 Serverless 毫秒级弹性奠定基础。</li>
</ol>
</li>
</ol>
<h3 data-id="heading-4">强大的生态</h3>
<p>AI 原生应用架构正在深刻重塑软件工程范式，传统软件的确定性被 Agent 的非确定性所取代，其最终效果由模型、数据和上下文共同决定，这使得传统的“代码测试”演变为复杂的“效果评估”。由于任何微小的变更都可能引发效果的剧烈波动，A/B 测试已从过去的优化选项，转变为保障版本质量的核心发布流程。软件工程重心也必须从以代码为中心转向以数据为中心，成功的关键在于构建一个高效的数据飞轮。</p>
<p>面对这一挑战，AgentScope 提供了 Studio、RM Gallery 和 Trinity-RFT 等一系列生态工具，结合 Higress AI 网关和可观测系统，您可以快速实践 AI 原生应用数据飞轮。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/869488f900334ff785218cf8991ba100~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766396803&amp;x-signature=NGCD4iN%2FPsiVCl4yld8V4v15CrU%3D" alt="图片" loading="lazy"/></p>
<p>在 Agent 开发阶段，我们采用 AgentScope Studio 可视化平台对 Agent 进行实时调试与观测，显著提升了开发效率，它深度集成了 OpenTelemetry 和 LoongSuite，实现了端到端的全链路追踪。</p>
<p>在部署架构中，Higress 作为统一的流量入口网关，负责将外部请求路由至相应的 Agent。Agent 则通过 Higress 内置的 AI 网关能力与 LLM 通信。借助 Higress 强大的插件体系，我们可以对流量进行灵活打标，从而实现对 Agent 和 LLM 的精准路由控制。</p>
<p>在发布后的 A/B 测试阶段，Higress 网关能根据请求内容（如用户地理位置、业务线、付费状态等）将流量分配到不同实验组。例如，将付费用户导向 Agent 的 A 版本，免费用户导向 B 版本，以进行效果对比。同时流量的分组标签会借助可观测在整个调用链路中透传。这样，AI 网关便能根据此标签将请求路由到对应的 LLM 版本。这一机制让我们在无需修改业务代码的情况下，实现了 Agent 与 LLM 的协同 A/B 测试。</p>
<p>在此过程中，全链路产生的所有数据——从用户输入、Agent 的提示词（Prompt），到模型的输出、时延与成本都会上报到可观测系统中。基于 RM Gallery 的奖励函数评估 Agent 在各实验组的业务表现，并筛选沉淀高质量的数据集。随后，我们的训练框架 Trinity-RFT 会运用这些数据集和奖励模型，通过强化学习对模型进行持续迭代，不断提升其解决业务问题的能力。</p>
<p>最终，这形成了一个以数据为驱动的自我优化闭环。系统通过持续采集线上真实数据、分析评估效果并转化为高质量的训练数据，不断增强模型能力，构筑起坚实的技术竞争壁垒。</p>
<h2 data-id="heading-5">AgentScope Java Roadmap</h2>
<ul>
<li>上下文工程持续优化：Agent 效果不够好的原因，要么是模型能力不够强，要么是提供的上下文不准确，上下文工程是工程能力的核心。AgentScope Java 会持续深耕上下文工程，致力于构建一个更加高效、低延迟的上下文管理系统。未来开发者不需要关心上下文的技术细节，只需要专注于定义好 Agent 的功能。</li>
<li>实时全模态支持：大模型的边界正在从文本扩展至图像、语音乃至视频，能够与物理世界互动的具身智能产品开始进入我们的生活，AgentScope Java 会构建对实时全模态的深度支持，帮助开发者更好地开发多模态的应用，未来 Agent 不只是文本输入，完全可以通过“眼睛”、“耳朵”和“手”更好地服务用户。</li>
<li>评估与强化学习优化：我们已经提供了观测、评估、优化的整体解决方案，但目前评估和强化学习的门槛仍旧比较高。后续会不断通过生态集成降低门槛，开发者只需编写业务逻辑与设计奖励函数，即可借助 AgentScope 的生态工具链，让 Agent 在与用户或环境的交互中不断进化，实现真正的自我成长与迭代。</li>
</ul>
<p>AgentScope Java 版 Github 地址：</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fagentscope-ai%2Fagentscope-java" target="_blank" title="https://github.com/agentscope-ai/agentscope-java" ref="nofollow noopener noreferrer">github.com/agentscope-…</a></p>
<p>帮助文档：<a href="https://link.juejin.cn?target=https%3A%2F%2Fjava.agentscope.io%2Fen%2Fintro.html" target="_blank" title="https://java.agentscope.io/en/intro.html" ref="nofollow noopener noreferrer">java.agentscope.io/en/intro.ht…</a></p>
<p>如果你觉得 AgentScope Java 不错，欢迎给我们的项目 Star 并加入我们开源社区，一起构建面向未来的 Agent 体系！</p>
<p>AgentScope Java 和 Spring AI Alibaba 有哪些不同，请查看：《<a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzIwODYwNTA4MA%3D%3D%26mid%3D2247486409%26idx%3D1%26sn%3Da934c815a81fec948c9e146223aab8f9%26scene%3D21%23wechat_redirect" target="_blank" title="https://mp.weixin.qq.com/s?__biz=MzIwODYwNTA4MA==&amp;mid=2247486409&amp;idx=1&amp;sn=a934c815a81fec948c9e146223aab8f9&amp;scene=21#wechat_redirect" ref="nofollow noopener noreferrer">Spring AI Alibaba 和 AgentScope 啥区别？</a>》</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[国际化语言包与Excel自动化双向转换方案]]></title>    <link>https://juejin.cn/post/7583469866008887331</link>    <guid>https://juejin.cn/post/7583469866008887331</guid>    <pubDate>2025-12-15T03:23:00.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7583469866008887331" data-draft-id="7583510227146047503" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="国际化语言包与Excel自动化双向转换方案"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2025-12-15T03:23:00.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="刘同学有点忙"/> <meta itemprop="url" content="https://juejin.cn/user/4318537402555224"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            国际化语言包与Excel自动化双向转换方案
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4318537402555224/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    刘同学有点忙
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-15T03:23:00.000Z" title="Mon Dec 15 2025 03:23:00 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-15
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    6
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读9分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#2b2b2b;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(159,219,252,.15) 3%,transparent 0),linear-gradient(1turn,rgba(159,219,252,.15) 3%,transparent 0);background-size:20px 20px;background-position:50%}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{padding:30px 0;margin-top:35px;margin-bottom:10px;color:#4dd0e1}.markdown-body h1{font-size:30px;text-align:center;position:relative;width:max-content;margin:0 auto}.markdown-body h1:before{position:absolute;content:"";z-index:-1;top:-20px;height:100%;width:100px;left:0;right:0;margin:0 auto;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADsAAAA6CAYAAAAOeSEWAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAABkLSURBVGhDtZoHnJ1llcbP3Om9ZiYzmfSQhCQQIbRQVQKI9CYC68qKriJK0UXcZRcINqStIoiIqKCi1NACQihBWiCkkJ5MJlMyvd7p7d759v989/sy34yTbIj48Atz71ff855znvOc971xDrB/EtoGI7a9Z8Aq+wZML0mNj7dE95NZ1OKsj1dHo1GbnJpss9OTbWJyonvun4VP1Njuoagtb+m0it4By0iIt8LEeMvkr8XFWcfgkA1gYDLf47i2PzpsyU7UspKSLDoctagTZ7Vc08MzClMS7awJ2ZaflBB78CeET8TYla1dtrKt2w5KS7YCDGzEoz2RqKUmhGw6x2bhuXyOp2BoRXef1Q1E7Lj8TIsMD1sbxu1kcnYSAX1810RMTUmyMB7f2j1gC7NS7byinNiL/kH8Q8a+2NRh77b32El56VaPAe0YeGR2mh2bm+FdMRqP1rbZe+3dFsHT35qcb/Oz0rwzo7Gxs9feYPLS4kM2h8lawee5hPmlJXneFQeGAzJ2F564v7rFzi7Msu3d/Xgjzq5g8ArX8VCNN2vJ28daey0zZJabmGCLslP5HOf+Oygr3UzDGOf+JxrauXfQjslJt+dbuuyMgiwmk+sPAB/b2Lt2NdoMZnuY21qHIvbvUyZ4Z0ZQiXGrWjvsmPxsK4R0nmHA8ZCTQvxVQn5eRipklIBtcVbV1WtHYsjati47ZWKuTUpP9Z4yGk/xDBGe3v1mW4/dOrvYO7P/2G9jRSjf31FnXyaUXiB8r51WaJkM3kcfOSa2FR6qarIenooTLQHPLcC4mYThyw1tVpKWYlVERlZ8nC3Oz3Jzdn1nn5uvQ8OOHYvhR/CvsqffJbkCkZTvcYZ6Z0WTfTovw5Y1dtjXp+TbFPhgf7FfxpYxuMfr2uwo8rEtMmwXF+d6Z8wGmIR2PLyjo8cqOFffP2SLGexJEJCP9R29thkPXlpa4A5Y3w/jmuVNYYwO2QkY7WMtz3mVcE1hkualJdmSolzX8GnpKd4VZq80d1o7zN0RdWxGaqItgbn3B/+vsasgh/UMNBOvzYMZDxtDKp289KGaVguFQvb1yQWWwuB97GaSXqUUnVaYbSUwrDCEBz/C2CM8EhNrP13fbkeSh3OJgCAe2N1CWXKsGOc6TOr5U4q8MwYhDtkTda02MyPN+nnGBQEH7A37NHYz5KOZVv08qyjbSseEzKauPnsMj98wc6Ibcj5UUv7M8QWZTE52jEwGOVaD8U1Dw1YNWX0qM8VKyb80L/TrOPYOzH4KBJQTrK8M7+7KZjuM63sHBt17FubGoibCuf+tarWFGUmuwWeT8/vCXo1tZOYeZcazCaez8MwEzzM+HqhqtiJI5twxL1jeGLYk7jmKMF1JOCbg6Qj5nAdRqX7q3BYm8VAmQvW1lfcMc58IT95uIA3q+gftrDHPXUXJWkVEHJme5Bp5UmHsvIZ/O3l8ECE/FWcsItX2hr0ae8O2Wjs+J43QTbOZzGYQ/7Wtxq6eXjRK3r0By4YJ6Ty8EiYSJqcm2eGeV4Pox/ANENJR49RiEdfqcLflUJrEBZqgxYHrBjn2ExFURqKdVETN9YirJxKxR2rbrYeQv5ISmB6IsiDGNfZGWPeMgkzr58xnPaJ5p6XDZPKz4T77wayJ7jGhhXLwanOHTWBgq5n5q6YUwNJ7l3kKcRl7OJ7fF56l1GzvHbSD8dghTPi0wIRfv6XafjJ3ssv0PnZQ7nZx/etwzO1zJ3lHR2OETTw8x0tOx1AN3De0D7YV+63oGthjaJQ5Ur7eVVZjcdGInUyuaT73ZWg3efV8fZs7cc2E777Qi5eunVbghvPPymrt/krKGfcLd8ybYjdxrK6333Z09rjHZkNuLYzz0uIc+xWCZzz8nbHbe4dsY1e/XUOY+nimvtUaSazv4jXhaQasSbmYmpuenGwHZ8TKggSEQm08rMD7ahBOoExcMqXQegjnZ+CEvaEa1ZQUQkt39dj0zDS7krq+ARmpdws/nlNqD9WFbWN7l5u3wr9MyrcXKUsqWy3jTOaoML4DdaQ83YIoT4VYpEXvYQZLmbX5SLohBrgOj186Kc/iKTUPUhq+Rrm5ekOl3TWv1Mr6hqwbY0VOQXwEo+Moq4Z47q5qsU489G944LyJOW4LOLZOKtT/iI6+nGe/0dhuEd4ltj2NmiuCU4hnk5fHIi7+RK4uTEu0e+s7rAiRcw1CYy3OejvcYz+eXeI9MYY9nu3lYZl0KavJJ7Vjibzgjp319rUZE20j7CkJqFr5JQYgQ39f3eQaKpQk0afy8nl4uBzvjUUTRk7k3iebOm0pabDiyFn2XGu3dRME41CGVeBVqSiVnc6hIUpekp1VjHLDSOEcQlui5W/U8C7IKREjv1Gabw3wRwUTvpv7jybPtzHmIPZ49q6KRjuccqBQVCOtGvqXhrCFUUXJzOYSHt7Kw5Ix9H08dSje1o1JyL73IYXpEMmE5CRbw6wuykx2pR+Pd6/J4JpLiJKV6N9OnrcQNfQ0Zem6qQX2MmFXyWTE+DMO0kGx4e08DEjnXbsYuOq7niHB8jdY/wQ8Srm2XCZZUrOakF1CY5EKX0h93Tu/1J4kRdbDMT8MamgZK9xe3uDcvrPe++Y4f61rcZr7B53rN1c5N2ytcV5rCrvHt3T2Og19g+5nH7dvq3bqunr4NOwgK2MHA1jeEDuG7HNuLmtw7qpocl5t6nCPvdTQ7v4N4u3WTqeyu9cZHIo4f6lqdFoHh7wzMbzDeeGv3Hvzjlrnh2W1zofhHuftxpFn3VFe7zxS0+p0DlKVPbhhvBxhvwiFMgfP+mjHA08gEC4pybeLyK1iZldh8zC5VJQyUl8l59KZ0WJk2xaiYWxNrkXXJhA8r3PvZRur7ZZZRfadaRPsfiTmX9HGajC2tXd6V8dQTMhX0h8rNdJx9Ra8F8SbRNLzhPRnJmTZIUTYueTyWxyr7uv3rjC3OkzE8495oS+4xq6D5WoI0bO5WVCOSerl8rIeBrOI/Hkaw6ME5W1zSuzx2la3CRdWi3zIG+FDBvUp9LMgI/vggUmE7KkT81yGvOOgEYa/aUahhRAF5xLec3OzbF1r2O17BbVxIi7hzJIC64IYhXdJA+nh/5xVbOmE9J0QqjSxWk0pp37M2YEtgjS8GpimACu7xkqxdKJ6fEXyYl2Lre0ZtC8yELVewtWUnbfCPIhrvgDFz8WI5yhJKgcnFMZWEFrwhgzo5uWDDDA1oGSOzcu0xfx7vTlsv6posIMpJ6cGWPiw/BxL4PU7vbrpjgf8bMdu5OYwOdhm83DARUSa0ELknYIeEAaILuWxlhGa0M8+EuJCrpJT+ymENhN60pXBxa3LZ5TsucnlGaCmIEQ4Evru91yuz0xMtKaeXluI5zdh9Mm8vAlBn4aR07X64EH3vEKdXQkZJXPP/JxMvNRpLxEtHZ5RQgmNewnpouvVTpYTHdfOnmy5kFUGnpRTfEhXD9DiBdFFJB0/YWS9aj6pmc89r0BaQmgTRkgI+EsdKsYasJZOBF+QqTH474NK7LbyBvf7W+RgOxNyxfQY2/2hrp2+NkroxrzrQ55fSZkpJIa28znCgF6rb7H1hOSslATyvNflAh9pvHcX3lVE/Ya8FjTJIexa2Rq77nfU96unTnD7aME3+TAm6BFKYrPnqCNIqV5sq0ZGCiEV+Db+qWMQqpFgb5KPx48R6omeDl2EuP9DTYt9iGA/f1KBS1w/La+H4ktsSmLItvZHXLUkrCeflVtJ9DVVg1H7+sxiGvVM975rZpfabuqHVhuP5F1vewav5O8GamUe91yDanoYw47FWzC929O+DJnKA2opFY1Rjru5CE7kOcO0jJtQVUIynzuZEMeb+1CEOFXN8iFSGeRpCm1BTlJxVg49Azm819SO7Bu0axEbwn27GuxMck+TMQHDP8fn48gfDVIL4R8xKVPJ73MQBUIfA/Z54LMw5vmlE+w+VFo2A78X/SsyPA/RMD0z3e2qVLtfo7aeBslpMX0N0TEnLcUlKym1jyBFqSohmYntI5enBhYB9CY/2kNarhwJhNiMtRGyWnkQdKaCFyQwgydjyNUw4VchKxXv2/DoKdC+lkQbCX1NlKCGvJiBJkSGbCus6jfo4yGBNySgr+u7e20BCsxdVAcFlJ/tHd32+cIsNxSXUULUUx+dg/d47g7OPYFw2MxkSuyMwLHVTI6PBN6dS8Sppw45zHJSgDXV3aQzmz40Z6fDgBfiAXU0uZxby2zejee+j3eltoQMzhV6qSBogXwrEXDj7ElWxUQ8RrnSaoU0dxIsKaiMvMykXTu90NqJsGHP4z78SdLigUrLKat32nFwy/E07pfDFRdQ/7N5r57pQ1482uvWhMGhQcviGkVrKDUp0ToCxfhQal5n4Hs/g1jOgH4LWdwFOd1b1WzHET4vLZppv+Czjxo840OrDlG8jAJzv2tp5mLK1dsU/lfIOeWy5NxFxfl2BoYImlQtx9QF6mJRQKBsQYYuO2yaLYPBUXvu/VqYPxtHhNy7Y4hCkNLGPtKSklzCVKSHtMQxcqm5Kw1DhI2PTGZtcGDAvoLQ/u7MifYtWFBlxz2H9zo8RkwKzC5UYiG+p44ccqE62YAxLeT/TOpf8MXx8Qk0IJFRY1Go+viQVJpE5Ehjf49xfAZeqGIy/7us3nqxwQfCkjZypPxobVr/6YpQHIalUvuCyEwbSXC9PC8QnkFcXlrgLpoLIhIfKuaqlQkYIAwQnr/f3eyu7KttOw2lNpv8/BPHyjzVNER3o72gvEBKqRMTflndbP8BMweRDyeciEj5bFayFXqTLzheivgYJC0jwzwHa0MDDEotm48ndze5BBBElAnxxcRYHAFh3FfZaA9UNRmC354kNwUx8eHkmVj5dcTE5ZMnuEyr1QqlhtaJLuOYZv4v3KNo0TKrGPUZ1NILPKuWcvVn5Trv10SMB6h0j/ARMnlOuafCBIfnSWEx/Raif3HDzofYMM31dOyY9LBaLK3TjoX2fEqT4+2qaUVWSTQvyM6wC8nNJyEetXIyuLKrx04P7MKNnbJZlKUtNAIHo7i2dA/YU3Vtdi5l6jCepXy8hOedSSSsI8/HQg5Q+gxTKXwkMHkbESo+hjG0lbRRzQ3Fc5LOzDuFhs3Ptumpie7ilRDhlEJOq/hjsZljCxjkt7fWuPS/EekpXMggJQIk0G+eN9Xu2VmHWIkJe0nJRN4ptBBit2yutG9ML7J1DHAxebiAMrZ4VZlduqGS8I2tJc2iborUxmIN79c+kTovFxivPvrcSaP3n7RSKYTUmKt4N3rMOcw4JOneD3sP956jNaMglIeTER5Xbdlt15Tm2W10NEsYrA/N5JLCHHsR9tSqwxq08G3bqm1ZTbOtagnbo6SLvH/VzBL7W7jPzqFea0LmMLFzUuLtdwumuO3i1Vtq7OK15Xgw3l1PDmIXak+6QBEkvB9YJIzBcc/L20JIYaSZ/qAzVm5Ut4oowk3QehC+N3xo/1wTqt7zsYawfX9no9XjqdPXVLhrwyo/wucJYQkE1e4j8rLcBuHUItQQKqgMXb6LGvxFQlXw33AdZLR0V5P9Fr29lP73scNnosoyvdWPv4fPJ+uJrLVtMakqaL1M1cTvv0OLIZE6wk2a2IcIRUQh+DaejpdcXepBa7bKDRGM9PIVxTl2EwarZ72rooVuY4RQtMypdk6e1lLLehhY2lt7QEd7WxlCDvdIli6E9B4+ZIodmZEMccUGqgiZOqru9tkR3iJ8nCcXRWRZCSPMLPEjlx2LjQL1OM5qKAm+vhSuRqSfV5Ttrg8FdWcrnhMqCTex7DEM6qTsVEuM1+8hovaHQ6e6a1Fz0xLd3nUt4ToWWuzWNkhcoAIIjUx2ZpxjLzWF9+SYmngR1lok4TEoJxGfuijhI/7OICoFmadl2llcL9b1oRVJtbD+JLlv1KrhHG5811t9ELbzgk14ICUwqE+TDzftqHPz98vUSy3jSIwP8dCpkNqLDPTx+rArz4T5qLG3G2PrvJKKPoLBWE501NC3ilUX5mVjVIb9nIbgWcpPMiSXjbcL8K62UkR86m1/yfkSeMaHFuK04X0CE3J6SWzFUxw0BSNHlSzi3RmIRJwHq5udO3c16quLp6sbnffbupxbt+12vzOrzuvNHc7ycRbIxuJHgYU7YSASdQgxp7qz2ynv6HJeqW91doa7nLruXof+17sqhhu31Xif9o7HalqczV29Dnrb/f5EXZvzdH27U98/6LR5i3N0UM5zjHU71/lwjRWWltU5CAIn7F1MqLp/r9hQ5RoaxG+qmrxP4yNKcfsFLwuiprffeb2l03m2scO5h3Or2rudzjGrhk8x4Cqu2xcexilBvNEcdi5Yu4tKF3Ue4tzPy+td5/1md4tzw5iJ27NuXEYobYUdlb8z6GTWkdxaCvk2zHjd5mpKQ459mv5TkAp6mQb9Aq9HHQ8S6mrZnuc6vUG6WHusIhCJGNXl9byvnJyaiE7+Eoz8c5TYNQiUveENGpJpcIJ+biS8R0+rlcazGNs7pKB+zPLTOSX2KNWhlDAf4r2Spj72JORB5OyHULX+dlD/FOky/HFy5ygYU0sey/i8moeqdunXK1qC3RuaMOYHlI/raQMl3M+EeTV5WxD3Km8a8PkM8nr648sQ9+esKbf5e/nxiKBfAOQkxbv3SU9LYmqPV9V/Pn+V20VwTyVjTqCI6edEQUOFUXs9WmfSll8DyX2dt7GlnwkswaM3l9XZ0oNK3MTXbxpOV2sGk69s6XCJw4cY8KbyRrt9TrHt7Bm0rRBQe1+fHUWNfaapU0KbqxzbORC1M/LS3dJwIl3KOrwykQG/E+61q+isgniztdOKqNOziDgZqZIzFwPvqGiyg5NCtoCqoG5NxHhPZTOsnORulKskjoKMDeLuXQ3OmnC3syxARFXdfc57LR3OrdtrvSOOs55rnqhtcdoGhpxHdjc5EfJUuHZTlftX+G15rXPlhkrnLe59F7Lz8VGHdg8c5y2OLeMZ126qduq9XC3v7nd+FchLvYPJd15gPCu8XQnh/qpm59WGVudZzvvQO97kXTcGxhnEuJvR39tWY8cwK4uhcikk4a3Gdstg9l5B2t0wfaTdWkEou5vCPOV5PH73vFL3+DfXltnh6OxjkJD6Wd5F3g88tMe6CW/7YmI99VIL4u0oqUK8ocW4d8hFrXMVoOQU8s3U97MnjvDD/XRYkyhHM1MT3GVZQR2Tdv70U8EbA5vlo+CaPAaaSWoZXm50otGodxQ6L6txGKxzw5ZYORrBsPPrykZKQIy1n8bTjwb2fO4Te3ue7x6KOKvaYns1wtIddd4nx3mwot55qyl2360cp81zurg+CGqwU8v4/Of5uAVvPgObrwvHomY8jOtZ4fXWLnefdHVXv9044+8ZklCx75DXwcV1Sb27y+vInUQEuVYSaMgRJYfAwtoj0raFxIUW1A8nz35f02qLc9Lc9lG7CBkwtUR7bf+A+5uL6ehnH9Lat+5sIEfj3Cbj3NKRvP7Rjlo7FSmqavKvpSP8MRZ7NVbQYLSkqlC9ZW4sPH18gBTcORjrhMWmQWzFmK2UsvO90qQ1oZcI8UhkCLZPtRqMy0NirobAvjIpb4/sW06qKGyPR2oGIdlazjOOTk+kLYzaaYGSp63Wz6HsXsQ51wd+LTAuZOy+8GBNq7tF+IOdDU4kENJthNID5YRafZtzZ3mDs9LbRgzixcZ2l1h83OKFbDmEd0/FiFp7DWHgp0AQGzq6nf8hPF+oa3EehOz0ziCWcm4NpBRMhX1hn571oR9wqVVSDVPtUi32sQ0vbu7scZdY9aOt2ZSEL9BEBIW+dv20AKDd9/ep09oimYqHpyImkKDuRllS4PrlHNuIqDmCJmNJQba7q1joEaUQJuR/WdXsLrJrq/L6cdJsPOyXscJ7GLKqo8cOpqhrO//yQG6oS3kZwS9xPkRB3wi7diFMtDN+PLk5m1ath+8f0Fy80dbjhvVXub+U5mEqeal27UP+dWpPlknNxW79Ak6/7Tg3UMOF52j1xA1qK7Trd6nXC+8P9ttYQcumIonLSnJtBdJNa77axw1C2x3qR4Wqnj73x9f6MbV+CCYFBZO6y51aSh3gzVrsmwzJnULEbCJC1oZ7vIZ/9Iqmfvn2u5oWO5n8fApxcuWUApum5diPgY9lrA9EtvUNOzYf8vqAcJPsU5iOh7XtXQgt2uZhjKU2amF7HQyfEYWcZk5yQ1RDKNrLcq02k/9IGmldrB93KiokPw8EB2SsoKWXO5FmxXhlckqi+3vEUvLqwok5PHVkIWAszlqzy1p54zuLpnPZ3q9bod08JlLSb5DrNxDm38Sbvsg5EBywsT7oH+3XNW3uasGirFSrxRNdCllKiPZHZzJYLZb5qEcpae3pxMCuu9oibS5/QCOiLcYUrp+MmtJeURjFdVlxzqiae6D4h40NQt54HyGv3JRo10aVfv8YhtC0pSlVKcPFuxIXahr08mzCO4VzMlLSsZuomZ+RaucU0rXsw/sfF5+osUFonWob/7TrLdaUgdpV93fl9X+VIC0Y6tek2uI8OD3J5gT2Vj9ZmP0f4IM4iY7RQ5gAAAAASUVORK5CYII=) no-repeat 50%;background-size:64px 64px;opacity:.84}.markdown-body h1:after{position:absolute;content:"";width:150%;left:-25%;height:50%;bottom:12px;border-radius:50%;background:linear-gradient(transparent 80%,rgba(77,208,225,.8));background-size:400% 200%;opacity:.6;animation:h1Animate 6s linear infinite}@keyframes h1Animate{0%{background-position:100% 100%}50%{background-position:100% 50%}to{background-position:100% 100%}}.markdown-body h2{display:block;border-bottom:4px solid #4dd0e1;position:relative;font-size:24px;padding:12px 32px;margin:30px 0}.markdown-body h2:before{width:24px;height:24px;left:0;top:0;margin:auto;background-size:24px 24px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAADGklEQVRYR81X32vTYBQ999s6mFjQgQ+DrbHiVFZYU4cDcQ/6pGhTFVYFEXGi82H+Bz448UnEF1Fx9ccEEcXpZE3d5tP2ooKiTacTHaLNpigMHDgnU9tcSbrWrkwWR0sbyEOSe885ObnfvV8IRT6oyPwoLQHBx+OVM5WJvSyEVAhnBOjt7yU/+/rr6r6l8TMO+F/EN0JQhICqQpD/xaRpcpAc9tS+M+9lBCia/oqBamK+zeDuQogQZaKJk3wcQjxSva7tGQGB2Ke1zIk3DNyMyNL+QpCnMQOaPsDAVuGAp9cjvbYc8Ec/bCYSg0zoiHilk1tHxqsqEsYlML4kjIpT/eurJxRNPweQU5VdrWaOEo1fgKAVbBgXIz73kF3R/ph+ghgdzMYWM29eAWlBJqgZaFlFYtC6nhWpaDqnSGlIlV1WjJ3DloDNgyNLncudqgX//Ucg3LxuStHGuhi8pqKCW3rqV342rwFjRznKm+/LNaN2yC237ThgF2wxcfMLeP6+ncrKzoPoKTGeLQbYbg4TNoC5iZPJY5HGVRdSNZAWYBclD3FzBQzrR8hACAKdzBzKA/4/IYioDQaOskBbpEG6PO8qKKSAEi3CnEb0Pw4oMf0OmKbTDWqh3Lw6EIiNBZi5lxh3wz4puBD5ovqAMvxhHSdFKxE1CQe3m/07TeTX4lcJdAhE+1Sv65Z5P/ByvIGTRowIZ9igbtXnmrOsbTvgj+kHBNMuBu9OdVw8EeU4nC1A0cYmAHZOTRrLhra4Z8ywnSN6vZHAFTA2WnnMfQB3qz73ddsOZM8CACFDIPSgQXqebXEgqgeZcAeEe6pXasm1f8ew3igMtAHWac0Uc/jYdyAaP0xEBwFsmgUPqbJ0NE2UKj4EGcahiOzuyhagaHpnmtgcVgTcCMuua7YdyAHbA3ArQNscVFbb4635aD6fnYaTvxxi9UNP7ddMXaRWVBdAcaLk6bDXPZCNZ9uBXEsDUX1T2Cc9yjig6Z0EHg3LK8/aqf6MwJKchkXfks1+0+JtSq3qLPa23BRR1B+T/6nkfMaW1r9hPt/MLtYfTLEpP+T9FNoAAAAASUVORK5CYII=)}.markdown-body h2:after,.markdown-body h2:before{content:"";display:block;position:absolute;bottom:0}.markdown-body h2:after{right:0;width:400px;height:10px;border-top-right-radius:24px;background:linear-gradient(90deg,#fff,#4dd0e1);max-width:50vw}.markdown-body h3{margin:30px 0;font-size:18px;position:relative;padding:4px 32px;width:max-content}.markdown-body h3:before{border-bottom:2px solid #4dd0e1;width:100%;content:"";display:block;height:28px;position:absolute;left:0;top:0;bottom:-2px;margin:auto;background-size:28px 28px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABRklEQVRYR2NkGGDAOMD2M4w6YDQERkNg+ITAppcfY/8zMv3wF+NdTUrZQpUQ2PT6cz8Dw/8CkMWMDIwNvqK8jcQ6gmIHNN19EaXPx1XPyMCghrCUKcpPlGc5MY6gyAE+Fx52MjL8j3cU5a1UYWXtZGBkEAVb+p8hxU+Mby5NHQCxnKEMaskzJ37uFmUetkmMjAzrfUX4woixHBJlZAA0y2EmPPYU4enLkhGeQIqRJDsAh+UgO7duNpD3IcVykkOA2paT5ABaWE60A2hlOdEO8D3/4CMDIyMfWvySFefoaYSoROh74eFXBgYGLiTNVLGc+BC48PAnAwMDG9QBVLOcaAd8P5ox+x/jf5AjGLgYfnwnKqv9/8/PwPO/kFF/MSj0cAKiouD/0bgYoixFU8RovWgJIX1EOYCQIZTIjzpgNARGQ2DAQwAAvHBaIdB7zxsAAAAASUVORK5CYII=);background-repeat:no-repeat;animation:h3AnimationBefore 2s infinite alternate}@keyframes h3AnimationBefore{0%{width:28px}25%{width:100%}50%{width:100%}to{width:100%}}.markdown-body h3:after{content:"";display:block;width:28px;height:28px;position:absolute;border:2px solid #4dd0e1;border-radius:50%;right:-15px;top:0;bottom:0;margin:auto;background-size:28px 28px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABRklEQVRYR2NkGGDAOMD2M4w6YDQERkNg+ITAppcfY/8zMv3wF+NdTUrZQpUQ2PT6cz8Dw/8CkMWMDIwNvqK8jcQ6gmIHNN19EaXPx1XPyMCghrCUKcpPlGc5MY6gyAE+Fx52MjL8j3cU5a1UYWXtZGBkEAVb+p8hxU+Mby5NHQCxnKEMaskzJ37uFmUetkmMjAzrfUX4woixHBJlZAA0y2EmPPYU4enLkhGeQIqRJDsAh+UgO7duNpD3IcVykkOA2paT5ABaWE60A2hlOdEO8D3/4CMDIyMfWvySFefoaYSoROh74eFXBgYGLiTNVLGc+BC48PAnAwMDG9QBVLOcaAd8P5ox+x/jf5AjGLgYfnwnKqv9/8/PwPO/kFF/MSj0cAKiouD/0bgYoixFU8RovWgJIX1EOYCQIZTIjzpgNARGQ2DAQwAAvHBaIdB7zxsAAAAASUVORK5CYII=);animation:h3AnimationAfter 2s infinite alternate}@keyframes h3AnimationAfter{0%{transform:rotate(0)}10%{transform:rotate(0)}50%{transform:rotate(-1turn)}to{transform:rotate(-1turn)}}.markdown-body h4{font-size:16px}.markdown-body h5{font-size:15px}.markdown-body h6{margin-top:5px}.markdown-body p{line-height:inherit;margin:22px 0;letter-spacing:2px;font-size:14px;word-spacing:2px}.markdown-body img{max-width:80%;border-radius:6px;display:block;margin:20px auto!important;object-fit:contain;box-shadow:0 0 16px hsla(0,0%,43.1%,.45)}.markdown-body figcaption{display:block;font-size:13px;color:#2b2b2b}.markdown-body figcaption:before{content:"";background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgBAMAAACBVGfHAAAAGFBMVEVHcExAuPtAuPpAuPtAuPpAuPtAvPxAuPokzOX5AAAAB3RSTlMAkDLqNegkoiUM7wAAAGBJREFUKM9jYBhcgMkBTUDVBE1BeDGqEtXychNUBeXlKEqACsrLQxB8lnCQQClCiWt5OYoSiAIkJVAF5eVBqAqAShTAAs7l5ShKWMwRAmAlSArASpAVgJUkCqIAscESHwCVVjMBK9JnbQAAAABJRU5ErkJggg==);display:inline-block;width:18px;height:18px;background-size:18px;background-repeat:no-repeat;background-position:50%;margin-right:5px;margin-bottom:-5px}.markdown-body hr{border:none;border-top:1px solid #4dd0e1;margin-top:32px;margin-bottom:32px}.markdown-body del{color:#4dd0e1}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:rgba(77,208,225,.08);color:#26c6da;padding:.195em .4em}.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace;overflow:auto;position:relative;line-height:1.75;box-shadow:0 0 8px hsla(0,0%,43.1%,.45);border-radius:4px;margin:16px}.markdown-body pre:before{content:"";display:block;height:30px;width:100%;margin-bottom:-7px;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAdCAYAAABcz8ldAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAhgSURBVGhD7Zp7bBTHHcdn33t7vvOdzy+ITVKDU0xIKG2ABCPTRCCaUiEVKWoqRJuASAhCitRCVKSoalFUKZBiSmmFRRJKRUnUtIpo+aNqGgwoOCmuFUIRzxjwE4zte+97drYzztji8HPvtkit/PnH+n1397Tz+83vN/PbMZhmmmmm+d+BoX8n5diihcGqgFQf5vk6BMAskWUlw3GyFnIvtqWSf91w7mKC3npfOLX7wYeiIa6BBWCOLLFRF2NB0JvIOP/80YG+k2ev6S699b/OzOfKBW5l5KsgyC4DCFQDnpEAdE1goc/dlNPc/Up7P711UiYNSMuyxeUzZPnHgGHWh5XADEkSAcdiN+AnEXIBhBComgFU0/xQR+jnj51sOUMf9Z0NKyL8S9+JPBEN8zuCMrsqGOA5QWAAyzLAxe53HBeYFgJp1c5Cx33nyIfpV3e+22/Sx32nev/sMCgVnmM4bjOniAtZWQAsz315EfsGQQc4hgWcjHkCmOj1rheuNn95cXwmDMiVp5etC/D8m5FwUWVQUYYGPh6mZYFUOgsGVa1pXvOZzVT2jRuH54RM230jEuI3RcIiL4l4UkxAJmuD/riVsqD7ct2m9nep7BtVTbVfZ0uE/UIk+CQflAHDjf8+Lg6MldYATGpH3c/Ul7p3dWXppVGM6eElJSHmnQWPbSlRlN1lJcUBjqNRnwJZVQO3B5P/uq5rK1d90pakckFcaKp5UJHY92JR8YlwkUDVySEZfGfQdO7E7Z8s2HL9TSoXTPXRud9nA8IBqSwcZgWeqpPj6BYw7yTbXBN9q2v9lQEq5zBmWA8vWLCptCi4tzwW8RQMQlFQATPLSh6vCSh/plJBkMyQBHZfWYnkKRgEktEVpTJXERN2Xzo4ex2VC6K6qXYpF5b3ypVRT8EgcAERSJXRbwCBOTFzXblM5RxGBaRt+ZPYA+LO0mgxz5K1Ig+UgAzKIuGnz39z6S+olDeaibaXRsU1RUFvgx+GwTWgPCaDgMw2XXpr9gwq50XV0bkxJiYeEiNF5cwE5XsiOEkAUkXkUW51SSOVchjl8WKef604XFSRbzCGCYeCoESStv/p8QU1VPIM3knNDynctnBRfsEYhgSlNCIGgQv2UCkvGIHZgteMh1nBW9W4F16RAM6yDVV7amZTaYQcr59cuuhhWRTWBvAMLxQGeyFSHOLnh0MvUskz5RF+fbRYDEy0mZgqQYUHOLhr//b6rGoqeaLqQG0pw3PrBbyA+4EQUkRmhvgqNUfICUipKK4OKUqIJVPKB0jpEhjmWWp64jdbKmVZZNYogcJm493gsifOqhDyeh9GYR/FM7sW+DA5CKR0MSK3tvKZkpwB5gRE4tjFEr7RL0iWBGV51vHFCyupNGWWPqLgnoer9mtyEGSJAzwLllDTGzyznDjRN/CwOFkoFb4bm0eVIXICgpvdGoEvrF7fC89zfLkkeV5HbOhWiTwTpKYvCAJLGshRdXtKMKAWlyxq+MPQLk1h66g5RE5ABJYNFrqY3wvJklJRUKg5ZWLFXIA86yek2uDOPkBNb3CM5Pf7DL2QyIrUGiLH+xC5Bmmm/ARnHUhC6PnzxWDK0RH5HuIjZGy27erU9AZ0dTIWXyG+NpBBrSFySxZw220IqeUPFoS6jVAPNadM7yDsgNB1qOkLuAziMYIb1PQGA75wIaKGPyAb+9oF16g5RE5ALIQ+tSyLWoWDEAK6aXW3JlK9VJoyx1oyvVkNdvo5KXXDAVkdnaKmNwx0xjH98w3JNmTCm+Bc9hKVhsgJSI9pvp9Vdd++jmq6AXB2/HHrhcs5aTkVDv0DFzoHvKdq/mQsKX/4t7KJLDpOJW+IbAvMGoMkxfwAWZB8DT7W1diTE+WcgKz6pK1bs6z3daPwmJDsSKt6ZsCyjlLJMz0DsDGZ8SdlDROBjOb8YeWOjptU8kTXusuaazu7oJrfEnQvdkpVcUn6PTVHyAkIIW7br/Unklni0EJIZ1WgGsauZR+fvUglz6zY0dGfVp09ybRNlfwgi3k8YSbvJJ29VMoLt9v6rZVQL7hOYUubndHJGclBtzn1byqNMCogi09/2nFb01/oj+f/5TyjauBOKtPcZ1r7qZQ3f2lRfxZPWi2anp8TSDAGExZMa2jr8u03L1M5L7q3Xc+iAeuHRl/ScvPcjSLDBnZS/cjtNHd2v3171Ewbs9N5q7Pn4otVMx3btBsCsoRbk1FxG5dMVgMDqfTpXl1/tuFMa5zKefPROdX59qLQBwLnNog8Wy1OcjB1N+QEsW/QsFNZuO35Xb1v98QLX4/Sx+O3wqujrQ6013ABUWI8+AaqBjAH01+ghL22+5X2PirnMG7r+esbnae/V1neauvGSoHjigTcVU7UGFm2DeK4ttxKpQ+mLPvl+o/PjnkAkw9HTqSMmVHhyAMx9iFcSh/BHTfLceO/C8mKjApBf9zszGhoY92m9sN+BGOY9AeD7eGniv8OTaOB4dgyTsQd9wS+IQu4lciYdkI7CLrNH3Rvbb9FL41i0tbzVP2iWJkobpN5fmM4IJfJskTP1Bk8A9HQmbpmGDBrWqdVCN/Yd7PjxKGOXn+bmbto3feVVcVB9qehIL8EJy8nChwgr0O2xxBnhGU5eP2CfYbl/m4gBRsbtneMORP9oGpjpcCsiKzHHfdOPiQ/wMniyFEu2dbiTQCAeN/vavC466BGYLttXc9fmXBXMGlAhiHHur+sq6uPiUI9z7CVHMPwBnLSuuN8FuC48/Oaz1ylt94XfrW5ouyprwWfYRkwNyCyYYjwkBHows1fa+tV/fzGxlv39b9gqvfPmQ+i/HK8KlcBjhHwfl8HEHyOd1JnuzZd66S3TTPNNNP8/wDAfwDG7G0m9LKBpwAAAABJRU5ErkJggg==) 10px 10px no-repeat;background-size:40px}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{color:#4dd0e1;border-bottom:1px solid #4dd0e1;font-weight:400;text-decoration:none;margin:0 4px}.markdown-body a:active,.markdown-body a:hover{background-color:rgba(77,208,225,.1)}.markdown-body strong{color:#26c6da}.markdown-body strong:before{content:"「"}.markdown-body strong:after{content:"」"}.markdown-body em{font-style:normal;color:#4dd0e1;font-weight:700}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:rgba(77,208,225,.05)}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{margin:2em 0;padding:24px 32px;border-left:4px solid #26c6da;background:rgba(77,208,225,.15);position:relative}.markdown-body blockquote:before{content:"❝";top:8px;left:8px;color:#4dd0e1;font-size:30px;line-height:1;font-weight:700;position:absolute;opacity:.7}.markdown-body blockquote:after{content:"❞";font-size:30px;position:absolute;right:8px;bottom:0;color:#4dd0e1;opacity:.7}.markdown-body blockquote p{color:#595959;line-height:2}.markdown-body ol,.markdown-body ul{color:#595959;padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="agate">.markdown-body pre,.markdown-body pre&gt;code.hljs{background:#333;color:#fff}.hljs-name,.hljs-strong{font-weight:700}.hljs-code,.hljs-emphasis{font-style:italic}.hljs-tag{color:#62c8f3}.hljs-selector-class,.hljs-selector-id,.hljs-template-variable,.hljs-variable{color:#ade5fc}.hljs-bullet,.hljs-string{color:#a2fca2}.hljs-attribute,.hljs-built_in,.hljs-builtin-name,.hljs-quote,.hljs-section,.hljs-title,.hljs-type{color:#ffa}.hljs-bullet,.hljs-number,.hljs-symbol{color:#d36363}.hljs-keyword,.hljs-literal,.hljs-selector-tag{color:#fcc28c}.hljs-code,.hljs-comment,.hljs-deletion{color:#888}.hljs-link,.hljs-regexp{color:#c6b4f0}.hljs-meta{color:#fc9b9b}.hljs-deletion{background-color:#fc9b9b;color:#333}.hljs-addition{background-color:#a2fca2;color:#333}.hljs a{color:inherit}.hljs a:focus,.hljs a:hover{color:inherit;text-decoration:underline}</style><h2 data-id="heading-0">一、方案背景</h2>
<p>在国际化项目开发过程中，多语言资源（locales语言包）的管理通常要经历下面的流程：</p>
<ol>
<li>开发人员通过机翻初步整理好一份语言包</li>
<li>把语言包转成Excel交付给翻译团队人工翻译</li>
<li>把人工翻译好的Excel重新转换为语言包且需保证其正确性</li>
</ol>
<p>这种手动转换的方式存在效率低下、容易出错的问题。因此需要设计一套自动转换方案，实现语言包和Excel的自动化双向转换。</p>
<h2 data-id="heading-1">二、方案目标</h2>
<ol>
<li>实现语言包和Excel的自动化双向转换。</li>
<li>Excel需包含"功能模块"列，方便定位语言包中字段对应页面的具体位置。</li>
<li>若存在中文语言包，转换成Excel时把中文列放在其它语言列前面，方便翻译对照。</li>
<li>基于TypeScript的项目，需提供完整的类型支持。</li>
</ol>
<h2 data-id="heading-2">三、技术选型与目录结构设计</h2>
<h3 data-id="heading-3">3.1 技术选型</h3>
<ul>
<li>核心框架：Vue3 + Vite + TypeScript</li>
<li>国际化方案：vue-i18n</li>
<li>语言包格式：YAML（支持注释功能）</li>
<li>表格处理：xlsx 库</li>
<li>自动化工具：Node.js脚本，脚本可以考虑大模型实现</li>
</ul>
<h3 data-id="heading-4">3.2 目录结构</h3>
<pre><code class="hljs language-plaintext" lang="plaintext">├── package.json                  # 项目依赖与脚本配置
├── vite.config.ts                # Vite配置文件
├── build/
│   └── vite-plugin-i18n-types.ts # 自动生成类型声明的Vite插件
├── scripts/
│   └── i18n/
│       ├── yaml2xlsx.js          # YAML转Excel脚本
│       ├── xlsx2yaml.js          # Excel转YAML脚本
│       └── output/
│           ├── translations.xlsx # 生成的Excel文件
│           └── locales/          # 从Excel生成的语言包
├── types/
│   └── i18n.d.ts                 # 自动生成的类型声明文件
└── src/
    ├── i18n/
    │   ├── index.ts              # i18n配置入口
    │   └── locales/
    │       ├── zh-CN.yaml        # 中文语言包
    │       ├── en-US.yaml        # 英文语言包
    │       └── ...               # 其他语言包
    └── ...                       # 其他业务代码
</code></pre>
<h2 data-id="heading-5">四、核心实现方案</h2>
<h3 data-id="heading-6">4.1 语言包设计</h3>
<p>采用yaml文件管理语言包。</p>
<blockquote>
<p>为什么不用更常用的json格式？
脚本在把语言包转换为Excel文件时，需要根据一些标记（如注释）来生成【功能模块】列，而json格式不支持注释。
js或ts也支持注释，但属于特定开发语言的格式，而非数据序列化格式，不够通用。
yaml是支持注释、开发语言无关的数据序列化格式，但对于TypeScript类型不友好，需要额外支持，不过这个问题解决了，后面会提到。所以最终选择了yaml格式。</p>
</blockquote>
<p>zh-CN.yaml示例：</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-comment"># 首页</span>
<span class="hljs-attr">home:</span>
  <span class="hljs-comment"># 导航栏</span>
  <span class="hljs-attr">navbar:</span>
    <span class="hljs-attr">title:</span> <span class="hljs-string">'首页'</span>
<span class="hljs-comment"># 登录页</span>
<span class="hljs-attr">login:</span>
  <span class="hljs-comment"># 表单</span>
  <span class="hljs-attr">form:</span>
    <span class="hljs-attr">username:</span> <span class="hljs-string">'用户名'</span>
    <span class="hljs-attr">password:</span> <span class="hljs-string">'密码'</span>
</code></pre>
<p>en-US.yaml示例：</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-comment"># 首页</span>
<span class="hljs-attr">home:</span>
  <span class="hljs-comment"># 导航栏</span>
  <span class="hljs-attr">navbar:</span>
    <span class="hljs-attr">title:</span> <span class="hljs-string">'Home'</span>
<span class="hljs-comment"># 登录页</span>
<span class="hljs-attr">login:</span>
  <span class="hljs-comment"># 表单</span>
  <span class="hljs-attr">form:</span>
    <span class="hljs-attr">username:</span> <span class="hljs-string">'Username'</span>
    <span class="hljs-attr">password:</span> <span class="hljs-string">'Password'</span>
</code></pre>
<h3 data-id="heading-7">4.2 YAML转Excel实现（yaml2xlsx.js）</h3>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">import</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">'fs'</span>
<span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">'path'</span>
<span class="hljs-keyword">import</span> { fileURLToPath } <span class="hljs-keyword">from</span> <span class="hljs-string">'url'</span>
<span class="hljs-keyword">import</span> yaml <span class="hljs-keyword">from</span> <span class="hljs-string">'yaml'</span>
<span class="hljs-keyword">import</span> <span class="hljs-variable constant_">XLSX</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'xlsx'</span>
<span class="hljs-keyword">import</span> yargs <span class="hljs-keyword">from</span> <span class="hljs-string">'yargs'</span>
<span class="hljs-keyword">import</span> { hideBin } <span class="hljs-keyword">from</span> <span class="hljs-string">'yargs/helpers'</span>

<span class="hljs-comment">// 获取当前文件的目录路径</span>
<span class="hljs-keyword">const</span> __filename = <span class="hljs-title function_">fileURLToPath</span>(<span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">url</span>)
<span class="hljs-keyword">const</span> __dirname = path.<span class="hljs-title function_">dirname</span>(__filename)

<span class="hljs-comment">/**
 * 反转义YAML单引号字符串中的转义序列
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">str</span> - 要反转义的字符串
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">string</span>} 反转义后的字符串
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">unescapeSingleQuotes</span>(<span class="hljs-params">str</span>) {
  <span class="hljs-comment">// 将两个连续的单引号转义为一个单引号</span>
  <span class="hljs-keyword">return</span> str.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/''/g</span>, <span class="hljs-string">"'"</span>)
}

<span class="hljs-comment">/**
 * 解析YAML文件并提取注释路径
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">filePath</span> - YAML文件路径
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">Object</span>} 解析后的数据对象，包含键值对和模块路径
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">parseYamlWithComments</span>(<span class="hljs-params">filePath</span>) {
  <span class="hljs-comment">// 读取YAML文件内容</span>
  <span class="hljs-keyword">const</span> content = fs.<span class="hljs-title function_">readFileSync</span>(filePath, <span class="hljs-string">'utf8'</span>)
  <span class="hljs-comment">// 按行分割内容</span>
  <span class="hljs-keyword">const</span> lines = content.<span class="hljs-title function_">split</span>(<span class="hljs-string">'\n'</span>)
  <span class="hljs-keyword">const</span> result = {}
  <span class="hljs-comment">// 注释栈，用于存储当前层级的注释</span>
  <span class="hljs-keyword">const</span> commentStack = []

  <span class="hljs-comment">// 当前路径栈和注释路径栈</span>
  <span class="hljs-keyword">let</span> currentPath = []
  <span class="hljs-keyword">let</span> currentCommentPath = []

  <span class="hljs-comment">// 遍历每一行</span>
  lines.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">line, index</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> trimmedLine = line.<span class="hljs-title function_">trim</span>()

    <span class="hljs-comment">// 如果是注释行</span>
    <span class="hljs-keyword">if</span> (trimmedLine.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">'#'</span>)) {
      <span class="hljs-comment">// 提取注释内容（去掉#号并去除前后空格）</span>
      <span class="hljs-keyword">const</span> comment = trimmedLine.<span class="hljs-title function_">substring</span>(<span class="hljs-number">1</span>).<span class="hljs-title function_">trim</span>()
      <span class="hljs-keyword">if</span> (comment) {
        <span class="hljs-comment">// 将注释压入栈中</span>
        commentStack.<span class="hljs-title function_">push</span>(comment)
      }
      <span class="hljs-keyword">return</span> <span class="hljs-comment">// 注释行不进行后续处理</span>
    }

    <span class="hljs-comment">// 如果是键值对行（包含冒号且不是注释）</span>
    <span class="hljs-keyword">if</span> (trimmedLine.<span class="hljs-title function_">includes</span>(<span class="hljs-string">':'</span>) &amp;&amp; !trimmedLine.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">'#'</span>)) {
      <span class="hljs-comment">// 提取键名</span>
      <span class="hljs-keyword">const</span> key = trimmedLine.<span class="hljs-title function_">split</span>(<span class="hljs-string">':'</span>)[<span class="hljs-number">0</span>].<span class="hljs-title function_">trim</span>()
      <span class="hljs-comment">// 计算缩进级别（通过行首空格数量）</span>
      <span class="hljs-keyword">const</span> indent = line.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/^\s*/</span>)[<span class="hljs-number">0</span>].<span class="hljs-property">length</span>

      <span class="hljs-comment">// 计算当前层级（假设使用2空格缩进）</span>
      <span class="hljs-keyword">const</span> level = indent / <span class="hljs-number">2</span>

      <span class="hljs-comment">// 根据层级更新路径栈（移除超出当前层级的部分）</span>
      currentPath = currentPath.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, level)
      currentCommentPath = currentCommentPath.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, level)

      <span class="hljs-comment">// 将当前键添加到路径栈</span>
      currentPath.<span class="hljs-title function_">push</span>(key)

      <span class="hljs-comment">// 处理注释路径</span>
      <span class="hljs-keyword">if</span> (commentStack.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-comment">// 如果有注释，将其添加到注释路径栈</span>
        currentCommentPath.<span class="hljs-title function_">push</span>(commentStack.<span class="hljs-title function_">pop</span>())
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (currentCommentPath.<span class="hljs-property">length</span> &lt; level &amp;&amp; currentCommentPath.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-comment">// 如果没有注释但需要继承父级注释，使用父级注释</span>
        currentCommentPath.<span class="hljs-title function_">push</span>(currentCommentPath[currentCommentPath.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>])
      }

      <span class="hljs-comment">// 检查是否是叶子节点（包含值的节点）</span>
      <span class="hljs-keyword">const</span> valueMatch = trimmedLine.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/:\s*(.+)$/</span>)
      <span class="hljs-keyword">if</span> (valueMatch &amp;&amp; valueMatch[<span class="hljs-number">1</span>].<span class="hljs-title function_">trim</span>()) {
        <span class="hljs-comment">// 提取值并去除前后空格</span>
        <span class="hljs-keyword">let</span> value = valueMatch[<span class="hljs-number">1</span>].<span class="hljs-title function_">trim</span>()

        <span class="hljs-comment">// 去除可能存在的单引号（YAML字符串有时会用引号包裹）</span>
        <span class="hljs-keyword">if</span> (value.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">"'"</span>) &amp;&amp; value.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">"'"</span>)) {
          value = value.<span class="hljs-title function_">substring</span>(<span class="hljs-number">1</span>, value.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>)
          <span class="hljs-comment">// 反转义单引号（将两个单引号转义为一个单引号）</span>
          value = unescapeSingleQuotes(value)
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">'"'</span>) &amp;&amp; value.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">'"'</span>)) {
          value = value.<span class="hljs-title function_">substring</span>(<span class="hljs-number">1</span>, value.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>)
          <span class="hljs-comment">// 如果需要，也可以处理双引号的转义</span>
        }

        <span class="hljs-comment">// 构建完整的键路径（用点号连接）</span>
        <span class="hljs-keyword">const</span> fullKey = currentPath.<span class="hljs-title function_">join</span>(<span class="hljs-string">'.'</span>)
        <span class="hljs-comment">// 构建模块路径（用斜杠连接注释）</span>
        <span class="hljs-keyword">const</span> modulePath = currentCommentPath.<span class="hljs-title function_">join</span>(<span class="hljs-string">'/'</span>)

        <span class="hljs-comment">// 将结果存储到对象中</span>
        result[fullKey] = {
          <span class="hljs-attr">value</span>: value,
          <span class="hljs-attr">module</span>: modulePath,
        }
      }
    }

    <span class="hljs-comment">// 重置注释栈（注释只对下一行有效）</span>
    <span class="hljs-keyword">if</span> (!trimmedLine.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">'#'</span>) &amp;&amp; trimmedLine !== <span class="hljs-string">''</span>) {
      commentStack.<span class="hljs-property">length</span> = <span class="hljs-number">0</span>
    }
  })

  <span class="hljs-keyword">return</span> result
}

<span class="hljs-comment">/**
 * 设置工作表的列宽
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Object</span>} <span class="hljs-variable">worksheet</span> - XLSX工作表对象
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">setColumnWidths</span>(<span class="hljs-params">worksheet</span>) {
  <span class="hljs-comment">// 定义列宽配置</span>
  <span class="hljs-keyword">const</span> colWidths = [
    { <span class="hljs-attr">wch</span>: <span class="hljs-number">30</span> }, <span class="hljs-comment">// 功能模块列宽：30字符</span>
    { <span class="hljs-attr">wch</span>: <span class="hljs-number">40</span> }, <span class="hljs-comment">// key列宽：40字符</span>
  ]

  <span class="hljs-comment">// 获取工作表的范围</span>
  <span class="hljs-keyword">const</span> range = <span class="hljs-variable constant_">XLSX</span>.<span class="hljs-property">utils</span>.<span class="hljs-title function_">decode_range</span>(worksheet[<span class="hljs-string">'!ref'</span>])
  <span class="hljs-keyword">const</span> numCols = range.<span class="hljs-property">e</span>.<span class="hljs-property">c</span> - range.<span class="hljs-property">s</span>.<span class="hljs-property">c</span> + <span class="hljs-number">1</span>

  <span class="hljs-comment">// 为语言列设置固定宽度（从第三列开始）</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt; numCols; i++) {
    colWidths.<span class="hljs-title function_">push</span>({ <span class="hljs-attr">wch</span>: <span class="hljs-number">20</span> }) <span class="hljs-comment">// 语言列宽：20字符</span>
  }

  <span class="hljs-comment">// 将列宽配置应用到工作表</span>
  worksheet[<span class="hljs-string">'!cols'</span>] = colWidths
}

<span class="hljs-comment">/**
 * 设置行高
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Object</span>} <span class="hljs-variable">worksheet</span> - XLSX工作表对象
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">setRowHeights</span>(<span class="hljs-params">worksheet</span>) {
  <span class="hljs-comment">// 获取工作表的范围</span>
  <span class="hljs-keyword">const</span> range = <span class="hljs-variable constant_">XLSX</span>.<span class="hljs-property">utils</span>.<span class="hljs-title function_">decode_range</span>(worksheet[<span class="hljs-string">'!ref'</span>])

  <span class="hljs-comment">// 遍历每一行设置行高</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> row = range.<span class="hljs-property">s</span>.<span class="hljs-property">r</span>; row &lt;= range.<span class="hljs-property">e</span>.<span class="hljs-property">r</span>; row++) {
    <span class="hljs-comment">// 确保行配置数组存在</span>
    <span class="hljs-keyword">if</span> (!worksheet[<span class="hljs-string">'!rows'</span>]) worksheet[<span class="hljs-string">'!rows'</span>] = []
    <span class="hljs-comment">// 设置行高，标题行（第0行）稍高一些</span>
    worksheet[<span class="hljs-string">'!rows'</span>][row] = { <span class="hljs-attr">hpt</span>: row === <span class="hljs-number">0</span> ? <span class="hljs-number">25</span> : <span class="hljs-number">20</span> }
  }
}

<span class="hljs-comment">/**
 * 对语言进行排序，确保zh-CN在最前面
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Array</span>} <span class="hljs-variable">languages</span> - 语言代码数组
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">Array</span>} 排序后的语言数组
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">sortLanguages</span>(<span class="hljs-params">languages</span>) {
  <span class="hljs-keyword">return</span> [...languages].<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> {
    <span class="hljs-comment">// zh-CN始终排在最前面</span>
    <span class="hljs-keyword">if</span> (a === <span class="hljs-string">'zh-CN'</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>
    <span class="hljs-keyword">if</span> (b === <span class="hljs-string">'zh-CN'</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>
    <span class="hljs-comment">// 其他语言按字母顺序排序</span>
    <span class="hljs-keyword">return</span> a.<span class="hljs-title function_">localeCompare</span>(b)
  })
}

<span class="hljs-comment">/**
 * 将目录下的所有YAML文件转换为XLSX格式
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">inputDir</span> - 输入目录路径（包含YAML文件）
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">outputFile</span> - 输出文件路径（XLSX文件）
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">convertYamlDirToXlsx</span>(<span class="hljs-params">inputDir, outputFile</span>) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-comment">// 确保输入目录存在</span>
    <span class="hljs-keyword">if</span> (!fs.<span class="hljs-title function_">existsSync</span>(inputDir)) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`输入目录不存在: <span class="hljs-subst">${inputDir}</span>`</span>)
    }

    <span class="hljs-comment">// 读取目录中的所有文件</span>
    <span class="hljs-keyword">const</span> files = fs.<span class="hljs-title function_">readdirSync</span>(inputDir)
    <span class="hljs-comment">// 过滤出YAML文件（支持.yaml和.yml扩展名）</span>
    <span class="hljs-keyword">const</span> yamlFiles = files.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">file</span>) =&gt;</span> file.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">'.yaml'</span>) || file.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">'.yml'</span>))

    <span class="hljs-comment">// 如果没有找到YAML文件，提示并退出</span>
    <span class="hljs-keyword">if</span> (yamlFiles.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'未找到YAML文件'</span>)
      <span class="hljs-keyword">return</span>
    }

    <span class="hljs-comment">// 收集所有语言的数据</span>
    <span class="hljs-keyword">const</span> allData = {}
    <span class="hljs-keyword">const</span> languages = []

    <span class="hljs-comment">// 处理每个YAML文件</span>
    yamlFiles.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">file</span>) =&gt;</span> {
      <span class="hljs-comment">// 构建完整的文件路径</span>
      <span class="hljs-keyword">const</span> filePath = path.<span class="hljs-title function_">join</span>(inputDir, file)
      <span class="hljs-comment">// 从文件名提取语言代码（去掉扩展名）</span>
      <span class="hljs-keyword">const</span> language = path.<span class="hljs-title function_">basename</span>(file, path.<span class="hljs-title function_">extname</span>(file))
      <span class="hljs-comment">// 将语言代码添加到语言数组</span>
      languages.<span class="hljs-title function_">push</span>(language)

      <span class="hljs-comment">// 解析YAML文件</span>
      <span class="hljs-keyword">const</span> parsedData = <span class="hljs-title function_">parseYamlWithComments</span>(filePath)

      <span class="hljs-comment">// 将解析后的数据按key组织</span>
      <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(parsedData).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">[key, data]</span>) =&gt;</span> {
        <span class="hljs-comment">// 如果该key尚未存在，初始化数据结构</span>
        <span class="hljs-keyword">if</span> (!allData[key]) {
          allData[key] = {
            <span class="hljs-attr">module</span>: data.<span class="hljs-property">module</span>,
            <span class="hljs-attr">translations</span>: {},
          }
        }
        <span class="hljs-comment">// 存储该语言的翻译值</span>
        allData[key].<span class="hljs-property">translations</span>[language] = data.<span class="hljs-property">value</span>
      })
    })

    <span class="hljs-comment">// 对语言进行排序，确保zh-CN在最前面</span>
    <span class="hljs-keyword">const</span> sortedLanguages = <span class="hljs-title function_">sortLanguages</span>([...<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(languages)])

    <span class="hljs-comment">// 准备XLSX数据</span>
    <span class="hljs-keyword">const</span> worksheetData = []

    <span class="hljs-comment">// 添加表头行</span>
    <span class="hljs-keyword">const</span> headers = [<span class="hljs-string">'功能模块'</span>, <span class="hljs-string">'key'</span>, ...sortedLanguages]
    worksheetData.<span class="hljs-title function_">push</span>(headers)

    <span class="hljs-comment">// 添加数据行</span>
    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(allData).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">[key, data]</span>) =&gt;</span> {
      <span class="hljs-comment">// 创建新行：功能模块和key</span>
      <span class="hljs-keyword">const</span> row = [data.<span class="hljs-property">module</span>, key]

      <span class="hljs-comment">// 按排序后的语言顺序添加翻译值</span>
      sortedLanguages.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">language</span>) =&gt;</span> {
        <span class="hljs-comment">// 如果该语言有翻译值则添加，否则为空字符串</span>
        row.<span class="hljs-title function_">push</span>(data.<span class="hljs-property">translations</span>[language] || <span class="hljs-string">''</span>)
      })

      <span class="hljs-comment">// 将行添加到工作表数据</span>
      worksheetData.<span class="hljs-title function_">push</span>(row)
    })

    <span class="hljs-comment">// 创建新的workbook和工作表</span>
    <span class="hljs-keyword">const</span> workbook = <span class="hljs-variable constant_">XLSX</span>.<span class="hljs-property">utils</span>.<span class="hljs-title function_">book_new</span>()
    <span class="hljs-keyword">const</span> worksheet = <span class="hljs-variable constant_">XLSX</span>.<span class="hljs-property">utils</span>.<span class="hljs-title function_">aoa_to_sheet</span>(worksheetData)

    <span class="hljs-comment">// 设置列宽和行高</span>
    <span class="hljs-title function_">setColumnWidths</span>(worksheet)
    <span class="hljs-title function_">setRowHeights</span>(worksheet)

    <span class="hljs-comment">// 添加样式：标题行加粗并居中对齐</span>
    <span class="hljs-keyword">const</span> headerRange = <span class="hljs-variable constant_">XLSX</span>.<span class="hljs-property">utils</span>.<span class="hljs-title function_">decode_range</span>(worksheet[<span class="hljs-string">'!ref'</span>])
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> col = headerRange.<span class="hljs-property">s</span>.<span class="hljs-property">c</span>; col &lt;= headerRange.<span class="hljs-property">e</span>.<span class="hljs-property">c</span>; col++) {
      <span class="hljs-keyword">const</span> cellAddress = <span class="hljs-variable constant_">XLSX</span>.<span class="hljs-property">utils</span>.<span class="hljs-title function_">encode_cell</span>({ <span class="hljs-attr">r</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">c</span>: col })
      <span class="hljs-comment">// 如果单元格存在，设置样式</span>
      <span class="hljs-keyword">if</span> (worksheet[cellAddress]) {
        worksheet[cellAddress].<span class="hljs-property">s</span> = {
          <span class="hljs-attr">font</span>: { <span class="hljs-attr">bold</span>: <span class="hljs-literal">true</span> },
          <span class="hljs-attr">alignment</span>: { <span class="hljs-attr">vertical</span>: <span class="hljs-string">'center'</span>, <span class="hljs-attr">horizontal</span>: <span class="hljs-string">'center'</span> },
        }
      }
    }

    <span class="hljs-comment">// 添加worksheet到workbook</span>
    <span class="hljs-variable constant_">XLSX</span>.<span class="hljs-property">utils</span>.<span class="hljs-title function_">book_append_sheet</span>(workbook, worksheet, <span class="hljs-string">'翻译数据'</span>)

    <span class="hljs-comment">// 确保输出目录存在</span>
    <span class="hljs-keyword">const</span> outputDir = path.<span class="hljs-title function_">dirname</span>(outputFile)
    <span class="hljs-keyword">if</span> (!fs.<span class="hljs-title function_">existsSync</span>(outputDir)) {
      <span class="hljs-comment">// 递归创建目录</span>
      fs.<span class="hljs-title function_">mkdirSync</span>(outputDir, { <span class="hljs-attr">recursive</span>: <span class="hljs-literal">true</span> })
    }

    <span class="hljs-comment">// 写入文件</span>
    <span class="hljs-variable constant_">XLSX</span>.<span class="hljs-title function_">writeFile</span>(workbook, outputFile)

    <span class="hljs-comment">// 输出成功信息</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`✅ 转换完成！`</span>)
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`📁 输入目录: <span class="hljs-subst">${inputDir}</span>`</span>)
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`📄 输出文件: <span class="hljs-subst">${outputFile}</span>`</span>)
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`🌐 处理了 <span class="hljs-subst">${yamlFiles.length}</span> 个语言文件: <span class="hljs-subst">${sortedLanguages.join(<span class="hljs-string">', '</span>)}</span>`</span>)
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`📊 列顺序: 功能模块, key, <span class="hljs-subst">${sortedLanguages.join(<span class="hljs-string">', '</span>)}</span>`</span>)
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-comment">// 错误处理</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'❌ 转换过程中发生错误:'</span>, error.<span class="hljs-property">message</span>)
    process.<span class="hljs-title function_">exit</span>(<span class="hljs-number">1</span>)
  }
}

<span class="hljs-comment">// 配置命令行参数</span>
<span class="hljs-keyword">const</span> argv = <span class="hljs-title function_">yargs</span>(<span class="hljs-title function_">hideBin</span>(process.<span class="hljs-property">argv</span>))
  .<span class="hljs-title function_">option</span>(<span class="hljs-string">'input'</span>, {
    <span class="hljs-attr">alias</span>: <span class="hljs-string">'i'</span>,
    <span class="hljs-attr">type</span>: <span class="hljs-string">'string'</span>,
    <span class="hljs-attr">description</span>: <span class="hljs-string">'YAML文件所在目录路径'</span>,
    <span class="hljs-attr">default</span>: <span class="hljs-string">'./locales'</span>,
  })
  .<span class="hljs-title function_">option</span>(<span class="hljs-string">'output'</span>, {
    <span class="hljs-attr">alias</span>: <span class="hljs-string">'o'</span>,
    <span class="hljs-attr">type</span>: <span class="hljs-string">'string'</span>,
    <span class="hljs-attr">description</span>: <span class="hljs-string">'输出的XLSX文件路径'</span>,
    <span class="hljs-attr">default</span>: <span class="hljs-string">'./output/translations.xlsx'</span>,
  })
  .<span class="hljs-title function_">option</span>(<span class="hljs-string">'config'</span>, {
    <span class="hljs-attr">alias</span>: <span class="hljs-string">'c'</span>,
    <span class="hljs-attr">type</span>: <span class="hljs-string">'string'</span>,
    <span class="hljs-attr">description</span>: <span class="hljs-string">'配置文件路径'</span>,
  })
  .<span class="hljs-title function_">help</span>() <span class="hljs-comment">// 添加帮助信息</span>
  .<span class="hljs-title function_">alias</span>(<span class="hljs-string">'help'</span>, <span class="hljs-string">'h'</span>) <span class="hljs-comment">// 设置帮助命令别名</span>
  .<span class="hljs-title function_">version</span>() <span class="hljs-comment">// 添加版本信息</span>
  .<span class="hljs-title function_">alias</span>(<span class="hljs-string">'version'</span>, <span class="hljs-string">'v'</span>).<span class="hljs-property">argv</span> <span class="hljs-comment">// 设置版本命令别名 // 解析命令行参数</span>

<span class="hljs-comment">/**
 * 主函数
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"/>) {
  <span class="hljs-comment">// 如果有配置文件，读取配置文件</span>
  <span class="hljs-keyword">if</span> (argv.<span class="hljs-property">config</span>) {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-comment">// 解析配置文件路径</span>
      <span class="hljs-keyword">const</span> configPath = path.<span class="hljs-title function_">resolve</span>(process.<span class="hljs-title function_">cwd</span>(), argv.<span class="hljs-property">config</span>)
      <span class="hljs-comment">// 读取并解析配置文件</span>
      <span class="hljs-keyword">const</span> config = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(fs.<span class="hljs-title function_">readFileSync</span>(configPath, <span class="hljs-string">'utf8'</span>))

      <span class="hljs-comment">// 合并配置参数（命令行参数优先于配置文件）</span>
      <span class="hljs-keyword">const</span> finalInput = argv.<span class="hljs-property">input</span> !== <span class="hljs-string">'./locales'</span> ? argv.<span class="hljs-property">input</span> : config.<span class="hljs-property">input</span> || <span class="hljs-string">'./locales'</span>
      <span class="hljs-keyword">const</span> finalOutput =
        argv.<span class="hljs-property">output</span> !== <span class="hljs-string">'./output/translations.xlsx'</span>
          ? argv.<span class="hljs-property">output</span>
          : config.<span class="hljs-property">output</span> || <span class="hljs-string">'./output/translations.xlsx'</span>

      <span class="hljs-comment">// 执行转换</span>
      <span class="hljs-title function_">convertYamlDirToXlsx</span>(finalInput, finalOutput)
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'❌ 读取配置文件失败:'</span>, error.<span class="hljs-property">message</span>)
      process.<span class="hljs-title function_">exit</span>(<span class="hljs-number">1</span>)
    }
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// 直接使用命令行参数</span>
    <span class="hljs-title function_">convertYamlDirToXlsx</span>(argv.<span class="hljs-property">input</span>, argv.<span class="hljs-property">output</span>)
  }
}

<span class="hljs-title function_">main</span>()
</code></pre>
<h3 data-id="heading-8">4.3 Excel转YAML实现（xlsx2yaml.js）</h3>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">import</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">'fs'</span>
<span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">'path'</span>
<span class="hljs-keyword">import</span> { fileURLToPath } <span class="hljs-keyword">from</span> <span class="hljs-string">'url'</span>
<span class="hljs-keyword">import</span> <span class="hljs-variable constant_">XLSX</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'xlsx'</span>
<span class="hljs-keyword">import</span> yargs <span class="hljs-keyword">from</span> <span class="hljs-string">'yargs'</span>
<span class="hljs-keyword">import</span> { hideBin } <span class="hljs-keyword">from</span> <span class="hljs-string">'yargs/helpers'</span>

<span class="hljs-comment">// 获取当前文件的目录路径</span>
<span class="hljs-keyword">const</span> __filename = <span class="hljs-title function_">fileURLToPath</span>(<span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">url</span>)
<span class="hljs-keyword">const</span> __dirname = path.<span class="hljs-title function_">dirname</span>(__filename)

<span class="hljs-comment">/**
 * 读取XLSX文件并解析为结构化数据
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">filePath</span> - XLSX文件路径
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">Object</span>} 包含语言数据和注释映射的对象
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">parseXlsxFile</span>(<span class="hljs-params">filePath</span>) {
  <span class="hljs-comment">// 读取XLSX文件</span>
  <span class="hljs-keyword">const</span> workbook = <span class="hljs-variable constant_">XLSX</span>.<span class="hljs-title function_">readFile</span>(filePath)
  <span class="hljs-comment">// 获取第一个工作表</span>
  <span class="hljs-keyword">const</span> worksheet = workbook.<span class="hljs-property">Sheets</span>[workbook.<span class="hljs-property">SheetNames</span>[<span class="hljs-number">0</span>]]
  <span class="hljs-comment">// 将工作表数据转换为JSON</span>
  <span class="hljs-keyword">const</span> jsonData = <span class="hljs-variable constant_">XLSX</span>.<span class="hljs-property">utils</span>.<span class="hljs-title function_">sheet_to_json</span>(worksheet, { <span class="hljs-attr">header</span>: <span class="hljs-number">1</span> })

  <span class="hljs-keyword">if</span> (jsonData.<span class="hljs-property">length</span> &lt; <span class="hljs-number">2</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'XLSX文件数据不足，至少需要表头和数据行'</span>)
  }

  <span class="hljs-comment">// 提取表头（第一行）</span>
  <span class="hljs-keyword">const</span> headers = jsonData[<span class="hljs-number">0</span>]
  <span class="hljs-comment">// 验证表头结构</span>
  <span class="hljs-keyword">if</span> (headers[<span class="hljs-number">0</span>] !== <span class="hljs-string">'功能模块'</span> || headers[<span class="hljs-number">1</span>] !== <span class="hljs-string">'key'</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'XLSX文件格式不正确，前两列应为"功能模块"和"key"'</span>)
  }

  <span class="hljs-comment">// 提取语言列（从第三列开始）</span>
  <span class="hljs-keyword">const</span> languages = headers.<span class="hljs-title function_">slice</span>(<span class="hljs-number">2</span>)

  <span class="hljs-comment">// 初始化数据结构</span>
  <span class="hljs-keyword">const</span> result = {
    <span class="hljs-attr">languages</span>: languages,
    <span class="hljs-attr">data</span>: {},
    <span class="hljs-attr">comments</span>: {}, <span class="hljs-comment">// 存储注释映射关系</span>
  }

  <span class="hljs-comment">// 处理每一行数据（跳过表头）</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; jsonData.<span class="hljs-property">length</span>; i++) {
    <span class="hljs-keyword">const</span> row = jsonData[i]
    <span class="hljs-keyword">if</span> (!row || row.<span class="hljs-property">length</span> &lt; <span class="hljs-number">3</span>) <span class="hljs-keyword">continue</span>

    <span class="hljs-keyword">const</span> modulePath = row[<span class="hljs-number">0</span>] <span class="hljs-comment">// 功能模块路径</span>
    <span class="hljs-keyword">const</span> key = row[<span class="hljs-number">1</span>] <span class="hljs-comment">// 键路径</span>

    <span class="hljs-comment">// 为每种语言存储键值对</span>
    languages.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">lang, index</span>) =&gt;</span> {
      <span class="hljs-keyword">const</span> value = row[<span class="hljs-number">2</span> + index] || <span class="hljs-string">''</span>
      <span class="hljs-keyword">if</span> (!result.<span class="hljs-property">data</span>[lang]) {
        result.<span class="hljs-property">data</span>[lang] = {}
      }

      <span class="hljs-comment">// 使用点号分隔的键路径设置嵌套对象</span>
      <span class="hljs-title function_">setNestedValue</span>(result.<span class="hljs-property">data</span>[lang], key, value)
    })

    <span class="hljs-comment">// 处理注释映射</span>
    <span class="hljs-keyword">if</span> (modulePath) {
      <span class="hljs-comment">// 将功能模块路径与键路径关联</span>
      result.<span class="hljs-property">comments</span>[key] = modulePath
    }
  }

  <span class="hljs-keyword">return</span> result
}

<span class="hljs-comment">/**
 * 根据点号分隔的路径设置嵌套对象的值
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Object</span>} <span class="hljs-variable">obj</span> - 目标对象
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">path</span> - 点号分隔的路径
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">*</span>} <span class="hljs-variable">value</span> - 要设置的值
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">setNestedValue</span>(<span class="hljs-params">obj, path, value</span>) {
  <span class="hljs-keyword">const</span> keys = path.<span class="hljs-title function_">split</span>(<span class="hljs-string">'.'</span>)
  <span class="hljs-keyword">let</span> current = obj

  <span class="hljs-comment">// 遍历路径，创建嵌套对象</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; keys.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i++) {
    <span class="hljs-keyword">const</span> key = keys[i]
    <span class="hljs-keyword">if</span> (!current[key] || <span class="hljs-keyword">typeof</span> current[key] !== <span class="hljs-string">'object'</span>) {
      current[key] = {}
    }
    current = current[key]
  }

  <span class="hljs-comment">// 设置最终的值</span>
  current[keys[keys.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>]] = value
}

<span class="hljs-comment">/**
 * 构建注释映射，将注释分配到正确的YAML层级
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Object</span>} <span class="hljs-variable">commentsMap</span> - 原始的注释映射
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">Object</span>} 按YAML层级组织的注释映射
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">buildHierarchicalComments</span>(<span class="hljs-params">commentsMap</span>) {
  <span class="hljs-keyword">const</span> hierarchicalComments = {}

  <span class="hljs-comment">// 遍历所有键和对应的注释路径</span>
  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(commentsMap).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">[key, commentPath]</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> keyParts = key.<span class="hljs-title function_">split</span>(<span class="hljs-string">'.'</span>)
    <span class="hljs-keyword">const</span> commentParts = commentPath.<span class="hljs-title function_">split</span>(<span class="hljs-string">'/'</span>)

    <span class="hljs-comment">// 为每个层级构建注释</span>
    <span class="hljs-keyword">let</span> currentPath = <span class="hljs-string">''</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; keyParts.<span class="hljs-property">length</span>; i++) {
      <span class="hljs-comment">// 构建当前路径</span>
      currentPath = currentPath ? <span class="hljs-string">`<span class="hljs-subst">${currentPath}</span>.<span class="hljs-subst">${keyParts[i]}</span>`</span> : keyParts[i]

      <span class="hljs-comment">// 如果当前层级有对应的注释部分，则分配注释</span>
      <span class="hljs-keyword">if</span> (i &lt; commentParts.<span class="hljs-property">length</span>) {
        <span class="hljs-comment">// 确保每个路径只分配一次注释（取第一个出现的）</span>
        <span class="hljs-keyword">if</span> (!hierarchicalComments[currentPath]) {
          hierarchicalComments[currentPath] = commentParts[i]
        }
      }
    }
  })

  <span class="hljs-keyword">return</span> hierarchicalComments
}

<span class="hljs-comment">/**
 * 转义字符串中的单引号，用于YAML单引号字符串
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">str</span> - 要转义的字符串
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">string</span>} 转义后的字符串
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">escapeSingleQuotes</span>(<span class="hljs-params">str</span>) {
  <span class="hljs-comment">// 将单引号转义为两个单引号</span>
  <span class="hljs-keyword">return</span> str.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/'/g</span>, <span class="hljs-string">"''"</span>)
}

<span class="hljs-comment">/**
 * 格式化YAML值，确保字符串使用单引号包裹并正确处理转义
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">*</span>} <span class="hljs-variable">value</span> - 要格式化的值
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">string</span>} 格式化后的YAML值表示
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">formatYamlValue</span>(<span class="hljs-params">value</span>) {
  <span class="hljs-keyword">if</span> (value === <span class="hljs-literal">null</span> || value === <span class="hljs-literal">undefined</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">"''"</span> <span class="hljs-comment">// 空值用空字符串表示</span>
  }

  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">'boolean'</span>) {
    <span class="hljs-keyword">return</span> value.<span class="hljs-title function_">toString</span>() <span class="hljs-comment">// 布尔值直接输出</span>
  }

  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">'number'</span>) {
    <span class="hljs-keyword">return</span> value.<span class="hljs-title function_">toString</span>() <span class="hljs-comment">// 数字直接输出</span>
  }

  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">'string'</span>) {
    <span class="hljs-comment">// 空字符串用空字符串表示</span>
    <span class="hljs-keyword">if</span> (value === <span class="hljs-string">''</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-string">"''"</span>
    }

    <span class="hljs-comment">// 转义字符串中的单引号</span>
    <span class="hljs-keyword">const</span> escapedValue = escapeSingleQuotes(value)

    <span class="hljs-comment">// 检查是否需要引号（包含特殊字符）</span>
    <span class="hljs-keyword">const</span> needsQuotes =
      <span class="hljs-regexp">/[:{}\[\],&amp;*#?|&lt;&gt;=!%@`]/</span>.<span class="hljs-title function_">test</span>(value) ||
      value.<span class="hljs-title function_">trim</span>() !== value ||
      value.<span class="hljs-title function_">includes</span>(<span class="hljs-string">'\n'</span>) ||
      value.<span class="hljs-title function_">includes</span>(<span class="hljs-string">'\t'</span>)

    <span class="hljs-keyword">if</span> (needsQuotes) {
      <span class="hljs-keyword">return</span> <span class="hljs-string">`'<span class="hljs-subst">${escapedValue}</span>'`</span> <span class="hljs-comment">// 需要引号的情况</span>
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// 简单字符串可以不加引号，但为了统一风格，我们仍然使用单引号</span>
      <span class="hljs-keyword">return</span> <span class="hljs-string">`'<span class="hljs-subst">${escapedValue}</span>'`</span>
    }
  }

  <span class="hljs-comment">// 其他类型（如对象、数组）不应该出现在这里</span>
  <span class="hljs-keyword">return</span> <span class="hljs-string">`'<span class="hljs-subst">${escapeSingleQuotes(<span class="hljs-built_in">String</span>(value))}</span>'`</span>
}

<span class="hljs-comment">/**
 * 将对象转换为YAML格式字符串，并添加注释
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Object</span>} <span class="hljs-variable">data</span> - 要转换的数据对象
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Object</span>} <span class="hljs-variable">commentsMap</span> - 注释映射关系
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">string</span>} YAML格式的字符串
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">objectToYamlWithComments</span>(<span class="hljs-params">data, commentsMap</span>) {
  <span class="hljs-comment">// 构建层级化的注释映射</span>
  <span class="hljs-keyword">const</span> hierarchicalComments = <span class="hljs-title function_">buildHierarchicalComments</span>(commentsMap)

  <span class="hljs-keyword">let</span> yamlContent = <span class="hljs-string">''</span>
  <span class="hljs-keyword">let</span> indentLevel = <span class="hljs-number">0</span>

  <span class="hljs-comment">/**
   * 递归处理对象，生成带注释的YAML
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Object</span>} <span class="hljs-variable">obj</span> - 当前处理的对象
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">currentPath</span> - 当前路径
   */</span>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">processObject</span>(<span class="hljs-params">obj, currentPath = <span class="hljs-string">''</span></span>) {
    <span class="hljs-keyword">const</span> keys = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj)

    keys.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> {
      <span class="hljs-keyword">const</span> value = obj[key]
      <span class="hljs-keyword">const</span> newPath = currentPath ? <span class="hljs-string">`<span class="hljs-subst">${currentPath}</span>.<span class="hljs-subst">${key}</span>`</span> : key
      <span class="hljs-keyword">const</span> indent = <span class="hljs-string">'  '</span>.<span class="hljs-title function_">repeat</span>(indentLevel)

      <span class="hljs-comment">// 检查当前路径是否有注释</span>
      <span class="hljs-keyword">if</span> (hierarchicalComments[newPath]) {
        <span class="hljs-comment">// 添加注释（缩进与当前层级相同）</span>
        yamlContent += <span class="hljs-string">`<span class="hljs-subst">${indent}</span># <span class="hljs-subst">${hierarchicalComments[newPath]}</span>\n`</span>
      }

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">'object'</span> &amp;&amp; value !== <span class="hljs-literal">null</span>) {
        <span class="hljs-comment">// 如果是嵌套对象，添加键并递归处理</span>
        yamlContent += <span class="hljs-string">`<span class="hljs-subst">${indent}</span><span class="hljs-subst">${key}</span>:\n`</span>
        indentLevel++
        <span class="hljs-title function_">processObject</span>(value, newPath)
        indentLevel--
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// 如果是叶子节点，格式化值并添加键值对</span>
        <span class="hljs-keyword">const</span> formattedValue = <span class="hljs-title function_">formatYamlValue</span>(value)
        yamlContent += <span class="hljs-string">`<span class="hljs-subst">${indent}</span><span class="hljs-subst">${key}</span>: <span class="hljs-subst">${formattedValue}</span>\n`</span>
      }
    })
  }

  <span class="hljs-comment">// 开始处理根对象</span>
  <span class="hljs-title function_">processObject</span>(data)
  <span class="hljs-keyword">return</span> yamlContent
}

<span class="hljs-comment">/**
 * 从XLSX文件生成YAML语言包
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">inputFile</span> - 输入的XLSX文件路径
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">outputDir</span> - 输出的YAML文件目录
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">convertXlsxToYaml</span>(<span class="hljs-params">inputFile, outputDir</span>) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-comment">// 确保输入文件存在</span>
    <span class="hljs-keyword">if</span> (!fs.<span class="hljs-title function_">existsSync</span>(inputFile)) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`输入文件不存在: <span class="hljs-subst">${inputFile}</span>`</span>)
    }

    <span class="hljs-comment">// 解析XLSX文件</span>
    <span class="hljs-keyword">const</span> parsedData = <span class="hljs-title function_">parseXlsxFile</span>(inputFile)
    <span class="hljs-keyword">const</span> { languages, data, comments } = parsedData

    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`📊 检测到 <span class="hljs-subst">${languages.length}</span> 种语言: <span class="hljs-subst">${languages.join(<span class="hljs-string">', '</span>)}</span>`</span>)
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`📝 处理了 <span class="hljs-subst">${<span class="hljs-built_in">Object</span>.keys(data[languages[<span class="hljs-number">0</span>]] || {}).length}</span> 个键值对`</span>)

    <span class="hljs-comment">// 确保输出目录存在</span>
    <span class="hljs-keyword">if</span> (!fs.<span class="hljs-title function_">existsSync</span>(outputDir)) {
      fs.<span class="hljs-title function_">mkdirSync</span>(outputDir, { <span class="hljs-attr">recursive</span>: <span class="hljs-literal">true</span> })
    }

    <span class="hljs-comment">// 为每种语言生成YAML文件</span>
    languages.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">lang</span>) =&gt;</span> {
      <span class="hljs-keyword">if</span> (!data[lang]) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">`⚠️  语言 <span class="hljs-subst">${lang}</span> 没有数据，跳过生成`</span>)
        <span class="hljs-keyword">return</span>
      }

      <span class="hljs-comment">// 生成带注释的YAML内容</span>
      <span class="hljs-keyword">const</span> yamlContent = <span class="hljs-title function_">objectToYamlWithComments</span>(data[lang], comments)

      <span class="hljs-comment">// 构建输出文件路径</span>
      <span class="hljs-keyword">const</span> outputFile = path.<span class="hljs-title function_">join</span>(outputDir, <span class="hljs-string">`<span class="hljs-subst">${lang}</span>.yaml`</span>)

      <span class="hljs-comment">// 写入文件</span>
      fs.<span class="hljs-title function_">writeFileSync</span>(outputFile, yamlContent, <span class="hljs-string">'utf8'</span>)

      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`✅ 生成 <span class="hljs-subst">${lang}</span>.yaml`</span>)
    })

    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`🎉 转换完成！`</span>)
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`📁 输出目录: <span class="hljs-subst">${outputDir}</span>`</span>)
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'❌ 转换过程中发生错误:'</span>, error.<span class="hljs-property">message</span>)
    process.<span class="hljs-title function_">exit</span>(<span class="hljs-number">1</span>)
  }
}

<span class="hljs-comment">// 配置命令行参数</span>
<span class="hljs-keyword">const</span> argv = <span class="hljs-title function_">yargs</span>(<span class="hljs-title function_">hideBin</span>(process.<span class="hljs-property">argv</span>))
  .<span class="hljs-title function_">option</span>(<span class="hljs-string">'input'</span>, {
    <span class="hljs-attr">alias</span>: <span class="hljs-string">'i'</span>,
    <span class="hljs-attr">type</span>: <span class="hljs-string">'string'</span>,
    <span class="hljs-attr">description</span>: <span class="hljs-string">'输入的XLSX文件路径'</span>,
    <span class="hljs-attr">default</span>: <span class="hljs-string">'./translations.xlsx'</span>,
  })
  .<span class="hljs-title function_">option</span>(<span class="hljs-string">'output'</span>, {
    <span class="hljs-attr">alias</span>: <span class="hljs-string">'o'</span>,
    <span class="hljs-attr">type</span>: <span class="hljs-string">'string'</span>,
    <span class="hljs-attr">description</span>: <span class="hljs-string">'输出的YAML文件目录'</span>,
    <span class="hljs-attr">default</span>: <span class="hljs-string">'./locales'</span>,
  })
  .<span class="hljs-title function_">option</span>(<span class="hljs-string">'config'</span>, {
    <span class="hljs-attr">alias</span>: <span class="hljs-string">'c'</span>,
    <span class="hljs-attr">type</span>: <span class="hljs-string">'string'</span>,
    <span class="hljs-attr">description</span>: <span class="hljs-string">'配置文件路径'</span>,
  })
  .<span class="hljs-title function_">help</span>()
  .<span class="hljs-title function_">alias</span>(<span class="hljs-string">'help'</span>, <span class="hljs-string">'h'</span>)
  .<span class="hljs-title function_">version</span>()
  .<span class="hljs-title function_">alias</span>(<span class="hljs-string">'version'</span>, <span class="hljs-string">'v'</span>).<span class="hljs-property">argv</span>

<span class="hljs-comment">/**
 * 主函数
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"/>) {
  <span class="hljs-comment">// 如果有配置文件，读取配置文件</span>
  <span class="hljs-keyword">if</span> (argv.<span class="hljs-property">config</span>) {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> configPath = path.<span class="hljs-title function_">resolve</span>(process.<span class="hljs-title function_">cwd</span>(), argv.<span class="hljs-property">config</span>)
      <span class="hljs-keyword">const</span> config = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(fs.<span class="hljs-title function_">readFileSync</span>(configPath, <span class="hljs-string">'utf8'</span>))

      <span class="hljs-comment">// 合并配置参数</span>
      <span class="hljs-keyword">const</span> finalInput =
        argv.<span class="hljs-property">input</span> !== <span class="hljs-string">'./translations.xlsx'</span> ? argv.<span class="hljs-property">input</span> : config.<span class="hljs-property">input</span> || <span class="hljs-string">'./translations.xlsx'</span>
      <span class="hljs-keyword">const</span> finalOutput = argv.<span class="hljs-property">output</span> !== <span class="hljs-string">'./locales'</span> ? argv.<span class="hljs-property">output</span> : config.<span class="hljs-property">output</span> || <span class="hljs-string">'./locales'</span>

      <span class="hljs-title function_">convertXlsxToYaml</span>(finalInput, finalOutput)
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'❌ 读取配置文件失败:'</span>, error.<span class="hljs-property">message</span>)
      process.<span class="hljs-title function_">exit</span>(<span class="hljs-number">1</span>)
    }
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// 直接使用命令行参数</span>
    <span class="hljs-title function_">convertXlsxToYaml</span>(argv.<span class="hljs-property">input</span>, argv.<span class="hljs-property">output</span>)
  }
}

<span class="hljs-title function_">main</span>()
</code></pre>
<h3 data-id="heading-9">4.4 脚本命令配置（package.json）</h3>
<p>脚本支持通过<code>-i</code>和<code>-o</code>参数自定义输入输出路径。</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>​
  <span class="hljs-attr">"scripts"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>​
    <span class="hljs-attr">"i18n:yaml2xlsx"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"node ./scripts/i18n/yaml2xlsx.js -i src/i18n/locales -o scripts/i18n/output/translation.xlsx"</span><span class="hljs-punctuation">,</span>​
    <span class="hljs-attr">"i18n:xlsx2yaml"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"node ./scripts/i18n/xlsx2yaml.js -i scripts/i18n/output/translation.xlsx -o scripts/i18n/output/locales"</span>​
  <span class="hljs-punctuation">}</span>​
<span class="hljs-punctuation">}</span>
</code></pre>
<h3 data-id="heading-10">4.5 类型自动生成方案</h3>
<p>ts默认是不支持导入yaml文件的，需要添加模块声明：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">declare</span> <span class="hljs-variable language_">module</span> <span class="hljs-string">'*.yaml'</span> {
  <span class="hljs-keyword">const</span> <span class="hljs-attr">content</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">any</span>&gt;
  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> content
}
</code></pre>
<p>这样就支持导入yaml文件了，但导入的所有ts类型都是<code>Record&lt;string, any&gt;</code>，使用<code>vue-i18n</code>时也没有类型提示：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// 无类型提示：login.?</span>
<span class="hljs-title function_">t</span>(<span class="hljs-string">'login.form.username'</span>)
</code></pre>
<p>期望的目标是：导入的yaml语言包是类型安全的，使用时可以享受类型提示。手动根据语言包yaml文件生成ts类型声明文件是重复低效的，yaml是一个结构化的文件，根据yaml文件自动生成ts类型声明文件是可行的。方案可以参考unplugin-vue-components，编写一个vite插件，根据语言包yaml文件自动生成ts类型声明文件。</p>
<p>vite-plugin-i18n-types.ts</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">import</span> { readFileSync, writeFileSync, existsSync, mkdirSync } <span class="hljs-keyword">from</span> <span class="hljs-string">'fs'</span>
<span class="hljs-keyword">import</span> { resolve, dirname } <span class="hljs-keyword">from</span> <span class="hljs-string">'path'</span>
<span class="hljs-keyword">import</span> { parse } <span class="hljs-keyword">from</span> <span class="hljs-string">'yaml'</span>
<span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> { <span class="hljs-title class_">Plugin</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'vite'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> I18nTypePluginOptions {
  <span class="hljs-attr">input</span>: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">string</span>[]
  <span class="hljs-attr">output</span>: <span class="hljs-built_in">string</span>
  typeName?: <span class="hljs-built_in">string</span>
  watch?: <span class="hljs-built_in">boolean</span>
  build?: <span class="hljs-built_in">boolean</span>
  <span class="hljs-comment">// 模块声明的路径，如 '@/i18n/locales'</span>
  modulePath?: <span class="hljs-built_in">string</span>
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">objectToTypeString</span>(<span class="hljs-params">obj: <span class="hljs-built_in">any</span>, indent = <span class="hljs-number">2</span>, level = <span class="hljs-number">1</span></span>): <span class="hljs-built_in">string</span> {
  <span class="hljs-keyword">const</span> spaces = <span class="hljs-string">' '</span>.<span class="hljs-title function_">repeat</span>(indent * level)
  <span class="hljs-keyword">const</span> entries = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(obj)

  <span class="hljs-keyword">if</span> (entries.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">'Record&lt;string, any&gt;'</span>

  <span class="hljs-keyword">const</span> <span class="hljs-attr">result</span>: <span class="hljs-built_in">string</span>[] = []

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, value] <span class="hljs-keyword">of</span> entries) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">'object'</span> &amp;&amp; value !== <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">const</span> nestedType = <span class="hljs-title function_">objectToTypeString</span>(value, indent, level + <span class="hljs-number">1</span>)
      result.<span class="hljs-title function_">push</span>(<span class="hljs-string">`<span class="hljs-subst">${spaces}</span><span class="hljs-subst">${key}</span>: <span class="hljs-subst">${nestedType}</span>`</span>)
    } <span class="hljs-keyword">else</span> {
      result.<span class="hljs-title function_">push</span>(<span class="hljs-string">`<span class="hljs-subst">${spaces}</span><span class="hljs-subst">${key}</span>: string`</span>)
    }
  }

  <span class="hljs-keyword">return</span> <span class="hljs-string">`{
<span class="hljs-subst">${result.join(<span class="hljs-string">'\n'</span>)}</span>
<span class="hljs-subst">${<span class="hljs-string">' '</span>.repeat(indent * (level - <span class="hljs-number">1</span>))}</span>}`</span>
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">i18nTypePlugin</span>(<span class="hljs-params">options: I18nTypePluginOptions</span>): <span class="hljs-title class_">Plugin</span> {
  <span class="hljs-keyword">const</span> {
    input = <span class="hljs-string">'src/i18n/locales/zh-CN.yaml'</span>,
    output = <span class="hljs-string">'types/i18n.d.ts'</span>,
    typeName = <span class="hljs-string">'I18nMessageSchema'</span>,
    watch = <span class="hljs-literal">true</span>,
    build = <span class="hljs-literal">true</span>,
    modulePath = <span class="hljs-string">'@/i18n/locales'</span>,
  } = options

  <span class="hljs-keyword">const</span> inputPaths = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(input) ? input : [input]
  <span class="hljs-keyword">const</span> resolvedInputPaths = inputPaths.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">path</span>) =&gt;</span> <span class="hljs-title function_">resolve</span>(process.<span class="hljs-title function_">cwd</span>(), path))
  <span class="hljs-keyword">const</span> resolvedOutputPath = <span class="hljs-title function_">resolve</span>(process.<span class="hljs-title function_">cwd</span>(), output)

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">generateTypes</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-comment">// 读取第一个输入文件（假设所有语言文件有相同的结构）</span>
      <span class="hljs-keyword">const</span> inputPath = resolvedInputPaths[<span class="hljs-number">0</span>]
      <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">existsSync</span>(inputPath)) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">`⚠️  File not found: <span class="hljs-subst">${inputPath}</span>`</span>)
        <span class="hljs-keyword">return</span>
      }

      <span class="hljs-keyword">const</span> yamlContent = <span class="hljs-title function_">readFileSync</span>(inputPath, <span class="hljs-string">'utf-8'</span>)
      <span class="hljs-keyword">const</span> data = <span class="hljs-title function_">parse</span>(yamlContent)
      <span class="hljs-keyword">const</span> typeDefinition = <span class="hljs-title function_">objectToTypeString</span>(data, <span class="hljs-number">2</span>)

      <span class="hljs-comment">// 构建完整的类型声明内容</span>
      <span class="hljs-keyword">let</span> content = <span class="hljs-string">`declare type <span class="hljs-subst">${typeName}</span> = <span class="hljs-subst">${typeDefinition}</span>\n`</span>

      <span class="hljs-comment">// 添加模块声明</span>
      <span class="hljs-keyword">if</span> (modulePath) {
        content += <span class="hljs-string">`
declare module '<span class="hljs-subst">${modulePath}</span>/*.yaml' {
  const content: <span class="hljs-subst">${typeName}</span>
  export default content
}

declare module '<span class="hljs-subst">${modulePath}</span>/*.yml' {
  const content: <span class="hljs-subst">${typeName}</span>
  export default content
}
`</span>
      }

      <span class="hljs-comment">// 确保输出目录存在</span>
      <span class="hljs-keyword">const</span> outputDir = <span class="hljs-title function_">dirname</span>(resolvedOutputPath)
      <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">existsSync</span>(outputDir)) {
        <span class="hljs-title function_">mkdirSync</span>(outputDir, { <span class="hljs-attr">recursive</span>: <span class="hljs-literal">true</span> })
      }

      <span class="hljs-title function_">writeFileSync</span>(resolvedOutputPath, content, <span class="hljs-string">'utf-8'</span>)
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`✅ Generated i18n types: <span class="hljs-subst">${resolvedOutputPath}</span>`</span>)
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'❌ Failed to generate i18n types:'</span>, error)
    }
  }

  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'vite-plugin-i18n-types'</span>,

    <span class="hljs-title function_">buildStart</span>(<span class="hljs-params"/>) {
      <span class="hljs-keyword">if</span> (build) {
        <span class="hljs-title function_">generateTypes</span>()
      }
    },

    <span class="hljs-title function_">configureServer</span>(<span class="hljs-params">server</span>) {
      <span class="hljs-keyword">if</span> (watch) {
        <span class="hljs-comment">// 首次生成</span>
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">generateTypes</span>(), <span class="hljs-number">100</span>)

        <span class="hljs-comment">// 监听所有输入文件</span>
        resolvedInputPaths.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">inputPath</span>) =&gt;</span> {
          <span class="hljs-keyword">if</span> (<span class="hljs-title function_">existsSync</span>(inputPath)) {
            server.<span class="hljs-property">watcher</span>.<span class="hljs-title function_">add</span>(inputPath)
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`👀 Watching: <span class="hljs-subst">${inputPath}</span>`</span>)
          }
        })

        <span class="hljs-comment">// 监听文件变化</span>
        server.<span class="hljs-property">watcher</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">'change'</span>, <span class="hljs-function">(<span class="hljs-params">changedPath</span>) =&gt;</span> {
          <span class="hljs-keyword">if</span> (resolvedInputPaths.<span class="hljs-title function_">some</span>(<span class="hljs-function">(<span class="hljs-params">path</span>) =&gt;</span> <span class="hljs-title function_">resolve</span>(path) === <span class="hljs-title function_">resolve</span>(changedPath))) {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`📄 i18n file changed: <span class="hljs-subst">${changedPath}</span>`</span>)
            <span class="hljs-title function_">generateTypes</span>()

            <span class="hljs-comment">// 发送 HMR 更新</span>
            server.<span class="hljs-property">ws</span>.<span class="hljs-title function_">send</span>({
              <span class="hljs-attr">type</span>: <span class="hljs-string">'full-reload'</span>,
              <span class="hljs-attr">path</span>: <span class="hljs-string">'*'</span>,
            })
          }
        })
      }
    },

    <span class="hljs-title function_">buildEnd</span>(<span class="hljs-params"/>) {
      <span class="hljs-keyword">if</span> (build &amp;&amp; !watch) {
        <span class="hljs-title function_">generateTypes</span>()
      }
    },
  }
}
</code></pre>
<h3 data-id="heading-11">4.6 Vite配置集成</h3>
<p>vite.config.ts</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">import</span> { defineConfig } <span class="hljs-keyword">from</span> <span class="hljs-string">'vite'</span>
<span class="hljs-keyword">import</span> i18nTypePlugin <span class="hljs-keyword">from</span> <span class="hljs-string">'./build/vite-plugin-i18n-types'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>({
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-title function_">i18nTypePlugin</span>({
      <span class="hljs-comment">// 使用哪个语言包为基准用来生成.d.ts文件</span>
      <span class="hljs-attr">input</span>: <span class="hljs-string">'src/i18n/locales/zh-CN.yaml'</span>,
      <span class="hljs-comment">// 用于生成.d.ts文件中的declare module '@/i18n/locales/*.yaml'语句</span>
      <span class="hljs-attr">modulePath</span>: <span class="hljs-string">'@/i18n/locales'</span>,
      <span class="hljs-comment">// .d.ts文件生成位置</span>
      <span class="hljs-attr">output</span>: <span class="hljs-string">'types/i18n.d.ts'</span>,
      <span class="hljs-comment">// .d.ts文件中的MessageSchema类型的名称</span>
      <span class="hljs-attr">typeName</span>: <span class="hljs-string">'I18nMessageSchema'</span>,
      <span class="hljs-attr">watch</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">build</span>: <span class="hljs-literal">true</span>,
    }),
  ],
})
</code></pre>
<p>自动生成<code>types/i18n.d.ts</code>文件</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">declare</span> <span class="hljs-keyword">type</span> I18nMessageSchema {
  <span class="hljs-attr">home</span>: {
    <span class="hljs-attr">navbar</span>: {
      <span class="hljs-attr">title</span>: <span class="hljs-built_in">string</span>
    }
  }
  <span class="hljs-attr">login</span>: {
    <span class="hljs-attr">form</span>: {
      <span class="hljs-attr">username</span>: <span class="hljs-built_in">string</span>
      <span class="hljs-attr">password</span>: <span class="hljs-built_in">string</span>
    }
  }
}

<span class="hljs-keyword">declare</span> <span class="hljs-variable language_">module</span> <span class="hljs-string">'@/i18n/locales/*.yaml'</span> {
  <span class="hljs-keyword">const</span> <span class="hljs-attr">content</span>: I18nMessageSchema
  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> content
}

<span class="hljs-keyword">declare</span> <span class="hljs-variable language_">module</span> <span class="hljs-string">'@/i18n/locales/*.yml'</span> {
  <span class="hljs-keyword">const</span> <span class="hljs-attr">content</span>: I18nMessageSchema
  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> content
}
</code></pre>
<p>上面的<code>declare module</code>语句不仅保证了引入的语言包yaml文件的类型安全，而且只限定了<code>@/i18n/locales</code>目录下的文件，不影响其它目录下的文件引入。</p>
<p>需要配合tsconfig.json:</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"include"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">"types/**/*"</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"compilerOptions"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"paths"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"@/*"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">"./src/*"</span><span class="hljs-punctuation">]</span>
    <span class="hljs-punctuation">}</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<h3 data-id="heading-12">4.7 i18n配置实现</h3>
<p>src/i18n/index.ts</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">import</span> { createI18n, useI18n } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue-i18n'</span>
<span class="hljs-comment">// zhCN和enUS都是I18nMessageSchema类型​</span>
<span class="hljs-keyword">import</span> zhCN <span class="hljs-keyword">from</span> <span class="hljs-string">'@/i18n/locales/zh-CN.yaml'</span>
<span class="hljs-keyword">import</span> enUS <span class="hljs-keyword">from</span> <span class="hljs-string">'@/i18n/locales/en-US.yaml'</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> <span class="hljs-title class_">LangCodes</span> = <span class="hljs-string">'zh-CN'</span> | <span class="hljs-string">'en-US'</span>
<span class="hljs-keyword">const</span> messages = {
  <span class="hljs-string">'zh-CN'</span>: zhCN,
  <span class="hljs-string">'en-US'</span>: enUS,
}
<span class="hljs-keyword">const</span> i18n = createI18n&lt;[I18nMessageSchema], <span class="hljs-title class_">LangCodes</span>, <span class="hljs-literal">false</span>&gt;({
  <span class="hljs-attr">legacy</span>: <span class="hljs-literal">false</span>,
  <span class="hljs-attr">locale</span>: <span class="hljs-string">'zh-CN'</span>, <span class="hljs-comment">// 默认中文​</span>
  <span class="hljs-attr">fallbackLocale</span>: <span class="hljs-string">'zh-CN'</span>,
  messages,
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> i18n
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">useGlobalI18n</span> = (<span class="hljs-params"/>) =&gt;
  useI18n&lt;{ <span class="hljs-attr">message</span>: I18nMessageSchema }&gt;({
    <span class="hljs-attr">useScope</span>: <span class="hljs-string">'global'</span>,
  })
</code></pre>
<p>在其它文件中使用：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">const</span> { t } = <span class="hljs-title function_">useGlobalI18n</span>()
<span class="hljs-comment">// 享受完整的类型提示​</span>
<span class="hljs-title function_">t</span>(<span class="hljs-string">'home.navbar.title'</span>)
</code></pre>
<h2 data-id="heading-13">五、使用流程说明</h2>
<ol>
<li>YAML 转 Excel：执行<code>pnpm i18n:yaml2xlsx</code>命令，这会扫描<code>src/i18n/locales</code>目录下的所有yaml文件，把它们转换成excel文件输出到<code>scripts/i18n/output/translation.xlsx</code>，语言包转换后的结果示例：</li>
</ol>





























<table><thead><tr><th>功能模块</th><th>key</th><th>zh-CN</th><th>en-US</th></tr></thead><tbody><tr><td>首页/导航栏</td><td>home.navbar.title</td><td>首页</td><td>Home</td></tr><tr><td>登录页/表单</td><td>login.form.username</td><td>用户名</td><td>Username</td></tr><tr><td>登录页/表单</td><td>login.form.password</td><td>密码</td><td>Password</td></tr></tbody></table>
<ol start="2">
<li>Excel 转 YAML: 执行<code>pnpm i18n:xlsx2yaml</code>命令，这会把<code>scripts/i18n/output/translation.xlsx</code>文件转换成语言包文件输出到<code>scripts/i18n/output/locales</code>目录下，而不是直接覆盖原语言包文件，这样方便开发者校对生成结果后再覆盖源码，防止可能发生的错误。</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[开箱即用的 GoWind Admin｜风行，企业级前后端一体中后台框架：OPA 集成指南：从原理到实践]]></title>    <link>https://juejin.cn/post/7583906870827646985</link>    <guid>https://juejin.cn/post/7583906870827646985</guid>    <pubDate>2025-12-15T12:34:41.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7583906870827646985" data-draft-id="7583906870827630601" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="开箱即用的 GoWind Admin｜风行，企业级前后端一体中后台框架：OPA 集成指南：从原理到实践"/> <meta itemprop="keywords" content="后端,Go"/> <meta itemprop="datePublished" content="2025-12-15T12:34:41.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="喵个咪"/> <meta itemprop="url" content="https://juejin.cn/user/1350630784901262"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            开箱即用的 GoWind Admin｜风行，企业级前后端一体中后台框架：OPA 集成指南：从原理到实践
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1350630784901262/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    喵个咪
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-15T12:34:41.000Z" title="Mon Dec 15 2025 12:34:41 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-15
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    21
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读13分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">开箱即用的 GoWind Admin｜风行，企业级前后端一体中后台框架：OPA 集成指南：从原理到实践</h2>
<p>Open Policy Agent（简称 OPA）是一款开源的通用策略引擎，核心价值在于实现“策略即代码”（Policy as Code），将分散在各系统中的权限控制、资源访问规则等策略逻辑抽离出来，进行统一管理、版本控制与执行。如今，OPA 已成为云原生生态中策略管控的事实标准，被 Netflix、Cloudflare、Pinterest、Chef 等巨头广泛应用——从内部 API 权限管控、Kubernetes 集群资源调度，到终端产品的 IAM 功能实现，均能看到其身影。</p>
<p>OPA 由 Styra 公司于 2016 年开源，2018 年加入 CNCF（云原生计算基金会）成为沙箱项目，2021 年 2 月正式毕业，其快速晋升的背后，是社区的高度活跃与行业对统一策略管控需求的迫切性。本文将从 OPA 核心原理、Rego 语言入门，逐步深入到 GoWind Admin 企业级中后台框架的完整集成流程，帮助开发者快速落地权限管控能力。</p>
<h3 data-id="heading-1">一、深入理解 OPA：核心原理与核心概念</h3>
<p>在集成 OPA 之前，我们需要先厘清其核心逻辑：OPA 不关心“谁在访问”（认证，Authentication），只专注于“能否访问”（授权，Authorization）及更广泛的策略决策（如资源部署规则、网络路由限制等）。它通过接收输入、结合外部数据、执行预定义策略，最终输出决策结果，实现策略与业务系统的解耦。</p>
<h4 data-id="heading-2">1.1 核心概念：四大核心要素</h4>
<p>宏观上，OPA 的决策过程依赖四个核心要素，四者构成完整的策略执行闭环，在 OPA 官方试炼场（<a href="https://link.juejin.cn?target=https%3A%2F%2Fplay.openpolicyagent.org" target="_blank" title="https://play.openpolicyagent.org" ref="nofollow noopener noreferrer">play.openpolicyagent.org</a>）中可直观验证其交互逻辑：</p>
<ul>
<li><strong>请求输入（Request Input）</strong>：触发策略决策的请求数据，通常包含访问主体、访问资源、访问操作等关键信息，格式为 JSON。</li>
<li><strong>外部数据（Data）</strong>：策略执行所需的补充数据（非请求自带），如用户角色列表、资源权限映射表等，可通过 OPA 的数据 API 动态注入。</li>
<li><strong>Rego 策略（Policy）</strong>：使用 OPA 专用的声明式 DSL 语言 Rego 编写的策略规则，定义“何种条件下允许/拒绝某个操作”。</li>
<li><strong>响应数据（Response）</strong>：策略执行后的决策结果，可是简单的 true/false（允许/拒绝），也可是复杂的 JSON 结构（如返回允许的资源列表、拒绝原因等）。</li>
</ul>
<h4 data-id="heading-3">1.2 微观视角：请求输入的三元组模型</h4>
<p>任何访问控制类的策略决策，其输入本质上都可抽象为“主体-资源-操作”的三元组模型：</p>
<ol>
<li>访问实体（Subject）：发起访问的主体，如用户 ID、角色、用户组等；</li>
<li>访问资源（Object）：被访问的对象，如 API 接口、数据库表、K8s 资源等；</li>
<li>访问方法（Action）：具体的操作类型，如 HTTP 的 GET/POST/PUT/DELETE，或数据库的查询/修改等。</li>
</ol>
<p>这一模型与 Casbin 高度相似，但两者核心差异在于策略描述能力：Casbin 采用简洁的表达式模型，适合简单权限场景；而 OPA 的 Rego 作为完整的 DSL 语言，支持复杂的逻辑判断、数据转换、函数调用，能应对企业级复杂策略需求（如多维度权限叠加、动态数据关联校验等）。</p>
<h3 data-id="heading-4">二、Rego 语言入门：从基础语法到完整规则</h3>
<p>Rego 是 OPA 的核心，专为策略编写设计，具有声明式、易读易写的特点。它灵感源自 Datalog 查询语言，扩展了对 JSON 结构化数据的支持，可轻松处理嵌套对象、数组等常见数据格式。以下从核心语法入手，逐步构建完整的策略规则。</p>
<h4 data-id="heading-5">2.1 基础语法：变量与赋值</h4>
<p>Rego 中的变量一旦赋值便不可修改（不可变变量），支持标量、复合类型（对象、数组、集合）等多种数据类型，赋值使用 <code>:=</code> 符号：</p>
<pre><code class="hljs language-rego" lang="rego"># 标量赋值：字符串、整数、浮点数、布尔值、空值
greeting   := "Hello"
max_height := 42
pi         := 3.14159
allowed    := true
location   := null

# 复合类型赋值
rect := {"width": 2, "height": 4}  # 对象：键值对集合
allowed_users := ["papaya", "potato"]  # 数组：有序元素集合
ips_by_port := {  # 嵌套对象：键为整数，值为数组
    80: ["1.1.1.1", "1.1.1.2"],
    443: ["2.2.2.1"],
}
</code></pre>
<h4 data-id="heading-6">2.2 逻辑判断：条件与决策块</h4>
<p>Rego 的策略规则本质是“条件判断”，通过 <code>if</code> 关键字或省略 <code>if</code> 的决策块定义“何时满足策略”。核心逻辑运算符支持 <code>==</code>、<code>!=</code>、<code>&gt;</code>、<code>&lt;</code> 等，逻辑关系通过语法结构表达：</p>
<pre><code class="hljs language-rego" lang="rego"># 基础条件判断（两种写法等价）
v if "hello" == "world"  # 条件不满足，v 为 false
t2 if {                  # 多行决策块，内部语句需全部满足
    x := 42
    y := 41
    x &gt; y                # 条件满足，t2 为 true
}

# 省略 if 关键字的简洁写法（推荐）
v { "hello" == "world" }  # 等价于上述 v 的定义
t2 {
    x := 42
    y := 41
    x &gt; y
}

# 逻辑 AND：分号分隔或多行分隔（两种写法等价）
# 需同时满足“服务器ID为app”和“协议为https”
valid_server {
    input.servers[0].id == "app"
    input.servers[0].protocols[0] == "https"
}
# 等价于：input.servers[0].id == "app"; input.servers[0].protocols[0] == "https"

# 逻辑 OR：多个同名决策块（任一满足即可）
# 满足“是管理员”或“端点公开”即允许访问
allow {
    is_admin
}
allow {
    is_endpoint_public
}
</code></pre>
<h4 data-id="heading-7">2.3 迭代遍历：some 与 every</h4>
<p>Rego 提供<code>some</code>（存在性遍历）和 <code>every</code>（全称遍历）关键字，用于处理数组、对象等可迭代数据，支持索引<code>+</code>值的双重遍历，也可通过下划线 <code>_</code> 忽略无关数据：</p>
<pre><code class="hljs language-rego" lang="rego"># 1. 数组遍历：some 关键字
arr := [1, 2, 3]
has_even {
    some val in arr  # 遍历数组中的值
    val % 2 == 0     # 存在偶数即满足
}

# 2. 索引+值遍历
has_index_1 {
    some i, val in arr  # i 为索引，val 为对应值
    i == 1 &amp;&amp; val == 2  # 索引1对应值为2即满足
}

# 3. 对象遍历：every 关键字（所有元素需满足条件）
valid_obj {
    every k, v in {"foo": "bar", "fox": "baz"} {
        startswith(k, "f")  # 所有键以f开头
        startswith(v, "b")  # 所有值以b开头
    }
}

# 4. 通配符 _：忽略无关数据
get_project_id {
    proj = input.projects[_]  # 取任意一个项目
    id := proj.id             # 获取项目ID
}
</code></pre>
<h4 data-id="heading-8">2.4 函数定义：自定义策略逻辑</h4>
<p>Rego 支持自定义函数，用于封装可复用的策略逻辑，核心特点：</p>
<ul>
<li>默认返回 <code>true/false</code>，也可显式指定返回值；</li>
<li>支持同名函数重载，但参数数量必须一致；</li>
<li>输入相同则输出必相同（纯函数特性，确保策略执行的一致性）。</li>
</ul>
<pre><code class="hljs language-rego" lang="rego"># 1. 无返回值函数（默认返回true/false）
# 判断文件是否为配置文件（满足任一后缀即返回true）
is_config_file(str) {
  contains(str, ".yaml")
}
is_config_file(str) {
  contains(str, ".yml")
}
is_config_file(str) {
  contains(str, ".json")
}

# 2. 用 else 合并同名函数（等价于上述写法，更简洁）
is_config_file2(str) {
  contains(str, ".yaml")
} else {
  contains(str, ".yml")
} else {
  contains(str, ".json")
}

# 3. 显式返回值函数
# 自定义加法函数，返回 a + b 的结果
plus_custom(a, b) := c {
    c := a + b
}
out := plus_custom(42, 43)  # out 结果为 85
</code></pre>
<h4 data-id="heading-9">2.5 完整策略示例：RBAC 权限控制</h4>
<p>结合上述语法，我们实现一个经典的 RBAC（基于角色的访问控制）策略，定义“GET 请求放行、管理员及管理员组用户全放行”的规则：</p>
<pre><code class="hljs language-rego" lang="rego">package authz  # 定义策略包（类似命名空间，避免冲突）

default allow = false  # 默认拒绝所有访问

# 规则1：放行所有 GET 请求
allow {
    input.method == "GET"
}

# 规则2：允许 admin 用户执行任何操作
allow {
    input.user == "admin"
}

# 规则3：允许 admin 用户组中的用户执行任何操作
allow {
    input.group[_] == "admin"  # 遍历用户组，存在admin即满足
}
</code></pre>
<h5 data-id="heading-10">策略测试</h5>
<p>输入以下请求数据（模拟用户 <code>user1</code> 属于 <code>dev</code> 和 <code>admin</code> 组）：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"user"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"user1"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"group"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">"dev"</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"admin"</span><span class="hljs-punctuation">]</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p>OPA 执行后输出决策结果（满足规则3，允许访问）：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"allow"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span>
<span class="hljs-punctuation">}</span>
</code></pre>
<h4 data-id="heading-11">2.6 单元测试：确保策略正确性</h4>
<p>Rego 原生支持单元测试，测试文件命名需遵循 <code>xxx_test.rego</code> 规范（与 Go 语言一致），通过 <code>with</code> 关键字模拟输入数据，验证策略是否符合预期。</p>
<h5 data-id="heading-12">测试示例</h5>
<p>创建测试文件<code>authz_test.rego</code>：</p>
<pre><code class="hljs language-rego" lang="rego">package authz  # 与被测策略包一致
import future.keywords  # 引入未来关键字（可选，增强语法兼容性）

# 测试用例1：GET 请求应被允许
test_get_allowed if {
    allow with input as {"user": "user1", "method": "GET"}
}

# 测试用例2：admin 用户应被允许
test_admin_allowed if {
    allow with input as {"user": "admin", "method": "POST"}
}

# 测试用例3：非 admin 非 GET 请求应被拒绝
test_non_admin_non_get_denied if {
    not allow with input as {"user": "user2", "method": "POST", "group": ["dev"]}
}
</code></pre>
<h5 data-id="heading-13">执行测试</h5>
<p>在策略文件所在目录执行以下命令，查看测试结果：</p>
<pre><code class="hljs language-shell" lang="shell">opa test . -v  # -v 显示详细测试日志
</code></pre>
<h5 data-id="heading-14">测试输出（成功示例）：</h5>
<pre><code class="hljs language-shell" lang="shell">authz_test.rego:
data.authz.test_get_allowed: PASS (522.5µs)
data.authz.test_admin_allowed: PASS (310.2µs)
data.authz.test_non_admin_non_get_denied: PASS (285.7µs)
--------------------------------------------------------------------------------
PASS: 3/3
</code></pre>
<h3 data-id="heading-15">三、GoWind Admin 集成 OPA 完整步骤</h3>
<p>GoWind Admin 已将 OPA 核心逻辑封装至 &lt;github.com/tx7do/kratos-authz&gt; 组件中，开发者无需重复实现引擎初始化、策略加载等底层逻辑，只需按以下步骤完成配置、依赖注入与中间件集成，即可快速启用 OPA 权限管控。</p>
<h4 data-id="heading-16">3.1 核心封装：实现 Authorizer 权限管理器</h4>
<p>首先在 <code>app/admin/service/internal/data/authorizer.go</code> 中实现权限管理器，封装 OPA 引擎初始化、策略重置（从数据库加载角色-API 权限映射）等核心能力：</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-comment">// app/admin/service/internal/data/authorizer.go</span>

<span class="hljs-keyword">package</span> data

<span class="hljs-keyword">import</span> (
	<span class="hljs-string">"context"</span>
	<span class="hljs-string">"errors"</span>

	<span class="hljs-string">"github.com/go-kratos/kratos/v2/log"</span>

	authzEngine <span class="hljs-string">"github.com/tx7do/kratos-authz/engine"</span>
	<span class="hljs-string">"github.com/tx7do/kratos-authz/engine/casbin"</span>
	<span class="hljs-string">"github.com/tx7do/kratos-authz/engine/noop"</span>

	pagination <span class="hljs-string">"github.com/tx7do/go-crud/api/gen/go/pagination/v1"</span>
	<span class="hljs-string">"github.com/tx7do/go-utils/trans"</span>
	conf <span class="hljs-string">"github.com/tx7do/kratos-bootstrap/api/gen/go/conf/v1"</span>

	<span class="hljs-string">"go-wind-admin/app/admin/service/cmd/server/assets"</span>

	adminV1 <span class="hljs-string">"go-wind-admin/api/gen/go/admin/service/v1"</span>
	userV1 <span class="hljs-string">"go-wind-admin/api/gen/go/user/service/v1"</span>
)

<span class="hljs-comment">// Authorizer 权限管理器</span>
<span class="hljs-keyword">type</span> Authorizer <span class="hljs-keyword">struct</span> {
	log *log.Helper

	roleRepo        *RoleRepo
	apiResourceRepo *ApiResourceRepo

	engine authzEngine.Engine
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewAuthorizer</span><span class="hljs-params">(
	logger log.Logger,
	cfg *conf.Bootstrap,
	roleRepo *RoleRepo,
	apiResourceRepo *ApiResourceRepo,
)</span></span> *Authorizer {
	a := &amp;Authorizer{
		log:             log.NewHelper(log.With(logger, <span class="hljs-string">"module"</span>, <span class="hljs-string">"authorizer/repo/admin-service"</span>)),
		roleRepo:        roleRepo,
		apiResourceRepo: apiResourceRepo,
	}

	a.init(cfg)

	<span class="hljs-keyword">return</span> a
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *Authorizer)</span></span> init(cfg *conf.Bootstrap) {
	a.engine = a.newEngine(cfg)

	<span class="hljs-keyword">if</span> err := a.ResetPolicies(context.Background()); err != <span class="hljs-literal">nil</span> {
		a.log.Errorf(<span class="hljs-string">"reset policies error: %v"</span>, err)
	}
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *Authorizer)</span></span> newEngine(cfg *conf.Bootstrap) authzEngine.Engine {
	<span class="hljs-keyword">if</span> cfg.Authz == <span class="hljs-literal">nil</span> {
		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
	}

	ctx := context.Background()

	<span class="hljs-keyword">switch</span> cfg.GetAuthz().GetType() {
	<span class="hljs-keyword">default</span>:
		<span class="hljs-keyword">fallthrough</span>
	<span class="hljs-keyword">case</span> <span class="hljs-string">"noop"</span>:
		state, err := noop.NewEngine(ctx)
		<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
			a.log.Errorf(<span class="hljs-string">"new noop engine error: %v"</span>, err)
			<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
		}
		<span class="hljs-keyword">return</span> state

	<span class="hljs-keyword">case</span> <span class="hljs-string">"casbin"</span>:
		state, err := casbin.NewEngine(ctx)
		<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
			a.log.Errorf(<span class="hljs-string">"init casbin engine error: %v"</span>, err)
			<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
		}
		<span class="hljs-keyword">return</span> state
	}
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *Authorizer)</span></span> Engine() authzEngine.Engine {
	<span class="hljs-keyword">return</span> a.engine
}

<span class="hljs-comment">// ResetPolicies 重置策略</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *Authorizer)</span></span> ResetPolicies(ctx context.Context) <span class="hljs-type">error</span> {
	<span class="hljs-comment">//a.log.Info("*******************reset policies")</span>

	roles, err := a.roleRepo.List(ctx, &amp;pagination.PagingRequest{NoPaging: trans.Ptr(<span class="hljs-literal">true</span>)})
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
		a.log.Errorf(<span class="hljs-string">"failed to list roles: %v"</span>, err)
		<span class="hljs-keyword">return</span> err
	}

	<span class="hljs-keyword">if</span> roles == <span class="hljs-literal">nil</span> || <span class="hljs-built_in">len</span>(roles.Items) &lt; <span class="hljs-number">1</span> {
		a.log.Warnf(<span class="hljs-string">"no roles found to set policies"</span>)
		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span> <span class="hljs-comment">// No roles to set policies</span>
	}

	apis, err := a.apiResourceRepo.List(ctx, &amp;pagination.PagingRequest{NoPaging: trans.Ptr(<span class="hljs-literal">true</span>)})
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
		a.log.Errorf(<span class="hljs-string">"failed to list APIs: %v"</span>, err)
		<span class="hljs-keyword">return</span> err
	}

	<span class="hljs-keyword">if</span> apis == <span class="hljs-literal">nil</span> || <span class="hljs-built_in">len</span>(apis.Items) &lt; <span class="hljs-number">1</span> {
		a.log.Warnf(<span class="hljs-string">"no APIs found to set policies for roles"</span>)
		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span> <span class="hljs-comment">// No APIs to set policies</span>
	}

	<span class="hljs-comment">//a.log.Debugf("roles [%d] apis [%d]", len(roles.Items), len(apis.Items))</span>

	<span class="hljs-keyword">var</span> policies authzEngine.PolicyMap

	<span class="hljs-keyword">switch</span> a.engine.Name() {
	<span class="hljs-keyword">case</span> <span class="hljs-string">"casbin"</span>:
		<span class="hljs-keyword">if</span> policies, err = a.generateCasbinPolicies(roles, apis); err != <span class="hljs-literal">nil</span> {
			a.log.Errorf(<span class="hljs-string">"generate casbin policies error: %v"</span>, err)
			<span class="hljs-keyword">return</span> err
		}

	<span class="hljs-keyword">case</span> <span class="hljs-string">"noop"</span>:
		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>

	<span class="hljs-keyword">default</span>:
		a.log.Warnf(<span class="hljs-string">"unknown engine name: %s"</span>, a.engine.Name())
		<span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">"unknown authz engine name"</span>)
	}

	<span class="hljs-comment">//a.log.Debugf("***************** policy rules len: %v", len(rules))</span>

	<span class="hljs-keyword">if</span> err = a.engine.SetPolicies(context.Background(), policies, <span class="hljs-literal">nil</span>); err != <span class="hljs-literal">nil</span> {
		a.log.Errorf(<span class="hljs-string">"set policies error: %v"</span>, err)
		<span class="hljs-keyword">return</span> err
	}
	a.log.Infof(<span class="hljs-string">"Reloaded policy rules"</span>)

	<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
}

<span class="hljs-comment">// generateCasbinPolicies 生成 Casbin 策略</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *Authorizer)</span></span> generateCasbinPolicies(roles *userV1.ListRoleResponse, apis *adminV1.ListApiResourceResponse) (authzEngine.PolicyMap, <span class="hljs-type">error</span>) {
	<span class="hljs-keyword">var</span> rules []casbin.PolicyRule
	apiSet := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">uint32</span>]<span class="hljs-keyword">struct</span>{})

	domain := <span class="hljs-string">"*"</span>

	<span class="hljs-keyword">for</span> _, role := <span class="hljs-keyword">range</span> roles.Items {
		<span class="hljs-keyword">if</span> role.GetId() == <span class="hljs-number">0</span> {
			<span class="hljs-keyword">continue</span> <span class="hljs-comment">// Skip if role or API ID is not set</span>
		}

		<span class="hljs-keyword">for</span> _, apiId := <span class="hljs-keyword">range</span> role.GetApis() {
			apiSet[apiId] = <span class="hljs-keyword">struct</span>{}{}
		}

		<span class="hljs-keyword">for</span> _, api := <span class="hljs-keyword">range</span> apis.Items {
			<span class="hljs-keyword">if</span> api.GetId() == <span class="hljs-number">0</span> {
				<span class="hljs-keyword">continue</span> <span class="hljs-comment">// Skip if role or API ID is not set</span>
			}

			<span class="hljs-keyword">if</span> _, exists := apiSet[api.GetId()]; exists {
				rules = <span class="hljs-built_in">append</span>(rules, casbin.PolicyRule{
					PType: <span class="hljs-string">"p"</span>,
					V0:    role.GetCode(),
					V1:    api.GetPath(),
					V2:    api.GetMethod(),
					V3:    domain,
				})
			}
		}
	}

	policies := authzEngine.PolicyMap{
		<span class="hljs-string">"policies"</span>: rules,
		<span class="hljs-string">"projects"</span>: authzEngine.MakeProjects(),
	}

	<span class="hljs-keyword">return</span> policies, <span class="hljs-literal">nil</span>
}
</code></pre>
<h4 data-id="heading-17">3.2 依赖注入：注册 Authorizer 到 Wire 容器</h4>
<p>GoWind Admin 使用 Wire 实现依赖注入，需修改 <code>app/admin/service/internal/data/init.go</code>，将 <code>NewAuthorizer</code> 注册到依赖容器，确保框架启动时自动初始化权限管理器：</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-comment">// app/admin/service/internal/data/init.go</span>

<span class="hljs-comment">//go:build wireinject</span>
<span class="hljs-comment">// +build wireinject</span>

<span class="hljs-keyword">package</span> data

<span class="hljs-keyword">import</span> <span class="hljs-string">"github.com/google/wire"</span>

<span class="hljs-comment">// ProviderSet 数据层依赖注入集合</span>
<span class="hljs-keyword">var</span> ProviderSet = wire.NewSet(
    NewAuthorizer,        <span class="hljs-comment">// 注册权限管理器（核心）</span>
    NewRoleRepo,          <span class="hljs-comment">// 注册角色数据仓库</span>
    NewApiResourceRepo,   <span class="hljs-comment">// 注册 API 资源数据仓库</span>
    <span class="hljs-comment">// ... 其他数据仓库（如用户仓库、菜单仓库等）</span>
)
</code></pre>
<h4 data-id="heading-18">3.3 中间件集成：嵌入 REST 服务请求链路</h4>
<p>将 OPA 权限校验中间件嵌入 REST 服务器的请求链路，实现对所有 API 接口的权限拦截。修改 <code>app/admin/service/internal/server/rest.go</code>：</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-comment">// app/admin/service/internal/server/rest.go</span>

<span class="hljs-keyword">package</span> server

<span class="hljs-comment">// NewMiddleware 创建中间件</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newRestMiddleware</span><span class="hljs-params">(
	logger log.Logger,
	authenticator authnEngine.Authenticator,
	authorizer *data.Authorizer,
)</span></span> []middleware.Middleware {
	<span class="hljs-keyword">var</span> ms []middleware.Middleware
	ms = <span class="hljs-built_in">append</span>(ms, logging.Server(logger))

	ms = <span class="hljs-built_in">append</span>(ms, selector.Server(
		authn.Server(authenticator),
		auth.Server(),
		authz.Server(authorizer.Engine()),
	).Match(newRestWhiteListMatcher()).Build())

	<span class="hljs-keyword">return</span> ms
}

<span class="hljs-comment">// NewRESTServer new an HTTP server.</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewRESTServer</span><span class="hljs-params">(
    cfg *conf.Bootstrap, logger log.Logger,
	authenticator authnEngine.Authenticator, authorizer *data.Authorizer,
)</span></span> {
    ...

	srv := rpc.CreateRestServer(cfg,
		newRestMiddleware(logger, authenticator, authorizer)...,
	)

    ...
}
</code></pre>
<h4 data-id="heading-19">3.4 配置启用：修改 auth.yaml 启用 OPA</h4>
<p>修改 <code>app/admin/service/configs/auth.yaml</code>，将权限引擎类型设置为 <code>opa</code>，启用权限校验：</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-comment"># app/admin/service/configs/auth.yaml</span>
<span class="hljs-comment"># 认证与授权配置</span>
<span class="hljs-attr">auth:</span>
  <span class="hljs-comment"># 认证配置（如 JWT、OAuth2 等，根据实际需求配置）</span>
  <span class="hljs-attr">authn:</span>
    <span class="hljs-attr">type:</span> <span class="hljs-string">"jwt"</span>
    <span class="hljs-attr">jwt:</span>
      <span class="hljs-attr">secret:</span> <span class="hljs-string">"your-jwt-secret"</span>
      <span class="hljs-attr">expires_at:</span> <span class="hljs-number">3600</span>

<span class="hljs-comment"># 授权配置（核心）</span>
<span class="hljs-attr">authz:</span>
  <span class="hljs-attr">type:</span> <span class="hljs-string">"opa"</span>  <span class="hljs-comment"># 启用 OPA 引擎（可选：opa/noop）</span>
  <span class="hljs-comment"># OPA 额外配置（可选，根据实际需求扩展）</span>
  <span class="hljs-comment"># opa:</span>
  <span class="hljs-comment">#   cache:  # 策略缓存配置</span>
  <span class="hljs-comment">#     enabled: true</span>
  <span class="hljs-comment">#     ttl: 300s  # 缓存过期时间</span>
  <span class="hljs-comment">#   watch: true  # 监听策略文件变化，动态重载（开发环境推荐）</span>
</code></pre>
<h4 data-id="heading-20">3.5 自定义模型：内嵌自定义 OPA 策略</h4>
<p>若默认的 RBAC 策略模型不满足业务需求（如支持数据权限、多租户隔离等），可自定义 Rego 策略文件，通过 Go 内置的 <code>//go:embed</code> 指令内嵌到项目中，实现策略与程序的一体化部署。</p>
<h5 data-id="heading-21">步骤 1：创建自定义策略文件</h5>
<p>在 <code>app/admin/service/cmd/server/assets/</code> 目录下创建 <code>opa_custom.rego</code>，编写自定义策略（示例：支持多租户的 RBAC 规则）：</p>
<pre><code class="hljs language-rego" lang="rego">package authz

default allow = false

# 自定义规则：租户内管理员可访问所有接口
allow {
    input.tenant_id != ""  # 租户ID非空
    input.user_role == "tenant_admin"  # 用户为租户管理员
}

# 自定义规则：普通用户仅可访问自身租户的资源
allow {
    input.tenant_id != ""
    input.user_role == "user"
    input.resource_tenant_id == input.tenant_id  # 资源租户ID与用户租户ID一致
    input.method == "GET"  # 仅允许查询操作
}

# 自定义规则：超级管理员忽略租户限制
allow {
    input.user_role == "super_admin"
}
</code></pre>
<h5 data-id="heading-22">步骤 2：内嵌策略文件</h5>
<p>修改 <code>app/admin/service/cmd/server/assets/assets.go</code>，通过 <code>//go:embed</code> 指令将自定义策略文件内嵌到程序中：</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-comment">// app/admin/service/cmd/server/assets/assets.go</span>
<span class="hljs-keyword">package</span> assets

<span class="hljs-keyword">import</span> _ <span class="hljs-string">"embed"</span>

<span class="hljs-comment">// 内嵌默认 RBAC 策略（原有）</span>
<span class="hljs-comment">//go:embed opa_rbac.rego</span>
<span class="hljs-keyword">var</span> OpaRbacRego []<span class="hljs-type">byte</span>

<span class="hljs-comment">// 内嵌自定义 OPA 策略（新增）</span>
<span class="hljs-comment">//go:embed opa_custom.rego</span>
<span class="hljs-keyword">var</span> OpaCustomRego []<span class="hljs-type">byte</span>
</code></pre>
<h5 data-id="heading-23">步骤 3：加载自定义策略</h5>
<p>修改 <code>Authorizer.newEngine</code> 方法，加载内嵌的自定义策略文件：</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-keyword">package</span> data

<span class="hljs-keyword">import</span> (
	<span class="hljs-string">"go-wind-admin/app/admin/service/cmd/server/assets"</span>
)

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *Authorizer)</span></span> newEngine(cfg *conf.Bootstrap) authzEngine.Engine {
	<span class="hljs-keyword">switch</span> cfg.GetAuthz().GetType() {
	<span class="hljs-keyword">default</span>:
		<span class="hljs-keyword">fallthrough</span>

	<span class="hljs-keyword">case</span> <span class="hljs-string">"casbin"</span>:
		state, err := opa.NewEngine(ctx,
			opa.WithModulesFromString(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>{
				<span class="hljs-string">"custom.rego"</span>: <span class="hljs-type">string</span>(assets.OpaCustomRego),
			}),
		)
		<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
			a.log.Errorf(<span class="hljs-string">"init opa engine error: %v"</span>, err)
			<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
		}

		<span class="hljs-keyword">if</span> err = state.InitModulesFromString(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>{
			<span class="hljs-string">"custom.rego"</span>: <span class="hljs-type">string</span>(assets.OpaCustomRego),
		}); err != <span class="hljs-literal">nil</span> {
			a.log.Errorf(<span class="hljs-string">"init opa modules error: %v"</span>, err)
		}

		<span class="hljs-keyword">return</span> state
	}
}
</code></pre>
<h3 data-id="heading-24">四、项目资源与参考资料</h3>
<h4 data-id="heading-25">4.1 核心项目仓库</h4>
<ul>
<li>GoWind Admin（Gitee）：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgitee.com%2Ftx7do%2Fgo-wind-admin" target="_blank" title="https://gitee.com/tx7do/go-wind-admin" ref="nofollow noopener noreferrer">gitee.com/tx7do/go-wi…</a></li>
<li>GoWind Admin（GitHub）：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ftx7do%2Fgo-wind-admin" target="_blank" title="https://github.com/tx7do/go-wind-admin" ref="nofollow noopener noreferrer">github.com/tx7do/go-wi…</a></li>
<li>Kratos-Authz（OPA/Casbin 封装组件）：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ftx7do%2Fkratos-authz" target="_blank" title="https://github.com/tx7do/kratos-authz" ref="nofollow noopener noreferrer">github.com/tx7do/krato…</a></li>
<li>OPA 官方仓库：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fopen-policy-agent%2Fopa%2F" target="_blank" title="https://github.com/open-policy-agent/opa/" ref="nofollow noopener noreferrer">github.com/open-policy…</a></li>
</ul>
<h4 data-id="heading-26">4.2 学习参考资料</h4>
<h5 data-id="heading-27">官方文档</h5>
<ul>
<li>OPA 官方网站：<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.openpolicyagent.org%2F" target="_blank" title="https://www.openpolicyagent.org/" ref="nofollow noopener noreferrer">www.openpolicyagent.org/</a></li>
<li>OPA 交互式解释器（在线测试 Rego）：<a href="https://link.juejin.cn?target=https%3A%2F%2Fplay.openpolicyagent.org%2F" target="_blank" title="https://play.openpolicyagent.org/" ref="nofollow noopener noreferrer">play.openpolicyagent.org/</a></li>
</ul>
<h5 data-id="heading-28">入门与进阶教程</h5>
<ul>
<li>《策略即代码——Open Policy Agent（OPA）简介》：<a href="https://link.juejin.cn?target=https%3A%2F%2Fcloudnative.to%2Fblog%2Fintroducing-policy-as-code-the-open-policy-agent-opa%2F" target="_blank" title="https://cloudnative.to/blog/introducing-policy-as-code-the-open-policy-agent-opa/" ref="nofollow noopener noreferrer">cloudnative.to/blog/introd…</a></li>
<li>《How to Write Your First Rules in Rego》（官方入门）：<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.styra.com%2Fblog%2Fhow-to-write-your-first-rules-in-rego-the-policy-language-for-opa%2F" target="_blank" title="https://www.styra.com/blog/how-to-write-your-first-rules-in-rego-the-policy-language-for-opa/" ref="nofollow noopener noreferrer">www.styra.com/blog/how-to…</a></li>
<li>《OPA进阶-函数与虚拟文档要分清》：<a href="https://link.juejin.cn?target=http%3A%2F%2Fblog.newbmiao.com%2F2020%2F03%2F18%2Fopa-func-and-virtual-doc.html" target="_blank" title="http://blog.newbmiao.com/2020/03/18/opa-func-and-virtual-doc.html" ref="nofollow noopener noreferrer">blog.newbmiao.com/2020/03/18/…</a></li>
<li>《OPA进阶-简洁的推导式》：<a href="https://link.juejin.cn?target=http%3A%2F%2Fblog.newbmiao.com%2F2020%2F03%2F20%2Fopa-comprehensions.html" target="_blank" title="http://blog.newbmiao.com/2020/03/20/opa-comprehensions.html" ref="nofollow noopener noreferrer">blog.newbmiao.com/2020/03/20/…</a></li>
</ul>
<h5 data-id="heading-29">实践案例</h5>
<ul>
<li>《Open Policy Agent - 快速導入 Authz 至 Microservice 架構》：<a href="https://link.juejin.cn?target=https%3A%2F%2Fengineering.linecorp.com%2Fzh-hant%2Fblog%2Fopen-policy-agent-authz-in-microservice%2F" target="_blank" title="https://engineering.linecorp.com/zh-hant/blog/open-policy-agent-authz-in-microservice/" ref="nofollow noopener noreferrer">engineering.linecorp.com/zh-hant/blo…</a></li>
<li>《Open Policy Agent: What Is OPA and How It Works (Examples)》：<a href="https://link.juejin.cn?target=https%3A%2F%2Fspacelift.io%2Fblog%2Fwhat-is-open-policy-agent-and-how-it-works" target="_blank" title="https://spacelift.io/blog/what-is-open-policy-agent-and-how-it-works" ref="nofollow noopener noreferrer">spacelift.io/blog/what-i…</a></li>
</ul>
<h3 data-id="heading-30">五、集成验证与常见问题</h3>
<h4 data-id="heading-31">5.1 集成验证步骤</h4>
<ol>
<li>启动 GoWind Admin 服务，确保 OPA 引擎初始化成功（查看日志 <code>successfully reloaded xxx policy rules</code>）；</li>
<li>通过 Postman 等工具发送请求：
<ul>
<li>未认证请求：访问需要权限的接口，应返回 401 未授权；</li>
<li>已认证但无权限：使用普通用户 Token 访问管理员接口，应返回 403 禁止访问；</li>
<li>已认证且有权限：使用管理员 Token 访问管理员接口，应返回 200 成功。</li>
</ul>
</li>
<li>修改角色-API 权限映射，调用 <code>Authorizer.ResetPolicies</code> 接口重置策略，验证权限动态更新是否生效。</li>
</ol>
<h4 data-id="heading-32">5.2 常见问题排查</h4>
<ul>
<li>OPA 引擎初始化失败：检查策略文件语法是否正确（可通过 OPA 在线试炼场验证）、内嵌文件路径是否正确；</li>
<li>权限校验不生效：确认中间件顺序（先认证后授权）、白名单配置是否正确、请求输入是否包含 <code>user</code>、<code>role</code> 等策略所需字段；</li>
<li>策略更新不生效：确保修改权限后调用了 <code>ResetPolicies</code> 方法，重新加载策略到 OPA 引擎；</li>
<li>性能问题：启用 OPA 策略缓存（配置 <code>authz.opa.cache</code>），减少重复策略计算。</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[【Agent】MemOS 源码笔记---(5)---记忆分类]]></title>    <link>https://juejin.cn/post/7583910418658459694</link>    <guid>https://juejin.cn/post/7583910418658459694</guid>    <pubDate>2025-12-15T13:35:35.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7583910418658459694" data-draft-id="7582955784569716787" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="【Agent】MemOS 源码笔记---(5)---记忆分类"/> <meta itemprop="keywords" content="算法,人工智能,深度学习"/> <meta itemprop="datePublished" content="2025-12-15T13:35:35.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="罗西的思考"/> <meta itemprop="url" content="https://juejin.cn/user/351470467691175"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            【Agent】MemOS 源码笔记---(5)---记忆分类
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/351470467691175/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    罗西的思考
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-15T13:35:35.000Z" title="Mon Dec 15 2025 13:35:35 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-15
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    9
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读35分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">【Agent】MemOS 源码笔记---(5)---记忆分类</h2>
<ul>
<li>
<p><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer">0x00 摘要</a></p>
</li>
<li>
<p><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer">0x01 记忆分类</a></p>
<ul>
<li><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer">1.1 业界分类</a></li>
<li><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer">1.2 MemOS</a></li>
</ul>
</li>
<li>
<p><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer">0x02 MemOS分类解析</a></p>
<ul>
<li><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer">2.1 维度定义</a></li>
<li><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer">2.2 核心关系解析</a></li>
</ul>
</li>
<li>
<p><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer">0x03 MemOS的具体实现</a></p>
<ul>
<li><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer">3.1 基本概念</a></li>
<li><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer">3.2 记忆生成</a></li>
</ul>
</li>
<li>
<p><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer">0x04 MemOS 记忆生命周期管理</a></p>
<ul>
<li><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer">4.1 生命周期阶段简介</a></li>
<li><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer">4.2 案例：在线教育助手的记忆生命周期</a></li>
<li><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer">4.3 自己的理解</a></li>
<li><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer">4.4 MemScheduler</a></li>
</ul>
</li>
<li>
<p><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer">0xFF 参考</a></p>
</li>
</ul>
<h3 data-id="heading-1">0x00 摘要</h3>
<p>大模型之所以“忘事”，根本在于我们对“无状态模型”里“上下文窗口”的误解。很多人把它当成一只大箩筐，认为装得越多越好；然而，事实上，上下文窗口更像一块容量有限的工作记忆。硬塞太多信息，只会同时带来如下麻烦：关键内容被噪声淹没，模型抓不住重点，上下文越长，费用和延迟也越高。</p>
<p>这不是模型偷懒，而是 Transformer 架构的先天特性。每一次调用都像重新开机：没有长期记忆，上下文一旦过长，注意力就被冗余信息扯散，于是出现遗忘、跑题、速度下降。</p>
<p>为了补上这块短板，人们在记忆上大动手脚。</p>
<p>虽然前文简略介绍了MemOS的记忆类型，但是并未深入，本文以官方文档为基础进行解读，目的是了解MemOS的记忆分类，以及其生命周期。</p>
<h3 data-id="heading-2">0x01 记忆分类</h3>
<h4 data-id="heading-3">1.1 业界分类</h4>
<p>为了更好的分析，我们先来看看业界如何对记忆进行分类。</p>
<p>在当前（截至 2025 年）主流的智能体（Agent）系统和记忆架构研究与实践中，存在多种分类方式，这些分类借鉴自认知科学，并被 AI Agent 架构不同程度地采纳。</p>
<h5 data-id="heading-4">1.1.1 整体图表</h5>
<p>先给出整体图表。</p>





















































<table><thead><tr><th>Memory 类型</th><th>特点</th><th>存储形式</th><th>典型用途</th></tr></thead><tbody><tr><td><strong>工作记忆（Working）</strong></td><td>任务级、临时、结构化</td><td>内存中的字典 / 对象</td><td>正在执行的工具调用参数、任务状态</td></tr><tr><td><strong>短期记忆（Short-term Memory）</strong></td><td>容量小、时效短、上下文相关</td><td>内存中的缓存 / 列表</td><td>当前对话、任务执行中的临时状态</td></tr><tr><td><strong>长期记忆（Long-term Memory）</strong></td><td>持久存储、可检索、结构化/非结构化</td><td>结构化数据库 / 向量库 / 知识库</td><td>用户历史、知识库、经验沉淀</td></tr><tr><td><strong>情景记忆（Episodic Memory）</strong></td><td>记录特定事件（时间+地点+内容）和对话轨迹</td><td>向量数据库 / 知识库</td><td>回忆“上次用户说...”</td></tr><tr><td><strong>语义记忆（Semantic Memory）</strong></td><td>抽象知识（事实、概念、规则），即从多次交互中提炼稳定事实</td><td>向量数据库 / 知识库</td><td>“巴黎是法国首都”</td></tr><tr><td><strong>程序性记忆（Procedural Memory）</strong></td><td>如何做某事（技能、流程）</td><td>结构化数据库 / 向量库</td><td>调用工具链、执行计划</td></tr><tr><td><strong>偏好/用户画像记忆/个性化记忆（Preference/User Profile Memory）</strong></td><td>用户兴趣、习惯、风格偏好</td><td>结构化数据库 / 向量库</td><td>个性化推荐、语气调整</td></tr></tbody></table>
<h5 data-id="heading-5">1.1.2 梳理</h5>
<p>以下分类属于笔者自己的理解，不一定正确，仅供大家参考。主要是 “感知 - 短期 - 长期” 三级时效分层体系，各层级功能与特性相对可以明确区分：</p>
<ul>
<li>感知记忆（环境感知记忆）：最瞬时的记忆形态，仅存储当下环境中的即时数据（如视觉、声音信息），无长期复用价值，仅在当前瞬间有效，需通过转化机制进入更高层级记忆才能长期保留。</li>
</ul>

<ul>
<li>
<p>短期记忆（对应 Agent 的 Session 级别数据管理），此处有两种非常类似的说法，可以混用。可能工作记忆更强调当前会话，短期记忆强调短期的对话记录。</p>
<ul>
<li>工作记忆（Working Memory）：用来处理当前会话与任务的上下文，包括当前目标、正在执行的子任务等。核心作用是保障上下文连续性与即时响应能力。容量有限，但读写频繁、延迟极低。有的方案中，工作记忆也包括最近几轮对话。</li>
<li>短期记忆：与特定会话或任务线程强绑定，即常见的 “历史对话记录”，是 LLM 推理 API 的核心基础参数，核心作用是维持单一会话内的交互连贯性。</li>
</ul>
</li>
<li>
<p>长期记忆：不依赖特定会话，可跨场景复用，包括两种分类方法：</p>
<ul>
<li>
<p>分类1（从用户角度出发）</p>
<ul>
<li>
<p>情景记忆（Episodic Memory）：负责存储用户和Agent的具体交互事件。记录过往事件与行动历程，区别于孤立事实，更侧重 “经历” 的完整留存，帮助 Agent 回忆任务执行的具体过程与场景；</p>
</li>
<li>
<p>陈述性记忆（Declarative Memory，“是什么），此处也有两种类似的说法：</p>
<ul>
<li>语义记忆（Semantic Memory”）：通过层级结构归纳用户长期信息。聚焦事实与概念的存储，如交互中积累的特定信息、概念间的关联关系，是实现个性化服务的关键（如记住用户的偏好事实）；</li>
<li>陈述性记忆：此分类和语义记忆很类似，属于将语义记忆扩大化。即， 陈述性记忆是关于事实和事件的知识 。它回答的是各种“是什么”的问题 — 无论是世界知识还是用户的具体信息。比如用户的姓名、喜欢的美食，曾遭遇过的事件等，都属于陈述性记忆 。</li>
</ul>
</li>
<li>
<p>程序性记忆（Procedural Memory，“怎么做”）：存储执行任务的规则、方法与流程，由模型权重、智能体代码、提示词策略等共同构成，相当于 Agent 的 “内在方法论”，指导其如何完成具体任务（类似人类骑自行车的技能记忆）。</p>
</li>
<li>
<p>个性化记忆：形成关于用户的持续画像。通过会话内容摘要等方式提取的用户画像信息，包括用户偏好、行为习惯、身份特征等，支撑长期交互中的个性化服务。</p>
</li>
</ul>
</li>
<li>
<p>分类2（从实际应用功能出发）：</p>
<ul>
<li>检索记忆：通过 RAG 技术对接外部知识库，核心价值是补充模型原生知识，同时减少内部知识冲突，提升信息获取的精准性与时效性。</li>
<li>通用记忆：通过预训练或后续微调沉淀的基础通用知识，构成 Agent 的核心认知底座，支撑各类基础任务的理解与执行。</li>
<li>规则记忆：以强化学习（RL）、提示词（Prompt）等方式固化的行为规范，用于约束 Agent 输出格式（如 JSON、CoT 链式推理）与行为边界，确保响应的一致性与合规性。</li>
<li>个性化记忆：通过会话内容摘要等方式提取的用户画像信息，包括用户偏好、行为习惯、身份特征等，支撑长期交互中的个性化服务。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 data-id="heading-6">1.2 MemOS</h4>
<p>MemOS对记忆有两种分类：</p>
<p>第一种是分成三个子类：</p>
<ul>
<li>结构化记忆（明文记忆）：尝试基于图的分层知识 TreeTextMemory，是结构化、层次化和知识图谱。图与向量后端会连接 Neo4j 或 Qdrant 实现生产级向量/图搜索。适合常青技能和稳定的领域专业知识。</li>
<li>激活记忆：运行时的 KV 缓存和隐藏状态（高效率），使用 KVCacheMemory （最近或稳定的上下文）加速多轮对话，高效的运行时状态缓存。适合对话中的快速重用、多轮会话。</li>
<li>参数化记忆：嵌入模型中的长期知识和技能，用适配器/LoRA 实现动态技能注入。适合可搜索、可检查、演进知识。</li>
</ul>
<p>第二种也是三个子类：</p>
<ul>
<li><code>WorkingMemory</code>: 工作记忆，临时存储</li>
<li><code>LongTermMemory</code>: 长期记忆，持久存储</li>
<li><code>UserMemory</code>: 用户记忆，个性化存储</li>
</ul>
<h3 data-id="heading-7">0x02 MemOS分类解析</h3>
<p>MemOS 这是两套完全不同的分类维度 —— 前者按 “记忆的物理形态与生命周期” 划分，后者按 “记忆的存储归属与访问优先级” 划分。二者无直接包含关系，但存在明确的动态迁移逻辑，共同支撑 MemOS 对 Agent 记忆的精细化管理。</p>
<ul>
<li>「物理形态 + 生命周期」分类（第一套）：解决 “记忆如何高效存储、快速访问” 的工程问题，通过 “工作记忆→激活记忆→长期存储” 的层级设计，平衡内存占用与访问速度；</li>
<li>「存储归属 + 访问优先级」分类（第二套）：解决 “记忆如何精准管理、个性化调用” 的功能问题，通过 “WorkingMemory→LongTermMemory→UserMemory” 的模块划分，实现 “任务实时处理、通用知识沉淀、用户个性化适配” 的目标。</li>
</ul>
<h4 data-id="heading-8">2.1 维度定义</h4>
<p>先明确两套分类的核心定义（维度本质）。</p>
<h5 data-id="heading-9">2.1.1 按「物理形态 + 生命周期」划分</h5>
<p>参数记忆（Parameter Memory）/激活记忆（Activated Memory）/结构化记忆（明文记忆） 的分类聚焦 “记忆在系统中的存在形式、存活时长”，是从工程实现角度对记忆数据的拆解，核心服务于 “资源优化”（如内存占用、计算效率），偏 “技术实现维度”：</p>

































<table><thead><tr><th>记忆类型</th><th>核心定义</th><th>物理形态</th><th>生命周期</th><th>核心作用</th></tr></thead><tbody><tr><td>参数记忆（Parameter Memory）</td><td>固化在模型权重中的 “隐性记忆”，是模型训练阶段习得的知识（非 MemOS 动态管理的记忆）。</td><td>模型参数（权重矩阵）</td><td>长期固定（除非模型微调）</td><td>提供 Agent 基础认知能力（如语言理解、通用逻辑），是其他记忆发挥作用的前提。</td></tr><tr><td>激活记忆（Activated Memory）</td><td>从长期存储中 “临时唤醒” 并加载到内存的记忆片段（如近期高频访问的知识、正在处理的任务相关记忆）。</td><td>内存中的结构化数据（节点、关系、向量）</td><td>中短期（任务执行期间 / 闲置超时后释放）</td><td>作为 “缓冲层”，避免频繁读取长期存储，提升记忆访问速度。</td></tr><tr><td>结构化记忆（明文记忆）</td><td>任务执行时 “实时生成 / 使用” 的临时记忆，是 Agent 当前决策所需的核心信息集合。</td><td>内存中的临时数据结构（如任务状态、推理中间结果、即时交互信息）</td><td>短期（任务结束后销毁 / 归档）</td><td>支撑当前任务的实时决策（如 “规划旅行” 时，临时存储目的地、交通方式等信息）。</td></tr></tbody></table>
<h5 data-id="heading-10">2.1.2 按「存储归属 + 访问优先级」划分</h5>
<p>该分类聚焦 “记忆的所有权、用途与访问优先级”，是从 Agent 功能逻辑角度对记忆的组织，核心服务于 “精准检索与管理”（如区分用户专属记忆和通用知识），偏 “功能逻辑维度”：</p>

































<table><thead><tr><th>记忆类型</th><th>核心定义</th><th>存储归属</th><th>访问优先级</th><th>核心作用</th></tr></thead><tbody><tr><td>WorkingMemory（工作记忆）</td><td>此处是 MemOS 中 “任务级临时存储模块”，专门存放当前任务的实时信息。</td><td>内存 / 临时存储</td><td>最高（任务执行期间优先访问）</td><td>承接当前任务的输入、中间结果、决策依据，是 Agent 实时交互的 “临时工作台”。</td></tr><tr><td>LongTermMemory（长期记忆）</td><td>Agent 的 “通用知识库”，存放不随任务销毁的长期有效信息（如通用知识、历史任务归档、领域规则）。</td><td>持久化存储（图数据库、向量数据库）</td><td>中低（需检索唤醒）</td><td>提供 Agent 长期稳定的知识支撑，避免 “任务结束即失忆”。</td></tr><tr><td>UserMemory（用户记忆）</td><td>属于 LongTermMemory 的 “子集化存储”，专门存放用户专属信息（如用户偏好、历史交互记录、个人属性）。</td><td>持久化存储（独立分区 / 带用户标识的数据库）</td><td>中高（用户相关任务优先访问）</td><td>实现 “个性化交互”（如记住用户喜欢的沟通风格、历史需求）。</td></tr></tbody></table>
<h4 data-id="heading-11">2.2 核心关系解析</h4>
<p>无包含关系，但有明确的 “映射与迁移”。</p>
<h5 data-id="heading-12">2.2.1. 不存在直接包含关系</h5>
<p>这两套分类维度是平行的</p>
<ul>
<li>第一套是 “技术实现维度”（关注 “记忆怎么存、存多久”），第二套是 “功能逻辑维度”（关注 “记忆为谁存、用来做什么”），二者如同 “按‘材质 + 保质期’分类食品” 与 “按‘食用场景 + 归属人’分类食品”—— 分类标准完全不同，无法直接说 “某类包含某类”。</li>
<li>例：UserMemory（功能维度）的物理形态可能是 “长期存储的结构化数据”（对应第一套的 “非激活态长期记忆”），也可能是 “临时加载到内存的激活数据”（对应第一套的 “激活记忆”）；WorkingMemory（功能维度）的物理形态就是第一套的 “结构化记忆”（临时数据结构）。</li>
</ul>
<h5 data-id="heading-13">2.2.2. 关键映射关系</h5>
<p>为了让逻辑更清晰，可通过 “功能模块 → 技术形态” 的映射理解二者关联：</p>





















<table><thead><tr><th>功能维度记忆（第二套）</th><th>对应的技术维度记忆（第一套）</th></tr></thead><tbody><tr><td>WorkingMemory</td><td>100% 对应「结构化记忆」（临时数据结构，任务结束后销毁 / 归档）；部分场景会加载「激活记忆」（如调用历史任务相关的唤醒记忆）。</td></tr><tr><td>LongTermMemory（通用）</td><td>未访问时：对应「长期存储的结构化数据」（非激活态）；访问时：加载为「激活记忆」；核心知识可能间接依赖「参数记忆」（模型权重中的通用认知）。</td></tr><tr><td>UserMemory</td><td>未访问时：对应「长期存储的用户专属数据」（非激活态）；访问时：加载为「激活记忆」；个性化偏好的理解依赖「参数记忆」（模型对 “偏好” 的语义认知）。</td></tr></tbody></table>
<h3 data-id="heading-14">0x03 MemOS的具体实现</h3>
<h4 data-id="heading-15">3.1 基本概念</h4>
<p>MemOS 关于记忆的基本概念如下。</p>
<h5 data-id="heading-16">3.1.1. 记忆类型 (memory_type)</h5>
<ul>
<li><code>WorkingMemory</code>: 工作记忆，临时存储。</li>
<li><code>LongTermMemory</code>: 长期记忆，持久存储</li>
<li><code>UserMemory</code>: 用户记忆，个性化存储</li>
</ul>
<p>WorkingMemory是Memos中的一种记忆类型，具有有限容量且会被定期清理。在MemoryManager中，默认最多保存20条WorkingMemory记录，并会自动移除旧记录以维持容量限制。</p>
<p>LongTermMemory和UserMemory是另外两种记忆类型，容量较大（默认分别为1500和480条记录）。它们不会像WorkingMemory那样频繁清理，用于存储更持久的信息。</p>
<h5 data-id="heading-17">3.1.2. 记忆状态 (status)</h5>
<ul>
<li><code>activated</code>: 激活状态</li>
<li><code>archived</code>: 归档状态</li>
<li><code>deleted</code>: 删除状态</li>
</ul>
<h5 data-id="heading-18">3.1.3. 记忆类型 (type)</h5>
<ul>
<li><code>fact</code>: 事实</li>
<li><code>event</code>: 事件</li>
<li><code>opinion</code>: 观点</li>
<li><code>topic</code>: 主题</li>
<li><code>reasoning</code>: 推理</li>
<li><code>procedure</code>: 程序</li>
</ul>
<h5 data-id="heading-19">3.1.4 问题</h5>
<p>如何选择合适的memory_type？</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-comment"># 🔧 根据记忆的重要性选择</span>
if is_important:
    <span class="hljs-attr">memory_type</span> = <span class="hljs-string">"LongTermMemory"</span>  <span class="hljs-comment"># 长期存储</span>
elif is_temporary:
    <span class="hljs-attr">memory_type</span> = <span class="hljs-string">"WorkingMemory"</span>   <span class="hljs-comment"># 临时存储</span>
else:
    <span class="hljs-attr">memory_type</span> = <span class="hljs-string">"UserMemory"</span>      <span class="hljs-comment"># 个性化存储</span>
</code></pre>
<p>如果发现基础的<code>TextualMemoryMetadata</code>功能有限，无法满足复杂场景的需求，比如需要区分工作记忆和长期记忆，需要追踪记忆的来源，需要为记忆添加标签和实体信息。</p>
<h4 data-id="heading-20">3.2 记忆生成</h4>
<p>在 TreeTextMemory 中，LongTermMemory、UserMemory 和 WorkingMemory 的设置是由系统根据预设规则和配置自动管理的。系统通过 prompt（更准确地说是 LLM）来判断记忆应该存储在 LongTermMemory、UserMemory 还是 WorkingMemory 中。这个判断过程主要发生在记忆提取阶段。</p>
<h5 data-id="heading-21">3.2.1 记忆提取阶段</h5>
<p>在记忆提取过程中，系统使用 SimpleStructMemReader 这样的组件来处理输入内容（如对话、文档等）。这个组件会调用 LLM 并使用特定的 prompt 来分析输入内容并决定每条记忆的类型。</p>
<p>例如，在 SIMPLE_STRUCT_MEM_READER_PROMPT 中，明确要求为每个提取的记忆指定 memory_type 字段：</p>
<pre><code class="hljs language-vbnet" lang="vbnet">{
  <span class="hljs-string">"memory list"</span>: [
    {
      <span class="hljs-string">"key"</span>: &lt;<span class="hljs-type">string</span>, a unique <span class="hljs-built_in">and</span> concise memory title&gt;,
      <span class="hljs-string">"memory_type"</span>: &lt;<span class="hljs-type">string</span>, <span class="hljs-string">"LongTermMemory"</span> <span class="hljs-built_in">or</span> <span class="hljs-string">"UserMemory"</span>&gt;,
      <span class="hljs-string">"value"</span>: &lt;a detailed, self-contained, <span class="hljs-built_in">and</span> unambiguous memory statement — use English <span class="hljs-keyword">if</span> the input conversation <span class="hljs-built_in">is</span> <span class="hljs-keyword">in</span> English, <span class="hljs-built_in">or</span> Chinese <span class="hljs-keyword">if</span> the conversation <span class="hljs-built_in">is</span> <span class="hljs-keyword">in</span> Chinese&gt;,
      <span class="hljs-string">"tags"</span>: &lt;a list <span class="hljs-keyword">of</span> relevant thematic keywords (e.g., [<span class="hljs-string">"deadline"</span>, <span class="hljs-string">"team"</span>, <span class="hljs-string">"planning"</span>])&gt;
    },
    ...
  ],
  <span class="hljs-string">"summary"</span>: &lt;a natural paragraph summarizing the above memories <span class="hljs-keyword">from</span> the user<span class="hljs-comment">'s perspective, 120–200 words, in the same language as the input&gt;</span>
}
</code></pre>
<p>SIMPLE_STRUCT_MEM_READER_PROMPT_ZH 摘录如下：</p>
<pre><code class="hljs language-vbnet" lang="vbnet">SIMPLE_STRUCT_MEM_READER_PROMPT_ZH = <span class="hljs-string">"""您是记忆提取专家。
您的任务是根据用户与助手之间的对话，从用户的角度提取记忆。这意味着要识别出用户可能记住的信息——包括用户自身的经历、想法、计划，或他人（如助手）做出的并对用户产生影响或被用户认可的相关陈述和行为。

请执行以下操作：
1. 识别反映用户经历、信念、关切、决策、计划或反应的信息——包括用户认可或回应的来自助手的有意义信息。
如果消息来自用户，请提取与用户相关的观点；如果来自助手，则在表达的时候表明记忆归属方，未经用户明确认可的信息不要与用户本身的观点混淆。
   - **用户观点**：仅记录由**用户亲口陈述、明确认可或自己作出承诺**的信息。
   - **助手观点**：仅记录由**助手/另一方亲口陈述、明确认可或自己作出承诺**的信息。
   - **互不越界**：不得将助手提出的需求清单/建议/观点改写为用户的“拥有/偏好/决定”；也不得把用户的想法写成助手的观点。

2. 清晰解析所有时间、人物和事件的指代：
   - 如果可能，使用消息时间戳将相对时间表达（如“昨天”、“下周五”）转换为绝对日期。
   - 明确区分事件时间和消息时间。
   - 如果存在不确定性，需明确说明（例如，“约2025年6月”，“具体日期不详”）。
   - 若提及具体地点，请包含在内。
   - 将所有代词、别名和模糊指代解析为全名或明确身份。
   - 如有同名人物，需加以区分。

3. 始终以第三人称视角撰写，使用“用户”或提及的姓名来指代用户，而不是使用第一人称（“我”、“我们”、“我的”）。
例如，写“用户感到疲惫……”而不是“我感到疲惫……”。

4. 不要遗漏用户可能记住的任何信息。
   - 包括用户的关键经历、想法、情绪反应和计划——即使看似微小。
   - 同时允许保留与语境密切相关的**助手/另一方的内容**（如建议、说明、清单），但须明确角色与归因。
   - 优先考虑完整性和保真度，而非简洁性；不得将助手内容推断或措辞为用户拥有/偏好/决定。
   - 若当前对话中仅出现助手信息而无可归因于用户的事实，可仅输出**助手观点**条目。

5. 请避免在提取的记忆中包含违反国家法律法规或涉及政治敏感的信息。

返回一个有效的JSON对象，结构如下：

{
  "</span>memory list<span class="hljs-string">": [
    {
      "</span><span class="hljs-keyword">key</span><span class="hljs-string">": &lt;字符串，唯一且简洁的记忆标题&gt;,
      "</span>memory_type<span class="hljs-string">": &lt;字符串，"</span>LongTermMemory<span class="hljs-string">" 或 "</span>UserMemory<span class="hljs-string">"&gt;,
      "</span>value<span class="hljs-string">": &lt;详细、独立且无歧义的记忆陈述——若输入对话为英文，则用英文；若为中文，则用中文&gt;,
      "</span>tags<span class="hljs-string">": &lt;相关主题关键词列表（例如，["</span>截止日期<span class="hljs-string">", "</span>团队<span class="hljs-string">", "</span>计划<span class="hljs-string">"]）&gt;
    },
    ...
  ],
  "</span>summary<span class="hljs-string">": &lt;从用户视角自然总结上述记忆的段落，120–200字，与输入语言一致&gt;
}

语言规则：
- `key`、`value`、`tags`、`summary` 字段必须与输入对话的主要语言一致。**如果输入是中文，请输出中文**
- `memory_type` 保持英文。

示例：
对话：
user: [2025年6月26日下午3:00]：嗨Jerry！昨天下午3点我和团队开了个会，讨论新项目。
assistant: 哦Tom！你觉得团队能在12月15日前完成吗？
user: [2025年6月26日下午3:00]：我有点担心。后端要到12月10日才能完成，所以测试时间会很紧。
assistant: [2025年6月26日下午3:00]：也许提议延期？
user: [2025年6月26日下午4:21]：好主意。我明天上午9:30的会上提一下——也许把截止日期推迟到1月5日。

输出：
{
  "</span>memory list<span class="hljs-string">": [
    {
        "</span><span class="hljs-keyword">key</span><span class="hljs-string">": "</span>项目初期会议<span class="hljs-string">",
        "</span>memory_type<span class="hljs-string">": "</span>LongTermMemory<span class="hljs-string">",
        "</span>value<span class="hljs-string">": "</span>[user-Tom观点]<span class="hljs-number">2025</span>年<span class="hljs-number">6</span>月<span class="hljs-number">25</span>日下午<span class="hljs-number">3</span>:<span class="hljs-number">00</span>，Tom与团队开会讨论新项目。当Jerry
        询问该项目能否在<span class="hljs-number">2025</span>年<span class="hljs-number">12</span>月<span class="hljs-number">15</span>日前完成时，Tom对此日期前完成的可行性表达担忧，并计划在<span class="hljs-number">2025</span>年<span class="hljs-number">6</span>月<span class="hljs-number">27</span>日上午<span class="hljs-number">9</span>:<span class="hljs-number">30</span>
        提议将截止日期推迟至<span class="hljs-number">2026</span>年<span class="hljs-number">1</span>月<span class="hljs-number">5</span>日。<span class="hljs-string">",
        "</span>tags<span class="hljs-string">": ["</span>项目<span class="hljs-string">", "</span>时间表<span class="hljs-string">", "</span>会议<span class="hljs-string">", "</span>截止日期<span class="hljs-string">"]
    },
    {
        "</span><span class="hljs-keyword">key</span><span class="hljs-string">": "</span>Jerry对新项目截止日期的建议<span class="hljs-string">",
        "</span>memory_type<span class="hljs-string">": "</span>LongTermMemory<span class="hljs-string">",
        "</span>value<span class="hljs-string">": "</span>[assistant-Jerry观点]Jerry对Tom的新项目截止日期提出疑问、并提议Tom考虑延期。<span class="hljs-string">",
        "</span>tags<span class="hljs-string">": ["</span>截止日期变更<span class="hljs-string">", "</span>建议<span class="hljs-string">"]
    }
  ],
  "</span>summary<span class="hljs-string">": "</span>Tom目前正在做一个进度紧张的新项目。在<span class="hljs-number">2025</span>年<span class="hljs-number">6</span>月<span class="hljs-number">25</span>日的团队会议后，他意识到原定<span class="hljs-number">2025</span>年<span class="hljs-number">12</span>月<span class="hljs-number">15</span>
  日的截止日期可能无法实现，因为后端会延迟。由于担心测试时间不足，他接受了Jerry提出的延期建议，计划在次日早上的会议上提出将截止日期推迟至<span class="hljs-number">2026</span>
  年<span class="hljs-number">1</span>月<span class="hljs-number">5</span>日。<span class="hljs-string">"
}

另一个中文示例（注意：当用户语言为中文时，您也需输出中文）：

对话（节选）：
user｜2025-07-12 19:30：下个月同事婚礼，要买条裙子，预算1500内，别太暴露。
assistant｜19:32
：了解～婚礼场合建议中长款，端庄一些。可以看法式茶歇/直筒/裹身三路。颜色上，奶油白、浅粉、雾霾蓝都适合；面料可看醋酸/真丝混纺（垂感好但需干洗）。品牌与商场：COS/ Massimo Dutti / &amp; Other Stories / Mango 比较好逛；想更法式可以看 Sandro / Maje。 我记得你很喜欢Maje？
user｜19:35：不喜欢亮色。国贸方便。
assistant｜19:37：那亮度就压低些：雾霾蓝、藕粉、燕麦米白更稳。国贸有 COS / Massimo Dutti / &amp;OS；可以先看 COS 直筒或裹身，再去 MD 看藕粉/雾霾蓝。搭配上，薄披肩/小西装都能压场。
user｜19:40：165cm，S码；最好有口袋。
assistant｜19:42：OK。版型避开大摆+高开衩，选直筒或轻A字更稳；若要口袋，COS直筒一些款有；开衩别太高，及小腿肚附近即可。鞋包：中跟裸色鞋 + 小号手拿包。
user｜19:47：本来想茶歇A字，但雾霾蓝直筒也行。
assistant｜19:49：可以先锁定：COS 雾霾蓝直筒中长为主选，MD 藕粉中长做备选；再看 &amp; Other Stories 是否有合身的裹身款。
user｜19:52：行，周六（7/19）去国贸试，合适就买。
assistant｜19:54：记得看肩带可调/有无内衬，醋酸/真丝优先干洗；准备同色安全裤/防走光贴。如果当天没货，可下单调货或线上下单门店自提。

{
  "</span>memory list<span class="hljs-string">": [
    {
      "</span><span class="hljs-keyword">key</span><span class="hljs-string">": "</span>参加婚礼购买裙子<span class="hljs-string">",
      "</span>memory_type<span class="hljs-string">": "</span>UserMemory<span class="hljs-string">",
      "</span>value<span class="hljs-string">": "</span>[user观点]用户计划于约<span class="hljs-number">2025</span>年<span class="hljs-number">8</span>月参加同事婚礼（具体日期不详），预算不超过<span class="hljs-number">1500</span>元，整体风格不宜暴露；用户已决定在<span class="hljs-number">2025</span>-<span class="hljs-number">07</span>-<span class="hljs-number">19</span>于国贸试穿并视合适即购买。<span class="hljs-string">",
      "</span>tags<span class="hljs-string">": ["</span>婚礼<span class="hljs-string">", "</span>预算<span class="hljs-string">", "</span>国贸<span class="hljs-string">", "</span>计划<span class="hljs-string">"]
    },
    {
      "</span><span class="hljs-keyword">key</span><span class="hljs-string">": "</span>审美与版型偏好<span class="hljs-string">",
      "</span>memory_type<span class="hljs-string">": "</span>UserMemory<span class="hljs-string">",
      "</span>value<span class="hljs-string">": "</span>[user观点]用户不喜欢亮色，倾向低亮度色系；裙装偏好端庄的中长款，接受直筒或轻A字。<span class="hljs-string">",
      "</span>tags<span class="hljs-string">": ["</span>偏好<span class="hljs-string">", "</span>颜色<span class="hljs-string">", "</span>版型<span class="hljs-string">"]
    },
    {
      "</span><span class="hljs-keyword">key</span><span class="hljs-string">": "</span>体型尺码<span class="hljs-string">",
      "</span>memory_type<span class="hljs-string">": "</span>UserMemory<span class="hljs-string">",
      "</span>value<span class="hljs-string">": [user观点]"</span>用户身高约<span class="hljs-number">165</span>cm、常穿S码<span class="hljs-string">",
      "</span>tags<span class="hljs-string">": ["</span>体型<span class="hljs-string">", "</span>尺码<span class="hljs-string">"]
    },
    {
      "</span><span class="hljs-keyword">key</span><span class="hljs-string">": "</span>关于用户选购裙子的建议<span class="hljs-string">",
      "</span>memory_type<span class="hljs-string">": "</span>LongTermMemory<span class="hljs-string">",
      "</span>value<span class="hljs-string">": "</span>[assistant观点]assistant在用户询问婚礼穿着时，建议在国贸优先逛COS查看雾霾蓝直筒中长为主选，Massimo Dutti藕粉中长为备选；该建议与用户“国贸方便”“雾霾蓝直筒也行”的回应相一致，另外assistant也提到user喜欢Maje，但User并未回应或证实该说法。<span class="hljs-string">",
      "</span>tags<span class="hljs-string">": ["</span>婚礼穿着<span class="hljs-string">", "</span>门店<span class="hljs-string">", "</span>选购路线<span class="hljs-string">"]
    }
  ],
  "</span>summary<span class="hljs-string">": "</span>用户计划在约<span class="hljs-number">2025</span>年<span class="hljs-number">8</span>月参加同事婚礼，预算≤<span class="hljs-number">1500</span>并偏好端庄的中长款；确定于<span class="hljs-number">2025</span>-<span class="hljs-number">07</span>-<span class="hljs-number">19</span>在国贸试穿。其长期画像显示：不喜欢亮色、偏好低亮度色系与不过分暴露的版型，身高约<span class="hljs-number">165</span>cm、S码且偏好裙装带口袋。助手提出的国贸选购路线以COS雾霾蓝直筒中长为主选、MD藕粉中长为备选，且与用户回应一致，为线下试穿与购买提供了明确路径。<span class="hljs-string">"
}

请始终使用与对话相同的语言进行回复。

对话：
${conversation}

您的输出：""
</span></code></pre>
<h5 data-id="heading-22">3.2.2 内存类型判断的标准</h5>
<p>根据 prompt 中的指示，LLM 会基于以下标准来判断记忆类型：</p>
<ul>
<li>
<p>LongTermMemory</p>
<ul>
<li>包含长期重要信息</li>
<li>涉及项目计划、重要决策、关键事实</li>
<li>对用户长期有价值的信息</li>
</ul>
</li>
<li>
<p>UserMemory</p>
<ul>
<li>与用户个人偏好、习惯、特征相关</li>
<li>用户的个人经历、观点、喜好</li>
<li>与特定用户强相关的信息</li>
</ul>
</li>
</ul>
<p>根据提供的 SIMPLE_STRUCT_MEM_READER_PROMPT，决定记忆类型的判断标准如下：</p>
<p>在 prompt 中，明确要求为每个提取的记忆指定 memory_type 字段，其值只能是 "LongTermMemory" 或 "UserMemory"。虽然 prompt 没有详细说明两者的具体区别，但通过示例和上下文可以推断出以下判断标准：</p>
<p>LongTermMemory（长期记忆）存储具有长期价值和重要性的信息：</p>
<ul>
<li>项目计划和关键决策</li>
<li>重要的事实和事件</li>
<li>需要长期保存的工作相关信息</li>
<li>对用户未来发展有持续影响的信息</li>
</ul>
<p>示例：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"key"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Initial project meeting"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"memory_type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"LongTermMemory"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"value"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"[user-Tom viewpoint] On June 25, 2025 at 3:00 PM, Tom met with the team to discuss a new project..."</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"tags"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">"project"</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"timeline"</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"meeting"</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"deadline"</span><span class="hljs-punctuation">]</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p>UserMemory（用户记忆）存储与用户个人相关的偏好、习惯和特征：</p>
<ul>
<li>用户的个人偏好和选择</li>
<li>用户的习惯和行为模式</li>
<li>用户的个人观点和感受</li>
<li>与特定用户强相关的信息</li>
</ul>
<p>示例（基于购物场景）：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"key"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"wedding dress preference"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"memory_type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"UserMemory"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"value"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"[user-viewpoint] For colleague's wedding next month, the user wants to buy a dress within 1500 RMB budget, not too revealing. Prefers midi length, modest style, and colors like cream white, light pink, or haze blue."</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"tags"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">"wedding"</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"dress"</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"budget"</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"preference"</span><span class="hljs-punctuation">]</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<h5 data-id="heading-23">3.2.3 判断依据总结</h5>
<p>虽然 prompt 中没有明确列出详细的判断规则，但从示例和任务描述中可以归纳出以下判断依据：</p>
<ul>
<li>内容性质：信息是工作/项目相关（LongTermMemory）还是个人偏好/体验（UserMemory）</li>
<li>时间跨度：短期临时信息可能归类为 WorkingMemory（虽然示例中未显示），而长期有价值信息归类为 LongTermMemory</li>
<li>所有权：信息属于用户个人（UserMemory）还是工作/项目相关（LongTermMemory）</li>
<li>重要性：对用户长期有价值的信息归类为 LongTermMemory，个人喜好和习惯归类为 UserMemory</li>
</ul>
<p>需要注意的是，在提取阶段的 prompt 中没有提及 WorkingMemory，这是因为 WorkingMemory 通常由系统自动管理，用于存储最近访问的记忆，而不是由 LLM 判断分类的。</p>
<h5 data-id="heading-24">3.2.4 代码流程</h5>
<h6 data-id="heading-25">实际转换流程总结</h6>
<p>新增记忆即时转换：</p>
<ul>
<li>用户输入或系统生成记忆时立即存储到相应的目标记忆库</li>
<li>所有记忆都同时保存在 WorkingMemory 中作为缓存，部分也会进入 LongTermMemory 或 UserMemory</li>
</ul>
<p>周期性清理</p>
<ul>
<li>WorkingMemory 达到容量上限时，移除最旧的记忆项</li>
<li>长期记忆库一般不主动清理，除非手动删除</li>
</ul>
<p>结构优化与抽象</p>
<ul>
<li>系统定期对长期记忆进行聚类分析</li>
<li>生成更高层次的抽象记忆节点</li>
<li>建立记忆间的语义关联网络</li>
</ul>
<p>并行检索</p>
<ul>
<li>搜索时会同时查询多种内存类型，然后合并结果</li>
</ul>
<p>手动替换</p>
<ul>
<li>可以手动替换 WorkingMemory 的内容</li>
</ul>
<p>这种设计使得系统既能快速响应最新信息，又能长期保存重要知识，并通过结构优化不断提升检索效率和语义理解能力。</p>
<h6 data-id="heading-26">创建和初始存储</h6>
<p>记忆通过 MemReader 组件创建，该组件处理输入数据（文档或对话）并将其转换为结构化的记忆项，存储在 TreeTextMemory 中。</p>
<p>在创建记忆项时，可以通过 TreeNodeTextualMemoryMetadata 的 memory_type 字段指定记忆类型为 LongTermMemory：</p>
<pre><code class="hljs language-arduino" lang="arduino"># 在 memos/memories/textual/item.py 中定义的 TreeNodeTextualMemoryMetadata 类
<span class="hljs-function"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNodeTextualMemoryMetadata</span><span class="hljs-params">(TextualMemoryMetadata)</span>:
    memory_type: Literal[<span class="hljs-string">"WorkingMemory"</span>, <span class="hljs-string">"LongTermMemory"</span>, <span class="hljs-string">"UserMemory"</span>] =</span> <span class="hljs-string">"WorkingMemory"</span>
</code></pre>
<p>当通过 TreeTextMemory.add() 添加记忆时，会触发以下转换逻辑：</p>
<ul>
<li>所有新增记忆都会先存储到 WorkingMemory；</li>
<li>同时根据记忆元数据中的 memory_type 字段决定是否同时存储到 LongTermMemory 或 UserMemory。</li>
</ul>
<pre><code class="hljs language-python" lang="python">TreeTextMemory.add()
→ MemoryManager.add()
→ MemoryManager._process_memory()

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_process_memory</span>(<span class="hljs-params">self, memory: TextualMemoryItem</span>):
        <span class="hljs-string">"""
        Process and add memory to different memory types (WorkingMemory, LongTermMemory, UserMemory).
        This method runs asynchronously to process each memory item.
        """</span>
        ids = []

        <span class="hljs-comment"># 总是添加到 WorkingMemory</span>
        working_id = self._add_memory_to_db(memory, <span class="hljs-string">"WorkingMemory"</span>)
        ids.append(working_id)

        <span class="hljs-comment"># 如果元数据中指定了 LongTermMemory 或 UserMemory，则也添加到相应类型</span>
        <span class="hljs-keyword">if</span> memory.metadata.memory_type <span class="hljs-keyword">in</span> [<span class="hljs-string">"LongTermMemory"</span>, <span class="hljs-string">"UserMemory"</span>]:
            added_id = self._add_to_graph_memory(
                memory=memory,
                memory_type=memory.metadata.memory_type,
            )
            ids.append(added_id)

        <span class="hljs-keyword">return</span> ids
</code></pre>
<p>当添加记忆时，可以指定LongTermMemory类型。</p>
<pre><code class="hljs language-ini" lang="ini">    <span class="hljs-comment"># Create character memory metadata</span>
    <span class="hljs-attr">metadata</span> = TreeNodeTextualMemoryMetadata(
        <span class="hljs-attr">user_id</span>=user_id,
        <span class="hljs-attr">type</span>=<span class="hljs-string">"fact"</span>,
        <span class="hljs-attr">source</span>=<span class="hljs-string">"conversation"</span>,
        <span class="hljs-attr">confidence</span>=<span class="hljs-number">90.0</span>,
        <span class="hljs-attr">memory_type</span>=<span class="hljs-string">"LongTermMemory"</span>,
        <span class="hljs-attr">key</span>=<span class="hljs-string">"Zhang_San_Info"</span>,
        <span class="hljs-attr">entities</span>=[<span class="hljs-string">"Zhang San"</span>, <span class="hljs-string">"Engineer"</span>],
        <span class="hljs-attr">tags</span>=[<span class="hljs-string">"Personnel"</span>, <span class="hljs-string">"Technical"</span>]
    )

    <span class="hljs-comment"># Create memory item</span>
    <span class="hljs-attr">memory_item</span> = TextualMemoryItem(
        <span class="hljs-attr">memory</span>=<span class="hljs-string">"Zhang San is a senior engineer in our company, specializing in Python and machine learning"</span>,
        <span class="hljs-attr">metadata</span>=metadata
    )
</code></pre>
<h6 data-id="heading-27">定期清理与维护机制</h6>
<p>系统采用先进先出（FIFO）的方式定期清理 WorkingMemory：</p>
<ul>
<li>在每次添加记忆后调用 remove_oldest_memory 方法；</li>
<li>保留最新的 N 条记录（默认配置为 20 条）；</li>
<li>超出限制的旧记录会被自动删除。</li>
</ul>
<p>在系统配置中，可以设置记忆大小限制等参数，这些参数会直接影响 LongTermMemory的管理。</p>
<p>在 TreeTextMemory 中，MemoryManager 负责管理不同类型内存的分配和维护：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 在 TreeTextMemory.__init__ 中初始化</span>
self.memory_manager: MemoryManager = MemoryManager(
    self.graph_store,
    self.embedder,
    self.extractor_llm,
    memory_size=config.memory_size <span class="hljs-keyword">or</span> {
        <span class="hljs-string">"WorkingMemory"</span>: <span class="hljs-number">20</span>, <span class="hljs-comment"># 生命周期：短期存储，定期清理，用途：存储最近使用的记忆，用于快速访问</span>
        <span class="hljs-string">"LongTermMemory"</span>: <span class="hljs-number">1500</span>, <span class="hljs-comment"># 生命周期：长期存储，存储重要且持久的记忆</span>
        <span class="hljs-string">"UserMemory"</span>: <span class="hljs-number">480</span>, <span class="hljs-comment"># 生命周期：与特定用户相关联，存储与特定用户相关的个性化记忆</span>
    },
    is_reorganize=self.is_reorganize,
)
</code></pre>
<p>清理触发时机为：</p>
<pre><code class="hljs language-python" lang="python">        <span class="hljs-keyword">try</span>:
            self.graph_store.remove_oldest_memory(
                memory_type=<span class="hljs-string">"WorkingMemory"</span>, keep_latest=self.memory_size[<span class="hljs-string">"WorkingMemory"</span>]
            )
        <span class="hljs-keyword">except</span> Exception:
            logger.warning(<span class="hljs-string">f"Remove WorkingMemory error: <span class="hljs-subst">{traceback.format_exc()}</span>"</span>)

        <span class="hljs-keyword">try</span>:
            self.graph_store.remove_oldest_memory(
                memory_type=<span class="hljs-string">"LongTermMemory"</span>, keep_latest=self.memory_size[<span class="hljs-string">"LongTermMemory"</span>]
            )
        <span class="hljs-keyword">except</span> Exception:
            logger.warning(<span class="hljs-string">f"Remove LongTermMemory error: <span class="hljs-subst">{traceback.format_exc()}</span>"</span>)

        <span class="hljs-keyword">try</span>:
            self.graph_store.remove_oldest_memory(
                memory_type=<span class="hljs-string">"UserMemory"</span>, keep_latest=self.memory_size[<span class="hljs-string">"UserMemory"</span>]
            )
        <span class="hljs-keyword">except</span> Exception:
            logger.warning(<span class="hljs-string">f"Remove UserMemory error: <span class="hljs-subst">{traceback.format_exc()}</span>"</span>)
</code></pre>
<h6 data-id="heading-28">搜索时的数据交互</h6>
<p>在搜索过程中，不同类型的内存会被并行查询，然后结果被合并和重新排序：</p>
<pre><code class="hljs language-less" lang="less"># 在 <span class="hljs-selector-tag">Searcher</span><span class="hljs-selector-class">._retrieve_paths</span> 方法中
<span class="hljs-selector-tag">tasks</span><span class="hljs-selector-class">.append</span>(
    executor.<span class="hljs-built_in">submit</span>(
        self._retrieve_from_working_memory,
        query,
        parsed_goal,
        query_embedding,
        top_k,
        memory_type,
        search_filter,
tasks.<span class="hljs-built_in">append</span>(
    executor.<span class="hljs-built_in">submit</span>(
        self._retrieve_from_working_memory,
    )
)
</code></pre>
<h6 data-id="heading-29">图结构重组过程中的记忆优化</h6>
<p>GraphStructureReorganizer 的周期性优化，即GraphStructureReorganizer 还会定期对 LongTermMemory 和 UserMemory 进行结构优化，可能会创建新的聚合节点。</p>
<p>系统有一个后台线程运行 GraphStructureReorganizer，它会定期执行以下操作：</p>
<ul>
<li>对长期记忆进行聚类和总结；</li>
<li>创建抽象层级的记忆节点。</li>
</ul>
<p>优化触发条件为：</p>
<ul>
<li>新增记忆时设置 _reorganize_needed=True 标志</li>
<li>定期调度器每 100 秒检查一次是否需要重新组织结构</li>
<li>当有足够多的新记忆积累时才真正触发优化过程</li>
</ul>
<pre><code class="hljs language-ini" lang="ini">def optimize_structure(
    self,
    scope: <span class="hljs-attr">str</span> = <span class="hljs-string">"LongTermMemory"</span>,
):
    <span class="hljs-comment"># 加载候选节点</span>
    <span class="hljs-attr">raw_nodes</span> = self.graph_store.get_structure_optimization_candidates(scope)
    <span class="hljs-attr">nodes</span> = [GraphDBNode(**n) for n in raw_nodes]
    <span class="hljs-comment"># 分区处理</span>
    <span class="hljs-attr">partitioned_groups</span> = self._partition(nodes)
    <span class="hljs-comment"># 对每个分区进行聚类和总结</span>
    for cluster_nodes in partitioned_groups:
        <span class="hljs-comment"># 创建父节点表示聚类</span>
        <span class="hljs-attr">sub_parent_node</span> = self._summarize_cluster(sub_nodes, scope)
        <span class="hljs-comment"># ...</span>
</code></pre>
<h6 data-id="heading-30">用户控制方式</h6>
<p>虽然系统自动管理内存类型，但用户可以通过以下方式间接影响：</p>
<ul>
<li>设置元数据：在创建 TextualMemoryItem 时设置 metadata.memory_type 字段</li>
<li>配置容量：通过 TreeTextMemoryConfig 设置各类内存的最大容量</li>
<li>手动替换：使用 replace_working_memory 方法直接操作工作内存</li>
</ul>
<h6 data-id="heading-31">总结</h6>
<p>LongTermMemory、UserMemory 和 WorkingMemory 的设置主要是由系统根据预定义规则自动完成的，而不是用户主动设置。系统会根据记忆的元数据和配置自动将其分配到适当的内存类型中，并按照设定的容量限制进行管理。用户可以通过配置参数和设置记忆元数据来间接影响这一过程。</p>
<h3 data-id="heading-32">0x04 MemOS 记忆生命周期管理</h3>
<p>MemOS 并没有一个统一的生命周期管理模块，该功能是散布在MemOS各个模块中。</p>
<p>以下为官方文档内容。</p>
<p>一条记忆从被生成开始，可能会逐步沉淀为稳定的长期偏好，也可能因过时或无效而被清理。</p>
<p>这套演化过程称为 <strong>记忆生命周期管理</strong>，它的目标是保持记忆库“干净而有序”。</p>
<ul>
<li><strong>近期有用的条目</strong>保持活跃，方便随时调用；</li>
<li><strong>长期稳定的事实</strong>被沉淀，减少重复和噪音；</li>
<li><strong>过时或冲突的信息</strong>会被归档或删除，保证一致性和合规性。</li>
</ul>
<blockquote>
<p>需要注意的是，生命周期管理关注的是<strong>记忆条目在存储层面的演化</strong>；而具体一次推理里“是否调用某条记忆”，仍由调度机制决定。</p>
</blockquote>
<h4 data-id="heading-33">4.1 生命周期阶段简介</h4>








































<table><thead><tr><th><strong>阶段</strong></th><th><strong>说明</strong></th><th><strong>系统行为</strong></th></tr></thead><tbody><tr><td>Generated 生成</td><td>新产生的记忆对象，带有来源、时间戳、置信度等元信息</td><td>初始存入存储层，等待后续使用</td></tr><tr><td>Activated 激活</td><td>在推理或任务中被引用，进入高频活跃状态</td><td>更容易被调度机制选中</td></tr><tr><td>Merged 合并</td><td>与历史记忆存在语义重叠或用户补充数据，系统将其整合为新版本</td><td>多条记录被压缩合并，形成更新后的稳定条目</td></tr><tr><td>Archived 归档</td><td>长期未被访问，自动降级为冷存储状态</td><td>仅在特殊检索或回溯时启用</td></tr><tr><td>Expired 过期，可选</td><td>归档后进一步超时或被策略判定为无效</td><td>被清理出索引，不再参与推理，仅留最小日志</td></tr><tr><td>Frozen 冻结，特殊状态</td><td>关键或合规性记忆被锁定，不允许修改</td><td>保留完整历史版本，支持审计与合规追踪</td></tr></tbody></table>
<h4 data-id="heading-34">4.2 案例：在线教育助手的记忆生命周期</h4>
<p>假设你正在用 MemOS 构建一个 <strong>在线教育助手</strong>，帮助学生解答数学题。</p>
<p><strong>生成（Generated）</strong></p>
<ul>
<li>学生第一次使用时说：“我总是把二次函数和一次函数搞混。”</li>
<li>系统抽取出记忆：</li>
</ul>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span><span class="hljs-attr">"fact"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"学生常混淆二次函数与一次函数"</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">"confidence"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0.8</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">"timestamp"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"2025-09-11"</span><span class="hljs-punctuation">}</span>
</code></pre>
<ul>
<li>状态：<strong>Generated</strong></li>
<li>行为：被存储进记忆库，等待后续使用。</li>
</ul>
<hr/>
<p><strong>激活（Activated）</strong></p>
<ul>
<li>在接下来的多次答题中，系统频繁调用这条记忆来辅助解题。</li>
<li>状态：<strong>Activated</strong></li>
<li>行为：被调度机制优先缓存进 MemoryCube，提高检索速度。</li>
</ul>
<hr/>
<p><strong>合并（Merged）</strong></p>
<ul>
<li>随着更多交互，系统发现学生不仅混淆一次函数和二次函数，还对指数函数也容易混淆。</li>
<li>系统将多条相似记忆合并为：</li>
</ul>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span><span class="hljs-attr">"fact"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"该学生在函数知识点上存在混淆，尤其是一元一次、二次和指数函数"</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">"confidence"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0.95</span><span class="hljs-punctuation">}</span>
</code></pre>
<ul>
<li>状态：<strong>Merged</strong></li>
<li>行为：旧条目被压缩，形成新版本，减少冗余。</li>
</ul>
<hr/>
<p><strong>归档（Archived）</strong></p>
<ul>
<li>三个月后，学生已掌握函数相关知识点，系统很久没有再调度到这条记忆。</li>
<li>状态：<strong>Archived</strong></li>
<li>行为：被迁移至 MemVault（冷存储），默认不参与推理，但可在“学习轨迹回溯”中被调用。</li>
</ul>
<hr/>
<p><strong>过期（Expired）</strong></p>
<ul>
<li>又过了一年，该学生升级到新的学段，旧的“初中函数混淆”记忆被策略判定为无效。</li>
<li>状态：<strong>Expired</strong></li>
<li>行为：从索引中彻底清理，仅保留最小审计信息：</li>
</ul>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span><span class="hljs-attr">"deleted_fact_id"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"12345"</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">"deleted_at"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"2026-09-11"</span><span class="hljs-punctuation">}</span>
</code></pre>
<hr/>
<p><strong>冻结（Frozen，特殊状态）</strong></p>
<ul>
<li>与此同时，该学生的“期末成绩评估报告”属于合规性文件，不允许修改。</li>
<li>状态：<strong>Frozen</strong></li>
<li>行为：被锁定，禁止更新，仅保留完整修改历史，便于审计与合规检查。</li>
</ul>
<p>进阶：如果你想做深度定制</p>



































<table><thead><tr><th><strong>可扩展点</strong></th><th><strong>描述</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td>状态转换条件</td><td>控制各个状态触发条件</td><td>“若 7 天未使用 → 归档”</td></tr><tr><td>合并与压缩</td><td>定义相似记忆的处理方式</td><td>多条“喜欢科幻片”合并为一条置信度更高的事实</td></tr><tr><td>冲突解决</td><td>处理时间戳或来源矛盾的记忆</td><td>选择“最新覆盖旧条目”或“并列保留”</td></tr><tr><td>清理机制</td><td>设置删除条件，控制索引规模</td><td>删除低置信度或用户撤回的记忆</td></tr><tr><td>审计追踪</td><td>决定是否保留被删除条目的最小元信息</td><td>在合规要求下开启“溯源日志”</td></tr></tbody></table>
<h4 data-id="heading-35">4.3 自己的理解</h4>
<p>Memos中TreeTextMemory系统的三种记忆类型（WorkingMemory、LongTermMemory和UserMemory）之间不存在自动迁移或转换机制。系统采用独立管理策略，每种记忆类型有各自的容量限制和生命周期管理方式。</p>
<p>MemoryManager负责维护各记忆类型的容量限制，包括WorkingMemory（默认20条）、LongTermMemory（默认1500条）和UserMemory（默认480条）。当超出限制时按照FIFO原则清理旧记忆，但不会自动将记忆在不同类型间迁移。新记忆添加时会根据其类型属性决定存储位置，这是一种并行添加而非迁移过程。</p>
<p>在添加记忆时，系统会将所有记忆同时添加到WorkingMemory中，并根据记忆的metadata.memory_type字段决定是否同时添加到LongTermMemory或UserMemory中。这一过程是并行发生的，而非迁移或转换。</p>
<p>以下是自己的理解。</p>
<p>动态迁移逻辑，核心是 “记忆在不同形态 / 模块间的流动”，本质是 “功能需求驱动技术形态转换”—— 让 Agent 既能 “实时响应任务”（依赖工作记忆、激活记忆），又能 “长期积累知识”（依赖 LongTermMemory、UserMemory），还能 “高效利用资源”（通过层级存储优化），最终实现 “可推理、可扩展、个性化” 的记忆管理核心目标。</p>
<p>MemOS 的核心记忆流转逻辑，具体迁移路径可分为 4 类，覆盖 Agent 任务执行的全流程：</p>
<p><strong>（1）任务启动：长期记忆 → 激活记忆 → 工作记忆</strong></p>
<ul>
<li>
<p>场景：Agent 接收用户任务（如 “帮我规划从北京到上海的旅行，记得我喜欢经济型酒店”）；</p>
</li>
<li>
<p>迁移过程：</p>
<ol>
<li>先从「UserMemory」（功能维度）中检索 “用户喜欢经济型酒店” 的专属记忆，从「LongTermMemory」（功能维度）中检索 “北京到上海的交通方式” 的通用记忆；</li>
<li>这些检索到的记忆从 “长期存储”（非激活态）加载为「激活记忆」（技术维度），缓存到内存；</li>
<li>再将「激活记忆」中的关键信息（用户偏好、交通选项）注入「WorkingMemory」（功能维度），作为当前任务的决策依据。</li>
</ol>
</li>
</ul>
<p><strong>（2）任务执行：工作记忆 ↔ 激活记忆（实时交互）</strong></p>
<ul>
<li>
<p>场景：Agent 分析旅行方案时，需要确认 “经济型酒店的具体标准”（用户之前提过 “价格低于 500 元 / 晚”）；</p>
</li>
<li>
<p>迁移过程：</p>
<ol>
<li>「WorkingMemory」中无该细节，触发从「UserMemory」检索；</li>
<li>检索结果加载为「激活记忆」，补充到「WorkingMemory」中；</li>
<li>Agent 基于补充信息细化方案（筛选 500 元以下酒店），中间决策结果实时写入「WorkingMemory」。</li>
</ol>
</li>
</ul>
<p><strong>（3）任务结束：工作记忆 → 长期记忆（归档 / 丢弃）</strong></p>
<ul>
<li>
<p>场景：旅行方案生成完成，用户确认后任务结束；</p>
</li>
<li>
<p>迁移过程：</p>
<ol>
<li>「WorkingMemory」中的有用信息（如用户最终选择的酒店、交通方式、反馈 “下次想避开高铁换乘”），按归属归档：用户专属信息写入「UserMemory」，通用方案模板写入「LongTermMemory」；</li>
<li>归档后，这些信息从「工作记忆」转为 “长期存储的非激活态数据”；</li>
<li>「WorkingMemory」中无价值的临时信息（如中间筛选的无效酒店、计算过程）直接销毁，释放内存。</li>
</ol>
</li>
</ul>
<p><strong>（4）长期记忆更新：激活记忆 → 长期记忆（迭代优化）</strong></p>
<ul>
<li>
<p>场景：Agent 学习到新的通用知识（如 “北京到上海新增了直达航班”），或用户更新偏好（如 “现在喜欢中端酒店，预算 800 元 / 晚”）；</p>
</li>
<li>
<p>迁移过程：</p>
<ol>
<li>新知识 / 新偏好先通过「RelationAndReasoningDetector」处理为结构化数据，加载为「激活记忆」；</li>
<li>「激活记忆」通过「NodeHandler」写入对应长期存储：通用知识写入「LongTermMemory」，用户偏好更新「UserMemory」；</li>
<li>写入完成后，「激活记忆」可保留缓存（提升后续访问速度），超时后自动释放。</li>
</ol>
</li>
</ul>
<p><strong>补充：参数记忆的特殊角色（无迁移，仅提供基础支撑）</strong></p>
<p>参数记忆（模型权重）是 “静态基础”，不参与上述动态迁移 —— 它为所有记忆的 “理解与推理” 提供底层能力（如识别 “用户偏好” 的语义、推理 “交通方式选择” 的逻辑），但自身不会被 MemOS 动态修改（除非进行模型微调，将长期记忆中的关键知识固化为参数记忆）。</p>
<h4 data-id="heading-36">4.4 MemScheduler</h4>
<p>MemOS 也在尝试自动迁移，这就是 MemScheduler 的功能。</p>
<p>MemScheduler 是一个与 MemOS 系统并行运行的并发记忆管理系统，它协调 AI 系统中工作记忆、长时记忆和激活记忆之间的记忆操作。它通过事件驱动调度处理记忆检索、更新和压缩。该系统特别适合需要动态记忆管理的对话代理和推理系统。</p>
<p>我们将在下一章介绍 MemScheduler。</p>
<h3 data-id="heading-37">0xFF 参考</h3>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F1981392181592871894" target="_blank" title="https://zhuanlan.zhihu.com/p/1981392181592871894" ref="nofollow noopener noreferrer">Multi-Agent系统构建初探：基于LangGraph的长短期记忆管理实践指南</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F1975514242754049684" target="_blank" title="https://zhuanlan.zhihu.com/p/1975514242754049684" ref="nofollow noopener noreferrer">Agent开发实践：从想法到产品——SSE、上下文工程与流式解析关键技术攻坚</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F1975511012347249929" target="_blank" title="https://zhuanlan.zhihu.com/p/1975511012347249929" ref="nofollow noopener noreferrer">Agent开发实践：从想法到产品——系统架构设计实践</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.memmachine.ai%2Fopen_source%2Fmemory_types" target="_blank" title="https://docs.memmachine.ai/open_source/memory_types" ref="nofollow noopener noreferrer">docs.memmachine.ai/open_source…</a></p>
<p>本文使用 <a href="https://link.juejin.cn?target=https%3A%2F%2Fmarkdown.com.cn" target="_blank" title="https://markdown.com.cn" ref="nofollow noopener noreferrer">markdown.com.cn</a> 排版</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[如何实现流式输出？一篇文章手把手教你！]]></title>    <link>https://juejin.cn/post/7583921477613502499</link>    <guid>https://juejin.cn/post/7583921477613502499</guid>    <pubDate>2025-12-15T13:42:59.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7583921477613502499" data-draft-id="7583903159774101519" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="如何实现流式输出？一篇文章手把手教你！"/> <meta itemprop="keywords" content="前端,AIGC,AI编程"/> <meta itemprop="datePublished" content="2025-12-15T13:42:59.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="天天扭码"/> <meta itemprop="url" content="https://juejin.cn/user/3349589831715801"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            如何实现流式输出？一篇文章手把手教你！
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3349589831715801/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    天天扭码
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-15T13:42:59.000Z" title="Mon Dec 15 2025 13:42:59 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-15
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    9
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读19分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>本文代码github仓库地址——<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FObjecteee%2FaiKnowedge" target="_blank" title="https://github.com/Objecteee/aiKnowedge" ref="nofollow noopener noreferrer">github.com/Objecteee/a…</a></p>
<h2 data-id="heading-0">一、什么是流式输出？</h2>
<p>流式输出是一种<strong>数据传输模式</strong>，在这种模式下，数据不是作为一个完整的、单一的包裹在一次响应中发送给客户端，而是被分成许多小的<strong>数据块 (chunks)</strong> ，并在服务器端生成的同时，<strong>持续不断、逐块地</strong>推送到客户端。例如下面的Gemini回答过程——</p>
<p align="center"><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b098f41dc36644fb971483fa5a7e0dd2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSp5aSp5omt56CB:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766412291&amp;x-signature=i7xZviKG%2BvYA1zYsFTtx6T1OaMY%3D" alt="GIF 2025-12-15 19-26-17.gif" width="50%" loading="lazy"/></p>
<h2 data-id="heading-1">二、为什么我们需要流式输出？</h2>
<p>流式输出的核心价值在于改变了用户对<strong>延迟的感知</strong>，将原本漫长的等待转化为即时的内容消费。</p>
<p><strong>1.极大地提升用户体验 (UX)：</strong></p>
<p>在传统的 <strong>请求-响应模型</strong>中，用户必须等待服务器生成并返回<strong>全部数据</strong>才能看到结果。例如，一个 AI 回复可能需要 5-10 秒。</p>
<p>流式输出则实现了内容<strong>逐块、逐字</strong>到达和显示。用户感知到的延迟从 <strong>“总生成时间”</strong> 缩短为 <strong>“首个数据块到达时间”</strong> 。这种实时反馈机制让用户感觉程序在即时响应，显著降低了等待的焦虑感。</p>
<p><strong>在 AI/LLM 场景中，</strong> 流式输出是<strong>必需品</strong>，它将数秒的枯燥等待变成了持续的阅读过程，是用户留存和产品体验的基石。</p>
<p><strong>2.提高系统和网络效率：</strong></p>
<p>流式输出技术（尤其是 <strong>SSE</strong> 和 <strong>WebSocket</strong>）通过建立持久连接，减少了重复建立和关闭 HTTP 连接的开销。
数据生成多少推送多少，网络带宽得到更有效的利用，特别是在处理大量异步或长时间运行的任务时，效率优势更为明显。</p>
<p>简单来说，流式输出的重要性在于：它把 <strong>“等待”</strong> 变成了 <strong>“消费”</strong> ，是现代交互式应用和实时数据平台的<strong>标配</strong>。</p>
<h2 data-id="heading-2">三、主流的流式输出实现</h2>
<p>流式输出主要有两种方案，第一种是SSE（基于HTTP）的单向流式输出；第二种是基于WebSocket的双向流式输出。</p>
<h3 data-id="heading-3">1.基于SSE的单向流式输出</h3>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/be674caa94c545a1bd70bb6008a9e46e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSp5aSp5omt56CB:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766412291&amp;x-signature=KZJnx9Y1OdAp4i%2FmPomM7K3sEV8%3D" alt="GIF 2025-12-15 22-02-13.gif" loading="lazy"/></p>
<h4 data-id="heading-4">（1）后端实现</h4>
<p>SSE 流式输出的后端代码是有<strong>固定的格式和严格的要求</strong>。这种格式是 <strong>Server-Sent Events 规范</strong>的核心，也是客户端浏览器能够正确解析流的关键。</p>
<h5 data-id="heading-5">A. 基础格式</h5>
<p>这是最常用、最核心的格式，用于传输数据块。</p>























<table><thead><tr><th><strong>字段</strong></th><th><strong>格式</strong></th><th><strong>作用</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><strong>Data</strong></td><td><code>data: [内容]</code></td><td>包含要发送的实际数据。客户端 <code>event.data</code> 接收到的就是 <code>:</code> 后面的内容。</td><td><code>data: Hello world\n\n</code></td></tr><tr><td><strong>分隔符</strong></td><td><code>\n\n</code></td><td><strong>至关重要！</strong> 必须以两个换行符标记一个事件块的结束。</td><td/></tr></tbody></table>
<h5 data-id="heading-6">B. 完整格式</h5>
<p>SSE 规范还允许其他可选字段，用于更复杂的流控制：</p>





























<table><thead><tr><th><strong>字段</strong></th><th><strong>格式</strong></th><th><strong>作用</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><strong>Event</strong></td><td><code>event: [事件名]</code></td><td>允许发送不同类型的事件，客户端可以通过 <code>eventSource.addEventListener('事件名', ...)</code> 监听。</td><td><code>event: update\n</code></td></tr><tr><td><strong>ID</strong></td><td><code>id: [唯一标识]</code></td><td>允许为每个事件分配一个唯一 ID。如果客户端断线重连，它会发送 <code>Last-Event-ID</code>，服务器可以从该 ID 恢复推送。</td><td><code>id: 12345\n</code></td></tr><tr><td><strong>Retry</strong></td><td><code>retry: [毫秒数]</code></td><td><strong>全局设置。</strong> 客户端断开连接后，浏览器等待该毫秒数后再尝试重连。</td><td><code>retry: 10000\n\n</code></td></tr></tbody></table>
<p><strong>一个包含所有字段的完整事件块示例如下：</strong></p>
<pre><code class="hljs language-vbnet" lang="vbnet"><span class="hljs-symbol">event:</span> system-update
<span class="hljs-symbol">id:</span> <span class="hljs-number">999</span>
<span class="hljs-symbol">retry:</span> <span class="hljs-number">5000</span>
<span class="hljs-symbol">data:</span> {<span class="hljs-string">"status"</span>: <span class="hljs-string">"ok"</span>, <span class="hljs-string">"progress"</span>: <span class="hljs-number">80</span>}
</code></pre>
<p><strong>注意：</strong> 即使使用了多个字段，<strong>最后也必须以 <code>\n\n</code> 结束</strong>。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>);
<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PORT</span> = <span class="hljs-number">3000</span>;

app.<span class="hljs-title function_">get</span>(<span class="hljs-string">'/api/stream-sse'</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {
    <span class="hljs-comment">// ------------------------------------------------------------------</span>
    <span class="hljs-comment">// A. 固定的 HTTP 响应头设置 (关键!)</span>
    <span class="hljs-comment">// ------------------------------------------------------------------</span>
    res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">'Content-Type'</span>, <span class="hljs-string">'text/event-stream'</span>);
    res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">'Cache-Control'</span>, <span class="hljs-string">'no-cache'</span>);
    res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">'Connection'</span>, <span class="hljs-string">'keep-alive'</span>);
    <span class="hljs-comment">// 允许跨域访问</span>
    res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">'Access-Control-Allow-Origin'</span>, <span class="hljs-string">'*'</span>); 

    <span class="hljs-comment">// 可选：设置断线重连时间间隔（单位：毫秒）</span>
    <span class="hljs-comment">// res.write('retry: 5000\n\n'); </span>

    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'--- SSE Connection Established ---'</span>);

    <span class="hljs-comment">// 模拟数据流式生成</span>
    <span class="hljs-keyword">let</span> counter = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">const</span> intervalId = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-keyword">if</span> (counter &gt;= <span class="hljs-number">8</span>) {
            <span class="hljs-comment">// 4. 结束流：发送 [DONE] 标记（常见实践）并关闭连接</span>
            res.<span class="hljs-title function_">write</span>(<span class="hljs-string">'data: [DONE]\n\n'</span>);
            res.<span class="hljs-title function_">end</span>();
            <span class="hljs-built_in">clearInterval</span>(intervalId);
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'--- SSE Stream Ended ---'</span>);
            <span class="hljs-keyword">return</span>;
        }

        counter++;
        <span class="hljs-keyword">const</span> payload = <span class="hljs-string">`这是第 <span class="hljs-subst">${counter}</span> 块数据，时间：<span class="hljs-subst">${<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().toLocaleTimeString()}</span>`</span>;
        
        <span class="hljs-comment">// ------------------------------------------------------------------</span>
        <span class="hljs-comment">// B. 固定的数据体格式 (严格要求!)</span>
        <span class="hljs-comment">// ------------------------------------------------------------------</span>
        <span class="hljs-keyword">const</span> sseData = 
        <span class="hljs-comment">// 1. data 字段：必须以 "data: " 开头</span>
        <span class="hljs-string">`data: <span class="hljs-subst">${payload}</span>\n`</span> + 
        <span class="hljs-comment">// 2. 两个换行符：必须以 "\n\n" 结尾，标志一个事件的结束</span>
        <span class="hljs-string">`\n`</span>; 

        <span class="hljs-comment">// 3. 实时写入数据到响应流</span>
        res.<span class="hljs-title function_">write</span>(sseData);
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Pushed: <span class="hljs-subst">${payload}</span>`</span>);

    }, <span class="hljs-number">1500</span>); <span class="hljs-comment">// 每 1.5 秒推送一次</span>

    <span class="hljs-comment">// 处理客户端断开连接的清理工作</span>
    req.<span class="hljs-title function_">on</span>(<span class="hljs-string">'close'</span>, <span class="hljs-function">() =&gt;</span> {
        <span class="hljs-built_in">clearInterval</span>(intervalId);
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Client closed connection.'</span>);
    });
});

app.<span class="hljs-title function_">listen</span>(<span class="hljs-variable constant_">PORT</span>, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`SSE Server running on http://localhost:<span class="hljs-subst">${PORT}</span>`</span>);
});
</code></pre>
<ol>
<li><strong>设置正确的 Header：</strong> 必须设置 <code>Content-Type: text/event-stream</code>。</li>
<li><strong>实时写入：</strong> 使用 Node.js 的 <code>res.write()</code> 方法，而不是等待数据全部收集完毕后使用 <code>res.send()</code>。<code>res.send()</code> 会尝试关闭连接，不适用于流式输出。</li>
<li><strong>遵守 <code>data: ...\n\n</code> 格式：</strong> 任何偏离这个格式的输出都可能导致客户端 <code>EventSource</code> 无法正确触发 <code>onmessage</code> 事件。</li>
<li><strong>连接清理：</strong> 监听 <code>req.on('close', ...)</code> 事件，确保在客户端断开连接时，服务器能停止不必要的定时器或资源占用。</li>
</ol>
<h4 data-id="heading-7">（2）前端实现</h4>
<h5 data-id="heading-8">A.浏览器原生实现（EventSource）</h5>
<p><code>EventSource</code> 是浏览器专为 SSE 规范设计的高级 API。它自动处理了底层 HTTP 连接、数据格式解析、事件触发，以及断线重连等所有复杂逻辑。</p>
<h6 data-id="heading-9">优势</h6>
<ul>
<li><strong>最简洁：</strong> 只需要几行代码即可开始监听流。</li>
<li><strong>可靠性高：</strong> 内置自动重连机制，非常健壮。</li>
<li><strong>无需手动解析：</strong> 自动将 <code>data:</code> 字段的内容提取出来，作为 <code>event.data</code>。</li>
</ul>
<h6 data-id="heading-10">局限性</h6>
<ul>
<li><strong>只能 GET 请求。</strong></li>
<li><strong>不支持自定义 Header：</strong> 无法在请求头中传递 Token（只能通过 URL query 参数）。</li>
</ul>

<pre><code class="hljs language-xml" lang="xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"zh-CN"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>EventSource 客户端示例<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
        <span class="hljs-selector-tag">body</span> { <span class="hljs-attribute">font-family</span>: <span class="hljs-string">'Segoe UI'</span>, Tahoma, Geneva, Verdana, sans-serif; <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>; }
        <span class="hljs-selector-tag">h1</span> { <span class="hljs-attribute">color</span>: <span class="hljs-number">#333</span>; }
        <span class="hljs-selector-id">#status</span> { <span class="hljs-attribute">font-weight</span>: bold; <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">15px</span>; <span class="hljs-attribute">padding</span>: <span class="hljs-number">8px</span>; <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">4px</span>; }
        <span class="hljs-selector-class">.status-connecting</span> { <span class="hljs-attribute">color</span>: orange; <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#fff3e0</span>; }
        <span class="hljs-selector-class">.status-open</span> { <span class="hljs-attribute">color</span>: green; <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#e8f5e9</span>; }
        <span class="hljs-selector-class">.status-closed</span> { <span class="hljs-attribute">color</span>: red; <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ffebee</span>; }
        <span class="hljs-selector-id">#output-area</span> { 
            <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ddd</span>; 
            <span class="hljs-attribute">padding</span>: <span class="hljs-number">15px</span>; 
            <span class="hljs-attribute">min-height</span>: <span class="hljs-number">150px</span>; 
            <span class="hljs-attribute">white-space</span>: pre-wrap; <span class="hljs-comment">/* 保持换行和空格 */</span>
            <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#fcfcfc</span>;
            <span class="hljs-attribute">overflow-y</span>: auto;
        }
        <span class="hljs-selector-class">.chunk</span> { <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">5px</span>; <span class="hljs-attribute">color</span>: <span class="hljs-number">#00796b</span>; }
        <span class="hljs-selector-class">.divider</span> { <span class="hljs-attribute">color</span>: <span class="hljs-number">#bdbdbd</span>; }
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>EventSource 实时流接收端<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"status"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"status-connecting"</span>&gt;</span>连接状态: 正在初始化...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    
    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>接收到的消息流:<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"output-area"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"closeStream()"</span>&gt;</span>🛑 停止接收流<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
        <span class="hljs-comment">// 请确保这里的 URL 与您的 Node.js 后端 SSE 路由匹配</span>
        <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">STREAM_URL</span> = <span class="hljs-string">'http://localhost:3000/api/stream-sse'</span>; 
        
        <span class="hljs-keyword">const</span> statusElement = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'status'</span>);
        <span class="hljs-keyword">const</span> outputElement = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'output-area'</span>);
        
        <span class="hljs-keyword">let</span> eventSource;

        <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateStatus</span>(<span class="hljs-params">text, className</span>) {
            statusElement.<span class="hljs-property">textContent</span> = text;
            statusElement.<span class="hljs-property">className</span> = <span class="hljs-string">''</span>;
            statusElement.<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(className);
        }

        <span class="hljs-keyword">function</span> <span class="hljs-title function_">initializeSSE</span>(<span class="hljs-params"/>) {
            outputElement.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">''</span>; <span class="hljs-comment">// 清空旧内容</span>
            
            <span class="hljs-comment">// 1. 创建 EventSource 实例并建立连接</span>
            eventSource = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventSource</span>(<span class="hljs-variable constant_">STREAM_URL</span>);
            <span class="hljs-title function_">updateStatus</span>(<span class="hljs-string">'连接状态: 正在连接...'</span>, <span class="hljs-string">'status-connecting'</span>);

            <span class="hljs-comment">// 2. 监听连接打开事件</span>
            eventSource.<span class="hljs-property">onopen</span> = <span class="hljs-function">() =&gt;</span> {
                <span class="hljs-title function_">updateStatus</span>(<span class="hljs-string">'连接状态: ✅ 已建立'</span>, <span class="hljs-string">'status-open'</span>);
                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'SSE connection opened successfully.'</span>);
            };

            <span class="hljs-comment">// 3. 监听接收到数据事件 (核心逻辑)</span>
            eventSource.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
                <span class="hljs-keyword">const</span> chunk = event.<span class="hljs-property">data</span>;
                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Received chunk:'</span>, chunk);

                <span class="hljs-comment">// 检查结束标记（与后端定义的 "[DONE]" 匹配）</span>
                <span class="hljs-keyword">if</span> (chunk === <span class="hljs-string">'[DONE]'</span>) {
                    eventSource.<span class="hljs-title function_">close</span>();
                    <span class="hljs-title function_">updateStatus</span>(<span class="hljs-string">'连接状态: 🟢 流已完成并关闭'</span>, <span class="hljs-string">'status-closed'</span>);
                    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Stream finished and closed by server.'</span>);
                    <span class="hljs-keyword">return</span>;
                }

                <span class="hljs-comment">// 实时追加数据到 UI</span>
                <span class="hljs-comment">// 使用 innerHTML 追加，可以实现更丰富的样式</span>
                outputElement.<span class="hljs-property">innerHTML</span> += <span class="hljs-string">`&lt;span class="chunk"&gt;<span class="hljs-subst">${chunk}</span>&lt;/span&gt;&lt;span class="divider"&gt; | &lt;/span&gt;`</span>;

                <span class="hljs-comment">// 确保滚动到底部以查看最新内容</span>
                outputElement.<span class="hljs-property">scrollTop</span> = outputElement.<span class="hljs-property">scrollHeight</span>;
            };

            <span class="hljs-comment">// 4. 监听错误事件（处理断线等）</span>
            eventSource.<span class="hljs-property">onerror</span> = <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {
                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'EventSource encountered an error:'</span>, error);
                
                <span class="hljs-keyword">if</span> (eventSource.<span class="hljs-property">readyState</span> === <span class="hljs-title class_">EventSource</span>.<span class="hljs-property">CLOSED</span>) {
                    <span class="hljs-title function_">updateStatus</span>(<span class="hljs-string">'连接状态: ❌ 已关闭或断开'</span>, <span class="hljs-string">'status-closed'</span>);
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-comment">// EventSource 默认会尝试自动重连</span>
                    <span class="hljs-title function_">updateStatus</span>(<span class="hljs-string">'连接状态: ⚠️ 发生错误，正在尝试重连...'</span>, <span class="hljs-string">'status-connecting'</span>);
                }
            };
        }

        <span class="hljs-comment">// 5. 客户端主动关闭流的函数</span>
        <span class="hljs-keyword">function</span> <span class="hljs-title function_">closeStream</span>(<span class="hljs-params"/>) {
            <span class="hljs-keyword">if</span> (eventSource &amp;&amp; eventSource.<span class="hljs-property">readyState</span> !== <span class="hljs-title class_">EventSource</span>.<span class="hljs-property">CLOSED</span>) {
                eventSource.<span class="hljs-title function_">close</span>();
                <span class="hljs-title function_">updateStatus</span>(<span class="hljs-string">'连接状态: 🛑 用户手动关闭'</span>, <span class="hljs-string">'status-closed'</span>);
                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'User manually closed the stream.'</span>);
            }
        }

        <span class="hljs-comment">// 页面加载完成后立即启动 SSE</span>
        <span class="hljs-variable language_">window</span>.<span class="hljs-property">onload</span> = initializeSSE;
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<h5 data-id="heading-11">阶段一：连接初始化与建立</h5>
<p>此阶段旨在建立一个持久化的 HTTP 连接，并开始监听。</p>





























<table><thead><tr><th><strong>步骤</strong></th><th><strong>动作描述</strong></th><th><strong>核心代码</strong></th><th><strong>关键点</strong></th></tr></thead><tbody><tr><td><strong>1. 创建 <code>EventSource</code> 实例</strong></td><td>使用 <code>EventSource</code> 构造函数传入 SSE 接口 URL，向服务器发起连接请求。</td><td><code>const es = new EventSource(url);</code></td><td><strong>浏览器自动处理</strong> 底层 HTTP GET 请求。</td></tr><tr><td><strong>2. 监听连接打开</strong></td><td>监听 <code>onopen</code> 事件，确认与服务器的连接已成功建立。</td><td><code>es.onopen = () =&gt; { ... }</code></td><td>此时流式数据传输通道已打开。</td></tr><tr><td><strong>3. 更新 UI 状态</strong></td><td>在 <code>onopen</code> 中，更新界面状态，提示用户数据流已开始。</td><td><code>setStatus('已连接');</code></td><td>提升用户体验。</td></tr></tbody></table>
<h5 data-id="heading-12">阶段二：数据接收与处理（核心）</h5>
<p>此阶段是持续接收服务器推送的数据，并实时更新 UI。</p>





























<table><thead><tr><th><strong>步骤</strong></th><th><strong>动作描述</strong></th><th><strong>核心代码</strong></th><th><strong>关键点</strong></th></tr></thead><tbody><tr><td><strong>4. 监听消息事件</strong></td><td>监听 <code>onmessage</code> 事件。每当服务器推送一个完整的 <code>data:...\n\n</code> 事件块时，此回调函数就会触发。</td><td><code>es.onmessage = (event) =&gt; { ... }</code></td><td><strong><code>event.data</code></strong> 包含了服务器推送的实际内容。</td></tr><tr><td><strong>5. 实时数据追加</strong></td><td>将接收到的数据 (<code>event.data</code>) <strong>追加</strong>到当前展示的文本末尾（而不是替换）。</td><td><code>currentMsg += event.data;</code></td><td>这是实现“打字机”效果的关键。</td></tr><tr><td><strong>6. 处理自定义事件</strong></td><td>如果后端使用了 <code>event: [name]</code> 字段，前端可以通过 <code>es.addEventListener('name', callback)</code> 针对性地处理不同类型的事件。</td><td><code>es.addEventListener('update', ...)</code></td><td>适用于需要区分不同业务类型数据的场景。</td></tr></tbody></table>
<h5 data-id="heading-13">阶段三：连接维护、关闭与错误处理</h5>
<p>此阶段处理流的正常结束、网络错误和重试逻辑。</p>





























<table><thead><tr><th><strong>步骤</strong></th><th><strong>动作描述</strong></th><th><strong>核心代码</strong></th><th><strong>关键点</strong></th></tr></thead><tbody><tr><td><strong>7. 监听流结束标记</strong></td><td>根据与后端约定的结束标记（如 <code>[DONE]</code>），判断流是否完成。</td><td><code>if (event.data === '[DONE]') { ... }</code></td><td><strong>流的正常结束，</strong> 避免无限等待。</td></tr><tr><td><strong>8. 关闭连接</strong></td><td>当流结束或用户主动点击“停止”按钮时，主动调用 <code>close()</code> 方法。</td><td><code>es.close();</code></td><td>释放客户端资源。</td></tr><tr><td><strong>9. 监听错误与重连</strong></td><td>监听 <code>onerror</code> 事件。当连接出错时，浏览器会根据服务器设置的 <code>retry:</code> 时间间隔自动尝试重连。</td><td><code>es.onerror = (error) =&gt; { ... }</code></td><td><strong>自动重试</strong> 是 SSE 相比于手动 <code>fetch</code> 的巨大优势。</td></tr></tbody></table>
<h5 data-id="heading-14">B.Fetch API实现</h5>
<p>当需要更强大的控制力、自定义请求头，或处理非标准 SSE 格式的流时，<code>fetch</code> 是最佳选择。</p>
<p>利用 <code>fetch</code> 返回的 <code>response.body</code>，它是一个 <strong><code>ReadableStream</code></strong> 对象。开发者需要获取这个流的 <strong>Reader</strong>，进入一个循环，<strong>手动</strong>读取数据块、解码，并根据 <code>\n\n</code> 规则<strong>手动解析</strong> SSE 格式。</p>
<h6 data-id="heading-15">优势</h6>
<ul>
<li><strong>控制力强：</strong> 可以发送 POST、PUT 等请求，并设置自定义 Header（用于鉴权）。</li>
<li><strong>通用性：</strong> 可以处理任何基于 HTTP 的流式数据，不限于 SSE 格式。</li>
<li><strong>新标准：</strong> 符合现代 Web 标准，浏览器支持良好。</li>
</ul>
<h6 data-id="heading-16">挑战</h6>
<ul>
<li><strong>实现复杂：</strong> 需要手动编写数据解析和错误重连的代码。</li>
<li><strong>性能考量：</strong> 频繁的循环读取和字符串拼接/解码操作需要谨慎优化。</li>
</ul>

<pre><code class="hljs language-xml" lang="xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"zh-CN"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Fetch API SSE 客户端示例<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
        <span class="hljs-selector-tag">body</span> { <span class="hljs-attribute">font-family</span>: <span class="hljs-string">'Segoe UI'</span>, Tahoma, Geneva, Verdana, sans-serif; <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>; }
        <span class="hljs-selector-id">#status</span> { <span class="hljs-attribute">font-weight</span>: bold; <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">15px</span>; <span class="hljs-attribute">color</span>: orange; }
        <span class="hljs-selector-id">#output-area</span> { 
            <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ddd</span>; 
            <span class="hljs-attribute">padding</span>: <span class="hljs-number">15px</span>; 
            <span class="hljs-attribute">min-height</span>: <span class="hljs-number">150px</span>; 
            <span class="hljs-attribute">white-space</span>: pre-wrap;
            <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#fcfcfc</span>;
            <span class="hljs-attribute">overflow-y</span>: auto;
        }
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>🔗 Fetch API 模拟 SSE 接收端<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"status"</span>&gt;</span>连接状态: 待启动<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    
    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>接收到的消息流:<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"output-area"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"startStream()"</span>&gt;</span>▶️ 启动流<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"stopStream()"</span>&gt;</span>🛑 停止接收流<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
        <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">STREAM_URL</span> = <span class="hljs-string">'http://localhost:3000/api/stream-sse'</span>; <span class="hljs-comment">// 确保 URL 正确</span>
        
        <span class="hljs-keyword">const</span> statusElement = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'status'</span>);
        <span class="hljs-keyword">const</span> outputElement = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'output-area'</span>);
        
        <span class="hljs-keyword">let</span> controller = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 用于控制请求中止 (AbortController)</span>

        <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateStatus</span>(<span class="hljs-params">text, color</span>) {
            statusElement.<span class="hljs-property">textContent</span> = text;
            statusElement.<span class="hljs-property">style</span>.<span class="hljs-property">color</span> = color;
        }

        <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">startStream</span>(<span class="hljs-params"/>) {
            <span class="hljs-keyword">if</span> (controller) <span class="hljs-title function_">stopStream</span>(); <span class="hljs-comment">// 确保前一个流已停止</span>

            controller = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbortController</span>();
            <span class="hljs-keyword">const</span> signal = controller.<span class="hljs-property">signal</span>;
            <span class="hljs-keyword">let</span> textDecoder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextDecoder</span>(<span class="hljs-string">'utf-8'</span>);
            <span class="hljs-keyword">let</span> buffer = <span class="hljs-string">''</span>; <span class="hljs-comment">// 缓冲区，用于存储不完整的事件块</span>

            outputElement.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">''</span>;
            <span class="hljs-title function_">updateStatus</span>(<span class="hljs-string">'连接状态: 正在连接...'</span>, <span class="hljs-string">'orange'</span>);

            <span class="hljs-keyword">try</span> {
                <span class="hljs-comment">// 1. 发起 Fetch 请求，设置 signal 用于中止</span>
                <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-variable constant_">STREAM_URL</span>, {
                    <span class="hljs-attr">method</span>: <span class="hljs-string">'GET'</span>,
                    <span class="hljs-attr">headers</span>: { <span class="hljs-string">'Accept'</span>: <span class="hljs-string">'text/event-stream'</span> },
                    <span class="hljs-attr">signal</span>: signal 
                });

                <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">body</span>) {
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"响应体不是一个可读流。"</span>);
                }

                <span class="hljs-comment">// 2. 获取 ReadableStream 的 Reader</span>
                <span class="hljs-keyword">const</span> reader = response.<span class="hljs-property">body</span>.<span class="hljs-title function_">getReader</span>();

                <span class="hljs-comment">// 3. 循环读取流数据</span>
                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
                    <span class="hljs-keyword">const</span> { done, value } = <span class="hljs-keyword">await</span> reader.<span class="hljs-title function_">read</span>();
                    
                    <span class="hljs-keyword">if</span> (done) {
                        <span class="hljs-title function_">updateStatus</span>(<span class="hljs-string">'连接状态: 🟢 流已完成'</span>, <span class="hljs-string">'green'</span>);
                        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Stream finished.'</span>);
                        <span class="hljs-keyword">break</span>;
                    }

                    <span class="hljs-comment">// 4. 解码字节数据并追加到缓冲区</span>
                    <span class="hljs-comment">// { stream: true } 允许在流继续时进行解码</span>
                    buffer += textDecoder.<span class="hljs-title function_">decode</span>(value, { <span class="hljs-attr">stream</span>: <span class="hljs-literal">true</span> });

                    <span class="hljs-comment">// 5. 手动解析 SSE 消息块</span>
                    <span class="hljs-comment">// SSE 消息以 \n\n 结束，分割缓冲区</span>
                    <span class="hljs-keyword">let</span> messages = buffer.<span class="hljs-title function_">split</span>(<span class="hljs-string">'\n\n'</span>);
                    buffer = messages.<span class="hljs-title function_">pop</span>(); <span class="hljs-comment">// 最后一个不完整的块留在缓冲区</span>

                    messages.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">message</span> =&gt;</span> {
                        <span class="hljs-keyword">if</span> (message) {
                            <span class="hljs-comment">// 6. 提取 data: 字段内容</span>
                            <span class="hljs-keyword">const</span> dataMatch = message.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/data: (.*)/</span>);
                            <span class="hljs-keyword">if</span> (dataMatch &amp;&amp; dataMatch[<span class="hljs-number">1</span>]) {
                                <span class="hljs-keyword">const</span> data = dataMatch[<span class="hljs-number">1</span>].<span class="hljs-title function_">trim</span>();

                                <span class="hljs-keyword">if</span> (data === <span class="hljs-string">'[DONE]'</span>) {
                                    controller.<span class="hljs-title function_">abort</span>(); <span class="hljs-comment">// 接收到结束标记，主动中止请求</span>
                                } <span class="hljs-keyword">else</span> {
                                    <span class="hljs-comment">// 7. 处理接收到的数据</span>
                                    outputElement.<span class="hljs-property">innerHTML</span> += <span class="hljs-string">`&lt;span class="chunk"&gt;<span class="hljs-subst">${data}</span>&lt;/span&gt;&lt;span class="divider"&gt; | &lt;/span&gt;`</span>;
                                    outputElement.<span class="hljs-property">scrollTop</span> = outputElement.<span class="hljs-property">scrollHeight</span>;
                                }
                            }
                        }
                    });
                }
            } <span class="hljs-keyword">catch</span> (error) {
                <span class="hljs-keyword">if</span> (error.<span class="hljs-property">name</span> === <span class="hljs-string">'AbortError'</span>) {
                    <span class="hljs-title function_">updateStatus</span>(<span class="hljs-string">'连接状态: 🛑 流被用户/DONE标记中止'</span>, <span class="hljs-string">'gray'</span>);
                    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Fetch request aborted successfully.'</span>);
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-title function_">updateStatus</span>(<span class="hljs-string">`连接状态: ❌ 错误: <span class="hljs-subst">${error.message}</span>`</span>, <span class="hljs-string">'red'</span>);
                    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'Fetch SSE 错误:'</span>, error);
                }
            }
        }

        <span class="hljs-keyword">function</span> <span class="hljs-title function_">stopStream</span>(<span class="hljs-params"/>) {
            <span class="hljs-keyword">if</span> (controller) {
                controller.<span class="hljs-title function_">abort</span>();
                controller = <span class="hljs-literal">null</span>;
            }
        }
        
        <span class="hljs-comment">// 页面加载完成后，设置初始状态</span>
        <span class="hljs-variable language_">window</span>.<span class="hljs-property">onload</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">updateStatus</span>(<span class="hljs-string">'连接状态: 待启动'</span>, <span class="hljs-string">'black'</span>);
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<p>Fetch API 实现流式输出是高度可定制但相对复杂的技术方案，它要求开发者<strong>手动处理数据的接收、解码和 SSE 格式的解析</strong>。整个流程可以清晰地划分为三个主要阶段。</p>
<h3 data-id="heading-17">阶段一：初始化请求与准备工作</h3>
<p>此阶段的目标是发起请求并设置流读取所需的环境。</p>






























<table><thead><tr><th><strong>步骤</strong></th><th><strong>动作描述</strong></th><th><strong>关键技术点</strong></th></tr></thead><tbody><tr><td><strong>1. 准备控制器</strong></td><td>创建 <code>AbortController</code> 实例。用于在流结束或需要中断时，能够<strong>中止</strong> <code>fetch</code> 请求。</td><td><code>new AbortController()</code></td></tr><tr><td><strong>2. 发起 Fetch 请求</strong></td><td>发起 <code>fetch</code> 请求，将 <code>controller.signal</code> 附加到请求配置中。可在 <code>headers</code> 中设置鉴权信息。</td><td><code>fetch(url, { signal: controller.signal, headers: {...} })</code></td></tr><tr><td><strong>3. 获取流读取器</strong></td><td>检查响应是否成功 (<code>response.ok</code>)，然后通过 <code>response.body.getReader()</code> 获取 <strong><code>reader</code></strong> 对象。</td><td><code>response.body.getReader()</code></td></tr><tr><td><strong>4. 准备解码器与缓冲区</strong></td><td>实例化 <code>TextDecoder</code> 用于将字节解码为字符串，并初始化一个 <strong><code>buffer</code></strong> 变量用于暂存不完整的数据片段。</td><td><code>new TextDecoder('utf-8')</code>, <code>let buffer = ''</code></td></tr></tbody></table>
<h3 data-id="heading-18">阶段二：循环读取、解码与解析（核心）</h3>
<p>此阶段是整个流程最复杂的部分，需要持续从流中拉取数据并手动解析 SSE 格式。</p>













































<table><thead><tr><th><strong>步骤</strong></th><th><strong>动作描述</strong></th><th><strong>关键技术点</strong></th></tr></thead><tbody><tr><td><strong>5. 启动读取循环</strong></td><td>使用 <code>while (true)</code> 或类似的循环结构开始持续读取数据。</td><td><code>while (true)</code></td></tr><tr><td><strong>6. 读取数据块</strong></td><td>调用 <code>await reader.read()</code>。它会暂停执行，等待服务器推送新的数据块 (<code>value: Uint8Array</code>)。</td><td><code>const { done, value } = await reader.read()</code></td></tr><tr><td><strong>7. 判断流结束</strong></td><td>检查 <code>done</code> 属性。如果为 <code>true</code>，跳出循环，进入清理阶段。</td><td><code>if (done) break;</code></td></tr><tr><td><strong>8. 解码与缓冲</strong></td><td>使用 <code>TextDecoder</code> 将原始字节 <code>value</code> 解码为字符串，并将其<strong>追加</strong>到缓冲区 (<code>buffer</code>) 中。</td><td><code>buffer += decoder.decode(value, { stream: true })</code></td></tr><tr><td><strong>9. 手动解析 SSE</strong></td><td>使用 <code>buffer.split('\n\n')</code> 将缓冲区内容分割成潜在的 SSE 消息数组。然后将数组中<strong>最后一个不完整的块</strong>重新放回缓冲区。</td><td><code>buffer.split('\n\n')</code>, <code>buffer = messages.pop()</code></td></tr><tr><td><strong>10. 提取数据</strong></td><td>遍历其余完整的消息块，使用正则表达式（如 <code>/data: (.*)/</code>）手动提取 <strong><code>data:</code></strong> 字段后的实际内容。</td><td><code>message.match(/data: (.*)/)</code></td></tr><tr><td><strong>11. 实时处理</strong></td><td>将提取到的数据追加到 UI 界面，并执行所需的业务逻辑。</td><td>UI 更新、滚动到底部</td></tr></tbody></table>
<h3 data-id="heading-19">阶段三：连接清理与错误处理</h3>
<p>此阶段确保流的正确终止和资源释放。</p>

























<table><thead><tr><th><strong>步骤</strong></th><th><strong>动作描述</strong></th><th><strong>关键技术点</strong></th></tr></thead><tbody><tr><td><strong>12. 处理结束标记</strong></td><td>在数据处理逻辑中，如果检测到服务器推送的结束标记（如 <code>[DONE]</code>），则立即调用 <strong><code>controller.abort()</code></strong> 终止流。</td><td><code>controller.abort()</code></td></tr><tr><td><strong>13. 错误捕获</strong></td><td>将整个 <code>fetch</code> 和流读取循环包裹在 <code>try...catch</code> 块中。捕获网络错误和因 <code>controller.abort()</code> 产生的 <code>AbortError</code>。</td><td><code>try...catch (error)</code></td></tr><tr><td><strong>14. 释放资源</strong></td><td>无论是正常结束还是出错，确保所有相关资源（如 <code>reader</code>）得到释放。</td><td><strong><code>AbortController</code></strong> 自动处理了请求的终止。</td></tr></tbody></table>
<p>通过这种手动控制的方式，Fetch API 提供了对流的<strong>最高级别控制</strong>，但代价是代码实现更为复杂，且需要开发者手动处理自动重连等健壮性机制。</p>
<h5 data-id="heading-20">C.Axios API实现</h5>
<p>使用 <code>axios</code> 实现流式输出主要依赖其配置项，但在浏览器环境下的表现不如 <code>fetch</code> 和 <code>EventSource</code>。</p>
<p>在 <code>axios</code> 的配置中，需要显式设置 <code>responseType: 'stream'</code>。在 <strong>Node.js</strong> 环境中，这会返回一个 Node.js 的流，处理起来比较方便。但在<strong>浏览器环境</strong>中，<code>axios</code> 对流的封装不如 <code>fetch</code> 原生。</p>
<h6 data-id="heading-21">优势</h6>
<ul>
<li><strong>Node.js 友好：</strong> 在 Node.js 环境中处理流式数据很方便。</li>
<li><strong>代码统一：</strong> 如果应用大量依赖 <code>axios</code>，可以避免引入 <code>fetch</code>。</li>
</ul>
<h6 data-id="heading-22">挑战</h6>
<ul>
<li><strong>浏览器兼容性/稳定性：</strong> 浏览器端对 <code>axios</code> 流的稳定支持不如 <code>fetch</code> 和 <code>EventSource</code>。</li>
<li><strong>解析依然需要手动：</strong> 像 <code>fetch</code> 一样，您仍然需要获取流并手动进行 SSE 格式的解析和解码。</li>
<li><strong>潜在的内存问题：</strong> 如果流处理不当，可能会导致内存占用过高。</li>
</ul>

<pre><code class="hljs language-xml" lang="xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"zh-CN"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Axios 客户端模拟 SSE 示例<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
        <span class="hljs-selector-tag">body</span> { <span class="hljs-attribute">font-family</span>: <span class="hljs-string">'Segoe UI'</span>, Tahoma, Geneva, Verdana, sans-serif; <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>; }
        <span class="hljs-selector-id">#status</span> { <span class="hljs-attribute">font-weight</span>: bold; <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">15px</span>; <span class="hljs-attribute">color</span>: orange; }
        <span class="hljs-selector-id">#output-area</span> { 
            <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ddd</span>; 
            <span class="hljs-attribute">padding</span>: <span class="hljs-number">15px</span>; 
            <span class="hljs-attribute">min-height</span>: <span class="hljs-number">150px</span>; 
            <span class="hljs-attribute">white-space</span>: pre-wrap;
            <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#fcfcfc</span>;
            <span class="hljs-attribute">overflow-y</span>: auto;
        }
        <span class="hljs-selector-class">.chunk</span> { <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">5px</span>; <span class="hljs-attribute">color</span>: <span class="hljs-number">#00796b</span>; }
        <span class="hljs-selector-class">.divider</span> { <span class="hljs-attribute">color</span>: <span class="hljs-number">#bdbdbd</span>; }
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>🛠️ Axios 模拟 SSE 接收端<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"status"</span>&gt;</span>连接状态: 待启动<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    
    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>接收到的消息流:<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"output-area"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"startStream()"</span>&gt;</span>▶️ 启动流<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"stopStream()"</span>&gt;</span>🛑 停止接收流<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
        <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">STREAM_URL</span> = <span class="hljs-string">'http://localhost:3000/api/stream-sse'</span>;
        
        <span class="hljs-keyword">const</span> statusElement = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'status'</span>);
        <span class="hljs-keyword">const</span> outputElement = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'output-area'</span>);
        
        <span class="hljs-keyword">let</span> cancelTokenSource = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 用于取消请求的 Axios Token</span>
        <span class="hljs-keyword">let</span> lastProcessedIndex = <span class="hljs-number">0</span>;   <span class="hljs-comment">// 追踪上次处理到的数据索引</span>
        <span class="hljs-keyword">let</span> buffer = <span class="hljs-string">''</span>;              <span class="hljs-comment">// 用于存放不完整的 SSE 事件块</span>
        <span class="hljs-keyword">let</span> isConnected = <span class="hljs-literal">false</span>;      <span class="hljs-comment">// 标记是否已建立连接</span>

        <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateStatus</span>(<span class="hljs-params">text, color</span>) {
            statusElement.<span class="hljs-property">textContent</span> = text;
            statusElement.<span class="hljs-property">style</span>.<span class="hljs-property">color</span> = color;
        }

        <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">startStream</span>(<span class="hljs-params"/>) {
            <span class="hljs-keyword">if</span> (cancelTokenSource) <span class="hljs-title function_">stopStream</span>();

            cancelTokenSource = axios.<span class="hljs-property">CancelToken</span>.<span class="hljs-title function_">source</span>();
            lastProcessedIndex = <span class="hljs-number">0</span>;
            buffer = <span class="hljs-string">''</span>;
            isConnected = <span class="hljs-literal">false</span>;
            outputElement.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">''</span>;
            <span class="hljs-title function_">updateStatus</span>(<span class="hljs-string">'连接状态: 正在连接...'</span>, <span class="hljs-string">'orange'</span>);

            <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">await</span> axios.<span class="hljs-title function_">get</span>(<span class="hljs-variable constant_">STREAM_URL</span>, {
                    <span class="hljs-attr">responseType</span>: <span class="hljs-string">'text'</span>,
                    <span class="hljs-attr">cancelToken</span>: cancelTokenSource.<span class="hljs-property">token</span>,
                    <span class="hljs-attr">onDownloadProgress</span>: <span class="hljs-function">(<span class="hljs-params">progressEvent</span>) =&gt;</span> {
                        <span class="hljs-keyword">let</span> xhr = progressEvent.<span class="hljs-property">currentTarget</span> || progressEvent.<span class="hljs-property">target</span>;
                        <span class="hljs-keyword">if</span> (progressEvent.<span class="hljs-property">event</span> &amp;&amp; progressEvent.<span class="hljs-property">event</span>.<span class="hljs-property">target</span>) {
                            xhr = progressEvent.<span class="hljs-property">event</span>.<span class="hljs-property">target</span>;
                        }
                        
                        <span class="hljs-keyword">if</span> (!xhr || <span class="hljs-keyword">typeof</span> xhr.<span class="hljs-property">responseText</span> === <span class="hljs-string">'undefined'</span>) {
                            <span class="hljs-keyword">return</span>;
                        }
                        
                        <span class="hljs-keyword">const</span> responseText = xhr.<span class="hljs-property">responseText</span>;
                        <span class="hljs-keyword">const</span> newChunk = responseText.<span class="hljs-title function_">substring</span>(lastProcessedIndex);
                        lastProcessedIndex = responseText.<span class="hljs-property">length</span>;
                        buffer += newChunk;

                        <span class="hljs-comment">// 收到数据时更新连接状态</span>
                        <span class="hljs-keyword">if</span> (!isConnected &amp;&amp; newChunk.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {
                            isConnected = <span class="hljs-literal">true</span>;
                            <span class="hljs-title function_">updateStatus</span>(<span class="hljs-string">'连接状态: ✅ 已连接，正在接收数据...'</span>, <span class="hljs-string">'green'</span>);
                        }

                        <span class="hljs-keyword">let</span> messages = buffer.<span class="hljs-title function_">split</span>(<span class="hljs-string">'\n\n'</span>);
                        buffer = messages.<span class="hljs-title function_">pop</span>() || <span class="hljs-string">''</span>;

                        messages.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">message</span> =&gt;</span> {
                            <span class="hljs-keyword">if</span> (message.<span class="hljs-title function_">trim</span>()) {
                                <span class="hljs-keyword">const</span> dataMatch = message.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/data: (.*)/</span>);
                                <span class="hljs-keyword">if</span> (dataMatch &amp;&amp; dataMatch[<span class="hljs-number">1</span>]) {
                                    <span class="hljs-keyword">const</span> data = dataMatch[<span class="hljs-number">1</span>].<span class="hljs-title function_">trim</span>();
                                    <span class="hljs-keyword">if</span> (data === <span class="hljs-string">'[DONE]'</span>) {
                                        <span class="hljs-title function_">stopStream</span>(<span class="hljs-literal">true</span>);
                                    } <span class="hljs-keyword">else</span> {
                                        outputElement.<span class="hljs-property">innerHTML</span> += <span class="hljs-string">`&lt;span class="chunk"&gt;<span class="hljs-subst">${data}</span>&lt;/span&gt;&lt;span class="divider"&gt; | &lt;/span&gt;`</span>;
                                        outputElement.<span class="hljs-property">scrollTop</span> = outputElement.<span class="hljs-property">scrollHeight</span>;
                                    }
                                }
                            }
                        });
                    }
                });
            } <span class="hljs-keyword">catch</span> (error) {
                <span class="hljs-keyword">if</span> (axios.<span class="hljs-title function_">isCancel</span>(error)) {
                    <span class="hljs-title function_">updateStatus</span>(<span class="hljs-string">'连接状态: 🛑 流已中止'</span>, <span class="hljs-string">'gray'</span>);
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-title function_">updateStatus</span>(<span class="hljs-string">`连接状态: ❌ 错误: <span class="hljs-subst">${error.message}</span>`</span>, <span class="hljs-string">'red'</span>);
                    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'Axios SSE 错误:'</span>, error);
                }
            }
        }

        <span class="hljs-keyword">function</span> <span class="hljs-title function_">stopStream</span>(<span class="hljs-params">isDone = <span class="hljs-literal">false</span></span>) {
            <span class="hljs-keyword">if</span> (cancelTokenSource) {
                cancelTokenSource.<span class="hljs-title function_">cancel</span>(<span class="hljs-string">'Stream terminated.'</span>);
                cancelTokenSource = <span class="hljs-literal">null</span>;
                <span class="hljs-keyword">if</span> (isDone) {
                    <span class="hljs-title function_">updateStatus</span>(<span class="hljs-string">'连接状态: 🟢 流已完成并关闭'</span>, <span class="hljs-string">'green'</span>);
                }
            }
        }
        
        <span class="hljs-variable language_">window</span>.<span class="hljs-property">onload</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">updateStatus</span>(<span class="hljs-string">'连接状态: 待启动'</span>, <span class="hljs-string">'black'</span>);
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<p>Axios 并非为 SSE 设计的，因为它基于传统的 XMLHttpRequest (XHR) 模型，或者在 Node.js 中基于 <code>http</code> 模块。在<strong>浏览器环境</strong>中，Axios 没有原生 <code>EventSource</code> 或 <code>ReadableStream</code> 的支持。</p>
<p>因此，使用 Axios 实现流式输出的<strong>标准工作流程</strong>是利用 XHR 的 <strong><code>onprogress</code></strong> 事件监听机制（在 Axios 中表现为 <code>onDownloadProgress</code> 回调），手动获取每次新增的数据块，并手动进行 SSE 格式的解析。</p>
<ol>
<li><strong>没有自动解析：</strong> 必须手动解析 <code>data:</code> 字段和 <code>\n\n</code> 分隔符。</li>
<li><strong>手动追踪数据：</strong> 每次 <code>onDownloadProgress</code> 触发时，返回的是<strong>当前已接收的全部数据</strong>，而不是新增的数据。您需要一个指针来追踪上次处理到了哪里，并提取出新的数据块。</li>
<li><strong>不支持自动重连：</strong> 必须手动实现错误检测和重连逻辑（本示例不包含重连，但需注意）。</li>
</ol>
<h5 data-id="heading-23">流式输出技术的选择</h5>
<h6 data-id="heading-24">1. 🥇 EventSource API</h6>
<p>这是实现 SSE 的<strong>标准和首选</strong>方案。</p>
<ul>
<li>
<p><strong>实现复杂度：</strong> <strong>最低。</strong> 浏览器原生支持，代码量最少。</p>
</li>
<li>
<p><strong>核心优势：</strong> <strong>内置健壮性。</strong> 自动处理 SSE 数据格式解析、消息事件 (<code>onmessage</code>) 触发，并内置了断线重连机制（支持服务器设置 <code>retry:</code> 间隔）。</p>
</li>
<li>
<p><strong>主要局限：</strong></p>
<ul>
<li><strong>只能 GET 请求。</strong></li>
<li><strong>不支持自定义 Header 鉴权。</strong> 只能通过 URL 参数传递 Token，安全性相对较低。</li>
</ul>
</li>
<li>
<p><strong>选择原则：</strong> <strong>强烈推荐</strong>用于大多数场景，尤其是在安全性要求不涉及请求 Header（例如，使用 Session Cookie 或 URL Token 鉴权）且只需要单向数据推送时。</p>
</li>
</ul>
<h6 data-id="heading-25">2. 🥈 Fetch API + ReadableStream</h6>
<p>这是在需要高控制度时使用的现代标准方案。</p>
<ul>
<li>
<p><strong>实现复杂度：</strong> <strong>中高。</strong> 需要手动获取流阅读器 (<code>getReader()</code>)，并进入循环，手动进行 SSE 数据解析（解码字节、查找 <code>\n\n</code>、提取 <code>data:</code>）。</p>
</li>
<li>
<p><strong>核心优势：</strong> <strong>控制力最强。</strong></p>
<ul>
<li>支持自定义 HTTP Header（适用于传递 JWT 等鉴权信息）。</li>
<li>支持 POST 等其他 HTTP 方法。</li>
<li>可以处理非标准的流格式。</li>
</ul>
</li>
<li>
<p><strong>主要局限：</strong> 必须手动编写复杂的 SSE 格式解析逻辑和错误重连机制。</p>
</li>
<li>
<p><strong>选择原则：</strong> 当您<strong>必须</strong>在请求 Header 中传递鉴权信息（例如 JWT），或者需要处理非标准的流格式时，应选择此方案。</p>
</li>
</ul>
<h6 data-id="heading-26">3. 🥉 Axios + onDownloadProgress</h6>
<p>这是基于旧的 XHR 机制的模拟方案，<strong>通常不推荐</strong>用于现代 Web 应用的 SSE。</p>
<ul>
<li>
<p><strong>实现复杂度：</strong> <strong>高。</strong> 依赖 <code>onDownloadProgress</code> 事件，每次事件触发返回的是<strong>全部</strong>已接收数据，因此需要额外的逻辑来追踪上次处理的索引，以提取新增的数据块。</p>
</li>
<li>
<p><strong>核心优势：</strong> 如果您的项目大量依赖 Axios，可以保持技术栈的统一。</p>
</li>
<li>
<p><strong>主要局限：</strong></p>
<ul>
<li>实现流程复杂且易错。</li>
<li>性能不如原生 API，且不支持原生的自动重连。</li>
<li>在浏览器环境中，缺乏对流的标准化支持。</li>
</ul>
</li>
<li>
<p><strong>选择原则：</strong> 仅在需要兼容旧环境或因特殊限制<strong>无法使用 <code>EventSource</code> 或 <code>fetch</code></strong> 的情况下考虑。</p>
</li>
</ul>
<h3 data-id="heading-27">2.基于WebSocket的双向流式输出实现</h3>
<p>WebSocket 协议与 SSE（单向流）和传统的 HTTP 请求（一次性传输）有着本质的区别，它在客户端和服务器之间建立了一个持久的、<strong>全双工（双向）</strong> 的通信通道，非常适合需要高频率、低延迟交互的场景。</p>
<h4 data-id="heading-28">1. 协议升级</h4>
<p>WebSocket 连接的建立始于一个标准的 HTTP 请求，这个请求包含了特殊的 Header，用于请求将连接从 HTTP <strong>升级（Upgrade）</strong> 到 WebSocket 协议。一旦升级成功，连接就不再受限于传统的 HTTP 请求-响应模型。</p>
<h4 data-id="heading-29">2. 全双工通信</h4>
<p>一旦连接建立，服务器和客户端可以<strong>独立、同时地</strong>互相发送数据帧。</p>
<ul>
<li><strong>客户端 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"/><span class="mrel">→</span></span></span></span></span> 服务器：</strong> 客户端可以随时发送输入、控制命令或心跳包。</li>
<li><strong>服务器 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"/><span class="mrel">→</span></span></span></span></span> 客户端：</strong> 服务器可以随时发送流式数据、状态更新或响应。</li>
</ul>
<p>这种双向性使得 WebSocket 不仅可以用于流式输出（服务器推数据），还可以用于实时接收用户输入，完美支持 <strong>实时聊天</strong> 或 <strong>协作编辑</strong> 等场景。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a3069d503a494ec090c04f35cdc6f07a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSp5aSp5omt56CB:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766412291&amp;x-signature=4GXjB9BUL9HsVXDblZgF%2Blgd46Q%3D" alt="WebSocket bidirectional communication diagram的图片" loading="lazy"/></p>
<h4 data-id="heading-30">3. 基于帧的传输</h4>
<p>WebSocket 的数据传输是基于<strong>帧</strong>的，而不是基于文本流或 HTTP 请求。这使得传输效率更高，延迟更低。帧可以包含文本数据（Text Frame）或二进制数据（Binary Frame）。</p>
<hr/>
<p>基于 WebSocket 的双向流式输出需要前端和后端分别<strong>使用专门的库和 API 进行</strong>实现。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/74f39a28fe9243eb92cd01fa86b8f306~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSp5aSp5omt56CB:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766412291&amp;x-signature=6krzmCfdIO55YFCsHg4rbpX41Gc%3D" alt="GIF 2025-12-15 22-03-28.gif" loading="lazy"/></p>
<h4 data-id="heading-31">1. 后端实现 (Node.js/ws 或 Socket.IO)</h4>
<p>后端需要一个专门的 WebSocket 服务器来管理连接和发送数据帧。</p>



































<table><thead><tr><th><strong>步骤</strong></th><th><strong>动作描述</strong></th><th><strong>关键技术点</strong></th></tr></thead><tbody><tr><td><strong>1. 握手与连接</strong></td><td>监听 HTTP 升级请求，接受连接，并分配一个唯一的 WebSocket 连接对象。</td><td><code>ws.on('connection', (socket) =&gt; { ... })</code></td></tr><tr><td><strong>2. 接收客户端输入</strong></td><td>监听客户端发送过来的数据帧，用于触发 AI 任务或控制流。</td><td><code>socket.on('message', (input) =&gt; { // Process input })</code></td></tr><tr><td><strong>3. 流式生成与推送</strong></td><td>在 AI 模型生成数据的过程中，将数据块封装成 WebSocket 帧并实时发送。</td><td><code>socket.send(data_chunk)</code></td></tr><tr><td><strong>4. 维护连接</strong></td><td>维护连接状态，处理心跳包（Ping/Pong），并在客户端断开时清理资源。</td><td><code>socket.on('close', ...)</code></td></tr><tr><td/><td/><td/></tr></tbody></table>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">WebSocket</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'ws'</span>);

<span class="hljs-comment">// 创建 WebSocket 服务器，监听 8080 端口</span>
<span class="hljs-keyword">const</span> wss = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>.<span class="hljs-title class_">Server</span>({ <span class="hljs-attr">port</span>: <span class="hljs-number">8080</span> });

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'WebSocket Server running on ws://localhost:8080'</span>);

<span class="hljs-comment">// 监听客户端连接事件</span>
wss.<span class="hljs-title function_">on</span>(<span class="hljs-string">'connection'</span>, <span class="hljs-keyword">function</span> <span class="hljs-title function_">connection</span>(<span class="hljs-params">ws</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'--- Client Connected ---'</span>);
    
    <span class="hljs-comment">// 1. 监听客户端发来的消息（双向输入）</span>
    ws.<span class="hljs-title function_">on</span>(<span class="hljs-string">'message'</span>, <span class="hljs-keyword">function</span> <span class="hljs-title function_">incoming</span>(<span class="hljs-params">message</span>) {
        <span class="hljs-keyword">const</span> clientMessage = message.<span class="hljs-title function_">toString</span>();
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Received message from client: <span class="hljs-subst">${clientMessage}</span>`</span>);

        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">const</span> data = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(clientMessage);
            
            <span class="hljs-keyword">if</span> (data.<span class="hljs-property">command</span> === <span class="hljs-string">'START'</span>) {
                <span class="hljs-comment">// 客户端请求开始流式输出</span>
                <span class="hljs-title function_">startStreaming</span>(ws, data.<span class="hljs-property">prompt</span>);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data.<span class="hljs-property">command</span> === <span class="hljs-string">'STOP'</span>) {
                <span class="hljs-comment">// 客户端请求停止流式输出 (实时控制)</span>
                <span class="hljs-title function_">stopStreaming</span>(ws);
                ws.<span class="hljs-title function_">send</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({ <span class="hljs-attr">status</span>: <span class="hljs-string">'info'</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">'Streaming stopped by client.'</span> }));
            }
        } <span class="hljs-keyword">catch</span> (e) {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'Error parsing client message:'</span>, e);
            ws.<span class="hljs-title function_">send</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({ <span class="hljs-attr">status</span>: <span class="hljs-string">'error'</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">'Invalid JSON format.'</span> }));
        }
    });

    <span class="hljs-comment">// 监听连接关闭事件</span>
    ws.<span class="hljs-title function_">on</span>(<span class="hljs-string">'close'</span>, <span class="hljs-keyword">function</span> <span class="hljs-title function_">close</span>(<span class="hljs-params"/>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'--- Client Disconnected ---'</span>);
        <span class="hljs-comment">// 清理资源，停止该连接上的所有流</span>
        <span class="hljs-title function_">stopStreaming</span>(ws);
    });

    <span class="hljs-comment">// 初始问候</span>
    ws.<span class="hljs-title function_">send</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({ <span class="hljs-attr">status</span>: <span class="hljs-string">'ready'</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">'Welcome! Send {"command": "START", "prompt": "..."} to begin streaming.'</span> }));
});

<span class="hljs-comment">// 存储当前正在流式输出的连接和定时器</span>
<span class="hljs-keyword">const</span> activeStreams = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();

<span class="hljs-comment">/**
 * 模拟 AI 模型流式输出的函数
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">WebSocket</span>} <span class="hljs-variable">ws</span> - 当前连接的 WebSocket 实例
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">prompt</span> - 客户端提供的输入提示
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">startStreaming</span>(<span class="hljs-params">ws, prompt</span>) {
    <span class="hljs-keyword">if</span> (activeStreams.<span class="hljs-title function_">has</span>(ws)) {
        ws.<span class="hljs-title function_">send</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({ <span class="hljs-attr">status</span>: <span class="hljs-string">'info'</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">'Stream is already active.'</span> }));
        <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">let</span> counter = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">const</span> intervalId = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
        counter++;
        <span class="hljs-keyword">const</span> chunk = <span class="hljs-string">`[Chunk <span class="hljs-subst">${counter}</span>] Output for "<span class="hljs-subst">${prompt.substring(<span class="hljs-number">0</span>, <span class="hljs-number">15</span>)}</span>...": Data block <span class="hljs-subst">${counter}</span>.`</span>;
        
        <span class="hljs-comment">// 2. 实时将数据块作为 WebSocket 帧发送给客户端</span>
        <span class="hljs-comment">// 使用 JSON 格式封装数据，方便客户端解析</span>
        <span class="hljs-keyword">const</span> dataToSend = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({ 
            <span class="hljs-attr">type</span>: <span class="hljs-string">'data'</span>, 
            <span class="hljs-attr">content</span>: chunk,
            <span class="hljs-attr">count</span>: counter
        });
        
        <span class="hljs-comment">// 检查连接是否仍然打开</span>
        <span class="hljs-keyword">if</span> (ws.<span class="hljs-property">readyState</span> === <span class="hljs-title class_">WebSocket</span>.<span class="hljs-property">OPEN</span>) {
            ws.<span class="hljs-title function_">send</span>(dataToSend);
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Pushed data chunk <span class="hljs-subst">${counter}</span>`</span>);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// 如果连接关闭，停止流</span>
            <span class="hljs-built_in">clearInterval</span>(intervalId);
            activeStreams.<span class="hljs-title function_">delete</span>(ws);
        }

        <span class="hljs-keyword">if</span> (counter &gt;= <span class="hljs-number">15</span>) {
            <span class="hljs-comment">// 3. 流结束，发送结束标记</span>
            <span class="hljs-built_in">clearInterval</span>(intervalId);
            activeStreams.<span class="hljs-title function_">delete</span>(ws);
            <span class="hljs-keyword">if</span> (ws.<span class="hljs-property">readyState</span> === <span class="hljs-title class_">WebSocket</span>.<span class="hljs-property">OPEN</span>) {
                 ws.<span class="hljs-title function_">send</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">'done'</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">'Streaming complete.'</span> }));
            }
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'--- Streaming finished ---'</span>);
        }
    }, <span class="hljs-number">500</span>); <span class="hljs-comment">// 每 500 毫秒发送一个数据块</span>

    activeStreams.<span class="hljs-title function_">set</span>(ws, intervalId);
}

<span class="hljs-comment">/**
 * 停止指定连接的流式输出
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">stopStreaming</span>(<span class="hljs-params">ws</span>) {
    <span class="hljs-keyword">if</span> (activeStreams.<span class="hljs-title function_">has</span>(ws)) {
        <span class="hljs-built_in">clearInterval</span>(activeStreams.<span class="hljs-title function_">get</span>(ws));
        activeStreams.<span class="hljs-title function_">delete</span>(ws);
    }
}
</code></pre>
<h4 data-id="heading-32">2. 前端实现 (Browser WebSocket API)</h4>
<p>前端使用浏览器原生的 <code>WebSocket</code> API 来建立连接和处理双向通信。</p>






























<table><thead><tr><th><strong>步骤</strong></th><th><strong>动作描述</strong></th><th><strong>关键技术点</strong></th></tr></thead><tbody><tr><td><strong>1. 建立连接</strong></td><td>使用 <code>new WebSocket(ws://url)</code> 建立连接。注意协议是 <code>ws://</code> 或 <code>wss://</code>。</td><td><code>new WebSocket('ws://localhost:8080')</code></td></tr><tr><td><strong>2. 监听连接状态</strong></td><td>监听 <code>onopen</code>（连接成功）、<code>onerror</code> 和 <code>onclose</code> 事件。</td><td><code>ws.onopen = () =&gt; {...}</code></td></tr><tr><td><strong>3. 接收流式输出</strong></td><td>监听 <strong><code>onmessage</code></strong> 事件，接收服务器推送的流式数据帧，并实时追加到 UI。</td><td><code>ws.onmessage = (event) =&gt; { // Append event.data }</code></td></tr><tr><td><strong>4. 发送客户端输入</strong></td><td>当用户有新输入或需要发送控制命令时，通过 <code>send()</code> 方法发送数据帧到服务器。</td><td><code>ws.send(JSON.stringify({command: 'stop'}))</code></td></tr></tbody></table>
<hr/>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"zh-CN"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>WebSocket 双向流式输出<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
        <span class="hljs-selector-tag">body</span> { <span class="hljs-attribute">font-family</span>: Arial, sans-serif; <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>; }
        <span class="hljs-selector-id">#status</span> { <span class="hljs-attribute">font-weight</span>: bold; <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">15px</span>; }
        <span class="hljs-selector-id">#output-area</span> { <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ccc</span>; <span class="hljs-attribute">padding</span>: <span class="hljs-number">15px</span>; <span class="hljs-attribute">min-height</span>: <span class="hljs-number">150px</span>; <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#f9f9f9</span>; <span class="hljs-attribute">white-space</span>: pre-wrap; <span class="hljs-attribute">overflow-y</span>: scroll; }
        <span class="hljs-selector-class">.control-panel</span> { <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">20px</span>; }
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>💬 WebSocket 双向流式交互<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"status"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"color: gray;"</span>&gt;</span>连接状态: 待连接...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    
    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>服务器输出流:<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"output-area"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"control-panel"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">"prompt"</span>&gt;</span>输入提示:<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"prompt"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"请给我写一篇关于AI流式输出的文章"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"width: 300px;"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"connectWebSocket()"</span>&gt;</span>建立连接<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"startStream()"</span>&gt;</span>▶️ 启动流式输出<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"stopStream()"</span>&gt;</span>🛑 实时停止流<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"closeWebSocket()"</span>&gt;</span>断开连接<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
        <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">WS_URL</span> = <span class="hljs-string">'ws://localhost:8080'</span>;
        <span class="hljs-keyword">let</span> ws = <span class="hljs-literal">null</span>;

        <span class="hljs-keyword">const</span> statusElement = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'status'</span>);
        <span class="hljs-keyword">const</span> outputElement = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'output-area'</span>);
        <span class="hljs-keyword">const</span> promptInput = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'prompt'</span>);

        <span class="hljs-keyword">function</span> <span class="hljs-title function_">log</span>(<span class="hljs-params">message</span>) {
            outputElement.<span class="hljs-property">innerHTML</span> += <span class="hljs-string">`&lt;p style="margin: 0; padding: 2px 0;"&gt;<span class="hljs-subst">${message}</span>&lt;/p&gt;`</span>;
            outputElement.<span class="hljs-property">scrollTop</span> = outputElement.<span class="hljs-property">scrollHeight</span>;
        }
        
        <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateStatus</span>(<span class="hljs-params">text, color</span>) {
            statusElement.<span class="hljs-property">textContent</span> = text;
            statusElement.<span class="hljs-property">style</span>.<span class="hljs-property">color</span> = color;
        }

        <span class="hljs-comment">// 1. 建立 WebSocket 连接</span>
        <span class="hljs-keyword">function</span> <span class="hljs-title function_">connectWebSocket</span>(<span class="hljs-params"/>) {
            <span class="hljs-keyword">if</span> (ws &amp;&amp; ws.<span class="hljs-property">readyState</span> === <span class="hljs-title class_">WebSocket</span>.<span class="hljs-property">OPEN</span>) {
                <span class="hljs-title function_">updateStatus</span>(<span class="hljs-string">'连接已存在'</span>, <span class="hljs-string">'blue'</span>);
                <span class="hljs-keyword">return</span>;
            }

            ws = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(<span class="hljs-variable constant_">WS_URL</span>);
            <span class="hljs-title function_">updateStatus</span>(<span class="hljs-string">'正在连接...'</span>, <span class="hljs-string">'orange'</span>);
            outputElement.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">''</span>;

            <span class="hljs-comment">// 监听连接成功事件</span>
            ws.<span class="hljs-property">onopen</span> = <span class="hljs-function">() =&gt;</span> {
                <span class="hljs-title function_">updateStatus</span>(<span class="hljs-string">'连接状态: ✅ 已建立'</span>, <span class="hljs-string">'green'</span>);
                <span class="hljs-title function_">log</span>(<span class="hljs-string">'--- WebSocket Connection Opened ---'</span>);
            };

            <span class="hljs-comment">// 2. 监听接收到的数据帧 (核心)</span>
            ws.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
                <span class="hljs-keyword">try</span> {
                    <span class="hljs-keyword">const</span> data = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(event.<span class="hljs-property">data</span>);
                    
                    <span class="hljs-keyword">if</span> (data.<span class="hljs-property">type</span> === <span class="hljs-string">'data'</span>) {
                        <span class="hljs-comment">// 实时追加流式输出的内容</span>
                        <span class="hljs-title function_">log</span>(<span class="hljs-string">`[Server Stream]: <span class="hljs-subst">${data.content}</span>`</span>);
                    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data.<span class="hljs-property">type</span> === <span class="hljs-string">'done'</span>) {
                        <span class="hljs-title function_">log</span>(<span class="hljs-string">`[INFO]: <span class="hljs-subst">${data.message}</span>`</span>);
                        <span class="hljs-title function_">updateStatus</span>(<span class="hljs-string">'流已完成'</span>, <span class="hljs-string">'blue'</span>);
                    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data.<span class="hljs-property">status</span> === <span class="hljs-string">'info'</span>) {
                        <span class="hljs-title function_">log</span>(<span class="hljs-string">`[INFO]: <span class="hljs-subst">${data.message}</span>`</span>);
                    }
                } <span class="hljs-keyword">catch</span> (e) {
                    <span class="hljs-comment">// 处理非 JSON 格式的消息</span>
                    <span class="hljs-title function_">log</span>(<span class="hljs-string">`[RAW MESSAGE]: <span class="hljs-subst">${event.data}</span>`</span>);
                }
            };

            <span class="hljs-comment">// 监听错误事件</span>
            ws.<span class="hljs-property">onerror</span> = <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {
                <span class="hljs-title function_">updateStatus</span>(<span class="hljs-string">'连接状态: ❌ 发生错误'</span>, <span class="hljs-string">'red'</span>);
                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'WebSocket Error:'</span>, error);
            };

            <span class="hljs-comment">// 监听连接关闭事件 (连接断开)</span>
            ws.<span class="hljs-property">onclose</span> = <span class="hljs-function">() =&gt;</span> {
                <span class="hljs-title function_">updateStatus</span>(<span class="hljs-string">'连接状态: 🛑 已断开'</span>, <span class="hljs-string">'red'</span>);
                <span class="hljs-title function_">log</span>(<span class="hljs-string">'--- WebSocket Connection Closed ---'</span>);
                ws = <span class="hljs-literal">null</span>;
            };
        }

        <span class="hljs-comment">// 3. 客户端发送命令：启动流式输出</span>
        <span class="hljs-keyword">function</span> <span class="hljs-title function_">startStream</span>(<span class="hljs-params"/>) {
            <span class="hljs-keyword">if</span> (ws &amp;&amp; ws.<span class="hljs-property">readyState</span> === <span class="hljs-title class_">WebSocket</span>.<span class="hljs-property">OPEN</span>) {
                <span class="hljs-keyword">const</span> prompt = promptInput.<span class="hljs-property">value</span> || <span class="hljs-string">"Default prompt"</span>;
                <span class="hljs-keyword">const</span> command = {
                    <span class="hljs-attr">command</span>: <span class="hljs-string">'START'</span>,
                    <span class="hljs-attr">prompt</span>: prompt
                };
                <span class="hljs-comment">// 发送 JSON 格式的启动命令</span>
                ws.<span class="hljs-title function_">send</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(command));
                <span class="hljs-title function_">updateStatus</span>(<span class="hljs-string">'流式输出已启动...'</span>, <span class="hljs-string">'purple'</span>);
                <span class="hljs-title function_">log</span>(<span class="hljs-string">`[Client Command]: Starting stream for prompt: "<span class="hljs-subst">${prompt}</span>"`</span>);
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-title function_">updateStatus</span>(<span class="hljs-string">'请先建立连接'</span>, <span class="hljs-string">'red'</span>);
            }
        }

        <span class="hljs-comment">// 4. 客户端发送命令：实时停止流</span>
        <span class="hljs-keyword">function</span> <span class="hljs-title function_">stopStream</span>(<span class="hljs-params"/>) {
            <span class="hljs-keyword">if</span> (ws &amp;&amp; ws.<span class="hljs-property">readyState</span> === <span class="hljs-title class_">WebSocket</span>.<span class="hljs-property">OPEN</span>) {
                <span class="hljs-keyword">const</span> command = {
                    <span class="hljs-attr">command</span>: <span class="hljs-string">'STOP'</span>
                };
                <span class="hljs-comment">// 发送 JSON 格式的停止命令</span>
                ws.<span class="hljs-title function_">send</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(command));
                <span class="hljs-title function_">updateStatus</span>(<span class="hljs-string">'发送停止命令'</span>, <span class="hljs-string">'purple'</span>);
                <span class="hljs-title function_">log</span>(<span class="hljs-string">`[Client Command]: Sending STOP command.`</span>);
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-title function_">updateStatus</span>(<span class="hljs-string">'请先建立连接'</span>, <span class="hljs-string">'red'</span>);
            }
        }
        
        <span class="hljs-keyword">function</span> <span class="hljs-title function_">closeWebSocket</span>(<span class="hljs-params"/>) {
             <span class="hljs-keyword">if</span> (ws &amp;&amp; ws.<span class="hljs-property">readyState</span> === <span class="hljs-title class_">WebSocket</span>.<span class="hljs-property">OPEN</span>) {
                 ws.<span class="hljs-title function_">close</span>();
             }
        }

        <span class="hljs-comment">// 页面加载后自动尝试连接</span>
        <span class="hljs-variable language_">window</span>.<span class="hljs-property">onload</span> = connectWebSocket;
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>



































<table><thead><tr><th><strong>特性</strong></th><th><strong>WebSocket 双向流</strong></th><th><strong>SSE 单向流</strong></th></tr></thead><tbody><tr><td><strong>通信方向</strong></td><td><strong>双向</strong>（全双工）</td><td><strong>单向</strong>（服务器 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"/><span class="mrel">→</span></span></span></span></span> 客户端）</td></tr><tr><td><strong>协议基础</strong></td><td>独立于 HTTP 的 TCP 协议</td><td>基于 HTTP 协议</td></tr><tr><td><strong>适用场景</strong></td><td>实时聊天、协作编辑、<strong>AI 实时交互控制</strong></td><td><strong>纯粹的 AI 流式输出</strong>、新闻推送</td></tr><tr><td><strong>实现复杂度</strong></td><td>较高（需独立服务器支持）</td><td>较低（基于标准 HTTP）</td></tr><tr><td><strong>自动重连</strong></td><td><strong>无原生支持</strong>，需要手动实现</td><td><strong>浏览器原生支持</strong></td></tr></tbody></table>
<p>如果你的 AI 应用只需要将 LLM 的结果流式输出给用户，<strong>SSE 是更简单、更健壮的选择</strong>。但如果您的应用需要用户在流式输出过程中<strong>实时中断、修改输入、或者实现多人协作</strong>，<strong>WebSocket 是唯一的选择</strong>。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[一文带你玩转 WebSocket 全链路可观测]]></title>    <link>https://juejin.cn/post/7583898823920418858</link>    <guid>https://juejin.cn/post/7583898823920418858</guid>    <pubDate>2025-12-15T09:14:16.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7583898823920418858" data-draft-id="7583845695196577846" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="一文带你玩转 WebSocket 全链路可观测"/> <meta itemprop="keywords" content="云原生"/> <meta itemprop="datePublished" content="2025-12-15T09:14:16.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="阿里云云原生"/> <meta itemprop="url" content="https://juejin.cn/user/3808363977648493"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            一文带你玩转 WebSocket 全链路可观测
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3808363977648493/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    阿里云云原生
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-15T09:14:16.000Z" title="Mon Dec 15 2025 09:14:16 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-15
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读24分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>作者：张铭辉（希铭）</p>
<h2 data-id="heading-0">前言：WebSocket 的技术演进与时代价值</h2>
<h3 data-id="heading-1">1.1 什么是 WebSocket？</h3>
<p>WebSocket 是一种基于 TCP 协议的全双工通信协议（RFC 6455 <strong>[</strong> <strong>1]</strong> ），通过一次 HTTP 握手即可建立持久化连接，实现客户端与服务端的双向数据传输。以下是一次 WebSocket 通信的示意图 <strong>[</strong> <strong>2]</strong> ：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/76c38de6ef7a4bccb8a4e8ba14927b81~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766394855&amp;x-signature=8rxa69Hb%2B16TwcJCDMZ3NojUW%2BU%3D" alt="图片" loading="lazy"/></p>
<p>可以看到，和 HTTP 不同，Client 会先向 Server 端基于 HTTP 协议发起一次握手请求，Server 返回响应握手成功。在这之后，已有的 TCP 连接会被升级为 WebSocket 连接，Client 和 Server 之间可以进行全双工通信。TCP 连接会一直持续到其中一侧认为需要关闭，且对方同意关闭之时。</p>
<p>为了更好理解后续 WebSocket 的全链路可观测方案，有必要对 WebSocket 的协议细节进行解读，本节剩余内容部分翻译 + 总结自 WebSocket Protocol <strong>[</strong> <strong>3]</strong> 。</p>
<h4 data-id="heading-2">1.1.1 URI 格式与语法</h4>
<p>和 HTTP 协议族非常类似，WebSocket 也有普通协议和他的安全版本，用 ws 和 wss 来区分，wss 的安全也采用 TLS 协议实现。由于 WebSocket 依赖 HTTP 协议进行握手，后续复用原 TCP 连接，故 WebSocket 默认的端口也是 80（ws）和 443（wss）。URI 整体的格式也和 HTTP 非常类似。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bfc5d72902bb4d3a880b3a5b5c5be124~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766394855&amp;x-signature=E8veoaNdC5JWPQ17NtDAl6JUFd4%3D" alt="图片" loading="lazy"/></p>
<h4 data-id="heading-3">1.1.2 启动连接握手（基于 HTTP/1.1）</h4>
<p>传统的 WebSocket 握手是一次典型的 HTTP 请求/响应。客户端主动发起一个 WebSocket 握手请求（一个特殊的 GET），如果服务器支持且允许使用 WebSocket 协议通信，则会返回一个 WebSocket 握手响应。WebSocket Connection 就建立起来了。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/828f98b33c1644ea84b9869e88576811~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766394855&amp;x-signature=UOfbY8VUXuXTd7Sg4Y6VAcr%2FkCs%3D" alt="图片" loading="lazy"/></p>
<p>握手请求包含以下头：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d4775de1446c4d339cdfae679ac6f5e6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766394855&amp;x-signature=OUfNON19IAxtnLG8tQNPjJnKBDA%3D" alt="图片" loading="lazy"/></p>
<p>如果服务端接受 WebSocket 协议，则发送一个 StatusCode 为 101 的响应：</p>
<pre><code class="hljs language-makefile" lang="makefile">HTTP/1.1 101 Switching Protocols
<span class="hljs-section">Upgrade: websocket</span>
<span class="hljs-section">Connection: Upgrade</span>
<span class="hljs-section">Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=</span>
</code></pre>
<p>响应包括：</p>
<ul>
<li><code>HTTP/1.1 101 Switching Protocols</code>：表示成功从 HTTP 升级到 WebSocket。</li>
<li><code>Upgrade: websocket</code>：确认协议升级。</li>
<li><code>Connection: Upgrade</code>：表示连接已升级。</li>
<li><code>Sec-WebSocket-Accept</code>：一个根据客户端的 <code>Sec-WebSocket-Key</code> 计算出的值，用于验证服务器理解了 WebSocket 握手请求。</li>
</ul>
<p>HTTP/2 与 HTTP/3 升级到 WebSocket 的过程有一些不同，但不是本文讨论的关键，在此不再赘述，欢迎阅读 WebSocket Protocol 原文 <strong>[</strong> <strong>3]</strong> 。</p>
<h4 data-id="heading-4">1.1.3 WebSocket 消息与数据帧</h4>
<p>在握手完毕后，连接会被升级为 WebSocket 连接，此时客户端和服务端可以随时双向发送 WebSocket 消息（message），用来交换数据和指令。WebSocket 中的最小通信单元是数据帧，每个消息有可能由一个或者多个数据帧组成。</p>
<p>数据帧根据其用途可以分为以下三种类型：</p>
<ul>
<li><strong>文本帧：</strong> 载荷为 UTF-8 编码的文本数据</li>
<li><strong>二进制帧：</strong> 载荷为二进制数据</li>
<li><strong>控制帧：</strong> 用于传递协议信号，如 ping、pong、close 帧等</li>
</ul>
<p>一个数据帧的数据组成如下图所示：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/961fdeb250e4437d816cca34abde8e6f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766394855&amp;x-signature=5wIgf%2FLtTgQxWjg6cHOKA%2FUAYQ8%3D" alt="图片" loading="lazy"/></p>
<p>关于数据帧中每段数据的含义，如有兴趣，欢迎阅读 WebSocket Protocol 原文  <strong>[</strong> <strong>3]</strong> 。</p>
<h4 data-id="heading-5">1.1.4 关闭连接握手</h4>
<p>当客户端或服务端某一方认为连接可以关闭时，会向对端发送一个关闭帧（是控制帧的一种），对端收到关闭帧后会尽快发送另一个关闭帧作为响应。发送完关闭帧后，该端不应该再发送任何数据帧。双方交换完关闭帧后，TCP 连接将关闭。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1ce443f1cb0b4b96827dacf032be2a1e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766394855&amp;x-signature=7jwOUM10oRrnC7OHhCF5%2BAsOMlc%3D" alt="图片" loading="lazy"/></p>
<h3 data-id="heading-6">1.2 为什么用 WebSocket？</h3>
<p>不难看出，WebSocket 核心特性体现在：</p>
<ul>
<li><strong>长连接保持：</strong> 连接建立后持续存在，避免重复握手开销</li>
<li><strong>双向数据通道：</strong> 客户端与服务端可随时发送数据帧（Text/Binary）</li>
<li><strong>低延迟特性：</strong> 省去 HTTP 轮询的请求头传输成本</li>
<li><strong>消息分帧机制：</strong> 支持超大数据量的分片传输（单帧最大 2^64 字节）</li>
</ul>
<p>与传统 HTTP 协议对比，WebSocket 在通信模式上实现了根本性突破：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/213ead72a2ec49ac8a38d1affaa83fc3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766394855&amp;x-signature=c7CMmh%2FKcgtL1LeOyt%2BLtIYnCv8%3D" alt="图片" loading="lazy"/></p>
<p>这种协议特性使其成为大数据量下实时通信场景的首选方案。</p>
<h3 data-id="heading-7">1.3 AI 时代 WebSocket 协议的复兴</h3>
<p>随着大模型技术的爆发，越来越多需要实时交互的场景开始出现，智能化赋予了 WebSocket 协议新的活力：</p>
<ul>
<li>支持实时对话与交互的智能客服或机器人</li>
<li>车载 AI 助手与云端模型实时交互</li>
<li>自动翻译、智能识图的 AI 智能眼镜</li>
</ul>
<p>除实时性外，WebSocket 为有状态的连接，多轮对话的记忆保持、即时打断输出等功能也比传统的 HTTP 更加容易实现。到目前为止，主流的大模型提供商大多都提供了 WebSocket 的交互 API 及配套的 SDK，帮助用户更好地构建后端服务系统，例如：</p>
<ul>
<li>OpenAI 支持基于 WebSocket 的 Realtime API <strong>[</strong> <strong>4]</strong></li>
<li>百炼大模型服务平台发布基于 WebSocket 的实时多模态交互协议 <strong>[</strong> <strong>5]</strong></li>
<li>Google Gemini 支持基于 WebSocket 的 Live API <strong>[</strong> <strong>6]</strong></li>
</ul>
<p>WebSocket 在赋能 AI 应用实时性的同时，也为应用系统的可观测性带来了很大的挑战。WebSocket 协议高度的灵活性与扩展性注定了它不能像 HTTP 和 gRPC 那样非常方便地做到全链路可观测，本文接下来将具体分析 WebSocket 场景下全链路可观测的实现痛点与解决方案。</p>
<h2 data-id="heading-8">WebSocket 全链路可观测痛点分析</h2>
<h3 data-id="heading-9">2.1 协议灵活性带来的链路追踪困境</h3>
<h4 data-id="heading-10">2.1.1 链路信息注入难</h4>
<p>对于常规的 HTTP 调用，为了保证链路的连通性，调用方会在 HTTP headers 中额外添加一组用于承载链路上下文的键值对，确保被调用方在解析协议时能够正确地还原调用方的链路上下文，进而保证上下文可以被继续传递下去。图示是使用 W3C 链路追踪协议 <strong>[</strong> <strong>7]</strong> 时，链路上下文的 header 的一个具体示例：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/aaf274625aa845d788f096c2488b3bdb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766394855&amp;x-signature=JZ5Em8skYNt%2FI4H7TVU9iF%2BKxvU%3D" alt="图片" loading="lazy"/></p>
<p>而在 1.1.3 节我们了解到，一个 WebSocket 数据帧其实仅由数字节的控制位和数据载荷构成。除建立连接时握手以外，没有其他的机会传输 header 这些元数据。因此，传统 OpenTelemetry 的 W3C 链路上下文无法直接植入每个数据帧中。而在实际应用场景中，对于一次 WebSocket 连接，往往并不代表仅一次 WebSocket 调用，仅依赖建立连接时的 HTTP 请求与响应是远远不够的。同时，这也牵扯出第二个困难——Span 作用域界定模糊。</p>
<h4 data-id="heading-11">2.1.2 Span 作用域界定模糊</h4>
<p>在可观测领域，我们一般把调用链路上一次关键的操作称为一条 Span（跨度） <strong>[</strong> <strong>8]</strong> ，一条调用链一般由一组树状结构的 Span 组成。在可观测前端的帮助下，我们可以把同属于一条调用链的 Span 召回，并根据父子关系（也就是调用关系）以及发生时间渲染为下图所示的瀑布图，以此来帮助我们了解一条链路发生的所有关键操作以及调用关系。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b45f8da1ce5c4769b633a16fbefe80d1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766394855&amp;x-signature=tMGgJdacc0KFUbsNUHSVH9ZD5kY%3D" alt="图片" loading="lazy"/></p>
<p>然而，在 WebSocket 场景下，操作粒度的定义可以非常灵活。如图所示，一个 Span 有可能对应一次 WebSocket 连接从开始到结束的全过程，也有可能对应每一次消息的收发，甚至也可以对应每一次数据帧的传递过程。对 Span 粒度定义的高度灵活也导致了链路上下文在注入与管理上也会有非常大的变化，这也增大了业务上落地的难度。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/61a6f4b831234030b1a14715fed53089~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766394855&amp;x-signature=0dIHTkc8ItpcLo8tF8jAF54Khns%3D" alt="图片" loading="lazy"/></p>
<h4 data-id="heading-12">2.1.3 链路上下文的反向扩散问题</h4>
<p>虽然我们根据 WebSocket 连接的发起方与接收方将两端分为了 Client 和 Server，但实际业务的处理过程是高度灵活的双向流，可能存在由 Server 侧发起请求，Client 进行处理的情况。例如，允许 Client 主动与 Server 建立连接并将自身服务注册给 Server 端，由 Server 发送消息来对 Client 进行回调。对于这种交互方式而言，消息生产方（调用方）是 Server，消费方（被调用方）是 Client，因此链路上下文应该由 Server 注入到消息中，由 Client 还原并进一步传递。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/156f2d0d0df54b4d9007f129ee2b59cc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766394855&amp;x-signature=E1ECT%2FpAqvV3FM9IuWzJ6wAn%2BR8%3D" alt="图片" loading="lazy"/></p>
<h3 data-id="heading-13">2.2 异步调用引发的断链危机</h3>
<p>在 WebSocket 应用中，为了提高连接利用率，两端也常用异步的方式来解耦消息接收过程与处理过程，以下是一个典型的异步消息处理架构。在这个过程中，消息有可能会直接被提交到线程池，也有可能存放在一个进程内的队列，甚至直接写入 Redis 等外部存储。这种灵活多变的异步方式也给链路上下文的进程内透传带来了困难，非常容易出现断链问题。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fd549381fe484dd391b81e0da8dc88d2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766394855&amp;x-signature=U4ELeDMOl6XmpFAm%2BC0yIno5nrU%3D" alt="图片" loading="lazy"/></p>
<h2 data-id="heading-14">基于 LoongSuite 的全链路观测最佳实践</h2>
<h3 data-id="heading-15">3.1 方案基本原理</h3>
<p>通过上两节的讨论，我们可以得到两个基本结论：</p>
<ul>
<li>WebSocket 的用法相当灵活，链路追踪的实现很大程度上取决于业务实现，需要开发者自主实现一些扩展来保证链路完整性</li>
<li>高频业务场景缺少一些最佳落地范式，导致自主实现链路追踪困难</li>
</ul>
<p>此外，由于 WebSocket 链路上也难免存在一些 NoSQL、HTTP 等其他类型的调用，依然需要无侵入探针来保证各种调用的串联，这就要求无侵入探针与自定义扩展产生的链路上下文可以很好地互通。LoongSuite 无侵入探针提供的基于 OpenTelemetry API 的扩展机制就是解决这些问题的最佳手段 <strong>[</strong> <strong>9]</strong> 。</p>
<h4 data-id="heading-16">3.1.1 OpenTelemetry API 与 LoongSuite 探针工作原理</h4>
<p>OpenTelemetry API 是 OpenTelemetry 社区定义的可观测数据采集标准的重要组件之一 <strong>[</strong> <strong>10]</strong> ，它定义了一整套可观测领域使用的 API 行为标准和功能说明，比如可观测数据创建、上下文管理/透传、数据上报等逻辑，并为许多语言提供了配套的 SDK 实现。使用者可以基于 API 与 SDK 比较容易地实现上下文的管理与透传。以下是使用 Tracer API 定义 Span 的示意：</p>
<pre><code class="hljs language-ini" lang="ini">private int doWork() {
  // 创建 span
  Span <span class="hljs-attr">doWorkSpan</span> = tracer.spanBuilder(<span class="hljs-string">"doWork"</span>).startSpan()<span class="hljs-comment">;</span>
  // 激活 span 所在上下文
  try (Scope <span class="hljs-attr">scope</span> = doWorkSpan.makeCurrent()) {
    int <span class="hljs-attr">result</span> = <span class="hljs-number">0</span><span class="hljs-comment">;</span>
    for (int <span class="hljs-attr">i</span> = <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; 10; i++) {</span>
      result += i<span class="hljs-comment">;</span>
    }
    return result<span class="hljs-comment">;</span>
  } finally {
    // 结束 span
    doWorkSpan.end()<span class="hljs-comment">;</span>
  }
}
</code></pre>
<p>LoongSuite 探针是阿里云可观测团队基于 OpenTelemetry 探针构建的，面向 AI 应用的开源的进程内可观测采集组件。对于热门的开源组件，例如 LangChain、OpenAI SDK、Tomcat 等，LoongSuite 探针提供了丰富的预定义插桩实现。使用者不再需要基于 OpenTelemetry API 进行开发，只需要修改编译或运行时命令，探针就能把可观测数据创建、上下文管理/透传、数据上报等关键逻辑自动完成，从而达成无侵入可观测的目标。</p>
<p>LoongSuite 探针可以满足生产应用绝大多数场景下的可观测需求，但对于一些高度自定义的场景，如消息系统中的复杂消费过程、部分 MQTT 场景以及 WebSocket 通信场景，使用 OpenTelemetry API/SDK 添加自定义埋点则是弥补无侵入探针监控盲区的最优方案。</p>
<h4 data-id="heading-17">3.1.2 LoongSuite 探针与自定义扩展交互示意</h4>
<p>对于 Java、Golang 这类包管理相对严格（需要明确指定版本）的语言来说，探针与应用可能会存在版本不一致的依赖，比如 Jackson、gRPC 和 OpenTelemetry API/SDK 等等。为了避免依赖冲突，常采用 shadow 的方式进行依赖隔离。但这也会导致用户在使用 OpenTelemetry API 和 SDK 自主埋点的时候，产生的链路上下文并不能与探针内互通，进而导致调用链断裂。</p>
<p>OpenTelemetry 和 LoongSuite 探针同样采用代码增强机制保证了链路上下文的共享，具体整体示意如下：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4577a2ca81bc4904a9eeb9bb187db058~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766394855&amp;x-signature=gVcx8e6nZY7xAKgYjNqlDKu5VHs%3D" alt="图片" loading="lazy"/></p>
<ul>
<li>探针和应用共用一套 API，API 自身保证向前兼容</li>
<li>探针初始化时，会将初始化好的实例对象注册到 GlobalHolder，应用中自定义埋点时，直接从 API 中的 GlobalHolder 就可以获取到探针的实例对象</li>
<li>对于 SDK 中定义的一些方法和静态的 API，如 Context、Baggage 等，通过代码增强的方式，跳过这些函数原本的调用，转而使用探针中对应的实现</li>
</ul>
<p>通过以上机制，LoongSuite 探针可以很好地和 OpenTelemetry API/SDK 创建的 Span 串联在一起，保证了链路的完整性。</p>
<h3 data-id="heading-18">3.2 WebSocket 分布式链路追踪最佳实践</h3>
<p>了解了这几个组件，关键的问题是，我的应用应该怎么添加这些自定义的埋点呢？在 WebSocket 全链路的实现中，需要先根据业务诉求明确几个问题：</p>
<p><strong>会话粒度问题：</strong> 一次 WebSocket 连接对应一条 Trace 还是多条 Trace？</p>
<ul>
<li>对应一条 Trace：一次 WebSocket 连接是为了完成一系列相关性强的操作，且持续时间一般仅在数分钟；</li>
<li>对应多条 Trace：一次 WebSocket 连接会在建立完成后留存下来持续复用，持续时间可能持续几小时。</li>
</ul>
<p><strong>调用建模问题：</strong> WebSocket 内部的数据传输过程能否建模为离散的请求与响应？</p>
<ul>
<li>如果连接建立后只用于双方传递数据，则不需要为每条消息专门创建 Span，一个 Span 的生命周期应该对应双方传递消息的完整过程；</li>
<li>如果连接建立后，一方发送消息，另一方处理消息并返回响应，则每组这类调用都可以创建一对父子 Span，对应的数据结构需要允许承载序列化后的链路上下文。</li>
</ul>
<p>应对以上几个不同场景，自定义埋点的实现推荐也会有所差异，接下来将分别展开介绍。</p>
<h4 data-id="heading-19">3.2.1 引入 OpenTelemetry API 依赖</h4>
<blockquote>
<p>探针对 API 的兼容为向前兼容，对于最新版本的 API 适配可能比较有限，生产环境中 API 包的版本不需要过新，基本 API 足够使用即可。</p>
</blockquote>
<p>对于 Java 语言，建议在 pom.xml 中引入。API 文档：<a href="https://link.juejin.cn?target=https%3A%2F%2Fjavadoc.io%2Fdoc%2Fio.opentelemetry%2Fopentelemetry-api%2F1.28.0%2Findex.html" target="_blank" title="https://javadoc.io/doc/io.opentelemetry/opentelemetry-api/1.28.0/index.html" ref="nofollow noopener noreferrer">javadoc.io/doc/io.open…</a></p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.opentelemetry<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>opentelemetry-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<p>获取探针注入的全局实例：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">openTelemetry</span> = GlobalOpenTelemetry.get()<span class="hljs-comment">;</span>
<span class="hljs-attr">tracer</span> = openTelemetry.getTracer(<span class="hljs-string">"websocket-example"</span>, <span class="hljs-string">"1.0.0"</span>)<span class="hljs-comment">;</span>
</code></pre>
<p>对于 Golang 语言，可以执行 go get 命令获取包。API 文档：<a href="https://link.juejin.cn?target=https%3A%2F%2Fpkg.go.dev%2Fgo.opentelemetry.io%2Fotel%40v1.28.0" target="_blank" title="https://pkg.go.dev/go.opentelemetry.io/otel@v1.28.0" ref="nofollow noopener noreferrer">pkg.go.dev/go.opentele…</a></p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-keyword">go</span> get <span class="hljs-keyword">go</span>.opentelemetry.io/otel
</code></pre>
<p>获取探针注入的全局实例：</p>
<pre><code class="hljs language-css" lang="css">tracer := otel.<span class="hljs-built_in">GetTracerProvider</span>().<span class="hljs-built_in">Tracer</span>(<span class="hljs-string">"websocket-example"</span>)
</code></pre>
<p>对于 Python 语言，可以通过 pip install 获取。API 文档：<a href="https://link.juejin.cn?target=https%3A%2F%2Fopentelemetry-python.readthedocs.io%2Fen%2Flatest%2F" target="_blank" title="https://opentelemetry-python.readthedocs.io/en/latest/" ref="nofollow noopener noreferrer">opentelemetry-python.readthedocs.io/en/latest/</a></p>
<pre><code class="hljs">pip install opentelemetry-api
</code></pre>
<p>获取探针注入的全局实例：</p>
<pre><code class="hljs language-ini" lang="ini">from opentelemetry import trace
<span class="hljs-attr">tracer</span> = trace.get_tracer(__name__)
</code></pre>
<h4 data-id="heading-20">3.2.2 会话粒度问题——创建 WebSocket 连接维度的 Trace</h4>
<p><strong>实现建议：</strong> WebSocket 在建立连接时会基于 HTTP 请求发起握手，复用该 Trace 上下文作为整次 WebSocket 连接中子操作的上下文。</p>
<p>以下是以一整个 WebSocket 连接为一条 Trace 的实现基本示意图，所有的请求与数据传递都作为子 Span 挂靠在一条 Trace 下面。因此，这种实现更适合 WebSocket 连接按需连接并会及时关闭的场景。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1b2c8e553b85415ba9d994c662b7b407~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766394855&amp;x-signature=gfzt3GBvWKXkZm6YggkDJxQK0iY%3D" alt="图片" loading="lazy"/></p>
<p>Client 侧代码实现（以 Java 原生提供的 WebSocket 库为例）：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-title class_">String</span>[] args) throws <span class="hljs-title class_">Exception</span> {
  <span class="hljs-comment">// 1. 创建连接级别的 Trace（在连接前创建，以便在握手时传递 TraceContext）</span>
  <span class="hljs-title class_">Span</span> connectionSpan = tracer.<span class="hljs-title function_">spanBuilder</span>(<span class="hljs-string">"websocket.connection"</span>)
      .<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">"websocket.endpoint"</span>, <span class="hljs-string">"/native/ws"</span>)
      .<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">"websocket.destination"</span>, <span class="hljs-string">"ws://localhost:18081"</span>)
      .<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">"websocket.connection.type"</span>, <span class="hljs-string">"client"</span>)
      .<span class="hljs-title function_">startSpan</span>();
  <span class="hljs-comment">// 2. 将当前 Span 激活在线程内的上下文中，标记 Span 的作用域为从连接开始到连接关闭</span>
  <span class="hljs-keyword">try</span> (<span class="hljs-title class_">Scope</span> scope = connectionSpan.<span class="hljs-title function_">makeCurrent</span>()) {
    <span class="hljs-title class_">WebSocketContainer</span> container = <span class="hljs-title class_">ContainerProvider</span>.<span class="hljs-title function_">getWebSocketContainer</span>();
    <span class="hljs-comment">// 创建 WebSocket Client</span>
    <span class="hljs-title class_">NativeWebSocketClient</span> client = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NativeWebSocketClient</span>();
    <span class="hljs-comment">// 使用 Endpoint 方式连接</span>
    <span class="hljs-title class_">Session</span> session = container.<span class="hljs-title function_">connectToServer</span>(
        <span class="hljs-keyword">new</span> jakarta.<span class="hljs-property">websocket</span>.<span class="hljs-title class_">Endpoint</span>() {
          <span class="hljs-meta">@Override</span>
          <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onOpen</span>(<span class="hljs-params">Session session, EndpointConfig config</span>) {
            client.<span class="hljs-title function_">onOpen</span>(session);
            <span class="hljs-comment">// 注册消息处理器（使用匿名内部类而不是 lambda，避免泛型类型推断问题）</span>
            session.<span class="hljs-title function_">addMessageHandler</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageHandler</span>.<span class="hljs-property">Whole</span>&lt;<span class="hljs-title class_">String</span>&gt;() {
              <span class="hljs-meta">@Override</span>
              <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onMessage</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> message</span>) {
                client.<span class="hljs-title function_">onMessage</span>(message);
              }
            });
          }
          <span class="hljs-meta">@Override</span>
          <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onClose</span>(<span class="hljs-params">Session session, CloseReason closeReason</span>) {
            client.<span class="hljs-title function_">onClose</span>();
          }
          <span class="hljs-meta">@Override</span>
          <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onError</span>(<span class="hljs-params">Session session, Throwable thr</span>) {
            <span class="hljs-comment">// 记录错误到当前 Span</span>
            connectionSpan.<span class="hljs-title function_">recordException</span>(thr);
            client.<span class="hljs-title function_">onError</span>(thr);
          }
        },
        <span class="hljs-comment">// 3. 发起握手时，在请求头中携带当前的上下文</span>
        <span class="hljs-title function_">createHeaderWithUserProperties</span>(),
        <span class="hljs-variable constant_">URI</span>.<span class="hljs-title function_">create</span>(<span class="hljs-string">"ws://localhost:18081/native/ws"</span>));
    client.<span class="hljs-property">session</span> = session;
    client.<span class="hljs-property">sessionId</span> = session.<span class="hljs-title function_">getId</span>();
    log.<span class="hljs-title function_">info</span>(<span class="hljs-string">"客户端已启动，输入消息发送给服务器（输入 'exit' 退出）:"</span>);
    <span class="hljs-comment">// 从控制台读取输入</span>
    <span class="hljs-title class_">BufferedReader</span> reader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(<span class="hljs-title class_">System</span>.<span class="hljs-property">in</span>));
    <span class="hljs-title class_">String</span> line;
    <span class="hljs-keyword">while</span> ((line = reader.<span class="hljs-title function_">readLine</span>()) != <span class="hljs-literal">null</span> &amp;&amp; !line.<span class="hljs-title function_">equals</span>(<span class="hljs-string">"exit"</span>)) {
      <span class="hljs-keyword">if</span> (!line.<span class="hljs-title function_">trim</span>().<span class="hljs-title function_">isEmpty</span>()) {
        <span class="hljs-comment">// 4. 向 Server 发送消息</span>
        client.<span class="hljs-title function_">sendMessage</span>(line);
      }
    }
    <span class="hljs-comment">// 关闭连接</span>
    client.<span class="hljs-title function_">close</span>();
    log.<span class="hljs-title function_">info</span>(<span class="hljs-string">"客户端已退出"</span>);
  } <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">Exception</span> e) {
    <span class="hljs-comment">// 如果出现错误，记录到 span 中</span>
    connectionSpan.<span class="hljs-title function_">recordException</span>(e);
    log.<span class="hljs-title function_">error</span>(<span class="hljs-string">"客户端启动失败"</span>, e);
  } <span class="hljs-keyword">finally</span> {
    <span class="hljs-comment">// 5. 结束 span</span>
    connectionSpan.<span class="hljs-title function_">end</span>();
  }
  <span class="hljs-comment">// 等待 span 异步上报，实际业务中无需保留</span>
  <span class="hljs-title class_">Thread</span>.<span class="hljs-title function_">sleep</span>(5000L);
}
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">ClientEndpointConfig</span> <span class="hljs-title function_">createHeaderWithUserProperties</span>(<span class="hljs-params"/>) {
  <span class="hljs-comment">// 创建 ClientEndpointConfig，用于自定义握手请求头</span>
  <span class="hljs-title class_">ClientEndpointConfig</span>.<span class="hljs-property">Builder</span> configBuilder = <span class="hljs-title class_">ClientEndpointConfig</span>.<span class="hljs-property">Builder</span>.<span class="hljs-title function_">create</span>();
  <span class="hljs-comment">// 3.1. 获取当前的 TraceContext，准备 HTTP headers</span>
  final <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">String</span>&gt;&gt; headersMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();
  <span class="hljs-title class_">Context</span> currentContext = <span class="hljs-title class_">Context</span>.<span class="hljs-title function_">current</span>();
  <span class="hljs-comment">// 3.2. 通过全局实例的 ContextPropagators 注入 TraceContext 到 headers</span>
  openTelemetry.<span class="hljs-title function_">getPropagators</span>().<span class="hljs-title function_">getTextMapPropagator</span>()
      .<span class="hljs-title function_">inject</span>(currentContext, headersMap, (carrier, key, value) -&gt; carrier.<span class="hljs-title function_">put</span>(key, <span class="hljs-title class_">List</span>.<span class="hljs-title function_">of</span>(value)));
  <span class="hljs-comment">// 3.3. 设置 Configurator 来在握手时添加 headers</span>
  configBuilder.<span class="hljs-title function_">configurator</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClientEndpointConfig</span>.<span class="hljs-title class_">Configurator</span>() {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">beforeRequest</span>(<span class="hljs-params"><span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, List&lt;<span class="hljs-built_in">String</span>&gt;&gt; headers</span>) {
      headers.<span class="hljs-title function_">putAll</span>(headersMap);
    }
  });
  <span class="hljs-keyword">return</span> configBuilder.<span class="hljs-title function_">build</span>();
}
</code></pre>
<p>Server 侧代码实现（以 Java 原生提供的 WebSocket 库为例）：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-meta">@ServerEndpoint</span>(value = <span class="hljs-string">"/native/ws"</span>, configurator = <span class="hljs-title class_">NativeWebSocketServer</span>.<span class="hljs-property">TraceContextConfigurator</span>.<span class="hljs-property">class</span>)
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NativeWebSocketServer</span> {
  <span class="hljs-comment">// 按照 session 维度管理来自 Client 的上下文</span>
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> final <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">Context</span>&gt; connectionTraceContexts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();
  <span class="hljs-comment">// 1. 定义配置类，用于在握手时提取 TraceContext</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TraceContextConfigurator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">ServerEndpointConfig.Configurator</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> final <span class="hljs-title class_">TextMapGetter</span>&lt;<span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">String</span>&gt;&gt;&gt; headerGetter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextMapGetter</span>&lt;<span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">String</span>&gt;&gt;&gt;() {
      <span class="hljs-meta">@Override</span>
      <span class="hljs-keyword">public</span> <span class="hljs-title class_">Iterable</span>&lt;<span class="hljs-title class_">String</span>&gt; <span class="hljs-title function_">keys</span>(<span class="hljs-params"><span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, List&lt;<span class="hljs-built_in">String</span>&gt;&gt; carrier</span>) {
        <span class="hljs-keyword">return</span> carrier.<span class="hljs-title function_">keySet</span>();
      }
      <span class="hljs-meta">@Override</span>
      <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">get</span>(<span class="hljs-params"><span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, List&lt;<span class="hljs-built_in">String</span>&gt;&gt; carrier, <span class="hljs-built_in">String</span> key</span>) {
        <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">String</span>&gt; values = carrier.<span class="hljs-title function_">get</span>(key);
        <span class="hljs-keyword">return</span> values != <span class="hljs-literal">null</span> &amp;&amp; !values.<span class="hljs-title function_">isEmpty</span>() ? values.<span class="hljs-title function_">get</span>(<span class="hljs-number">0</span>) : <span class="hljs-literal">null</span>;
      }
    };
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">modifyHandshake</span>(<span class="hljs-params">ServerEndpointConfig sec, HandshakeRequest request, HandshakeResponse response</span>) {
      <span class="hljs-comment">// 从 HTTP headers 中提取 TraceContext</span>
      <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">String</span>&gt;&gt; headers = request.<span class="hljs-title function_">getHeaders</span>();
      <span class="hljs-title class_">Context</span> extractedContext = openTelemetry.<span class="hljs-title function_">getPropagators</span>()
          .<span class="hljs-title function_">getTextMapPropagator</span>()
          .<span class="hljs-title function_">extract</span>(<span class="hljs-title class_">Context</span>.<span class="hljs-title function_">current</span>(), headers, headerGetter);
      <span class="hljs-comment">// 2. 将 TraceContext 存储到 userProperties，在 onOpen 时提取</span>
      sec.<span class="hljs-title function_">getUserProperties</span>().<span class="hljs-title function_">put</span>(<span class="hljs-string">"traceContext"</span>, extractedContext);
    }
  }
  <span class="hljs-meta">@OnOpen</span>
  <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onOpen</span>(<span class="hljs-params">Session session, EndpointConfig config</span>) {
    <span class="hljs-title class_">String</span> sessionId = session.<span class="hljs-title function_">getId</span>();
    sessions.<span class="hljs-title function_">put</span>(sessionId, session);
    <span class="hljs-comment">// 3. 从 config 的 userProperties 中提取 TraceContext（在 Configurator 中设置）</span>
    <span class="hljs-title class_">Context</span> parentContext = <span class="hljs-title class_">Context</span>.<span class="hljs-title function_">current</span>();
    <span class="hljs-title class_">Object</span> traceContextObj = config.<span class="hljs-title function_">getUserProperties</span>().<span class="hljs-title function_">get</span>(<span class="hljs-string">"traceContext"</span>);
    <span class="hljs-keyword">if</span> (traceContextObj <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Context</span>) {
        parentContext = (<span class="hljs-title class_">Context</span>) traceContextObj;
    }
    <span class="hljs-comment">// 4. 将 Client 链路上下文保存下来，在需要创建子 span 时获取即可</span>
    connectionTraceContexts.<span class="hljs-title function_">put</span>(sessionId, parentContext);
    log.<span class="hljs-title function_">info</span>(<span class="hljs-string">"客户端连接: sessionId={}, 当前连接数={}, 已从 Client TraceContext 创建子 Span"</span>, sessionId, sessions.<span class="hljs-title function_">size</span>());
    <span class="hljs-title function_">sendMessage</span>(session, <span class="hljs-string">"欢迎连接！您的会话ID: "</span> + sessionId);
  }
  <span class="hljs-meta">@OnClose</span>
  <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onClose</span>(<span class="hljs-params">Session session</span>) {
    <span class="hljs-title class_">String</span> sessionId = session.<span class="hljs-title function_">getId</span>();
    sessions.<span class="hljs-title function_">remove</span>(sessionId);
    connectionTraceContexts.<span class="hljs-title function_">remove</span>(sessionId);
    log.<span class="hljs-title function_">info</span>(<span class="hljs-string">"客户端断开: sessionId={}, 剩余连接数={}, Trace已结束"</span>, sessionId, sessions.<span class="hljs-title function_">size</span>());
  }
}
</code></pre>
<h4 data-id="heading-21">3.2.3 会话粒度问题——使用会话 ID 关联不同的 Trace</h4>
<p><strong>实现建议：</strong> 复用 WebSocket 的 Session ID 作为每条 Span 的属性，在必要时也可以按照属性查询来自于同一个 WebSocket 会话的所有 Trace。</p>
<p>以下是使用会话 ID 关联不同 Trace 的实现基本示意图，每次 Client 侧或 Server 侧发起的主动请求都是一条单独的 Trace，彼此之间并不会在 Trace 瀑布图中呈现关系，但可以通过会话 ID 这个属性进行过滤和查询。因此，这种实现更适合 WebSocket 连接时间很长，且可能存在复用的场景。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8f0e6fa947114ba0b17c1972832d2087~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766394855&amp;x-signature=MX%2B%2BPHdbiF7dDs1s%2BrjjX1sswGs%3D" alt="图片" loading="lazy"/></p>
<p>使用会话 ID 关联不同 Trace 实现方案相对简单，大多数框架都能直接获取到当前所在会话的 ID，调用 setAttribute API 写入 Span 即可，以下是一个基本示例：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMessage</span><span class="hljs-params">(Session session, String message)</span> {
  <span class="hljs-type">Span</span> <span class="hljs-variable">span</span> <span class="hljs-operator">=</span> tracer.spanBuilder(<span class="hljs-string">"Client send message"</span>).startSpan();
  <span class="hljs-comment">// 向 span 中写入 session id</span>
  span.setAttribute(<span class="hljs-string">"websocket.session.id"</span>, session.getId());
  <span class="hljs-keyword">try</span> (<span class="hljs-type">Scope</span> <span class="hljs-variable">scope</span> <span class="hljs-operator">=</span> span.makeCurrent()) {
    doSendMessage(message);
  } <span class="hljs-keyword">finally</span> {
    span.end();
  }
}
</code></pre>
<h4 data-id="heading-22">3.2.4 调用建模问题——存在明显调用关系</h4>
<p><strong>实现建议：</strong> 仿照 Messaging 系统的链路追踪逻辑，消息的发送者为调用方，消息的接受者为被调用方，分别创建 Span。调用方 Span 作为被调用方的父级。涉及多轮消息发送，只要意图为流式传输，视为一次调用行为。</p>
<p>链路效果如下图所示：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/77e68f788b7c4c6eafcb0381b57bf7ed~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766394855&amp;x-signature=Sg%2FCnw1eoFQivh9Ang3gFXDeME8%3D" alt="图片" loading="lazy"/></p>
<p>这种情形是生产应用中最普遍碰到的情况，要保证 Client 链路和 Server 链路的串联，需要调用方在发送消息时保证消息中有一个类似 headers 的预留字段用于传递链路上下文，该字段需要被 Client 和 Server 同时支持解析。许多生产服务都预留了这类字段，例如：语音合成CosyVoice WebSocket API#指令（客户端→服务端）：<a href="https://link.juejin.cn?target=https%3A%2F%2Fhelp.aliyun.com%2Fzh%2Fmodel-studio%2Fcosyvoice-websocket-api%255B%23b0100c3591yqq" target="_blank" title="https://help.aliyun.com/zh/model-studio/cosyvoice-websocket-api%5B#b0100c3591yqq" ref="nofollow noopener noreferrer">help.aliyun.com/zh/model-st…</a></p>
<p>调用方代码实现：</p>
<pre><code class="hljs language-scss" lang="scss">public void <span class="hljs-built_in">sendMessage</span>(String message) {
  <span class="hljs-comment">// 0. （可选）如果为一个 Connection 创建了 span，需要在此处执行 span.makeCurrent()</span>
  <span class="hljs-comment">// 1. 创建 header 字段</span>
  HashMap&lt;String, String&gt; headers = new HashMap&lt;&gt;();
  <span class="hljs-comment">// 2. 创建 span 并写入必要的属性</span>
  <span class="hljs-selector-tag">Span</span> <span class="hljs-selector-tag">span</span> = tracer<span class="hljs-selector-class">.spanBuilder</span>("Client send message")<span class="hljs-selector-class">.startSpan</span>();
  <span class="hljs-selector-tag">span</span><span class="hljs-selector-class">.setAttribute</span>("websocket.session.id", session.getId());
  try (Scope scope = span.makeCurrent()) {
    <span class="hljs-comment">// 3. 调用 OTel API，将上下文注入到 header 中</span>
    openTelemetry<span class="hljs-selector-class">.getPropagators</span>()<span class="hljs-selector-class">.getTextMapPropagator</span>()<span class="hljs-selector-class">.inject</span>(Context.current(), headers,
        (headersMap, key, value) -&gt; headersMap<span class="hljs-selector-class">.put</span>(key, value));
    <span class="hljs-comment">// 4. 发送消息</span>
    <span class="hljs-comment">// 如果是流式发送消息，则可以仅在第一条消息中添加 header，调用双方需要保证 span 创建的幂等性（即整个流式发送期间仅创建一个 span）</span>
    <span class="hljs-built_in">sendMessage</span>(message, headers);
  } finally {
    <span class="hljs-selector-tag">span</span><span class="hljs-selector-class">.end</span>();
  }
}
</code></pre>
<p>被调用方代码实现：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onMessage</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> message, Session session</span>) {
  <span class="hljs-title class_">String</span> sessionId = session.<span class="hljs-title function_">getId</span>();
  <span class="hljs-keyword">try</span> {
    <span class="hljs-comment">// 1. 解析消息</span>
    <span class="hljs-title class_">MessageWithHeaders</span> msgWithHeaders = objectMapper.<span class="hljs-title function_">readValue</span>(message, <span class="hljs-title class_">MessageWithHeaders</span>.<span class="hljs-property">class</span>);
    <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">String</span>&gt; headers = msgWithHeaders.<span class="hljs-title function_">getHeaders</span>();
    <span class="hljs-comment">// 2. 从消息中提取链路上下文</span>
    <span class="hljs-title class_">Context</span> remoteContext = openTelemetry.<span class="hljs-title function_">getPropagators</span>().<span class="hljs-title function_">getTextMapPropagator</span>()
        .<span class="hljs-title function_">extract</span>(<span class="hljs-title class_">Context</span>.<span class="hljs-title function_">current</span>(),
            headers, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextMapGetter</span>&lt;<span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">String</span>&gt;&gt;() {
              <span class="hljs-meta">@Override</span>
              <span class="hljs-keyword">public</span> <span class="hljs-title class_">Iterable</span>&lt;<span class="hljs-title class_">String</span>&gt; <span class="hljs-title function_">keys</span>(<span class="hljs-params"><span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>&gt; headersMap</span>) {
                <span class="hljs-keyword">return</span> headersMap.<span class="hljs-title function_">keySet</span>();
              }
              <span class="hljs-meta">@Override</span>
              <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">get</span>(<span class="hljs-params"><span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>&gt; headersMap, <span class="hljs-built_in">String</span> key</span>) {
                <span class="hljs-keyword">return</span> headersMap.<span class="hljs-title function_">getOrDefault</span>(key, <span class="hljs-literal">null</span>);
              }
            });
    <span class="hljs-comment">// 3. 以提取出来的上下文作为父级，创建 Server span</span>
    <span class="hljs-title class_">Span</span> serverSpan = tracer.<span class="hljs-title function_">spanBuilder</span>(<span class="hljs-string">"Server handle message"</span>)
        .<span class="hljs-title function_">setParent</span>(remoteContext).<span class="hljs-title function_">startSpan</span>();
    <span class="hljs-keyword">try</span> (<span class="hljs-title class_">Scope</span> scope = serverSpan.<span class="hljs-title function_">makeCurrent</span>()) {
      <span class="hljs-comment">// 4. 处理消息/流式返回响应</span>
      <span class="hljs-title class_">String</span> body = msgWithHeaders.<span class="hljs-title function_">getBody</span>();
      log.<span class="hljs-title function_">info</span>(<span class="hljs-string">"收到消息 [{}] [headers={}]: {}"</span>, sessionId, headers, body);
      <span class="hljs-comment">// 处理消息（带 headers）</span>
      <span class="hljs-title function_">handleMessage</span>(session, body, headers);
    } <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">Exception</span> e) {
      serverSpan.<span class="hljs-title function_">recordException</span>(e);
    } <span class="hljs-keyword">finally</span> {
      serverSpan.<span class="hljs-title function_">end</span>();
    }
  } <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">Exception</span> e) {
    log.<span class="hljs-title function_">error</span>(<span class="hljs-string">"消息接收失败 [{}]: {}"</span>, sessionId, message, e);
  }
}
</code></pre>
<h4 data-id="heading-23">3.2.5 调用建模问题——无显式调用关系，仅传输数据</h4>
<p><strong>实现建议：</strong> 数据发送方创建 Span，作为整个 WebSocket 连接 Span（如有）的子 Span，双方 Span 不维持父子关系。</p>
<p>链路效果如下图所示：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f36d0163e58b49f19fa6afe419ffd57d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766394855&amp;x-signature=BUKxDgBS8ScFsshQ7BwRqJjQ5%2FM%3D" alt="图片" loading="lazy"/></p>
<p>数据发送方代码示例：</p>
<pre><code class="hljs language-scss" lang="scss">public void <span class="hljs-built_in">streamingSendMessages</span>(Session session) {
  <span class="hljs-comment">// 0. （可选）如果为一个 Connection 创建了 span，需要在此处执行 span.makeCurrent()</span>
  Context context = connectionTraceContexts<span class="hljs-selector-class">.containsKey</span>(session.getId()) ?
            connectionTraceContexts<span class="hljs-selector-class">.get</span>(session.getId()) : Context.<span class="hljs-built_in">current</span>();
  try (Scope pScope = context.makeCurrent()) {
    <span class="hljs-comment">// 1. 创建 Span</span>
    <span class="hljs-selector-tag">Span</span> <span class="hljs-selector-tag">span</span> = tracer<span class="hljs-selector-class">.spanBuilder</span>("Client send message")<span class="hljs-selector-class">.setParent</span>(context)<span class="hljs-selector-class">.startSpan</span>();
    <span class="hljs-selector-tag">span</span><span class="hljs-selector-class">.setAttribute</span>("websocket.session.id", session.getId());
    try (Scope scope = span.makeCurrent()) {
      <span class="hljs-comment">// 2. 发送消息</span>
      while (messageQueue != null &amp;&amp; messageQueue.containsKey(session.getId())) {
        List&lt;Message&gt; messages = messageQueue<span class="hljs-selector-class">.get</span>(session.getId());
        messages<span class="hljs-selector-class">.forEach</span>(message -&gt; sendMessage(session, message));
        Thread<span class="hljs-selector-class">.sleep</span>(<span class="hljs-number">200</span>L);
      }
    } finally {
      <span class="hljs-selector-tag">span</span><span class="hljs-selector-class">.end</span>();
    }
  }
}
</code></pre>
<h4 data-id="heading-24">3.2.6 异步透传问题——进程内异步上下文管理</h4>
<p>一般地，在 WebSocket 应用中的异步存在两种实现：</p>
<ul>
<li>基于线程池的异步调度，每当接收到消息，都创建一个 Runnable 或 Callable，或者创建一个 Golang/Python 协程</li>
<li>基于进程内队列进行异步通信（如 Java 的 Deque、Golang 的 Channel、Python 的 Generator 等），每当接收到消息都入队，由统一的 Worker 进行处理</li>
</ul>
<p>对于第一种情形，LoongSuite 探针已经支持上下文的自动透传：</p>
<pre><code class="hljs language-scss" lang="scss">public void <span class="hljs-built_in">onMessage</span>(String message) {
  <span class="hljs-selector-tag">Span</span> messageSpan = tracer<span class="hljs-selector-class">.spanBuilder</span>("Server handle message")<span class="hljs-selector-class">.startSpan</span>();
  <span class="hljs-comment">// 把当前 span 激活并放到 ThreadLocal 中</span>
  try (Scope scope = messageSpan.makeCurrent()) {
    <span class="hljs-comment">// 异步调用消息处理流程</span>
    <span class="hljs-comment">// 探针会在 Runnable 任务被创建时，将 span 所在上下文自动传递到 doHandleMessage 方法内部</span>
    <span class="hljs-comment">// doHandleMessage 方法实际执行时，上下文会被自动复原</span>
    workerExecutor<span class="hljs-selector-class">.execute</span>(() -&gt; <span class="hljs-built_in">doHandleMessage</span>(message));
  }
}
</code></pre>
<p>对于第二种情形，需要使用者主动进行上下文透传和还原：</p>
<pre><code class="hljs language-scss" lang="scss">public void <span class="hljs-built_in">onMessage</span>(String message) {
  <span class="hljs-selector-tag">Span</span> messageSpan = tracer<span class="hljs-selector-class">.spanBuilder</span>("Server handle message")<span class="hljs-selector-class">.startSpan</span>();
  <span class="hljs-comment">// 把当前 span 激活并放到 ThreadLocal 中</span>
  try (Scope scope = messageSpan.makeCurrent()) {
    <span class="hljs-comment">// 手动将 TraceContext 与 Message 关联（也可以通过 Map）</span>
    message<span class="hljs-selector-class">.setTracingContext</span>(Context.current());
    <span class="hljs-comment">// 消息入队</span>
    messageQueue<span class="hljs-selector-class">.offer</span>(message);
  }
}
public void <span class="hljs-built_in">pollAndHandleMessage</span>() {
  while (true) {
    if (!messageQueue.isEmpty) {
      Message message = messageQueue<span class="hljs-selector-class">.poll</span>();
      <span class="hljs-comment">// 消息出队后，获取 TraceContext 与 Span</span>
      Context tracingContext = message<span class="hljs-selector-class">.getTracingContext</span>();
      <span class="hljs-selector-tag">Span</span> <span class="hljs-selector-tag">span</span> = <span class="hljs-selector-tag">Span</span><span class="hljs-selector-class">.fromContext</span>(tracingContext);
      <span class="hljs-comment">// 将 TraceContext 重新激活并放到 ThreadLocal 中</span>
      try (Scope scope = tracingContext.makeCurrent()) {
        <span class="hljs-built_in">handleMessage</span>(message);
      } finally {
        <span class="hljs-comment">// 消息处理结束，关闭 span</span>
        <span class="hljs-selector-tag">span</span><span class="hljs-selector-class">.end</span>();
      }
    }
    Thread<span class="hljs-selector-class">.sleep</span>(<span class="hljs-number">100</span>L);
  }
}
</code></pre>
<h3 data-id="heading-25">3.3 WebSocket 中流式传输的关键业务指标</h3>
<p>在 3.2 节中我们可以看到，在流式传输的场景下，我们会把一次完整的请求记录为一条 Span，以防止过多 Span 导致性能瓶颈。但这也会抹去流式传输中的一些关键性能信息——一次消息处理中，某些个别的数据包处理时长过长引发整个响应过程偏慢。实际生产中，这些指标也能很大程度上帮我们衡量应用的健康度与评估某些链路的问题所在，以下是几个常用的业务指标：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9b4f17d11e0f4280beca8b9dfecb5224~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766394855&amp;x-signature=pzkdagqWySUY5WnMeVnQaz1D6rw%3D" alt="图片" loading="lazy"/></p>
<p>以下是计算这些指标的一个简单的工具类实现，关于详细的使用方式，欢迎查看示例代码：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FCirilla-zmh%2Fasr-demo%2Fblob%2Fmain%2Fasr-service%2Fsrc%2Fmain%2Fjava%2Fcom%2Fexample%2Fasr%2Fws%2FAsrWebSocketHandler.java" target="_blank" title="https://github.com/Cirilla-zmh/asr-demo/blob/main/asr-service/src/main/java/com/example/asr/ws/AsrWebSocketHandler.java" ref="nofollow noopener noreferrer">github.com/Cirilla-zmh…</a></p>
<p>工具类定义</p>
<pre><code class="hljs language-ini" lang="ini">public class WebSocketPerformanceMeasure {
  private static final Logger <span class="hljs-attr">log</span> = LoggerFactory.getLogger(WebSocketPerformanceMeasure.class)<span class="hljs-comment">;</span>
  private static final long <span class="hljs-attr">UNINITIALIZED</span> = -<span class="hljs-number">1</span>L<span class="hljs-comment">;</span>
  private Long startTime<span class="hljs-comment">;</span>
  private Long firstChunkTime<span class="hljs-comment">;</span>
  private AtomicInteger chunkCounts<span class="hljs-comment">;</span>
  private AtomicLong totalInterval<span class="hljs-comment">;</span>
  private Long lastChunkTime<span class="hljs-comment">;</span>
  public static WebSocketPerformanceMeasure create() {
    WebSocketPerformanceMeasure <span class="hljs-attr">measure</span> = new WebSocketPerformanceMeasure()<span class="hljs-comment">;</span>
    <span class="hljs-attr">measure.startTime</span> = System.currentTimeMillis()<span class="hljs-comment">;</span>
    <span class="hljs-attr">measure.firstChunkTime</span> = UNINITIALIZED<span class="hljs-comment">;</span>
    <span class="hljs-attr">measure.chunkCounts</span> = new AtomicInteger(<span class="hljs-number">0</span>)<span class="hljs-comment">;</span>
    <span class="hljs-attr">measure.totalInterval</span> = new AtomicLong(<span class="hljs-number">0</span>)<span class="hljs-comment">;</span>
    <span class="hljs-attr">measure.lastChunkTime</span> = UNINITIALIZED<span class="hljs-comment">;</span>
    return measure<span class="hljs-comment">;</span>
  }
  /**
   * 开始测量（如果尚未开始）
   */
  public void start() {
    if (<span class="hljs-attr">startTime</span> == null) {
      <span class="hljs-attr">startTime</span> = System.currentTimeMillis()<span class="hljs-comment">;</span>
      <span class="hljs-attr">firstChunkTime</span> = UNINITIALIZED<span class="hljs-comment">;</span>
      <span class="hljs-attr">chunkCounts</span> = new AtomicInteger(<span class="hljs-number">0</span>)<span class="hljs-comment">;</span>
      <span class="hljs-attr">totalInterval</span> = new AtomicLong(<span class="hljs-number">0</span>)<span class="hljs-comment">;</span>
      <span class="hljs-attr">lastChunkTime</span> = UNINITIALIZED<span class="hljs-comment">;</span>
    }
  }
  /**
   * 记录一个 chunk 的到达
   * 自动计算 time_to_first_chunk 和更新间隔统计
   * 
   * @return 如果是第一个 chunk，返回 time_to_first_chunk（毫秒），否则返回 null
   */
  public Long recordChunk() {
    if (<span class="hljs-attr">startTime</span> == null) {
      log.warn("Performance measure not started, calling start() automatically")<span class="hljs-comment">;</span>
      start()<span class="hljs-comment">;</span>
    }
    long <span class="hljs-attr">currentTime</span> = System.currentTimeMillis()<span class="hljs-comment">;</span>
    chunkCounts.incrementAndGet()<span class="hljs-comment">;</span>
    // 记录第一个 chunk 的时间
    Long <span class="hljs-attr">timeToFirstChunk</span> = null<span class="hljs-comment">;</span>
    if (<span class="hljs-attr">firstChunkTime</span> == UNINITIALIZED) {
      <span class="hljs-attr">timeToFirstChunk</span> = currentTime - startTime<span class="hljs-comment">;</span>
      <span class="hljs-attr">firstChunkTime</span> = currentTime<span class="hljs-comment">;</span>
      log.debug("First chunk recorded, time_to_first_chunk: {}ms", timeToFirstChunk)<span class="hljs-comment">;</span>
    }
    // 计算 chunk 间隔（从第二个 chunk 开始）
    if (lastChunkTime != UNINITIALIZED) {
      long <span class="hljs-attr">interval</span> = currentTime - lastChunkTime<span class="hljs-comment">;</span>
      totalInterval.addAndGet(interval)<span class="hljs-comment">;</span>
    }
    <span class="hljs-attr">lastChunkTime</span> = currentTime<span class="hljs-comment">;</span>
    return timeToFirstChunk<span class="hljs-comment">;</span>
  }
  /**
   * 获取 time_to_first_chunk（毫秒）
   * 如果第一个 chunk 尚未到达，返回 null
   */
  public Long getTimeToFirstChunk() {
    if (<span class="hljs-attr">firstChunkTime</span> == UNINITIALIZED || startTime == null) {
      return null<span class="hljs-comment">;</span>
    }
    return firstChunkTime - startTime<span class="hljs-comment">;</span>
  }
  /**
   * 获取 time_to_last_chunk（毫秒）
   * 需要保证在 chunk 完全到达后调用
   * 如果第一个 chunk 尚未到达，返回 null
   */
  public Long getTimeToLastChunk() {
    if (<span class="hljs-attr">lastChunkTime</span> == UNINITIALIZED || startTime == null) {
      return null<span class="hljs-comment">;</span>
    }
    return lastChunkTime - startTime<span class="hljs-comment">;</span>
  }
  /**
   * 获取平均 chunk 间隔（毫秒）
   * 如果 chunk 数量少于 2，返回 null
   */
  public Long getAverageInterval() {
    int <span class="hljs-attr">count</span> = chunkCounts.get()<span class="hljs-comment">;</span>
    if (count &lt; 2 || <span class="hljs-attr">totalInterval</span> == null) {
      return null<span class="hljs-comment">;</span>
    }
    return totalInterval.get() / (count - 1)<span class="hljs-comment">;</span>
  }
  /**
   * 获取 chunk 总数
   */
  public int getChunkCount() {
    return chunkCounts != null ? chunkCounts.get() : 0<span class="hljs-comment">;</span>
  }
}
</code></pre>
<h2 data-id="heading-26">典型场景实践：AI 语音对话系统</h2>
<p>本节我们将结合一个生产中常见的业务系统，来简要介绍本文方案在该场景下的具体实践。相关 demo 代码已开源，欢迎移步 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FCirilla-zmh%2Fasr-demo%25C2%25A0%25E5%25AE%259E%25E8%25B7%25B5%25E3%2580%2582" target="_blank" title="https://github.com/Cirilla-zmh/asr-demo%C2%A0%E5%AE%9E%E8%B7%B5%E3%80%82" ref="nofollow noopener noreferrer">github.com/Cirilla-zmh…</a></p>
<h3 data-id="heading-27">4.1 系统架构解析</h3>
<p>以下是系统整体架构的简单示意：</p>
<pre><code class="hljs language-scss" lang="scss">设备端 → WebSocket → ASR → <span class="hljs-built_in">LLM</span>(意图识别) ↓
├─ 闲聊 → <span class="hljs-built_in">LLM</span>(生成) → TTS → 设备端
└─ 下单 → <span class="hljs-built_in">MCP</span>(下单) → <span class="hljs-built_in">LLM</span>(生成) → TTS → 设备端
</code></pre>
<p>调用时序图：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/55cc7b8d26324cb9982d1ff6557e7739~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766394855&amp;x-signature=4dDIWtu837Ut3S4ADlWodJ9LtKM%3D" alt="图片" loading="lazy"/></p>
<h3 data-id="heading-28">4.2 接入 LoongSuite 探针</h3>
<p>在本示例项目中，预留了探针挂载的环境变量，通过挂载 LoongSuite 探针，我们可以将 ASR demo 服务的可观测数据接入到 ARMS 控制台。以下是具体步骤：</p>
<ol>
<li>下载 LoongSuite 商业化探针并解压</li>
</ol>
<blockquote>
<p>为保证 LLM 链路的完整性，建议下载 4.6.0 及更高版本探针。</p>
</blockquote>
<pre><code class="hljs language-python" lang="python">wget <span class="hljs-string">"http://arms-apm-cn-hangzhou.oss-cn-hangzhou.aliyuncs.com/4.6.0/AliyunJavaAgent.zip"</span> -O AliyunJavaAgent.<span class="hljs-built_in">zip</span>
unzip AliyunJavaAgent.<span class="hljs-built_in">zip</span>
</code></pre>
<p>2.  参照 README，在启动应用时添加探针挂载相关参数，相关参数可以参考手动安装探针 <strong>[1****1]</strong> 文档获取。</p>

<pre><code class="hljs language-bash" lang="bash"><span class="hljs-built_in">export</span> JAVA_AGENT_OPTIONS=<span class="hljs-string">"-javaagent:/path/to/4.6.0/AliyunJavaAgent/aliyun-java-agent.jar -Darms.licenseKey=<span class="hljs-variable">${your_license_key}</span> -Darms.appName=websocket-demo -Daliyun.javaagent.regionId=cn-hangzhou -Darms.workspace=<span class="hljs-variable">${your_cms_workspace}</span>"</span>
./start.sh
</code></pre>
<p>你也可以接入 LoongSuite 开源版本探针或者 OpenTelemetry 探针，并可观测数据上报到开源的可观测平台，受限于篇幅，在此不再展开，欢迎移步 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Falibaba%2Floongsuite-java-agent%25C2%25A0%25E8%258E%25B7%25E5%258F%2596%25E6%259B%25B4%25E5%25A4%259A%25E4%25BF%25A1%25E6%2581%25AF%25E3%2580%2582" target="_blank" title="https://github.com/alibaba/loongsuite-java-agent%C2%A0%E8%8E%B7%E5%8F%96%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF%E3%80%82" ref="nofollow noopener noreferrer">github.com/alibaba/loo…</a></p>
<h3 data-id="heading-29">4.3 系统页面与可观测效果示意</h3>
<p>以下是部署后的应用系统页面，类似现在的智能机器人 IM 系统，用于替代设备端的左右：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2457aea5acd3462ab61a2d4077a53634~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766394855&amp;x-signature=eWkO7fbQjUwnAOzEyuitlK9thLQ%3D" alt="图片" loading="lazy"/></p>
<p>在发起对话后，统计上来的链路如图所示。可以在一条链路中清晰看到每个环节的持续时间：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3d467b4c5bd743509e58891c4fd82f21~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766394855&amp;x-signature=qNy8DKKAQVSBUKu%2BqlkWgPlqfKA%3D" alt="图片" loading="lazy"/></p>
<p>在 WebSocket 对应 span 中，能够看到统计到的首包延迟与平均输出间隔等指标，帮助分析整体业务性能：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/58bdf4fa4b1144abb890919506bf80c3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766394855&amp;x-signature=y6FtHNwt%2ByaP4qV6XmhmttVbafw%3D" alt="图片" loading="lazy"/></p>
<h2 data-id="heading-30">结语：未来展望</h2>
<p>WebSocket 领域的全链路可观测性一直以来都是让许多企业开发和运维人员头痛的问题。可观测性的解决方案并不能一蹴而就，需要与用户进行持续深度共建与配合。很兴奋能看到公牛在与可观测团队共同完成了该方案在生产上的实际落地 <strong>[</strong> <strong>12]</strong> ，也为我们方案的完善提供了非常宝贵的经验。未来我们将与更多的用户与开源开发者共建，持续补充和建设更完善、更易用的 WebSocket 可观测方案。</p>
<p>欢迎大家关注 LoongSuite 社区，以获取相关方案的最新进展：</p>
<p>“LoongCollector(原iLogtail)社区”钉钉群号： 35576244</p>
<p>“LoongSuite Go Agent开源交流群”钉钉群号： 102565007776</p>
<p>“LoongSuite Python SIG”钉钉群号： 101925034286</p>
<p>“LoongSuite Python SIG”钉钉群号： 101925034286</p>
<p><strong>参考文章：</strong></p>
<p>[1] RFC 6455</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fdatatracker.ietf.org%2Fdoc%2Fhtml%2Frfc6455" target="_blank" title="https://datatracker.ietf.org/doc/html/rfc6455" ref="nofollow noopener noreferrer">datatracker.ietf.org/doc/html/rf…</a></p>
<p>[2] The Road to WebSockets</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwebsocket.org%2Fguides%2Froad-to-websockets%2F" target="_blank" title="https://websocket.org/guides/road-to-websockets/" ref="nofollow noopener noreferrer">websocket.org/guides/road…</a></p>
<p>[3] WebSocket Protocol</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwebsocket.org%2Fguides%2Fwebsocket-protocol%2F" target="_blank" title="https://websocket.org/guides/websocket-protocol/" ref="nofollow noopener noreferrer">websocket.org/guides/webs…</a></p>
<p>[4] OpenAI Realtime API</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fplatform.openai.com%2Fdocs%2Fguides%2Frealtime-websocket" target="_blank" title="https://platform.openai.com/docs/guides/realtime-websocket" ref="nofollow noopener noreferrer">platform.openai.com/docs/guides…</a></p>
<p>[5] 实时多模态交互协议（WebSocket）</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fhelp.aliyun.com%2Fzh%2Fmodel-studio%2Fmultimodal-interaction-protocol" target="_blank" title="https://help.aliyun.com/zh/model-studio/multimodal-interaction-protocol" ref="nofollow noopener noreferrer">help.aliyun.com/zh/model-st…</a></p>
<p>[6] Live API - WebSockets API reference</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fai.google.dev%2Fapi%2Flive" target="_blank" title="https://ai.google.dev/api/live" ref="nofollow noopener noreferrer">ai.google.dev/api/live</a></p>
<p>[7] Trace Context</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.w3.org%2FTR%2Ftrace-context%2F%23abstract" target="_blank" title="https://www.w3.org/TR/trace-context/#abstract" ref="nofollow noopener noreferrer">www.w3.org/TR/trace-co…</a></p>
<p>[8] Distributed Tracing 基本介绍</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fobservability.cn%2Fproject%2Fopentelemetry%2Frp8k7gzvtys07zsb%2F" target="_blank" title="https://observability.cn/project/opentelemetry/rp8k7gzvtys07zsb/" ref="nofollow noopener noreferrer">observability.cn/project/ope…</a></p>
<p>[9] 通过OpenTelemetry Java SDK为调用链增加自定义埋点</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fhelp.aliyun.com%2Fzh%2Farms%2Fapplication-monitoring%2Fuse-cases%2Fuse-opentelemetry-sdk-for-java-to-manually-instrument-applications%3Fspm%3Da2c4g.11186623.help-menu-search-34364.d_5" target="_blank" title="https://help.aliyun.com/zh/arms/application-monitoring/use-cases/use-opentelemetry-sdk-for-java-to-manually-instrument-applications?spm=a2c4g.11186623.help-menu-search-34364.d_5" ref="nofollow noopener noreferrer">help.aliyun.com/zh/arms/app…</a></p>
<p>[10] OpenTelemetry Specification Overview</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fopentelemetry.io%2Fdocs%2Fspecs%2Fotel%2Foverview%2F" target="_blank" title="https://opentelemetry.io/docs/specs/otel/overview/" ref="nofollow noopener noreferrer">opentelemetry.io/docs/specs/…</a></p>
<p>[11] 手动安装探针</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fhelp.aliyun.com%2Fzh%2Farms%2Fapplication-monitoring%2Fuser-guide%2Fmanually-install-arms-agent-for-java-applications" target="_blank" title="https://help.aliyun.com/zh/arms/application-monitoring/user-guide/manually-install-arms-agent-for-java-applications" ref="nofollow noopener noreferrer">help.aliyun.com/zh/arms/app…</a></p>
<p>[12] 《<a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzUzNzYxNjAzMg%3D%3D%26mid%3D2247577965%26idx%3D2%26sn%3D842338decd2e1d6886f9f7c77b0e68fc%26scene%3D21%23wechat_redirect" target="_blank" title="https://mp.weixin.qq.com/s?__biz=MzUzNzYxNjAzMg==&amp;mid=2247577965&amp;idx=2&amp;sn=842338decd2e1d6886f9f7c77b0e68fc&amp;scene=21#wechat_redirect" ref="nofollow noopener noreferrer">让每次语音唤醒都可靠，公牛沐光重构可观测体系</a>》</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Repository 方法设计：suspend 与 Flow 的决选择指南（以朋友圈为例）]]></title>    <link>https://juejin.cn/post/7583567658253762586</link>    <guid>https://juejin.cn/post/7583567658253762586</guid>    <pubDate>2025-12-14T23:51:58.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7583567658253762586" data-draft-id="6979915155467403271" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Repository 方法设计：suspend 与 Flow 的决选择指南（以朋友圈为例）"/> <meta itemprop="keywords" content="Android"/> <meta itemprop="datePublished" content="2025-12-14T23:51:58.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="潜龙勿用之化骨龙"/> <meta itemprop="url" content="https://juejin.cn/user/2313028195058471"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Repository 方法设计：suspend 与 Flow 的决选择指南（以朋友圈为例）
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2313028195058471/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    潜龙勿用之化骨龙
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-14T23:51:58.000Z" title="Sun Dec 14 2025 23:51:58 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-14
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    1
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在Repo接口定义中，常见两类函数：</p>
<ul>
<li><strong>suspend functions</strong>：返回单一结果</li>
<li><strong>普通函数返回 Flow</strong>：返回一个结果流</li>
</ul>
<p>这两类函数在 Room DAO 等库中都有体现。例如 <code>observeUsers()</code> 返回 <code>Flow</code>，因为它是一个观察者，每次表变化都会发射新的用户列表。</p>
<hr/>
<h2 data-id="heading-0">一、通用原则</h2>
<ul>
<li><strong>使用 <code>suspend</code></strong>：当函数只产生一个结果时，例如数据库查询或调用外部服务</li>
<li><strong>使用 <code>Flow</code></strong>：当函数可能产生未知数量的结果时，例如 WebSocket 连接或数据库观察</li>
</ul>
<blockquote>
<p>不推荐在只期望一个结果的场景使用 <code>Flow</code>，原因包括：</p>
<ol>
<li><strong>语义误导</strong>：<code>Flow</code> 暗示多个结果</li>
<li><strong>复杂度更高</strong>：<code>suspend</code> 更简单、可读性更好、易于调试</li>
</ol>
</blockquote>
<hr/>
<h2 data-id="heading-1">二、朋友圈发送场景 —— 使用 <code>suspend</code></h2>
<p>在发送朋友圈的业务中，很多操作都是一次性触发并返回结果，因此适合用 <code>suspend</code>：</p>
<ul>
<li>发布朋友圈：用户点击"发送"后，等待结果返回</li>
<li>删除朋友圈：一次性操作，执行后即结束</li>
<li>点赞/取消点赞：触发后立即返回结果</li>
<li>发表评论：提交后返回成功或失败</li>
</ul>
<h3 data-id="heading-2">示例接口</h3>
<h2 data-id="heading-3"><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8ea10b1cc9af49b6970089d80d043f2a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5r2c6b6Z5Yu_55So5LmL5YyW6aqo6b6Z:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766361118&amp;x-signature=iJEWuu0y01K82jGHOOIw6cFkjto%3D" alt="image.png" loading="lazy"/></h2>
<h2 data-id="heading-4">三、朋友圈动态场景 —— 使用 <code>Flow</code></h2>
<p>朋友圈的另一类需求是实时动态更新，例如：</p>
<ul>
<li>朋友圈列表：新内容发布后，列表需要自动刷新</li>
<li>特定朋友圈详情：点赞数、评论数随时变化</li>
<li>新朋友圈通知：好友发布新动态时推送</li>
<li>互动更新：点赞、评论的实时变化</li>
</ul>
<h3 data-id="heading-5">示例接口</h3>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0cc7df2d7e354e65bfa14cc4f9252ef4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5r2c6b6Z5Yu_55So5LmL5YyW6aqo6b6Z:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766361118&amp;x-signature=O3KkdXZhZAF7iQSw2F7xcsvzPgI%3D" alt="image.png" loading="lazy"/></p>
<h2 data-id="heading-6">四、 ViewModel与状态管理</h2>
<p>ViewModel 的可观察状态通常用 <code>StateFlow</code> 表示。  因此，API 暴露 <code>Flow</code> 会更容易消费，可以直接用 <code>stateIn</code> 转换为 <code>StateFlow</code>。</p>
<ul>
<li>小型应用：用 Flow 到处都行，差别不大</li>
<li>复杂领域模型：滥用 Flow 会成为负担，<code>suspend</code> 更简洁</li>
<li>最佳实践：可以定义辅助函数，把 <code>suspend</code> 转换为 <code>StateFlow</code>，避免强行用 Flow everywhere (不要为了迎合 ViewModel 的需要而让数据层所有 API 都返回 Flow，而是保持数据层 API 的简洁性（使用挂起函数），然后在 ViewModel 层通过辅助函数将一次性操作的结果转换为 StateFlow)。</li>
</ul>
<h2 data-id="heading-7">五、决策流程图</h2>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5316144709b04c64a2a42bee418689e9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5r2c6b6Z5Yu_55So5LmL5YyW6aqo6b6Z:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766361118&amp;x-signature=Wq%2FsFSnFi6xh6jY5GKYi1plo7LQ%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-8">我总结了一个图,如下:</h3>
<h2 data-id="heading-9"><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/559df06a3f1843cc9afcc4e23884d4e3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5r2c6b6Z5Yu_55So5LmL5YyW6aqo6b6Z:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766361118&amp;x-signature=M494oJTiFAG00gZseBS4LBWBoI4%3D" alt="Copilot_20251212_175153.png" loading="lazy"/></h2>
<h2 data-id="heading-10">六、总结原则</h2>






























<table><thead><tr><th>特征</th><th><code>suspend</code></th><th><code>Flow</code></th></tr></thead><tbody><tr><td><strong>数据特性</strong></td><td>静态，一次性</td><td>动态，持续变化</td></tr><tr><td><strong>结果数量</strong></td><td>单次结果</td><td>多个值序列</td></tr><tr><td><strong>使用场景</strong></td><td>发送朋友圈、删除、点赞、评论</td><td>列表更新、通知、互动变化</td></tr><tr><td><strong>生命周期</strong></td><td>执行完即结束</td><td>持续到取消收集</td></tr></tbody></table>
<p><strong>简单记忆</strong>：</p>
<ul>
<li>操作像 <strong>动词</strong>（做某事，例如"发送朋友圈"） → 用 <code>suspend</code></li>
<li>操作像 <strong>名词</strong>（观察某物，例如"朋友圈动态"） → 用 <code>Flow</code></li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[C进阶之内存对齐，硬件总线和高并发伪共享的底层原理]]></title>    <link>https://juejin.cn/post/7583615094362701878</link>    <guid>https://juejin.cn/post/7583615094362701878</guid>    <pubDate>2025-12-15T06:50:21.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7583615094362701878" data-draft-id="7583591656177418276" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content=" C进阶之内存对齐，硬件总线和高并发伪共享的底层原理"/> <meta itemprop="keywords" content="面试,代码规范"/> <meta itemprop="datePublished" content="2025-12-15T06:50:21.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="xlp666hub"/> <meta itemprop="url" content="https://juejin.cn/user/2965810860569131"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
             C进阶之内存对齐，硬件总线和高并发伪共享的底层原理
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2965810860569131/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    xlp666hub
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-15T06:50:21.000Z" title="Mon Dec 15 2025 06:50:21 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-15
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读15分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在 C 语言的面试和实际开发中，<code>sizeof</code> 是一个出现频率极高的关键词。初学者往往认为它只是用来计算变量占用空间的，但实际上，<code>sizeof</code> 的背后隐藏着<strong>CPU 架构</strong>、<strong>硬件总线</strong>甚至<strong>高并发性能</strong>的秘密。</p>
<p>今天，我们不注重于对齐规则，而是从硬件视角出发，彻底搞懂<strong>为什么要对齐？不对齐会发生什么？以及如何掌控对齐。</strong></p>
<h2 data-id="heading-0">1. <code>sizeof</code> 的结果居然和想象中不一样！</h2>
<p>我们可以先来看一段简单的代码，大家可以先思考一下它会输出多少？</p>
<pre><code class="hljs language-c" lang="c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>
​
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">demo</span> {</span>
    <span class="hljs-type">char</span> a; <span class="hljs-comment">// 1 字节</span>
    <span class="hljs-type">int</span> b;  <span class="hljs-comment">// 4 字节</span>
};
​
<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"sizeof(struct demo) = %zu\n"</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> demo));
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>我是在 64 位 Linux 系统下运行，大家的结果大概率也是这样的：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9a39e3ebe9214242b47fb812da500d12~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgeGxwNjY2aHVi:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766386221&amp;x-signature=GM7S4fPwU1F%2BTquM5IYfhLXy1q8%3D" alt="1. sizeof 结果.png" loading="lazy"/></p>
<p>怎么样，可能有的人已经知道了这个细节，但按照正常人的思维，1加4是等于5的，结果为什么会是8呢？为什么有3个字节的内存被白白浪费了？其实这并不是编译器的 BUG ，而是编译器为了迎合 CPU 而做出的<strong>妥协</strong>。</p>
<p>要理解这一点，我们必须跳出软件的代码逻辑，看看<strong>硬件总线</strong>是如何工作的。</p>
<h2 data-id="heading-1">2. CPU 读取内存的方式</h2>
<p>要理解内存对齐，首先要明白一个核心概念：<strong>CPU 读取内存并不是一个字节一个字节读的，而是一块一块读的。</strong></p>
<h3 data-id="heading-2">2.1 数据总线与读取粒度</h3>
<p>CPU 和内存之间有一条“ 高速公路 ”，叫<strong>数据总线 (Data Bus)</strong> 。这条路的宽度是固定的：</p>
<p>对于<strong>32位 CPU</strong>：总线宽度 32 bit，一次搬运 <strong>4 字节</strong>。</p>
<p>对于<strong>64位 CPU</strong>：总线宽度 64 bit，一次搬运 <strong>8 字节</strong>。</p>
<p>除此之外，还有一条规则：</p>
<p>我拿32位 CPU 来举例子，它一次只能搬运4个字节。这个规则的大致内容是，这个32位 CPU ，每次搬运只能从地址为4的倍数处（0，4，8，12等）开始搬运4个字节。</p>
<p>可能有人无法理解这条规则存在的意义，那我们先来看一下<strong>内存条的物理结构</strong>。</p>
<p>实际上，现代标准内存条（DIMM）物理位宽通常都是 64 位的。</p>
<p>对于 <strong>64 位 CPU</strong>，它能充分利用内存条的物理位宽，一次吞吐 8 字节。</p>
<p>对于 <strong>32 位 CPU</strong>，受限于 CPU 内部的数据总线宽度，它<strong>逻辑上</strong>依然只能把内存当作 4 字节宽的设备来访问。</p>
<p>假设我们是一个 32 位的 CPU（一次读4字节）：CPU 和内存之间有 <strong>32 根数据线</strong>（D0 - D31）。内存条内部并不是一个字节一个字节存的，而是像<strong>4列宽的表格</strong>一样存的，想象一下有四列的 execl 表格，CPU 每次读一行（一个 Row ，也就是4个字节）。它的物理寻址逻辑是这样的：</p>
<p><strong>Row 0 (地址 0)</strong> : 包含字节 0, 1, 2, 3</p>
<p><strong>Row 1 (地址 4)</strong> : 包含字节 4, 5, 6, 7</p>
<p><strong>Row 2 (地址 8)</strong> : 包含字节 8, 9, 10, 11</p>
<p>当你给内存发送读取地址 0 的信号时，内存芯片会<strong>同时</strong>把 Row 0 的 4 个字节，通过 32 根线一次性发给 CPU。</p>
<p><strong>那如果你想读地址 1 呢？</strong> 也就是说<strong>你想要</strong>字节 1, 2, 3, 4。字节 1, 2, 3 在 <strong>Row 0</strong> 里。字节 4 在 <strong>Row 1</strong> 里。而内存控制器<strong>一次只能选中一行</strong>。它不能让数据线的一半连着 Row 0，另一半连着 Row 1。<strong>这就是物理限制</strong>。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8c18f19835914f4e807f863f41d7c3bf~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgeGxwNjY2aHVi:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766386221&amp;x-signature=HzPAq7fc%2BwejIESiICIB2uZlw6s%3D" alt="2. 32位内存演示.png" loading="lazy"/></p>
<p>这也就解释了为什么会有<strong>4的倍数</strong>这条规则——<strong>这本质上是为了匹配内存颗粒的物理位宽，以达到最高的传输效率。</strong></p>
<p>这里再简单提一下，对于 64 位 CPU ，上面的表格中每行就是 8 个单元，代表每次读取 8 个字节。</p>
<p><strong>如果我们非要读取地址 1 的数据（跨越了第0行和第1行）时，到底会发生什么？</strong></p>
<ol>
<li><strong>在严格的架构上（如早期的 ARM、DSP）</strong> ：硬件电路为了简化设计，强制要求地址必须对齐。如果 CPU 发现你试图从地址 1 读取 4 字节，它根本无法生成对应的时序信号，直接抛出 <strong>Bus Error</strong> 或 <strong>Hard Fault</strong>，程序<strong>当场崩溃</strong>。</li>
<li><strong>在宽容的架构上（如 x86）</strong> ：CPU 硬件内部集成了复杂的处理逻辑。它会帮我们处理这种情况，自动发起<strong>两次</strong>内存访问（一次读第0行，一次读第1行），然后在 CPU 内部将两部分数据拼接起来。虽然程序没崩，但<strong>消耗了双倍的总线周期</strong>。</li>
</ol>
<p><strong>因此内存对齐的本质，就是为了保证在任何架构下，都能通过单次总线传输完成数据的读取，既不死机，也不降速。</strong></p>
<h3 data-id="heading-3">2.2 不同数据类型的自然对齐逻辑</h3>
<p>明白了总线的物理限制后，我们就能推导出不同数据类型在内存中的<strong>存放法则</strong>。</p>
<p>只要遵循下面这条<strong>黄金定律</strong>，就能保证数据永远不会跨越行边界：</p>
<p><strong>数据的起始地址，必须是该数据类型大小的整数倍。</strong> 即：<code>Address % sizeof(Type) == 0</code>。</p>
<p>下面我来解释一下为什么，我们还是看上面的内存表格。</p>
<ol>
<li><strong>对于 char</strong> ：因为它只有 1 个字节。无论你把它放在哪个位置，它都<strong>绝对不可能</strong>同时跨越两行。因此 char 不需要对齐，地址任意。</li>
</ol>

<ol start="2">
<li><strong>对于short</strong>：它占 2 个字节。</li>
</ol>
<p>如果放在 0：占 [0, 1]，在 Row 0 内，安全。</p>
<p>如果放在 1：占 [1, 2]，在 Row 0 内，安全。</p>
<p>如果放在 2：占 [2, 3]，在 Row 0 内，安全。</p>
<p>如果放在 3 (奇数)：占 [3, 4]。跨行了。</p>
<p>因此，为了防止这种情况，short 的地址必须是 2 的倍数</p>
<ol start="3">
<li>
<p><strong>对于 int</strong> ：占满了一整行。</p>
<p><strong>如果放在 0</strong>：占 [0, 1, 2, 3]，完美填满 Row 0，安全。</p>
<p><strong>如果放在 1</strong>：占 [1, 2, 3, 4]。跨越了 Row 0 和 Row 1。跨行！</p>
<p>因此int 的地址必须是 4 的倍数，这样才能保证它永远只落在同一行里，被 CPU 一次抓取。</p>
</li>
</ol>

<ol start="4">
<li>
<p><strong>对于Double (8字节)</strong> ： 在 64位系统 下，<strong>必须 8 字节对齐</strong>，否则跨越总线周期。</p>
<p>在 32位系统 下，虽然总线一次只能搬 4 字节，被迫读两次（这已经是极限了），但依然建议 8 字节对齐（或者至少 4 字节对齐），否则可能需要读三次！</p>
</li>
<li>
<p><strong>对于Long</strong> ： 千万不要想当然地认为 long 是 8 字节。</p>
<p>在 64位 Windows 下，long 依然是 4 字节（同 int）。</p>
<p>在 64位 Linux 下，long 才是 8 字节。</p>
<p>工程经验：在设计跨平台通信协议时，<strong>严禁使用 long</strong>，请直接使用 <code>&lt;stdint.h&gt;</code> 中的 <code>int32_t</code> 或 <code>int64_t</code>，明确指定字节宽，彻底消灭歧义。</p>
</li>
</ol>
<h3 data-id="heading-4">2.3 结构体中的隐形填充</h3>
<p>在明白了上面所讲的细节之后，我们再回过头看最开始的那个结构体 Demo，就能理解编译器为什么要浪费那 3 个字节了。</p>
<pre><code class="hljs language-c" lang="c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">demo</span> {</span>
    <span class="hljs-type">char</span> a; <span class="hljs-comment">// 1 字节</span>
    <span class="hljs-type">int</span> b;  <span class="hljs-comment">// 4 字节</span>
};
</code></pre>
<p>假设起始地址是 0，我们来模拟一下编译器安排内存的过程：</p>
<p>放置 <code>char a</code>：<code>char</code> 是一字节数据，对齐要求是 1。把它放在地址 0x00。</p>
<p>放置 <code>int b</code>：<code>int</code> 是四字节数据，对齐要求是 4。它必须放在 4 的倍数地址上。如果紧挨着 a 放，地址是 0x01 ，而 0x01 不是4的倍数，放在这里，CPU 读它需要两次总线操作，甚至报错。因此把 <code>int b</code> <strong>放在地址 0x04</strong>。</p>
<p>这时，0x01, 0x02, 0x03 这三个位置是空的。编译器会在这些位置自动填入 <strong>Padding Bytes（填充字节）</strong> ，顾名思义，这些字节只是起到了填充的作用。</p>
<p>最终的内存布局如下：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7e0fc48877c04ccaa0233339dbdaffbc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgeGxwNjY2aHVi:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766386221&amp;x-signature=j9dBvXnKqF3Gork0mJvlb0Yyp6o%3D" alt="3. 最终内存布局.png" loading="lazy"/></p>
<p><strong>计算总大小</strong>：1 (a) + 3 (padding) + 4 (b) = <strong>8 字节</strong>。</p>
<p>这就解释了为什么 <code>sizeof(demo)</code> 是 8，而不是 5。这是<strong>用空间换时间</strong>的典型策略。</p>
<h2 data-id="heading-5">3. 编译器的对齐原则</h2>
<p>讲完了总线宽度和自然对齐，我们再来看看软件层面。编译器在处理结构体时，并不是随意填充的，而是严格遵循一套<strong>对齐算法</strong>。这也正是我们能手动计算 <code>sizeof</code> 的依据。</p>
<p>编译器主要遵循两条核心原则：<strong>成员对齐</strong> 和 <strong>整体对齐</strong>。</p>
<h3 data-id="heading-6">3.1 成员对齐</h3>
<p>结构体中每个成员相对于结构体首地址的<strong>偏移量 (Offset)</strong> ，必须是<strong>该成员大小的整数倍</strong>（或者编译器指定的对齐模数 #pragma pack(n)，取二者较小值）。</p>
<p>我们还是以 struct demo 为例：</p>
<pre><code class="hljs language-c" lang="c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Demo</span> {</span>
    <span class="hljs-type">char</span> a; <span class="hljs-comment">// 1 byte</span>
    <span class="hljs-type">int</span> b;  <span class="hljs-comment">// 4 bytes</span>
};
</code></pre>
<p>结构体<strong>第一个成员的首地址</strong>与<strong>整个结构体的首地址</strong>是相同的，所以我们说，结构体第一个成员相对于结构体首地址的<strong>偏移量为0</strong>。</p>
<p>放置a：<code>char</code> 大小为 1。偏移量 0 正好是 1 的倍数。<strong>放在 Offset 0</strong>。</p>
<p>放置b：<code>int</code> 大小为 4。此时离 a 最近的可以存放的位置是 <strong>Offset 4</strong>。</p>
<p>也就是说，为了让 b 放在 Offset 4，编译器自动在 a 后面填充了 3 个字节（Padding）。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5e0b5c76eae14379b16050de4557f85d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgeGxwNjY2aHVi:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766386221&amp;x-signature=xuedjrkKLRsUSOhYXN4KFJWAZ8Q%3D" alt="4. 成员对齐内存布局.png" loading="lazy"/></p>
<p>最终的内存布局是这样的。</p>
<h3 data-id="heading-7">3.2 整体对齐</h3>
<p>结构体的<strong>总大小</strong>，必须是其<strong>内部最大成员大小</strong>的整数倍。</p>
<p><strong>为什么要这样规定？</strong> 其实这是为了<strong>结构体数组</strong>。</p>
<p>如果结构体是这样的：</p>
<pre><code class="hljs language-c" lang="c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">demo_reverse</span> {</span>
    <span class="hljs-type">int</span> a;  <span class="hljs-comment">// 4 bytes</span>
    <span class="hljs-type">char</span> b; <span class="hljs-comment">// 1 byte</span>
};
</code></pre>
<p>a 在 <strong>Offset 0</strong>，占据着0，1，2，3四个字节的位置。</p>
<p>b 是 char 型，可以任意放，那就放在 <strong>Offset 4</strong> 这个位置。</p>
<p>这样看起来确实是不需要填充的。</p>
<p>但是，如果我们定义一个数组 <code>struct Reverse arr[2];</code> 会发生什么？</p>
<p><strong>arr[0]</strong> ：占据地址 0x00 到 0x04。</p>
<p><strong>arr[1]</strong> ：如果结构体大小是 5，也就是说没有填充，那么 <code>arr[1]</code> 的起始地址就是 0x05。</p>
<p>这时候问题出现了：<code>arr[1].a</code> 的地址<strong>0x05</strong>。0x05 不是 4 的倍数。这意味着，数组里<strong>第二个元素的 int 成员竟然不对齐了</strong>，CPU 读它会<strong>变慢或者崩溃</strong>。</p>
<p>怎么解决呢？其实也很简单，编译器强制要求：<strong>结构体总大小 = 最大成员的倍数</strong>。这样就不会出现上面的问题了。</p>
<p>目前大小为 5，需要补齐到 8 (这是4的倍数)。所以在 <code>char b</code> 后面，编译器会加 3 个字节的 <code>Padding</code>。</p>
<p>此时的内存布局是这样的：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/af83649898d24a4e9ae0694d19d1999f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgeGxwNjY2aHVi:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766386221&amp;x-signature=wQkD9gmX24b5RRDhgLi9P%2Bccbd4%3D" alt="5. 整体对齐内存布局.png" loading="lazy"/></p>
<h3 data-id="heading-8">3.3 如何控制对齐</h3>
<p>在某些场景下（比如网络传输），我们不想浪费空间，或者协议规定了紧凑排列，我们可以<strong>修改编译器的默认行为</strong>。</p>
<h4 data-id="heading-9">3.3.1 <code>#pragma pack(n)</code></h4>
<p>告诉编译器：不要按成员大小对齐，按我指定的 n 来对齐。</p>
<pre><code class="hljs language-c" lang="c"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(1) <span class="hljs-comment">// 强制按 1 字节对齐（相当于不对齐）</span></span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">packed_demo</span> {</span>
    <span class="hljs-type">char</span> a;
    <span class="hljs-type">int</span> b;
};
<span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack() <span class="hljs-comment">// 用来恢复默认</span></span>
</code></pre>
<p><code>a</code> 在 0，<code>b</code> 在 1（因为 1 是 <code>pack(1)</code> 的倍数）。总共 1 + 4 = 5 字节。但是CPU 读写效率会降低。</p>
<h4 data-id="heading-10">3.3.2 <code>__attribute__((packed))</code> (GCC 特有)</h4>
<p>在 Linux 内核源码中，下面这种情况是很常见的：</p>
<pre><code class="hljs language-c" lang="c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">packet</span> {</span>
    <span class="hljs-type">char</span> head;
    <span class="hljs-type">int</span> len;
} __attribute__((packed));
</code></pre>
<p>这个效果和 3.3.1 中介绍的方法效果是相同的。</p>
<h2 data-id="heading-11">4. 实战避坑：网络通信与跨平台传输</h2>
<p>理解了对齐，你就能避开嵌入式网络编程中最大的“坑”。很多人在本地跑代码没问题，一联调设备就崩，原因往往就在这里。</p>
<h3 data-id="heading-12">4.1 当 64位服务器遇上 32位单片机</h3>
<p>在网络编程（物联网）中，我们经常直接把结构体指针转成 <code>void*</code>，通过 <code>Socket</code> 或串口直接发送出去。</p>
<p>假设我们定义了一个通信协议包：</p>
<pre><code class="hljs language-c" lang="c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Packet</span> {</span>
    <span class="hljs-type">char</span> cmd;    <span class="hljs-comment">// 1 byte (命令字)</span>
    <span class="hljs-type">int</span> length;  <span class="hljs-comment">// 4 bytes (数据长度)</span>
};
</code></pre>
<p>发送端（64位 Linux 开发机）：根据对齐规则，<code>cmd</code> 后面补 3 字节 <code>Padding</code>，<code>sizeof(Packet) = 8</code>。</p>
<p>发送的数据流为：<code>[cmd] [X] [X] [X] [len_byte1] [len_byte2]...</code></p>
<p>接收端（资源受限的 32位 STM32 单片机）：为了节省珍贵的 RAM，固件工程师可能在编译选项里开启了 <code>-fpack-struct</code>（全局紧凑模式），或者手动设置了对齐。 接收端认为：<code>sizeof(Packet) = 5</code>。 此时，它读取第 1 个字节当 <code>cmd</code>，紧接着读取第 2-5 个字节当 <code>length</code>。</p>
<p>结果是接收端把<strong>发送端填充的那 3 个垃圾字节当成了 length 的高位数据</strong>。</p>
<p>那么这种问题该怎么解决呢？请看下一章。</p>
<h3 data-id="heading-13">4.2 强制取消对齐</h3>
<p>在设计跨平台通信协议时，我们不能依赖编译器的默认对齐行为，因为你不知道对方的编译器是怎么想的。</p>
<p>我们需要<strong>显式</strong>地让编译器不要填充。</p>
<pre><code class="hljs language-c" lang="c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Packet</span> {</span>
    <span class="hljs-type">char</span> cmd;
    <span class="hljs-type">int</span> length;
} __attribute__((packed)); 
​
<span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(1)  </span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Packet</span> {</span>
    <span class="hljs-type">char</span> cmd;
    <span class="hljs-type">int</span> length;
};
<span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack()   </span>
</code></pre>
<p>这也是上面提到的两种方法。</p>
<p><code>sizeof</code> 变成了 <strong>5</strong>。发送端和接收端的内存布局完全一致。但代价是<strong>性能的牺牲</strong>。CPU 读取这个 <code>length</code> 时，因为地址不对齐（<code>Offset 1</code>），硬件需要进行两次总线访问和拼接。但在网络传输的<strong>正确性</strong>面前，这点 CPU 损耗是必须付出的。</p>
<h3 data-id="heading-14">4.3 关于 long 的陷阱</h3>
<p>除了对齐，数据类型的大小是另一个大坑。这里我先说结论：<strong>永远不要在跨平台协议中使用</strong> <strong>long</strong>。</p>
<p>因为 C 语言标准只规定 <code>long</code> 至少和 <code>int</code> 一样大，但是并没有规定具体是多少。</p>
<p>在Windows 64位中：<code>long</code> 是 <strong>4 字节</strong>。 在Linux 64位中：<code>long</code> 是 <strong>8 字节</strong>。</p>
<p>如果你在协议里写了 <code>long timestamp;</code>，Windows 发给 Linux，数据就会彻底错位。</p>
<p>那么不用 long 的话，该怎么定义 long 大小的数据类型呢？答案是永远使用 <code>&lt;stdint.h&gt;</code> 中的定长类型，明确指定位宽，不给编译器留任何解释空间：</p>
<pre><code class="hljs language-c" lang="c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span>
​
<span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(1)</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ProtocolHeader</span> {</span>
    <span class="hljs-type">uint8_t</span>  cmd;       
    <span class="hljs-type">uint32_t</span> length;    
    <span class="hljs-type">int64_t</span>  timestamp; 
};
<span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack()</span>
</code></pre>
<p>在底层开发中，显式定义是永远优于隐式定义的。</p>
<h2 data-id="heading-15">5. 高并发下的伪共享</h2>
<p>如果说前面的 <code>Padding</code> 是为了对齐而填充，那么在<strong>多线程高并发</strong>领域，我们有时需要反其道而行之，也就是为了<strong>不对齐</strong>而填充。</p>
<p>这听起来很矛盾？让我们回到硬件层面，聊聊 <strong>Cache Line</strong>。关于 Cache Line的详细内容我前面的文章已经讲的非常详细了，这里我们就直接进入本章节的内容。</p>
<h3 data-id="heading-16">5.1 同一个缓存行内的竞争</h3>
<p>Cache Line 大小通常是 <strong>64 字节</strong>。这意味着，当你读取一个 4 字节的整数时，CPU 会顺便把附近的 60 个字节也都加载到 L1 Cache 中（空间局部性）。但在<strong>多核多线程</strong>环境下，这个机制可能会好心办坏事。假设我们有一个全局结构体，被两个线程频繁访问：</p>
<pre><code class="hljs language-c" lang="c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SharedData</span> {</span>
    <span class="hljs-type">long</span> a; <span class="hljs-comment">// 线程 A 频繁修改</span>
    <span class="hljs-type">long</span> b; <span class="hljs-comment">// 线程 B 频繁修改</span>
};
</code></pre>
<p><code>long</code> 占 8 字节，a 和 b 紧挨着，加起来才 16 字节。在内存中，它们有很大概率会处在<strong>同一个 64 字节的 Cache Line</strong> 中。</p>
<p>请看下面的过程：</p>
<p>Core A 修改了变量 a。根据 <strong>MESI 缓存一致性协议</strong>，它必须广播告诉其他核心：这一行 Cache Line 已经被修改了，它是脏的，你们已经获取的 Cache Line 无效。 Core B 此时想修改变量 b。虽然 b 和 a 逻辑上无关，但因为它们<strong>在同一行 Cache Line</strong>，Core B 发现自己手里的 Cache 失效了。 Core B 不得不重新从 L3 或主存拉取最新的 Cache Line 数据，然后修改 b。这一修改，又导致 Core A 的 Cache Line 失效。</p>
<p>结果是两个线程明明修改的是不同的变量，却在硬件缓存层面<strong>互相打架</strong>，导致 CPU 在核心间疯狂倒腾数据，总线带宽被占满，性能暴跌。</p>
<p>这就是著名的<strong>伪共享 (False Sharing)</strong> 。</p>
<h3 data-id="heading-17">5.2 解决方案</h3>
<p>为了解决这个问题，我们需要<strong>手动填充</strong>，把 a 和 b <strong>分到不同的缓存行</strong>，让他们老死不相往来。具体做法如下：</p>
<p>我们需要在 a 后面强行塞入填充字节，使其填满一个 Cache Line：</p>
<pre><code class="hljs language-c" lang="c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SharedData</span> {</span>
    <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> a;
    <span class="hljs-comment">// 强制填充 56 字节，加上long型的a正好64字节</span>
    <span class="hljs-type">char</span> padding1[<span class="hljs-number">56</span>]; 
    
    <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> b;
    <span class="hljs-comment">// 尾部也填充，防止 b 和后面的变量冲突</span>
    <span class="hljs-type">char</span> padding2[<span class="hljs-number">56</span>]; 
};
</code></pre>
<h3 data-id="heading-18">5.3 应用案例</h3>
<p>这种方法虽然会浪费很多字节，但是在极致的高并发领域，是非常有必要的。</p>
<p><strong>Linux 内核</strong>：在自旋锁和一些网络设备驱动的数据结构中，经常使用 <code>____cacheline_aligned</code> 宏来强制对齐到 64 字节，防止多核竞争。</p>
<h2 data-id="heading-19">6. 结语</h2>
<p>到这里，这篇文章就结束了，从最开始的一个经典案例，到对硬件层面的解读，和编译器的优化以及作为编程人员的我们该怎样控制对齐，再到网络和跨平台通信的坑和高并发下的伪共享，相信大家已经很全面的认识并理解了<strong>内存对齐</strong>存在的意义，以及如何控制它。如果大家有任何问题可以发在评论区，我看到了都会恢复</p>
<p>最后，如果这篇文章对你有帮助，记得点赞和关注哦~</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[深入浅出链表操作：从Dummy节点到快慢指针的实战精要]]></title>    <link>https://juejin.cn/post/7584307642999406635</link>    <guid>https://juejin.cn/post/7584307642999406635</guid>    <pubDate>2025-12-16T10:25:13.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584307642999406635" data-draft-id="7584287969213972499" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="深入浅出链表操作：从Dummy节点到快慢指针的实战精要"/> <meta itemprop="keywords" content="前端,JavaScript,算法"/> <meta itemprop="datePublished" content="2025-12-16T10:25:13.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="栀秋666"/> <meta itemprop="url" content="https://juejin.cn/user/2566698322650307"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            深入浅出链表操作：从Dummy节点到快慢指针的实战精要
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2566698322650307/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    栀秋666
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-16T10:25:13.000Z" title="Tue Dec 16 2025 10:25:13 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-16
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{color:#595959;font-size:15px;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(60,10,30,.04) 3%,transparent 0),linear-gradient(1turn,rgba(60,10,30,.04) 3%,transparent 0);background-size:20px 20px;background-position:50%}.markdown-body p{color:#595959;font-size:15px;line-height:2;font-weight:400}.markdown-body p+p{margin-top:16px}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{padding:30px 0;margin:0;color:#135ce0}.markdown-body h1{position:relative;text-align:center;font-size:22px;margin:50px 0}.markdown-body h1:before{position:absolute;content:"";top:-10px;left:50%;width:32px;height:32px;transform:translateX(-50%);background-size:100% 100%;opacity:.36;background-repeat:no-repeat;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABfVBMVEX///8Ad/8AgP8AgP8AgP8Aff8AgP8Af/8AgP8AVf8Af/8Af/8AgP8AgP8Af/8Afv8AAP8Afv8Afv8Aef8AgP8AdP8Afv8AgP8AgP8Acf8Ae/8AgP8Af/8AgP8Af/8Af/8AfP8Afv8AgP8Af/8Af/8Afv8Afv8AgP8Afv8AgP8Af/8Af/8AgP8AgP8Afv8AgP8Af/8AgP8AgP8AgP8Ae/8Afv8Af/8AgP8Af/8AgP8Af/8Af/8Aff8Af/8Abf8AgP8Af/8AgP8Af/8Af/8Afv8AgP8AgP8Afv8Afv8AgP8Af/8Aff8AgP8Afv8AgP8Aff8AgP8AfP8AgP8Ae/8AgP8Af/8AgP8AgP8AgP8Afv8AgP8AgP8AgP8Afv8AgP8AgP8AgP8AgP8AgP8Af/8AgP8Af/8Af/8Aev8Af/8AgP8Aff8Afv8AgP8AgP8AgP8Af/8AgP8Af/8Af/8AgP8Afv8AgP8AgP8AgP8AgP8Af/8AeP8Af/8Af/8Af//////rzEHnAAAAfXRSTlMAD7CCAivatxIDx5EMrP19AXdLEwgLR+6iCR/M0yLRzyFF7JupSXn8cw6v60Q0QeqzKtgeG237HMne850/6Qeq7QaZ+WdydHtj+OM3qENCMRYl1B3K2U7wnlWE/mhlirjkODa9FN/BF7/iNV/2kASNZpX1Wlf03C4stRGxgUPclqoAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEaBzgZ4yeM3AAAAT9JREFUOMvNUldbwkAQvCAqsSBoABE7asSOBRUVVBQNNuy9996789+9cMFAMHnVebmdm+/bmdtbQv4dOFOW2UjPzgFyLfo6nweKfIMOBYWwFtmMPGz2Yj2pJI0JDq3udJW6VVbmKa9I192VQFV1ktXUAl5NB0cd4KpnORqsEO2ZIRpF9gJfE9Dckqq0KuZt7UAH5+8EPF3spjsRpCeQNO/tA/qDwIDA+OCQbBoKA8NOdjMySgcZGVM6jwcgRuUiSs0nlPFNSrEpJfU0jTLD6llqbvKxei7OzvkFNQohi0vAsj81+MoqsCaoPOQFgus/1LyxichW+hS2JWCHZ7VlF9jb187pIAYcHiViHAMnp5mTjJ8B5xeEXF4B1ze/fTh/C0h398DDI9HB07O8ci+vRBdvdGnfP4gBuM8vw7X/G3wDmFhFZEdxzjMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDEtMjZUMDc6NTY6MjUrMDE6MDA67pVWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAxLTI2VDA3OjU2OjI1KzAxOjAwS7Mt6gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAWdEVYdFRpdGxlAGp1ZWppbl9sb2dvIGNvcHlxapmKAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC)}.markdown-body h2{position:relative;font-size:20px;border-left:4px solid;padding:0 0 0 10px;margin:30px 0}.markdown-body h3{font-size:16px}.markdown-body ul{list-style:disc outside;margin-left:2em;margin-top:1em}.markdown-body li{line-height:2;color:#595959}.markdown-body img.loaded{margin:0 auto;display:block}.markdown-body blockquote{background:#fff9f9;margin:2em 0;padding:2px 20px;border-left:4px solid #b2aec5}.markdown-body blockquote p{color:#666;line-height:2}.markdown-body a{color:#036aca;border-bottom:1px solid rgba(3,106,202,.8);font-weight:400;text-decoration:none}.markdown-body em strong,.markdown-body strong{color:#036aca}.markdown-body hr{border-top:1px solid #135ce0}.markdown-body pre{overflow:auto}.markdown-body code,.markdown-body pre{overflow:auto;position:relative;line-height:1.75;font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body table{border-collapse:collapse;margin:1rem 0;overflow-x:auto}.markdown-body table td,.markdown-body table th{border:1px solid #dfe2e5;padding:.6em 1em}.markdown-body table tr{border-top:1px solid #dfe2e5}.markdown-body table tr:nth-child(2n){background-color:#f6f8fa}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">引言</h2>
<p>在数据结构的学习中，链表以其动态灵活的内存管理特性，成为算法设计与面试考察的重点。然而，由于其依赖指针操作、缺乏随机访问能力，许多开发者在处理链表问题时常常陷入边界混乱、逻辑断裂的困境。本文将聚焦三大核心技巧——<strong>dummy节点、头插法反转、快慢指针</strong>，系统梳理链表操作的本质逻辑，助你构建清晰稳定的解题思维。</p>
<hr/>
<h3 data-id="heading-1">一、Dummy节点：统一边界处理的“万能哨兵”</h3>
<p>链表操作中最令人头疼的问题之一，是<strong>头节点的特殊性</strong>。例如删除值为 <code>val</code> 的节点时，若目标恰好是头节点，由于它没有前驱，无法通过“前驱修改 next”的方式删除，必须单独判断。</p>
<p>这种“例外情况”不仅增加代码复杂度，还容易引发空指针异常，尤其在空链表或全匹配场景下极易出错。</p>
<h4 data-id="heading-2">解决方案：引入 dummy 节点</h4>
<p>dummy 节点（又称哨兵节点）是一个不存储有效数据的人工节点，通常置于链表头部，作为 <code>head</code> 的前驱。它的核心价值在于：</p>
<blockquote>
<p><strong>让所有节点都拥有前驱，从而将头节点降级为普通节点，实现操作统一化。</strong></p>
</blockquote>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">removeElements</span>(<span class="hljs-params">head, val</span>) {
    <span class="hljs-keyword">const</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);
    dummy.<span class="hljs-property">next</span> = head;
    <span class="hljs-keyword">let</span> cur = dummy;

    <span class="hljs-keyword">while</span> (cur.<span class="hljs-property">next</span>) {
        <span class="hljs-keyword">if</span> (cur.<span class="hljs-property">next</span>.<span class="hljs-property">val</span> === val) {
            cur.<span class="hljs-property">next</span> = cur.<span class="hljs-property">next</span>.<span class="hljs-property">next</span>;
        } <span class="hljs-keyword">else</span> {
            cur = cur.<span class="hljs-property">next</span>;
        }
    }

    <span class="hljs-keyword">return</span> dummy.<span class="hljs-property">next</span>;
}
</code></pre>
<p>此时无论原头节点是否被删除，<code>dummy.next</code> 始终指向新的头节点，彻底规避了对 <code>head</code> 的特殊处理，也避免了空链表下的 <code>null</code> 异常。</p>
<p>💡 <strong>使用原则</strong>：</p>
<ul>
<li>凡涉及节点删除、插入等可能影响头节点的操作，优先考虑添加 dummy。</li>
<li>最终返回 <code>dummy.next</code>，而非原始 head。</li>
</ul>
<hr/>
<h3 data-id="heading-3">二、头插法反转链表：最优雅的就地反转策略</h3>
<p>链表反转是经典操作，常见解法有递归法和三指针迭代法。而<strong>基于 dummy 的头插法</strong>，逻辑最为直观，不易出错。</p>
<h4 data-id="heading-4">核心思想</h4>
<p>遍历原链表，将每个节点依次“插入”到 dummy 节点之后，形成一个新的逆序链。随着遍历进行，已处理部分自然构成一个反向链表。</p>
<h4 data-id="heading-5">实现步骤</h4>
<ol>
<li>创建 <code>dummy</code> 节点，初始 <code>dummy.next = null</code></li>
<li>遍历原链表，对每个节点 <code>cur</code>：
<ul>
<li>保存其后继：<code>const next = cur.next</code></li>
<li>将 <code>cur</code> 插入 dummy 后：<code>cur.next = dummy.next</code></li>
<li>更新 dummy 指向新头：<code>dummy.next = cur</code></li>
<li>继续处理：<code>cur = next</code></li>
</ul>
</li>
</ol>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">reverseList</span>(<span class="hljs-params">head</span>) {
    <span class="hljs-keyword">const</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">let</span> cur = head;

    <span class="hljs-keyword">while</span> (cur) {
        <span class="hljs-keyword">const</span> next = cur.<span class="hljs-property">next</span>;     <span class="hljs-comment">// 保存后续</span>
        cur.<span class="hljs-property">next</span> = dummy.<span class="hljs-property">next</span>;     <span class="hljs-comment">// 接到已反转部分</span>
        dummy.<span class="hljs-property">next</span> = cur;          <span class="hljs-comment">// 成为新头</span>
        cur = next;                <span class="hljs-comment">// 继续遍历</span>
    }

    <span class="hljs-keyword">return</span> dummy.<span class="hljs-property">next</span>;
}
</code></pre>
<p>✅ <strong>优势分析</strong>：</p>
<ul>
<li>时间复杂度 O(n)，空间复杂度 O(1)</li>
<li>无需额外变量记录 prev 和 next</li>
<li>逻辑清晰，适合快速编码</li>
</ul>
<p>📌 <strong>关键提醒</strong>：务必在修改 <code>cur.next</code> 前保存 <code>next</code>，否则原链断裂，遍历中断。</p>
<hr/>
<h3 data-id="heading-6">三、快慢指针：高效定位的“双引擎”</h3>
<p>当需要在单次遍历中定位特定位置（如中间节点、倒数第 N 个、环入口），<strong>快慢指针</strong>是最高效的工具。</p>
<p>其基本形式为：</p>
<ul>
<li><code>slow</code> 每次走 1 步</li>
<li><code>fast</code> 每次走 2 步</li>
</ul>
<p>利用两者速度差，可巧妙解决多种问题。</p>
<h4 data-id="heading-7">应用 1：判断链表是否有环</h4>
<p>若链表无环，<code>fast</code> 会先到达末尾（<code>null</code>）。若有环，<code>fast</code> 进入环后会不断追赶 <code>slow</code>，最终相遇。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">hasCycle</span>(<span class="hljs-params">head</span>) {
    <span class="hljs-keyword">let</span> slow = head, fast = head;

    <span class="hljs-keyword">while</span> (fast &amp;&amp; fast.<span class="hljs-property">next</span>) {
        slow = slow.<span class="hljs-property">next</span>;
        fast = fast.<span class="hljs-property">next</span>.<span class="hljs-property">next</span>;
        <span class="hljs-keyword">if</span> (slow === fast) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}
</code></pre>
<p>为何 <code>fast</code> 走两步？因为每轮两者距离缩小 1，必能追上；若走更多步，可能跳过 <code>slow</code> 导致误判。</p>
<h4 data-id="heading-8">应用 2：查找中间节点</h4>
<p>当 <code>fast</code> 到达末尾时，<code>slow</code> 正好位于中点。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">middleNode</span>(<span class="hljs-params">head</span>) {
    <span class="hljs-keyword">let</span> slow = head, fast = head;
    <span class="hljs-keyword">while</span> (fast &amp;&amp; fast.<span class="hljs-property">next</span>) {
        slow = slow.<span class="hljs-property">next</span>;
        fast = fast.<span class="hljs-property">next</span>.<span class="hljs-property">next</span>;
    }
    <span class="hljs-keyword">return</span> slow;
}
</code></pre>
<p>此方法适用于奇偶长度链表，返回靠后的中间节点。</p>
<h4 data-id="heading-9">应用 3：删除倒数第 N 个节点</h4>
<p>思路：让 <code>fast</code> 先走 N 步，再与 <code>slow</code> 同步前进。当 <code>fast</code> 到达末尾时，<code>slow</code> 指向目标节点的前驱。</p>
<p>结合 dummy 节点，可统一处理头节点删除：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">removeNthFromEnd</span>(<span class="hljs-params">head, n</span>) {
    <span class="hljs-keyword">const</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);
    dummy.<span class="hljs-property">next</span> = head;
    <span class="hljs-keyword">let</span> fast = dummy, slow = dummy;

    <span class="hljs-keyword">while</span> (n--) fast = fast.<span class="hljs-property">next</span>;

    <span class="hljs-keyword">while</span> (fast.<span class="hljs-property">next</span>) {
        fast = fast.<span class="hljs-property">next</span>;
        slow = slow.<span class="hljs-property">next</span>;
    }

    slow.<span class="hljs-property">next</span> = slow.<span class="hljs-property">next</span>.<span class="hljs-property">next</span>;
    <span class="hljs-keyword">return</span> dummy.<span class="hljs-property">next</span>;
}
</code></pre>
<hr/>
<h3 data-id="heading-10">四、总结：链表操作的四大心法</h3>
<ol>
<li>
<p><strong>Dummy优先原则</strong><br/>
所有涉及结构变更的操作，优先添加 dummy 节点，消除边界差异。</p>
</li>
<li>
<p><strong>指针安全第一</strong><br/>
修改任何 <code>next</code> 指针前，务必保存后续节点引用，防止链表断裂。</p>
</li>
<li>
<p><strong>快慢指针提速</strong><br/>
涉及“中点”、“倒数”、“环”等问题，首选快慢指针，实现一次遍历定位。</p>
</li>
<li>
<p><strong>动手画图验证</strong><br/>
链表逻辑抽象，建议用简单实例（如 3 个节点）手动模拟每一步指针变化，确保理解正确。</p>
</li>
</ol>
<hr/>
<p>掌握这三大技巧，你就拥有了应对绝大多数链表问题的“工具箱”。它们不仅是解题方法，更是一种编程思维：<strong>通过引入辅助结构（dummy）、控制相对速度（快慢指针）、重构处理顺序（头插法），将复杂问题转化为可统一处理的模式</strong>。</p>
<p>链表并不可怕，可怕的是没有章法。当你学会用这些模式去拆解问题，你会发现，所谓的“难题”，不过是基础技巧的组合应用。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[React页面刷新数据不丢失？5种方案全解析！]]></title>    <link>https://juejin.cn/post/7583913535271092234</link>    <guid>https://juejin.cn/post/7583913535271092234</guid>    <pubDate>2025-12-15T13:30:16.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7583913535271092234" data-draft-id="7583878719544147977" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="React页面刷新数据不丢失？5种方案全解析！"/> <meta itemprop="keywords" content="React.js"/> <meta itemprop="datePublished" content="2025-12-15T13:30:16.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="北辰alk"/> <meta itemprop="url" content="https://juejin.cn/user/1772855673241352"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            React页面刷新数据不丢失？5种方案全解析！
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1772855673241352/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    北辰alk
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-15T13:30:16.000Z" title="Mon Dec 15 2025 13:30:16 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-15
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>前端开发中，相信大家都遇到过这样的痛点：<strong>页面一刷新，辛辛苦苦填的表单数据没了！精心选择的筛选条件重置了！</strong></p>
<p>今天我们就来深入探讨React中数据持久化的<strong>5大核心方案</strong>，从简单到复杂，帮你彻底解决这个难题！</p>
<h2 data-id="heading-0">一、问题场景：为什么数据会丢失？</h2>
<p>我们先通过一个简单例子感受一下问题：</p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">UserForm</span>(<span class="hljs-params"/>) </span>{
  <span class="hljs-keyword">const</span> [formData, setFormData] = <span class="hljs-title function_ invoke__">useState</span>({
<span class="hljs-attr">    username</span>: <span class="hljs-string">''</span>,
<span class="hljs-attr">    email</span>: <span class="hljs-string">''</span>,
<span class="hljs-attr">    preferences</span>: {
<span class="hljs-attr">      theme</span>: <span class="hljs-string">'light'</span>,
<span class="hljs-attr">      notifications</span>: <span class="hljs-literal">true</span>
    }
  });

  <span class="hljs-comment">// 用户输入数据...</span>
  <span class="hljs-comment">// 页面刷新 → 所有数据归零 😭</span>
  
  <span class="hljs-keyword">return</span><span class="hljs-title function_ invoke__"> </span>(
    &lt;form&gt;
      &lt;input 
        value={formData.username}
        onChange={(e) =&gt; <span class="hljs-title function_ invoke__">setFormData</span>({...formData,<span class="hljs-attr"> username</span>: e.target.value})}
      /&gt;
      {<span class="hljs-comment">/* 其他表单项 */</span>}
    &lt;/form&gt;
  );
}
</code></pre>
<p>数据丢失的根本原因是：<strong>React状态（state）存储在内存中，页面刷新时内存被清空</strong>。</p>
<h2 data-id="heading-1">二、方案一：localStorage（最常用）</h2>
<h3 data-id="heading-2">基本实现</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">useLocalStorage</span>(<span class="hljs-params">key, initialValue</span>) {
  <span class="hljs-comment">// 从localStorage读取初始值</span>
  <span class="hljs-keyword">const</span> [storedValue, setStoredValue] = <span class="hljs-title function_">useState</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> item = <span class="hljs-variable language_">window</span>.<span class="hljs-property">localStorage</span>.<span class="hljs-title function_">getItem</span>(key);
      <span class="hljs-keyword">return</span> item ? <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(item) : initialValue;
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error);
      <span class="hljs-keyword">return</span> initialValue;
    }
  });

  <span class="hljs-comment">// 更新状态并保存到localStorage</span>
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">setValue</span> = (<span class="hljs-params">value</span>) =&gt; {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> valueToStore = value <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span> ? <span class="hljs-title function_">value</span>(storedValue) : value;
      <span class="hljs-title function_">setStoredValue</span>(valueToStore);
      <span class="hljs-variable language_">window</span>.<span class="hljs-property">localStorage</span>.<span class="hljs-title function_">setItem</span>(key, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(valueToStore));
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error);
    }
  };

  <span class="hljs-keyword">return</span> [storedValue, setValue];
}

<span class="hljs-comment">// 使用示例</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">PersistentForm</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> [userData, setUserData] = <span class="hljs-title function_">useLocalStorage</span>(<span class="hljs-string">'user_form_data'</span>, {
    <span class="hljs-attr">username</span>: <span class="hljs-string">''</span>,
    <span class="hljs-attr">email</span>: <span class="hljs-string">''</span>,
    <span class="hljs-attr">theme</span>: <span class="hljs-string">'light'</span>
  });

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">input</span>
        <span class="hljs-attr">value</span>=<span class="hljs-string">{userData.username}</span>
        <span class="hljs-attr">onChange</span>=<span class="hljs-string">{(e)</span> =&gt;</span> setUserData({
          ...userData, 
          username: e.target.value
        })}
      /&gt;
      {/* 保存后刷新页面，数据还在！ */}
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}
</code></pre>
<h3 data-id="heading-3">进阶：自动过期和加密</h3>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SecureStorage</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">namespace</span></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">namespace</span> = <span class="hljs-keyword">namespace</span>;
  }

  set(key, value, ttl = null) {
    <span class="hljs-keyword">const</span> item = {
      value,
      <span class="hljs-attr">timestamp</span>: <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>(),
      ttl
    };
    
    <span class="hljs-comment">// 简单加密（生产环境应使用更安全的方案）</span>
    <span class="hljs-keyword">const</span> encrypted = <span class="hljs-title function_">btoa</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(item));
    <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.<span class="hljs-keyword">namespace</span>}</span>:<span class="hljs-subst">${key}</span>`</span>, encrypted);
  }

  <span class="hljs-title function_">get</span>(<span class="hljs-params">key</span>) {
    <span class="hljs-keyword">const</span> encrypted = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.<span class="hljs-keyword">namespace</span>}</span>:<span class="hljs-subst">${key}</span>`</span>);
    <span class="hljs-keyword">if</span> (!encrypted) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;

    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> item = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title function_">atob</span>(encrypted));
      
      <span class="hljs-comment">// 检查是否过期</span>
      <span class="hljs-keyword">if</span> (item.<span class="hljs-property">ttl</span> &amp;&amp; <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() - item.<span class="hljs-property">timestamp</span> &gt; item.<span class="hljs-property">ttl</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">remove</span>(key);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }
      
      <span class="hljs-keyword">return</span> item.<span class="hljs-property">value</span>;
    } <span class="hljs-keyword">catch</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }
  }
}

<span class="hljs-comment">// 使用</span>
<span class="hljs-keyword">const</span> storage = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecureStorage</span>(<span class="hljs-string">'myApp'</span>);
storage.<span class="hljs-title function_">set</span>(<span class="hljs-string">'token'</span>, <span class="hljs-string">'abc123'</span>, <span class="hljs-number">1000</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span>); <span class="hljs-comment">// 1小时过期</span>
</code></pre>
<h2 data-id="heading-4">三、方案二：sessionStorage（标签页级别）</h2>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">useSessionStorage</span>(<span class="hljs-params">key, initialValue</span>) {
  <span class="hljs-keyword">const</span> [state, setState] = <span class="hljs-title function_">useState</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// 只在客户端执行</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">window</span> === <span class="hljs-string">'undefined'</span>) <span class="hljs-keyword">return</span> initialValue;
    
    <span class="hljs-keyword">const</span> stored = sessionStorage.<span class="hljs-title function_">getItem</span>(key);
    <span class="hljs-keyword">return</span> stored ? <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(stored) : initialValue;
  });

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    sessionStorage.<span class="hljs-title function_">setItem</span>(key, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(state));
  }, [key, state]);

  <span class="hljs-keyword">return</span> [state, setState];
}

<span class="hljs-comment">// 特性：不同标签页数据隔离，关闭标签页自动清除</span>
</code></pre>
<h2 data-id="heading-5">四、方案三：IndexedDB（大量数据）</h2>
<p>当需要存储大量结构化数据时，IndexedDB是更好的选择：</p>
<pre><code class="hljs language-ini" lang="ini">class IndexedDBService {
  constructor(dbName, version) {
    <span class="hljs-attr">this.dbName</span> = dbName<span class="hljs-comment">;</span>
    <span class="hljs-attr">this.version</span> = version<span class="hljs-comment">;</span>
    <span class="hljs-attr">this.db</span> = null<span class="hljs-comment">;</span>
  }

  async open() {
    return new Promise((resolve, reject) =&gt; {
      const <span class="hljs-attr">request</span> = indexedDB.open(this.dbName, this.version)<span class="hljs-comment">;</span>

      <span class="hljs-attr">request.onupgradeneeded</span> = (event) =&gt; {
        const <span class="hljs-attr">db</span> = event.target.result<span class="hljs-comment">;</span>
        if (!db.objectStoreNames.contains('state')) {
          db.createObjectStore('state', { keyPath: 'key' })<span class="hljs-comment">;</span>
        }
      }<span class="hljs-comment">;</span>

      <span class="hljs-attr">request.onsuccess</span> = (event) =&gt; {
        <span class="hljs-attr">this.db</span> = event.target.result<span class="hljs-comment">;</span>
        resolve()<span class="hljs-comment">;</span>
      }<span class="hljs-comment">;</span>

      <span class="hljs-attr">request.onerror</span> = (event) =&gt; reject(event.target.error)<span class="hljs-comment">;</span>
    })<span class="hljs-comment">;</span>
  }

  async set(key, value) {
    const <span class="hljs-attr">transaction</span> = this.db.transaction([<span class="hljs-string">'state'</span>], <span class="hljs-string">'readwrite'</span>)<span class="hljs-comment">;</span>
    const <span class="hljs-attr">store</span> = transaction.objectStore(<span class="hljs-string">'state'</span>)<span class="hljs-comment">;</span>
    store.put({ key, value })<span class="hljs-comment">;</span>
  }

  async get(key) {
    return new Promise((resolve, reject) =&gt; {
      const <span class="hljs-attr">transaction</span> = this.db.transaction([<span class="hljs-string">'state'</span>], <span class="hljs-string">'readonly'</span>)<span class="hljs-comment">;</span>
      const <span class="hljs-attr">store</span> = transaction.objectStore(<span class="hljs-string">'state'</span>)<span class="hljs-comment">;</span>
      const <span class="hljs-attr">request</span> = store.get(key)<span class="hljs-comment">;</span>

      <span class="hljs-attr">request.onsuccess</span> = () =&gt; resolve(request.result?.value)<span class="hljs-comment">;</span>
      <span class="hljs-attr">request.onerror</span> = () =&gt; reject(request.error)<span class="hljs-comment">;</span>
    })<span class="hljs-comment">;</span>
  }
}

// React Hook封装
function useIndexedDB(key, initialValue) {
  const <span class="hljs-section">[value, setValue]</span> = useState(initialValue)<span class="hljs-comment">;</span>
  const <span class="hljs-section">[db, setDb]</span> = useState(null)<span class="hljs-comment">;</span>

  useEffect(() =&gt; {
    const <span class="hljs-attr">initDB</span> = async () =&gt; {
      const <span class="hljs-attr">dbService</span> = new IndexedDBService(<span class="hljs-string">'AppDB'</span>, <span class="hljs-number">1</span>)<span class="hljs-comment">;</span>
      await dbService.open()<span class="hljs-comment">;</span>
      setDb(dbService)<span class="hljs-comment">;</span>
      
      const <span class="hljs-attr">stored</span> = await dbService.get(key)<span class="hljs-comment">;</span>
      if (stored) setValue(stored)<span class="hljs-comment">;</span>
    }<span class="hljs-comment">;</span>
    
    initDB()<span class="hljs-comment">;</span>
  }, <span class="hljs-section">[key]</span>)<span class="hljs-comment">;</span>

  const <span class="hljs-attr">updateValue</span> = async (newValue) =&gt; {
    setValue(newValue)<span class="hljs-comment">;</span>
    if (db) await db.set(key, newValue)<span class="hljs-comment">;</span>
  }<span class="hljs-comment">;</span>

  return <span class="hljs-section">[value, updateValue]</span><span class="hljs-comment">;</span>
}
</code></pre>
<h2 data-id="heading-6">五、方案四：URL参数（分享友好型）</h2>
<p>适合筛选条件等需要分享的场景：</p>
<pre><code class="hljs language-ini" lang="ini">import { useHistory, useLocation } from 'react-router-dom'<span class="hljs-comment">;</span>

function useURLState(key, initialValue) {
  const <span class="hljs-attr">location</span> = useLocation()<span class="hljs-comment">;</span>
  const <span class="hljs-attr">history</span> = useHistory()<span class="hljs-comment">;</span>
  
  const <span class="hljs-attr">queryParams</span> = new URLSearchParams(location.search)<span class="hljs-comment">;</span>
  
  const <span class="hljs-section">[value, setValue]</span> = useState(() =&gt; {
    const <span class="hljs-attr">param</span> = queryParams.get(key)<span class="hljs-comment">;</span>
    return param ? JSON.parse(decodeURIComponent(param)) : initialValue<span class="hljs-comment">;</span>
  })<span class="hljs-comment">;</span>

  const <span class="hljs-attr">setURLValue</span> = (newValue) =&gt; {
    setValue(newValue)<span class="hljs-comment">;</span>
    
    // 更新URL参数
    const <span class="hljs-attr">newParams</span> = new URLSearchParams(location.search)<span class="hljs-comment">;</span>
    newParams.set(key, encodeURIComponent(JSON.stringify(newValue)))<span class="hljs-comment">;</span>
    
    history.replace({
      pathname: location.pathname,
      search: newParams.toString()
    })<span class="hljs-comment">;</span>
  }<span class="hljs-comment">;</span>

  return <span class="hljs-section">[value, setURLValue]</span><span class="hljs-comment">;</span>
}

// 使用：URL会显示 ?<span class="hljs-attr">filters</span>=%<span class="hljs-number">7</span>B%<span class="hljs-number">22</span>status%<span class="hljs-number">22</span>%<span class="hljs-number">3</span>A%<span class="hljs-number">22</span>active%<span class="hljs-number">22</span>%<span class="hljs-number">7</span>D
function FilterComponent() {
  const <span class="hljs-section">[filters, setFilters]</span> = useURLState('filters', { status: 'all' })<span class="hljs-comment">;</span>
  
  // 分享当前URL，别人打开能看到同样的筛选结果
}
</code></pre>
<h2 data-id="heading-7">六、方案五：Redux + 持久化中间件</h2>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// store/persistConfig.js</span>
<span class="hljs-keyword">const</span> persistConfig = {
  <span class="hljs-attr">key</span>: <span class="hljs-string">'root'</span>,
  storage, <span class="hljs-comment">// 可以是localStorage、sessionStorage等</span>
  <span class="hljs-attr">whitelist</span>: [<span class="hljs-string">'auth'</span>, <span class="hljs-string">'userPreferences'</span>], <span class="hljs-comment">// 只持久化这些reducer</span>
  <span class="hljs-attr">blacklist</span>: [<span class="hljs-string">'temporaryData'</span>], <span class="hljs-comment">// 不持久化这些</span>
  <span class="hljs-attr">transforms</span>: [
    <span class="hljs-comment">// 数据转换（如加密）</span>
    <span class="hljs-title function_">encryptTransform</span>({
      <span class="hljs-attr">secretKey</span>: process.<span class="hljs-property">env</span>.<span class="hljs-property">REACT_APP_ENCRYPT_KEY</span>
    })
  ]
};

<span class="hljs-comment">// store/index.js</span>
<span class="hljs-keyword">import</span> { createStore } <span class="hljs-keyword">from</span> <span class="hljs-string">'redux'</span>;
<span class="hljs-keyword">import</span> { persistStore, persistReducer } <span class="hljs-keyword">from</span> <span class="hljs-string">'redux-persist'</span>;
<span class="hljs-keyword">import</span> storage <span class="hljs-keyword">from</span> <span class="hljs-string">'redux-persist/lib/storage'</span>;

<span class="hljs-keyword">const</span> persistedReducer = <span class="hljs-title function_">persistReducer</span>(persistConfig, rootReducer);

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(persistedReducer);
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> persistor = <span class="hljs-title function_">persistStore</span>(store);

<span class="hljs-comment">// App.js</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">PersistGate</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'redux-persist/integration/react'</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Provider</span> <span class="hljs-attr">store</span>=<span class="hljs-string">{store}</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">PersistGate</span> <span class="hljs-attr">loading</span>=<span class="hljs-string">{</span>&lt;<span class="hljs-attr">LoadingSpinner</span> /&gt;</span>} persistor={persistor}&gt;
        <span class="hljs-tag">&lt;<span class="hljs-name">MainApp</span> /&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">PersistGate</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">Provider</span>&gt;</span></span>
  );
}
</code></pre>
<h2 data-id="heading-8">七、数据持久化流程图</h2>
<pre><code class="hljs">小量简单数据

标签页隔离数据

大量结构化数据

可分享状态

全局状态管理

页面刷新数据恢复决策localStoragesessionStorageIndexedDBURL参数Redux持久化快速读取
5-10MB限制会话级存储
标签页独立大容量存储
异步操作可分享状态
URL可见集成Redux
状态同步数据恢复完成
</code></pre>
<h2 data-id="heading-9">八、性能与安全最佳实践</h2>
<h3 data-id="heading-10">1. 防抖保存避免频繁写入</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">useDebouncedPersist</span>(<span class="hljs-params">key, value, delay = <span class="hljs-number">1000</span></span>) {
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(key, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(value));
    }, delay);
    
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">clearTimeout</span>(timer);
  }, [key, value, delay]);
}
</code></pre>
<h3 data-id="heading-11">2. 数据压缩（大数据量时）</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> { compress, decompress } <span class="hljs-keyword">from</span> <span class="hljs-string">'lz-string'</span>;

<span class="hljs-keyword">const</span> <span class="hljs-title function_">compressData</span> = (<span class="hljs-params">data</span>) =&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">compress</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data));
};

<span class="hljs-keyword">const</span> <span class="hljs-title function_">decompressData</span> = (<span class="hljs-params">compressed</span>) =&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title function_">decompress</span>(compressed));
};
</code></pre>
<h3 data-id="heading-12">3. 安全存储敏感信息</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 永远不要这样做！</span>
<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">'token'</span>, rawToken);

<span class="hljs-comment">// 应该：使用HttpOnly Cookie或临时内存存储</span>
</code></pre>
<h2 data-id="heading-13">九、方案对比选择指南</h2>















































<table><thead><tr><th>方案</th><th>容量</th><th>生命周期</th><th>使用场景</th><th>优缺点</th></tr></thead><tbody><tr><td><strong>localStorage</strong></td><td>5-10MB</td><td>永久</td><td>用户偏好设置</td><td>简单易用，但同步阻塞</td></tr><tr><td><strong>sessionStorage</strong></td><td>5-10MB</td><td>标签页</td><td>临时表单数据</td><td>标签页隔离，关闭即失</td></tr><tr><td><strong>IndexedDB</strong></td><td>大量</td><td>永久</td><td>离线应用数据</td><td>异步大容量，API复杂</td></tr><tr><td><strong>URL参数</strong></td><td>受限</td><td>页面级别</td><td>筛选条件分享</td><td>可分享，但有长度限制</td></tr><tr><td><strong>Redux持久化</strong></td><td>灵活</td><td>可配置</td><td>全局状态管理</td><td>集成度高，需额外配置</td></tr></tbody></table>
<h2 data-id="heading-14">十、实战：完整表单持久化示例</h2>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">PersistentForm</span>(<span class="hljs-params"/>) {
  <span class="hljs-comment">// 综合使用多种方案</span>
  <span class="hljs-keyword">const</span> [basicInfo, setBasicInfo] = <span class="hljs-title function_">useLocalStorage</span>(<span class="hljs-string">'form_basic'</span>, {});
  <span class="hljs-keyword">const</span> [tempData, setTempData] = <span class="hljs-title function_">useSessionStorage</span>(<span class="hljs-string">'form_temp'</span>, {});
  <span class="hljs-keyword">const</span> [filters, setFilters] = <span class="hljs-title function_">useURLState</span>(<span class="hljs-string">'form_filters'</span>, {});
  
  <span class="hljs-comment">// 自动保存草稿</span>
  <span class="hljs-title function_">useDebouncedPersist</span>(<span class="hljs-string">'form_draft'</span>, {
    basicInfo,
    tempData
  }, <span class="hljs-number">2000</span>);
  
  <span class="hljs-comment">// 离开页面提示</span>
  <span class="hljs-title function_">useBeforeUnload</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">if</span> (hasUnsavedChanges) {
      <span class="hljs-keyword">return</span> <span class="hljs-string">'您有未保存的更改，确定要离开吗？'</span>;
    }
  });
  
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      {/* 表单内容 */}
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{clearAllStorage}</span>&gt;</span>
        清空所有持久化数据
      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}
</code></pre>
<h2 data-id="heading-15">总结</h2>
<p>React数据持久化没有银弹，<strong>关键在于根据场景选择合适的方案</strong>：</p>
<ol>
<li>1. <strong>用户设置</strong> → localStorage</li>
<li>2. <strong>临时表单</strong> → sessionStorage</li>
<li>3. <strong>离线数据</strong> → IndexedDB</li>
<li>4. <strong>分享状态</strong> → URL参数</li>
<li>5. <strong>全局状态</strong> → Redux持久化</li>
</ol>
<p>记住一个原则：<strong>敏感信息永远不要在前端持久化</strong>！token、密码等应该通过HttpOnly Cookie或后端session管理。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[一个看似“送分”的需求为何翻车？——前端状态机实战指南]]></title>    <link>https://juejin.cn/post/7584071941025497103</link>    <guid>https://juejin.cn/post/7584071941025497103</guid>    <pubDate>2025-12-16T10:55:02.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584071941025497103" data-draft-id="7583799807594201122" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="一个看似“送分”的需求为何翻车？——前端状态机实战指南"/> <meta itemprop="keywords" content="前端,JavaScript,面试"/> <meta itemprop="datePublished" content="2025-12-16T10:55:02.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="前端一小卒"/> <meta itemprop="url" content="https://juejin.cn/user/1943592286564045"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            一个看似“送分”的需求为何翻车？——前端状态机实战指南
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1943592286564045/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    前端一小卒
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-16T10:55:02.000Z" title="Tue Dec 16 2025 10:55:02 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-16
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读9分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>源码太枯燥？一个人啃不动？关注公众号-「前端小卒」，让我做你的源码领读人。这里没有晦涩的说教，只有清晰的 <strong>Vue 3 &amp; React 19</strong> 源码拆解。积跬步以至千里，<strong>小卒也能进阶为大将</strong>，我们一起过河！♟️</p>
</blockquote>
<p>故事的开始总是惊人的相似。</p>
<p>上个月，需求评审会上，收到了产品经理的一个需求：“做一个扫码支付弹窗。逻辑很简单：打开弹窗获取二维码，然后每隔 2 秒轮询一次接口，扫码成功就跳转，30 秒超时就让用户刷新”</p>
<p>一拍脑袋，凭经验判断，需求不难。作为一名熟练的“React工程师”，我极其自信地敲下代码，开始写需求代码。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> [isLoading, setIsLoading] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>); <span class="hljs-comment">// 加载二维码中</span>
<span class="hljs-keyword">const</span> [isPolling, setIsPolling] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>); <span class="hljs-comment">// 轮询接口中</span>
<span class="hljs-keyword">const</span> [isError, setIsError] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);     <span class="hljs-comment">// 出错了</span>
<span class="hljs-keyword">const</span> [retryCount, setRetryCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);   <span class="hljs-comment">// 重试次数</span>
<span class="hljs-comment">// ...后面还有一堆 useEffect 和 useRef 用来存定时器ID</span>
</code></pre>
<p>当时的我还未意识到，这几个state给我带来了好几个bug单。</p>
<h2 data-id="heading-0">隐形的“状态爆炸”</h2>
<p>正式提测之后，我就陆陆续续收到了好几个bug单。</p>
<p>“大佬，我就在网络卡顿的时候多点了几下‘刷新’，页面就乱了”</p>
<p>浏览器的Network 面板上，几十个轮询请求在并发执行。UI 界面上，“正在加载”的转圈动画和“网络错误”的红字提示竟然同时存在，甚至还能点击“重试”按钮！！！</p>
<p>按照我的逻辑，<code>isLoading</code> 为 <code>true</code> 时，<code>isError</code> 肯定得是 <code>false</code> 啊。我明明写了 <code>setLoading(true); setError(false)</code>，为啥会出现这种问题！</p>
<p><strong>为什么会失控？</strong></p>
<p>问题的根源就在于试图用线性的逻辑，去对抗非线性的现实。</p>
<p>当 <code>isLoading</code>、<code>isPolling</code>、<code>isError</code> 三个布尔值混在一起时，理论上它们能组合出 2^3=8 种状态。而在真实的业务逻辑中，合法的状态可能只有 3 种（加载中、轮询中、失败）。那么<strong>剩下的那 5 种“不可能存在的状态”，一不小心没处理就会存在大量的缺陷。</strong></p>
<p>我们花费 80% 的时间，不是在写业务，而是在写防御代码，去堵那些因为逻辑漏洞而产生的混沌状态。</p>
<p>面对那坨膨胀且脆弱的代码，再进行修修补补已经无济于事，必须要大刀阔斧式的推倒重来，和PM和运营沟通，需求进行延期，代码打回去重写。</p>
<p>解决此类问题的最佳方案，不是更高超的 <code>if-else</code> 技巧，而是一个经典的数学模型——<strong>有限状态机</strong> 。它的核心理念是：<strong>系统在任何时刻只能处于一种状态，且状态的流转是确定的。</strong></p>
<h2 data-id="heading-1">引入有限状态机 (FSM)</h2>
<h3 data-id="heading-2">绘制状态流转图</h3>
<p>在写代码之前，我先画了一张图。这才是逻辑的核心：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d1a5e676a636492fa064b0e5d1417ea8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YmN56uv5LiA5bCP5Y2S:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766487301&amp;x-signature=bhvOGCRnUe0UJ6YFfe0nvs14GVQ%3D" alt="svgviewer-png-output (52).png" loading="lazy"/></p>
<p>流程图清晰的展示出来：</p>
<ul>
<li>只有在 <code>FAILURE</code> 或 <code>IDLE</code> 状态下，才允许发起 <code>FETCH</code>。</li>
<li>在 <code>LOADING</code> 状态下，无论用户怎么点击，都不会触发多余的请求。</li>
</ul>
<h3 data-id="heading-3">引入useReducer</h3>
<p>React 的 <code>useReducer</code> 是实现状态机的绝佳工具，通过它可以将状态管理收敛到一个纯函数中。</p>
<p><strong>定义状态与事件</strong></p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// 状态枚举，只有这五种状态</span>
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">STATES</span> = {
  <span class="hljs-attr">IDLE</span>: <span class="hljs-string">'idle'</span>,
  <span class="hljs-attr">LOADING</span>: <span class="hljs-string">'loading'</span>,
  <span class="hljs-attr">POLLING</span>: <span class="hljs-string">'polling'</span>,
  <span class="hljs-attr">SUCCESS</span>: <span class="hljs-string">'success'</span>,
  <span class="hljs-attr">FAILURE</span>: <span class="hljs-string">'failure'</span>,
};

<span class="hljs-comment">// 事件枚举：用户或系统能做的动作</span>
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">EVENTS</span> = {
  <span class="hljs-attr">FETCH</span>: <span class="hljs-string">'FETCH'</span>,      <span class="hljs-comment">// 触发获取</span>
  <span class="hljs-attr">RESOLVE</span>: <span class="hljs-string">'RESOLVE'</span>,  <span class="hljs-comment">// 成功拿到二维码</span>
  <span class="hljs-attr">REJECT</span>: <span class="hljs-string">'REJECT'</span>,    <span class="hljs-comment">// 失败</span>
  <span class="hljs-attr">DONE</span>: <span class="hljs-string">'DONE'</span>,        <span class="hljs-comment">// 支付完成</span>
  <span class="hljs-attr">TIMEOUT</span>: <span class="hljs-string">'TIMEOUT'</span>,  <span class="hljs-comment">// 超时</span>
};
</code></pre>
<p><strong>编写 Reducer</strong></p>
<p>这里使用双重 Switch 结构：先判断<strong>当前处于什么状态</strong>，再判断<strong>发生了什么事件</strong>。</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-keyword">const</span> machineReducer = (state, event) =&gt; {
  <span class="hljs-keyword">switch</span> (state.status) {
    <span class="hljs-keyword">case</span> STATES.IDLE:
    <span class="hljs-keyword">case</span> STATES.FAILURE:
      <span class="hljs-comment">// 只有在空闲或失败时，才允许发起 FETCH</span>
      <span class="hljs-keyword">if</span> (event.<span class="hljs-keyword">type</span> === EVENTS.FETCH) {
        <span class="hljs-keyword">return</span> { ...state, status: STATES.LOADING, <span class="hljs-type">error</span>: null };
      }
      <span class="hljs-keyword">return</span> state; <span class="hljs-comment">// 其他事件直接忽略！</span>

    <span class="hljs-keyword">case</span> STATES.LOADING:
      <span class="hljs-keyword">if</span> (event.<span class="hljs-keyword">type</span> === EVENTS.RESOLVE) {
        <span class="hljs-keyword">return</span> { ...state, status: STATES.POLLING, qrCode: event.data };
      }
      <span class="hljs-keyword">if</span> (event.<span class="hljs-keyword">type</span> === EVENTS.REJECT) {
        <span class="hljs-keyword">return</span> { ...state, status: STATES.FAILURE, <span class="hljs-type">error</span>: event.<span class="hljs-type">error</span> };
      }
      <span class="hljs-comment">// 🔥 重点：这里没有处理 'FETCH' 事件。</span>
      <span class="hljs-comment">// 这意味着：在 Loading 状态下，无论用户怎么狂点按钮，代码都不会有任何反应！</span>
      <span class="hljs-keyword">return</span> state;

    <span class="hljs-keyword">case</span> STATES.POLLING:
      <span class="hljs-keyword">if</span> (event.<span class="hljs-keyword">type</span> === EVENTS.DONE) <span class="hljs-keyword">return</span> { ...state, status: STATES.SUCCESS };
      <span class="hljs-keyword">if</span> (event.<span class="hljs-keyword">type</span> === EVENTS.TIMEOUT) <span class="hljs-keyword">return</span> { ...state, status: STATES.FAILURE, <span class="hljs-type">error</span>: <span class="hljs-string">'超时'</span> };
      <span class="hljs-keyword">return</span> state;

    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">return</span> state;
  }
};
</code></pre>
<p><strong>组件层调用（分离副作用）</strong></p>
<p>现在，组件层的代码变得异常清爽。我们只需要根据状态去渲染 UI，并利用 <code>useEffect</code> 处理轮询副作用。</p>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">PaymentModal</span> = () =&gt; {
  const <span class="hljs-section">[state, dispatch]</span> = useReducer(machineReducer, { status: STATES.IDLE })<span class="hljs-comment">;</span>

  // 业务动作：只负责派发意图，不负责判断逻辑
  const <span class="hljs-attr">handleFetch</span> = () =&gt; {
    dispatch({ type: EVENTS.FETCH })<span class="hljs-comment">;</span>
    api.getQrCode()
      .then(<span class="hljs-attr">data</span> =&gt; dispatch({ type: EVENTS.RESOLVE, data }))
      .catch(<span class="hljs-attr">err</span> =&gt; dispatch({ type: EVENTS.REJECT, error: err }))<span class="hljs-comment">;</span>
  }<span class="hljs-comment">;</span>

  // 副作用管理：由状态驱动轮询
  useEffect(() =&gt; {
    let <span class="hljs-attr">timer</span> = null<span class="hljs-comment">;</span>
    if (<span class="hljs-attr">state.status</span> === STATES.POLLING) {
      <span class="hljs-attr">timer</span> = setInterval(async () =&gt; {
        const <span class="hljs-attr">res</span> = await api.checkStatus()<span class="hljs-comment">;</span>
        if (res.success) dispatch({ type: EVENTS.DONE })<span class="hljs-comment">;</span>
      }, 2000)<span class="hljs-comment">;</span>
    }
    return () =&gt; clearInterval(timer)<span class="hljs-comment">;</span>
  }, <span class="hljs-section">[state.status]</span>)<span class="hljs-comment">; // 状态变了，副作用自动清理或重启</span>

  return (
    &lt;div&gt;
      {<span class="hljs-attr">state.status</span> === STATES.LOADING &amp;&amp; &lt;Spinner /&gt;}
      {<span class="hljs-attr">state.status</span> === STATES.POLLING &amp;&amp; &lt;QRCode img={state.qrCode} /&gt;}
      {<span class="hljs-attr">state.status</span> === STATES.FAILURE &amp;&amp; &lt;ErrorView <span class="hljs-literal">on</span>Retry={handleFetch} /&gt;}
      {<span class="hljs-attr">state.status</span> === STATES.SUCCESS &amp;&amp; &lt;SuccessView /&gt;}
    &lt;/div&gt;
  )<span class="hljs-comment">;</span>
}<span class="hljs-comment">;</span>
</code></pre>
<p>看懂了吗？我们不再修补漏洞，通过清晰的定义状态和触发事件，收敛业务代码复杂度，消除可能产生的bug。</p>
<hr/>
<h2 data-id="heading-4">深度解析状态机</h2>
<p>写到这里，可能很多同学会问： <strong>“这不就是 Switch-Case 吗？为什么要叫它状态机？”</strong> 我们需要把视角拉高，从理论层面彻底理解它，以便应对更复杂的场景。</p>
<h3 data-id="heading-5">什么是有限状态机</h3>
<p>有限状态机不是一种代码写法，而是一个数学模型。它由五个要素组成：</p>
<ul>
<li><strong>有限的状态</strong> ：比如红绿灯只有红、黄、绿，不可能出现“红绿”。</li>
<li><strong>有限的事件</strong> ：比如“倒计时结束”、“按下按钮”。</li>
<li><strong>转换规则</strong> ：即 <code>状态 A + 事件 B -&gt; 状态 C</code>。</li>
<li><strong>初始状态</strong> 。</li>
<li><strong>最终状态</strong> 。</li>
</ul>
<p>它的核心理念就是：<strong>系统在任何时刻只能处于一种状态，且状态的流转是确定的。</strong></p>
<h3 data-id="heading-6">为什么前端需要它</h3>
<p>前端早已不是“展示页面”那么简单了，我们是在浏览器里跑 APP。以下场景如果不以状态机思维去写，迟早会崩：</p>
<ul>
<li><strong>多媒体播放器</strong>： 你以为只有 <code>Play</code> 和 <code>Pause</code>？错。 还有 <code>Buffering</code>（缓冲中）、<code>Seeking</code>（拖拽进度条中）、<code>Ended</code>（播放结束）、<code>Error</code>（加载失败）这些场景。</li>
<li><strong>复杂的表单向导</strong> ： 第一步 -&gt; 第二步 -&gt; 第三步。 用户在第二步点了“上一步”，数据怎么存？在第三步提交失败了，退回哪一步？</li>
<li><strong>TCP/WebSocket 连接管理</strong>： <code>Connecting</code> -&gt; <code>Connected</code> -&gt; <code>Reconnecting</code> -&gt; <code>Disconnected</code>。 如果在 <code>Reconnecting</code> 期间用户手动点了“断开”，应该去哪？</li>
<li><strong>Canvas 游戏/交互可视化</strong>： 拖拽模式、绘图模式、选中模式。</li>
</ul>
<p>读到这里，你可能已经热血沸腾，准备把项目里的所有组件都重写一遍。</p>
<p><strong>且慢。</strong></p>
<p>软件工程的核心在于权衡，如果需求仅仅是控制一个模态框的显示与隐藏，引入状态机只会增加无谓的代码复杂度。</p>
<p>那么，在实际业务开发中，我们应该依据哪些标准来判定是否需要引入状态机？当你的组件出现以下三种特征之一时，就可以结合业务适当的考虑重构了。</p>
<h3 data-id="heading-7">存在多个需要“手动同步”的boolean变量</h3>
<p>这是最显著的信号。检查一下你的组件 State 定义，如果出现了两个及以上的boolean，且彼此之间存在逻辑关联，就需要警惕，<strong>当你需要维护多个布尔值变量的同步关系时，状态机是更优解</strong>。</p>
<p>例如：</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// 典型的高风险代码</span>
const <span class="hljs-selector-attr">[isLoading, setLoading]</span> = <span class="hljs-built_in">useState</span>(false);
const <span class="hljs-selector-attr">[isError, setError]</span> = <span class="hljs-built_in">useState</span>(false);
const <span class="hljs-selector-attr">[hasData, setHasData]</span> = <span class="hljs-built_in">useState</span>(false);
</code></pre>
<p>在这种结构下，开发者需要时刻警惕变量间的同步问题。比如在 <code>setLoading(true)</code> 时，必须记得同时重置 <code>setError(false)</code>。这种依赖“人为细心”来维护的代码，随着迭代周期的拉长，几乎必然会产生 Bug。</p>
<h3 data-id="heading-8">业务逻辑要求状态必须“互斥”</h3>
<p>在很多场景下，业务状态在逻辑上是完全排他的。</p>
<p>比如开头的“扫码轮询”场景：一个请求不可能既在“进行中”又“已失败”。然而，如果使用分散的布尔值控制，代码层面是允许 <code>{ isLoading: true, isError: true }</code> 这种非法组合存在的。</p>
<p>这种逻辑上的“排他性”如果不能在代码结构上得到强制保证，就会导致 UI 渲染出错（例如 Loading 动画和错误提示重叠显示）。所以如果UI展示依赖于严格互斥的状态（如 Promise 的 Pending/Resolved/Rejected），请尽可能的使用状态机强制约束。</p>
<h3 data-id="heading-9">状态流转路径有严格限制</h3>
<p>简单的业务状态流转是自由的，而复杂的业务往往是有向图。</p>
<p>以“退款流程”为例：</p>
<ul>
<li>✅ 合法路径：<code>申请中</code> -&gt; <code>审核通过</code> -&gt; <code>打款中</code></li>
<li>❌ 非法路径：<code>申请中</code> -&gt; <code>打款中</code>（跳过审核）</li>
</ul>
<p>如果使用传统的 <code>if-else</code> 来防御非法跳转，代码中会充斥着大量 <code>if (status === 'AUDIT_PASS')</code> 这样的防御性判断。而状态机可以通过配置 <code>transitions</code>，天然地禁止了所有未定义的跳转路径。</p>
<p>所以当业务逻辑不仅仅关乎“当前是什么状态”，更关乎“当前状态允许变更为哪些状态”时，可以考虑引入状态机。</p>
<h3 data-id="heading-10">技术选型对照表</h3>
<p>在开始写代码前，可以参考下表进行决策：</p>

























<table><thead><tr><th><strong>业务场景特征</strong></th><th><strong>推荐方案</strong></th></tr></thead><tbody><tr><td>简单的开/关状态 (Toggle)</td><td><code>useState(boolean)</code></td></tr><tr><td>简单的互斥状态 (Loading/Success/Error)</td><td>字符串枚举 (String Enum)</td></tr><tr><td><strong>状态复杂，且存在特定的流转规则</strong></td><td><strong>状态机 (Reducer / XState)</strong></td></tr><tr><td><strong>涉及定时器、重试、取消等异步竞态问题</strong></td><td><strong>状态机 (推荐)</strong></td></tr></tbody></table>
<p>记住，工具是为了解决复杂度而生的。简单留给 <code>useState</code>，复杂留给状态机。</p>
<h2 data-id="heading-11">限制即自由</h2>
<p>写烂代码的本质，往往是我们试图在混乱中保留过多的“自由度”。而优秀架构的本质，通常在于<strong>限制</strong>。正如那句话说的：「<strong>喜欢就会放肆，但爱就是克制</strong>」</p>
<p>状态机严格规定了什么状态下能做什么事，这种克制提高了我们的前端稳定性。</p>
<p><strong>最后送给所有的前端的一句话：</strong></p>
<blockquote>
<p>所有的 Bug，本质上都是 <strong>“非法的状态”或“错误的转换”</strong>。</p>
<p>TypeScript 帮我们在编译时静态地规避了非法类型，而状态机则帮我们在运行时动态地管理状态流转。</p>
<p>TypeScript + State Machine = 前端逻辑的绝对防御。</p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Q CLI助力合合信息实现Aurora的升级运营]]></title>    <link>https://juejin.cn/post/7584289165753614390</link>    <guid>https://juejin.cn/post/7584289165753614390</guid>    <pubDate>2025-12-16T11:01:23.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584289165753614390" data-draft-id="7583898823920926762" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Q CLI助力合合信息实现Aurora的升级运营"/> <meta itemprop="keywords" content="人工智能"/> <meta itemprop="datePublished" content="2025-12-16T11:01:23.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="亚马逊云开发者"/> <meta itemprop="url" content="https://juejin.cn/user/2850395271209496"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Q CLI助力合合信息实现Aurora的升级运营
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2850395271209496/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    亚马逊云开发者
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-16T11:01:23.000Z" title="Tue Dec 16 2025 11:01:23 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-16
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读23分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f51e1e53d92e492cb369495a99b9628c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqa6ams6YCK5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766487683&amp;x-signature=jxq%2Bp0lx3qR04HutCyBZceMdcE4%3D" alt="image.png" loading="lazy"/></p>
<h2 data-id="heading-0">1. 升级背景</h2>
<p>合合信息是一家中国领先的人工智能(AI)产品公司，一直致力于通过AI技术赋能创新，为全球数亿用户和多元化行业提供产品服务。凭借超过18年的AI研究和应用专业知识，合合信息已成为全球多模态大模型文本智能技术的领先者，并自主研发推出了一系列产品，包括扫描全能王、名片全能王、启信宝、TextIn和Chaterm，公司业务遍及全球200多个国家和地区。</p>
<p>目前合合信息在海外区域有多套Aurora MySQL实例运行在3.x版本，计算节点的配置为r6g。我们期望与亚马逊云科技合作达成以下目标：</p>
<h3 data-id="heading-1">1.1借助Graviton4机型提升Aurora集群性价比</h3>
<p>众所周知，Graviton芯片的算力和性价比是相当出众的，曾有Blog提到次新一代Graviton3与高于Graviton3一代的Intel r7i机型相比，在.net的测试场景中有23～32%的性能提升，但价格却更便宜(可参考<a href="https://link.juejin.cn?target=https%3A%2F%2Faws.amazon.com%2Fblogs%2Fdotnet%2Fpowering-net-8-with-aws-graviton3-benchmarks%2F" target="_blank" title="https://aws.amazon.com/blogs/dotnet/powering-net-8-with-aws-graviton3-benchmarks/" ref="nofollow noopener noreferrer">Blog</a>)。在本次实验当中合合信息将在Aurora服务上验证最新的Graviton4的性能收益，也希望通过引入G4机型到Aurora服务中来提升当前数据库集群的处理能力，享受到最新Graviton4芯片所带来的大幅度性价比提升。</p>
<h3 data-id="heading-2">1.2借助Aurora 3.10 LTS版本获得更长的生命周期</h3>
<p>Aurora MySQL 3.10版本在2025年8月份发布，这一版本与普通的发布版本仅支持1年不同，LTS 3.10版本将提供近3年的支持时间，即到2028年。用户可以保持在LTS版本3年以避免每年一次的升级工作，同时因为升级切换带来的业务影响也被减少到最低。</p>
<h3 data-id="heading-3">1.3借助Q CLI加速技术验证，支撑Aurora演进</h3>
<p>在生产迁移前需要对Graviton4做性能验证，同时需要对节点切换的影响做深入的分析，最小化切换对应用访问的影响，但这些工作往往是需要繁杂的环境搭建和工具设计才能完成，本次合合信息的测试验证当中就大量使用了Q CLI来加速技术验证，甚至形成多维度的分析报告。让我们在接下来的章节里展示如何使用Q CLI来加速合合信息在Aurora + Graviton4上的技术验证。</p>
<blockquote>
<p>📢限时插播：Amazon Q Developer 来帮你做应用啦！
🌟10分钟帮你构建智能番茄钟应用，1小时搞定新功能拓展、测试优化、文档注程和部署
⏩快快点击进入《<a href="https://link.juejin.cn?target=https%3A%2F%2Fevents.amazoncloud.cn%2Flabs%2Fcloudlab-amazon-q-cli-and-ide-build%3Fvisitfrom%3D3P_SFhead_1216%26sc_medium%3Downed%26sc_campaign%3Dcloudlab%26sc_channel%3D3P_SFhead_1216" target="_blank" title="https://events.amazoncloud.cn/labs/cloudlab-amazon-q-cli-and-ide-build?visitfrom=3P_SFhead_1216&amp;sc_medium=owned&amp;sc_campaign=cloudlab&amp;sc_channel=3P_SFhead_1216" ref="nofollow noopener noreferrer">Agentic Al 帮你做应用 -- 从0到1打造自己的智能番茄钟</a>》实验
免费体验企业级 AI 开发工具的真实效果吧
构建无限，探索启程!</p>
</blockquote>
<h2 data-id="heading-4">2. Aurora升级的版本选择</h2>
<p>在本次技术验证当中，我们需要对Aurora的版本信息，支持时间，以及引擎与R7g/R8g的兼容信息做整理。如果使用人工，这将是非常耗时，且容易出错的，但当我们配置亚马逊云科技官方的aws-knowledge-mcp-server，就可以比较方便的生成相关的版本信息。</p>
<h3 data-id="heading-5">2.1 Aurora R8g/R7g与版本选择建议</h3>
<p>当前最新的Aurora mysql 版本是3.10.1，当前LTS版本是3.10，推荐生产系统使用3.10.1版本。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c709cb1705e54a19b1451fd7a0e2ff1d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqa6ams6YCK5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766487683&amp;x-signature=1yBWzdLTY%2FyX%2BgbrnjGrzX9a1zg%3D" alt="1.webp" loading="lazy"/></p>
<p>对于Aurora MySQL引擎推荐使用3.10.0 (LTS)，获得近3年的支持周期。更长的周期意味着更少的运维工作，同时也能避免强制升级带来的业务影响。</p>
<h3 data-id="heading-6">2.2 Aurora R8g机型按需/预留实例的可用性</h3>
<p>结合Q CLI的MCP功能，借助于Amazon Pricing API完成R8g OD/RI在各区域的覆盖情况确认，并借助于aws-knowledge-mcp-server补充相应的发布时间信息。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5509ebd117c14feaaf9f1c8dec38f443~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqa6ams6YCK5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766487683&amp;x-signature=en4lLSTCUo7SkmGDpAq%2BGjZFtIE%3D" alt="2.webp" loading="lazy"/></p>
<h3 data-id="heading-7">2.3 Q CLI辅助完成版本调研</h3>
<p>可以参考以下提示词完成相关内容的生成：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ef89ea14ebdb4f1b93281c927e15c572~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqa6ams6YCK5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766487683&amp;x-signature=oD%2B78PwPZKonMlkDWJwRE69q6ds%3D" alt="3.webp" loading="lazy"/></p>
<pre><code class="hljs language-markdown" lang="markdown">Plain Text
我需要对Aurora和版本和r7g/r8g的兼容性做分析，以下是分析要求：
<span class="hljs-bullet">   -</span> 基于Amazon CLI查询的实时版本兼容性分析，结合aws的在线文档和Blog，What'new资源；
<span class="hljs-bullet">   -</span> 当前可用Aurora版本总览：以表格呈现，包括引擎类型/最新版本/当前LTS版本/R7g最低版本要求/R8g最低版本要求
<span class="hljs-bullet">   -</span> 详细的Aurora MySQL和PostgreSQL版本发布时间线,以表格呈现，包括Aurora版本/发布时间/标准支持结束时间/是否LTS版本/R7g兼容/r8g兼容
<span class="hljs-bullet">   -</span> 如果需要渲染可以使用中国国内源的d3.js；
<span class="hljs-bullet">   -</span> 以html格式呈现，文件名为aurora-graviton-version.html;
</code></pre>
<p>注意：</p>
<p>1.为确保R8g/R7g OD/RI实例可用信息的准确性，这需要aws cli环境支持，profile需要有Pricing API的访问权；</p>
<p>2.需要确保Q CLI配置了这两个MCP Server</p>
<ul>
<li>core-mcp-server：亚马逊云科技相关的语义识别</li>
<li>aws-knowledge-mcp-server：支持streamablehttp</li>
</ul>
<p>参考链接：<a href="https://link.juejin.cn?target=https%3A%2F%2Fawslabs.github.io%2Fmcp%2Fservers%2Faws-knowledge-mcp-server%2F" target="_blank" title="https://awslabs.github.io/mcp/servers/aws-knowledge-mcp-server/" ref="nofollow noopener noreferrer">awslabs.github.io/mcp/servers…</a></p>
<h2 data-id="heading-8">3. Q CLI加速升级前的技术验证</h2>
<p>合合信息在决定将Aurora迁移至最新的Graviton4平台之前，我们对两个维度的信息做了确认，这包括：</p>
<ul>
<li>性能验证场景 – Graviton2/Graviton3/Graviton4的数据库性能做测试；</li>
<li>应用切换验证 – 切换过程应用影响模拟与分析；</li>
</ul>
<p>以下我们将通过Q CLI来加速这些维度的技术验证。</p>
<h3 data-id="heading-9">3.1使用Q CLI加速Aurora的G2/G3/G4机型的性能对比</h3>
<p>想到做一次数据库性能测试，相信大家会想到有这几类工作要做：</p>
<ul>
<li><strong>设计阶段：</strong> 设计并搭建测试环境，包括VPC/子网/安全组，用于测试的堡垒机和Aurora集群；</li>
<li><strong>测试阶段：</strong> 安装sysbench，为ARM架构编译程序，创建测试数据，编写脚本，多次测试；</li>
<li><strong>生成测试报告：</strong> 分析测试数据，用Excel画出表格，以此得出测试结论；</li>
</ul>
<p>但使用了Q CLI之后以上除了实验设计，测试方法，测试报告要求需要明确外，其它工作都可以交给Q CLI来完成。它可以帮我们达成什么样的结果，我们一步步看。</p>
<h4 data-id="heading-10">3.1.1 Q CLI创建的验证环境和验证流程图</h4>
<p><strong>1.</strong> <strong>验证机型选择</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/37265a3f4f8045c1b2d2a2b63458eb5d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqa6ams6YCK5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766487683&amp;x-signature=N7xifgtAfKQzd%2F5gfbZU%2BMesIxQ%3D" alt="4.webp" loading="lazy"/></p>
<p><strong>2.</strong> <strong>验证资源与架构图</strong></p>
<p>借助于Q CLI的xml解析能力，在完成了测试环境搭建之后，它为本次测试环境生成了drawio格式的架构图(字体重叠问题需人工美化)：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7a8eb3eafc18477093e56972c792150b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqa6ams6YCK5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766487683&amp;x-signature=RwYmzLvyCjT2VdY97Qc8tf2lr%2Fo%3D" alt="5.webp" loading="lazy"/></p>
<p><strong>3.</strong> <strong>验证流程概要</strong></p>
<p>对于本次测试需要测试人员与Q CLI紧密协作，因为Q CLI还不具备独立完成测试流程制订的能力，需要融合我们在性能测试的许多方法和经验积累。 以下为Q CLI根据多次的修改补充后完成的测试计划，并且使用drawio格式生成的测试流程图，为了美观总体布局做了少量调整。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e3176fbbb588444c91b0529405a41ba0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqa6ams6YCK5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766487683&amp;x-signature=XOc8uxDBKx%2Bxl87IJVGzZiSC6Gc%3D" alt="6.webp" loading="lazy"/></p>
<h4 data-id="heading-11">3.1.2使用Q CLI完成测试结果分析与报告展示</h4>
<p>Q CLI在本次的技术验证中发挥了重大的作用，尤其是在测试结果的分析和呈现上，可以生成非常美观的测试报告，而这些报告可以作为独立的交付物存档总结。</p>
<p><strong>1.</strong> <strong>性能验证总结</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1582fab0aaeb428ca5bb4d6990b0c758~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqa6ams6YCK5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766487683&amp;x-signature=tZ8IfJEBJhXSzM47q3mjB7UT1yo%3D" alt="7.webp" loading="lazy"/></p>
<p><strong>2.</strong> <strong>测试各项指标情</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cff41fe79461442fa7845ba7f185c9d5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqa6ams6YCK5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766487683&amp;x-signature=QcbgoVxMKz3Aox8iH72f5cujbCw%3D" alt="8.webp" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/68751b69da39429cbcf406ad7a1959f9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqa6ams6YCK5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766487683&amp;x-signature=CIvKF0IQfPlOLhOWurq2S7mUNPE%3D" alt="9.webp" loading="lazy"/></p>
<p><strong>3.</strong> <strong>详细的测试数据与性价比折算</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/833f9cd48daf47788cec067fa08a8791~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqa6ams6YCK5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766487683&amp;x-signature=peOgT%2FihcQ4%2BmYRjnkCvxPQOeGE%3D" alt="10.webp" loading="lazy"/></p>
<p><strong>4.</strong> <strong>验证总结</strong></p>
<p>通过这次性能验证测试，我们可以按每百万TPS每美金的成本来对比不同机型的差异：</p>
<ul>
<li><strong>r8g.2xlarge TPS</strong> <strong>提升113%:</strong>  最新一代处理器，在128线程高并发场景下表现优异，测试结果为27.22百万<strong>TPS/$；</strong></li>
<li><strong>r7g.2xlarge TPS</strong> <strong>提升40%:</strong>  平衡的性能表现，适合大多数工作负载，在128线程下，测试结果为15.55百万<strong>TPS/$；</strong></li>
<li><strong>r6g.2xlarge</strong> <strong>测试基线:</strong>  128线程并发下，测试结果为13.88百万<strong>TPS/$；</strong></li>
</ul>
<p><strong>5.Q CLI</strong> <strong>提示词参考</strong></p>
<p>以下是提示词参考</p>
<pre><code class="hljs language-diff" lang="diff">Bash
我需要完成Aurora 3.10版本和Graviton2/Graviton3/Graviton4实例的性能测试项目，并生成完整的分析报告。
## 环境配置
<span class="hljs-deletion">- 当前环境：macOS，已配置AWS CLI和Python3</span>
<span class="hljs-deletion">- Python环境：source ~/Documents/VSCodeFolder/.venv/bin/activate</span>
<span class="hljs-deletion">- 包管理：使用 uv pip install 安装Python包</span>
<span class="hljs-deletion">- 密钥路径：~/Documents/VSCodeFolder/_aihome/kp-vgn.pem</span>
<span class="hljs-deletion">- 测试区域：us-east-1</span>
## 基础设施要求
<span class="hljs-deletion">- 使用现有VPC（如满足要求）</span>
<span class="hljs-deletion">- 堡垒机：r6a.2xlarge，Amazon Linux 2023，开放22端口</span>
<span class="hljs-deletion">- Aurora集群：3.10版本，3个实例分别为 db.r6g.2xlarge(主), db.r7g.2xlarge, db.r8g.2xlarge</span>
<span class="hljs-deletion">- 安全组：不开放公网，但允许堡垒机访问Aurora（3306端口）</span>
## 软件安装要求（关键改进）
<span class="hljs-deletion">- 堡垒机软件包：</span>
* MySQL客户端：使用 mariadb105 (Amazon Linux 2023兼容)
* sysbench：从源码编译安装，需要先安装Development Tools和mariadb105-devel
* 编译依赖：git, automake, libtool, openssl-devel
<span class="hljs-deletion">- 安装顺序：先安装依赖包 → 编译sysbench → 验证安装</span>
## 测试数据要求
<span class="hljs-deletion">- 使用sysbench oltp_read_write模板</span>
<span class="hljs-deletion">- 8张表，每表200万记录</span>
<span class="hljs-deletion">- 读写比例1:1</span>
<span class="hljs-deletion">- 数据准备时间：约15-20分钟</span>
## 测试执行要求
<span class="hljs-deletion">- 测试线程：32, 64, 128</span>
<span class="hljs-deletion">- 每个测试：预热1分钟 + 测试2分钟 = 共3分钟</span>
<span class="hljs-deletion">- **关键**：每个实例必须通过主备切换作为主节点进行测试（因为sysbench包含写操作）</span>
<span class="hljs-deletion">- 测试顺序：r6g → r7g → r8g</span>
<span class="hljs-deletion">- 切换等待时间：failover后等待60秒稳定，测试间隔30秒</span>
## 定价数据（us-east-1，基于实时查询）
<span class="hljs-deletion">- 按需价格：db.r6g.2xlarge=$1.038/h, db.r7g.2xlarge=$1.106/h, db.r8g.2xlarge=$1.104/h</span>
<span class="hljs-deletion">- 预留实例(1年)：db.r6g.2xlarge=$0.68/h, db.r7g.2xlarge=$0.851/h, db.r8g.2xlarge=$0.74/h</span>
## 报告生成要求（重要更新）
需要生成3个不同类型的报告：
### 1. 性能测试报告
<span class="hljs-deletion">- 使用ECharts（中国国内CDN）进行图表渲染</span>
<span class="hljs-deletion">- 商务风格HTML报告</span>
<span class="hljs-deletion">- 包含：TPS/QPS/延迟P95对比、成本效益分析</span>
<span class="hljs-deletion">- 文件名：aurora_graviton_performance_report.html</span>
### 2. 架构分析报告
<span class="hljs-deletion">- 商务风格HTML报告，包含：</span>
* Aurora版本兼容性详细分析（基于AWS CLI查询）
* 全球区域可用性和定价对比
* LTS版本发布时间线
* 技术规格对比
<span class="hljs-deletion">- 文件名：aurora_graviton_analysis_report.html</span>
### 3. Draw.io架构图（重要新增）
<span class="hljs-deletion">- AWS官方风格架构图，使用标准AWS图标和颜色</span>
<span class="hljs-deletion">- 包含VPC、多AZ、安全组、Aurora集群的完整架构</span>
<span class="hljs-deletion">- 测试流程图，展示7个关键阶段和详细任务分解</span>
<span class="hljs-deletion">- 文件格式：.drawio (可在diagrams.net中打开编辑)</span>
<span class="hljs-deletion">- 文件名：aurora_graviton_architecture.drawio, aurora_graviton_test_process.drawio</span>
</code></pre>
<h3 data-id="heading-12">3.2 Q CLI加速应用切换透视与验证</h3>
<p>Aurora集群在节点切换或蓝绿部署的切换上提供非常好的体验， 从技术上我们也希望借助于Q CLI的能力，帮我们理清楚两个技术问题：</p>
<ul>
<li><strong>读写访问的影响机制：</strong> 在节点切换的整个过程，应用程序会经历哪些阶段，会有怎样的行为表现；</li>
<li><strong>实例切换与DNS切换的时间关系：</strong> DNS切换与实例切换的关系，以及哪些机制将有助于减少切换对业务的影响；</li>
</ul>
<h4 data-id="heading-13">3.2.1测试场景设计</h4>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/deccce4412df47fa912a81c70e41db5f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqa6ams6YCK5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766487683&amp;x-signature=TMz5caAAvs9%2FEnpczMJemqGSZ2c%3D" alt="11.webp" loading="lazy"/></p>
<h4 data-id="heading-14">3.2.2测试的重要指标</h4>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e7feaddb5fdf471f86329a0506851fe7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqa6ams6YCK5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766487683&amp;x-signature=XxFKhtkmvmXcNqeTUZeDYbkoXwo%3D" alt="12.webp" loading="lazy"/></p>
<h4 data-id="heading-15">3.2.3.测试的时间线</h4>
<p>下图是切换过程操作的时间线与3种探针的表现</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a7dcbb667f8b4334b7d1de1722d1d77c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqa6ams6YCK5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766487683&amp;x-signature=NikvaabJXl%2B0Evcv5cSd0w0%2F8fM%3D" alt="13.webp" loading="lazy"/></p>
<h4 data-id="heading-16">3.2.4切换过程与应用行为</h4>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2a5fe5ef9fd548438fcddb45744de64b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqa6ams6YCK5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766487683&amp;x-signature=9GNi9IpwrrdnlXUH3IlNC9QmrbE%3D" alt="14.webp" loading="lazy"/></p>
<p>从上面的表格，在整个切换过程中读写探针和DNS探针所有的性能变化，报错类型，这些都尽收眼底，我们终于比较透彻了解切换过程应用程序的行为表现。</p>
<h4 data-id="heading-17">3.2.5切换测试结论</h4>
<p>通过上面的测试我们可以看出：</p>
<ol>
<li>业务的影响为14s，其中读操作的影响为9s，写操作的影响为14s，这说明如果应用可以有读写分离，在节点切换时将能提供更高的可用性；</li>
<li>在Aurora实例发生切换到DNS的IP映射真实切换之间，对于写操作都是不可用的，这期间的连接尝试也是无效和；</li>
<li>在DNS切换完成后写操作完全恢复正常，这表明DNS切换是应用恢复的唯一标记；</li>
</ol>
<h4 data-id="heading-18">3.2.6应用切换的优化</h4>
<p>既然DNS切换是应用恢复的唯一标记，我们可以通过以下两种方式使应用切换变得更快，更有效率：</p>
<ol>
<li>对于具备DNS检测的应用，它最终会通过DNS解析到新的IP，连接到新的实例；</li>
<li>对于没有DNS检测的应用，在切换发生后，将新的集群IP刷新给这些应用(reload或重启服务)，这些应用也会连接到正确的实例；</li>
<li>使用亚马逊云科技官方的驱动程序或Wrapper插件实现集群拓扑感知，在第一时间获知IP改变，第一时间恢复连接；</li>
</ol>
<p>官方的数据库驱动加速切换的原理，可以参考这篇博客《<a href="https://link.juejin.cn?target=https%3A%2F%2Faws.amazon.com%2Fblogs%2Fdatabase%2Fdemystifying-the-aws-advanced-jdbc-wrapper-plugins%2F" target="_blank" title="https://aws.amazon.com/blogs/database/demystifying-the-aws-advanced-jdbc-wrapper-plugins/" ref="nofollow noopener noreferrer">Demystifying the Amazon advanced JDBC wrapper plugins</a>》</p>
<h4 data-id="heading-19">3.2.7 Q CLI的提示词参考</h4>
<p>切换测试进行过许多次，提示词会根据Q CLI输出的不同根据测试目标做调整，所以这个提示词不是合并所有修改的版本，并且你使用它可能的输出不一定相同，需要结合你的测试环境，测试要求来确定。以下是一个供参考的版本。</p>
<pre><code class="hljs language-diff" lang="diff">Shell
我需要完成Aurora 3.10版本和Graviton2/Graviton4实例的切换测试项目，我会提供测试工具，你熟悉它，并完成测试，最终生成完整的分析报告。以下是测试的详细描述：

## 环境配置
<span class="hljs-deletion">- 当前环境：macOS，已配置AWS CLI和Python3</span>
<span class="hljs-deletion">- Python环境：source ~/Documents/VSCodeFolder/.venv/bin/activate</span>
<span class="hljs-deletion">- 包管理：使用 uv pip install 安装Python包</span>
<span class="hljs-deletion">- 密钥路径：~/Documents/VSCodeFolder/_aihome/kp-vgn.pem</span>
<span class="hljs-deletion">- 测试区域：ap-southeast-1</span>

## 基础设施要求
<span class="hljs-deletion">- 使用现有VPC（如满足要求）</span>
<span class="hljs-deletion">- 堡垒机：r6a.2xlarge，Amazon Linux 2023，开放22端口</span>
<span class="hljs-deletion">- Aurora集群：3.10版本，2个实例分别为 db.r6g.2xlarge(主),  db.r8g.2xlarge</span>
<span class="hljs-deletion">- 安全组：允许堡垒机访问Aurora（3306端口）</span>

## 软件安装要求（关键改进）
<span class="hljs-deletion">- 堡垒机软件包：</span>
  * MySQL客户端：使用 mariadb105 (Amazon Linux 2023兼容)
  * sysbench：从源码编译安装，需要先安装Development Tools和mariadb105-devel
  * 编译依赖：git, automake, libtool, openssl-devel
<span class="hljs-deletion">- 安装顺序：先安装依赖包 → 编译sysbench → 验证安装</span>
<span class="hljs-deletion">- 测试程序：~/Documents/VSCodeFolder/tanzhen目录下</span>
    aurora_failover_monitor_3probes-v2.py - 包括MySQL读/写/DNS检测的3探针验证工具；
    aurora_config.json - 测试的配置信息，包括集群/用户名/密码/超时设置等；
    generate_html_report.py - HTML报告生成工具；
    README.md - 探针工具介绍
    aurora_probe_round2_20250918.jsonl - 之前的测试日志
    aurora_failover_report_round2.html - 之前的分析报告

## 测试执行要求
<span class="hljs-deletion">- 测试并发：使用测试程序模拟200个会话从堡垒机连接到Aurora集群</span>
<span class="hljs-deletion">- 测试方法：在预热30秒之后，发起节点切换，从r6g切换到r8g，程序继续运行1分钟</span>
<span class="hljs-deletion">- 测试评估：根据aurora_failover_monitor_3probes-v2.py的会话信息分析200个会话受影响的情况，包括受影响的时间点，影响的操作，恢复的时间，以及切换过程中会话的异常情况：中断/超时/重连等情况</span>

## 报告输出
1.使用html输出报告，需要Chart渲染请使用中国区的echarts；
2.内容包括：实验设计，环境配置，操作时序图，会话随时间展示受影响的的情况，包括报错/超时/中断/恢复等情况；
3.给出切换对于高并发业务的影响模式描述，消除客户对业务影响的顾虑；
</code></pre>
<h2 data-id="heading-20">4.升级方案选择与升级过程</h2>
<p>借助于上面的技术验证，我们对将生产环境切换到Aurora的Graviton4机型更加有信心了，那么接下来我们要做的就是升级方案的选择，因为我们的Aurora MySQL数据库的主要版本在3.04上，需要升级到Aurora 3.10 LTS版本。</p>
<p>在升级方案的选择上，我们可以用Q CLI生成基本的方案建议，但同时我们需要考虑到目前的生产实况，把不常用的方案剔除，接下来我们将从多个维度对比3套升级方案：</p>
<h3 data-id="heading-21">4.1升级方案选择</h3>
<h4 data-id="heading-22">4.1.1方案1 – 蓝绿部署(推荐)</h4>
<p><strong>建议方式： 对于升级支持，Aurora提供了蓝绿部署，它将自动创建绿环境(目标环境)，并自动同步数据修改，最终按照指令完成DNS指向的切换。。</strong></p>
<p>以下是切换的核心代码，供参考：</p>
<pre><code class="hljs language-arduino" lang="arduino">Shell
<span class="hljs-number">1.</span> 创建蓝绿部署
aws rds create-blue-green-deployment \
  --blue-green-deployment-name <span class="hljs-string">"aurora-upgrade"</span> \
  --source <span class="hljs-string">"arn:aws:rds:region:account:cluster:source-cluster"</span> \
  --target-engine-version <span class="hljs-string">"8.0.mysql_aurora.3.10.0"</span>

<span class="hljs-number">2.</span> 升级绿环境实例到R8g
aws rds modify-db-instance \
  --db-instance-identifier <span class="hljs-string">"green-instance-id"</span> \
  --db-instance-<span class="hljs-keyword">class</span> <span class="hljs-string">"db.r8g.xlarge"</span>

<span class="hljs-number">3.</span> 执行切换
aws rds switchover-blue-green-deployment \
  --blue-green-deployment-identifier <span class="hljs-string">"deployment-id"</span>
</code></pre>
<h4 data-id="heading-23">4.1.2方案2 – 原地升级</h4>
<p><strong>直接在原集群上串行执行版本升级和硬件升级，读写业务会受影响，升级后无法回退。</strong></p>
<p>以下是原地升级的核心代码，供参考：</p>
<pre><code class="hljs language-css" lang="css">Shell
<span class="hljs-number">1</span>. 升级引擎版本
aws rds modify-db-cluster \
  <span class="hljs-attr">--db-cluster-identifier</span> "cluster-name" \
  <span class="hljs-attr">--engine-version</span> "<span class="hljs-number">8.0</span><span class="hljs-selector-class">.mysql_aurora</span>.<span class="hljs-number">3.10</span>.<span class="hljs-number">0</span>" \
  <span class="hljs-attr">--apply-immediately</span>

<span class="hljs-number">2</span>. 升级实例类型
aws rds modify-db-instance \
  <span class="hljs-attr">--db-instance-identifier</span> "instance-name" \
  <span class="hljs-attr">--db-instance-class</span> "db<span class="hljs-selector-class">.r8g</span><span class="hljs-selector-class">.xlarge</span>" \
  <span class="hljs-attr">--apply-immediately</span>
</code></pre>
<h4 data-id="heading-24">4.1.3方案3 – 读复本提升</h4>
<p><strong>创建跨区域读副本集群(新版本+新硬件)，提升为独立集群后手动切换应用连接。该特性目前只在3.10上支持。</strong></p>
<p>以下是读复本提升的核心代码，供参考：</p>
<pre><code class="hljs language-lua" lang="lua">Shell
<span class="hljs-number">1.</span> 创建跨区域读副本(新版本)
aws rds <span class="hljs-built_in">create</span>-db-cluster \
  <span class="hljs-comment">--db-cluster-identifier "replica-cluster" \</span>
  <span class="hljs-comment">--engine-version "8.0.mysql_aurora.3.10.0" \</span>
  <span class="hljs-comment">--replication-source-identifier "source-cluster-arn"</span>

<span class="hljs-number">2.</span> 添加R8g实例
aws rds <span class="hljs-built_in">create</span>-db-instance \
  <span class="hljs-comment">--db-cluster-identifier "replica-cluster" \</span>
  <span class="hljs-comment">--db-instance-class "db.r8g.xlarge"</span>

<span class="hljs-number">3.</span> 提升为独立集群
aws rds promote-<span class="hljs-built_in">read</span>-replica-db-cluster \
  <span class="hljs-comment">--db-cluster-identifier "replica-cluster"</span>
</code></pre>
<h4 data-id="heading-25">4.1.4三种方案的对比</h4>
<p>借助于Q CLI我们可以对三种典型的升级方案进行多维度的对比，对比维度包括停机时间/数据安全/回滚能力，以及适用的应用场景等：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6f919c7f1ac5478db0440d4dab43108a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqa6ams6YCK5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766487683&amp;x-signature=PDDaF9CsJ4waIBM1PJOGnwjv2UQ%3D" alt="15.webp" loading="lazy"/></p>
<p>根据目前我们过去的生产实践，结合业务停机时间要求，我们将选择蓝绿部署来实现数据库的升级和切换。</p>
<h3 data-id="heading-26">4.2应用切换方案</h3>
<p>借助于上面的技术验证结论，应用程序在实例切换时恢复的速度和DNS的变化感知有直接关系，我们对现有的应用进行梳理后，将应用分为两类场景：如果一个应用具备主动的DNS变化检测能力，它在连接重建上将是最有效的。如果应用不具备这样的检测能力，我们就可以结合手工reload配置文件的方式实现应用的快速切换。</p>
<p>根据这个因素我们将生产的业务分为两类场景：</p>
<ul>
<li>场景1 – 以golang为客户端的数据库中间层，具备DNS变化检测能力</li>
<li>场景2 – 以ngx+lua为客户端的业务中间层，不具备DNS变化检测能力</li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ac11be3750624188836d3dc9f7ccc6ee~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqa6ams6YCK5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766487683&amp;x-signature=mCYvOIO2VniFEOZN5SbXseoRJ%2FM%3D" alt="16.webp" loading="lazy"/></p>
<p>根据我们的生产实践，这样的区分应用场景的切换虽然稍稍增加运维工作量，但它可以让应用程序在10s之内快速的恢复，这样的切换效率是相当高的。</p>
<h4 data-id="heading-27">4.2.1场景1 – 以golang为客户端的数据库中间层</h4>
<p>能自主识别RDS域名后端IP地址变动，该场景下，在蓝绿切换后，客户端会立即将90%到100%的连接切换到绿实例，在域名稳定后(约30秒)，reload客户端，完成剩余连接切换。</p>
<h4 data-id="heading-28">4.2.2场景2 – 以ngx+lua为客户端的业务中间层</h4>
<p>不能自主识别RDS域名后端IP地址变动，需要提前解析ip，然后在配置中心更新ip，在蓝绿切换后，完成一致性校验，蓝只读，绿可写，约5秒内，reload ngx，实现快速切换。</p>
<h3 data-id="heading-29">4.3 完整的升级过程</h3>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f1f3adb2e71e407c8b6bf62f648bb396~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqa6ams6YCK5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766487683&amp;x-signature=m6XobEAhi%2F2nlun05BGFr054v44%3D" alt="17.webp" loading="lazy"/></p>
<p>结合我们对切换过程最佳实践的了解，可以使用Q CLI对整个升级过程做梳理，把相关工作按阶段划分，可以为我们生成清晰的drawio格式的升级与切换过程的展示。</p>
<p>在技术验证和方案整理上，Q CLI是非常得力的助力，可以为我们提升数倍的工作效率。在生产集群的升级切换阶段，我们为了最大程度的过程可控性，仍然使用Console方式来实现集群的升级和切换。</p>
<h4 data-id="heading-30">4.3.1开启Binlog</h4>
<p>如果在初次使用蓝绿部署，因为Binlog为静态参数，设置这个参数需要实例重启，请注意。</p>
<h4 data-id="heading-31">4.3.2创建蓝绿部署</h4>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c184cc4dcb80432db13dcd0c1d0f0468~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqa6ams6YCK5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766487683&amp;x-signature=HCuBXPd8KxWwMEPXiYviAIez6sI%3D" alt="18.webp" loading="lazy"/></p>
<h4 data-id="heading-32">4.3.3确认并创建</h4>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/62814ca1e9e14aefbaabd289221bad09~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqa6ams6YCK5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766487683&amp;x-signature=kBqFVWp8m7vpTJL0FRhsceyIuC8%3D" alt="19.webp" loading="lazy"/></p>
<h4 data-id="heading-33">4.3.4创建完成</h4>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0be9dd194c5641e39a2772846b07836a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqa6ams6YCK5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766487683&amp;x-signature=flwchQP23F2%2BfXcPSfcvyKMKqbM%3D" alt="20.webp" loading="lazy"/></p>
<h4 data-id="heading-34">4.3.5修改绿实例类型</h4>
<p>绿环境创建后，手动停止复制(CALL mysql.rds_stop_replication; show slave status\G)，记录复制位置信息，单独修改实例类型:</p>
<pre><code class="hljs language-scss" lang="scss">Plain Text
aws rds modify-db-instance \
<span class="hljs-attr">--db-instance-identifier</span> "green-cluster-instance-name" \
<span class="hljs-attr">--db-instance-class</span> "db<span class="hljs-selector-class">.r8g</span><span class="hljs-selector-class">.large</span>" \
<span class="hljs-attr">--apply-immediately</span>
</code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d09b75b7c043471a89363975b279c9b8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqa6ams6YCK5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766487683&amp;x-signature=Phv2ZDTlb2fe%2Be2aF7b0uIoa83g%3D" alt="21.webp" loading="lazy"/></p>
<h4 data-id="heading-35">4.3.6恢复Binlog同步</h4>
<p>实例类型修改成功后，验证复制位置，手动启动复制(show slave status\G; CALL mysql.rds_start_replication;)验证数据同步后，安排窗口执行切换。</p>
<h4 data-id="heading-36">4.3.7蓝绿集群切换</h4>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8fda579b9ee14ba38260447b01b0a671~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqa6ams6YCK5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766487683&amp;x-signature=M1p71jG7xFlxYjN2JkgehlrVoGI%3D" alt="22.webp" loading="lazy"/></p>
<h4 data-id="heading-37">4.3.8执行应用切换</h4>
<p>根据4.2的方案，我们区分不同应用场景完成应用配置的reload，此处需要确认应用操作的正确性。</p>
<h4 data-id="heading-38">4.3.9删除旧集群</h4>
<p>先关闭集群删除保护，使用以下命令或console完成旧集群的删除。</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">SQL</span>
aws rds <span class="hljs-keyword">delete</span><span class="hljs-operator">-</span>db<span class="hljs-operator">-</span>instance \
  <span class="hljs-comment">--db-instance-identifier aurora-test-304-traditional-instance-old1 \</span>
  <span class="hljs-comment">--region us-east-1</span>

aws rds <span class="hljs-keyword">delete</span><span class="hljs-operator">-</span>db<span class="hljs-operator">-</span>cluster \
  <span class="hljs-comment">--db-cluster-identifier aurora-test-304-traditional-old1 \</span>
  <span class="hljs-comment">--region us-east-1 \</span>
  <span class="hljs-comment">--skip-final-snapshot</span>
</code></pre>
<h3 data-id="heading-39">4.4升级过程中的关注点</h3>
<p>我们在生产集群的升级切换当中，在同步环节曾经遇到Relay Log堆积的情况，我们借助于企业服务，在TAM的协助下，快速的定位原因，并实施的优化方案，这使同步延迟快速的解决，确保了应用切换前蓝绿集群可以达到同步状态。</p>
<h4 data-id="heading-40">4.4.1同步延迟的优化</h4>
<ul>
<li>binlog_transaction_dependency_tracking=WRITESET (源库跟目标库都要设置)</li>
</ul>
<p>这个参数可以非常有效和提高复制效能：</p>
<p>a. 更精确地识别事务之间的依赖关系<br/>
b. 允许不相关的事务并行执行<br/>
c. 减少复制延迟<br/>
d. 改善并行复制</p>
<ul>
<li>aurora_binlog_replication_sec_index_parallel_workers=8</li>
</ul>
<p>在Aurora MySQL 3.06及以上版本中，当复制具有多个二级索引的大表事务时，通过该特性引入线程池，在二进制日志副本上并行应用二级索引进行变更，有效提升同步速度</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f2a40633956842cc90f02d9817af7342~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqa6ams6YCK5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766487683&amp;x-signature=UH9rVcgn9ZT%2B7rQXXK5qLfjdxbQ%3D" alt="23.webp" loading="lazy"/></p>
<h4 data-id="heading-41">4.4.2其它参数优化</h4>
<ul>
<li>关闭Aurora 3.10的新特性Memory Relaylog ：aurora_in_memory_relaylog=OFF</li>
</ul>
<p>避免绿实例报错：can’t find relay log</p>
<p>参数的功能描述请参考：<a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.aws.amazon.com%2FAmazonRDS%2Flatest%2FAuroraUserGuide%2Fbinlog-optimization.html" target="_blank" title="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/binlog-optimization.html" ref="nofollow noopener noreferrer">docs.aws.amazon.com/AmazonRDS/l…</a></p>
<h2 data-id="heading-42">5.升级后的运行效果</h2>
<p>我们在9月9号非常顺利的完成了Aurora数据库的切换，从按下来一周的系统负载数据看，CPU负载和事务提交/DML延迟都有近50%的下降，这也和我们之前的技术验证结果完全吻合。</p>
<h3 data-id="heading-43">5.1日间CPU高峰负载下降近一半(47%)</h3>
<p>9月9号0时，我们完成了数据库实例和Aurora 3.10+Graviton4机型的迁移，8号与9号的业务负载模式其实是相同的(为工作日模式，7号为周末模式)，所以从系统的峰值的变化可以得到引入Aurora 3.10+Graviton4带来的负载变化：CPU的日间峰值从8号的50%下降到9号的27%左右，降幅为47%；CPU的凌晨高峰从64%下降到52%，降幅为19%。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f61448da4c1b46f39bfb5d576f83c839~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqa6ams6YCK5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766487683&amp;x-signature=OCBCY9M60a870wCbw73pqBe9AmQ%3D" alt="24.webp" loading="lazy"/></p>
<h3 data-id="heading-44">5.2日间提交/DMLLatency降低50%</h3>
<p>同样的，我们来看事务提交延迟，日间最大提交Latency从8号的5ms下降到2.5ms，下降幅度为50%，凌晨的最大提交Latency从9号的27ms下降到5ms，下降幅度为81%。</p>
<p>对于DML延迟也有相当明显的表现，日间最大DML延迟从8号的2ms下降到1.7ms，下降幅度为30%。凌晨DML延迟从8号的3ms下降到1ms，下降幅度为60%。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/606c453ec24a45c983a081b1cc0e1122~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqa6ams6YCK5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766487683&amp;x-signature=LeR0e3uv9a%2B%2BEt2coRldC9XIFW4%3D" alt="25.webp" loading="lazy"/></p>
<h2 data-id="heading-45">6. 回顾与总结</h2>
<p>作为今年运维工作的重要部分，在过去的2个月，我们完成了对Graviton4的性能验证，生产业务模拟的切换验证，以及Aurora的版本选择和生产环境完成升级，而Q CLI也提供了直接或间接的支持。</p>
<h3 data-id="heading-46">6.1 Aurora 3.10与Graviton4机型的综合表现</h3>
<p>从最终的生产系统的负载信息，我们不难看出Aurora的Graviton4机型的引入相当明显把CPU使用率降低了47%，事务提交和DML延迟也降低了近50%，这意味着Aurora集群在成本没有显著增加的情况下，可以为业务提供近1倍的数据库计算能力。</p>
<p>Aurora 3.10版本为业务提供了比常规版本更长期的支持周期，接近3年，这也意味着更少的停机时间，更少的业务中断和更低的运维成本。</p>
<h3 data-id="heading-47">6.2 TAM与Q CLI在方案落地过程中的价值体现</h3>
<p>在本项目中Amazon Q CLI以出色的架构感知和操控能力，相当大程度上加速了技术验证，版本分析，方案对比等工作：</p>
<ul>
<li><strong>TAM</strong> <strong>有力的支持 –</strong> 在技术验证和生产集群的切换期间，企业服务团队的TAM从前期的技术验证，到后期的切换过程的复制优化，体现了TAM自身扎实的技术能力，并且为客户发声，高效的协调前后端团队，提供了许许多多思路，解决了众多技术疑难问题；</li>
<li><strong>性能与切换场景验证 –</strong> 在测试方案设计，方案补充，以及环境搭建，测试工具生成，测试数据分析与报告整理，Q CLI可以提供非常好的协助，显著缩短测试周期，为生产切换做技术准备，让切换更有信心；</li>
<li><strong>版本分析与建议 –</strong> Q CLI可以更快速的从在线文档、Blog、What’s new、Pricing API等官方资源、途径中提炼、汇总多方面的数据，形成完全适用于合合信息的版本建议，这节省了大量的人工查阅的时间，也提升了准确性；</li>
<li><strong>数据分析与报告生成 –</strong> 我们可以使用Q CLI对多维度的测试数据进行分析，并且在架构图生成，流程图生成，分析报告呈现和渲染，这些工作上Q CLI都为我们大幅度提升了效率，也提升了交付物的质量；</li>
</ul>
<h3 data-id="heading-48">6.3未来探索 – Q CLI在运维场景的应用</h3>
<p>在本项目当中Q CLI 在技术验证上是运维同学得力的助手，提升的效率，我们同时也会在以下运维场景中深度使用这个工具：</p>
<ul>
<li><strong>运维故障诊断 –</strong> 借助于Q CLI对亚马逊云科技资源的理解和强大的知识库支撑，加速运维故障分析与解决；</li>
<li><strong>运维知识库 –</strong> Q CLI提供了与Bedrock KnowledgeBase交互的MCP Server支持，可以将运维信息更充分的在团队内部分享；</li>
<li><strong>运维工具开发 –</strong> Q CLI提供了越来越丰富的代码编写支持，从Todos/Hooks到Issue的管理，降低运维开发门槛；</li>
<li><strong>智能巡检 –</strong> 基于亚马逊云科技后端知识库，可以对生产、开发环境做深度的架构分析，发现更多可优化的技术项，提升运维水平；</li>
</ul>
<p>以上是我们对Q CLI在未来运维价值的展望，相信熟练运用这些工具，会不断提升我们的运维水平、运维效率。</p>
<h2 data-id="heading-49">7.本文提到的技术资料链接</h2>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Flvst-gh%2Fqcli-aurora-graviton4%2F" target="_blank" title="https://github.com/lvst-gh/qcli-aurora-graviton4/" ref="nofollow noopener noreferrer">github.com/lvst-gh/qcl…</a><br/>
*<strong>前述特定亚马逊云科技生成式人工智能相关的服务目前在亚马逊云科技海外区域可用。亚马逊云科技中国区域相关云服务由西云数据和光环新网运营，具体信息以中国区域官网为准。</strong></p>
<p><strong>本篇作者</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9c7437c2f13e405f839259e21bbfc282~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqa6ams6YCK5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766487683&amp;x-signature=iMjFjMrWCh9q%2FASylqpnPu2%2Bvy4%3D" alt="26.webp" loading="lazy"/></p>
<blockquote>
<p>本期最新实验为《<a href="https://link.juejin.cn?target=https%3A%2F%2Fevents.amazoncloud.cn%2Flabs%2Fcloudlab-amazon-q-cli-and-ide-build%3Fvisitfrom%3D3P_Juejintail_1216%26sc_medium%3Downed%26sc_campaign%3Dcloudlab%26sc_channel%3D3P_Juejintail_1216" target="_blank" title="https://events.amazoncloud.cn/labs/cloudlab-amazon-q-cli-and-ide-build?visitfrom=3P_Juejintail_1216&amp;sc_medium=owned&amp;sc_campaign=cloudlab&amp;sc_channel=3P_Juejintail_1216" ref="nofollow noopener noreferrer">Agentic AI 帮你做应用 —— 从0到1打造自己的智能番茄钟</a>》</p>
<p>✨ 自然语言玩转命令行，10分钟帮你构建应用，1小时搞定新功能拓展、测试优化、文档注释和部署</p>
<p>💪 免费体验企业级 AI 开发工具，质量+安全全掌控</p>
<p>⏩️[<a href="https://link.juejin.cn?target=https%3A%2F%2Fevents.amazoncloud.cn%2Flabs%2Fcloudlab-amazon-q-cli-and-ide-build%3Fvisitfrom%3D3P_Juejintail_1216%26sc_medium%3Downed%26sc_campaign%3Dcloudlab%26sc_channel%3D3P_Juejintail_1216" target="_blank" title="https://events.amazoncloud.cn/labs/cloudlab-amazon-q-cli-and-ide-build?visitfrom=3P_Juejintail_1216&amp;sc_medium=owned&amp;sc_campaign=cloudlab&amp;sc_channel=3P_Juejintail_1216" ref="nofollow noopener noreferrer">点击进入实验</a>] 即刻开启  AI 开发之旅
构建无限, 探索启程！</p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[自定义封装 vue多页项目新增项目脚手架]]></title>    <link>https://juejin.cn/post/7584057497206702123</link>    <guid>https://juejin.cn/post/7584057497206702123</guid>    <pubDate>2025-12-16T08:49:27.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584057497206702123" data-draft-id="7584007232411926534" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="自定义封装 vue多页项目新增项目脚手架"/> <meta itemprop="keywords" content="前端,JavaScript,Node.js"/> <meta itemprop="datePublished" content="2025-12-16T08:49:27.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="ximimimi"/> <meta itemprop="url" content="https://juejin.cn/user/3350967174040238"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            自定义封装 vue多页项目新增项目脚手架
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3350967174040238/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    ximimimi
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-16T08:49:27.000Z" title="Tue Dec 16 2025 08:49:27 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-16
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    1
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">背景</h2>
<p>在多页项目中，有时候新建项目需要基于原先的项目拷贝一份，还需要在public上新增html入口，修改vue.config.js配置....这个过程比较繁琐，而且容易漏掉，所以封装了一个自动化的脚手架工具</p>
<h2 data-id="heading-1">使用</h2>
<ul>
<li>
<p>原先方式： 手动增加</p>
<ul>
<li>在src目录下新增项目,main.ts中监听版本号的initVersionUpdateJson传入参数改成新的模块 （注意，这里拷贝整个项目后需要把项目内的引用改一下，比如新建项目是B, 拷贝的是A项目，需要全局将@/views/A/XXX 改成@/views/B/XXXX）</li>
<li>在public目录下新增一个html文件</li>
<li>配置vue.config.js中的pages参数，新增一个item</li>
<li>在首页（<code>src/views/Home/index.vue</code>）添加新入口项</li>
<li>在version.json中增加该项目版本</li>
</ul>
</li>
<li>
<p>现在： 使用自动化工具</p>
<ul>
<li>安装：npm install hcli</li>
<li>使用：hcli create
交互式提示将询问：
<ul>
<li>是否创建新的项目（confirm）</li>
<li>项目名称（name）</li>
<li>在首页显示的标题（title）</li>
<li>选择要复用的模板（model，列举例如 <code>A项目</code>, <code>B项目</code>....）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 data-id="heading-2">如何实现</h2>
<h4 data-id="heading-3">前置知识</h4>
<ul>
<li>node bin 封装插件</li>
<li>node模块（commander /inquirer /fs/ chalk)</li>
</ul>
<h4 data-id="heading-4">实现</h4>
<ul>
<li>
<p>初始化项目npm init -y， 新建bin/hcli.js文件,内容如下
// 在package.json中的配置
{
"name": "hcli",
"version": "1.0.0",
"description": "",
"main": "index.js",
"bin": {
"hcli": "bin/hcli.js"
},
"scripts": {
"publish": "npm publish",
"test": "echo "Error: no test specified" &amp;&amp; exit 1"
},
"author": "",
"license": "ISC",
"dependencies": {
"commander": "^14.0.2",
"inquirer": "^12.11.1"
}
}</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// bin/hcli.js 内容</span>
#!<span class="hljs-regexp">/usr/</span>bin/env node
 <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'hello,world'</span>)
</code></pre>
</li>
</ul>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/97374feb3aec45ec9a561d08a9a4328c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgeGltaW1pbWk=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766479811&amp;x-signature=JYkVC3LxOYWqDoxfP1DgZ%2BRKflc%3D" alt="image.png" loading="lazy"/></p>
<p>调试： 在当前目录下npm link,在调试的目录下npm link hcli; 这时候执行hcli就会打印hello,world</p>
<ul>
<li>为了实现hcli create功能，需要使用commander这个模块, 在bin/hcli.js文件中</li>
</ul>

<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-meta">#!/usr/bin/env node</span>
<span class="hljs-keyword">const</span> { program } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'commander'</span>)
<span class="hljs-keyword">const</span> create = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../src/create'</span>)

program.<span class="hljs-title function_">command</span>(<span class="hljs-string">'create'</span>).<span class="hljs-title function_">description</span>(<span class="hljs-string">'create a project '</span>).<span class="hljs-title function_">action</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'create project'</span>)
})

program.<span class="hljs-title function_">parse</span>(process.<span class="hljs-property">argv</span>)
</code></pre>
<ul>
<li>在hcli create时需要出现交互界面运行用户输入选择，这时候需要用到inquirer模块</li>
</ul>

<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 新增src/question.js文件</span>
<span class="hljs-keyword">const</span> create = [
    {
        <span class="hljs-attr">name</span>:<span class="hljs-string">'conf'</span>,
        <span class="hljs-attr">type</span>:<span class="hljs-string">'confirm'</span>,
        <span class="hljs-attr">message</span>:<span class="hljs-string">'是否创建新的项目？'</span>
    },{
        <span class="hljs-attr">name</span>:<span class="hljs-string">'name'</span>,
        <span class="hljs-attr">message</span>:<span class="hljs-string">'请输入项目名称？'</span>,
        <span class="hljs-attr">when</span>: <span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-title class_">Boolean</span>(res.<span class="hljs-property">conf</span>)
    },{
        <span class="hljs-attr">name</span>:<span class="hljs-string">'title'</span>,
        <span class="hljs-attr">message</span>:<span class="hljs-string">'请输入项目在首页的标题？'</span>,
        <span class="hljs-attr">when</span>: <span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-title class_">Boolean</span>(res.<span class="hljs-property">conf</span>)
    },{
        <span class="hljs-attr">type</span>: <span class="hljs-string">'list'</span>,
        <span class="hljs-attr">message</span>: <span class="hljs-string">'请选择要复用的项目模版？'</span>,
        <span class="hljs-attr">name</span>: <span class="hljs-string">'model'</span>,
        <span class="hljs-attr">choices</span>: [<span class="hljs-string">'A'</span>,<span class="hljs-string">'B'</span>,<span class="hljs-string">'C'</span> ....],
        <span class="hljs-attr">filter</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>) {
          <span class="hljs-keyword">return</span> val.<span class="hljs-title function_">toLowerCase</span>()
        },
        <span class="hljs-attr">when</span>: <span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-title class_">Boolean</span>(res.<span class="hljs-property">conf</span>)
    }
]
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
    create
}

<span class="hljs-comment">// 新增src/inquirer.js文件</span>
<span class="hljs-keyword">const</span> inquirer = <span class="hljs-built_in">require</span>(<span class="hljs-string">'inquirer'</span>)
<span class="hljs-keyword">const</span> questions = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./question'</span>)
<span class="hljs-keyword">const</span> prompt = inquirer.<span class="hljs-property">prompt</span> || (inquirer.<span class="hljs-property">default</span> &amp;&amp; inquirer.<span class="hljs-property">default</span>.<span class="hljs-property">prompt</span>)

<span class="hljs-keyword">const</span> <span class="hljs-title function_">create</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> {
    <span class="hljs-title function_">prompt</span>(questions.<span class="hljs-property">create</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> {
      <span class="hljs-title function_">resolve</span>(res)
    })
  })
}

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  create
}

<span class="hljs-comment">/// bin/hcli.js文件</span>
#!<span class="hljs-regexp">/usr/</span>bin/env node
<span class="hljs-keyword">const</span> { program } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'commander'</span>)
<span class="hljs-keyword">const</span> inquirer = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../src/inquirer'</span>)
<span class="hljs-keyword">const</span> create = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../src/create'</span>)

program.<span class="hljs-title function_">command</span>(<span class="hljs-string">'create'</span>).<span class="hljs-title function_">description</span>(<span class="hljs-string">'create a project '</span>).<span class="hljs-title function_">action</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'create project'</span>)
  inquirer.<span class="hljs-title function_">create</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>{
		<span class="hljs-keyword">if</span>(res.<span class="hljs-property">conf</span>){
                <span class="hljs-comment">// todo</span>
                 <span class="hljs-title function_">create</span>(res)
		}
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'res'</span>, res)
	})
})
program.<span class="hljs-title function_">parse</span>(process.<span class="hljs-property">argv</span>)
</code></pre>
<ul>
<li>最重要的就是根据inquirer传入的res参数来实现create功能</li>
</ul>

<pre><code class="hljs language-scss" lang="scss">const fs = <span class="hljs-built_in">require</span>('fs')
const path = <span class="hljs-built_in">require</span>('path')
const copy = <span class="hljs-built_in">require</span>('../utils/copyFile.js')

module<span class="hljs-selector-class">.exports</span> = <span class="hljs-built_in">function</span>(res){
    <span class="hljs-comment">/**
    * 1、在src/view下创建name目录，将model目录下的文件复制过去
    * 2、在public目录下创建name.html文件
    * 3、修改vue.config.js文件，添加新的入口
    * 4、在home项目中增加入口
    * 5、在public/versions.json中添加版本信息
    * **/</span>
    <span class="hljs-built_in">createBaseProject</span>(res)
    <span class="hljs-built_in">createPublicHtml</span>(res)
    <span class="hljs-built_in">updateVueConfig</span>(res)
    <span class="hljs-built_in">addHomeEnetry</span>(res)
    <span class="hljs-built_in">addVersion</span>(res)
}

function <span class="hljs-built_in">createBaseProject</span>(res){
    ....
}

function <span class="hljs-built_in">createPublicHtml</span>(res){
 ...
}

function <span class="hljs-built_in">updateVueConfig</span>(res) {
 ...
}

const addVersion = (res) =&gt; {
 ...
}
</code></pre>
<p>这里create方法需要根据自己实际项目的需求来实现～只需列出具体框架，其他让AI实现就好了</p>
<p>参考文章： <a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.aliyun.com%2Farticle%2F1259366" target="_blank" title="https://developer.aliyun.com/article/1259366" ref="nofollow noopener noreferrer">developer.aliyun.com/article/125…</a></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[JS执行机制揭秘：你以为的“顺序执行”，其实是V8引擎在背后搞事情！]]></title>    <link>https://juejin.cn/post/7584073390694187023</link>    <guid>https://juejin.cn/post/7584073390694187023</guid>    <pubDate>2025-12-16T09:00:19.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584073390694187023" data-draft-id="7584071941025054735" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="JS执行机制揭秘：你以为的“顺序执行”，其实是V8引擎在背后搞事情！"/> <meta itemprop="keywords" content="前端,JavaScript"/> <meta itemprop="datePublished" content="2025-12-16T09:00:19.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="ETA8"/> <meta itemprop="url" content="https://juejin.cn/user/608445545328347"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            JS执行机制揭秘：你以为的“顺序执行”，其实是V8引擎在背后搞事情！
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/608445545328347/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    ETA8
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-16T09:00:19.000Z" title="Tue Dec 16 2025 09:00:19 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-16
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">🚀 <strong>JS执行机制揭秘：你以为的“顺序执行”，其实是V8引擎在背后搞事情！</strong></h2>
<hr/>
<p>你有没有遇到过这样的场景？</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-title function_">showName</span>(); <span class="hljs-comment">// 能执行？</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myname); <span class="hljs-comment">// undefined？</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(hero); <span class="hljs-comment">// 直接报错？？？</span>

<span class="hljs-keyword">var</span> myname = <span class="hljs-string">'lc'</span>;
<span class="hljs-keyword">let</span> hero = <span class="hljs-string">'钢铁侠'</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">showName</span>(<span class="hljs-params"/>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'函数showName执行了'</span>);
}
</code></pre>
<p>是不是一脸懵？<br/>
为什么 <code>showName()</code> 没定义就能调用？<br/>
为什么 <code>myname</code> 是 <code>undefined</code> 而不是报错？<br/>
但 <code>hero</code> 却直接抛出错误：“Cannot access 'hero' before initialization”？</p>
<p>别急——这并不是 JS 的 bug，而是 <strong>V8 引擎在编译阶段悄悄做了点“手脚”</strong>。</p>
<p>今天，我们就来揭开 JavaScript 执行机制的神秘面纱，带你走进 <strong>Chrome 浏览器背后的“大脑”——V8引擎</strong>，看看它是如何一步步把你的代码“玩弄于股掌之间”的！</p>
<hr/>
<h3 data-id="heading-1">🔥 开篇暴击：JS 真的是“边解释边执行”吗？</h3>
<p>很多人说：“JavaScript 是脚本语言，不需要编译，是边解释边执行的。”</p>
<p>❌ 错！大错特错！</p>
<p>现代 JavaScript（尤其是 V8 引擎）<strong>在执行前会先进行一轮快速的“编译”</strong> —— 虽然它不像 C++ 那样生成机器码，但它确实会在“执行前的一刹那”完成变量提升、作用域分析、语法检查等一系列准备工作。</p>
<p>这个过程，就是我们常说的：</p>
<blockquote>
<p>💡 <strong>编译阶段 + 执行阶段</strong></p>
</blockquote>
<p>而这一切的背后推手，就是 <strong>调用栈（Call Stack） + 执行上下文（Execution Context）</strong>。</p>
<hr/>
<h3 data-id="heading-2">🧠 举个生活化的例子：做一顿饭</h3>
<p>想象你要做一顿饭：</p>
<ol>
<li>先看菜谱（相当于读代码）</li>
<li>把要用的食材提前准备好（鸡蛋打散、葱切好…）</li>
<li>再开始炒菜（真正执行）</li>
</ol>
<p>JavaScript 的执行流程也是一样的：</p>
<ul>
<li><strong>编译阶段</strong>：提前把变量和函数“备好料”</li>
<li><strong>执行阶段</strong>：正式开火炒菜</li>
</ul>
<p>如果你跳过“备料”直接炒，就会发现：“哎我葱还没切！”——这就是你看到 <code>undefined</code> 或报错的原因。</p>
<hr/>
<h3 data-id="heading-3">🛠️ 第一步：V8 引擎的两步走战略</h3>
<h4 data-id="heading-4">✅ 编译阶段（Compilation Phase）</h4>
<ul>
<li>检查语法错误</li>
<li>变量提升（Hoisting）</li>
<li>函数优先提升</li>
<li>创建执行上下文（Execution Context）</li>
</ul>
<h4 data-id="heading-5">✅ 执行阶段（Execution Phase）</h4>
<ul>
<li>按顺序执行可执行代码</li>
<li>使用已准备好的变量和函数</li>
</ul>
<blockquote>
<p>⚠️ 注意：<strong>编译总是在执行之前发生</strong>，哪怕只差一毫秒！</p>
</blockquote>
<hr/>
<h3 data-id="heading-6">🎯 实战解析 1：<code>var</code> 和 <code>let</code> 的命运为何天差地别？</h3>
<p>来看这段代码：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 1.js</span>
<span class="hljs-title function_">showName</span>();           <span class="hljs-comment">// ✅ 输出：函数showName执行了</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myname);  <span class="hljs-comment">// ❓ 输出：undefined</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(hero);    <span class="hljs-comment">// 💥 报错：Cannot access 'hero' before initialization</span>

<span class="hljs-keyword">var</span> myname = <span class="hljs-string">'lc'</span>;
<span class="hljs-keyword">let</span> hero = <span class="hljs-string">'钢铁侠'</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">showName</span>(<span class="hljs-params"/>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'函数showName执行了'</span>);
}
</code></pre>
<h4 data-id="heading-7">🤔 为什么结果这么奇怪？</h4>
<p>让我们模拟 V8 引擎的“内心独白”：</p>
<h5 data-id="heading-8">编译阶段 👇</h5>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// V8心里想：</span>
<span class="hljs-keyword">var</span> myname;        <span class="hljs-comment">// 提升，初始值 undefined</span>
<span class="hljs-keyword">let</span> hero;          <span class="hljs-comment">// 声明了，但不能访问！进入“暂时性死区”</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">showName</span>(<span class="hljs-params"/>) { ... } <span class="hljs-comment">// 函数声明，直接整个函数体挂上去</span>
</code></pre>
<p>此时内存长这样：</p>





















<table><thead><tr><th>变量名</th><th>值</th></tr></thead><tbody><tr><td>myname</td><td><code>undefined</code></td></tr><tr><td>hero</td><td><code>&lt;uninitialized&gt;</code></td></tr><tr><td>showName</td><td><code>function showName(){}</code></td></tr></tbody></table>
<h5 data-id="heading-9">执行阶段 👇</h5>
<pre><code class="hljs language-js" lang="js"><span class="hljs-title function_">showName</span>();           <span class="hljs-comment">// ✅ 找到了函数，执行成功</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myname);  <span class="hljs-comment">// myname 还没赋值，所以是 undefined</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(hero);    <span class="hljs-comment">// ❌ hero 处于“暂时性死区”，不允许访问 → 报错！</span>
</code></pre>
<blockquote>
<p>💡 小贴士：<code>let/const</code> 不允许重复声明，且存在 <strong>暂时性死区（Temporal Dead Zone, TDZ）</strong>，即从进入作用域到被赋值前都不能访问。</p>
</blockquote>
<hr/>
<h3 data-id="heading-10">🔄 实战解析 2：函数提升比变量更牛？</h3>
<p>再看一个经典案例：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 2.js</span>
<span class="hljs-title function_">showName</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myName);

<span class="hljs-keyword">var</span> myName = <span class="hljs-string">'lc'</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">showName</span>(<span class="hljs-params"/>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'函数showName执行了'</span>);
}
</code></pre>
<p>你以为的执行顺序是：</p>
<ol>
<li>调用 <code>showName</code></li>
<li>打印 <code>myName</code></li>
<li>给 <code>myName</code> 赋值</li>
</ol>
<p>但实际上，V8 编译后是这样的：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 编译阶段后的样子（伪代码）</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">showName</span>(<span class="hljs-params"/>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'函数showName执行了'</span>);
}
<span class="hljs-keyword">var</span> myName = <span class="hljs-literal">undefined</span>;

<span class="hljs-comment">// 执行阶段</span>
<span class="hljs-title function_">showName</span>();         <span class="hljs-comment">// ✅ 成功</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myName); <span class="hljs-comment">// ❓ undefined（还没赋值）</span>
myName = <span class="hljs-string">'lc'</span>;       <span class="hljs-comment">// 后面才赋值</span>
</code></pre>
<p>🎯 结论：<strong>函数声明 &gt; var 变量提升</strong><br/>
函数会被完整提升到最上面，<code>var</code> 只是声明提升，赋值仍留在原地。</p>
<hr/>
<h3 data-id="heading-11">🔥 高能预警：函数内部也能“宫斗”？</h3>
<p>来看这段“内讧严重”的代码：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 3.js</span>
<span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">a</span>) {
  <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params"/>) {}
  <span class="hljs-keyword">var</span> b = a;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);
}

<span class="hljs-title function_">fn</span>(<span class="hljs-number">3</span>);
</code></pre>
<p>输出什么？🤔</p>
<p>A. <code>2</code><br/>
B. <code>3</code><br/>
C. <code>function a(){}</code><br/>
D. 报错</p>
<p>揭晓答案：👉 <strong>A. 2</strong></p>
<h4 data-id="heading-12">🕵️‍♂️ 让我们还原 V8 的编译现场：</h4>
<h5 data-id="heading-13">编译阶段（进入 fn 函数时）</h5>
<p>参数 <code>a</code> 已经传入实参 <code>3</code> → <code>a = 3</code></p>
<p>然后开始扫描内部声明：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params"/>) {}  <span class="hljs-comment">// 函数声明，优先级最高 → a = function a(){}</span>
<span class="hljs-keyword">var</span> a;           <span class="hljs-comment">// var 声明，忽略（已有 a）</span>
<span class="hljs-keyword">var</span> b;           <span class="hljs-comment">// b = undefined</span>
</code></pre>
<p>⚠️ 关键来了：虽然函数声明优先，但 <strong>函数内部如果有同名变量或参数，会覆盖函数名</strong>！</p>
<p>接着执行阶段：</p>
<pre><code class="hljs language-js" lang="js">a = <span class="hljs-number">2</span>;      <span class="hljs-comment">// 显式赋值，覆盖之前的 function a(){}</span>
b = a;      <span class="hljs-comment">// b = 2</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// 打印 2</span>
</code></pre>
<p>🎯 所以最终输出：<code>2</code></p>
<blockquote>
<p>🧨 总结：<strong>函数声明虽强，但在执行阶段的赋值操作面前，也会被无情覆盖！</strong></p>
</blockquote>
<hr/>
<h3 data-id="heading-14">🚫 <code>var</code> 和 <code>let</code> 的“婚姻观”完全不同！</h3>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 4.js</span>
<span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;
<span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>; <span class="hljs-comment">// ✅ 合法！var 允许重复声明</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// 2</span>

<span class="hljs-keyword">let</span> b = <span class="hljs-number">3</span>;
<span class="hljs-keyword">let</span> b = <span class="hljs-number">4</span>; <span class="hljs-comment">// ❌ 报错！SyntaxError: Identifier 'b' has already been declared</span>
</code></pre>
<p>💡 类比一下：</p>
<ul>
<li><code>var</code> 就像“开放式婚姻”：你可以多次 declare，只要不闹大就行。</li>
<li><code>let/const</code> 则是“一夫一妻制”：一旦声明，终身绑定，重复就是违法！</li>
</ul>
<p>这也是为什么现代开发推荐使用 <code>let/const</code>，避免意外覆盖。</p>
<hr/>
<h3 data-id="heading-15">💣 最致命陷阱：函数表达式不会提升！</h3>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 5.js</span>
<span class="hljs-title function_">func</span>(); <span class="hljs-comment">// ❌ 报错！Cannot access 'func' before initialization</span>

<span class="hljs-keyword">let</span> <span class="hljs-title function_">func</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">123</span>);
};
</code></pre>
<p>很多人以为：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">let</span> <span class="hljs-title function_">func</span> = (<span class="hljs-params"/>) =&gt; {}
</code></pre>
<p>也能提升？错！</p>
<p>📌 <strong>只有函数声明会完整提升，函数表达式不会！</strong></p>
<p>上面这段代码在编译阶段是：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">let</span> func; <span class="hljs-comment">// 声明了，但处于 TDZ（暂时性死区）</span>
</code></pre>
<p>执行到 <code>func()</code> 时，<code>func</code> 还没初始化 → 直接爆炸 💥</p>
<blockquote>
<p>✅ 正确写法应该是：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">let</span> <span class="hljs-title function_">func</span> = (<span class="hljs-params"/>) =&gt; { ... };
<span class="hljs-title function_">func</span>(); <span class="hljs-comment">// 放在后面调用</span>
</code></pre>
</blockquote>
<hr/>
<h3 data-id="heading-16">🧩 核心机制揭秘：执行上下文与调用栈</h3>
<p>JavaScript 是如何管理这些复杂的作用域和提升行为的？</p>
<p>答案是：<strong>执行上下文（Execution Context） + 调用栈（Call Stack）</strong></p>
<h4 data-id="heading-17">🧱 每次函数执行都会创建一个新的执行上下文</h4>
<p>每个执行上下文包含两个重要部分：</p>

















<table><thead><tr><th>组件</th><th>说明</th></tr></thead><tbody><tr><td><strong>变量环境（Variable Environment）</strong></td><td>存放 <code>var</code> 声明的变量</td></tr><tr><td><strong>词法环境（Lexical Environment）</strong></td><td>存放 <code>let/const</code> 声明的变量</td></tr></tbody></table>
<blockquote>
<p>📌 全局上下文最先入栈，函数调用时新上下文压入栈顶，执行完后弹出并销毁。</p>
</blockquote>
<h4 data-id="heading-18">🧱 调用栈的工作方式（LIFO：后进先出）</h4>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params"/>) {
  <span class="hljs-title function_">b</span>();
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">b</span>(<span class="hljs-params"/>) {
  <span class="hljs-title function_">c</span>();
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">c</span>(<span class="hljs-params"/>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'我在栈顶！'</span>);
}
<span class="hljs-title function_">a</span>(); <span class="hljs-comment">// a → b → c 入栈，c 先执行完，依次出栈</span>
</code></pre>
<p>就像叠盘子：最后放上的最先拿走。</p>
<hr/>
<h3 data-id="heading-19">🧠 总结：一张图看懂 JS 执行机制</h3>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c58c00e8d1734246b00c8fb07ac49c2f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRVRBOA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766480418&amp;x-signature=BFdbvntxKGP6lyF0EVIamwbmEC8%3D" alt="Snipaste_2025-12-16_16-58-13.jpg" loading="lazy"/>
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f6b67974727e488d944bde215e84a8f1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRVRBOA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766480418&amp;x-signature=w%2FTCgVVnTCy6Il2OBryHfjA4K2A%3D" alt="Snipaste_2025-12-16_16-48-07.jpg" loading="lazy"/></p>
<hr/>
<h3 data-id="heading-20">✅ 终极口诀：背下这几句，面试不再慌！</h3>
<blockquote>
<p>🎯 <strong>“函数优先，var 提升，let 死区，表达式不升，栈管执行。”</strong></p>
</blockquote>






























<table><thead><tr><th>特性</th><th>var</th><th>let/const</th></tr></thead><tbody><tr><td>是否提升</td><td>是（声明）</td><td>否（TDZ）</td></tr><tr><td>是否可重复声明</td><td>是</td><td>否</td></tr><tr><td>初始化时机</td><td>undefined</td><td>必须手动赋值</td></tr><tr><td>提升优先级</td><td>低于函数</td><td>不参与提升</td></tr></tbody></table>
<hr/>
<h3 data-id="heading-21">🎁 彩蛋：如何避免提升带来的坑？</h3>
<h4 data-id="heading-22">✔️ 最佳实践建议：</h4>
<ol>
<li><strong>一律使用 <code>let/const</code></strong>，杜绝 <code>var</code></li>
<li><strong>函数声明放在文件顶部</strong></li>
<li><strong>不要在函数内混用同名函数与变量</strong></li>
<li><strong>变量声明尽量靠近使用位置</strong></li>
<li><strong>开启 ESLint，自动检测 TDZ 错误</strong></li>
</ol>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// ✅ 推荐写法</span>
<span class="hljs-keyword">let</span> userName = <span class="hljs-string">'lc'</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">showName</span>(<span class="hljs-params"/>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(userName);
}

<span class="hljs-title function_">showName</span>();
</code></pre>
<hr/>
<h3 data-id="heading-23">🌟 写在最后：你写的不是代码，是 V8 的剧本</h3>
<p>JavaScript 表面上看似随意、灵活，实则每一步都在 V8 引擎的精密计算之中。</p>
<p>理解执行机制，不只是为了应付面试，更是为了写出更稳定、更可预测的代码。</p>
<p>当你下次看到 <code>undefined</code> 或莫名其妙的报错时，不要再骂“JS 是个奇葩语言”了。</p>
<p>你应该微笑着说：</p>
<blockquote>
<p>“哦～原来是你，V8，在背后偷偷搞事情啊。”</p>
</blockquote>
<hr/>
<h3 data-id="heading-24">🔖 关键词标签</h3>
<p>#JavaScript #JS执行机制 #变量提升 #Hoisting #V8引擎 #执行上下文 #调用栈 #let和var区别 #前端面试 #掘金热门</p>
<hr/>
<p>📌 <strong>喜欢这篇文章？记得点赞 + 收藏 + 分享给同事！让更多人少走弯路！</strong><br/>
关注我，每周一篇深度前端源理解析，带你从青铜走向王者 💪</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[VonaJS是如何做到文件级别精确HMR(热更新)的？]]></title>    <link>https://juejin.cn/post/7584059298696921129</link>    <guid>https://juejin.cn/post/7584059298696921129</guid>    <pubDate>2025-12-16T09:04:32.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584059298696921129" data-draft-id="7584057497206194219" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="VonaJS是如何做到文件级别精确HMR(热更新)的？"/> <meta itemprop="keywords" content="TypeScript,Node.js,NestJS"/> <meta itemprop="datePublished" content="2025-12-16T09:04:32.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="濮水大叔"/> <meta itemprop="url" content="https://juejin.cn/user/1119781972622208"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            VonaJS是如何做到文件级别精确HMR(热更新)的？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1119781972622208/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    濮水大叔
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-16T09:04:32.000Z" title="Tue Dec 16 2025 09:04:32 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-16
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">NestJS：项目级别HMR</h2>
<p>如果使用过NestJS，就会知道NestJS是基于整个项目实现HMR（热更新）的。大致流程如下：当一个源码文件变更时，系统会自动将文件重新编译输出到dist目录，然后重启App。当项目非常大时，这样的HMR机制就会非常慢。</p>
<h2 data-id="heading-1">VonaJS：文件级别HMR</h2>
<p>而VonaJS就实现了基于单文件的精确HMR（热更新）。大致流程如下：当源码文件变更时，系统会自动重新导入该文件，并替换IOC容器中注册的实例。既没有重新编译的环节，也不需要重启App。如果你要开发大型项目，没有比这个更爽的HMR机制了。</p>
<p>下面先简要看看VonaJS HMR的效果，再介绍是如何实现的：</p>
<h2 data-id="heading-2">文件级别HMR效果展示</h2>
<h3 data-id="heading-3">1. 修改Service文件</h3>
<p>当我们修改某个Service文件并保存之后，控制台显示如下：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4055072902884aaeb3710824c94040df~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5r-u5rC05aSn5Y-U:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766480671&amp;x-signature=TmJEyfG1uLibwAxZAXAE7QDZm6w%3D" alt="hmr_1.png" loading="lazy"/></p>
<h3 data-id="heading-4">2. 修改Controller文件</h3>
<p>当我们修改某个Controller文件并保存之后，控制台显示如下：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0911e3ae1f8b41da8100c48c8310ebc0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5r-u5rC05aSn5Y-U:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766480671&amp;x-signature=4%2F1qSMd0Y5ik4ozg6nXLx2hY0VI%3D" alt="hmr-2.png" loading="lazy"/></p>
<h3 data-id="heading-5">3. 修改Middleware文件</h3>
<p>当我们修改某个Middleware文件并保存之后，控制台显示如下：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2b96f32e55ba46c6ad129f3a33916076~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5r-u5rC05aSn5Y-U:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766480671&amp;x-signature=TlInyPQPnPfIpQsaL3uBq%2BWs4KI%3D" alt="hmr-3.png" loading="lazy"/></p>
<h2 data-id="heading-6">文件级别HMR原理分析</h2>
<h3 data-id="heading-7">1. 分布式场景中如何实现文件Watch</h3>
<p>VonaJS原生支持分布式架构，因此在执行<code>npm run dev</code>时也是默认启动两个Workers，便于尽早排查分布式场景下可能遇到的问题。那么，在分布式场景中，我们需要挑选出一个Worker，用于监听文件的变更事件。</p>
<p>VonaJS提供了<code>Election</code>机制，代码如下：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Monkey</span> {
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">appStarted</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">const</span> scope = <span class="hljs-variable language_">this</span>.<span class="hljs-property">app</span>.<span class="hljs-title function_">scope</span>(__ThisModule__);
    scope.<span class="hljs-property">election</span>.<span class="hljs-title function_">obtain</span>(<span class="hljs-string">'hmr'</span>, <span class="hljs-keyword">async</span> () =&gt; {
      <span class="hljs-keyword">await</span> scope.<span class="hljs-property">service</span>.<span class="hljs-property">watch</span>.<span class="hljs-title function_">start</span>();
    }, <span class="hljs-keyword">async</span> () =&gt; {
      <span class="hljs-keyword">await</span> scope.<span class="hljs-property">service</span>.<span class="hljs-property">watch</span>.<span class="hljs-title function_">stop</span>();
    });
  }
}
</code></pre>
<ol>
<li>响应系统启动事件，通过<code>scope.election.obtain</code>竞争所有权</li>
<li>当取得所有权时，执行<code>scope.service.watch.start</code>，实现文件监听</li>
<li>当释放所有权时，执行<code>scope.service.watch.stop</code>，停止文件监听</li>
</ol>
<h3 data-id="heading-8">2. ESM文件重新加载</h3>
<p>当监听到源码文件变更之后，需要重新加载。我们知道一个文件<code>import</code>之后，系统会自动缓存，如果再次import，系统会直接使用缓存，不会重新加载。那么，我们是否可以强制清理系统缓存呢？在CJS中是可以的，但在ESM中不行。</p>
<p>NestJS开发时间比较早，到目前为止仍然使用的是CJS模块。在NestJS中，源码采用的是ESM语法，但是实际运行时，需要先编译成CJS模块，然后再通过<code>require</code>加载模块。</p>
<p>而VonaJS是全新设计的框架，全部使用了ESM模块。虽然不能删除系统缓存，但是可以通过变更文件名的方式来实现重新加载，代码如下：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">const</span> file=<span class="hljs-string">'/path/to/service.ts'</span>;
<span class="hljs-keyword">const</span> fileUrl = <span class="hljs-string">`<span class="hljs-subst">${file}</span>?<span class="hljs-subst">${<span class="hljs-built_in">Date</span>.now()}</span>`</span>;
<span class="hljs-keyword">const</span> fileModule = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(fileUrl);
</code></pre>
<h3 data-id="heading-9">3. 清理运行状态值</h3>
<p>当文件重新加载之后，就可以替换IOC容器中注册的实例。除此之外还有可能需要清理一些运行状态值。这就需要具体问题具体分析。比如，Server文件不需清理运行状态值。但是，Middleware就需要清理运行状态，从而让新的Middleware生效</p>
<p>下面以系统中间件为例，演示基本流程：</p>
<ol>
<li>当系统启动时，需要注入系统中间件</li>
</ol>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-variable language_">this</span>.<span class="hljs-property">app</span>.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">ctx, next</span>) =&gt;</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">_composeMiddlewareSystems</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">app</span>)(ctx, next);
});
</code></pre>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">_composeMiddlewareSystems</span>(<span class="hljs-params">app: VonaApplication</span>) {
  <span class="hljs-comment">// compose</span>
  <span class="hljs-keyword">if</span> (!app.<span class="hljs-property">meta</span>[<span class="hljs-title class_">SymbolCacheComposeMiddlewareSystems</span>]) {
    <span class="hljs-keyword">const</span> middlewares = app.<span class="hljs-property">bean</span>.<span class="hljs-property">onion</span>.<span class="hljs-property">middlewareSystem</span>.<span class="hljs-title function_">getOnionsEnabledWrapped</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">_wrapOnion</span>(app, item);
    });
    app.<span class="hljs-property">meta</span>[<span class="hljs-title class_">SymbolCacheComposeMiddlewareSystems</span>] = <span class="hljs-title function_">compose</span>(middlewares);
  }
  <span class="hljs-keyword">return</span> app.<span class="hljs-property">meta</span>[<span class="hljs-title class_">SymbolCacheComposeMiddlewareSystems</span>];
}
</code></pre>
<p><code>_composeMiddlewareSystems</code>方法将收集所有系统中间件，并<code>compose</code>成一个函数，然后缓存到<code>app.meta[SymbolCacheComposeMiddlewareSystems]</code>中</p>
<ol start="2">
<li>清理运行状态</li>
</ol>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-meta">@Hmr</span>()
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HmrMiddlewareSystem</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">BeanBase</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IHmrReload</span> {
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">reload</span>(<span class="hljs-params">_beanOptions: IDecoratorBeanOptionsBase</span>) {
    <span class="hljs-keyword">delete</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">app</span>.<span class="hljs-property">meta</span>[<span class="hljs-title class_">SymbolCacheComposeMiddlewareSystems</span>];
  }
}
</code></pre>
<p>当某个系统中间件重新加载后，就会自动执行该Class的<code>reload</code>方法，删除缓存<code>app.meta[SymbolCacheComposeMiddlewareSystems]</code>。从而让<code>_composeMiddlewareSystems</code>方法重新收集所有系统中间件，<code>compose</code>出一个新的函数</p>
<h3 data-id="heading-10">4. 支持更多场景</h3>
<p>如上所述，不同场景的文件，需要根据不同的运行机制，提供不同的清理逻辑，确保文件级别的HMR可以正常运行</p>
<p>VonaJS支持大量的场景开发，清单如下：</p>
<ol>
<li>Vona Aspect</li>
</ol>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7834f512448240c5b25b3d80775bafa2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5r-u5rC05aSn5Y-U:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766480671&amp;x-signature=t43wvdTgWwrJFSp8Idl3VgITbGI%3D" alt="menu-aspect.png" loading="lazy"/></p>
<ol start="2">
<li>Vona Bean</li>
</ol>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c0bc694db1944659bae85da86f7c7c69~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5r-u5rC05aSn5Y-U:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766480671&amp;x-signature=KyI6DrSw6HCHZua%2BQl16jbqmP2Q%3D" alt="menu-bean.png" loading="lazy"/></p>
<ol start="3">
<li>Vona Create</li>
</ol>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6786eece962e4ffdbe6d648f59355df4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5r-u5rC05aSn5Y-U:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766480671&amp;x-signature=AXTZGvActrOBCp1n3dCyT%2B2%2FWTQ%3D" alt="menu-create.png" loading="lazy"/></p>
<ol start="4">
<li>Vona Init</li>
</ol>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/66b964992b1349b0b167e22f49722c0c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5r-u5rC05aSn5Y-U:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766480671&amp;x-signature=NHMRYrlKAGess%2Fqekk91HIDgazk%3D" alt="menu-init.png" loading="lazy"/></p>
<ol start="5">
<li>Vona Meta</li>
</ol>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ad38ed7a9e124f499fcb8111ab2ef09a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5r-u5rC05aSn5Y-U:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766480671&amp;x-signature=w9bVSSqj8AV6hKfHY5Ypi80BZSw%3D" alt="menu-meta.png" loading="lazy"/></p>
<ol start="6">
<li>Vona Tools</li>
</ol>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7287edb7a74141e08b41593bf1b6387a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5r-u5rC05aSn5Y-U:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766480671&amp;x-signature=mbQqBdDioTbXEtZrX0J0lZ4N25U%3D" alt="menu-tools.png" loading="lazy"/></p>
<h2 data-id="heading-11">资源</h2>
<ul>
<li>Github：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fvonajs%2Fvona" target="_blank" title="https://github.com/vonajs/vona" ref="nofollow noopener noreferrer">github.com/vonajs/vona</a></li>
<li>文档：<a href="https://link.juejin.cn?target=https%3A%2F%2Fvona.js.org" target="_blank" title="https://vona.js.org" ref="nofollow noopener noreferrer">vona.js.org</a></li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[失败的服务端SSR降级CSR]]></title>    <link>https://juejin.cn/post/7584203412197720090</link>    <guid>https://juejin.cn/post/7584203412197720090</guid>    <pubDate>2025-12-16T09:13:02.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584203412197720090" data-draft-id="7584028251167621147" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="失败的服务端SSR降级CSR"/> <meta itemprop="keywords" content="Next.js"/> <meta itemprop="datePublished" content="2025-12-16T09:13:02.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="saintofficial"/> <meta itemprop="url" content="https://juejin.cn/user/1864415033966120"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            失败的服务端SSR降级CSR
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1864415033966120/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    saintofficial
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-16T09:13:02.000Z" title="Tue Dec 16 2025 09:13:02 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-16
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{font-family:-apple-system,system-ui,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial;color:#00325e}.markdown-body ::selection{background-color:#00325e;color:#fff}.markdown-body blockquote{padding:10px 20px;background-color:#fffaf0;box-shadow:0 3px 10px 0 rgba(255,172,194,.24);border:1px solid #f3ca8e;transition:all .2s;margin:1em 0;border-radius:5px}.markdown-body blockquote p{font-size:14px;line-height:25px;color:#795548}.markdown-body blockquote p:last-child{margin:0}.markdown-body blockquote:hover{border-color:#ff9800;background-color:#fff8e0;box-shadow:0 6px 10px -5px rgba(225,173,98,.3803921569)}.markdown-body blockquote code{color:#ff502c}.markdown-body pre{border:1px solid #8cc0f3;box-shadow:0 3px 10px 0 rgba(255,198,198,.28);border-radius:5px;transition:all .2s;overflow-x:auto;white-space:pre-wrap}.markdown-body pre:hover{border-color:#6d9dce}.markdown-body pre&gt;code{padding:10px 20px;color:#00325e;background:#f0f8ff;font-size:12px;line-height:1.6;display:block}.markdown-body code{background:#f6fbff;color:#0b5393;padding:2px 4px;border-radius:4px;font-size:12px}.markdown-body p{font-size:14px;line-height:28px;text-align:justify;margin-bottom:17px;color:#595959}.markdown-body a{color:#00325e;text-decoration:none}.markdown-body a:after{content:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAAAXNSR0IArs4c6QAAAQdJREFUKFNt0DtLA0EUBeBzZle0Eks7rcUfEfBRCha7NorYa6NmVJzgyi4smUgKtdZGCJktLMVH4Y8QeztLWyE7VyLEuNFbXj4Oh0P8c8mZm+uJrEN4BJFTeP/MUVe3bnocfALwkOlo1zS7iZAzf6Cx7oXgbaqjxiDEWCcVaGyxQ8pSWo9XhqhoQ/xUFbaKjhe5V+CmR7mnSplEEF6GSmJ+F/d0KHvbCIIJCLc85U6BC5mONgbJNM3uFag++sX7z8O8MzsWBucifMx0dDGE1kmm458KDVukAlnNdDz/exEeW3dNkbfsYC0xtmgDWP6ELLZ0/F6BJu/UoFQN5AkoeUjeJPvx6+i+X5Sjah4tA6gYAAAAAElFTkSuQmCC);margin-left:2px}.markdown-body a:hover{box-shadow:0 1px}.markdown-body table{max-width:100%;border-collapse:collapse;border-spacing:0;box-shadow:0 3px 10px 0 rgba(255,238,172,.24);transition:all .2s}.markdown-body table:hover{box-shadow:0 3px 10px 0 rgba(185,169,103,.24)}.markdown-body table tr th{border:1px solid #8cc0f3;background-color:#f0f8ff;padding:12px 15px}.markdown-body table tr td{border:1px solid rgba(243,202,142,.4);padding:12px 15px}.markdown-body table tbody tr{transition:all .2s}.markdown-body table tbody tr:hover td{border-color:#f3ca8e;background-color:#fff8e0;z-index:1}.markdown-body img{max-width:100%}.markdown-body h1{font-size:20px;margin-top:30px;margin-bottom:10px;padding-left:30px;position:relative}.markdown-body h1&gt;code{font-size:20px}.markdown-body h1:before{content:"🍺";display:block;font-size:18px;width:18px;height:18px;left:0;position:absolute}.markdown-body h2{font-size:18px;margin-top:30px;margin-bottom:10px;padding-left:28px;position:relative}.markdown-body h2&gt;code{font-size:18px}.markdown-body h2:before{content:"🍻";display:block;font-size:16px;width:16px;height:16px;left:0;position:absolute}.markdown-body h3{font-size:16px;margin-top:30px;margin-bottom:10px;padding-left:26px;position:relative}.markdown-body h3&gt;code{font-size:16px}.markdown-body h3:before{content:"🥂";display:block;font-size:14px;width:14px;height:14px;left:0;position:absolute}.markdown-body h4{font-size:14px;margin-top:30px;margin-bottom:10px;padding-left:24px;position:relative}.markdown-body h4&gt;code{font-size:14px}.markdown-body h4:before{content:"🥃";display:block;font-size:12px;width:12px;height:12px;left:0;position:absolute}.markdown-body h5{font-size:12px;margin-top:30px;margin-bottom:10px}.markdown-body h5&gt;code{font-size:12px}.markdown-body h6{font-size:10px;margin-top:30px;margin-bottom:10px}.markdown-body h6&gt;code{font-size:10px}.markdown-body h1,.markdown-body h2{color:#ff502c}.markdown-body hr{height:4px;border:none;margin-top:32px;margin-bottom:32px;background-size:4px 1px;background-image:linear-gradient(270deg,#6d9dce,#8cc0f3 25%,transparent 50%)}.markdown-body hr:nth-child(2n){background-image:linear-gradient(270deg,#ff9800,#fff8e0 25%,transparent 50%)}.markdown-body ul{padding-inline-start:20px}.markdown-body ul li{list-style-type:"🔸"}.markdown-body ul li li{list-style-type:"◻️"}.markdown-body ul li li li{list-style-type:"▫️"}.markdown-body ol{padding-inline-start:20px}.markdown-body ol ::marker{color:#ff9800}.markdown-body ol,.markdown-body ul{line-height:2em}.markdown-body li{padding-inline-start:1ch}.markdown-body li.task-list-item{list-style:none;padding-inline-start:0}.markdown-body li input{padding-right:2px}.markdown-body li input[type=checkbox i]{appearance:none}.markdown-body li input:before{content:"🟩";display:block;width:13px;height:13px}.markdown-body li input:checked:before{content:"✅"}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="atelier-sulphurpool-light">.hljs-comment,.hljs-quote{color:#6b7394}.hljs-attribute,.hljs-link,.hljs-name,.hljs-regexp,.hljs-selector-class,.hljs-selector-id,.hljs-tag,.hljs-template-variable,.hljs-variable{color:#c94922}.hljs-built_in,.hljs-builtin-name,.hljs-literal,.hljs-meta,.hljs-number,.hljs-params,.hljs-type{color:#c76b29}.hljs-bullet,.hljs-string,.hljs-symbol{color:#ac9739}.hljs-section,.hljs-title{color:#3d8fd1}.hljs-keyword,.hljs-selector-tag{color:#6679cc}.markdown-body pre,.markdown-body pre&gt;code.hljs{background:#f5f7ff;color:#5e6687}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h3 data-id="heading-0">前沿</h3>
<p>在活动页需要同时兼顾首屏渲染和接口不稳定，想用一个组件兜底：服务端优先渲染，失败时自动降级到客户端再拉一次。于是写了 DataSection（src/components/global/DataSection），记录这次尝试和它最终没完全达成预期的原因。</p>
<h3 data-id="heading-1">条件</h3>
<ol>
<li>全局公共使用，那么必须是公共组件，不用为每个涉及接口的组件处理（各种Wapper组件)</li>
<li>复用同一份业务代码片段，避免写两套（啥客户端一套、服务端一套的）</li>
<li>如果SSR 正常，dom元素仍然走SSR，如果失败，可接受全局dom降级客户端渲染</li>
</ol>
<h3 data-id="heading-2">目的</h3>
<ul>
<li>SSR 正常：直接用服务端数据渲染，拿到完整 HTML/SEO。</li>
<li>SSR 失败：不要 500，也不要空白；在浏览器端再请求一次。</li>
</ul>
<h3 data-id="heading-3">实现过程</h3>
<ol>
<li>服务端安全 fetch<br/>
api-client.ts 用 safeFetch 包装，服务端请求失败不抛错，返回 null，避免整个页面崩掉。</li>
</ol>
<pre><code class="hljs language-typescript" lang="typescript">src/components/<span class="hljs-variable language_">global</span>/<span class="hljs-title class_">DataSection</span>/api-client.<span class="hljs-property">ts</span> 

<span class="hljs-keyword">const</span> isServer = <span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">window</span> === <span class="hljs-string">"undefined"</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> safeFetch&lt;T&gt;(<span class="hljs-attr">fetcher</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">Promise</span>&lt;T&gt;): <span class="hljs-title class_">Promise</span>&lt;T | <span class="hljs-literal">null</span>&gt; {
  <span class="hljs-keyword">if</span> (!isServer) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"safeFetch should only be called on server"</span>)
  }

  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetcher</span>()
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"[Server] API failed:"</span>, error)
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>
  }
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> safeFetchAll&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">unknown</span>[]&gt;(
  <span class="hljs-attr">fetchers</span>: <span class="hljs-keyword">readonly</span> (<span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">Promise</span>&lt;T[<span class="hljs-built_in">number</span>]&gt;)[]
): <span class="hljs-title class_">Promise</span>&lt;{ [K <span class="hljs-keyword">in</span> keyof T]: T[K] | <span class="hljs-literal">null</span> }&gt; {
  <span class="hljs-keyword">const</span> results = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">allSettled</span>(fetchers.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">fetcher</span> =&gt;</span> <span class="hljs-title function_">fetcher</span>()))

  <span class="hljs-keyword">return</span> results.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> (result.<span class="hljs-property">status</span> === <span class="hljs-string">"fulfilled"</span> ? result.<span class="hljs-property">value</span> : <span class="hljs-literal">null</span>)) <span class="hljs-keyword">as</span> { [K <span class="hljs-keyword">in</span> keyof T]: T[K] | <span class="hljs-literal">null</span> }
}

</code></pre>
<ol start="2">
<li>统一入口 DataSection<br/>
SSR 有数据（initialData.code === 0）就直接渲染 children；否则走客户端降级。</li>
</ol>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// src/components/global/DataSection/index.tsx</span>

<span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>

<span class="hljs-keyword">import</span> <span class="hljs-title class_">ClientFallback</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./ClientFallback'</span>

<span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> { <span class="hljs-title class_">CommonApiRes</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/lib/service/type'</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Props</span>&lt;T&gt; {
  <span class="hljs-attr">queryKey</span>: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">string</span>[]
  <span class="hljs-attr">initialData</span>: <span class="hljs-title class_">CommonApiRes</span>&lt;T&gt; | <span class="hljs-literal">null</span>
  <span class="hljs-attr">fetcher</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">CommonApiRes</span>&lt;T&gt;&gt;
  <span class="hljs-attr">children</span>: <span class="hljs-function">(<span class="hljs-params">data: T</span>) =&gt;</span> <span class="hljs-title class_">React</span>.<span class="hljs-property">ReactNode</span>
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title class_">DataSection</span>&lt;T&gt;(<span class="hljs-attr">props</span>: <span class="hljs-title class_">Props</span>&lt;T&gt;) {
  <span class="hljs-keyword">const</span> { queryKey, initialData, fetcher, children } = props
  <span class="hljs-comment">// ✅ 服务端渲染路径</span>
  <span class="hljs-keyword">if</span> (initialData !== <span class="hljs-literal">null</span> &amp;&amp; initialData.<span class="hljs-property">code</span> === <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">React.Fragment</span>&gt;</span>
        {children(initialData.res)}
      <span class="hljs-tag">&lt;/<span class="hljs-name">React.Fragment</span>&gt;</span></span>
    )
  }

  <span class="hljs-comment">// ❌ 客户端降级路径</span>
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ClientFallback</span>
      <span class="hljs-attr">queryKey</span>=<span class="hljs-string">{queryKey}</span>
      <span class="hljs-attr">fetcher</span>=<span class="hljs-string">{fetcher}</span>
    &gt;</span>
      {children}
    <span class="hljs-tag">&lt;/<span class="hljs-name">ClientFallback</span>&gt;</span></span>
  )
}

</code></pre>
<ol start="3">
<li>客户端兜底 ClientFallback<br/>
用 React Query 触发浏览器端请求，loading 时展示骨架，拿到数据后复用 children。</li>
</ol>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// src/components/global/DataSection/ClientFallback.tsx</span>

<span class="hljs-string">'use client'</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>

<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Loading</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'../Loading'</span>

<span class="hljs-keyword">import</span> { useServerData } <span class="hljs-keyword">from</span> <span class="hljs-string">'./useServerData'</span>

<span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> { <span class="hljs-title class_">CommonApiRes</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/lib/service/type'</span>

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Props</span>&lt;T&gt; {
  <span class="hljs-attr">queryKey</span>: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">string</span>[]
  <span class="hljs-attr">fetcher</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">CommonApiRes</span>&lt;T&gt;&gt;
  <span class="hljs-attr">children</span>: <span class="hljs-function">(<span class="hljs-params">data: T</span>) =&gt;</span> <span class="hljs-title class_">React</span>.<span class="hljs-property">ReactNode</span>
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title class_">ClientFallback</span>&lt;T&gt;(<span class="hljs-attr">props</span>: <span class="hljs-title class_">Props</span>&lt;T&gt;) {
  <span class="hljs-keyword">const</span> { queryKey, fetcher, children } = props

  <span class="hljs-keyword">const</span> { data, loading, ...rest } = <span class="hljs-title function_">useServerData</span>(
    queryKey,
    <span class="hljs-literal">null</span>,
    fetcher
  )

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">React.Fragment</span> &gt;</span>
      {loading &amp;&amp; <span class="hljs-tag">&lt;<span class="hljs-name">Loading</span> /&gt;</span>}
      {data &amp;&amp; children(data)}
    <span class="hljs-tag">&lt;/<span class="hljs-name">React.Fragment</span>&gt;</span></span>
  )
}
</code></pre>
<ol start="4">
<li>Hook 细节<br/>
useServerData 包装 useQuery，控制启用与重试。</li>
</ol>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// src/components/global/DataSection/useServerData.ts </span>
<span class="hljs-keyword">import</span> { useQuery, <span class="hljs-keyword">type</span> <span class="hljs-title class_">UseQueryOptions</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"@tanstack/react-query"</span>

<span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> { <span class="hljs-title class_">CommonApiRes</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"@/lib/service/type"</span>

<span class="hljs-keyword">type</span> <span class="hljs-title class_">UseServerDataOptions</span>&lt;T&gt; = <span class="hljs-title class_">Omit</span>&lt;<span class="hljs-title class_">UseQueryOptions</span>&lt;T, <span class="hljs-title class_">Error</span>&gt;, <span class="hljs-string">"queryKey"</span> | <span class="hljs-string">"queryFn"</span>&gt;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> useServerData&lt;T&gt;(
  <span class="hljs-attr">queryKey</span>: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">string</span>[],
  <span class="hljs-attr">initialData</span>: <span class="hljs-title class_">CommonApiRes</span>&lt;T&gt; | <span class="hljs-literal">null</span>,
  <span class="hljs-attr">fetcher</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">CommonApiRes</span>&lt;T&gt;&gt;,
  options?: <span class="hljs-title class_">UseServerDataOptions</span>&lt;<span class="hljs-title class_">CommonApiRes</span>&lt;T&gt;&gt;
) {
  <span class="hljs-keyword">const</span> key = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(queryKey) ? queryKey : [queryKey]

  <span class="hljs-keyword">const</span> query = useQuery&lt;<span class="hljs-title class_">CommonApiRes</span>&lt;T&gt;, <span class="hljs-title class_">Error</span>&gt;({
    <span class="hljs-attr">queryKey</span>: key,
    <span class="hljs-attr">queryFn</span>: fetcher,
    <span class="hljs-attr">enabled</span>: initialData === <span class="hljs-literal">null</span>,
    <span class="hljs-attr">initialData</span>: initialData ?? <span class="hljs-literal">undefined</span>,
    <span class="hljs-attr">staleTime</span>: initialData ? <span class="hljs-number">0</span> : <span class="hljs-number">5</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>,
    <span class="hljs-attr">retry</span>: <span class="hljs-number">3</span>,
    <span class="hljs-attr">retryDelay</span>: <span class="hljs-function"><span class="hljs-params">attemptIndex</span> =&gt;</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(<span class="hljs-number">1000</span> * <span class="hljs-number">2</span> ** attemptIndex, <span class="hljs-number">30000</span>),
    ...options,
  })

  <span class="hljs-keyword">return</span> {
    ...query,
    <span class="hljs-attr">data</span>: query.<span class="hljs-property">data</span>?.<span class="hljs-property">res</span> ?? <span class="hljs-literal">null</span>,
    <span class="hljs-attr">loading</span>: query.<span class="hljs-property">isLoading</span>,
    <span class="hljs-attr">error</span>: query.<span class="hljs-property">error</span>,
    <span class="hljs-attr">refetch</span>: query.<span class="hljs-property">refetch</span>,
    <span class="hljs-attr">isRefetching</span>: query.<span class="hljs-property">isRefetching</span>,
  }
}
</code></pre>
<ol>
<li>实际落地<br/>
在兑换商店页 src/app/act/(1st)/exchange-store/page.tsx 同时传入服务端结果和客户端 fetcher。</li>
</ol>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">exchangeRes</span> = await ExchangeStoreApi.getExchangeList()

&lt;DataSection
  <span class="hljs-attr">queryKey</span>=<span class="hljs-string">"exchange-list"</span>
  <span class="hljs-attr">initialData</span>={exchangeRes}
  <span class="hljs-attr">fetcher</span>={() =&gt; ExchangeStoreClientApi.getExchangeList()}&gt;
  {<span class="hljs-attr">data</span> =&gt; &lt;p className=<span class="hljs-string">"text-[38px] text-white"</span>&gt;{data?.carnivalNum || <span class="hljs-number">0</span>}&lt;/p&gt;}
&lt;/DataSection&gt;

</code></pre>
<p>SSR 成功则直出；失败则客户端重试并显示 loading。</p>
<h3 data-id="heading-4">解决了什么</h3>
<ul>
<li>服务端 fetch 失败不再直接抛出错误页面，可回退到客户端请求 <strong>(实际场景：我的项目前期的接口是需要token，所以只能从app通过bridge获取token，导致接口部分只能是客户端渲染，后期改了可以服务端渲染，但是需要更新app版本,这样就存在版本兼容问题)。</strong></li>
</ul>
<h3 data-id="heading-5">为什么方案不行（遗留与限制）</h3>
<ul>
<li>请求成本、水合不一致、不通过safeFetch返回null导致SSR抛错等等其他问题，这些其实可以解决。组件实现里最主要的问题是函数不能序列化传递的问题，如果我想保持这样的写法的话（主要这种写法是比较优雅了、工作量少，不用单独处理），这里最难处理的是children通过传递data问题，但是这个问题我目前没有思考到好的方式</li>
</ul>
<pre><code class="hljs language-ini" lang="ini">&lt;DataSection
  ...
  <span class="hljs-attr">fetcher</span>={() =&gt; ExchangeStoreClientApi.getExchangeList()}&gt;
  {<span class="hljs-attr">data</span> =&gt; (
    &lt;p <span class="hljs-attr">className</span>=<span class="hljs-string">"text-[38px] text-white"</span>&gt;{data?.carnivalNum || <span class="hljs-number">0</span>}&lt;/p&gt;
  )}
&lt;/DataSection&gt;
</code></pre>
<h3 data-id="heading-6">解决方案</h3>
<p>解决方案其实有一些，尝试过很多</p>
<p>fetch方面，比如我写一个fetchMap+注册表，这样就可以不传，但是也只是解决了fetch，data =&gt; 只能在客户端</p>
<p>比如在包一层DataSectionWrapper,use client组件，但是弊端就是如果SSR成功，原本SSR的dom全部变成client的dom，丢失了框架的优势</p>
<p>在比如为每一个涉及接口的组件单独写一个Render Wapper，去判断返回成功or失败，对应渲染，但是这样工作量其实很大</p>
<h3 data-id="heading-7">小结</h3>
<p>还在想解决方法</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[uni-app 上架 iOS，并不是卡在技术，而是卡在流程理解]]></title>    <link>https://juejin.cn/post/7584266920640610355</link>    <guid>https://juejin.cn/post/7584266920640610355</guid>    <pubDate>2025-12-16T09:15:14.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584266920640610355" data-draft-id="7584244431869509659" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="uni-app 上架 iOS，并不是卡在技术，而是卡在流程理解"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2025-12-16T09:15:14.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="aiopencode"/> <meta itemprop="url" content="https://juejin.cn/user/1898230261493865"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            uni-app 上架 iOS，并不是卡在技术，而是卡在流程理解
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1898230261493865/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    aiopencode
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-16T09:15:14.000Z" title="Tue Dec 16 2025 09:15:14 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-16
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在 uni-app 项目里，开发阶段通常推进得很快。
页面、接口、逻辑验证都跑通之后，很多团队会产生一种错觉：<strong>上架只是最后一步的“提交动作”</strong>。</p>
<p>我第一次负责 uni-app 项目的 iOS 上架时，也有类似预期。真正开始操作之后才意识到，uni-app 并没有改变 iOS 上架的底层规则，它只是把代码层面的复杂度隐藏了，而证书、Bundle ID、描述文件、IPA 校验这些问题，一个都不会少。</p>
<hr/>
<h2 data-id="heading-0"><strong>uni-app 项目在上架前，其实已经隐含了很多假设</strong></h2>
<p>uni-app 的构建工具帮我们做了很多事，例如生成 Xcode 工程、处理资源目录、封装 WebView。但它并不会替你判断：</p>
<ul>
<li>当前 Bundle ID 是否已经存在</li>
<li>使用的是开发证书还是发布证书</li>
<li>构建出来的 IPA 是否真的“适合上架”</li>
</ul>
<p>在最初的项目中，我遇到的第一个问题并不是构建失败，而是 <strong>不知道自己正在用什么身份上架</strong>。</p>
<hr/>
<h2 data-id="heading-1"><strong>Bundle ID 在 uni-app 项目里很容易被忽略</strong></h2>
<p>在 HBuilderX 里填写 Bundle ID 的时候，它看起来只是一个配置项。但一旦进入 Apple 的体系，这个字符串会同时影响：</p>
<ul>
<li>证书是否可用</li>
<li>描述文件是否匹配</li>
<li>App Store Connect 是否接受构建</li>
</ul>
<p>我后来养成的习惯是：
在准备上架之前，先确认账号里到底已经有哪些 Bundle ID，而不是直接“假设还没有”。</p>
<p>在 Windows 环境下，我通常会用 <strong>开心上架（Appuploader）查看账号内的 Bundle ID 列表</strong>，主要目的是：</p>
<ul>
<li>避免和历史项目冲突</li>
<li>确认是否需要新建</li>
<li>明确当前 uni-app 项目对应的唯一身份
<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/84e3a9a994db43e1ba917f355602da09~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgYWlvcGVuY29kZQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766481314&amp;x-signature=EpFjlutcfCpQ6rHJ1gBO6NeI4Hk%3D" alt="bid查看" loading="lazy"/></li>
</ul>
<p>这个动作并不复杂，但它能提前避免很多“看起来像证书问题”的后续麻烦。</p>
<hr/>
<h2 data-id="heading-2"><strong>证书问题在 uni-app 项目里，往往暴露得更晚</strong></h2>
<p>很多 uni-app 项目并不直接操作 Xcode，也很少接触钥匙串。
结果就是：证书一旦出问题，排查成本会明显放大。</p>
<p>我遇到过的典型情况包括：</p>
<ul>
<li>构建能成功，但上传被拒</li>
<li>IPA 能安装，但无法提交 TestFlight</li>
<li>描述文件下载了，但不知道它绑定了哪个证书</li>
</ul>
<p>在这些情况下，仅仅“重新生成证书”往往不是最优解。</p>
<p>在一些项目中，我开始直接用 <strong>Appuploader 创建 iOS 证书</strong>，原因并不是为了绕过 Mac，而是：</p>
<ul>
<li>证书生成过程更明确</li>
<li>证书文件可以直接交给构建节点</li>
<li>不需要依赖某一台 Mac 的钥匙串状态
<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5ef652098fb74a6aa14bb44fe674a9cf~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgYWlvcGVuY29kZQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766481314&amp;x-signature=f%2BlEjIQfX1qhn9a87otJtC0YMdw%3D" alt="证书生成" loading="lazy"/></li>
</ul>
<p>这样做之后，证书不再是“某个人电脑里的东西”，而是工程的一部分。</p>
<hr/>
<h2 data-id="heading-3"><strong>描述文件是 uni-app 上架里最容易被误用的文件</strong></h2>
<p>描述文件的问题，通常不会在构建阶段报错，而是在上传或审核阶段出现。</p>
<p>有一次项目卡了整整一天，最后发现只是 <strong>IPA 里带的是开发描述文件</strong>。
构建没问题、安装没问题，但就是上不了架。</p>
<p>从那之后，我在 uni-app 项目里都会做一件事：
<strong>在上传前，主动看一眼描述文件的内容。</strong></p>
<p>通过 <strong>Appuploader 查看 mobileprovision 文件</strong>，可以直接确认：</p>
<ul>
<li>它是开发还是发布类型</li>
<li>绑定的是哪个 Bundle ID</li>
<li>使用的是哪一个证书
<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3f447b48e95d42b4a14262a238460705~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgYWlvcGVuY29kZQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766481314&amp;x-signature=vMmqB1M8IH5zq4ZltgqdjT%2B1EQc%3D" alt="查看文件" loading="lazy"/></li>
</ul>
<p>这个动作不依赖 Xcode，也不依赖 macOS，对 Windows 团队尤其重要。</p>
<hr/>
<h2 data-id="heading-4"><strong>IPA 不是“黑盒”，但很多团队把它当黑盒</strong></h2>
<p>uni-app 构建出来的 IPA，本质上仍然是一个标准的 iOS 应用包。
但在很多项目里，它只被当作“上传用文件”，而不是一个可以被检查的工程产物。</p>
<p>我在 uni-app 上架中遇到过的问题包括：</p>
<ul>
<li>Bundle ID 在工程配置里是对的，但 IPA 里不一致</li>
<li>图标资源缺失，审核阶段才被指出</li>
<li>Info.plist 权限说明不完整</li>
</ul>
<p>这些问题如果能在上传前发现，代价会小得多。</p>
<p>在 Windows 上，我通常会用 <strong>Appuploader 查看 IPA 内容</strong>，重点关注：</p>
<ul>
<li><code>CFBundleIdentifier</code></li>
<li>是否携带了正确的 mobileprovision</li>
<li>基础资源是否存在</li>
</ul>
<p>这个步骤让 uni-app 上架不再完全依赖“构建结果是否报错”。</p>
<hr/>
<h2 data-id="heading-5"><strong>uni-app 项目里，上架上传这一环最容易被忽视</strong></h2>
<p>uni-app 的开发者往往不太关心“用什么工具上传 IPA”，因为这一步通常被认为是工具自带的。</p>
<p>但在跨平台团队里，这个假设并不成立。</p>
<p>当构建发生在云端或 CI，而团队成员主要使用 Windows 时，Xcode 和 Transporter 就不再是一个稳定选项。</p>
<p>在这些项目中，我使用 <strong>开心上架（Appuploader）提供的上传方式</strong>，原因很简单：</p>
<ul>
<li>可以在 Windows 上执行</li>
<li>上传动作可脚本化</li>
<li>构建和上传职责可以分离</li>
</ul>
<p>例如：</p>
<pre><code class="hljs language-bash" lang="bash">appuploader_cli -u appleid@example.com -p xxxx-xxxx -c 1 -f app.ipa
</code></pre>
<p>这并没有改变苹果的审核规则，但它改变了 <strong>uni-app 项目内部的协作方式</strong>。
GUI界面：
<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7ca6df1ce1724ac49ad35b7277075a85~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgYWlvcGVuY29kZQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766481314&amp;x-signature=5Pc38v1iZnCKiKBHM0MyB%2BwJ0yo%3D" alt="ipa上传" loading="lazy"/></p>
<hr/>
<h2 data-id="heading-6"><strong>uni-app 上架顺利，往往不是因为“工具选对了”</strong></h2>
<p>回头看这些经历，会发现 uni-app 上架顺利与否，很少取决于某一个工具，而更多取决于：</p>
<ul>
<li>是否清楚 Bundle ID 的实际作用</li>
<li>是否知道证书和描述文件在用哪一套</li>
<li>是否在上传前真正检查过 IPA</li>
<li>是否把上架当成工程流程，而不是提交动作</li>
</ul>
<hr/>
<p>uni-app 让开发变快了，但它不会替你理解 iOS 上架。
当团队主要工作在 Windows 环境，或者构建与上传被拆分时，上架流程如果仍然依赖“某台 Mac 的状态”，就很容易失控。</p>
<p>当我开始把证书、Bundle ID、描述文件、IPA 当成明确的工程对象，而不是工具内部细节时，uni-app 的 iOS 上架才真正稳定下来。</p>
<p>这不是某一次配置的成功，而是一种对流程的重新理解。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[播放器视频后处理实践（二）氛围模式]]></title>    <link>https://juejin.cn/post/7584110439933755438</link>    <guid>https://juejin.cn/post/7584110439933755438</guid>    <pubDate>2025-12-16T09:19:23.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584110439933755438" data-draft-id="7584094504631992329" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="播放器视频后处理实践（二）氛围模式"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2025-12-16T09:19:23.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="百度Geek说"/> <meta itemprop="url" content="https://juejin.cn/user/4186596000416094"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            播放器视频后处理实践（二）氛围模式
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4186596000416094/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    百度Geek说
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-16T09:19:23.000Z" title="Tue Dec 16 2025 09:19:23 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-16
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读10分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">01 前言</h2>
<p>在日常视频播放中，我们经常会遇到这样的问题：视频的长宽比例与设备屏幕不一致，导致画面上下或左右出现黑边。虽然这并不影响视频的正常播放，但从用户体验的角度来看，这些黑边往往打断了视觉的沉浸感，显得格外突兀。</p>
<p>为了解决这一问题，业界主流播放器（如 YouTube、Netflix）引入了一种被称为氛围模式（Ambient Mode）的视觉增强效果。它的核心思路是：</p>
<p>通过实时识别视频画面的主色调，并动态将其填充到黑边区域，使边缘色彩与视频内容保持一致，提升整体视觉统一性，从而营造出与视频内容相协调的氛围效果，让观众的观看体验更加自然和沉浸。</p>
<p>下面是YouTube的氛围模式效果：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/047a991acb3b4a558b0ec276341531e0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55m-5bqmR2Vla-ivtA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766481562&amp;x-signature=IhzK8ll7nF6FPFH%2FWsKu4ZCJz8g%3D" alt="图片" loading="lazy"/></p>
<p>youtube竖屏效果</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/47622cb9be444ec38d26cb0e5730e422~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55m-5bqmR2Vla-ivtA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766481562&amp;x-signature=qMcG0PtCGWtR3zEfXbSKw1KPnYk%3D" alt="图片" loading="lazy"/></p>
<p>youtube横屏效果</p>
<p>百度播放内核团队也将氛围模式效果应用到了视频播放场景，用于提升用户观看视频沉浸感，同时在百度App、好看App两款产品完成上线。本文将详细说明视频场景氛围模式技术方案。</p>
<h2 data-id="heading-1">02 整体技术方案</h2>
<p>氛围模式通过在播放内核视频后处理通道（FilterChain）添加一个AmbientFilter滤镜实现，其核心思路：通过AmbientFilter滤镜先将视频帧数据从GPU下载到CPU，然后将视频帧数据按块进行区域划分，划分完成后再通过颜色量化算法提取每个区域主色调，最后将各个区域主色调传给平台层，平台层拿到主色调进行绘制视频四周氛围效果。整体方案流程大致如下图所示：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/efff8125738a428e9fe6402077c7f7e5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55m-5bqmR2Vla-ivtA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766481562&amp;x-signature=fodAnWu8sTbxeMmqLXeVcSO4bUk%3D" alt="图片" loading="lazy"/></p>
<p>氛围模式整体方案</p>
<h3 data-id="heading-2"><strong>2.1 视频帧采样</strong></h3>
<p>为了提取视频的主色调，需要获取视频帧数据。但提取主色调并不要求每帧都下载，太频繁下载会拖垮应用性能，在视觉上也不会带来特别好的体验。因此我们对视频帧进行采样下载：在 25 FPS 的视频下，每隔约 50 帧（约 2 秒）采集一次帧数据。</p>
<p>同时，为了避免将视频帧数据从 GPU 下载到 CPU 时阻塞渲染线程，我们采取了以下优化：</p>
<p>1. FBO 压缩：先将视频帧渲染到较低分辨率的 FBO（例如将 1080p 压缩到 108p），大幅减少待传输的数据量。</p>
<p>2. PBO 异步传输：利用 PBO 异步将帧数据从 GPU 下载到 CPU，从而避免阻塞主渲染线程。</p>
<p>通过这种方式，我们既能保证主色调提取的效率，又不会影响视频的流畅播放。渲染线程和氛围模式工作线程两个线程工作流程如下图：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0a739c05ac7646188b15eca2426cbe81~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55m-5bqmR2Vla-ivtA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766481562&amp;x-signature=R1VmW%2FDmik70cMxHYHhCuamrBd4%3D" alt="图片" loading="lazy"/></p>
<p>线程核心职责</p>
<h3 data-id="heading-3"><strong>2.2 主色调提取</strong></h3>
<h4 data-id="heading-4">2.2.1 视频帧区域划分</h4>
<p>拿到视频帧数据后，我们先将视频帧划分出几个区域。项目中我们是将视频帧画面划分为：TopLeft, TopCenter, TopRight, BottomLeft, BottomCenter, BottomRight 六个区域，如下图所示：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fced291d707f49509009a28bdbd7681a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55m-5bqmR2Vla-ivtA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766481562&amp;x-signature=m2xwkhlZ2%2Br4QVTYW%2F8cNBFx0ok%3D" alt="图片" loading="lazy"/></p>
<p>视频区域块划分</p>
<p>接下来我们提取出每块区域的主色调。</p>
<h4 data-id="heading-5">2.2.2 提取主色调</h4>
<p>要提取画面主色调，我们是通过颜色量化技术实现的。颜色量化（Color Quantization） 是一种图像处理技术，目的是减少图像中使用的颜色数量，同时尽量保持原图的视觉效果。代表性的颜色量化算法有：</p>
<p>1. 中值切割法（Median Cut）：将颜色空间递归分割成小立方体，取每个立方体的颜色中位数作为调色板颜色。</p>
<p>2. K-means聚类：将颜色按相似性分组，取每组的中心作为调色板颜色。</p>
<p>3. 八叉树算法：通过构建八叉树分层合并颜色，逐层减少叶子节点数量，最终保留高频颜色。</p>
<p>4. 流行色算法（Popularity）：统计原图颜色出现的频率，选取高频颜色作为调色板。</p>
<p>这几种算法从各维度对比情况如下：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c6a49bfda08e4676b52998060b34d477~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55m-5bqmR2Vla-ivtA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766481562&amp;x-signature=kzp47Y%2BHhpx%2BSw0ZOusAET3fW2c%3D" alt="图片" loading="lazy"/></p>
<p>从算法的速度、精度以及实现复杂度等多维度考虑，氛围模式场景我们选用中值切割法完成视频画面主色调的提取。</p>
<h4 data-id="heading-6">2.2.3 中值切割法</h4>
<p>中值切割法（Median Cut）是一种用于图像颜色量化的算法，算法核心思想是将颜色空间递归地分割成更小的区域，以减少图像中颜色数量。该算法的目标是在颜色空间中选择一组代表性的颜色，这些颜色可以用于生成调色板，从而减少图像的颜色数量，同时尽量保留图像的视觉效果。算法核心步骤如下：</p>
<p><strong>1. 初始化颜色盒</strong></p>
<p>a. 首先，将所有颜色视为一个大的颜色盒（即整个颜色空间的一个区域）。</p>
<p>b. 颜色盒包含图像中所有像素的颜色。</p>
<p><strong>2. 选择分割轴</strong></p>
<p>a. 在每次迭代中，选择颜色分量（红、绿、蓝）中范围最大的分量作为分割轴。这是为了最大限度地减少颜色空间的不均匀性。</p>
<p><strong>3. 按中值分割</strong></p>
<p>a. 沿着选定的分割轴，根据颜色值的中值，将颜色盒分成两个较小的盒。</p>
<p>b. 这种方法确保每个新盒子中包含的颜色数量尽可能相等。</p>
<p><strong>4. 递归分割</strong></p>
<p>a. 对每个新的颜色盒重复步骤2和3，直到达到所需的颜色盒数量（通常是所需调色板的大小）。</p>
<p><strong>5. 生成调色板</strong></p>
<p>a. 一旦颜色盒的数量达到预期的数量，对每个盒子计算平均颜色或中值颜色，将其作为代表颜色添加到调色板中。</p>
<p><strong>6. 颜色映射</strong></p>
<p>a. 使用生成的调色板，重新映射原始图像中的每个像素到最接近的调色板颜色。</p>
<p>中值切割算法核心流程如下图：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/17ff6df1c48249829968465058be3946~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55m-5bqmR2Vla-ivtA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766481562&amp;x-signature=%2BLU9VtAbxchwlbb1radhJ9qpW%2B0%3D" alt="图片" loading="lazy"/></p>
<p>中值切割算法</p>
<h2 data-id="heading-7">03 平台渲染氛围效果</h2>
<p>当native层提取完视频帧各区域主色调后，将色值传给平台层（Android/iOS）。平台层收到色值后，将色值渲染到视频四周以产生氛围效果。为保证各个区域色值过渡自然，以及前后两帧的色值平滑过渡，需要借助平台层渐变、动画、rgb插值等技术实现。 下面结合Android和iOS两个平台分别介绍具体思路。</p>
<h3 data-id="heading-8"><strong>3.1 Android平台</strong></h3>
<p>Android 使用自定义view技术，完成氛围色值的渲染。我们提供一个自定义view名为AmbientView 来完成这个功能。有了AmbientView之后，布局结构大致如下：</p>
<pre><code class="hljs language-ini" lang="ini">&lt;FrameLayout
    android:<span class="hljs-attr">layout_width</span>=<span class="hljs-string">"match_parent"</span>
    android:<span class="hljs-attr">layout_height</span>=<span class="hljs-string">"match_parent"</span>
    android:<span class="hljs-attr">layout_gravity</span>=<span class="hljs-string">"center"</span>&gt;
        &lt;com.baidu.cyberplayer.sdk.AmbientView
            android:<span class="hljs-attr">id</span>=<span class="hljs-string">"@+id/left_ambient"</span>
            android:<span class="hljs-attr">layout_width</span>=<span class="hljs-string">"xxxdp"</span>
            android:<span class="hljs-attr">layout_height</span>=<span class="hljs-string">"match_parent"</span>/&gt;
        &lt;FrameLayout
            android:<span class="hljs-attr">id</span>=<span class="hljs-string">"@+id/video_container"</span>
            android:<span class="hljs-attr">layout_width</span>=<span class="hljs-string">"wrap_content"</span>
            android:<span class="hljs-attr">layout_height</span>=<span class="hljs-string">"wrap_content"</span>/&gt;
        &lt;com.baidu.cyberplayer.sdk.AmbientView
            android:<span class="hljs-attr">id</span>=<span class="hljs-string">"@+id/right_ambient"</span>
            android:<span class="hljs-attr">layout_width</span>=<span class="hljs-string">"xxxdp"</span>
            android:<span class="hljs-attr">layout_height</span>=<span class="hljs-string">"match_parent"</span>/&gt;
&lt;/FrameLayout&gt;

</code></pre>
<p>上面为视频横屏下布局大致情况，id为video_container的FrameLayout是播放器容器，在播放器容器左右各摆放一个AmbientView渲染氛围模式，AmbientView的宽度会根据播放器的尺寸的变化在代码中动态调整。</p>
<p>AmbientView核心功能：</p>
<p>1. 相邻区域的主色调，使用LinearGradient拉出线形渐变。对于横屏视频，我们渐变方向就是从上至下。所以更新氛围色值的代码如下：</p>
<pre><code class="hljs language-scss" lang="scss">private void <span class="hljs-built_in">updateGradient</span>() {
    mLinearGradient = new <span class="hljs-built_in">LinearGradient</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, getHeight(),
                        mColors, null, Shader<span class="hljs-selector-class">.TileMode</span><span class="hljs-selector-class">.CLAMP</span>);
    mPaint<span class="hljs-selector-class">.setShader</span>(mLinearGradient);
    <span class="hljs-built_in">invalidate</span>();
}

</code></pre>
<p>2. 前后两帧氛围色值的切换，为了颜色切换不显得生硬，我们借助Android属性动画以及RGB插值实现色值缓慢渐变效果，核心代码如下：</p>
<pre><code class="hljs language-ini" lang="ini">private void startColorAnimator() {
    int<span class="hljs-section">[]</span> <span class="hljs-attr">lastColors</span> = new int[mLastColors.length]<span class="hljs-comment">;</span>
    for (int <span class="hljs-attr">i</span> = <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; lastColors.length; i++) {</span>
        lastColors<span class="hljs-section">[i]</span> = mLastColors<span class="hljs-section">[i]</span><span class="hljs-comment">;</span>
    }

    <span class="hljs-attr">mColorAnimator</span> = ValueAnimator.<span class="hljs-literal">ofF</span>loat(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>f)<span class="hljs-comment">;</span>
    mColorAnimator.setDuration(1500)<span class="hljs-comment">;</span>
    mColorAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
        @Override
        public void onAnimationUpdate(@NonNull ValueAnimator valueAnimator) {
            float <span class="hljs-attr">progress</span> = (float) valueAnimator.getAnimatedValue()<span class="hljs-comment">;</span>
            interpolateColors(progress, lastColors)<span class="hljs-comment">;</span>
            updateGradient()<span class="hljs-comment">;</span>
        }
    })<span class="hljs-comment">;</span>
    mColorAnimator.start()<span class="hljs-comment">;</span>
}

/**
 * 插值计算color
 */
private void interpolateColors(float progress, int<span class="hljs-section">[]</span> lastColors) {
    if (<span class="hljs-attr">mCurColors</span> == null || mCurColors.length &lt;= <span class="hljs-number">0</span>) {
        return<span class="hljs-comment">;</span>
    }

    ArgbEvaluator <span class="hljs-attr">evaluator</span> = new ArgbEvaluator()<span class="hljs-comment">;</span>
    for (int <span class="hljs-attr">i</span> = <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; mCurColors.length; i++) {</span>
        mColors<span class="hljs-section">[i]</span> = (int) evaluator.evaluate(progress, lastColors<span class="hljs-section">[i]</span>, mCurColors<span class="hljs-section">[i]</span>)<span class="hljs-comment">;</span>
    }
}

</code></pre>
<p>mColorAnimator是一个ValueAnimator对象，通过ValueAnimator我们创建一个1500ms的动画，在动画的更新函数里面，我们调用了interpolateColors，这个方法内部就是用ArgbEvaluator完成RGB颜色插值，更新到mColors数组中。最后调用updateGradient方法触发AmbientView重绘。</p>
<p>3. 渐变遮罩：最后我们还要在上面添加一层黑色渐变遮罩，保证氛围区域不要太突兀，以免过度吸引用户眼球，导致用户注意力不在视频内容本身上面。黑色遮罩实现也非常简单，代码如下所示：</p>
<pre><code class="hljs language-ini" lang="ini">float<span class="hljs-section">[]</span> <span class="hljs-attr">mPositions</span> = {<span class="hljs-number">0.0</span>f, <span class="hljs-number">1.0</span>f}<span class="hljs-comment">;</span>
int<span class="hljs-section">[]</span> <span class="hljs-attr">mMaskColors</span> = {<span class="hljs-number">0</span>x88000000, <span class="hljs-number">0</span>xff000000}<span class="hljs-comment">;</span>
// 从左到右渐变
<span class="hljs-attr">mMaskLinearGradient</span> = new LinearGradient(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, getWidth(), <span class="hljs-number">0</span>,
                            mMaskColors, mPositions, Shader.TileMode.CLAMP)<span class="hljs-comment">;</span>
mMaskPaint.setShader(mMaskLinearGradient)<span class="hljs-comment">;</span>
// 绘制黑色渐变蒙层
canvas.drawRect(0, 0, getWidth(), getHeight(), mMaskPaint)<span class="hljs-comment">;</span>

</code></pre>
<h3 data-id="heading-9"><strong>3.2  iOS平台</strong></h3>
<p>iOS端同样提供了一个自定义的 AmbientView（氛围视图），为视频播放场景提供动态渐变背景和遮罩效果，增强视觉沉浸感。</p>
<p>1. 双图层架构设计：采用主渐变层与遮罩层分离的架构方案，确保色彩渲染与边缘遮罩效果互不干扰，提升整体渲染效率。</p>
<pre><code class="hljs language-ini" lang="ini">- (void)setupSubLayers {
    <span class="hljs-attr">_gradientLayer</span> = [CAGradientLayer layer]<span class="hljs-comment">;</span>
    <span class="hljs-attr">_gradientLayer.frame</span> = self.bounds<span class="hljs-comment">;</span>
    <span class="hljs-section">[self.layer addSublayer:_gradientLayer]</span><span class="hljs-comment">;</span>

    <span class="hljs-attr">_maskLayer</span> = [CAGradientLayer layer]<span class="hljs-comment">;</span>
    <span class="hljs-attr">_maskLayer.frame</span> = self.bounds<span class="hljs-comment">;</span>
    <span class="hljs-section">[self.layer addSublayer:_maskLayer]</span><span class="hljs-comment">;</span>
}

</code></pre>
<p>2. 流畅动画引擎：基于CADisplayLink构建动画循环，通过实时颜色插值计算，实现细腻流畅的色彩过渡效果。</p>
<pre><code class="hljs language-ini" lang="ini">- (void)startAnimation {
    // 核心功能代码
    <span class="hljs-attr">self.displayLink</span> = [CADisplayLink displayLinkWithTarget:self selector:@selector(updateColors)]<span class="hljs-comment">;</span>
    <span class="hljs-section">[self.displayLink addToRunLoop:[NSRunLoop mainRunLoop]</span> forMode:NSRunLoopCommonModes]<span class="hljs-comment">;</span>
}

- (void)updateColors {
    CGFloat <span class="hljs-attr">progress</span> = MIN(<span class="hljs-number">1.0</span>, (CACurrentMediaTime() - self.startTime) / self.animationDuration)<span class="hljs-comment">;</span>
    NSMutableArray *<span class="hljs-attr">interpolated</span> = [NSMutableArray array]<span class="hljs-comment">;</span>
    for (NSUInteger <span class="hljs-attr">i</span> = <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; self.endColors.count; i++) {</span>
        UIColor *<span class="hljs-attr">from</span> = i &lt; self.startColors.count ? self.startColors[i] : [UIColor clearColor]<span class="hljs-comment">;</span>
        UIColor *<span class="hljs-attr">to</span> = self.endColors[i]<span class="hljs-comment">;</span>
        <span class="hljs-section">[interpolated addObject:(__bridge id)[self interpolateFrom:from to:to progress:progress]</span>.CGColor]<span class="hljs-comment">;</span>
    }
    <span class="hljs-attr">_gradientLayer.colors</span> = interpolated<span class="hljs-comment">;</span>
}

- (UIColor *)interpolateFrom:(UIColor *)from to:(UIColor *)to progress:(CGFloat)progress {
    CGFloat fr, fg, fb, fa, tr, tg, tb, ta<span class="hljs-comment">;</span>
    <span class="hljs-section">[from getRed:&amp;fr green:&amp;fg blue:&amp;fb alpha:&amp;fa]</span><span class="hljs-comment">;</span>
    <span class="hljs-section">[to getRed:&amp;tr green:&amp;tg blue:&amp;tb alpha:&amp;ta]</span><span class="hljs-comment">;</span>
    return <span class="hljs-section">[UIColor colorWithRed:fr + (tr - fr) * progress
                           green:fg + (tg - fg) * progress
                            blue:fb + (tb - fb) * progress
                           alpha:fa + (ta - fa) * progress]</span><span class="hljs-comment">;</span>
}

</code></pre>
<p>3. 渐变遮罩：采用多段式渐变遮罩配合加速曲线算法，打造自然的边缘过渡，有效增强视觉层次感。</p>
<pre><code class="hljs language-ini" lang="ini">- (void)makeMaskColorsAndLocations {
    const NSInteger <span class="hljs-attr">steps</span> = <span class="hljs-number">6</span><span class="hljs-comment">;</span>
    for (NSInteger <span class="hljs-attr">i</span> = <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; steps; i++) {</span>
        CGFloat <span class="hljs-attr">t</span> = (CGFloat)i / (steps - <span class="hljs-number">1</span>)<span class="hljs-comment">;</span>
        CGFloat <span class="hljs-attr">acceleratedT</span> = t * t<span class="hljs-comment">;</span>
        CGFloat <span class="hljs-attr">currentAlpha</span> = a + (<span class="hljs-number">1.0</span> - a) * acceleratedT<span class="hljs-comment">;</span>

        UIColor *<span class="hljs-attr">color</span> = [UIColor colorWithRed:r green:g blue:b alpha:currentAlpha]<span class="hljs-comment">;</span>
        <span class="hljs-section">[_maskColors addObject:(__bridge id)color.CGColor]</span><span class="hljs-comment">;</span>
        <span class="hljs-section">[_maskColorsLocations addObject:@(t)]</span><span class="hljs-comment">;</span>
    }
    <span class="hljs-attr">_maskLayer.colors</span> = _maskColors<span class="hljs-comment">;</span>
    <span class="hljs-attr">_maskLayer.locations</span> = _maskColorsLocations<span class="hljs-comment">;</span>
    <span class="hljs-attr">_maskLayer.startPoint</span> = CGPointMake(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<span class="hljs-comment">;</span>
    <span class="hljs-attr">_maskLayer.endPoint</span> = CGPointMake(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)<span class="hljs-comment">;</span>
}

</code></pre>
<p>该实现确保了氛围渲染的高性能和优美视觉效果，为用户提供了沉浸式的观看体验。</p>
<h2 data-id="heading-10">04 效果展示</h2>
<p>氛围模式已在百度内包括百度App和好看App两款App完成上线，其中百度App主要集中在搜索三方影视场景，好看App所有视频横屏场景（排除广告视频）。同时在视频观看时长、分发、完播率等UBS指标取得了正向收益，说明氛围模式给用户带来了不错的沉浸式观影体验。</p>
<p>下面是百度App和好看App效果展示：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7b2cac248a8241519c544f37d741908b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55m-5bqmR2Vla-ivtA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766481562&amp;x-signature=FSGBL8zPM08006qKnl%2FcTGuggqg%3D" alt="图片" loading="lazy"/></p>
<p>百度App氛围模式</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/823557021bd1475aa4c2d20289cc5d6d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55m-5bqmR2Vla-ivtA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766481562&amp;x-signature=p0h7JvMuUXNXHlJCqjydfuVoLGY%3D" alt="图片" loading="lazy"/></p>
<p>好看App氛围模式</p>
<h2 data-id="heading-11"><strong><strong><strong>5. 总结</strong></strong></strong></h2>
<p>氛围模式是一种视觉增强功能，通过技术手段有效解决了视频比例不匹配导致的黑边问题，显著提升了用户视觉体验，主要表现在如下几个方面：</p>
<p>1. 视觉沉浸：氛围模式通过在视频周围添加柔和的背景颜色，使屏幕的边缘与视频内容更好地融合。这种设计使得用户在观看视频时感觉更加沉浸，减少了视频与周围环境之间的视觉割裂</p>
<p>2. 舒适观看：这种模式可以减少长时间观看视频时的眼睛疲劳。通过在视频周围使用柔和的色彩过渡，可以缓解亮度差异带来的视觉刺激，从而提高观看舒适度。</p>
<p>3. 提升观感：氛围模式通过智能地调整背景色彩，使其与视频中的主要色调相匹配，提升整体观感。这使得视频内容更加突出，同时为观看者提供一种更为和谐的视觉体验。</p>
<p>通过本文介绍的技术方案，开发者可以实现类似主流视频平台的高质量氛围模式效果，为用户带来更加沉浸的观看体验。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Java后端进阶：处理多数据源聚合API —— 以天远小微企业报告为例]]></title>    <link>https://juejin.cn/post/7584273076645478406</link>    <guid>https://juejin.cn/post/7584273076645478406</guid>    <pubDate>2025-12-16T09:21:34.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584273076645478406" data-draft-id="7584057497206980651" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Java后端进阶：处理多数据源聚合API —— 以天远小微企业报告为例"/> <meta itemprop="keywords" content="API,大数据"/> <meta itemprop="datePublished" content="2025-12-16T09:21:34.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="天远API"/> <meta itemprop="url" content="https://juejin.cn/user/195070305779163"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Java后端进阶：处理多数据源聚合API —— 以天远小微企业报告为例
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/195070305779163/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    天远API
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-16T09:21:34.000Z" title="Tue Dec 16 2025 09:21:34 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-16
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">一、用 Java 构建“公私联动”的信贷审批中台</h2>
<p>在商业银行与供应链金融的信贷系统中，<strong>小微企业贷</strong>（SME Loan）的风控逻辑最为复杂。它要求系统既要像查企业一样核验工商司法信息，又要像查个人一样评估企业主（法人）的偿债能力。</p>
<p><strong>天远API</strong> 的“全能小微企业报告”（COMBQN13），通过单一接口聚合了 <strong>QYGL3F8E（人企关系）</strong> 、<strong>JRZQ7F1A（全景雷达）</strong> 、<strong>JRZQ8A2D（特殊名单）</strong> 和 <strong>FLXG7E8F（司法涉诉）</strong> 四大核心产品 111。这种“一包四查”的设计极大降低了网络交互频次，但也给 Java 后端带来了挑战：如何将接口返回的异构 <code>JSON Array</code> 解析为标准的 Java 对象，以便输入到 Drools 或 EasyRules 等规则引擎中？</p>
<p>本文将提供一套完整的 Java 解决方案，涵盖 <strong>AES 加密工具类</strong>、<strong>组合响应的 POJO 映射策略</strong> 以及 <strong>核心风控指标的提取逻辑</strong>，助力开发者构建高健壮性的小微风控服务。</p>
<h2 data-id="heading-1">二、API接口调用示例（Java版）</h2>
<p>本接口采用标准的 AES-128-CBC 加密。由于请求参数涉及 <code>authorized</code>（授权书状态），请确保在业务流程中已留存用户的电子签名或授权日志。</p>
<h3 data-id="heading-2">1. 接口配置概览</h3>
<ul>
<li><strong>服务地址</strong>：<code>https://api.tianyuanapi.com/api/v1/COMBQN13</code> 2</li>
<li><strong>请求方式</strong>：POST</li>
<li><strong>鉴权</strong>：Header (<code>Access-Id</code>) + Body (<code>data</code> 密文)</li>
<li><strong>数据特点</strong>：响应体包含一个 <code>responses</code> 数组，每个元素对应一个子产品 3。</li>
</ul>
<h3 data-id="heading-3">2. Java 完整接入代码</h3>
<p>为了处理聚合响应，本示例定义了一个 <code>SmeRiskService</code> 类。我们使用 Jackson 的 <code>JsonNode</code> 来灵活处理不同子产品的 <code>data</code> 结构，避免定义过于庞大的实体类。</p>
<p>Java</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">import</span> com.fasterxml.jackson.databind.JsonNode;
<span class="hljs-keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;
<span class="hljs-keyword">import</span> com.fasterxml.jackson.databind.node.ArrayNode;

<span class="hljs-keyword">import</span> javax.crypto.Cipher;
<span class="hljs-keyword">import</span> javax.crypto.spec.IvParameterSpec;
<span class="hljs-keyword">import</span> javax.crypto.spec.SecretKeySpec;
<span class="hljs-keyword">import</span> java.io.BufferedReader;
<span class="hljs-keyword">import</span> java.io.InputStreamReader;
<span class="hljs-keyword">import</span> java.io.OutputStream;
<span class="hljs-keyword">import</span> java.net.HttpURLConnection;
<span class="hljs-keyword">import</span> java.net.URL;
<span class="hljs-keyword">import</span> java.nio.charset.StandardCharsets;
<span class="hljs-keyword">import</span> java.security.SecureRandom;
<span class="hljs-keyword">import</span> java.util.Base64;
<span class="hljs-keyword">import</span> java.util.HashMap;
<span class="hljs-keyword">import</span> java.util.Map;

<span class="hljs-comment">/**
 * 天远小微企业全能报告 API 服务
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SmeRiskService</span> {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">API_URL</span> <span class="hljs-operator">=</span> <span class="hljs-string">"&lt;https://api.tianyuanapi.com/api/v1/COMBQN13&gt;"</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ACCESS_ID</span> <span class="hljs-operator">=</span> <span class="hljs-string">"YOUR_ACCESS_ID"</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ACCESS_KEY</span> <span class="hljs-operator">=</span> <span class="hljs-string">"YOUR_ACCESS_KEY_HEX"</span>; <span class="hljs-comment">// 16字节 Hex</span>

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 1. 发起聚合查询</span>
            <span class="hljs-type">SmeRiskSummary</span> <span class="hljs-variable">summary</span> <span class="hljs-operator">=</span> querySmeReport(<span class="hljs-string">"张三"</span>, <span class="hljs-string">"110101199001011234"</span>, <span class="hljs-string">"13800138000"</span>);

            <span class="hljs-keyword">if</span> (summary != <span class="hljs-literal">null</span>) {
                System.out.println(<span class="hljs-string">"=== 小微企业主风险摘要 ==="</span>);
                System.out.println(<span class="hljs-string">"关联企业: "</span> + summary.getCompanyName());
                System.out.println(<span class="hljs-string">"经营状态: "</span> + summary.getRegStatus());
                System.out.println(<span class="hljs-string">"个人借贷行为分: "</span> + summary.getLoanBehaviorScore());
                System.out.println(<span class="hljs-string">"近半年逾期金额: "</span> + summary.getOverdueAmount6M());
                System.out.println(<span class="hljs-string">"涉诉未结案数: "</span> + summary.getOpenLawsuitCount());
                
                <span class="hljs-comment">// 简单的拒单规则演示</span>
                <span class="hljs-keyword">if</span> (<span class="hljs-string">"注销"</span>.equals(summary.getRegStatus()) || summary.getOpenLawsuitCount() &gt; <span class="hljs-number">0</span>) {
                    System.err.println(<span class="hljs-string">"[REJECT] 命中拒单规则：企业注销或存在未结案涉诉"</span>);
                }
            }
        } <span class="hljs-keyword">catch</span> (Exception e) {
            e.printStackTrace();
        }
    }

    <span class="hljs-comment">/**
     * 查询并清洗数据，返回领域模型对象
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SmeRiskSummary <span class="hljs-title function_">querySmeReport</span><span class="hljs-params">(String name, String idCard, String mobile)</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-comment">// 1. 准备参数</span>
        Map&lt;String, String&gt; params = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();
        params.put(<span class="hljs-string">"name"</span>, name);
        params.put(<span class="hljs-string">"id_card"</span>, idCard);
        params.put(<span class="hljs-string">"mobile_no"</span>, mobile);
        params.put(<span class="hljs-string">"authorized"</span>, <span class="hljs-string">"1"</span>); <span class="hljs-comment">// 必须获得授权</span>

        <span class="hljs-comment">// 2. 加密</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">encryptedData</span> <span class="hljs-operator">=</span> AesUtil.encrypt(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>().writeValueAsString(params), ACCESS_KEY);

        <span class="hljs-comment">// 3. 发送请求</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">responseJson</span> <span class="hljs-operator">=</span> sendPost(encryptedData);

        <span class="hljs-comment">// 4. 解析响应结构</span>
        <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();
        <span class="hljs-type">JsonNode</span> <span class="hljs-variable">rootNode</span> <span class="hljs-operator">=</span> mapper.readTree(responseJson);
        
        <span class="hljs-comment">// 假设外层未加密，直接解析 responses 数组</span>
        <span class="hljs-comment">// 若 data 字段加密，需先解密 data 再解析，逻辑同上</span>
        <span class="hljs-type">JsonNode</span> <span class="hljs-variable">responses</span> <span class="hljs-operator">=</span> rootNode.get(<span class="hljs-string">"responses"</span>);
        <span class="hljs-keyword">if</span> (responses == <span class="hljs-literal">null</span> || !responses.isArray()) {
            System.err.println(<span class="hljs-string">"无效的响应格式"</span>);
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }

        <span class="hljs-comment">// 5. 核心：从聚合数据中提取关键指标</span>
        <span class="hljs-keyword">return</span> parseRiskSummary(responses);
    }

    <span class="hljs-comment">/**
     * 数据清洗器：遍历子产品数组，提取核心字段
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SmeRiskSummary <span class="hljs-title function_">parseRiskSummary</span><span class="hljs-params">(JsonNode responses)</span> {
        <span class="hljs-type">SmeRiskSummary</span> <span class="hljs-variable">summary</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SmeRiskSummary</span>();

        <span class="hljs-keyword">for</span> (JsonNode item : responses) {
            <span class="hljs-type">String</span> <span class="hljs-variable">apiCode</span> <span class="hljs-operator">=</span> item.get(<span class="hljs-string">"api_code"</span>).asText();
            <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> item.get(<span class="hljs-string">"success"</span>).asBoolean();
            <span class="hljs-type">JsonNode</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> item.get(<span class="hljs-string">"data"</span>);

            <span class="hljs-keyword">if</span> (!success || data == <span class="hljs-literal">null</span> || data.isNull()) <span class="hljs-keyword">continue</span>;

            <span class="hljs-comment">// 分发处理逻辑</span>
            <span class="hljs-keyword">switch</span> (apiCode) {
                <span class="hljs-keyword">case</span> <span class="hljs-string">"QYGL3F8E"</span>: <span class="hljs-comment">// 人企关系</span>
                    <span class="hljs-keyword">if</span> (data.has(<span class="hljs-string">"items"</span>) &amp;&amp; data.get(<span class="hljs-string">"items"</span>).isArray() &amp;&amp; data.get(<span class="hljs-string">"items"</span>).size() &gt; <span class="hljs-number">0</span>) {
                        <span class="hljs-type">JsonNode</span> <span class="hljs-variable">company</span> <span class="hljs-operator">=</span> data.get(<span class="hljs-string">"items"</span>).get(<span class="hljs-number">0</span>).get(<span class="hljs-string">"basicInfo"</span>);
                        summary.setCompanyName(company.path(<span class="hljs-string">"name"</span>).asText());
                        summary.setRegStatus(company.path(<span class="hljs-string">"regStatus"</span>).asText());
                    }
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"JRZQ7F1A"</span>: <span class="hljs-comment">// 全景雷达</span>
                    summary.setLoanBehaviorScore(data.path(<span class="hljs-string">"behavior_report_detail"</span>).path(<span class="hljs-string">"B22170001"</span>).asText(<span class="hljs-string">"0"</span>));
                    summary.setOverdueAmount6M(data.path(<span class="hljs-string">"behavior_report_detail"</span>).path(<span class="hljs-string">"B22170031"</span>).asText(<span class="hljs-string">"0"</span>));
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"JRZQ8A2D"</span>: <span class="hljs-comment">// 特殊名单</span>
                    summary.setCourtBad(data.path(<span class="hljs-string">"id"</span>).path(<span class="hljs-string">"court_bad"</span>).asText(<span class="hljs-string">"未命中"</span>));
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"FLXG7E8F"</span>: <span class="hljs-comment">// 司法涉诉</span>
                    summary.setOpenLawsuitCount(data.path(<span class="hljs-string">"judicial_data"</span>).path(<span class="hljs-string">"lawsuitStat"</span>)
                            .path(<span class="hljs-string">"count"</span>).path(<span class="hljs-string">"count_wei_total"</span>).asInt(<span class="hljs-number">0</span>));
                    <span class="hljs-keyword">break</span>;
            }
        }
        <span class="hljs-keyword">return</span> summary;
    }

    <span class="hljs-comment">// --- 领域模型 DTO ---</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SmeRiskSummary</span> {
        <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">companyName</span> <span class="hljs-operator">=</span> <span class="hljs-string">"未查得"</span>;
        <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">regStatus</span> <span class="hljs-operator">=</span> <span class="hljs-string">"未知"</span>;
        <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">loanBehaviorScore</span> <span class="hljs-operator">=</span> <span class="hljs-string">"0"</span>;
        <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">overdueAmount6M</span> <span class="hljs-operator">=</span> <span class="hljs-string">"0"</span>;
        <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">courtBad</span> <span class="hljs-operator">=</span> <span class="hljs-string">"未命中"</span>;
        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">openLawsuitCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
        
        <span class="hljs-comment">// Getters &amp; Setters 省略...</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCompanyName</span><span class="hljs-params">(String name)</span> { <span class="hljs-built_in">this</span>.companyName = name; }
        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getCompanyName</span><span class="hljs-params">()</span> { <span class="hljs-keyword">return</span> companyName; }
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRegStatus</span><span class="hljs-params">(String status)</span> { <span class="hljs-built_in">this</span>.regStatus = status; }
        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getRegStatus</span><span class="hljs-params">()</span> { <span class="hljs-keyword">return</span> regStatus; }
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setLoanBehaviorScore</span><span class="hljs-params">(String score)</span> { <span class="hljs-built_in">this</span>.loanBehaviorScore = score; }
        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getLoanBehaviorScore</span><span class="hljs-params">()</span> { <span class="hljs-keyword">return</span> loanBehaviorScore; }
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setOverdueAmount6M</span><span class="hljs-params">(String amt)</span> { <span class="hljs-built_in">this</span>.overdueAmount6M = amt; }
        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getOverdueAmount6M</span><span class="hljs-params">()</span> { <span class="hljs-keyword">return</span> overdueAmount6M; }
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCourtBad</span><span class="hljs-params">(String status)</span> { <span class="hljs-built_in">this</span>.courtBad = status; }
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setOpenLawsuitCount</span><span class="hljs-params">(<span class="hljs-type">int</span> count)</span> { <span class="hljs-built_in">this</span>.openLawsuitCount = count; }
        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getOpenLawsuitCount</span><span class="hljs-params">()</span> { <span class="hljs-keyword">return</span> openLawsuitCount; }
    }

    <span class="hljs-comment">// --- HTTP &amp; AES Utils (简化版) ---</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">sendPost</span><span class="hljs-params">(String data)</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-type">URL</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(API_URL + <span class="hljs-string">"?t="</span> + System.currentTimeMillis());
        <span class="hljs-type">HttpURLConnection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> (HttpURLConnection) url.openConnection();
        conn.setRequestMethod(<span class="hljs-string">"POST"</span>);
        conn.setRequestProperty(<span class="hljs-string">"Content-Type"</span>, <span class="hljs-string">"application/json"</span>);
        conn.setRequestProperty(<span class="hljs-string">"Access-Id"</span>, ACCESS_ID);
        conn.setDoOutput(<span class="hljs-literal">true</span>);
        <span class="hljs-keyword">try</span> (<span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> conn.getOutputStream()) {
            os.write((<span class="hljs-string">"{\"data\":\""</span> + data + <span class="hljs-string">"\"}"</span>).getBytes(StandardCharsets.UTF_8));
        }
        <span class="hljs-keyword">try</span> (<span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(conn.getInputStream(), StandardCharsets.UTF_8))) {
            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();
            String line;
            <span class="hljs-keyword">while</span> ((line = br.readLine()) != <span class="hljs-literal">null</span>) sb.append(line);
            <span class="hljs-keyword">return</span> sb.toString();
        }
    }

    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AesUtil</span> {
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">encrypt</span><span class="hljs-params">(String content, String key)</span> <span class="hljs-keyword">throws</span> Exception {
            <span class="hljs-type">byte</span>[] iv = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">16</span>];
            <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecureRandom</span>().nextBytes(iv);
            <span class="hljs-type">Cipher</span> <span class="hljs-variable">cipher</span> <span class="hljs-operator">=</span> Cipher.getInstance(<span class="hljs-string">"AES/CBC/PKCS5Padding"</span>);
            cipher.init(Cipher.ENCRYPT_MODE, <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecretKeySpec</span>(key.getBytes(StandardCharsets.UTF_8), <span class="hljs-string">"AES"</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">IvParameterSpec</span>(iv));
            <span class="hljs-type">byte</span>[] enc = cipher.doFinal(content.getBytes(StandardCharsets.UTF_8));
            <span class="hljs-type">byte</span>[] combined = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">16</span> + enc.length];
            System.arraycopy(iv, <span class="hljs-number">0</span>, combined, <span class="hljs-number">0</span>, <span class="hljs-number">16</span>);
            System.arraycopy(enc, <span class="hljs-number">0</span>, combined, <span class="hljs-number">16</span>, enc.length);
            <span class="hljs-keyword">return</span> Base64.getEncoder().encodeToString(combined);
        }
    }
}
</code></pre>
<h2 data-id="heading-4">三、核心数据结构解析</h2>
<h3 data-id="heading-5">1. 聚合响应模式</h3>
<p>接口返回的 <code>data</code> 并非直接的业务对象，而是一个由子产品响应组成的列表。Java 开发者应使用 <strong>策略模式</strong> 或 <strong>Switch-Case</strong> 结构根据 <code>api_code</code> 字段进行分发处理。</p>
<p>JSON</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"responses"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
    <span class="hljs-punctuation">{</span> <span class="hljs-attr">"api_code"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"QYGL3F8E"</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">"success"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span> <span class="hljs-attr">"data"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span> ... <span class="hljs-punctuation">}</span> <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 人企关系</span>
    <span class="hljs-punctuation">{</span> <span class="hljs-attr">"api_code"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"JRZQ7F1A"</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">"success"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span> <span class="hljs-attr">"data"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span> ... <span class="hljs-punctuation">}</span> <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 全景雷达</span>
    <span class="hljs-punctuation">{</span> <span class="hljs-attr">"api_code"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"JRZQ8A2D"</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">"success"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span> <span class="hljs-attr">"data"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span> ... <span class="hljs-punctuation">}</span> <span class="hljs-punctuation">}</span>  <span class="hljs-comment">// 特殊名单</span>
  <span class="hljs-punctuation">]</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<h3 data-id="heading-6">2. 字段映射挑战</h3>
<p>每个子产品的字段命名风格不同：</p>
<ul>
<li><strong>QYGL3F8E</strong>：使用驼峰命名（如 <code>regStatus</code>）4。</li>
<li><strong>JRZQ7F1A</strong>：使用大写代码（如 <code>B22170001</code>）55。</li>
<li><strong>JRZQ8A2D</strong>：使用下划线命名（如 <code>id_court_bad</code>）6。</li>
</ul>
<p>建议在 Java 实体类（如上文的 <code>SmeRiskSummary</code>）中统一重命名为符合业务语义的字段（如 <code>loanScore</code>, <code>companyStatus</code>），屏蔽底层的异构性。</p>
<h2 data-id="heading-7">四、字段详解（Java 开发重点）</h2>
<p>以下表格梳理了在 Java 风控系统中，用于**自动准入（Auto-Approve）<strong>或</strong>自动拒单（Auto-Reject）**的关键字段。</p>
<h3 data-id="heading-8">1. 企业经营维度 (QYGL3F8E)</h3>




















<table><thead><tr><th><strong>字段路径 (JSON Path)</strong></th><th><strong>业务含义</strong></th><th><strong>逻辑建议</strong></th></tr></thead><tbody><tr><td><code>items[0].basicInfo.regStatus</code></td><td>经营状态</td><td>若包含“注销”、“吊销”，Java 逻辑应直接抛出 <code>RejectException</code> 7。</td></tr><tr><td><code>items[0].basicInfo.estiblishTime</code></td><td>成立时间</td><td>计算经营年限，如 <code>&lt; 1年</code> 则归为高风险 8。</td></tr></tbody></table>
<h3 data-id="heading-9">2. 企业主还款能力 (JRZQ7F1A)</h3>

























<table><thead><tr><th><strong>字段代码</strong></th><th><strong>字段含义</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>B22170001</strong></td><td>贷款行为分</td><td>1-1000。分数越低，个人信用越差 9999。</td></tr><tr><td><strong>B22170031</strong></td><td>近6个月累计逾期金额</td><td>区间值（如 <code>[5000,10000)</code>）。用于计算负债压力 10。</td></tr><tr><td><strong>B22170026</strong></td><td>近12个月M0+逾期笔数</td><td>衡量还款意愿。若 &gt; 3，建议转人工 11。</td></tr></tbody></table>
<h3 data-id="heading-10">3. 司法与黑名单 (JRZQ8A2D / FLXG7E8F)</h3>




















<table><thead><tr><th><strong>字段路径</strong></th><th><strong>字段含义</strong></th><th><strong>逻辑建议</strong></th></tr></thead><tbody><tr><td><code>id.court_bad</code></td><td>法院失信人</td><td>值 <code>0</code> 表示命中。<strong>一票否决</strong>指标 12。</td></tr><tr><td><code>lawsuitStat.count.money_wei_total</code></td><td>涉诉未结案金额</td><td>企业主的潜在负债，需计入 DTI（债务收入比）计算 13。</td></tr></tbody></table>
<h2 data-id="heading-11">五、应用价值分析</h2>
<p>集成<strong>天远全能小微企业报告</strong>后，Java 后端系统可实现以下核心能力：</p>
<ol>
<li>
<p>公私联动画像构建：</p>
<p>在一次 API 事务中，同时获取“企业的壳”和“法人的核”。例如，如果企业经营正常（QYGL3F8E），但法人近期有大量网贷逾期（JRZQ7F1A），系统可自动判定为“经营性资金挪用风险”，拒绝放款。</p>
</li>
<li>
<p>供应链金融自动准入：</p>
<p>对于经销商融资场景，Java 服务可以配置规则链：</p>
<ul>
<li>
<p>Step 1: 校验企业是否存续（QYGL3F8E）。</p>
</li>
<li>
<p>Step 2: 校验法人是否为老赖（JRZQ8A2D）。</p>
</li>
<li>
<p>Step 3: 校验涉诉金额是否超过注册资本的 50%（FLXG7E8F）。</p>
<p>全部通过后，自动触发授信流程。</p>
</li>
</ul>
</li>
<li>
<p>贷后风险预警：</p>
<p>利用 Java 的 Quartz 或 Spring Scheduler 定时任务，定期调用此接口。若发现存量客户的 openLawsuitCount（未结案数）突增，系统自动生成风控工单，提示客户经理进行贷后回访。</p>
</li>
</ol>
<h2 data-id="heading-12">六、总结</h2>
<p>对于 Java 开发者而言，<strong>天远全能小微企业报告</strong> 是一个典型的“胖接口”。对接的关键在于编写健壮的 <strong>解析器（Parser）</strong> ，能够兼容子产品的成功与失败状态，并将异构数据清洗为统一的领域模型。</p>
<p>通过本文提供的 <code>SmeRiskService</code> 示例，您可以快速打通从数据获取、清洗到规则判定的全流程，为企业构建一个高效、智能的小微风控大脑。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[比 Kettle 快2倍的 Java ETL 开源库：Etl-engine]]></title>    <link>https://juejin.cn/post/7584286241487634472</link>    <guid>https://juejin.cn/post/7584286241487634472</guid>    <pubDate>2025-12-16T09:22:38.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584286241487634472" data-draft-id="7584043969687961652" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="比 Kettle 快2倍的 Java ETL 开源库：Etl-engine"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2025-12-16T09:22:38.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="变形侠医"/> <meta itemprop="url" content="https://juejin.cn/user/2418581313172413"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            比 Kettle 快2倍的 Java ETL 开源库：Etl-engine
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2418581313172413/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    变形侠医
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-16T09:22:38.000Z" title="Tue Dec 16 2025 09:22:38 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-16
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    20
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>最近在Github上发现了一个不错的开源项目，基于Java的ETL开发库，号称表数据导入速度是kettle的2倍，而且简单易用，推荐一波：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fadd2ws%2Fetl-engine-project" target="_blank" title="https://github.com/add2ws/etl-engine-project" ref="nofollow noopener noreferrer">add2ws/etl-engine-project: A fast &amp; stable &amp; flexible ETL tool.</a></p>
<h2 data-id="heading-0">🚀 项目简介</h2>
<p><strong><code>Etl-engine</code></strong> 是一个轻量、稳健、易扩展的面向开发者的 ETL（抽取、转换、加载）库，旨在成为 **Kettle (PDI) 的高性能替代方案。</p>
<hr/>
<h2 data-id="heading-1">🔥 核心优势</h2>
<p><strong><code>Etl-engine</code></strong> 提供以下三大核心特性：</p>
<h3 data-id="heading-2">1. 极致的速度 ⚡️</h3>
<p>通过批量操作和非阻塞的缓存管道设计，显著提升数据处理和数据库 I/O 速度。</p>
<p>📊 <strong>实测数据：</strong> 处理 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>200</mn><mo separator="true">,</mo><mn>000</mn></mrow><annotation encoding="application/x-tex">200,000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"/><span class="mord">200</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord">000</span></span></span></span></span> 条数据的插入/更新任务，<code>etl-engine</code> 的速度是 <strong>Kettle 的 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn mathvariant="bold">2</mn></mrow><annotation encoding="application/x-tex">\mathbf{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord mathbf">2</span></span></span></span></span> 倍左右</strong>。</p>
<p><strong>Kettle:</strong></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/730ea2f329a54295bb8d105999f16a41~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-Y5b2i5L6g5Yy7:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766482988&amp;x-signature=2bmKC1ZVdzuGltXFP6ZzZkk8zgs%3D" alt="1765353174408.png" loading="lazy"/></p>
<p><strong>Etl-engine:</strong></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bbd84d731054490b95ed994e30bd014d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-Y5b2i5L6g5Yy7:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766482988&amp;x-signature=cpJbFBaGSTitgy9ULJEh45JBfQQ%3D" alt="1765353763090.png" loading="lazy"/></p>
<h3 data-id="heading-3">2. 运行稳健可靠 🛡️</h3>
<p>数据流传输过程中如果遇到异常不会马上停止，自动尝试重新读取或写入数据。</p>
<h3 data-id="heading-4">3. 轻量且易于扩展 🧩</h3>
<p>核心仅由 <strong>Node(节点)</strong> , <strong>Pipe(管道)</strong> , <strong>Dataflow(数据流)</strong> 3个主要组件构成，所有数据加载逻辑都抽象为可扩展的<strong>节点</strong>。除了内置的JDBC数据源节点，用户可以轻松继承基类，快速开发新的数据源（如 Http、Redis）或自定义转换逻辑，满足特定的业务需求。</p>
<hr/>
<h2 data-id="heading-5">🛠️ 使用示例</h2>
<p>以下代码展示了如何快速构建一个将 <strong>Oracle 数据（抽取）</strong> 通过 <strong>Upsert 方式同步到 PostgreSQL（加载）</strong> 的 ETL 任务。</p>
<h3 data-id="heading-6">1. 一个表输入到一个表输出</h3>
<pre><code class="hljs language-mermaid" lang="mermaid">flowchart LR
  sqlInputNode --pipe--&gt; upsertOutputNode
</code></pre>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">//创建Oracle数据源</span>
<span class="hljs-type">DataSource</span> <span class="hljs-variable">dataSourceOracle</span> <span class="hljs-operator">=</span> DataSourceUtil.getOracleDataSource();
<span class="hljs-comment">//创建表输入节点</span>
<span class="hljs-type">SqlInputNode</span> <span class="hljs-variable">sqlInputNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlInputNode</span>(dataSourceOracle, <span class="hljs-string">"select * from t_resident_info"</span>);

<span class="hljs-comment">//创建Postgres数据源</span>
<span class="hljs-type">DataSource</span> <span class="hljs-variable">dataSourcePG</span> <span class="hljs-operator">=</span> DataSourceUtil.getPostgresDataSource();
<span class="hljs-comment">//创建插入/更新节点</span>
<span class="hljs-type">UpsertOutputNode</span> <span class="hljs-variable">upsertOutputNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UpsertOutputNode</span>(dataSourcePG, <span class="hljs-string">"t_resident_info"</span>, <span class="hljs-number">1000</span>);
<span class="hljs-comment">//设置唯一标识(主键)映射，用于判断 Insert 或 Update</span>
upsertOutputNode.setIdentityMapping(Arrays.asList(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Tuple2</span>&lt;&gt;(<span class="hljs-string">"ID"</span>, <span class="hljs-string">"ID"</span>)));

<span class="hljs-comment">//创建管道，并设定缓冲区为1000条数据</span>
<span class="hljs-type">Pipe</span> <span class="hljs-variable">pipe</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pipe</span>(<span class="hljs-number">1000</span>);
<span class="hljs-comment">//连接表输入和输出节点</span>
pipe.connect(sqlInputNode, upsertOutputNode);

<span class="hljs-comment">//创建数据流实例</span>
<span class="hljs-type">Dataflow</span> <span class="hljs-variable">dataflow</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dataflow</span>(sqlInputNode);
<span class="hljs-comment">//启动数据流，并设定5分钟后超时</span>
dataflow.syncStart(<span class="hljs-number">5</span>, TimeUnit.MINUTES);
</code></pre>
<h3 data-id="heading-7">2. 一个表输入到多个输出</h3>
<pre><code class="hljs language-mermaid" lang="mermaid">flowchart LR
  sqlInputNode --pipe--&gt; upsertOutputNode
  sqlInputNode --pipe--&gt; csvOutputNode
</code></pre>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">//创建Oracle数据源</span>
<span class="hljs-type">DataSource</span> <span class="hljs-variable">oracleDataSource</span> <span class="hljs-operator">=</span> DataSourceUtil.getOracleDataSource();
<span class="hljs-type">SqlInputNode</span> <span class="hljs-variable">sqlInputNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlInputNode</span>(oracleDataSource, <span class="hljs-string">"select * from etl_base.t_resident_info where rownum&lt;=50000 order by id"</span>);

<span class="hljs-comment">//创建Postgres目标数据源</span>
<span class="hljs-type">DataSource</span> <span class="hljs-variable">postgresDataSource</span> <span class="hljs-operator">=</span> DataSourceUtil.getPostgresDataSource();
<span class="hljs-type">UpsertOutputNode</span> <span class="hljs-variable">upsertOutputNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UpsertOutputNode</span>(postgresDataSource, <span class="hljs-string">"public.t_resident_info"</span>, <span class="hljs-number">1000</span>);
upsertOutputNode.setIdentityMapping(Arrays.asList(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Tuple2</span>&lt;&gt;(<span class="hljs-string">"ID"</span>,<span class="hljs-string">"ID"</span>)));

<span class="hljs-comment">//创建csv文件目标</span>
<span class="hljs-type">FileOutputNode</span> <span class="hljs-variable">fileOutputNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputNode</span>(<span class="hljs-string">"E:/output_"</span> + System.currentTimeMillis() + <span class="hljs-string">".csv"</span>, FileOutputNode.Format.CSV);

<span class="hljs-comment">//创建管道并连接Oracle和Postgres</span>
<span class="hljs-type">Pipe</span> <span class="hljs-variable">pipe</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pipe</span>(<span class="hljs-number">1000</span>);
pipe.connect(sqlInputNode,upsertOutputNode);

<span class="hljs-comment">//创建管道并连接Oracle和csv文件</span>
<span class="hljs-type">Pipe</span> <span class="hljs-variable">pipe_2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pipe</span>(<span class="hljs-number">1000</span>);
pipe_2.connect(sqlInputNode,fileOutputNode);

<span class="hljs-comment">//创建数据流并启动</span>
<span class="hljs-type">Dataflow</span> <span class="hljs-variable">dataflow</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dataflow</span>(sqlInputNode);
dataflow.syncStart();

</code></pre>
<hr/>
<h2 data-id="heading-8">🏗️ 架构概览</h2>
<p><code>Etl-engine</code> 核心仅由以下3个主要组件构成：</p>
<ul>
<li><strong>Node (节点):</strong> 数据的起点、终点和数据转换逻辑载体。</li>
<li><strong>Pipe (管道):</strong> 负责在节点间传递数据的非阻塞缓存队列。</li>
<li><strong>Dataflow (数据流):</strong> 任务的编排器和执行入口。</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[GoFrame vs Laravel：从ORM到CLI工具的全面对比与迁移指南]]></title>    <link>https://juejin.cn/post/7584203412197883930</link>    <guid>https://juejin.cn/post/7584203412197883930</guid>    <pubDate>2025-12-16T09:25:10.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584203412197883930" data-draft-id="7584203412197851162" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="GoFrame vs Laravel：从ORM到CLI工具的全面对比与迁移指南"/> <meta itemprop="keywords" content="后端,Go"/> <meta itemprop="datePublished" content="2025-12-16T09:25:10.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="王中阳Go背后的男人"/> <meta itemprop="url" content="https://juejin.cn/user/1444135685064410"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            GoFrame vs Laravel：从ORM到CLI工具的全面对比与迁移指南
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1444135685064410/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    王中阳Go背后的男人
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-16T09:25:10.000Z" title="Tue Dec 16 2025 09:25:10 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-16
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读9分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;font-weight:400;line-height:2;font-size:17px;overflow-x:hidden;color:#000}.markdown-body strong{padding:1px;color:#ee3f4d}.markdown-body em{padding:0 2px;color:#f33b1f}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{position:relative;margin-top:30px;margin-bottom:20px;line-height:1.5;font-weight:700}.markdown-body h1{text-align:center;padding-bottom:5px;font-size:32px;color:#ac1f18}.markdown-body h1:after{content:"";display:block;margin:4px auto 0;width:100px;height:2px;border-bottom:2px solid #f33b1f}.markdown-body h2{font-size:28px;border-bottom:1px solid #f33b1f}.markdown-body h2:before{content:"# "!important;color:#f33b1f}.markdown-body h3{font-size:24px;padding-left:9px;border-left:6px solid #f33b1f}.markdown-body h4{font-size:20px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #bbb;margin:16px 0}.markdown-body code{word-break:break-word;overflow-x:auto;background-color:#f9f1db;color:#ee2746;border-radius:2px;font-size:16px;padding:1px 2px}.markdown-body code,.markdown-body pre{font-family:-apple-system,-apple-system-body,BlinkMacSystemFont,Segoe UI,Helvetica,Arial,PingFang SC,思源黑体 CN,思源黑体,JetBrains Mono,Fira Code,Menlo,Ubuntu Mono,Consolas,sans-serif}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{margin:12px 0!important;border-radius:3px;font-size:15px;padding:16px 12px;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f7f7f7}.markdown-body a{text-decoration:none;color:#1781b5;padding:0 2px;border-bottom:1px solid #1781b5}.markdown-body a:active,.markdown-body a:hover{border-bottom:2px solid #f33b1f;color:#ac1f18}.markdown-body blockquote{color:#3d3d3d;background-color:#fff9f9;padding:6px 16px;margin:16px 0;border-left:3px solid #f07c82}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:6px 0}.markdown-body ol,.markdown-body ul{padding-left:30px}.markdown-body ol li,.markdown-body ul li{margin-bottom:6px}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:6px}.markdown-body ol li{padding-left:6px}.markdown-body ::marker{color:#f33b1f}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}.markdown-body .task-list-item input[type=checkbox]{position:relative}.markdown-body .task-list-item input[type=checkbox]:before{content:"";position:absolute;top:0;left:0;right:0;bottom:0;background:#fff;border:1px solid #f07c82;border-radius:3px;box-sizing:border-box;z-index:1}.markdown-body .task-list-item input[type=checkbox]:checked:after{content:"✓";position:absolute;top:-5px;left:0;right:0;bottom:0;width:0;height:0;color:#f33b1f;font-size:16px;font-weight:700;z-index:2}.markdown-body table{display:inline-block!important;font-size:14px;width:auto;max-width:100%;overflow:auto;border-spacing:0;border-collapse:collapse}.markdown-body table thead{background:#fff9f9;color:#000;text-align:left;font-size:15px}.markdown-body table tr:nth-child(2n){background-color:#fcfcfc}.markdown-body table tr:hover{background-color:#fff9f9}.markdown-body table td,.markdown-body table th{padding:12px 7px;line-height:24px;border:1px solid #f9f1db}.markdown-body table td{min-width:120px}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="xcode">.markdown-body pre,.markdown-body pre&gt;code.hljs{background:#fff;color:#000}.xml .hljs-meta{color:silver}.hljs-comment,.hljs-quote{color:#007400}.hljs-attribute,.hljs-keyword,.hljs-literal,.hljs-name,.hljs-selector-tag,.hljs-tag{color:#aa0d91}.hljs-template-variable,.hljs-variable{color:#3f6e74}.hljs-code,.hljs-meta-string,.hljs-string{color:#c41a16}.hljs-link,.hljs-regexp{color:#0e0eff}.hljs-bullet,.hljs-number,.hljs-symbol,.hljs-title{color:#1c00cf}.hljs-meta,.hljs-section{color:#643820}.hljs-built_in,.hljs-builtin-name,.hljs-class .hljs-title,.hljs-params,.hljs-type{color:#5c2699}.hljs-attr{color:#836c28}.hljs-subst{color:#000}.hljs-formula{background-color:#eee;font-style:italic}.hljs-addition{background-color:#baeeba}.hljs-deletion{background-color:#ffc8bd}.hljs-selector-class,.hljs-selector-id{color:#9b703f}.hljs-doctag,.hljs-strong{font-weight:700}.hljs-emphasis{font-style:italic}</style><blockquote>
<p>最近贼有意思，发现了一个账号，专门发PHP转Go的帖子，哎呦喂，这不正是我3年前做的事情吗？哈哈。</p>
</blockquote>
<p>尤其看到他写的安利GoFrame教程的文章，有点刺激到我了，一看他就没我用的多，用的溜，因为我不仅在公司用GoFrame做过商业项目，还写过专栏，出过教程。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e7fc34ce8f2641d1861712e3feb8a3d4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg546L5Lit6ZizR2_og4zlkI7nmoTnlLfkuro=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766481910&amp;x-signature=XkPgP7Pa4XZ%2BYimznHXYZbTeFvk%3D" alt="" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c6e702d1b7a44948b9301f52bdedd189~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg546L5Lit6ZizR2_og4zlkI7nmoTnlLfkuro=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766481910&amp;x-signature=sDVxrw%2BWfT%2Fji%2FcC%2FchLhfTJzLo%3D" alt="" loading="lazy"/></p>
<p>作为一名<strong>深耕PHP多年</strong>的开发者，Laravel的<strong>优雅与高效</strong>早已刻入我的开发习惯。当业务需求朝着<strong>高并发、高性能</strong>方向升级，Go语言成为必然选择时，我却一度陷入"用惯了Laravel，再写Go总觉得不顺手"的困境——直到邂逅<strong>GoFrame</strong>。这个被誉为Go生态"<strong>瑞士军刀</strong>"的框架，完美复刻了Laravel的开发体验，又兼具Go语言的<strong>原生优势</strong>，让我在转型路上少走了无数弯路。今天就来拆解<strong>GoFrame为何能成为PHP开发者的Go语言入门首选</strong>，以及如何快速上手实践。</p>
<h2 data-id="heading-0">一、GoFrame：Laravel开发者的"他乡故知"</h2>
<p>GoFrame最打动PHP开发者的，是它与Laravel<strong>一脉相承的设计理念</strong>。很多用过的开发者都戏称它是"<strong>Go版Laravel</strong>"，这种亲切感源于两者在核心功能上的<strong>高度契合</strong>：</p>
<h3 data-id="heading-1">1. 如出一辙的ORM操作</h3>
<p>Laravel的<strong>Eloquent ORM</strong>是其核心亮点之一，而GoFrame的ORM设计几乎做到了"<strong>无缝衔接</strong>"。同样支持<strong>链式调用</strong>，同样<strong>简洁直观</strong>的查询语法，让习惯了Laravel的开发者无需重新适应：</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-comment">// GoFrame查询示例</span>
user, err := g.Model(<span class="hljs-string">"user"</span>).Where(<span class="hljs-string">"id"</span>, <span class="hljs-number">1</span>).One()
activeUsers, err := g.Model(<span class="hljs-string">"user"</span>).Where(<span class="hljs-string">"status"</span>, <span class="hljs-number">1</span>).Order(<span class="hljs-string">"create_at desc"</span>).All()

<span class="hljs-comment">// 对比Laravel的Eloquent</span>
$user = User::where(<span class="hljs-string">'id'</span>, <span class="hljs-number">1</span>)-&gt;first();
$activeUsers = User::where(<span class="hljs-string">'status'</span>, <span class="hljs-number">1</span>)-&gt;orderBy(<span class="hljs-string">'create_at'</span>, <span class="hljs-string">'desc'</span>)-&gt;get();
</code></pre>
<p>这种<strong>语法上的相似度</strong>，让开发者能瞬间代入，极大降低了<strong>学习成本</strong>。</p>
<h3 data-id="heading-2">2. 功能对等的命令行工具</h3>
<p>Laravel的<strong>Artisan工具</strong>是提升开发效率的利器，而GoFrame的<code>gf</code>命令行工具在功能上<strong>完全不输</strong>。从<strong>项目初始化</strong>到<strong>代码生成</strong>，再到<strong>热重载运行</strong>，一套命令就能搞定所有基础操作：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># GoFrame gf工具</span>
gf init myapp          <span class="hljs-comment"># 初始化项目（对应laravel new myapp）</span>
gf gen model user      <span class="hljs-comment"># 生成数据模型（对应php artisan make:model User）</span>
gf run                 <span class="hljs-comment"># 热启动项目（无需手动重启，对应laravel serve）</span>

<span class="hljs-comment"># 额外实用功能</span>
gf gen controller user <span class="hljs-comment"># 快速生成控制器</span>
gf sql <span class="hljs-built_in">export</span>          <span class="hljs-comment"># 数据库结构导出</span>
</code></pre>
<p>熟悉的<strong>命令行体验</strong>，让开发者从Laravel切换到GoFrame时<strong>毫无违和感</strong>。</p>
<h3 data-id="heading-3">3. 经典MVC架构复用</h3>
<p>GoFrame沿用了Laravel经典的<strong>MVC（模型-视图-控制器）架构</strong>，路由、控制器、模型的<strong>代码组织方式</strong>与Laravel高度一致。这种<strong>架构上的熟悉感</strong>，让开发者能直接复用此前的<strong>项目结构设计经验</strong>：</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-comment">// 路由定义（对应Laravel的routes/api.php）</span>
s.Group(<span class="hljs-string">"/api"</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(group *ghttp.RouterGroup)</span></span> {
    group.POST(<span class="hljs-string">"/users"</span>, controller.User.Create)
    group.GET(<span class="hljs-string">"/users/:id"</span>, controller.User.Show)
})

<span class="hljs-comment">// 控制器逻辑（对应Laravel的app/Http/Controllers/UserController）</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *UserController)</span></span> Create(r *ghttp.Request) {
    <span class="hljs-comment">// 接收参数、业务处理、返回响应的流程与Laravel一致</span>
}
</code></pre>
<p>此外，GoFrame的<strong>中间件机制</strong>也与Laravel完全同源，无论是<strong>认证授权</strong>、<strong>日志记录</strong>还是<strong>限流熔断</strong>，都能按照熟悉的方式实现，无需重构<strong>开发思维</strong>。</p>
<h3 data-id="heading-4">4. 更灵活的配置管理</h3>
<p>Laravel的<code>.env</code>配置方式<strong>简洁易用</strong>，但GoFrame在此基础上提供了<strong>更灵活的方案</strong>——支持<strong>yaml、toml、json</strong>等多种格式的配置文件，还能根据<strong>环境（开发、测试、生产）</strong> 自动加载对应配置：</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-comment"># 开发环境配置（config.dev.yaml）</span>
<span class="hljs-attr">server:</span>
  <span class="hljs-attr">address:</span> <span class="hljs-string">":8080"</span>
<span class="hljs-attr">database:</span>
  <span class="hljs-attr">default:</span>
    <span class="hljs-attr">link:</span> <span class="hljs-string">"mysql:root:123456@tcp(127.0.0.1:3306)/dev_db"</span>
    <span class="hljs-attr">debug:</span> <span class="hljs-literal">true</span>

<span class="hljs-comment"># 生产环境配置（config.prod.yaml）</span>
<span class="hljs-attr">server:</span>
  <span class="hljs-attr">address:</span> <span class="hljs-string">":80"</span>
<span class="hljs-attr">database:</span>
  <span class="hljs-attr">default:</span>
    <span class="hljs-attr">link:</span> <span class="hljs-string">"mysql:prod_user:prod_pwd@tcp(10.0.0.1:3306)/prod_db"</span>
    <span class="hljs-attr">debug:</span> <span class="hljs-literal">false</span>
</code></pre>
<p>通过<code>gf env set</code>命令即可<strong>切换环境</strong>，比Laravel手动修改<code>.env</code>更<strong>高效安全</strong>。</p>
<h2 data-id="heading-5">二、GoFrame的独家优势：不止于"像Laravel"</h2>
<p>如果说<strong>相似性</strong>让GoFrame降低了入门门槛，那么这些<strong>独家优势</strong>才是它真正的核心竞争力：</p>
<h3 data-id="heading-6">1. Go原生的高性能</h3>
<p>作为Go语言框架，GoFrame天生继承了Go的<strong>并发优势</strong>。在同等服务器配置下，GoFrame的<strong>QPS（每秒查询率）</strong> 是传统PHP框架的<strong>5-10倍</strong>，内存占用却只有PHP的<strong>1/3</strong>。对于需要处理<strong>高并发请求</strong>的场景（如直播互动、电商秒杀），这种<strong>性能差距</strong>尤为明显。</p>
<h3 data-id="heading-7">2. 真正的模块化设计</h3>
<p>GoFrame的"<strong>全家桶</strong>"并非简单堆砌，而是由多个<strong>可独立使用的模块</strong>组成。除了Web开发必备的ORM、路由、控制器，还包含<strong>缓存、日志、验证、国际化</strong>等全套企业级组件。开发者可以<strong>按需选用</strong>，比如只使用它的ORM模块操作数据库，或用缓存模块替代Redis客户端，<strong>灵活性远超Laravel</strong>。</p>
<h3 data-id="heading-8">3. 完善的中文生态支持</h3>
<p>对于国内开发者而言，GoFrame的<strong>中文文档</strong>堪称"<strong>教科书级别</strong>"——不仅内容详尽，还包含大量针对<strong>国内场景</strong>的优化说明（如MySQL驱动适配、微信支付集成等）。此外，GitHub社区<strong>活跃度极高</strong>，大部分问题都能在<strong>24小时内</strong>找到解决方案，比依赖英文文档的Laravel生态更<strong>接地气</strong>。</p>
<h3 data-id="heading-9">4. 微服务友好型架构</h3>
<p>GoFrame的<strong>模块化设计</strong>天然适合<strong>微服务拆分</strong>。每个业务模块都可以<strong>独立部署、独立扩展</strong>，配合Go语言的<strong>跨平台编译特性</strong>，能轻松实现<strong>多环境部署</strong>。相比之下，Laravel在微服务架构中需要额外引入<strong>第三方组件</strong>，复杂度更高。</p>
<h2 data-id="heading-10">三、快速上手：30分钟搭建完整CRUD API</h2>
<p>说了这么多，不如亲手实践一番。下面以<strong>用户管理API</strong>为例，带你体验GoFrame的<strong>开发流程</strong>：</p>
<h3 data-id="heading-11">1. 环境准备与安装</h3>
<p>首先确保本地已安装<strong>Go 1.18+版本</strong>，然后执行以下命令安装<code>gf</code>工具：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 安装gf命令行工具</span>
go install github.com/gogf/gf/cmd/gf@latest

<span class="hljs-comment"># 验证安装成功</span>
gf -v
</code></pre>
<h3 data-id="heading-12">2. 初始化项目</h3>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 创建项目</span>
gf init user-api

<span class="hljs-comment"># 进入项目目录</span>
<span class="hljs-built_in">cd</span> user-api

<span class="hljs-comment"># 启动项目（热重载模式）</span>
gf run
</code></pre>
<p>此时访问<code>http://127.0.0.1:8080</code>，就能看到GoFrame的<strong>默认欢迎页面</strong>，项目初始化完成。</p>
<h3 data-id="heading-13">3. 配置数据库</h3>
<p>编辑项目根目录的<code>config.yaml</code>文件，配置<strong>MySQL连接信息</strong>：</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">database:</span>
  <span class="hljs-attr">default:</span>
    <span class="hljs-attr">link:</span> <span class="hljs-string">"mysql:root:123456@tcp(127.0.0.1:3306)/user_db"</span>
    <span class="hljs-attr">debug:</span> <span class="hljs-literal">true</span>
    <span class="hljs-attr">maxIdleConn:</span> <span class="hljs-number">10</span>
    <span class="hljs-attr">maxOpenConn:</span> <span class="hljs-number">100</span>
</code></pre>
<p>确保数据库已创建（可手动创建<code>user_db</code>库），无需提前建表，后续可通过<strong>模型生成工具</strong>自动同步。</p>
<h3 data-id="heading-14">4. 生成模型与控制器</h3>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 生成User模型（会自动创建数据表）</span>
gf gen model user -t user -f

<span class="hljs-comment"># 生成User控制器</span>
gf gen controller user
</code></pre>
<p>执行完成后，项目会自动创建<code>model/user.go</code>和<code>controller/user.go</code>文件，无需手动编写<strong>基础代码</strong>。</p>
<h3 data-id="heading-15">5. 定义路由</h3>
<p>编辑<code>router/router.go</code>文件，添加<strong>CRUD路由</strong>：</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-keyword">package</span> router

<span class="hljs-keyword">import</span> (
    <span class="hljs-string">"user-api/app/controller"</span>
    <span class="hljs-string">"github.com/gogf/gf/frame/g"</span>
)

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> {
    s := g.Server()
    <span class="hljs-comment">// 接口路由组</span>
    s.Group(<span class="hljs-string">"/api/v1"</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(group *ghttp.RouterGroup)</span></span> {
        <span class="hljs-comment">// 跨域支持</span>
        group.Middleware(ghttp.MiddlewareCORS)
        <span class="hljs-comment">// 用户管理路由</span>
        group.POST(<span class="hljs-string">"/users"</span>, controller.User.Create)
        group.GET(<span class="hljs-string">"/users/:id"</span>, controller.User.Show)
        group.PUT(<span class="hljs-string">"/users/:id"</span>, controller.User.Update)
        group.DELETE(<span class="hljs-string">"/users/:id"</span>, controller.User.Delete)
        group.GET(<span class="hljs-string">"/users"</span>, controller.User.List)
    })
}
</code></pre>
<h3 data-id="heading-16">6. 完善控制器逻辑</h3>
<p>编辑<code>controller/user.go</code>，补充<strong>业务处理逻辑</strong>：</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-keyword">package</span> controller

<span class="hljs-keyword">import</span> (
    <span class="hljs-string">"user-api/app/model"</span>
    <span class="hljs-string">"github.com/gogf/gf/net/ghttp"</span>
    <span class="hljs-string">"github.com/gogf/gf/frame/g"</span>
)

<span class="hljs-keyword">type</span> UserController <span class="hljs-keyword">struct</span>{}

<span class="hljs-comment">// 创建用户</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *UserController)</span></span> Create(r *ghttp.Request) {
    <span class="hljs-keyword">var</span> data model.User
    <span class="hljs-keyword">if</span> err := r.Parse(&amp;data); err != <span class="hljs-literal">nil</span> {
        r.Response.WriteJsonExit(g.Map{
            <span class="hljs-string">"code"</span>: <span class="hljs-number">400</span>,
            <span class="hljs-string">"msg"</span>:  <span class="hljs-string">"参数错误："</span> + err.Error(),
        })
    }
    <span class="hljs-comment">// 插入数据库</span>
    result, err := g.Model(<span class="hljs-string">"user"</span>).Insert(&amp;data)
    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
        r.Response.WriteJsonExit(g.Map{
            <span class="hljs-string">"code"</span>: <span class="hljs-number">500</span>,
            <span class="hljs-string">"msg"</span>:  <span class="hljs-string">"创建失败："</span> + err.Error(),
        })
    }
    id, _ := result.LastInsertId()
    r.Response.WriteJsonExit(g.Map{
        <span class="hljs-string">"code"</span>: <span class="hljs-number">200</span>,
        <span class="hljs-string">"msg"</span>:  <span class="hljs-string">"创建成功"</span>,
        <span class="hljs-string">"data"</span>: g.Map{<span class="hljs-string">"id"</span>: id},
    })
}

<span class="hljs-comment">// 获取单个用户</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *UserController)</span></span> Show(r *ghttp.Request) {
    id := r.GetInt(<span class="hljs-string">"id"</span>)
    user, err := g.Model(<span class="hljs-string">"user"</span>).Where(<span class="hljs-string">"id"</span>, id).One()
    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
        r.Response.WriteJsonExit(g.Map{
            <span class="hljs-string">"code"</span>: <span class="hljs-number">500</span>,
            <span class="hljs-string">"msg"</span>:  <span class="hljs-string">"查询失败："</span> + err.Error(),
        })
    }
    <span class="hljs-keyword">if</span> user.IsEmpty() {
        r.Response.WriteJsonExit(g.Map{
            <span class="hljs-string">"code"</span>: <span class="hljs-number">404</span>,
            <span class="hljs-string">"msg"</span>:  <span class="hljs-string">"用户不存在"</span>,
        })
    }
    r.Response.WriteJsonExit(g.Map{
        <span class="hljs-string">"code"</span>: <span class="hljs-number">200</span>,
        <span class="hljs-string">"msg"</span>:  <span class="hljs-string">"查询成功"</span>,
        <span class="hljs-string">"data"</span>: user,
    })
}

<span class="hljs-comment">// 其他方法（Update、Delete、List）类似，此处省略...</span>
</code></pre>
<h3 data-id="heading-17">7. 启动测试</h3>
<p>执行<code>gf run</code>启动项目，通过<strong>Postman或curl</strong>测试接口：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 测试创建用户</span>
curl -X POST http://127.0.0.1:8080/api/v1/users \
-H <span class="hljs-string">"Content-Type: application/json"</span> \
-d <span class="hljs-string">'{"name":"test","email":"test@example.com"}'</span>
</code></pre>
<p>返回如下结果即表示成功：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span><span class="hljs-attr">"code"</span><span class="hljs-punctuation">:</span><span class="hljs-number">200</span><span class="hljs-punctuation">,</span><span class="hljs-attr">"msg"</span><span class="hljs-punctuation">:</span><span class="hljs-string">"创建成功"</span><span class="hljs-punctuation">,</span><span class="hljs-attr">"data"</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">{</span><span class="hljs-attr">"id"</span><span class="hljs-punctuation">:</span><span class="hljs-number">1</span><span class="hljs-punctuation">}</span><span class="hljs-punctuation">}</span>
</code></pre>
<h2 data-id="heading-18">四、谁该选择GoFrame？</h2>
<p>经过<strong>3年多的实战体验</strong>，我认为以下几类开发者/团队<strong>最适合使用GoFrame</strong>：</p>
<ol>
<li><strong>PHP/Laravel转Go的开发者</strong>：最低学习成本，最快上手速度，无需重构开发思维；</li>
<li><strong>追求"开发效率+运行性能"的团队</strong>：既想要Laravel式的高效开发，又需要应对高并发场景；</li>
<li><strong>微服务架构项目</strong>：模块化设计适合拆分部署，Go语言的轻量特性降低服务运维成本；</li>
<li><strong>国内中小企业</strong>：中文文档+活跃社区，解决问题更高效，无需依赖海外资源。</li>
</ol>
<p>当然，GoFrame<strong>并非万能</strong>。如果只是开发一个<strong>极简的静态网站或个人工具</strong>，Gin等轻量框架可能更合适；如果项目涉及<strong>复杂的领域驱动设计</strong>，可能需要结合其他工具补充。但对于<strong>绝大多数Web开发场景</strong>，GoFrame的"<strong>不折腾</strong>"哲学——提供全套解决方案但不捆绑开发者——都能带来<strong>极佳的体验</strong>。</p>
<h2 data-id="heading-19">五、最后建议</h2>
<p>如果你正打算从PHP转向Go，或者正在为Go项目选择框架，不妨花一个周末的时间<strong>试试GoFrame</strong>：</p>
<ol>
<li>从<a href="https://link.juejin.cn?target=https%3A%2F%2Fgoframe.org%2F" target="_blank" title="https://goframe.org/" ref="nofollow noopener noreferrer">官方文档</a>的"<strong>快速开始</strong>"入手，熟悉核心概念；</li>
<li>用<code>gf</code>工具创建一个demo项目，亲手实现<strong>简单的CRUD</strong>；</li>
<li>遇到问题时，优先查看GitHub的issue和社区讨论，大部分常见问题都有<strong>成熟解决方案</strong>。</li>
</ol>
<p>就像Laravel当年让PHP开发变得优雅一样，GoFrame也正在让Go的Web开发变得<strong>更高效、更愉悦</strong>。对于PHP开发者而言，它不仅是一个框架，更是一座通往Go语言世界的"<strong>无缝桥梁</strong>"。不妨现在就动手试试，相信你会和我一样，爱上这种"<strong>Laravel式体验+Go级性能</strong>"的开发快感。</p>
<h3 data-id="heading-20">互动话题（欢迎评论区交流）</h3>
<ol>
<li>你也是 PHP 转 Go 的开发者吗？踩过哪些框架坑？</li>
<li>你用 GoFrame 做过哪些项目？有没有隐藏技巧可以分享？</li>
<li>下期想我拆解 GoFrame 的哪个功能？（比如权限控制、微服务部署、日志排查）</li>
</ol>
<p>关注我，后续持续输出 GoFrame 实战干货、PHP 转 Go 避坑指南，还有商业项目中的真实案例拆解，帮你快速从 "Go 新手" 熬成 "Go 熟手"💪</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[LangChain.js 1.0 + NestJS 入门 Demo]]></title>    <link>https://juejin.cn/post/7584289165753253942</link>    <guid>https://juejin.cn/post/7584289165753253942</guid>    <pubDate>2025-12-16T09:22:06.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584289165753253942" data-draft-id="7584307642983448617" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="LangChain.js 1.0 + NestJS 入门 Demo"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2025-12-16T09:22:06.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="tirelyl"/> <meta itemprop="url" content="https://juejin.cn/user/870468941789383"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            LangChain.js 1.0 + NestJS 入门 Demo
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/870468941789383/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    tirelyl
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-16T09:22:06.000Z" title="Tue Dec 16 2025 09:22:06 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-16
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>最近在学习 AI Agent 开发，所以避免不了的了解到了 LangChain 这个框架。由于本人一直从事前端开发，所以一直将 JS 语言作为整个全栈的生态语言的选择。LangChain 在今年 10 月份发布了 1.0 版本，但是内外网对于 TS 版本的 LangChain 相关的介绍和实践的资料都非常少，所以我尝试将我最近的学习总结记录一下。</p>
<h2 data-id="heading-0">介绍</h2>
<p>由于最近才开始学习 Agent 开发，对于 LangChain 1.0 之前的版本只是在<a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.langchain.com%2Foss%2Fjavascript%2Fmigrate%2Flangchain-v1%23prompts" target="_blank" title="https://docs.langchain.com/oss/javascript/migrate/langchain-v1#prompts" ref="nofollow noopener noreferrer">文档中的迁移</a>变更模块中大概了解一下。本着学新不学旧的原则，1.0 之前版本的什么 <code>createReactAgent</code> <code>pipe</code> <code>chian</code> 等概念，通通都不去详细了解了（我也学不动了），直接最新版本一把梭。</p>
<h2 data-id="heading-1">初始化 NestJs</h2>
<p>为了更好地演示生产中的场景，我选择 <a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.nestjs.com%2F" target="_blank" title="https://docs.nestjs.com/" ref="nofollow noopener noreferrer">NestJs</a> 框架，Nest 中所提供的原始脚手架以及模块等概念，能够更好地演示编写一个 Agent 在生产环境中的逻辑划分。</p>
<p>使用 Nestjs 创建两个模块：</p>
<ol>
<li><code>AgentModule</code>：编写 Agent 逻辑，提供 <code>AgentService</code> 。</li>
<li><code>ChatModule</code>：编写我们的聊天对话接口，提供调用 Agent 的 API。</li>
</ol>
<p>相关命令：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 全局安装 NestJs cli</span>
npm install -g @nest/cli

<span class="hljs-comment"># 使用 Nest Cli 创建一个 Nest 项目</span>
nest new project-name

<span class="hljs-comment"># 创建 AgentModule</span>
nest g module agent

<span class="hljs-comment"># 创建 AgentService</span>
nest g service agent

<span class="hljs-comment"># 创建 ChatModule</span>
nest g module chat

<span class="hljs-comment"># 创建 ChatController</span>
nest g controller chat

</code></pre>
<p>最终我们的 Nest 项目结构如下图所示：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4a0cd2769b4d44fa8a8bce619427db2b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdGlyZWx5bA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766481725&amp;x-signature=FzNcJFHBixo%2FJVNgeK6Ne3b5buo%3D" alt="image.png" loading="lazy"/></p>
<p>最后我们将做一些导入和导出的处理：</p>
<p><code>AgentModule</code> 中需要导出 <code>AgentService</code>，供 <code>ChatModule</code> 中的 Controller 使用。</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// agent.module.ts</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Module</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">AgentService</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./agent.service'</span>;

<span class="hljs-meta">@Module</span>({
  <span class="hljs-attr">providers</span>: [<span class="hljs-title class_">AgentService</span>],
  <span class="hljs-attr">exports</span>: [<span class="hljs-title class_">AgentService</span>], <span class="hljs-comment">// 导出 AgentService</span>
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AgentModule</span> {}
</code></pre>
<p><code>ChatModule</code> 中导入 <code>AgentModule</code>，以供在 <code>ChatController</code> 中使用 <code>AgentService</code> 来编写 API 逻辑。</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// chat.module.ts</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Module</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">ChatController</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./chat.controller'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">AgentModule</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'../agent/agent.module'</span>;

<span class="hljs-meta">@Module</span>({
  <span class="hljs-attr">imports</span>: [<span class="hljs-title class_">AgentModule</span>],
  <span class="hljs-attr">controllers</span>: [<span class="hljs-title class_">ChatController</span>],
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChatModule</span> {}
</code></pre>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// chat.controller.ts</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Controller</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">AgentService</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'../agent/agent.service'</span>;

<span class="hljs-meta">@Controller</span>(<span class="hljs-string">'chat'</span>)
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChatController</span> {
  <span class="hljs-comment">// 使用依赖注入 `AgentService`</span>
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> agentService: AgentService</span>) {}
}
</code></pre>
<p><code>AppModule</code> 中导入 <code>ChatModule</code> 让我们的 API 接口能够注册到整个项目中。</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// app.module.ts</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Module</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">ChatModule</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./chat/chat.module'</span>;

<span class="hljs-meta">@Module</span>({
  <span class="hljs-attr">imports</span>: [<span class="hljs-title class_">ChatModule</span>], <span class="hljs-comment">// 确保 `ChatModule` 导入</span>
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppModule</span> {}

</code></pre>
<p>到此为止我们项目的初始结构就搭建完成了</p>
<h2 data-id="heading-2">安装 LangChain</h2>
<pre><code class="hljs language-bash" lang="bash">npm install langchain @langchain/openai @langchain/core
</code></pre>
<h2 data-id="heading-3">AgentService 逻辑</h2>
<p>使用 LangChain 1.0 来编写我们的 Agent 逻辑，在这个简单的 demo 中，提供以下功能：</p>
<ul>
<li>LLM 的初始化以及简单配置。</li>
<li>提供一个简单的查询天气的 tool，供 Agent 使用（以官方文档中展示的 demo 为例）。</li>
<li>提供基于本地内存的 Memory，保证一次简单 Agent 对话流程的完整性。</li>
</ul>
<p>完整代码：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// agent.service.ts</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Injectable</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">ConfigService</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/config'</span>;

<span class="hljs-keyword">import</span> { <span class="hljs-title class_">ChatOpenAI</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@langchain/openai'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">HumanMessage</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@langchain/core/messages'</span>;
<span class="hljs-keyword">import</span> { tool } <span class="hljs-keyword">from</span> <span class="hljs-string">'@langchain/core/tools'</span>;
<span class="hljs-keyword">import</span> { createAgent, <span class="hljs-keyword">type</span> <span class="hljs-title class_">ReactAgent</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'langchain'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">MemorySaver</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@langchain/langgraph'</span>;
<span class="hljs-keyword">import</span> z <span class="hljs-keyword">from</span> <span class="hljs-string">'zod'</span>;

<span class="hljs-meta">@Injectable</span>()
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AgentService</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-attr">agent</span>: <span class="hljs-title class_">ReactAgent</span>;

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> configService: ConfigService</span>) {
    <span class="hljs-comment">// 初始化 LLM 语言模型</span>
    <span class="hljs-keyword">const</span> model = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChatOpenAI</span>({
      <span class="hljs-attr">model</span>: <span class="hljs-string">'qwen-plus'</span>, <span class="hljs-comment">// 使用 Qwen-Plus 模型，任何兼容 OpenAI API 的模型均可使用</span>
      <span class="hljs-attr">apiKey</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">configService</span>.<span class="hljs-property">get</span>&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-string">'AI_API_KEY'</span>), <span class="hljs-comment">// 配置自己获取的 api key</span>
      <span class="hljs-attr">configuration</span>: {
        <span class="hljs-attr">baseURL</span>: <span class="hljs-string">'https://dashscope.aliyuncs.com/compatible-mode/v1'</span>, <span class="hljs-comment">// 针对自己使用的模型提供商，调整该值</span>
      },
      <span class="hljs-attr">temperature</span>: <span class="hljs-number">0.1</span>,
    });

    <span class="hljs-comment">// 定义天气查询工具</span>
    <span class="hljs-keyword">const</span> getWeatherTool = <span class="hljs-title function_">tool</span>(
      <span class="hljs-function">(<span class="hljs-params">{ location }</span>) =&gt;</span> <span class="hljs-string">`<span class="hljs-subst">${location}</span> 的天气是: 晴天☀️, 72°F`</span>, <span class="hljs-comment">// 此处是写死的逻辑，生产中应该使用真实的接口进行查询</span>
      {
        <span class="hljs-attr">name</span>: <span class="hljs-string">'get_weather'</span>,
        <span class="hljs-attr">description</span>: <span class="hljs-string">'获取某个地点的天气信息'</span>,
        <span class="hljs-attr">schema</span>: z.<span class="hljs-title function_">object</span>({
          <span class="hljs-attr">location</span>: z.<span class="hljs-title function_">string</span>().<span class="hljs-title function_">describe</span>(<span class="hljs-string">'用户获取天气预报的地点'</span>),
        }),
      },
    );

    <span class="hljs-comment">// 初始化检查点存储器</span>
    <span class="hljs-keyword">const</span> checkpointer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MemorySaver</span>();

    <span class="hljs-comment">// 初始化 Agent</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">agent</span> = <span class="hljs-title function_">createAgent</span>({
      model,
      <span class="hljs-attr">systemPrompt</span>: <span class="hljs-string">'你是一个帮助人们查找信息的人工智能助手。'</span>,
      <span class="hljs-attr">tools</span>: [getWeatherTool],
      checkpointer,
    });
  }

  <span class="hljs-comment">/**
   * 与 agent 对话（普通响应）
   */</span>
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">chatWithAgent</span>(<span class="hljs-params">message: <span class="hljs-built_in">string</span>, threadId: <span class="hljs-built_in">string</span></span>) {
    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">agent</span>.<span class="hljs-title function_">invoke</span>(
      {
        <span class="hljs-attr">messages</span>: [<span class="hljs-keyword">new</span> <span class="hljs-title class_">HumanMessage</span>(message)],
      },
      {
        <span class="hljs-attr">configurable</span>: {
          <span class="hljs-attr">thread_id</span>: threadId, <span class="hljs-comment">// thread_id 提供给 checkpointer，用于识别当前对话应该使用哪个聊天会话的记忆 </span>
        },
      },
    );

    <span class="hljs-comment">// 简单粗暴返回最后的 AI 总结的信息</span>
    <span class="hljs-keyword">return</span> result.<span class="hljs-property">messages</span>[result.<span class="hljs-property">messages</span>.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>].<span class="hljs-property">content</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>;
  }
}
</code></pre>
<h3 data-id="heading-4"><code>checkpointer</code> 变量</h3>
<p>由于最简单的大模型对话流程中，AI 是没有自己的记忆的，对话历史需要自己编写逻辑保存，然后将保存后的记录整体扔给大模型，这样的操作过于复杂。引入 checkpointer，它是 langgraph 的 MemorySaver，用来给 Agent 做“检查点”存储，解决多轮/多次调用时状态丢失的问题。在我们这个简单的接口对话 demo 中，让 AI 具备连续对话的能力。
设置了 <code>checkpointer</code> 后，在后续的 agent 调用时，需要传入 <code>thread_id</code>，它会作为对话的 key 值，针对唯一的 key，来保存某次会话的聊天记忆。
在本 demo 中，使用了<code>@langchain/langgraph</code> 包中的 <code>MemorySaver</code>，该类使用内存最为一次对话的临时存储，在 node 进程重启后，会丢失所有记忆。所以只适合在 demo 中演示。实际生产环境的后端项目，可以考虑和数据库作持久储存。</p>
<h3 data-id="heading-5">关于 <code>AgentService.agent</code> 成员变量的 ts 提示</h3>
<p>这里不选择在 agent 变量定义时初始化，而是在 constructor 方法中初始化，是因为 <code>createAgent</code> 方法所需要的参数有很多需要复杂的编排逻辑，以及从依赖注入中获取（例如从 <code>ConfigService</code> 中获取环境变量等）。由于 <code>ReactAgent</code> 类型有着复杂的泛型参数定义，如果不能和后续的 <code>createAgent</code> 方法返回的 agent 类型对齐的话，在严格的 ts 类型校验模式下会出现类型报错，对于不喜欢把 TypeScript 当 AnyScript 的人来说，建议转到 <code>ReactAgent</code>的类型定义中详细看下泛型参数的定义。</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">import</span> { <span class="hljs-keyword">type</span> <span class="hljs-title class_">ReactAgent</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'langchain'</span>;

<span class="hljs-comment">// 定义上下文 Schema</span>
<span class="hljs-keyword">const</span> agentContextSchema = z.<span class="hljs-title function_">object</span>({
  <span class="hljs-comment">// 上下文中，永远不变的 userId，可以用于数据库查询，身份验证等</span>
  <span class="hljs-attr">userId</span>: z.<span class="hljs-title function_">number</span>(),
});

<span class="hljs-meta">@Injectable</span>()
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AgentService</span> {
  <span class="hljs-comment">// 第一个泛型参数 StructuredResponseFormat（结构化后的模型输出结构）， 默认值为 `Record&lt;string, any&gt;`</span>
  <span class="hljs-comment">// 第二个泛型参数 StateSchema（graph state 数据结构），默认值为 undefined</span>
  <span class="hljs-comment">// 第三个泛型参数为 ContextSchema（graph context 数据结构），需要传入自己定义的上下文 schema</span>
  <span class="hljs-keyword">private</span> <span class="hljs-attr">agent</span>: <span class="hljs-title class_">ReactAgent</span>&lt;<span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">any</span>&gt;, <span class="hljs-literal">undefined</span>, <span class="hljs-keyword">typeof</span> agentContextSchema&gt;;
}

</code></pre>
<h2 data-id="heading-6"><code>ChatController</code> 提供对话接口</h2>
<p>这部分代码很简单，将我们编写好的 Agent 服务封装成 restful 接口，此处只演示一个 chat 接口
全部代码：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Body</span>, <span class="hljs-title class_">Controller</span>, <span class="hljs-title class_">Post</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">AgentService</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'../agent/agent.service'</span>;

<span class="hljs-meta">@Controller</span>(<span class="hljs-string">'chat'</span>)
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChatController</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> agentService: AgentService</span>) {}

  <span class="hljs-comment">// 访问该接口：http://localhost:3000/chat</span>
  <span class="hljs-meta">@Post</span>()
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">chat</span>(<span class="hljs-params"><span class="hljs-meta">@Body</span>() body: { message: <span class="hljs-built_in">string</span>; threadId: <span class="hljs-built_in">string</span> }</span>) {
    <span class="hljs-keyword">const</span> content = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">agentService</span>.<span class="hljs-title function_">chatWithAgent</span>(
      body.<span class="hljs-property">message</span>,
      body.<span class="hljs-property">threadId</span>,
    );
    <span class="hljs-keyword">return</span> {
      content,
    };
  }
}
</code></pre>
<p>尝试访问接口：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4516036e3ad34fd1a2437db67a530129~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdGlyZWx5bA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766481725&amp;x-signature=Enb80lJwqBSB9QWuEWI7SpUFMXg%3D" alt="image.png" loading="lazy"/></p>
<p>调用天气工具：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7f3d437b12da4c23a451728bcf8e1508~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdGlyZWx5bA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766481725&amp;x-signature=aSFzqXTaTZvSuM3ZhFGrcrLea9k%3D" alt="image.png" loading="lazy"/></p>
<p>展示记忆功能：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c24c4b3ea23c4244888cc0fc3c2a41ce~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdGlyZWx5bA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766481725&amp;x-signature=r%2Ftq47KsSXjMHxgS5%2F4EMOWKshM%3D" alt="image.png" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8159ec36331f4fa3b8780a6167c20d83~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdGlyZWx5bA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766481725&amp;x-signature=g5y1ilxJlCpqgM60r1yEYYP6aWY%3D" alt="image.png" loading="lazy"/></p>
<h2 data-id="heading-7">总结</h2>
<p>作为 LangChain 框架官方重点支持的两种语言之一，TypeScript 在 1.0 版本中与 NestJS 结合使用的实践资料相对较少。希望这篇文章能帮助到入门的同学。</p>
<p>在实际使用过程中，LangChain 强大的编排能力往往依赖于大量的泛型参数来完善类型约束。如果不希望频繁使用 <code>as any</code> 进行类型断言，就需要对其源码中的类型设计有较为深入的理解，这对使用者的 TypeScript 基础提出了更高要求。</p>
<p>本人也是一名后端方向的初学者，以上内容更多是个人在学习和实践过程中的一些总结与思考。如果本文能对你有所帮助，欢迎点赞和交流，非常感谢 🙏</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Node.js 文件系统 fs]]></title>    <link>https://juejin.cn/post/7584059298697052201</link>    <guid>https://juejin.cn/post/7584059298697052201</guid>    <pubDate>2025-12-16T09:25:44.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584059298697052201" data-draft-id="7584289165753335862" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Node.js 文件系统 fs"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2025-12-16T09:25:44.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="梨子同志"/> <meta itemprop="url" content="https://juejin.cn/user/2084329779627965"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Node.js 文件系统 fs
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2084329779627965/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    梨子同志
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-16T09:25:44.000Z" title="Tue Dec 16 2025 09:25:44 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-16
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读9分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p><strong>参考资源：</strong></p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fnodejs.org%2Fapi%2Ffs.html" target="_blank" title="https://nodejs.org/api/fs.html" ref="nofollow noopener noreferrer">Node.js 官方文档 - File System</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.w3schools.com%2Fnodejs%2Fdefault.asp" target="_blank" title="https://www.w3schools.com/nodejs/default.asp" ref="nofollow noopener noreferrer">W3Schools Node.js 教程</a></li>
</ul>
</blockquote>
<hr/>
<p>Node.js 提供了强大的文件系统（File System）模块，允许开发者与文件系统进行交互。<code>fs</code> 模块提供了同步和异步两种操作方式，支持文件读写、目录操作、文件监听、流式操作等功能。本文将深入探讨 Node.js 文件系统的各个方面，包括基础操作和高级特性。</p>
<hr/>
<h2 data-id="heading-0">一、文件系统基础</h2>
<h3 data-id="heading-1">1.1 引入 fs 模块</h3>
<p>在 Node.js 中，使用 <code>require()</code> 或 <code>import</code> 引入文件系统模块：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// CommonJS 方式</span>
<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

<span class="hljs-comment">// ES Modules 方式</span>
<span class="hljs-keyword">import</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">'fs'</span>;
</code></pre>
<h3 data-id="heading-2">1.2 异步与同步操作</h3>
<p>Node.js 文件系统提供了两种操作方式：</p>
<ul>
<li><strong>异步操作</strong>：非阻塞，使用回调函数处理结果（推荐）</li>
<li><strong>同步操作</strong>：阻塞，直接返回结果（适用于脚本或初始化）</li>
</ul>
<p><strong>最佳实践：</strong> 在生产环境中优先使用异步操作，避免阻塞事件循环。</p>
<hr/>
<h2 data-id="heading-3">二、文件读写操作</h2>
<h3 data-id="heading-4">2.1 读取文件</h3>
<h4 data-id="heading-5">2.1.1 异步读取文件（readFile）</h4>
<p><code>fs.readFile()</code> 是异步读取文件的推荐方式：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

<span class="hljs-comment">// 基本用法</span>
fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">'example.txt'</span>, <span class="hljs-string">'utf8'</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (err) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'读取文件失败:'</span>, err);
    <span class="hljs-keyword">return</span>;
  }
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'文件内容:'</span>, data);
});

<span class="hljs-comment">// 读取二进制文件（如图片）</span>
fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">'image.png'</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (err) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'读取失败:'</span>, err);
    <span class="hljs-keyword">return</span>;
  }
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'文件大小:'</span>, data.<span class="hljs-property">length</span>, <span class="hljs-string">'字节'</span>);
});
</code></pre>
<p><strong>参数说明：</strong></p>
<ul>
<li><code>path</code>: 文件路径（字符串、Buffer 或 URL）</li>
<li><code>encoding</code>: 编码格式（可选，如 'utf8'、'ascii'、'base64'）</li>
<li><code>callback</code>: 回调函数 <code>(err, data) =&gt; {}</code></li>
</ul>
<h4 data-id="heading-6">2.1.2 同步读取文件（readFileSync）</h4>
<p><code>fs.readFileSync()</code> 是同步读取文件的方式：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

<span class="hljs-keyword">try</span> {
  <span class="hljs-comment">// 同步读取，会阻塞执行</span>
  <span class="hljs-keyword">const</span> data = fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">'example.txt'</span>, <span class="hljs-string">'utf8'</span>);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'文件内容:'</span>, data);
} <span class="hljs-keyword">catch</span> (err) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'读取文件失败:'</span>, err);
}

<span class="hljs-comment">// 读取二进制文件</span>
<span class="hljs-keyword">try</span> {
  <span class="hljs-keyword">const</span> buffer = fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">'image.png'</span>);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'文件大小:'</span>, buffer.<span class="hljs-property">length</span>, <span class="hljs-string">'字节'</span>);
} <span class="hljs-keyword">catch</span> (err) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'读取失败:'</span>, err);
}
</code></pre>
<p><strong>注意事项：</strong></p>
<ul>
<li>同步操作会阻塞 Node.js 事件循环</li>
<li>适合在应用启动时读取配置文件</li>
<li>不适合处理大文件或高并发场景</li>
</ul>
<h3 data-id="heading-7">2.2 写入文件</h3>
<h4 data-id="heading-8">2.2.1 异步写入文件（writeFile）</h4>
<p><code>fs.writeFile()</code> 用于异步写入文件：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

<span class="hljs-comment">// 写入文本文件</span>
fs.<span class="hljs-title function_">writeFile</span>(<span class="hljs-string">'output.txt'</span>, <span class="hljs-string">'Hello Node.js!'</span>, <span class="hljs-string">'utf8'</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (err) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'写入失败:'</span>, err);
    <span class="hljs-keyword">return</span>;
  }
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'文件写入成功'</span>);
});

<span class="hljs-comment">// 写入 JSON 数据</span>
<span class="hljs-keyword">const</span> data = { <span class="hljs-attr">name</span>: <span class="hljs-string">'Node.js'</span>, <span class="hljs-attr">version</span>: <span class="hljs-string">'18.0.0'</span> };
fs.<span class="hljs-title function_">writeFile</span>(<span class="hljs-string">'data.json'</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data, <span class="hljs-literal">null</span>, <span class="hljs-number">2</span>), <span class="hljs-string">'utf8'</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (err) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'写入失败:'</span>, err);
    <span class="hljs-keyword">return</span>;
  }
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'JSON 文件写入成功'</span>);
});

<span class="hljs-comment">// 追加内容（使用 flag: 'a'）</span>
fs.<span class="hljs-title function_">writeFile</span>(<span class="hljs-string">'log.txt'</span>, <span class="hljs-string">'新的一行\n'</span>, { <span class="hljs-attr">flag</span>: <span class="hljs-string">'a'</span>, <span class="hljs-attr">encoding</span>: <span class="hljs-string">'utf8'</span> }, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (err) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'追加失败:'</span>, err);
    <span class="hljs-keyword">return</span>;
  }
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'内容追加成功'</span>);
});
</code></pre>
<p><strong>常用 flag 选项：</strong></p>
<ul>
<li><code>'w'</code>: 写入（覆盖，默认）</li>
<li><code>'a'</code>: 追加</li>
<li><code>'r+'</code>: 读写</li>
<li><code>'wx'</code>: 写入（如果文件不存在则失败）</li>
</ul>
<h4 data-id="heading-9">2.2.2 同步写入文件（writeFileSync）</h4>
<p><code>fs.writeFileSync()</code> 用于同步写入文件：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

<span class="hljs-keyword">try</span> {
  fs.<span class="hljs-title function_">writeFileSync</span>(<span class="hljs-string">'output.txt'</span>, <span class="hljs-string">'Hello Node.js!'</span>, <span class="hljs-string">'utf8'</span>);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'文件写入成功'</span>);
} <span class="hljs-keyword">catch</span> (err) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'写入失败:'</span>, err);
}

<span class="hljs-comment">// 追加内容</span>
<span class="hljs-keyword">try</span> {
  fs.<span class="hljs-title function_">writeFileSync</span>(<span class="hljs-string">'log.txt'</span>, <span class="hljs-string">'新的一行\n'</span>, { <span class="hljs-attr">flag</span>: <span class="hljs-string">'a'</span>, <span class="hljs-attr">encoding</span>: <span class="hljs-string">'utf8'</span> });
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'内容追加成功'</span>);
} <span class="hljs-keyword">catch</span> (err) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'追加失败:'</span>, err);
}
</code></pre>
<h3 data-id="heading-10">2.3 追加文件内容</h3>
<p>除了使用 <code>writeFile</code> 的 <code>flag: 'a'</code> 选项，还可以使用专门的追加方法：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

<span class="hljs-comment">// 异步追加</span>
fs.<span class="hljs-title function_">appendFile</span>(<span class="hljs-string">'log.txt'</span>, <span class="hljs-string">'新的日志条目\n'</span>, <span class="hljs-string">'utf8'</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (err) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'追加失败:'</span>, err);
    <span class="hljs-keyword">return</span>;
  }
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'追加成功'</span>);
});

<span class="hljs-comment">// 同步追加</span>
<span class="hljs-keyword">try</span> {
  fs.<span class="hljs-title function_">appendFileSync</span>(<span class="hljs-string">'log.txt'</span>, <span class="hljs-string">'新的日志条目\n'</span>, <span class="hljs-string">'utf8'</span>);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'追加成功'</span>);
} <span class="hljs-keyword">catch</span> (err) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'追加失败:'</span>, err);
}
</code></pre>
<hr/>
<h2 data-id="heading-11">三、目录操作</h2>
<h3 data-id="heading-12">3.1 创建目录</h3>
<h4 data-id="heading-13">3.1.1 异步创建目录（mkdir）</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

<span class="hljs-comment">// 创建单个目录</span>
fs.<span class="hljs-title function_">mkdir</span>(<span class="hljs-string">'newDir'</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (err) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'创建目录失败:'</span>, err);
    <span class="hljs-keyword">return</span>;
  }
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'目录创建成功'</span>);
});

<span class="hljs-comment">// 创建嵌套目录（需要 recursive: true）</span>
fs.<span class="hljs-title function_">mkdir</span>(<span class="hljs-string">'path/to/nested/dir'</span>, { <span class="hljs-attr">recursive</span>: <span class="hljs-literal">true</span> }, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (err) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'创建目录失败:'</span>, err);
    <span class="hljs-keyword">return</span>;
  }
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'嵌套目录创建成功'</span>);
});
</code></pre>
<h4 data-id="heading-14">3.1.2 同步创建目录（mkdirSync）</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

<span class="hljs-keyword">try</span> {
  <span class="hljs-comment">// 创建单个目录</span>
  fs.<span class="hljs-title function_">mkdirSync</span>(<span class="hljs-string">'newDir'</span>);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'目录创建成功'</span>);
  
  <span class="hljs-comment">// 创建嵌套目录</span>
  fs.<span class="hljs-title function_">mkdirSync</span>(<span class="hljs-string">'path/to/nested/dir'</span>, { <span class="hljs-attr">recursive</span>: <span class="hljs-literal">true</span> });
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'嵌套目录创建成功'</span>);
} <span class="hljs-keyword">catch</span> (err) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'创建目录失败:'</span>, err);
}
</code></pre>
<h3 data-id="heading-15">3.2 读取目录</h3>
<h4 data-id="heading-16">3.2.1 异步读取目录（readdir）</h4>
<p><code>fs.readdir()</code> 用于读取目录内容：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);

<span class="hljs-comment">// 基本用法</span>
fs.<span class="hljs-title function_">readdir</span>(<span class="hljs-string">'./'</span>, <span class="hljs-function">(<span class="hljs-params">err, files</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (err) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'读取目录失败:'</span>, err);
    <span class="hljs-keyword">return</span>;
  }
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'目录内容:'</span>, files);
});

<span class="hljs-comment">// 读取详细信息（使用 withFileTypes）</span>
fs.<span class="hljs-title function_">readdir</span>(<span class="hljs-string">'./'</span>, { <span class="hljs-attr">withFileTypes</span>: <span class="hljs-literal">true</span> }, <span class="hljs-function">(<span class="hljs-params">err, entries</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (err) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'读取目录失败:'</span>, err);
    <span class="hljs-keyword">return</span>;
  }
  
  entries.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">entry</span> =&gt;</span> {
    <span class="hljs-keyword">if</span> (entry.<span class="hljs-title function_">isDirectory</span>()) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`目录: <span class="hljs-subst">${entry.name}</span>`</span>);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (entry.<span class="hljs-title function_">isFile</span>()) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`文件: <span class="hljs-subst">${entry.name}</span>`</span>);
    }
  });
});

<span class="hljs-comment">// 递归读取目录</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">readDirRecursive</span>(<span class="hljs-params">dirPath</span>) {
  fs.<span class="hljs-title function_">readdir</span>(dirPath, { <span class="hljs-attr">withFileTypes</span>: <span class="hljs-literal">true</span> }, <span class="hljs-function">(<span class="hljs-params">err, entries</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (err) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'读取失败:'</span>, err);
      <span class="hljs-keyword">return</span>;
    }
    
    entries.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">entry</span> =&gt;</span> {
      <span class="hljs-keyword">const</span> fullPath = path.<span class="hljs-title function_">join</span>(dirPath, entry.<span class="hljs-property">name</span>);
      <span class="hljs-keyword">if</span> (entry.<span class="hljs-title function_">isDirectory</span>()) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`目录: <span class="hljs-subst">${fullPath}</span>`</span>);
        <span class="hljs-title function_">readDirRecursive</span>(fullPath);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`文件: <span class="hljs-subst">${fullPath}</span>`</span>);
      }
    });
  });
}

<span class="hljs-title function_">readDirRecursive</span>(<span class="hljs-string">'./'</span>);
</code></pre>
<h4 data-id="heading-17">3.2.2 同步读取目录（readdirSync）</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

<span class="hljs-keyword">try</span> {
  <span class="hljs-keyword">const</span> files = fs.<span class="hljs-title function_">readdirSync</span>(<span class="hljs-string">'./'</span>);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'目录内容:'</span>, files);
  
  <span class="hljs-comment">// 读取详细信息</span>
  <span class="hljs-keyword">const</span> entries = fs.<span class="hljs-title function_">readdirSync</span>(<span class="hljs-string">'./'</span>, { <span class="hljs-attr">withFileTypes</span>: <span class="hljs-literal">true</span> });
  entries.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">entry</span> =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(entry.<span class="hljs-title function_">isDirectory</span>() ? <span class="hljs-string">`目录: <span class="hljs-subst">${entry.name}</span>`</span> : <span class="hljs-string">`文件: <span class="hljs-subst">${entry.name}</span>`</span>);
  });
} <span class="hljs-keyword">catch</span> (err) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'读取目录失败:'</span>, err);
}
</code></pre>
<h3 data-id="heading-18">3.3 删除目录</h3>
<h4 data-id="heading-19">3.3.1 异步删除目录（rmdir）</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

<span class="hljs-comment">// 删除空目录</span>
fs.<span class="hljs-title function_">rmdir</span>(<span class="hljs-string">'emptyDir'</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (err) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'删除目录失败:'</span>, err);
    <span class="hljs-keyword">return</span>;
  }
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'目录删除成功'</span>);
});

<span class="hljs-comment">// 删除非空目录（需要 recursive: true）</span>
fs.<span class="hljs-title function_">rmdir</span>(<span class="hljs-string">'nonEmptyDir'</span>, { <span class="hljs-attr">recursive</span>: <span class="hljs-literal">true</span> }, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (err) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'删除目录失败:'</span>, err);
    <span class="hljs-keyword">return</span>;
  }
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'目录及其内容删除成功'</span>);
});
</code></pre>
<p><strong>注意：</strong> 在 Node.js 14.14.0+ 版本中，推荐使用 <code>fs.rm()</code> 替代 <code>fs.rmdir()</code> 删除非空目录。</p>
<h4 data-id="heading-20">3.3.2 同步删除目录（rmdirSync）</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

<span class="hljs-keyword">try</span> {
  <span class="hljs-comment">// 删除空目录</span>
  fs.<span class="hljs-title function_">rmdirSync</span>(<span class="hljs-string">'emptyDir'</span>);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'目录删除成功'</span>);
  
  <span class="hljs-comment">// 删除非空目录</span>
  fs.<span class="hljs-title function_">rmdirSync</span>(<span class="hljs-string">'nonEmptyDir'</span>, { <span class="hljs-attr">recursive</span>: <span class="hljs-literal">true</span> });
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'目录及其内容删除成功'</span>);
} <span class="hljs-keyword">catch</span> (err) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'删除目录失败:'</span>, err);
}
</code></pre>
<h3 data-id="heading-21">3.4 删除文件</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

<span class="hljs-comment">// 异步删除文件</span>
fs.<span class="hljs-title function_">unlink</span>(<span class="hljs-string">'file.txt'</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (err) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'删除文件失败:'</span>, err);
    <span class="hljs-keyword">return</span>;
  }
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'文件删除成功'</span>);
});

<span class="hljs-comment">// 同步删除文件</span>
<span class="hljs-keyword">try</span> {
  fs.<span class="hljs-title function_">unlinkSync</span>(<span class="hljs-string">'file.txt'</span>);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'文件删除成功'</span>);
} <span class="hljs-keyword">catch</span> (err) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'删除文件失败:'</span>, err);
}
</code></pre>
<hr/>
<h2 data-id="heading-22">四、文件系统高级操作</h2>
<h3 data-id="heading-23">4.1 文件监听</h3>
<h4 data-id="heading-24">4.1.1 使用 watch 监听文件变化</h4>
<p><code>fs.watch()</code> 是跨平台的文件监听 API，但行为可能因平台而异：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

<span class="hljs-comment">// 监听文件</span>
<span class="hljs-keyword">const</span> watcher = fs.<span class="hljs-title function_">watch</span>(<span class="hljs-string">'example.txt'</span>, <span class="hljs-function">(<span class="hljs-params">eventType, filename</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (filename) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`事件类型: <span class="hljs-subst">${eventType}</span>`</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`文件名: <span class="hljs-subst">${filename}</span>`</span>);
    
    <span class="hljs-keyword">if</span> (eventType === <span class="hljs-string">'change'</span>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'文件内容发生变化'</span>);
      <span class="hljs-comment">// 读取最新内容</span>
      fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">'example.txt'</span>, <span class="hljs-string">'utf8'</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> {
        <span class="hljs-keyword">if</span> (!err) {
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'最新内容:'</span>, data);
        }
      });
    }
  }
});

<span class="hljs-comment">// 监听目录</span>
<span class="hljs-keyword">const</span> dirWatcher = fs.<span class="hljs-title function_">watch</span>(<span class="hljs-string">'./'</span>, { <span class="hljs-attr">recursive</span>: <span class="hljs-literal">true</span> }, <span class="hljs-function">(<span class="hljs-params">eventType, filename</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`事件类型: <span class="hljs-subst">${eventType}</span>, 文件: <span class="hljs-subst">${filename}</span>`</span>);
});

<span class="hljs-comment">// 关闭监听器</span>
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
  watcher.<span class="hljs-title function_">close</span>();
  dirWatcher.<span class="hljs-title function_">close</span>();
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'监听器已关闭'</span>);
}, <span class="hljs-number">60000</span>); <span class="hljs-comment">// 60秒后关闭</span>
</code></pre>
<p><strong>事件类型：</strong></p>
<ul>
<li><code>'rename'</code>: 文件或目录被重命名或删除</li>
<li><code>'change'</code>: 文件内容发生变化</li>
</ul>
<h4 data-id="heading-25">4.1.2 使用 watchFile 监听文件（已弃用）</h4>
<p><code>fs.watchFile()</code> 使用轮询机制，性能较差，不推荐使用：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

<span class="hljs-comment">// 监听文件变化（轮询方式）</span>
fs.<span class="hljs-title function_">watchFile</span>(<span class="hljs-string">'example.txt'</span>, { <span class="hljs-attr">interval</span>: <span class="hljs-number">1000</span> }, <span class="hljs-function">(<span class="hljs-params">curr, prev</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (curr.<span class="hljs-property">mtime</span> !== prev.<span class="hljs-property">mtime</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'文件已修改'</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'当前修改时间:'</span>, curr.<span class="hljs-property">mtime</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'之前修改时间:'</span>, prev.<span class="hljs-property">mtime</span>);
  }
});

<span class="hljs-comment">// 停止监听</span>
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
  fs.<span class="hljs-title function_">unwatchFile</span>(<span class="hljs-string">'example.txt'</span>);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'已停止监听'</span>);
}, <span class="hljs-number">30000</span>);
</code></pre>
<p><strong>注意：</strong> <code>fs.watchFile()</code> 已被标记为弃用，推荐使用 <code>fs.watch()</code>。</p>
<h3 data-id="heading-26">4.2 流式文件操作</h3>
<p>流（Stream）是处理大文件的高效方式，避免一次性将整个文件加载到内存中。</p>
<h4 data-id="heading-27">4.2.1 创建可读流</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

<span class="hljs-comment">// 创建可读流</span>
<span class="hljs-keyword">const</span> readStream = fs.<span class="hljs-title function_">createReadStream</span>(<span class="hljs-string">'large-file.txt'</span>, <span class="hljs-string">'utf8'</span>);

readStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">'data'</span>, <span class="hljs-function">(<span class="hljs-params">chunk</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'读取数据块:'</span>, chunk.<span class="hljs-property">length</span>, <span class="hljs-string">'字节'</span>);
  <span class="hljs-comment">// 处理数据块</span>
});

readStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">'end'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'文件读取完成'</span>);
});

readStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">'error'</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'读取错误:'</span>, err);
});
</code></pre>
<h4 data-id="heading-28">4.2.2 创建可写流</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

<span class="hljs-comment">// 创建可写流</span>
<span class="hljs-keyword">const</span> writeStream = fs.<span class="hljs-title function_">createWriteStream</span>(<span class="hljs-string">'output.txt'</span>, <span class="hljs-string">'utf8'</span>);

writeStream.<span class="hljs-title function_">write</span>(<span class="hljs-string">'第一行数据\n'</span>);
writeStream.<span class="hljs-title function_">write</span>(<span class="hljs-string">'第二行数据\n'</span>);
writeStream.<span class="hljs-title function_">write</span>(<span class="hljs-string">'第三行数据\n'</span>);

writeStream.<span class="hljs-title function_">end</span>(); <span class="hljs-comment">// 结束写入</span>

writeStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">'finish'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'文件写入完成'</span>);
});

writeStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">'error'</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'写入错误:'</span>, err);
});
</code></pre>
<h4 data-id="heading-29">4.2.3 使用管道（pipe）复制文件</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

<span class="hljs-comment">// 使用管道复制大文件</span>
<span class="hljs-keyword">const</span> readStream = fs.<span class="hljs-title function_">createReadStream</span>(<span class="hljs-string">'source.txt'</span>);
<span class="hljs-keyword">const</span> writeStream = fs.<span class="hljs-title function_">createWriteStream</span>(<span class="hljs-string">'destination.txt'</span>);

readStream.<span class="hljs-title function_">pipe</span>(writeStream);

readStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">'end'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'文件复制完成'</span>);
});

writeStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">'error'</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'复制错误:'</span>, err);
});
</code></pre>
<h4 data-id="heading-30">4.2.4 流式处理大文件示例</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">const</span> readline = <span class="hljs-built_in">require</span>(<span class="hljs-string">'readline'</span>);

<span class="hljs-comment">// 逐行读取大文件</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">processLargeFile</span>(<span class="hljs-params">filePath</span>) {
  <span class="hljs-keyword">const</span> readStream = fs.<span class="hljs-title function_">createReadStream</span>(filePath, <span class="hljs-string">'utf8'</span>);
  <span class="hljs-keyword">const</span> rl = readline.<span class="hljs-title function_">createInterface</span>({
    <span class="hljs-attr">input</span>: readStream,
    <span class="hljs-attr">crlfDelay</span>: <span class="hljs-title class_">Infinity</span>
  });
  
  rl.<span class="hljs-title function_">on</span>(<span class="hljs-string">'line'</span>, <span class="hljs-function">(<span class="hljs-params">line</span>) =&gt;</span> {
    <span class="hljs-comment">// 处理每一行</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'处理行:'</span>, line);
  });
  
  rl.<span class="hljs-title function_">on</span>(<span class="hljs-string">'close'</span>, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'文件处理完成'</span>);
  });
}

<span class="hljs-title function_">processLargeFile</span>(<span class="hljs-string">'large-file.txt'</span>);
</code></pre>
<h3 data-id="heading-31">4.3 文件权限</h3>
<h4 data-id="heading-32">4.3.1 检查文件权限</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

<span class="hljs-comment">// 检查文件访问权限（异步）</span>
fs.<span class="hljs-title function_">access</span>(<span class="hljs-string">'file.txt'</span>, fs.<span class="hljs-property">constants</span>.<span class="hljs-property">F_OK</span> | fs.<span class="hljs-property">constants</span>.<span class="hljs-property">R_OK</span> | fs.<span class="hljs-property">constants</span>.<span class="hljs-property">W_OK</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (err) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'文件不可访问:'</span>, err);
    <span class="hljs-keyword">return</span>;
  }
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'文件可读可写'</span>);
});

<span class="hljs-comment">// 检查文件权限（同步）</span>
<span class="hljs-keyword">try</span> {
  fs.<span class="hljs-title function_">accessSync</span>(<span class="hljs-string">'file.txt'</span>, fs.<span class="hljs-property">constants</span>.<span class="hljs-property">R_OK</span>);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'文件可读'</span>);
} <span class="hljs-keyword">catch</span> (err) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'文件不可读:'</span>, err);
}
</code></pre>
<p><strong>权限常量：</strong></p>
<ul>
<li><code>fs.constants.F_OK</code>: 文件存在</li>
<li><code>fs.constants.R_OK</code>: 可读</li>
<li><code>fs.constants.W_OK</code>: 可写</li>
<li><code>fs.constants.X_OK</code>: 可执行</li>
</ul>
<h4 data-id="heading-33">4.3.2 修改文件权限</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

<span class="hljs-comment">// 异步修改权限</span>
fs.<span class="hljs-title function_">chmod</span>(<span class="hljs-string">'file.txt'</span>, <span class="hljs-number">0o755</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (err) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'修改权限失败:'</span>, err);
    <span class="hljs-keyword">return</span>;
  }
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'权限修改成功'</span>);
});

<span class="hljs-comment">// 同步修改权限</span>
<span class="hljs-keyword">try</span> {
  fs.<span class="hljs-title function_">chmodSync</span>(<span class="hljs-string">'file.txt'</span>, <span class="hljs-number">0o644</span>);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'权限修改成功'</span>);
} <span class="hljs-keyword">catch</span> (err) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'修改权限失败:'</span>, err);
}
</code></pre>
<p><strong>权限模式说明：</strong></p>
<ul>
<li><code>0o755</code>: 所有者可读可写可执行，组和其他用户可读可执行</li>
<li><code>0o644</code>: 所有者可读可写，组和其他用户只读</li>
</ul>
<h3 data-id="heading-34">4.4 文件统计信息</h3>
<h4 data-id="heading-35">4.4.1 获取文件统计信息（stat）</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

<span class="hljs-comment">// 异步获取文件统计信息</span>
fs.<span class="hljs-title function_">stat</span>(<span class="hljs-string">'file.txt'</span>, <span class="hljs-function">(<span class="hljs-params">err, stats</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (err) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'获取统计信息失败:'</span>, err);
    <span class="hljs-keyword">return</span>;
  }
  
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'文件统计信息:'</span>);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'是否为文件:'</span>, stats.<span class="hljs-title function_">isFile</span>());
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'是否为目录:'</span>, stats.<span class="hljs-title function_">isDirectory</span>());
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'文件大小:'</span>, stats.<span class="hljs-property">size</span>, <span class="hljs-string">'字节'</span>);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'创建时间:'</span>, stats.<span class="hljs-property">birthtime</span>);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'修改时间:'</span>, stats.<span class="hljs-property">mtime</span>);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'访问时间:'</span>, stats.<span class="hljs-property">atime</span>);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'权限:'</span>, stats.<span class="hljs-property">mode</span>.<span class="hljs-title function_">toString</span>(<span class="hljs-number">8</span>));
});

<span class="hljs-comment">// 同步获取文件统计信息</span>
<span class="hljs-keyword">try</span> {
  <span class="hljs-keyword">const</span> stats = fs.<span class="hljs-title function_">statSync</span>(<span class="hljs-string">'file.txt'</span>);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'文件大小:'</span>, stats.<span class="hljs-property">size</span>, <span class="hljs-string">'字节'</span>);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'修改时间:'</span>, stats.<span class="hljs-property">mtime</span>);
} <span class="hljs-keyword">catch</span> (err) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'获取统计信息失败:'</span>, err);
}
</code></pre>
<p><strong>Stats 对象属性：</strong></p>
<ul>
<li><code>size</code>: 文件大小（字节）</li>
<li><code>birthtime</code>: 创建时间</li>
<li><code>mtime</code>: 修改时间</li>
<li><code>atime</code>: 访问时间</li>
<li><code>ctime</code>: 状态变更时间</li>
<li><code>isFile()</code>: 是否为文件</li>
<li><code>isDirectory()</code>: 是否为目录</li>
<li><code>isSymbolicLink()</code>: 是否为符号链接</li>
</ul>
<h4 data-id="heading-36">4.4.2 检查文件或目录是否存在</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

<span class="hljs-comment">// 异步检查</span>
fs.<span class="hljs-title function_">access</span>(<span class="hljs-string">'file.txt'</span>, fs.<span class="hljs-property">constants</span>.<span class="hljs-property">F_OK</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (err) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'文件不存在'</span>);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'文件存在'</span>);
  }
});

<span class="hljs-comment">// 同步检查（推荐）</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">fileExists</span>(<span class="hljs-params">filePath</span>) {
  <span class="hljs-keyword">try</span> {
    fs.<span class="hljs-title function_">accessSync</span>(filePath, fs.<span class="hljs-property">constants</span>.<span class="hljs-property">F_OK</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  } <span class="hljs-keyword">catch</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }
}

<span class="hljs-keyword">if</span> (<span class="hljs-title function_">fileExists</span>(<span class="hljs-string">'file.txt'</span>)) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'文件存在'</span>);
} <span class="hljs-keyword">else</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'文件不存在'</span>);
}
</code></pre>
<hr/>
<h2 data-id="heading-37">五、实用示例</h2>
<h3 data-id="heading-38">5.1 文件复制工具</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

<span class="hljs-keyword">function</span> <span class="hljs-title function_">copyFile</span>(<span class="hljs-params">source, destination</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> readStream = fs.<span class="hljs-title function_">createReadStream</span>(source);
    <span class="hljs-keyword">const</span> writeStream = fs.<span class="hljs-title function_">createWriteStream</span>(destination);
    
    readStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">'error'</span>, reject);
    writeStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">'error'</span>, reject);
    writeStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">'finish'</span>, resolve);
    
    readStream.<span class="hljs-title function_">pipe</span>(writeStream);
  });
}

<span class="hljs-comment">// 使用示例</span>
<span class="hljs-title function_">copyFile</span>(<span class="hljs-string">'source.txt'</span>, <span class="hljs-string">'destination.txt'</span>)
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'复制成功'</span>))
  .<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'复制失败:'</span>, err));
</code></pre>
<h3 data-id="heading-39">5.2 目录遍历工具</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);

<span class="hljs-keyword">function</span> <span class="hljs-title function_">walkDir</span>(<span class="hljs-params">dirPath, callback</span>) {
  fs.<span class="hljs-title function_">readdir</span>(dirPath, { <span class="hljs-attr">withFileTypes</span>: <span class="hljs-literal">true</span> }, <span class="hljs-function">(<span class="hljs-params">err, entries</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (err) {
      <span class="hljs-title function_">callback</span>(err);
      <span class="hljs-keyword">return</span>;
    }
    
    entries.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">entry</span> =&gt;</span> {
      <span class="hljs-keyword">const</span> fullPath = path.<span class="hljs-title function_">join</span>(dirPath, entry.<span class="hljs-property">name</span>);
      <span class="hljs-keyword">if</span> (entry.<span class="hljs-title function_">isDirectory</span>()) {
        <span class="hljs-title function_">callback</span>(<span class="hljs-literal">null</span>, fullPath, <span class="hljs-string">'directory'</span>);
        <span class="hljs-title function_">walkDir</span>(fullPath, callback);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-title function_">callback</span>(<span class="hljs-literal">null</span>, fullPath, <span class="hljs-string">'file'</span>);
      }
    });
  });
}

<span class="hljs-comment">// 使用示例</span>
<span class="hljs-title function_">walkDir</span>(<span class="hljs-string">'./'</span>, <span class="hljs-function">(<span class="hljs-params">err, filePath, type</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (err) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'遍历错误:'</span>, err);
    <span class="hljs-keyword">return</span>;
  }
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${type}</span>: <span class="hljs-subst">${filePath}</span>`</span>);
});
</code></pre>
<h3 data-id="heading-40">5.3 日志记录工具</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Logger</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">logFile</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">logFile</span> = logFile;
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">ensureLogFile</span>();
  }
  
  <span class="hljs-title function_">ensureLogFile</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">if</span> (!fs.<span class="hljs-title function_">existsSync</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">logFile</span>)) {
      fs.<span class="hljs-title function_">writeFileSync</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">logFile</span>, <span class="hljs-string">''</span>);
    }
  }
  
  <span class="hljs-title function_">log</span>(<span class="hljs-params">message</span>) {
    <span class="hljs-keyword">const</span> timestamp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">toISOString</span>();
    <span class="hljs-keyword">const</span> logMessage = <span class="hljs-string">`[<span class="hljs-subst">${timestamp}</span>] <span class="hljs-subst">${message}</span>\n`</span>;
    
    fs.<span class="hljs-title function_">appendFile</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">logFile</span>, logMessage, <span class="hljs-string">'utf8'</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
      <span class="hljs-keyword">if</span> (err) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'日志写入失败:'</span>, err);
      }
    });
  }
}

<span class="hljs-comment">// 使用示例</span>
<span class="hljs-keyword">const</span> logger = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Logger</span>(<span class="hljs-string">'app.log'</span>);
logger.<span class="hljs-title function_">log</span>(<span class="hljs-string">'应用程序启动'</span>);
logger.<span class="hljs-title function_">log</span>(<span class="hljs-string">'处理用户请求'</span>);
</code></pre>
<hr/>
<h2 data-id="heading-41">六、最佳实践</h2>
<h3 data-id="heading-42">6.1 错误处理</h3>
<p>始终处理文件系统操作的错误：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">'file.txt'</span>, <span class="hljs-string">'utf8'</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (err) {
    <span class="hljs-keyword">if</span> (err.<span class="hljs-property">code</span> === <span class="hljs-string">'ENOENT'</span>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'文件不存在'</span>);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (err.<span class="hljs-property">code</span> === <span class="hljs-string">'EACCES'</span>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'权限不足'</span>);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'未知错误:'</span>, err);
    }
    <span class="hljs-keyword">return</span>;
  }
  <span class="hljs-comment">// 处理数据</span>
});
</code></pre>
<h3 data-id="heading-43">6.2 路径处理</h3>
<p>使用 <code>path</code> 模块处理路径，确保跨平台兼容：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);

<span class="hljs-keyword">const</span> filePath = path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">'data'</span>, <span class="hljs-string">'file.txt'</span>);
fs.<span class="hljs-title function_">readFile</span>(filePath, <span class="hljs-string">'utf8'</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> {
  <span class="hljs-comment">// ...</span>
});
</code></pre>
<h3 data-id="heading-44">6.3 性能优化</h3>
<ul>
<li>对于大文件，使用流（Stream）而不是 <code>readFile</code>/<code>writeFile</code></li>
<li>优先使用异步操作，避免阻塞事件循环</li>
<li>使用 <code>fs.promises</code> API 或 <code>util.promisify</code> 将回调转换为 Promise</li>
</ul>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">const</span> { promisify } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'util'</span>);

<span class="hljs-keyword">const</span> readFile = <span class="hljs-title function_">promisify</span>(fs.<span class="hljs-property">readFile</span>);

<span class="hljs-comment">// 使用 async/await</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">readFileAsync</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> <span class="hljs-title function_">readFile</span>(<span class="hljs-string">'file.txt'</span>, <span class="hljs-string">'utf8'</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);
  } <span class="hljs-keyword">catch</span> (err) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'读取失败:'</span>, err);
  }
}
</code></pre>
<h3 data-id="heading-45">6.4 使用 Promise API</h3>
<p>Node.js 10+ 提供了 <code>fs.promises</code> API：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>).<span class="hljs-property">promises</span>;

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fileOperations</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-comment">// 读取文件</span>
    <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">'file.txt'</span>, <span class="hljs-string">'utf8'</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'文件内容:'</span>, data);
    
    <span class="hljs-comment">// 写入文件</span>
    <span class="hljs-keyword">await</span> fs.<span class="hljs-title function_">writeFile</span>(<span class="hljs-string">'output.txt'</span>, <span class="hljs-string">'Hello World'</span>, <span class="hljs-string">'utf8'</span>);
    
    <span class="hljs-comment">// 创建目录</span>
    <span class="hljs-keyword">await</span> fs.<span class="hljs-title function_">mkdir</span>(<span class="hljs-string">'newDir'</span>, { <span class="hljs-attr">recursive</span>: <span class="hljs-literal">true</span> });
    
    <span class="hljs-comment">// 读取目录</span>
    <span class="hljs-keyword">const</span> files = <span class="hljs-keyword">await</span> fs.<span class="hljs-title function_">readdir</span>(<span class="hljs-string">'./'</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'目录内容:'</span>, files);
  } <span class="hljs-keyword">catch</span> (err) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'操作失败:'</span>, err);
  }
}

<span class="hljs-title function_">fileOperations</span>();
</code></pre>
<hr/>
<h2 data-id="heading-46">七、总结</h2>
<p>Node.js 文件系统模块提供了丰富的功能，包括：</p>
<ul>
<li><strong>基础操作</strong>：文件读写、目录操作</li>
<li><strong>高级特性</strong>：文件监听、流式操作、权限管理、统计信息</li>
<li><strong>多种方式</strong>：同步/异步操作、回调/Promise/async-await</li>
</ul>
<p><strong>关键要点：</strong></p>
<ol>
<li>优先使用异步操作，避免阻塞事件循环</li>
<li>处理大文件时使用流（Stream）</li>
<li>始终进行错误处理</li>
<li>使用 <code>path</code> 模块处理路径，确保跨平台兼容</li>
<li>考虑使用 <code>fs.promises</code> API 或 Promise 包装器</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[ReactDOM.preload]]></title>    <link>https://juejin.cn/post/7584262116388192282</link>    <guid>https://juejin.cn/post/7584262116388192282</guid>    <pubDate>2025-12-16T09:26:21.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584262116388192282" data-draft-id="7584262116387995674" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="ReactDOM.preload"/> <meta itemprop="keywords" content="前端,React.js"/> <meta itemprop="datePublished" content="2025-12-16T09:26:21.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Kellen"/> <meta itemprop="url" content="https://juejin.cn/user/1007587030991165"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            ReactDOM.preload
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1007587030991165/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Kellen
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-16T09:26:21.000Z" title="Tue Dec 16 2025 09:26:21 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-16
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#2b2b2b;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(159,219,252,.15) 3%,transparent 0),linear-gradient(1turn,rgba(159,219,252,.15) 3%,transparent 0);background-size:20px 20px;background-position:50%}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{padding:30px 0;margin-top:35px;margin-bottom:10px;color:#4dd0e1}.markdown-body h1{font-size:30px;text-align:center;position:relative;width:max-content;margin:0 auto}.markdown-body h1:before{position:absolute;content:"";z-index:-1;top:-20px;height:100%;width:100px;left:0;right:0;margin:0 auto;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADsAAAA6CAYAAAAOeSEWAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAABkLSURBVGhDtZoHnJ1llcbP3Om9ZiYzmfSQhCQQIbRQVQKI9CYC68qKriJK0UXcZRcINqStIoiIqKCi1NACQihBWiCkkJ5MJlMyvd7p7d759v989/sy34yTbIj48Atz71ff855znvOc971xDrB/EtoGI7a9Z8Aq+wZML0mNj7dE95NZ1OKsj1dHo1GbnJpss9OTbWJyonvun4VP1Njuoagtb+m0it4By0iIt8LEeMvkr8XFWcfgkA1gYDLf47i2PzpsyU7UspKSLDoctagTZ7Vc08MzClMS7awJ2ZaflBB78CeET8TYla1dtrKt2w5KS7YCDGzEoz2RqKUmhGw6x2bhuXyOp2BoRXef1Q1E7Lj8TIsMD1sbxu1kcnYSAX1810RMTUmyMB7f2j1gC7NS7byinNiL/kH8Q8a+2NRh77b32El56VaPAe0YeGR2mh2bm+FdMRqP1rbZe+3dFsHT35qcb/Oz0rwzo7Gxs9feYPLS4kM2h8lawee5hPmlJXneFQeGAzJ2F564v7rFzi7Msu3d/Xgjzq5g8ArX8VCNN2vJ28daey0zZJabmGCLslP5HOf+Oygr3UzDGOf+JxrauXfQjslJt+dbuuyMgiwmk+sPAB/b2Lt2NdoMZnuY21qHIvbvUyZ4Z0ZQiXGrWjvsmPxsK4R0nmHA8ZCTQvxVQn5eRipklIBtcVbV1WtHYsjati47ZWKuTUpP9Z4yGk/xDBGe3v1mW4/dOrvYO7P/2G9jRSjf31FnXyaUXiB8r51WaJkM3kcfOSa2FR6qarIenooTLQHPLcC4mYThyw1tVpKWYlVERlZ8nC3Oz3Jzdn1nn5uvQ8OOHYvhR/CvsqffJbkCkZTvcYZ6Z0WTfTovw5Y1dtjXp+TbFPhgf7FfxpYxuMfr2uwo8rEtMmwXF+d6Z8wGmIR2PLyjo8cqOFffP2SLGexJEJCP9R29thkPXlpa4A5Y3w/jmuVNYYwO2QkY7WMtz3mVcE1hkualJdmSolzX8GnpKd4VZq80d1o7zN0RdWxGaqItgbn3B/+vsasgh/UMNBOvzYMZDxtDKp289KGaVguFQvb1yQWWwuB97GaSXqUUnVaYbSUwrDCEBz/C2CM8EhNrP13fbkeSh3OJgCAe2N1CWXKsGOc6TOr5U4q8MwYhDtkTda02MyPN+nnGBQEH7A37NHYz5KOZVv08qyjbSseEzKauPnsMj98wc6Ibcj5UUv7M8QWZTE52jEwGOVaD8U1Dw1YNWX0qM8VKyb80L/TrOPYOzH4KBJQTrK8M7+7KZjuM63sHBt17FubGoibCuf+tarWFGUmuwWeT8/vCXo1tZOYeZcazCaez8MwEzzM+HqhqtiJI5twxL1jeGLYk7jmKMF1JOCbg6Qj5nAdRqX7q3BYm8VAmQvW1lfcMc58IT95uIA3q+gftrDHPXUXJWkVEHJme5Bp5UmHsvIZ/O3l8ECE/FWcsItX2hr0ae8O2Wjs+J43QTbOZzGYQ/7Wtxq6eXjRK3r0By4YJ6Ty8EiYSJqcm2eGeV4Pox/ANENJR49RiEdfqcLflUJrEBZqgxYHrBjn2ExFURqKdVETN9YirJxKxR2rbrYeQv5ISmB6IsiDGNfZGWPeMgkzr58xnPaJ5p6XDZPKz4T77wayJ7jGhhXLwanOHTWBgq5n5q6YUwNJ7l3kKcRl7OJ7fF56l1GzvHbSD8dghTPi0wIRfv6XafjJ3ssv0PnZQ7nZx/etwzO1zJ3lHR2OETTw8x0tOx1AN3De0D7YV+63oGthjaJQ5Ur7eVVZjcdGInUyuaT73ZWg3efV8fZs7cc2E777Qi5eunVbghvPPymrt/krKGfcLd8ybYjdxrK6333Z09rjHZkNuLYzz0uIc+xWCZzz8nbHbe4dsY1e/XUOY+nimvtUaSazv4jXhaQasSbmYmpuenGwHZ8TKggSEQm08rMD7ahBOoExcMqXQegjnZ+CEvaEa1ZQUQkt39dj0zDS7krq+ARmpdws/nlNqD9WFbWN7l5u3wr9MyrcXKUsqWy3jTOaoML4DdaQ83YIoT4VYpEXvYQZLmbX5SLohBrgOj186Kc/iKTUPUhq+Rrm5ekOl3TWv1Mr6hqwbY0VOQXwEo+Moq4Z47q5qsU489G944LyJOW4LOLZOKtT/iI6+nGe/0dhuEd4ltj2NmiuCU4hnk5fHIi7+RK4uTEu0e+s7rAiRcw1CYy3OejvcYz+eXeI9MYY9nu3lYZl0KavJJ7Vjibzgjp319rUZE20j7CkJqFr5JQYgQ39f3eQaKpQk0afy8nl4uBzvjUUTRk7k3iebOm0pabDiyFn2XGu3dRME41CGVeBVqSiVnc6hIUpekp1VjHLDSOEcQlui5W/U8C7IKREjv1Gabw3wRwUTvpv7jybPtzHmIPZ49q6KRjuccqBQVCOtGvqXhrCFUUXJzOYSHt7Kw5Ix9H08dSje1o1JyL73IYXpEMmE5CRbw6wuykx2pR+Pd6/J4JpLiJKV6N9OnrcQNfQ0Zem6qQX2MmFXyWTE+DMO0kGx4e08DEjnXbsYuOq7niHB8jdY/wQ8Srm2XCZZUrOakF1CY5EKX0h93Tu/1J4kRdbDMT8MamgZK9xe3uDcvrPe++Y4f61rcZr7B53rN1c5N2ytcV5rCrvHt3T2Og19g+5nH7dvq3bqunr4NOwgK2MHA1jeEDuG7HNuLmtw7qpocl5t6nCPvdTQ7v4N4u3WTqeyu9cZHIo4f6lqdFoHh7wzMbzDeeGv3Hvzjlrnh2W1zofhHuftxpFn3VFe7zxS0+p0DlKVPbhhvBxhvwiFMgfP+mjHA08gEC4pybeLyK1iZldh8zC5VJQyUl8l59KZ0WJk2xaiYWxNrkXXJhA8r3PvZRur7ZZZRfadaRPsfiTmX9HGajC2tXd6V8dQTMhX0h8rNdJx9Ra8F8SbRNLzhPRnJmTZIUTYueTyWxyr7uv3rjC3OkzE8495oS+4xq6D5WoI0bO5WVCOSerl8rIeBrOI/Hkaw6ME5W1zSuzx2la3CRdWi3zIG+FDBvUp9LMgI/vggUmE7KkT81yGvOOgEYa/aUahhRAF5xLec3OzbF1r2O17BbVxIi7hzJIC64IYhXdJA+nh/5xVbOmE9J0QqjSxWk0pp37M2YEtgjS8GpimACu7xkqxdKJ6fEXyYl2Lre0ZtC8yELVewtWUnbfCPIhrvgDFz8WI5yhJKgcnFMZWEFrwhgzo5uWDDDA1oGSOzcu0xfx7vTlsv6posIMpJ6cGWPiw/BxL4PU7vbrpjgf8bMdu5OYwOdhm83DARUSa0ELknYIeEAaILuWxlhGa0M8+EuJCrpJT+ymENhN60pXBxa3LZ5TsucnlGaCmIEQ4Evru91yuz0xMtKaeXluI5zdh9Mm8vAlBn4aR07X64EH3vEKdXQkZJXPP/JxMvNRpLxEtHZ5RQgmNewnpouvVTpYTHdfOnmy5kFUGnpRTfEhXD9DiBdFFJB0/YWS9aj6pmc89r0BaQmgTRkgI+EsdKsYasJZOBF+QqTH474NK7LbyBvf7W+RgOxNyxfQY2/2hrp2+NkroxrzrQ55fSZkpJIa28znCgF6rb7H1hOSslATyvNflAh9pvHcX3lVE/Ya8FjTJIexa2Rq77nfU96unTnD7aME3+TAm6BFKYrPnqCNIqV5sq0ZGCiEV+Db+qWMQqpFgb5KPx48R6omeDl2EuP9DTYt9iGA/f1KBS1w/La+H4ktsSmLItvZHXLUkrCeflVtJ9DVVg1H7+sxiGvVM975rZpfabuqHVhuP5F1vewav5O8GamUe91yDanoYw47FWzC929O+DJnKA2opFY1Rjru5CE7kOcO0jJtQVUIynzuZEMeb+1CEOFXN8iFSGeRpCm1BTlJxVg49Azm819SO7Bu0axEbwn27GuxMck+TMQHDP8fn48gfDVIL4R8xKVPJ73MQBUIfA/Z54LMw5vmlE+w+VFo2A78X/SsyPA/RMD0z3e2qVLtfo7aeBslpMX0N0TEnLcUlKym1jyBFqSohmYntI5enBhYB9CY/2kNarhwJhNiMtRGyWnkQdKaCFyQwgydjyNUw4VchKxXv2/DoKdC+lkQbCX1NlKCGvJiBJkSGbCus6jfo4yGBNySgr+u7e20BCsxdVAcFlJ/tHd32+cIsNxSXUULUUx+dg/d47g7OPYFw2MxkSuyMwLHVTI6PBN6dS8Sppw45zHJSgDXV3aQzmz40Z6fDgBfiAXU0uZxby2zejee+j3eltoQMzhV6qSBogXwrEXDj7ElWxUQ8RrnSaoU0dxIsKaiMvMykXTu90NqJsGHP4z78SdLigUrLKat32nFwy/E07pfDFRdQ/7N5r57pQ1482uvWhMGhQcviGkVrKDUp0ToCxfhQal5n4Hs/g1jOgH4LWdwFOd1b1WzHET4vLZppv+Czjxo840OrDlG8jAJzv2tp5mLK1dsU/lfIOeWy5NxFxfl2BoYImlQtx9QF6mJRQKBsQYYuO2yaLYPBUXvu/VqYPxtHhNy7Y4hCkNLGPtKSklzCVKSHtMQxcqm5Kw1DhI2PTGZtcGDAvoLQ/u7MifYtWFBlxz2H9zo8RkwKzC5UYiG+p44ccqE62YAxLeT/TOpf8MXx8Qk0IJFRY1Go+viQVJpE5Ehjf49xfAZeqGIy/7us3nqxwQfCkjZypPxobVr/6YpQHIalUvuCyEwbSXC9PC8QnkFcXlrgLpoLIhIfKuaqlQkYIAwQnr/f3eyu7KttOw2lNpv8/BPHyjzVNER3o72gvEBKqRMTflndbP8BMweRDyeciEj5bFayFXqTLzheivgYJC0jwzwHa0MDDEotm48ndze5BBBElAnxxcRYHAFh3FfZaA9UNRmC354kNwUx8eHkmVj5dcTE5ZMnuEyr1QqlhtaJLuOYZv4v3KNo0TKrGPUZ1NILPKuWcvVn5Trv10SMB6h0j/ARMnlOuafCBIfnSWEx/Raif3HDzofYMM31dOyY9LBaLK3TjoX2fEqT4+2qaUVWSTQvyM6wC8nNJyEetXIyuLKrx04P7MKNnbJZlKUtNAIHo7i2dA/YU3Vtdi5l6jCepXy8hOedSSSsI8/HQg5Q+gxTKXwkMHkbESo+hjG0lbRRzQ3Fc5LOzDuFhs3Ptumpie7ilRDhlEJOq/hjsZljCxjkt7fWuPS/EekpXMggJQIk0G+eN9Xu2VmHWIkJe0nJRN4ptBBit2yutG9ML7J1DHAxebiAMrZ4VZlduqGS8I2tJc2iborUxmIN79c+kTovFxivPvrcSaP3n7RSKYTUmKt4N3rMOcw4JOneD3sP956jNaMglIeTER5Xbdlt15Tm2W10NEsYrA/N5JLCHHsR9tSqwxq08G3bqm1ZTbOtagnbo6SLvH/VzBL7W7jPzqFea0LmMLFzUuLtdwumuO3i1Vtq7OK15Xgw3l1PDmIXak+6QBEkvB9YJIzBcc/L20JIYaSZ/qAzVm5Ut4oowk3QehC+N3xo/1wTqt7zsYawfX9no9XjqdPXVLhrwyo/wucJYQkE1e4j8rLcBuHUItQQKqgMXb6LGvxFQlXw33AdZLR0V5P9Fr29lP73scNnosoyvdWPv4fPJ+uJrLVtMakqaL1M1cTvv0OLIZE6wk2a2IcIRUQh+DaejpdcXepBa7bKDRGM9PIVxTl2EwarZ72rooVuY4RQtMypdk6e1lLLehhY2lt7QEd7WxlCDvdIli6E9B4+ZIodmZEMccUGqgiZOqru9tkR3iJ8nCcXRWRZCSPMLPEjlx2LjQL1OM5qKAm+vhSuRqSfV5Ttrg8FdWcrnhMqCTex7DEM6qTsVEuM1+8hovaHQ6e6a1Fz0xLd3nUt4ToWWuzWNkhcoAIIjUx2ZpxjLzWF9+SYmngR1lok4TEoJxGfuijhI/7OICoFmadl2llcL9b1oRVJtbD+JLlv1KrhHG5811t9ELbzgk14ICUwqE+TDzftqHPz98vUSy3jSIwP8dCpkNqLDPTx+rArz4T5qLG3G2PrvJKKPoLBWE501NC3ilUX5mVjVIb9nIbgWcpPMiSXjbcL8K62UkR86m1/yfkSeMaHFuK04X0CE3J6SWzFUxw0BSNHlSzi3RmIRJwHq5udO3c16quLp6sbnffbupxbt+12vzOrzuvNHc7ycRbIxuJHgYU7YSASdQgxp7qz2ynv6HJeqW91doa7nLruXof+17sqhhu31Xif9o7HalqczV29Dnrb/f5EXZvzdH27U98/6LR5i3N0UM5zjHU71/lwjRWWltU5CAIn7F1MqLp/r9hQ5RoaxG+qmrxP4yNKcfsFLwuiprffeb2l03m2scO5h3Or2rudzjGrhk8x4Cqu2xcexilBvNEcdi5Yu4tKF3Ue4tzPy+td5/1md4tzw5iJ27NuXEYobYUdlb8z6GTWkdxaCvk2zHjd5mpKQ459mv5TkAp6mQb9Aq9HHQ8S6mrZnuc6vUG6WHusIhCJGNXl9byvnJyaiE7+Eoz8c5TYNQiUveENGpJpcIJ+biS8R0+rlcazGNs7pKB+zPLTOSX2KNWhlDAf4r2Spj72JORB5OyHULX+dlD/FOky/HFy5ygYU0sey/i8moeqdunXK1qC3RuaMOYHlI/raQMl3M+EeTV5WxD3Km8a8PkM8nr648sQ9+esKbf5e/nxiKBfAOQkxbv3SU9LYmqPV9V/Pn+V20VwTyVjTqCI6edEQUOFUXs9WmfSll8DyX2dt7GlnwkswaM3l9XZ0oNK3MTXbxpOV2sGk69s6XCJw4cY8KbyRrt9TrHt7Bm0rRBQe1+fHUWNfaapU0KbqxzbORC1M/LS3dJwIl3KOrwykQG/E+61q+isgniztdOKqNOziDgZqZIzFwPvqGiyg5NCtoCqoG5NxHhPZTOsnORulKskjoKMDeLuXQ3OmnC3syxARFXdfc57LR3OrdtrvSOOs55rnqhtcdoGhpxHdjc5EfJUuHZTlftX+G15rXPlhkrnLe59F7Lz8VGHdg8c5y2OLeMZ126qduq9XC3v7nd+FchLvYPJd15gPCu8XQnh/qpm59WGVudZzvvQO97kXTcGxhnEuJvR39tWY8cwK4uhcikk4a3Gdstg9l5B2t0wfaTdWkEou5vCPOV5PH73vFL3+DfXltnh6OxjkJD6Wd5F3g88tMe6CW/7YmI99VIL4u0oqUK8ocW4d8hFrXMVoOQU8s3U97MnjvDD/XRYkyhHM1MT3GVZQR2Tdv70U8EbA5vlo+CaPAaaSWoZXm50otGodxQ6L6txGKxzw5ZYORrBsPPrykZKQIy1n8bTjwb2fO4Te3ue7x6KOKvaYns1wtIddd4nx3mwot55qyl2360cp81zurg+CGqwU8v4/Of5uAVvPgObrwvHomY8jOtZ4fXWLnefdHVXv9044+8ZklCx75DXwcV1Sb27y+vInUQEuVYSaMgRJYfAwtoj0raFxIUW1A8nz35f02qLc9Lc9lG7CBkwtUR7bf+A+5uL6ehnH9Lat+5sIEfj3Cbj3NKRvP7Rjlo7FSmqavKvpSP8MRZ7NVbQYLSkqlC9ZW4sPH18gBTcORjrhMWmQWzFmK2UsvO90qQ1oZcI8UhkCLZPtRqMy0NirobAvjIpb4/sW06qKGyPR2oGIdlazjOOTk+kLYzaaYGSp63Wz6HsXsQ51wd+LTAuZOy+8GBNq7tF+IOdDU4kENJthNID5YRafZtzZ3mDs9LbRgzixcZ2l1h83OKFbDmEd0/FiFp7DWHgp0AQGzq6nf8hPF+oa3EehOz0ziCWcm4NpBRMhX1hn571oR9wqVVSDVPtUi32sQ0vbu7scZdY9aOt2ZSEL9BEBIW+dv20AKDd9/ep09oimYqHpyImkKDuRllS4PrlHNuIqDmCJmNJQba7q1joEaUQJuR/WdXsLrJrq/L6cdJsPOyXscJ7GLKqo8cOpqhrO//yQG6oS3kZwS9xPkRB3wi7diFMtDN+PLk5m1ath+8f0Fy80dbjhvVXub+U5mEqeal27UP+dWpPlknNxW79Ak6/7Tg3UMOF52j1xA1qK7Trd6nXC+8P9ttYQcumIonLSnJtBdJNa77axw1C2x3qR4Wqnj73x9f6MbV+CCYFBZO6y51aSh3gzVrsmwzJnULEbCJC1oZ7vIZ/9Iqmfvn2u5oWO5n8fApxcuWUApum5diPgY9lrA9EtvUNOzYf8vqAcJPsU5iOh7XtXQgt2uZhjKU2amF7HQyfEYWcZk5yQ1RDKNrLcq02k/9IGmldrB93KiokPw8EB2SsoKWXO5FmxXhlckqi+3vEUvLqwok5PHVkIWAszlqzy1p54zuLpnPZ3q9bod08JlLSb5DrNxDm38Sbvsg5EBywsT7oH+3XNW3uasGirFSrxRNdCllKiPZHZzJYLZb5qEcpae3pxMCuu9oibS5/QCOiLcYUrp+MmtJeURjFdVlxzqiae6D4h40NQt54HyGv3JRo10aVfv8YhtC0pSlVKcPFuxIXahr08mzCO4VzMlLSsZuomZ+RaucU0rXsw/sfF5+osUFonWob/7TrLdaUgdpV93fl9X+VIC0Y6tek2uI8OD3J5gT2Vj9ZmP0f4IM4iY7RQ5gAAAAASUVORK5CYII=) no-repeat 50%;background-size:64px 64px;opacity:.84}.markdown-body h1:after{position:absolute;content:"";width:150%;left:-25%;height:50%;bottom:12px;border-radius:50%;background:linear-gradient(transparent 80%,rgba(77,208,225,.8));background-size:400% 200%;opacity:.6;animation:h1Animate 6s linear infinite}@keyframes h1Animate{0%{background-position:100% 100%}50%{background-position:100% 50%}to{background-position:100% 100%}}.markdown-body h2{display:block;border-bottom:4px solid #4dd0e1;position:relative;font-size:24px;padding:12px 32px;margin:30px 0}.markdown-body h2:before{width:24px;height:24px;left:0;top:0;margin:auto;background-size:24px 24px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAADGklEQVRYR81X32vTYBQ999s6mFjQgQ+DrbHiVFZYU4cDcQ/6pGhTFVYFEXGi82H+Bz448UnEF1Fx9ccEEcXpZE3d5tP2ooKiTacTHaLNpigMHDgnU9tcSbrWrkwWR0sbyEOSe885ObnfvV8IRT6oyPwoLQHBx+OVM5WJvSyEVAhnBOjt7yU/+/rr6r6l8TMO+F/EN0JQhICqQpD/xaRpcpAc9tS+M+9lBCia/oqBamK+zeDuQogQZaKJk3wcQjxSva7tGQGB2Ke1zIk3DNyMyNL+QpCnMQOaPsDAVuGAp9cjvbYc8Ec/bCYSg0zoiHilk1tHxqsqEsYlML4kjIpT/eurJxRNPweQU5VdrWaOEo1fgKAVbBgXIz73kF3R/ph+ghgdzMYWM29eAWlBJqgZaFlFYtC6nhWpaDqnSGlIlV1WjJ3DloDNgyNLncudqgX//Ucg3LxuStHGuhi8pqKCW3rqV342rwFjRznKm+/LNaN2yC237ThgF2wxcfMLeP6+ncrKzoPoKTGeLQbYbg4TNoC5iZPJY5HGVRdSNZAWYBclD3FzBQzrR8hACAKdzBzKA/4/IYioDQaOskBbpEG6PO8qKKSAEi3CnEb0Pw4oMf0OmKbTDWqh3Lw6EIiNBZi5lxh3wz4puBD5ovqAMvxhHSdFKxE1CQe3m/07TeTX4lcJdAhE+1Sv65Z5P/ByvIGTRowIZ9igbtXnmrOsbTvgj+kHBNMuBu9OdVw8EeU4nC1A0cYmAHZOTRrLhra4Z8ywnSN6vZHAFTA2WnnMfQB3qz73ddsOZM8CACFDIPSgQXqebXEgqgeZcAeEe6pXasm1f8ew3igMtAHWac0Uc/jYdyAaP0xEBwFsmgUPqbJ0NE2UKj4EGcahiOzuyhagaHpnmtgcVgTcCMuua7YdyAHbA3ArQNscVFbb4635aD6fnYaTvxxi9UNP7ddMXaRWVBdAcaLk6bDXPZCNZ9uBXEsDUX1T2Cc9yjig6Z0EHg3LK8/aqf6MwJKchkXfks1+0+JtSq3qLPa23BRR1B+T/6nkfMaW1r9hPt/MLtYfTLEpP+T9FNoAAAAASUVORK5CYII=)}.markdown-body h2:after,.markdown-body h2:before{content:"";display:block;position:absolute;bottom:0}.markdown-body h2:after{right:0;width:400px;height:10px;border-top-right-radius:24px;background:linear-gradient(90deg,#fff,#4dd0e1);max-width:50vw}.markdown-body h3{margin:30px 0;font-size:18px;position:relative;padding:4px 32px;width:max-content}.markdown-body h3:before{border-bottom:2px solid #4dd0e1;width:100%;content:"";display:block;height:28px;position:absolute;left:0;top:0;bottom:-2px;margin:auto;background-size:28px 28px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABRklEQVRYR2NkGGDAOMD2M4w6YDQERkNg+ITAppcfY/8zMv3wF+NdTUrZQpUQ2PT6cz8Dw/8CkMWMDIwNvqK8jcQ6gmIHNN19EaXPx1XPyMCghrCUKcpPlGc5MY6gyAE+Fx52MjL8j3cU5a1UYWXtZGBkEAVb+p8hxU+Mby5NHQCxnKEMaskzJ37uFmUetkmMjAzrfUX4woixHBJlZAA0y2EmPPYU4enLkhGeQIqRJDsAh+UgO7duNpD3IcVykkOA2paT5ABaWE60A2hlOdEO8D3/4CMDIyMfWvySFefoaYSoROh74eFXBgYGLiTNVLGc+BC48PAnAwMDG9QBVLOcaAd8P5ox+x/jf5AjGLgYfnwnKqv9/8/PwPO/kFF/MSj0cAKiouD/0bgYoixFU8RovWgJIX1EOYCQIZTIjzpgNARGQ2DAQwAAvHBaIdB7zxsAAAAASUVORK5CYII=);background-repeat:no-repeat;animation:h3AnimationBefore 2s infinite alternate}@keyframes h3AnimationBefore{0%{width:28px}25%{width:100%}50%{width:100%}to{width:100%}}.markdown-body h3:after{content:"";display:block;width:28px;height:28px;position:absolute;border:2px solid #4dd0e1;border-radius:50%;right:-15px;top:0;bottom:0;margin:auto;background-size:28px 28px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABRklEQVRYR2NkGGDAOMD2M4w6YDQERkNg+ITAppcfY/8zMv3wF+NdTUrZQpUQ2PT6cz8Dw/8CkMWMDIwNvqK8jcQ6gmIHNN19EaXPx1XPyMCghrCUKcpPlGc5MY6gyAE+Fx52MjL8j3cU5a1UYWXtZGBkEAVb+p8hxU+Mby5NHQCxnKEMaskzJ37uFmUetkmMjAzrfUX4woixHBJlZAA0y2EmPPYU4enLkhGeQIqRJDsAh+UgO7duNpD3IcVykkOA2paT5ABaWE60A2hlOdEO8D3/4CMDIyMfWvySFefoaYSoROh74eFXBgYGLiTNVLGc+BC48PAnAwMDG9QBVLOcaAd8P5ox+x/jf5AjGLgYfnwnKqv9/8/PwPO/kFF/MSj0cAKiouD/0bgYoixFU8RovWgJIX1EOYCQIZTIjzpgNARGQ2DAQwAAvHBaIdB7zxsAAAAASUVORK5CYII=);animation:h3AnimationAfter 2s infinite alternate}@keyframes h3AnimationAfter{0%{transform:rotate(0)}10%{transform:rotate(0)}50%{transform:rotate(-1turn)}to{transform:rotate(-1turn)}}.markdown-body h4{font-size:16px}.markdown-body h5{font-size:15px}.markdown-body h6{margin-top:5px}.markdown-body p{line-height:inherit;margin:22px 0;letter-spacing:2px;font-size:14px;word-spacing:2px}.markdown-body img{max-width:80%;border-radius:6px;display:block;margin:20px auto!important;object-fit:contain;box-shadow:0 0 16px hsla(0,0%,43.1%,.45)}.markdown-body figcaption{display:block;font-size:13px;color:#2b2b2b}.markdown-body figcaption:before{content:"";background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgBAMAAACBVGfHAAAAGFBMVEVHcExAuPtAuPpAuPtAuPpAuPtAvPxAuPokzOX5AAAAB3RSTlMAkDLqNegkoiUM7wAAAGBJREFUKM9jYBhcgMkBTUDVBE1BeDGqEtXychNUBeXlKEqACsrLQxB8lnCQQClCiWt5OYoSiAIkJVAF5eVBqAqAShTAAs7l5ShKWMwRAmAlSArASpAVgJUkCqIAscESHwCVVjMBK9JnbQAAAABJRU5ErkJggg==);display:inline-block;width:18px;height:18px;background-size:18px;background-repeat:no-repeat;background-position:50%;margin-right:5px;margin-bottom:-5px}.markdown-body hr{border:none;border-top:1px solid #4dd0e1;margin-top:32px;margin-bottom:32px}.markdown-body del{color:#4dd0e1}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:rgba(77,208,225,.08);color:#26c6da;padding:.195em .4em}.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace;overflow:auto;position:relative;line-height:1.75;box-shadow:0 0 8px hsla(0,0%,43.1%,.45);border-radius:4px;margin:16px}.markdown-body pre:before{content:"";display:block;height:30px;width:100%;margin-bottom:-7px;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAdCAYAAABcz8ldAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAhgSURBVGhD7Zp7bBTHHcdn33t7vvOdzy+ITVKDU0xIKG2ABCPTRCCaUiEVKWoqRJuASAhCitRCVKSoalFUKZBiSmmFRRJKRUnUtIpo+aNqGgwoOCmuFUIRzxjwE4zte+97drYzztji8HPvtkit/PnH+n1397Tz+83vN/PbMZhmmmmm+d+BoX8n5diihcGqgFQf5vk6BMAskWUlw3GyFnIvtqWSf91w7mKC3npfOLX7wYeiIa6BBWCOLLFRF2NB0JvIOP/80YG+k2ev6S699b/OzOfKBW5l5KsgyC4DCFQDnpEAdE1goc/dlNPc/Up7P711UiYNSMuyxeUzZPnHgGHWh5XADEkSAcdiN+AnEXIBhBComgFU0/xQR+jnj51sOUMf9Z0NKyL8S9+JPBEN8zuCMrsqGOA5QWAAyzLAxe53HBeYFgJp1c5Cx33nyIfpV3e+22/Sx32nev/sMCgVnmM4bjOniAtZWQAsz315EfsGQQc4hgWcjHkCmOj1rheuNn95cXwmDMiVp5etC/D8m5FwUWVQUYYGPh6mZYFUOgsGVa1pXvOZzVT2jRuH54RM230jEuI3RcIiL4l4UkxAJmuD/riVsqD7ct2m9nep7BtVTbVfZ0uE/UIk+CQflAHDjf8+Lg6MldYATGpH3c/Ul7p3dWXppVGM6eElJSHmnQWPbSlRlN1lJcUBjqNRnwJZVQO3B5P/uq5rK1d90pakckFcaKp5UJHY92JR8YlwkUDVySEZfGfQdO7E7Z8s2HL9TSoXTPXRud9nA8IBqSwcZgWeqpPj6BYw7yTbXBN9q2v9lQEq5zBmWA8vWLCptCi4tzwW8RQMQlFQATPLSh6vCSh/plJBkMyQBHZfWYnkKRgEktEVpTJXERN2Xzo4ex2VC6K6qXYpF5b3ypVRT8EgcAERSJXRbwCBOTFzXblM5RxGBaRt+ZPYA+LO0mgxz5K1Ig+UgAzKIuGnz39z6S+olDeaibaXRsU1RUFvgx+GwTWgPCaDgMw2XXpr9gwq50XV0bkxJiYeEiNF5cwE5XsiOEkAUkXkUW51SSOVchjl8WKef604XFSRbzCGCYeCoESStv/p8QU1VPIM3knNDynctnBRfsEYhgSlNCIGgQv2UCkvGIHZgteMh1nBW9W4F16RAM6yDVV7amZTaYQcr59cuuhhWRTWBvAMLxQGeyFSHOLnh0MvUskz5RF+fbRYDEy0mZgqQYUHOLhr//b6rGoqeaLqQG0pw3PrBbyA+4EQUkRmhvgqNUfICUipKK4OKUqIJVPKB0jpEhjmWWp64jdbKmVZZNYogcJm493gsifOqhDyeh9GYR/FM7sW+DA5CKR0MSK3tvKZkpwB5gRE4tjFEr7RL0iWBGV51vHFCyupNGWWPqLgnoer9mtyEGSJAzwLllDTGzyznDjRN/CwOFkoFb4bm0eVIXICgpvdGoEvrF7fC89zfLkkeV5HbOhWiTwTpKYvCAJLGshRdXtKMKAWlyxq+MPQLk1h66g5RE5ABJYNFrqY3wvJklJRUKg5ZWLFXIA86yek2uDOPkBNb3CM5Pf7DL2QyIrUGiLH+xC5Bmmm/ARnHUhC6PnzxWDK0RH5HuIjZGy27erU9AZ0dTIWXyG+NpBBrSFySxZw220IqeUPFoS6jVAPNadM7yDsgNB1qOkLuAziMYIb1PQGA75wIaKGPyAb+9oF16g5RE5ALIQ+tSyLWoWDEAK6aXW3JlK9VJoyx1oyvVkNdvo5KXXDAVkdnaKmNwx0xjH98w3JNmTCm+Bc9hKVhsgJSI9pvp9Vdd++jmq6AXB2/HHrhcs5aTkVDv0DFzoHvKdq/mQsKX/4t7KJLDpOJW+IbAvMGoMkxfwAWZB8DT7W1diTE+WcgKz6pK1bs6z3daPwmJDsSKt6ZsCyjlLJMz0DsDGZ8SdlDROBjOb8YeWOjptU8kTXusuaazu7oJrfEnQvdkpVcUn6PTVHyAkIIW7br/Unklni0EJIZ1WgGsauZR+fvUglz6zY0dGfVp09ybRNlfwgi3k8YSbvJJ29VMoLt9v6rZVQL7hOYUubndHJGclBtzn1byqNMCogi09/2nFb01/oj+f/5TyjauBOKtPcZ1r7qZQ3f2lRfxZPWi2anp8TSDAGExZMa2jr8u03L1M5L7q3Xc+iAeuHRl/ScvPcjSLDBnZS/cjtNHd2v3171Ewbs9N5q7Pn4otVMx3btBsCsoRbk1FxG5dMVgMDqfTpXl1/tuFMa5zKefPROdX59qLQBwLnNog8Wy1OcjB1N+QEsW/QsFNZuO35Xb1v98QLX4/Sx+O3wqujrQ6013ABUWI8+AaqBjAH01+ghL22+5X2PirnMG7r+esbnae/V1neauvGSoHjigTcVU7UGFm2DeK4ttxKpQ+mLPvl+o/PjnkAkw9HTqSMmVHhyAMx9iFcSh/BHTfLceO/C8mKjApBf9zszGhoY92m9sN+BGOY9AeD7eGniv8OTaOB4dgyTsQd9wS+IQu4lciYdkI7CLrNH3Rvbb9FL41i0tbzVP2iWJkobpN5fmM4IJfJskTP1Bk8A9HQmbpmGDBrWqdVCN/Yd7PjxKGOXn+bmbto3feVVcVB9qehIL8EJy8nChwgr0O2xxBnhGU5eP2CfYbl/m4gBRsbtneMORP9oGpjpcCsiKzHHfdOPiQ/wMniyFEu2dbiTQCAeN/vavC466BGYLttXc9fmXBXMGlAhiHHur+sq6uPiUI9z7CVHMPwBnLSuuN8FuC48/Oaz1ylt94XfrW5ouyprwWfYRkwNyCyYYjwkBHows1fa+tV/fzGxlv39b9gqvfPmQ+i/HK8KlcBjhHwfl8HEHyOd1JnuzZd66S3TTPNNNP8/wDAfwDG7G0m9LKBpwAAAABJRU5ErkJggg==) 10px 10px no-repeat;background-size:40px}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{color:#4dd0e1;border-bottom:1px solid #4dd0e1;font-weight:400;text-decoration:none;margin:0 4px}.markdown-body a:active,.markdown-body a:hover{background-color:rgba(77,208,225,.1)}.markdown-body strong{color:#26c6da}.markdown-body strong:before{content:"「"}.markdown-body strong:after{content:"」"}.markdown-body em{font-style:normal;color:#4dd0e1;font-weight:700}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:rgba(77,208,225,.05)}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{margin:2em 0;padding:24px 32px;border-left:4px solid #26c6da;background:rgba(77,208,225,.15);position:relative}.markdown-body blockquote:before{content:"❝";top:8px;left:8px;color:#4dd0e1;font-size:30px;line-height:1;font-weight:700;position:absolute;opacity:.7}.markdown-body blockquote:after{content:"❞";font-size:30px;position:absolute;right:8px;bottom:0;color:#4dd0e1;opacity:.7}.markdown-body blockquote p{color:#595959;line-height:2}.markdown-body ol,.markdown-body ul{color:#595959;padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="tomorrow-night">.hljs-comment,.hljs-quote{color:#969896}.hljs-deletion,.hljs-name,.hljs-regexp,.hljs-selector-class,.hljs-selector-id,.hljs-tag,.hljs-template-variable,.hljs-variable{color:#c66}.hljs-built_in,.hljs-builtin-name,.hljs-link,.hljs-literal,.hljs-meta,.hljs-number,.hljs-params,.hljs-type{color:#de935f}.hljs-attribute{color:#f0c674}.hljs-addition,.hljs-bullet,.hljs-string,.hljs-symbol{color:#b5bd68}.hljs-section,.hljs-title{color:#81a2be}.hljs-keyword,.hljs-selector-tag{color:#b294bb}.markdown-body pre,.markdown-body pre&gt;code.hljs{background:#1d1f21;color:#c5c8c6}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">简介</h2>
<p><code>ReactDOM.preload</code>React 提供的资源预加载 API，用于在组件真正渲染前，提前告诉浏览器高优先级加载“当前页面一定会用到”的关键资源。</p>
<p>它在语义上等价于<code>&lt;link rel="preload"&gt; </code>，但由 React 统一管理，适用于并发渲染和 SSR / Streaming 场景。</p>
<h2 data-id="heading-1">主要功能（它解决了什么问题）</h2>
<p>用于提前预加载关键资源（脚本、样式、字体、图像等），优化页面性能。即：将<code>“资源加载”提前到渲染之前，缩短关键渲染路径。</code></p>
<p>在并发渲染或 Streaming SSR 场景中：</p>
<ul>
<li>组件可能还没 render</li>
<li>但已经确定某些资源马上会被使用（图片 / 字体 / CSS / JS）</li>
</ul>
<p>如果等组件 render 后再触发资源加载，会导致：</p>
<ul>
<li>首屏资源下载启动过晚</li>
<li>LCP（Largest Contentful Paint）变慢</li>
<li>Suspense resolve 后出现二次等待</li>
</ul>
<h2 data-id="heading-2">参数/属性</h2>
<h3 data-id="heading-3"><code>preload(href, options) </code></h3>


























<table><thead><tr><th>参数名</th><th>类型</th><th>必填</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td><code>href</code></td><td>string</td><td>✅</td><td>-</td><td>要预加载的资源URL</td></tr><tr><td><code>options</code></td><td>object</td><td>✅</td><td>-</td><td>配置选项</td></tr></tbody></table>
<h3 data-id="heading-4"><code>options</code> 对象参数:</h3>





















































































<table><thead><tr><th>属性</th><th>类型</th><th>必填</th><th>默认值</th><th>描述</th><th>有效值</th></tr></thead><tbody><tr><td>as</td><td>string</td><td>✅</td><td>-</td><td>资源类型</td><td>'audio', 'document', 'embed', 'font', 'image', 'object', 'script', 'style', 'track', 'video', 'worker'</td></tr><tr><td>crossOrigin</td><td>string</td><td>❌</td><td>undefined</td><td>CORS设置</td><td>'anonymous', 'use-credentials'</td></tr><tr><td>integrity</td><td>string</td><td>❌</td><td>undefined</td><td>子资源完整性(SRI)</td><td>哈希字符串 (如 'sha256-abc123...')</td></tr><tr><td>type</td><td>string</td><td>❌</td><td>undefined</td><td>资源MIME类型</td><td>'font/woff2', 'text/css', 'application/javascript' 等</td></tr><tr><td>fetchPriority</td><td>string</td><td>❌</td><td>'auto'</td><td>加载优先级</td><td>'high', 'low', 'auto'</td></tr><tr><td>referrerPolicy</td><td>string</td><td>❌</td><td>undefined</td><td>Referrer策略</td><td>'no-referrer', 'no-referrer-when-downgrade', 'origin', 'origin-when-cross-origin', 'unsafe-url'</td></tr><tr><td>imageSrcSet</td><td>string</td><td>❌</td><td>undefined</td><td>响应式图片源集</td><td>仅当 as: 'image' 时有效</td></tr><tr><td>imageSizes</td><td>string</td><td>❌</td><td>undefined</td><td>响应式图片尺寸</td><td>仅当 as: 'image' 时有效</td></tr><tr><td>media</td><td>string</td><td>❌</td><td>undefined</td><td>媒体查询条件</td><td>如 '(max-width: 768px)'</td></tr></tbody></table>
<h2 data-id="heading-5">使用场景</h2>
<h3 data-id="heading-6">Case1：预加载字体文件</h3>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">ReactDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;

<span class="hljs-comment">// 预加载自定义字体，避免FOUT/FOIT</span>
<span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">preload</span>(<span class="hljs-string">'/fonts/inter-bold.woff2'</span>, {
  <span class="hljs-attr">as</span>: <span class="hljs-string">'font'</span>,
  <span class="hljs-attr">type</span>: <span class="hljs-string">'font/woff2'</span>,
  <span class="hljs-attr">crossOrigin</span>: <span class="hljs-string">'anonymous'</span>,
  <span class="hljs-attr">fetchPriority</span>: <span class="hljs-string">'high'</span>
});
</code></pre>
<blockquote>
<p>📌字体 preload 几乎总是需要<code>crossOrigin</code>。</p>
</blockquote>
<h3 data-id="heading-7">Case2：预加载关键CSS</h3>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-comment">// 分离关键CSS和非关键CSS</span>
<span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">preload</span>(<span class="hljs-string">'/critical.css'</span>, {
  <span class="hljs-attr">as</span>: <span class="hljs-string">'style'</span>,
  <span class="hljs-attr">fetchPriority</span>: <span class="hljs-string">'high'</span>
});

<span class="hljs-comment">// 延迟加载非关键CSS</span>
<span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">preload</span>(<span class="hljs-string">'/non-critical.css'</span>, {
  <span class="hljs-attr">as</span>: <span class="hljs-string">'style'</span>,
  <span class="hljs-attr">fetchPriority</span>: <span class="hljs-string">'low'</span>,
  <span class="hljs-attr">media</span>: <span class="hljs-string">'print'</span>, <span class="hljs-comment">// 初始设为print，加载后切换</span>
  <span class="hljs-attr">onLoad</span>: <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'link[href="/non-critical.css"]'</span>).<span class="hljs-property">media</span> = <span class="hljs-string">'all'</span>;
  }
});
</code></pre>
<h3 data-id="heading-8">Case3：预加载脚本模块</h3>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-comment">// 预加载ES模块</span>
<span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">preload</span>(<span class="hljs-string">'/analytics-module.js'</span>, {
  <span class="hljs-attr">as</span>: <span class="hljs-string">'script'</span>,
  <span class="hljs-attr">type</span>: <span class="hljs-string">'module'</span>,
  <span class="hljs-attr">crossOrigin</span>: <span class="hljs-string">'anonymous'</span>,
  <span class="hljs-attr">integrity</span>: <span class="hljs-string">'sha256-abc123...'</span>
});

<span class="hljs-comment">// 预加载JSON模块</span>
<span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">preload</span>(<span class="hljs-string">'/config.json'</span>, {
  <span class="hljs-attr">as</span>: <span class="hljs-string">'fetch'</span>,
  <span class="hljs-attr">type</span>: <span class="hljs-string">'application/json'</span>
});
</code></pre>
<h3 data-id="heading-9">Case4：响应式图片预加载</h3>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-comment">// 预加载响应式图片</span>
<span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">preload</span>(<span class="hljs-string">'/hero-image.jpg'</span>, {
  <span class="hljs-attr">as</span>: <span class="hljs-string">'image'</span>,
  <span class="hljs-attr">fetchPriority</span>: <span class="hljs-string">'high'</span>,
  <span class="hljs-attr">imageSrcSet</span>: <span class="hljs-string">`
    hero-image-320w.jpg 320w,
    hero-image-480w.jpg 480w,
    hero-image-800w.jpg 800w
  `</span>,
  <span class="hljs-attr">imageSizes</span>: <span class="hljs-string">`
    (max-width: 320px) 280px,
    (max-width: 480px) 440px,
    800px
  `</span>
});
</code></pre>
<h3 data-id="heading-10">Case5：视频资源预加载</h3>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-comment">// 预加载视频元数据，但不下载整个视频</span>
<span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">preload</span>(<span class="hljs-string">'/product-demo.mp4'</span>, {
  <span class="hljs-attr">as</span>: <span class="hljs-string">'video'</span>,
  <span class="hljs-attr">type</span>: <span class="hljs-string">'video/mp4'</span>,
  <span class="hljs-attr">fetchPriority</span>: <span class="hljs-string">'low'</span>, <span class="hljs-comment">// 非关键资源用低优先级</span>
  <span class="hljs-attr">media</span>: <span class="hljs-string">'(min-width: 1024px)'</span> <span class="hljs-comment">// 仅在大屏幕预加载</span>
});
</code></pre>
<h3 data-id="heading-11">Case6：第三方资源预加载</h3>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-comment">// 预加载Google字体</span>
<span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">preload</span>(<span class="hljs-string">'https://fonts.gstatic.com/s/inter/v12/...woff2'</span>, {
  <span class="hljs-attr">as</span>: <span class="hljs-string">'font'</span>,
  <span class="hljs-attr">crossOrigin</span>: <span class="hljs-string">'anonymous'</span>,
  <span class="hljs-attr">type</span>: <span class="hljs-string">'font/woff2'</span>
});

<span class="hljs-comment">// 预加载CDN上的脚本</span>
<span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">preload</span>(<span class="hljs-string">'https://cdn.jsdelivr.net/npm/chart.js'</span>, {
  <span class="hljs-attr">as</span>: <span class="hljs-string">'script'</span>,
  <span class="hljs-attr">crossOrigin</span>: <span class="hljs-string">'anonymous'</span>
});
</code></pre>
<h3 data-id="heading-12">Case7：条件性预加载策略</h3>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-keyword">import</span> { useState, useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">SmartPreloadComponent</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> [shouldPreload, setShouldPreload] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);
  
  <span class="hljs-comment">// 用户接近特定区域时触发预加载</span>
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> observer = <span class="hljs-keyword">new</span> <span class="hljs-variable language_">window</span>.<span class="hljs-title class_">IntersectionObserver</span>(<span class="hljs-function">(<span class="hljs-params">entries</span>) =&gt;</span> {
      <span class="hljs-keyword">if</span> (entries[<span class="hljs-number">0</span>].<span class="hljs-property">isIntersecting</span> &amp;&amp; !shouldPreload) {
        <span class="hljs-title function_">setShouldPreload</span>(<span class="hljs-literal">true</span>);
        
        <span class="hljs-comment">// 预加载下一屏内容</span>
        <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">preload</span>(<span class="hljs-string">'/next-section.css'</span>, { <span class="hljs-attr">as</span>: <span class="hljs-string">'style'</span> });
        <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">preload</span>(<span class="hljs-string">'/interactive-widget.js'</span>, { <span class="hljs-attr">as</span>: <span class="hljs-string">'script'</span> });
      }
    }, { <span class="hljs-attr">threshold</span>: <span class="hljs-number">0.1</span> });
    
    <span class="hljs-keyword">const</span> trigger = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'#next-section-trigger'</span>);
    <span class="hljs-keyword">if</span> (trigger) observer.<span class="hljs-title function_">observe</span>(trigger);

    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> observer.<span class="hljs-title function_">disconnect</span>();
  }, [shouldPreload]);
  
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"next-section-trigger"</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
}
</code></pre>
<h3 data-id="heading-13">Case8：基于网络条件的智能预加载</h3>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-keyword">import</span> { useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">AdaptivePreload</span>(<span class="hljs-params"/>) {
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> connection = navigator.<span class="hljs-property">connection</span> || navigator.<span class="hljs-property">mozConnection</span> || navigator.<span class="hljs-property">webkitConnection</span>;
    
    <span class="hljs-keyword">if</span> (connection) {
      <span class="hljs-keyword">switch</span> (connection.<span class="hljs-property">effectiveType</span>) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">'4g'</span>:
          <span class="hljs-comment">// 高速网络：预加载更多资源</span>
          <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">preload</span>(<span class="hljs-string">'/carousel-images.jpg'</span>, { <span class="hljs-attr">as</span>: <span class="hljs-string">'image'</span> });
          <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">preload</span>(<span class="hljs-string">'/video-preview.mp4'</span>, { <span class="hljs-attr">as</span>: <span class="hljs-string">'video'</span> });
          <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">preload</span>(<span class="hljs-string">'/comments-widget.js'</span>, { <span class="hljs-attr">as</span>: <span class="hljs-string">'script'</span> });
          <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-string">'3g'</span>:
          <span class="hljs-comment">// 中速网络：只预加载关键资源</span>
          <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">preload</span>(<span class="hljs-string">'/hero-image.jpg'</span>, { <span class="hljs-attr">as</span>: <span class="hljs-string">'image'</span>, <span class="hljs-attr">fetchPriority</span>: <span class="hljs-string">'high'</span> });
          <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-string">'2g'</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'slow-2g'</span>:
          <span class="hljs-comment">// 低速网络：不预加载额外资源</span>
          <span class="hljs-keyword">break</span>;
      }
      <span class="hljs-keyword">if</span> (connection.<span class="hljs-property">saveData</span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'省流量模式开启，跳过非关键预加载'</span>);
      }
    }
  }, []);
  
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>自适应预加载组件<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
}
</code></pre>
<h3 data-id="heading-14">Case9：路由级资源预加载</h3>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-keyword">import</span> { useNavigate } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-router-dom'</span>;

<span class="hljs-keyword">const</span> routePreloadConfig = {
  <span class="hljs-string">'/dashboard'</span>: [
    { <span class="hljs-attr">href</span>: <span class="hljs-string">'/dashboard-styles.css'</span>, <span class="hljs-attr">as</span>: <span class="hljs-string">'style'</span> },
    { <span class="hljs-attr">href</span>: <span class="hljs-string">'/charts-library.js'</span>, <span class="hljs-attr">as</span>: <span class="hljs-string">'script'</span> }
  ],
  <span class="hljs-string">'/editor'</span>: [
    { <span class="hljs-attr">href</span>: <span class="hljs-string">'/monaco-editor.css'</span>, <span class="hljs-attr">as</span>: <span class="hljs-string">'style'</span> },
    { <span class="hljs-attr">href</span>: <span class="hljs-string">'/monaco-editor.js'</span>, <span class="hljs-attr">as</span>: <span class="hljs-string">'script'</span>, <span class="hljs-attr">fetchPriority</span>: <span class="hljs-string">'high'</span> }
  ]
};

<span class="hljs-keyword">function</span> <span class="hljs-title function_">useRoutePreload</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> navigate = <span class="hljs-title function_">useNavigate</span>();
  
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">preloadAndNavigate</span> = (<span class="hljs-params">path</span>) =&gt; {
    <span class="hljs-comment">// 预加载目标路由资源</span>
    <span class="hljs-keyword">const</span> resources = routePreloadConfig[path] || [];
    resources.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">{ href, ...options }</span>) =&gt;</span> {
      <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">preload</span>(href, options);
    });
    <span class="hljs-comment">// 延迟导航，确保资源开始加载</span>
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">navigate</span>(path), <span class="hljs-number">50</span>);
  };
  
  <span class="hljs-keyword">return</span> preloadAndNavigate;
}
</code></pre>
<h3 data-id="heading-15">Case10：错误处理和回退</h3>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-keyword">import</span> { useState, useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">SafePreloadComponent</span>(<span class="hljs-params">{ imageUrl, fallbackUrl }</span>) {
  <span class="hljs-keyword">const</span> [preloadFailed, setPreloadFailed] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);
  
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// 创建link元素进行预加载</span>
    <span class="hljs-keyword">const</span> link = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">'link'</span>);
    link.<span class="hljs-property">rel</span> = <span class="hljs-string">'preload'</span>;
    link.<span class="hljs-property">href</span> = imageUrl;
    link.<span class="hljs-property">as</span> = <span class="hljs-string">'image'</span>;
    
    <span class="hljs-comment">// 添加错误处理</span>
    link.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'error'</span>, <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">`预加载失败: <span class="hljs-subst">${imageUrl}</span>`</span>);
      <span class="hljs-title function_">setPreloadFailed</span>(<span class="hljs-literal">true</span>);
      <span class="hljs-comment">// 尝试预加载回退资源</span>
      <span class="hljs-keyword">if</span> (fallbackUrl) {
        <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">preload</span>(fallbackUrl, { <span class="hljs-attr">as</span>: <span class="hljs-string">'image'</span> });
      }
    });
    
    <span class="hljs-comment">// 添加成功回调</span>
    link.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'load'</span>, <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`预加载成功: <span class="hljs-subst">${imageUrl}</span>`</span>);
    });
    
    <span class="hljs-variable language_">document</span>.<span class="hljs-property">head</span>.<span class="hljs-title function_">appendChild</span>(link);
    
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">document</span>.<span class="hljs-property">head</span>.<span class="hljs-title function_">removeChild</span>(link);
    };
  }, [imageUrl, fallbackUrl]);
  
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> 
      <span class="hljs-attr">src</span>=<span class="hljs-string">{preloadFailed</span> ? <span class="hljs-attr">fallbackUrl</span> <span class="hljs-attr">:</span> <span class="hljs-attr">imageUrl</span>} 
      <span class="hljs-attr">alt</span>=<span class="hljs-string">"示例图片"</span>
      <span class="hljs-attr">onError</span>=<span class="hljs-string">{(e)</span> =&gt;</span> {
        if (fallbackUrl &amp;&amp; e.target.src !== fallbackUrl) {
          e.target.src = fallbackUrl;
        }
      }}
    /&gt;</span>
  );
}
</code></pre>
<h2 data-id="heading-16">什么时候使用</h2>
<p>:::tip
只有当“资源一定会在当前页面立即使用，并且影响首屏体验”时，才考虑使用 ReactDOM.preload。
:::</p>
<h2 data-id="heading-17">参考</h2>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fzh-hans.react.dev%2Freference%2Freact-dom%2Fpreload" target="_blank" title="https://zh-hans.react.dev/reference/react-dom/preload" ref="nofollow noopener noreferrer">React 官网</a></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[2 数组 递归 复杂度 字符串]]></title>    <link>https://juejin.cn/post/7584028251167866907</link>    <guid>https://juejin.cn/post/7584028251167866907</guid>    <pubDate>2025-12-16T08:16:17.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584028251167866907" data-draft-id="7584028251167850523" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="2 数组  递归   复杂度  字符串"/> <meta itemprop="keywords" content="JavaScript,前端"/> <meta itemprop="datePublished" content="2025-12-16T08:16:17.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="瘦的可以下饭了"/> <meta itemprop="url" content="https://juejin.cn/user/895474817042060"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            2 数组  递归   复杂度  字符串
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/895474817042060/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    瘦的可以下饭了
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-16T08:16:17.000Z" title="Tue Dec 16 2025 08:16:17 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-16
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1小时+
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>数据结构层面，大家需要掌握以下几种：</p>
<ul>
<li>数组</li>
<li>栈</li>
<li>队列</li>
<li>链表</li>
<li>树（这里我们着重讲二叉树）</li>
</ul>
<p>对于这些数据结构，各位如果没有大量的可支配时间可以投入，那么其实不建议找厚厚的大学教材来刷。此时此刻，时间为王，我们追求的是效率的最大化。</p>
<p>不同的数据结构教材，对数据结构有着不同的划分、不同的解读、不同的编码实现。在这里，我们面向 JavaScript，面向前端面试，只针对大家后续做题、答题时会用到的最贴合实战的数据结构特性&amp;编码技能作讲解。</p>
<p><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="LightPink"><mtext>保姆式教学の</mtext><mstyle mathcolor="Pink"><mtext>温情提示：</mtext></mstyle></mstyle></mrow><annotation encoding="application/x-tex">\color{LightPink}{保姆式教学の}\color{Pink}{温情提示：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"/><span class="mord" style="color:LightPink;"><span class="mord cjk_fallback" style="color:LightPink;">保姆式教学の</span></span><span class="mord" style="color:Pink;"><span class="mord cjk_fallback" style="color:Pink;">温情提示：</span></span></span></span></span></span><br/>
这两节我们所提及的基础知识细节，很可能会成为你后面写代码的关键线索。<br/>
<strong>不要因为乍一看觉得简单，就急着跳读急着做题</strong>。<br/>
不然你很可能做题做到一半，会不知道自己到底为什么就卡了壳。<br/>
到时候万一又因为懒得回头看，而原地卡死，那就更做不下去了orz。</p>
<p>注：由于 JavaScript 中字符串和数组关联紧密，关键知识点重复度较高，故我们在数据结构部分，不再单独为字符串保留篇幅。字符串相关的知识点，我们直接带到后续的解题技巧归纳专题里去看。</p>
<h3 data-id="heading-0">数组</h3>
<p>数组是各位要认识的第一个数据结构。<br/>
作为最简单、最基础的数据结构，大多数的语言都天然地对数组有着原生的表达，JavaScript 亦然。这意味着我们可以对数组做到“开箱即用”，而不必自行模拟实现，非常方便。</p>
<p>考虑到日常开发过程中，数组的出镜率本身已经很高，相信它也是大多数同学最熟悉的数据结构。 即便如此，这里仍然需要提醒各位：<strong>要对数组格外走点心，毕竟后面需要它帮忙的地方会非常多</strong>。</p>
<h4 data-id="heading-1">数组的创建</h4>
<p>大家平时用的最多的创建方式想必就是直接方括号+元素内容这种形式：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]   
</code></pre>
<p>不过在算法题中，很多时候我们初始化一个数组时，并不知道它内部元素的情况。这种场景下，要给大家推荐的是构造函数创建数组的方法：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>()
</code></pre>
<p>当我们以构造函数的形式创建数组时，若我们像楼上这样，不传任何参数，得到的就会是一个空数组。等价于：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> arr = []
</code></pre>
<p>不过咱们使用构造函数，可不是为了创建空数组这么无聊。<br/>
我们需要它的时候，往往是因为我们有“创造指定长度的空数组”这样的需求。需要多长的数组，就给它传多大的参数：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">7</span>)
</code></pre>
<p>这样的写法就可以得到一个长度为7的数组：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/8/170b97e7423bafba~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp#?w=832&amp;h=270&amp;s=31854&amp;e=png" alt="" loading="lazy"/></p>
<p>在一些场景中，这个需求会稍微变得有点复杂——
“创建一个长度确定、同时每一个元素的值也都确定的数组”。这时我们可以调用 fill 方法，假设需求是每个坑里都填上一个1，只需给它 fill 一个1：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> arr = (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">7</span>)).<span class="hljs-title function_">fill</span>(<span class="hljs-number">1</span>)
</code></pre>
<p>如此便可以得到一个长度为7，且每个元素都初始化为1的数组：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/8/170b9821b9fce58b~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp#?w=846&amp;h=150&amp;s=14874&amp;e=png&amp;b=fefefe" alt="" loading="lazy"/></p>
<h5 data-id="heading-2">数组的访问和遍历</h5>
<p>访问数组中的元素，我们直接在中括号中指定其索引即可：</p>
<pre><code class="hljs language-js" lang="js">arr[<span class="hljs-number">0</span>] <span class="hljs-comment">// 访问索引下标为0的元素</span>
</code></pre>
<p>而遍历数组，这个方法就多了，不过目的往往都是一致的——访问到数组中的每个元素，并且知道当前元素的索引。这里我们讲三个方法：</p>
<ol>
<li><strong>for 循环</strong><br/>
这个是最最基础的操作。我们可以通过循环数组的下标，来依次访问每个值：</li>
</ol>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 获取数组的长度</span>
<span class="hljs-keyword">const</span> len = arr.<span class="hljs-property">length</span>
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;len;i++) {
    <span class="hljs-comment">// 输出数组的元素值，输出当前索引</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[i], i)
}
</code></pre>
<ol start="2">
<li><strong>forEach 方法</strong><br/>
通过取 forEach 方法中传入函数的第一个入参和第二个入参，我们也可以取到数组每个元素的值及其对应索引：</li>
</ol>
<pre><code class="hljs language-js" lang="js">arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item, index</span>)=&gt;</span> {
    <span class="hljs-comment">// 输出数组的元素值，输出当前索引</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item, index)
})
</code></pre>
<ol start="3">
<li><strong>map 方法</strong><br/>
map 方法在调用形式上与 forEach 无异，区别在于 map 方法会根据你传入的函数逻辑对数组中每个元素进行处理、进而返回一个全新的数组。<br/>
所以其实 map 做的事情不仅仅是遍历，而是在遍历的基础上“再加工”。当我们需要对数组内容做批量修改、同时修改的逻辑又高度一致时，就可以调用 map 来达到我们的目的：</li>
</ol>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> newArr = arr.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">item, index</span>)=&gt;</span> {
    <span class="hljs-comment">// 输出数组的元素值，输出当前索引</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item, index)
    <span class="hljs-comment">// 在当前元素值的基础上加1</span>
    <span class="hljs-keyword">return</span> item+<span class="hljs-number">1</span>
})
</code></pre>
<p>这段代码就通过 map 来返回了一个全新的数组，数组中每个元素的值都是在其现有元素值的基础上+1后的结果。</p>
<p>这里给个小建议：个人推荐如果没有特殊的需要，那么统一使用 for 循环来实现遍历。因为<strong>从性能上看，for 循环遍历起来是最快的</strong>。</p>
<h4 data-id="heading-3">二维数组</h4>
<p>初学编程的同学基础如果比较薄弱，会对二维数组完全没有概念。这里咱们先简单介绍下：二维数组其实就是数组套数组，也就是每个元素都是数组的数组。<br/>
说起来有点绕口，咱们直接上图来看：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]
</code></pre>
<p>这个数组在逻辑上的分布就是这样式儿的：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/8/170b9a59c3bc0944~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp#?w=882&amp;h=266&amp;s=15240&amp;e=png" alt="" loading="lazy"/></p>
<p>像图上这样，数组的元素是数字而非数组。整个数组的结构看上去宛如一条“线”，这就是一维数组。<br/>
而“每个元素都是数组的数组”，代码里看是这样：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> arr = [
  [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],
  [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],
  [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],
  [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],
  [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]
]
</code></pre>
<p>直接把它的逻辑结构画出来看，是这样：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/8/170b9bedc6a882c1~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp#?w=850&amp;h=788&amp;s=38505&amp;e=png&amp;b=1ca2fc" alt="" loading="lazy"/><br/>
图中的每一行，就代表着一个数组元素。比如第 0 行，就代表着数组中 arr[0] 这个数组元素，其内容是 [1,2,3,4,5]。<br/>
每一行中的每一列，则代表一个确切的“坑”。比如第 0 行第 1 列，就代表着数组中 arr[0][1] 这个元素，其值为2，是一个确切的 number。</p>
<p>明白了二维数组的索引规律，现在我们来看一下二维数组的特点：从形状上看，相对于一维数组一条“线”一般的布局，二维数组更像是一个“面”。拿咱们这个例子来说，这里的二维数组逻辑分布图就宛如一个正方形。当然啦，如果我们稍微延长一下其中的一边，它也可以是一个矩形。</p>
<p>在数学中，形如这样<strong>长方阵列排列的复数或实数集合</strong>，被称为“矩阵”。因此<strong>二维数组的别名就叫“矩阵”</strong>。</p>
<p>讲到这里，如果有对“矩阵”的定义一脸懵逼的同学，也不用怕——不知道“矩阵”是啥，一点不打紧（所以快停下你复制粘贴到 Google 的手哈哈），但你必须要<strong>记住“矩阵”和“二维数组”之间的等价关系</strong>。在算法题目中，见到“矩阵”时，能够立刻反射出它说的是二维数组，不被别名整懵逼，这就够了。</p>
<h4 data-id="heading-4">二维数组的初始化</h4>
<h5 data-id="heading-5">fill 的局限性</h5>
<p>有同学用 fill 方法用顺了手，就本能地想用 fill 解决所有的问题，比如初始化一个二维数组：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> arr =(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">7</span>)).<span class="hljs-title function_">fill</span>([])
</code></pre>
<p>乍一看没啥毛病，7个坑都被乖乖地填上了数组元素：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/8/170b9cf7d9677680~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp#?w=1246&amp;h=752&amp;s=77964&amp;e=png" alt="" loading="lazy"/><br/>
但是当你想修改某一个坑里的数组的值的时候：</p>
<pre><code class="hljs language-js" lang="js">arr[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>
</code></pre>
<p>你会发现一整列的元素都被设为了 1：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/8/170b9d27489b1815~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp#?w=1300&amp;h=758&amp;s=79078&amp;e=png" alt="" loading="lazy"/></p>
<p>这是什么骚操作？？？<br/>
这就要从 fill 的工作机制讲起了。各位要清楚，当你给 fill 传递一个入参时，<strong>如果这个入参的类型是引用类型，那么 fill 在填充坑位时填充的其实就是入参的引用</strong>。也就是说下图中虽然看似我们给7个坑位各初始化了一个数组：<br/>
<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/8/170b9cf7d9677680~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp#?w=1246&amp;h=752&amp;s=77964&amp;e=png" alt="" loading="lazy"/><br/>
其实这7个数组对应了同一个引用、指向的是同一块内存空间，<strong>它们本质上是同一个数组</strong>。因此当你修改第0行第0个元素的值时，第1-6行的第0个元素的值也都会跟着发生改变。</p>
<h5 data-id="heading-6">初始化一个二维数组</h5>
<p>本着安全的原则，这里我推荐大家采纳的二维数组初始化方法非常简单（而且性能也不错）。直接用一个 for 循环来解决：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> len = arr.<span class="hljs-property">length</span>
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;len;i++) {
    <span class="hljs-comment">// 将数组的每一个坑位初始化为数组</span>
    arr[i] = []
}
</code></pre>
<p>for 循环中，每一次迭代我们都通过“[]”来创建一个新的数组，这样便不会有引用指向问题带来的尴尬。</p>
<h5 data-id="heading-7">二维数组的访问</h5>
<p>访问二维数组和访问一维数组差别不大，区别在于我们现在需要的是两层循环：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 缓存外部数组的长度</span>
<span class="hljs-keyword">const</span> outerLen = arr.<span class="hljs-property">length</span>
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;outerLen;i++) {
    <span class="hljs-comment">// 缓存内部数组的长度</span>
    <span class="hljs-keyword">const</span> innerLen = arr[i].<span class="hljs-property">length</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j=<span class="hljs-number">0</span>;j&lt;innerLen;j++) {
        <span class="hljs-comment">// 输出数组的值，输出数组的索引</span>
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[i][j],i,j)
    }
}
</code></pre>
<p>一维数组用 for 循环遍历只需一层循环，二维数组是两层，三维数组就是三层。依次类推，<strong>N 维数组需要 N 层循环来完成遍历</strong>。</p>
<h3 data-id="heading-8">数组小结</h3>
<p>关于数组的基础知识，咱们整整用掉了一节的篇幅来介绍，可见其重要性。</p>
<p>在本节，我们仅仅围绕数组最基本的操作进行介绍，这远不是数组的全部。关于数组，还有太多太多的故事要讲——实际上，单就其重要的方法的使用：如concat、some、slice、join、sort、pop、push 等等这些，就足以说上个把钟头。</p>
<p>本节暂时不对数组 API 作集中讲解，因为罗列 API 没有意义——脱离场景去记忆 API 实在是一件太痛苦的事情，这会挫伤各位继续走下去的积极性。</p>
<p>关于数组的更多特性和技巧，会被打散到后续的章节中去。各位在真题解读的环节、包括在其它数据结构的讲解中，都会不可避免地再见到数组的身影。彼时数组的每一个方法都会和它对应的应用场景一起出现，相信你会有更深刻的记忆。</p>
<p>事实上，在 JavaScript 数据结构中，数组几乎是“基石”一般的存在。这一点，大家在下一节就会有所感触。</p>
<p>（阅读过程中有任何想法或疑问，或者单纯希望和笔者交个朋友啥的，欢迎大家添加我的微信xyalinode与我交流哈~）</p>
<p>本节我们基于对数组的理解和掌握，围剿线性数据结构（栈、队列和链表）。</p>
<h3 data-id="heading-9">栈和队列</h3>
<p>在 JavaScript 中，<strong>栈和队列的实现一般都要依赖于数组</strong>，大家完全可以把栈和队列都看作是“特别的数组”。</p>
<p>（注：实际上，栈和队列作为两种运算受限的<strong>线性表</strong>，用链表来实现也是没问题的。只是从前端面试做题的角度来说，基于链表来实现栈和队列约等于脱裤子放屁（链表实现起来会比数组麻烦得多，做不到开箱即用），基本没人会这么干。这里大家按照数组的思路往下走就行了）</p>
<p>两者的区别在于，它们各自对数组的<strong>增删操作</strong>有着不一样的限制。因此，在学习栈与队列之前，我们需要先来明确一下数组中的增删操作具有什么样的特性、对应的方法有哪些：</p>
<h4 data-id="heading-10">灵活增删的数组</h4>
<p>数组的增删操作可以说是没有任何限制的，允许我们在任何位置执行想要的操作。</p>
<h5 data-id="heading-11">数组中增加元素的三种方法</h5>
<ul>
<li>unshift 方法-添加元素到数组的头部</li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]
arr.<span class="hljs-title function_">unshift</span>(<span class="hljs-number">0</span>) <span class="hljs-comment">// [0,1,2]</span>
</code></pre>
<ul>
<li>push 方法-添加元素到数组的尾部</li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]
arr.<span class="hljs-title function_">push</span>(<span class="hljs-number">3</span>) <span class="hljs-comment">// [1,2,3]</span>
</code></pre>
<ul>
<li>splice 方法-添加元素到数组的任何位置</li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>] 
arr.<span class="hljs-title function_">splice</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>) <span class="hljs-comment">// [1,3,2]</span>
</code></pre>
<p>这里重点讲一下这个 splice 方法。很多同学对传入两个以上的参数这种用法可能比较陌生。大家相对熟悉的应该还是 splice 用于删除的操作：</p>
<pre><code class="hljs language-js" lang="js">arr.<span class="hljs-title function_">splice</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)
</code></pre>
<p>第一个入参是起始的索引值，第二个入参表示从起始索引开始需要删除的元素个数。这里我们指明从索引为1的元素开始，删掉1个元素，也就相当于把 arr[1] 给删掉了。这就是数组中<strong>删除任意位置元素的方法</strong>。<br/>
至于传入两个以上参数这种用法，是用于在删除的同时完成数组元素的新增。而从第三个位置开始的入参，都代表着需要添加到数组里的元素的值：</p>
<pre><code class="hljs language-js" lang="js">arr.<span class="hljs-title function_">splice</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>) <span class="hljs-comment">// [1,3,2]</span>
</code></pre>
<p>在这个例子里，我们就指明了从 arr[1] 开始，删掉 0 个元素，并且在索引为1的地方新增了值为3的元素。<br/>
因为删掉的元素是0个，所以说 arr[1] 中原有的元素值“2”仍然会被保留下来；同时因为我们后面又指定了 arr[1] 处需要新增一个元素3，那么这个3就会把原来arr[1]这个地方的元素给“挤到后面去”。这样我们就做到了在数组中任意位置进行元素的新增。这个过程如下图：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8bb23bc7244f4f93bd2f85a3c65016e8~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=760&amp;h=632&amp;s=23173&amp;e=png&amp;b=ffffff" alt="" loading="lazy"/></p>
<h5 data-id="heading-12">数组中删除元素的三种方法</h5>
<ul>
<li>shift 方法-删除数组头部的元素</li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]
arr.<span class="hljs-title function_">shift</span>() <span class="hljs-comment">// [2,3]</span>
</code></pre>
<ul>
<li>pop 方法-删除数组尾部的元素</li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]
arr.<span class="hljs-title function_">pop</span>() <span class="hljs-comment">// [1,2]</span>
</code></pre>
<ul>
<li>splice 方法-删除数组任意位置的元素<br/>
splice 方法我们上文已经详细讲过，此处不再赘述。</li>
</ul>
<h4 data-id="heading-13">栈（Stack）——只用 pop 和 push 完成增删的“数组”</h4>
<p>栈是一种后进先出(LIFO，Last In First Out)的数据结构。<br/>
我们可以把它想象成小时候学校门口小卖部里，摞满了冰淇淋的方形大冰柜。<br/>
小卖部老板往里面摆置冰淇淋的时候，最先摆进去的会落在冰柜的底部，最后摆置进去的留在冰柜的顶部。如果这时候咱们去买冰淇淋，老板就会把冰柜顶部的那个取出来给我们。在冰淇淋不断被取出的这个过程里，越是后来放进去的，越是先被取出来；越是先放进去的，越是最后被取出来。这个过程，就是所谓的“后进先出”：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5248e4cb4f26445fb04c2f0a231dd9b6~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1268&amp;h=846&amp;s=53338&amp;e=png&amp;b=ffffff" alt="" loading="lazy"/>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c87d3e3a7ee47309cd33bc2976e15a7~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1296&amp;h=844&amp;s=70920&amp;e=png&amp;b=ffffff" alt="" loading="lazy"/></p>
<p>我们看到这个过程有两个特征：</p>
<ul>
<li>只允许从尾部添加元素</li>
<li>只允许从尾部取出元素<br/>
对应到数组的方法，刚好就是 push 和 pop。因此，我们可以认为在 JavaScript 中，栈就是限制只能用 push 来添加元素，同时只能用 pop 来移除元素的一种特殊的数组。</li>
</ul>
<p>除了 pop 和 push 之外，栈相关的面试题中往往还会涉及到取栈顶元素的操作。所谓栈顶元素，从图上我们不难看出来，实际上它指的就是数组尾部的元素。</p>
<p>下面我们基于数组来实现一波栈的常用操作，完成“放置冰淇淋”和“卖冰淇淋”的过程：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 初始状态，栈空</span>
<span class="hljs-keyword">const</span> stack = []  
<span class="hljs-comment">// 入栈过程</span>
stack.<span class="hljs-title function_">push</span>(<span class="hljs-string">'东北大板'</span>)
stack.<span class="hljs-title function_">push</span>(<span class="hljs-string">'可爱多'</span>)
stack.<span class="hljs-title function_">push</span>(<span class="hljs-string">'巧乐兹'</span>)
stack.<span class="hljs-title function_">push</span>(<span class="hljs-string">'冰工厂'</span>)
stack.<span class="hljs-title function_">push</span>(<span class="hljs-string">'光明奶砖'</span>)

<span class="hljs-comment">// 出栈过程，栈不为空时才执行</span>
<span class="hljs-keyword">while</span>(stack.<span class="hljs-property">length</span>) {
    <span class="hljs-comment">// 单纯访问栈顶元素（不出栈）</span>
    <span class="hljs-keyword">const</span> top = stack[stack.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>]
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'现在取出的冰淇淋是'</span>, top)  
    <span class="hljs-comment">// 将栈顶元素出栈</span>
    stack.<span class="hljs-title function_">pop</span>()
}

<span class="hljs-comment">// 栈空</span>
stack <span class="hljs-comment">// []</span>
</code></pre>
<p>丢到控制台运行，冰淇淋就会按照后进先出的顺序被取出：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3214df44908b41f0928c51ed5e93cc58~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1208&amp;h=374&amp;s=117317&amp;e=png&amp;b=fefefe" alt="" loading="lazy"/></p>
<h4 data-id="heading-14">队列（Queue）——只用 push 和 shift 完成增删的“数组”</h4>
<p>队列是一种先进先出（FIFO，First In First Out）的数据结构。<br/>
它比较像咱们去肯德基排队点餐。先点餐的人先出餐，后点餐的人后出餐：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33522d7a89ef44cba52975b9793ca7d3~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=940&amp;h=810&amp;s=63687&amp;e=png&amp;b=ffffff" alt="" loading="lazy"/>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/285f76f511aa413ba04a8c510d136ae1~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=822&amp;h=814&amp;s=63483&amp;e=png&amp;b=ffffff" alt="" loading="lazy"/></p>
<p>这个过程的规律也很明显：</p>
<ul>
<li>只允许从尾部添加元素</li>
<li>只允许从头部移除元素</li>
</ul>
<p>也就是说整个过程只涉及了数组的 push 和 shift 方法。<br/>
在栈元素出栈时，我们关心的是栈顶元素（数组的最后一个元素）；队列元素出队时，我们关心的则是队头元素（数组的第一个元素）。<br/>
下面我们基于数组来实现一波队列的常用操作，完成“小册姐排队”和“小册姐取餐”的过程：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> queue = []  
queue.<span class="hljs-title function_">push</span>(<span class="hljs-string">'小册一姐'</span>)
queue.<span class="hljs-title function_">push</span>(<span class="hljs-string">'小册二姐'</span>)
queue.<span class="hljs-title function_">push</span>(<span class="hljs-string">'小册三姐'</span>)  
  
<span class="hljs-keyword">while</span>(queue.<span class="hljs-property">length</span>) {
    <span class="hljs-comment">// 单纯访问队头元素（不出队）</span>
    <span class="hljs-keyword">const</span> top = queue[<span class="hljs-number">0</span>]
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(top,<span class="hljs-string">'取餐'</span>)
    <span class="hljs-comment">// 将队头元素出队</span>
    queue.<span class="hljs-title function_">shift</span>()
}

<span class="hljs-comment">// 队空</span>
queue <span class="hljs-comment">// []</span>
</code></pre>
<p>把上面代码丢进控制台运行，我们可以看到小册姐一个接一个地乖乖去取餐了：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d209732f39cf42da991a17d47dbe1d36~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1186&amp;h=230&amp;s=48465&amp;e=png&amp;b=fefefe" alt="" loading="lazy"/></p>
<h3 data-id="heading-15">链表</h3>
<p>链表和数组相似，它们都是有序的列表、都是线性结构（有且仅有一个前驱、有且仅有一个后继）。不同点在于，链表中，数据单位的名称叫做“结点”，而结点和结点的分布，在内存中可以是<strong>离散</strong>的。</p>
<p>这个“离散”是相对于数组的“连续”来说的。上一节咱们给大家画过数组的元素分布示意图：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36ee8a2b5e554d1e99125a3ace41f65a~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=882&amp;h=266&amp;s=15240&amp;e=png&amp;b=ffffff" alt="" loading="lazy"/></p>
<p>数组在内存中最为关键的一个特征，就是它一般是对应一段位于自己上界和下界之间的、一段<strong>连续</strong>的内存空间。元素与元素之间，紧紧相连（当然啦，还有二般情况，我们在下文的辨析环节会提到）。</p>
<p>而链表中的结点，则允许散落在内存空间的各个角落里。一个内容为1-&gt;2-&gt;3-&gt;4-&gt;5的链表，在内存中的形态可以是散乱如下的：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87081b9e7fea480bb20225830f141e9b~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=892&amp;h=776&amp;s=21367&amp;e=png&amp;b=1ca2fc" alt="" loading="lazy"/><br/>
正是由于数组中的元素是连续的，每个元素的内存地址可以根据其索引距离数组头部的距离来计算出来。因此对数组来说，每一个元素都可以通过数组的索引下标直接定位。</p>
<p>但是对链表来说，元素和元素之间似乎毫无内存上的瓜葛可言。就比如说咱们图上这种情况，1、2、3、4、5各据山头，站在元素1的坑位里，我们对元素2、3、4、5的内存地址一无所知，连遍历都没法遍历，这可咋整？</p>
<p>没有关联，就创造关联！</p>
<p>在链表中，每一个结点的结构都包括了两部分的内容：数据域和指针域。JS 中的链表，是以嵌套的对象的形式来实现的：</p>
<pre><code class="hljs language-js" lang="js">{
    <span class="hljs-comment">// 数据域</span>
    <span class="hljs-attr">val</span>: <span class="hljs-number">1</span>,
    <span class="hljs-comment">// 指针域，指向下一个结点</span>
    <span class="hljs-attr">next</span>: {
        <span class="hljs-attr">val</span>:<span class="hljs-number">2</span>,
        <span class="hljs-attr">next</span>: ...
    }
}   
</code></pre>
<p>数据域存储的是当前结点所存储的数据值，而指针域则代表下一个结点（后继结点）的引用。
有了 next 指针来记录后继结点的引用，每一个结点至少都能知道自己后面的同学是哪位了，原本相互独立的结点之间就有了如下的联系：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d0baf800bfb4b5bb81f6fbc83dfdb9c~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=792&amp;h=742&amp;s=25909&amp;e=png&amp;b=1ca2fc" alt="" loading="lazy"/></p>
<p>我们把这个关系给简化一下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae5e9931272d49e18d96122dfa186e86~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1314&amp;h=462&amp;s=30110&amp;e=png&amp;b=ffffff" alt="" loading="lazy"/><br/>
要想访问链表中的任何一个元素，我们都得从起点结点开始，逐个访问 next，一直访问到目标结点为止。为了确保起点结点是可抵达的，我们有时还会设定一个 head 指针来专门指向链表的开始位置：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/981d8c74866d4aefb8b695c9e4ed0e1e~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1266&amp;h=562&amp;s=43215&amp;e=png&amp;b=ffffff" alt="" loading="lazy"/><br/>
以上，就是链表的基本形态啦。</p>
<h4 data-id="heading-16">链表结点的创建</h4>
<p>创建链表结点，咱们需要一个构造函数：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ListNode</span>(<span class="hljs-params">val</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">val</span> = val;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">next</span> = <span class="hljs-literal">null</span>;
}
</code></pre>
<p>在使用构造函数创建结点时，传入 val （数据域对应的值内容）、指定 next （下一个链表结点）即可：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">1</span>)  
node.<span class="hljs-property">next</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">2</span>)
</code></pre>
<p>以上，就创建出了一个数据域值为1，next 结点数据域值为2的链表结点：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/816ad2c296f74df78342093e4d6edcf6~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=682&amp;h=258&amp;s=12528&amp;e=png&amp;b=ffffff" alt="" loading="lazy"/></p>
<h4 data-id="heading-17">链表元素的添加</h4>
<p>结合前面的学习，我们已经知道，链表的结点间关系是通过 next 指针来维系的。因此，链表元素的添加和删除操作，本质上都是在围绕 next 指针做文章。</p>
<p>先来说说添加，直接在尾部添加结点相对比较简单，我们改变一个 next 指针就行。这里记值为2的 node 结点为 node2（假设 node2 是现在的尾部结点），值为3的 node 结点为 node3。假如我要把 node3 添加到 node2 所在链表的尾部，直接把 node2 的 next 指针指向 node3 即可：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97312baddfb342128ffb9c205bedccac~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=928&amp;h=288&amp;s=17560&amp;e=png&amp;b=ffffff" alt="" loading="lazy"/></p>
<p>需要大家引起重视的是另一种添加操作：如何在两个结点间插入一个结点？注意，由于链表有时会有头结点，这时即便你是往链表头部增加结点，其本质也是“在头结点和第一个结点之间插入一个新结点”。所以说，<strong>任意两结点间插入一个新结点</strong>这种类型的增加操作，将会是链表基础中的一个关键考点。</p>
<p>要想完成这个动作，我们需要变更的是<strong>前驱结点</strong>和<strong>目标结点</strong>的 next 指针指向，过程如下图：<br/>
插入前：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/601217fc64d141f0aed48f6558c53998~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=846&amp;h=506&amp;s=22276&amp;e=png&amp;b=ffffff" alt="" loading="lazy"/>
插入后：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/faf00f911dc04864ae52a6343dacafa2~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=798&amp;h=550&amp;s=27741&amp;e=png&amp;b=ffffff" alt="" loading="lazy"/></p>
<p>注意我圈红的地方，就是咱们要动手脚的地方。下面我用代码来表述一下这个改变。：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 如果目标结点本来不存在，那么记得手动创建</span>
<span class="hljs-keyword">const</span> node3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">3</span>)     
<span class="hljs-comment">// 把node3的 next 指针指向 node2（即 node1.next）</span>
node3.<span class="hljs-property">next</span> = node1.<span class="hljs-property">next</span>
<span class="hljs-comment">// 把node1的 next 指针指向 node3</span>
node1.<span class="hljs-property">next</span> = node3
</code></pre>
<h4 data-id="heading-18">链表元素的删除</h4>
<p>链表元素的删除也是非常高频的操作。延续我们前面的思路，仍然把重心放在对 next 指针的调整上。我们思考一下：如何把刚刚添加进来的 node3 从现在的链表里删掉？<br/>
注意，删除的标准是：在链表的遍历过程中，无法再遍历到某个结点的存在。按照这个标准，要想遍历不到 node3，我们直接让它的前驱结点 node1 的 next 指针跳过它、指向 node3 的后继即可：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc6a1f482c0c4b24bf791171c43167d9~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=760&amp;h=598&amp;s=33301&amp;e=png&amp;b=ffffff" alt="" loading="lazy"/><br/>
如此一来，node3 就成为了一个完全不可抵达的结点了，它会被 JS 的垃圾回收器自动回收掉。这个过程用代码表述如下：</p>
<pre><code class="hljs language-js" lang="js">node1.<span class="hljs-property">next</span> = node3.<span class="hljs-property">next</span> 
</code></pre>
<p>这里给大家提个醒：在涉及链表删除操作的题目中，重点不是定位目标结点，而是<strong>定位目标结点的前驱结点</strong>。做题时，完全可以只使用一个指针（引用），这个指针用来定位目标结点的前驱结点。比如说咱们这个题里，其实只要能拿到 node1 就行了：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 利用 node1 可以定位到 node3</span>
<span class="hljs-keyword">const</span> target = node1.<span class="hljs-property">next</span>  
node1.<span class="hljs-property">next</span> = target.<span class="hljs-property">next</span>
</code></pre>
<p>因此大家做题的时候，千万别跑过了头，最后找到了目标结点、回头却发现忘了记录真正重要的前驱结点。（这点我们后面做题的时候会再给大家提点一下）</p>
<h4 data-id="heading-19">链表和数组的辨析</h4>
<p>在大多数的计算机语言中，数组都对应着一段连续的内存。如果我们想要在任意位置删除一个元素，那么该位置往后的所有元素，都需要往前挪一个位置；相应地，如果要在任意位置新增一个元素，那么该位置往后的所有元素也都要往后挪一个位置。<br/>
<strong>我们假设数组的长度是 n，那么因增加/删除操作导致需要移动的元素数量，就会随着数组长度 n 的增大而增大，呈一个线性关系。所以说数组增加/删除操作对应的复杂度就是 O(n)</strong>。</p>
<p>（关于时间复杂度，在第6小节我们会作专题讲解，大家莫慌）</p>
<p>但 JS 中不一定是。<br/>
JS比较特别。如果我们在一个数组中只定义了一种类型的元素，比如：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]
</code></pre>
<p>它是一个纯数字数组，那么对应的确实是连续内存。<br/>
但如果我们定义了不同类型的元素：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">'haha'</span>, <span class="hljs-number">1</span>, {<span class="hljs-attr">a</span>:<span class="hljs-number">1</span>}]
</code></pre>
<p>它对应的就是一段非连续的内存。此时，JS 数组不再具有数组的特征，其底层使用哈希映射分配内存空间，是由对象链表来实现的。</p>
<p>说起来有点绕口，但大家谨记“JS 数组未必是真正的数组”即可。</p>
<p>何谓“真正的数组”？在各大教材（包括百科词条）对数组的定义中，都有一个“存储在连续的内存空间里”这样的必要条件。因此在本文中，我们描述的“数组”就是符合这个定义的数组。面试时，若考到数组和链表的辨析，大家也沿着这个思路往下说，是没有问题的。如果能够说出 JS 数组和常规数组的不同，那就是锦上添花了。</p>
<p>相对于数组来说，链表有一个明显的优点，就是<strong>添加和删除元素都不需要挪动多余的元素</strong>。</p>
<h5 data-id="heading-20">高效的增删操作</h5>
<p>在链表中，添加和删除操作的复杂度是固定的——不管链表里面的结点个数 n 有多大，只要我们明确了要插入/删除的目标位置，那么我们需要做的都仅仅是改变目标结点及其前驱/后继结点的指针指向。
因此我们说链表增删操作的复杂度是常数级别的复杂度，用大 O 表示法表示为 O(1)。</p>
<h5 data-id="heading-21">麻烦的访问操作</h5>
<p>但是链表也有一个弊端：当我们试图读取某一个特定的链表结点时，必须遍历整个链表来查找它。比如说我要在一个长度为 n（n&gt;10） 的链表里，定位它的第 10 个结点，我需要这样做：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 记录目标结点的位置</span>
<span class="hljs-keyword">const</span> index = <span class="hljs-number">10</span>  
<span class="hljs-comment">// 设一个游标指向链表第一个结点，从第一个结点开始遍历</span>
<span class="hljs-keyword">let</span> node = head  
<span class="hljs-comment">// 反复遍历到第10个结点为止</span>
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;index&amp;&amp;node;i++) {
    node = node.<span class="hljs-property">next</span>
}
</code></pre>
<p>随着链表长度的增加，我们搜索的范围也会变大、遍历其中任意元素的时间成本自然随之提高。这个变化的趋势呈线性规律，用大 O 表示法表示为 O(n)。</p>
<p>但在数组中，我们直接访问索引、可以做到一步到位，这个操作的复杂度会被降级为常数级别(O(1))：</p>
<pre><code class="hljs language-js" lang="js">arr[<span class="hljs-number">9</span>]
</code></pre>
<h4 data-id="heading-22">小结</h4>
<p>结合上述分析，我们不难得出这样的结论：链表的插入/删除效率较高，而访问效率较低；数组的访问效率较高，而插入效率较低。这个特性需要大家牢记，可能会作为数据结构选型的依据来单独考察。</p>
<p>（阅读过程中有任何想法或疑问，或者单纯希望和笔者交个朋友啥的，欢迎大家添加我的微信xyalinode与我交流哈~）</p>
<h2 data-id="heading-23">快速上手——从0到1掌握算法面试需要的数据结构（三）</h2>
<p>本节我们一起来认识一下树与二叉树。<br/></p>
<p><a name="user-content-4175d9d6" title="" ref="nofollow noopener noreferrer" href="https://link.juejin.cn?target="/></p>
<h3 data-id="heading-24">理解树结构</h3>
<p><br/>在理解计算机世界的树结构之前，大家不妨回忆一下现实世界中的树有什么特点：一棵树往往只有一个树根，向上生长后，却可以伸展出无数的树枝、树枝上会长出树叶。由树根从泥土中吸收水、无机盐等营养物质，源源不断地输送到树枝与树叶的那一端。一棵树往往呈现这样的基本形态：<br/> <br/><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/6/1714e6b2706ab067~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp#?w=886&amp;h=628&amp;s=101731&amp;e=png" alt="" loading="lazy"/><br/>数据结构中的树，首先是对现实世界中树的一层简化：把树根抽象为“根结点”，树枝抽象为“边”，树枝的两个端点抽象为“结点”，树叶抽象为“叶子结点”。抽象后的树结构如下：<br/> <br/>
<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/15/1717d9e07221bb94~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp#?w=1162&amp;h=776&amp;s=90313&amp;e=png" alt="" loading="lazy"/><br/>把这棵抽象后的树颠倒一下，就得到了计算机中的树结构：<br/> <br/><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/6/1714e6b267f22329~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp#?w=621&amp;h=401&amp;s=24592&amp;e=png" alt="" loading="lazy"/><br/> <br/>结合这张图，我们来讲解树的关键特性和重点概念。希望大家可以牢记以下几点：<br/></p>
<ul>
<li>树的层次计算规则：根结点所在的那一层记为第一层，其子结点所在的就是第二层，以此类推。</li>
<li>结点和树的“高度”计算规则：叶子结点高度记为1，每向上一层高度就加1，逐层向上累加至目标结点时，所得到的的值就是目标结点的高度。树中结点的最大高度，称为“树的高度”。</li>
<li>“度”的概念：一个结点开叉出去多少个子树，被记为结点的“度”。比如我们上图中，根结点的“度”就是3。</li>
<li>“叶子结点”：叶子结点就是度为0的结点。在上图中，最后一层的结点的度全部为0，所以这一层的结点都是叶子结点。</li>
</ul>
<p><a name="user-content-aa301582" title="" ref="nofollow noopener noreferrer" href="https://link.juejin.cn?target="/></p>
<h3 data-id="heading-25">理解二叉树结构</h3>
<p><br/>二叉树是指满足以下要求的树：<br/></p>
<ul>
<li>它可以没有根结点，作为一棵空树存在</li>
<li>如果它不是空树，那么<strong>必须由根结点、左子树和右子树组成，且左右子树都是二叉树</strong>。如下图：<br/>
<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/6/1714e6b275ab6309~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp#?w=621&amp;h=401&amp;s=24948&amp;e=png" alt="" loading="lazy"/><br/>
注意，<strong>二叉树不能被简单定义为每个结点的度都是2的树</strong>。普通的树并不会区分左子树和右子树，但在二叉树中，左右子树的位置是严格约定、不能交换的。对应到图上来看，也就意味着 B 和 C、D 和 E、F 和 G 是不能互换的。</li>
</ul>
<p><a name="user-content-f302bdd8" title="" ref="nofollow noopener noreferrer" href="https://link.juejin.cn?target="/></p>
<h3 data-id="heading-26">二叉树的编码实现</h3>
<p><br/>在 JS 中，二叉树使用对象来定义。它的结构分为三块：<br/></p>
<ul>
<li>数据域</li>
<li>左侧子结点（左子树根结点）的引用</li>
<li>右侧子结点（右子树根结点）的引用</li>
</ul>
<p><br/>在定义二叉树构造函数时，我们需要把左侧子结点和右侧子结点都预置为空：<br/></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 二叉树结点的构造函数</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">TreeNode</span>(<span class="hljs-params">val</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">val</span> = val;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">left</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">right</span> = <span class="hljs-literal">null</span>;
}
</code></pre>
<p><br/>当你需要新建一个二叉树结点时，直接调用构造函数、传入数据域的值就行了：<br/></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> node  = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">1</span>)
</code></pre>
<p><br/>如此便能得到一个值为 1 的二叉树结点，从结构上来说，它长这样：<br/> <br/><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/6/1714e6b26ae0d174~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp#?w=500&amp;h=224&amp;s=10175&amp;e=png" alt="" loading="lazy"/><br/> <br/>以这个结点为根结点，我们可以通过给 left/right 赋值拓展其子树信息，延展出一棵二叉树。因此从更加细化的角度来看，一棵二叉树的形态实际是这样的：<br/><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/6/1714e6b268b61522~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp#?w=1150&amp;h=804&amp;s=56127&amp;e=png&amp;b=ffffff" alt="" loading="lazy"/><br/> <br/>现在各位已经掌握了做二叉树面试题所需要的一系列前置知识。接下来我会带大家一起通过写代码的方式，来搞定二叉树系列里最首当其冲、同时相当热门的考点——二叉树的遍历。</p>
<p>（阅读过程中有任何想法或疑问，或者单纯希望和笔者交个朋友啥的，欢迎大家添加我的微信xyalinode与我交流哈~）
<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="LightPink"><mtext>保姆式教学の</mtext><mstyle mathcolor="Pink"><mtext>温情提示：</mtext></mstyle></mstyle></mrow><annotation encoding="application/x-tex">\color{LightPink}{保姆式教学の}\color{Pink}{温情提示：}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"/><span class="mord" style="color:LightPink;"><span class="mord cjk_fallback" style="color:LightPink;">保姆式教学の</span></span><span class="mord" style="color:Pink;"><span class="mord cjk_fallback" style="color:Pink;">温情提示：</span></span></span></span></span></span></p>
<p>我们之前学过数组的遍历、链表的遍历，这些线性结构的遍历考起来没有什么难度，可以理解为基本技能，一般也不会单独出题。</p>
<p>但是二叉树可不一样了，这一“开叉”，它的遍历难度陡然上了一个台阶。在面试中，<strong>二叉树的各种姿势的遍历，是非常容易作为独立命题点来考察的</strong>，而且这个考察的频率极高极高。<br/>
因此对于有志于在算法面试上求稳的同学，本节涉及的编码内容，你千万不要沉溺在“我看懂了”、“我理解了”、“我知道你说的是啥意思了”这种虚无的成就感中——假的，都是假的，只有自己写出来的代码才是真的！</p>
<p>理解只是记忆的前提，只吹理解不记忆，不如回家去种地：）。</p>
<p>这里我对大家的要求就是“<strong>在理解的基础上记忆</strong>”。如果你真的暂时理解不了，<code>背也要先给你自己背下来</code>，然后带着对正确思路的记忆，重新去看解析部分里的图文（尤其是图）、反复去理解，这么整下来你不可能学不会。<br/>
面试时见到二叉树的遍历，你不能再去想太多——没有那么多时间给你现场推理，这么熟悉的题目你没必要现场推理，你要做的是默写！默写啊！老哥们！！（捶胸顿足）</p>
<h3 data-id="heading-27">二叉树的遍历——命题思路解读</h3>
<p>以一定的顺序规则，逐个访问二叉树的所有结点，这个过程就是二叉树的遍历。按照顺序规则的不同，遍历方式有以下四种：</p>
<ul>
<li>先序遍历</li>
<li>中序遍历</li>
<li>后序遍历</li>
<li>层次遍历</li>
</ul>
<p>按照实现方式的不同，遍历方式又可以分为以下两种：</p>
<ul>
<li>递归遍历（先、中、后序遍历）</li>
<li>迭代遍历（层次遍历）</li>
</ul>
<p>层次遍历的考察相对比较孤立，我们会把它放在后续的真题归纳解读环节来讲。这里我们重点要看的是先、中、后序遍历三兄弟——由于同时纠结了二叉树和“递归”两个大热命题点，又不属于“偏难怪”之流，遍历三兄弟一直是前端算法面试官们的心头好，考察热度经久不衰。</p>
<h3 data-id="heading-28">递归遍历初相见</h3>
<blockquote>
<p>编程语言中，函数Func(Type a,……)直接或间接调用函数本身，则该函数称为递归函数。</p>
</blockquote>
<p>简单来说，当我们看到一个函数反复调用它自己的时候，递归就发生了。“递归”就意味着“反复”，像咱们之前对二叉树的定义，就可以理解为是一个递归式的定义：</p>
<ul>
<li>它可以没有根结点，作为一棵空树存在</li>
<li>如果它不是空树，那么必须由根结点、左子树和右子树组成，<strong>且左右子树都是二叉树</strong>。</li>
</ul>
<p>这个定义有着这样的内涵：如果我们想要创建一个二叉树结点作为根结点，那么它左侧的子结点和右侧的子结点也都必须符合二叉树结点的定义，这意味着我们要反复地执行“创建一个由数据域、左右子树组成的结点”这个动作，直到数据被分配完为止。</p>
<p>结合这个定义来看，每一棵二叉树都应该由这三部分组成：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/14/17177af5d863f478~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp#?w=674&amp;h=456&amp;s=30434&amp;e=png" alt="" loading="lazy"/>
对树的遍历，就可以看做是对这三个部分的遍历。这里就引出一个问题：三个部分中，到底先遍历哪个、后遍历哪个呢？我们此处其实可以穷举一下，假如在保证“左子树一定先于右子树遍历”这个前提，那么遍历的可能顺序也不过三种：</p>
<ul>
<li>根结点 -&gt; 左子树 -&gt; 右子树</li>
<li>左子树 -&gt; 根结点 -&gt; 右子树</li>
<li>左子树 -&gt; 右子树 -&gt; 根结点</li>
</ul>
<p>上述三个遍历顺序，就分别对应了二叉树的先序遍历、中序遍历和后序遍历规则。</p>
<p>在这三种顺序中，根结点的遍历分别被安排在了首要位置、中间位置和最后位置。<br/>
所谓的“先序”、“中序”和“后序”，“先”、“中”、“后”其实就是指根结点的遍历时机。</p>
<h3 data-id="heading-29">遍历方法图解与编码实现</h3>
<h4 data-id="heading-30">先序遍历</h4>
<p>先序遍历的“旅行路线”如下图红色数字
所示：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/14/17177aac2aee4da6~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp#?w=772&amp;h=484&amp;s=33985&amp;e=png" alt="" loading="lazy"/></p>
<p>如果说有 N 多个子树，那么我们在每一棵子树内部，都要重复这个“旅行路线”，动画演示如下：
<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/6/1714ec42acc57e04~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp#?w=1553&amp;h=1010&amp;s=237869&amp;e=gif&amp;f=27" alt="" loading="lazy"/></p>
<p>这个“重复”，我们就用递归来实现。</p>
<p>注：上面这个二叉树的结构，大家可以试着用我们前面学过的知识编码实现一把。这里为了方便大家理解，我直接给出来了哈（记得自己回去也要试着手写一遍）：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> root = {
  <span class="hljs-attr">val</span>: <span class="hljs-string">"A"</span>,
  <span class="hljs-attr">left</span>: {
    <span class="hljs-attr">val</span>: <span class="hljs-string">"B"</span>,
    <span class="hljs-attr">left</span>: {
      <span class="hljs-attr">val</span>: <span class="hljs-string">"D"</span>
    },
    <span class="hljs-attr">right</span>: {
      <span class="hljs-attr">val</span>: <span class="hljs-string">"E"</span>
    }
  },
  <span class="hljs-attr">right</span>: {
    <span class="hljs-attr">val</span>: <span class="hljs-string">"C"</span>,
    <span class="hljs-attr">right</span>: {
      <span class="hljs-attr">val</span>: <span class="hljs-string">"F"</span>
    }
  }
};
</code></pre>
<h5 data-id="heading-31">递归函数的编写要点</h5>
<p>编写一个递归函数之前，大家首先要明确两样东西：</p>
<ul>
<li>递归式</li>
<li>递归边界</li>
</ul>
<p>递归式，它指的是你每一次重复的内容是什么。在这里，我们要做先序遍历，那么每一次重复的其实就是 <code>根结点 -&gt; 左子树 -&gt; 右子树</code> 这个旅行路线。</p>
<p>递归边界，它指的是<strong>你什么时候停下来</strong>。<br/>
在遍历的场景下，当我们发现遍历的目标树为空的时候，就意味着旅途已达终点、需要画上句号了。这个“画句号”的方式，在编码实现里对应着一个 return 语句——这就是二叉树遍历的递归边界。</p>
<h5 data-id="heading-32">第一个递归遍历函数</h5>
<p>上面咱们已经捋清楚思路，接下来话不多说，先序遍历的编码实现：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 所有遍历函数的入参都是树的根结点对象</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">preorder</span>(<span class="hljs-params">root</span>) {
    <span class="hljs-comment">// 递归边界，root 为空</span>
    <span class="hljs-keyword">if</span>(!root) {
        <span class="hljs-keyword">return</span> 
    }
     
    <span class="hljs-comment">// 输出当前遍历的结点值</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'当前遍历的结点值是：'</span>, root.<span class="hljs-property">val</span>)  
    <span class="hljs-comment">// 递归遍历左子树 </span>
    <span class="hljs-title function_">preorder</span>(root.<span class="hljs-property">left</span>)  
    <span class="hljs-comment">// 递归遍历右子树  </span>
    <span class="hljs-title function_">preorder</span>(root.<span class="hljs-property">right</span>)
}
</code></pre>
<p>不熟悉这种写法？不用怕，我们接下来一行一行把这段代码跑完，你就知道它在干啥了：</p>
<h5 data-id="heading-33">图解先序遍历的完整过程</h5>
<p>各位现在完全可以再回过头来看一下我们前面示例的这棵二叉树：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/6/1714ec60340dc2db~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp#?w=1098&amp;h=718&amp;s=54834&amp;e=png&amp;b=ffffff" alt="" loading="lazy"/></p>
<p>我们直接把它套进 <code>preorder</code> 函数里，一步一步来认清楚先序遍历的每一步做了什么：</p>
<ol>
<li>调用 <code>preorder(root)</code>，这里 root 就是 A，它非空，所以进入递归式，输出 A 值。接着优先遍历左子树，<code>preorder(root.left)  </code> 此时为 <code>preorder(B)  </code>：</li>
</ol>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/15/170dcc91bf634932~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp#?w=1066&amp;h=748&amp;s=56726&amp;e=png&amp;b=ffffff" alt="" loading="lazy"/>
2. 进入 <code>preorder(B)  </code>的逻辑： 入参为结点 B，非空，进入递归式，输出 B 值。接着优先遍历 B 的左子树，<code>preorder(root.left)  </code> 此时为 <code>preorder(D)  </code>：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/15/170dccaa644cac09~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp#?w=1124&amp;h=754&amp;s=57690&amp;e=png&amp;b=ffffff" alt="" loading="lazy"/><br/>
3. 进入 <code>preorder(D)  </code>的逻辑： 入参为结点 D，非空，进入递归式，输出 D 值。接着优先遍历 D 的左子树，<code>preorder(root.left)  </code> 此时为 <code>preorder(null)</code>：
<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/15/170dccbc123ee093~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp#?w=1206&amp;h=878&amp;s=68891&amp;e=png" alt="" loading="lazy"/></p>
<ol start="4">
<li>进入<code>preorder(null) </code>，发现抵达了递归边界，直接 return 掉。紧接着是 <code>preorder(D)  </code>的逻辑往下走，走到了 <code>preorder(root.right) </code>：</li>
</ol>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/15/170dccd42ab28ae3~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp#?w=1068&amp;h=768&amp;s=64559&amp;e=png&amp;b=ffffff" alt="" loading="lazy"/>
5. 再次进入<code>preorder(null) </code>，发现抵达了递归边界，直接 return 掉，回到<code>preorder(D)  </code>里。接着 <code>preorder(D)  </code>的逻辑往下走，发现  <code>preorder(D)  </code> 已经执行完了。于是返回，回到<code>preorder(B) </code>里，接着<code>preorder(B) </code>往下走，进入 <code>preorder(root.right) </code>，也就是 <code>preorder(E) </code>：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/15/170dcd0c633202e3~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp#?w=1112&amp;h=766&amp;s=57528&amp;e=png" alt="" loading="lazy"/><br/>
E 不为空，进入递归式，输出 E 值。接着优先遍历 E 的左子树，<code>preorder(root.left)  </code> 此时为 <code>preorder(null)</code>，触碰递归边界，直接返回 <code>preorder(E)</code>；继续<code>preorder(E)</code>执行下去，是<code>preorder(root.right)  </code>，这里 E 的 right 同样是 null，故直接返回。如此一来，<code>preorder(E)</code>就执行完了，回到<code>preorder(B)</code>里去；发现<code>preorder(B)</code>也执行完了，于是回到<code>preorder(A)</code>里去，执行<code>preorder(A)</code>中的 <code>preorder(root.right)</code>。</p>
<ol start="6">
<li>root 是A，root.right 就是 C 了，进入<code>preorder(C)</code>的逻辑：</li>
</ol>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/15/170dcd3c66015e73~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp#?w=1086&amp;h=706&amp;s=55802&amp;e=png" alt="" loading="lazy"/>
C 不为空，进入递归式，输出 C 值。接着优先遍历 C 的左子树，<code>preorder(root.left)  </code> 此时为 <code>preorder(null)</code>，触碰递归边界，直接返回。继续<code>preorder(C)</code>执行下去，是<code>preorder(root.right)  </code>，这里 C 的 right 是 F：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/15/170dcd5098638f06~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp#?w=1156&amp;h=734&amp;s=57242&amp;e=png" alt="" loading="lazy"/>
7. 进入<code>preorder(F)</code>的逻辑，F 不为空，进入递归式，输出 F 值。接着优先遍历 F 的左子树，<code>preorder(root.left)  </code> 此时为 <code>preorder(null)</code>，触碰递归边界，直接返回 <code>preorder(F)</code>；继续<code>preorder(F)</code>执行下去，是<code>preorder(root.right)  </code>，这里 F 的 right 同样是 null，故直接返回<code>preorder(F)</code>。此时<code>preorder(F)</code>已经执行完了，返回<code>preorder(C)</code>；发现<code>preorder(C)</code>也执行完了，就回到 <code>preorder(A)</code>；发现<code>preorder(A)</code>作为递归入口，它的逻辑也已经执行完了，于是我们的递归活动就正式画上了句号。到此为止，6个结点也已全部按照先序遍历顺序输出：</p>
<pre><code class="hljs language-js" lang="js">当前遍历的结点值是： A
当前遍历的结点值是： B
当前遍历的结点值是： D
当前遍历的结点值是： E
当前遍历的结点值是： C
当前遍历的结点值是： F
</code></pre>
<h4 data-id="heading-34">中序遍历</h4>
<p>理解了先序遍历的过程，中序遍历就不是什么难题。唯一的区别只是把遍历顺序调换了左子树 -&gt; 根结点 -&gt; 右子树：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/14/17177ac5f4302ee7~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp#?w=714&amp;h=460&amp;s=32754&amp;e=png&amp;b=ffffff" alt="" loading="lazy"/>
若有多个子树，那么我们在每一棵子树内部，都要重复这个“旅行路线”，这个过程用动画表示如下：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/6/1714f098b2bd1f9a~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp#?w=903&amp;h=558&amp;s=288516&amp;e=gif&amp;f=29" alt="" loading="lazy"/></p>
<p>递归边界照旧，唯一发生改变的是递归式里调用递归函数的顺序——左子树的访问会优先于根结点。我们参考先序遍历的分析思路，来写中序遍历的代码：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 所有遍历函数的入参都是树的根结点对象</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">inorder</span>(<span class="hljs-params">root</span>) {
    <span class="hljs-comment">// 递归边界，root 为空</span>
    <span class="hljs-keyword">if</span>(!root) {
        <span class="hljs-keyword">return</span> 
    }
     
    <span class="hljs-comment">// 递归遍历左子树 </span>
    <span class="hljs-title function_">inorder</span>(root.<span class="hljs-property">left</span>)  
    <span class="hljs-comment">// 输出当前遍历的结点值</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'当前遍历的结点值是：'</span>, root.<span class="hljs-property">val</span>)  
    <span class="hljs-comment">// 递归遍历右子树  </span>
    <span class="hljs-title function_">inorder</span>(root.<span class="hljs-property">right</span>)
}
</code></pre>
<p>按照中序遍历的逻辑，同样的一棵二叉树，结点内容的输出顺序如下：</p>
<pre><code class="hljs language-js" lang="js">当前遍历的结点值是： D
当前遍历的结点值是： B
当前遍历的结点值是： E
当前遍历的结点值是： A
当前遍历的结点值是： C
当前遍历的结点值是： F
</code></pre>
<h4 data-id="heading-35">后序遍历</h4>
<p>在后序遍历中，我们先访问左子树，再访问右子树，最后访问根结点：<br/>
<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/14/17177ad1ebeef412~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp#?w=770&amp;h=484&amp;s=33874&amp;e=png" alt="" loading="lazy"/>
若有多个子树，那么我们在每一棵子树内部，都要重复这个“旅行路线”：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/6/1714efce7db2cdff~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp#?w=911&amp;h=532&amp;s=226576&amp;e=gif&amp;f=29" alt="" loading="lazy"/>
在编码实现的时候，递归边界照旧，唯一发生改变的仍然是是递归式里调用递归函数的顺序：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">postorder</span>(<span class="hljs-params">root</span>) {
    <span class="hljs-comment">// 递归边界，root 为空</span>
    <span class="hljs-keyword">if</span>(!root) {
        <span class="hljs-keyword">return</span> 
    }
     
    <span class="hljs-comment">// 递归遍历左子树 </span>
    <span class="hljs-title function_">postorder</span>(root.<span class="hljs-property">left</span>)  
    <span class="hljs-comment">// 递归遍历右子树  </span>
    <span class="hljs-title function_">postorder</span>(root.<span class="hljs-property">right</span>)
    <span class="hljs-comment">// 输出当前遍历的结点值</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'当前遍历的结点值是：'</span>, root.<span class="hljs-property">val</span>)  
}
</code></pre>
<p>按照后序遍历的逻辑，同样的一棵二叉树，结点内容的输出顺序如下：</p>
<pre><code class="hljs language-js" lang="js">当前遍历的结点值是： D
当前遍历的结点值是： E
当前遍历的结点值是： B
当前遍历的结点值是： F
当前遍历的结点值是： C
当前遍历的结点值是： A
</code></pre>
<h3 data-id="heading-36">结语</h3>
<p>对于二叉树的先、中、后序遍历，各位只要掌握了其中一种的思路，就可以举一反三、顺势推导其它三种思路。不过，我个人的建议，仍然是以“默写”的标准来要求自己，面试时不要指望“推导”，而应该有<strong>条件反射</strong>。这样才可以尽量地提高你做题的效率，为后面真正的难题、综合性题目腾出时间。</p>
<p>关于二叉树遍历类题目的讨论，这里只是一个开始。二叉树的先、中、后包括层次遍历的玩法，还有很多很多，我们在后续的真题归纳解读专题、包括末尾的大规模刷题训练中，会带大家认识更多新奇好玩的东西。</p>
<p>（阅读过程中有任何想法或疑问，或者单纯希望和笔者交个朋友啥的，欢迎大家添加我的微信xyalinode与我交流哈~）
结束了数据结构基本功的学习，接下来在真正开始撸真题之前，大家还需要具备<strong>评价算法的能力</strong>。</p>
<p>平时我们定义一个人是否“懂行”，一个重要的依据就是看这个人对某一个事物是否具备正确的评价能力。<br/>
举个例子，同样是买手机，外行进到手机店，他关注的可能是手机有没有跑马灯、有没有皮套护体、有没有“八心八箭”——这些东西，任何一部手机随便包装一下就都有了，根本没法反映出这台手机的本质问题。但如果是一个相对懂手机的人，他可能就会去关注这台手机的芯片、内存、屏幕材质及分辨率等等，从而对手机的整体性能和质量作出一个合理的判断，这样他买到好手机的概率就更大。</p>
<p>回到做算法题上，也是一样的道理。在面试时，自己给出的算法到底过不过得去，这一点在面试官给出评语之前，自己就应该有所感知。做到这一点，你才会掌握改进算法的主动权。</p>
<p>本节我们要学习的就是评价算法的两个重要依据——时间复杂度和空间复杂度。</p>
<p>很多同学算法入门直接就跪在复杂度理解这一环。时间复杂度、空间复杂度，直接读概念确实太无聊，我们本节从代码入手，大家的理解会更直观一点。</p>
<h3 data-id="heading-37">时间复杂度</h3>
<p>大家先来看这样一个问题：下面这段代码，一共会执行多少次？</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">traverse</span>(<span class="hljs-params">arr</span>) {
    <span class="hljs-keyword">var</span> len = arr.<span class="hljs-property">length</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;len;i++) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[i])
    }
}
</code></pre>
<p>首先，最没有悬念的是函数里的第一行代码，它只会被执行1次：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">var</span> len = arr.<span class="hljs-property">length</span>
</code></pre>
<p>其次没有悬念的是循环体：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[i])
</code></pre>
<p><code>for</code>循环跑了 <code>n</code> 次，因此这条语句就会被执行 <code>n</code> 次。</p>
<p>循环体上面的几个部分我们拆开来看，首先是 <code>i</code> 的初始化语句：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>
</code></pre>
<p>初始化只有1次，因此它也只会被执行1次。</p>
<p>接着是 <code>i &lt; len</code> 这个判断。这里有个规律大家可以记下：在所有的 <code>for</code> 循环里，判断语句都会比递增语句多执行一次。在这里，判断语句执行的次数就是 <code>n+1</code>。<br/>
再往下就是递增语句 <code>i++</code> 了，它跟随整个循环体，毫无疑问会被执行 <code>n</code> 次。<br/>
假如把总的执行次数记为 T(n)，下面咱们就可以来做个简单的加法：</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-built_in">T</span>(n) = <span class="hljs-number">1</span> + n + <span class="hljs-number">1</span> + (n+<span class="hljs-number">1</span>) + n = <span class="hljs-number">3</span>n + <span class="hljs-number">3</span>
</code></pre>
<p>接下来我们看看规模为 <code>n*n</code> 的二维数组的遍历，一共需要执行多少次代码：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">traverse</span>(<span class="hljs-params">arr</span>) {
    <span class="hljs-keyword">var</span> outLen = arr.<span class="hljs-property">length</span>

    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;outLen;i++) {
        <span class="hljs-keyword">var</span> inLen = arr[i].<span class="hljs-property">length</span>

        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j=<span class="hljs-number">0</span>;j&lt;inLen;j++) { 
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[i][j])
        }
    }
}
</code></pre>
<p>首先仍然是没有悬念的第一行代码，它只会被执行一次：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">var</span> outLen = arr.<span class="hljs-property">length</span>
</code></pre>
<p>接下来我们来看最内层的循环体：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[i][j])
</code></pre>
<p>因为咱们是两层循环，所以这货会被执行 <code>n*n = n^2</code> 次。<br/>
其它语句的计算思路和咱们第一个🌰区别不大，这里我就不重复讲了，直接给出大家答案：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/6/1714f38044f931dd~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp#?w=932&amp;h=676&amp;s=97339&amp;e=png&amp;b=ffffff" alt="" loading="lazy"/></p>
<p>继续来做个求总执行次数 T(n) 的加法看看：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-title function_">T</span>(n) = <span class="hljs-number">1</span> + <span class="hljs-number">1</span> + (n+<span class="hljs-number">1</span>) + n + n + n + n*(n+<span class="hljs-number">1</span>) + n*n + n*n = <span class="hljs-number">3n</span>^<span class="hljs-number">2</span> + <span class="hljs-number">5n</span> + <span class="hljs-number">3</span>
</code></pre>
<p>代码的执行次数，可以反映出代码的执行时间。但是如果每次我们都逐行去计算 T(n)，事情会变得非常麻烦。算法的时间复杂度，它反映的不是算法的逻辑代码到底被执行了多少次，而是随着输入规模的增大，算法对应的执行总次数的一个<strong>变化趋势</strong>。要想反映趋势，那就简单多了，直接抓主要矛盾就行。我们可以尝试对 T(n) 做如下处理：</p>
<ul>
<li>若 T(n) 是常数，那么无脑简化为1</li>
<li>若 T(n) 是多项式，比如 3n^2 + 5n + 3，我们只保留次数最高那一项，并且将其常数系数无脑改为1。</li>
</ul>
<p>经过这么一波操作，T(n) 就被简化为了 O(n)：</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-built_in">T</span>(n) = <span class="hljs-number">10</span>  
<span class="hljs-built_in">O</span>(n) = <span class="hljs-number">1</span>
</code></pre>

<pre><code class="hljs language-scss" lang="scss"><span class="hljs-built_in">T</span>(n) = <span class="hljs-number">3</span>n^<span class="hljs-number">2</span> + <span class="hljs-number">5</span>n + <span class="hljs-number">3</span>
<span class="hljs-built_in">O</span>(n) = n^<span class="hljs-number">2</span>
</code></pre>
<p>到这里，我们思路仍然是 <code>计算T(n) -&gt; 推导O(n)</code>。这么讲是为了方便大家理解 O(n) 的简化过程，实际操作中，O(n) 基本可以目测，比如咱们上面的两个遍历函数：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">traverse1</span>(<span class="hljs-params">arr</span>) {
    <span class="hljs-keyword">var</span> len = arr.<span class="hljs-property">length</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;len;i++) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[i])
    }
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">traverse2</span>(<span class="hljs-params">arr</span>) {
    <span class="hljs-keyword">var</span> outLen = arr.<span class="hljs-property">length</span>

    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;outLen;i++) {
        <span class="hljs-keyword">var</span> inLen = arr[i].<span class="hljs-property">length</span>

        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j=<span class="hljs-number">0</span>;j&lt;inLen;j++) { 
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[i][j])
        }
    }
}
</code></pre>
<p>遍历 N 维数组，需要 N 层循环，我们只需要关心其最内层那个循环体被执行多少次就行了。</p>
<p>我们可以看出，规模为 <code>n</code> 的一维数组遍历时，最内层的循环会执行 <code>n</code> 次，其对应的时间复杂度是 <code>O(n)</code>；规模为 <code>n*n</code> 的二维数组遍历时，最内层的循环会执行 <code>n*n</code> 次，其对应的时间复杂度是 <code>O(n^2)</code>。</p>
<p>以此类推，规模为 <code>n*m</code> 的二维数组最内层循环会执行 <code>n*m</code> 次，其对应的时间复杂度就是 <code>O(n*m)</code>；规模为 <code>n*n*n</code> 的三维数组最内层循环会执行 <code>n^3</code> 次，因此其对应的时间复杂度就表示为 <code>O(n^3)</code>。</p>
<p>常见的时间复杂度表达，除了多项式以外，还有<code>logn</code>。我们一起来看另一个算法：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">arr</span>) {
    <span class="hljs-keyword">var</span> len = arr.<span class="hljs-property">length</span>  
    
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">1</span>;i&lt;len;i=i*<span class="hljs-number">2</span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[i])
    }
}
</code></pre>
<p>这个算法读取一个一维数组作为入参，然后对其中的元素进行跳跃式的输出。这个跳跃的规则，就是数组下标从1开始，每次会乘以二。</p>
<p>如何计算这个函数的时间复杂度呢？在有循环的地方，我们关心的永远是最内层的循环体。这个算法中，我们关心的就是 <code>console.log(arr[i])</code> 到底被执行了几次，换句话说，也就是要知道 <code>i&lt;n</code>（ len === n） 这个条件是在 <code>i</code> 递增多少次后才不成立的。</p>
<p>假设 <code>i</code> 在以 <code>i=i*2</code>的规则递增了 <code>x</code> 次之后，<code>i&lt;n</code> 开始不成立（反过来说也就是 <code>i&gt;=n</code> 成立）。那么此时我们要计算的其实就是这样一个数学方程：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-number">2</span>^x &gt;= n
</code></pre>
<p><code>x</code>解出来，就是要大于等于以 2 为底数的 <code>n</code> 的对数：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/6/1714f5c2b41495c3~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp#?w=366&amp;h=162&amp;s=9127&amp;e=png" alt="" loading="lazy"/></p>
<p>也就是说，只有当 <code>x</code> 小于 <code>log2n</code> 的时候，循环才是成立的、循环体才能执行。注意涉及到对数的时间复杂度，底数和系数都是要被简化掉的。那么这里的 O(n) 就可以表示为：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-title function_">O</span>(n) = logn
</code></pre>
<p>没错，这时的主要矛盾，就变成了一个对数表达式。</p>
<p>关于常见的时间复杂度，我们会在后面讲到具体知识点（尤其是排序算法）时，结合实例来给大家做分析。这里大家首先要认识一下常见时间复杂度有哪些，并且对这些常见时间复杂度之间的大小关系做个把握。<br/>
常见的时间复杂度按照从小到大的顺序排列，有以下几种：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/6/1714f67c52dc8d15~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp#?w=1148&amp;h=414&amp;s=35829&amp;e=png" alt="" loading="lazy"/></p>
<h3 data-id="heading-38">空间复杂度</h3>
<p>空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度。和时间复杂度相似，它是内存增长的<strong>趋势</strong>。<br/>
常见的空间复杂度有 <code>O(1)</code>、<code>O(n)</code> 和 <code>O(n^2)</code>。</p>
<p>理解空间复杂度，我们照样来看一个🌰：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">traverse</span>(<span class="hljs-params">arr</span>) {
    <span class="hljs-keyword">var</span> len = arr.<span class="hljs-property">length</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;len;i++) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[i])
    }
}
</code></pre>
<p>在 <code>traverse</code> 中，占用空间的有以下变量：</p>
<pre><code class="hljs language-js" lang="js">arr    
len   
i    
</code></pre>
<p>后面尽管咱们做了很多次循环，但是这些都是时间上的开销。循环体在执行时，并没有开辟新的内存空间。因此，整个 <code>traverse</code> 函数对内存的占用量是恒定的，它对应的空间复杂度就是 <code>O(1)</code>。</p>
<p>下面我们来看另一个🌰，此时我想要初始化一个规模为 n 的数组，并且要求这个数组的每个元素的值与其索引始终是相等关系，我可以这样写：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">init</span>(<span class="hljs-params">n</span>) {
    <span class="hljs-keyword">var</span> arr = []
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) {
        arr[i] = i
    }
    <span class="hljs-keyword">return</span> arr
}
</code></pre>
<p>在这个 <code>init</code> 中，涉及到的占用内存的变量有以下几个：</p>
<pre><code class="hljs language-js" lang="js">n 
arr
i
</code></pre>
<p>注意这里这个 <code>arr</code>，它并不是一个一成不变的数组。<code>arr</code>最终的大小是由输入的 <code>n</code> 的大小决定的，它会随着 <code>n</code> 的增大而增大、呈一个线性关系。因此这个算法的空间复杂度就是 <code>O(n)</code>。<br/>
由此我们不难想象，假如需要初始化的是一个规模为 <code>n*n</code> 的数组，那么它的空间复杂度就是 <code>O(n^2)</code> 啦。</p>
<h3 data-id="heading-39">小结</h3>
<p>结束了本节的学习，相信各位对时间复杂度和空间复杂度都有了一个感性的认知和初步的了解。在后续的学习中，我们会在必要的时候继续为大家提点真题中的时间复杂度和空间复杂度，带领大家在实战中强化对理论概念的认知。</p>
<p>（阅读过程中有任何想法或疑问，或者单纯希望和笔者交个朋友啥的，欢迎大家添加我的微信xyalinode与我交流哈~）
我们现在要开始做题啦！</p>
<p>万里长征第一步，仍然是数组。<br/>
单纯针对数组来考察的题目，总体来说，都不算太难——数组题目要想往难了出，基本都要结合排序、二分和动态规划这些相对复杂的算法思想才行。</p>
<p>咱们本节要解决的正是这一类“不算太难”的数组题目——并不是只有难题才拥有成为真题的入场券，一道好题不一定会难，它只要能够反映问题就可以了。<br/>
本节所涉及的题目在面试中普遍具有较高的出镜率、同时兼具一定的综合性，对培养大家的通用解题能力大有裨益 。<br/>
相信这节你会学得很开心，在轻松中收获自己的第一份算法解题锦囊。</p>
<h3 data-id="heading-40">Map 的妙用——两数求和问题</h3>
<blockquote>
<p>真题描述： 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。<br/>
你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p>
</blockquote>
<blockquote>
<p>示例:
给定 nums = [2, 7, 11, 15], target = 9<br/>
因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]</p>
</blockquote>
<h4 data-id="heading-41">思路分析：</h4>
<h5 data-id="heading-42">一个“淳朴”的解法</h5>
<p>这道题相信很多同学看一眼就很快能得出一个最基本的思路：两层循环来遍历同一个数组；第一层循环遍历的值记为 a，第二层循环时遍历的值记为 b；若 <code>a+b = 目标值</code>，那么 a 和 b 对应的数组下标就是我们想要的答案。</p>
<h5 data-id="heading-43">对“淳朴”解法的反思</h5>
<p>大家以后做算法题的时候，要有这样的一种本能：当发现自己的代码里有两层循环时，先反思一下，能不能用空间换时间，把它优化成一层循环。</p>
<p>因为两层循环很多情况下都意味着 O(n^2) 的复杂度，这个复杂度非常容易导致你的算法超时。即便没有超时，在明明有一层遍历解法的情况下，你写了两层遍历，面试官对你的印象分会大打折扣。</p>
<h5 data-id="heading-44">空间换时间，Map 来帮忙</h5>
<p>拿我们这道题来说，其实二层遍历是完全不必要的。<br/>
大家记住一个结论：几乎所有的求和问题，都可以转化为<strong>求差问题</strong>。
这道题就是一个典型的例子，通过把求和问题转化为求差问题，事情会变得更加简单。</p>
<p>我们可以在遍历数组的过程中，增加一个 Map 来记录已经遍历过的数字及其对应的索引值。然后每遍历到一个新数字的时候，都回到 Map 里去查询 targetNum 与该数的<strong>差值</strong>是否已经在前面的数字中出现过了。若出现过，那么答案已然显现，我们就不必再往下走了。</p>
<p>我们以 <code>nums = [2, 7, 11, 15]</code> 这个数组为例，来模拟一下这个思路：<br/>
第一次遍历到 2，此时 Map 为空：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/16/171815ed07055b8d~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp#?w=792&amp;h=472&amp;s=16503&amp;e=png" alt="" loading="lazy"/></p>
<p>以 2 为 key，索引 0 为 value 作存储，继续往下走；遇到了 7：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/16/171815d7f14b9ce0~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp#?w=736&amp;h=416&amp;s=16273&amp;e=png" alt="" loading="lazy"/></p>
<p>计算 targetNum 和 7 的差值为2，去 Map 中检索 2 这个 key，发现是之前出现过的值：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/16/171815cf9cc83f3f~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp#?w=696&amp;h=460&amp;s=20589&amp;e=png" alt="" loading="lazy"/>
那么 2 和 7 的索引组合就是这道题的答案啦。<br/>
键值对存储我们可以用 ES6 里的 Map 来做，如果图省事，直接用对象字面量来定义也没什么问题。</p>
<h5 data-id="heading-45">编码实现</h5>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/**
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number[]</span>} <span class="hljs-variable">nums</span>
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number</span>} <span class="hljs-variable">target</span>
 * <span class="hljs-doctag">@return</span> {<span class="hljs-type">number[]</span>}
 */</span>
<span class="hljs-keyword">const</span> twoSum = <span class="hljs-keyword">function</span>(<span class="hljs-params">nums, target</span>) {
    <span class="hljs-comment">// 这里我用对象来模拟 map 的能力</span>
    <span class="hljs-keyword">const</span> diffs = {}
    <span class="hljs-comment">// 缓存数组长度</span>
    <span class="hljs-keyword">const</span> len = nums.<span class="hljs-property">length</span>
    <span class="hljs-comment">// 遍历数组</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;len;i++) {
        <span class="hljs-comment">// 判断当前值对应的 target 差值是否存在（是否已遍历过）</span>
        <span class="hljs-keyword">if</span>(diffs[target-nums[i]]!==<span class="hljs-literal">undefined</span>) {
            <span class="hljs-comment">// 若有对应差值，那么答案get！</span>
            <span class="hljs-keyword">return</span> [diffs[target - nums[i]], i]
        }
        <span class="hljs-comment">// 若没有对应差值，则记录当前值</span>
        diffs[nums[i]]=i
    }
};
</code></pre>
<p>tips：这道题也可以用 ES6 中的 Map 来做，你试试呢？</p>
<h3 data-id="heading-46">强大的双指针法</h3>
<h4 data-id="heading-47">合并两个有序数组</h4>
<blockquote>
<p>真题描述：给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。<br/>
说明: 初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。
你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。</p>
</blockquote>
<blockquote>
<p>示例:
输入:<br/>
nums1 = [1,2,3,0,0,0], m = 3<br/>
nums2 = [2,5,6],       n = 3<br/>
输出: [1,2,2,3,5,6]</p>
</blockquote>
<h4 data-id="heading-48">思路分析</h4>
<h5 data-id="heading-49">标准解法</h5>
<p>这道题没有太多的弯弯绕绕，标准解法就是双指针法。首先我们定义两个指针，各指向两个数组生效部分的尾部：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/15/170ddde2f653cce0~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp#?w=954&amp;h=634&amp;s=22043&amp;e=png" alt="" loading="lazy"/></p>
<p><strong>每次只对指针所指的元素进行比较</strong>。取其中较大的元素，把它从 nums1 的末尾往前面填补：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/15/170de023737bd4d0~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp#?w=1020&amp;h=660&amp;s=26875&amp;e=png" alt="" loading="lazy"/>
这里有一点需要解释一下：<br/>
为什么是从后往前填补？因为是要把所有的值合并到 nums1 里，所以说我们这里可以把 nums1 看做是一个“容器”。但是这个容器，它不是空的，而是前面几个坑有内容的。如果我们从前往后填补，就没法直接往对应的坑位赋值了（会产生值覆盖）。<br/>
从后往前填补，我们填的都是没有内容的坑，这样会省掉很多麻烦。</p>
<p>由于 nums1 的有效部分和 nums2 并不一定是一样长的。我们还需要考虑其中一个提前到头的这种情况：</p>
<ol>
<li>
<p>如果提前遍历完的是 nums1 的有效部分，剩下的是 nums2。那么这时意味着 nums1 的头部空出来了，直接把 nums2 整个补到 nums1 前面去即可。</p>
</li>
<li>
<p>如果提前遍历完的是 nums2，剩下的是 nums1。由于容器本身就是  nums1，所以此时不必做任何额外的操作。</p>
</li>
</ol>
<h5 data-id="heading-50">编码实现：</h5>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/**
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number[]</span>} <span class="hljs-variable">nums1</span>
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number</span>} <span class="hljs-variable">m</span>
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number[]</span>} <span class="hljs-variable">nums2</span>
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number</span>} <span class="hljs-variable">n</span>
 * <span class="hljs-doctag">@return</span> {<span class="hljs-type">void</span>} Do not return anything, modify nums1 in-place instead.
 */</span>
<span class="hljs-keyword">const</span> merge = <span class="hljs-keyword">function</span>(<span class="hljs-params">nums1, m, nums2, n</span>) {
    <span class="hljs-comment">// 初始化两个指针的指向，初始化 nums1 尾部索引k</span>
    <span class="hljs-keyword">let</span> i = m - <span class="hljs-number">1</span>, j = n - <span class="hljs-number">1</span>, k = m + n - <span class="hljs-number">1</span>
    <span class="hljs-comment">// 当两个数组都没遍历完时，指针同步移动</span>
    <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>) {
        <span class="hljs-comment">// 取较大的值，从末尾往前填补</span>
        <span class="hljs-keyword">if</span>(nums1[i] &gt;= nums2[j]) {
            nums1[k] = nums1[i] 
            i-- 
            k--
        } <span class="hljs-keyword">else</span> {
            nums1[k] = nums2[j] 
            j-- 
            k--
        }
    }
    
    <span class="hljs-comment">// nums2 留下的情况，特殊处理一下 </span>
    <span class="hljs-keyword">while</span>(j&gt;=<span class="hljs-number">0</span>) {
        nums1[k] = nums2[j]  
        k-- 
        j--
    }
};
</code></pre>
<p>找点乐子：<br/>
上面我们给出的，是面试官最喜欢看到的一种解法，这种解法适用于各种语言。<br/>
但是就 JS 而言，我们还可以“另辟蹊径”，仔细想想，你有什么妙招？</p>
<h4 data-id="heading-51">三数求和问题</h4>
<p>双指针法能处理的问题多到你想不到。不信来瞅瞅两数求和它儿子——三数求和问题！<br/>
俗话说，青出于蓝而胜于蓝，三数求和虽然和两数求和只差了一个字，但是思路却完全不同。</p>
<blockquote>
<p>真题描述：给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。<br/>
注意：答案中不可以包含重复的三元组。</p>
</blockquote>
<blockquote>
<p>示例：
给定数组 nums = [-1, 0, 1, 2, -1, -4]，
满足要求的三元组集合为：
[
[-1, 0, 1],
[-1, -1, 2]
]</p>
</blockquote>
<h5 data-id="heading-52">思路分析</h5>
<p>三数之和延续两数之和的思路，我们可以<strong>把求和问题变成求差问题</strong>——固定其中一个数，在剩下的数中寻找是否有两个数和这个固定数相加是等于0的。</p>
<p>虽然乍一看似乎还是需要三层循环才能解决的样子，不过现在我们有了双指针法，定位效率将会被大大提升，从此告别过度循环~</p>
<p>（这里大家相信已经能察觉出来双指针法的使用场景了，一方面，它可以做到空间换时间；另一方面，它也可以帮我们降低问题的复杂度。）</p>
<p>双指针法用在涉及求和、比大小类的数组题目里时，大前提往往是：该数组必须有序。否则双指针根本无法帮助我们缩小定位的范围，压根没有意义。因此这道题的第一步是将数组排序：</p>
<pre><code class="hljs language-js" lang="js"> nums = nums.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a,b</span>)=&gt;</span>{
    <span class="hljs-keyword">return</span> a-b
})
</code></pre>
<p>然后，对数组进行遍历，每次遍历到哪个数字，就固定哪个数字。然后把左指针指向该数字后面一个坑里的数字，把右指针指向数组末尾，让左右指针从起点开始，向中间前进：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/15/170de65ecf8b277f~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp#?w=1046&amp;h=406&amp;s=25797&amp;e=png" alt="" loading="lazy"/>
每次指针移动一次位置，就计算一下两个指针指向数字之和加上固定的那个数之后，是否等于0。如果是，那么我们就得到了一个目标组合；否则，分两种情况来看：</p>
<ul>
<li>
<p>相加之和大于0，说明右侧的数偏大了，右指针左移</p>
</li>
<li>
<p>相加之和小于0，说明左侧的数偏小了，左指针右移</p>
</li>
</ul>
<p>tips：这个数组在题目中要求了“不重复的三元组”，因此我们还需要做一个重复元素的跳过处理。这一点在编码实现环节大家会注意到。</p>
<h5 data-id="heading-53">编码实现</h5>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/**
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number[]</span>} <span class="hljs-variable">nums</span>
 * <span class="hljs-doctag">@return</span> {<span class="hljs-type">number[][]</span>}
 */</span>
<span class="hljs-keyword">const</span> threeSum = <span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) {
    <span class="hljs-comment">// 用于存放结果数组</span>
    <span class="hljs-keyword">let</span> res = [] 
    <span class="hljs-comment">// 给 nums 排序</span>
    nums = nums.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a,b</span>)=&gt;</span>{
        <span class="hljs-keyword">return</span> a-b
    })
    <span class="hljs-comment">// 缓存数组长度</span>
    <span class="hljs-keyword">const</span> len = nums.<span class="hljs-property">length</span>
    <span class="hljs-comment">// 注意我们遍历到倒数第三个数就足够了，因为左右指针会遍历后面两个数</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;len-<span class="hljs-number">2</span>;i++) {
        <span class="hljs-comment">// 左指针 j</span>
        <span class="hljs-keyword">let</span> j=i+<span class="hljs-number">1</span> 
        <span class="hljs-comment">// 右指针k</span>
        <span class="hljs-keyword">let</span> k=len-<span class="hljs-number">1</span>   
        <span class="hljs-comment">// 如果遇到重复的数字，则跳过</span>
        <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>&amp;&amp;nums[i]===nums[i-<span class="hljs-number">1</span>]) {
            <span class="hljs-keyword">continue</span>
        }
        <span class="hljs-keyword">while</span>(j&lt;k) {
            <span class="hljs-comment">// 三数之和小于0，左指针前进</span>
            <span class="hljs-keyword">if</span>(nums[i]+nums[j]+nums[k]&lt;<span class="hljs-number">0</span>){
                j++
               <span class="hljs-comment">// 处理左指针元素重复的情况</span>
               <span class="hljs-keyword">while</span>(j&lt;k&amp;&amp;nums[j]===nums[j-<span class="hljs-number">1</span>]) {
                    j++
                }
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[i]+nums[j]+nums[k]&gt;<span class="hljs-number">0</span>){
                <span class="hljs-comment">// 三数之和大于0，右指针后退</span>
                k--
               
               <span class="hljs-comment">// 处理右指针元素重复的情况</span>
               <span class="hljs-keyword">while</span>(j&lt;k&amp;&amp;nums[k]===nums[k+<span class="hljs-number">1</span>]) {
                    k--
                }
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-comment">// 得到目标数字组合，推入结果数组</span>
                res.<span class="hljs-title function_">push</span>([nums[i],nums[j],nums[k]])
                
                <span class="hljs-comment">// 左右指针一起前进</span>
                j++  
                k--
               
                <span class="hljs-comment">// 若左指针元素重复，跳过</span>
                <span class="hljs-keyword">while</span>(j&lt;k&amp;&amp;nums[j]===nums[j-<span class="hljs-number">1</span>]) {
                    j++
                }  
               
               <span class="hljs-comment">// 若右指针元素重复，跳过</span>
               <span class="hljs-keyword">while</span>(j&lt;k&amp;&amp;nums[k]===nums[k+<span class="hljs-number">1</span>]) {
                    k--
                }
            }
        }
    }
    
    <span class="hljs-comment">// 返回结果数组</span>
    <span class="hljs-keyword">return</span> res
};
</code></pre>
<h4 data-id="heading-54">双指针法中的“对撞指针”法</h4>
<p>在上面这道题中，左右指针一起从两边往中间位置相互迫近，这样的特殊双指针形态，被称为“对撞指针”。</p>
<p>什么时候你需要联想到对撞指针？<br/>
这里我给大家两个关键字——“有序”和“数组”。<br/>
没错，见到这两个关键字，立刻把双指针法调度进你的大脑内存。普通双指针走不通，立刻想对撞指针！</p>
<p>即便数组题目中并没有直接给出“有序”这个关键条件，我们在发觉普通思路走不下去的时候，也应该及时地尝试手动对其进行排序试试看有没有新的切入点——没有条件，创造条件也要上。</p>
<p>对撞指针可以帮助我们缩小问题的范围，这一点在“三数求和”问题中体现得淋漓尽致：因为数组有序，所以我们可以用两个指针“画地为牢”圈出一个范围，这个范围以外的值不是太大就是太小、直接被排除在我们的判断逻辑之外，这样我们就可以把时间花在真正有意义的计算和对比上。如此一来，不仅节省了计算的时间，更降低了问题本身的复杂度，我们做题的速度也会大大加快。</p>
<p>（阅读过程中有任何想法或疑问，或者单纯希望和笔者交个朋友啥的，欢迎大家添加我的微信xyalinode与我交流哈~）
字符串在算法面试中，单独考察的机会并不多，同样倾向于和一些经典算法（后面会讲的）结合来体现区分度。步子不能跨太大，不然容易扯着x。本节我们照样是先解决只需要数据结构知识做基础就可以解决的字符串问题。</p>
<p>在讲题之前，我首先要给大家点拨两个字符串相关的“基本算法技能”。这两个技能偶尔也会单独命题，但整体来看在综合性题目中的考察频率较高，需要大家<strong>着重熟悉、反复练习和记忆</strong>，确保真正做题时万无一失。</p>
<h3 data-id="heading-55">基本算法技能</h3>
<h4 data-id="heading-56">反转字符串</h4>
<p>在 JS 中，反转字符串我们直接调相关 API 即可，相信不少同学都能手到擒来：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 定义被反转的字符串 </span>
<span class="hljs-keyword">const</span> str = <span class="hljs-string">'juejin'</span>  
<span class="hljs-comment">// 定义反转后的字符串</span>
<span class="hljs-keyword">const</span> res = str.<span class="hljs-title function_">split</span>(<span class="hljs-string">''</span>).<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">''</span>)

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res) <span class="hljs-comment">// nijeuj</span>
</code></pre>
<p>（这段代码需要你非常熟悉，一些公司一面为了试水，有时会单独考这个操作）。</p>
<h4 data-id="heading-57">判断一个字符串是否是回文字符串</h4>
<p>回文字符串，就是正着读和倒着读都一🐱一样的字符串，比如这样的：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-string">'yessey'</span>
</code></pre>
<p>结合这个定义，我们不难写出一个判定回文字符串的方法：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isPalindrome</span>(<span class="hljs-params">str</span>) {
    <span class="hljs-comment">// 先反转字符串</span>
    <span class="hljs-keyword">const</span> reversedStr = str.<span class="hljs-title function_">split</span>(<span class="hljs-string">''</span>).<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">''</span>)
    <span class="hljs-comment">// 判断反转前后是否相等</span>
    <span class="hljs-keyword">return</span> reversedStr === str
}
</code></pre>
<p>同时，回文字符串还有另一个特性：如果从中间位置“劈开”，那么两边的两个子串在内容上是完全对称的。因此我们也可以结合对称性来做判断：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isPalindrome</span>(<span class="hljs-params">str</span>) {
    <span class="hljs-comment">// 缓存字符串的长度</span>
    <span class="hljs-keyword">const</span> len = str.<span class="hljs-property">length</span>
    <span class="hljs-comment">// 遍历前半部分，判断和后半部分是否对称</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;len/<span class="hljs-number">2</span>;i++) {
        <span class="hljs-keyword">if</span>(str[i]!==str[len-i-<span class="hljs-number">1</span>]) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
}
</code></pre>
<p>（谨记这个对称的特性，非常容易用到）</p>
<h3 data-id="heading-58">高频真题解读</h3>
<h4 data-id="heading-59">回文字符串的衍生问题</h4>
<blockquote>
<p>真题描述：给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。</p>
</blockquote>
<blockquote>
<p>示例 1:
输入: "aba"<br/>
输出: True<br/>
示例 2:<br/>
输入: "abca"<br/>
输出: True<br/>
解释: 你可以删除c字符。<br/>
注意: 字符串只包含从 a-z 的小写字母。字符串的最大长度是50000。</p>
</blockquote>
<h5 data-id="heading-60">思路分析</h5>
<p>这道题很多同学第一眼看过去，可能本能地会想到这样一种解法：若字符串本身不回文，则直接遍历整个字符串。遍历到哪个字符就删除哪个字符、同时对删除该字符后的字符串进行是否回文的判断，看看存不存在删掉某个字符后、字符串能够满足回文的这种情况。</p>
<p>这个思路真的实现起来的话，在判题系统眼里其实也是没啥毛病的。但是在面试官看来，就有点问题了——这不是一个高效的解法。<br/>
如何判断自己解决回文类问题的解法是否“高效”？其中一个很重要的标准，就是看你对<strong>回文字符串的对称特性</strong>利用得是否彻底。</p>
<p>字符串题干中若有“回文”关键字，那么做题时脑海中一定要冒出两个关键字——<strong>对称性</strong> 和 <strong>双指针</strong>。这两个工具一起上，足以解决大部分的回文字符串衍生问题。</p>
<p>回到这道题上来，我们首先是初始化两个指针，一个指向字符串头部，另一个指向尾部：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/16/170e18e4bd1c843a~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp#?w=828&amp;h=472&amp;s=14207&amp;e=png" alt="" loading="lazy"/><br/>
如果两个指针所指的字符恰好相等，那么这两个字符就符合了回文字符串对对称性的要求，跳过它们往下走即可。如果两个指针所指的字符串不等，比如这样：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/16/170e191a29f7b7cb~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp#?w=790&amp;h=364&amp;s=11980&amp;e=png" alt="" loading="lazy"/><br/>
那么就意味着不对称发生了，意味着这是一个可以“删掉试试看”的操作点。我们可以分别对左指针字符和右指针字符尝试进行“跳过”，看看区间在 <code>[left+1, right]</code> 或 <code>[left, right-1]</code> 的字符串是否回文。如果是的话，那么就意味着如果删掉被“跳过”那个字符，整个字符串都将回文：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/16/170e1993aac908fe~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp#?w=900&amp;h=510&amp;s=18643&amp;e=png" alt="" loading="lazy"/>
比如说这里我们跳过了 b，[left+1, right] 的区间就是 [2, 2]，它对应 c 这个字符，单个字符一定回文。这样一来，删掉 b 之后，左右指针所指的内部区间是回文的，外部区间也是回文的，可以认为整个字符串就是一个回文字符串了。</p>
<h5 data-id="heading-61">编码实现</h5>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> validPalindrome = <span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) {
    <span class="hljs-comment">// 缓存字符串的长度</span>
    <span class="hljs-keyword">const</span> len = s.<span class="hljs-property">length</span>

    <span class="hljs-comment">// i、j分别为左右指针</span>
    <span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>, j=len-<span class="hljs-number">1</span>
    
    <span class="hljs-comment">// 当左右指针均满足对称时，一起向中间前进</span>
    <span class="hljs-keyword">while</span>(i&lt;j&amp;&amp;s[i]===s[j]) {
        i++ 
        j--
    }
    
    <span class="hljs-comment">// 尝试判断跳过左指针元素后字符串是否回文</span>
    <span class="hljs-keyword">if</span>(<span class="hljs-title function_">isPalindrome</span>(i+<span class="hljs-number">1</span>,j)) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
    }
    <span class="hljs-comment">// 尝试判断跳过右指针元素后字符串是否回文</span>
    <span class="hljs-keyword">if</span>(<span class="hljs-title function_">isPalindrome</span>(i,j-<span class="hljs-number">1</span>)) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
    }
    
    <span class="hljs-comment">// 工具方法，用于判断字符串是否回文</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">isPalindrome</span>(<span class="hljs-params">st, ed</span>) {
        <span class="hljs-keyword">while</span>(st&lt;ed) {
            <span class="hljs-keyword">if</span>(s[st] !== s[ed]) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
            }
            st++
            ed--
        } 
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
    }
    
    <span class="hljs-comment">// 默认返回 false</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> 
};
</code></pre>
<h4 data-id="heading-62">字符串匹配问题——正则表达式初相见</h4>
<p>接下来我们来看一道综合性比较强的字符串大题：</p>
<blockquote>
<p>真题描述： 设计一个支持以下两种操作的数据结构：<br/>
void addWord(word)<br/>
bool search(word)<br/>
search(word) 可以搜索文字或正则表达式字符串，字符串只包含字母 . 或 a-z 。<br/>
. 可以表示任何一个字母。</p>
</blockquote>
<blockquote>
<p>示例:
addWord("bad")<br/>
addWord("dad")<br/>
addWord("mad")<br/>
search("pad") -&gt; false<br/>
search("bad") -&gt; true<br/>
search(".ad") -&gt; true<br/>
search("b..") -&gt; true<br/>
说明:<br/>
你可以假设所有单词都是由小写字母 a-z 组成的。</p>
</blockquote>
<h5 data-id="heading-63">思路分析</h5>
<p>这道题要求字符串既可以被添加、又可以被搜索，这就意味着字符串在添加时一定要被存在某处。键值对存储，我们用 Map（或对象字面量来模拟 Map）。</p>
<p>注意，这里为了降低查找时的复杂度，我们可以考虑以字符串的长度为 key，相同长度的字符串存在一个数组中，这样可以提高我们后续定位的效率。</p>
<p>难点在于 search 这个 API，它既可以搜索文字，又可以搜索正则表达式。因此我们在搜索前需要额外判断一下，传入的到底是普通字符串，还是正则表达式。若是普通字符串，则直接去 Map 中查找是否有这个 key；若是正则表达式，则创建一个正则表达式对象，判断 Map 中相同长度的字符串里，是否存在一个能够与这个正则相匹配。</p>
<p>这里需要大家复习一下正则表达式的创建，以及用于测试某个字符串是否与之匹配的方法：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/**
 * 构造函数
 */</span>
<span class="hljs-keyword">const</span> <span class="hljs-title class_">WordDictionary</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"/>) {
  <span class="hljs-comment">// 初始化一个对象字面量，承担 Map 的角色</span>
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">words</span> = {}
};

<span class="hljs-comment">/**
  添加字符串的方法
 */</span>
<span class="hljs-title class_">WordDictionary</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">addWord</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">word</span>) {
  <span class="hljs-comment">// 若该字符串对应长度的数组已经存在，则只做添加</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">words</span>[word.<span class="hljs-property">length</span>]) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">words</span>[word.<span class="hljs-property">length</span>].<span class="hljs-title function_">push</span>(word)
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// 若该字符串对应长度的数组还不存在，则先创建</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">words</span>[word.<span class="hljs-property">length</span>] = [word]
  }

};

<span class="hljs-comment">/**
  搜索方法
 */</span>
<span class="hljs-title class_">WordDictionary</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">search</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">word</span>) {
  <span class="hljs-comment">// 若该字符串长度在 Map 中对应的数组根本不存在，则可判断该字符串不存在</span>
  <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">words</span>[word.<span class="hljs-property">length</span>]) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
  }
  <span class="hljs-comment">// 缓存目标字符串的长度</span>
  <span class="hljs-keyword">const</span> len = word.<span class="hljs-property">length</span>
  <span class="hljs-comment">// 如果字符串中不包含‘.’，那么一定是普通字符串</span>
  <span class="hljs-keyword">if</span> (!word.<span class="hljs-title function_">includes</span>(<span class="hljs-string">'.'</span>)) {
    <span class="hljs-comment">// 定位到和目标字符串长度一致的字符串数组，在其中查找是否存在该字符串</span>
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">words</span>[len].<span class="hljs-title function_">includes</span>(word)

  }

  <span class="hljs-comment">// 否则是正则表达式，要先创建正则表达式对象</span>
  <span class="hljs-keyword">const</span> reg = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(word)

  <span class="hljs-comment">// 只要数组中有一个匹配正则表达式的字符串，就返回true</span>
  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">words</span>[len].<span class="hljs-title function_">some</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> reg.<span class="hljs-title function_">test</span>(item)
  })
};
</code></pre>
<h4 data-id="heading-64">正则表达式更进一步——字符串与数字之间的转换问题</h4>
<blockquote>
<p>真题描述：请你来实现一个 atoi 函数，使其能将字符串转换成整数。<br/>
首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。<br/>
当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。<br/>
该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。<br/>
注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。<br/>
在任何情况下，若函数不能进行有效的转换时，请返回 0。</p>
</blockquote>
<blockquote>
<p>说明：
假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−2^31,  2^31 − 1]。如果数值超过这个范围，请返回  INT_MAX (2^31 − 1) 或 INT_MIN (−2^31) 。</p>
</blockquote>
<blockquote>
<p>示例 1:<br/>
输入: "42"<br/>
输出: 42</p>
</blockquote>
<blockquote>
<p>示例 2:<br/>
输入: "   -42"<br/>
输出: -42<br/>
解释: 第一个非空白字符为 '-', 它是一个负号。<br/>
我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。<br/>
</p>
</blockquote>
<blockquote>
<p>示例 3:
输入: "4193 with words"<br/>
输出: 4193<br/>
解释: 转换截止于数字 '3'    ，因为它的下一个字符不为数字。</p>
</blockquote>
<blockquote>
<p>示例 4:
输入: "words and 987"<br/>
输出: 0<br/>
解释: 第一个非空字符是 'w',    但它不是数字或正、负号。   因此无法执行有效的转换。</p>
</blockquote>
<blockquote>
<p>示例 5:<br/>
输入: "-91283472332"<br/>
输出: -2147483648<br/>
解释: 数字 "-91283472332" 超过 32 位有符号整数范围。因此返回 INT_MIN (−2^31) 。</p>
</blockquote>
<h5 data-id="heading-65">思路解读</h5>
<p>这道题乍一看比较唬人，毕竟题干这么长，首先会刷掉一波没耐心读完的火大老哥。我在实际的面试情景下，见过题没读完就掀桌走人的.....嗨，这里特别提醒大家，千万别冲动：小孩子才害怕读题，成年人都偷着乐——你得知道，一般来说，题干越长，题目越好做。</p>
<p>为啥这样说？大家想想，我们做题靠的是什么？自身的知识储备+题目提供的信息。题干长意味着什么？意味着它提供的信息相对丰富、细节描述相对到位，甚至很有可能，这个题的答案都藏在题里了！</p>
<p>就拿这道题开刀，我把其中比较关键的句子摘出来给大家翻译翻译：</p>
<ol>
<li>
<p>该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止——暗示你拿到字符串先去空格；</p>
</li>
<li>
<p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号——暗示你识别开头的“+”字符和“-”字符；</p>
</li>
<li>
<p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响——暗示你见到非整数字符就刹车；</p>
</li>
<li>
<p>说明： 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−2^31,  2^31 − 1]。如果数值超过这个范围，请返回  INT_MAX (2^31 − 1) 或 INT_MIN (−2^31) ——暗示......这都不是暗示了，这是明示啊！直接告诉你先把这俩边界值算出来，摆在那做卡口就完了。</p>
</li>
</ol>
<p><strong>Step1：计算卡口</strong><br/>
所以说不管这道题你用啥方法做，这个卡口计算肯定是没跑了。计算某个数的 n 次方，我们要用到 Math.pow 这个方法：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 计算最大值</span>
<span class="hljs-keyword">const</span> max = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(<span class="hljs-number">2</span>,<span class="hljs-number">31</span>) - <span class="hljs-number">1</span>
<span class="hljs-comment">// 计算最小值</span>
<span class="hljs-keyword">const</span> min = -max - <span class="hljs-number">1</span>
</code></pre>
<p><strong>Step2：解析字符串</strong><br/>
这道题其实有很多种解法，不同解法之间的区别就在于解析字符串的方式不同。<br/>
最直接的解法，是对字符串进行遍历，在遍历的过程中，按照上文我给大家提取的 1、2、3 这三点暗示，逐个地去对每个遍历对象进行判断，从而提取出符合题目要求的数字字符串，再把它转换成数字。</p>
<p>这样做理论上来说没毛病，也不会有超时问题。不过这里我更推荐大家用正则来做，原因很简单：我们看题目里有这么密集的字符串约束条件，作为前端，本能地是能想到用正则来做的；同时，正则表达式本身就是前端面试中的一个基础知识点，如果一道题能够同时考察字符串操作和正则表达式，其实也正中了面试官的下怀。</p>
<p>现在我们决定了用正则来做这道题，能不能做对它，就要看咱们正则表达式能不能写对了。<br/>
对于正则表达式，大多数的团队不会有特别强硬的要求，不会期望你一定要多么多么精通、能不靠 Google 徒手写多么复杂的表达式出来啥的——这样搞其实也没有意义。但是必要的基础你是要有的，这道题目涉及到的正则其实就在这个“必要”的范围里，我们一起来分析一下，首先是看回这三个约束条件，我重新给大家翻译一下：</p>
<ol>
<li>
<p>该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止——允许字符串头部出现空格，但是你在处理的时候要想办法把它摘出去，不要让它干扰你的计算</p>
</li>
<li>
<p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号——允许字符串的第一个有效字符为“+”或者“—”，不要摘它出去，它对你的计算是有意义的</p>
</li>
<li>
<p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响——匹配的时候，连续整数之外的部分都应该被摘除</p>
</li>
</ol>
<p>通过以上分析，我们可以形成以下思路：<br/>
首先，摘除空格：有两个方法，一个是直接使用 string 的 trim 方法，它是 JavaScript 的一个原生方法，可以去除字符串的头尾空格:</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">'      +10086'</span>
str.<span class="hljs-title function_">trim</span>() <span class="hljs-comment">// '+10086'</span>
</code></pre>
<p>另一个方法是在匹配的时候，匹配空格（正则匹配符为 \s*，意味着匹配 0 个或多个空格），但是<strong>不把它放在捕获组</strong>里——这种方法会更加通用，正则表达式匹配过程中，所有的“摘除”动作都可以通过将匹配到的结果排除在捕获组之外来实现，</p>
<p>什么是捕获组？其实就是正则表达式中被小括号括住的部分。在这道题里，我们需要从字符串中提取的其实只有“+/-”符号以及其后面的数字而已，同时这个字符串需要满足 <code>可能存在的空格+正负号+数字字符串+其它字符内容</code> 这样的格式才算合法，那我们就可以通过这样写正则表达式，实现“匹配”和“提取”的双重目的：</p>
<pre><code class="hljs language-js" lang="js">/\s*([-\+]?[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]*).*/
</code></pre>
<p>针对正则基础比较薄弱的同学，我来解释一下上面这个正则表达式：</p>
<ul>
<li>首先，<code>\s</code> 这个符号，意味着空字符，它可以用来匹配回车、空格、换行等空白区域，这里，它用来被匹配空格。<code>*</code>这个符号，跟在其它符号后面，意味着“前面这个符号可以出现0次或多次。<code>\s*</code>，这里的意思就是空格出现0次或多次，都可被匹配到。</li>
<li>接着 <code>()</code> 出现了。<code>()</code> 圈住的内容，就是我们要捕获起来额外存储的东西。</li>
<li><code>[]</code>中的匹配符之间是“或”的关系，也就是说只要能匹配上其中一个就行了。这里<code>[]</code>中包括了<code>-</code>和<code>\+</code>，<code>-</code>不必说匹配的是对应字符，这个<code>\+</code>之所以加了一个斜杠符，是因为<code>+</code>本身是一个有特殊作用的正则匹配符，这里我们要让它回归<code>+</code>字符的本义，所以要用一个<code>\</code>来完成转义。</li>
<li><code>[0-9]*</code>结合咱们前面铺陈的知识，这个就不难理解了，它的意思是 <code>0-9</code> 之间的整数，能匹配到0个或多个就算匹配成功。</li>
<li>最后的 <code>.</code>这个是任意字符的意思，<code>.*</code>用于字符串尾部匹配非数字的任意字符。我们看到<code>.*</code>是被排除捕获组之外的，所以说这个东西其实也不会被额外存储，它被“摘除”了。</li>
</ul>
<p><strong>Step3：获取捕获结果</strong><br/>
JS 的正则相关方法中， <code>test()</code>方法返回的是一个布尔值，单纯判断“是否匹配”。要想获取匹配的结果，我们需要调度<code>match()</code>方法：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> reg = <span class="hljs-regexp">/\s*([-\+]?[0-9]*).*/</span>
<span class="hljs-keyword">const</span> groups = str.<span class="hljs-title function_">match</span>(reg)
</code></pre>
<p><code>match()</code> 方法是一个在字符串中执行查找匹配的String方法，它返回一个数组，在未匹配到时会返回 null。<br/>
如果我们的正则表达式尾部有 g 标志，<code>match()</code>会返回与完整正则表达式匹配的所有结果，但不会返回捕获组。<br/>
这里我们没有使用g标志，<code>match()</code>就会返回第一个完整匹配（作为数组的第0项）及其相关的捕获组（作为数组的第1及第1+项）。<br/>
这里我们只定义了一个捕获组，因此可以从 <code>groups[1]</code> 里拿到我们捕获的结果。</p>
<p><strong>Step4：判断卡口</strong>
最后一步，就是把捕获的结果转换成数字，看看是否超出了题目要求的范围。这一步比较简单，无需多言。</p>
<h5 data-id="heading-66">编码实现</h5>
<p>分析了这么多，我们终于可以写代码啦：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 入参是一个字符串</span>
<span class="hljs-keyword">const</span> myAtoi = <span class="hljs-keyword">function</span>(<span class="hljs-params">str</span>) {
    <span class="hljs-comment">// 编写正则表达式</span>
    <span class="hljs-keyword">const</span> reg = <span class="hljs-regexp">/\s*([-\+]?[0-9]*).*/</span>
    <span class="hljs-comment">// 得到捕获组</span>
    <span class="hljs-keyword">const</span> groups = str.<span class="hljs-title function_">match</span>(reg)
    <span class="hljs-comment">// 计算最大值</span>
    <span class="hljs-keyword">const</span> max = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(<span class="hljs-number">2</span>,<span class="hljs-number">31</span>) - <span class="hljs-number">1</span>
    <span class="hljs-comment">// 计算最小值</span>
    <span class="hljs-keyword">const</span> min = -max - <span class="hljs-number">1</span>
    <span class="hljs-comment">// targetNum 用于存储转化出来的数字</span>
    <span class="hljs-keyword">let</span> targetNum = <span class="hljs-number">0</span>
    <span class="hljs-comment">// 如果匹配成功</span>
    <span class="hljs-keyword">if</span>(groups) {
        <span class="hljs-comment">// 尝试转化捕获到的结构</span>
        targetNum = +groups[<span class="hljs-number">1</span>]
        <span class="hljs-comment">// 注意，即便成功，也可能出现非数字的情况，比如单一个'+'</span>
        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isNaN</span>(targetNum)) {
            <span class="hljs-comment">// 不能进行有效的转换时，请返回 0</span>
            targetNum = <span class="hljs-number">0</span>
        }
    }
    <span class="hljs-comment">// 卡口判断</span>
    <span class="hljs-keyword">if</span>(targetNum &gt; max) {
        <span class="hljs-keyword">return</span> max
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( targetNum &lt; min) {
        <span class="hljs-keyword">return</span> min
    }
    <span class="hljs-comment">// 返回转换结果</span>
    <span class="hljs-keyword">return</span> targetNum
};

</code></pre>
<p>冲！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item>  </channel></rss>