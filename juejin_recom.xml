<?xml version="1.0" encoding="UTF-8"?><rss version="2.0">  <channel>      <title>掘金文章推荐</title>      <link>https://juejin.cn/recommended?sort=newest</link>      <description>一个帮助开发者成长的社区</description>      <generator>python juejin_recom.py @Pi20</generator>      <item>    <title><![CDATA[Crow 项目 CMake 结构分析：为什么不能从 examples 目录开始执行？]]></title>    <link>https://juejin.cn/post/7596890557546086446</link>    <guid>https://juejin.cn/post/7596890557546086446</guid>    <pubDate>2026-01-19T17:15:47.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7596890557546086446" data-draft-id="7596906923892572170" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Crow 项目 CMake 结构分析：为什么不能从 examples 目录开始执行？"/> <meta itemprop="keywords" content="程序员"/> <meta itemprop="datePublished" content="2026-01-19T17:15:47.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="自由生长2024"/> <meta itemprop="url" content="https://juejin.cn/user/1591748569862670"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Crow 项目 CMake 结构分析：为什么不能从 examples 目录开始执行？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1591748569862670/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    自由生长2024
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-19T17:15:47.000Z" title="Mon Jan 19 2026 17:15:47 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读20分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>摘要：Crow 项目采用现代 CMake 结构，根目录定义了 INTERFACE 库 Crow::Crow、依赖查找及全局变量，examples 作为子目录通过 add_subdirectory 引入，依赖父目录的上下文。若从 examples 目录直接执行 CMake，将因路径错误、目标未定义、变量缺失而失败。正确做法始终从根目录配置构建。</p>
<h2 data-id="heading-0">Crow 项目 CMake 结构分析：为什么不能从 examples 目录开始执行</h2>
<blockquote>
<p>cmake项目地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FCrowCpp%2FCrow%2F" target="_blank" title="https://github.com/CrowCpp/Crow/" ref="nofollow noopener noreferrer">CrowCpp/Crow: A Fast and Easy to use microframework for the web.</a></p>
</blockquote>
<h3 data-id="heading-1">概述</h3>
<p>Crow项目是一个类似于Flask但是Cpp版的微型Web框架。</p>
<p>本文档深入分析 Crow 项目的 CMake 构建系统结构，重点阐述根目录和 <code>examples</code> 目录的 CMakeLists.txt 核心内容，并解释为什么不能从 <code>examples</code> 目录直接执行 CMake 配置和构建。</p>
<h3 data-id="heading-2">一、根目录 CMakeLists.txt 核心内容</h3>
<p>根目录的 <code>CMakeLists.txt</code> 是整个 Crow 项目的构建系统核心，它定义了项目的基础设施、库目标、依赖管理和子项目集成。</p>
<h4 data-id="heading-3">1.1 项目基础配置</h4>
<pre><code class="hljs language-cmake" lang="cmake">cmake_minimum_required(VERSION 3.15.0 FATAL_ERROR)
project(Crow
    LANGUAGES CXX
    VERSION 1.1.1
)
</code></pre>
<ul>
<li><strong>作用</strong>：定义项目名称、语言和版本</li>
<li><strong>重要性</strong>：这是整个 CMake 构建树的根，所有子目录的 <code>CMAKE_SOURCE_DIR</code> 都指向这里</li>
</ul>
<h4 data-id="heading-4">1.2 CMake 模块路径配置</h4>
<pre><code class="hljs language-cmake" lang="cmake"># Make sure Findasio.cmake module is found
list(APPEND CMAKE_MODULE_PATH ${CMAKE_CURRENT_SOURCE_DIR}/cmake)
</code></pre>
<ul>
<li><strong>作用</strong>：将项目根目录下的 <code>cmake</code> 子目录添加到 CMake 模块搜索路径</li>
<li><strong>重要性</strong>：使得 CMake 能够找到项目自定义的模块，如 <code>Findasio.cmake</code> 和 <code>compiler_options.cmake</code></li>
<li><strong>依赖关系</strong>：<code>examples/CMakeLists.txt</code> 依赖这个配置来找到 <code>compiler_options.cmake</code></li>
</ul>
<h4 data-id="heading-5">1.3 核心库目标定义</h4>
<pre><code class="hljs language-cmake" lang="cmake">add_library(Crow INTERFACE)
add_library(Crow::Crow ALIAS Crow)

target_include_directories(Crow
    INTERFACE
        $&lt;BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include&gt;
        $&lt;INSTALL_INTERFACE:include&gt;
)
</code></pre>
<p><strong>关键点分析</strong>：</p>
<ol>
<li>
<p><strong>INTERFACE 库</strong>：Crow 是一个 header-only 库，使用 <code>INTERFACE</code> 库类型，这意味着它不编译任何源文件，只提供接口（头文件路径、编译选项、链接库等）</p>
</li>
<li>
<p><strong>别名目标详解</strong>：</p>
<pre><code class="hljs language-cmake" lang="cmake">add_library(Crow::Crow ALIAS Crow)
</code></pre>
<p><strong>语法解析</strong>：</p>
<ul>
<li><code>add_library()</code>：CMake 命令，用于创建库目标</li>
<li><code>Crow::Crow</code>：别名目标的名称（带命名空间前缀）</li>
<li><code>ALIAS</code>：关键字，表示这是一个别名，不是真正的库</li>
<li><code>Crow</code>：被别名的实际目标名称</li>
</ul>
<p><strong>核心作用</strong>：</p>
<ul>
<li><strong>加前缀防止弄混</strong>：为 <code>Crow</code> 目标添加 <code>Crow::</code> 命名空间前缀，避免与其他同名目标冲突</li>
<li><code>Crow</code> 和 <code>Crow::Crow</code> 指向同一个目标，可以互换使用</li>
<li>例如：<code>target_link_libraries(myapp Crow)</code> 和 <code>target_link_libraries(myapp Crow::Crow)</code> 效果相同</li>
</ul>
<p><strong>简单理解</strong>：</p>
<pre><code class="hljs language-cmake" lang="cmake">add_library(Crow INTERFACE)           # 创建实际目标 "Crow"
add_library(Crow::Crow ALIAS Crow)    # 给 "Crow" 加个前缀 "Crow::"，变成 "Crow::Crow"
</code></pre>
<p>就像给文件加个文件夹前缀一样：</p>
<ul>
<li><code>Crow</code> → <code>Crow::Crow</code>（加个命名空间前缀）</li>
<li>防止和其他叫 <code>Crow</code> 的目标弄混</li>
</ul>
<p><strong>为什么不能直接创建带命名空间的目标？</strong></p>
<p>你可能会问：为什么不直接写 <code>add_library(Crow::Crow INTERFACE)</code> 呢？</p>
<p><strong>原因 1：CMake 语法限制</strong></p>
<pre><code class="hljs language-cmake" lang="cmake"># ❌ 不推荐：虽然语法上可以，但 CMake 会把 "Crow::Crow" 当作普通目标名
add_library(Crow::Crow INTERFACE)  # 这不是真正的命名空间，只是名字里带 "::"

# ✅ 推荐：先创建实际目标，再用 ALIAS 创建命名空间版本
add_library(Crow INTERFACE)
add_library(Crow::Crow ALIAS Crow)
</code></pre>
<p><strong>原因 2：ALIAS 的限制</strong></p>
<p>ALIAS 目标有一些限制，不能做某些操作：</p>
<ul>
<li>❌ 不能修改属性（如 <code>target_include_directories()</code>）</li>
<li>❌ 不能安装（<code>install(TARGETS ...)</code>）</li>
<li>❌ 不能导出（<code>install(EXPORT ...)</code>）</li>
<li>✅ 只能作为原目标的另一个名字</li>
</ul>
<p>所以实际的库配置必须在<strong>裸名字目标</strong>上完成：</p>
<pre><code class="hljs language-cmake" lang="cmake">add_library(Crow INTERFACE)  # ✅ 实际目标，可以配置属性
target_include_directories(Crow INTERFACE ...)  # ✅ 在裸名字目标上设置
target_link_libraries(Crow INTERFACE ...)       # ✅ 在裸名字目标上设置

add_library(Crow::Crow ALIAS Crow)  # ✅ 只是别名，指向上面的 Crow
</code></pre>
<p><strong>重要澄清：CMake 不会"隐藏"原目标</strong></p>
<p><strong>如果配置操作只能在裸名字上完成，那不会暴露裸名字吗？</strong></p>
<p><strong>答案：是的，会暴露！但这是 CMake 的设计，不是 bug。</strong></p>
<p><strong>实际情况</strong>：</p>
<pre><code class="hljs language-cmake" lang="cmake"># 库提供者（Crow 项目）
add_library(Crow INTERFACE)                    # 裸名字目标
target_include_directories(Crow INTERFACE include/)  # 在裸名字上配置
add_library(Crow::Crow ALIAS Crow)            # 创建别名

# 库使用者（你的项目）
target_link_libraries(myapp Crow)        # ✅ 技术上可以，但不推荐
target_link_libraries(myapp Crow::Crow)  # ✅ 推荐使用命名空间版本
</code></pre>
<p><strong>关键点</strong>：</p>
<ol>
<li>
<p><strong>CMake 不会隐藏原目标</strong>：</p>
<ul>
<li><code>Crow</code> 和 <code>Crow::Crow</code> <strong>同时存在</strong>，都可以使用</li>
<li>这不是"隐藏"，而是"提供两个名字"</li>
<li>用户技术上可以使用 <code>Crow</code>，但最佳实践是使用 <code>Crow::Crow</code></li>
</ul>
</li>
<li>
<p><strong>这是命名约定，不是真正的封装</strong>：</p>
<ul>
<li>CMake 没有真正的"私有"目标概念</li>
<li>命名空间是<strong>约定</strong>，不是<strong>强制</strong></li>
<li>就像 C++ 的命名空间一样，技术上可以绕过，但遵循约定更好</li>
</ul>
</li>
<li>
<p><strong>为什么这样设计？</strong></p>
<p><strong>灵活性</strong>：</p>
<pre><code class="hljs language-cmake" lang="cmake"># 项目内部可以使用裸名字（更简洁）
target_link_libraries(internal_lib Crow)  # ✅ 内部使用，更简洁

# 对外接口使用命名空间（更规范）
target_link_libraries(public_api Crow::Crow)  # ✅ 公共接口，更清晰
</code></pre>
<p><strong>向后兼容</strong>：</p>
<ul>
<li>如果完全隐藏裸名字，会破坏旧代码</li>
<li>允许两种方式，保持兼容性</li>
</ul>
<p><strong>实际需求</strong>：</p>
<ul>
<li>有些操作（如配置属性）必须在裸名字上完成</li>
<li>如果完全隐藏，这些操作就无法进行</li>
</ul>
</li>
</ol>
<p><strong>实际例子</strong>：</p>
<p>查看 Crow 项目的实际代码：</p>
<pre><code class="hljs language-cmake" lang="cmake"># CMakeLists.txt
add_library(Crow INTERFACE)  # 裸名字，用于配置
target_include_directories(Crow INTERFACE ...)  # 在裸名字上配置
target_link_libraries(Crow INTERFACE asio::asio)  # 在裸名字上配置

add_library(Crow::Crow ALIAS Crow)  # 创建别名，提供命名空间版本
</code></pre>
<p>在 <code>examples/CMakeLists.txt</code> 中：</p>
<pre><code class="hljs language-cmake" lang="cmake"># 所有示例都使用命名空间版本（最佳实践）
target_link_libraries(basic_example PUBLIC Crow::Crow)  # ✅ 推荐

# 技术上也可以使用裸名字（但不推荐）
# target_link_libraries(basic_example PUBLIC Crow)  # ⚠️ 不推荐，但可以工作
</code></pre>
<p><strong>对比其他语言</strong>：</p>
<p>这就像 C++ 的命名空间：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-keyword">namespace</span> crow {
    <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> { ... };
}

<span class="hljs-comment">// 可以使用完整命名空间</span>
crow::App app;  <span class="hljs-comment">// ✅ 推荐</span>

<span class="hljs-comment">// 也可以使用 using 声明</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> crow;
App app;  <span class="hljs-comment">// ⚠️ 技术上可以，但不推荐（可能冲突）</span>
</code></pre>
<p>CMake 的命名空间也是类似的：</p>
<ul>
<li>推荐使用 <code>Crow::Crow</code>（清晰、不冲突）</li>
<li>技术上可以使用 <code>Crow</code>（简洁，但可能冲突）</li>
<li>这是约定，不是强制</li>
</ul>
<p><strong>最佳实践</strong>：</p>
<ol>
<li><strong>库提供者</strong>：
<ul>
<li>创建裸名字目标用于配置</li>
<li>创建命名空间别名用于对外接口</li>
<li>文档中推荐使用命名空间版本</li>
</ul>
</li>
<li><strong>库使用者</strong>：
<ul>
<li>总是使用命名空间版本（<code>Crow::Crow</code>）</li>
<li>避免使用裸名字（<code>Crow</code>），除非确定不会冲突</li>
</ul>
</li>
</ol>
<p><strong>总结</strong>：</p>
<ul>
<li>✅ <strong>会暴露</strong>：裸名字目标仍然可用</li>
<li>✅ <strong>这是设计</strong>：CMake 不隐藏原目标，提供灵活性</li>
<li>✅ <strong>这是约定</strong>：命名空间是约定，不是强制封装</li>
<li>✅ <strong>最佳实践</strong>：使用命名空间版本，避免冲突</li>
<li>⚠️ <strong>注意</strong>：技术上可以使用裸名字，但遵循约定更好</li>
</ul>
<p><strong>原因 3：设计清晰性</strong></p>
<p>分离实际目标和别名，职责更清晰：</p>
<ul>
<li><strong>裸名字目标</strong>（<code>Crow</code>）：负责实际的库配置和属性设置</li>
<li><strong>命名空间别名</strong>（<code>Crow::Crow</code>）：负责提供统一的公共接口</li>
</ul>
<p><strong>原因 4：兼容性和灵活性</strong></p>
<p>这种方式可以同时支持两种使用方式：</p>
<pre><code class="hljs language-cmake" lang="cmake"># 项目内部可以使用裸名字（更简洁）
target_link_libraries(internal_lib Crow)  # ✅ 内部使用

# 对外提供命名空间版本（更规范）
target_link_libraries(public_api Crow::Crow)  # ✅ 公共接口
</code></pre>
<p><strong>实际例子对比</strong>：</p>
<pre><code class="hljs language-cmake" lang="cmake"># ❌ 错误方式：直接创建带命名空间的目标
add_library(Crow::Crow INTERFACE)  # ⚠️ CMake 政策 CMP0037 不允许
target_include_directories(Crow::Crow INTERFACE include/)  # ⚠️ 可能报错或警告

# ✅ 正确方式：先创建裸名字，再创建别名
add_library(Crow INTERFACE)
target_include_directories(Crow INTERFACE include/)  # ✅ 在裸名字上配置
add_library(Crow::Crow ALIAS Crow)  # ✅ 创建命名空间别名
</code></pre>
<p><strong>具体问题说明</strong>：</p>
<ol>
<li><strong>CMake 政策限制（CMP0037）</strong>：
<ul>
<li>CMake 规定：带 <code>::</code> 的目标名<strong>只能用于 ALIAS 或 IMPORTED 目标</strong></li>
<li>普通目标（如 <code>add_library(Crow::Crow INTERFACE)</code>）不能直接使用带 <code>::</code> 的名字</li>
<li>如果强制使用，CMake 可能会：
<ul>
<li>报错：<code>Target names may not contain a "::" unless it is an ALIAS or IMPORTED target</code></li>
<li>或者发出警告，取决于 CMake 版本和政策设置</li>
</ul>
</li>
</ul>
</li>
<li><strong>行为不确定</strong>：
<ul>
<li>即使某些 CMake 版本允许，这种行为也是未定义的</li>
<li>可能导致后续配置、安装、导出时出现问题</li>
<li>不同 CMake 版本可能有不同的处理方式</li>
</ul>
</li>
<li><strong>不符合最佳实践</strong>：
<ul>
<li>现代 CMake 明确要求：普通目标用裸名字，命名空间用 ALIAS</li>
<li>违反这个约定可能导致工具链、IDE 支持不佳</li>
</ul>
</li>
</ol>
<p><strong>实际测试</strong>：</p>
<p>如果你尝试直接创建带命名空间的目标，CMake 通常会报错：</p>
<pre><code class="hljs language-vbnet" lang="vbnet">CMake <span class="hljs-keyword">Error</span>: Target names may <span class="hljs-built_in">not</span> contain a <span class="hljs-string">"::"</span> unless it <span class="hljs-built_in">is</span> an <span class="hljs-keyword">ALIAS</span> <span class="hljs-built_in">or</span> IMPORTED target.
</code></pre>
<p>或者在某些版本中会警告：</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-type">CMake</span> <span class="hljs-type">Warning</span>: <span class="hljs-type">Target</span> <span class="hljs-string">"Crow::Crow"</span> contains <span class="hljs-string">"::"</span> but <span class="hljs-keyword">is</span> not an <span class="hljs-type">ALIAS</span> or <span class="hljs-type">IMPORTED</span> target.
</code></pre>
<p><strong>总结</strong>：</p>
<ul>
<li>必须先用裸名字创建实际目标（因为要配置属性）</li>
<li>然后用 ALIAS 创建命名空间版本（提供统一接口）</li>
<li>这是 CMake 的设计，也是最佳实践</li>
</ul>
<p><strong>历史原因和设计考量</strong>：</p>
<p>为什么不直接创建带命名空间的目标呢？<strong>如果可以直接创建带命名空间的目标，确实会更清晰</strong>！</p>
<pre><code class="hljs language-cmake" lang="cmake"># 理想情况（如果 CMake 支持）
add_library(Crow::Crow INTERFACE)  # 直接创建，一步到位，多清晰！
target_include_directories(Crow::Crow INTERFACE include/)
</code></pre>
<p>但现实是，CMake 的历史设计导致了这种"两步走"的方式：</p>
<p><strong>为什么 CMake 这样设计？</strong></p>
<ol>
<li><strong>历史演进</strong>：
<ul>
<li>CMake 早期（2.x 时代）没有命名空间概念</li>
<li>目标名就是简单的字符串，没有 <code>::</code> 的特殊含义</li>
<li>后来引入命名空间时，为了向后兼容，采用了 ALIAS 机制</li>
</ul>
</li>
<li><strong>技术限制</strong>：
<ul>
<li>CMake 的目标系统建立在对目标名的字符串匹配上</li>
<li>带 <code>::</code> 的名字需要特殊处理，区分"普通目标"和"命名空间目标"</li>
<li>为了保持系统一致性，限制普通目标不能直接用 <code>::</code></li>
</ul>
</li>
<li><strong>向后兼容性</strong>：
<ul>
<li>如果允许普通目标用 <code>::</code>，会破坏大量现有项目</li>
<li>需要区分"旧式目标"和"新式命名空间目标"</li>
<li>ALIAS 机制提供了一个平滑的过渡方案</li>
</ul>
</li>
</ol>
<p><strong>如果重新设计会怎样？</strong></p>
<p>理论上，如果 CMake 重新设计，可能会这样：</p>
<pre><code class="hljs language-cmake" lang="cmake"># 理想设计（假设）
add_library(Crow::Crow INTERFACE)  # 直接创建命名空间目标
target_include_directories(Crow::Crow INTERFACE include/)
# 不需要 ALIAS，一步到位
</code></pre>
<p>这样确实更清晰，但现实是：</p>
<ul>
<li>CMake 已经是一个成熟、广泛使用的构建系统</li>
<li>改变这个设计会破坏大量现有项目</li>
<li>所以只能通过 ALIAS 机制来"模拟"命名空间</li>
</ul>
<p><strong>类比理解</strong>：</p>
<p>这就像编程语言中的一些"历史包袱"：</p>
<ul>
<li>C++ 的 <code>std::string</code> vs <code>string</code>（需要 <code>using namespace std</code>）</li>
<li>JavaScript 的 <code>var</code> vs <code>let/const</code>（历史原因导致多种声明方式）</li>
<li>Python 2 vs Python 3（为了改进，但需要兼容性考虑）</li>
</ul>
<p><strong>实际影响</strong>：</p>
<p>虽然设计上不够理想，但实际使用中：</p>
<ul>
<li>✅ 两行代码就能解决（<code>add_library</code> + <code>add_library ALIAS</code>）</li>
<li>✅ 已经成为标准做法，所有现代 CMake 项目都这样用</li>
<li>✅ 工具链、IDE 都很好地支持这种模式</li>
<li>⚠️ 确实有点"绕"，但这是历史原因，不是设计缺陷</li>
</ul>
<p><strong>结论</strong>：</p>
<p><strong>直接创建带命名空间的目标确实更清晰</strong>。但 CMake 的历史设计导致必须用"裸名字 + ALIAS"的方式。这是技术债务，但已经成为了事实标准。作为使用者，我们只能遵循这个约定，虽然它确实不够优雅。</p>
<p><strong>如果两个裸名字都叫 <code>Crow</code>，会冲突吗？</strong></p>
<p>这是一个很好的问题！答案是：<strong>会冲突，CMake 会报错</strong>。</p>
<p><strong>冲突场景 1：同一个项目中创建两个同名目标</strong></p>
<pre><code class="hljs language-cmake" lang="cmake"># CMakeLists.txt
add_library(Crow INTERFACE)  # 第一个 Crow
add_library(Crow STATIC crow.cpp)  # ❌ 第二个 Crow，会报错！
</code></pre>
<p><strong>错误信息</strong>：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-title class_">CMake</span> <span class="hljs-title class_">Error</span>: add_library cannot create target <span class="hljs-string">"Crow"</span> because another
target <span class="hljs-keyword">with</span> the same name already exists.
</code></pre>
<p><strong>冲突场景 2：通过 add_subdirectory 引入同名目标</strong></p>
<pre><code class="hljs language-cmake" lang="cmake"># 主项目 CMakeLists.txt
add_library(Crow INTERFACE)
add_subdirectory(third_party/Crow)  # 子项目也创建了 Crow
</code></pre>
<p>如果子项目的 <code>CMakeLists.txt</code> 也创建了 <code>Crow</code> 目标，会冲突：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-title class_">CMake</span> <span class="hljs-title class_">Error</span>: add_library cannot create target <span class="hljs-string">"Crow"</span> because another
target <span class="hljs-keyword">with</span> the same name already exists.
</code></pre>
<p><strong>这就是为什么需要命名空间！</strong></p>
<p>使用命名空间可以避免冲突：</p>
<pre><code class="hljs language-cmake" lang="cmake"># 主项目
add_library(MyCrow INTERFACE)
add_library(MyCrow::MyCrow ALIAS MyCrow)

# 子项目（第三方 Crow）
add_subdirectory(third_party/Crow)  # 内部创建 Crow 和别名Crow::Crow

# 现在可以同时使用，不会冲突！
target_link_libraries(myapp 
    MyCrow::MyCrow    # ✅ 主项目的 Crow
    Crow::Crow        # ✅ 第三方 Crow
)
</code></pre>
<p><strong>命名空间如何避免冲突？</strong></p>
<p>命名空间前缀让目标名变得唯一：</p>



































<table><thead><tr><th>场景</th><th>裸名字</th><th>命名空间版本</th><th>是否冲突？</th></tr></thead><tbody><tr><td>同一个项目</td><td><code>Crow</code></td><td><code>Crow::Crow</code></td><td>✅ 不冲突（不同名字）</td></tr><tr><td>不同项目</td><td><code>Crow</code></td><td><code>Crow::Crow</code></td><td>✅ 不冲突（不同名字）</td></tr><tr><td>两个 <code>Crow</code></td><td><code>Crow</code> vs <code>Crow</code></td><td>-</td><td>❌ 冲突！</td></tr><tr><td>两个命名空间</td><td><code>Crow::Crow</code> vs <code>MyCrow::Crow</code></td><td>-</td><td>✅ 不冲突（不同名字）</td></tr></tbody></table>
<p><strong>实际例子</strong>：</p>
<p>假设你的项目同时使用两个子目录的库，它们内部都创建了 <code>Crow</code> 目标：</p>
<pre><code class="hljs language-cmake" lang="cmake"># 你的项目
add_subdirectory(libA)  # libA 内部：add_library(Crow INTERFACE)
add_subdirectory(libB)  # libB 内部：add_library(Crow INTERFACE)
# ❌ 冲突！两个 Crow 目标
</code></pre>
<p>但如果它们都使用命名空间：</p>
<pre><code class="hljs language-cmake" lang="cmake"># 你的项目
add_subdirectory(libA)  # libA: add_library(Crow INTERFACE)
                        #      add_library(LibA::Crow ALIAS Crow)
add_subdirectory(libB)  # libB: add_library(Crow INTERFACE)
                        #      add_library(LibB::Crow ALIAS Crow)

# ✅ 不冲突！因为命名空间不同
target_link_libraries(myapp
    LibA::Crow   # ✅ 来自 libA
    LibB::Crow   # ✅ 来自 libB
)
</code></pre>
<p>虽然内部都有 <code>Crow</code> 裸名字目标，但：</p>
<ul>
<li>它们在不同的作用域中（不同的 <code>add_subdirectory</code>，在各自目录下是唯一的）</li>
<li>通过命名空间别名 <code>LibA::Crow</code> 和 <code>LibB::Crow</code> 区分</li>
<li>不会冲突</li>
</ul>
<p><strong>作用域规则</strong>：</p>
<p>CMake 的目标作用域：</p>
<ul>
<li>在同一个 <code>add_subdirectory</code> 作用域内，目标名必须唯一</li>
<li>不同作用域可以有同名目标（但通过命名空间区分更清晰）</li>
<li>全局作用域（根 CMakeLists.txt）的目标在整个项目可见</li>
</ul>
<p><strong>最佳实践</strong>：</p>
<ol>
<li>
<p><strong>总是使用命名空间别名</strong>：</p>
<pre><code class="hljs language-cmake" lang="cmake">add_library(Crow INTERFACE)
add_library(Crow::Crow ALIAS Crow)  # ✅ 提供命名空间版本
</code></pre>
</li>
<li>
<p><strong>对外接口使用命名空间</strong>：</p>
<pre><code class="hljs language-cmake" lang="cmake"># 对外提供命名空间版本
target_link_libraries(public_api Crow::Crow)  # ✅ 清晰、不冲突
</code></pre>
</li>
<li>
<p><strong>内部可以使用裸名字</strong>（如果确定不会冲突）：</p>
<pre><code class="hljs language-cmake" lang="cmake"># 内部使用（如果确定唯一）
target_link_libraries(internal_lib Crow)  # ⚠️ 谨慎使用
</code></pre>
</li>
</ol>
<p><strong>总结</strong>：</p>
<ul>
<li>✅ <strong>会冲突</strong>：同一个作用域内两个同名裸名字目标会冲突</li>
<li>✅ <strong>命名空间避免冲突</strong>：<code>Crow::Crow</code> 和 <code>MyCrow::Crow</code> 是不同的名字，不冲突</li>
<li>✅ <strong>最佳实践</strong>：总是创建命名空间别名，对外使用命名空间版本</li>
<li>⚠️ <strong>注意</strong>：即使在不同作用域，使用命名空间也更清晰、更安全</li>
</ul>
<p><strong>为什么使用 <code>Crow::Crow</code> 命名空间格式？</strong></p>
<p>a. <strong>CMake 最佳实践</strong>：</p>
<ul>
<li>现代 CMake 推荐使用 <code>命名空间::目标名</code> 的格式</li>
<li>这是 CMake 3.x 引入的命名空间约定</li>
<li>许多第三方库都遵循这个约定（如 <code>asio::asio</code>、<code>OpenSSL::SSL</code>、<code>Boost::system</code>）</li>
</ul>
<p>b. <strong>安装兼容性</strong>：</p>
<ul>
<li>当项目安装后，通过 <code>find_package(Crow)</code> 导入时，通常会提供命名空间目标</li>
<li>使用命名空间格式可以保持构建时和安装后的一致性</li>
<li>用户代码可以统一使用 <code>Crow::Crow</code>，无需区分是构建时还是安装后</li>
</ul>
<p>c. <strong>避免名称冲突</strong>：</p>
<ul>
<li>命名空间可以避免与其他项目的目标名称冲突</li>
<li>例如，如果有另一个库也叫 <code>Crow</code>，使用 <code>Crow::Crow</code> 可以明确区分</li>
</ul>
<p>d. <strong>代码可读性</strong>：</p>
<ul>
<li><code>Crow::Crow</code> 明确表示这是 Crow 项目的 Crow 库</li>
<li>提高代码的可读性和可维护性</li>
</ul>
<p><strong>实际使用示例和好处对比</strong>：</p>
<p><strong>示例 1：代码一致性 - 构建时 vs 安装后</strong></p>
<p>场景：你的项目可能有两种使用 Crow 的方式</p>
<pre><code class="hljs language-cmake" lang="cmake"># 方式 A：作为子项目（构建时）
add_subdirectory(third_party/Crow)
target_link_libraries(myapp Crow::Crow)  # ✅ 使用命名空间

# 方式 B：通过 find_package（安装后）
find_package(Crow REQUIRED)
target_link_libraries(myapp Crow::Crow)  # ✅ 同样的写法！
</code></pre>
<p><strong>好处</strong>：无论 Crow 是作为子项目还是已安装的包，代码写法完全一致！</p>
<p><strong>示例 2：避免名称冲突</strong></p>
<p>假设你的项目同时使用多个库：</p>
<pre><code class="hljs language-cmake" lang="cmake"># 项目同时使用 Crow 和另一个叫 "Crow" 的库（假设）
add_subdirectory(third_party/Crow)
add_subdirectory(third_party/OtherCrow)  # 另一个库也叫 Crow

# 使用命名空间 - 清晰明确
target_link_libraries(myapp 
    Crow::Crow        # ✅ 明确是 Crow 项目的库
    OtherCrow::Crow   # ✅ 明确是 OtherCrow 项目的库
)

# 不使用命名空间 - 容易混淆
target_link_libraries(myapp 
    Crow    # ❌ 这是哪个 Crow？
    Crow    # ❌ 冲突！CMake 会报错
)
</code></pre>
<p><strong>好处</strong>：命名空间避免了目标名称冲突，代码更清晰。</p>
<p><strong>示例 3：与第三方库风格一致</strong></p>
<p>在 Crow 项目中，可以看到所有依赖库都使用命名空间：</p>
<pre><code class="hljs language-cmake" lang="cmake"># CMakeLists.txt 中的实际代码
target_link_libraries(Crow INTERFACE
    asio::asio        # ✅ Asio 库使用命名空间
    ZLIB::ZLIB       # ✅ ZLib 库使用命名空间
    OpenSSL::SSL     # ✅ OpenSSL 库使用命名空间
)
</code></pre>
<p>在 examples 中，也使用命名空间：</p>
<pre><code class="hljs language-cmake" lang="cmake"># examples/CMakeLists.txt 中的实际代码
target_link_libraries(basic_example PUBLIC Crow::Crow)  # ✅ 风格一致
</code></pre>
<p><strong>好处</strong>：代码风格统一，符合现代 CMake 最佳实践，提高可读性。</p>
<p><strong>示例 4：IDE 和工具支持更好</strong></p>
<p>使用命名空间的目标，IDE 和 CMake 工具能更好地识别：</p>
<pre><code class="hljs language-cmake" lang="cmake"># 使用命名空间 - IDE 可以自动补全和检查
target_link_libraries(myapp Crow::Crow)  # ✅ IDE 知道这是 Crow 项目的目标

# 不使用命名空间 - 可能与其他目标混淆
target_link_libraries(myapp Crow)  # ❌ 可能是任何叫 Crow 的目标
</code></pre>
<p><strong>好处</strong>：更好的开发体验，工具支持更完善。</p>
<p><strong>示例 5：安装配置文件中的使用</strong></p>
<p>查看 <code>cmake/CrowConfig.cmake.in</code>（安装配置文件）：</p>
<pre><code class="hljs language-cmake" lang="cmake"># 第 28 行：获取 Crow::Crow 的属性
get_target_property(_CROW_ILL Crow::Crow INTERFACE_LINK_LIBRARIES)
get_target_property(_CROW_ICD Crow::Crow INTERFACE_COMPILE_DEFINITIONS)

# 第 52 行：设置 Crow::Crow 的属性
set_target_properties(Crow::Crow PROPERTIES
    INTERFACE_COMPILE_DEFINITIONS "${_CROW_ICD}"
)
</code></pre>
<p>安装后的包必须使用 <code>Crow::Crow</code>，如果构建时不使用命名空间，会导致：</p>
<ul>
<li>构建时用 <code>Crow</code></li>
<li>安装后用 <code>Crow::Crow</code></li>
<li>代码不一致，容易出错</li>
</ul>
<p><strong>好处</strong>：构建时和安装后使用相同的目标名称，避免混淆。</p>
<p><strong>总结对比表</strong>：</p>













































<table><thead><tr><th>特性</th><th>使用 <code>Crow::Crow</code></th><th>使用 <code>Crow</code></th></tr></thead><tbody><tr><td>构建时可用</td><td>✅ 是</td><td>✅ 是</td></tr><tr><td>安装后可用</td><td>✅ 是</td><td>❌ 可能不行</td></tr><tr><td>避免名称冲突</td><td>✅ 是</td><td>❌ 否</td></tr><tr><td>代码一致性</td><td>✅ 高</td><td>❌ 低</td></tr><tr><td>符合现代 CMake</td><td>✅ 是</td><td>❌ 否</td></tr><tr><td>IDE 支持</td><td>✅ 更好</td><td>⚠️ 一般</td></tr><tr><td>与第三方库风格一致</td><td>✅ 是</td><td>❌ 否</td></tr></tbody></table>
<p><strong>重要澄清：CMake 命名空间 vs C++ 命名空间</strong></p>
<p>⚠️ <strong>关键区别</strong>：CMake 的 <code>Crow::Crow</code> 命名空间和 C++ 代码中的命名空间是<strong>完全独立</strong>的，互不影响！</p>
<p><strong>CMake 命名空间</strong>（只在 CMakeLists.txt 中使用）：</p>
<pre><code class="hljs language-cmake" lang="cmake"># CMakeLists.txt 中
add_library(Crow::Crow ALIAS Crow)  # CMake 目标名称
target_link_libraries(myapp Crow::Crow)  # 链接时使用
</code></pre>
<p><strong>C++ 命名空间</strong>（在 C++ 源代码中使用）：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// C++ 源代码中</span>
<span class="hljs-keyword">namespace</span> crow {  <span class="hljs-comment">// C++ 命名空间（小写）</span>
    <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> { ... };
}

<span class="hljs-comment">// 使用时</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"crow.h"</span></span>
crow::App app;  <span class="hljs-comment">// ✅ 使用 C++ 命名空间 crow（小写）</span>
</code></pre>
<p><strong>实际例子</strong>：</p>
<p>查看 <code>examples/example.cpp</code> 的实际代码：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"crow.h"</span></span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    crow::App&lt;ExampleMiddleware&gt; app;  <span class="hljs-comment">// ✅ C++ 命名空间：crow（小写）</span>
    crow::json::wvalue x;              <span class="hljs-comment">// ✅ C++ 命名空间：crow（小写）</span>
    crow::request req;                 <span class="hljs-comment">// ✅ C++ 命名空间：crow（小写）</span>
    <span class="hljs-comment">// ...</span>
}
</code></pre>
<p>而在 <code>examples/CMakeLists.txt</code> 中：</p>
<pre><code class="hljs language-cmake" lang="cmake">target_link_libraries(basic_example PUBLIC Crow::Crow)  # ✅ CMake 命名空间：Crow::Crow（大写）
</code></pre>
<p><strong>两者对比</strong>：</p>



































<table><thead><tr><th>层面</th><th>CMake 命名空间</th><th>C++ 命名空间</th></tr></thead><tbody><tr><td>使用位置</td><td>CMakeLists.txt</td><td>.cpp/.h 源代码</td></tr><tr><td>格式</td><td><code>Crow::Crow</code>（大写）</td><td><code>crow</code>（小写）</td></tr><tr><td>作用</td><td>构建系统目标标识</td><td>代码组织、避免符号冲突</td></tr><tr><td>影响范围</td><td>构建配置</td><td>编译后的代码</td></tr><tr><td>是否相关</td><td>❌ 完全独立</td><td>❌ 完全独立</td></tr></tbody></table>
<p><strong>总结</strong>：</p>
<ul>
<li>CMake 的 <code>Crow::Crow</code> 只影响构建系统，不影响 C++ 代码</li>
<li>C++ 代码中的 <code>namespace crow</code> 是库的编程接口，与 CMake 无关</li>
<li>你可以使用 <code>Crow::Crow</code>（CMake）链接库，然后在代码中使用 <code>crow::App</code>（C++）</li>
<li>两者可以有不同的命名风格，互不干扰</li>
</ul>
</li>
<li>
<p><strong>包含目录详解</strong>：</p>
<pre><code class="hljs language-cmake" lang="cmake">target_include_directories(Crow
    INTERFACE
        $&lt;BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include&gt;
        $&lt;INSTALL_INTERFACE:include&gt;
)
</code></pre>
<p><strong><code>target_include_directories</code> 的本质</strong>：</p>
<p><strong>核心作用</strong>：告诉编译器在哪里找头文件</p>
<p><code>target_include_directories</code> 的本质是<strong>设置编译器的头文件搜索路径</strong>。它会在编译时转换为编译器的 <code>-I</code> 选项（GCC/Clang）或 <code>/I</code> 选项（MSVC）。</p>
<p><strong>从 CMake 到编译器的转换</strong>：</p>
<pre><code class="hljs language-cmake" lang="cmake"># CMakeLists.txt
target_include_directories(Crow INTERFACE include/)
</code></pre>
<p>转换为实际的编译器命令：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># GCC/Clang</span>
g++ -I/path/to/include -c example.cpp

<span class="hljs-comment"># MSVC</span>
cl.exe /I<span class="hljs-string">"C:\path\to\include"</span> example.cpp
</code></pre>
<p><strong>为什么需要这个？</strong></p>
<p>当你的代码写 <code>#include "crow.h"</code> 时：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"crow.h"</span>  <span class="hljs-comment">// 编译器需要知道在哪里找这个文件</span></span>
</code></pre>
<p>编译器会：</p>
<ol>
<li>先在当前目录查找 <code>crow.h</code></li>
<li>如果找不到，在 <code>target_include_directories</code> 指定的路径中查找</li>
<li>如果还找不到，报错：<code>fatal error: 'crow.h' file not found</code></li>
</ol>
<p><strong>INTERFACE、PUBLIC、PRIVATE 的区别</strong>：</p>
<pre><code class="hljs language-cmake" lang="cmake"># 假设有一个库 MyLib
add_library(MyLib STATIC mylib.cpp)

# PRIVATE：只给自己用，不传播给依赖者
target_include_directories(MyLib PRIVATE 
    ${CMAKE_CURRENT_SOURCE_DIR}/private_headers  # 只有 MyLib 自己用
)

# INTERFACE：只给依赖者用，自己不用
target_include_directories(MyLib INTERFACE 
    ${CMAKE_CURRENT_SOURCE_DIR}/public_headers   # 依赖 MyLib 的目标可以用
)

# PUBLIC：既给自己用，也传播给依赖者
target_include_directories(MyLib PUBLIC 
    ${CMAKE_CURRENT_SOURCE_DIR}/headers          # MyLib 和依赖者都能用
)
</code></pre>
<p><strong>实际例子</strong>：</p>
<pre><code class="hljs language-cmake" lang="cmake"># MyLib 的 CMakeLists.txt
add_library(MyLib STATIC mylib.cpp)
target_include_directories(MyLib PUBLIC include/)  # PUBLIC：传播给使用者

# 你的项目的 CMakeLists.txt
add_executable(myapp main.cpp)
target_link_libraries(myapp MyLib)  # 链接 MyLib

# 编译 myapp 时，编译器会自动添加 -I/path/to/MyLib/include
# 所以 main.cpp 可以写：
# #include "mylib.h"  // ✅ 能找到，因为 MyLib 的 PUBLIC include 路径被传播了
</code></pre>
<p><strong>Crow 项目中的实际使用</strong>：</p>
<pre><code class="hljs language-cmake" lang="cmake">target_include_directories(Crow
    INTERFACE
        $&lt;BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include&gt;
        $&lt;INSTALL_INTERFACE:include&gt;
)
</code></pre>
<p><strong>解析</strong>：</p>
<ol>
<li><strong><code>INTERFACE</code></strong>：
<ul>
<li>Crow 是 header-only 库，没有自己的源文件需要编译</li>
<li>所以用 <code>INTERFACE</code>，只给使用者提供头文件路径</li>
</ul>
</li>
<li><strong><code>$&lt;BUILD_INTERFACE:...&gt;</code></strong>：
<ul>
<li>这是 CMake 的生成器表达式（Generator Expression）</li>
<li>构建时（<code>cmake --build</code>）使用：<code>${CMAKE_CURRENT_SOURCE_DIR}/include</code></li>
<li>即：<code>C:\Users\notfr\projects\Crow\include</code></li>
</ul>
</li>
<li><strong><code>$&lt;INSTALL_INTERFACE:...&gt;</code></strong>：
<ul>
<li>安装后（<code>cmake --install</code>）使用：<code>include</code></li>
<li>即：安装目录下的 <code>include</code> 文件夹</li>
<li>例如：<code>C:\Program Files\Crow\include</code></li>
</ul>
</li>
</ol>
<p><strong>实际效果</strong>：</p>
<p>当你在代码中写：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"crow.h"</span>  <span class="hljs-comment">// 或 #include &lt;crow.h&gt;</span></span>
</code></pre>
<p>编译器会：</p>
<ol>
<li>构建时：在 <code>C:\Users\notfr\projects\Crow\include</code> 中查找</li>
<li>安装后：在 <code>C:\Program Files\Crow\include</code> 中查找</li>
</ol>
<p><strong>为什么需要两个不同的路径？</strong></p>
<ul>
<li><strong>构建时</strong>：头文件在源码目录 <code>include/</code></li>
<li><strong>安装后</strong>：头文件被安装到系统目录 <code>include/</code></li>
<li>使用生成器表达式可以自动切换，无需手动修改</li>
</ul>
<p><strong>本质总结</strong>：</p>
<p><code>target_include_directories</code> 的本质是：</p>
<ol>
<li><strong>设置编译器的头文件搜索路径</strong>（转换为 <code>-I</code> 或 <code>/I</code> 选项）</li>
<li><strong>控制路径的传播</strong>（PRIVATE/INTERFACE/PUBLIC）</li>
<li><strong>支持构建时和安装后的路径切换</strong>（生成器表达式）</li>
<li><strong>让 <code>#include</code> 能找到头文件</strong></li>
</ol>
<p>没有它，编译器就不知道在哪里找头文件，<code>#include "crow.h"</code> 会失败。</p>
</li>
</ol>
<p><strong>这是为什么不能从 examples 目录执行的关键原因之一</strong>：<code>Crow::Crow</code> 目标必须在根目录的 CMakeLists.txt 中定义，<code>examples</code> 目录中的代码依赖这个目标。</p>
<h4 data-id="heading-6">1.4 依赖库查找和链接</h4>
<h5 data-id="heading-7">Asio 库（默认）</h5>
<pre><code class="hljs language-cmake" lang="cmake">else()
    find_package(asio REQUIRED)
    target_link_libraries(Crow
        INTERFACE
            asio::asio
    )
    target_compile_definitions(Crow INTERFACE ASIO_NO_DEPRECATED)
endif()
</code></pre>
<ul>
<li><strong>作用</strong>：查找并链接 Asio 异步 I/O 库</li>
<li><strong>依赖</strong>：使用自定义的 <code>Findasio.cmake</code> 模块（位于 <code>cmake/Findasio.cmake</code>）</li>
</ul>
<h5 data-id="heading-8">可选依赖</h5>
<pre><code class="hljs language-cmake" lang="cmake">if(CROW_ENABLE_COMPRESSION)
    find_package(ZLIB REQUIRED)
    target_link_libraries(Crow INTERFACE ZLIB::ZLIB)
    target_compile_definitions(Crow INTERFACE CROW_ENABLE_COMPRESSION)
endif()

if(CROW_ENABLE_SSL)
    find_package(OpenSSL REQUIRED)
    target_link_libraries(Crow INTERFACE OpenSSL::SSL)
    target_compile_definitions(Crow INTERFACE CROW_ENABLE_SSL)
endif()
</code></pre>
<ul>
<li><strong>作用</strong>：根据编译选项条件性地添加压缩和 SSL 支持</li>
<li><strong>变量传递</strong>：这些选项会影响 <code>CROW_FEATURES</code> 变量，<code>examples</code> 目录会检查这个变量</li>
</ul>
<h4 data-id="heading-9">1.5 子项目集成</h4>
<pre><code class="hljs language-cmake" lang="cmake"># Examples
if(CROW_BUILD_EXAMPLES)
    add_subdirectory(examples)
endif()
</code></pre>
<p><strong><code>add_subdirectory</code> 的本质</strong>：</p>
<p><strong>核心作用</strong>：将子目录的 CMakeLists.txt 包含到当前构建中，创建一个子作用域</p>
<p><code>add_subdirectory</code> 的本质是<strong>在当前 CMake 配置过程中，切换到指定子目录，执行该目录下的 CMakeLists.txt，然后返回</strong>。它创建了一个新的作用域，但保持了与父目录的上下文联系。</p>
<p><strong>执行流程</strong>：</p>
<pre><code class="hljs language-cmake" lang="cmake"># 根目录 CMakeLists.txt
add_library(Crow INTERFACE)           # 1. 创建 Crow 目标
set(MY_VAR "value")                  # 2. 设置变量
add_subdirectory(examples)           # 3. 切换到 examples 目录
# 4. 执行 examples/CMakeLists.txt
# 5. 返回根目录，继续执行
</code></pre>
<p><strong>关键机制</strong>：</p>
<ol>
<li>
<p><strong>条件包含</strong>：只有当 <code>CROW_BUILD_EXAMPLES</code> 选项为 <code>ON</code> 时，才会包含 <code>examples</code> 子目录</p>
</li>
<li>
<p><strong>作用域和变量传递</strong>：</p>
<p><strong>父目录 → 子目录（可见）</strong>：</p>
<pre><code class="hljs language-cmake" lang="cmake"># 根目录 CMakeLists.txt
set(PARENT_VAR "parent_value")     # 父目录变量
add_library(Crow INTERFACE)        # 父目录目标
add_subdirectory(examples)         # 进入子目录

# examples/CMakeLists.txt
message(STATUS ${PARENT_VAR})      # ✅ 可以访问：输出 "parent_value"
target_link_libraries(myapp Crow)  # ✅ 可以访问：Crow 目标可见
</code></pre>
<p><strong>子目录 → 父目录（不可见）</strong>：</p>
<pre><code class="hljs language-cmake" lang="cmake"># examples/CMakeLists.txt
set(CHILD_VAR "child_value")       # 子目录变量
add_executable(myapp main.cpp)     # 子目录目标

# 根目录 CMakeLists.txt（add_subdirectory 之后）
message(STATUS ${CHILD_VAR})       # ❌ 不可访问：变量未定义
# 但目标 myapp 在整个项目中可见
</code></pre>
</li>
<li>
<p><strong>关键变量行为</strong>：</p>
<p><strong><code>CMAKE_SOURCE_DIR</code></strong>：始终指向<strong>根项目</strong>的源目录</p>
<pre><code class="hljs language-cmake" lang="cmake"># 根目录 CMakeLists.txt
message(STATUS "Root: ${CMAKE_SOURCE_DIR}")  # C:/Users/notfr/projects/Crow
add_subdirectory(examples)

# examples/CMakeLists.txt
message(STATUS "Examples: ${CMAKE_SOURCE_DIR}")  # C:/Users/notfr/projects/Crow（相同！）
</code></pre>
<p><strong><code>CMAKE_CURRENT_SOURCE_DIR</code></strong>：指向<strong>当前</strong>CMakeLists.txt 所在的目录</p>
<pre><code class="hljs language-cmake" lang="cmake"># 根目录 CMakeLists.txt
message(STATUS "Root current: ${CMAKE_CURRENT_SOURCE_DIR}")  # C:/Users/notfr/projects/Crow
add_subdirectory(examples)

# examples/CMakeLists.txt
message(STATUS "Examples current: ${CMAKE_CURRENT_SOURCE_DIR}")  # C:/Users/notfr/projects/Crow/examples
</code></pre>
<p><strong><code>CMAKE_BINARY_DIR</code></strong>：始终指向<strong>根项目</strong>的构建目录</p>
<pre><code class="hljs language-cmake" lang="cmake"># 根目录和子目录的 CMAKE_BINARY_DIR 都相同
# 例如：C:/Users/notfr/projects/Crow/build
</code></pre>
<p><strong><code>CMAKE_CURRENT_BINARY_DIR</code></strong>：指向<strong>当前</strong>CMakeLists.txt 对应的构建目录</p>
<pre><code class="hljs language-cmake" lang="cmake"># 根目录：C:/Users/notfr/projects/Crow/build
# examples：C:/Users/notfr/projects/Crow/build/examples
</code></pre>
</li>
<li>
<p><strong>目标可见性</strong>：</p>
<ul>
<li>父目录创建的目标在子目录中<strong>可见且可用</strong></li>
<li>子目录创建的目标在父目录中<strong>可见</strong>（但变量不可见）</li>
<li>所有目标在整个项目中可见（除非使用特殊作用域控制）</li>
</ul>
</li>
<li>
<p><strong>函数和宏的传递</strong>：</p>
<pre><code class="hljs language-cmake" lang="cmake"># 根目录 CMakeLists.txt
include(cmake/compiler_options.cmake)  # 定义函数 add_warnings_optimizations()
add_subdirectory(examples)

# examples/CMakeLists.txt
add_warnings_optimizations(myapp)  # ✅ 可以使用父目录定义的函数
</code></pre>
</li>
</ol>
<p><strong>实际例子</strong>：</p>
<p>在 Crow 项目中：</p>
<pre><code class="hljs language-cmake" lang="cmake"># 根目录 CMakeLists.txt
add_library(Crow INTERFACE)                    # 创建 Crow 目标
target_include_directories(Crow INTERFACE ...) # 配置 Crow
add_library(Crow::Crow ALIAS Crow)            # 创建别名

if(CROW_BUILD_EXAMPLES)
    add_subdirectory(examples)  # 进入 examples 目录
endif()

# examples/CMakeLists.txt
add_executable(basic_example example.cpp)
target_link_libraries(basic_example PUBLIC Crow::Crow)  # ✅ 可以使用父目录的 Crow::Crow
</code></pre>
<p><strong>执行时的变量值</strong>：</p>






























<table><thead><tr><th>变量</th><th>根目录 CMakeLists.txt</th><th>examples/CMakeLists.txt</th></tr></thead><tbody><tr><td><code>CMAKE_SOURCE_DIR</code></td><td><code>C:/.../Crow</code></td><td><code>C:/.../Crow</code>（相同）</td></tr><tr><td><code>CMAKE_CURRENT_SOURCE_DIR</code></td><td><code>C:/.../Crow</code></td><td><code>C:/.../Crow/examples</code></td></tr><tr><td><code>CMAKE_BINARY_DIR</code></td><td><code>C:/.../Crow/build</code></td><td><code>C:/.../Crow/build</code>（相同）</td></tr><tr><td><code>CMAKE_CURRENT_BINARY_DIR</code></td><td><code>C:/.../Crow/build</code></td><td><code>C:/.../Crow/build/examples</code></td></tr></tbody></table>
<p><strong>本质总结</strong>：</p>
<p><code>add_subdirectory</code> 的本质是：</p>
<ol>
<li><strong>切换目录</strong>：临时切换到子目录，执行其 CMakeLists.txt</li>
<li><strong>创建子作用域</strong>：子目录有自己的变量作用域，但可以访问父目录的变量和目标</li>
<li><strong>保持上下文</strong>：<code>CMAKE_SOURCE_DIR</code> 始终指向根项目，保持项目结构的一致性</li>
<li><strong>目标全局可见</strong>：所有目标在整个项目中可见，实现依赖管理</li>
<li><strong>函数传递</strong>：父目录定义的函数和宏在子目录中可用</li>
</ol>
<p><strong>为什么不能从子目录独立执行？</strong></p>
<p>因为 <code>add_subdirectory</code> 创建的是<strong>子作用域</strong>，不是独立项目：</p>
<ul>
<li>子目录依赖父目录的上下文（变量、目标、函数）</li>
<li><code>CMAKE_SOURCE_DIR</code> 必须指向根项目</li>
<li>如果从子目录执行，这些上下文都不存在，会失败</li>
</ul>
<p>这是 CMake 的设计哲学：<strong>子项目是父项目的组成部分，不是独立项目</strong>。</p>
<h4 data-id="heading-10">1.6 编译选项函数定义</h4>
<p>根目录通过包含 <code>compiler_options.cmake</code> 定义了 <code>add_warnings_optimizations()</code> 函数：</p>
<pre><code class="hljs language-cmake" lang="cmake"># 在 cmake/compiler_options.cmake 中定义
function(add_warnings_optimizations target_name)
    # 根据编译器类型（MSVC、Clang、GCC）设置不同的警告和优化选项
    ...
endfunction()
</code></pre>
<p>这个函数在 <code>examples/CMakeLists.txt</code> 中被广泛使用。</p>
<h3 data-id="heading-11">二、examples 目录 CMakeLists.txt 核心内容</h3>
<p><code>examples/CMakeLists.txt</code> 是一个<strong>子项目</strong>的构建文件，它依赖于父目录（根目录）提供的所有基础设施。</p>
<h4 data-id="heading-12">2.1 项目声明</h4>
<pre><code class="hljs language-cmake" lang="cmake">cmake_minimum_required(VERSION 3.15)
project(crow_examples)
</code></pre>
<ul>
<li><strong>注意</strong>：这里虽然声明了 <code>project(crow_examples)</code>，但这不是一个独立的项目</li>
<li><strong>上下文</strong>：当通过 <code>add_subdirectory(examples)</code> 调用时，这个 <code>project()</code> 命令会创建一个子项目，但 <code>CMAKE_SOURCE_DIR</code> 仍然指向根目录</li>
</ul>
<h4 data-id="heading-13">2.2 依赖父目录的 CMake 模块</h4>
<pre><code class="hljs language-cmake" lang="cmake">include(${CMAKE_SOURCE_DIR}/cmake/compiler_options.cmake)
</code></pre>
<p><strong>关键分析</strong>：</p>
<ol>
<li><strong><code>CMAKE_SOURCE_DIR</code> 的含义</strong>：
<ul>
<li>在根目录执行 CMake 时：<code>CMAKE_SOURCE_DIR</code> = 项目根目录</li>
<li>在 <code>examples</code> 目录执行 CMake 时：<code>CMAKE_SOURCE_DIR</code> = <code>examples</code> 目录</li>
</ul>
</li>
<li><strong>路径解析</strong>：
<ul>
<li>从根目录执行：<code>${CMAKE_SOURCE_DIR}/cmake/compiler_options.cmake</code> = <code>根目录/cmake/compiler_options.cmake</code> ✅</li>
<li>从 <code>examples</code> 目录执行：<code>${CMAKE_SOURCE_DIR}/cmake/compiler_options.cmake</code> = <code>examples/cmake/compiler_options.cmake</code> ❌（路径不存在）</li>
</ul>
</li>
</ol>
<p><strong>这是为什么不能从 examples 目录执行的第一个原因</strong>：路径解析错误。</p>
<h4 data-id="heading-14">2.3 依赖父目录定义的目标</h4>
<pre><code class="hljs language-cmake" lang="cmake">add_executable(basic_example example.cpp)
add_warnings_optimizations(basic_example)
target_link_libraries(basic_example PUBLIC Crow::Crow)
</code></pre>
<p><strong>依赖链分析</strong>：</p>
<ol>
<li>
<p><strong><code>add_warnings_optimizations()</code> 函数</strong>：</p>
<ul>
<li>定义在 <code>cmake/compiler_options.cmake</code> 中</li>
<li>该文件通过 <code>include(${CMAKE_SOURCE_DIR}/cmake/compiler_options.cmake)</code> 引入</li>
<li>如果路径解析失败，函数不存在，构建会失败</li>
</ul>
</li>
<li>
<p><strong><code>Crow::Crow</code> 目标</strong>：</p>
<ul>
<li>在根目录的 <code>CMakeLists.txt</code> 中定义（第 88-89 行）</li>
<li>是一个 INTERFACE 库，包含：
<ul>
<li>头文件路径：<code>${CMAKE_CURRENT_SOURCE_DIR}/include</code></li>
<li>链接库：<code>asio::asio</code>（或 Boost 库）</li>
<li>编译定义：<code>ASIO_NO_DEPRECATED</code> 等</li>
</ul>
</li>
<li>如果从 <code>examples</code> 目录执行，这个目标不存在，<code>target_link_libraries()</code> 会报错</li>
</ul>
</li>
</ol>
<p><strong>这是为什么不能从 examples 目录执行的第二个原因</strong>：目标不存在。</p>
<h4 data-id="heading-15">2.4 依赖父目录定义的变量</h4>
<pre><code class="hljs language-cmake" lang="cmake"># If compression is enabled, the example will be built
if("compression" IN_LIST CROW_FEATURES)
    add_executable(example_compression example_compression.cpp)
    ...
endif()

if(CROW_AMALGAMATE)
    add_executable(example_with_all example_with_all.cpp)
    add_dependencies(example_with_all crow_amalgamated)
    ...
endif()
</code></pre>
<p><strong>变量依赖</strong>：</p>
<ol>
<li><strong><code>CROW_FEATURES</code></strong>：在根目录的 CMakeLists.txt 中根据 <code>CROW_ENABLE_COMPRESSION</code> 和 <code>CROW_ENABLE_SSL</code> 选项设置</li>
<li><strong><code>CROW_AMALGAMATE</code></strong>：在根目录定义为 CMake 选项</li>
<li><strong><code>crow_amalgamated</code></strong>：在根目录定义的自定义目标（如果启用了 amalgamate）</li>
</ol>
<p><strong>这是为什么不能从 examples 目录执行的第三个原因</strong>：变量未定义。</p>
<h3 data-id="heading-16">三、依赖关系图</h3>
<pre><code class="hljs language-scss" lang="scss">┌─────────────────────────────────────────────────────────┐
│           根目录 CMakeLists<span class="hljs-selector-class">.txt</span>                         │
│  ┌──────────────────────────────────────────────────┐   │
│  │ <span class="hljs-number">1</span>. 配置 CMAKE_MODULE_PATH                        │   │
│  │    → 添加 cmake/ 目录                            │   │
│  └──────────────────────────────────────────────────┘   │
│  ┌──────────────────────────────────────────────────┐   │
│  │ <span class="hljs-number">2</span>. 定义 Crow::Crow INTERFACE 库                   │   │
│  │    → 包含目录: include/                          │   │
│  │    → 链接库: asio::asio                          │   │
│  └──────────────────────────────────────────────────┘   │
│  ┌──────────────────────────────────────────────────┐   │
│  │ <span class="hljs-number">3</span>. 查找依赖库                                     │   │
│  │    → <span class="hljs-built_in">find_package</span>(asio)                          │   │
│  │    → <span class="hljs-built_in">find_package</span>(ZLIB) [可选]                   │   │
│  │    → <span class="hljs-built_in">find_package</span>(OpenSSL) [可选]                │   │
│  └──────────────────────────────────────────────────┘   │
│  ┌──────────────────────────────────────────────────┐   │
│  │ <span class="hljs-number">4</span>. 设置变量                                       │   │
│  │    → CROW_FEATURES                               │   │
│  │    → CROW_AMALGAMATE                             │   │
│  └──────────────────────────────────────────────────┘   │
│  ┌──────────────────────────────────────────────────┐   │
│  │ <span class="hljs-number">5</span>. <span class="hljs-built_in">add_subdirectory</span>(examples)                    │   │
│  │    → 执行 examples/CMakeLists.txt                │   │
│  └──────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────┘
                        │
                        │ 依赖
                        ▼
┌─────────────────────────────────────────────────────────┐
│         examples/CMakeLists.txt                          │
│  ┌──────────────────────────────────────────────────┐   │
│  │ <span class="hljs-number">1</span>. <span class="hljs-built_in">include</span>(${CMAKE_SOURCE_DIR}/cmake/...)        │   │
│  │    ← 需要根目录的 cmake/ 目录                     │   │
│  └──────────────────────────────────────────────────┘   │
│  ┌──────────────────────────────────────────────────┐   │
│  │ <span class="hljs-number">2</span>. <span class="hljs-built_in">add_warnings_optimizations</span>()                  │   │
│  │    ← 需要 compiler_options<span class="hljs-selector-class">.cmake</span> 中的函数       │   │
│  └──────────────────────────────────────────────────┘   │
│  ┌──────────────────────────────────────────────────┐   │
│  │ <span class="hljs-number">3</span>. <span class="hljs-built_in">target_link_libraries</span>(..., Crow::Crow)       │   │
│  │    ← 需要根目录定义的 Crow::Crow 目标            │   │
│  └──────────────────────────────────────────────────┘   │
│  ┌──────────────────────────────────────────────────┐   │
│  │ <span class="hljs-number">4</span>. <span class="hljs-built_in">if</span>(<span class="hljs-string">"compression"</span> IN_LIST CROW_FEATURES)      │   │
│  │    ← 需要根目录设置的 CROW_FEATURES 变量         │   │
│  └──────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────┘
</code></pre>
<h3 data-id="heading-17">四、为什么不能从 examples 目录开始执行</h3>
<h4 data-id="heading-18">4.1 路径解析问题</h4>
<p><strong>场景</strong>：在 <code>examples</code> 目录执行 <code>cmake .</code></p>
<pre><code class="hljs language-cmake" lang="cmake">include(${CMAKE_SOURCE_DIR}/cmake/compiler_options.cmake)
</code></pre>
<ul>
<li><code>CMAKE_SOURCE_DIR</code> = <code>C:/Users/notfr/projects/Crow/examples</code></li>
<li>解析路径：<code>examples/cmake/compiler_options.cmake</code> ❌</li>
<li>实际路径：<code>根目录/cmake/compiler_options.cmake</code> ✅</li>
</ul>
<p><strong>错误信息</strong>：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-title class_">CMake</span> <span class="hljs-title class_">Error</span> at <span class="hljs-title class_">CMakeLists</span>.<span class="hljs-property">txt</span>:<span class="hljs-number">4</span> (include):
  include could not find load <span class="hljs-attr">file</span>:
    <span class="hljs-attr">C</span>:<span class="hljs-regexp">/Users/</span>notfr/projects/<span class="hljs-title class_">Crow</span>/examples/cmake/compiler_options.<span class="hljs-property">cmake</span>
</code></pre>
<h4 data-id="heading-19">4.2 目标不存在问题</h4>
<p><strong>场景</strong>：即使修复了路径问题，继续执行</p>
<pre><code class="hljs language-cmake" lang="cmake">target_link_libraries(basic_example PUBLIC Crow::Crow)
</code></pre>
<ul>
<li><code>Crow::Crow</code> 目标在根目录的 <code>CMakeLists.txt</code> 中定义</li>
<li>从 <code>examples</code> 目录执行时，根目录的 <code>CMakeLists.txt</code> 未执行</li>
<li>目标不存在</li>
</ul>
<p><strong>错误信息</strong>：</p>
<pre><code class="hljs language-kotlin" lang="kotlin">CMake Error at CMakeLists.txt:<span class="hljs-number">40</span> (target_link_libraries):
  Cannot specify link libraries <span class="hljs-keyword">for</span> target <span class="hljs-string">"basic_example"</span> which <span class="hljs-keyword">is</span> not
  built <span class="hljs-keyword">by</span> <span class="hljs-keyword">this</span> project.
  
  CMake Error: The following variables are used <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span> project, but they are
  <span class="hljs-keyword">set</span> to NOTFOUND.
  Please <span class="hljs-keyword">set</span> them or make sure they are <span class="hljs-keyword">set</span> correctly:
  Crow::Crow
</code></pre>
<h4 data-id="heading-20">4.3 依赖库未查找问题</h4>
<p>即使手动创建了 <code>Crow::Crow</code> 目标，还需要：</p>
<ol>
<li>
<p><strong>查找 asio 库</strong>：</p>
<pre><code class="hljs language-cmake" lang="cmake">find_package(asio REQUIRED)
</code></pre>
<ul>
<li>需要根目录的 <code>cmake/Findasio.cmake</code> 模块</li>
<li>需要正确的 <code>CMAKE_MODULE_PATH</code> 配置</li>
</ul>
</li>
<li>
<p><strong>设置包含目录</strong>：</p>
<pre><code class="hljs language-cmake" lang="cmake">target_include_directories(Crow INTERFACE ${CMAKE_CURRENT_SOURCE_DIR}/include)
</code></pre>
<ul>
<li><code>CMAKE_CURRENT_SOURCE_DIR</code> 在 <code>examples</code> 目录执行时指向 <code>examples</code></li>
<li>但头文件在根目录的 <code>include/</code> 中</li>
</ul>
</li>
</ol>
<h4 data-id="heading-21">4.4 变量未定义问题</h4>
<pre><code class="hljs language-cmake" lang="cmake">if("compression" IN_LIST CROW_FEATURES)
</code></pre>
<ul>
<li><code>CROW_FEATURES</code> 在根目录根据 <code>CROW_ENABLE_COMPRESSION</code> 和 <code>CROW_ENABLE_SSL</code> 设置</li>
<li>从 <code>examples</code> 目录执行时，这些变量未定义</li>
<li>条件判断可能产生意外行为</li>
</ul>
<h4 data-id="heading-22">4.5 CMake 子项目机制的本质</h4>
<p>CMake 的 <code>add_subdirectory()</code> 机制设计上就是<strong>单向依赖</strong>的：</p>
<ul>
<li><strong>父目录 → 子目录</strong>：父目录的所有定义（目标、变量、函数）对子目录可见 ✅</li>
<li><strong>子目录 → 父目录</strong>：子目录不能独立运行，必须通过父目录调用 ❌</li>
</ul>
<p>这是 CMake 的设计哲学：<strong>子项目是父项目的组成部分，不是独立项目</strong>。</p>
<h3 data-id="heading-23">五、正确的使用方式</h3>
<h4 data-id="heading-24">5.1 标准构建流程</h4>
<pre><code class="hljs language-powershell" lang="powershell"># 1. 在根目录配置 CMake
cd C:\Users\notfr\projects\Crow
cmake -B build -S .

# 2. 在根目录构建所有目标
cmake --build build

# 3. 在根目录只构建 basic_example
cmake --build build --target basic_example
</code></pre>
<h4 data-id="heading-25">5.2 为什么这样设计</h4>
<ol>
<li><strong>单一配置源</strong>：所有 CMake 选项（如 <code>CROW_ENABLE_SSL</code>）在根目录统一配置</li>
<li><strong>依赖管理集中</strong>：所有依赖库（asio、OpenSSL 等）在根目录统一查找和配置</li>
<li><strong>目标可见性</strong>：<code>Crow::Crow</code> 目标对所有子项目可见</li>
<li><strong>构建一致性</strong>：确保所有子项目使用相同的编译选项和配置</li>
</ol>
<h4 data-id="heading-26">5.3 如果确实需要独立构建</h4>
<p>如果确实需要从 <code>examples</code> 目录独立构建（不推荐），需要：</p>
<ol>
<li>
<p><strong>修改路径引用</strong>：</p>
<pre><code class="hljs language-cmake" lang="cmake"># 使用相对路径或绝对路径
include(../cmake/compiler_options.cmake)
</code></pre>
</li>
<li>
<p><strong>手动定义 Crow::Crow 目标</strong>：</p>
<pre><code class="hljs language-cmake" lang="cmake"># 查找依赖
list(APPEND CMAKE_MODULE_PATH ${CMAKE_CURRENT_SOURCE_DIR}/../cmake)
find_package(asio REQUIRED)

# 创建目标
add_library(Crow INTERFACE)
add_library(Crow::Crow ALIAS Crow)
target_include_directories(Crow INTERFACE ${CMAKE_CURRENT_SOURCE_DIR}/../include)
target_link_libraries(Crow INTERFACE asio::asio)
</code></pre>
</li>
<li>
<p><strong>设置必要的变量</strong>：</p>
<pre><code class="hljs language-cmake" lang="cmake">if(NOT DEFINED CROW_FEATURES)
    set(CROW_FEATURES "")
endif()
</code></pre>
</li>
</ol>
<p>但这样做会：</p>
<ul>
<li>破坏项目的统一性</li>
<li>增加维护成本</li>
<li>可能导致配置不一致</li>
</ul>
<h3 data-id="heading-27">六、总结</h3>
<h4 data-id="heading-28">6.1 核心要点</h4>
<ol>
<li>
<p><strong>根目录 CMakeLists.txt</strong> 是构建系统的核心：</p>
<ul>
<li>定义项目基础设施</li>
<li>查找和配置所有依赖库</li>
<li>创建 <code>Crow::Crow</code> INTERFACE 库目标</li>
<li>设置全局变量和选项</li>
</ul>
</li>
<li>
<p><strong>examples/CMakeLists.txt</strong> 是子项目：</p>
<ul>
<li>依赖父目录的所有定义</li>
<li>使用父目录的目标、变量和函数</li>
<li>不能独立运行</li>
</ul>
</li>
<li>
<p><strong>不能从 examples 目录执行的原因</strong>：</p>
<ul>
<li>路径解析错误（<code>CMAKE_SOURCE_DIR</code> 指向错误）</li>
<li>目标不存在（<code>Crow::Crow</code> 未定义）</li>
<li>依赖库未查找（asio 等）</li>
<li>变量未定义（<code>CROW_FEATURES</code> 等）</li>
<li>违反 CMake 子项目设计原则</li>
</ul>
</li>
</ol>
<h4 data-id="heading-29">6.2 最佳实践</h4>
<ul>
<li>✅ <strong>始终从根目录执行 CMake</strong></li>
<li>✅ <strong>使用 <code>--target</code> 选项只构建需要的目标</strong></li>
<li>✅ <strong>保持子项目对父目录的依赖关系</strong></li>
<li>❌ <strong>不要尝试从子目录独立构建</strong></li>
</ul>
<h4 data-id="heading-30">6.3 设计哲学</h4>
<p>Crow 项目的 CMake 结构体现了现代 CMake 的最佳实践：</p>
<ul>
<li><strong>接口库（INTERFACE Library）</strong>：适合 header-only 库</li>
<li><strong>目标导向</strong>：使用 <code>target_*</code> 命令而非全局变量</li>
<li><strong>子项目组织</strong>：通过 <code>add_subdirectory()</code> 管理复杂项目</li>
<li><strong>依赖传播</strong>：通过 INTERFACE 属性自动传播依赖</li>
</ul>
<p>这种设计确保了构建系统的一致性、可维护性和可扩展性。</p>
<h2 data-id="heading-31">附1 Cmake三个最重要的语法</h2>
<p>我们用“剃刀原则”（即奥卡姆剃刀：如无必要，勿增实体）来思考 CMake —— 只保留最核心、最必要、能支撑绝大多数项目的三个语法要素。去掉花里胡哨的细节，只讲真正“不可或缺”的三件套。</p>
<hr/>
<h4 data-id="heading-32">✂️ 剃刀原则下的 CMake 最重要三个语法：</h4>
<h5 data-id="heading-33">1. <strong>project() —— 定义你的项目名字和语言</strong></h5>
<blockquote>
<p><strong>为什么必要？</strong> 没有项目，CMake 就不知道你在构建什么。</p>
<p><strong>通俗理解</strong>：就像你写作文要先起个标题，<code>project()</code> 就是给你的代码工程起个“名字”。</p>
</blockquote>
<pre><code class="hljs language-cmake" lang="cmake"># 最简形式
project(MyApp)

# 更常见：指定语言（C++ 是默认，但显式写出更清晰）
project(MyApp LANGUAGES CXX)
</code></pre>
<p>✅ <strong>剃刀理由</strong>：没有 <code>project()</code>，后续很多变量（比如 <code>${PROJECT_NAME}</code>）都无法使用，构建系统也无法正确初始化。</p>
<hr/>
<h5 data-id="heading-34">2. <strong>add_executable() 或 add_library() —— 告诉 CMake 要生成什么</strong></h5>
<blockquote>
<p><strong>为什么必要？</strong> 你总得告诉 CMake：“我要编译出一个可执行程序”还是“我要打包成一个库”。</p>
</blockquote>
<pre><code class="hljs language-cmake" lang="cmake"># 编译一个叫 my_app 的可执行文件，源码是 main.cpp
add_executable(my_app main.cpp utils.cpp)

# 或者编译一个静态库
add_library(my_utils STATIC utils.cpp helper.cpp)
</code></pre>
<p>✅ <strong>剃刀理由</strong>：这是 CMake 的“目标”（target）机制的核心。不定义目标，就没有任何东西会被编译！</p>
<hr/>
<h5 data-id="heading-35">3. <strong>target_link_libraries() —— 告诉 CMake 目标依赖什么</strong></h5>
<blockquote>
<p><strong>为什么必要？</strong> 程序很少孤立存在，通常要链接标准库、第三方库，或者自己写的其他模块。</p>
</blockquote>
<pre><code class="hljs language-cmake" lang="cmake"># my_app 依赖 my_utils 这个库
target_link_libraries(my_app PRIVATE my_utils)

# 或者链接系统线程库
target_link_libraries(my_app PRIVATE Threads::Threads)
</code></pre>
<p>✅ <strong>剃刀理由</strong>：现代 CMake 强调“基于目标的依赖管理”。用 <code>target_link_libraries()</code> 不仅能链接库，还能自动传递头文件路径、编译选项等——它是组织依赖的唯一简洁且正确的方式。</p>
<hr/>
<h4 data-id="heading-36">🎯 举个完整小例子（三行搞定一个 C++ 项目）：</h4>
<pre><code class="hljs language-cmake" lang="cmake"># CMakeLists.txt
project(MyApp LANGUAGES CXX)
add_executable(hello main.cpp)
target_link_libraries(hello)  # 暂无依赖，可省略，但习惯保留结构
</code></pre>
<p>即使只有这三行，也能在任何平台生成 Makefile、Visual Studio 工程或 Xcode 项目！</p>
<hr/>
<h4 data-id="heading-37">✅ 总结（剃刀三要素）：</h4>

























<table><thead><tr><th>语法</th><th>作用</th><th>类比</th></tr></thead><tbody><tr><td><code>project()</code></td><td>起名字、定语言</td><td>给项目办“身份证”</td></tr><tr><td><code>add_executable()</code> / <code>add_library()</code></td><td>定义要构建什么</td><td>写“任务清单”</td></tr><tr><td><code>target_link_libraries()</code></td><td>声明依赖关系</td><td>画“关系图”</td></tr></tbody></table>
<p>只要掌握这三点，80% 的 CMake 项目都能看懂、能写。其余都是锦上添花，非“必要”。</p>
<blockquote>
<p>💡 记住：CMake 的核心思想不是“怎么编译”，而是“描述你的项目结构”。越简单，越强大。</p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[抢占AI风控赛道制高点：为什么fengkong.ai是你不能错过的战略资产？]]></title>    <link>https://juejin.cn/post/7596904122866040883</link>    <guid>https://juejin.cn/post/7596904122866040883</guid>    <pubDate>2026-01-19T22:54:40.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7596904122866040883" data-draft-id="7596906923892752394" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="抢占AI风控赛道制高点：为什么fengkong.ai是你不能错过的战略资产？"/> <meta itemprop="keywords" content="人工智能"/> <meta itemprop="datePublished" content="2026-01-19T22:54:40.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="数擎AI"/> <meta itemprop="url" content="https://juejin.cn/user/2928754707402423"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            抢占AI风控赛道制高点：为什么fengkong.ai是你不能错过的战略资产？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2928754707402423/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    数擎AI
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-19T22:54:40.000Z" title="Mon Jan 19 2026 22:54:40 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>【收藏级数字资产 · 即刻拥有】<br/>
战略域名 fengkong.ai 现已开放交易<br/>
直达链接：<a href="https://link.juejin.cn?target=https%3A%2F%2Fciguo.net%2F" target="_blank" title="https://ciguo.net/" ref="nofollow noopener noreferrer">ciguo.net/</a><br/>
这是一个直指千亿AI风控市场的品牌入口，一份即将随行业爆发而指数增长的数字不动产。</p>
</blockquote>
<p>市场风险评估不准确、缺乏实时监控预警已成为投资领域的主要痛点，而香港金融机构采用生成式AI的比例高达38%，远超全球26%的平均水平。</p>
<p>深夜的办公室里，一家香港量化基金的风控主管盯着屏幕上跳动的数字，最新的AI预警系统刚刚标记出三个投资组合的异常关联交易。过去需要人工三天完成的分析，现在只用了23秒。</p>
<p>这是AI风控领域每天发生的真实场景，而fengkong.ai这个域名，正是通往这个价值数万亿美元市场的数字钥匙。</p>
<h2 data-id="heading-0">01 行业脉搏</h2>
<p>金融科技的浪潮与AI风控的必然兴起</p>
<p>当前全球金融科技市场正经历前所未有的变革，特别是在风险控制领域。香港作为国际金融中心，引领着这一变革的潮流。</p>
<p>根据一项2023年的全球调查，香港金融机构采用生成式AI的比例已达到38%，明显高于全球26%的平均水平。这种技术采纳速度背后，反映的是对高效、精准风控解决方案的迫切需求。</p>
<p>行业内的风控痛点十分明显：市场风波带来的不可预测影响、风险评估不准确导致投资损失、缺乏实时数据和分析造成决策滞后，以及不完善的合规管理带来的法律风险。</p>
<p>传统风控手段已无法满足现代金融市场的需求，而AI风控凭借其能够“实时动态数据监测”、“多维数据分析”和“智能预警提示”的能力，正在成为金融机构的标配。</p>
<h2 data-id="heading-1">02 域名解析</h2>
<p>品牌价值与市场定位的战略匹配</p>
<p>Fengkong.ai这一域名直指行业核心—“风控”与“AI”的完美结合。在中文语境中，“风控”是金融、科技和互联网行业的高频专业术语，具有明确的行业指向性。</p>
<p>从品牌建设角度看，这个域名具有天然的记忆优势。与需要解释和记忆的虚构品牌名不同，fengkong.ai直白地传达了业务核心，降低了客户认知成本。</p>
<p>这个域名的稀缺性不言而喻。在优质域名资源日益枯竭的今天，简短、易记且与热门行业直接相关的域名已成为数字时代的稀有资产。而“.ai”域名的特殊性更增加了其价值—它不仅是安圭拉的国家顶级域名，更是人工智能行业的身份象征。</p>
<h2 data-id="heading-2">03 应用蓝图</h2>
<p>AI风控平台的多元场景与实际价值</p>
<p>AI风控技术已经渗透到金融行业的各个环节。以中科闻歌的全场景投资风控平台为例，它能够实现实时动态数据监测，持续追踪企业的关键指标和风险信号。</p>
<p>竹间智能的Gemini风控产品展示了AI风控的另一维度，它能够本地化部署，快速集成不同数据源，灵活处理海量结构化及非结构化数据。</p>
<p>该平台实现了基于图分析的风控引擎，在结合传统风控规则的基础上，实现了深度自动关联推理和可疑点发现，并自动识别新的风险模式。</p>
<p>实际应用中，AI风控平台可服务于多个场景：</p>
<p>客户尽职调查，快速提供准确的企业信息；</p>
<p>风险等级评估，科学评定企业风险等级；</p>
<p>多维身份识别，全面展现企业关联网络；</p>
<p>风险动态监控，持续监控企业经营状态和风险事件。</p>
<h2 data-id="heading-3">04 成功样板</h2>
<p>行业领先者的实践与市场验证</p>
<p>北京科创基金的一站式智能投研、风控、资管平台是AI风控的成功案例。该平台基于图神经网络、智能风险监测模型和智能推荐引擎技术，融合了产业价值图谱。</p>
<p>平台为投资研判、风险管理和投后赋能提供一站式服务，帮助客户实现资产管理规模的高质量增长。这一案例充分证明了AI风控平台的实际价值和市场接受度。</p>
<p>竹间智能的Gemini风控平台则体现了技术的前沿性，它的 “认知+RPA”模式仅需5步就能创建专属风控机器人，大大降低了技术使用门槛。平台包括创建、训练、测试、使用和优化的完整流程，实现了风控流程的自动化和智能化。</p>
<h2 data-id="heading-4">05 战略定位</h2>
<p>国际化视野与市场扩张的双重优势</p>
<p>香港作为国际金融中心，具有独特的双重优势。它不仅是内地AI企业出海的测试基地，也是国际AI技术进入亚洲市场的重要门户。</p>
<p>这种桥梁作用在AI风控领域尤为重要。香港拥有国际化的客户基础和环境，使其成为AI公司服务全球市场的理想试点。</p>
<p>对于拥有fengkong.ai域名的企业，这一战略位置提供了双重机遇：既可以服务内地庞大的金融市场，又能对接国际先进的AI技术和金融标准。</p>
<p>香港三所大学—香港科技大学、香港大学和香港中文大学在2025年QS世界大学排名中，均进入了数据科学和AI领域的前20名。这为AI风控领域提供了丰富的人才资源和研发支持。</p>
<h2 data-id="heading-5">06 投资前瞻</h2>
<p>数字资产增值与品牌建设的双重回报</p>
<p>从投资角度看，fengkong.ai这样的行业精准域名具有多重价值维度。在AI风控行业爆发前夜，抢占这一战略域名相当于在数字世界圈定了行业领地。</p>
<p>域名的价值会随着AI风控行业的发展而自然增值，这种增值是指数级的。当AI风控成为金融行业的标准配置时，这个域名的品牌价值将不可估量。</p>
<p>域名投资与其他投资不同，它具有“赢家通吃”的特点。在互联网领域，行业关键词域名往往只承认一个权威持有者。这意味着一旦你拥有了fengkong.ai，就相当于在这个细分领域建立了天然的竞争壁垒。</p>
<p>香港国际机场第三跑道系统已全面启用，年旅客吞吐量增至1.2亿人次。每天，无数资金、数据和决策在这里交汇流转。</p>
<p>跑道上，FJDynamics公司的自主划线机器人精确地标记着安全线，误差不超过2厘米。与此同时，金融市场的“跑道”上，AI风控系统正以更高的精度标记着风险边界。</p>
<p><strong>现在，您有机会通过 <a href="https://link.juejin.cn?target=https%3A%2F%2Fciguo.net%2F" target="_blank" title="https://ciguo.net/" ref="nofollow noopener noreferrer">ciguo.net/</a> 直接持有 <a href="https://link.juejin.cn?target=https%3A%2F%2Ffengkong.ai%2F" target="_blank" title="https://fengkong.ai/" ref="nofollow noopener noreferrer">fengkong.ai</a> 这一战略域名，成为AI风控赛道数字地标的拥有者。这不仅是一次购买，更是对金融科技未来的提前布局。</strong></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[BlockingCollection<T> 内部机制与最佳实践]]></title>    <link>https://juejin.cn/post/7596971669862088745</link>    <guid>https://juejin.cn/post/7596971669862088745</guid>    <pubDate>2026-01-19T23:19:23.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7596971669862088745" data-draft-id="7596969908324499510" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="BlockingCollection&lt;T&gt; 内部机制与最佳实践"/> <meta itemprop="keywords" content="C#,.NET"/> <meta itemprop="datePublished" content="2026-01-19T23:19:23.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="唐青枫"/> <meta itemprop="url" content="https://juejin.cn/user/3737995266234280"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            BlockingCollection&lt;T&gt; 内部机制与最佳实践
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3737995266234280/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    唐青枫
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-19T23:19:23.000Z" title="Mon Jan 19 2026 23:19:23 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h3 data-id="heading-0">简介</h3>
<p><code>BlockingCollection&lt;T&gt;</code> 是 <code>.NET</code> 中非常重要且实用的线程安全、阻塞式的生产者-消费者集合类，位于 <code>System.Collections.Concurrent</code> 命名空间。</p>
<blockquote>
<p>BlockingCollection 不是队列，
而是一个“带阻塞语义的并发管道（Blocking Producer–Consumer Abstraction）”。
在并发集合外面，加了一层“阻塞 + 容量控制 + 完成语义”</p>
</blockquote>
<h3 data-id="heading-1">什么是生产者-消费者模式？</h3>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-comment">// 生产者线程 → [BlockingCollection] → 消费者线程</span>
<span class="hljs-comment">// 1. 生产者添加项目，如果集合已满则阻塞等待</span>
<span class="hljs-comment">// 2. 消费者取出项目，如果集合为空则阻塞等待</span>
<span class="hljs-comment">// 3. 自动的线程同步和资源管理</span>
</code></pre>
<h3 data-id="heading-2">核心定位与价值</h3>
<p><code>BlockingCollection&lt;T&gt;</code> 是一个包装器，它可以基于以下几种底层集合来工作（默认使用 <code>ConcurrentQueue&lt;T&gt;</code>）：</p>



































<table><thead><tr><th>底层集合类型</th><th>默认</th><th>有界（Bounded）</th><th>特点</th></tr></thead><tbody><tr><td>ConcurrentQueue</td><td>是</td><td>可选</td><td>FIFO，性能最高</td></tr><tr><td>ConcurrentStack</td><td>否</td><td>可选</td><td>LIFO</td></tr><tr><td>ConcurrentBag</td><td>否</td><td>可选</td><td>无序，插入/取出最快</td></tr><tr><td>自定义 IProducerConsumerCollection</td><td>否</td><td>可选</td><td>高度自定义</td></tr></tbody></table>
<p>在多线程场景中，“生产者线程生产数据，消费者线程消费数据” 是高频场景（如日志收集、任务队列、消息处理）。若用普通集合（如<code>List&lt;T&gt;</code>）+ 手动锁实现，需处理：</p>
<ul>
<li>
<p>线程安全（加 <code>lock</code> ）；</p>
</li>
<li>
<p>空集合时消费者等待（<code>Monitor.Wait</code>）；</p>
</li>
<li>
<p>满集合时生产者等待（<code>Monitor.Wait</code>）；</p>
</li>
<li>
<p>数据就绪时唤醒等待线程（<code>Monitor.Pulse</code>）。</p>
</li>
</ul>
<p><code>BlockingCollection&lt;T&gt;</code> 封装了上述所有逻辑，核心价值：</p>
<ul>
<li>
<p>开箱即用的阻塞逻辑：空集合消费阻塞、满集合生产阻塞；</p>
</li>
<li>
<p>线程安全：所有操作（添加 / 移除 / 遍历）均线程安全；</p>
</li>
<li>
<p>支持边界限制：可设置集合最大容量（满则阻塞生产者）；</p>
</li>
<li>
<p>支持取消 / 完成：可优雅停止生产 / 消费，避免线程卡死；</p>
</li>
<li>
<p>灵活的底层存储：默认基于 <code>ConcurrentQueue&lt;T&gt;</code>（先进先出），也可指定 <code>ConcurrentStack&lt;T&gt;/ConcurrentBag&lt;T&gt;</code>。</p>
</li>
</ul>
<h3 data-id="heading-3">最常用的几种创建方式</h3>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-comment">// 1. 最常用：无界队列（推荐用于大多数场景）</span>
<span class="hljs-keyword">var</span> bc = <span class="hljs-keyword">new</span> BlockingCollection&lt;<span class="hljs-built_in">string</span>&gt;();

<span class="hljs-comment">// 2. 有界队列（限制容量，生产者满时会阻塞）</span>
<span class="hljs-keyword">var</span> bcBounded = <span class="hljs-keyword">new</span> BlockingCollection&lt;<span class="hljs-built_in">string</span>&gt;(boundedCapacity: <span class="hljs-number">100</span>);

<span class="hljs-comment">// 3. 指定底层集合 + 有界</span>
<span class="hljs-keyword">var</span> bcStack = <span class="hljs-keyword">new</span> BlockingCollection&lt;<span class="hljs-built_in">string</span>&gt;(
    <span class="hljs-keyword">new</span> ConcurrentStack&lt;<span class="hljs-built_in">string</span>&gt;(),
    boundedCapacity: <span class="hljs-number">50</span>);

<span class="hljs-comment">// 4. 基于已有的集合（高级用法）</span>
<span class="hljs-keyword">var</span> queue = <span class="hljs-keyword">new</span> ConcurrentQueue&lt;<span class="hljs-built_in">string</span>&gt;();
<span class="hljs-keyword">var</span> bcFromExisting = <span class="hljs-keyword">new</span> BlockingCollection&lt;<span class="hljs-built_in">string</span>&gt;(queue, <span class="hljs-number">200</span>);
</code></pre>
<h3 data-id="heading-4">核心 API 与基础使用</h3>
<h4 data-id="heading-5">核心构造函数</h4>
<ul>
<li>
<p><code>BlockingCollection&lt;T&gt;()</code>: 默认构造：无边界限制，底层用 <code>ConcurrentQueue&lt;T&gt;</code></p>
</li>
<li>
<p><code>BlockingCollection&lt;T&gt;(int boundedCapacity)</code>: 指定最大容量（边界），满则生产者阻塞</p>
</li>
<li>
<p><code>BlockingCollection&lt;T&gt;(IProducerConsumerCollection&lt;T&gt;)</code>: 自定义底层存储（如<code>ConcurrentStack&lt;T&gt;</code>）</p>
</li>
<li>
<p><code>BlockingCollection&lt;T&gt;(IProducerConsumerCollection&lt;T&gt;, int)</code>: 自定义存储 + 最大容量</p>
</li>
</ul>
<h4 data-id="heading-6">核心方法 / 属性</h4>
<ul>
<li>
<p><code>Add(T item)</code>: 向集合添加元素：若集合满则阻塞，直到有空间</p>
</li>
<li>
<p><code>Add(T item, CancellationToken)</code>: 带取消令牌的 Add：可中途取消阻塞</p>
</li>
<li>
<p><code>Take()</code>: 从集合移除并返回元素：若集合空则阻塞，直到有元素</p>
</li>
<li>
<p><code>Take(CancellationToken)</code>: 带取消令牌的 Take：可中途取消阻塞</p>
</li>
<li>
<p><code>TryAdd(T item, int millisecondsTimeout)</code>: 尝试添加：超时返回 false（非阻塞）</p>
</li>
<li>
<p><code>TryTake(out T item, int millisecondsTimeout)</code>: 尝试获取：超时返回 false（非阻塞）</p>
</li>
<li>
<p><code>CompleteAdding()</code>: 标记 “添加完成”：后续 Add 会抛异常，Take 在集合空后退出</p>
</li>
<li>
<p><code>IsAddingCompleted</code>: 判断是否已调用 <code>CompleteAdding()</code></p>
</li>
<li>
<p><code>IsCompleted</code>: 判断是否 “添加完成且集合为空”</p>
</li>
<li>
<p><code>BoundedCapacity</code>: 集合最大容量（-1 表示无限制）</p>
</li>
</ul>
<h4 data-id="heading-7">核心操作方法</h4>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CoreOperations</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DemonstrateOperations</span>()</span>
    {
        <span class="hljs-keyword">var</span> collection = <span class="hljs-keyword">new</span> BlockingCollection&lt;<span class="hljs-built_in">string</span>&gt;(boundedCapacity: <span class="hljs-number">3</span>);
        
        <span class="hljs-comment">// 1. 添加项目</span>
        collection.Add(<span class="hljs-string">"项目1"</span>); <span class="hljs-comment">// 阻塞直到有空间</span>
        
        <span class="hljs-comment">// 2. 尝试添加（不阻塞）</span>
        <span class="hljs-built_in">bool</span> added = collection.TryAdd(<span class="hljs-string">"项目2"</span>, millisecondsTimeout: <span class="hljs-number">0</span>);
        Console.WriteLine(<span class="hljs-string">$"尝试添加结果: <span class="hljs-subst">{added}</span>"</span>);
        
        <span class="hljs-comment">// 3. 带超时的添加</span>
        <span class="hljs-built_in">bool</span> addedWithTimeout = collection.TryAdd(<span class="hljs-string">"项目3"</span>, 
            millisecondsTimeout: <span class="hljs-number">1000</span>); <span class="hljs-comment">// 最多等待1秒</span>
        Console.WriteLine(<span class="hljs-string">$"带超时添加结果: <span class="hljs-subst">{addedWithTimeout}</span>"</span>);
        
        <span class="hljs-comment">// 4. 取出项目（阻塞）</span>
        <span class="hljs-built_in">string</span> item1 = collection.Take(); <span class="hljs-comment">// 阻塞直到有项目可取</span>
        Console.WriteLine(<span class="hljs-string">$"取出: <span class="hljs-subst">{item1}</span>"</span>);
        
        <span class="hljs-comment">// 5. 尝试取出（不阻塞）</span>
        <span class="hljs-built_in">bool</span> taken = collection.TryTake(<span class="hljs-keyword">out</span> <span class="hljs-built_in">string</span> item2, millisecondsTimeout: <span class="hljs-number">0</span>);
        Console.WriteLine(<span class="hljs-string">$"尝试取出结果: <span class="hljs-subst">{taken}</span>, 项目: <span class="hljs-subst">{item2}</span>"</span>);
        
        <span class="hljs-comment">// 6. 查看但不移除</span>
        <span class="hljs-built_in">bool</span> peeked = collection.TryPeek(<span class="hljs-keyword">out</span> <span class="hljs-built_in">string</span> item3);
        Console.WriteLine(<span class="hljs-string">$"查看结果: <span class="hljs-subst">{peeked}</span>, 项目: <span class="hljs-subst">{item3}</span>"</span>);
        
        <span class="hljs-comment">// 7. 完成添加</span>
        collection.CompleteAdding();
        Console.WriteLine(<span class="hljs-string">$"IsAddingCompleted: <span class="hljs-subst">{collection.IsAddingCompleted}</span>"</span>);
        Console.WriteLine(<span class="hljs-string">$"IsCompleted: <span class="hljs-subst">{collection.IsCompleted}</span>"</span>);
        
        <span class="hljs-comment">// 8. 获取当前所有项目（不阻塞）</span>
        <span class="hljs-built_in">string</span>[] allItems = collection.ToArray();
        Console.WriteLine(<span class="hljs-string">$"当前项目数: <span class="hljs-subst">{allItems.Length}</span>"</span>);
    }
}
</code></pre>
<h4 data-id="heading-8">基础示例：简单生产者 - 消费者</h4>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-keyword">using</span> System;
<span class="hljs-keyword">using</span> System.Collections.Concurrent;
<span class="hljs-keyword">using</span> System.Threading;
<span class="hljs-keyword">using</span> System.Threading.Tasks;

<span class="hljs-keyword">class</span> <span class="hljs-title">BlockingCollectionBasicDemo</span>
{
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span>
    {
        <span class="hljs-comment">// 创建阻塞集合，最大容量为5（满则生产者阻塞）</span>
        <span class="hljs-keyword">var</span> bc = <span class="hljs-keyword">new</span> BlockingCollection&lt;<span class="hljs-built_in">int</span>&gt;(<span class="hljs-number">5</span>);

        <span class="hljs-comment">// 1. 生产者线程：生产1-10的数字</span>
        Task producer = Task.Run(() =&gt;
        {
            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++)
            {
                bc.Add(i); <span class="hljs-comment">// 满则阻塞</span>
                Console.WriteLine(<span class="hljs-string">$"生产者：添加 <span class="hljs-subst">{i}</span>，当前集合数量：<span class="hljs-subst">{bc.Count}</span>"</span>);
                Thread.Sleep(<span class="hljs-number">100</span>); <span class="hljs-comment">// 模拟生产耗时</span>
            }
            <span class="hljs-comment">// 标记添加完成：消费者知道不会有新数据了</span>
            bc.CompleteAdding();
            Console.WriteLine(<span class="hljs-string">"生产者：完成所有生产，标记添加完成"</span>);
        });

        <span class="hljs-comment">// 2. 消费者线程：消费所有数字</span>
        Task consumer = Task.Run(() =&gt;
        {
            <span class="hljs-comment">// GetConsumingEnumerable()：遍历集合，空则阻塞，直到CompleteAdding且空</span>
            <span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">int</span> item <span class="hljs-keyword">in</span> bc.GetConsumingEnumerable())
            {
                Console.WriteLine(<span class="hljs-string">$"消费者：消费 <span class="hljs-subst">{item}</span>，当前集合数量：<span class="hljs-subst">{bc.Count}</span>"</span>);
                Thread.Sleep(<span class="hljs-number">500</span>); <span class="hljs-comment">// 模拟消费耗时（比生产慢，会导致集合堆积）</span>
            }
            Console.WriteLine(<span class="hljs-string">"消费者：所有数据消费完成"</span>);
        });

        <span class="hljs-comment">// 等待所有任务完成</span>
        Task.WaitAll(producer, consumer);
        bc.Dispose(); <span class="hljs-comment">// 释放资源</span>
    }
}
</code></pre>
<p>输出结果</p>
<pre><code class="hljs language-arduino" lang="arduino">生产者：添加 <span class="hljs-number">1</span>，当前集合数量：<span class="hljs-number">1</span>
生产者：添加 <span class="hljs-number">2</span>，当前集合数量：<span class="hljs-number">2</span>
生产者：添加 <span class="hljs-number">3</span>，当前集合数量：<span class="hljs-number">3</span>
生产者：添加 <span class="hljs-number">4</span>，当前集合数量：<span class="hljs-number">4</span>
生产者：添加 <span class="hljs-number">5</span>，当前集合数量：<span class="hljs-number">5</span>
消费者：消费 <span class="hljs-number">1</span>，当前集合数量：<span class="hljs-number">4</span>
生产者：添加 <span class="hljs-number">6</span>，当前集合数量：<span class="hljs-number">5</span>  <span class="hljs-comment">// 消费后腾出空间，生产者继续添加</span>
生产者：添加 <span class="hljs-number">7</span>，当前集合数量：<span class="hljs-number">5</span>  <span class="hljs-comment">// 集合再次满，生产者阻塞</span>
消费者：消费 <span class="hljs-number">2</span>，当前集合数量：<span class="hljs-number">4</span>
生产者：添加 <span class="hljs-number">8</span>，当前集合数量：<span class="hljs-number">5</span>
...（后续依次消费和生产）
生产者：完成所有生产，标记添加完成
消费者：消费 <span class="hljs-number">10</span>，当前集合数量：<span class="hljs-number">0</span>
消费者：所有数据消费完成
</code></pre>
<p>核心现象：</p>
<ul>
<li>
<p>集合容量设为 5，生产者添加到 5 个后阻塞，直到消费者消费 1 个腾出空间；</p>
</li>
<li>
<p><code>GetConsumingEnumerable()</code> 自动处理阻塞逻辑，无需手动判断集合是否为空；</p>
</li>
<li>
<p><code>CompleteAdding()</code> 后，消费者遍历完剩余数据即退出，不会无限阻塞。</p>
</li>
</ul>
<h3 data-id="heading-9">高级用法详解</h3>
<h4 data-id="heading-10">边界限制（Bounded Capacity）</h4>
<p>通过构造函数指定 <code>boundedCapacity</code>，实现 “生产者限流”：</p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-comment">// 最大容量3，满则生产者阻塞</span>
<span class="hljs-keyword">var</span> bc = <span class="hljs-keyword">new</span> BlockingCollection&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-number">3</span>);

<span class="hljs-comment">// 生产者1：快速添加3个元素，第4个会阻塞</span>
Task.Run(() =&gt;
{
    bc.Add(<span class="hljs-string">"A"</span>);
    bc.Add(<span class="hljs-string">"B"</span>);
    bc.Add(<span class="hljs-string">"C"</span>);
    Console.WriteLine(<span class="hljs-string">"生产者1：已添加3个，准备添加第4个（会阻塞）"</span>);
    bc.Add(<span class="hljs-string">"D"</span>); <span class="hljs-comment">// 阻塞，直到消费者消费一个</span>
    Console.WriteLine(<span class="hljs-string">"生产者1：第4个元素添加成功"</span>);
});

<span class="hljs-comment">// 消费者1：2秒后消费一个元素</span>
Task.Run(() =&gt;
{
    Thread.Sleep(<span class="hljs-number">2000</span>);
    <span class="hljs-keyword">var</span> item = bc.Take();
    Console.WriteLine(<span class="hljs-string">$"消费者1：消费 <span class="hljs-subst">{item}</span>"</span>);
});
</code></pre>
<h4 data-id="heading-11">取消阻塞（CancellationToken）</h4>
<p>用 <code>CancellationToken</code> 中断阻塞的 <code>Add/Take</code> 操作，避免线程永久阻塞：</p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-keyword">var</span> cts = <span class="hljs-keyword">new</span> CancellationTokenSource();
<span class="hljs-comment">// 3秒后取消</span>
cts.CancelAfter(<span class="hljs-number">3000</span>);

<span class="hljs-keyword">var</span> bc = <span class="hljs-keyword">new</span> BlockingCollection&lt;<span class="hljs-built_in">int</span>&gt;();

<span class="hljs-comment">// 生产者：尝试添加，3秒后取消</span>
Task.Run(() =&gt;
{
    <span class="hljs-keyword">try</span>
    {
        <span class="hljs-comment">// 集合无边界，此处不会阻塞，但演示取消逻辑</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; ; i++)
        {
            bc.Add(i, cts.Token);
            Console.WriteLine(<span class="hljs-string">$"添加 <span class="hljs-subst">{i}</span>"</span>);
            Thread.Sleep(<span class="hljs-number">500</span>);
        }
    }
    <span class="hljs-keyword">catch</span> (OperationCanceledException)
    {
        Console.WriteLine(<span class="hljs-string">"生产者：添加操作被取消"</span>);
        bc.CompleteAdding();
    }
});

<span class="hljs-comment">// 消费者：尝试消费，3秒后取消</span>
Task.Run(() =&gt;
{
    <span class="hljs-keyword">try</span>
    {
        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)
        {
            <span class="hljs-built_in">int</span> item = bc.Take(cts.Token);
            Console.WriteLine(<span class="hljs-string">$"消费 <span class="hljs-subst">{item}</span>"</span>);
        }
    }
    <span class="hljs-keyword">catch</span> (OperationCanceledException)
    {
        Console.WriteLine(<span class="hljs-string">"消费者：消费操作被取消"</span>);
    }
});
</code></pre>
<h4 data-id="heading-12">自定义底层存储</h4>
<p>默认底层是 <code>ConcurrentQueue&lt;T&gt;</code>（FIFO），可指定 <code>ConcurrentStack&lt;T&gt;</code>（LIFO）或 <code>ConcurrentBag&lt;T&gt;</code>（无序）：</p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-comment">// 底层用ConcurrentStack（栈：后进先出）</span>
<span class="hljs-keyword">var</span> bc = <span class="hljs-keyword">new</span> BlockingCollection&lt;<span class="hljs-built_in">int</span>&gt;(<span class="hljs-keyword">new</span> ConcurrentStack&lt;<span class="hljs-built_in">int</span>&gt;());

bc.Add(<span class="hljs-number">1</span>);
bc.Add(<span class="hljs-number">2</span>);
bc.Add(<span class="hljs-number">3</span>);

<span class="hljs-comment">// Take会获取最后添加的3（栈顶）</span>
Console.WriteLine(bc.Take()); <span class="hljs-comment">// 输出：3</span>
Console.WriteLine(bc.Take()); <span class="hljs-comment">// 输出：2</span>
Console.WriteLine(bc.Take()); <span class="hljs-comment">// 输出：1</span>
</code></pre>
<h4 data-id="heading-13">多生产者 / 多消费者</h4>
<p><code>BlockingCollection&lt;T&gt;</code> 天然支持多生产者、多消费者并发操作，无需额外同步：</p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-keyword">var</span> bc = <span class="hljs-keyword">new</span> BlockingCollection&lt;<span class="hljs-built_in">int</span>&gt;(<span class="hljs-number">10</span>);

<span class="hljs-comment">// 3个生产者线程</span>
<span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)
{
    <span class="hljs-built_in">int</span> producerId = i + <span class="hljs-number">1</span>;
    Task.Run(() =&gt;
    {
        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">5</span>; j++)
        {
            <span class="hljs-built_in">int</span> <span class="hljs-keyword">value</span> = producerId * <span class="hljs-number">100</span> + j;
            bc.Add(<span class="hljs-keyword">value</span>);
            Console.WriteLine(<span class="hljs-string">$"生产者<span class="hljs-subst">{producerId}</span>：添加 <span class="hljs-subst">{<span class="hljs-keyword">value</span>}</span>"</span>);
            Thread.Sleep(<span class="hljs-number">100</span>);
        }
    });
}

<span class="hljs-comment">// 2个消费者线程</span>
<span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++)
{
    <span class="hljs-built_in">int</span> consumerId = i + <span class="hljs-number">1</span>;
    Task.Run(() =&gt;
    {
        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> item <span class="hljs-keyword">in</span> bc.GetConsumingEnumerable())
        {
            Console.WriteLine(<span class="hljs-string">$"消费者<span class="hljs-subst">{consumerId}</span>：消费 <span class="hljs-subst">{item}</span>"</span>);
            Thread.Sleep(<span class="hljs-number">200</span>);
        }
    });
}

<span class="hljs-comment">// 等待所有生产者完成后标记添加完成</span>
Task.Delay(<span class="hljs-number">2000</span>).ContinueWith(_ =&gt; bc.CompleteAdding());
</code></pre>
<h4 data-id="heading-14">数据流水线（Pipeline）模式</h4>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DataPipelineExample</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">RunPipeline</span>()</span>
    {
        <span class="hljs-comment">// 创建三个阶段的流水线</span>
        <span class="hljs-keyword">var</span> stage1 = <span class="hljs-keyword">new</span> BlockingCollection&lt;<span class="hljs-built_in">string</span>&gt;(boundedCapacity: <span class="hljs-number">10</span>);
        <span class="hljs-keyword">var</span> stage2 = <span class="hljs-keyword">new</span> BlockingCollection&lt;<span class="hljs-built_in">string</span>&gt;(boundedCapacity: <span class="hljs-number">10</span>);
        <span class="hljs-keyword">var</span> stage3 = <span class="hljs-keyword">new</span> BlockingCollection&lt;<span class="hljs-built_in">string</span>&gt;(boundedCapacity: <span class="hljs-number">10</span>);
        
        CancellationTokenSource cts = <span class="hljs-keyword">new</span> CancellationTokenSource();
        
        <span class="hljs-comment">// 阶段1：数据源</span>
        <span class="hljs-keyword">var</span> sourceTask = Task.Run(() =&gt;
        {
            <span class="hljs-keyword">try</span>
            {
                <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">20</span>; i++)
                {
                    <span class="hljs-built_in">string</span> data = <span class="hljs-string">$"原始数据<span class="hljs-subst">{i}</span>"</span>;
                    stage1.Add(data, cts.Token);
                    Console.WriteLine(<span class="hljs-string">$"阶段1: 产生 <span class="hljs-subst">{data}</span>"</span>);
                    Thread.Sleep(<span class="hljs-number">50</span>);
                }
                
                stage1.CompleteAdding();
                Console.WriteLine(<span class="hljs-string">"阶段1完成"</span>);
            }
            <span class="hljs-keyword">catch</span> (OperationCanceledException)
            {
                Console.WriteLine(<span class="hljs-string">"阶段1被取消"</span>);
            }
        });
        
        <span class="hljs-comment">// 阶段2：数据处理</span>
        <span class="hljs-keyword">var</span> processorTask = Task.Run(() =&gt;
        {
            <span class="hljs-keyword">try</span>
            {
                <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> item <span class="hljs-keyword">in</span> stage1.GetConsumingEnumerable(cts.Token))
                {
                    <span class="hljs-built_in">string</span> processed = <span class="hljs-string">$"处理过的[<span class="hljs-subst">{item}</span>]"</span>;
                    stage2.Add(processed, cts.Token);
                    Console.WriteLine(<span class="hljs-string">$"阶段2: 处理 <span class="hljs-subst">{item}</span> -&gt; <span class="hljs-subst">{processed}</span>"</span>);
                    Thread.Sleep(<span class="hljs-number">100</span>);
                }
                
                stage2.CompleteAdding();
                Console.WriteLine(<span class="hljs-string">"阶段2完成"</span>);
            }
            <span class="hljs-keyword">catch</span> (OperationCanceledException)
            {
                Console.WriteLine(<span class="hljs-string">"阶段2被取消"</span>);
            }
        });
        
        <span class="hljs-comment">// 阶段3：数据输出</span>
        <span class="hljs-keyword">var</span> outputTask = Task.Run(() =&gt;
        {
            <span class="hljs-keyword">try</span>
            {
                <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> item <span class="hljs-keyword">in</span> stage2.GetConsumingEnumerable(cts.Token))
                {
                    <span class="hljs-built_in">string</span> result = <span class="hljs-string">$"最终结果&lt;<span class="hljs-subst">{item}</span>&gt;"</span>;
                    stage3.Add(result, cts.Token);
                    Console.WriteLine(<span class="hljs-string">$"阶段3: 输出 <span class="hljs-subst">{item}</span> -&gt; <span class="hljs-subst">{result}</span>"</span>);
                    Thread.Sleep(<span class="hljs-number">80</span>);
                }
                
                stage3.CompleteAdding();
                Console.WriteLine(<span class="hljs-string">"阶段3完成"</span>);
            }
            <span class="hljs-keyword">catch</span> (OperationCanceledException)
            {
                Console.WriteLine(<span class="hljs-string">"阶段3被取消"</span>);
            }
        });
        
        <span class="hljs-comment">// 监控输出</span>
        <span class="hljs-keyword">var</span> monitorTask = Task.Run(() =&gt;
        {
            <span class="hljs-built_in">int</span> count = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> item <span class="hljs-keyword">in</span> stage3.GetConsumingEnumerable())
            {
                count++;
                Console.WriteLine(<span class="hljs-string">$"监控: 收到第<span class="hljs-subst">{count}</span>个结果: <span class="hljs-subst">{item}</span>"</span>);
            }
            
            Console.WriteLine(<span class="hljs-string">$"监控: 总共收到 <span class="hljs-subst">{count}</span> 个结果"</span>);
        });
        
        <span class="hljs-comment">// 运行5秒后取消</span>
        Task.Run(() =&gt;
        {
            Thread.Sleep(<span class="hljs-number">5000</span>);
            Console.WriteLine(<span class="hljs-string">"\n流水线运行5秒，发送取消信号..."</span>);
            cts.Cancel();
        });
        
        <span class="hljs-keyword">try</span>
        {
            Task.WaitAll(sourceTask, processorTask, outputTask, monitorTask, <span class="hljs-number">10000</span>);
        }
        <span class="hljs-keyword">catch</span> (AggregateException ex)
        {
            Console.WriteLine(<span class="hljs-string">$"任务异常: <span class="hljs-subst">{ex.Flatten().Message}</span>"</span>);
        }
        
        Console.WriteLine(<span class="hljs-string">"流水线运行结束"</span>);
    }
}
</code></pre>
<h3 data-id="heading-15">使用场景</h3>
<h4 data-id="heading-16">适合场景</h4>
<ul>
<li>
<p><code>CPU</code> 线程池任务</p>
</li>
<li>
<p>后台 <code>Worker</code></p>
</li>
<li>
<p>批处理系统</p>
</li>
<li>
<p><code>ETL</code> 管道</p>
</li>
<li>
<p>传统 <code>Producer–Consumer</code></p>
</li>
</ul>
<h4 data-id="heading-17">不适合场景</h4>
<ul>
<li>
<p><code>async/await</code></p>
</li>
<li>
<p>高吞吐低延迟网络 IO</p>
</li>
<li>
<p><code>UI</code> 线程</p>
</li>
<li>
<p>实时系统</p>
</li>
</ul>
<h3 data-id="heading-18">总结</h3>
<ul>
<li>
<p><code>BlockingCollection&lt;T&gt;</code> 是 <code>.NET</code> 官方的阻塞式线程安全集合，核心适配 “生产者 - 消费者” 模型；</p>
</li>
<li>
<p>核心特性：空集合消费阻塞、满集合生产阻塞，支持边界限制、取消操作、自定义底层存储；</p>
</li>
<li>
<p>核心 API：<code>Add()</code>（生产）、<code>Take()</code>（消费）、<code>CompleteAdding()</code>（标记生产完成）、<code>GetConsumingEnumerable()</code>（遍历消费）；</p>
</li>
<li>
<p>关键坑点：必须调用 <code>CompleteAdding()</code> 避免消费者永久阻塞，使用后需 <code>Dispose</code> 释放资源；</p>
</li>
<li>
<p>适用场景：日志收集、任务队列、消息分发、多线程数据处理等生产者 - 消费者场景，优先使用而非手动实现。</p>
</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[PHP 应用性能分析 从假设到数据与修复优先级]]></title>    <link>https://juejin.cn/post/7596906923892817930</link>    <guid>https://juejin.cn/post/7596906923892817930</guid>    <pubDate>2026-01-19T23:44:14.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7596906923892817930" data-draft-id="7596904122866057267" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="PHP 应用性能分析 从假设到数据与修复优先级"/> <meta itemprop="keywords" content="后端,PHP"/> <meta itemprop="datePublished" content="2026-01-19T23:44:14.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="BingoGo"/> <meta itemprop="url" content="https://juejin.cn/user/993614242266077"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            PHP 应用性能分析 从假设到数据与修复优先级
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/993614242266077/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    BingoGo
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-19T23:44:14.000Z" title="Mon Jan 19 2026 23:44:14 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">PHP 应用性能分析 从假设到数据与修复优先级</h2>
<h3 data-id="heading-1">为什么 PHP 应用需要性能分析</h3>
<p>作为 PHP 开发者，你经常要构建可扩展、能支撑高并发、性能稳定的应用。但当系统复杂度或流量上来后，性能瓶颈就会出现，而且这些问题在开发甚至测试阶段往往看不到。</p>
<p>性能分析（profiling）能让你从猜测回到数据。它帮你衡量应用各个环节的性能，精准找出低效点。与其凭感觉优化，不如直接看数据告诉你哪里慢——数据库查询、内存占用还是函数调用。</p>
<p>本文会介绍如何对 PHP 应用做性能分析、常见性能问题、适用工具，以及如何为修复排优先级。
<a href="https://link.juejin.cn?target=https%3A%2F%2Fcatchadmin.com%2Fpost%2F2026-01%2Fprofiling-php-applications-from-assumptions-to-data" target="_blank" title="https://catchadmin.com/post/2026-01/profiling-php-applications-from-assumptions-to-data" ref="nofollow noopener noreferrer">原文 PHP 应用性能分析 从假设到数据与修复优先级</a></p>
<h3 data-id="heading-2">性能分析基础：你需要知道什么</h3>
<p>性能分析的核心是测量与分析应用的资源消耗，例如 CPU、内存和执行时间，帮助你找出真正需要优化的“热区”。</p>
<p>性能分析数据通常能回答这些问题：</p>
<ul>
<li><strong>内存占用</strong>：脚本执行过程中用了多少内存？</li>
<li><strong>执行时间</strong>：哪些函数或模块耗时最长？</li>
<li><strong>数据库查询性能</strong>：哪些查询最慢？总共执行了多少次？</li>
<li><strong>CPU 使用</strong>：哪些函数消耗了最多 CPU 计算？</li>
</ul>
<p>通过这些指标，你就能精准定位性能问题并优化代码。</p>
<h3 data-id="heading-3">PHP 应用常见性能问题</h3>
<p>做性能分析时，下面这些问题最常出现。</p>
<h4 data-id="heading-4">过多的数据库查询</h4>
<p>如果应用频繁与数据库交互，响应就可能变慢，常见原因包括：</p>
<ul>
<li>查询写得低效（取了过多数据、缺少索引）</li>
<li>在循环里执行查询，出现 N+1 问题</li>
</ul>
<p>示例：</p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-variable">$posts</span> = <span class="hljs-variable">$db</span>-&gt;<span class="hljs-title function_ invoke__">query</span>(<span class="hljs-string">"SELECT * FROM posts"</span>);
<span class="hljs-keyword">foreach</span> (<span class="hljs-variable">$posts</span> <span class="hljs-keyword">as</span> <span class="hljs-variable">$post</span>) {
    <span class="hljs-variable">$comments</span> = <span class="hljs-variable">$db</span>-&gt;<span class="hljs-title function_ invoke__">query</span>(<span class="hljs-string">"SELECT * FROM comments WHERE post_id = "</span> . <span class="hljs-variable">$post</span>[<span class="hljs-string">'id'</span>]);
    <span class="hljs-comment">// display posts and comments</span>
}
</code></pre>
<p>如果有 100 篇文章，这段代码会跑 101 次查询（1 次取文章 + 100 次取评论），效率很低。</p>
<h4 data-id="heading-5">低效的循环</h4>
<p>有些代码在大数据集上使用嵌套循环或昂贵操作，执行时间会被放大。</p>
<p>示例：</p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-keyword">foreach</span> (<span class="hljs-variable">$data</span> <span class="hljs-keyword">as</span> <span class="hljs-variable">$item</span>) {
    <span class="hljs-comment">// Performing some heavy operation</span>
    <span class="hljs-variable">$result</span> = <span class="hljs-title function_ invoke__">complexOperation</span>(<span class="hljs-variable">$item</span>);
}
</code></pre>
<p>Profiling 能帮你识别这些循环并衡量耗时，给你优化的抓手。</p>
<h4 data-id="heading-6">内存泄漏</h4>
<p>内存泄漏指对象或变量占用过多内存且无法及时释放。数据量大时，内存会持续增长，导致性能下降甚至崩溃。</p>
<p>示例：</p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-keyword">while</span> (<span class="hljs-variable">$row</span> = <span class="hljs-variable">$result</span>-&gt;<span class="hljs-title function_ invoke__">fetch_assoc</span>()) {
    <span class="hljs-variable">$rows</span>[] = <span class="hljs-variable">$row</span>;
}
</code></pre>
<p>如果 <code>$rows</code> 无限增长，就可能耗尽内存。Profiling 能帮助你识别并优化这类问题。</p>
<h4 data-id="heading-7">缓存策略不佳</h4>
<p>缓存是提速的利器，但策略不当也会拖慢系统，例如：</p>
<ul>
<li>没有缓存数据（每次都从数据库重新查询）</li>
<li>缓存失效策略混乱</li>
</ul>
<h3 data-id="heading-8">PHP 应用性能分析的方法</h3>
<p>下面是几种常见且实用的性能分析方法与工具。</p>
<h4 data-id="heading-9">使用 microtime() 手动性能分析</h4>
<p>对于小范围性能测试，可以用 PHP 内置的 <code>microtime()</code> 记录执行时间。</p>
<p>示例：使用 microtime() 进行基础性能分析</p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-variable">$start_time</span> = <span class="hljs-title function_ invoke__">microtime</span>(<span class="hljs-literal">true</span>);
<span class="hljs-comment">// Simulating some code execution</span>
<span class="hljs-title function_ invoke__">sleep</span>(<span class="hljs-number">2</span>);  <span class="hljs-comment">// Sleep for 2 seconds</span>
<span class="hljs-variable">$end_time</span> = <span class="hljs-title function_ invoke__">microtime</span>(<span class="hljs-literal">true</span>);
<span class="hljs-variable">$execution_time</span> = <span class="hljs-variable">$end_time</span> - <span class="hljs-variable">$start_time</span>;
<span class="hljs-keyword">echo</span> <span class="hljs-string">"Execution time: "</span> . <span class="hljs-variable">$execution_time</span> . <span class="hljs-string">" seconds"</span>;
</code></pre>
<p>这种方法简单，但不适合复杂应用，更适合小片段性能检查。</p>
<h4 data-id="heading-10">Xdebug：强大的性能分析工具</h4>
<p>Xdebug 是最常用的 PHP profiling 工具之一，可跟踪函数调用、内存占用和执行时间。它会生成 cachegrind 文件，并可用 KCacheGrind 或 QCacheGrind 可视化分析。</p>
<p>配置 Xdebug 性能分析：</p>
<ol>
<li>安装 Xdebug。</li>
</ol>
<pre><code class="hljs language-bash" lang="bash">sudo apt-get install php-xdebug
</code></pre>
<ol start="2">
<li>在 <code>php.ini</code> 中开启 profiling：</li>
</ol>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">xdebug.profiler_enable</span> = <span class="hljs-number">1</span>
<span class="hljs-attr">xdebug.profiler_output_dir</span> = <span class="hljs-string">"/var/tmp/xdebug_profiles"</span>
</code></pre>
<ol start="3">
<li>运行应用，生成 cachegrind 文件。</li>
<li>用 KCacheGrind 或 QCacheGrind 可视化分析。</li>
</ol>
<p>示例：Xdebug 性能分析输出</p>
<pre><code class="hljs language-text" lang="text">Function Name     Calls  Time   Memory
--------------------------------------
myFunction()       10    0.005  512KB
databaseQuery()    15    0.020  1MB
</code></pre>
<p>在这个例子里，<code>databaseQuery()</code> 耗时更高，说明数据库层可能需要进一步优化。</p>
<h4 data-id="heading-11">Blackfire：现代化性能分析方案</h4>
<p>Blackfire 更现代、体验友好，提供火焰图（flame graph），能直观看到 CPU 和内存耗时。</p>
<p>Blackfire 的特点：</p>
<ul>
<li>自动性能分析：每次 HTTP 请求都可自动分析</li>
<li>对比分析：支持对比优化前后的性能</li>
<li>火焰图（flame graph）：可视化 CPU 与内存消耗</li>
</ul>
<p>使用 Blackfire：</p>
<ol>
<li>在 Blackfire.io 注册并安装 Blackfire Agent 与 Profiler。</li>
<li>在应用里启用性能分析：</li>
</ol>
<pre><code class="hljs language-php" lang="php"><span class="hljs-title class_">Blackfire\Profiler</span>::<span class="hljs-title function_ invoke__">enable</span>();
</code></pre>
<ol start="3">
<li>执行性能分析后，报告中会以火焰图展示代码耗时分布。</li>
</ol>
<h3 data-id="heading-12">解析性能分析数据：把洞察变成行动</h3>
<p>拿到性能分析数据后，关键是判断哪些地方耗资源最多，再决定优化优先级。</p>
<h4 data-id="heading-13">慢函数</h4>
<p>优先找执行时间长的函数。通常是多做了不必要的计算，或处理了过多数据。</p>
<h4 data-id="heading-14">内存占用</h4>
<p>如果脚本吃内存过多，检查是否有大对象或数组长期保留。可以考虑释放内存或改成流式处理。</p>
<h4 data-id="heading-15">低效的数据库查询</h4>
<p>慢查询通常是性能的最大瓶颈。可考虑加索引、缓存，或重写查询逻辑。</p>
<p>示例：</p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-comment">// Inefficient:</span>
<span class="hljs-keyword">foreach</span> (<span class="hljs-variable">$posts</span> <span class="hljs-keyword">as</span> <span class="hljs-variable">$post</span>) {
    <span class="hljs-variable">$comments</span> = <span class="hljs-variable">$db</span>-&gt;<span class="hljs-title function_ invoke__">query</span>(<span class="hljs-string">"SELECT * FROM comments WHERE post_id = "</span> . <span class="hljs-variable">$post</span>[<span class="hljs-string">'id'</span>]);
}
<span class="hljs-comment">// Optimized:</span>
<span class="hljs-variable">$post_ids</span> = <span class="hljs-title function_ invoke__">implode</span>(<span class="hljs-string">','</span>, <span class="hljs-title function_ invoke__">array_column</span>(<span class="hljs-variable">$posts</span>, <span class="hljs-string">'id'</span>));
<span class="hljs-variable">$comments</span> = <span class="hljs-variable">$db</span>-&gt;<span class="hljs-title function_ invoke__">query</span>(<span class="hljs-string">"SELECT * FROM comments WHERE post_id IN (<span class="hljs-subst">$post_ids</span>)"</span>);
</code></pre>
<p>这种改写把多次查询变成一次查询，性能明显更好。</p>
<h3 data-id="heading-16">修复优先级：先从哪里下手</h3>
<p>拿到数据后，应该优先处理收益最大的地方：</p>
<ul>
<li><strong>用户体验优先</strong>：直接影响页面响应的慢点必须先解决。</li>
<li><strong>修复成本</strong>：大规模重构要衡量投入产出，先做小改动的高收益优化。</li>
<li><strong>高影响区域</strong>：数据库查询、内存占用和 CPU 密集的函数往往最值得先动手。</li>
</ul>
<p>比如，如果频繁调用的函数存在内存泄漏，修复它会在高并发下带来显著收益。</p>
<h3 data-id="heading-17">结语：性能分析对 PHP 性能优化的价值</h3>
<p>性能分析让性能优化有数据支撑。你不再靠直觉找瓶颈，而是通过量化结果准确定位问题。无论是 <code>microtime()</code>、Xdebug 还是 Blackfire，性能分析都能给你足够的洞察来做出有效优化。</p>
<p>养成定期性能分析的习惯，可以让你的 PHP 应用在流量和复杂度增长时依然保持性能稳定。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[从 Anthropic 封杀与苹果谷歌结盟，看 AI 护城河的构建 -- 肘子的 Swift 周报 #119]]></title>    <link>https://juejin.cn/post/7596962344044494888</link>    <guid>https://juejin.cn/post/7596962344044494888</guid>    <pubDate>2026-01-19T23:47:50.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7596962344044494888" data-draft-id="7596153767872462882" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="从 Anthropic 封杀与苹果谷歌结盟，看 AI 护城河的构建  -- 肘子的 Swift 周报 #119"/> <meta itemprop="keywords" content="Swift,SwiftUI,人工智能"/> <meta itemprop="datePublished" content="2026-01-19T23:47:50.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="东坡肘子"/> <meta itemprop="url" content="https://juejin.cn/user/1548526032528727"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            从 Anthropic 封杀与苹果谷歌结盟，看 AI 护城河的构建  -- 肘子的 Swift 周报 #119
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1548526032528727/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    东坡肘子
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-19T23:47:50.000Z" title="Mon Jan 19 2026 23:47:50 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读10分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c4b40df9e0804e3987022e73cf363fc9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lic5Z2h6IKY5a2Q:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769471269&amp;x-signature=wb3c0JNme5oq8O6DuaNh7iEquIA%3D" alt="issue119.webp" loading="lazy"/></p>
<h2 data-id="heading-0">从 Anthropic 封杀与苹果谷歌结盟，看 AI 护城河的构建</h2>
<p>2026 年伊始，AI 界便迎来了两记重磅消息。</p>
<p>首先是 Anthropic 痛下杀手，禁止第三方命令行工具（CLI）和“套壳”软件调用 Claude 的个人订阅账号（Pro/Max）。官方意图非常明显：堵住利用低价订阅“薅”高价 API 羊毛的漏洞，并将这种高效的编码体验收归为官方工具 Claude Code 的专属护城河。</p>
<p>紧接着，苹果正式确认与谷歌达成深度合作。Gemini 将成为 Siri 及 Apple Intelligence 后端推理、逻辑处理的主力基石。这意味着，在苹果的 AI 版图中，谷歌凭借其在云计算和 TPU 算力上的深厚积累成为了“基础设施”，而 OpenAI 的角色则被重新定位为可选的“高级插件”。</p>
<p>这两个看似独立的新闻，揭示了 2026 年 AI 行业的一个显著趋势：随着大模型能力的边际效应递减，单纯的“智力”已不再是唯一的壁垒，各家公司正在疯狂构建属于自己的差异化护城河。</p>
<p>Anthropic 选择了“垂直整合”，通过强绑定 Claude Code 与订阅计划，将模型能力固化为不可替代的工作流体验；而谷歌则赢在了“规模效应”，凭借 TPU 集群带来的极致成本控制和稳定性，拿下了苹果这张通往十亿用户的船票。</p>
<p>2025 年，我们还在为“哪个模型更聪明”而频繁切换订阅，各家服务虽各有千秋，但可替代性强。进入 2026 年，这种“同质化竞争”的窗口期已临近关闭。</p>
<p>在烧钱如流水的 AI 赛道，留给“不错但平庸”的中间派的时间已经不多了。无论你是拥有极致的成本优势（如 Google），还是拥有独占的杀手级工作流（如 Anthropic），你必须具备一个竞争对手无法轻易复制的“特质”。</p>
<p>我目前仍有 4 个不同的 AI 服务订阅，我相信不用到年底，留 2 个订阅或许就能满足我的全部需求。</p>
<p>2026 年的主轴将不再是跑分榜上的数字游戏，而是通过价格壁垒或极致体验，提供切实打动 B 端与 C 端的生存理由。</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Ffatbobman.com%2Fzh%2Fweekly%2Fissue-119%2F" target="_blank" title="https://fatbobman.com/zh/weekly/issue-119/" ref="nofollow noopener noreferrer">本期内容</a> | <a href="https://link.juejin.cn?target=https%3A%2F%2Ffatbobman.com%2Fzh%2Fweekly%2Fissue-118%2F" target="_blank" title="https://fatbobman.com/zh/weekly/issue-118/" ref="nofollow noopener noreferrer">前一期内容</a> | <a href="https://link.juejin.cn?target=https%3A%2F%2Ffatbobman.com%2Fzh%2Fweekly%2F" target="_blank" title="https://fatbobman.com/zh/weekly/" ref="nofollow noopener noreferrer">全部周报列表</a></p>
<blockquote>
<p>🚀 <strong>《肘子的 Swift 周报》</strong></p>
<p>每周为你精选最值得关注的 Swift、SwiftUI 技术动态</p>
<ul>
<li><strong>📮 立即订阅</strong> | <a href="https://link.juejin.cn?target=https%3A%2F%2Fweekly.fatbobman.com%2Ffatbobman" target="_blank" title="https://weekly.fatbobman.com/fatbobman" ref="nofollow noopener noreferrer">weekly.fatbobman.com</a> 获取完整内容</li>
<li><strong>👥 加入社区</strong> | <a href="https://link.juejin.cn?target=https%3A%2F%2Fdiscord.com%2Finvite%2F7FedN5E2QQ" target="_blank" title="https://discord.com/invite/7FedN5E2QQ" ref="nofollow noopener noreferrer">Discord</a> 与 2000+ 开发者交流</li>
<li><strong>📚 深度教程</strong> | <a href="https://link.juejin.cn?target=http%3A%2F%2Ffatbobman.com" target="_blank" title="http://fatbobman.com" ref="nofollow noopener noreferrer">fatbobman.com</a> 探索 200+ 原创文章</li>
</ul>
</blockquote>
<h2 data-id="heading-1">近期推荐</h2>
<h3 data-id="heading-2"><a href="https://link.juejin.cn?target=https%3A%2F%2Fl.fatbobman.com%2Fsb-tuist%3Futm_source%3Dfatbobman%26utm_medium%3Dsocial%26utm_content%3Djuejin%26utm_term%3Dweekly-119" target="_blank" title="https://l.fatbobman.com/sb-tuist?utm_source=fatbobman&amp;utm_medium=social&amp;utm_content=juejin&amp;utm_term=weekly-119" ref="nofollow noopener noreferrer">AI 速度快，你的构建也应如此</a></h3>
<p>通过构建缓存、选择性测试以及可操作的洞察，让你的构建、测试运行和 CI 工作流飞速运转，让你的 AI 代理获得更快的反馈和更可靠的结果。</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fl.fatbobman.com%2Fsb-tuist%3Futm_source%3Dfatbobman%26utm_medium%3Dsocial%26utm_content%3Djuejin%26utm_term%3Dweekly-119" target="_blank" title="https://l.fatbobman.com/sb-tuist?utm_source=fatbobman&amp;utm_medium=social&amp;utm_content=juejin&amp;utm_term=weekly-119" ref="nofollow noopener noreferrer">立即体验 →</a></p>
<hr/>
<h3 data-id="heading-3"><a href="https://link.juejin.cn?target=https%3A%2F%2Ffatbobman.com%2Fzh%2Fposts%2Fsurviving-tvos%2F%3Futm_source%3Dfatbobman%2520weekly%2520issue%2520119%26utm_medium%3Dweb" target="_blank" title="https://fatbobman.com/zh/posts/surviving-tvos/?utm_source=fatbobman%20weekly%20issue%20119&amp;utm_medium=web" ref="nofollow noopener noreferrer">在 tvOS 上活下來：一個非典型播放器的工程實錄</a></h3>
<p>在苹果庞大的硬件生态中，Apple TV 往往处于一个略显尴尬的位置：它在客厅场景中拥有稳定且忠实的用户群，却始终不是多数开发者的优先目标，投入与回报的不确定性也让不少人望而却步。<a href="https://link.juejin.cn?target=https%3A%2F%2Fx.com%2Fllqoli" target="_blank" title="https://x.com/llqoli" ref="nofollow noopener noreferrer">Ronnie Wong</a> 以一款非典型播放器为切入点，回顾了她在 tvOS 开发过程中的真实经历——从平台限制、交互差异，到工程取舍与妥协。这篇文章这篇文章没有试图粉饰 tvOS 开发的痛点，而是如实呈现了在这一“小众但独特”的平台上，开发者如何在现实条件中做出理性选择并“活下来”。</p>
<hr/>
<h3 data-id="heading-4"><a href="https://link.juejin.cn?target=https%3A%2F%2Fl.fatbobman.com%2Fw0119-01" target="_blank" title="https://l.fatbobman.com/w0119-01" ref="nofollow noopener noreferrer">@_exported import vs. public import</a></h3>
<p>Swift 6 引入了一个并不显眼、却影响深远的新特性：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fswiftlang%2Fswift-evolution%2Fblob%2Fmain%2Fproposals%2F0409-access-level-on-imports.md" target="_blank" title="https://github.com/swiftlang/swift-evolution/blob/main/proposals/0409-access-level-on-imports.md" ref="nofollow noopener noreferrer">Access-level modifiers on import declarations</a>。该提案要求开发者在使用 <code>import</code> 时显式声明访问级别，以减少依赖无意外泄、避免模块接口被“悄然污染”。在本文中，<a href="https://link.juejin.cn?target=https%3A%2F%2Fx.com%2F_al_we" target="_blank" title="https://x.com/_al_we" ref="nofollow noopener noreferrer">Alexander Weiß</a> 系统讲解了这一机制的设计初衷与使用注意事项，并重点对比了 <code>public import</code> 与 <code>@_exported import</code> 在模块接口暴露、依赖传递以及 API 设计层面的实际差异，解释了为什么前者往往并不能实现开发者直觉中的“重导出”效果。这对于正在构建 SDK、Swift Package，或希望明确模块边界的开发者来说，具有很强的现实指导意义。</p>
<blockquote>
<p>我在读完这篇文章后，已经在当前项目以及部分第三方库中启用了 <code>InternalImportsByDefault</code>，并立刻迎来了一批编译错误，多少重温了刚接触严格并发时的体验。不过，相比并发相关的问题，这类错误通常更直观、也更容易修复。建议你尽早开启这一设置，以避免在未来官方默认启用时，集中面对更大规模的迁移成本。</p>
</blockquote>
<hr/>
<h3 data-id="heading-5"><a href="https://link.juejin.cn?target=https%3A%2F%2Fl.fatbobman.com%2Fw0119-02" target="_blank" title="https://l.fatbobman.com/w0119-02" ref="nofollow noopener noreferrer">Universal Links at Scale：那些鲜有人提及的规模化挑战 (Universal Links At Scale: The Challenges Nobody Talks About)</a></h3>
<p>Universal Links 的原理和实现本身并不复杂，也因此常常给人一种“简单而优雅”的错觉。但一旦进入大规模应用、多个域名、复杂路由和长期演进的真实场景，其复杂度会迅速显现。在本文中，<a href="https://link.juejin.cn?target=https%3A%2F%2Fx.com%2Falbertodebo" target="_blank" title="https://x.com/albertodebo" ref="nofollow noopener noreferrer">Alberto De Bortoli</a> 结合自身在大型项目中的实践经验，系统梳理了 Universal Links 在规模化使用时常被忽视的问题：AASA 文件的维护成本、缓存与生效时机的不确定性、多环境与多团队协作下的风险，以及调试与回滚几乎没有“安全网”的现实困境。Alberto 提醒开发者在设计深度链接方案时，必须提前为“规模效应”做好准备。</p>
<hr/>
<h3 data-id="heading-6"><a href="https://link.juejin.cn?target=https%3A%2F%2Fl.fatbobman.com%2Fw0119-03" target="_blank" title="https://l.fatbobman.com/w0119-03" ref="nofollow noopener noreferrer">当模块化遇到资源重复问题 (Swift Modules and Code/Assets Duplication)</a></h3>
<p>随着 Swift 模块化程度的不断加深，资源（CodeAssets）管理逐渐成为一个容易被忽视、却可能在规模化项目中引发实际问题的领域。<a href="https://link.juejin.cn?target=https%3A%2F%2Fx.com%2Fpfandrade_" target="_blank" title="https://x.com/pfandrade_" ref="nofollow noopener noreferrer">Paulo Andrade</a> 通过具体示例分析了 Swift 模块与 CodeAssets 在多模块依赖场景下产生重复打包与体积膨胀的问题，解释了其背后的构建与链接机制，并探讨了当前工具链下可行的规避策略。Paulo 提醒开发者：模块化并不仅仅是 API 与依赖关系的设计，资源的边界与归属同样需要被认真对待。</p>
<hr/>
<h3 data-id="heading-7"><a href="https://link.juejin.cn?target=https%3A%2F%2Fl.fatbobman.com%2Fw0119-04" target="_blank" title="https://l.fatbobman.com/w0119-04" ref="nofollow noopener noreferrer">使用 SwiftUI 构建文档型应用 (Crafting document-based apps in SwiftUI)</a></h3>
<p>文档型应用（Document-Based App）是一个既常见、却常被低估复杂度的应用形态。相比普通应用，其文件生命周期管理、权限与安全作用域，以及与系统文档浏览体验的协同方式，对不少开发者而言都较为陌生。 在本文中，<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.linkedin.com%2Fin%2Ffonztara%2F" target="_blank" title="https://www.linkedin.com/in/fonztara/" ref="nofollow noopener noreferrer">Alfonso Tarallo</a> 以 SwiftUI 为核心，系统梳理了构建文档型应用所需的关键组成部分，包括 <code>FileDocument</code>、<code>DocumentGroup</code> 的职责划分，以及 SwiftUI 如何与系统文件机制协同工作。</p>
<hr/>
<h3 data-id="heading-8"><a href="https://link.juejin.cn?target=https%3A%2F%2Fl.fatbobman.com%2Fw0119-05" target="_blank" title="https://l.fatbobman.com/w0119-05" ref="nofollow noopener noreferrer">Swift 2026 生态现状 (State of Swift 2026)</a></h3>
<p>这是一篇围绕 Swift 生态的深度观察与趋势研判。文章将 2025 年定义为 Swift 的“变革之年”，详细梳理了并发模型从“严格”向“平易近人（Approachable）”的演进路径，以及服务端（如 Apple 密码服务迁移案例）与 Android 开发的实质性突破。作者没有回避社区关于 SwiftUI 与 AppKit 的架构争议，而是客观分析了其中的机遇与挑战。相比于单纯的技术清单，本文更像是一份战略报告，帮助开发者在日常代码之外，看清 Swift 正从单一的“App 语言”向全场景安全语言蜕变的宏观图景。</p>
<hr/>
<h3 data-id="heading-9"><a href="https://link.juejin.cn?target=https%3A%2F%2Fl.fatbobman.com%2Fw0119-06" target="_blank" title="https://l.fatbobman.com/w0119-06" ref="nofollow noopener noreferrer">和 ChaoCode 一起学 CS146S</a></h3>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fthemodernsoftware.dev%2F" target="_blank" title="https://themodernsoftware.dev/" ref="nofollow noopener noreferrer">CS146S</a> 是斯坦福大学开设的一门前沿计算机科学课程，全名为 "CS146S: The Modern Software Developer"。该课程的核心理念在于教导学生利用最新的 AI 工具（如 LLMs、Cursor、Claude 等）将开发效率提升 10 倍，从单纯的“代码编写者”转变为“AI 智能体的指挥官”。</p>
<p>如果你对这门课程感兴趣，但面对大量的英文阅读材料和纯文本 Slides 感到枯燥或畏难，那么 <a href="https://link.juejin.cn?target=https%3A%2F%2Fx.com%2Fjanechao_dev" target="_blank" title="https://x.com/janechao_dev" ref="nofollow noopener noreferrer">ChaoCode</a> (Jane) 刚刚开启的这个“伴读”系列可能正是你需要的。Jane 以“视觉学习者”的视角，通过视频形式记录并分享了这门课程的学习过程。她不仅将原始 Slides 整理成了繁体中文/英文双语版本，补充了原版缺失的讲者注释，还专门维护了一个 <a href="https://link.juejin.cn?target=https%3A%2F%2Fchaocode.notion.site%2Fcs146s" target="_blank" title="https://chaocode.notion.site/cs146s" ref="nofollow noopener noreferrer">Notion 页面</a> 来整合所有的学习资源与作业。这不是一个课程搬运，而是一个“Learning in Public”的最佳实践。</p>
<h2 data-id="heading-10">工具</h2>
<h3 data-id="heading-11"><a href="https://link.juejin.cn?target=https%3A%2F%2Fl.fatbobman.com%2Fw0119-07" target="_blank" title="https://l.fatbobman.com/w0119-07" ref="nofollow noopener noreferrer">Axiom：面向 iOS 开发的 Claude Code Agent 集合</a></h3>
<p>Axiom 是由 <a href="https://link.juejin.cn?target=https%3A%2F%2Fbsky.app%2Fprofile%2Fwiltgen.net" target="_blank" title="https://bsky.app/profile/wiltgen.net" ref="nofollow noopener noreferrer">Charles Wiltgen</a> 维护的一套面向 iOS 开发者的 Claude Code Agents 与 Skills 知识体系。它将大量真实项目中反复出现的开发任务、排障流程与最佳实践，系统整理为可复用的 Skills、Agents 与 Commands，覆盖 Swift 6、SwiftUI、并发、数据持久化、调试、可访问性以及 Apple Intelligence 等多个方向。</p>
<p>Axiom 尝试回答另一个问题：如何把经验丰富的工程判断，系统化地交给 AI 助手执行。作者也鼓励使用者在 <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.reddit.com%2Fr%2Faxiomdev%2F" target="_blank" title="https://www.reddit.com/r/axiomdev/" ref="nofollow noopener noreferrer">Reddit 的 axiomdev 板块</a> 中交流实践经验与反馈。</p>
<hr/>
<h3 data-id="heading-12"><a href="https://link.juejin.cn?target=https%3A%2F%2Fl.fatbobman.com%2Fw0119-08" target="_blank" title="https://l.fatbobman.com/w0119-08" ref="nofollow noopener noreferrer">BibTeXKit：类型安全的 BibTeX 解析库</a></h3>
<p>BibTeX 文件是一种基于文本的文献数据库格式，广泛用于 LaTeX 文档体系中管理参考文献。通过维护独立的 <code>.bib</code> 文件，用户可以集中存储并复用文献的元数据，在排版阶段由工具自动完成引用与格式化。</p>
<p>由 <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.linkedin.com%2Fin%2Fezefranca%2F" target="_blank" title="https://www.linkedin.com/in/ezefranca/" ref="nofollow noopener noreferrer">Ezequiel Santos</a> 开发的 BibTeXKit 是一个使用 Swift 编写的 BibTeX 解析与建模库，目标非常明确：为 Swift 项目提供一套类型安全、可扩展的 BibTeX 处理能力。它将 BibTeX 文件中的条目、字段与引用关系映射为清晰的 Swift 数据结构，避免了停留在字符串层面反复解析与手工处理所带来的复杂性，更适合作为文献管理类工具或研究型应用的底层组件。</p>
<hr/>
<h3 data-id="heading-13"><a href="https://link.juejin.cn?target=https%3A%2F%2Fl.fatbobman.com%2Fw0119-09" target="_blank" title="https://l.fatbobman.com/w0119-09" ref="nofollow noopener noreferrer">MirageKit：Apple 平台高性能投屏与远程控制框架</a></h3>
<p>MirageKit 是一个由 <a href="https://link.juejin.cn?target=https%3A%2F%2Fx.com%2FEthanLipnik" target="_blank" title="https://x.com/EthanLipnik" ref="nofollow noopener noreferrer">Ethan Lipnik</a> 开发的 Apple 平台专用流媒体框架，旨在实现 macOS 画面向 iOS、visionOS 或另一台 Mac 的低延迟投屏与控制。</p>
<p>该框架充分利用了 Apple 最新的系统特性（需 iOS 26+ / macOS 26+），核心基于 ScreenCaptureKit 与 Metal 构建，利用 UDP 传输视频流并支持 AWDL 点对点连接，在保证画质（支持 1:1 虚拟显示器像素级渲染）的同时实现了极低的延迟。除了单纯的画面传输，MirageKit 还打通了输入反向控制，支持将客户端的键鼠、手势操作甚至原生菜单栏交互回传至主机。对于想要构建高性能远程桌面、副屏应用或 Vision Pro 生产力工具的开发者来说，这是一个非常有潜力的起步方案。</p>
<p>需要注意的是，MirageKit 目前仍处于 <strong>早期且活跃的开发阶段</strong>，API 可能会出现破坏性变更。<a href="https://link.juejin.cn?target=https%3A%2F%2Fx.com%2FEthanLipnik%2Fstatus%2F2012298013558063499" target="_blank" title="https://x.com/EthanLipnik/status/2012298013558063499" ref="nofollow noopener noreferrer">推文</a> 中展示的视频，是 Ethan 基于 MirageKit 构建、仍在开发中的应用演示。</p>
<h2 data-id="heading-14">往期内容</h2>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Ffatbobman.com%2Fzh%2Fweekly%2Fissue-118%2F" target="_blank" title="https://fatbobman.com/zh/weekly/issue-118/" ref="nofollow noopener noreferrer">AT 的人生未必比 MT 更好- #118</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fhttps%3A%2F%2Ffatbobman.com%2Fzh%2Fweekly%2Fissue-117%2F" target="_blank" title="https://https://fatbobman.com/zh/weekly/issue-117/" ref="nofollow noopener noreferrer">2026：当 AI 隐入工作流，你准备好了吗？- #117</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Ffatbobman.com%2Fzh%2Fweekly%2Fissue-116%2F" target="_blank" title="https://fatbobman.com/zh/weekly/issue-116/" ref="nofollow noopener noreferrer">Swift、SwiftUI 与 SwiftData：走向成熟的 2025 - #116</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Ffatbobman.com%2Fzh%2Fweekly%2Fissue-115%2F" target="_blank" title="https://fatbobman.com/zh/weekly/issue-115/" ref="nofollow noopener noreferrer">周日小插曲 - #115</a></li>
</ul>
<h2 data-id="heading-15">💝 支持与反馈</h2>
<p>如果本期周报对你有帮助，请：</p>
<ul>
<li>👍 <strong>点赞</strong> - 让更多开发者看到</li>
<li>💬 <strong>评论</strong> - 分享你的看法或问题</li>
<li>🔄 <strong>转发</strong> - 帮助同行共同成长</li>
</ul>
<hr/>
<blockquote>
<p>🚀 <strong>拓展 Swift 视野</strong></p>
<ul>
<li><strong>📮 邮件订阅</strong> | <a href="https://link.juejin.cn?target=https%3A%2F%2Fweekly.fatbobman.com%2Fwelcome" target="_blank" title="https://weekly.fatbobman.com/welcome" ref="nofollow noopener noreferrer">weekly.fatbobman.com</a> 获取独家技术洞察</li>
<li><strong>👥 开发者社区</strong> | <a href="https://link.juejin.cn?target=https%3A%2F%2Fdiscord.com%2Finvite%2F7FedN5E2QQ" target="_blank" title="https://discord.com/invite/7FedN5E2QQ" ref="nofollow noopener noreferrer">Discord</a> 实时交流开发经验</li>
<li><strong>📚 原创教程</strong> | <a href="https://link.juejin.cn?target=http%3A%2F%2Ffatbobman.com" target="_blank" title="http://fatbobman.com" ref="nofollow noopener noreferrer">fatbobman.com</a> 学习 Swift/SwiftUI 最佳实践</li>
</ul>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[ooder-agent v0.6.2 升级实测：SDK 封装 + Skill 化 VFS，AI 一键生成分布式存储应用]]></title>    <link>https://juejin.cn/post/7596896373053997119</link>    <guid>https://juejin.cn/post/7596896373053997119</guid>    <pubDate>2026-01-19T16:07:13.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7596896373053997119" data-draft-id="7596926832913137727" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="ooder-agent v0.6.2 升级实测：SDK 封装 + Skill 化 VFS，AI 一键生成分布式存储应用"/> <meta itemprop="keywords" content="人工智能"/> <meta itemprop="datePublished" content="2026-01-19T16:07:13.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="OneCodeCN"/> <meta itemprop="url" content="https://juejin.cn/user/1427583415622366"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            ooder-agent v0.6.2 升级实测：SDK 封装 + Skill 化 VFS，AI 一键生成分布式存储应用
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1427583415622366/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    OneCodeCN
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-19T16:07:13.000Z" title="Mon Jan 19 2026 16:07:13 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>作为一名深耕分布式Agent框架的开发者，我踩过最多的坑，就是<strong>分布式存储的配置复杂、断网数据丢失、自定义应用开发成本高</strong>这三大难题。</p>
<p>直到上手 ooder-agent v0.6.2 版本，我才发现原来分布式存储应用可以这么简单——这次升级直接把两个核心痛点连根拔起：<code>agent-sdk</code> 深度封装降低开发门槛，<code>skill-vfs</code> 变身完整Skill程序适配复杂网络场景，更关键的是，<strong>AI一句话就能生成存储应用，零代码自动部署</strong>。</p>
<p>今天就从技术角度，聊聊这次升级的两大核心亮点和实际使用价值。</p>
<h2 data-id="heading-0">一、核心升级1：agent-sdk 0.6.2 深度封装，开发门槛直降</h2>
<p>本次升级的重中之重，是对 <code>agent-sdk</code> 的全面重构与封装，核心目标就是<strong>让开发者不用关心底层存储实现，专注业务逻辑</strong>。</p>
<h3 data-id="heading-1">1.  统一存储接口，屏蔽底层差异</h3>
<p>SDK 重构了存储模块，将 LocalJsonStorage、VfsJsonStorage、SwitchableJsonStorage 彻底解耦，同时提供标准化的存储操作接口。</p>
<p>不管是本地存储还是分布式VFS存储，开发者调用的都是同一套API，不用写两套逻辑适配不同存储后端。</p>
<h3 data-id="heading-2">2.  零配置集成VFS，开箱即用</h3>
<p>新版本支持 <strong>VFS服务自动发现</strong>，开发者不需要手动配置VFS服务地址、端口等参数。</p>
<p>只要部署了 skill-vfs 服务，SDK就能自动识别并连接，真正做到“代码写完直接跑”。</p>
<h3 data-id="heading-3">3.  模块化+插件化，扩展性拉满</h3>
<p>封装后的SDK采用模块化设计，存储功能与其他核心能力完全解耦。</p>
<p>想要新增S3、HDFS这类存储后端？不用修改SDK核心代码，直接开发对应的存储插件就能集成，扩展性直接拉满。</p>
<h2 data-id="heading-4">二、核心升级2：skill-vfs 变身完整Skill程序，适配分布式不稳定网络</h2>
<p>如果说SDK封装是降低开发门槛，那 <code>skill-vfs</code> 的Skill化改造，就是这次升级的灵魂——它不再是一个单纯的存储服务，而是一个能被 ooder-agent 统一调度的Skill程序。</p>
<h3 data-id="heading-5">1.  作为Skill的全特性兼容，协同能力翻倍</h3>
<p>skill-vfs 继承了Skill程序的所有优良特性：可以被 ooder-agent 统一管理、调度，能和 skill-a（信息检索）、skill-b（数据提交）等其他Skill无缝协作。</p>
<p>比如 skill-a 检索到的文件，能直接调用 skill-vfs 进行存储；skill-b 提交的数据，也能通过 skill-vfs 实现跨设备同步。</p>
<h3 data-id="heading-6">2.  多级VFSServer关联，构建分布式存储网络</h3>
<p>skill-vfs 支持关联多个层级的 VFSServer 分布式存储中心，能根据业务需求配置存储节点的优先级和副本策略。</p>
<p>这意味着你可以搭建“本地节点+云端节点+NAS节点”的多级存储架构，数据多副本备份，再也不怕单点故障。</p>
<h3 data-id="heading-7">3.  离线可用+弱网适配，专治网络不稳定</h3>
<p>这是最戳中分布式场景痛点的功能：</p>
<ul>
<li><strong>断网不翻车</strong>：当分布式VFS服务不可用时，skill-vfs 会自动切换到本地存储，保障业务流程不中断；</li>
<li><strong>网好自动同步</strong>：网络恢复后，本地存储的数据会自动增量同步到VFS服务，不用手动触发；</li>
<li><strong>弱网优化策略</strong>：针对异地办公、IoT设备这类弱网场景，SDK内置了差异同步算法，减少网络传输量，提升同步效率。</li>
</ul>
<h2 data-id="heading-8">三、杀手锏功能：AI一句话生成Skill，零代码自动部署</h2>
<p>这次升级最让我惊喜的，是<strong>AI与框架的深度融合</strong>——不用写一行代码，对着任意AI-IDE（qoder、codebuddy、trae都行）说句话，就能生成分布式存储应用，自动部署到ooder-agent。</p>
<h3 data-id="heading-9">1.  超简单的使用流程，三步搞定</h3>
<ol>
<li><strong>AI-IDE一键编译工程</strong>：导入ooder-agent v0.6.2项目，点击编译按钮，AI-IDE会自动适配JDK/Maven环境，后台自动完成编译；</li>
<li><strong>一句话描述需求</strong>：对着AI-IDE输入你的存储需求，比如：
<ul>
<li>“帮我生成每周自动备份邮件到NAS的Skill程序”</li>
<li>“每天12点打包服务器日志，上传到多级VFSServer”</li>
<li>“照片增量同步到云端和本地NAS，断网自动切本地”</li>
</ul>
</li>
<li><strong>ooder-agent自动部署</strong>：AI生成的Skill程序会自动提交到ooder-agent，平台完成校验、注册、运行全流程，全程无需人工干预。</li>
</ol>
<h3 data-id="heading-10">2.  三个高频实用场景，直接抄作业</h3>

























<table><thead><tr><th align="left">需求场景</th><th align="left">AI指令示例</th><th align="left">实现效果</th></tr></thead><tbody><tr><td align="left">邮件定期备份</td><td align="left">帮我生成每周日晚10点备份邮箱数据到NAS的Skill</td><td align="left">自动触发备份，断网存本地，网好同步到NAS</td></tr><tr><td align="left">服务器日志上传</td><td align="left">每天12点打包服务器/var/log目录日志，上传到三级VFSServer</td><td align="left">日志自动压缩、上传、多副本存储，支持检索</td></tr><tr><td align="left">照片增量同步</td><td align="left">监测本地相册文件夹，增量同步到云端和家庭NAS</td><td align="left">手机拍的照片，电脑/NAS实时更新，删除操作双向同步</td></tr></tbody></table>
<h2 data-id="heading-11">四、升级后的实际价值：对开发者和运维的双重友好</h2>
<ol>
<li><strong>开发者：效率提升10倍</strong>
不用再写繁琐的存储适配代码，SDK统一接口+AI生成Skill，一天能开发的应用数量，顶之前一周的工作量。</li>
<li><strong>运维：管理成本骤降</strong>
所有Skill程序由ooder-agent统一调度，存储节点状态、同步进度、异常信息一目了然，不用逐个服务排查。</li>
<li><strong>分布式场景：稳定性拉满</strong>
离线切换+弱网适配+多级存储，不管是异地办公、IoT设备协同还是企业级分布式部署，都能稳稳hold住。</li>
</ol>
<h2 data-id="heading-12">五、总结与展望</h2>
<p>ooder-agent v0.6.2 这次升级，不是简单的功能堆砌，而是<strong>从“工具”到“生态”的进化</strong>：SDK封装降低开发门槛，Skill化VFS适配复杂场景，AI融合让零代码开发成为可能。</p>
<p>对于想要搭建分布式存储应用、或者基于Agent架构开发业务的团队来说，这个版本值得立刻上手。</p>
<p>未来如果能支持更多AI模型生成更复杂的Skill逻辑，并且打通更多第三方存储服务（比如阿里云OSS、腾讯云COS），这个生态的潜力会更大。</p>
<p>最后附上项目地址，感兴趣的朋友可以直接冲：</p>
<ul>
<li>项目仓库：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fooder-project%2Fsuper-agent" target="_blank" title="https://github.com/ooder-project/super-agent" ref="nofollow noopener noreferrer">github.com/ooder-proje…</a></li>
<li>文档地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fooder-project.github.io%2Fsuper-agent-docs%2F" target="_blank" title="https://ooder-project.github.io/super-agent-docs/" ref="nofollow noopener noreferrer">ooder-project.github.io/super-agent…</a></li>
</ul>
<p>#ooder-agent #分布式存储 #Agent框架 #AI开发工具 #程序员日常</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[极限科技 Coco AI 荣获 2025 IT168 技术卓越奖 - 创新产品奖]]></title>    <link>https://juejin.cn/post/7596874823722516514</link>    <guid>https://juejin.cn/post/7596874823722516514</guid>    <pubDate>2026-01-19T15:10:51.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7596874823722516514" data-draft-id="7596874823722500130" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="极限科技 Coco AI 荣获 2025 IT168 技术卓越奖 - 创新产品奖"/> <meta itemprop="keywords" content="产品"/> <meta itemprop="datePublished" content="2026-01-19T15:10:51.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="极限实验室"/> <meta itemprop="url" content="https://juejin.cn/user/1258294223312599"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            极限科技 Coco AI 荣获 2025 IT168 技术卓越奖 - 创新产品奖
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1258294223312599/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    极限实验室
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-19T15:10:51.000Z" title="Mon Jan 19 2026 15:10:51 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>北京，2026 年 1 月 —— 在由 <strong>IT168</strong> 主办的“<strong>2025 年度技术卓越奖</strong>”评选中，<strong>极限数据（北京）科技有限公司</strong>（简称：<a href="https://link.juejin.cn?target=https%3A%2F%2Finfinilabs.cn%2F" target="_blank" title="https://infinilabs.cn/" ref="nofollow noopener noreferrer">极限科技</a>）的人工智能产品 <strong>Coco AI</strong> 凭借其创新的技术架构与突出的市场实践，荣获 “创新产品奖”。该奖项旨在表彰在  AI、大数据、云计算等领域实现关键突破、具备显著应用价值与市场潜力的产品与解决方案。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9946968c39be4a7cad2d61a4fba38a02~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p6B6ZmQ5a6e6aqM5a6k:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769440251&amp;x-signature=S7DYyto3W1cJcQHwHrJ0m%2F7ecUY%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-0">奖项与产品信息</h2>
<p>获奖企业：极限数据（北京）科技有限公司<br/>
获奖产品：Coco AI – 统一搜索与 AI 智能助手<br/>
产品官网：<a href="https://link.juejin.cn?target=https%3A%2F%2Fcoco.rs%2Fzh" target="_blank" title="https://coco.rs/zh" ref="nofollow noopener noreferrer">coco.rs/zh</a><br/>
开源地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Finfinilabs%2Fcoco-app" target="_blank" title="https://github.com/infinilabs/coco-app" ref="nofollow noopener noreferrer">github.com/infinilabs/…</a><br/>
评选榜单：<a href="https://link.juejin.cn?target=https%3A%2F%2Fzt.itpub.net%2Ftopic%2Fjishuzhuoyue251215" target="_blank" title="https://zt.itpub.net/topic/jishuzhuoyue251215" ref="nofollow noopener noreferrer">zt.itpub.net/topic/jishu…</a></p>
<h2 data-id="heading-1">关于  Coco AI</h2>
<p>Coco AI 是极限科技推出的一款 <strong>完全开源、可私有部署</strong>的统一搜索与  AI 智能助手系统，专为企业打造。它致力于解决企业数据分散、信息孤岛严重、数据敏感及知识沉睡等核心痛点。</p>
<ul>
<li>统一搜索：通过连接本地文件、云存储（S3）、知识库、代码仓库（GitHub）、协作平台（Notion、语雀）、MySQL、MongoDB 等异构数据源，提供跨平台的一站式搜索体验。</li>
<li>AI 赋能：深度融合主流大模型能力，支持语义搜索、自然语言问答、智能推荐，并构建个性化知识图谱，激活企业沉睡数据。</li>
<li>安全可控：支持企业级权限管理、数据脱敏与加密，可完全私有化部署，确保数据安全合规。</li>
<li>灵活扩展：采用 MCP 架构，支持模型动态调用外部工具，无需修改核心代码即可灵活扩展 AI 应用场景。</li>
</ul>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ed98f4ec124d43dfbc009ea5db3c3250~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p6B6ZmQ5a6e6aqM5a6k:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769440251&amp;x-signature=raoMRupGAeKmtmOl6GzTrndKE3o%3D" alt="" loading="lazy"/></p>
<p>目前，Coco AI 已在多个行业场景中落地，帮助企业构建“智能知识中枢”，提升信息获取效率与决策协作水平。</p>
<h2 data-id="heading-2">获奖理由</h2>
<p>IT168 技术卓越奖评审委员会认为，Coco AI 的获奖主要基于以下几点：</p>
<ol>
<li><strong>技术创新</strong>：将企业搜索、RAG、知识图谱与大模型能力深度融合，构建了面向真实业务场景的“搜索+AI”一体化平台，技术路径清晰且具备前瞻性。</li>
<li><strong>开源开放</strong>：产品完全开源并支持私有化部署，为企业提供了兼顾自主可控与成本效益的 AI 搜索解决方案，对推动基础软件与 AI 应用生态繁荣具有积极意义。</li>
<li><strong>实践价值</strong>：已在多个行业完成从技术验证到规模化应用的跨越，帮助企业将分散的知识资产转化为可复用的生产力，在“技术实效”上表现突出。</li>
</ol>
<h2 data-id="heading-3">团队声音</h2>
<p>极限科技总经理、Coco AI 项目负责人曾勇表示：</p>
<blockquote>
<p>“感谢 IT168 和业界同仁对 Coco AI 的认可。在 AI 定义一切的今天，我们始终相信，真正的技术价值在于深入业务场景、解决实际问题。Coco AI 希望为企业打造一个安全、开放、智能的知识入口，让团队在信息海洋中‘搜得到、问得清、用得好’。未来，我们将继续深耕企业搜索与 AI 智能助手领域，与合作伙伴共同推动中国自主 AI 产品体系的繁荣发展。”</p>
</blockquote>
<h2 data-id="heading-4">展望未来</h2>
<p>此次获奖，不仅是行业对我们技术路径的认可，更是对 “开源创新、自主实效” 这一发展方向的肯定。极限科技将以此为新的起点，持续深耕 “搜索+AI”核心技术，以  Coco AI  及未来更多开源产品，赋能千行百业夯实智能根基，在全球数字化转型中贡献中国解决方案。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Win11 如何打开 IE11 浏览器]]></title>    <link>https://juejin.cn/post/7596932640726368291</link>    <guid>https://juejin.cn/post/7596932640726368291</guid>    <pubDate>2026-01-19T15:13:15.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7596932640726368291" data-draft-id="7596874823722532898" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Win11 如何打开 IE11 浏览器"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2026-01-19T15:13:15.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="程序员大卫"/> <meta itemprop="url" content="https://juejin.cn/user/1961184474695213"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Win11 如何打开 IE11 浏览器
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1961184474695213/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    程序员大卫
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-19T15:13:15.000Z" title="Mon Jan 19 2026 15:13:15 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    3
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>大家好，我是<strong>前端架构师</strong>，关注微信公众号【@<strong>程序员大卫</strong>】免费领取前端精品资料。</p>
<h2 data-id="heading-0">前言</h2>
<p>有时候在调试老项目时，仍然需要使用 <strong>IE11 浏览器</strong>。但在 <strong>Windows 11</strong> 中，直接打开 IE 时，系统通常会自动跳转到 <strong>Microsoft Edge</strong>，导致无法真正进入 IE11。</p>
<p>下面教你一种<strong>简单、有效</strong>的方法，在 Win11 中直接打开 IE11。</p>
<h2 data-id="heading-1">1. 搜索并打开 cmd</h2>
<p>在开始菜单中搜索 <strong>cmd</strong>，然后点击打开。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/28099663424b407b976ef22ece7a5f86~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY5aSn5Y2r:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769440672&amp;x-signature=NZFlsbM4vDqFki9D%2BZ2WDIPFu14%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-2">2. 粘贴并执行下面的脚本</h2>
<p>将以下命令粘贴到 cmd 中并回车执行：</p>
<pre><code class="hljs language-bash" lang="bash">powershell -<span class="hljs-built_in">command</span> <span class="hljs-string">"<span class="hljs-variable">$pf86</span>=[Environment]::GetFolderPath('ProgramFilesX86');<span class="hljs-variable">$s</span>=New-Object -ComObject WScript.Shell;<span class="hljs-variable">$sc</span>=<span class="hljs-variable">$s</span>.CreateShortcut(\"<span class="hljs-variable">$env</span>:USERPROFILE\Desktop\Internet Explorer.lnk\");<span class="hljs-variable">$sc</span>.TargetPath=\"<span class="hljs-variable">$pf86</span>\Internet Explorer\iexplore.exe\";<span class="hljs-variable">$sc</span>.Arguments='about:blank -Embedding';<span class="hljs-variable">$sc</span>.IconLocation=\"<span class="hljs-variable">$pf86</span>\Internet Explorer\iexplore.exe, 0\";<span class="hljs-variable">$sc</span>.Save()"</span>
</code></pre>
<p>这段脚本会在桌面创建一个 IE 浏览器的<strong>快捷方式</strong>。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8ba3a613d300483ca30773d4a9a9a7a7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY5aSn5Y2r:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769440672&amp;x-signature=hGwyWu8x%2FnNgcOgowICR6aCc5tU%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-3">3. 双击桌面的 IE 图标即可打开</h2>
<p>执行完成后，桌面会出现一个 <strong>Internet Explorer</strong> 图标，双击它即可成功打开 IE11 浏览器。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ae2038a1e631475cbdd93a415944bb61~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY5aSn5Y2r:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769440672&amp;x-signature=puOO6iiNLjrr8p757QS%2FnLLf5d0%3D" alt="" loading="lazy"/></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[React Native之Android端Fabric 架构源码分析（下）]]></title>    <link>https://juejin.cn/post/7596896373053915199</link>    <guid>https://juejin.cn/post/7596896373053915199</guid>    <pubDate>2026-01-19T15:15:48.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7596896373053915199" data-draft-id="7593731473490214975" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="React Native之Android端Fabric 架构源码分析（下）"/> <meta itemprop="keywords" content="React Native,Android,源码阅读"/> <meta itemprop="datePublished" content="2026-01-19T15:15:48.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="编程之路从0到1"/> <meta itemprop="url" content="https://juejin.cn/user/4125023359744296"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            React Native之Android端Fabric 架构源码分析（下）
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4125023359744296/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    编程之路从0到1
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-19T15:15:48.000Z" title="Mon Jan 19 2026 15:15:48 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读18分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">React Native之Android端Fabric 架构源码分析（下）</h2>
<blockquote>
<p>由于单章字数限制，这里将本文拆成上下两篇，上篇<a href="https://juejin.cn/post/7596869784538824704" target="_blank" title="https://juejin.cn/post/7596869784538824704">《React Native之Android端Fabric 架构源码分析（上）》</a></p>
</blockquote>
<h3 data-id="heading-1">Fabric 组件</h3>
<h4 data-id="heading-2">声明组件</h4>
<p>要开发一个Fabric 组件，首先需要在TS代码中声明规范。我们使用<code>npx create-react-native-library@latest</code>创建一个Fabric组件库，然后参考根据官方文档的<a href="https://link.juejin.cn?target=https%3A%2F%2Freactnative.dev%2Fdocs%2Ffabric-native-components-introduction" target="_blank" title="https://reactnative.dev/docs/fabric-native-components-introduction" ref="nofollow noopener noreferrer">示例</a>添加如下内容：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> {
  <span class="hljs-title class_">CodegenTypes</span>,
  <span class="hljs-title class_">HostComponent</span>,
  <span class="hljs-title class_">ViewProps</span>,
} <span class="hljs-keyword">from</span> <span class="hljs-string">'react-native'</span>;
<span class="hljs-keyword">import</span> {codegenNativeComponent} <span class="hljs-keyword">from</span> <span class="hljs-string">'react-native'</span>;

<span class="hljs-keyword">type</span> <span class="hljs-title class_">WebViewScriptLoadedEvent</span> = {
  <span class="hljs-attr">result</span>: <span class="hljs-string">'success'</span> | <span class="hljs-string">'error'</span>;
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">NativeProps</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ViewProps</span> {
  sourceURL?: <span class="hljs-built_in">string</span>;
  onScriptLoaded?: <span class="hljs-title class_">CodegenTypes</span>.<span class="hljs-property">BubblingEventHandler</span>&lt;<span class="hljs-title class_">WebViewScriptLoadedEvent</span>&gt; | <span class="hljs-literal">null</span>;
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> codegenNativeComponent&lt;<span class="hljs-title class_">NativeProps</span>&gt;(
  <span class="hljs-string">'CustomWebView'</span>,
) <span class="hljs-keyword">as</span> <span class="hljs-title class_">HostComponent</span>&lt;<span class="hljs-title class_">NativeProps</span>&gt;;
</code></pre>
<p>这里主要有三部分：</p>
<ul>
<li>
<p><code>WebViewScriptLoadedEvent</code> 是一种支持的数据类型，用于存储事件需要从原生代码传递到 JavaScript 的数据。</p>
</li>
<li>
<p><code>NativeProps</code> 定义了可以设置的组件属性。</p>
</li>
<li>
<p><code>codegenNativeComponent</code> 允许我们为自定义组件生成代码，并为组件定义一个与原生实现相匹配的名称。</p>
</li>
</ul>
<p>其中，对<code>codegenNativeComponent</code>函数进行分析，源码<code>react-native/packages/react-native/Libraries/Utilities/codegenNativeComponent.js</code>:</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 如果这个函数运行，说明视图配置没有在构建时通过 `GenerateViewConfigJs.js` 生成。</span>
<span class="hljs-comment">// 因此我们需要使用 `requireNativeComponent` 从视图管理器获取视图配置。</span>
<span class="hljs-comment">// `requireNativeComponent` 在 Bridgeless 模式下不可用。</span>
<span class="hljs-comment">// 例如：如果 `codegenNativeComponent` 不是从以 NativeComponent.js 结尾的文件中调用，</span>
<span class="hljs-comment">// 这个函数就会在运行时执行。</span>
<span class="hljs-keyword">function</span> codegenNativeComponent&lt;<span class="hljs-title class_">Props</span>: {...}&gt;(
  <span class="hljs-attr">componentName</span>: string,
  options?: <span class="hljs-title class_">NativeComponentOptions</span>,
): <span class="hljs-title class_">NativeComponentType</span>&lt;<span class="hljs-title class_">Props</span>&gt; {
  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">global</span>.<span class="hljs-property">RN$Bridgeless</span> === <span class="hljs-literal">true</span> &amp;&amp; __DEV__) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(
      <span class="hljs-string">`Codegen didn't run for <span class="hljs-subst">${componentName}</span>. This will be an error in the future. Make sure you are using @react-native/babel-preset when building your JavaScript code.`</span>,
    );
  }
  <span class="hljs-comment">// 确定基础组件名称</span>
  <span class="hljs-keyword">let</span> componentNameInUse =
    options &amp;&amp; options.<span class="hljs-property">paperComponentName</span> != <span class="hljs-literal">null</span>
      ? options.<span class="hljs-property">paperComponentName</span>
      : componentName;

  <span class="hljs-comment">// 省略部分代码......</span>

  <span class="hljs-keyword">return</span> (requireNativeComponent&lt;<span class="hljs-title class_">Props</span>&gt;(
    <span class="hljs-comment">// $FlowFixMe[incompatible-type]</span>
    componentNameInUse,
  ): <span class="hljs-title class_">HostComponent</span>&lt;<span class="hljs-title class_">Props</span>&gt;);
}
</code></pre>
<p>根据注释可知，在新架构中，这个函数几乎没有实际意义，因为新架构是通过<code>GenerateViewConfigJs.js</code> 来生成实际的视图配置。</p>
<p>我们通过搜索<code>codegenNativeComponent</code>字符串，很容易定位到<code>react-native/packages/babel-plugin-codegen/index.js</code>文件，这里<strong>babel-plugin-codegen</strong>包就是检测<code>codegenNativeComponent</code>调用，解析<strong>TypeScript/Flow</strong>类型定义的工具包：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">{parse, types: t}</span>) {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-title function_">pre</span>(<span class="hljs-params">state</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">code</span> = state.<span class="hljs-property">code</span>;
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">filename</span> = state.<span class="hljs-property">opts</span>.<span class="hljs-property">filename</span>;
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">defaultExport</span> = <span class="hljs-literal">null</span>;
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">commandsExport</span> = <span class="hljs-literal">null</span>;
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">codeInserted</span> = <span class="hljs-literal">false</span>;
    },

    <span class="hljs-comment">// 省略部分代码.....</span>
      <span class="hljs-title class_">ExportDefaultDeclaration</span>(path, state) {
        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isCodegenDeclaration</span>(path.<span class="hljs-property">node</span>.<span class="hljs-property">declaration</span>)) {
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">defaultExport</span> = path;
        }
      },

      <span class="hljs-comment">// 程序退出时进行替换</span>
      <span class="hljs-title class_">Program</span>: {
        <span class="hljs-title function_">exit</span>(<span class="hljs-params">path</span>) {
          <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">defaultExport</span>) {
            <span class="hljs-comment">// 1. 生成ViewConfig代码</span>
            <span class="hljs-keyword">const</span> viewConfig = <span class="hljs-title function_">generateViewConfig</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">filename</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">code</span>);
            <span class="hljs-comment">// 2. 解析为AST</span>
            <span class="hljs-keyword">const</span> ast = <span class="hljs-title function_">parse</span>(viewConfig, {
              <span class="hljs-attr">babelrc</span>: <span class="hljs-literal">false</span>,
              <span class="hljs-attr">browserslistConfigFile</span>: <span class="hljs-literal">false</span>,
              <span class="hljs-attr">configFile</span>: <span class="hljs-literal">false</span>,
            });

            <span class="hljs-comment">// 3. 完全替换原始导出</span>
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">defaultExport</span>.<span class="hljs-title function_">replaceWithMultiple</span>(ast.<span class="hljs-property">program</span>.<span class="hljs-property">body</span>);

            <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">commandsExport</span> != <span class="hljs-literal">null</span>) {
              <span class="hljs-variable language_">this</span>.<span class="hljs-property">commandsExport</span>.<span class="hljs-title function_">remove</span>();
            }

            <span class="hljs-variable language_">this</span>.<span class="hljs-property">codeInserted</span> = <span class="hljs-literal">true</span>;
          }
        },
      },
    },
  };
};


<span class="hljs-keyword">function</span> <span class="hljs-title function_">generateViewConfig</span>(<span class="hljs-params">filename <span class="hljs-comment">/*: string */</span>, code <span class="hljs-comment">/*: string */</span></span>) {
  <span class="hljs-comment">// 解析TypeScript/Flow类型</span>
  <span class="hljs-keyword">const</span> schema = <span class="hljs-title function_">parseFile</span>(filename, code);
  <span class="hljs-comment">// 提取组件信息</span>
  <span class="hljs-keyword">const</span> libraryName = <span class="hljs-title function_">basename</span>(filename).<span class="hljs-title function_">replace</span>(
    <span class="hljs-regexp">/NativeComponent\.(js|ts)$/</span>,
    <span class="hljs-string">''</span>,
  );
  <span class="hljs-comment">// 调用Codegen生成器</span>
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">RNCodegen</span>.<span class="hljs-title function_">generateViewConfig</span>({
    libraryName,
    schema,
  });
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">isCodegenDeclaration</span>(<span class="hljs-params">declaration</span>) {
  <span class="hljs-keyword">if</span> (!declaration) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }

  <span class="hljs-keyword">if</span> (
    declaration.<span class="hljs-property">left</span> &amp;&amp;
    declaration.<span class="hljs-property">left</span>.<span class="hljs-property">left</span> &amp;&amp;
    declaration.<span class="hljs-property">left</span>.<span class="hljs-property">left</span>.<span class="hljs-property">name</span> === <span class="hljs-string">'codegenNativeComponent'</span>
  ) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (
    declaration.<span class="hljs-property">callee</span> &amp;&amp;
    declaration.<span class="hljs-property">callee</span>.<span class="hljs-property">name</span> &amp;&amp;
    declaration.<span class="hljs-property">callee</span>.<span class="hljs-property">name</span> === <span class="hljs-string">'codegenNativeComponent'</span>
  ) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  } 
  <span class="hljs-comment">// 省略......</span>
  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}
</code></pre>
<p>继续跟踪<code>RNCodegen.generateViewConfig</code>的实现，源码<code>react-native/packages/react-native-codegen/src/generators/RNCodegen.js</code>：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> generateViewConfigJs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./components/GenerateViewConfigJs.js'</span>);


<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">allGenerators</span>: <span class="hljs-variable constant_">ALL_GENERATORS</span>,
  <span class="hljs-comment">// 省略部分代码......</span>
  <span class="hljs-title function_">generateViewConfig</span>({
    libraryName,
    schema,
  }: <span class="hljs-title class_">Pick</span>&lt;<span class="hljs-title class_">LibraryOptions</span>, <span class="hljs-string">'libraryName'</span> | <span class="hljs-string">'schema'</span>&gt;): string {
    schemaValidator.<span class="hljs-title function_">validate</span>(schema);

    <span class="hljs-keyword">const</span> result = generateViewConfigJs
      .<span class="hljs-title function_">generate</span>(libraryName, schema)
      .<span class="hljs-title function_">values</span>()
      .<span class="hljs-title function_">next</span>();

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> result.<span class="hljs-property">value</span> !== <span class="hljs-string">'string'</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`Failed to generate view config for <span class="hljs-subst">${libraryName}</span>`</span>);
    }

    <span class="hljs-keyword">return</span> result.<span class="hljs-property">value</span>;
  },
};
</code></pre>
<p>最终是调用的<code>GenerateViewConfigJs.js</code>中的<code>generate</code>，源码<code>react-native/packages/react-native-codegen/src/generators/components/GenerateViewConfigJs.js</code>：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-title function_">generate</span>(<span class="hljs-attr">libraryName</span>: string, <span class="hljs-attr">schema</span>: <span class="hljs-title class_">SchemaType</span>): <span class="hljs-title class_">FilesOutput</span> {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> fileName = <span class="hljs-string">`<span class="hljs-subst">${libraryName}</span>NativeViewConfig.js`</span>;
      <span class="hljs-keyword">const</span> <span class="hljs-attr">imports</span>: <span class="hljs-title class_">Set</span>&lt;string&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();

      <span class="hljs-keyword">const</span> moduleResults = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(schema.<span class="hljs-property">modules</span>)
        .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">moduleName</span> =&gt;</span> {
          <span class="hljs-keyword">const</span> <span class="hljs-variable language_">module</span> = schema.<span class="hljs-property">modules</span>[moduleName];
          <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">module</span>.<span class="hljs-property">type</span> !== <span class="hljs-string">'Component'</span>) {
            <span class="hljs-keyword">return</span>;
          }

          <span class="hljs-keyword">const</span> {components} = <span class="hljs-variable language_">module</span>;

          <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(components)
            .<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">componentName: string</span>) =&gt;</span> {
              <span class="hljs-keyword">const</span> component = components[componentName];

              <span class="hljs-keyword">if</span> (component.<span class="hljs-property">paperComponentNameDeprecated</span>) {
                imports.<span class="hljs-title function_">add</span>(<span class="hljs-variable constant_">UIMANAGER_IMPORT</span>);
              }

              <span class="hljs-keyword">const</span> replacedTemplate = <span class="hljs-title class_">ComponentTemplate</span>({
                componentName,
                <span class="hljs-attr">paperComponentName</span>: component.<span class="hljs-property">paperComponentName</span>,
                <span class="hljs-attr">paperComponentNameDeprecated</span>:
                  component.<span class="hljs-property">paperComponentNameDeprecated</span>,
              });
      <span class="hljs-comment">// 省略部分代码...... </span>

      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([[fileName, replacedTemplate]]);
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`\nError parsing schema for <span class="hljs-subst">${libraryName}</span>\n`</span>);
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(schema));
      <span class="hljs-keyword">throw</span> error;
    }
  },
};
</code></pre>
<p>这里我们根据<code>ComponentTemplate</code>中的模板，大概就能还原出生成的代码是什么样子：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 输入：</span>
<span class="hljs-comment">// libraryName: "MyComponent"</span>
<span class="hljs-comment">// schema: { 解析后的TypeScript/Flow类型信息 }</span>

<span class="hljs-comment">// 输出：完整的JavaScript代码字符串</span>
<span class="hljs-meta">

'use strict'</span>;

<span class="hljs-keyword">const</span> {<span class="hljs-title class_">UIManager</span>} = <span class="hljs-built_in">require</span>(<span class="hljs-string">"react-native"</span>)

<span class="hljs-keyword">let</span> nativeComponentName = <span class="hljs-string">'MyComponent'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> __INTERNAL_VIEW_CONFIG = {
  <span class="hljs-attr">uiViewClassName</span>: <span class="hljs-string">'MyComponent'</span>,
  <span class="hljs-attr">bubblingEventTypes</span>: {},
  <span class="hljs-attr">directEventTypes</span>: {},
  <span class="hljs-attr">validAttributes</span>: {
    <span class="hljs-attr">opacity</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">backgroundColor</span>: { <span class="hljs-attr">process</span>: <span class="hljs-built_in">require</span>(<span class="hljs-string">'react-native/Libraries/StyleSheet/processColor'</span>).<span class="hljs-property">default</span> },
    <span class="hljs-comment">// ... 其他属性</span>
  }
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">NativeComponentRegistry</span>.<span class="hljs-title function_">get</span>(nativeComponentName, <span class="hljs-function">() =&gt;</span> __INTERNAL_VIEW_CONFIG);
</code></pre>
<p>这里最关键的就是最后一行，它将开发者编写的Fabric 组件规范进行了代码替换：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 开发者编写</span>
<span class="hljs-keyword">const</span> <span class="hljs-title class_">CustomView</span> = codegenNativeComponent&lt;<span class="hljs-title class_">Props</span>&gt;(<span class="hljs-string">'CustomView'</span>);

<span class="hljs-comment">// Babel插件替换后</span>
<span class="hljs-keyword">const</span> <span class="hljs-title class_">CustomView</span> = <span class="hljs-title class_">NativeComponentRegistry</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">'CustomView'</span>, <span class="hljs-function">() =&gt;</span> __INTERNAL_VIEW_CONFIG);
</code></pre>
<p>需要注意，<strong>babel-plugin-codegen</strong>工具并不像<strong>Codegen</strong>工具，会生成实际的代码文件。它是对AST语法树进行的动态修改和替换，也就是说它修改的是内存中的语法树，并不会写文件。</p>
<p>现在来重点追踪<code>NativeComponentRegistry.get</code>的实现，首先是导出位置<code>react-native/packages/react-native/index.js</code>：</p>
<pre><code class="hljs language-js" lang="js">  <span class="hljs-keyword">get</span> <span class="hljs-title function_">NativeComponentRegistry</span>() {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">require</span>(<span class="hljs-string">'./Libraries/NativeComponent/NativeComponentRegistry'</span>);
  },
</code></pre>
<p>定位到方法实现<code>react-native/packages/react-native/Libraries/NativeComponent/NativeComponentRegistry.js</code>：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/**
 * 获取一个可以被 React Native 渲染的 `NativeComponent`。
 *
 * 提供的 `viewConfigProvider` 可能会被调用和使用，也可能不会，
 * 这取决于 `setRuntimeConfigProvider` 是如何配置的。
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> get&lt;<span class="hljs-title class_">Config</span>: {...}&gt;(
  <span class="hljs-attr">name</span>: string,
  <span class="hljs-attr">viewConfigProvider</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">PartialViewConfig</span>,
): <span class="hljs-title class_">HostComponent</span>&lt;<span class="hljs-title class_">Config</span>&gt; {
  <span class="hljs-comment">// 注册ViewConfig到全局注册表</span>
  <span class="hljs-title class_">ReactNativeViewConfigRegistry</span>.<span class="hljs-title function_">register</span>(name, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// 这里的回调函数会在React需要组件配置时被调用</span>
    <span class="hljs-keyword">const</span> {native, verify} = getRuntimeConfig?.(name) ?? {
      <span class="hljs-attr">native</span>: !<span class="hljs-variable language_">global</span>.<span class="hljs-property">RN$Bridgeless</span>,   <span class="hljs-comment">// 关键：新架构检测</span>
      <span class="hljs-attr">verify</span>: <span class="hljs-literal">false</span>,
    };

    <span class="hljs-keyword">let</span> <span class="hljs-attr">viewConfig</span>: <span class="hljs-title class_">ViewConfig</span>;
    <span class="hljs-keyword">if</span> (native) {
      <span class="hljs-comment">// 旧架构：原生ViewManager</span>
      viewConfig =
        <span class="hljs-title function_">getNativeComponentAttributes</span>(name) ??
        <span class="hljs-title function_">createViewConfig</span>(<span class="hljs-title function_">viewConfigProvider</span>());
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// 新架构：优先静态ViewConfig</span>
      viewConfig =
        <span class="hljs-title function_">createViewConfig</span>(<span class="hljs-title function_">viewConfigProvider</span>()) ??
        <span class="hljs-title function_">getNativeComponentAttributes</span>(name);
    }
    <span class="hljs-comment">// 省略部分代码......</span>
    <span class="hljs-keyword">return</span> viewConfig;
  });

  <span class="hljs-comment">// $FlowFixMe[incompatible-type] `NativeComponent` 实际上是字符串!</span>
  <span class="hljs-keyword">return</span> name;
}
</code></pre>
<p>继续跟踪<code>ReactNativeViewConfigRegistry.register</code>实现。源码<code>react-native/packages/react-native/Libraries/Renderer/shims/ReactNativeViewConfigRegistry.js</code>：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> viewConfigCallbacks = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>&lt;string, ?<span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">ViewConfig</span>&gt;();


<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">register</span>(<span class="hljs-params">name: string, callback: () =&gt; ViewConfig</span>): string {
  <span class="hljs-comment">// 省略部分代码......</span>
  viewConfigCallbacks.<span class="hljs-title function_">set</span>(name, callback);
  <span class="hljs-keyword">return</span> name;
}
</code></pre>
<p>这里基本上就是将返回<code>ViewConfig</code>的闭包给存了起来。</p>
<h4 data-id="heading-3">查找组件</h4>
<h5 data-id="heading-4">JS层</h5>
<p>在前面启动渲染一节我们知道了启动渲染的最终调用是JS层的<code>AppRegistry.runApplication</code>方法。沿着这条线，我们来分析一下JS层的组件加载与处理流程。源码<code>react-native/packages/react-native/Libraries/ReactNative/AppRegistry.js</code>：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-title class_">AppRegistry</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./AppRegistryImpl'</span>;

<span class="hljs-comment">// 省略部分代码......</span>
<span class="hljs-variable language_">global</span>.<span class="hljs-property">RN$AppRegistry</span> = <span class="hljs-title class_">AppRegistry</span>;

<span class="hljs-title function_">registerCallableModule</span>(<span class="hljs-string">'AppRegistry'</span>, <span class="hljs-title class_">AppRegistry</span>);

<span class="hljs-keyword">export</span> {<span class="hljs-title class_">AppRegistry</span>};
</code></pre>
<p>继续跟踪源码<code>react-native/packages/react-native/Libraries/ReactNative/AppRegistryImpl.js</code>：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> <span class="hljs-attr">runnables</span>: <span class="hljs-title class_">Runnables</span> = {};


<span class="hljs-comment">/**
 * Loads the JavaScript bundle and runs the app.
 *
 * See https://reactnative.dev/docs/appregistry#runapplication
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">runApplication</span>(<span class="hljs-params">
  appKey: string,
  appParameters: AppParameters,
  displayMode?: number,
</span>): <span class="hljs-keyword">void</span> {
  <span class="hljs-keyword">if</span> (appKey !== <span class="hljs-string">'LogBox'</span>) {
    <span class="hljs-keyword">const</span> logParams = __DEV__ ? <span class="hljs-string">` with <span class="hljs-subst">${<span class="hljs-built_in">JSON</span>.stringify(appParameters)}</span>`</span> : <span class="hljs-string">''</span>;
    <span class="hljs-keyword">const</span> msg = <span class="hljs-string">`Running "<span class="hljs-subst">${appKey}</span>"<span class="hljs-subst">${logParams}</span>`</span>;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(msg);
  }

  <span class="hljs-title class_">SceneTracker</span>.<span class="hljs-title function_">setActiveScene</span>({<span class="hljs-attr">name</span>: appKey});
  runnables[appKey](appParameters, <span class="hljs-title function_">coerceDisplayMode</span>(displayMode));
}


<span class="hljs-comment">/**
 * Registers an app's root component.
 *
 * See https://reactnative.dev/docs/appregistry#registercomponent
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">registerComponent</span>(<span class="hljs-params">
  appKey: string,
  componentProvider: ComponentProvider,
  section?: boolean,
</span>): string {
  <span class="hljs-keyword">const</span> scopedPerformanceLogger = <span class="hljs-title function_">createPerformanceLogger</span>();
  runnables[appKey] = <span class="hljs-function">(<span class="hljs-params">appParameters, displayMode</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> renderApplication = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./renderApplication'</span>).<span class="hljs-property">default</span>;
    <span class="hljs-title function_">renderApplication</span>(
      <span class="hljs-title function_">componentProviderInstrumentationHook</span>(
        componentProvider,
        scopedPerformanceLogger,
      ),
      appParameters.<span class="hljs-property">initialProps</span>,
      appParameters.<span class="hljs-property">rootTag</span>,
      wrapperComponentProvider &amp;&amp; <span class="hljs-title function_">wrapperComponentProvider</span>(appParameters),
      rootViewStyleProvider &amp;&amp; <span class="hljs-title function_">rootViewStyleProvider</span>(appParameters),
      appParameters.<span class="hljs-property">fabric</span>,
      scopedPerformanceLogger,
      appKey === <span class="hljs-string">'LogBox'</span>, <span class="hljs-comment">// is logbox</span>
      appKey,
      displayMode,
    );
  };
  <span class="hljs-keyword">if</span> (section) {
    sections[appKey] = runnables[appKey];
  }
  <span class="hljs-keyword">return</span> appKey;
}
</code></pre>
<p>可以看到，<code>runApplication</code>调用的是<code>runnables</code>对象中注册的闭包。而在我们React Native JS层的Bundle包中，首先就需要调用<code>AppRegistry.registerComponent(appName, () =&gt; App)</code>完成最根组件的注册。所以<code>runApplication</code>方法中调用的闭包，就是在<code>registerComponent</code>中注册的闭包。</p>
<p>继续跟踪<code>renderApplication</code>方法的实现，源码<code>react-native/packages/react-native/Libraries/ReactNative/renderApplication.js</code>：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> renderApplication&lt;<span class="hljs-title class_">Props</span>: <span class="hljs-title class_">Object</span>&gt;(
  <span class="hljs-title class_">RootComponent</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">ComponentType</span>&lt;<span class="hljs-title class_">Props</span>&gt;,
  <span class="hljs-attr">initialProps</span>: <span class="hljs-title class_">Props</span>,
  <span class="hljs-attr">rootTag</span>: any,
  <span class="hljs-title class_">WrapperComponent</span>?: ?<span class="hljs-title class_">React</span>.<span class="hljs-property">ComponentType</span>&lt;any&gt;,
  rootViewStyle?: ?<span class="hljs-title class_">ViewStyleProp</span>,
  fabric?: boolean,
  scopedPerformanceLogger?: <span class="hljs-title class_">IPerformanceLogger</span>,
  isLogBox?: boolean,
  debugName?: string,
  displayMode?: ?<span class="hljs-title class_">DisplayModeType</span>,
  useOffscreen?: boolean,
) {

  <span class="hljs-keyword">const</span> performanceLogger = scopedPerformanceLogger ?? <span class="hljs-title class_">GlobalPerformanceLogger</span>;

  <span class="hljs-comment">// 构建React元素树</span>
  <span class="hljs-comment">// 外层：PerformanceLoggerContext.Provider - 提供性能监控上下文</span>
  <span class="hljs-comment">// 中层：AppContainer - React Native的根容器组件</span>
  <span class="hljs-comment">// 内层：RootComponent - 用户注册的应用组件（如App.js）</span>
  <span class="hljs-keyword">let</span> <span class="hljs-attr">renderable</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">MixedElement</span> = (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">PerformanceLoggerContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{performanceLogger}</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">AppContainer</span>
        <span class="hljs-attr">rootTag</span>=<span class="hljs-string">{rootTag}</span>
        <span class="hljs-attr">fabric</span>=<span class="hljs-string">{fabric}</span>
        <span class="hljs-attr">WrapperComponent</span>=<span class="hljs-string">{WrapperComponent}</span>
        <span class="hljs-attr">rootViewStyle</span>=<span class="hljs-string">{rootViewStyle}</span>
        <span class="hljs-attr">initialProps</span>=<span class="hljs-string">{initialProps</span> ?? <span class="hljs-attr">Object.freeze</span>({})}
        <span class="hljs-attr">internal_excludeLogBox</span>=<span class="hljs-string">{isLogBox}</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">RootComponent</span> {<span class="hljs-attr">...initialProps</span>} <span class="hljs-attr">rootTag</span>=<span class="hljs-string">{rootTag}</span> /&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">AppContainer</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">PerformanceLoggerContext.Provider</span>&gt;</span></span>
  );

  <span class="hljs-comment">// 开发模式调试包装</span>
  <span class="hljs-keyword">if</span> (__DEV__ &amp;&amp; debugName) {
    <span class="hljs-keyword">const</span> <span class="hljs-title class_">RootComponentWithMeaningfulName</span> = <span class="hljs-title function_">getCachedComponentWithDebugName</span>(
      <span class="hljs-string">`<span class="hljs-subst">${debugName}</span>(RootComponent)`</span>,
    );
    renderable = (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">RootComponentWithMeaningfulName</span>&gt;</span>
        {renderable}
      <span class="hljs-tag">&lt;/<span class="hljs-name">RootComponentWithMeaningfulName</span>&gt;</span></span>
    );
  }

  <span class="hljs-comment">//  实验性离屏渲染支持</span>
  <span class="hljs-keyword">if</span> (useOffscreen &amp;&amp; displayMode != <span class="hljs-literal">null</span>) {
    <span class="hljs-comment">// $FlowFixMe[incompatible-type]</span>
    <span class="hljs-comment">// $FlowFixMe[prop-missing]</span>
    <span class="hljs-comment">// $FlowFixMe[missing-export]</span>
    <span class="hljs-keyword">const</span> <span class="hljs-title class_">Activity</span>: <span class="hljs-title class_">ActivityType</span> = <span class="hljs-title class_">React</span>.<span class="hljs-property">unstable_Activity</span>;

    renderable = (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Activity</span>
        <span class="hljs-attr">mode</span>=<span class="hljs-string">{displayMode</span> === <span class="hljs-string">DisplayMode.VISIBLE</span> ? '<span class="hljs-attr">visible</span>' <span class="hljs-attr">:</span> '<span class="hljs-attr">hidden</span>'}&gt;</span>
        {renderable}
      <span class="hljs-tag">&lt;/<span class="hljs-name">Activity</span>&gt;</span></span>
    );
  }

  <span class="hljs-comment">// 我们希望在使用 Fabric 时始终启用 concurrentRoot 功能</span>
  <span class="hljs-keyword">const</span> useConcurrentRoot = <span class="hljs-title class_">Boolean</span>(fabric);

  <span class="hljs-comment">// 省略部分性能日志打印......</span>

  <span class="hljs-comment">// 进入React渲染系统</span>
  <span class="hljs-title class_">Renderer</span>.<span class="hljs-title function_">renderElement</span>({
    <span class="hljs-attr">element</span>: renderable,
    rootTag,
    <span class="hljs-attr">useFabric</span>: <span class="hljs-title class_">Boolean</span>(fabric),
    useConcurrentRoot,
  });
}
</code></pre>
<p>继续跟踪<code>Renderer.renderElement</code>方法实现。源码<code>react-native/packages/react-native/Libraries/ReactNative/RendererImplementation.js</code>：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">renderElement</span>(<span class="hljs-params">{
  element,
  rootTag,
  useFabric,
  useConcurrentRoot,
}: {
  element: React.MixedElement,
  rootTag: number,
  useFabric: boolean,
  useConcurrentRoot: boolean,
}</span>): <span class="hljs-keyword">void</span> {
  <span class="hljs-keyword">if</span> (useFabric) {
    <span class="hljs-keyword">if</span> (cachedFabricRender == <span class="hljs-literal">null</span>) {
      <span class="hljs-comment">// 获取实际渲染器</span>
      cachedFabricRender = <span class="hljs-title function_">getFabricRenderer</span>().<span class="hljs-property">render</span>;
    }

    <span class="hljs-title function_">cachedFabricRender</span>(element, rootTag, <span class="hljs-literal">null</span>, useConcurrentRoot, {
      onCaughtError,
      onUncaughtError,
      onRecoverableError,
    });
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// 省略旧架构......</span>
  }
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">getFabricRenderer</span>(<span class="hljs-params"/>): <span class="hljs-title class_">ReactFabricType</span> {
  <span class="hljs-keyword">if</span> (cachedFabricRenderer == <span class="hljs-literal">null</span>) {
    cachedFabricRenderer = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../Renderer/shims/ReactFabric'</span>).<span class="hljs-property">default</span>;
  }
  <span class="hljs-keyword">return</span> cachedFabricRenderer;
}
</code></pre>
<p>继续跟踪<code>react-native/packages/react-native/Libraries/Renderer/shims/ReactFabric.js</code>：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">import</span> {<span class="hljs-title class_">BatchedBridge</span>} <span class="hljs-keyword">from</span> <span class="hljs-string">'react-native/Libraries/ReactPrivate/ReactNativePrivateInterface'</span>;

<span class="hljs-keyword">import</span> type {<span class="hljs-title class_">ReactFabricType</span>} <span class="hljs-keyword">from</span> <span class="hljs-string">'./ReactNativeTypes'</span>;

<span class="hljs-keyword">let</span> <span class="hljs-title class_">ReactFabric</span>: <span class="hljs-title class_">ReactFabricType</span>;

<span class="hljs-keyword">if</span> (__DEV__) {
  <span class="hljs-title class_">ReactFabric</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../implementations/ReactFabric-dev'</span>);
} <span class="hljs-keyword">else</span> {
  <span class="hljs-title class_">ReactFabric</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../implementations/ReactFabric-prod'</span>);
}

<span class="hljs-variable language_">global</span>.<span class="hljs-property">RN$stopSurface</span> = <span class="hljs-title class_">ReactFabric</span>.<span class="hljs-property">stopSurface</span>;

<span class="hljs-keyword">if</span> (<span class="hljs-variable language_">global</span>.<span class="hljs-property">RN$Bridgeless</span> !== <span class="hljs-literal">true</span>) {
  <span class="hljs-title class_">BatchedBridge</span>.<span class="hljs-title function_">registerCallableModule</span>(<span class="hljs-string">'ReactFabric'</span>, <span class="hljs-title class_">ReactFabric</span>);
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">ReactFabric</span>;
</code></pre>
<p>这里根据开发环境选择了不同的渲染器。开发环境的渲染器体积更大，包含了许多调试、性能日志等信息，而生产环境的移除了注释和空白，变量名被压缩代码经过优化，减少包体积。</p>
<p>继续跟踪生产环境的渲染器，因为代码更加简洁，可更好的聚焦于调用的链路和流程。源码<code>react-native/packages/react-native/Libraries/Renderer/implementations/ReactFabric-prod.js</code>：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-built_in">exports</span>.<span class="hljs-property">render</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">
  element,
  containerTag,
  callback,
  concurrentRoot,
  options
</span>) {
  <span class="hljs-keyword">var</span> root = roots.<span class="hljs-title function_">get</span>(containerTag);
  <span class="hljs-keyword">if</span> (!root) {
    <span class="hljs-comment">// 创建新的FiberRootNode</span>
    <span class="hljs-comment">// 省略部分代码......</span>

    <span class="hljs-title function_">initializeUpdateQueue</span>(concurrentRoot);
    roots.<span class="hljs-title function_">set</span>(containerTag, root);
  }
  <span class="hljs-comment">// 启动渲染 </span>
  <span class="hljs-title function_">updateContainer</span>(element, root, <span class="hljs-literal">null</span>, callback);
  <span class="hljs-comment">// 返回渲染后的公共实例引用</span>
  <span class="hljs-attr">a</span>: <span class="hljs-keyword">if</span> (((element = root.<span class="hljs-property">current</span>), element.<span class="hljs-property">child</span>))
    <span class="hljs-keyword">switch</span> (element.<span class="hljs-property">child</span>.<span class="hljs-property">tag</span>) {
      <span class="hljs-keyword">case</span> <span class="hljs-number">27</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:
        element = <span class="hljs-title function_">getPublicInstance</span>(element.<span class="hljs-property">child</span>.<span class="hljs-property">stateNode</span>);
        <span class="hljs-keyword">break</span> a;
      <span class="hljs-attr">default</span>:
        element = element.<span class="hljs-property">child</span>.<span class="hljs-property">stateNode</span>;
    }
  <span class="hljs-keyword">else</span> element = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">return</span> element;
};

<span class="hljs-keyword">function</span> <span class="hljs-title function_">updateContainer</span>(<span class="hljs-params">element, container, parentComponent, callback</span>) {
  parentComponent = container.<span class="hljs-property">current</span>;
  <span class="hljs-comment">// / 获取更新优先级</span>
  <span class="hljs-keyword">var</span> lane = <span class="hljs-title function_">requestUpdateLane</span>(parentComponent);
  <span class="hljs-literal">null</span> === container.<span class="hljs-property">context</span>
    ? (container.<span class="hljs-property">context</span> = emptyContextObject)
    : (container.<span class="hljs-property">pendingContext</span> = emptyContextObject);

  <span class="hljs-comment">// 创建更新对象</span>
  container = <span class="hljs-title function_">createUpdate</span>(lane);
  container.<span class="hljs-property">payload</span> = { <span class="hljs-attr">element</span>: element };
  callback = <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> === callback ? <span class="hljs-literal">null</span> : callback;
  <span class="hljs-literal">null</span> !== callback &amp;&amp; (container.<span class="hljs-property">callback</span> = callback);

  <span class="hljs-comment">// 将更新加入队列</span>
  element = <span class="hljs-title function_">enqueueUpdate</span>(parentComponent, container, lane);

  <span class="hljs-comment">// 调度更新</span>
  <span class="hljs-literal">null</span> !== element &amp;&amp;
    (<span class="hljs-title function_">scheduleUpdateOnFiber</span>(element, parentComponent, lane),
    <span class="hljs-title function_">entangleTransitions</span>(element, parentComponent, lane));
  <span class="hljs-keyword">return</span> lane;
}
</code></pre>
<p>以上调用都比较简单，这里的核心是<code>scheduleUpdateOnFiber</code>方法，它负责调度更新。由于代码量较大，我们后面只追求核心逻辑，将省略大部分代码：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">scheduleUpdateOnFiber</span>(<span class="hljs-params">root, fiber, lane</span>) {
  <span class="hljs-comment">// 省略......</span>

  <span class="hljs-comment">// 标记更新并触发调度</span>
  <span class="hljs-title function_">markRootUpdated$1</span>(root, lane);
  <span class="hljs-keyword">if</span> (<span class="hljs-comment">/* 不在渲染中 */</span>) {
      <span class="hljs-title function_">ensureRootIsScheduled</span>(root);                    <span class="hljs-comment">// 确保根节点被调度</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-comment">/* 同步更新 */</span>) {
        <span class="hljs-title function_">flushSyncWorkAcrossRoots_impl</span>(<span class="hljs-number">0</span>, !<span class="hljs-number">0</span>);         <span class="hljs-comment">// 立即执行同步工作</span>
      }
   }
}


<span class="hljs-keyword">function</span> <span class="hljs-title function_">flushSyncWorkAcrossRoots_impl</span>(<span class="hljs-params">syncTransitionLanes, onlyLegacy</span>) {
  <span class="hljs-keyword">if</span> (!isFlushingWork &amp;&amp; mightHavePendingSyncWork) {
    isFlushingWork = !<span class="hljs-number">0</span>;
    <span class="hljs-keyword">do</span> {
      <span class="hljs-keyword">var</span> didPerformSomeWork = !<span class="hljs-number">1</span>;
      <span class="hljs-comment">// 遍历所有根节点执行同步工作</span>
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> root = firstScheduledRoot; <span class="hljs-literal">null</span> !== root; ) {
        <span class="hljs-keyword">if</span> (!onlyLegacy || <span class="hljs-number">0</span> === root.<span class="hljs-property">tag</span>)
          <span class="hljs-comment">//省略......</span>
          <span class="hljs-comment">// 常规同步更新 </span>
          <span class="hljs-title function_">performSyncWorkOnRoot</span>(root, <span class="hljs-title class_">JSCompiler</span>_inline_result));

        root = root.<span class="hljs-property">next</span>;
      }
    } <span class="hljs-keyword">while</span> (didPerformSomeWork);
    isFlushingWork = !<span class="hljs-number">1</span>;
  }
}


<span class="hljs-keyword">function</span> <span class="hljs-title function_">performSyncWorkOnRoot</span>(<span class="hljs-params">root, lanes</span>) {
  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">flushPendingEffects</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  <span class="hljs-title function_">performWorkOnRoot</span>(root, lanes, !<span class="hljs-number">0</span>);
}


<span class="hljs-keyword">function</span> <span class="hljs-title function_">performWorkOnRoot</span>(<span class="hljs-params">root$jscomp$0, lanes, forceSync</span>) {
   <span class="hljs-comment">// 选择同步或并发渲染</span>
   <span class="hljs-keyword">var</span> shouldTimeSlice = (!forceSync &amp;&amp; <span class="hljs-comment">/* 条件判断 */</span>);
   <span class="hljs-keyword">var</span> exitStatus = shouldTimeSlice
      ? <span class="hljs-title function_">renderRootConcurrent</span>(root, lanes)            <span class="hljs-comment">// 并发渲染</span>
      : <span class="hljs-title function_">renderRootSync</span>(root, lanes, !<span class="hljs-number">0</span>);             <span class="hljs-comment">// 同步渲染</span>

   <span class="hljs-comment">// 省略......</span>
}
</code></pre>
<p>继续追踪同步渲染<code>renderRootSync</code>方法实现：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">renderRootSync</span>(<span class="hljs-params">root, lanes, shouldYieldForPrerendering</span>) {
   <span class="hljs-comment">// 省略......</span>

   <span class="hljs-comment">// 同步工作循环</span>
   <span class="hljs-title function_">workLoopSync</span>();
   <span class="hljs-comment">// 省略......</span>
}


<span class="hljs-keyword">function</span> <span class="hljs-title function_">workLoopSync</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">for</span> (; <span class="hljs-literal">null</span> !== workInProgress; ) <span class="hljs-title function_">performUnitOfWork</span>(workInProgress);
}


<span class="hljs-keyword">function</span> <span class="hljs-title function_">performUnitOfWork</span>(<span class="hljs-params">unitOfWork</span>) {
  <span class="hljs-comment">// 处理单个Fiber节点</span>
  <span class="hljs-keyword">var</span> next = <span class="hljs-title function_">beginWork</span>(unitOfWork.<span class="hljs-property">alternate</span>, unitOfWork, entangledRenderLanes);
  unitOfWork.<span class="hljs-property">memoizedProps</span> = unitOfWork.<span class="hljs-property">pendingProps</span>;
  <span class="hljs-literal">null</span> === next ? <span class="hljs-title function_">completeUnitOfWork</span>(unitOfWork) : (workInProgress = next);
}


<span class="hljs-keyword">function</span> <span class="hljs-title function_">completeUnitOfWork</span>(<span class="hljs-params">unitOfWork</span>) {
  <span class="hljs-keyword">var</span> completedWork = unitOfWork;
  <span class="hljs-keyword">do</span> {
    <span class="hljs-comment">// 省略......</span>
    unitOfWork = completedWork.<span class="hljs-property">return</span>;
    <span class="hljs-keyword">var</span> next = <span class="hljs-title function_">completeWork</span>(
      completedWork.<span class="hljs-property">alternate</span>,
      completedWork,
      entangledRenderLanes
    );
    <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> !== next) {
      workInProgress = next;
      <span class="hljs-keyword">return</span>;
    }
    completedWork = completedWork.<span class="hljs-property">sibling</span>;
    <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> !== completedWork) {
      workInProgress = completedWork;
      <span class="hljs-keyword">return</span>;
    }
    workInProgress = completedWork = unitOfWork;
  } <span class="hljs-keyword">while</span> (<span class="hljs-literal">null</span> !== completedWork);
  <span class="hljs-number">0</span> === workInProgressRootExitStatus &amp;&amp; (workInProgressRootExitStatus = <span class="hljs-number">5</span>);
}
</code></pre>
<p>最终是调用的<code>completeWork</code>方法完成渲染工作：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">completeWork</span>(<span class="hljs-params">current, workInProgress, renderLanes</span>) {
  <span class="hljs-keyword">var</span> newProps = workInProgress.<span class="hljs-property">pendingProps</span>;
  <span class="hljs-keyword">switch</span> (workInProgress.<span class="hljs-property">tag</span>) {
    <span class="hljs-keyword">case</span> <span class="hljs-number">28</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-number">16</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-number">15</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-number">11</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-number">8</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-number">12</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-number">9</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-number">14</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">bubbleProperties</span>(workInProgress), <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">bubbleProperties</span>(workInProgress), <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:
      <span class="hljs-comment">// 省略......</span>
      <span class="hljs-comment">// return  </span>
    <span class="hljs-keyword">case</span> <span class="hljs-number">26</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-number">27</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:
      <span class="hljs-title function_">popHostContext</span>(workInProgress);
      <span class="hljs-keyword">var</span> type = workInProgress.<span class="hljs-property">type</span>;
      <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> !== current &amp;&amp; <span class="hljs-literal">null</span> != workInProgress.<span class="hljs-property">stateNode</span>)
        <span class="hljs-comment">// 省略......</span>
      <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// 首次挂载</span>
        <span class="hljs-keyword">if</span> (!newProps) {  
          <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> === workInProgress.<span class="hljs-property">stateNode</span>)
            <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(
              <span class="hljs-string">"We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."</span>
            );
          <span class="hljs-title function_">bubbleProperties</span>(workInProgress);
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }
        current = rootInstanceStackCursor.<span class="hljs-property">current</span>;
        renderLanes = nextReactTag;
        nextReactTag += <span class="hljs-number">2</span>;
        <span class="hljs-comment">// 获取ViewConfig</span>
        type = <span class="hljs-title function_">getViewConfigForType</span>(type);
        <span class="hljs-keyword">var</span> updatePayload = <span class="hljs-title class_">ReactNativePrivateInterface</span>.<span class="hljs-title function_">createAttributePayload</span>(
          newProps,
          type.<span class="hljs-property">validAttributes</span>
        );
        <span class="hljs-comment">// 创建原生节点</span>
        current = {
          <span class="hljs-attr">node</span>: <span class="hljs-title function_">createNode</span>(
            renderLanes,
            type.<span class="hljs-property">uiViewClassName</span>,  <span class="hljs-comment">//  使用ViewConfig中的原生类名</span>
            current.<span class="hljs-property">containerTag</span>,
            updatePayload,
            workInProgress
          ),
          <span class="hljs-attr">canonical</span>: {
            <span class="hljs-attr">nativeTag</span>: renderLanes,
            <span class="hljs-attr">viewConfig</span>: type,       <span class="hljs-comment">// 保存ViewConfig引用</span>
            <span class="hljs-attr">currentProps</span>: newProps,
            <span class="hljs-attr">internalInstanceHandle</span>: workInProgress,
            <span class="hljs-attr">publicInstance</span>: <span class="hljs-literal">null</span>,
            <span class="hljs-attr">publicRootInstance</span>: current.<span class="hljs-property">publicInstance</span>
          }
        };
        workInProgress.<span class="hljs-property">flags</span> |= <span class="hljs-number">8</span>;
        <span class="hljs-title function_">appendAllChildren</span>(current, workInProgress, !<span class="hljs-number">1</span>, !<span class="hljs-number">1</span>);
        workInProgress.<span class="hljs-property">stateNode</span> = current;
      }
      <span class="hljs-title function_">bubbleProperties</span>(workInProgress);
      workInProgress.<span class="hljs-property">flags</span> &amp;= -<span class="hljs-number">16777217</span>;
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    <span class="hljs-comment">// 省略部分代码......</span>
  }
}
</code></pre>
<p>此方法中的<code>case</code>都是整数，为了弄清楚其含义，我们可以查看React 仓库中的<strong>Tag</strong>定义。源码位于 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ffacebook%2Freact%2Fblob%2Fmain%2Fpackages%2Freact-reconciler%2Fsrc%2FReactWorkTags.js" target="_blank" title="https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactWorkTags.js" ref="nofollow noopener noreferrer">ReactWorkTags.js</a>：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">FunctionComponent</span> = <span class="hljs-number">0</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">ClassComponent</span> = <span class="hljs-number">1</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">HostRoot</span> = <span class="hljs-number">3</span>; <span class="hljs-comment">// 宿主树的根节点。它可以嵌套在另一个节点内部</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">HostPortal</span> = <span class="hljs-number">4</span>; <span class="hljs-comment">// 一个子树。它可以是通往不同渲染器的入口点</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">HostComponent</span> = <span class="hljs-number">5</span>;
<span class="hljs-comment">// 省略......</span>
</code></pre>
<p>很显然，我们需要查看的是React Native的Tag类型，也就是<code>HostComponent</code>，它的值是5，因此对应到<code>completeWork</code>中的处理代码就是我截取的这部分。这段代码中有一个关键的方法，就是<code>getViewConfigForType</code>，查看其定义，显示为<code>getViewConfigForType = ReactNativePrivateInterface.ReactNativeViewConfigRegistry.get</code></p>
<p>可看到，这里就完全与前面<strong>声明组件</strong>一节最后分析到的<code>ReactNativeViewConfigRegistry.js</code>对应上了，我们前面分析的是ViewConfig的注册，现在来看一下<code>get</code>方法：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/**
 * 获取指定视图的配置。如果这是第一次使用该视图，此配置将从UIManager延迟加载
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">name: string</span>): <span class="hljs-title class_">ViewConfig</span> {
  <span class="hljs-comment">// 从viewConfigs Map中查找已缓存的ViewConfig</span>
  <span class="hljs-keyword">let</span> viewConfig = viewConfigs.<span class="hljs-title function_">get</span>(name);
  <span class="hljs-keyword">if</span> (viewConfig == <span class="hljs-literal">null</span>) {
    <span class="hljs-comment">// 获取该组件的配置生成回调函数</span>
    <span class="hljs-keyword">const</span> callback = viewConfigCallbacks.<span class="hljs-title function_">get</span>(name);
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">'function'</span>) {
      <span class="hljs-comment">// 省略日志......</span>
    }
    viewConfig = <span class="hljs-title function_">callback</span>();
    <span class="hljs-title function_">invariant</span>(viewConfig, <span class="hljs-string">'View config not found for component `%s`'</span>, name);

    <span class="hljs-title function_">processEventTypes</span>(viewConfig);
    viewConfigs.<span class="hljs-title function_">set</span>(name, viewConfig);

    <span class="hljs-comment">// 配置设置后清除回调，这样我们就不会在注册过程中掩盖任何错误。</span>
    viewConfigCallbacks.<span class="hljs-title function_">set</span>(name, <span class="hljs-literal">null</span>);
  }
  <span class="hljs-keyword">return</span> viewConfig;
}
</code></pre>
<p>通过<strong>ViewConfig</strong>，可以得到<code>uiViewClassName</code>，也就是声明的组件名称，我们继续查看原生节点创建的方法：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">var</span> _nativeFabricUIManage = nativeFabricUIManager,
  createNode = _nativeFabricUIManage.<span class="hljs-property">createNode</span>,          


 <span class="hljs-title function_">createNode</span>(
   renderLanes,
   type.<span class="hljs-property">uiViewClassName</span>,  <span class="hljs-comment">//  使用ViewConfig中的原生类名</span>
   current.<span class="hljs-property">containerTag</span>,
   updatePayload,
   workInProgress
 )
</code></pre>
<p><code>createNode</code>方法来自于全局对象<code>nativeFabricUIManager</code>，通过变量名就知道，这个应该是来自于JSI定义的对象，代码不在JS层。</p>
<h5 data-id="heading-5">C++ 层</h5>
<p>继续在C++中搜索<code>nativeFabricUIManager</code>，定位到源码<code>react-native/packages/react-native/ReactCommon/react/renderer/uimanager/UIManagerBinding.cpp</code>：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">void</span> <span class="hljs-title class_">UIManagerBinding</span>::<span class="hljs-title function_">createAndInstallIfNeeded</span>(<span class="hljs-params">
    jsi::Runtime&amp; runtime,
    <span class="hljs-keyword">const</span> std::shared_ptr&lt;UIManager&gt;&amp; uiManager</span>) {
  auto uiManagerModuleName = <span class="hljs-string">"nativeFabricUIManager"</span>;

  auto uiManagerValue =
      runtime.<span class="hljs-title function_">global</span>().<span class="hljs-title function_">getProperty</span>(runtime, uiManagerModuleName);
  <span class="hljs-keyword">if</span> (uiManagerValue.<span class="hljs-title function_">isUndefined</span>()) {
    <span class="hljs-comment">// 全局命名空间中没有该绑定的实例；我们需要创建、安装并返回它</span>
    auto uiManagerBinding = <span class="hljs-attr">std</span>::make_shared&lt;<span class="hljs-title class_">UIManagerBinding</span>&gt;(uiManager);
    auto object = <span class="hljs-attr">jsi</span>::<span class="hljs-title class_">Object</span>::<span class="hljs-title function_">createFromHostObject</span>(runtime, uiManagerBinding);
    runtime.<span class="hljs-title function_">global</span>().<span class="hljs-title function_">setProperty</span>(
        runtime, uiManagerModuleName, <span class="hljs-attr">std</span>::<span class="hljs-title function_">move</span>(object));
  }
}
</code></pre>
<p>可见这里的<code>nativeFabricUIManager</code>是一个<code>jsi::HostObject</code>对象，我们要查找其<code>createNode</code>方法，直接查看<strong>UIManagerBinding</strong>的<code>get</code>方法：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-function">jsi::Value <span class="hljs-title">UIManagerBinding::get</span><span class="hljs-params">(
    jsi::Runtime&amp; runtime,
    <span class="hljs-type">const</span> jsi::PropNameID&amp; name)</span> </span>{
  <span class="hljs-keyword">auto</span> methodName = name.<span class="hljs-built_in">utf8</span>(runtime);

  <span class="hljs-comment">// 将 shared_ptr&lt;UIManager&gt; 转换为原始指针</span>
  <span class="hljs-comment">// 为什么这样做？原因如下：</span>
  <span class="hljs-comment">// 1) UIManagerBinding 强引用（strongly retains）UIManager。</span>
  <span class="hljs-comment">//    JS VM 通过 JSI 强引用 UIManagerBinding。</span>
  <span class="hljs-comment">//    这些函数是 JSI 函数，只能通过 JS VM 调用；如果 JS VM 被销毁，</span>
  <span class="hljs-comment">//    这些函数无法执行，这些 lambda 也不会执行。</span>
  <span class="hljs-comment">// 2) UIManager 只有在所有对它的引用都被释放后才会被析构，包括</span>
  <span class="hljs-comment">//    UIManagerBinding。这只有在 JS VM 被析构时才会发生。因此，原始指针是安全的。</span>
  <span class="hljs-comment">//</span>
  <span class="hljs-comment">// 即使这样做是安全的，为什么不直接使用 shared_ptr 作为额外的保险呢？</span>
  <span class="hljs-comment">// 1) 在不需要的情况下使用 shared_ptr 或 weak_ptr</span>
  <span class="hljs-comment">// 是一种性能劣化（pessimisation）。</span>
  <span class="hljs-comment">//    在这种情况下，它会执行更多指令，但不会带来任何额外价值。</span>
  <span class="hljs-comment">// 2) 这些 lambda 的确切释放时机和方式很复杂。向它们添加 shared_ptr 会导致</span>
  <span class="hljs-comment">//    UIManager 可能存活更长时间，这是不必要的、复杂的认知负担。</span>
  <span class="hljs-comment">// 3) 有强烈怀疑认为，从这些 C++ lambda 中保留 UIManager（这些 lambda 被</span>
  <span class="hljs-comment">//    JSI 持有的对象所保留），在 Scheduler 和 JS VM 析构时导致了一些崩溃。</span>
  <span class="hljs-comment">//    如果 C++ 语义导致这些 lambda 在 JS VM 被析构后一个 CPU</span>
  <span class="hljs-comment">//    时钟周期（或更久） 才被释放，就可能发生这种情况。</span>
  UIManager* uiManager = uiManager_.<span class="hljs-built_in">get</span>();

  <span class="hljs-comment">// Semantic: Creates a new node with given pieces.</span>
  <span class="hljs-keyword">if</span> (methodName == <span class="hljs-string">"createNode"</span>) {
    <span class="hljs-keyword">auto</span> paramCount = <span class="hljs-number">5</span>;
    <span class="hljs-keyword">return</span> jsi::Function::<span class="hljs-built_in">createFromHostFunction</span>(
        runtime,
        name,
        paramCount,
        [uiManager, methodName, paramCount](
            jsi::Runtime&amp; runtime,
            <span class="hljs-type">const</span> jsi::Value&amp; <span class="hljs-comment">/*thisValue*/</span>,
            <span class="hljs-type">const</span> jsi::Value* arguments,
            <span class="hljs-type">size_t</span> count) -&gt; jsi::Value {
          <span class="hljs-keyword">try</span> {
            <span class="hljs-built_in">validateArgumentCount</span>(runtime, methodName, paramCount, count);

            <span class="hljs-keyword">auto</span> instanceHandle =
                <span class="hljs-built_in">instanceHandleFromValue</span>(runtime, arguments[<span class="hljs-number">4</span>], arguments[<span class="hljs-number">0</span>]);
            <span class="hljs-keyword">if</span> (!instanceHandle) {
              <span class="hljs-built_in">react_native_assert</span>(<span class="hljs-literal">false</span>);
              <span class="hljs-keyword">return</span> jsi::Value::<span class="hljs-built_in">undefined</span>();
            }

            <span class="hljs-keyword">return</span> <span class="hljs-built_in">valueFromShadowNode</span>(
                runtime,
                uiManager-&gt;<span class="hljs-built_in">createNode</span>(
                    <span class="hljs-built_in">tagFromValue</span>(arguments[<span class="hljs-number">0</span>]),
                    <span class="hljs-built_in">stringFromValue</span>(runtime, arguments[<span class="hljs-number">1</span>]),
                    <span class="hljs-built_in">surfaceIdFromValue</span>(runtime, arguments[<span class="hljs-number">2</span>]),
                    <span class="hljs-built_in">RawProps</span>(runtime, arguments[<span class="hljs-number">3</span>]),
                    std::<span class="hljs-built_in">move</span>(instanceHandle)),
                <span class="hljs-literal">true</span>);
          } <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::logic_error&amp; ex) {
            <span class="hljs-built_in">LOG</span>(FATAL) &lt;&lt; <span class="hljs-string">"logic_error in createNode: "</span> &lt;&lt; ex.<span class="hljs-built_in">what</span>();
          }
        });
  }
  <span class="hljs-comment">// 省略部分代码......</span>

  <span class="hljs-keyword">return</span> jsi::Value::<span class="hljs-built_in">undefined</span>();
}
</code></pre>
<p>继续跟踪<code>react-native/packages/react-native/ReactCommon/react/renderer/uimanager/UIManager.cpp</code>中的<code>createNode</code>实现：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-function">std::shared_ptr&lt;ShadowNode&gt; <span class="hljs-title">UIManager::createNode</span><span class="hljs-params">(
    Tag tag,                  <span class="hljs-comment">// 节点标签</span>
    <span class="hljs-type">const</span> std::string&amp; name,  <span class="hljs-comment">// 组件名称</span>
    SurfaceId surfaceId,
    RawProps rawProps,        <span class="hljs-comment">// 原始属性</span>
    InstanceHandle::Shared instanceHandle)</span> <span class="hljs-type">const</span> </span>{
  <span class="hljs-function">TraceSection <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">"UIManager::createNode"</span>, <span class="hljs-string">"componentName"</span>, name)</span></span>;

  <span class="hljs-comment">// 根据组件名称获取对应的ComponentDescriptor</span>
  <span class="hljs-keyword">auto</span>&amp; componentDescriptor = componentDescriptorRegistry_-&gt;<span class="hljs-built_in">at</span>(name);
  <span class="hljs-keyword">auto</span> fallbackDescriptor =
      componentDescriptorRegistry_-&gt;<span class="hljs-built_in">getFallbackComponentDescriptor</span>();

  PropsParserContext propsParserContext{surfaceId, *contextContainer_};

  <span class="hljs-comment">// 创建ShadowNodeFamily，用于管理同一组件的不同实例</span>
  <span class="hljs-keyword">auto</span> family = componentDescriptor.<span class="hljs-built_in">createFamily</span>(
      {.tag = tag,
       .surfaceId = surfaceId,
       .instanceHandle = std::<span class="hljs-built_in">move</span>(instanceHandle)});

  <span class="hljs-comment">// 解析和克隆属性</span>
  <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> props = componentDescriptor.<span class="hljs-built_in">cloneProps</span>(
      propsParserContext, <span class="hljs-literal">nullptr</span>, std::<span class="hljs-built_in">move</span>(rawProps));
  <span class="hljs-comment">// 创建初始状态</span>
  <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> state = componentDescriptor.<span class="hljs-built_in">createInitialState</span>(props, family);

  <span class="hljs-comment">// 创建ShadowNode</span>
  <span class="hljs-keyword">auto</span> shadowNode = componentDescriptor.<span class="hljs-built_in">createShadowNode</span>(
      ShadowNodeFragment{
          .props = fallbackDescriptor != <span class="hljs-literal">nullptr</span> &amp;&amp;
                  fallbackDescriptor-&gt;<span class="hljs-built_in">getComponentHandle</span>() ==
                      componentDescriptor.<span class="hljs-built_in">getComponentHandle</span>()
              ? componentDescriptor.<span class="hljs-built_in">cloneProps</span>(
                    propsParserContext,
                    props,
                    <span class="hljs-built_in">RawProps</span>(folly::dynamic::<span class="hljs-built_in">object</span>(<span class="hljs-string">"name"</span>, name)))
              : props,
          .children = ShadowNodeFragment::<span class="hljs-built_in">childrenPlaceholder</span>(),
          .state = state,
      },
      family);

  <span class="hljs-keyword">if</span> (delegate_ != <span class="hljs-literal">nullptr</span>) {
    delegate_-&gt;<span class="hljs-built_in">uiManagerDidCreateShadowNode</span>(*shadowNode);
  }
  <span class="hljs-keyword">if</span> (leakChecker_) {
    leakChecker_-&gt;<span class="hljs-built_in">uiManagerDidCreateShadowNodeFamily</span>(family);
  }

  <span class="hljs-keyword">return</span> shadowNode;
}
</code></pre>
<p>可以看到，这里通过<code>componentDescriptorRegistry_</code>来查找Fabric 组件描述对象，至于注册的地方，下一节<strong>注册组件</strong>会专门分析。</p>
<p>这里还有一点要注意，<code>createShadowNode</code>方法只是创建了虚拟的<strong>ShadowNode</strong>，并没有创建真正的原生视图。ShadowNode是Fabric中的虚拟DOM节点，用于布局计算。也就是说当完成布局和diff计算后，会生成MountItem指令。</p>
<h5 data-id="heading-6">Kotlin层</h5>
<p>在前面<strong>启动渲染</strong>一节中，我们有分析到<code>createViewUnsafe</code>方法，回顾一下安卓原生组件的查找：</p>
<pre><code class="hljs language-kotlin" lang="kotlin">ViewManager viewManager = mViewManagerRegistry.<span class="hljs-keyword">get</span>(componentName);
</code></pre>
<p>跟踪源码<code>react-native/packages/react-native/ReactAndroid/src/main/java/com/facebook/react/uimanager/ViewManagerRegistry.kt</code>：</p>
<pre><code class="hljs language-kotlin" lang="kotlin">  <span class="hljs-meta">@Synchronized</span>
  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">get</span><span class="hljs-params">(className: <span class="hljs-type">String</span>)</span></span>: ViewManager&lt;*, *&gt; {
    <span class="hljs-comment">// 1. Try to get the manager without the prefix.</span>
    viewManagersMap[className]?.let {
      <span class="hljs-keyword">return</span> it
    }

    <span class="hljs-comment">// 2. Try to get the manager with the RCT prefix.</span>
    <span class="hljs-keyword">val</span> rctViewManagerName = <span class="hljs-string">"RCT<span class="hljs-variable">$className</span>"</span>
    viewManagersMap[rctViewManagerName]?.let {
      <span class="hljs-keyword">return</span> it
    }

    <span class="hljs-keyword">if</span> (viewManagerResolver != <span class="hljs-literal">null</span>) {

      <span class="hljs-comment">// 1. Try to get the manager without the prefix.</span>
      <span class="hljs-keyword">val</span> resolvedManager = getViewManagerFromResolver(className)
      <span class="hljs-keyword">if</span> (resolvedManager != <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">return</span> resolvedManager
      }

      <span class="hljs-comment">// 2. Try to get the manager with the RCT prefix.</span>
      <span class="hljs-keyword">val</span> rctResolvedManager = getViewManagerFromResolver(rctViewManagerName)
      <span class="hljs-keyword">if</span> (rctResolvedManager != <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">return</span> rctResolvedManager
      }

      <span class="hljs-keyword">throw</span> IllegalViewOperationException(
          <span class="hljs-string">"Can't find ViewManager '<span class="hljs-variable">$className</span>' nor '<span class="hljs-variable">$rctViewManagerName</span>' in ViewManagerRegistry, "</span> +
              <span class="hljs-string">"existing names are: <span class="hljs-subst">${viewManagerResolver.getViewManagerNames()}</span>"</span>
      )
    }

    <span class="hljs-keyword">throw</span> IllegalViewOperationException(<span class="hljs-string">"No ViewManager found for class <span class="hljs-variable">$className</span>"</span>)
  }

  <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getViewManagerFromResolver</span><span class="hljs-params">(className: <span class="hljs-type">String</span>)</span></span>: ViewManager&lt;*, *&gt;? {
    <span class="hljs-keyword">val</span> viewManager = viewManagerResolver?.getViewManager(className)
    <span class="hljs-keyword">if</span> (viewManager != <span class="hljs-literal">null</span>) {
      viewManagersMap[className] = viewManager
    }
    <span class="hljs-keyword">return</span> viewManager
  }
</code></pre>
<p>新架构的情况下，是通过<code>getViewManagerFromResolver</code>方法来查找，其中<code>viewManagerResolver</code>的类型是<code>BridgelessViewManagerResolver</code>，它是一个内部类，定义在<code>ReactInstance.kt</code>文件中：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BridgelessViewManagerResolver</span>(
      <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> reactPackages: List&lt;ReactPackage&gt;,
      <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> context: BridgelessReactContext,
  ) : ViewManagerResolver {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> lazyViewManagerMap: MutableMap&lt;String, ViewManager&lt;*, *&gt;&gt; = HashMap()

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getViewManager</span><span class="hljs-params">(viewManagerName: <span class="hljs-type">String</span>)</span></span>: ViewManager&lt;*, *&gt;? {
      <span class="hljs-comment">// 从懒加载包中查找</span>
      <span class="hljs-keyword">val</span> viewManager = getLazyViewManager(viewManagerName)
      <span class="hljs-keyword">if</span> (viewManager != <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">return</span> viewManager
      }
      <span class="hljs-comment">// 如果通过延迟加载在所有 React 包中都找不到视图管理器，则回退到默认实现：立即初始化所有视图管理器</span>
      <span class="hljs-keyword">return</span> eagerViewManagerMap[viewManagerName]
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> _eagerViewManagerMap: Map&lt;String, ViewManager&lt;*, *&gt;&gt;

    <span class="hljs-meta">@get:Synchronized</span>
    <span class="hljs-keyword">val</span> eagerViewManagerMap: Map&lt;String, ViewManager&lt;*, *&gt;&gt;
      <span class="hljs-keyword">get</span>() {
        <span class="hljs-keyword">if</span> (::_eagerViewManagerMap.isInitialized) {
          <span class="hljs-keyword">return</span> _eagerViewManagerMap
        }

        <span class="hljs-keyword">val</span> viewManagerMap: MutableMap&lt;String, ViewManager&lt;*, *&gt;&gt; = HashMap()
        <span class="hljs-keyword">for</span> (reactPackage <span class="hljs-keyword">in</span> reactPackages) {
          <span class="hljs-keyword">if</span> (reactPackage <span class="hljs-keyword">is</span> ViewManagerOnDemandReactPackage) {
            <span class="hljs-keyword">continue</span>
          }

          <span class="hljs-keyword">val</span> viewManagersInPackage = reactPackage.createViewManagers(context)
          <span class="hljs-keyword">for</span> (viewManager <span class="hljs-keyword">in</span> viewManagersInPackage) {
            <span class="hljs-comment">// TODO(T173624687): Should we throw/warn when the same view manager name is registered</span>
            <span class="hljs-comment">// twice?</span>
            viewManagerMap[viewManager.name] = viewManager
          }
        }

        _eagerViewManagerMap = viewManagerMap
        <span class="hljs-keyword">return</span> viewManagerMap
      }

    <span class="hljs-meta">@Synchronized</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getLazyViewManager</span><span class="hljs-params">(viewManagerName: <span class="hljs-type">String</span>)</span></span>: ViewManager&lt;*, *&gt;? {
      <span class="hljs-comment">// 先查缓存 </span>
      <span class="hljs-keyword">if</span> (lazyViewManagerMap.containsKey(viewManagerName)) {
        <span class="hljs-keyword">return</span> lazyViewManagerMap[viewManagerName]
      }

      <span class="hljs-comment">// 缓存未命中则遍历所有 reactPackages，调用 createViewManager(name) 创建</span>
      <span class="hljs-keyword">for</span> (reactPackage <span class="hljs-keyword">in</span> reactPackages) {
        <span class="hljs-keyword">if</span> (reactPackage <span class="hljs-keyword">is</span> ViewManagerOnDemandReactPackage) {
          <span class="hljs-keyword">val</span> viewManager = reactPackage.createViewManager(context, viewManagerName)
          <span class="hljs-keyword">if</span> (viewManager != <span class="hljs-literal">null</span>) {
            <span class="hljs-comment">// TODO(T173624687): Should we throw/warn when the same view manager name is registered</span>
            <span class="hljs-comment">// twice?</span>
            lazyViewManagerMap[viewManagerName] = viewManager
            <span class="hljs-keyword">return</span> viewManager
          }
        }
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>
    }

    <span class="hljs-comment">// 省略部分代码......</span>
  }
</code></pre>
<h4 data-id="heading-7">注册组件</h4>
<h5 data-id="heading-8">JS工具</h5>
<p>React Native新架构使用了很多代码生成工具，以致于成了黑箱操作，这对于Turbo Module和Fabric组件的注册流程造成了理解上的困难。为此，我们不得不研究这些CLI工具。首先研究<code>@react-native-community/cli</code>工具，源码 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Freact-native-community%2Fcli" target="_blank" title="https://github.com/react-native-community/cli" ref="nofollow noopener noreferrer">cli</a>。这里我们使用的版本是<code>v20.0.2</code>。</p>
<p>查看源码<code>cli/packages/cli-config-android/src/config/index.ts</code>：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">dependencyConfig</span>(<span class="hljs-params">
  root: <span class="hljs-built_in">string</span>,
  userConfig: AndroidDependencyParams | <span class="hljs-literal">null</span> = {},
</span>): <span class="hljs-title class_">AndroidDependencyConfig</span> | <span class="hljs-literal">null</span> {
  <span class="hljs-keyword">if</span> (userConfig === <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }

  <span class="hljs-keyword">const</span> src = userConfig.<span class="hljs-property">sourceDir</span> || <span class="hljs-title function_">findAndroidDir</span>(root);

  <span class="hljs-keyword">if</span> (!src) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }

  <span class="hljs-keyword">const</span> sourceDir = path.<span class="hljs-title function_">join</span>(root, src);
  <span class="hljs-keyword">const</span> manifestPath = userConfig.<span class="hljs-property">manifestPath</span>
    ? path.<span class="hljs-title function_">join</span>(sourceDir, userConfig.<span class="hljs-property">manifestPath</span>)
    : <span class="hljs-title function_">findManifest</span>(sourceDir);
  <span class="hljs-keyword">const</span> buildGradlePath = <span class="hljs-title function_">findBuildGradle</span>(sourceDir, <span class="hljs-string">''</span>);
  <span class="hljs-keyword">const</span> isPureCxxDependency =
    userConfig.<span class="hljs-property">cxxModuleCMakeListsModuleName</span> != <span class="hljs-literal">null</span> &amp;&amp;
    userConfig.<span class="hljs-property">cxxModuleCMakeListsPath</span> != <span class="hljs-literal">null</span> &amp;&amp;
    userConfig.<span class="hljs-property">cxxModuleHeaderName</span> != <span class="hljs-literal">null</span> &amp;&amp;
    !manifestPath &amp;&amp;
    !buildGradlePath;

  <span class="hljs-keyword">if</span> (!manifestPath &amp;&amp; !buildGradlePath &amp;&amp; !isPureCxxDependency) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }

  <span class="hljs-keyword">let</span> packageImportPath = <span class="hljs-literal">null</span>,
    packageInstance = <span class="hljs-literal">null</span>;

  <span class="hljs-keyword">if</span> (!isPureCxxDependency) {
    <span class="hljs-keyword">const</span> packageName =
      userConfig.<span class="hljs-property">packageName</span> || <span class="hljs-title function_">getPackageName</span>(manifestPath, buildGradlePath);
    <span class="hljs-keyword">const</span> packageClassName = <span class="hljs-title function_">findPackageClassName</span>(sourceDir);

    <span class="hljs-comment">/**
     * This module has no package to export
     */</span>
    <span class="hljs-keyword">if</span> (!packageClassName) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    packageImportPath =
      userConfig.<span class="hljs-property">packageImportPath</span> ||
      <span class="hljs-string">`import <span class="hljs-subst">${packageName}</span>.<span class="hljs-subst">${packageClassName}</span>;`</span>;

    packageInstance = userConfig.<span class="hljs-property">packageInstance</span> || <span class="hljs-string">`new <span class="hljs-subst">${packageClassName}</span>()`</span>;
  }

  <span class="hljs-keyword">const</span> buildTypes = userConfig.<span class="hljs-property">buildTypes</span> || [];
  <span class="hljs-keyword">const</span> dependencyConfiguration = userConfig.<span class="hljs-property">dependencyConfiguration</span>;
  <span class="hljs-keyword">const</span> libraryName =
    userConfig.<span class="hljs-property">libraryName</span> || <span class="hljs-title function_">findLibraryName</span>(root, sourceDir);
  <span class="hljs-keyword">const</span> componentDescriptors =
    userConfig.<span class="hljs-property">componentDescriptors</span> || <span class="hljs-title function_">findComponentDescriptors</span>(root);
  <span class="hljs-keyword">let</span> cmakeListsPath = userConfig.<span class="hljs-property">cmakeListsPath</span>
    ? path.<span class="hljs-title function_">join</span>(sourceDir, userConfig.<span class="hljs-property">cmakeListsPath</span>)
    : path.<span class="hljs-title function_">join</span>(sourceDir, <span class="hljs-string">'build/generated/source/codegen/jni/CMakeLists.txt'</span>);
  <span class="hljs-keyword">const</span> cxxModuleCMakeListsModuleName =
    userConfig.<span class="hljs-property">cxxModuleCMakeListsModuleName</span> || <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">const</span> cxxModuleHeaderName = userConfig.<span class="hljs-property">cxxModuleHeaderName</span> || <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">let</span> cxxModuleCMakeListsPath = userConfig.<span class="hljs-property">cxxModuleCMakeListsPath</span>
    ? path.<span class="hljs-title function_">join</span>(sourceDir, userConfig.<span class="hljs-property">cxxModuleCMakeListsPath</span>)
    : <span class="hljs-literal">null</span>;

  <span class="hljs-keyword">if</span> (process.<span class="hljs-property">platform</span> === <span class="hljs-string">'win32'</span>) {
    cmakeListsPath = cmakeListsPath.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\\/g</span>, <span class="hljs-string">'/'</span>);
    <span class="hljs-keyword">if</span> (cxxModuleCMakeListsPath) {
      cxxModuleCMakeListsPath = cxxModuleCMakeListsPath.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\\/g</span>, <span class="hljs-string">'/'</span>);
    }
  }

  <span class="hljs-keyword">return</span> {
    sourceDir,
    packageImportPath,
    packageInstance,
    buildTypes,
    dependencyConfiguration,
    libraryName,
    componentDescriptors,
    cmakeListsPath,
    cxxModuleCMakeListsModuleName,
    cxxModuleCMakeListsPath,
    cxxModuleHeaderName,
    isPureCxxDependency,
  };
}
</code></pre>
<p>此<code>dependencyConfig</code>函数非常重要，它主要用于生成<code>example/android/build/generated/autolinking/autolinking.json</code>文件。<code>autolinking.json</code>文件我们在前面的TurboModule的文章已经介绍过了，其中的信息是指导代码生成的关键。这里重点关注<code>componentDescriptors</code>字段的生成，因为它是Fabric组件代码生成的起始。</p>
<p>组件开发者通常并不会在<code>react-native.config.js</code>文件中主动配置<code>componentDescriptors</code>字段，一般都是默认值，那么就要查看一下<code>findComponentDescriptors</code>函数的实现逻辑了，源码<code>cli/packages/cli-config-android/src/config/findComponentDescriptors.ts</code>：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">findComponentDescriptors</span>(<span class="hljs-params">packageRoot: <span class="hljs-built_in">string</span></span>) {
  <span class="hljs-keyword">let</span> jsSrcsDir = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> packageJson = fs.<span class="hljs-title function_">readFileSync</span>(
      path.<span class="hljs-title function_">join</span>(packageRoot, <span class="hljs-string">'package.json'</span>),
      <span class="hljs-string">'utf8'</span>,
    );
    jsSrcsDir = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(packageJson).<span class="hljs-property">codegenConfig</span>.<span class="hljs-property">jsSrcsDir</span>;
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-comment">// no jsSrcsDir, continue with default glob pattern</span>
  }
  <span class="hljs-keyword">const</span> globPattern = jsSrcsDir
    ? <span class="hljs-string">`<span class="hljs-subst">${jsSrcsDir}</span>/**/*{.js,.jsx,.ts,.tsx}`</span>
    : <span class="hljs-string">'**/*{.js,.jsx,.ts,.tsx}'</span>;
  <span class="hljs-keyword">const</span> files = glob.<span class="hljs-title function_">sync</span>(globPattern, {
    <span class="hljs-attr">cwd</span>: <span class="hljs-title function_">unixifyPaths</span>(packageRoot),
    <span class="hljs-attr">onlyFiles</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">ignore</span>: [<span class="hljs-string">'**/node_modules/**'</span>],
  });
  <span class="hljs-keyword">const</span> codegenComponent = files
    .<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">filePath</span>) =&gt;</span>
      fs.<span class="hljs-title function_">readFileSync</span>(path.<span class="hljs-title function_">join</span>(packageRoot, filePath), <span class="hljs-string">'utf8'</span>),
    )
    .<span class="hljs-title function_">map</span>(extractComponentDescriptors)
    .<span class="hljs-title function_">filter</span>(<span class="hljs-title class_">Boolean</span>);

  <span class="hljs-comment">// Filter out duplicates as it happens that libraries contain multiple outputs due to package publishing.</span>
  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> consider using "codegenConfig" to avoid this.</span>
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(codegenComponent <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>[]));
}
</code></pre>
<p>这里主要逻辑其实是从<code>package.json</code>中获取到<code>jsSrcsDir</code>配置，从而定位到源码所在目录。我们关注的是<code>codegenComponent</code>的生成，此处是通过读取每个源文件内容，然后调用 <code>extractComponentDescriptors</code> 提取组件描述符。继续查看<code>cli/packages/cli-config-android/src/config/extractComponentDescriptors.ts</code>：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CODEGEN_NATIVE_COMPONENT_REGEX</span> =
  <span class="hljs-regexp">/codegenNativeComponent(&lt;.*&gt;)?\s*\(\s*["'`](\w+)["'`](,?[\s\S]+interfaceOnly:\s*(\w+))?/m</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">extractComponentDescriptors</span>(<span class="hljs-params">contents: <span class="hljs-built_in">string</span></span>) {
  <span class="hljs-keyword">const</span> match = contents.<span class="hljs-title function_">match</span>(<span class="hljs-variable constant_">CODEGEN_NATIVE_COMPONENT_REGEX</span>);
  <span class="hljs-keyword">if</span> (!(match?.[<span class="hljs-number">4</span>] === <span class="hljs-string">'true'</span>) &amp;&amp; match?.[<span class="hljs-number">2</span>]) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${match[<span class="hljs-number">2</span>]}</span>ComponentDescriptor`</span>;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}
</code></pre>
<p>到这里就很清楚了，扫描所有源码，使用正则找到我们在声明组件一节中提到的<code>export default codegenNativeComponent&lt;NativeProps&gt;('CustomviewView');</code>这行代码，这里的正则就是匹配关键字<code>codegenNativeComponent</code>。这里的<code>match?.[2]</code>就是提前出组件名，也就是我们示例中的<code>CustomviewView</code>。最终返回的字符串是拼接后的，这里就是<code>CustomviewViewComponentDescriptor</code>。也就是说<code>componentDescriptors</code>字段的默认值是<code>CustomviewViewComponentDescriptor</code>。</p>
<p>接下来我们回顾前文《Android端TurboModule分析》，其中提到但略过的React Gradle脚本的<code>configureCodegen</code>方法：</p>
<pre><code class="hljs language-kotlin" lang="kotlin">  <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">configureCodegen</span><span class="hljs-params">(
      project: <span class="hljs-type">Project</span>,
      localExtension: <span class="hljs-type">ReactExtension</span>,
      rootExtension: <span class="hljs-type">PrivateReactExtension</span>,
      isLibrary: <span class="hljs-type">Boolean</span>,
  )</span></span> {
    <span class="hljs-comment">// 首先，我们需要设置 Codegen 的输出目录</span>
    <span class="hljs-keyword">val</span> generatedSrcDir: Provider&lt;Directory&gt; =
        project.layout.buildDirectory.dir(<span class="hljs-string">"generated/source/codegen"</span>)

    <span class="hljs-comment">// 我们为 jsRootDir（JS根目录）指定默认值（约定）。</span>
    <span class="hljs-comment">// 对于 App 来说是根文件夹（即 Gradle 项目的 ../../）</span>
    <span class="hljs-comment">// 对于 Library 来说是包文件夹（即 Gradle 项目的 ../）</span>
    <span class="hljs-keyword">if</span> (isLibrary) {
      localExtension.jsRootDir.convention(project.layout.projectDirectory.dir(<span class="hljs-string">"../"</span>))
    } <span class="hljs-keyword">else</span> {
      localExtension.jsRootDir.convention(localExtension.root)
    }

    <span class="hljs-comment">// 我们创建任务以从 JS 文件生成 Schema</span>
    <span class="hljs-keyword">val</span> generateCodegenSchemaTask =
        project.tasks.register(
            <span class="hljs-string">"generateCodegenSchemaFromJavaScript"</span>,
            GenerateCodegenSchemaTask::<span class="hljs-keyword">class</span>.java,
        ) { it -&gt;
          it.nodeExecutableAndArgs.<span class="hljs-keyword">set</span>(rootExtension.nodeExecutableAndArgs)
          it.codegenDir.<span class="hljs-keyword">set</span>(rootExtension.codegenDir)
          it.generatedSrcDir.<span class="hljs-keyword">set</span>(generatedSrcDir)
          it.nodeWorkingDir.<span class="hljs-keyword">set</span>(project.layout.projectDirectory.asFile.absolutePath)

          <span class="hljs-comment">// 我们在配置阶段读取 package.json，以便正确地填充此任务的 `jsRootDir` @Input 属性</span>
          <span class="hljs-comment">// 以及 onlyIf 条件。因此，parsePackageJson 应该在这个 lambda 表达式内部被调用。</span>
          <span class="hljs-keyword">val</span> packageJson = findPackageJsonFile(project, rootExtension.root)
          <span class="hljs-keyword">val</span> parsedPackageJson = packageJson?.let { JsonUtils.fromPackageJson(it) }

          <span class="hljs-keyword">val</span> jsSrcsDirInPackageJson = parsedPackageJson?.codegenConfig?.jsSrcsDir
          <span class="hljs-keyword">val</span> includesGeneratedCode =
              parsedPackageJson?.codegenConfig?.includesGeneratedCode ?: <span class="hljs-literal">false</span>
          <span class="hljs-keyword">if</span> (jsSrcsDirInPackageJson != <span class="hljs-literal">null</span>) {
            it.jsRootDir.<span class="hljs-keyword">set</span>(File(packageJson.parentFile, jsSrcsDirInPackageJson))
          } <span class="hljs-keyword">else</span> {
            it.jsRootDir.<span class="hljs-keyword">set</span>(localExtension.jsRootDir)
          }
          it.jsInputFiles.<span class="hljs-keyword">set</span>(
              project.fileTree(it.jsRootDir) { tree -&gt;
                tree.include(<span class="hljs-string">"**/*.js"</span>)
                tree.include(<span class="hljs-string">"**/*.jsx"</span>)
                tree.include(<span class="hljs-string">"**/*.ts"</span>)
                tree.include(<span class="hljs-string">"**/*.tsx"</span>)

                tree.exclude(<span class="hljs-string">"node_modules/**/*"</span>)
                tree.exclude(<span class="hljs-string">"**/*.d.ts"</span>)
                <span class="hljs-comment">// 我们希望排除 build 目录，以避免在执行规避检查时选中它们</span>
                tree.exclude(<span class="hljs-string">"**/build/**/*"</span>)
              }
          )

          <span class="hljs-keyword">val</span> needsCodegenFromPackageJson = project.needsCodegenFromPackageJson(rootExtension.root)
          it.onlyIf { (isLibrary || needsCodegenFromPackageJson) &amp;&amp; !includesGeneratedCode }
        }

    <span class="hljs-comment">// 我们创建任务以从 Schema 生成 Java 代码</span>
    <span class="hljs-keyword">val</span> generateCodegenArtifactsTask =
        project.tasks.register(
            <span class="hljs-string">"generateCodegenArtifactsFromSchema"</span>,
            GenerateCodegenArtifactsTask::<span class="hljs-keyword">class</span>.java,
        ) { task -&gt;
          task.dependsOn(generateCodegenSchemaTask)
          task.reactNativeDir.<span class="hljs-keyword">set</span>(rootExtension.reactNativeDir)
          task.nodeExecutableAndArgs.<span class="hljs-keyword">set</span>(rootExtension.nodeExecutableAndArgs)
          task.generatedSrcDir.<span class="hljs-keyword">set</span>(generatedSrcDir)
          task.packageJsonFile.<span class="hljs-keyword">set</span>(findPackageJsonFile(project, rootExtension.root))
          task.codegenJavaPackageName.<span class="hljs-keyword">set</span>(localExtension.codegenJavaPackageName)
          task.libraryName.<span class="hljs-keyword">set</span>(localExtension.libraryName)
          task.nodeWorkingDir.<span class="hljs-keyword">set</span>(project.layout.projectDirectory.asFile.absolutePath)

          <span class="hljs-comment">// 请注意，appNeedsCodegen 会触发在配置阶段读取 package.json，</span>
          <span class="hljs-comment">// 因为我们需要填充此任务的 onlyIf 条件。</span>
          <span class="hljs-comment">// 因此，appNeedsCodegen 需要在这个 lambda 表达式内部被调用</span>
          <span class="hljs-keyword">val</span> needsCodegenFromPackageJson = project.needsCodegenFromPackageJson(rootExtension.root)
          <span class="hljs-keyword">val</span> packageJson = findPackageJsonFile(project, rootExtension.root)
          <span class="hljs-keyword">val</span> parsedPackageJson = packageJson?.let { JsonUtils.fromPackageJson(it) }
          <span class="hljs-keyword">val</span> includesGeneratedCode =
              parsedPackageJson?.codegenConfig?.includesGeneratedCode ?: <span class="hljs-literal">false</span>
          task.onlyIf { (isLibrary || needsCodegenFromPackageJson) &amp;&amp; !includesGeneratedCode }
        }

    <span class="hljs-comment">// 我们更新 Android 配置以包含生成的源码</span>
    <span class="hljs-comment">// 这相当于以下的 DSL：</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// android { sourceSets { main { java { srcDirs += "$generatedSrcDir/java" } } } }</span>
    <span class="hljs-keyword">if</span> (isLibrary) {
      project.extensions.getByType(LibraryAndroidComponentsExtension::<span class="hljs-keyword">class</span>.java).finalizeDsl { ext
        -&gt;
        ext.sourceSets.getByName(<span class="hljs-string">"main"</span>).java.srcDir(generatedSrcDir.<span class="hljs-keyword">get</span>().dir(<span class="hljs-string">"java"</span>).asFile)
      }
    } <span class="hljs-keyword">else</span> {
      project.extensions.getByType(ApplicationAndroidComponentsExtension::<span class="hljs-keyword">class</span>.java).finalizeDsl {
          ext -&gt;
        ext.sourceSets.getByName(<span class="hljs-string">"main"</span>).java.srcDir(generatedSrcDir.<span class="hljs-keyword">get</span>().dir(<span class="hljs-string">"java"</span>).asFile)
      }
    }

    <span class="hljs-comment">// `preBuild` 是 AGP 自动注册的基础任务之一</span>
    <span class="hljs-comment">// 这将在编译整个项目之前调用 Codegen</span>
    project.tasks.named(<span class="hljs-string">"preBuild"</span>, Task::<span class="hljs-keyword">class</span>.java).dependsOn(generateCodegenArtifactsTask)
  }
</code></pre>
<p><code>configureCodegen</code> 是 React Native Gradle 插件的核心方法，负责配置 <strong>Fabric/TurboModule 新架构的代码生成（Codegen）流程</strong>。该方法在 Gradle 配置阶段执行，设置两个关键任务和 Android 源码集集成。</p>
<p>其流程可以分为五个阶段：</p>
<ol>
<li>
<p>设置输出目录和 JS 根目录</p>
</li>
<li>
<p>创建 Schema 生成任务</p>
</li>
<li>
<p>创建代码生成任务</p>
</li>
<li>
<p>集成到 Android 构建系统</p>
</li>
<li>
<p>挂载到构建生命周期</p>
</li>
</ol>
<p>这里概括一下整个流程：</p>
<pre><code class="hljs language-bash" lang="bash">1. Gradle 配置阶段
   ├─&gt; 设置 generatedSrcDir = <span class="hljs-string">"build/generated/source/codegen"</span>
   ├─&gt; 设置 jsRootDir 默认值（Library: <span class="hljs-string">"../"</span>, App: root）
   ├─&gt; 读取 package.json（配置阶段）
   │   ├─&gt; 检查 codegenConfig.jsSrcsDir
   │   └─&gt; 检查 codegenConfig.includesGeneratedCode
   ├─&gt; 注册 generateCodegenSchemaTask
   │   ├─&gt; 配置 Node.js 环境
   │   ├─&gt; 设置 JS 输入文件（**/*.{js,jsx,ts,tsx}）
   │   └─&gt; 设置 onlyIf 条件
   ├─&gt; 注册 generateCodegenArtifactsTask
   │   ├─&gt; 依赖 generateCodegenSchemaTask
   │   └─&gt; 设置 onlyIf 条件
   ├─&gt; 配置 Android SourceSets
   │   └─&gt; 添加 generatedSrcDir/java 到 main SourceSet
   └─&gt; 建立 preBuild 依赖关系

2. Gradle 执行阶段（运行 ./gradlew build）
   ├─&gt; preBuild 任务执行
   │   └─&gt; generateCodegenArtifactsTask 执行
   │         ├─&gt; generateCodegenSchemaTask 执行
   │         │     ├─&gt; 扫描 JS/TS 文件
   │         │     └─&gt; 生成 schema.json
   │         └─&gt; 根据 schema.json 生成 Java/C++ 代码
   └─&gt; compileJava 编译生成的代码
</code></pre>
<p>这里的两个关键任务分别是<strong>generateCodegenSchemaFromJavaScript</strong>和<strong>generateCodegenArtifactsFromSchema</strong>。前者从 JS/TS 生成 Schema JSON文件，后者从 Schema 生成 Java/C++ 代码。</p>
<p>Schema JSON主要是JS/TS的接口描述，生成路径是<code>Your Project/node_modules/Third-party Lib/android/build/generated/source/codegen/schema.json</code>，可以自行查看，这里我们重点关注<code>generateCodegenArtifactsFromSchema</code>，源码<code>react-native/packages/gradle-plugin/react-native-gradle-plugin/src/main/kotlin/com/facebook/react/tasks/GenerateCodegenArtifactsTask.kt</code>：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenerateCodegenArtifactsTask</span> : <span class="hljs-type">Exec</span>() {
  <span class="hljs-meta">@get:Internal</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">val</span> reactNativeDir: DirectoryProperty
  <span class="hljs-meta">@get:Internal</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">val</span> generatedSrcDir: DirectoryProperty
  <span class="hljs-meta">@get:InputFile</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">val</span> packageJsonFile: RegularFileProperty   <span class="hljs-comment">// package.json 文件路径</span>
  <span class="hljs-meta">@get:Input</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">val</span> nodeWorkingDir: Property&lt;String&gt;
  <span class="hljs-meta">@get:Input</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">val</span> nodeExecutableAndArgs: ListProperty&lt;String&gt;
  <span class="hljs-meta">@get:Input</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">val</span> codegenJavaPackageName: Property&lt;String&gt;
  <span class="hljs-meta">@get:Input</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">val</span> libraryName: Property&lt;String&gt;

  <span class="hljs-meta">@get:InputFile</span>
  <span class="hljs-keyword">val</span> generatedSchemaFile: Provider&lt;RegularFile&gt; = generatedSrcDir.file(<span class="hljs-string">"schema.json"</span>)

  <span class="hljs-meta">@get:OutputDirectory</span> <span class="hljs-keyword">val</span> generatedJavaFiles: Provider&lt;Directory&gt; = generatedSrcDir.dir(<span class="hljs-string">"java"</span>)
  <span class="hljs-meta">@get:OutputDirectory</span> <span class="hljs-keyword">val</span> generatedJniFiles: Provider&lt;Directory&gt; = generatedSrcDir.dir(<span class="hljs-string">"jni"</span>)

  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">exec</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> (resolvedLibraryName, resolvedCodegenJavaPackageName) = resolveTaskParameters()
    setupCommandLine(resolvedLibraryName, resolvedCodegenJavaPackageName)
    <span class="hljs-keyword">super</span>.exec()
  }

  <span class="hljs-keyword">internal</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resolveTaskParameters</span><span class="hljs-params">()</span></span>: Pair&lt;String, String&gt; {
    <span class="hljs-keyword">val</span> parsedPackageJson =
        <span class="hljs-keyword">if</span> (packageJsonFile.isPresent &amp;&amp; packageJsonFile.<span class="hljs-keyword">get</span>().asFile.exists()) {
          JsonUtils.fromPackageJson(packageJsonFile.<span class="hljs-keyword">get</span>().asFile)
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-literal">null</span>
        }
    <span class="hljs-keyword">val</span> resolvedLibraryName = parsedPackageJson?.codegenConfig?.name ?: libraryName.<span class="hljs-keyword">get</span>()
    <span class="hljs-keyword">val</span> resolvedCodegenJavaPackageName =
        parsedPackageJson?.codegenConfig?.android?.javaPackageName ?: codegenJavaPackageName.<span class="hljs-keyword">get</span>()
    <span class="hljs-keyword">return</span> resolvedLibraryName to resolvedCodegenJavaPackageName
  }

  <span class="hljs-keyword">internal</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setupCommandLine</span><span class="hljs-params">(libraryName: <span class="hljs-type">String</span>, codegenJavaPackageName: <span class="hljs-type">String</span>)</span></span> {
    <span class="hljs-keyword">val</span> workingDir = File(nodeWorkingDir.<span class="hljs-keyword">get</span>())
    commandLine(
        windowsAwareCommandLine(
            *nodeExecutableAndArgs.<span class="hljs-keyword">get</span>().toTypedArray(),
            reactNativeDir.file(<span class="hljs-string">"scripts/generate-specs-cli.js"</span>).<span class="hljs-keyword">get</span>().asFile.cliPath(workingDir),
            <span class="hljs-string">"--platform"</span>,
            <span class="hljs-string">"android"</span>,
            <span class="hljs-string">"--schemaPath"</span>,
            generatedSchemaFile.<span class="hljs-keyword">get</span>().asFile.cliPath(workingDir),
            <span class="hljs-string">"--outputDir"</span>,
            generatedSrcDir.<span class="hljs-keyword">get</span>().asFile.cliPath(workingDir),
            <span class="hljs-string">"--libraryName"</span>,
            libraryName,
            <span class="hljs-string">"--javaPackageName"</span>,
            codegenJavaPackageName,
        )
    )
  }
}
</code></pre>
<p>该类主要用于执行外部 Node.js 命令，依据 <code>schema.json</code>文件，生成 Java/JNI 代码。需要注意一下，这里<code>libraryName</code>和<code>codegenJavaPackageName</code>的取值，代码中是通过<code>resolveTaskParameters</code>方法提取出来的。回顾一下package.json文件的配置，大概是以下结构：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"codegenConfig"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"MyLibrary"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"android"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"javaPackageName"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"com.example.mylibrary"</span>
    <span class="hljs-punctuation">}</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p>那么<code>libraryName</code>就是<code>"MyLibrary"</code>，<code>codegenJavaPackageName</code>就是<code>"com.example.mylibrary"</code>。</p>
<p>现在再还原一下命令，其实就是以下形式：</p>
<pre><code class="hljs language-shell" lang="shell">node &lt;reactNativeDir&gt;/scripts/generate-specs-cli.js \
  --platform android \
  --schemaPath &lt;generatedSrcDir&gt;/schema.json \
  --outputDir &lt;generatedSrcDir&gt; \
  --libraryName &lt;resolvedLibraryName&gt; \
  --javaPackageName &lt;resolvedCodegenJavaPackageName&gt;
</code></pre>
<p>我们定位到该js文件<code>react-native/packages/react-native/scripts/generate-specs-cli.js</code>：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> executor = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./codegen/generate-specs-cli-executor'</span>);
<span class="hljs-comment">// 省略......</span>

<span class="hljs-keyword">function</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"/>) {
  executor.<span class="hljs-title function_">execute</span>(
    <span class="hljs-comment">// $FlowFixMe[prop-missing]</span>
    argv.<span class="hljs-property">platform</span>,
    <span class="hljs-comment">// $FlowFixMe[prop-missing]</span>
    argv.<span class="hljs-property">schemaPath</span>,
    <span class="hljs-comment">// $FlowFixMe[prop-missing]</span>
    argv.<span class="hljs-property">outputDir</span>,
    <span class="hljs-comment">// $FlowFixMe[prop-missing]</span>
    argv.<span class="hljs-property">libraryName</span>,
    <span class="hljs-comment">// $FlowFixMe[prop-missing]</span>
    argv.<span class="hljs-property">javaPackageName</span>,
    <span class="hljs-comment">// $FlowFixMe[prop-missing]</span>
    argv.<span class="hljs-property">libraryType</span>,
  );
}

<span class="hljs-title function_">main</span>();
</code></pre>
<p>继续跟踪<code>react-native/packages/react-native/scripts/codegen/generate-specs-cli-executor.js</code></p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> utils = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./codegen-utils'</span>);

<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">GENERATORS</span> <span class="hljs-comment">/*: {[string]: {[string]: $ReadOnlyArray&lt;string&gt;}} */</span> = {
  <span class="hljs-attr">all</span>: {
    <span class="hljs-attr">android</span>: [<span class="hljs-string">'componentsAndroid'</span>, <span class="hljs-string">'modulesAndroid'</span>, <span class="hljs-string">'modulesCxx'</span>],
    <span class="hljs-attr">ios</span>: [<span class="hljs-string">'componentsIOS'</span>, <span class="hljs-string">'modulesIOS'</span>, <span class="hljs-string">'modulesCxx'</span>],
  },
  <span class="hljs-attr">components</span>: {
    <span class="hljs-attr">android</span>: [<span class="hljs-string">'componentsAndroid'</span>],
    <span class="hljs-attr">ios</span>: [<span class="hljs-string">'componentsIOS'</span>],
  },
  <span class="hljs-attr">modules</span>: {
    <span class="hljs-attr">android</span>: [<span class="hljs-string">'modulesAndroid'</span>, <span class="hljs-string">'modulesCxx'</span>],
    <span class="hljs-attr">ios</span>: [<span class="hljs-string">'modulesIOS'</span>, <span class="hljs-string">'modulesCxx'</span>],
  },
};

<span class="hljs-keyword">function</span> <span class="hljs-title function_">generateSpecFromInMemorySchema</span>(<span class="hljs-params">
  platform <span class="hljs-comment">/*: string */</span>,
  schema <span class="hljs-comment">/*: string */</span>,
  outputDirectory <span class="hljs-comment">/*: string */</span>,
  libraryName <span class="hljs-comment">/*: string */</span>,
  packageName <span class="hljs-comment">/*: string */</span>,
  libraryType <span class="hljs-comment">/*: string */</span>,
  useLocalIncludePaths <span class="hljs-comment">/*: boolean */</span>,
</span>) {
  <span class="hljs-title function_">validateLibraryType</span>(libraryType);
  <span class="hljs-title function_">createOutputDirectoryIfNeeded</span>(outputDirectory, libraryName);
  <span class="hljs-keyword">const</span> includeGetDebugPropsImplementation =
    libraryName.<span class="hljs-title function_">includes</span>(<span class="hljs-string">'FBReactNativeSpec'</span>); <span class="hljs-comment">//only generate getDebugString for React Native Core Components</span>
  utils.<span class="hljs-title function_">getCodegen</span>().<span class="hljs-title function_">generate</span>(
    {
      libraryName,
      schema,
      outputDirectory,
      packageName,
      <span class="hljs-attr">assumeNonnull</span>: platform === <span class="hljs-string">'ios'</span>,
      useLocalIncludePaths,
      includeGetDebugPropsImplementation,
    },
    {
      <span class="hljs-attr">generators</span>: <span class="hljs-variable constant_">GENERATORS</span>[libraryType][platform],
    },
  );

  <span class="hljs-keyword">if</span> (platform === <span class="hljs-string">'android'</span>) {
    <span class="hljs-comment">// Move all components C++ files to a structured jni folder for now.</span>
    <span class="hljs-comment">// Note: this should've been done by RNCodegen's generators, but:</span>
    <span class="hljs-comment">// * the generators don't support platform option yet</span>
    <span class="hljs-comment">// * this subdir structure is Android-only, not applicable to iOS</span>
    <span class="hljs-keyword">const</span> files = fs.<span class="hljs-title function_">readdirSync</span>(outputDirectory);
    <span class="hljs-keyword">const</span> jniOutputDirectory = <span class="hljs-string">`<span class="hljs-subst">${outputDirectory}</span>/jni/react/renderer/components/<span class="hljs-subst">${libraryName}</span>`</span>;
    fs.<span class="hljs-title function_">mkdirSync</span>(jniOutputDirectory, {<span class="hljs-attr">recursive</span>: <span class="hljs-literal">true</span>});
    files
      .<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">f</span> =&gt;</span> f.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">'.h'</span>) || f.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">'.cpp'</span>))
      .<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">f</span> =&gt;</span> {
        fs.<span class="hljs-title function_">renameSync</span>(<span class="hljs-string">`<span class="hljs-subst">${outputDirectory}</span>/<span class="hljs-subst">${f}</span>`</span>, <span class="hljs-string">`<span class="hljs-subst">${jniOutputDirectory}</span>/<span class="hljs-subst">${f}</span>`</span>);
      });
  }
}
</code></pre>
<p>这里核心是调用<code>utils.getCodegen().generate</code>来执行代码生成逻辑，但是这里有一个传参需要注意一下，<code>generators: GENERATORS[libraryType][platform],</code>我们观察<strong>GENERATORS</strong>的定义就会发现，这里的参数配置正好对应package.json中的codegen配置，由于我们现在研究的是Fabric组件注册，那么这里的参数应该是<code>componentsAndroid</code>。</p>
<p>继续查找<code>generate</code>方法的实现，源码<code>react-native/packages/react-native/scripts/codegen/codegen-utils.js</code>：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/**
* 用于抽象实际代码生成过程的包装器。 
* 之所以需要这个包装器，是因为在 Sandcastle 中运行测试时，并非所有环境都像通常那样设置。 
* 例如，`<span class="hljs-doctag">@react</span>-native/codegen` 库就不存在。 
*
* 借助这个包装器，我们可以模拟代码生成器的 getter 方法，使其返回一个自定义对象，该对象模拟了 Codegen 接口。 
*
* <span class="hljs-doctag">@return</span> 一个可以为新架构生成代码的对象。 
*/</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">getCodegen</span>(<span class="hljs-params"/>) <span class="hljs-comment">/*: $FlowFixMe */</span> {
  <span class="hljs-keyword">let</span> <span class="hljs-title class_">RNCodegen</span>;
  <span class="hljs-keyword">try</span> {
    <span class="hljs-comment">// $FlowFixMe[cannot-resolve-module]</span>
    <span class="hljs-title class_">RNCodegen</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../../packages/react-native-codegen/lib/generators/RNCodegen.js'</span>);
  } <span class="hljs-keyword">catch</span> (e) {
    <span class="hljs-comment">// $FlowFixMe[cannot-resolve-module]</span>
    <span class="hljs-title class_">RNCodegen</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'@react-native/codegen/lib/generators/RNCodegen.js'</span>);
  }
  <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">RNCodegen</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'RNCodegen not found.'</span>);
  }
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">RNCodegen</span>;
}
</code></pre>
<p>继续跟踪<code>react-native/packages/react-native-codegen/lib/generators/RNCodegen.js</code>：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">LIBRARY_GENERATORS</span> = {
  <span class="hljs-attr">descriptors</span>: [
    generateComponentDescriptorCpp.<span class="hljs-property">generate</span>,
    generateComponentDescriptorH.<span class="hljs-property">generate</span>,
  ],
  <span class="hljs-attr">events</span>: [generateEventEmitterCpp.<span class="hljs-property">generate</span>, generateEventEmitterH.<span class="hljs-property">generate</span>],
  <span class="hljs-attr">states</span>: [generateStateCpp.<span class="hljs-property">generate</span>, generateStateH.<span class="hljs-property">generate</span>],
  <span class="hljs-attr">props</span>: [
    generateComponentHObjCpp.<span class="hljs-property">generate</span>,
    generatePropsCpp.<span class="hljs-property">generate</span>,
    generatePropsH.<span class="hljs-property">generate</span>,
    generatePropsJavaInterface.<span class="hljs-property">generate</span>,
    generatePropsJavaDelegate.<span class="hljs-property">generate</span>,
  ],
  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Refactor this to consolidate various C++ output variation instead of forking per platform.</span>
  <span class="hljs-attr">componentsAndroid</span>: [
    <span class="hljs-comment">// JNI/C++ files</span>
    generateComponentDescriptorH.<span class="hljs-property">generate</span>,
    generateComponentDescriptorCpp.<span class="hljs-property">generate</span>,
    generateEventEmitterCpp.<span class="hljs-property">generate</span>,
    generateEventEmitterH.<span class="hljs-property">generate</span>,
    generatePropsCpp.<span class="hljs-property">generate</span>,
    generatePropsH.<span class="hljs-property">generate</span>,
    generateStateCpp.<span class="hljs-property">generate</span>,
    generateStateH.<span class="hljs-property">generate</span>,
    generateShadowNodeCpp.<span class="hljs-property">generate</span>,
    generateShadowNodeH.<span class="hljs-property">generate</span>,
    <span class="hljs-comment">// Java files</span>
    generatePropsJavaInterface.<span class="hljs-property">generate</span>,
    generatePropsJavaDelegate.<span class="hljs-property">generate</span>,
  ],
  <span class="hljs-attr">componentsIOS</span>: [
    generateComponentDescriptorH.<span class="hljs-property">generate</span>,
    generateComponentDescriptorCpp.<span class="hljs-property">generate</span>,
    generateEventEmitterCpp.<span class="hljs-property">generate</span>,
    generateEventEmitterH.<span class="hljs-property">generate</span>,
    generateComponentHObjCpp.<span class="hljs-property">generate</span>,
    generatePropsCpp.<span class="hljs-property">generate</span>,
    generatePropsH.<span class="hljs-property">generate</span>,
    generateStateCpp.<span class="hljs-property">generate</span>,
    generateStateH.<span class="hljs-property">generate</span>,
    generateShadowNodeCpp.<span class="hljs-property">generate</span>,
    generateShadowNodeH.<span class="hljs-property">generate</span>,
  ],
  <span class="hljs-attr">modulesAndroid</span>: [
    generateModuleJniCpp.<span class="hljs-property">generate</span>,
    generateModuleJniH.<span class="hljs-property">generate</span>,
    generateModuleJavaSpec.<span class="hljs-property">generate</span>,
  ],
  <span class="hljs-attr">modulesCxx</span>: [generateModuleH.<span class="hljs-property">generate</span>],
  <span class="hljs-attr">modulesIOS</span>: [generateModuleObjCpp.<span class="hljs-property">generate</span>],
  <span class="hljs-attr">tests</span>: [generateTests.<span class="hljs-property">generate</span>],
  <span class="hljs-string">'shadow-nodes'</span>: [
    generateShadowNodeCpp.<span class="hljs-property">generate</span>,
    generateShadowNodeH.<span class="hljs-property">generate</span>,
  ],
};


<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">allGenerators</span>: <span class="hljs-variable constant_">ALL_GENERATORS</span>,
  <span class="hljs-title function_">generate</span>(<span class="hljs-params">
    {
      libraryName,
      schema,
      outputDirectory,
      packageName,
      assumeNonnull,
      useLocalIncludePaths,
      includeGetDebugPropsImplementation = <span class="hljs-literal">false</span>,
      libraryGenerators = LIBRARY_GENERATORS,
    },
    {generators, test},
  </span>) {
    schemaValidator.<span class="hljs-title function_">validate</span>(schema);
    <span class="hljs-keyword">const</span> defaultHeaderPrefix = <span class="hljs-string">'react/renderer/components'</span>;
    <span class="hljs-keyword">const</span> headerPrefix =
      useLocalIncludePaths === <span class="hljs-literal">true</span>
        ? <span class="hljs-string">''</span>
        : <span class="hljs-string">`<span class="hljs-subst">${defaultHeaderPrefix}</span>/<span class="hljs-subst">${libraryName}</span>/`</span>;
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">composePath</span>(<span class="hljs-params">intermediate</span>) {
      <span class="hljs-keyword">return</span> path.<span class="hljs-title function_">join</span>(outputDirectory, intermediate, libraryName);
    }
    <span class="hljs-keyword">const</span> componentIOSOutput = <span class="hljs-title function_">composePath</span>(
      useLocalIncludePaths === <span class="hljs-literal">true</span> ? <span class="hljs-string">''</span> : defaultHeaderPrefix,
    );
    <span class="hljs-keyword">const</span> modulesIOSOutput = <span class="hljs-title function_">composePath</span>(<span class="hljs-string">'./'</span>);
    <span class="hljs-keyword">const</span> outputFoldersForGenerators = {
      <span class="hljs-attr">componentsIOS</span>: componentIOSOutput,
      <span class="hljs-attr">modulesIOS</span>: modulesIOSOutput,
      <span class="hljs-attr">descriptors</span>: outputDirectory,
      <span class="hljs-attr">events</span>: outputDirectory,
      <span class="hljs-attr">props</span>: outputDirectory,
      <span class="hljs-attr">states</span>: outputDirectory,
      <span class="hljs-attr">componentsAndroid</span>: outputDirectory,
      <span class="hljs-attr">modulesAndroid</span>: outputDirectory,
      <span class="hljs-attr">modulesCxx</span>: outputDirectory,
      <span class="hljs-attr">tests</span>: outputDirectory,
      <span class="hljs-string">'shadow-nodes'</span>: outputDirectory,
    };
    <span class="hljs-keyword">const</span> generatedFiles = [];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> name <span class="hljs-keyword">of</span> generators) {
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> generator <span class="hljs-keyword">of</span> libraryGenerators[name]) {
        <span class="hljs-title function_">generator</span>(
          libraryName,
          schema,
          packageName,
          assumeNonnull,
          headerPrefix,
          includeGetDebugPropsImplementation,
        ).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">contents, fileName</span>) =&gt;</span> {
          generatedFiles.<span class="hljs-title function_">push</span>({
            <span class="hljs-attr">name</span>: fileName,
            <span class="hljs-attr">content</span>: contents,
            <span class="hljs-attr">outputDir</span>: outputFoldersForGenerators[name],
          });
        });
      }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">checkOrWriteFiles</span>(generatedFiles, test);
  },
  <span class="hljs-comment">// 省略......</span>
};
</code></pre>
<p>可以看到，这里<code>for (const name of generators)</code>遍历的<strong>generators</strong>就是我们前面强调过的<strong>GENERATORS</strong>参数处理。那么此时<code>name</code>的值就是<code>componentsAndroid</code>。</p>
<p>既然确定了参数，那么从<code>libraryGenerators</code>中遍历出来的<code>generator</code>就是以下这些生成器：</p>
<pre><code class="hljs language-js" lang="js">  <span class="hljs-attr">componentsAndroid</span>: [
    <span class="hljs-comment">// JNI/C++ files</span>
    generateComponentDescriptorH.<span class="hljs-property">generate</span>,
    generateComponentDescriptorCpp.<span class="hljs-property">generate</span>,
    generateEventEmitterCpp.<span class="hljs-property">generate</span>,
    generateEventEmitterH.<span class="hljs-property">generate</span>,
    generatePropsCpp.<span class="hljs-property">generate</span>,
    generatePropsH.<span class="hljs-property">generate</span>,
    generateStateCpp.<span class="hljs-property">generate</span>,
    generateStateH.<span class="hljs-property">generate</span>,
    generateShadowNodeCpp.<span class="hljs-property">generate</span>,
    generateShadowNodeH.<span class="hljs-property">generate</span>,
    <span class="hljs-comment">// Java files</span>
    generatePropsJavaInterface.<span class="hljs-property">generate</span>,
    generatePropsJavaDelegate.<span class="hljs-property">generate</span>,
  ],
</code></pre>
<p>这里先研究一下<code>generateComponentDescriptorH.generate</code>和<code>generateComponentDescriptorCpp.generate</code>。</p>
<p>源码<code>react-native/packages/react-native-codegen/src/generators/components/GenerateComponentDescriptorH.js</code>：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">FileTemplate</span> = (<span class="hljs-params">{
  libraryName,
  componentDefinitions,
  headerPrefix,
}: {
  libraryName: string,
  componentDefinitions: string,
  headerPrefix: string,
}</span>) =&gt; <span class="hljs-string">`
/**
 * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
 *
 * Do not edit this file as changes may cause incorrect behavior and will be lost
 * once the code is regenerated.
 *
 * <span class="hljs-subst">${<span class="hljs-string">'@'</span>}</span>generated by codegen project: GenerateComponentDescriptorH.js
 */

#pragma once

<span class="hljs-subst">${IncludeTemplate({headerPrefix, file: <span class="hljs-string">'ShadowNodes.h'</span>})}</span>
#include &lt;react/renderer/core/ConcreteComponentDescriptor.h&gt;
#include &lt;react/renderer/componentregistry/ComponentDescriptorProviderRegistry.h&gt;

namespace facebook::react {

<span class="hljs-subst">${componentDefinitions}</span>

void <span class="hljs-subst">${libraryName}</span>_registerComponentDescriptorsFromCodegen(
  std::shared_ptr&lt;const ComponentDescriptorProviderRegistry&gt; registry);

} // namespace facebook::react
`</span>;

<span class="hljs-keyword">const</span> <span class="hljs-title function_">ComponentDefinitionTemplate</span> = (<span class="hljs-params">{className}: {className: string}</span>) =&gt;
  <span class="hljs-string">`
using <span class="hljs-subst">${className}</span>ComponentDescriptor = ConcreteComponentDescriptor&lt;<span class="hljs-subst">${className}</span>ShadowNode&gt;;
`</span>.<span class="hljs-title function_">trim</span>();

<span class="hljs-comment">// 省略部分代码......</span>
</code></pre>
<p>这里我们只简单看一下用于头文件生成的字符串模版。<code>libraryName</code>参数取值我们上面已经分析过了，来自<code>package.json</code>中的配置项。那么还有一个关键参数<code>className</code>的取值需要弄清楚。实际上这里的<code>componentDefinitions</code>和<code>className</code>都来自于<code>schema.json</code>。具体看一下className生成逻辑：</p>
<pre><code class="hljs language-js" lang="js">    <span class="hljs-keyword">const</span> componentDefinitions = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(schema.<span class="hljs-property">modules</span>)
      .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">moduleName</span> =&gt;</span> {
        <span class="hljs-keyword">const</span> <span class="hljs-variable language_">module</span> = schema.<span class="hljs-property">modules</span>[moduleName];
        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">module</span>.<span class="hljs-property">type</span> !== <span class="hljs-string">'Component'</span>) {
          <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">const</span> {components} = <span class="hljs-variable language_">module</span>;
        <span class="hljs-comment">// No components in this module</span>
        <span class="hljs-keyword">if</span> (components == <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }

        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(components)
          .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">componentName</span> =&gt;</span> {
            <span class="hljs-keyword">if</span> (components[componentName].<span class="hljs-property">interfaceOnly</span> === <span class="hljs-literal">true</span>) {
              <span class="hljs-keyword">return</span>;
            }

            <span class="hljs-keyword">return</span> <span class="hljs-title class_">ComponentDefinitionTemplate</span>({<span class="hljs-attr">className</span>: componentName});
          })
          .<span class="hljs-title function_">join</span>(<span class="hljs-string">'\n'</span>);
      })
      .<span class="hljs-title function_">filter</span>(<span class="hljs-title class_">Boolean</span>)
      .<span class="hljs-title function_">join</span>(<span class="hljs-string">'\n'</span>);

    <span class="hljs-keyword">const</span> replacedTemplate = <span class="hljs-title class_">FileTemplate</span>({
      libraryName,
      componentDefinitions,
      <span class="hljs-attr">headerPrefix</span>: headerPrefix ?? <span class="hljs-string">''</span>,
    });
</code></pre>
<p>可以看到，实际上是在遍历<code>schema.json</code>中的<code>components</code>字段。在声明组件一节已经创建了Demo工程，现在构建项目生成<code>schema.json</code>，查看相关内容：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"libraryName"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">""</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"modules"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"CustomWebView"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Component"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"components"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">"CustomWebView"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
          <span class="hljs-attr">"extendsProps"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
            <span class="hljs-punctuation">{</span>
              <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"ReactNativeBuiltInType"</span><span class="hljs-punctuation">,</span>
              <span class="hljs-attr">"knownTypeName"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"ReactNativeCoreViewProps"</span>
            <span class="hljs-punctuation">}</span>
          <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
          <span class="hljs-attr">"events"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>省略......<span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
          <span class="hljs-attr">"props"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>省略......<span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
          <span class="hljs-attr">"commands"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span>
        <span class="hljs-punctuation">}</span>
      <span class="hljs-punctuation">}</span>
    <span class="hljs-punctuation">}</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p>那么<code>className</code>就是<code>componentName</code>，也就是自定义的组件名<strong>CustomWebView</strong>。</p>
<h5 data-id="heading-9">C++ 层</h5>
<p>弄清楚代码生成的逻辑之后，接下来我们可以直接查看生成的文件内容，主要是<code>ComponentDescriptors.h</code></p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span>

<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;react/renderer/components/CustomviewViewSpec/ShadowNodes.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;react/renderer/core/ConcreteComponentDescriptor.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;react/renderer/componentregistry/ComponentDescriptorProviderRegistry.h&gt;</span></span>

<span class="hljs-keyword">namespace</span> facebook::react {

<span class="hljs-keyword">using</span> CustomWebViewComponentDescriptor = ConcreteComponentDescriptor&lt;CustomWebViewShadowNode&gt;;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CustomviewViewSpec_registerComponentDescriptorsFromCodegen</span><span class="hljs-params">(
  std::shared_ptr&lt;<span class="hljs-type">const</span> ComponentDescriptorProviderRegistry&gt; registry)</span></span>;
}
</code></pre>
<p><code>ComponentDescriptors.cpp</code></p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;react/renderer/components/CustomviewViewSpec/ComponentDescriptors.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;react/renderer/core/ConcreteComponentDescriptor.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;react/renderer/componentregistry/ComponentDescriptorProviderRegistry.h&gt;</span></span>

<span class="hljs-keyword">namespace</span> facebook::react {

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CustomviewViewSpec_registerComponentDescriptorsFromCodegen</span><span class="hljs-params">(
  std::shared_ptr&lt;<span class="hljs-type">const</span> ComponentDescriptorProviderRegistry&gt; registry)</span> </span>{
registry-&gt;<span class="hljs-built_in">add</span>(<span class="hljs-built_in">concreteComponentDescriptorProvider</span>&lt;CustomWebViewComponentDescriptor&gt;());
}

}
</code></pre>
<p>头文件定义了一个类型别名<code>CustomWebViewComponentDescriptor</code>，然后在实现文件中注册了这个Provider。我们看一下<code>concreteComponentDescriptorProvider</code>函数的实现，源码<code>react-native/packages/react-native/ReactCommon/react/renderer/componentregistry/ComponentDescriptorProvider.h</code>:</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">/*
* 为给定的 `ComponentDescriptor` 类创建一个 `ComponentDescriptorProvider`
*/</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ComponentDescriptorT&gt;
<span class="hljs-function">ComponentDescriptorProvider <span class="hljs-title">concreteComponentDescriptorProvider</span><span class="hljs-params">()</span>
</span>{
  <span class="hljs-built_in">static_assert</span>(
      std::is_base_of&lt;ComponentDescriptor, ComponentDescriptorT&gt;::value,
      <span class="hljs-string">"ComponentDescriptorT must be a descendant of ComponentDescriptor"</span>);

  <span class="hljs-keyword">return</span> {
      ComponentDescriptorT::ConcreteShadowNode::<span class="hljs-built_in">Handle</span>(),
      ComponentDescriptorT::ConcreteShadowNode::<span class="hljs-built_in">Name</span>(),
      <span class="hljs-literal">nullptr</span>,
      &amp;concreteComponentDescriptorConstructor&lt;ComponentDescriptorT&gt;};
}
</code></pre>
<p>返回值是一个<code>ComponentDescriptorProvider</code>类型实例，继续跟踪一下类定义：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">/*
 * 提供了一种统一的方式来构造特定存储的 `ComponentDescriptor` 类的实例。 
 * C++ 不允许创建指向构造函数的指针，因此我们必须使用这样的数据结构来操作一组类。
 *
 * 注意：某些组件的 `handle` 和 `name` 的实际值取决于 `flavor`。 
 * 如果使用给定的 `flavor` 通过 `constructor` 对象实例化后，
 * Provider暴露的 `handle` 和 `name` 值与预期值相同，则该提供者有效。 
 */</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ComponentDescriptorProvider</span> <span class="hljs-keyword">final</span> {
 <span class="hljs-keyword">public</span>:
  ComponentHandle handle;
  ComponentName name;
  ComponentDescriptor::Flavor flavor;
  ComponentDescriptorConstructor *constructor;
};
</code></pre>
<p>这里大量使用了C++模版，要想查看真正的handle和name值，需要当实际的模版类型中查找。这里先查看源码<code>react-native/packages/react-native/ReactCommon/react/renderer/core/ConcreteComponentDescriptor.h</code>：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-keyword">namespace</span> facebook::react {

<span class="hljs-comment">/*
 * Default template-based implementation of ComponentDescriptor.
 * Use your `ShadowNode` type as a template argument and override any methods
 * if necessary.
 */</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ShadowNodeT&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteComponentDescriptor</span> : <span class="hljs-keyword">public</span> ComponentDescriptor {
  <span class="hljs-built_in">static_assert</span>(std::is_base_of&lt;ShadowNode, ShadowNodeT&gt;::value, <span class="hljs-string">"ShadowNodeT must be a descendant of ShadowNode"</span>);

  <span class="hljs-keyword">using</span> SharedShadowNodeT = std::shared_ptr&lt;<span class="hljs-type">const</span> ShadowNodeT&gt;;

 <span class="hljs-keyword">public</span>:
  <span class="hljs-keyword">using</span> ConcreteShadowNode = ShadowNodeT;

  <span class="hljs-comment">// 省略代码......</span>
} <span class="hljs-comment">// namespace facebook::react</span>
</code></pre>
<p>可以看到，<code>ConcreteShadowNode</code>实际上只是一个类型别名，具体的要看模版的实际参数，那么<code>ConcreteShadowNode::Handle</code>就相当于<code>CustomWebViewShadowNode::Handle</code>。这里<code>CustomWebViewShadowNode</code>也是自动生成的代码，我们直接查看<code>android/app/build/generated/source/codegen/jni/react/renderer/components/CustomviewViewSpec/ShadowNodes.h</code>：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">/*
 * `ShadowNode` for &lt;CustomWebView&gt; component.
 */</span>
<span class="hljs-keyword">using</span> CustomWebViewShadowNode = ConcreteViewShadowNode&lt;
    CustomWebViewComponentName,
    CustomWebViewProps,
    CustomWebViewEventEmitter,
    CustomWebViewState&gt;;
</code></pre>
<p>继续查看<code>android/app/build/generated/source/codegen/jni/react/renderer/components/CustomviewViewSpec/ShadowNodes.cpp</code>：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;react/renderer/components/CustomviewViewSpec/ShadowNodes.h&gt;</span></span>

<span class="hljs-keyword">namespace</span> facebook::react {

<span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> CustomWebViewComponentName[] = <span class="hljs-string">"CustomWebView"</span>;

} 
</code></pre>
<p>现在跟踪一下<code>react-native/packages/react-native/ReactCommon/react/renderer/components/view/ConcreteViewShadowNode.h</code>：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-keyword">namespace</span> facebook::react {

<span class="hljs-comment">/*
 * Template for all &lt;View&gt;-like classes (classes which have all same props
 * as &lt;View&gt; and similar basic behaviour).
 * For example: &lt;Paragraph&gt;, &lt;Image&gt;, but not &lt;Text&gt;, &lt;RawText&gt;.
 */</span>
<span class="hljs-keyword">template</span> &lt;
    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *concreteComponentName,
    <span class="hljs-keyword">typename</span> ViewPropsT = ViewProps,
    <span class="hljs-keyword">typename</span> ViewEventEmitterT = ViewEventEmitter,
    <span class="hljs-keyword">typename</span> StateDataT = StateData&gt;
  <span class="hljs-built_in">requires</span>(std::is_base_of_v&lt;ViewProps, ViewPropsT&gt;)
<span class="hljs-keyword">class</span> ConcreteViewShadowNode : <span class="hljs-keyword">public</span> ConcreteShadowNode&lt;
                                   concreteComponentName,
                                   YogaLayoutableShadowNode,
                                   ViewPropsT,
                                   ViewEventEmitterT,
                                   StateDataT&gt; {
  <span class="hljs-comment">// 省略代码......</span>
};

} <span class="hljs-comment">// namespace facebook::react</span>
</code></pre>
<p><code>ConcreteViewShadowNode</code>类中并未实现<code>Handle</code>和<code>Name</code>方法，继续查看父类<code>react-native/packages/react-native/ReactCommon/react/renderer/core/ConcreteShadowNode.h</code></p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-keyword">namespace</span> facebook::react {

<span class="hljs-comment">/*
 * Base templace class for all `ShadowNode`s which connects exact `ShadowNode`
 * type with exact `Props` type.
 * `ConcreteShadowNode` is a default implementation of `ShadowNode` interface
 * with many handy features.
 */</span>
<span class="hljs-keyword">template</span> &lt;
    ComponentName concreteComponentName,
    <span class="hljs-keyword">typename</span> BaseShadowNodeT,
    <span class="hljs-keyword">typename</span> PropsT,
    <span class="hljs-keyword">typename</span> EventEmitterT = EventEmitter,
    <span class="hljs-keyword">typename</span> StateDataT = StateData&gt;
<span class="hljs-keyword">class</span> ConcreteShadowNode : <span class="hljs-keyword">public</span> BaseShadowNodeT {

 <span class="hljs-keyword">protected</span>:
  <span class="hljs-keyword">using</span> ShadowNode::props_;
  <span class="hljs-keyword">using</span> ShadowNode::state_;

 <span class="hljs-keyword">public</span>:
  <span class="hljs-keyword">using</span> BaseShadowNodeT::BaseShadowNodeT;
  <span class="hljs-comment">// 省略......</span>

  <span class="hljs-function"><span class="hljs-type">static</span> ComponentName <span class="hljs-title">Name</span><span class="hljs-params">()</span>
  </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">ComponentName</span>(concreteComponentName);
  }

  <span class="hljs-function"><span class="hljs-type">static</span> ComponentHandle <span class="hljs-title">Handle</span><span class="hljs-params">()</span>
  </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">ComponentHandle</span>(concreteComponentName);
  }

  <span class="hljs-comment">// 省略......</span>
};

} <span class="hljs-comment">// namespace facebook::react</span>
</code></pre>
<p>到这里就很清晰了，Name和Handle方法返回值内部是持有的相同的<code>concreteComponentName</code>，而这个模版参数，根据前面的传参，实际是就是</p>
<p><code>CustomWebViewComponentName</code>，也就是<code>"CustomWebView"</code>。</p>
<p>扫描Fabric 组件库，生成代码的逻辑其实已经很清楚了，最后只剩下一个问题，真正调用注册的代码在哪里？事实上，安卓中并未真正通过<code>CustomviewViewSpec_registerComponentDescriptorsFromCodegen</code>函数去注册，而是使用了autolinking机制。这部分在《Android端TurboModule分析》一文有详细介绍了，可以去回顾一下<code>GenerateAutolinkingNewArchitecturesFileTask</code>脚本的分析，其中生成的信息源就来自我们前面费了半天劲分析的<code>autolinking.json</code>中的</p>
<p>现在来看一下Gradle脚本生成的<code>autolinking.cpp</code>：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"autolinking.h"</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;CustomviewViewSpec.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;react/renderer/components/CustomviewViewSpec/ComponentDescriptors.h&gt;</span></span>

<span class="hljs-keyword">namespace</span> facebook {
<span class="hljs-keyword">namespace</span> react {

<span class="hljs-function">std::shared_ptr&lt;TurboModule&gt; <span class="hljs-title">autolinking_ModuleProvider</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string moduleName, <span class="hljs-type">const</span> JavaTurboModule::InitParams &amp;params)</span> </span>{
<span class="hljs-keyword">auto</span> module_CustomviewViewSpec = <span class="hljs-built_in">CustomviewViewSpec_ModuleProvider</span>(moduleName, params);
<span class="hljs-keyword">if</span> (module_CustomviewViewSpec != <span class="hljs-literal">nullptr</span>) {
<span class="hljs-keyword">return</span> module_CustomviewViewSpec;
}
  <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;
}

<span class="hljs-function">std::shared_ptr&lt;TurboModule&gt; <span class="hljs-title">autolinking_cxxModuleProvider</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string moduleName, <span class="hljs-type">const</span> std::shared_ptr&lt;CallInvoker&gt;&amp; jsInvoker)</span> </span>{

  <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">autolinking_registerProviders</span><span class="hljs-params">(std::shared_ptr&lt;ComponentDescriptorProviderRegistry <span class="hljs-type">const</span>&gt; providerRegistry)</span> </span>{
providerRegistry-&gt;<span class="hljs-built_in">add</span>(<span class="hljs-built_in">concreteComponentDescriptorProvider</span>&lt;CustomWebViewComponentDescriptor&gt;());
  <span class="hljs-keyword">return</span>;
}

} <span class="hljs-comment">// namespace react</span>
} <span class="hljs-comment">// namespace facebook</span>
</code></pre>
<p>这里生成了<code>autolinking_registerProviders</code>方法，这才是真正注册组件的地方。而此处的代码是由Gradle脚本生成，其中的关键信息就来自<code>autolinking.json</code>中的<code>componentDescriptors</code>字段，也就是前面我们费了半天劲才分析出该字段的默认值的地方。整个React Native的代码生成其实是有些混乱的，会生成一些并不会使用的代码，对理解产生干扰。</p>
<p>关于<code>autolinking_registerProviders</code>函数的调用链，在前面的文章也分析涉及过，这里再回顾一下调用流程，源码<code>react-native/packages/react-native/ReactAndroid/cmake-utils/default-app-setup/OnLoad.cpp</code>：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-keyword">namespace</span> facebook::react {

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">registerComponents</span><span class="hljs-params">(
    std::shared_ptr&lt;<span class="hljs-type">const</span> ComponentDescriptorProviderRegistry&gt; registry)</span> </span>{
  <span class="hljs-comment">// 自定义 Fabric 组件放在这里。您可以在此处注册来自您的应用程序或第三方库的自定义组件</span>
  <span class="hljs-comment">// providerRegistry-&gt;add(concreteComponentDescriptorProvider&lt;</span>
  <span class="hljs-comment">//        MyComponentDescriptor&gt;());</span>

  <span class="hljs-comment">// We link app local components if available</span>
<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> REACT_NATIVE_APP_COMPONENT_REGISTRATION</span>
  <span class="hljs-built_in">REACT_NATIVE_APP_COMPONENT_REGISTRATION</span>(registry);
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>

  <span class="hljs-comment">// And we fallback to the components autolinked</span>
  <span class="hljs-built_in">autolinking_registerProviders</span>(registry);
}

<span class="hljs-comment">// 省略部分代码......</span>

} <span class="hljs-comment">// namespace facebook::react</span>

<span class="hljs-function">JNIEXPORT jint JNICALL <span class="hljs-title">JNI_OnLoad</span><span class="hljs-params">(JavaVM* vm, <span class="hljs-type">void</span>*)</span> </span>{
  <span class="hljs-keyword">return</span> facebook::jni::<span class="hljs-built_in">initialize</span>(vm, [] {
    facebook::react::DefaultTurboModuleManagerDelegate::cxxModuleProvider =
        &amp;facebook::react::cxxModuleProvider;
    facebook::react::DefaultTurboModuleManagerDelegate::javaModuleProvider =
        &amp;facebook::react::javaModuleProvider;
    facebook::react::DefaultComponentsRegistry::
        registerComponentDescriptorsFromEntryPoint =
            &amp;facebook::react::registerComponents;
  });
}
</code></pre>
<p>可见，注册的起点也是<code>JNI_OnLoad</code>函数。</p>
<h5 data-id="heading-10">Kotlin层</h5>
<p>使用<code>npx create-react-native-library@latest</code>工具创建一个Fabric组件库时，会生成一些模版代码，其中包括我们上面提到的<code>CustomWebViewManager</code>类，现在我们来看一下<code>CustomWebViewPackage</code>类：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomWebViewPackage</span> : <span class="hljs-type">ReactPackage</span> {
  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createViewManagers</span><span class="hljs-params">(reactContext: <span class="hljs-type">ReactApplicationContext</span>)</span></span>: List&lt;ViewManager&lt;*, *&gt;&gt; {
    <span class="hljs-keyword">val</span> viewManagers: MutableList&lt;ViewManager&lt;*, *&gt;&gt; = ArrayList()
    viewManagers.add(CustomWebViewManager())
    <span class="hljs-keyword">return</span> viewManagers
  }

  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createNativeModules</span><span class="hljs-params">(reactContext: <span class="hljs-type">ReactApplicationContext</span>)</span></span>: List&lt;NativeModule&gt; {
    <span class="hljs-keyword">return</span> emptyList()
  }
}
</code></pre>
<p>这里<code>createViewManagers</code>方法会返回一个<code>ViewManager</code>的实例列表。根据我们在<a href="https://juejin.cn/post/7595178023256211475" target="_blank" title="https://juejin.cn/post/7595178023256211475">《ReactNative新架构之Android端TurboModule机制完全解析》</a>一文中分析<code>GeneratePackageListTask</code>任务的结果，我们知道最终会生成一个<code>PackageList</code>文件，其中会注入每个三方TurboModule或Fabric组件包中的<strong>ReactPackage</strong>实现类。</p>
<p>现在来查看一下我们示例工程生成的<code>example/android/app/build/generated/autolinking/src/main/java/com/facebook/react/PackageList.java</code>文件：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PackageList</span> {
  <span class="hljs-keyword">private</span> Application application;
  <span class="hljs-keyword">private</span> ReactNativeHost reactNativeHost;
  <span class="hljs-keyword">private</span> MainPackageConfig mConfig;

  <span class="hljs-comment">// 省略部分代码......</span>

  <span class="hljs-keyword">public</span> ArrayList&lt;ReactPackage&gt; <span class="hljs-title function_">getPackages</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(Arrays.&lt;ReactPackage&gt;asList(
      <span class="hljs-keyword">new</span> <span class="hljs-title class_">MainReactPackage</span>(mConfig),
      <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomWebViewPackage</span>()
    ));
  }
}
</code></pre>
<p>回顾一下本文开头的初始化部分，我们提到过以下代码</p>
<pre><code class="hljs language-kotlin" lang="kotlin">fabricUIManager =
    FabricUIManager(context, ViewManagerRegistry(viewManagerResolver), eventBeatManager)
</code></pre>
<p>现在回顾一下<a href="https://juejin.cn/post/7594627998839406634" target="_blank" title="https://juejin.cn/post/7594627998839406634">《React Native新架构之Android端初始化源码分析》</a>一文，在<code>ReactInstance</code>类构造时，有如下初始化逻辑：</p>
<pre><code class="hljs language-kotlin" lang="kotlin">    viewManagerResolver = BridgelessViewManagerResolver(reactPackages, context)

    ComponentNameResolverBinding.install(
        unbufferedRuntimeExecutor,
        <span class="hljs-keyword">object</span> : ComponentNameResolver {
          <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> componentNames: Array&lt;String&gt;
            <span class="hljs-keyword">get</span>() {
              <span class="hljs-keyword">val</span> viewManagerNames = viewManagerResolver.getViewManagerNames()
              <span class="hljs-keyword">if</span> (viewManagerNames.isEmpty()) {
                FLog.e(TAG, <span class="hljs-string">"No ViewManager names found"</span>)
                <span class="hljs-keyword">return</span> arrayOf()
              }
              <span class="hljs-keyword">return</span> viewManagerNames.toTypedArray&lt;String&gt;()
            }
        },
    )
</code></pre>
<p>结合上一节<strong>查找组件</strong> kotlin层实现的分析，整个流程都十分清晰了。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[2026 最新 Claude Skills 保姆级教程及实践！]]></title>    <link>https://juejin.cn/post/7596926832913055807</link>    <guid>https://juejin.cn/post/7596926832913055807</guid>    <pubDate>2026-01-19T15:28:19.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7596926832913055807" data-draft-id="7596905751110746175" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="2026 最新 Claude Skills 保姆级教程及实践！"/> <meta itemprop="keywords" content="人工智能"/> <meta itemprop="datePublished" content="2026-01-19T15:28:19.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="苍何"/> <meta itemprop="url" content="https://juejin.cn/user/588993963763405"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            2026 最新 Claude Skills 保姆级教程及实践！
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/588993963763405/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    苍何
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-19T15:28:19.000Z" title="Mon Jan 19 2026 15:28:19 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>这是苍何的第 470 篇原创！</p>
<p>大家好，我是苍何。</p>
<p>其实想写这篇文章想写很久了，Claude Skills 现在也已经🔥的一塌糊涂了，</p>
<p>我也看了很多大佬的文章，收藏了一堆的教程，比如一泽的教程，就让我一度只能粗鲁的喊了好几遍：卧槽，牛逼，还不忘加几个表情：🐂🍺</p>
<p>在经历一番研究 Claude 技术博客后，我决定分享一些我的实践和感受。</p>
<p>本文主要分为以下几大部分：</p>
<p>1、什么是 Claude Skills<br/>
2、Claude Skills 和 MCP 区别及联系<br/>
3、怎么使用 Skills<br/>
4、都有哪些好用的 Skills？<br/>
5、如何制作自己的 Skills </p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2e945982976b4849b3625a34ef4dd9d1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441299&amp;x-signature=%2BTFbkemNvjWakwA72q4lww%2B9tvg%3D" alt="图片" loading="lazy"/></p>
<blockquote>
<p>文章会显得有些长，可以先点赞收藏，并转发给需要的朋友。文末也会有 Skill 交流群。</p>
</blockquote>
<h2 data-id="heading-0">什么是Claude Skills？</h2>
<p><strong>Claude Skills 我的理解就是给大模型的技能工具包，他是可复用的指令包，通过封装团队的工作流程，业务逻辑和领域知识，解决了 AI 缺乏专业知识的鸿沟。</strong></p>
<p>它将特定的程序化知识、业务逻辑和执行脚本打包，让 Agent 能像工作流一样较稳定的执行。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d12b0a77870f45009d358f57033481e6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441299&amp;x-signature=NlKABbJvHp6NCr1L3rWfIibgh4E%3D" alt="图片" loading="lazy"/></p>
<p>从使用层面上理解 Skills 是包含指令、脚本和资源的文件夹，供 LLM 可以动态加载，底层采用的是渐进式披露，也就是仅在需要的时候加载技能的详细指令，能有效节省宝贵的上下文窗口。</p>
<p>Skills 带来的是一种全新的 AI Agent 协作模式，过去，我们需要在每次对话中提供背景知识和操作指南，现在，借助 Skills，我们可以将这些知识封装起来，给到 AI 使用。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/af2bdc56fac047deb42cda72aeb92a50~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441299&amp;x-signature=PpzL7UcvkDcLGoi6EQCskaj5vRQ%3D" alt="图片" loading="lazy"/></p>
<p>要想很好的理解 Skills 就得先看清现阶段 AI 面临的一些问题。</p>
<p><strong>1、对话是短暂的</strong>：每一次新的 Chat 对话都要从 0 开始，通常无法记住之前讨论，项目的具体背景和团队的工作流程。</p>
<p><strong>2、知识是分散的</strong>：团队经验（数据结构、业务逻辑等）分散在 Wiki、文档里，AI 无法直接调用</p>
<p>3、<strong>重复劳动多</strong>：开发者 / 用户需反复在提示词中解释细节，既耗时又导致 AI 输出不一致</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/80d2a7293e3d45289981d84259488c4d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441299&amp;x-signature=eq%2FN48nFSP0K5YFOmzGvnt83GSg%3D" alt="图片" loading="lazy"/></p>
<p>就好比一个新入职的员工，想要快速上手项目就得需要各种知识和技能，Skills 更像是模块化的知识包，给 AI 量身定制。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2b837db3d4b54b8dae348c732f348440~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441299&amp;x-signature=LDRXDSxN%2BebvGqFsdgi2BBGbl%2FI%3D" alt="图片" loading="lazy"/></p>
<p>那 Skills 的核心机制是通过<strong>渐进式披露</strong> (Progressive Disclosure)，通过分层加载信息，确保 AI 总能获取所需知识，同时最大化利用上下文的效率。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4e133b928a8a46e599f7300b54f07e93~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441299&amp;x-signature=0ZAJbDeEa3apoVMQqAHVvPqLKZg%3D" alt="图片" loading="lazy"/></p>
<p>从文件夹层面，来做个剖析吧。通常会包含这几大部分：</p>
<p>1、scripts：存放执行脚本<br/>
2、references：存放按需加载的详细文档，如表结构定义，API 规范，代码片段等。<br/>
3、SKILL. md：核心指令、触发条件、执行指引等。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/55f1f0698c634b71b2bb57464e7c08a3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441299&amp;x-signature=FqeQFEE5Q%2BQGAoHmX5n5OzGYkD8%3D" alt="图片" loading="lazy"/></p>
<p>其中 SKILL. md 内部剖析如下：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/80b128055872495e910303ab779ebff3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441299&amp;x-signature=YwnAZAxHYDpzL94c7zQB2GDLK9Y%3D" alt="图片" loading="lazy"/></p>
<p>Skill 能否被准确触发，完全取决于其SKILL. md 中 description 的质量。它非简单的关键词匹配，而是 Claude 对其能力和适用场景的语义理解。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bc7146fd12f345409a0905c793ccb9d2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441299&amp;x-signature=%2BkyLSRNudbgqe736GY8F1ZLCoEc%3D" alt="图片" loading="lazy"/></p>
<p>Skills 是构建强大 Al Agent 的核心基石，但它并非孤立存在。为了发挥最大潜能，我们需要理解它如何与 Anthropic 生态系统中的其他组件协同工作。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a373ee0631fd4aa69eecbd6400a01d92~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441299&amp;x-signature=ZD4XQbwtV5kZ2qkNs8i1nbMB5WI%3D" alt="图片" loading="lazy"/></p>
<h2 data-id="heading-1">和 MCP 区别及联系</h2>
<p>最大的困惑其实是和 MCP 区别。我做了个图：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/538462f993384c72a0ccc6c79a8f276f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441299&amp;x-signature=nHyHpS5R9VNgdY73GUd10EgXWUg%3D" alt="图片" loading="lazy"/></p>
<p>MCP 是一种标准协议，像是大模型的手和脚，负责连接工具，而 Skills 负责程序化知识，他让 Agent 具备工作流的能力，稳定执行特定任务。</p>
<p>比如一份调研报告 skill，他需要通过 MCP 去连接 Google Drive 搜索最新周报，并从 GitHub 拉取竞品开源库的数据，skill 提供分析框架，指导 AI 如何进行 SWOT 分析，最后由 subagent 来执行。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/caaf2df710794acc841a584d501081d3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441299&amp;x-signature=TaSKWb1S7s4dWxcTCCy4wZqEyOI%3D" alt="图片" loading="lazy"/></p>
<h2 data-id="heading-2">怎么使用 Skills？</h2>
<p>那具体怎么使用 Skills 呢？其实在很多 AI IDE 中都可以使用了，比如 Claude Code、OpenCode。</p>
<p>这里以 Claude Code 为例，使用只需要以下几步。</p>
<p><strong>第一步，安装 Claude Code</strong></p>
<p>推荐使用 native 的方式安装，相比较于 npm 更加的稳定以及能及时更新，终端中输入：</p>
<pre><code class="hljs language-arduino" lang="arduino">curl -fsSL https:<span class="hljs-comment">//claude.ai/install.sh | bash</span>
</code></pre>
<p>然后选择一个文件夹，终端输入： claude，即可启动。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4cfcab48aa434ff2a8fe13cc7fe1f63f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441299&amp;x-signature=Xr2g1dCABw3UiSouJElFcIvgY0M%3D" alt="图片" loading="lazy"/></p>
<p>但是要想使用还是需要配置一下 API 的，有挺多种办法，你可以选择官方的 Claude，非常贵，你也可以选择中转的 API，性价比高，当然你甚至可以选择 GLM 4.7，相对划算。</p>
<p>通常我还会安装一个工具叫 CC Swtich，用来管理各种 API 的配置。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fb111aea64bc443383927640ae61133e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441299&amp;x-signature=%2BKN0cC9tuN9mDtzcThe77o%2FwWww%3D" alt="图片" loading="lazy"/></p>
<p><strong>第二步，在 Claude Code 中安装 Skills</strong></p>
<p>一共有三种安装方式，分别是：</p>
<p>方式一：自然语言安装</p>
<p>你可以直接让 CC 来安装，直接提需求：</p>
<pre><code class="hljs language-ruby" lang="ruby">帮我安装下 skill，项目地址是：<span class="hljs-symbol">https:</span>/<span class="hljs-regexp">/github.com/anthropics</span><span class="hljs-regexp">/skills/blob</span><span class="hljs-regexp">/mai
n/skills</span><span class="hljs-regexp">/pptx 
</span></code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e065d4b712bd48328561f4892549de49~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441299&amp;x-signature=UQxl9mUCVVR5Wvp2Z1s3M8vUVuM%3D" alt="图片" loading="lazy"/></p>
<p>可以看到他能理解需求，并直接帮安装好了：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/623743fe078a41a5af153a96e03dc5ae~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441299&amp;x-signature=fWMmQCLP4QkJKPjawhwedG1CyDM%3D" alt="图片" loading="lazy"/></p>
<p>方式二：手动安装</p>
<p>下载 skill 安装包，然后直接放到 .claude/skills/，这个目录下：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9620789708294e849a0a4e00abe593a9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441299&amp;x-signature=tABkSRLLp8j3tPbVcH9jvim%2Bd4o%3D" alt="图片" loading="lazy"/></p>
<p>方式三，注册命令</p>
<p>在 Claude Code 中运行以下命令，将此存储库注册为 Claude Code 插件市场：</p>
<pre><code class="hljs language-bash" lang="bash">/plugin marketplace add anthropics/skills
</code></pre>
<p>然后，在插件市场中搜索相关插件：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/06ef996146ff4736b29ec7b92a433f26~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441299&amp;x-signature=nEny0pH8vg5d9ZNMH%2B3vSd6Fr4w%3D" alt="图片" loading="lazy"/></p>
<p>通过插件安装的 skills 需要在 .claude/plugins/marketplaces/ 这个目录下查看：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ff17a72229714b29a3eb9e7046254d26~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441299&amp;x-signature=ff1TyZue7gNkw4BQZnrnCBOnRo4%3D" alt="图片" loading="lazy"/></p>
<p>或者也可以直接输入命令安装插件：</p>
<pre><code class="hljs language-typescript" lang="typescript">/plugin install <span class="hljs-variable language_">document</span>-skills<span class="hljs-meta">@anthropic</span>-agent-skills
</code></pre>
<p>当安装好 skills 后，需要重启一下 Claude Code。</p>
<p>要想使用的话，可以直接指定 skill，也可以按照用户意图，Agent 自动选择合适的 skill。</p>
<p>比如输入 prompt：</p>
<blockquote>
<p>用 pptx skill 创建一个关于 Claude Skills 的演示文稿</p>
</blockquote>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8688927ac2894edeb1a137f1be28e832~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441299&amp;x-signature=FjeZrZck%2FO3mRDN8ZBH8AADaKBc%3D" alt="图片" loading="lazy"/></p>
<p>可以看到先是去用 HTML 来写 PPT，然后调用 pptx skill 里面的 html2pptx.md 约束，把 html 转为 PPT。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4753aaa412ab43d5b10ba603cb57ddb0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441299&amp;x-signature=056gGZ9MUewb8ZtJHeZ30MCHn3s%3D" alt="图片" loading="lazy"/></p>
<p>而这个约束文件 html2pptx.md 是对 html 转 PPT 的一些约束规则和条件，通过 markdown 的形式约束了。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1825511dc7a84456947aba6ae050f2b2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441299&amp;x-signature=pQ%2BX030No91ZpUnS027KJRHa7GA%3D" alt="图片" loading="lazy"/></p>
<p>Claude Skills 经过一番苦战，终于完成了。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6479103f5c6f46c5a6fb0f9c43481f78~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441299&amp;x-signature=S8mX4eKh11raCSQtUn9uDgSD0Do%3D" alt="图片" loading="lazy"/></p>
<p>我们来看下效果：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d9113a52664a4ba38aac43fd425e5286~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441299&amp;x-signature=Fl67JSAhr4siVeNtnJi%2FPuCx5Vk%3D" alt="图片" loading="lazy"/></p>
<p>靠，非常不错啊。一个做 PPT 的 skill 就这样安装好了。</p>
<h2 data-id="heading-3">都有哪些好用的 Skills？</h2>
<p>Anthropic 官方的 skill 仓库提供了不少有用的 skill，开源地址如下：</p>
<pre><code class="hljs language-arduino" lang="arduino">https:<span class="hljs-comment">//github.com/anthropics/skills</span>
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a59be8f89d634753bf06add18e33fb47~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441299&amp;x-signature=Gf1JM%2Fg1PG3DNdtjlLJ2cSvFr%2FM%3D" alt="图片" loading="lazy"/></p>
<p>也可以在 Skills 市场找到非常多的 skill：<a href="https://link.juejin.cn?target=https%3A%2F%2Fskillsmp.com%2Fzh" target="_blank" title="https://skillsmp.com/zh" ref="nofollow noopener noreferrer">skillsmp.com/zh</a></p>
<p>目前已经有 58925 个 Skills 了：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/29d5ae9cb300478e92f49c0e3a34235b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441299&amp;x-signature=minqNWzAWmr60W5wk70MnzcPnAU%3D" alt="图片" loading="lazy"/></p>
<p>然后可以在这里用 AI 来搜索你想要的 Skills，也可以按照分类查找。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9ea43539d672443599584ba52c81b066~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441299&amp;x-signature=4MfvIiFRiXbnYrJlrVJcaqloK4M%3D" alt="图片" loading="lazy"/></p>
<p>那都有哪些必装的 skill 呢？给大家推荐几款：</p>
<p><strong>1、skill-creator</strong></p>
<p>Anthropic 官方出品，能够自动写 skill 的 skill。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/01051de2a93f43bb99405252adc777f5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441299&amp;x-signature=gFwlP4BvjfGT%2BuXZgoTEjNoNA3c%3D" alt="图片" loading="lazy"/></p>
<p>地址：</p>
<pre><code class="hljs language-ruby" lang="ruby"><span class="hljs-symbol">https:</span>/<span class="hljs-regexp">/github.com/anthropics</span><span class="hljs-regexp">/skills/tree</span><span class="hljs-regexp">/main/skills</span><span class="hljs-regexp">/skill-creator
</span></code></pre>
<p>2、Superpowers</p>
<p>这个是一个完整的软件开发工作流程的 skill，包含需求文档、开发、测试等流程。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/896ddc5273c34ff9a67de7cdc261df37~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441299&amp;x-signature=HopJQvCMEzxYdqEjk8rABCSNq9g%3D" alt="图片" loading="lazy"/></p>
<p>地址：</p>
<pre><code class="hljs language-arduino" lang="arduino">https:<span class="hljs-comment">//github.com/obra/superpowers</span>
</code></pre>
<p>3、X Article Publisher Skill</p>
<p>可以很方便的用来写 X 文章，早就有这个痛点，没想到这么快就有对应的工具了。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/65cba3d251d944a79995ef4cd5deef64~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441299&amp;x-signature=wvD%2FBA%2B%2BvT9cAiv2X0OmvOyeGSY%3D" alt="图片" loading="lazy"/></p>
<p>地址：</p>
<pre><code class="hljs language-arduino" lang="arduino">https:<span class="hljs-comment">//github.com/wshuyi/x-article-publisher-skill</span>
</code></pre>
<p><strong>4、NotebookLM skill</strong></p>
<p>能在 Claude Code 里面直接和 NotebookLM 对话，并上传 PDF 直接到 NotebookLM。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/498bb2c78c7d41d9bd8f7cf58097c548~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441299&amp;x-signature=Ke3R9sBArd0ONrxD0YCoWRHwxRw%3D" alt="图片" loading="lazy"/></p>
<p>地址：</p>
<pre><code class="hljs language-bash" lang="bash">https://github.com/PleasePrompto/notebooklm-skill
</code></pre>
<p><strong>5、obsidian-skills</strong></p>
<p>由 obsidian 老板亲自写的 skills，能够生成 Obsidian 增强型 Markdown，自动添加标签、日期，不破坏原有格式，生成内容可直接存入 Obsidian 库。还能直接生成 Obsidian Canvas 白板。</p>
<p>这个甚至就可以直接在 obsidian 里面安装。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d5aa9ff676804fd0886fac0a02c7e9f9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441299&amp;x-signature=Cx%2F1%2FSSSHcwaubAWhMMtOEmYg14%3D" alt="图片" loading="lazy"/></p>
<p>然后输入提示词：</p>
<pre><code class="hljs language-css" lang="css">用obsidian-skills画一个 <span class="hljs-selector-tag">canvas</span> 来解读这一篇文章"开源版 Claude <span class="hljs-selector-tag">Code</span> 火爆全网，已狂飙 <span class="hljs-number">51.7</span>k Star。。。"
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a91e523a396844cdaf35e76363000a5a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441299&amp;x-signature=rS88xM8YqJyQNuwPzBTCCV3M2sk%3D" alt="图片" loading="lazy"/></p>
<p>可以看到，图就很快出来了：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e15acad07a66488d9054b96c2bf82f55~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441299&amp;x-signature=6eThwP0sW6wd%2FuLEZtJvClYGnmk%3D" alt="图片" loading="lazy"/></p>
<h2 data-id="heading-4">如何制作自己的 Skills 呢？</h2>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c8ffbb8b103d409593407fbe7019708d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441299&amp;x-signature=Ej1lKRt78aVxh3sfp2oDIwxl0no%3D" alt="图片" loading="lazy"/></p>
<p>非常推荐大家先安装 Anthropic 官方的一个 skill：skill-creator，他是专门用来安装 skill 的 skill。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1a252da828974280a8e00a5d50a36737~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441299&amp;x-signature=%2Bkh0tuhlO1CxU%2Fsz45l6DtI5sqA%3D" alt="图片" loading="lazy"/></p>
<p>按照同样的方法先安装这个 skill：</p>
<pre><code class="hljs language-ruby" lang="ruby">帮我直接安装这个skill，地址：<span class="hljs-symbol">https:</span>/<span class="hljs-regexp">/github.com/anthropics</span><span class="hljs-regexp">/skills/blob</span><span class="hljs-regexp">/main/skills</span><span class="hljs-regexp">/skill-creator，克隆这个 skill 到我的已存在的技能目录~/</span>.claude/skills
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1e41865654db4953ae7cf23cd258e7e4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441299&amp;x-signature=5cpHP8Pw1ompzvUpwgf1WtkYoTo%3D" alt="图片" loading="lazy"/></p>
<p>下面就可以在 CC 里面快速的创建 skill</p>
<blockquote>
<p>创建一个 skill，能自动将 pdf 转为 PPT</p>
</blockquote>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/60914da8078c4fe495afb57be8c707f6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441299&amp;x-signature=UGzwroX0zkAQ4Iq3is385rTIBCc%3D" alt="图片" loading="lazy"/></p>
<p>开始一顿操作来创建这个 skill 了：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3d241b945390431eb71a395e6317c712~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441299&amp;x-signature=5BkvBcCBvgx6IOIugf8JWuy20WU%3D" alt="图片" loading="lazy"/></p>
<p>接下来就什么都不用管了，很快就生成好了这个 skill：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/51022ed1345f46a68e543ebacd12e24a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441299&amp;x-signature=Qic33VcI6NB1cANeuKgxaYYsYfs%3D" alt="图片" loading="lazy"/></p>
<p>对应的文件夹也生成 ok 了。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/28cca640652848158ffe358dbc93473d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441299&amp;x-signature=kEP1q%2Bqm8TBbm4NQLEngNAzgSOk%3D" alt="图片" loading="lazy"/></p>
<p>来做下验证，输入以下提示词：</p>
<blockquote>
<p>帮我把“值得去的IT公司（武汉篇）.pdf”转为 ppt 格式</p>
</blockquote>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a77709b812fa438b9cf2fcfd894bc58e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441299&amp;x-signature=ZezpUVOHKNmJe2zbkZoLbSRmkiU%3D" alt="图片" loading="lazy"/></p>
<p>转好了：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a9cd8d6ac26544159447c8b77c8fcbce~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441299&amp;x-signature=4X7%2FKEPCdMyz7hMcHRojhtZLFG8%3D" alt="图片" loading="lazy"/></p>
<p>打开项目看一下：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5e6f58206e9f423cbd7973de1415022e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441299&amp;x-signature=b%2FZBEI7Pccm2zhKGUv%2Buv83d678%3D" alt="图片" loading="lazy"/></p>
<p>来看看效果，没什么问题：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/12ca22e0eca440e7b0c3abb85b13017d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441299&amp;x-signature=u1joUAl0vRSgm2dwKADqp3jViSs%3D" alt="图片" loading="lazy"/></p>
<p>做一个 skill 几分钟时间，非常方便。</p>
<h2 data-id="heading-5">写在最后</h2>
<p>Skills 改变了我们与 AI 协作的基本方式。它们将一次性的提示，转变为持久、可组合的知识资产。</p>
<p>通过为 AI 建立一个可扩展的程序性记忆库，Skills 正在为下一代代更强大、更自主、更能与人类专家无缝协作的 AI Agent 奠定基础。</p>
<p>Skills 把各种经验和方法打包成技能包，降低了跨行使用的成本，普通人也更加方便的创作自己的 Agent 了。</p>
<p><strong>我觉得，掌握 Skills，就是掌握了将组织智慧规模化的能力。</strong></p>
<p>未来，Skills 还会一如火爆，会有越来越多的 Skills 出来。</p>
<p>好了，今天的文章就到这里了，谢谢你喜欢我的文章，我们下期见。</p>
<p>同时，大家如果对 Skills 感兴趣，可以后台回复：Skills，一起加入交流群，探讨。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[首个国产芯片训练的多模态 SOTA 模型，已免费开源！]]></title>    <link>https://juejin.cn/post/7596934200580259876</link>    <guid>https://juejin.cn/post/7596934200580259876</guid>    <pubDate>2026-01-19T15:30:44.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7596934200580259876" data-draft-id="7596934200580243492" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="首个国产芯片训练的多模态 SOTA 模型，已免费开源！"/> <meta itemprop="keywords" content="人工智能"/> <meta itemprop="datePublished" content="2026-01-19T15:30:44.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="苍何"/> <meta itemprop="url" content="https://juejin.cn/user/588993963763405"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            首个国产芯片训练的多模态 SOTA 模型，已免费开源！
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/588993963763405/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    苍何
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-19T15:30:44.000Z" title="Mon Jan 19 2026 15:30:44 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读10分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>这是苍何的第 471 篇原创！</p>
<p>大家好，我是苍何。</p>
<p>看到智谱联合华为开源了新一代图像生成模型 GLM-Image 的消息，我还挺兴奋的。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4c93656891264510b3979faf4478864a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441444&amp;x-signature=NP7%2F8jkEkv0Q2yZ8AIHOKPwts9E%3D" alt="图片" loading="lazy"/></p>
<p>这意味着，AI 生图的价格可能会被打下来，我的感触是很深的，因为最近一直在给我的产品薯图寻找性价比高的生图 API。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/39d5162126af49d4b4d92905b169df43~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441444&amp;x-signature=nCU2Hs6Qec04474OQqAnjENZXl0%3D" alt="图片" loading="lazy"/></p>
<p>试了很多的中转站，目前🍌pro 的价格大概在 0.3-1.2 元之间，总是在稳定和价格之间反复衡量。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3f07e17b80454908be9ed16f93fa3920~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441444&amp;x-signature=x%2BsxAEJCNzxTCqv7Us6OmoLLRMY%3D" alt="图片" loading="lazy"/></p>
<p>看了 GLM-Image 的 API，价格只要 0.1 元一张图，我整个人都精神了。</p>
<p>于是我花时间内测了一下 GLM-Image，也顺带来看看这个<strong>首个在国产芯片上完成全程训练的SOTA多模态模型</strong>有几斤几两。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1dc017a6e4324f9b90c265c94dfd2d03~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441444&amp;x-signature=Gp5uKIjxlpAlSblVq4pirbh4pME%3D" alt="图片" loading="lazy"/></p>
<p>先说下整体感受：</p>
<p><strong>1、中文指令理解能力好，文字生成准确率高，特别是多区域文字生成上。</strong><br/>
<strong>2、在绘制包含复杂逻辑的原理图、科普插画上表现好。</strong><br/>
<strong>3、具备一定的设计和审美能力，</strong></p>
<p>但是在长 prompt 的输入下，就会被限制，也希望后面官方可以优化下，就拿薯图来说，提示词非常的长，就非常需要支持。</p>
<p>这篇文章主要给大家带来一手的实测，以及对 GLM-Image 的 API 调用教程。并且我把基于GLM-Image API 的生图平台也开源了，大家可以去 GitHub 上使用，见文末。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a19d069e9d634a1c81ca38b1b60f9749~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441444&amp;x-signature=PVfI3T8%2FZI12SBPpVymFCbdbIPg%3D" alt="图片" loading="lazy"/></p>
<blockquote>
<p>如果文章对你有帮助，欢迎点赞收藏，并转发给需要的朋友。</p>
</blockquote>
<h2 data-id="heading-0">GLM-Image 介绍</h2>
<p>在开始实测前，还是有必要来了解下 GLM-Image。</p>
<p>模型基于昇腾Atlas 800T A2设备和昇思MindSpore AI框架完成从数据到训练的全流程，是首个在国产芯片上完成全程训练的SOTA多模态模型。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7602f7b494d1400995b4bb583e35855f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441444&amp;x-signature=kHv%2FUCxC3XhRoNfqmQfO%2FQBvIIs%3D" alt="图片" loading="lazy"/></p>
<p>GLM-Image采用自主创新的「自回归+扩散解码器」混合架构，实现了图像生成与语言模型的联合，</p>
<p><strong>这也是首个开源的工业表现级离散自回归图像生成模型</strong>。</p>
<p>GLM-Image 引入了「自回归+扩散解码器」混合架构，创新地融合了9B大小的自回归模型与7B大小的DiT扩散解码器。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/695b0d3bbbb24b18b82e8a3ca53e3ba1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441444&amp;x-signature=nrKeeKC69jqzkIAUYpFymAcIcug%3D" alt="图片" loading="lazy"/></p>
<p>同时，GLM-Image 在文字渲染的权威榜单中达到开源 SOTA 水平。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3a1f17dbc3ba45609e1b26b58dbf3a8a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441444&amp;x-signature=yvbjVB7v3uqT09R0wpXWF5K6vq8%3D" alt="图片" loading="lazy"/></p>
<h2 data-id="heading-1">GLM-Image 实测</h2>
<p>下面给大家带来一波我用 API 做的实测 GLM-Image，内含提示词。</p>
<h3 data-id="heading-2">黑板报制作</h3>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0da59d2f8baa43d88ea73ed224ddbb15~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441444&amp;x-signature=KPhE9i4CH3%2F2BiemS4AMgFzgSyk%3D" alt="图片" loading="lazy"/></p>
<pre><code class="hljs">提示词：
⿊板粉笔⻛格的科学信息图插画，采⽤横向构图，背景为深⾊⿊板，带有明显的粉笔灰、擦拭

痕迹与颗粒质感，整体呈现⼩学⾼年级或中学科学教室中常⻅的教学⿊板⻛格。顶部居中位置

为⼀个⼤标题，使⽤彩⾊粉笔⼿写字体⻛格，标题内容为：“⽜顿的三棱镜实验：光的『七⼗

⼆变』”，字体颜⾊包括红、蓝、绿、⻩、紫等多种粉笔⾊，边缘略带粗糙感，呈现⼿⼯书写

的真实质感。 \n\n画⾯左侧放置⼀个⽤⽩⾊粉笔画出的矩形光源装置，⼀束强烈⽩光以⽔平⽅

向射出，旁边标注⽂字：“⼀束⽩光（⼤礼包）”，字体采⽤简洁的粉笔字，略带⼿写⻛格。

\n\n画⾯中央绘有⼀块透明的三棱镜，⽤⽩⾊粉笔线条勾勒出清晰的⽴体结构，具有轻微的透

视效果。⽩光进⼊三棱镜后，在其内部发⽣折射并分离，表现出光的分解过程。 \n\n画⾯右侧

展⽰⽩光分解为红、橙、⻩、绿、⻘、蓝、紫七道彩⾊光束，呈扇形展开，颜⾊采⽤粉笔质感

渲染，⽽⾮真实的光效。在彩⾊光束的右侧，⽤⼤括号标注：“七⾊光谱（真相⼤⽩！）”。

在彩⾊光束的上⽅和下⽅分别⽤粉笔⽂字标注解释：“红光：拐弯最⼩”“紫光：拐弯最

⼤”。 \n\n在三棱镜顶部或彩⾊光束上⽅，加⼊两个拟⼈化的卡通⻆⾊（简单粉笔涂鸦⻛），

分别为红⾊和紫⾊，两个⻆⾊像滑滑梯⼀样顺着折射路径滑下，表情夸张、有趣但不过于低

幼，⽤于直观表现光的折射差异，增强趣味性和理解性。 \n\n底部中央位置绘制⼀个粉笔画出

的对⽩框或讲解框，内含多⾏中⽂说明⽂字：“原来，⽩光不是‘单⾝狗’，⽽是‘七⾊合

体’的复⾊光！不同颜⾊的光‘性格’不同（折射率不同），过三棱镜时拐弯⻆度就不同，紫

光最容易拐⼤弯！” \n\n整体画⾯⻛格为⼿绘⻛格，线条略带抖动感，强调粉笔的质感与⼿⼯

感，不追求真实光学模拟，⽽是注重信息传达与教学直观性。信息图结构清晰，具有强烈的教

学感，融合⼀点幽默元素，适合⽤于科普插画、知识卡⽚或课堂海报。图幅⾼分辨率，⾮摄影

⻛格，⾮3D渲染，不包含真实⼈物形象。
</code></pre>
<h3 data-id="heading-3">黑板粉笔风格</h3>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/337cb206483040baa7a59c62057c41f2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441444&amp;x-signature=u8ns4%2Bfr74TZCMYmBD88%2FVt7B38%3D" alt="图片" loading="lazy"/>提示词：</p>
<pre><code class="hljs">提示词：
黑板粉笔风格科学信息图，横向构图，深色黑板背景，带有粉笔灰与擦拭痕迹。

顶部标题： 彩色粉笔手写体“植物的魔法厨房”。

左侧（原料）： 戴墨镜的卡通太阳（阳光）、蓝色水滴（水）、白色气泡（CO2）。

中央（加工）： 巨大的绿色叶子剖面图，内部画成工厂车间，有一个戴厨师帽的绿色“叶绿体”卡通角色正在大锅里搅拌烹饪。

右侧（产物）： 飘出的O2气泡（氧气）和堆积的白色方块（糖/淀粉）。

底部： 粉笔画的讲解框，内含中文说明文字。

风格： 2D手绘涂鸦风，线条粗糙，高对比度粉笔质感，色彩鲜艳（绿、黄、白为主），幽默通俗，非写实，无真实人物，教育插图风格。
</code></pre>
<h3 data-id="heading-4">仿真 3D 图</h3>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/71483cf6ae804be998da412973052c20~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441444&amp;x-signature=L2wOpH7Klhc3KN8fa6J2a9HnfXk%3D" alt="图片" loading="lazy"/></p>
<pre><code class="hljs">提示词：
画个航空发动机的仿真3d图，其中的字体有中英双语注程
</code></pre>
<h3 data-id="heading-5">生成清明上河图部分</h3>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bc51f930f40746a3af7ed1aadded6f78~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441444&amp;x-signature=eErhFhk9HexbYixLyU84uH8CFU8%3D" alt="图片" loading="lazy"/></p>
<pre><code class="hljs">提示词：
请你帮我生成一张清明上河图的照片
</code></pre>
<h3 data-id="heading-6">电商宣传图</h3>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7a9323641fda462d8362cd5d0d52e20d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441444&amp;x-signature=f%2Byn1UlorM%2FUP2I79bwVfMQkjDk%3D" alt="图片" loading="lazy"/></p>
<pre><code class="hljs">提示词：
高端极简护肤品摄影。画面中央竖立着一瓶半透明的粉色液体洁面乳，配有白色按压泵头。瓶身浸润在柔和的粉色泡沫中，轻盈的泡沫向外扩散，形成光滑圆润的形状。细小的透明气泡漂浮在泡沫表面。干净的哑光粉色背景，
带有微妙的渐变效果。柔和的漫射顶光和柔和的轮廓光透过液体，营造出明亮的光泽，并突出瓶内的按压泵头。画面清晰锐利，清晰度高，呈现逼真的液体折射效果，光滑的塑料和玻璃质感，展现出奢华美妆广告风格，符合现代化妆品品牌形象，超逼真，8K细节，高动态范围。 否定提示： 
手、人、脸、杂物、刺眼的反光、标签变形、无法辨认的文字、扭曲的泵、生硬的阴影、颗粒感、噪点、低分辨率、电脑特效风格、卡通风格、凌乱的泡沫、光线不均、水印
</code></pre>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1fb0b73a9c4f4b4f95642019651a65f1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441444&amp;x-signature=h4Qpqf%2BmSiaVu6JZormJwUv3Gyc%3D" alt="图片" loading="lazy"/></p>
<pre><code class="hljs language-css" lang="css">提示词：
视觉构建：Tip-<span class="hljs-attribute">Top</span> 核心系列果汁包装 第一层：核心定调（Core Intent） 一套高品质商业级的果汁包装视觉。不仅是产品展示，更是充满动感与食欲的商业海报。统一采用 <span class="hljs-number">2</span>:<span class="hljs-number">3</span> 的纵横比，旨在通过强烈的视觉张力驱动消费购买欲望。 第二层：场景构建（Context &amp; Lighting） 构建一个**动态飞溅（Splash）**的虚拟空间。果汁流在包装周围呈螺旋状旋转，伴随着新鲜果块的飞舞。灯光通透且明亮，完美还原商业摄影中对液体晶莹剔透质感的捕捉。 
第三层：视觉系统（Aesthetic &amp; Subject） 色彩矩阵： 采用色彩映射逻辑。草莓味对应清新莫兰迪粉，芒果味对应热带橙黄渐变，葡萄味对应优雅深紫渐变。 视觉语言： 走超写实、高饱和度的活力商业风，强调色彩的纯净度与诱惑力。 第四层：文字/符号系统（Graphics） 
画面视觉中心为 <span class="hljs-string">"Tip-Top"</span> 品牌包装盒。包装设计与背景元素无缝融合，品牌 Logo 位于包装醒目位置，下方标注对应的草莓、金芒果或紫色葡萄口味名称。 第五层：细节增强（Material &amp; Texture） 极致质感： 包装盒呈现真实的纸质/复合材料触感；果肉细节需达到毛孔级写实（如草莓表面的颗粒、芒果的润泽）。 动态特效： 飞溅的液体带有写实的光泽反射与通透的折射效果，包装边缘伴有动感旋转的水流微粒。
</code></pre>
<h3 data-id="heading-7">人物生成</h3>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a5b4f2bd276d4b3ca102bd418da57975~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441444&amp;x-signature=OhZeILprgTa8frlsxbRxf55U3N4%3D" alt="图片" loading="lazy"/></p>
<pre><code class="hljs language-makefile" lang="makefile">提示词：
<span class="hljs-section">9:16，超现实电影感自拍摄影，严格保留参考图脸部、皮肤、头发、眼镜、年龄性别，无合成皮肤/雕塑感；女性全身自拍，一脚触地，一手伸直上举持机（相机不可见）、一手伸镜头前持佳能相机（产品最突出），头微倾、表情放松；极端俯拍（相机正上方）+胸部高度自拍视角，强制透视让女性极度巨大，</span>
建筑最高及膝，行人/车辆为真实尺度；背景是真实城市十字路口（含人行横道、交通标志等），自然日光（晴/轻微多云）、阴影柔和真实；佳能相机无畸变、logo完整、仅自然反光；画面无AI艺术感、塑料皮肤、
肢体扭曲、多余肢体、文字水印，前景/主体/背景清晰分离，主体视觉主导全场景
</code></pre>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b2673f9e3e464b30a96a1236e0c75738~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441444&amp;x-signature=ZKKha8OPFKbWJepEXjpI5F5C8YQ%3D" alt="图片" loading="lazy"/></p>
<pre><code class="hljs language-makefile" lang="makefile">提示词：
传统艺术扫描，纹理纸上的原始石墨铅笔素描。艺术风格明显为荒木飞吕彦，《JOJO的奇妙冒险》美学。粗犷、黑白漫画分镜感。全身镜头，摆出夸张、戏剧化的“JOJO立”，肢体扭曲、不可能解剖结构、
<span class="hljs-section">强烈动态透视。高级时尚雕塑姿态。强调肌肉结构与张力。厚重棱角交叉影线阴影，大胆凿刻粗轮廓，极其细致的面部特征，厚唇锐利眼神。可见的侵略性铅笔笔触。高对比度。强烈气场。9:16</span>
</code></pre>
<h3 data-id="heading-8">海报</h3>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4c713b9f8f274d2f985296b9bbf74fb0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441444&amp;x-signature=6O36Xeis7ct%2FYSTZVC8UkrXmgiA%3D" alt="图片" loading="lazy"/></p>
<pre><code class="hljs language-css" lang="css">提示词：
我要举办一场活动，主题为“<span class="hljs-selector-tag">A</span>赋能发明创新”，时间为<span class="hljs-number">2025</span>年<span class="hljs-number">11</span> 月<span class="hljs-number">20</span>日上午<span class="hljs-number">10</span>点，地点在北京体育中心，请帮我画一张宣传海 报，要求有科技感。
</code></pre>
<h3 data-id="heading-9">做菜步骤</h3>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ca5e275e5e0d4441864d76e133b70d6f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441444&amp;x-signature=vyhXNvebfMB3dsqUZp1uF5ia7Zk%3D" alt="图片" loading="lazy"/></p>
<pre><code class="hljs">提示词：
为「{红烧鱼}」生成一张分步骤菜谱信息图，要求： - 俯视图，极简风格，白色背景 - 顶部居中显示菜品中文名 - 标注所有食材的中文名称、用量和热量 - 用虚线和图标展示烹饪步骤 - 底部展示成品摆盘效果图 请根据该菜品的传统做法，自动匹配合适的： 1. 食材清单（包含精确用量和热量） 2. 烹饪步骤图标（如：切菜、炒制、调味等） 3. 成品呈现方式 2:3
</code></pre>
<h2 data-id="heading-10">如何接入 API</h2>
<p>目前 GLM-Image 的 API 还处于内测阶段，为了方便大家体验，我用 Claude Code 配合 GLM-4.7 开发了个测试平台，并且在 GitHub 上开源了。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4146a2a32c9a4022888cdf4861b465c1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441444&amp;x-signature=CPiiG7t1uPa7zYndkJZWAwqMTIc%3D" alt="图片" loading="lazy"/></p>
<p>输入需求生成图片，大家可以在 bigmodel 上用自己的 API 试试。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c9263f0a462f4d0a8809c07b4868cc8d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441444&amp;x-signature=kPytKC3HyAv328T8rSPvBsMTJe8%3D" alt="wxv_4341792120702074885" loading="lazy"/></p>
<p>开源地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ffreestylefly%2Fglm_image_platform" target="_blank" title="https://github.com/freestylefly/glm_image_platform" ref="nofollow noopener noreferrer">github.com/freestylefl…</a></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/695e1f1e549d489380b5afc754cb8b2f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441444&amp;x-signature=Mk9ow9pf8AYI4cXe%2FCHUewNcFZg%3D" alt="图片" loading="lazy"/></p>
<h2 data-id="heading-11">写在最后</h2>
<p>说实话，写到这里，我心里挺感慨的。</p>
<p>曾几何时，国产算力在很多 AI 开发者眼里，往往意味着适配难、生态弱、甚至跑不动。</p>
<p>但这回，GLM-Image 这个完全基于国产芯片训练出来的 SOTA 模型，实实在在地证明了一件事：<strong>哪怕路再难走，只要有人肯沉下心去死磕，路总是能走通的。</strong></p>
<p>它可能还不是终点，甚至可能在某些场景下还有瑕疵，但它迈出的这一步，让咱们看到了国产 AI 生态“自主造血”的希望。</p>
<p>风起于青萍之末，我很期待看到大家用它玩出什么新花样。</p>
<p>模型链接和部署教程我都打包好了，感兴趣的兄弟们自取。</p>
<p>好啦，今天的文章就到这，感谢你喜欢我的文章，我们下一期见。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[一文搞懂t-SNE和UMAP降维方法！]]></title>    <link>https://juejin.cn/post/7596919439019278345</link>    <guid>https://juejin.cn/post/7596919439019278345</guid>    <pubDate>2026-01-19T15:36:20.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7596919439019278345" data-draft-id="7596906473306636338" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="一文搞懂t-SNE和UMAP降维方法！"/> <meta itemprop="keywords" content="面试,算法"/> <meta itemprop="datePublished" content="2026-01-19T15:36:20.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="aicoting"/> <meta itemprop="url" content="https://juejin.cn/user/933911964427818"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            一文搞懂t-SNE和UMAP降维方法！
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/933911964427818/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    aicoting
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-19T15:36:20.000Z" title="Mon Jan 19 2026 15:36:20 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>推荐直接网站在线阅读：<a href="https://link.juejin.cn?target=https%3A%2F%2Faicoting.cn" target="_blank" title="https://aicoting.cn" ref="nofollow noopener noreferrer">aicoting.cn</a></p>
</blockquote>
<p>降维与表示学习是无监督学习中的重要方法，旨在将高维数据映射到低维空间，同时尽可能保留数据的结构与信息。降维方法如 主成分分析（PCA）、独立成分分析（ICA） 能去除冗余特征，降低计算复杂度，并便于可视化；非线性方法如 t-SNE、UMAP 则能在低维空间中保留数据的局部或全局结构。</p>
<p>前面我们介绍了PCA<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F1993373759931954886" target="_blank" title="https://zhuanlan.zhihu.com/p/1993373759931954886" ref="nofollow noopener noreferrer">一文搞懂机器学习中的PCA主成分分析！</a>和<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F1993671061439549575" target="_blank" title="https://zhuanlan.zhihu.com/p/1993671061439549575" ref="nofollow noopener noreferrer">ICA机器学习中独立成分分析ICA和主成分分析PCA有什么区别</a>？今天我们来看一下 t-SNE和UMAP。</p>
<h2 data-id="heading-0">t-SNE 降维</h2>
<p>在高维数据分析和可视化中，t-SNE（t-distributed Stochastic Neighbor Embedding,t-分布随机邻域嵌入） 是一种非常流行的非线性降维方法，特别适用于将高维数据嵌入到二维或三维空间以进行可视化。</p>
<p>与 PCA 或 ICA 不同，t-SNE 并不关注全局结构，而是重点保持数据在局部邻域的结构关系，使相似样本在低维空间中保持相对接近，而不相似样本尽量远离，从而直观展示数据的聚类或分布模式。</p>
<p>t-SNE 的核心思想是将高维数据中的相似性映射到低维空间。它首先计算高维空间中每对样本的条件概率，表示一个样本选择另一个样本作为邻居的可能性。接着，t-SNE 在低维空间中定义类似的条件概率，并通过最小化高维与低维概率分布之间的 Kullback-Leibler（KL）散度，使低维嵌入尽量保持高维局部相似性。</p>
<p>为了防止“拥挤问题”（Crowding Problem），t-SNE 使用 t 分布（自由度为 1 的学生 t 分布）代替高斯分布，增加低维空间中样本间的分离度。</p>
<p>t-SNE 的算法流程通常包括以下步骤：</p>
<ol>
<li>计算高维相似度：对高维数据中的每对样本 ，使用高斯核计算条件概率 ，表示 选择 作为邻居的概率。</li>
<li>对称化概率：将条件概率对称化得到 。</li>
<li>初始化低维嵌入：通常随机初始化低维空间中的点 。</li>
<li>计算低维相似度：使用 t 分布计算低维空间中每对点的相似度 。</li>
<li>最小化 KL 散度：通过梯度下降最小化高维分布 P 与低维分布 Q 的 KL 散度：</li>
<li>迭代优化：更新低维嵌入，直到 KL 散度收敛或达到预设迭代次数。</li>
</ol>
<p>t-SNE 的核心特点是局部结构保持能力强，能很好地将数据中的簇结构和局部关系呈现在低维空间中，但它对全局结构的保留较弱。此外，t-SNE 对超参数敏感，如 perplexity（相当于邻居数量的平滑参数）、学习率和迭代次数都会显著影响结果。实践中，通常需要尝试不同参数组合以获得稳定的可视化效果。</p>
<p>下面使用 Scikit-learn 对 Iris 数据集进行 t-SNE 可视化：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> sklearn.datasets <span class="hljs-keyword">import</span> load_iris
<span class="hljs-keyword">from</span> sklearn.manifold <span class="hljs-keyword">import</span> TSNE
<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt

<span class="hljs-comment"># 加载数据</span>
iris = load_iris()
X = iris.data
y = iris.target

<span class="hljs-comment"># t-SNE 降维到 2 维</span>
tsne = TSNE(n_components=<span class="hljs-number">2</span>, perplexity=<span class="hljs-number">30</span>, learning_rate=<span class="hljs-number">200</span>, n_iter=<span class="hljs-number">1000</span>, random_state=<span class="hljs-number">42</span>)
X_tsne = tsne.fit_transform(X)

<span class="hljs-comment"># 可视化</span>
plt.figure(figsize=(<span class="hljs-number">8</span>,<span class="hljs-number">6</span>))
plt.scatter(X_tsne[:,<span class="hljs-number">0</span>], X_tsne[:,<span class="hljs-number">1</span>], c=y, cmap=<span class="hljs-string">'viridis'</span>, s=<span class="hljs-number">40</span>)
plt.xlabel(<span class="hljs-string">"t-SNE Component 1"</span>)
plt.ylabel(<span class="hljs-string">"t-SNE Component 2"</span>)
plt.title(<span class="hljs-string">"t-SNE Visualization of Iris Dataset"</span>)
plt.colorbar()
plt.show()
</code></pre>
<p>运行结果如下，二维散点图展示了不同类别样本的聚类情况。可以看到，t-SNE 能很好地区分数据的不同簇，并且保持每个簇的局部结构。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e19be82147a44e549dfc9075cfb8fd00~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgYWljb3Rpbmc=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441780&amp;x-signature=EVfYkgbuA3tq9CDzqYZeDZ3zFVg%3D" alt="" loading="lazy"/></p>
<p>总结来说，t-SNE 是一种强大的非线性降维和可视化方法，尤其适用于高维数据的探索性分析。它能有效揭示数据的簇结构和局部关系，使数据可视化更直观。相比 PCA、ICA 等线性方法，t-SNE 更关注局部相似性，但也因此存在全局结构保留不足和计算开销较大的问题。在实际使用中，通过调整超参数，可以获得不同的可视化效果，广泛应用于图像、文本、基因组数据等领域。</p>
<h2 data-id="heading-1">UMAP 降维</h2>
<p>UMAP（Uniform Manifold Approximation and Projection）是一种先进的非线性降维方法，用于将高维数据映射到低维空间，同时尽可能保留数据的局部和全局结构。</p>
<p>UMAP 结合了流形学习理论和图论方法，相比 t-SNE，它不仅保留局部邻域关系，同时在低维空间中对全局结构的保留也更好，并且计算效率更高。UMAP 广泛应用于高维数据可视化、聚类分析、特征提取等场景。</p>
<h3 data-id="heading-2">算法原理</h3>
<p>UMAP 基于流形假设，假设高维数据分布在低维流形上，并且数据的局部邻域可以反映流形的几何结构。UMAP 的核心思想是：首先通过高维空间中的邻域关系构建一个加权图，然后将图映射到低维空间，通过优化低维空间中点的相似性，使得邻居关系尽可能保持一致。</p>
<p>具体而言，UMAP 通过以下步骤建立映射：</p>
<ol>
<li>高维邻域图构建：对每个样本计算 k 个最近邻，并使用模糊集合理论定义邻居之间的相似度权重。</li>
<li>低维图初始化：随机初始化低维空间中每个样本的位置。</li>
<li>优化嵌入：通过交叉熵损失函数最小化高维图和低维图之间的差异，使低维点的邻居关系与高维数据尽量一致。</li>
</ol>
<p>UMAP 的优化过程使用随机梯度下降（SGD），使其在处理大规模数据时也能保持高效率。UMAP 的非线性特性使它能够捕捉复杂的数据结构，同时保留局部和部分全局关系。</p>
<h3 data-id="heading-3">算法特点</h3>
<p>与其他降维方法相比，UMAP 具有以下显著特点：</p>
<ul>
<li>局部结构保持能力强：类似 t-SNE，能够将相似样本在低维空间中聚集。</li>
<li>全局结构保留较好：相比 t-SNE，UMAP 在低维空间中更好地保持簇之间的相对位置关系。</li>
<li>高计算效率：UMAP 利用图近似和优化算法，对大规模数据的降维速度快。</li>
<li>可扩展性强：UMAP 可以处理数十万到百万级样本的数据集，同时支持新样本的嵌入。</li>
<li>超参数可控：主要包括 n_neighbors（邻居数量）和 min_dist（最小距离），分别控制局部平滑和低维空间簇的紧密程度。</li>
</ul>
<p>下面用 Python 的 umap-learn 库对 Iris 数据集进行降维和可视化示例：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> umap
<span class="hljs-keyword">from</span> sklearn.datasets <span class="hljs-keyword">import</span> load_iris
<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt

<span class="hljs-comment"># 加载数据</span>
iris = load_iris()
X = iris.data
y = iris.target

<span class="hljs-comment"># UMAP 降维到 2 维</span>
umap_model = umap.UMAP(n_neighbors=<span class="hljs-number">15</span>, min_dist=<span class="hljs-number">0.1</span>, n_components=<span class="hljs-number">2</span>, random_state=<span class="hljs-number">42</span>)
X_umap = umap_model.fit_transform(X)

<span class="hljs-comment"># 可视化</span>
plt.figure(figsize=(<span class="hljs-number">8</span>,<span class="hljs-number">6</span>))
plt.scatter(X_umap[:,<span class="hljs-number">0</span>], X_umap[:,<span class="hljs-number">1</span>], c=y, cmap=<span class="hljs-string">'viridis'</span>, s=<span class="hljs-number">40</span>)
plt.xlabel(<span class="hljs-string">"UMAP Component 1"</span>)
plt.ylabel(<span class="hljs-string">"UMAP Component 2"</span>)
plt.title(<span class="hljs-string">"UMAP Visualization of Iris Dataset"</span>)
plt.colorbar()
plt.show()
</code></pre>
<p>在结果中，不同类别的样本被清晰地分开，UMAP 能同时保留局部簇结构和簇之间的全局关系。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e302480eabec4eff8d870a68022ec29e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgYWljb3Rpbmc=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441780&amp;x-signature=l7Ux%2BufE9To7sqqqun9sJcJpXpY%3D" alt="" loading="lazy"/></p>
<p>UMAP 适用于多种高维数据分析任务：</p>
<ul>
<li>数据可视化：二维或三维投影，便于观察数据分布和聚类结构。</li>
<li>聚类前处理：降低维度减少计算量，提高聚类算法效率。</li>
<li>特征提取：从高维数据中提取低维特征用于分类或回归任务。</li>
<li>生物信息学：用于单细胞 RNA-seq 数据分析和可视化。</li>
<li>图像与文本：在图像嵌入和自然语言处理特征表示中广泛使用。</li>
</ul>
<p>总结一下，UMAP 是一种高效、灵活的非线性降维方法，结合了流形学习和图优化思想，能够在低维空间中同时保留局部和全局结构。相比 t-SNE，它在可视化高维数据簇结构和保持簇间关系方面表现更好，同时计算速度更快。UMAP 的超参数可调，使其在不同数据集和任务中灵活适配。通过合理使用 UMAP，可以将复杂高维数据的模式、簇结构和潜在特征直观呈现，为后续分析和建模提供有力支持。</p>
<p>📚 推荐阅读</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwMTcyOTcyOQ%3D%3D%26mid%3D2247485782%26idx%3D1%26sn%3D060c8222b47cbf903fbfded1f0421bcf%26scene%3D21%23wechat_redirect" target="_blank" title="https://mp.weixin.qq.com/s?__biz=MzkwMTcyOTcyOQ==&amp;mid=2247485782&amp;idx=1&amp;sn=060c8222b47cbf903fbfded1f0421bcf&amp;scene=21#wechat_redirect" ref="nofollow noopener noreferrer">机器学习之数据预处理篇！</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwMTcyOTcyOQ%3D%3D%26mid%3D2247485800%26idx%3D1%26sn%3Da52107c9dc7071d8530a24563861fa46%26scene%3D21%23wechat_redirect" target="_blank" title="https://mp.weixin.qq.com/s?__biz=MzkwMTcyOTcyOQ==&amp;mid=2247485800&amp;idx=1&amp;sn=a52107c9dc7071d8530a24563861fa46&amp;scene=21#wechat_redirect" ref="nofollow noopener noreferrer">机器学习特征工程中的特征选择</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwMTcyOTcyOQ%3D%3D%26mid%3D2247485808%26idx%3D1%26sn%3D2c57081d4b12433f6b8919209e2e52ed%26scene%3D21%23wechat_redirect" target="_blank" title="https://mp.weixin.qq.com/s?__biz=MzkwMTcyOTcyOQ==&amp;mid=2247485808&amp;idx=1&amp;sn=2c57081d4b12433f6b8919209e2e52ed&amp;scene=21#wechat_redirect" ref="nofollow noopener noreferrer">机器学习中的特征构造</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwMTcyOTcyOQ%3D%3D%26mid%3D2247485820%26idx%3D1%26sn%3Dadcb41fd14347f2f1431709323fa253f%26scene%3D21%23wechat_redirect" target="_blank" title="https://mp.weixin.qq.com/s?__biz=MzkwMTcyOTcyOQ==&amp;mid=2247485820&amp;idx=1&amp;sn=adcb41fd14347f2f1431709323fa253f&amp;scene=21#wechat_redirect" ref="nofollow noopener noreferrer">机器学习之特征降维</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwMTcyOTcyOQ%3D%3D%26mid%3D2247485941%26idx%3D1%26sn%3Dcb53a98bacd1cfbd3255bbeeab6a24ec%26scene%3D21%23wechat_redirect" target="_blank" title="https://mp.weixin.qq.com/s?__biz=MzkwMTcyOTcyOQ==&amp;mid=2247485941&amp;idx=1&amp;sn=cb53a98bacd1cfbd3255bbeeab6a24ec&amp;scene=21#wechat_redirect" ref="nofollow noopener noreferrer">一文搞懂层次聚类和密度聚类方法！</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwMTcyOTcyOQ%3D%3D%26mid%3D2247485946%26idx%3D1%26sn%3Da5cf50a4a3bda9785fb0c7baae3a6bb2%26scene%3D21%23wechat_redirect" target="_blank" title="https://mp.weixin.qq.com/s?__biz=MzkwMTcyOTcyOQ==&amp;mid=2247485946&amp;idx=1&amp;sn=a5cf50a4a3bda9785fb0c7baae3a6bb2&amp;scene=21#wechat_redirect" ref="nofollow noopener noreferrer">一文搞懂机器学习中的PCA主成分分析！</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwMTcyOTcyOQ%3D%3D%26mid%3D2247485952%26idx%3D1%26sn%3Dffe1fca4cb75b2f99ace92593554837c%26scene%3D21%23wechat_redirect" target="_blank" title="https://mp.weixin.qq.com/s?__biz=MzkwMTcyOTcyOQ==&amp;mid=2247485952&amp;idx=1&amp;sn=ffe1fca4cb75b2f99ace92593554837c&amp;scene=21#wechat_redirect" ref="nofollow noopener noreferrer">机器学习中独立成分分析ICA和主成分分析PCA有什么区别？</a></p>
<p>最新的文章都在公众号更新，别忘记关注哦！！！</p>
<p>作者：aicoting</p>
<p>分享是一种信仰，连接让成长更有温度。</p>
<p>我们下次不见不散！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[这张 DINQ 卡，装下了我所有的 AI 经历！]]></title>    <link>https://juejin.cn/post/7596934200580276260</link>    <guid>https://juejin.cn/post/7596934200580276260</guid>    <pubDate>2026-01-19T15:36:56.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7596934200580276260" data-draft-id="7596883689827565631" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="这张 DINQ 卡，装下了我所有的 AI 经历！"/> <meta itemprop="keywords" content="人工智能"/> <meta itemprop="datePublished" content="2026-01-19T15:36:56.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="苍何"/> <meta itemprop="url" content="https://juejin.cn/user/588993963763405"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            这张 DINQ 卡，装下了我所有的 AI 经历！
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/588993963763405/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    苍何
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-19T15:36:56.000Z" title="Mon Jan 19 2026 15:36:56 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>这是苍何的第 472 篇原创！</p>
<p>大家好，我是苍何。</p>
<p>不瞒你说，我现在两个号加起来差不多有 15000 好友了，加起来也发了差不多有 10000 多次自我介绍了。</p>
<p>我迭代过 N 个版本，无论是文字版还是小程序版，总觉得哪里不大对劲，但又说不上来。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/875ab91b956f4811bd3a474363e5862e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441816&amp;x-signature=VwltLpLYdRwv77m2wod6UYSj3as%3D" alt="图片" loading="lazy"/></p>
<p>你说发纯文字吧，又没办法展示全，装逼又没法装到位（呸，是没法让新朋友更深入了解我🐶）。</p>
<p>比如除了公众号，我的小红书、B 站、X 我还蛮想分享的。</p>
<p>后面，我又学着发个名片小程序，但平台数据又没办法直接同步，每次有新的更新，又得同步。</p>
<p>最关键的是，在其他平台的名片总不能都用小程序吧。</p>
<p>特别是最近 X，不少朋友想链接我，一小子没法找到，只能评论区来留言。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0996b7873f3742e794e1d6e2bec2f807~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441816&amp;x-signature=VFRf6sdLiU%2Fr1LzWiNABplS6uhU%3D" alt="图片" loading="lazy"/></p>
<p>你看我主页，干净的比刚出生的小猪还白。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/157e9e26d8374b9697553a36e4d6edbd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441816&amp;x-signature=ovjjqRMWT96ZDLst0uQbP4Lwtl0%3D" alt="图片" loading="lazy"/></p>
<p>唯一留的一个个人网站，还是前两年做的，就很抽象。</p>
<p>所以，我找了蛮多的工具想要做一个超级名片，能 all in one 所有平台，并方便更新和维护，更方便社交和链接。</p>
<p>只要精神不滑坡，办法总比问题多，在一番折腾后，我总算找到了一款产品，能解决我当下的问题了。</p>
<p>我愿称之为我的 AI 超级名片。</p>
<p>我先浅浅给你截一张图，你先浅浅感受一下：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8d43888fba0f4555836447fd8c4a6535~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441816&amp;x-signature=xEut8e1m8JYxIVXF4%2BJMUl2Cpvw%3D" alt="图片" loading="lazy"/></p>
<p>这是第二视角，也就是拿到我的名片后看到的静态效果，但你以为就这？说个锤子，还真不是。</p>
<p>首先，这是个可以交互的 AI 超级名片，这里面每一个社媒账号都是可点击直接跳转到对应主页的。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/017309c787994fa397b26e4a065aaaed~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441816&amp;x-signature=UYh8FQ%2F51A3%2F7SSNEoksgtI9LoA%3D" alt="图片" loading="lazy"/></p>
<p>而且你发现没有，这里展示的永远是我最新的一条作品，也就是，平台数据的更新，在这里就能实时做显示。</p>
<p>比如我最近在 X 上发表的 skills 的教程，当我点击进去的时候，客户就能看到我最新的这条内容。</p>
<p>对于像 X、YouTube、B 站等平台的粉丝数据也直接一并显示了，这一点很重要，这个数据也是动态更新的。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/13eb9928faad47c59f51fdf9e24bce6f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441816&amp;x-signature=ywIOD6EF7IstpScIhOguhYfE6v4%3D" alt="图片" loading="lazy"/></p>
<p>你发现没有，在 X 关注数的下方，有一个 Top Smart Followers，你是可以看到最活跃粉丝数的，点击甚至能直接去他们的主页。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/08d92d69b49944d39f8e8bc55a6c8c70~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441816&amp;x-signature=pQMsidQUZ7q1KBnlNn4HGAfUCdE%3D" alt="图片" loading="lazy"/></p>
<p>我看了一下，我的粉丝中，居然 top 前三都是小姐姐，不知道是不是因为我这个黄毛头像比较亮眼还是其他什么原因，总之还挺惊喜的。</p>
<p>这还只是一小部分细节，在 YouTube 这里甚至可以直接看最新的一条视频，而无需直接跳转到 YouTube 平台，就可完整的看完最新的视频作品。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1f723ce36ff446668f22654f3bde6fca~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441816&amp;x-signature=NVwZZTfWMFenkhIrgVmhfwW4e6g%3D" alt="wxv_4342331248954572800" loading="lazy"/></p>
<p>除了展示社交平台，还能放自己的产品，简历、个人网站等，可以放图片或者视频，然后超链接跳转。比如我就放了个我的产品薯图的视频，当用户点击视频就能跳转到产品首页。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/273003bd014e4e30a7d6d3948dc560f9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441816&amp;x-signature=LhFxytaWHCW4Fj7r2KmFjh3oi74%3D" alt="图片" loading="lazy"/></p>
<p>还能展示团队关系以及相关介绍。录了个视频你可以感受一下这种链接的感觉。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f12cba3785bc4cf398273139f8fdb139~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441816&amp;x-signature=9tklZCr9n%2FbE51KlDCDRvYvPtQo%3D" alt="wxv_4342331629546242049" loading="lazy"/></p>
<p>你甚至还能直接在这里找我聊天，直接进行即时通讯了。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c1322e3135854947b5df8bc9a5681ff9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441816&amp;x-signature=hX37Ha4smBSiXqrABJemw59fD4g%3D" alt="图片" loading="lazy"/></p>
<p>这是站在第二视角，那如果是站在超级名片的第一视角，也就是我的名片这里，添加这样的一个名片甚至，只需要几分钟不到。</p>
<p>说真的，我特别想和你兴奋的分享，相信很多有和我一样困惑的朋友，我们渴望被看到，渴望被更深入的了解和链接。</p>
<p>不卖关子了，这个 AI 产品叫 DINQ，网址是：<a href="https://link.juejin.cn?target=https%3A%2F%2Fdinq.me" target="_blank" title="https://dinq.me" ref="nofollow noopener noreferrer">dinq.me</a></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8a5cdeb46aa34e578d40dd724326359b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441816&amp;x-signature=H8H9gMG5i3Ys7bVH6OVe8wjVXkU%3D" alt="图片" loading="lazy"/></p>
<p>他能够一键添加非常多主流社媒平台。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3f0f67b3824c496bb6f5614cade32ebf~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441816&amp;x-signature=6sW3%2BiLsg7AoyK0GihiKbYGvfiw%3D" alt="图片" loading="lazy"/></p>
<p>只需要丢一个主页链接，AI 自动解析，然后做成卡片展示。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b27c38ca1a29445fa9e7b3060efbc44f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441816&amp;x-signature=CAR2Gvby50TeGnwhQ8P9RhKKUDg%3D" alt="图片" loading="lazy"/></p>
<p>可以灵活调整布局和展示样式，说白了就是怎么好看怎么来。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/69c72f509bb449fabc355e97b6b79e06~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441816&amp;x-signature=XXjGI47Bo7y5%2BAzt01cd38zBN48%3D" alt="图片" loading="lazy"/></p>
<p>同时如果是手机上打开，效果也会自适应调整变为竖版展示卡片。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c866791c8a15426b802117691f45395c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441816&amp;x-signature=fk2kSEmBUoALJbfsxSJDtqqMmQs%3D" alt="图片" loading="lazy"/></p>
<p>我们也可以直接分享喜欢的风格样式，分享链接或者码或者图片的方式。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/098e9756eb264db59d71736b8a3c263e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441816&amp;x-signature=nbqyGgrbb3TNwjGrn5RTkJGbWqI%3D" alt="图片" loading="lazy"/></p>
<p>最骚的是，DINQ 居然内置了一个 AI 找人的功能，就是左侧这个「Discover」：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/36cb6793c6674bc2a81e6b87e286601e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441816&amp;x-signature=0bDAza5uoArb8mSxO3TE2zIl%2BJI%3D" alt="图片" loading="lazy"/></p>
<p>可以寻找全球范围的人才或者是在 DINQ 的 follows。</p>
<p>我一开始让他找马斯克，他说马斯克过于出名没必要找了，意思是找了也没用，你小子想干啥，找点你想要的吧。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7d3aae1b0d664795977ef4ac6a929720~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441816&amp;x-signature=fpL2rbPK3cnZwv0%2BMb0QkhRhTXE%3D" alt="图片" loading="lazy"/></p>
<p>然后我就去找了下 xAI 的 AI 研究人员，不是，真给我找了好多 AI 研究人员？</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d64c2144ff31447f97369a54bf8ca86b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441816&amp;x-signature=yLcJbdhEhC1jGLE5fGq3EPipCSU%3D" alt="图片" loading="lazy"/></p>
<p>还直接给了 GitHub 访问链接，我一点，好家伙，还真有此人。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8576a8b289044c18a110da6933264697~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441816&amp;x-signature=O0y4fPwjI9sJmzBSuf4ly4PbS08%3D" alt="图片" loading="lazy"/></p>
<p>我给跪了，还能去分析他的网络关系。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e6e1037b17284cfc804be9cdbfee529b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441816&amp;x-signature=B4JEoAfNZex2B02M4phG8SpQgWE%3D" alt="图片" loading="lazy"/></p>
<p>点击去分析的时候，DINQ 居然给我了一堆这个大佬的分析报告，我当场就兴奋了，卧槽。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/79de73a876244148808eb1aac2585850~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441816&amp;x-signature=NCrzqpILBwZFuVGdDaLjn44KCIM%3D" alt="图片" loading="lazy"/></p>
<p>然后还提供了一些能联系到大佬的办法：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c5eca410b5414d98b6dc633dce875aa7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441816&amp;x-signature=8Rr0ijPSJIkaV%2F%2BnAz1nqCEON1E%3D" alt="图片" loading="lazy"/></p>
<p>太牛了，我真的有被这个产品整的很兴奋。</p>
<p>然后我脑子里突然有了一个邪恶的想法，我决定去搜下苍何，搜下我自己。</p>
<p>完美，能搜到：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b91109fdb6754fb2b77372890d7d24c8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441816&amp;x-signature=%2FOVBlcQKPOLZ%2FlWi%2BpR9XkwYOGw%3D" alt="图片" loading="lazy"/></p>
<p>然后我让 DINQ，也分析下我自己？</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b3272a9f58b847d78a554d446d5d950e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441816&amp;x-signature=BF%2BOv5canVKUiwzya8L69MB%2FHS0%3D" alt="图片" loading="lazy"/></p>
<p>他给我的 GitHub 做了一顿分析，但这个热力图，我感觉有点儿没跟上，和我实际的 GitHub 有点出入，不知道 DINQ 的技术能看到不，修 bug 了。</p>
<p>实际上我的热力图是这样的：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5e35e2026a244b7e92e91b0de2d7f4e8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441816&amp;x-signature=gCLoTfeKGZe%2FXkD8TW7Bl%2BgUKlo%3D" alt="图片" loading="lazy"/></p>
<p>我发现他优先去了 GitHub 和阿里云社区找信息源，让我一度偷偷怀疑，开发者不会是阿里同学吧？</p>
<p>不过直到现在，随着对 DINQ 的使用越多，越发现，这个产品真的有在做好很多的细节。</p>
<p>虽然我一开始就是绷着超级名片去的，没想到多出不少惊喜的功能。</p>
<p>这或许就是大佬们经常说的，性感的产品吧。</p>
<p>不多吹了，搞的和广告似的。大家自己去玩玩。</p>
<p>如果你也有这种超级名片需求，或者想找点大佬人才？不妨到 DINQ 玩玩吧，我不知道这款产品的背后是怎样一群团队。</p>
<p>我知道的是，他们真的有在用心想捕获我的心，反正以后我就逢人就推了。</p>
<p>并且我已经把 X 介绍引入了我这个 AI 超级名片：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fbf03f794c724acda36ca6aedee2c1d4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769441816&amp;x-signature=XMkZG2wg8iyhcG%2BibvgRFtp%2FeFQ%3D" alt="图片" loading="lazy"/></p>
<p>以及之后的加好友，大家应该也都能看到了。</p>
<p>好啦，今天一篇轻松的分享，希望对你有帮助，感谢你读完我的文章，我们下一期见。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[扣子发布 Coze Skills 功能，做了个抖音一键转公众号的 Skill，免费用！]]></title>    <link>https://juejin.cn/post/7596926832913104959</link>    <guid>https://juejin.cn/post/7596926832913104959</guid>    <pubDate>2026-01-19T15:42:45.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7596926832913104959" data-draft-id="7596896373053947967" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="扣子发布 Coze Skills 功能，做了个抖音一键转公众号的 Skill，免费用！"/> <meta itemprop="keywords" content="人工智能"/> <meta itemprop="datePublished" content="2026-01-19T15:42:45.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="苍何"/> <meta itemprop="url" content="https://juejin.cn/user/588993963763405"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            扣子发布 Coze Skills 功能，做了个抖音一键转公众号的 Skill，免费用！
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/588993963763405/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    苍何
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-19T15:42:45.000Z" title="Mon Jan 19 2026 15:42:45 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>这是苍何的第 473 篇原创！</p>
<p>大家好，我是在哈尔滨冰雪里写文章的苍何。</p>
<p>前阵子去扣子的闭门分享会，就有拿到 Coze Skills 的内测。</p>
<p>今天扣子也正式推出了 Skills 技能，及技能商店。我也时候给大家分享我这段期间的内测成果了😄</p>
<p>技能入口在扣子 2.0 版本的扣子编程这里就可以看到。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d47a43f7c1e84f3293454b60f2566537~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769442164&amp;x-signature=9gxRxyZpuM6UbV4MVK%2BcUhAYq9s%3D" alt="图片" loading="lazy"/></p>
<p>在扣子编程中的<strong>能够通过自然语言的方式进行方便的创建技能，支持在线调试预览开发好的技能，然后还支持一键部署和发布到扣子</strong>。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3dd9edd39ec34083aacf006135b968d2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769442164&amp;x-signature=t5fWaQVS8QO9Lf2EiAlgkxeK75Q%3D" alt="图片" loading="lazy"/></p>
<p>可以打开文件夹，看到 skill 自定义文件、脚本、引用来源等信息，可以说，这很 skill。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/95357ffdb0d3441f80d1bb5d8df541c0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769442164&amp;x-signature=0otCHconllyLYzV7sd5fRQQbilA%3D" alt="图片" loading="lazy"/></p>
<p>技能开发完成后，点击部署，在技能商店中可以看到自己刚刚部署和安装的技能，并支持一键发布到技能商店给所有人使用。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/605fbd13fdff48af95b6bd4e931fd63b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769442164&amp;x-signature=cOsXB9cnxMrfkX1KdUlujZ8wKQ4%3D" alt="图片" loading="lazy"/></p>
<p><strong>可以发布为免费技能也可以发布为付费技能</strong>，特别注意的是，发布为付费技能，扣子还直接打通了收款链路，通过技能赚钱这事，很快成为了现实。</p>
<blockquote>
<p>划重点，估计嗅觉敏略的大聪明已经开始上线一堆创作内技能然后开始赚钱了。哈哈哈，时间很重要。</p>
</blockquote>
<p>发布完后，所有人都能在技能商店使用你的技能，如果是付费的，用户可以很方便的对技能进行付费，技能开发者也能快速变现。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d09e7ba662344611949d7e268cfd8131~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769442164&amp;x-signature=oBCExROvsXhxOxVB2OjSb%2BXbDes%3D" alt="图片" loading="lazy"/></p>
<p>经过一段时间的研究和开发，我也在技能商店上架了 2 个技能，分别是<strong>抖音爆款视频一键解析</strong>和<strong>抖音爆款视频一键转公众号文章</strong>。在技能商店中可以直接搜索：抖音。</p>
<p>其中一个技能是<strong>抖音视频解析技能</strong>，这是一个抖音视频多维度数据提取的技能，支持从抖音链接中一键获取视频标题、完整文案、无水印视频地址、高清封面、音频文件等核心数据智能内容分析。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/430f7c2538854dbd9e34d8fc02538d8e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769442164&amp;x-signature=y4cTC2jDeT13k4aQ8DJG0RgnfuE%3D" alt="图片" loading="lazy"/></p>
<p>还能自动提取视频中的金句、热点标签和关键信息点结构化输出，生成包含内容分析、数据说明和提取结果的 Markdown 文档。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/94e3c60d76aa4c06a3c6ce1b1ece9ae1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769442164&amp;x-signature=9xeRJALaxGOvzjWXwCU4iPSnscM%3D" alt="图片" loading="lazy"/></p>
<p>当你需要解析抖音视频的具体内容、提取无水印素材、或对视频文案进行二次创作时，即可使用该技能。只需提供抖音视频链接，工具会自动完成所有提取和分析工作。</p>
<p>使用的话也很简单，先打开扣子：coze.cn，先在技能商店中找到该技能安装，然后直接@，找到对应的技能，丢一个视频的链接过来就可使用。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fcaa609194054f5b83b41f04b03f3739~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769442164&amp;x-signature=X20o1cYJ0Twcymj8fhDBZKQoWes%3D" alt="图片" loading="lazy"/></p>
<p>悄咪咪的点一下回车，就会开始启动技能，然后一顿输出，就可以提取视频元数据信息，可以说非常全面。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7830b61de3394010b437391b55104e02~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769442164&amp;x-signature=kw4FUqLZnW3PryLTHvy6A495Wjw%3D" alt="图片" loading="lazy"/></p>
<p>包括视频的逐字稿也能一键提取，还是非常方便的。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2039fc0673754427afd70f81108c676a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769442164&amp;x-signature=YbGows8YfCIByCA1xMmcSkr9464%3D" alt="图片" loading="lazy"/></p>
<p>第二个技能是第一个技能的升级款，可以将<strong>抖音爆款视频一键转公众号文章</strong>，支持自定义风格文章，让创作变得更丝滑。</p>
<p>同样@抖音爆款一键转公众号，或者在技能商店中找到该技能，然后点击使用。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ba723fc93f4d4b3ead37a18f00defe06~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769442164&amp;x-signature=o0nI9zkwGEdxHtUExG44KkpnWGc%3D" alt="图片" loading="lazy"/></p>
<p>该技能先会去解析视频，然后创建公众号文章，我录了个视频，大家可以感受一下。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3ec8c79c6688495c8e02ca592c64178a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769442164&amp;x-signature=AOk3LIECm0qz3X5j1%2BtHr6d8Eic%3D" alt="wxv_4346639535682715651" loading="lazy"/></p>
<p>标题、封面、内容都能直接一键产出。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/20c1a6ac29484d5687e1d13687f0407e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769442164&amp;x-signature=OEQ4e2P2L6wHalAFGJiR4MFW60Q%3D" alt="图片" loading="lazy"/></p>
<p>内容侧，也完全根据爆款视频节奏来安排，还可以用户自定义文风，类型等主题。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/58a73d8ad6e445f59d9b9a563e6186e5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769442164&amp;x-signature=POhUyvnAZb9sU0P%2BKsKJHXuBFyQ%3D" alt="图片" loading="lazy"/></p>
<p>是不是感觉还挺 nice，这样一个技能就能直接给用户使用，减少了一些重复的工作，这是 skill 带来的便利。</p>
<p>下面也给大家分享下如何在扣子编程里面创建一个专属于自己的 skill。</p>
<p><strong>第一步，打开扣子编程：</strong></p>
<p>地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fcode.coze.cn" target="_blank" title="https://code.coze.cn" ref="nofollow noopener noreferrer">code.coze.cn</a></p>
<p>然后打开技能 tab，输入你的需求：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7b72325e9e2e435a99c726bf4d0f61ed~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769442164&amp;x-signature=W%2B8KZ6Qk9JzEVOWPkKlLvzSW5R8%3D" alt="图片" loading="lazy"/></p>
<p>如果你的技能需要调用第三方 API，你需要先整理好 API 文档，然后丢给扣子，会比你单纯描述需求会更好一些。</p>
<p>API 文档也完全可以用 AI 来帮助你写，丢一个文档地址或者截图，让 AI 输出，这才是 AI Native 开发。😄</p>
<p>左侧描述修改需求，右侧进行调试测试效果。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9890c3c11c754559a403527e6387a9fd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769442164&amp;x-signature=xJzq9H4l4jl7LZ7I7A5RKGO3Btk%3D" alt="图片" loading="lazy"/></p>
<p>可以通过对话的方式把需求描述清楚，让 AI 帮助你完成技能的开发，这个我感觉像是扣子编程里面内置了一个开发 skill 的 skill，就很方便。</p>
<p>如果你想检查或者修改 skill 的代码及文件，也可以点击直接在编辑器里面进行修改。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1642ec6d41b34ecba4e42be3d4c7d22c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769442164&amp;x-signature=%2BtxDJoE3lieFmIRGA9QAo1QcgdU%3D" alt="图片" loading="lazy"/></p>
<p>当然，点击+，也能看到非常多的开发工具可以直接使用，比如版本控制、环境变量。</p>
<p><strong>第二步，部署。</strong></p>
<p>开发调试没问题后，可以点击右上角部署。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/23e0ec2aa7294879beb278a5a13266d9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769442164&amp;x-signature=MoJ93HG5HvtvPWbCfG8ZifbPQRE%3D" alt="图片" loading="lazy"/></p>
<p>也可以查看部署历史和日志分析。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b673e8c06aea42b08dcd6bfb2a310c00~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769442164&amp;x-signature=c5WBhPGkhH9OhFrKMal70Fe5SEM%3D" alt="图片" loading="lazy"/></p>
<p><strong>第三步，使用技能。</strong></p>
<p>技能部署好之后，就可以去扣子里面使用这个技能，方法就是@这个技能，或者技能商店找到刚才部署的技能。</p>
<p>扣子地址：space.coze.cn</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/172997bcf9624f8998a5f7f319b423ab~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769442164&amp;x-signature=jNGlA5AwkT%2BKr3ZzUphgy%2B4JzAQ%3D" alt="图片" loading="lazy"/></p>
<p>里面也可以调用很多的办公实用技能工具包，比如 PPT、视频、写作等。</p>
<p>然后描述具体需求，就能痛快的使用该技能了。</p>
<p>Skills 还是太火了，这几天参加 AIGCLink 开发者大会，都在谈论的话题就是 Skills。</p>
<p>而扣子也第一时间，支持了 Skills 的无代码开发以及技能商店。</p>
<p>不得不说大厂还是快啊，打通了技能的生产、使用、变现的全链路，这对 Agent 和技能开发者来说，是个非常大的机会。</p>
<p>我记得扣子是 23 年成立的，到今天也两年多了，当前，据我理解可以说是中国最大的 Agent 开发平台了。</p>
<p>后面去年底的时候推出了扣子编程，能一句话创作智能体、工作流及应用，可以说更适合普通用户了。</p>
<p>真实业务场景里，哪有那么多标准答案？每个行业都有自己秘而不宣的 SOP 和最佳实践。我看大家现在的玩法真是五花八门：做电商分析的、搞内容自动化的、甚至用来辅助写代码的……现在的破局点在于【技能】和【技能市场】。你可以把那些摸爬滚打换来的经验，直接封装成一个「技能」。往市场上一挂，你的经验可能正是别人的刚需；同样，你遇到的难题，或许别人早就有了现成的解法。这其实就是把各行各业的 Know-how 变成了可复用的组件。新人一键加载老员工的「经验包」，起手就是专家水平，这才是技术该有的样子。</p>
<p>这或许是 Skills 最大的价值，或许也会扣子最想做的事情吧。</p>
<p>好啦，感谢你喜欢我的文章，我们下一期见。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[万字长文！搞懂机器学习中的概率图模型]]></title>    <link>https://juejin.cn/post/7596919439019311113</link>    <guid>https://juejin.cn/post/7596919439019311113</guid>    <pubDate>2026-01-19T15:46:35.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7596919439019311113" data-draft-id="7596904122865664051" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="万字长文！搞懂机器学习中的概率图模型"/> <meta itemprop="keywords" content="面试,算法"/> <meta itemprop="datePublished" content="2026-01-19T15:46:35.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="aicoting"/> <meta itemprop="url" content="https://juejin.cn/user/933911964427818"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            万字长文！搞懂机器学习中的概率图模型
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/933911964427818/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    aicoting
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-19T15:46:35.000Z" title="Mon Jan 19 2026 15:46:35 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>推荐直接网站在线阅读：<a href="https://link.juejin.cn?target=https%3A%2F%2Faicoting.cn%2F" target="_blank" title="https://aicoting.cn/" ref="nofollow noopener noreferrer">aicoting.cn</a></p>
</blockquote>
<p>概率图模型（Probabilistic Graphical Models, PGM）是一类结合概率论与图论的强大工具，用于描述多个随机变量之间的依赖关系。它通过图结构将复杂的联合概率分布分解为局部条件概率分布，使得对高维数据建模和推断变得可行且高效。</p>
<p>根据图的类型，PGM 可分为有向图模型（如贝叶斯网络）和无向图模型（如马尔可夫随机场）。贝叶斯网络利用有向无环图表示变量之间的因果关系，适合建模因果推断和序列数据；马尔可夫随机场则通过无向图捕捉变量之间的联合约束，更适合处理对称依赖或空间关系。</p>
<p>概率图模型广泛应用于自然语言处理、计算机视觉、基因组学和推荐系统等领域，能够实现推断、学习和预测等多种任务，为复杂系统提供可解释的概率表示。</p>
<h2 data-id="heading-0">高斯混合模型</h2>
<p>高斯混合模型（Gaussian Mixture Model, GMM）是一种重要的概率图模型，用于对数据进行聚类和密度估计。GMM 假设数据来自若干个高斯分布的线性组合，每个高斯分布称为一个“分量”，模型通过估计各个分量的均值、方差以及混合权重来刻画整个数据分布。</p>
<p>与 K-means 等硬聚类方法不同，GMM 是软聚类方法，每个样本属于每个簇的概率可以不同，更加灵活地刻画数据的连续性和重叠结构。</p>
<p>高斯混合模型在金融风控、语音识别、图像分割以及异常检测等场景中应用广泛。例如，在图像分割中，每个像素的颜色可以建模为若干高斯分布，通过 GMM 可以将图像自动分割为不同区域。在异常检测中，GMM 可以对正常数据建模，当新样本的概率很低时被判定为异常。</p>
<h3 data-id="heading-1">模型原理</h3>
<p>假设观测数据为 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>=</mo><mo stretchy="false">{</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">X = \{x_1, x_2, ..., x_n\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"/><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mopen">{</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span><span class="mclose">}</span></span></span></span></span>，GMM 假设每个数据点由 K 个高斯分布中的一个生成。数学表达式为：<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>K</mi></msubsup><msub><mi>π</mi><mi>k</mi></msub><mi mathvariant="script">N</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mi mathvariant="normal">∣</mi><msub><mi>μ</mi><mi>k</mi></msub><mo separator="true">,</mo><msub><mi mathvariant="normal">Σ</mi><mi>k</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p(x_i) = \sum_{k=1}^{K} \pi_k \mathcal{N}(x_i|\mu_k, \Sigma_k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:1.2809em;vertical-align:-0.2997em;"/><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9812em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span/></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span><span class="mord mathcal" style="margin-right:0.14736em;">N</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
<p>其中：</p>
<ul>
<li><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">\pi_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"/><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span></span></span></span></span>为第 k 个高斯分布的混合权重，满足</li>
<li><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">N</mi><mo stretchy="false">(</mo><mi>x</mi><mi mathvariant="normal">∣</mi><msub><mi>μ</mi><mi>k</mi></msub><mo separator="true">,</mo><msub><mi mathvariant="normal">Σ</mi><mi>k</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{N}(x|\mu_k, \Sigma_k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mord mathcal" style="margin-right:0.14736em;">N</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>是均值为 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>μ</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">\mu_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"/><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span></span></span></span></span>、协方差矩阵为 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">Σ</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">\Sigma_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"/><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span></span></span></span></span>的高斯分布</li>
</ul>
<p>GMM 的目标是通过最大化观测数据的似然函数来估计参数<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><msub><mi>π</mi><mi>k</mi></msub><mo separator="true">,</mo><msub><mi>μ</mi><mi>k</mi></msub><mo separator="true">,</mo><msub><mi mathvariant="normal">Σ</mi><mi>k</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{\pi_k, \mu_k, \Sigma_k\} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mopen">{</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span><span class="mclose">}</span></span></span></span></span>。由于直接最大化似然函数困难，通常使用 期望最大化算法（EM） 来迭代求解。</p>
<h3 data-id="heading-2">EM 算法流程</h3>
<p>EM 算法通过两个步骤交替进行，直至参数收敛：</p>
<ol>
<li>初始化：随机初始化每个高斯分布的均值 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>μ</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">\mu_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"/><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span></span></span></span></span>、协方差 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">Σ</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">\Sigma_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"/><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span></span></span></span></span> 和混合权重 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">\pi_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"/><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span></span></span></span></span> 。</li>
<li>E 步（Expectation）：计算每个样本属于每个分量的后验概率（责任度）：
<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>γ</mi><mrow><mi>i</mi><mi>k</mi></mrow></msub><mo>=</mo><mfrac><mrow><msub><mi>π</mi><mi>k</mi></msub><mi mathvariant="script">N</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mi mathvariant="normal">∣</mi><msub><mi>μ</mi><mi>k</mi></msub><mo separator="true">,</mo><msub><mi mathvariant="normal">Σ</mi><mi>k</mi></msub><mo stretchy="false">)</mo></mrow><mrow><msubsup><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>K</mi></msubsup><msub><mi>π</mi><mi>j</mi></msub><mi mathvariant="script">N</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mi mathvariant="normal">∣</mi><msub><mi>μ</mi><mi>j</mi></msub><mo separator="true">,</mo><msub><mi mathvariant="normal">Σ</mi><mi>j</mi></msub><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\gamma_{ik} = \frac{\pi_k \mathcal{N}(x_i|\mu_k, \Sigma_k)}{\sum_{j=1}^K \pi_j \mathcal{N}(x_i|\mu_j, \Sigma_j)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"/><span class="mord"><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0556em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">ik</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:1.7619em;vertical-align:-0.7519em;"/><span class="mord"><span class="mopen nulldelimiter"/><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.5703em;"><span class="pstrut" style="height:3em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mop mtight"><span class="mop op-symbol small-op mtight" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8852em;"><span style="top:-2.1786em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"/><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-2.8971em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"/><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4603em;"><span/></span></span></span></span></span><span class="mspace mtight" style="margin-right:0.1952em;"/><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:-0.0359em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"/><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2819em;"><span/></span></span></span></span></span><span class="mord mathcal mtight" style="margin-right:0.14736em;">N</span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"/><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span/></span></span></span></span></span><span class="mord mtight">∣</span><span class="mord mtight"><span class="mord mathnormal mtight">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"/><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2819em;"><span/></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mtight">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"/><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2819em;"><span/></span></span></span></span></span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"/><span class="frac-line" style="border-bottom-width:0.04em;"/></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3488em;margin-left:-0.0359em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"/><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1512em;"><span/></span></span></span></span></span><span class="mord mathcal mtight" style="margin-right:0.14736em;">N</span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"/><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span/></span></span></span></span></span><span class="mord mtight">∣</span><span class="mord mtight"><span class="mord mathnormal mtight">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3488em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"/><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1512em;"><span/></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mtight">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3488em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"/><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1512em;"><span/></span></span></span></span></span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span/></span></span></span></span><span class="mclose nulldelimiter"/></span></span></span></span></span></li>
<li>M 步（Maximization）：根据责任度更新参数：</li>
</ol>
<div class="math math-display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>μ</mi><mi>k</mi></msub><mo>=</mo><mfrac><mrow><munder><mo>∑</mo><mi>i</mi></munder><msub><mi>γ</mi><mrow><mi>i</mi><mi>k</mi></mrow></msub><msub><mi>x</mi><mi>i</mi></msub></mrow><mrow><munder><mo>∑</mo><mi>i</mi></munder><msub><mi>γ</mi><mrow><mi>i</mi><mi>k</mi></mrow></msub></mrow></mfrac><mo separator="true">,</mo><mspace width="1em"/><msub><mi mathvariant="normal">Σ</mi><mi>k</mi></msub><mo>=</mo><mfrac><mrow><munder><mo>∑</mo><mi>i</mi></munder><msub><mi>γ</mi><mrow><mi>i</mi><mi>k</mi></mrow></msub><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><msub><mi>μ</mi><mi>k</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><msub><mi>μ</mi><mi>k</mi></msub><msup><mo stretchy="false">)</mo><mi>T</mi></msup></mrow><mrow><munder><mo>∑</mo><mi>i</mi></munder><msub><mi>γ</mi><mrow><mi>i</mi><mi>k</mi></mrow></msub></mrow></mfrac><mo separator="true">,</mo><mspace width="1em"/><msub><mi>π</mi><mi>k</mi></msub><mo>=</mo><mfrac><mrow><munder><mo>∑</mo><mi>i</mi></munder><msub><mi>γ</mi><mrow><mi>i</mi><mi>k</mi></mrow></msub></mrow><mi>n</mi></mfrac></mrow><annotation encoding="application/x-tex">\mu_k = \frac{\sum_i \gamma_{ik} x_i}{\sum_i \gamma_{ik}}, \quad \Sigma_k = \frac{\sum_i \gamma_{ik} (x_i - \mu_k)(x_i - \mu_k)^T}{\sum_i \gamma_{ik}}, \quad \pi_k = \frac{\sum_i \gamma_{ik}}{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"/><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:2.4254em;vertical-align:-0.9857em;"/><span class="mord"><span class="mopen nulldelimiter"/><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.4397em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"/><span class="mord"><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.162em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span/></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord"><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0556em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">ik</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"/><span class="frac-line" style="border-bottom-width:0.04em;"/></span><span style="top:-3.6897em;"><span class="pstrut" style="height:3em;"/><span class="mord"><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.162em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span/></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord"><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0556em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">ik</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9857em;"><span/></span></span></span></span><span class="mclose nulldelimiter"/></span><span class="mpunct">,</span><span class="mspace" style="margin-right:1em;"/><span class="mspace" style="margin-right:0.1667em;"/><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:2.5168em;vertical-align:-0.9857em;"/><span class="mord"><span class="mopen nulldelimiter"/><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.531em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"/><span class="mord"><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.162em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span/></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord"><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0556em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">ik</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"/><span class="frac-line" style="border-bottom-width:0.04em;"/></span><span style="top:-3.6897em;"><span class="pstrut" style="height:3em;"/><span class="mord"><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.162em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span/></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord"><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0556em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">ik</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"/><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"/><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span><span class="mclose">)</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"/><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"/><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9857em;"><span/></span></span></span></span><span class="mclose nulldelimiter"/></span><span class="mpunct">,</span><span class="mspace" style="margin-right:1em;"/><span class="mspace" style="margin-right:0.1667em;"/><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:2.1257em;vertical-align:-0.686em;"/><span class="mord"><span class="mopen nulldelimiter"/><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.4397em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"/><span class="mord"><span class="mord mathnormal">n</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"/><span class="frac-line" style="border-bottom-width:0.04em;"/></span><span style="top:-3.6897em;"><span class="pstrut" style="height:3em;"/><span class="mord"><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.162em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span/></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord"><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0556em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">ik</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span/></span></span></span></span><span class="mclose nulldelimiter"/></span></span></span></span></span></div>
<ol start="5">
<li>迭代：重复 E 步和 M 步，直到似然函数收敛或达到最大迭代次数。</li>
</ol>
<p>下面使用 Scikit-learn 对 Iris 数据集进行 GMM 聚类示例：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> sklearn.datasets <span class="hljs-keyword">import</span> load_iris
<span class="hljs-keyword">from</span> sklearn.mixture <span class="hljs-keyword">import</span> GaussianMixture
<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt

<span class="hljs-comment"># 加载数据</span>
iris = load_iris()
X = iris.data
y = iris.target

<span class="hljs-comment"># 定义 GMM 模型</span>
gmm = GaussianMixture(n_components=<span class="hljs-number">3</span>, covariance_type=<span class="hljs-string">'full'</span>, random_state=<span class="hljs-number">42</span>)
gmm.fit(X)
labels = gmm.predict(X)

<span class="hljs-comment"># 可视化前两维</span>
plt.figure(figsize=(<span class="hljs-number">8</span>,<span class="hljs-number">6</span>))
plt.scatter(X[:,<span class="hljs-number">0</span>], X[:,<span class="hljs-number">1</span>], c=labels, cmap=<span class="hljs-string">'viridis'</span>, s=<span class="hljs-number">40</span>)
plt.xlabel(<span class="hljs-string">"Feature 1"</span>)
plt.ylabel(<span class="hljs-string">"Feature 2"</span>)
plt.title(<span class="hljs-string">"GMM Clustering of Iris Dataset"</span>)
plt.show()
</code></pre>
<p>在结果中，不同颜色表示样本被分配到不同的高斯分量，GMM 能够捕捉簇的概率结构，并允许簇之间存在重叠。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ddc2995ef5ed4937b0425b3c3305c55a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgYWljb3Rpbmc=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769442395&amp;x-signature=1lZZZ04ww0KJW5GyxuQ%2FaxCAZ7g%3D" alt="" loading="lazy"/></p>
<p>由上面的内容来看，高斯混合模型是一种灵活的软聚类方法和概率密度建模工具，通过将数据表示为若干高斯分布的混合，实现对数据的连续建模。与 K-means 相比，GMM 能更好地处理簇形状不规则、簇间重叠的情况。它广泛应用于聚类、图像分割、异常检测、语音识别等领域。</p>
<p>通过合理选择分量数量和协方差类型，GMM 可以在实际问题中提供高精度的聚类和密度估计能力。</p>
<h2 data-id="heading-3">隐马尔可夫模型</h2>
<p>隐马尔可夫模型（Hidden Markov Model, HMM） 是一种经典的概率图模型，用于建模含有隐含状态的序列数据。它假设观测序列是由一组不可直接观察的隐藏状态生成的，而隐藏状态之间满足马尔可夫性（当前状态只依赖于前一个状态）。HMM 在自然语言处理、语音识别、基因序列分析、行为预测等领域都有广泛应用，能够有效处理时间序列或序列依赖数据。</p>
<p>在 HMM 中，每个隐藏状态会以一定概率生成观测值，因此 HMM 不仅可以对序列进行建模，还可以进行序列预测、状态解码以及参数估计。与 GMM 等静态概率模型不同，HMM 显式考虑了数据的时序特性，能捕捉动态演化规律。</p>
<h3 data-id="heading-4">模型定义</h3>
<p>一个 HMM 通常由以下三部分组成：</p>
<ol>
<li>状态集<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>=</mo><mo stretchy="false">{</mo><msub><mi>s</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>s</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>s</mi><mi>N</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">S = \{s_1, s_2, ..., s_N\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"/><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mopen">{</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span><span class="mclose">}</span></span></span></span></span> ：表示模型的隐藏状态，总数为 N。</li>
<li>观测集<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo>=</mo><mo stretchy="false">{</mo><msub><mi>o</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>o</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>o</mi><mi>M</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">O = \{o_1, o_2, ..., o_M\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"/><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mopen">{</span><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span><span class="mclose">}</span></span></span></span></span> ：表示可观测的符号或特征，总数为 M。</li>
<li>参数集：</li>
</ol>
<ul>
<li>
<p>状态转移概率矩阵<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mo stretchy="false">[</mo><msub><mi>a</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">A = [a_{ij}] </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"/><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"/><span class="mopen">[</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span/></span></span></span></span></span><span class="mclose">]</span></span></span></span></span>，其中<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><mi>P</mi><mo stretchy="false">(</mo><msub><mi>s</mi><mi>j</mi></msub><mo>∣</mo><msub><mi>s</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a_{ij} = P(s_j \mid s_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"/><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span/></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"/><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span/></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
</li>
<li>
<p>观测概率矩阵<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>=</mo><mo stretchy="false">[</mo><msub><mi>b</mi><mrow><mi>j</mi><mi>k</mi></mrow></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">B = [b_{jk}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"/><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"/><span class="mopen">[</span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">jk</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span/></span></span></span></span></span><span class="mclose">]</span></span></span></span></span> ，其中<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mrow><mi>j</mi><mi>k</mi></mrow></msub><mo>=</mo><mi>P</mi><mo stretchy="false">(</mo><msub><mi>o</mi><mi>k</mi></msub><mo>∣</mo><msub><mi>s</mi><mi>j</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">b_{jk} = P(o_k \mid s_j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9805em;vertical-align:-0.2861em;"/><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">jk</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span/></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"/><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span/></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
</li>
<li>
<p>初始状态概率向量<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi><mo>=</mo><mo stretchy="false">[</mo><msub><mi>π</mi><mi>i</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\pi = [\pi_i] </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"/><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span><span class="mclose">]</span></span></span></span></span>，其中<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mi>i</mi></msub><mo>=</mo><mi>P</mi><mo stretchy="false">(</mo><msub><mi>s</mi><mi>i</mi></msub><mtext> at time </mtext><mi>t</mi><mo>=</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_i = P(s_i \text{ at time } t=1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"/><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span><span class="mord text"><span class="mord"> at time </span></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></p>
</li>
</ul>
<p>HMM 的核心目标是通过观测序列<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>o</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>o</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>o</mi><mi>T</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O = (o_1, o_2, ..., o_T)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"/><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
<p>来解决三个典型问题：</p>
<ol>
<li>评估问题：给定模型参数，计算观测序列的概率 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>O</mi><mi mathvariant="normal">∣</mi><mi>λ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(O|\lambda)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mord">∣</span><span class="mord mathnormal">λ</span><span class="mclose">)</span></span></span></span></span>。</li>
<li>解码问题：给定观测序列，找到最可能的隐藏状态序列（常用 Viterbi 算法）。</li>
<li>学习问题：给定观测序列，估计模型参数 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo separator="true">,</mo><mi>π</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(A, B, \pi)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mclose">)</span></span></span></span></span>（常用 Baum-Welch/EM 算法）。</li>
</ol>
<h3 data-id="heading-5">算法流程</h3>
<p>以最常用的 Baum-Welch 算法（EM 算法的一种）为例，HMM 的训练流程如下：</p>
<ol>
<li>初始化：随机初始化状态转移矩阵 A、观测概率矩阵 B 和初始状态概率<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"/><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span></span> 。</li>
<li>E 步（Expectation）：计算前向概率 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"/><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span></span>和后向概率<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"/><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span></span> ，用于估计每个时间点的状态概率。</li>
<li>M 步（Maximization）：根据前向后向概率更新 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo separator="true">,</mo><mi>π</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(A, B, \pi)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mclose">)</span></span></span></span></span>参数，使观测序列的似然概率最大化。</li>
<li>迭代：重复 E 步和 M 步，直到模型收敛或达到最大迭代次数。</li>
</ol>
<p>对于状态解码问题，常用 Viterbi 算法，通过动态规划求解最可能的隐藏状态序列。</p>
<p>下面使用 hmmlearn 库对一个简单的离散序列进行 HMM 建模和预测：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">from</span> hmmlearn <span class="hljs-keyword">import</span> hmm

<span class="hljs-comment"># 假设观测值 0,1,2（离散类别），隐藏状态 0,1</span>
obs = np.array([[<span class="hljs-number">0</span>],[<span class="hljs-number">1</span>],[<span class="hljs-number">0</span>],[<span class="hljs-number">2</span>],[<span class="hljs-number">1</span>],[<span class="hljs-number">0</span>],[<span class="hljs-number">2</span>],[<span class="hljs-number">1</span>]])  <span class="hljs-comment"># 注意列向量</span>

<span class="hljs-comment"># 定义 HMM，禁止自动初始化</span>
model = hmm.MultinomialHMM(n_components=<span class="hljs-number">2</span>, n_iter=<span class="hljs-number">100</span>, random_state=<span class="hljs-number">42</span>, init_params=<span class="hljs-string">""</span>)

<span class="hljs-comment"># 手动设置参数</span>
model.startprob_ = np.array([<span class="hljs-number">0.6</span>, <span class="hljs-number">0.4</span>])
model.transmat_ = np.array([[<span class="hljs-number">0.7</span>, <span class="hljs-number">0.3</span>],
                            [<span class="hljs-number">0.4</span>, <span class="hljs-number">0.6</span>]])

<span class="hljs-comment"># emissionprob_ 形状必须是 (n_components, n_features)</span>
<span class="hljs-comment"># n_features = 3，因为观测值 0,1,2 共 3 类</span>
model.emissionprob_ = np.array([[<span class="hljs-number">0.5</span>, <span class="hljs-number">0.4</span>, <span class="hljs-number">0.1</span>],
                                [<span class="hljs-number">0.1</span>, <span class="hljs-number">0.3</span>, <span class="hljs-number">0.6</span>]])

<span class="hljs-comment"># 训练 HMM</span>
model.fit(obs)

<span class="hljs-comment"># 解码隐藏状态序列</span>
hidden_states = model.predict(obs)
<span class="hljs-built_in">print</span>(<span class="hljs-string">"隐藏状态序列:"</span>, hidden_states)
</code></pre>
<p>在这个示例中，HMM 对观测序列进行了建模，并预测了最可能的隐藏状态序列。</p>
<p>HMM 的时序建模能力使其在多个领域表现出色：</p>
<ul>
<li>语音识别：将语音信号序列映射到音素或文字序列。</li>
<li>自然语言处理：词性标注、命名实体识别等序列标注任务。</li>
<li>生物信息学：基因序列分析、蛋白质二级结构预测。</li>
<li>行为预测与异常检测：对时间序列数据进行模式发现和异常识别。</li>
</ul>
<p>简单总结一下HMM，HMM 是一种经典的序列概率模型，通过隐藏状态和观测概率描述序列数据的生成机制。与静态概率模型（如 GMM）不同，HMM 显式考虑时序依赖和马尔可夫性，能够捕捉动态演化规律。</p>
<p>通过合理设计状态数和初始化参数，HMM 可以在语音、文本、生物序列及行为数据等领域提供强大的建模能力。</p>
<h2 data-id="heading-6">贝叶斯网络</h2>
<p>贝叶斯网络（Bayesian Network, BN） 是一种基于概率的图模型，用于表示变量之间的条件依赖关系。它由一个有向无环图（Directed Acyclic Graph, DAG）和与节点对应的条件概率表（Conditional Probability Table, CPT）组成。节点代表随机变量，边表示变量之间的依赖关系，而 CPT 则量化了这种依赖关系的强度。</p>
<p>贝叶斯网络能够处理不确定性、推理复杂系统、进行因果分析，并广泛应用于医疗诊断、故障检测、自然语言处理、风险评估等领域。与其他概率模型不同，贝叶斯网络显式地表示变量之间的条件依赖与独立性，使得复杂的联合概率分布能够分解为局部概率分布的乘积，从而大幅降低计算复杂度。</p>
<h3 data-id="heading-7">模型定义</h3>
<p>一个贝叶斯网络通常由两部分组成：</p>
<ol>
<li>结构（DAG）</li>
</ol>
<ul>
<li>节点<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>X</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>X</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">X_1, X_2, ..., X_n </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"/><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span></span></span></span></span>表示随机变量</li>
<li>有向边<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub><mo>→</mo><msub><mi>X</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">X_i \to X_j </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"/><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"/><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span/></span></span></span></span></span></span></span></span></span>表示<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">X_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"/><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span/></span></span></span></span></span></span></span></span></span> 的概率分布依赖于<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">X_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"/><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span></span></span></span></span></li>
<li>图中不允许环路（无环性保证了概率计算的正确性）</li>
</ul>
<ol start="2">
<li>参数（CPT）</li>
</ol>
<ul>
<li>每个节点<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">X_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"/><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span></span></span></span></span>  都有条件概率表P(X_i \mid \text{Parents}(X_i))</li>
<li>若节点没有父节点，则为边缘概率<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><msub><mi>X</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(X_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></li>
<li>联合概率分布可分解为各节点条件概率的乘积：<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><msub><mi>X</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>X</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>X</mi><mi>n</mi></msub><mo stretchy="false">)</mo><mo>=</mo><msubsup><mo>∏</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mi>P</mi><mo stretchy="false">(</mo><msub><mi>X</mi><mi>i</mi></msub><mo>∣</mo><mtext>Parents</mtext><mo stretchy="false">(</mo><msub><mi>X</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(X_1, X_2, ..., X_n) = \prod_{i=1}^{n} P(X_i \mid \text{Parents}(X_i))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:1.104em;vertical-align:-0.2997em;"/><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∏</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8043em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span/></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mord text"><span class="mord">Parents</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span><span class="mclose">))</span></span></span></span></span></li>
</ul>
<h3 data-id="heading-8">核心特点</h3>
<p>贝叶斯网络的核心特点：</p>
<ul>
<li>表达条件独立性：通过 DAG 的结构，能够清晰地表示哪些变量是条件独立的，从而减少计算复杂度。</li>
<li>因果建模能力：可以用于描述因果关系而不仅仅是相关性。</li>
<li>灵活的概率推理：可以进行边缘化、条件推理和后验推断。</li>
</ul>
<p>优点：</p>
<ul>
<li>模型可解释性强</li>
<li>能处理不完整数据</li>
<li>可进行推理和决策支持</li>
</ul>
<p>缺点：</p>
<ul>
<li>学习 DAG 结构复杂（尤其是变量多时）</li>
<li>CPT 随父节点数量增加呈指数增长</li>
<li>对连续变量需要离散化或假设特定分布</li>
</ul>
<h3 data-id="heading-9">学习与推理</h3>
<p>贝叶斯网络涉及两类核心任务：</p>
<ol>
<li>结构学习</li>
</ol>
<ul>
<li>从数据中学习网络结构</li>
<li>常用方法：贪心搜索、约束方法、得分函数（如 BIC, AIC）</li>
</ul>
<ol start="2">
<li>参数学习</li>
</ol>
<ul>
<li>给定 DAG，学习 CPT</li>
<li>可使用极大似然估计（MLE）或贝叶斯估计</li>
</ul>
<ol start="3">
<li>推理（Inference）</li>
</ol>
<ul>
<li>给定部分变量的观测值，计算其他变量的后验分布</li>
<li>方法：精确推理（变量消元、信念传播）和近似推理（蒙特卡洛采样、Gibbs 采样）</li>
</ul>
<p>下面用 pgmpy 对一个简单的贝叶斯网络建模、参数学习和推理：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-keyword">from</span> pgmpy.models <span class="hljs-keyword">import</span> BayesianModel
<span class="hljs-keyword">from</span> pgmpy.estimators <span class="hljs-keyword">import</span> MaximumLikelihoodEstimator
<span class="hljs-keyword">from</span> pgmpy.inference <span class="hljs-keyword">import</span> VariableElimination

<span class="hljs-comment"># 定义网络结构</span>
model = BayesianModel([(<span class="hljs-string">'Rain'</span>, <span class="hljs-string">'Traffic'</span>), (<span class="hljs-string">'Accident'</span>, <span class="hljs-string">'Traffic'</span>)])

<span class="hljs-comment"># 构造数据</span>
data = pd.DataFrame({
    <span class="hljs-string">'Rain'</span>: [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>],
    <span class="hljs-string">'Accident'</span>: [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],
    <span class="hljs-string">'Traffic'</span>: [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]
})

<span class="hljs-comment"># 参数学习</span>
model.fit(data, estimator=MaximumLikelihoodEstimator)

<span class="hljs-comment"># 推理</span>
infer = VariableElimination(model)
posterior = infer.query(variables=[<span class="hljs-string">'Traffic'</span>], evidence={<span class="hljs-string">'Rain'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'Accident'</span>: <span class="hljs-number">0</span>})
<span class="hljs-built_in">print</span>(posterior)
</code></pre>
<p>在这个示例中：</p>
<ul>
<li>Rain 和 Accident 是 Traffic 的父节点</li>
<li>学习 CPT 后可以基于观测推断 Traffic 的概率 运行结果如下：</li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/915b3f6f4a8b4174a9aa0b64231aa6b7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgYWljb3Rpbmc=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769442395&amp;x-signature=7GQFEWBZo6uInb2Q0TJomNy%2BipY%3D" alt="" loading="lazy"/></p>
<p>贝叶斯网络是一种强大的概率图模型，通过 DAG 表示变量之间的条件依赖关系，能够高效地进行联合概率建模和推理。它特别适合处理复杂系统的因果分析和不确定性建模。</p>
<p>最新的文章都在公众号aicoting更新，别忘记关注哦！！！</p>
<p>📚 推荐阅读</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwMTcyOTcyOQ%3D%3D%26mid%3D2247485782%26idx%3D1%26sn%3D060c8222b47cbf903fbfded1f0421bcf%26scene%3D21%23wechat_redirect" target="_blank" title="https://mp.weixin.qq.com/s?__biz=MzkwMTcyOTcyOQ==&amp;mid=2247485782&amp;idx=1&amp;sn=060c8222b47cbf903fbfded1f0421bcf&amp;scene=21#wechat_redirect" ref="nofollow noopener noreferrer">机器学习之数据预处理篇！</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwMTcyOTcyOQ%3D%3D%26mid%3D2247485800%26idx%3D1%26sn%3Da52107c9dc7071d8530a24563861fa46%26scene%3D21%23wechat_redirect" target="_blank" title="https://mp.weixin.qq.com/s?__biz=MzkwMTcyOTcyOQ==&amp;mid=2247485800&amp;idx=1&amp;sn=a52107c9dc7071d8530a24563861fa46&amp;scene=21#wechat_redirect" ref="nofollow noopener noreferrer">机器学习特征工程中的特征选择</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwMTcyOTcyOQ%3D%3D%26mid%3D2247485808%26idx%3D1%26sn%3D2c57081d4b12433f6b8919209e2e52ed%26scene%3D21%23wechat_redirect" target="_blank" title="https://mp.weixin.qq.com/s?__biz=MzkwMTcyOTcyOQ==&amp;mid=2247485808&amp;idx=1&amp;sn=2c57081d4b12433f6b8919209e2e52ed&amp;scene=21#wechat_redirect" ref="nofollow noopener noreferrer">机器学习中的特征构造</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwMTcyOTcyOQ%3D%3D%26mid%3D2247485820%26idx%3D1%26sn%3Dadcb41fd14347f2f1431709323fa253f%26scene%3D21%23wechat_redirect" target="_blank" title="https://mp.weixin.qq.com/s?__biz=MzkwMTcyOTcyOQ==&amp;mid=2247485820&amp;idx=1&amp;sn=adcb41fd14347f2f1431709323fa253f&amp;scene=21#wechat_redirect" ref="nofollow noopener noreferrer">机器学习之特征降维</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwMTcyOTcyOQ%3D%3D%26mid%3D2247485941%26idx%3D1%26sn%3Dcb53a98bacd1cfbd3255bbeeab6a24ec%26scene%3D21%23wechat_redirect" target="_blank" title="https://mp.weixin.qq.com/s?__biz=MzkwMTcyOTcyOQ==&amp;mid=2247485941&amp;idx=1&amp;sn=cb53a98bacd1cfbd3255bbeeab6a24ec&amp;scene=21#wechat_redirect" ref="nofollow noopener noreferrer">一文搞懂层次聚类和密度聚类方法！</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwMTcyOTcyOQ%3D%3D%26mid%3D2247485946%26idx%3D1%26sn%3Da5cf50a4a3bda9785fb0c7baae3a6bb2%26scene%3D21%23wechat_redirect" target="_blank" title="https://mp.weixin.qq.com/s?__biz=MzkwMTcyOTcyOQ==&amp;mid=2247485946&amp;idx=1&amp;sn=a5cf50a4a3bda9785fb0c7baae3a6bb2&amp;scene=21#wechat_redirect" ref="nofollow noopener noreferrer">一文搞懂机器学习中的PCA主成分分析！</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwMTcyOTcyOQ%3D%3D%26mid%3D2247485952%26idx%3D1%26sn%3Dffe1fca4cb75b2f99ace92593554837c%26scene%3D21%23wechat_redirect" target="_blank" title="https://mp.weixin.qq.com/s?__biz=MzkwMTcyOTcyOQ==&amp;mid=2247485952&amp;idx=1&amp;sn=ffe1fca4cb75b2f99ace92593554837c&amp;scene=21#wechat_redirect" ref="nofollow noopener noreferrer">机器学习中独立成分分析ICA和主成分分析PCA有什么区别？</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwMTcyOTcyOQ%3D%3D%26mid%3D2247485960%26idx%3D1%26sn%3D05cf98957ea11dcd6ae165588b4c91c7%26scene%3D21%23wechat_redirect" target="_blank" title="https://mp.weixin.qq.com/s?__biz=MzkwMTcyOTcyOQ==&amp;mid=2247485960&amp;idx=1&amp;sn=05cf98957ea11dcd6ae165588b4c91c7&amp;scene=21#wechat_redirect" ref="nofollow noopener noreferrer">一文搞懂t-SNE和UMAP降维方法！</a></p>
<p>作者：aicoting</p>
<p>分享是一种信仰，连接让成长更有温度。</p>
<p>我们下次不见不散！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[《实时渲染》第2章-图形渲染管线-2.2应用程序阶段]]></title>    <link>https://juejin.cn/post/7596869784538710016</link>    <guid>https://juejin.cn/post/7596869784538710016</guid>    <pubDate>2026-01-19T14:08:09.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7596869784538710016" data-draft-id="7596932640726269987" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="《实时渲染》第2章-图形渲染管线-2.2应用程序阶段"/> <meta itemprop="keywords" content="计算机图形学"/> <meta itemprop="datePublished" content="2026-01-19T14:08:09.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="charlee44"/> <meta itemprop="url" content="https://juejin.cn/user/1117549770846872"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            《实时渲染》第2章-图形渲染管线-2.2应用程序阶段
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1117549770846872/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    charlee44
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-19T14:08:09.000Z" title="Mon Jan 19 2026 14:08:09 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读2分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">实时渲染</h2>
<h3 data-id="heading-1">2. 图形渲染管线</h3>
<h4 data-id="heading-2">2.2 应用程序阶段</h4>
<p>开发人员可以完全控制应用程序阶段发生的事情，因为它通常在CPU上执行。因此，开发人员可以完全决定其实现，然后对其进行修改以提高性能。此处的更改也会影响后续阶段的性能。例如，应用程序阶段算法或设置可以减少要渲染的三角形数量。</p>
<p>综上所述，一些应用程序工作可以由GPU执行，使用称为计算着色器的单独模式。此模式将GPU视为高度并行的通用处理器，忽略其专门用于渲染图形的特殊功能。</p>
<p>在应用程序阶段结束时，要渲染的几何图形被馈送到几何图形处理阶段。这些是渲染图元，即点、线和三角形，它们最终可能会出现在屏幕上（或正在使用的任何输出设备）。这是应用阶段最重要的任务。</p>
<p>该阶段基于软件实现的结果是它没有被划分为子阶段，几何处理、光栅化和像素处理阶段也是如此<sup><a href="#user-content-fn-1" id="user-content-user-content-fnref-1" data-footnote-ref="" aria-describedby="footnote-label" title="#user-content-fn-1">1</a></sup>。但是，为了提高性能，此阶段通常在多个处理器内核上并行执行。在CPU设计中，这被称为超标量构造，因为它能够在同一阶段同时执行多个进程。<a href="https://link.juejin.cn?target=%25E7%25AC%25AC18.5%25E8%258A%2582" target="_blank" title="%E7%AC%AC18.5%E8%8A%82" ref="nofollow noopener noreferrer">第18.5节</a>介绍了使用多个处理器内核的各种方法。</p>
<p>在这个阶段通常实施的一个过程是碰撞检测。在检测到两个物体之间发生碰撞后，可以生成响应并将其发送回碰撞物体以及力反馈设备。应用程序阶段也是处理来自其他来源的输入的地方，例如键盘、鼠标或头戴式显示器。根据这个输入，可以采取几种不同的动作。加速算法，例如特定的剔除算法（<a href="https://link.juejin.cn?target=%25E7%25AC%25AC19%25E7%25AB%25A0" target="_blank" title="%E7%AC%AC19%E7%AB%A0" ref="nofollow noopener noreferrer">第19章</a>），也在这里实现，以及管道的其余部分无法处理的任何其他内容。</p>
<h3 class="sr-only" id="user-content-footnote-label" data-id="heading-3">Footnotes</h3>
<ol>
<li id="user-content-user-content-fn-1">
<p>由于CPU本身的流水线规模要小得多，您可以说应用程序阶段被进一步细分为几个流水线阶段，但这在这里无关紧要。 <a href="#user-content-fnref-1" data-footnote-backref="" class="data-footnote-backref" aria-label="Back to content" title="#user-content-fnref-1">↩</a></p>
</li>
</ol>
</div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[这才是AI建模该有的样子：混元3D 1.2公测，鼠标秒变雕刻刀]]></title>    <link>https://juejin.cn/post/7596926832912826431</link>    <guid>https://juejin.cn/post/7596926832912826431</guid>    <pubDate>2026-01-19T14:12:25.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7596926832912826431" data-draft-id="7596905751110516799" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="这才是AI建模该有的样子：混元3D 1.2公测，鼠标秒变雕刻刀"/> <meta itemprop="keywords" content="AIGC"/> <meta itemprop="datePublished" content="2026-01-19T14:12:25.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="墨风如雪"/> <meta itemprop="url" content="https://juejin.cn/user/4064249017803927"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            这才是AI建模该有的样子：混元3D 1.2公测，鼠标秒变雕刻刀
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4064249017803927/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    墨风如雪
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-19T14:12:25.000Z" title="Mon Jan 19 2026 14:12:25 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>坦白说，在很长一段时间里，AI生成3D模型给我的感觉就像是在“开盲盒”。你输入一张图，AI扔给你一个模型，至于背面是不是乱作一团，或者纹理是不是把光影画死在贴图上，全看运气。对于想拿来做游戏资产或者3D打印的人来说，这种不可控性简直是噩梦。</p>
<p>但就在今天，腾讯混元3D Studio 1.2版本全量开放公测。在仔细研究了这次更新的文档并上手体验后，我感觉到风向变了：AI 3D工具正在从“让大家看个乐子”，转向“真正能干活的生产力”。</p>
<p>这次升级不需要什么邀请码，也没了排队申请的门槛，直接进官网就能用。而最让我兴奋的，是它终于把“控制权”交还给了人类。</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.worldcodeing.com%2Fwp-content%2Fuploads%2F2026%2F01%2Fasdasfd-1024x375.webp" target="_blank" title="https://blog.worldcodeing.com/wp-content/uploads/2026/01/asdasfd-1024x375.webp" ref="nofollow noopener noreferrer"><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6f3bee37dd9f4193a46a306df8cf4c31~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aKo6aOO5aaC6Zuq:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769436745&amp;x-signature=mndI%2BJKQAIemSexAeokeYbwSXqA%3D" alt="asdasfd" loading="lazy"/></a></p>
<p><strong>告别随机，指哪拆哪</strong></p>
<p>以前用AI拆分模型组件（PartGen），系统往往是自动瞎猜，经常把一只完整的胳膊强行切成两段，或者把帽子和头发粘在一起。</p>
<p>这次更新的PartGen 1.5版本，带来了一个在传统建模软件里司空见惯，但在生成式AI里却是革命性的功能：<strong>笔刷交互</strong>。</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.worldcodeing.com%2Fwp-content%2Fuploads%2F2026%2F01%2Ffsdfgdfg-1024x476.webp" target="_blank" title="https://blog.worldcodeing.com/wp-content/uploads/2026/01/fsdfgdfg-1024x476.webp" ref="nofollow noopener noreferrer"><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c41bed293955405aa78e7da8a1150985~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aKo6aOO5aaC6Zuq:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769436745&amp;x-signature=%2Fw%2FH23kN%2BNLXgzqMyZbY2V%2BbFTY%3D" alt="fsdfgdfg" loading="lazy"/></a></p>
<p>现在，你可以直接拿着鼠标当笔刷，在模型上涂抹。你觉得这个角色的护肩应该是一个独立零件，你就涂它；你觉得那个复杂的机械结构需要单独拆分，你就画出来。这种“指哪拆哪”的逻辑，直接消除了AI瞎猜带来的挫败感。</p>
<p>为了配合这种精细操作，腾讯把拆分精度的分辨率直接拉到了1536³。这个数字意味着什么？意味着模型的切口不再是锯齿状的狗啃边缘，而是平滑、干净的几何线条。这对于后续的骨骼绑定或者3D打印时的分件处理，简直是救命般的改进。</p>
<p><strong>不仅看得全，还懂什么是光</strong></p>
<p>除了拆分，底层的生成模型也升级到了混元3D 3.1。以前做AI 3D最怕什么？怕“视觉盲区”。单张图生成时，AI经常脑补不出物体的底部和顶部，导致生成的模型像个被压扁的纸盒子。</p>
<p>新版本直接支持了<strong>八视图输入</strong>。除了常规的前后左右，还加上了顶部、底部和45度角的视角。这就好比让AI绕着物体走了一圈，看清楚了所有死角再动手捏泥巴。实测下来，复杂物体的结构完整性有了质的飞跃，那些莫名其妙的凹陷和扭曲少了很多。</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.worldcodeing.com%2Fwp-content%2Fuploads%2F2026%2F01%2FiShot_2026-01-19_22.04.21-488x1024.png" target="_blank" title="https://blog.worldcodeing.com/wp-content/uploads/2026/01/iShot_2026-01-19_22.04.21-488x1024.png" ref="nofollow noopener noreferrer"><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d80c0c92541947c1875c881eb5edc883~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aKo6aOO5aaC6Zuq:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769436745&amp;x-signature=1EFLb4JF588clBaKsVBwRGGR1Ww%3D" alt="iShot_2026-01-19_22.04.21" loading="lazy"/></a></p>
<p>另一个细节是渲染管线的重构。以前的AI容易把照片里的阴影当成物体本身的颜色印在贴图上（Baked Lighting），导致模型放到其他光照环境下显得很假。新版本优化了材质推断，它开始更懂“什么是材质本色，什么是环境光影”，还原出来的纹理质感终于有了次世代游戏资产的味道。</p>
<p><strong>写在最后</strong></p>
<p>这次混元3D 1.2的更新，最大的意义不在于生成速度快了多少，而在于它开始尊重专业工作流。</p>
<p>当一个AI工具允许你用笔刷去修正它的判断，允许你提供更多视角的参考图来约束它的发挥，它就不再是一个单纯的玩具，而是一个可以辅助设计师的得力助手。</p>
<p>如果你是游戏开发者、手办模型爱好者，或者只是对3D创作好奇，现在就可以去官网试试。毕竟，在这个AI日新月异的时代，能把鼠标重新变成“雕刻刀”的感觉，真的很棒。</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.worldcodeing.com%2Fwp-content%2Fuploads%2F2026%2F01%2Fsfgghhjghj-1024x231.webp" target="_blank" title="https://blog.worldcodeing.com/wp-content/uploads/2026/01/sfgghhjghj-1024x231.webp" ref="nofollow noopener noreferrer"><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bea212a414d645d8ac97873fa5cc600c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aKo6aOO5aaC6Zuq:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769436745&amp;x-signature=Xt3LOU%2FokgKrWlpjQRyvOu%2BOC9o%3D" alt="sfgghhjghj" loading="lazy"/></a></p>
<p><strong>如果你也对最新的AI信息感兴趣或者有疑问 都可以加入我的大家庭 第一时间分享最新AI资讯、工具、教程、文档 欢迎你的加入！！！😉😉😉</strong></p>
<p>公众号：墨风如雪小站</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[C++编程从新手到高手的成长之路]]></title>    <link>https://juejin.cn/post/7596883689827352639</link>    <guid>https://juejin.cn/post/7596883689827352639</guid>    <pubDate>2026-01-19T14:57:25.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7596883689827352639" data-draft-id="7596896373053882431" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="C++编程从新手到高手的成长之路"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-01-19T14:57:25.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="码事漫谈"/> <meta itemprop="url" content="https://juejin.cn/user/1972974802965230"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            C++编程从新手到高手的成长之路
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1972974802965230/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    码事漫谈
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-19T14:57:25.000Z" title="Mon Jan 19 2026 14:57:25 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">我的C++学习之旅</h2>
<p><strong>我</strong>：最近想学C++，但是感觉好难啊！指针、内存管理、模板... 头都大了！</p>
<p><strong>C++导师</strong>：别担心，每个C++程序员都经历过这个阶段。让我带你一步步理解C++的精髓。想想看，C++就像一辆超级跑车——既能像赛车一样追求极致性能，又能提供舒适的驾驶体验。</p>
<h2 data-id="heading-1">第一章：从C到C++的思维转变</h2>
<p><strong>我</strong>：我已经会C语言了，C++和C最大的区别是什么？</p>
<p><strong>C++导师</strong>：很好的问题！C++不是"C with classes"这么简单。让我们从一个具体例子开始：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// C风格 - 你需要手动管理一切</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process_data_c_style</span><span class="hljs-params">()</span> </span>{
    FILE* file = <span class="hljs-built_in">fopen</span>(<span class="hljs-string">"data.txt"</span>, <span class="hljs-string">"r"</span>);
    <span class="hljs-keyword">if</span> (!file) {
        <span class="hljs-comment">// 错误处理...</span>
        <span class="hljs-keyword">return</span>;
    }
    
    <span class="hljs-type">char</span>* buffer = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">1024</span>);
    <span class="hljs-keyword">if</span> (!buffer) {
        <span class="hljs-built_in">fclose</span>(file);
        <span class="hljs-keyword">return</span>;
    }
    
    <span class="hljs-comment">// 使用buffer...</span>
    
    <span class="hljs-built_in">free</span>(buffer);
    <span class="hljs-built_in">fclose</span>(file);  <span class="hljs-comment">// 容易忘记！</span>
}

<span class="hljs-comment">// C++风格 - 让对象帮你管理资源</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process_data_cpp_style</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-function">std::ifstream <span class="hljs-title">file</span><span class="hljs-params">(<span class="hljs-string">"data.txt"</span>)</span></span>;
    <span class="hljs-keyword">if</span> (!file) {
        <span class="hljs-comment">// 更优雅的错误处理</span>
        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">"无法打开文件"</span>);
    }
    
    std::string buffer;
    buffer.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">1024</span>);
    
    <span class="hljs-comment">// 使用buffer... 当函数结束时，file和buffer自动清理</span>
}
</code></pre>
<p><strong>我</strong>：哇，第二个版本确实更简洁！这就是RAII吗？</p>
<p><strong>C++导师</strong>：没错！RAII（Resource Acquisition Is Initialization）是C++的核心哲学。资源在对象构造时获取，在对象析构时释放。这避免了资源泄漏。</p>
<h2 data-id="heading-2">第二章：现代C++的语法糖</h2>
<p><strong>我</strong>：我听说C++11之后有很多新特性，真的有必要学吗？</p>
<p><strong>C++导师</strong>：绝对有必要！现代C++让编程更安全、更高效。看这个例子：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// 传统C++（C++98）</span>
std::vector&lt;<span class="hljs-type">int</span>&gt;::iterator it;
<span class="hljs-keyword">for</span> (it = vec.<span class="hljs-built_in">begin</span>(); it != vec.<span class="hljs-built_in">end</span>(); ++it) {
    std::cout &lt;&lt; *it &lt;&lt; std::endl;
}

<span class="hljs-comment">// 现代C++（C++11起）</span>
<span class="hljs-comment">// 1. auto类型推导</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = vec.<span class="hljs-built_in">begin</span>(); it != vec.<span class="hljs-built_in">end</span>(); ++it) {
    std::cout &lt;&lt; *it &lt;&lt; std::endl;
}

<span class="hljs-comment">// 2. 范围for循环</span>
<span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; value : vec) {
    std::cout &lt;&lt; value &lt;&lt; std::endl;
}

<span class="hljs-comment">// 3. 配合lambda表达式</span>
std::for_each(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">int</span> value) {
    std::cout &lt;&lt; value &lt;&lt; std::endl;
});
</code></pre>
<p><strong>我</strong>：auto关键字看起来很实用，但会不会让代码可读性变差？</p>
<p><strong>C++导师</strong>：好问题！合理使用auto：</p>
<ul>
<li>✅ 用在明显的地方：<code>auto it = container.begin();</code></li>
<li>✅ 配合模板编程</li>
<li>❌ 不要用在基本类型上：<code>auto x = 5;</code> 不如 <code>int x = 5;</code> 清晰</li>
</ul>
<h2 data-id="heading-3">第三章：面向对象 vs 现代范式</h2>
<p><strong>我</strong>：我该把所有东西都写成类吗？</p>
<p><strong>C++导师</strong>：不一定！现代C++鼓励多范式编程。看看不同场景：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// 场景1：需要状态管理的复杂对象 - 适合OOP</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">SmartSocket</span> {
<span class="hljs-keyword">private</span>:
    <span class="hljs-type">int</span> socket_fd;
    <span class="hljs-type">bool</span> connected;
    
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">SmartSocket</span>(<span class="hljs-type">const</span> std::string&amp; address) {
        <span class="hljs-comment">// 建立连接</span>
        connected = <span class="hljs-literal">true</span>;
    }
    
    ~<span class="hljs-built_in">SmartSocket</span>() {
        <span class="hljs-keyword">if</span> (connected) {
            <span class="hljs-comment">// 自动关闭连接</span>
        }
    }
    
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">send</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; data)</span> </span>{
        <span class="hljs-comment">// 发送数据</span>
    }
};

<span class="hljs-comment">// 场景2：纯计算函数 - 适合函数式风格</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">auto</span> <span class="hljs-title">calculate_statistics</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;T&gt;&amp; data)</span> </span>{
    <span class="hljs-keyword">if</span> (data.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_tuple</span>(T{}, T{}, T{});
    
    <span class="hljs-keyword">auto</span> sum = std::<span class="hljs-built_in">accumulate</span>(data.<span class="hljs-built_in">begin</span>(), data.<span class="hljs-built_in">end</span>(), T{});
    <span class="hljs-keyword">auto</span> mean = sum / data.<span class="hljs-built_in">size</span>();
    
    <span class="hljs-comment">// 使用lambda和算法</span>
    <span class="hljs-keyword">auto</span> squared_diff = [mean](T acc, T x) {
        <span class="hljs-keyword">return</span> acc + (x - mean) * (x - mean);
    };
    
    <span class="hljs-keyword">auto</span> variance = std::<span class="hljs-built_in">accumulate</span>(data.<span class="hljs-built_in">begin</span>(), data.<span class="hljs-built_in">end</span>(), T{}, squared_diff) 
                    / data.<span class="hljs-built_in">size</span>();
    
    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_tuple</span>(mean, variance, std::<span class="hljs-built_in">sqrt</span>(variance));
}

<span class="hljs-comment">// 场景3：配置选项 - 适合结构化绑定（C++17）</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">AppConfig</span> {
    std::string host;
    <span class="hljs-type">int</span> port;
    <span class="hljs-type">bool</span> debug_mode;
};

<span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">load_config</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> AppConfig{<span class="hljs-string">"localhost"</span>, <span class="hljs-number">8080</span>, <span class="hljs-literal">true</span>};
}

<span class="hljs-comment">// 使用结构化绑定</span>
<span class="hljs-keyword">auto</span> [host, port, debug] = <span class="hljs-built_in">load_config</span>();
</code></pre>
<h2 data-id="heading-4">第四章：内存管理的艺术</h2>
<p><strong>我</strong>：指针和智能指针，我该用哪个？</p>
<p><strong>C++导师</strong>：简单规则：优先使用智能指针，只在必要时用原始指针。</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// ❌ 危险的旧方式</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">risky_function</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-type">int</span>* ptr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">100</span>];
    <span class="hljs-comment">// ... 如果这里抛出异常，内存泄漏！</span>
    <span class="hljs-keyword">delete</span>[] ptr;
}

<span class="hljs-comment">// ✅ 现代方式</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">safe_function</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// 1. 独占所有权用 unique_ptr</span>
    <span class="hljs-keyword">auto</span> unique_data = std::<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">int</span>[]&gt;(<span class="hljs-number">100</span>);
    
    <span class="hljs-comment">// 2. 共享所有权用 shared_ptr</span>
    <span class="hljs-keyword">auto</span> shared_data = std::make_shared&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt;(<span class="hljs-number">100</span>);
    
    <span class="hljs-comment">// 3. 观察而不拥有用 weak_ptr</span>
    std::weak_ptr&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt; observer = shared_data;
    
    <span class="hljs-comment">// 4. 需要原始指针时（如C接口）</span>
    <span class="hljs-built_in">some_c_api</span>(unique_data.<span class="hljs-built_in">get</span>());  <span class="hljs-comment">// get()获得原始指针但不转移所有权</span>
}

<span class="hljs-comment">// 自定义资源的RAII包装</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">AutoReleaser</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">AutoReleaser</span><span class="hljs-params">(T* ptr)</span> : ptr_(ptr) {</span>}
    ~<span class="hljs-built_in">AutoReleaser</span>() { 
        <span class="hljs-keyword">if</span> (ptr_) ptr_-&gt;<span class="hljs-built_in">Release</span>(); 
    }
    
    <span class="hljs-comment">// 禁止拷贝</span>
    <span class="hljs-built_in">AutoReleaser</span>(<span class="hljs-type">const</span> AutoReleaser&amp;) = <span class="hljs-keyword">delete</span>;
    AutoReleaser&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> AutoReleaser&amp;) = <span class="hljs-keyword">delete</span>;
    
    <span class="hljs-comment">// 允许移动</span>
    <span class="hljs-built_in">AutoReleaser</span>(AutoReleaser&amp;&amp; other) <span class="hljs-keyword">noexcept</span> : <span class="hljs-built_in">ptr_</span>(other.ptr_) {
        other.ptr_ = <span class="hljs-literal">nullptr</span>;
    }
    
    <span class="hljs-function">T* <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> ptr_; }
    T* <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-type">const</span> { <span class="hljs-keyword">return</span> ptr_; }
    
<span class="hljs-keyword">private</span>:
    T* ptr_;
};
</code></pre>
<h2 data-id="heading-5">第五章：模板与泛型编程</h2>
<p><strong>我</strong>：模板看起来像黑魔法！</p>
<p><strong>C++导师</strong>：模板确实强大，但理解后并不神秘。关键是：模板是编译期的多态。</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// 1. 基础模板</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
T <span class="hljs-title">max</span><span class="hljs-params">(T a, T b)</span> </span>{
    <span class="hljs-keyword">return</span> (a &gt; b) ? a : b;
}

<span class="hljs-comment">// 2. 模板特化</span>
<span class="hljs-keyword">template</span>&lt;&gt;
<span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-built_in">max</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt;(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* a, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* b) {
    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">strcmp</span>(a, b) &gt; <span class="hljs-number">0</span>) ? a : b;
}

<span class="hljs-comment">// 3. 变参模板（C++11）</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Args&gt;
<span class="hljs-type">void</span> <span class="hljs-title">log</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* format, Args... args)</span> </span>{
    <span class="hljs-built_in">printf</span>(format, args...);
}

<span class="hljs-comment">// 4. 概念约束（C++20）- 让模板更安全</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">concept</span> Addable = <span class="hljs-built_in">requires</span>(T a, T b) {
    { a + b } -&gt; std::same_as&lt;T&gt;;
};

<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;Addable T&gt;
T <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;T&gt;&amp; values)</span> </span>{
    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">accumulate</span>(values.<span class="hljs-built_in">begin</span>(), values.<span class="hljs-built_in">end</span>(), T{});
}

<span class="hljs-comment">// 使用</span>
<span class="hljs-keyword">auto</span> result1 = <span class="hljs-built_in">sum</span>(std::vector&lt;<span class="hljs-type">int</span>&gt;{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>});      <span class="hljs-comment">// ✅ 编译</span>
<span class="hljs-comment">// auto result2 = sum(std::vector&lt;std::string&gt;{"a", "b"}); // ❌ 编译错误：string不满足Addable</span>
</code></pre>
<h2 data-id="heading-6">第六章：实战：构建一个小项目</h2>
<p><strong>我</strong>：能给我一个完整的例子吗？</p>
<p><strong>C++导师</strong>：当然！这是一个简单的线程安全的消息队列：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadSafeQueue</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(T value)</span> </span>{
        {
            <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;
            queue_.<span class="hljs-built_in">push</span>(std::<span class="hljs-built_in">move</span>(value));
        }
        condition_.<span class="hljs-built_in">notify_one</span>();
    }
    
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">try_pop</span><span class="hljs-params">(T&amp; value)</span> </span>{
        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;
        <span class="hljs-keyword">if</span> (queue_.<span class="hljs-built_in">empty</span>()) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
        value = std::<span class="hljs-built_in">move</span>(queue_.<span class="hljs-built_in">front</span>());
        queue_.<span class="hljs-built_in">pop</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
    
    <span class="hljs-function">T <span class="hljs-title">wait_and_pop</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;
        condition_.<span class="hljs-built_in">wait</span>(lock, [<span class="hljs-keyword">this</span>] { <span class="hljs-keyword">return</span> !queue_.<span class="hljs-built_in">empty</span>(); });
        
        T value = std::<span class="hljs-built_in">move</span>(queue_.<span class="hljs-built_in">front</span>());
        queue_.<span class="hljs-built_in">pop</span>();
        <span class="hljs-keyword">return</span> value;
    }
    
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{
        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;
        <span class="hljs-keyword">return</span> queue_.<span class="hljs-built_in">empty</span>();
    }
    
<span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">mutable</span> std::mutex mutex_;
    std::queue&lt;T&gt; queue_;
    std::condition_variable condition_;
};

<span class="hljs-comment">// 使用示例</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    ThreadSafeQueue&lt;std::string&gt; queue;
    
    <span class="hljs-comment">// 生产者线程</span>
    <span class="hljs-function">std::thread <span class="hljs-title">producer</span><span class="hljs-params">([&amp;queue] {
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) {
            queue.push(<span class="hljs-string">"消息 "</span> + std::to_string(i));
            std::this_thread::sleep_for(std::chrono::milliseconds(<span class="hljs-number">100</span>));
        }
    })</span></span>;
    
    <span class="hljs-comment">// 消费者线程</span>
    <span class="hljs-function">std::thread <span class="hljs-title">consumer</span><span class="hljs-params">([&amp;queue] {
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) {
            <span class="hljs-keyword">auto</span> msg = queue.wait_and_pop();
            std::cout &lt;&lt; <span class="hljs-string">"收到: "</span> &lt;&lt; msg &lt;&lt; std::endl;
        }
    })</span></span>;
    
    producer.<span class="hljs-built_in">join</span>();
    consumer.<span class="hljs-built_in">join</span>();
    
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<h2 data-id="heading-7">结语：成为C++高手的建议</h2>
<p><strong>我</strong>：最后有什么建议吗？</p>
<p><strong>C++导师</strong>：</p>
<ol>
<li><strong>从基础开始</strong>：理解指针、内存布局、编译链接过程</li>
<li><strong>拥抱现代C++</strong>：至少学习C++11/14的特性</li>
<li><strong>工具很重要</strong>：学会使用调试器、Valgrind、Clang-Tidy等工具</li>
<li><strong>阅读优秀代码</strong>：看看STL实现、开源项目</li>
<li><strong>实践出真知</strong>：多写代码，参与开源项目</li>
</ol>
<p><strong>我</strong>：最常犯的错误有哪些？</p>
<p><strong>C++导师</strong>：</p>
<ol>
<li>忘记<code>const</code>正确性</li>
<li>过度设计，过早优化</li>
<li>不理解移动语义（C++11）</li>
<li>异常安全考虑不周</li>
<li>忽视编译期计算的可能性</li>
</ol>
<p>记住，学习C++是一场马拉松，不是短跑。享受这个过程，你会逐渐体会到这门语言的强大和优雅！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[React Native之Android端Fabric 架构源码分析（上）]]></title>    <link>https://juejin.cn/post/7596869784538824704</link>    <guid>https://juejin.cn/post/7596869784538824704</guid>    <pubDate>2026-01-19T14:59:16.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7596869784538824704" data-draft-id="7594087108593254463" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="React Native之Android端Fabric 架构源码分析（上）"/> <meta itemprop="keywords" content="React Native,Android,源码阅读"/> <meta itemprop="datePublished" content="2026-01-19T14:59:16.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="编程之路从0到1"/> <meta itemprop="url" content="https://juejin.cn/user/4125023359744296"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            React Native之Android端Fabric 架构源码分析（上）
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4125023359744296/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    编程之路从0到1
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-19T14:59:16.000Z" title="Mon Jan 19 2026 14:59:16 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读18分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">React Native之Android端Fabric 架构源码分析（上）</h2>
<h3 data-id="heading-1">前言</h3>
<p>Fabric 是 React Native 新架构的 UI 渲染系统，现在我们就来深入分析其源码。</p>
<p>本文基于<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ffacebook%2Freact-native%2Ftree%2Fv0.83.0" target="_blank" title="https://github.com/facebook/react-native/tree/v0.83.0" ref="nofollow noopener noreferrer">React Native</a> 0.83版本源码进行分析。</p>
<h3 data-id="heading-2">初始化</h3>
<p>在<a href="https://juejin.cn/post/7594627998839406634" target="_blank" title="https://juejin.cn/post/7594627998839406634">《React Native新架构之Android端初始化源码分析》</a>一文已经提过Fabric的初始化部分，现在回顾一下：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"> <span class="hljs-comment">// ReactInstance.kt   </span>


    <span class="hljs-keyword">val</span> eventBeatManager = EventBeatManager()
    fabricUIManager =
        FabricUIManager(context, ViewManagerRegistry(viewManagerResolver), eventBeatManager)

    <span class="hljs-comment">// 在 Fabric 初始化之前需要完成的其他初始化操作。</span>
    DisplayMetricsHolder.initDisplayMetricsIfNotInitialized(context)

    <span class="hljs-keyword">val</span> binding = FabricUIManagerBinding()
    binding.register(
        getBufferedRuntimeExecutor(),
        getRuntimeScheduler(),
        fabricUIManager,
        eventBeatManager,
        componentFactory,
    )

    <span class="hljs-comment">// 初始化 FabricUIManager</span>
    fabricUIManager.initialize()
</code></pre>
<p>这里<strong>EventBeatManager</strong> 是 一个基于观察者模式的 Fabric 架构的 "节拍控制器"，它利用 Android 原生的帧回调机制，协调并驱动 C++ 层的事件向 JS 层高效、有序地流动。</p>
<p>现在重点看一<code>FabricUIManager</code>的构造方法做了什么<code>react-native/packages/react-native/ReactAndroid/src/main/java/com/facebook/react/fabric/FabricUIManager.java</code>：</p>
<pre><code class="hljs language-java" lang="java">  <span class="hljs-keyword">public</span> <span class="hljs-title function_">FabricUIManager</span><span class="hljs-params">(
      ReactApplicationContext reactContext,
      ViewManagerRegistry viewManagerRegistry,
      BatchEventDispatchedListener batchEventDispatchedListener)</span> {
    <span class="hljs-comment">// 初始化帧回调 </span>
    mDispatchUIFrameCallback = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DispatchUIFrameCallback</span>(reactContext);
    mReactApplicationContext = reactContext;
    <span class="hljs-comment">// 初始化挂载管理器 </span>
    mMountingManager = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MountingManager</span>(viewManagerRegistry, mMountItemExecutor);
    <span class="hljs-comment">// 初始化挂载指令调度器 </span>
    mMountItemDispatcher =
        <span class="hljs-keyword">new</span> <span class="hljs-title class_">MountItemDispatcher</span>(mMountingManager, <span class="hljs-keyword">new</span> <span class="hljs-title class_">MountItemDispatchListener</span>());
    <span class="hljs-comment">// 初始化事件分发器 </span>
    mEventDispatcher = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FabricEventDispatcher</span>(reactContext, <span class="hljs-keyword">new</span> <span class="hljs-title class_">FabricEventEmitter</span>(<span class="hljs-built_in">this</span>));
    <span class="hljs-comment">// 持有批处理事件监听器</span>
    mBatchEventDispatchedListener = batchEventDispatchedListener;
    <span class="hljs-comment">// 注册生命周期监听</span>
    mReactApplicationContext.addLifecycleEventListener(<span class="hljs-built_in">this</span>);
    <span class="hljs-comment">// 注册组件回调 </span>
    mViewManagerRegistry = viewManagerRegistry;
    mReactApplicationContext.registerComponentCallbacks(viewManagerRegistry);
  }
</code></pre>
<p>这段代码，首先创建一个派生自<code> Choreographer.FrameCallback</code>的回调，这是 Fabric 渲染的“心脏”。它会注册到 Android 的 Choreographer，在每一帧垂直同步（VSync）信号到来时被调用。它负责驱动 MountItemDispatcher 来执行挂载操作（即实际的 View 更新）。</p>
<p>随后创建了一个挂载管理器<code>MountingManager</code>，它是实际操作 Android View 的管理者（执行 createView, updateProps 等）。接着创建了挂载指令调度器<code>MountItemDispatcher</code>，它负责管理挂载指令（MountItem）的队列，决定它们是在当前线程同步执行还是推入队列等待下一帧执行。当一批指令分发完成后，它会收到回调。这主要用于通知监听器，告诉它们“UI 已经更新了，你们可以进行下一帧动画计算了”。</p>
<p>接下来又创建了事件分发器<code>FabricEventDispatcher</code>，它负责将 Android 原生事件（如 Touch, Scroll）发送给 JavaScript。它的参数<code>FabricEventEmitter</code>是一个实现了 <strong>RCTEventEmitter</strong> 接口的类，它内部持有 C++ 层的引用（通过 JNI），是 Java 事件通往 C++ Fabric 核心的入口。</p>
<p>以上这写类基本上构成了一套UI系统的核心处理。如果大家需要更深入分析React Native UI系统，那么这些类就是研究的重点。在构造方法的最后，注册了生命周期监听，这是为了让 <strong>FabricUIManager</strong> 能够感知 Activity/Host 的 <code>onResume</code>, <code>onPause</code>, <code>onDestroy</code>。尤其是在 onHostResume 时恢复 UI 挂载循环，在 onHostPause 时暂停，以节省资源并避免在后台更新 UI。</p>
<p>最后注册组件回调，主要是用于当系统内存不足时，ViewManagerRegistry 可以收到通知并释放缓存。</p>
<p>现在继续分析初始化流程<code>FabricUIManagerBinding</code>的创建，源码<code>react-native/packages/react-native/ReactAndroid/src/main/java/com/facebook/react/fabric/FabricUIManagerBinding.kt</code>：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-meta">@DoNotStrip</span>
<span class="hljs-meta">@SuppressLint(<span class="hljs-string">"MissingNativeLoadLibrary"</span>)</span>
<span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FabricUIManagerBinding</span> : <span class="hljs-type">HybridClassBase</span>() {
  <span class="hljs-keyword">init</span> {
    initHybrid()
  }

  <span class="hljs-keyword">private</span> <span class="hljs-keyword">external</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">initHybrid</span><span class="hljs-params">()</span></span>

  <span class="hljs-keyword">external</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setPixelDensity</span><span class="hljs-params">(pointScaleFactor: <span class="hljs-type">Float</span>)</span></span>

  <span class="hljs-keyword">private</span> <span class="hljs-keyword">external</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">installFabricUIManager</span><span class="hljs-params">(
      runtimeExecutor: <span class="hljs-type">RuntimeExecutor</span>,
      runtimeScheduler: <span class="hljs-type">RuntimeScheduler</span>,
      uiManager: <span class="hljs-type">FabricUIManager</span>,
      eventBeatManager: <span class="hljs-type">EventBeatManager</span>,
      componentsRegistry: <span class="hljs-type">ComponentFactory</span>,
  )</span></span>


  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">register</span><span class="hljs-params">(
      runtimeExecutor: <span class="hljs-type">RuntimeExecutor</span>,
      runtimeScheduler: <span class="hljs-type">RuntimeScheduler</span>,
      fabricUIManager: <span class="hljs-type">FabricUIManager</span>,
      eventBeatManager: <span class="hljs-type">EventBeatManager</span>,
      componentFactory: <span class="hljs-type">ComponentFactory</span>,
  )</span></span> {
    fabricUIManager.setBinding(<span class="hljs-keyword">this</span>)
    installFabricUIManager(
        runtimeExecutor,
        runtimeScheduler,
        fabricUIManager,
        eventBeatManager,
        componentFactory,
    )
    setPixelDensity(getDisplayMetricDensity())
  }

  <span class="hljs-comment">// 省略部分代码......</span>
}
</code></pre>
<p>该对象的构造，主要是调用<code>initHybrid</code>方法。关于<code>initHybrid</code>的机制，我们在前面的文章已经做了详细分析，这里就不再重复解释。</p>
<p>这里的<code>FabricUIManagerBinding</code>是 React Native Fabric 架构在 Android 端的 "核心启动器" 和 "跨语言胶水层"。它的主要作用是初始化 Fabric 的 C++ 核心组件，并建立 Java、C++ 和 JavaScript 三者之间的通信桥梁。当该对象被创建时，立即调用了其<code>register</code>方法。在这个方法中，主要是调用了<code>installFabricUIManager</code>，它将 C++ 层的 Fabric API 绑定到 JavaScript 运行时（Runtime）。这使得 JavaScript 可以直接通过 JSI 调用 C++ 接口（如 createNode, cloneNode, appendChild），实现同步且高效的 UI 操作。这里还有一个重要的操作，即<code>setPixelDensity</code>，将 Android 设备的屏幕像素密度（Density）传递给 React Native 的 C++ 核心层（Fabric/Yoga），用于统一布局单位。</p>
<p>最后，分析一下<code>FabricUIManager</code>的<code>initialize</code>做了什么事：</p>
<pre><code class="hljs language-kotlin" lang="kotlin">  <span class="hljs-keyword">public</span> void initialize() {
    <span class="hljs-comment">// 注册事件批处理监听</span>
    mEventDispatcher.addBatchEventDispatchedListener(mBatchEventDispatchedListener);

    <span class="hljs-comment">// 启用 Fabric 日志与性能监控</span>
    <span class="hljs-keyword">if</span> (ReactNativeFeatureFlags.enableFabricLogs()) {
      mDevToolsReactPerfLogger = new DevToolsReactPerfLogger();
      mDevToolsReactPerfLogger.addDevToolsReactPerfLoggerListener(FABRIC_PERF_LOGGER);

      ReactMarker.addFabricListener(mDevToolsReactPerfLogger);
    }

    <span class="hljs-comment">// 启用新旧架构互操作</span>
    <span class="hljs-keyword">if</span> (ReactNativeNewArchitectureFeatureFlags.useFabricInterop()) {
      InteropEventEmitter interopEventEmitter = new InteropEventEmitter(mReactApplicationContext);
      mReactApplicationContext.internal_registerInteropModule(
          RCTEventEmitter.<span class="hljs-keyword">class</span>, interopEventEmitter);
    }
  }
</code></pre>
<p>这里首先是将 <code>mBatchEventDispatchedListener</code>（即 EventBeatManager）注册到事件分发器中。这是 “心跳” 连接的关键一步。当 Android 原生事件（如 Touch）被成批分发时，会通知 EventBeatManager，进而触发 C++ 层的 tick()，驱动 Fabric 渲染管线刷新。没有这一步，JavaScript 可能永远收不到事件更新。</p>
<p>接下来是性能监控相关的处理，开启需依赖<code>enableFabricLogs</code>的值，这是排查 Fabric 性能问题（如掉帧、白屏）和调试渲染流程的“开关”。</p>
<p>最后是启用新旧架构互操作的处理，这是 React Native 平滑迁移到新架构的重要兼容层，确保老代码在新架构下也能工作。</p>
<h4 data-id="heading-3">C++层</h4>
<p>以上<code>FabricUIManagerBinding</code>提供了很多Native方法，我们在此重点分析一下<code>installFabricUIManager</code>。源码<code>react-native/packages/react-native/ReactAndroid/src/main/jni/react/fabric/FabricUIManagerBinding.cpp</code>：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FabricUIManagerBinding::installFabricUIManager</span><span class="hljs-params">(
    jni::alias_ref&lt;JRuntimeExecutor::javaobject&gt; runtimeExecutorHolder,
    jni::alias_ref&lt;JRuntimeScheduler::javaobject&gt; runtimeSchedulerHolder,
    jni::alias_ref&lt;JFabricUIManager::javaobject&gt; javaUIManager,
    EventBeatManager* eventBeatManager,
    ComponentFactory* componentsRegistry)</span> </span>{
  <span class="hljs-function">TraceSection <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">"FabricUIManagerBinding::installFabricUIManager"</span>)</span></span>;

  enableFabricLogs_ = ReactNativeFeatureFlags::<span class="hljs-built_in">enableFabricLogs</span>();

  <span class="hljs-keyword">if</span> (enableFabricLogs_) {
    <span class="hljs-built_in">LOG</span>(WARNING)
        &lt;&lt; <span class="hljs-string">"FabricUIManagerBinding::installFabricUIManager() was called (address: "</span>
        &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; <span class="hljs-string">")."</span>;
  }

  <span class="hljs-function">std::unique_lock <span class="hljs-title">lock</span><span class="hljs-params">(installMutex_)</span></span>;

  <span class="hljs-comment">// 创建 C++ MountingManager (</span>
  <span class="hljs-keyword">auto</span> globalJavaUiManager = <span class="hljs-built_in">make_global</span>(javaUIManager);
  mountingManager_ =
      std::<span class="hljs-built_in">make_shared</span>&lt;FabricMountingManager&gt;(globalJavaUiManager);

  std::shared_ptr&lt;<span class="hljs-type">const</span> ContextContainer&gt; contextContainer =
      std::<span class="hljs-built_in">make_shared</span>&lt;ContextContainer&gt;();

  <span class="hljs-keyword">auto</span> runtimeExecutor = runtimeExecutorHolder-&gt;<span class="hljs-built_in">cthis</span>()-&gt;<span class="hljs-built_in">get</span>();

  <span class="hljs-keyword">auto</span> runtimeScheduler = runtimeSchedulerHolder-&gt;<span class="hljs-built_in">cthis</span>()-&gt;<span class="hljs-built_in">get</span>().<span class="hljs-built_in">lock</span>();
  <span class="hljs-comment">// 如果存在 RuntimeScheduler（通常都存在），则包装 runtimeExecutor。</span>
  <span class="hljs-comment">// 这意味着所有通过此 executor 提交的 JS 任务都会经过 RuntimeScheduler 调度，从而支持优先级和任务取消。</span>
  <span class="hljs-keyword">if</span> (runtimeScheduler) {
    runtimeExecutor =
        [runtimeScheduler](
            std::function&lt;<span class="hljs-built_in">void</span>(jsi::Runtime &amp; runtime)&gt;&amp;&amp; callback) {
          runtimeScheduler-&gt;<span class="hljs-built_in">scheduleWork</span>(std::<span class="hljs-built_in">move</span>(callback));
        };
    contextContainer-&gt;<span class="hljs-built_in">insert</span>(
        RuntimeSchedulerKey, std::<span class="hljs-built_in">weak_ptr</span>&lt;RuntimeScheduler&gt;(runtimeScheduler));
  }

  <span class="hljs-comment">// 创建 EventBeat 工厂 </span>
  EventBeat::Factory eventBeatFactory =
      [eventBeatManager, &amp;runtimeScheduler, globalJavaUiManager](
          std::shared_ptr&lt;EventBeat::OwnerBox&gt; ownerBox)
      -&gt; std::unique_ptr&lt;EventBeat&gt; {
    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_unique</span>&lt;AndroidEventBeat&gt;(
        std::<span class="hljs-built_in">move</span>(ownerBox),
        eventBeatManager,
        *runtimeScheduler,
        globalJavaUiManager);
  };

  contextContainer-&gt;<span class="hljs-built_in">insert</span>(<span class="hljs-string">"FabricUIManager"</span>, globalJavaUiManager);

  <span class="hljs-comment">// 组装 Scheduler 工具箱</span>
  <span class="hljs-keyword">auto</span> toolbox = SchedulerToolbox{};
  toolbox.contextContainer = contextContainer;
  toolbox.componentRegistryFactory = componentsRegistry-&gt;buildRegistryFunction;

  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> (T132338609) runtimeExecutor 应该在主 bundle eval 之后执行 lambda 表达式，</span>
  <span class="hljs-comment">// 而 bindingsInstallExecutor 应该在之前执行。</span>
  toolbox.bridgelessBindingsExecutor = std::<span class="hljs-literal">nullopt</span>;
  toolbox.runtimeExecutor = runtimeExecutor;

  toolbox.eventBeatFactory = eventBeatFactory;

  <span class="hljs-comment">// 启动 Fabric 核心</span>
  animationDriver_ = std::<span class="hljs-built_in">make_shared</span>&lt;LayoutAnimationDriver&gt;(
      runtimeExecutor, contextContainer, <span class="hljs-keyword">this</span>);
  scheduler_ =
      std::<span class="hljs-built_in">make_shared</span>&lt;Scheduler&gt;(toolbox, animationDriver_.<span class="hljs-built_in">get</span>(), <span class="hljs-keyword">this</span>);
}
</code></pre>
<p>这个方法是一个 "组装车间"：</p>
<ol>
<li>
<p>它接收来自 Android (Java) 的原材料（<code>UIManager</code>, <code>EventBeatManager</code>）。</p>
</li>
<li>
<p>它接收来自 JS Runtime 的驱动器（<code>RuntimeExecutor</code>）。</p>
</li>
<li>
<p>它将这些零件组装成 C++ 的核心部件（<code>MountingManager</code>, <code>AndroidEventBeat</code>）。</p>
</li>
<li>
<p>最后，它启动了 Fabric 的引擎 —— <code>Scheduler</code>。</p>
</li>
</ol>
<h4 data-id="heading-4">总结</h4>
<p>下面是对整个初始化流程的概述</p>
<pre><code class="hljs language-scss" lang="scss">ReactInstance 初始化
           │
           │
           └─► Fabric 初始化
                    │
                    ├─► ViewManagerResolver 创建 (收集 ReactPackage 中的 ViewManager)
                    │
                    ├─► ViewManagerRegistry 创建
                    │
                    ├─► FabricUIManager 创建
                    │
                    ├─► FabricUIManagerBinding 创建
                    │
                    └─► binding<span class="hljs-selector-class">.register</span>() ──► 触发 C++ 层初始化
</code></pre>
<h3 data-id="heading-5">启动渲染</h3>
<p>回顾一下Android 的初始化流程一文：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// ReactInstance.kt</span>


 <span class="hljs-comment">/**
   * 渲染一个 React Native surface.
   *
   * <span class="hljs-doctag">@param</span> surface 要渲染的 [com.facebook.react.interfaces.fabric.ReactSurface] 对象
   */</span>
  <span class="hljs-meta">@ThreadConfined(<span class="hljs-string">"ReactHost"</span>)</span>
  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">startSurface</span><span class="hljs-params">(surface: <span class="hljs-type">ReactSurfaceImpl</span>)</span></span> {
    <span class="hljs-comment">// 省略部分代码......</span>
    <span class="hljs-keyword">val</span> view = surface.view

    <span class="hljs-keyword">if</span> (surface.isRunning) {
      <span class="hljs-comment">// Surface 已经在运行（预渲染过），只需附加 View</span>
      fabricUIManager.attachRootView(surface.surfaceHandler, view)
    } <span class="hljs-keyword">else</span> {
      fabricUIManager.startSurface(surface.surfaceHandler, surface.context, view)
    }
  }
</code></pre>
<p>之前并未深入<code>fabricUIManager.startSurface</code>方法的调用，现在来分析一下：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// FabricUIManager.java</span>

  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startSurface</span><span class="hljs-params">(
      <span class="hljs-keyword">final</span> SurfaceHandlerBinding surfaceHandler,
      <span class="hljs-keyword">final</span> Context context,
      <span class="hljs-keyword">final</span> <span class="hljs-meta">@Nullable</span> View rootView)</span> {
    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">rootTag</span> <span class="hljs-operator">=</span>
        rootView <span class="hljs-keyword">instanceof</span> ReactRoot
            ? ((ReactRoot) rootView).getRootViewTag()
            : ReactRootViewTagGenerator.getNextRootViewTag();

    <span class="hljs-type">ThemedReactContext</span> <span class="hljs-variable">reactContext</span> <span class="hljs-operator">=</span>
        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThemedReactContext</span>(
            mReactApplicationContext, context, surfaceHandler.getModuleName(), rootTag);
    mMountingManager.startSurface(rootTag, reactContext, rootView);
    Assertions.assertNotNull(mBinding, <span class="hljs-string">"Binding in FabricUIManager is null"</span>);
    mBinding.startSurfaceWithSurfaceHandler(rootTag, surfaceHandler, rootView != <span class="hljs-literal">null</span>);
  }
</code></pre>
<p>此方法主要做了两件事，首先是调用<strong>MountingManager</strong>的<code>startSurface</code>启动 Surface，接着调用了<strong>FabricUIManagerBinding</strong>的Native方法<code>startSurfaceWithSurfaceHandler</code>在C++层启动 Surface。先查看<code>react-native/packages/react-native/ReactAndroid/src/main/java/com/facebook/react/fabric/mounting/MountingManager.kt</code>：</p>
<pre><code class="hljs language-kotlin" lang="kotlin">  <span class="hljs-comment">/**
    * 启动 Surface 但不附加视图。对该 Surface 执行的所有视图操作都将被排队，直到视图被附加为止。
    */</span>
  <span class="hljs-meta">@AnyThread</span>
  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">startSurface</span><span class="hljs-params">(
      surfaceId: <span class="hljs-type">Int</span>,
      reactContext: <span class="hljs-type">ThemedReactContext</span>?,
      rootView: <span class="hljs-type">View</span>?,
  )</span></span>: SurfaceMountingManager {
    <span class="hljs-comment">// 创建一个新的 SurfaceMountingManager 实例，负责管理特定 Surface 的视图挂载操作</span>
    <span class="hljs-keyword">val</span> surfaceMountingManager =
        SurfaceMountingManager(
            surfaceId,
            jsResponderHandler,  <span class="hljs-comment">// JS 响应处理器（处理触摸事件响应）</span>
            viewManagerRegistry,
            rootViewManager,
            mountItemExecutor,   <span class="hljs-comment">// 挂载项执行器</span>
            checkNotNull(reactContext),
        )

    <span class="hljs-comment">// 理论上这里可能存在竞态条件，如果 addRootView 从不同线程被调用两次，</span>
    <span class="hljs-comment">// 虽然这种情况（可能）极不可能发生，而且很可能是一个错误。</span>
    <span class="hljs-comment">// 这个防止竞态条件的逻辑是从旧代码继承而来的，我们不知道在实际中是否真的会发生</span>
    <span class="hljs-comment">// 所以，我们现在记录软异常。这在调试模式下会崩溃，但在生产环境中不会。</span>
    surfaceIdToManager.putIfAbsent(surfaceId, surfaceMountingManager)
    <span class="hljs-keyword">if</span> (surfaceIdToManager[surfaceId] !== surfaceMountingManager) {
      logSoftException(
          TAG,
          IllegalStateException(
              <span class="hljs-string">"Called startSurface more than once for the SurfaceId [<span class="hljs-variable">$surfaceId</span>]"</span>
          ),
      )
    }

    mostRecentSurfaceMountingManager = surfaceIdToManager[surfaceId]

    <span class="hljs-keyword">if</span> (rootView != <span class="hljs-literal">null</span>) {
      surfaceMountingManager.attachRootView(rootView, reactContext)
    }

    <span class="hljs-keyword">return</span> surfaceMountingManager
  }
</code></pre>
<p>此方法主要内容是创建<strong>SurfaceMountingManager</strong>，然后调用<code>attachRootView</code>方法。现在继续跟踪<code>attachRootView</code>方法，源码<code>react-native/packages/react-native/ReactAndroid/src/main/java/com/facebook/react/fabric/mounting/SurfaceMountingManager.java</code>：</p>
<pre><code class="hljs language-java" lang="java">  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attachRootView</span><span class="hljs-params">(View rootView, ThemedReactContext themedReactContext)</span> {
    mThemedReactContext = themedReactContext;
    addRootView(rootView);
  }

  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addRootView</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> <span class="hljs-keyword">final</span> View rootView)</span> {
    <span class="hljs-keyword">if</span> (isStopped()) {
      <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// 检查 Surface 是否已停止</span>
    }

    mTagToViewState.put(mSurfaceId, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ViewState</span>(mSurfaceId, rootView, mRootViewManager, <span class="hljs-literal">true</span>));

    <span class="hljs-comment">// 在 UI 线程上执行根视图设置</span>
    <span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span>
        <span class="hljs-keyword">new</span> <span class="hljs-title class_">GuardedRunnable</span>(Assertions.assertNotNull(mThemedReactContext)) {
          <span class="hljs-meta">@Override</span>
          <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">runGuarded</span><span class="hljs-params">()</span> {
            <span class="hljs-comment">// 自从调用`addRootView`以来，CPU 一直在运行，因此从理论上讲，界面可能已经在此处停止渲染了。</span>
            <span class="hljs-keyword">if</span> (isStopped()) {
              <span class="hljs-keyword">return</span>;
            }
            <span class="hljs-comment">// 省略部分日志打印......</span>

            <span class="hljs-comment">// 设置根视图 ID </span>
            rootView.setId(mSurfaceId);

            <span class="hljs-keyword">if</span> (rootView <span class="hljs-keyword">instanceof</span> ReactRoot) {
              ((ReactRoot) rootView).setRootViewTag(mSurfaceId);
            }

            executeMountItemsOnViewAttach();

            <span class="hljs-comment">// 通过在调用 `executeMountItemsOnViewAttach` 之后执行此操作，</span>
            <span class="hljs-comment">// 我们可以确保在处理此队列时安排的任何操作也会被添加到队列中，</span>
            <span class="hljs-comment">// 而不是通过 `MountItemDispatcher` 中的队列立即进行处理。</span>
            mRootViewAttached = <span class="hljs-literal">true</span>;
          }
        };

    <span class="hljs-comment">// 确保在 UI 线程执行</span>
    <span class="hljs-keyword">if</span> (UiThreadUtil.isOnUiThread()) {
      runnable.run();
    } <span class="hljs-keyword">else</span> {
      UiThreadUtil.runOnUiThread(runnable);
    }
  }
</code></pre>
<p>这里的实现核心是封装了一个<strong>Runnable</strong>，即一个任务，且这个任务必须在安卓的UI线程执行。继续跟踪<code>executeMountItemsOnViewAttach</code>方法，查看任务的内容：</p>
<pre><code class="hljs language-java" lang="java">  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Queue&lt;MountItem&gt; mOnViewAttachMountItems = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();


  <span class="hljs-meta">@UiThread</span>
  <span class="hljs-meta">@ThreadConfined(UI)</span>
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">executeMountItemsOnViewAttach</span><span class="hljs-params">()</span> {
    mMountItemExecutor.executeItems(mOnViewAttachMountItems);
  }
</code></pre>
<p>可以看到，该方法就是在调用挂载项执行器不断的执行挂载项队列。这里的挂载项执行器是在创建<strong>MountingManager</strong>时传入的，回到<code>FabricUIManager</code>源码查看实现：</p>
<pre><code class="hljs language-java" lang="java">  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MountingManager.<span class="hljs-type">MountItemExecutor</span> <span class="hljs-variable">mMountItemExecutor</span> <span class="hljs-operator">=</span>
      <span class="hljs-keyword">new</span> <span class="hljs-title class_">MountingManager</span>.MountItemExecutor() {
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">executeItems</span><span class="hljs-params">(Queue&lt;MountItem&gt; items)</span> {
          <span class="hljs-comment">// 从技术上讲，在调度程序创建之前就可以访问这个执行器，但如果真的发生这种情况，那就说明出了非常严重的问题。</span>
          mMountItemDispatcher.dispatchMountItems(items);
        }
      };
</code></pre>
<p>继续跟踪<code>react-native/packages/react-native/ReactAndroid/src/main/java/com/facebook/react/fabric/mounting/MountItemDispatcher.kt</code>中的实现：</p>
<pre><code class="hljs language-kotlin" lang="kotlin">  <span class="hljs-meta">@UiThread</span>
  <span class="hljs-meta">@ThreadConfined(UI)</span>
  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dispatchMountItems</span><span class="hljs-params">(mountItems: <span class="hljs-type">Queue</span>&lt;<span class="hljs-type">MountItem</span>?&gt;)</span></span> {
    <span class="hljs-keyword">while</span> (!mountItems.isEmpty()) {
      <span class="hljs-keyword">val</span> item = requireNotNull(mountItems.poll()) { <span class="hljs-string">"MountItem should not be null"</span> }
      <span class="hljs-keyword">try</span> {
        item.execute(mountingManager)
      } <span class="hljs-keyword">catch</span> (e: RetryableMountingLayerException) {
        <span class="hljs-comment">// 省略已弃用的逻辑......</span>
      }
    }
  }
</code></pre>
<p>此处核心逻辑是从队列取出一个 <strong>MountItem</strong>并执行它的<code>execute</code>方法。至于<strong>MountItem</strong>接口，它有许多实现类，其中最核心的是<code>IntBufferBatchMountItem</code>实现，我们可以大致浏览一下它的<code>execute</code>方法主要做些什么。源码<code>react-native/packages/react-native/ReactAndroid/src/main/java/com/facebook/react/fabric/mounting/mountitems/IntBufferBatchMountItem.kt</code>：</p>
<pre><code class="hljs language-kotlin" lang="kotlin">  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">execute</span><span class="hljs-params">(mountingManager: <span class="hljs-type">MountingManager</span>)</span></span> {
    <span class="hljs-keyword">val</span> surfaceMountingManager = mountingManager.getSurfaceManager(surfaceId)
    <span class="hljs-keyword">if</span> (surfaceMountingManager == <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">return</span>
    }
    <span class="hljs-keyword">if</span> (surfaceMountingManager.isStopped) {
      <span class="hljs-keyword">return</span>
    }
    <span class="hljs-keyword">if</span> (ReactNativeFeatureFlags.enableFabricLogs()) {
      FLog.d(TAG, <span class="hljs-string">"Executing IntBufferBatchMountItem on surface [%d]"</span>, surfaceId)
    }

    beginMarkers(<span class="hljs-string">"mountViews"</span>)
    <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>
    <span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>
    <span class="hljs-keyword">while</span> (i &lt; intBufferLen) {
      <span class="hljs-keyword">val</span> rawType = intBuffer[i++]
      <span class="hljs-keyword">val</span> type = rawType and INSTRUCTION_FLAG_MULTIPLE.inv()
      <span class="hljs-keyword">val</span> numInstructions =
          (<span class="hljs-keyword">if</span> ((rawType and INSTRUCTION_FLAG_MULTIPLE) != <span class="hljs-number">0</span>) intBuffer[i++] <span class="hljs-keyword">else</span> <span class="hljs-number">1</span>)

      <span class="hljs-keyword">val</span> args = arrayOf(<span class="hljs-string">"numInstructions"</span>, numInstructions.toString())

      <span class="hljs-keyword">for</span> (k <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> until numInstructions) {
        <span class="hljs-keyword">when</span> (type) {
          INSTRUCTION_CREATE -&gt; {    
            <span class="hljs-keyword">val</span> componentName = (objBuffer[j++] <span class="hljs-keyword">as</span> String?).orEmpty()
            <span class="hljs-keyword">val</span> fabricComponentName =
                FabricNameComponentMapping.getFabricComponentName(componentName)
            <span class="hljs-comment">// 创建视图</span>
            surfaceMountingManager.createView(
                fabricComponentName,
                intBuffer[i++],
                objBuffer[j++] <span class="hljs-keyword">as</span> ReadableMap?,
                objBuffer[j++] <span class="hljs-keyword">as</span> StateWrapper?,
                objBuffer[j++] <span class="hljs-keyword">as</span> EventEmitterWrapper?,
                intBuffer[i++] == <span class="hljs-number">1</span>,
            )
          }
          <span class="hljs-comment">// 删除视图</span>
          INSTRUCTION_DELETE -&gt; surfaceMountingManager.deleteView(intBuffer[i++]) 
          INSTRUCTION_INSERT -&gt; {
            <span class="hljs-keyword">val</span> tag = intBuffer[i++]
            <span class="hljs-keyword">val</span> parentTag = intBuffer[i++]
            <span class="hljs-comment">// 插入视图到父视图</span>
            surfaceMountingManager.addViewAt(parentTag, tag, intBuffer[i++])
          }
          <span class="hljs-comment">// 从父视图移除</span>
          INSTRUCTION_REMOVE -&gt;
              surfaceMountingManager.removeViewAt(intBuffer[i++], intBuffer[i++], intBuffer[i++])
           <span class="hljs-comment">// 更新属性</span>
          INSTRUCTION_UPDATE_PROPS -&gt;
              surfaceMountingManager.updateProps(intBuffer[i++], objBuffer[j++] <span class="hljs-keyword">as</span> ReadableMap?)
          <span class="hljs-comment">// 更新状态</span>
          INSTRUCTION_UPDATE_STATE -&gt;
              surfaceMountingManager.updateState(intBuffer[i++], objBuffer[j++] <span class="hljs-keyword">as</span> StateWrapper?)

          <span class="hljs-comment">// 更新布局</span>
          INSTRUCTION_UPDATE_LAYOUT -&gt; {
            <span class="hljs-keyword">val</span> reactTag = intBuffer[i++]
            <span class="hljs-keyword">val</span> parentTag = intBuffer[i++]
            <span class="hljs-keyword">val</span> x = intBuffer[i++]
            <span class="hljs-keyword">val</span> y = intBuffer[i++]
            <span class="hljs-keyword">val</span> width = intBuffer[i++]
            <span class="hljs-keyword">val</span> height = intBuffer[i++]
            <span class="hljs-keyword">val</span> displayType = intBuffer[i++]
            <span class="hljs-keyword">val</span> layoutDirection = intBuffer[i++]
            surfaceMountingManager.updateLayout(
                reactTag,
                parentTag,
                x,
                y,
                width,
                height,
                displayType,
                layoutDirection,
            )
          }
          <span class="hljs-comment">// 省略部分代码......</span>
          <span class="hljs-keyword">else</span> -&gt; {
            <span class="hljs-keyword">throw</span> IllegalArgumentException(
                <span class="hljs-string">"Invalid type argument to IntBufferBatchMountItem: <span class="hljs-variable">$type</span> at index: <span class="hljs-variable">$i</span>"</span>
            )
          }
        }
      }
    }
    endMarkers()
  }
</code></pre>
<p>可以看到，<code>IntBufferBatchMountItem</code>包含批量视图操作指令，它使用 int 数组和 object 数组优化性能，减少 JNI 调用，并且支持多种视图操作：创建、删除、插入、移除、更新属性/状态/布局等。</p>
<p>接下来我们跟踪一下<code>surfaceMountingManager.createView</code>的实现，源码<code>react-native/packages/react-native/ReactAndroid/src/main/java/com/facebook/react/fabric/mounting/SurfaceMountingManager.java</code>：</p>
<pre><code class="hljs language-java" lang="java"> <span class="hljs-meta">@UiThread</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createView</span><span class="hljs-params">(
      <span class="hljs-meta">@NonNull</span> String componentName,
      <span class="hljs-type">int</span> reactTag,
      <span class="hljs-meta">@Nullable</span> ReadableMap props,
      <span class="hljs-meta">@Nullable</span> StateWrapper stateWrapper,
      <span class="hljs-meta">@Nullable</span> EventEmitterWrapper eventEmitterWrapper,
      <span class="hljs-type">boolean</span> isLayoutable)</span> {
    <span class="hljs-keyword">if</span> (isStopped()) {
      <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-type">ViewState</span> <span class="hljs-variable">viewState</span> <span class="hljs-operator">=</span> getNullableViewState(reactTag);
    <span class="hljs-keyword">if</span> (viewState != <span class="hljs-literal">null</span> &amp;&amp; viewState.mView != <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">return</span>;
    }

    createViewUnsafe(
        componentName, reactTag, props, stateWrapper, eventEmitterWrapper, isLayoutable);
  }

  <span class="hljs-comment">/**
   * 执行视图创建操作，但不进行任何安全检查。您必须在调用此方法之前确保安全性（参见现有调用位置）
   */</span>
  <span class="hljs-meta">@UiThread</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createViewUnsafe</span><span class="hljs-params">(
      <span class="hljs-meta">@NonNull</span> String componentName,
      <span class="hljs-type">int</span> reactTag,
      <span class="hljs-meta">@Nullable</span> ReadableMap props,
      <span class="hljs-meta">@Nullable</span> StateWrapper stateWrapper,
      <span class="hljs-meta">@Nullable</span> EventEmitterWrapper eventEmitterWrapper,
      <span class="hljs-type">boolean</span> isLayoutable)</span> {
    Systrace.beginSection(
        Systrace.TRACE_TAG_REACT,
        <span class="hljs-string">"SurfaceMountingManager::createViewUnsafe("</span> + componentName + <span class="hljs-string">")"</span>);
    <span class="hljs-keyword">try</span> {
      <span class="hljs-type">ReactStylesDiffMap</span> <span class="hljs-variable">propMap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReactStylesDiffMap</span>(props);

      <span class="hljs-type">ViewState</span> <span class="hljs-variable">viewState</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ViewState</span>(reactTag);
      viewState.mCurrentProps = propMap;
      viewState.mStateWrapper = stateWrapper;
      viewState.mEventEmitter = eventEmitterWrapper;
      mTagToViewState.put(reactTag, viewState);

      <span class="hljs-keyword">if</span> (isLayoutable) {
        <span class="hljs-type">ViewManager</span> <span class="hljs-variable">viewManager</span> <span class="hljs-operator">=</span> mViewManagerRegistry.get(componentName);
        <span class="hljs-comment">// View Managers are responsible for dealing with inital state and props.</span>
        viewState.mView =
            viewManager.createView(
                reactTag, mThemedReactContext, propMap, stateWrapper, mJSResponderHandler);
        viewState.mViewManager = viewManager;
      }
    } <span class="hljs-keyword">finally</span> {
      Systrace.endSection(Systrace.TRACE_TAG_REACT);
    }
  }
</code></pre>
<p>这里是根据组件名通过<code>mViewManagerRegistry</code>来查找<code>ViewManager</code>。具体注册逻辑，我们在后面的<strong>注册组件</strong>一节分析。</p>
<p>继续跟踪一下<code>viewManager.createView</code>方法的实现，源码<code>react-native/packages/react-native/ReactAndroid/src/main/java/com/facebook/react/uimanager/ViewManager.java</code>：</p>
<pre><code class="hljs language-java" lang="java">  <span class="hljs-comment">/** 创建一个了解 props 和 state 的视图。 */</span>
  <span class="hljs-keyword">public</span> <span class="hljs-meta">@NonNull</span> T <span class="hljs-title function_">createView</span><span class="hljs-params">(
      <span class="hljs-type">int</span> reactTag,
      <span class="hljs-meta">@NonNull</span> ThemedReactContext reactContext,
      <span class="hljs-meta">@Nullable</span> ReactStylesDiffMap props,
      <span class="hljs-meta">@Nullable</span> StateWrapper stateWrapper,
      JSResponderHandler jsResponderHandler)</span> {
    <span class="hljs-type">T</span> <span class="hljs-variable">view</span> <span class="hljs-operator">=</span> createViewInstance(reactTag, reactContext, props, stateWrapper);
    <span class="hljs-keyword">if</span> (view <span class="hljs-keyword">instanceof</span> ReactInterceptingViewGroup) {
      ((ReactInterceptingViewGroup) view).setOnInterceptTouchEventListener(jsResponderHandler);
    }
    <span class="hljs-keyword">return</span> view;
  }

  <span class="hljs-comment">/**
   * 子类应该返回一个适当类型的新 View 实例。这是一个可选方法，它会为您调用 createViewInstance。
   * 如果您需要在创建视图时使用 props 或 state，请重写它。
   *
   * 如果您重写此方法，您*必须*确保正确处理 updateProperties、view.setId、
   * addEventEmitters 和 updateState/updateExtraData！
   *
   * <span class="hljs-doctag">@param</span> reactTag 应该设置为视图实例 ID 的 reactTag
   * <span class="hljs-doctag">@param</span> reactContext 用于初始化视图实例的 ReactContext
   * <span class="hljs-doctag">@param</span> initialProps 视图实例的初始 props
   * <span class="hljs-doctag">@param</span> stateWrapper 视图实例的初始 state
   */</span>
  <span class="hljs-keyword">protected</span> <span class="hljs-meta">@NonNull</span> T <span class="hljs-title function_">createViewInstance</span><span class="hljs-params">(
      <span class="hljs-type">int</span> reactTag,
      <span class="hljs-meta">@NonNull</span> ThemedReactContext reactContext,
      <span class="hljs-meta">@Nullable</span> ReactStylesDiffMap initialProps,
      <span class="hljs-meta">@Nullable</span> StateWrapper stateWrapper)</span> {
    <span class="hljs-type">T</span> <span class="hljs-variable">view</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;
    <span class="hljs-meta">@Nullable</span> Stack&lt;T&gt; recyclableViews = getRecyclableViewStack(reactContext.getSurfaceId(), <span class="hljs-literal">true</span>);
    <span class="hljs-keyword">if</span> (recyclableViews != <span class="hljs-literal">null</span> &amp;&amp; !recyclableViews.empty()) {
      <span class="hljs-type">T</span> <span class="hljs-variable">recyclableView</span> <span class="hljs-operator">=</span> recyclableViews.pop();

      <span class="hljs-comment">// 当视图回收未对所有组件启用时，可回收视图仍可能附加到不可回收视图。</span>
      <span class="hljs-comment">// 这保证了回收视图已从其父视图中移除。</span>
      <span class="hljs-keyword">if</span> (ReactNativeFeatureFlags.enableViewRecycling() &amp;&amp; recyclableView.getParent() != <span class="hljs-literal">null</span>) {
        ((ViewGroup) recyclableView.getParent()).removeView(recyclableView);
      }

      view = recycleView(reactContext, recyclableView);
    } <span class="hljs-keyword">else</span> {
      view = createViewInstance(reactContext);
    }
    view.setId(reactTag);
    addEventEmitters(reactContext, view);
    <span class="hljs-keyword">if</span> (initialProps != <span class="hljs-literal">null</span>) {
      updateProperties(view, initialProps);
    }
    <span class="hljs-comment">// 仅在 Fabric 架构中存在；但在 Fabric 中始终存在。</span>
    <span class="hljs-keyword">if</span> (stateWrapper != <span class="hljs-literal">null</span>) {
      <span class="hljs-type">Object</span> <span class="hljs-variable">extraData</span> <span class="hljs-operator">=</span> updateState(view, initialProps, stateWrapper);
      <span class="hljs-keyword">if</span> (extraData != <span class="hljs-literal">null</span>) {
        updateExtraData(view, extraData);
      }
    }
    <span class="hljs-keyword">return</span> view;
  }

 <span class="hljs-comment">/**
   * 子类应该返回一个适当类型的新 View 实例。
   */</span>
  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-meta">@NonNull</span> T <span class="hljs-title function_">createViewInstance</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> ThemedReactContext reactContext)</span>;

   <span class="hljs-comment">/**
   * 子类可以重写此方法以在给定 View 上安装自定义事件发射器。
   * 如果您的视图需要向 JS 发送除基本触摸事件之外的事件（例如滚动事件），
   * 您可能想要重写此方法。
   */</span>
  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addEventEmitters</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> ThemedReactContext reactContext, <span class="hljs-meta">@NonNull</span> T view)</span> {}

 <span class="hljs-comment">/**
   * 子类可以实现此方法以接收从 {<span class="hljs-doctag">@link</span> ReactShadowNode#onCollectExtraUpdates} 中
   * 相应 {<span class="hljs-doctag">@link</span> ReactShadowNode} 实例排队的可选额外数据。
   *
   * 由于 CSS 布局步骤和 UI 更新可以在设置 x/y/width/height 之外的单独线程中执行，
   * 这是从 CSS 节点向原生视图对应部分传递额外数据的推荐且线程安全的方式。
   *
   * &lt;p&gt;TODO T7247021: Replace updateExtraData with generic update props mechanism after D2086999
   */</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateExtraData</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> T view, Object extraData)</span>;

 <span class="hljs-comment">/**
   * 子类可以实现此方法以接收在此组件类型的所有实例之间共享的状态更新。
   */</span>
  <span class="hljs-keyword">public</span> <span class="hljs-meta">@Nullable</span> Object <span class="hljs-title function_">updateState</span><span class="hljs-params">(
      <span class="hljs-meta">@NonNull</span> T view, ReactStylesDiffMap props, StateWrapper stateWrapper)</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }
</code></pre>
<p>这里比较重要的是<code>createViewInstance</code>方法，子类必须重写它，用于创建自定义View。现在查看一下我们创建的自定义Fabric 组件包中自动生成的模版代码：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-meta">@ReactModule(name = CustomWebViewManager.NAME)</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomWebViewManager</span> : <span class="hljs-type">SimpleViewManager</span>&lt;<span class="hljs-type">CustomWebView</span>&gt;(),
  CustomWebViewManagerInterface&lt;CustomWebView&gt; {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> mDelegate: ViewManagerDelegate&lt;CustomWebView&gt;

  <span class="hljs-keyword">init</span> {
    mDelegate = CustomWebViewManagerDelegate(<span class="hljs-keyword">this</span>)
  }

  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getDelegate</span><span class="hljs-params">()</span></span>: ViewManagerDelegate&lt;CustomWebView&gt;? {
    <span class="hljs-keyword">return</span> mDelegate
  }

  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>: String {
    <span class="hljs-keyword">return</span> NAME
  }

  <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createViewInstance</span><span class="hljs-params">(context: <span class="hljs-type">ThemedReactContext</span>)</span></span>: CustomWebView {
    <span class="hljs-keyword">return</span> CustomWebView(context)
  }

  <span class="hljs-meta">@ReactProp(name = <span class="hljs-string">"sourceURL"</span>)</span>
  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setSourceURL</span><span class="hljs-params">(view: <span class="hljs-type">CustomWebView</span>?, sourceURL: <span class="hljs-type">String</span>?)</span></span> {
    <span class="hljs-comment">// Implement the logic to handle the sourceURL property</span>
  }

  <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> {
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> NAME = <span class="hljs-string">"CustomWebView"</span>
  }
}
</code></pre>
<p>可以看到，<code>CustomWebViewManager</code>实际上就是<code>ViewManager</code>的子孙类，其实现了<code>createViewInstance</code>方法，返回自定义的View实例。</p>
<p>这条线的跟踪已经足够深入了，关于原生UI组件的具体布局渲染就不继续了，先到此为止。</p>
<h4 data-id="heading-6">C++ 层</h4>
<p><strong>FabricUIManager</strong>的<code>startSurface</code>方法中还有一个Native方法<code>mBinding.startSurfaceWithSurfaceHandler</code>未分析，源码<code>react-native/packages/react-native/ReactAndroid/src/main/jni/react/fabric/FabricUIManagerBinding.cpp</code>：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FabricUIManagerBinding::startSurfaceWithSurfaceHandler</span><span class="hljs-params">(
    jint surfaceId,
    jni::alias_ref&lt;SurfaceHandlerBinding::jhybridobject&gt; surfaceHandlerBinding,
    jboolean isMountable)</span> </span>{

  <span class="hljs-comment">// SurfaceHandler配置 </span>
  <span class="hljs-comment">// 从JNI包装中提取C++ SurfaceHandler对象</span>
  <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; surfaceHandler =
      surfaceHandlerBinding-&gt;<span class="hljs-built_in">cthis</span>()-&gt;<span class="hljs-built_in">getSurfaceHandler</span>();
  surfaceHandler.<span class="hljs-built_in">setSurfaceId</span>(surfaceId);
  <span class="hljs-comment">// 根据是否有View设置显示模式</span>
  surfaceHandler.<span class="hljs-built_in">setDisplayMode</span>(
      isMountable != <span class="hljs-number">0</span> ? DisplayMode::Visible : DisplayMode::Suspended);

  <span class="hljs-comment">// 获取Fabric调度器</span>
  <span class="hljs-keyword">auto</span> scheduler = <span class="hljs-built_in">getScheduler</span>();
  <span class="hljs-keyword">if</span> (!scheduler) {
    <span class="hljs-built_in">LOG</span>(ERROR)
        &lt;&lt; <span class="hljs-string">"FabricUIManagerBinding::startSurfaceWithSurfaceHandler: scheduler disappeared"</span>;
    <span class="hljs-keyword">return</span>;
  }

  <span class="hljs-comment">// 将SurfaceHandler注册到调度器中。调度器负责管理渲染和布局</span>
  scheduler-&gt;<span class="hljs-built_in">registerSurface</span>(surfaceHandler);

  <span class="hljs-keyword">auto</span> mountingManager = <span class="hljs-built_in">getMountingManager</span>(<span class="hljs-string">"startSurfaceWithSurfaceHandler"</span>);
  <span class="hljs-keyword">if</span> (mountingManager != <span class="hljs-literal">nullptr</span>) {
    <span class="hljs-comment">// 通知MountingManager, Surface开始启动</span>
    <span class="hljs-comment">// MountingManager负责将C++的UI操作转换为Android原生View操作</span>
    mountingManager-&gt;<span class="hljs-built_in">onSurfaceStart</span>(surfaceId);
  }

  <span class="hljs-comment">// 启动SurfaceHandler </span>
  surfaceHandler.<span class="hljs-built_in">start</span>();

  <span class="hljs-comment">// 如果启用布局动画，设置动画驱动器</span>
  <span class="hljs-keyword">if</span> (ReactNativeFeatureFlags::<span class="hljs-built_in">enableLayoutAnimationsOnAndroid</span>()) {
    surfaceHandler.<span class="hljs-built_in">getMountingCoordinator</span>()-&gt;<span class="hljs-built_in">setMountingOverrideDelegate</span>(
        animationDriver_);
  }

  {
    <span class="hljs-function">std::unique_lock <span class="hljs-title">lock</span><span class="hljs-params">(surfaceHandlerRegistryMutex_)</span></span>;
    <span class="hljs-comment">// 将SurfaceHandler添加到注册表中，便于后续管理（停止、更新等）</span>
    surfaceHandlerRegistry_.<span class="hljs-built_in">emplace</span>(
        surfaceId, jni::<span class="hljs-built_in">make_weak</span>(surfaceHandlerBinding));
  }
}
</code></pre>
<p>这个方法是新架构Surface启动的关键桥梁，它体现了新架构的核心特点：通过<strong>JSI</strong>直接从C++调用JS。</p>
<ul>
<li>
<p>向上：接收Java层的启动请求</p>
</li>
<li>
<p>向下：触发C++层的Surface启动流程</p>
</li>
<li>
<p>横向：协调Scheduler、MountingManager等各个子系统</p>
</li>
</ul>
<p>这里重点关注一下<code>surfaceHandler.start()</code>的实现，源码<code>react-native/packages/react-native/ReactCommon/react/renderer/scheduler/SurfaceHandler.cpp</code>:</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SurfaceHandler::start</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span> </span>{
  <span class="hljs-function">std::unique_lock <span class="hljs-title">lock</span><span class="hljs-params">(linkMutex_)</span></span>;
  <span class="hljs-comment">// 省略断言......</span>

  <span class="hljs-keyword">auto</span> parameters = Parameters{};
  {
    <span class="hljs-function">std::shared_lock <span class="hljs-title">parametersLock</span><span class="hljs-params">(parametersMutex_)</span></span>;
    parameters = parameters_;
  }

  <span class="hljs-comment">// 创建ShadowTree </span>
  <span class="hljs-keyword">auto</span> shadowTree = std::<span class="hljs-built_in">make_unique</span>&lt;ShadowTree&gt;(
      parameters.surfaceId,
      parameters.layoutConstraints,
      parameters.layoutContext,
      *link_.uiManager,
      *parameters.contextContainer);

  <span class="hljs-comment">// 将ShadowTree指针保存到link_中，供后续操作使用</span>
  link_.shadowTree = shadowTree.<span class="hljs-built_in">get</span>();

  <span class="hljs-keyword">if</span> (!parameters.moduleName.<span class="hljs-built_in">empty</span>()) {
    <span class="hljs-comment">// 启动Surface</span>
    link_.uiManager-&gt;<span class="hljs-built_in">startSurface</span>(
        std::<span class="hljs-built_in">move</span>(shadowTree),
        parameters.moduleName,
        parameters.props,
        parameters_.displayMode);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// 创建空Surface，仅用于预渲染</span>
    link_.uiManager-&gt;<span class="hljs-built_in">startEmptySurface</span>(std::<span class="hljs-built_in">move</span>(shadowTree));
  }
  <span class="hljs-comment">// 将状态从Registered更新为Running</span>
  link_.status = Status::Running;
  <span class="hljs-comment">// 应用显示模式</span>
  <span class="hljs-built_in">applyDisplayMode</span>(parameters.displayMode);
}
</code></pre>
<p>此方法是Fabric架构中渲染流程的起点，负责创建ShadowTree并启动UI渲染流程。这里的<strong>ShadowTree</strong>就是Fabric中的虚拟DOM树，用于布局计算和渲染。</p>
<p>继续跟踪<code>uiManager-&gt;startSurface</code>的实现，源码<code>react-native/packages/react-native/ReactCommon/react/renderer/uimanager/UIManager.cpp</code>:</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">UIManager::startSurface</span><span class="hljs-params">(
    ShadowTree::Unique&amp;&amp; shadowTree,
    <span class="hljs-type">const</span> std::string&amp; moduleName,
    <span class="hljs-type">const</span> folly::dynamic&amp; props,
    DisplayMode displayMode)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span> </span>{
  <span class="hljs-function">TraceSection <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">"UIManager::startSurface"</span>)</span></span>;

  <span class="hljs-comment">// ShadowTree注册 </span>
  <span class="hljs-keyword">auto</span> surfaceId = shadowTree-&gt;<span class="hljs-built_in">getSurfaceId</span>();
  shadowTreeRegistry_.<span class="hljs-built_in">add</span>(std::<span class="hljs-built_in">move</span>(shadowTree));

  <span class="hljs-comment">// 委托通知</span>
  <span class="hljs-comment">// 使用访问者模式安全访问已注册的ShadowTree</span>
  shadowTreeRegistry_.<span class="hljs-built_in">visit</span>(
      surfaceId, [delegate = delegate_](<span class="hljs-type">const</span> ShadowTree&amp; shadowTree) {
        <span class="hljs-keyword">if</span> (delegate != <span class="hljs-literal">nullptr</span>) {
          <span class="hljs-comment">// 通知UIManager的委托对象Surface已启动</span>
          delegate-&gt;<span class="hljs-built_in">uiManagerDidStartSurface</span>(shadowTree);
        }
      });

  <span class="hljs-comment">// 异步调用JS层</span>
  <span class="hljs-built_in">runtimeExecutor_</span>([=](jsi::Runtime&amp; runtime) {
    TraceSection <span class="hljs-built_in">s</span>(<span class="hljs-string">"UIManager::startSurface::onRuntime"</span>);
    <span class="hljs-comment">// 在JS线程上异步执行</span>
    AppRegistryBinding::<span class="hljs-built_in">startSurface</span>(
        runtime, surfaceId, moduleName, props, displayMode);
  });
}
</code></pre>
<p>此方法是Fabric架构中连接C++渲染系统和JS应用层的关键桥梁方法，负责注册ShadowTree并触发JS应用启动。</p>
<p>继续跟踪<code>AppRegistryBinding::startSurface</code>。源码<code>react-native/packages/react-native/ReactCommon/react/renderer/uimanager/AppRegistryBinding.cpp</code>:</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">/* static */</span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AppRegistryBinding::startSurface</span><span class="hljs-params">(
    jsi::Runtime&amp; runtime,
    SurfaceId surfaceId,
    <span class="hljs-type">const</span> std::string&amp; moduleName,
    <span class="hljs-type">const</span> folly::dynamic&amp; initialProps,
    DisplayMode displayMode)</span> </span>{
  <span class="hljs-function">TraceSection <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">"AppRegistryBinding::startSurface"</span>)</span></span>;

  <span class="hljs-comment">// 构建参数对象</span>
  <span class="hljs-function">jsi::Object <span class="hljs-title">parameters</span><span class="hljs-params">(runtime)</span></span>;
  parameters.<span class="hljs-built_in">setProperty</span>(runtime, <span class="hljs-string">"rootTag"</span>, surfaceId);
  parameters.<span class="hljs-built_in">setProperty</span>(
      runtime, <span class="hljs-string">"initialProps"</span>, jsi::<span class="hljs-built_in">valueFromDynamic</span>(runtime, initialProps));
  parameters.<span class="hljs-built_in">setProperty</span>(runtime, <span class="hljs-string">"fabric"</span>, <span class="hljs-literal">true</span>);

  <span class="hljs-comment">// 获取全局AppRegistry </span>
  <span class="hljs-comment">// 访问JS全局对象</span>
  <span class="hljs-keyword">auto</span> global = runtime.<span class="hljs-built_in">global</span>();
  <span class="hljs-comment">// 查找RN$AppRegistry（在AppRegistry.js中设置）</span>
  <span class="hljs-keyword">auto</span> registry = global.<span class="hljs-built_in">getProperty</span>(runtime, <span class="hljs-string">"RN$AppRegistry"</span>);
  <span class="hljs-keyword">if</span> (!registry.<span class="hljs-built_in">isObject</span>()) {
    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(
        <span class="hljs-string">"AppRegistryBinding::startSurface failed. Global was not installed."</span>);
  }

  <span class="hljs-comment">// 获取runApplication方法对象</span>
  <span class="hljs-keyword">auto</span> method = std::<span class="hljs-built_in">move</span>(registry).<span class="hljs-built_in">asObject</span>(runtime).<span class="hljs-built_in">getPropertyAsFunction</span>(
      runtime, <span class="hljs-string">"runApplication"</span>);

  <span class="hljs-comment">// 调用JS方法：runApplication</span>
  method.<span class="hljs-built_in">call</span>(
      runtime,
      {jsi::String::<span class="hljs-built_in">createFromUtf8</span>(runtime, moduleName),
       std::<span class="hljs-built_in">move</span>(parameters),
       jsi::<span class="hljs-built_in">Value</span>(runtime, <span class="hljs-built_in">displayModeToInt</span>(displayMode))});
}
</code></pre>
<p>这里的重点是就是JS层的<strong>runApplication</strong>方法调用，可以说这就是JS层的入口方法。此处的JSI C++调用等价于以下JS代码：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-title class_">AppRegistry</span>.<span class="hljs-title function_">runApplication</span>(
  <span class="hljs-string">"RNTesterApp"</span>,           <span class="hljs-comment">// moduleName</span>
  {
    <span class="hljs-attr">rootTag</span>: <span class="hljs-number">1</span>,            <span class="hljs-comment">// surfaceId</span>
    <span class="hljs-attr">initialProps</span>: {...},   <span class="hljs-comment">// 初始属性</span>
    <span class="hljs-attr">fabric</span>: <span class="hljs-literal">true</span>           <span class="hljs-comment">// 新架构标记</span>
  },
  <span class="hljs-number">0</span>                        <span class="hljs-comment">// displayMode</span>
);
</code></pre>
<p><code>AppRegistryBinding::startSurface</code>方法是新架构调用链的终点，负责通过JSI直接调用JS层的AppRegistry.runApplication，启动React Native应用。</p>
<h3 data-id="heading-7">渲染调度</h3>
<p>接下来我们探索一下前面提到的<code>mOnViewAttachMountItems</code>队列：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// SurfaceMountingManager.java</span>

  <span class="hljs-meta">@UiThread</span>
  <span class="hljs-meta">@ThreadConfined(UI)</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">scheduleMountItemOnViewAttach</span><span class="hljs-params">(MountItem item)</span> {
    mOnViewAttachMountItems.add(item);
  }
</code></pre>
<p>经过搜索，可以定位到<code>scheduleMountItemOnViewAttach</code>调用处：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// MountItemDispatcher.kt</span>

  <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getAndResetViewCommandMountItems</span><span class="hljs-params">()</span></span>: List&lt;DispatchCommandMountItem&gt;? =
      drainConcurrentItemQueue(viewCommandMountItems)

  <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getAndResetMountItems</span><span class="hljs-params">()</span></span>: List&lt;MountItem&gt;? = drainConcurrentItemQueue(mountItems)

  <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getAndResetPreMountItems</span><span class="hljs-params">()</span></span>: List&lt;MountItem&gt;? = drainConcurrentItemQueue(preMountItems)

  <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">executeOrEnqueue</span><span class="hljs-params">(item: <span class="hljs-type">MountItem</span>)</span></span> {
    <span class="hljs-keyword">if</span> (mountingManager.isWaitingForViewAttach(item.getSurfaceId())) {
      <span class="hljs-comment">// Surface 还未准备好，将任务加入等待队列</span>
      <span class="hljs-keyword">val</span> surfaceMountingManager: SurfaceMountingManager =
          mountingManager.getSurfaceManagerEnforced(
              item.getSurfaceId(),
              <span class="hljs-string">"MountItemDispatcher::executeOrEnqueue"</span>,
          )
      surfaceMountingManager.scheduleMountItemOnViewAttach(item)
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// Surface 已准备好，直接执行</span>
      item.execute(mountingManager)
    }
  }


  <span class="hljs-comment">/*
   * 按以下顺序执行视图命令、预挂载项和挂载项：
   * 1. 视图命令
   * 2. 预挂载项  
   * 3. 常规挂载项
   *
   * 如果 `viewCommandMountItemsToDispatch` 和 `mountItemsToDispatch` 都为空，则不执行任何操作。
   * 除了 `tryDispatchMountItems` 之外，任何地方都不应直接调用此方法。
   */</span>
  <span class="hljs-meta">@UiThread</span>
  <span class="hljs-meta">@ThreadConfined(UI)</span>
  <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dispatchMountItems</span><span class="hljs-params">()</span></span> {
    batchedExecutionTime = <span class="hljs-number">0</span>
    runStartTime = SystemClock.uptimeMillis()
    <span class="hljs-comment">// 初始化和获取待分发项</span>
    <span class="hljs-keyword">val</span> viewCommandMountItemsToDispatch = getAndResetViewCommandMountItems()
    <span class="hljs-keyword">val</span> mountItemsToDispatch = getAndResetMountItems()

    <span class="hljs-keyword">if</span> (mountItemsToDispatch == <span class="hljs-literal">null</span> &amp;&amp; viewCommandMountItemsToDispatch == <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">return</span>
    }

    itemDispatchListener.willMountItems(mountItemsToDispatch)

    <span class="hljs-comment">// 定义视图命令分发函数</span>
    <span class="hljs-keyword">val</span> dispatchViewCommand: (command: DispatchCommandMountItem) -&gt; <span class="hljs-built_in">Unit</span> = { command -&gt;
      <span class="hljs-keyword">if</span> (ReactNativeFeatureFlags.enableFabricLogs()) {
        printMountItem(command, <span class="hljs-string">"dispatchMountItems: Executing viewCommandMountItem"</span>)
      }
      <span class="hljs-keyword">try</span> {
        executeOrEnqueue(command)
      } <span class="hljs-keyword">catch</span> (e: RetryableMountingLayerException) {
        <span class="hljs-comment">// 省略......</span>
      } <span class="hljs-keyword">catch</span> (e: Throwable) {
        <span class="hljs-comment">// 省略......</span>
      }
    }

    <span class="hljs-comment">// 执行ViewCommand</span>

    <span class="hljs-comment">// 作为优化，首先执行所有 ViewCommand</span>
    <span class="hljs-comment">// 这应该是：</span>
    <span class="hljs-comment">// 1) 高性能的：ViewCommand 通常是 SetNativeProps 的替代品，我们一直希望它尽可能"同步"。</span>
    <span class="hljs-comment">// 2) 更安全的：ViewCommand 本质上与树提交/差异/挂载过程断开连接。</span>
    <span class="hljs-comment">// JS 令式地排队这些命令。</span>
    <span class="hljs-comment">//    如果 JS 已经排队了一个命令，可以合理地假设时间过得越久， 视图消失的可能性就越大。</span>
    <span class="hljs-comment">//    因此，通过提前执行 ViewCommand，我们实际上应该避免一类错误/故障。</span>
    viewCommandMountItemsToDispatch?.let { commands -&gt;
      <span class="hljs-keyword">for</span> (command <span class="hljs-keyword">in</span> commands) {
        dispatchViewCommand(command)
      }

      Systrace.endSection(Systrace.TRACE_TAG_REACT)
    }

    <span class="hljs-comment">// 执行PreMountItem</span>
    <span class="hljs-comment">// 如果有 MountItem 要分发，我们确保所有"预挂载项"首先执行</span>
    getAndResetPreMountItems()?.let { preMountItems -&gt;
      <span class="hljs-keyword">for</span> (preMountItem <span class="hljs-keyword">in</span> preMountItems) {
        <span class="hljs-keyword">if</span> (ReactNativeFeatureFlags.enableFabricLogs()) {
          printMountItem(preMountItem, <span class="hljs-string">"dispatchMountItems: Executing preMountItem"</span>)
        }
        executeOrEnqueue(preMountItem)
      }
      Systrace.endSection(Systrace.TRACE_TAG_REACT)
    }

    <span class="hljs-comment">// 执行常规 MountItem </span>
    mountItemsToDispatch?.let { items -&gt;
      <span class="hljs-keyword">val</span> batchedExecutionStartTime = SystemClock.uptimeMillis()

      <span class="hljs-keyword">for</span> (mountItem <span class="hljs-keyword">in</span> items) {
        <span class="hljs-keyword">if</span> (ReactNativeFeatureFlags.enableFabricLogs()) {
          printMountItem(mountItem, <span class="hljs-string">"dispatchMountItems: Executing mountItem"</span>)
        }

        <span class="hljs-keyword">val</span> command = mountItem <span class="hljs-keyword">as</span>? DispatchCommandMountItem
        <span class="hljs-keyword">if</span> (command != <span class="hljs-literal">null</span>) {
          dispatchViewCommand(command)
          <span class="hljs-keyword">continue</span>
        }

        <span class="hljs-keyword">try</span> {
          executeOrEnqueue(mountItem)
        } <span class="hljs-keyword">catch</span> (e: Throwable) {
          <span class="hljs-comment">// 省略......</span>
        }
      }
      batchedExecutionTime += SystemClock.uptimeMillis() - batchedExecutionStartTime
    }

    itemDispatchListener.didMountItems(mountItemsToDispatch)
  }

 <span class="hljs-comment">/**
  * 尝试分发 MountItems。如果出现异常，我们将重试 10 次后放弃。
  */</span>
  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">tryDispatchMountItems</span><span class="hljs-params">()</span></span> {
    <span class="hljs-comment">// 如果我们已经在分发中，不要重入。在 Android 的 Fabric 中可能经常发生重入，</span>
    <span class="hljs-comment">// 因为来自挂载层的 `updateState` 会导致挂载项被同步分发。我们想要 </span>
    <span class="hljs-comment">//    1)确保在这些情况下不重入，但 2)仍然同步执行这些排队的指令。</span>
    <span class="hljs-comment">// 这是一个相当粗暴的工具，但我们可能没有更好的选择，因为我们真的不想执行任何乱序的操作。</span>
    <span class="hljs-keyword">if</span> (inDispatch) {
      <span class="hljs-keyword">return</span>
    }

    inDispatch = <span class="hljs-literal">true</span>

    <span class="hljs-keyword">try</span> {
      dispatchMountItems()
    } <span class="hljs-keyword">finally</span> {
      <span class="hljs-comment">// 即使抛出异常也要在运行 dispatchMountItems 后清理</span>
      inDispatch = <span class="hljs-literal">false</span>
    }

    <span class="hljs-comment">// 无论我们是否实际分发了任何内容，我们都会调用 didDispatchMountItems，</span>
    <span class="hljs-comment">// 因为 NativeAnimatedModule 依赖于此来执行可能已调度的任何动画</span>
    itemDispatchListener.didDispatchMountItems()
  }
</code></pre>
<p>可以看到，<code>scheduleMountItemOnViewAttach</code>仅被<code>executeOrEnqueue</code>方法调用。只有在<strong>Surface</strong> 还未准备好时，才将任务加入等待队列。否则，直接在<code>executeOrEnqueue</code>中执行挂载项。</p>
<p>这里<code>executeOrEnqueue</code>方法在<code>dispatchMountItems</code>方法中有三次调用，分别对应着三个队列。这三个队列存在执行顺序：</p>
<ol>
<li>
<p><strong>ViewCommand</strong> 优先执行：提高性能和安全性（存储视图命令，如 scrollTo、focus等，这些是来自 JS 的命令式调用，与视图树的提交/差异/挂载过程分离）</p>
</li>
<li>
<p><strong>PreMountItem</strong> 次之：为后续挂载做准备（存储预挂载项，主要是视图预分配操作。这是性能优化，尽可能提前完成工作）</p>
</li>
<li>
<p>常规 <strong>MountItem</strong> 最后：执行实际的视图操作（存储常规挂载项，包含主要的视图操作。这是视图树更新的核心操作）</p>
</li>
</ol>
<p>有个地方需要注意，就是<code>drainConcurrentItemQueue</code>方法。此方法是一次性清空队列，将结果转为一个List。之所以这样做，是为了将累积的所有挂载项一次性取出进行批处理，避免在执行过程中队列继续增长导致的不一致性。这里的三个队列都调用了此方法返回列表。</p>
<p>接下来，根据注释可知，<code>dispatchMountItems</code>方法只应该被<code>tryDispatchMountItems</code>调用。而<code>tryDispatchMountItems</code>方法主要做了一个防止重入的处理。继续搜索该方法，发现只有两处调用，且都在<code>FabricUIManager.java</code>中：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DispatchUIFrameCallback</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">GuardedFrameCallback</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">mIsMountingEnabled</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;
    <span class="hljs-meta">@ThreadConfined(UI)</span>
    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">mShouldSchedule</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;
    <span class="hljs-meta">@ThreadConfined(UI)</span>
    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">mIsScheduled</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;

    <span class="hljs-keyword">private</span> <span class="hljs-title function_">DispatchUIFrameCallback</span><span class="hljs-params">(ReactContext reactContext)</span> {
      <span class="hljs-built_in">super</span>(reactContext);
    }

    <span class="hljs-meta">@UiThread</span>
    <span class="hljs-meta">@ThreadConfined(UI)</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">schedule</span><span class="hljs-params">()</span> {
      <span class="hljs-keyword">if</span> (!mIsScheduled &amp;&amp; mShouldSchedule) {
        mIsScheduled = <span class="hljs-literal">true</span>;
        ReactChoreographer.getInstance()
            .postFrameCallback(ReactChoreographer.CallbackType.DISPATCH_UI, <span class="hljs-built_in">this</span>);
      }
    }
    <span class="hljs-comment">// 省略部分代码......</span>

    <span class="hljs-meta">@Override</span>
    <span class="hljs-meta">@UiThread</span>
    <span class="hljs-meta">@ThreadConfined(UI)</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFrameGuarded</span><span class="hljs-params">(<span class="hljs-type">long</span> frameTimeNanos)</span> {
      mIsScheduled = <span class="hljs-literal">false</span>;
      <span class="hljs-keyword">if</span> (!mIsMountingEnabled) {
        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">if</span> (mDestroyed) {
        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-comment">// 通过 C++ 驱动所有动画。</span>
      <span class="hljs-comment">// 这里存在获取/设置 `mDriveCxxAnimations` 的竞态条件，但这应该无关紧要；</span>
      <span class="hljs-comment">// 调用 mBinding 方法是安全的，除非 mBinding 对象已被销毁。</span>
      <span class="hljs-keyword">if</span> ((mDriveCxxAnimations || ReactNativeFeatureFlags.cxxNativeAnimatedEnabled())
          &amp;&amp; mBinding != <span class="hljs-literal">null</span>) {
        mBinding.driveCxxAnimations();
      }

      <span class="hljs-keyword">if</span> (mBinding != <span class="hljs-literal">null</span>) {
        mBinding.drainPreallocateViewsQueue();
      }

      <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">// 首先，在 frameTimeNanos 时间内执行尽可能多的预挂载项。</span>
        <span class="hljs-comment">// 如果不是所有预挂载项都被执行，可能发生以下情况：</span>
        <span class="hljs-comment">//   1. 如果 MountItemDispatcher 中有视图命令或挂载项：执行剩余的预挂载项。</span>
        <span class="hljs-comment">//   2. 如果没有视图命令或挂载项，等待下一帧。</span>
        mMountItemDispatcher.dispatchPreMountItems(frameTimeNanos);
        mMountItemDispatcher.tryDispatchMountItems();
      } <span class="hljs-keyword">catch</span> (Exception ex) {
        FLog.e(TAG, <span class="hljs-string">"Exception thrown when executing UIFrameGuarded"</span>, ex);
        mIsMountingEnabled = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">throw</span> ex;
      } <span class="hljs-keyword">finally</span> {
        schedule();
      }

      mSynchronousEvents.clear();
    }
  }
</code></pre>
<p>先看<code>doFrameGuarded</code>这处调用，这里正是一开始分析初始化流程时提到的基于 Android Choreographer帧回调处理。</p>
<ul>
<li>
<p>监听 VSync 信号</p>
</li>
<li>
<p>在每帧开始时触发回调</p>
</li>
<li>
<p>按优先级顺序执行回调队列</p>
<ol>
<li>
<p><code>mBinding.driveCxxAnimations()</code>- C++ 动画</p>
</li>
<li>
<p><code>mBinding.drainPreallocateViewsQueue()</code>- C++ 预分配队列</p>
</li>
<li>
<p><code>dispatchPreMountItems(frameTimeNanos)</code>- Java 预挂载项</p>
</li>
<li>
<p><code>tryDispatchMountItems()</code> - 常规挂载项</p>
</li>
</ol>
</li>
</ul>
<p><code>doFrameGuarded</code>这处调用就是正常的帧驱动渲染流程，确保 UI 更新与屏幕刷新同步。</p>
<p>我们再看另一处调用：</p>
<pre><code class="hljs language-java" lang="java">  <span class="hljs-comment">/**
   * 此方法将 UI 操作直接添加到 UI 线程队列中。以使用 {<span class="hljs-doctag">@link</span> ReactChoreographer.CallbackType} 来强制执行顺序。
   * 此方法应仅在提交新渲染树后调用。
   */</span>
  <span class="hljs-meta">@SuppressWarnings("unused")</span>
  <span class="hljs-meta">@AnyThread</span>
  <span class="hljs-meta">@ThreadConfined(ANY)</span>
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">scheduleMountItem</span><span class="hljs-params">(
      <span class="hljs-meta">@Nullable</span> <span class="hljs-keyword">final</span> MountItem mountItem,
      <span class="hljs-type">int</span> commitNumber,
      <span class="hljs-type">long</span> commitStartTime,
      <span class="hljs-type">long</span> diffStartTime,
      <span class="hljs-type">long</span> diffEndTime,
      <span class="hljs-type">long</span> layoutStartTime,
      <span class="hljs-type">long</span> layoutEndTime,
      <span class="hljs-type">long</span> finishTransactionStartTime,
      <span class="hljs-type">long</span> finishTransactionEndTime,
      <span class="hljs-type">int</span> affectedLayoutNodesCount)</span> {
    <span class="hljs-comment">// 当 Binding.cpp 在提交阶段调用 scheduleMountItems 时，它总是使用 BatchMountItem 调用。</span>
    <span class="hljs-comment">// 没有其他地方使用 BatchMountItem 调用此方法，并且 Binding.cpp 只使用 BatchMountItem 调用 scheduleMountItems。</span>
    <span class="hljs-type">long</span> <span class="hljs-variable">scheduleMountItemStartTime</span> <span class="hljs-operator">=</span> SystemClock.uptimeMillis();
    <span class="hljs-type">boolean</span> <span class="hljs-variable">isBatchMountItem</span> <span class="hljs-operator">=</span> mountItem <span class="hljs-keyword">instanceof</span> BatchMountItem;
    <span class="hljs-type">boolean</span> <span class="hljs-variable">shouldSchedule</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;

    <span class="hljs-comment">// 判断是否为批量挂载项</span>
    <span class="hljs-keyword">if</span> (isBatchMountItem) {
      <span class="hljs-type">BatchMountItem</span> <span class="hljs-variable">batchMountItem</span> <span class="hljs-operator">=</span> (BatchMountItem) mountItem;
      Assertions.assertNotNull(batchMountItem, <span class="hljs-string">"BatchMountItem is null"</span>);
      shouldSchedule = !batchMountItem.isBatchEmpty();
    } <span class="hljs-keyword">else</span> {
      shouldSchedule = mountItem != <span class="hljs-literal">null</span>;
    }
    <span class="hljs-comment">// 省略性能记录......</span>

    <span class="hljs-comment">// 通知监听器</span>
    <span class="hljs-comment">// 在同步渲染的情况下，这可能在 UI 线程上被调用。否则，</span>
    <span class="hljs-comment">// 它应该几乎总是在 JS 线程上被调用。</span>
    <span class="hljs-keyword">for</span> (UIManagerListener listener : mListeners) {
      listener.didScheduleMountItems(<span class="hljs-built_in">this</span>);
    }

    <span class="hljs-comment">// 调度执行</span>
    <span class="hljs-keyword">if</span> (shouldSchedule) {
      Assertions.assertNotNull(mountItem, <span class="hljs-string">"MountItem is null"</span>);
      <span class="hljs-comment">// 将 MountItem 添加到分发器队列</span>
      mMountItemDispatcher.addMountItem(mountItem);
      <span class="hljs-comment">// 判断是否是UI线程，如果是UI线程则立即执行，实现低延迟渲染</span>
      <span class="hljs-keyword">if</span> (UiThreadUtil.isOnUiThread()) {
        <span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span>
            <span class="hljs-keyword">new</span> <span class="hljs-title class_">GuardedRunnable</span>(mReactApplicationContext) {
              <span class="hljs-meta">@Override</span>
              <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">runGuarded</span><span class="hljs-params">()</span> {
                mMountItemDispatcher.tryDispatchMountItems();
              }
            };
        runnable.run();
      }
    }

    <span class="hljs-comment">// 在锁外和同步挂载完成执行后发布标记</span>
    <span class="hljs-keyword">if</span> (isBatchMountItem) {
      <span class="hljs-comment">// 省略部分代码......</span>
    }
  }
</code></pre>
<p>可以看到，此方法是由C++层调用，在其中实现了双路径执行渲染策略。当前如果在UI线程调用，则会立即执行渲染。反之，只是通过<code>mMountItemDispatcher.addMountItem(mountItem)</code>将 MountItem 添加到队列，等待帧回调处理：</p>
<pre><code class="hljs language-kotlin" lang="kotlin">  <span class="hljs-comment">// MountItemDispatcher.kt</span>

  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">addMountItem</span><span class="hljs-params">(mountItem: <span class="hljs-type">MountItem</span>)</span></span> {
    mountItems.add(mountItem)
  }
</code></pre>
<h4 data-id="heading-8">C++ 层</h4>
<p>现在来研究一下C++层触发<code>scheduleMountItem</code>的流程，源码<code>react-native/packages/react-native/ReactCommon/react/renderer/uimanager/UIManagerBinding.cpp</code>：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-function">jsi::Value <span class="hljs-title">UIManagerBinding::get</span><span class="hljs-params">(
    jsi::Runtime&amp; runtime,
    <span class="hljs-type">const</span> jsi::PropNameID&amp; name)</span> </span>{
  <span class="hljs-keyword">auto</span> methodName = name.<span class="hljs-built_in">utf8</span>(runtime);

  UIManager* uiManager = uiManager_.<span class="hljs-built_in">get</span>();
  <span class="hljs-comment">// 省略部分代码......</span>

  <span class="hljs-keyword">if</span> (methodName == <span class="hljs-string">"completeRoot"</span>) {
    <span class="hljs-keyword">auto</span> paramCount = <span class="hljs-number">2</span>;
    <span class="hljs-keyword">return</span> jsi::Function::<span class="hljs-built_in">createFromHostFunction</span>(
        runtime,
        name,
        paramCount,
        [uiManager, methodName, paramCount](
            jsi::Runtime&amp; runtime,
            <span class="hljs-type">const</span> jsi::Value&amp; <span class="hljs-comment">/*thisValue*/</span>,
            <span class="hljs-type">const</span> jsi::Value* arguments,
            <span class="hljs-type">size_t</span> count) -&gt; jsi::Value {
          <span class="hljs-built_in">validateArgumentCount</span>(runtime, methodName, paramCount, count);

          <span class="hljs-keyword">auto</span> runtimeSchedulerBinding =
              RuntimeSchedulerBinding::<span class="hljs-built_in">getBinding</span>(runtime);
          <span class="hljs-keyword">auto</span> surfaceId = <span class="hljs-built_in">surfaceIdFromValue</span>(runtime, arguments[<span class="hljs-number">0</span>]);

          <span class="hljs-keyword">auto</span> shadowNodeList = <span class="hljs-built_in">shadowNodeListFromValue</span>(runtime, arguments[<span class="hljs-number">1</span>]);
          uiManager-&gt;<span class="hljs-built_in">completeSurface</span>(
              surfaceId,
              shadowNodeList,
              {.enableStateReconciliation = <span class="hljs-literal">true</span>,
               .mountSynchronously = <span class="hljs-literal">false</span>,
               .source = ShadowTree::CommitSource::React});

          <span class="hljs-keyword">return</span> jsi::Value::<span class="hljs-built_in">undefined</span>();
        });
  }
  <span class="hljs-comment">// 省略部分代码......</span>

  <span class="hljs-keyword">return</span> jsi::Value::<span class="hljs-built_in">undefined</span>();
}
</code></pre>
<p>继续跟踪<code>completeSurface</code>方法实现，源码<code>react-native/packages/react-native/ReactCommon/react/renderer/uimanager/UIManager.cpp</code>：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">UIManager::completeSurface</span><span class="hljs-params">(
    SurfaceId surfaceId,
    <span class="hljs-type">const</span> ShadowNode::UnsharedListOfShared&amp; rootChildren,
    ShadowTree::CommitOptions commitOptions)</span> </span>{
  <span class="hljs-function">TraceSection <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">"UIManager::completeSurface"</span>, <span class="hljs-string">"surfaceId"</span>, surfaceId)</span></span>;

  shadowTreeRegistry_.<span class="hljs-built_in">visit</span>(surfaceId, [&amp;](<span class="hljs-type">const</span> ShadowTree&amp; shadowTree) {
    <span class="hljs-keyword">auto</span> result = shadowTree.<span class="hljs-built_in">commit</span>(
        [&amp;](<span class="hljs-type">const</span> RootShadowNode&amp; oldRootShadowNode) {
          <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_shared</span>&lt;RootShadowNode&gt;(
              oldRootShadowNode,
              ShadowNodeFragment{
                  .props = ShadowNodeFragment::<span class="hljs-built_in">propsPlaceholder</span>(),
                  .children = rootChildren,
              });
        },
        commitOptions);

    <span class="hljs-keyword">if</span> (result == ShadowTree::CommitStatus::Succeeded) {
      <span class="hljs-comment">// It's safe to update the visible revision of the shadow tree immediately</span>
      <span class="hljs-comment">// after we commit a specific one.</span>
      lazyShadowTreeRevisionConsistencyManager_-&gt;<span class="hljs-built_in">updateCurrentRevision</span>(
          surfaceId, shadowTree.<span class="hljs-built_in">getCurrentRevision</span>().rootShadowNode);
    }
  });
}
</code></pre>
<p>这里的核心是<code>ShadowTree::commit</code>方法的调用，实参是个闭包。它主要用于计算 Diff，生成 MountingTransaction。继续跟踪源码<code>react-native/packages/react-native/ReactCommon/react/renderer/mounting/ShadowTree.cpp</code>：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-function">CommitStatus <span class="hljs-title">ShadowTree::commit</span><span class="hljs-params">(
    <span class="hljs-type">const</span> ShadowTreeCommitTransaction&amp; transaction,
    <span class="hljs-type">const</span> CommitOptions&amp; commitOptions)</span> <span class="hljs-type">const</span> </span>{
  [[maybe_unused]] <span class="hljs-type">int</span> attempts = <span class="hljs-number">0</span>;

  <span class="hljs-keyword">if</span> (ReactNativeFeatureFlags::<span class="hljs-built_in">preventShadowTreeCommitExhaustion</span>()) {
    <span class="hljs-keyword">while</span> (attempts &lt; MAX_COMMIT_ATTEMPTS_BEFORE_LOCKING) {
      <span class="hljs-keyword">auto</span> status = <span class="hljs-built_in">tryCommit</span>(transaction, commitOptions);
      <span class="hljs-keyword">if</span> (status != CommitStatus::Failed) {
        <span class="hljs-keyword">return</span> status;
      }
      attempts++;
    }

    {
      <span class="hljs-function">std::unique_lock <span class="hljs-title">lock</span><span class="hljs-params">(commitMutexRecursive_)</span></span>;
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">tryCommit</span>(transaction, commitOptions);
    }
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// 循环尝试提交，直到成功或达到最大尝试次数</span>
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
      attempts++;

      <span class="hljs-keyword">auto</span> status = <span class="hljs-built_in">tryCommit</span>(transaction, commitOptions);
      <span class="hljs-keyword">if</span> (status != CommitStatus::Failed) {
        <span class="hljs-keyword">return</span> status;
      }

      <span class="hljs-comment">// After multiple attempts, we failed to commit the transaction.</span>
      <span class="hljs-comment">// Something internally went terribly wrong.</span>
      <span class="hljs-built_in">react_native_assert</span>(attempts &lt; <span class="hljs-number">1024</span>);
    }
  }
}

<span class="hljs-function">CommitStatus <span class="hljs-title">ShadowTree::tryCommit</span><span class="hljs-params">(
    <span class="hljs-type">const</span> ShadowTreeCommitTransaction&amp; transaction,
    <span class="hljs-type">const</span> CommitOptions&amp; commitOptions)</span> <span class="hljs-type">const</span> </span>{
  <span class="hljs-function">TraceSection <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">"ShadowTree::commit"</span>)</span></span>;

  <span class="hljs-keyword">auto</span> telemetry = TransactionTelemetry{};
  telemetry.<span class="hljs-built_in">willCommit</span>();

  CommitMode commitMode;
  <span class="hljs-keyword">auto</span> oldRevision = ShadowTreeRevision{};
  <span class="hljs-keyword">auto</span> newRevision = ShadowTreeRevision{};

  {
    <span class="hljs-comment">// Reading `currentRevision_` in shared manner.</span>
    SharedLock lock = <span class="hljs-built_in">sharedCommitLock</span>();
    commitMode = commitMode_;
    oldRevision = currentRevision_;
  }

  <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; oldRootShadowNode = oldRevision.rootShadowNode;

  <span class="hljs-comment">// 1. 执行 transaction，生成新的 RootShadowNode</span>
  <span class="hljs-keyword">auto</span> newRootShadowNode = <span class="hljs-built_in">transaction</span>(*oldRevision.rootShadowNode);

  <span class="hljs-keyword">if</span> (!newRootShadowNode) {
    <span class="hljs-keyword">return</span> CommitStatus::Cancelled;
  }

  <span class="hljs-comment">// 2. 状态协调（State Reconciliation）</span>
  <span class="hljs-keyword">if</span> (commitOptions.enableStateReconciliation) {
    <span class="hljs-keyword">auto</span> updatedNewRootShadowNode =
        <span class="hljs-built_in">progressState</span>(*newRootShadowNode, *oldRootShadowNode);
    <span class="hljs-keyword">if</span> (updatedNewRootShadowNode) {
      newRootShadowNode =
          std::<span class="hljs-built_in">static_pointer_cast</span>&lt;RootShadowNode&gt;(updatedNewRootShadowNode);
    }
  }

  <span class="hljs-comment">// 3. 调用 delegate 的 shadowTreeWillCommit hook</span>
  newRootShadowNode = delegate_.<span class="hljs-built_in">shadowTreeWillCommit</span>(
      *<span class="hljs-keyword">this</span>, oldRootShadowNode, newRootShadowNode, commitOptions);

  <span class="hljs-keyword">if</span> (!newRootShadowNode) {
    <span class="hljs-keyword">return</span> CommitStatus::Cancelled;
  }

  <span class="hljs-comment">// Layout nodes.</span>
  std::vector&lt;<span class="hljs-type">const</span> LayoutableShadowNode*&gt; affectedLayoutableNodes{};
  affectedLayoutableNodes.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">1024</span>);

  telemetry.<span class="hljs-built_in">willLayout</span>();
  telemetry.<span class="hljs-built_in">setAsThreadLocal</span>();

  <span class="hljs-comment">// 4. 布局计算</span>
  newRootShadowNode-&gt;<span class="hljs-built_in">layoutIfNeeded</span>(&amp;affectedLayoutableNodes);
  telemetry.<span class="hljs-built_in">unsetAsThreadLocal</span>();
  telemetry.<span class="hljs-built_in">didLayout</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(affectedLayoutableNodes.<span class="hljs-built_in">size</span>()));

  {
    <span class="hljs-comment">// Updating `currentRevision_` in unique manner if it hasn't changed.</span>
    UniqueLock lock = <span class="hljs-built_in">uniqueCommitLock</span>();

    <span class="hljs-keyword">if</span> (currentRevision_.number != oldRevision.number) {
      <span class="hljs-keyword">return</span> CommitStatus::Failed;
    }

    <span class="hljs-keyword">auto</span> newRevisionNumber = currentRevision_.number + <span class="hljs-number">1</span>;

    {
      <span class="hljs-function">std::scoped_lock <span class="hljs-title">dispatchLock</span><span class="hljs-params">(EventEmitter::DispatchMutex())</span></span>;
      <span class="hljs-built_in">updateMountedFlag</span>(
          currentRevision_.rootShadowNode-&gt;<span class="hljs-built_in">getChildren</span>(),
          newRootShadowNode-&gt;<span class="hljs-built_in">getChildren</span>(),
          commitOptions.source);
    }

    telemetry.<span class="hljs-built_in">didCommit</span>();
    telemetry.<span class="hljs-built_in">setRevisionNumber</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(newRevisionNumber));

    <span class="hljs-comment">// Seal the shadow node so it can no longer be mutated</span>
    <span class="hljs-comment">// Does nothing in release.</span>
    newRootShadowNode-&gt;<span class="hljs-built_in">sealRecursive</span>();

    newRevision = ShadowTreeRevision{
        .rootShadowNode = std::<span class="hljs-built_in">move</span>(newRootShadowNode),
        .number = newRevisionNumber,
        .telemetry = telemetry};
    <span class="hljs-comment">// 5. 更新 currentRevision_</span>
    currentRevision_ = newRevision;
  }

  <span class="hljs-comment">// 6. 发送布局事件</span>
  <span class="hljs-built_in">emitLayoutEvents</span>(affectedLayoutableNodes);

  <span class="hljs-comment">// 7. 关键：如果 commitMode 是 Normal，调用 mount</span>
  <span class="hljs-keyword">if</span> (commitMode == CommitMode::Normal) {
    <span class="hljs-built_in">mount</span>(std::<span class="hljs-built_in">move</span>(newRevision), commitOptions.mountSynchronously);
  }

  <span class="hljs-keyword">return</span> CommitStatus::Succeeded;
}


<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShadowTree::mount</span><span class="hljs-params">(ShadowTreeRevision revision, <span class="hljs-type">bool</span> mountSynchronously)</span>
    <span class="hljs-type">const</span> </span>{
  <span class="hljs-comment">// 1. 将新的 revision 推送到 MountingCoordinator</span>
  mountingCoordinator_-&gt;<span class="hljs-built_in">push</span>(std::<span class="hljs-built_in">move</span>(revision));
  <span class="hljs-comment">// 2. 调用 delegate 的 shadowTreeDidFinishTransaction</span>
  delegate_.<span class="hljs-built_in">shadowTreeDidFinishTransaction</span>(
      mountingCoordinator_, mountSynchronously);
}
</code></pre>
<p>注意，<strong>ShadowTreeRevision</strong> 表示 Shadow Tree 的一个已提交快照（版本）。由三个组成部分：</p>
<ul>
<li>
<p><code>rootShadowNode</code>：整个 Shadow Tree 的根节点，包含完整的树结构和所有子节点</p>
</li>
<li>
<p><code>number</code>：版本号，从 0（INITIAL_REVISION）开始递增，每次 commit 创建新 revision 时递增。主要用于检测并发冲突和版本追踪</p>
</li>
<li>
<p><code>telemetry</code>：性能数据（commit 时间、layout 时间、影响的节点数等</p>
</li>
</ul>
<p><strong>MountingCoordinator</strong> 使用 revision 来计算新旧树之间的差异，生成需要执行的视图操作。</p>
<p>继续跟踪<code>shadowTreeDidFinishTransaction</code>的实现：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// UIManager.cpp</span>

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">UIManager::shadowTreeDidFinishTransaction</span><span class="hljs-params">(
    std::shared_ptr&lt;<span class="hljs-type">const</span> MountingCoordinator&gt; mountingCoordinator,
    <span class="hljs-type">bool</span> mountSynchronously)</span> <span class="hljs-type">const</span> </span>{
  <span class="hljs-function">TraceSection <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">"UIManager::shadowTreeDidFinishTransaction"</span>)</span></span>;

  <span class="hljs-keyword">if</span> (delegate_ != <span class="hljs-literal">nullptr</span>) {
    delegate_-&gt;<span class="hljs-built_in">uiManagerDidFinishTransaction</span>(
        std::<span class="hljs-built_in">move</span>(mountingCoordinator), mountSynchronously);
  }
}
</code></pre>
<p>继续跟踪<code>uiManagerDidFinishTransaction</code>实现，源码<code>react-native/packages/react-native/ReactCommon/react/renderer/scheduler/Scheduler.cpp</code>：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Scheduler::uiManagerDidFinishTransaction</span><span class="hljs-params">(
    std::shared_ptr&lt;<span class="hljs-type">const</span> MountingCoordinator&gt; mountingCoordinator,
    <span class="hljs-type">bool</span> mountSynchronously)</span> </span>{
  <span class="hljs-function">TraceSection <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">"Scheduler::uiManagerDidFinishTransaction"</span>)</span></span>;

  <span class="hljs-keyword">if</span> (delegate_ != <span class="hljs-literal">nullptr</span>) {
    <span class="hljs-comment">// 除了 Android 平台之外，此操作在所有平台上均无效，</span>
    <span class="hljs-comment">// 因为在 Android 平台上我们需要观察每个事务才能正确地进行挂载。</span>
    delegate_-&gt;<span class="hljs-built_in">schedulerDidFinishTransaction</span>(mountingCoordinator);

    <span class="hljs-keyword">if</span> (!mountSynchronously) {
      <span class="hljs-keyword">auto</span> surfaceId = mountingCoordinator-&gt;<span class="hljs-built_in">getSurfaceId</span>();

      runtimeScheduler_-&gt;<span class="hljs-built_in">scheduleRenderingUpdate</span>(
          surfaceId,
          [delegate = delegate_,
           mountingCoordinator = std::<span class="hljs-built_in">move</span>(mountingCoordinator)]() {
            delegate-&gt;<span class="hljs-built_in">schedulerShouldRenderTransactions</span>(mountingCoordinator);
          });
    } <span class="hljs-keyword">else</span> {
      delegate_-&gt;<span class="hljs-built_in">schedulerShouldRenderTransactions</span>(mountingCoordinator);
    }
  }
}
</code></pre>
<p>继续跟踪<code>schedulerShouldRenderTransactions</code>实现：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// FabricUIManagerBinding.cpp</span>


<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FabricUIManagerBinding::schedulerShouldRenderTransactions</span><span class="hljs-params">(
    <span class="hljs-type">const</span> std::shared_ptr&lt;<span class="hljs-type">const</span> MountingCoordinator&gt;&amp; mountingCoordinator)</span> </span>{
  <span class="hljs-keyword">auto</span> mountingManager =
      <span class="hljs-built_in">getMountingManager</span>(<span class="hljs-string">"schedulerShouldRenderTransactions"</span>);
  <span class="hljs-keyword">if</span> (!mountingManager) {
    <span class="hljs-keyword">return</span>;
  }
  <span class="hljs-keyword">if</span> (ReactNativeFeatureFlags::<span class="hljs-built_in">enableAccumulatedUpdatesInRawPropsAndroid</span>()) {
    <span class="hljs-keyword">auto</span> mountingTransaction = mountingCoordinator-&gt;<span class="hljs-built_in">pullTransaction</span>(
        <span class="hljs-comment">/* willPerformAsynchronously = */</span> <span class="hljs-literal">true</span>);
    <span class="hljs-keyword">if</span> (mountingTransaction.<span class="hljs-built_in">has_value</span>()) {
      <span class="hljs-keyword">auto</span> transaction = std::<span class="hljs-built_in">move</span>(*mountingTransaction);
      mountingManager-&gt;<span class="hljs-built_in">executeMount</span>(transaction);
    }
  } <span class="hljs-keyword">else</span> {
    std::vector&lt;MountingTransaction&gt; pendingTransactions;

    {
      <span class="hljs-comment">// 保留锁以访问待处理事务，但不要执行挂载操作，因为该方法可能会再次调用此方法。</span>
      <span class="hljs-comment">//</span>
      <span class="hljs-comment">// 当挂载管理器同步触发状态更新时（例如从 UI 线程提交时），此方法可能会被重入调用。</span>
      <span class="hljs-comment">// 这是安全的，因为我们已经将同一surface ID 的所有事务合并到待处理事务列表中的单个事务中，</span>
      <span class="hljs-comment">// 因此操作不会乱序执行。</span>
      <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(pendingTransactionsMutex_)</span></span>;
      pendingTransactions_.<span class="hljs-built_in">swap</span>(pendingTransactions);
    }

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; transaction : pendingTransactions) {
      mountingManager-&gt;<span class="hljs-built_in">executeMount</span>(transaction);
    }
  }
}
</code></pre>
<p>到这里，最重要的方法是<code>executeMount</code>。该方法负责将 C++ 层的 Shadow Tree 变更（MountingTransaction）转换为 Java 层的视图操作指令，并调度到 UI 线程执行。</p>
<p>具体说，就是将 C++ 的 ShadowViewMutation 转换为 Java 的 MountItem，并序列化传递给 Java 层。该方法的实现非常长，这里仅摘要一部分。源码<code>react-native/packages/react-native/ReactAndroid/src/main/jni/react/fabric/FabricMountingManager.cpp</code>：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FabricMountingManager::executeMount</span><span class="hljs-params">(
    <span class="hljs-type">const</span> MountingTransaction&amp; transaction)</span> </span>{
   <span class="hljs-comment">// 省略......</span>

    <span class="hljs-comment">// 遍历 mutations，将 ShadowViewMutation（Create/Delete/Insert/Remove/Update）转换为 CppMountItem</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; mutation : mutations) {
      <span class="hljs-keyword">auto</span> parentTag = mutation.parentTag;
      <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; oldChildShadowView = mutation.oldChildShadowView;
      <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; newChildShadowView = mutation.newChildShadowView;
      <span class="hljs-keyword">auto</span>&amp; mutationType = mutation.type;
      <span class="hljs-keyword">auto</span>&amp; index = mutation.index;

      <span class="hljs-type">bool</span> isVirtual = mutation.<span class="hljs-built_in">mutatedViewIsVirtual</span>();
      <span class="hljs-keyword">switch</span> (mutationType) {
        <span class="hljs-keyword">case</span> ShadowViewMutation::Create: {
          <span class="hljs-type">bool</span> shouldCreateView =
              !allocatedViewTags.<span class="hljs-built_in">contains</span>(newChildShadowView.tag);

          <span class="hljs-keyword">if</span> (shouldCreateView) {
            cppCommonMountItems.<span class="hljs-built_in">push_back</span>(
                CppMountItem::<span class="hljs-built_in">CreateMountItem</span>(newChildShadowView));
            allocatedViewTags.<span class="hljs-built_in">insert</span>(newChildShadowView.tag);
          }
          <span class="hljs-keyword">break</span>;
        }
        <span class="hljs-keyword">case</span> ShadowViewMutation::Remove: {
          <span class="hljs-keyword">if</span> (!isVirtual) {
            cppCommonMountItems.<span class="hljs-built_in">push_back</span>(
                CppMountItem::<span class="hljs-built_in">RemoveMountItem</span>(
                    parentTag, oldChildShadowView, index));
          }
          <span class="hljs-keyword">break</span>;
        }
        <span class="hljs-keyword">case</span> ShadowViewMutation::Delete: {
          (maintainMutationOrder ? cppCommonMountItems : cppDeleteMountItems)
              .<span class="hljs-built_in">push_back</span>(CppMountItem::<span class="hljs-built_in">DeleteMountItem</span>(oldChildShadowView));
          <span class="hljs-keyword">if</span> (allocatedViewTags.<span class="hljs-built_in">erase</span>(oldChildShadowView.tag) != <span class="hljs-number">1</span>) {
            <span class="hljs-built_in">LOG</span>(ERROR) &lt;&lt; <span class="hljs-string">"Emitting delete for unallocated view "</span>
                       &lt;&lt; oldChildShadowView.tag;
          }
          <span class="hljs-keyword">break</span>;
        }
        <span class="hljs-comment">// 省略代码......</span>

        <span class="hljs-keyword">default</span>: {
          <span class="hljs-keyword">break</span>;
        }
      }
    }
  }

  <span class="hljs-comment">// 现在我们已经掌握了所有必要的信息，包括挂载项的顺序，因此可以准确地知道需要分配多少空间。</span>
  <span class="hljs-keyword">auto</span> [batchMountItemIntsSize, batchMountItemObjectsSize] = <span class="hljs-built_in">computeBufferSizes</span>(
      cppCommonMountItems,
      cppDeleteMountItems,
      cppUpdatePropsMountItems,
      cppUpdateStateMountItems,
      cppUpdatePaddingMountItems,
      cppUpdateLayoutMountItems,
      cppUpdateOverflowInsetMountItems,
      cppUpdateEventEmitterMountItems);

  <span class="hljs-type">static</span> <span class="hljs-keyword">auto</span> scheduleMountItem = JFabricUIManager::<span class="hljs-built_in">javaClassStatic</span>()
                                      -&gt;<span class="hljs-built_in">getMethod</span>&lt;<span class="hljs-built_in">void</span>(
                                          JMountItem::javaobject,
                                          jint,
                                          jlong,
                                          jlong,
                                          jlong,
                                          jlong,
                                          jlong,
                                          jlong,
                                          jlong,
                                          jint)&gt;(<span class="hljs-string">"scheduleMountItem"</span>);

  <span class="hljs-comment">// 省略</span>

  <span class="hljs-comment">// 调用 JFabricUIManager.createIntBufferBatchMountItem() 创建 Java 对象</span>
  <span class="hljs-comment">// 将序列化数据传递给 Java 层</span>
  <span class="hljs-type">static</span> <span class="hljs-keyword">auto</span> createMountItemsIntBufferBatchContainer =
      JFabricUIManager::<span class="hljs-built_in">javaClassStatic</span>()
          -&gt;getMethod&lt;jni::<span class="hljs-built_in">alias_ref</span>&lt;JMountItem&gt;(
              jint, jintArray, jni::jtypeArray&lt;jobject&gt;, jint)&gt;(
              <span class="hljs-string">"createIntBufferBatchMountItem"</span>);
  <span class="hljs-keyword">auto</span> batch = <span class="hljs-built_in">createMountItemsIntBufferBatchContainer</span>(
      javaUIManager_,
      surfaceId,
      <span class="hljs-comment">// If there are no items, we pass a nullptr instead of passing the</span>
      <span class="hljs-comment">// object through the JNI</span>
      batchMountItemIntsSize &gt; <span class="hljs-number">0</span> ? buffer.ints : <span class="hljs-literal">nullptr</span>,
      batchMountItemObjectsSize &gt; <span class="hljs-number">0</span> ? buffer.objects.<span class="hljs-built_in">get</span>() : <span class="hljs-literal">nullptr</span>,
      revisionNumber);

  <span class="hljs-keyword">auto</span> finishTransactionEndTime = <span class="hljs-built_in">telemetryTimePointNow</span>();

  <span class="hljs-comment">// 调度到 UI 线程，将 BatchMountItem 发送到 Java 层</span>
  <span class="hljs-built_in">scheduleMountItem</span>(
      javaUIManager_,
      batch.<span class="hljs-built_in">get</span>(),
      telemetry.<span class="hljs-built_in">getRevisionNumber</span>(),
      <span class="hljs-built_in">telemetryTimePointToMilliseconds</span>(telemetry.<span class="hljs-built_in">getCommitStartTime</span>()),
      <span class="hljs-built_in">telemetryTimePointToMilliseconds</span>(telemetry.<span class="hljs-built_in">getDiffStartTime</span>()),
      <span class="hljs-built_in">telemetryTimePointToMilliseconds</span>(telemetry.<span class="hljs-built_in">getDiffEndTime</span>()),
      <span class="hljs-built_in">telemetryTimePointToMilliseconds</span>(telemetry.<span class="hljs-built_in">getLayoutStartTime</span>()),
      <span class="hljs-built_in">telemetryTimePointToMilliseconds</span>(telemetry.<span class="hljs-built_in">getLayoutEndTime</span>()),
      <span class="hljs-built_in">telemetryTimePointToMilliseconds</span>(finishTransactionStartTime),
      <span class="hljs-built_in">telemetryTimePointToMilliseconds</span>(finishTransactionEndTime),
      telemetry.<span class="hljs-built_in">getAffectedLayoutNodesCount</span>());

  env-&gt;<span class="hljs-built_in">DeleteLocalRef</span>(buffer.ints);
}
</code></pre>
<p>可以看到，在此方法中反射调用了上层的<code>scheduleMountItem</code>，与我们前面分析的结果对接上了。</p>
<p>总的来说，该方法充当 C++ Shadow Tree 与 Java 原生视图之间的桥梁，将 React 的声明式变更转换为 Android 视图操作指令，并调度到 UI 线程执行，实现从虚拟树到真实视图的映射。</p>
<blockquote>
<p>由于单章字数限制，这里将本文拆成上下两篇，下篇<a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer">《React Native之Android端Fabric 架构源码分析（下）》</a></p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[AI Agent框架探秘：拆解 OpenHands（1）--- 核心理念]]></title>    <link>https://juejin.cn/post/7596904122865336371</link>    <guid>https://juejin.cn/post/7596904122865336371</guid>    <pubDate>2026-01-19T13:13:51.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7596904122865336371" data-draft-id="7595890117865898030" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="AI Agent框架探秘：拆解 OpenHands（1）--- 核心理念"/> <meta itemprop="keywords" content="算法,机器学习"/> <meta itemprop="datePublished" content="2026-01-19T13:13:51.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="罗西的思考"/> <meta itemprop="url" content="https://juejin.cn/user/351470467691175"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            AI Agent框架探秘：拆解 OpenHands（1）--- 核心理念
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/351470467691175/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    罗西的思考
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-19T13:13:51.000Z" title="Mon Jan 19 2026 13:13:51 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读20分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">AI Agent框架探秘：拆解 OpenHands（1）--- 核心理念</h2>
<ul>
<li>
<p><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer">0x00 摘要</a></p>
</li>
<li>
<p><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer">0x01 背景</a></p>
<ul>
<li><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer">1.1 什么是Agent</a></li>
<li><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer">1.2 Agent工程的重要性</a></li>
<li><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer">1.3 架构才是竞争优势</a></li>
</ul>
</li>
<li>
<p><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer">0x02 AI Agent 系统</a></p>
<ul>
<li><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer">2.1 架构设计的难点</a></li>
<li><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer">2.2 核心组件</a></li>
<li><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer">2.3 Devin &amp; OpenHands（原OpenDevin）</a></li>
</ul>
</li>
<li>
<p><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer">0x03 OpenHands 架构概念图谱</a></p>
<ul>
<li><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer">3.1 系统架构</a></li>
<li><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer">3.2 代码库目录结构</a></li>
<li><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer">3.3 核心组件</a></li>
</ul>
</li>
<li>
<p><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer">0xFF 参考</a></p>
</li>
</ul>
<p>自本文起，我们将开启一个新的系列，以OpenHands（原 OpenDevin）为例，深入剖析Agent框架。</p>
<p>写这个系列的原因，是因为和几个同学讨论Agent系统，但是总觉得自己讲得浮于表面，兄弟们好像也没有很理解。因此决定再系统梳理一下。</p>
<p>因为本系列借鉴的文章过多，可能在参考文献中有遗漏的文章，如果有，还请大家指出。</p>
<h3 data-id="heading-1">0x00 摘要</h3>
<p>掌握Agent的底层逻辑，不仅是熟练使用的基础，更是设计、评估和扩展的关键。对于产品经理、人工智能工程师和技术决策者来说，只有深入理解Agent的技术蓝图，才能在AI应用的落地过程中做出精准布局，抓住未来的机遇。我们希望从技术底层出发，深入探讨以下关键问题：</p>
<ul>
<li>构建一个实用的AI Agent需要哪些核心技术模块的支持？</li>
<li>这些核心模块如何协同工作，形成完整的任务执行闭环？</li>
<li>AI Agent系统在落地过程中会面临哪些关键挑战，OpenHands如何解决这些工程化难题？</li>
</ul>
<p>我们希望通过这一场深入的“拆解”之旅，超越表层功能的演示，直接触及其架构的基石。</p>
<p>之所以分析OpenHands，是因为OpenHands（前身为 OpenDevin）作为开源的 AI 软件开发代理框架，在功能、架构和兼容性等方面均具备鲜明特色，且从入门难度、学习价值和实践场景来看，它十分适合用来学习 Agent 框架。具体特色如下：</p>
<ul>
<li><strong>入门门槛低，上手难度小</strong>：支持自然语言交互，开发者无需复杂编码即可下达开发任务，降低初期学习成本。同时提供 GUI 和 CLI 等友好界面，还有详尽的实战案例和清晰的文档，便于理解 Agent 与工具、LLM 的协同逻辑。且基于 MIT 许可完全开源，可自由查看 Agent 调度、任务编排等核心源码。</li>
<li><strong>覆盖 Agent 核心知识体系</strong>：学习它能掌握多 Agent 协作、任务拆解、工具调用、沙盒安全控制等 Agent 框架的核心技术点。其与网页交互、API 集成、代码处理等实战场景结合紧密，能帮助学习者理解 Agent 在真实开发流程中的落地逻辑。</li>
<li><strong>兼具学习与落地价值</strong>：既能用于简单的 Agent 原型搭建，快速验证想法；也能支撑大规模Agent的可靠部署，适配从学习测试到生产应用的全流程。此外，与主流 Agent SDK 相比，其独特的沙盒化生产服务器、远程执行等特性，能让学习者接触到更全面的 Agent 进阶能力，提升技术竞争力。</li>
</ul>
<h3 data-id="heading-2">0x01 背景</h3>
<p>当我们讨论AI Agent系统的技术时，需要先理解一个关键问题：真正让系统有竞争力的，是那些一眼能看到的“智能功能”，还是背后支撑一切平稳运行的“工作流架构”？这个答案不仅决定了该先研发什么，更关乎系统能不能打造出别人抄不走的长期优势。</p>
<h4 data-id="heading-3">1.1 什么是Agent</h4>
<p>Agent的定义具有多元视角：</p>
<ul>
<li>有人将其界定为可长期自主运行、借助各类工具完成复杂任务的独立系统；</li>
<li>有人认为Agent是可以在最小人工干预下完成「感知 → 规划 → 行动 → 反馈」闭环的Agent，既能解析自然语言目标，又能调用搜索引擎、数据库等外部工具。</li>
<li>有人则将其理解为遵循预设工作流程的规范化实现方案。</li>
</ul>
<p>Anthropic 将这些不同形态的系统统一归为 “Agent系统（agentic systems）”，同时从架构层面明确区分了 “工作流程（Workflows）” 与 “Agent” 这两个核心概念。具体来看：</p>
<ul>
<li>工作流是编码”如何做“：工作流程类系统如同按照固定剧本演出的舞台剧，大语言模型（LLMs）与各类工具的协作完全遵循预先编写的代码路径推进；</li>
<li>Agent是编码”做什么“：Agent系统则更像拥有自主决策能力的项目经理，由大语言模型动态主导流程走向与工具调用，全程掌控任务的执行方式。</li>
</ul>
<p>随着大语言模型在四大关键能力上的日趋成熟 —— 包括复杂输入理解、逻辑推理与任务规划、可靠工具调用以及错误恢复能力，Agent已在生产场景中逐步落地应用。其工作流程通常始于人类用户的指令或交互式沟通，待任务目标明确后，便自主开展规划与执行操作，过程中若需补充信息或寻求判断，会主动向人类用户发起请求。在每一步执行环节，Agent必须从环境中获取 “真实数据（Ground Truth）”—— 比如工具调用返回结果或代码运行输出 —— 以此评估任务进展。当抵达预设检查点或遭遇执行阻碍时，Agent可暂停操作以获取人类反馈。任务一般在完成后终止，同时也会设置停止条件（如最大迭代次数）来确保过程可控。</p>
<h4 data-id="heading-4">1.2 Agent工程的重要性</h4>
<p>Agent的实现逻辑相对简洁，本质上是大语言模型在 “环境反馈 - 工具调用” 的循环中持续运作。Agent系统的核心构建模块是一个增强功能的大语言模型（LLM），它能够主动地利用检索、工具和记忆等能力来优化其功能。对于绝大部分应用程序来说，通过检索（RAG）和在 prompt 中添加上下文示例（Prompt Engineering）来优化单个 LLM 调用通常就足够了。</p>
<p>虽然只要提供一堆工具和prompt，agent就可以自行探索-分析-决策-执行直到解决任务。从宏观角度上来说这样并没有错，但让LLM控制一切的结果就是，不完善的prompt和tools带来了无限循环和放飞自我。因此，尽管AI模型是Agent的“大脑”，但要实现生产级的落地，Agent工程才是关键支撑。Rakesh Gohel发布的“AI Agent冰山模型”指出：构建一个真正可用的Agent，90%的工作是软件工程，仅10%是AI技术：</p>
<ul>
<li>“10% AI”：AI模型只是Agent的“大脑”：理解任务、规划步骤、生成内容。</li>
<li>“90% Engineering”：工程是支撑Agent的整个“身体和神经系统”，包括用户交互、权限控制、任务编排、工具调用、日志、异常回滚等。</li>
</ul>
<p>在这背后，一整套系统化的Agent架构，正悄然决定着这些Agent的效率、扩展性和演化方向。如果将大语言模型（LLM）比作AI的发动机，那么“Agent架构”就是决定AI能走多远的底盘和驾驶系统。</p>
<h4 data-id="heading-5">1.3 架构才是竞争优势</h4>
<p>AI Agent不是一款单一产品，而是一种全新的软件形态——它不是“更聪明的机器人”，而是“能自主协作的数字个体”。其技术难点不在于“想象力”，而在于“工程落地能力”。未来，真正引领Agent发展的，必然是那些既懂AI技术，又精通系统架构的“Agent工匠”。Agent架构，已成为下一代AI应用的核心竞争赛道。能否理解“Memory-Plan-Tool-Reflection”的协同逻辑，能否构建“透明、可控、可扩展”的任务系统，决定了一个团队是否具备打造实用Agent应用的核心能力。</p>
<p>拿browerAgent来说，它们能生成代码、跟网页互动，看着很厉害，但这些能力其实靠三个外部条件撑着 —— 而这三个条件现在行业里正变得越来越通用。</p>
<ul>
<li>基础模型能力人人能用。未来大语言模型能力越来越强，AI Agent能做的功能会越来越容易实现，慢慢变成行业标配。这么一来，不同系统在 “智能” 上的差距越来越小。</li>
<li>提示词技巧容易复制。没法成为独家优势。</li>
<li>工具调用越来越标准化。Agent 调用工具的能力，本质就是用别人的 API 接口。任何团队都能直接集成现成工具，补全自己的功能短板，这方面的竞争慢慢变得千篇一律。</li>
</ul>
<p>真正的技术壁垒，从来都是打造一个稳定、能控制、能监控、能扩展的底层运行环境。这需要团队有深厚的技术积累、能搞定复杂系统，还得一直迭代应对新问题。这些问题是AI跟现实世界互动时天生就有的，不会因为模型变强就自动消失，反而会决定系统稳不稳定、靠不靠谱。谁能解决状态管理、工具容错、计划可控、行为透明这些“系统级痛点”，谁就能在Agent技术革命中占据主动。</p>
<p>未来AI Agent系统的竞争，会从“谁能做什么”的功能比拼，变成“谁能做得更稳、更好、更长久”的工程实力较量——说白了，工程实力才决定长期竞争力。</p>
<h3 data-id="heading-6">0x02 AI Agent 系统</h3>
<p>构建一套成熟的 AI Agent Framework，本质是打造一个能支撑Agent自主感知、环境感知、决策制定、动作执行、自我进化的 “数字生命体” 基础设施。其核心在于拆解Agent的核心能力模块，明确各组件的职责边界与协作逻辑，同时攻克系统稳定性、灵活性与实用性的关键瓶颈。Agent系统核心涵盖四大能力：</p>
<ul>
<li>通过 Function Call、MCP 协议等工具调用实现环境交互感知；</li>
<li>借助 ReAct、Reflexion 等方法完成自主推理决策；</li>
<li>采用短期记忆（依托 Prompt / 上下文窗口）与长期记忆（通过 RAG 和向量数据库管理）的范式进行知识管理；</li>
<li>通过 A2A、ACP、ANP 等协议达成多Agent间的通信协作。</li>
</ul>
<h4 data-id="heading-7">2.1 架构设计的难点</h4>
<p>大模型本质是概率输出，这种“概率本性”带来的三位一体风险</p>
<ul>
<li>不一致性：同一输入多次采样结果发散。</li>
<li>不真实性：幻觉导致事实错误。</li>
<li>不及时性：静态训练数据过期。</li>
</ul>
<p>这样导致 Agent 带来的的四大硬核卡点为：</p>
<ol>
<li>记忆断片。单纯的Agent缺少专门的任务状态感知机制，仅靠上下文拼接无法稳定跟踪长流程任务。比如，多步任务里， “中间态”只躺在 LLM 的上下文窗口里，既没有结构化存储，也没有显式语义索引。</li>
<li>一错就躺。单纯的Agent 缺乏工具调用的异常感知与容错机制，</li>
<li>黑箱拆包。LLM 直接吐出自然语言计划，开发者无法插拔，更无法验证，只能在执行末端才发现。</li>
<li>审计黑洞。Agent 调了谁、取了什么字段、基于哪句用户提示做决策，全程无留痕，企业合规无从谈起。</li>
</ol>
<p>因此，Agent 的竞争正离开“谁能调用更多 API”，转向“谁能把不确定的模型封装成确定性的系统”。把概率装进状态机，把幻觉关进审计笼，把成本压进预算表——这才是Agent 系统的真正门槛。</p>
<h4 data-id="heading-8">2.2 核心组件</h4>
<p>Agent绝非单一语言模型的增强版，LLM仅相当于其 “认知中枢”，真正支撑其完整功能的是一套协同运作的多模块架构，成熟可落地的Agent系统至少包含几大核心模块，各模块如同精密团队中的不同角色，各司其职又紧密配合。</p>
<ul>
<li>规划与决策引擎（Planner / Policy）。LLM 作为 “认知中枢”，就像团队里的 “智囊团”，核心负责解析用户任务意图、把用户的“复杂终极目标”切成“可执行的子任务序列”，拆解复杂任务为子任务、明确子任务的依赖关系、生成代码、报告等输出内容。即支持一次性静态计划、也支持 ReAct / CodeAct 这种逐步展开，即支持动态计划调整：根据工具调用结果、环境变化或用户反馈，实时修正子任务流程，避免计划与实际执行脱节。</li>
<li>Memory 模块是 “上下文延续器”，负责存储对话上下文、任务执行关键节点与进度、历史经验等信息，保障任务执行的连贯性。用于存储对话历史、中间结果和长期记忆。这样，通过在Prompt中引入对前文的总结或关键数据，Agent能“记住”先前步骤的结果，确保状态的一致性和跨步骤的上下文衔接。</li>
<li>Planner 模块扮演 “行动路线图” 的角色。其实现机制包括基于规则的固定流程（适用于标准化任务）、依托 LLM 推理能力的动态生成（适用于灵活需求），以及结合二者优势的混合型调度（如基于 LangGraph 构建有向图任务流）。</li>
<li>Tool-use 模块是Agent的 “手脚”，让模型“看到”工具，而不是“摸黑”调用，打破了仅输出文本的局限，通过调用第三方 API、检索外部知识库、读写本地文件等方式连接外部资源，完成实际操作。</li>
<li>Reflection 模块赋予Agent “元认知能力”，如同团队的 “复盘专员”，在任务失败或受阻时，对比执行结果与预期，评估执行效果、定位问题原因并调整策略。</li>
</ul>
<p>这几大模块相辅相成，构成 “状态驱动 + 意图分解 + 工具调用 + 自我学习” 的有机整体，而非简单叠加。</p>
<p>另外，在具体实现中，通常也会有如下组件：</p>
<ul>
<li>事件总线（Event Bus）：用于解耦，将用户消息、工具返回、状态变更、异常报告都序列化为事件，广播给订阅者。</li>
<li>运行时沙箱（Runtime Sandbox）：给模型提供“动手”空间——文件系统、网络、Shell、Python 解释器、第三方库。</li>
<li>观测与遥测（Observability）：提供可视化的任务执行界面，展示任务流程、子任务进度、模块交互日志，支持开发者实时监控，让运维者看到「黑盒」——每次调用链、token 消耗、异常栈、决策理由全部落盘。</li>
<li>配置与存储模块（Config &amp; Storage）：管理框架的全局配置，如 LLM 参数、任务预算（最大迭代次数、成本上限）、存储路径、工具列表等，支持动态配置更新。实现数据持久化，包括任务状态、执行轨迹、记忆数据、配置信息等，确保系统重启后可恢复。</li>
</ul>
<h4 data-id="heading-9">2.3 Devin &amp; OpenHands（原OpenDevin）</h4>
<p>‌Devin是由Cognition AI开发的全球首个AI程序员，具备全栈开发能力，能自主完成代码编写、调试、部署及AI模型训练等任务‌。Devin 代表了一种先进的自主Agent，旨在应对软件工程的复杂性。它利用了诸如 shell、代码编辑器和网络浏览器等工具的组合，展示了 LLM 在软件开发中未被充分利用的潜力。</p>
<p>OpenDevin 项目诞生于复制、增强并创新原始 Devin 模型的愿望。OpenDevin 的目标是探索并扩展 Devin 的能力，识别其优势和改进领域，以指导开放代码模型的进展。通过吸引开源社区的参与，OpenDevin 旨在应对 Code LLM 在实际场景中面临的挑战，产出对社区有重大贡献的作品，并为未来的进步铺平道路。</p>
<p>OpenHands 目前 GitHub 星标数已超 6.5 万。</p>
<p>OpenHands 的网址为：<a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.openhands.dev%2F" target="_blank" title="https://docs.openhands.dev/" ref="nofollow noopener noreferrer">docs.openhands.dev/</a></p>
<p>github 链接为：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FOpenHands%2FOpenHands" target="_blank" title="https://github.com/OpenHands/OpenHands" ref="nofollow noopener noreferrer">github.com/OpenHands/O…</a></p>
<p>Software Agent SDK: <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FOpenHands%2Fsoftware-agent-sdk" target="_blank" title="https://github.com/OpenHands/software-agent-sdk" ref="nofollow noopener noreferrer">github.com/OpenHands/s…</a></p>
<p>Benchmarks: <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FOpenHands%2Fbenchmarks" target="_blank" title="https://github.com/OpenHands/benchmarks" ref="nofollow noopener noreferrer">github.com/OpenHands/b…</a></p>
<p>最新的OpenHands论文如下：The OpenHands Software Agent SDK: A Composable and Extensible Foundation for Production Agents 2511.03690v1</p>
<h3 data-id="heading-10">0x03 OpenHands 架构概念图谱</h3>
<p>为精准解锁 OpenHands 源码的深层逻辑，我们需要构建一幅清晰的架构概念图谱，将分散的核心组件与设计理念串联成有机整体。这一图谱的每一环都承载着关键使命，共同构筑起 AI Agent高效运行的基础。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/925c40e26e404219a90815f978073242~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg572X6KW_55qE5oCd6ICD:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769433231&amp;x-signature=i0kkI%2FkSx1lWdzpnEpx9dZ88Vbg%3D" alt="OpenHands-组件" loading="lazy"/></p>
<p>OpenHands-组件</p>
<h4 data-id="heading-11">3.1 系统架构</h4>
<p>下图是OpenHands 系统架构的高级概览。系统分为两个主要部分：前端和后端。前端负责处理用户交互并展示结果。后端负责处理业务逻辑并执行Agent操作。这种架构的关键优势在于其灵活性和可扩展性：新的Agent类型、行动类型或运行时环境可以轻松集成到现有系统中。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/db7b3e9538454b13b5fa379a1404082c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg572X6KW_55qE5oCd6ICD:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769433231&amp;x-signature=Wdog2eIcVxiOo8dCIg05C2n4NMo%3D" alt="OpenHands-Overview" loading="lazy"/></p>
<p>OpenHands-Overview</p>
<p>后端架构如下：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9de55afa100f4b4da11e095b63f9c040~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg572X6KW_55qE5oCd6ICD:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769433231&amp;x-signature=SgOqx4sN5kh3xZzybM%2BTNRROM%2BM%3D" alt="OpenHands-类图" loading="lazy"/></p>
<p>OpenHands-类图</p>
<h4 data-id="heading-12">3.2 代码库目录结构</h4>
<p>OpenHands的代码库组织清晰，以下是最主要的目录：</p>
<ol>
<li><strong>Agent中心（agenthub）</strong> ：这是Agent的核心区域，负责代码生成和执行相关的逻辑，是平台的核心能力载体。它包含专注于代码生成与执行的Agent逻辑，是平台的核心能力所在。此外，还包括负责浏览器交互的Agent实现。</li>
<li><strong>事件系统（events）</strong> ：这是事件驱动架构的核心目录，定义了系统的“通信语言”。它包含封装任务执行结果等反馈类事件的<code>observation/</code>，以及定义Agent可执行的各类动作指令的<code>action/</code>。<code>stream.py</code>实现了事件流的管理机制，负责事件的分发、存储与订阅，是组件协同工作的关键枢纽。</li>
<li><strong>运行时环境（runtime/）</strong> ：提供Agent执行的底层环境支持。<code>impl/</code>目录包含Docker容器、本地环境等不同运行时的具体实现；<code>plugins/</code>支持通过插件扩展运行时功能，提升系统的灵活性。</li>
<li><strong>记忆管理（memory/）</strong> ：负责管理Agent的历史数据与记忆。<code>conversation_memory.py</code>处理对话历史的存储与检索；<code>condenser/</code>实现历史记录的压缩逻辑，解决LLM上下文窗口有限的问题，保障长周期任务的连贯性。</li>
<li><strong>语言模型集成（llm/）</strong> ：实现与各类大型语言模型的集成。</li>
<li><strong>控制器（controller/）</strong> ：系统的“指挥中心”，负责Agent的调度与管理。</li>
</ol>
<p>这种结构反映了OpenHands的模块化设计，各组件之间有明确的职责划分，便于维护和扩展。这些目录之间的逻辑结构大致如下：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a63591e152704c359a97d25106ff75c8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg572X6KW_55qE5oCd6ICD:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769433231&amp;x-signature=0DaHoHsOiI3pFWaaHRv7v4ByaIA%3D" alt="OpenHands-总体流程" loading="lazy"/></p>
<p>OpenHands-总体流程</p>
<h4 data-id="heading-13">3.3 核心组件</h4>
<p>OpenHands采用了一种基于事件的架构，将Agent、运行时环境和用户界面解耦，实现灵活的交互模式。OpenHands 的关键类包括：</p>
<ul>
<li>
<p><strong>LLM</strong>：负责与大型语言模型的所有交互。由于 LiteLLM 的支持，它可以与任何底层完成模型一起工作。</p>
</li>
<li>
<p><strong>Agent</strong>：负责查看当前状态，并产生一个动作，使目标更进一步接近最终目标。</p>
</li>
<li>
<p><strong>AgentController</strong>：初始化 Agent，管理状态，并驱动主要循环，一步步推动 Agent 前进。</p>
</li>
<li>
<p><strong>State</strong>：代表 Agent 任务的当前状态。包括当前步骤、最近事件的历史记录、Agent的长期计划等。State 模块就像 Agent 的 “记忆大脑”，不仅能记下任务执行中的各种状态数据，还支持断点恢复，长周期任务就算中断了，也能接着之前的进度继续做，不用从头再来。</p>
</li>
<li>
<p><strong>EventStream</strong>：事件的中心枢纽，任何组件都可以发布事件，或监听其他组件发布的事件。</p>
<ul>
<li>
<p><strong>Event</strong>：动作或观察</p>
<ul>
<li><strong>Action</strong>：代表一个请求，例如编辑文件、运行命令或发送消息。</li>
<li><strong>Observation</strong>：代表从环境中收集的信息，例如文件内容或命令输出。</li>
</ul>
</li>
<li>
<p>Action 和 Observation 相当于组件间的 “通用语言”——Action 带着要执行的指令，Observation 传回执行的结果，俩者配合到位，信息传递才顺畅不卡壳。这些模块不是各干各的，而是靠 Event Stream 这个 “核心枢纽” 连在一起协同工作 —— 各种事件都在这里汇聚、分发，推着任务按计划一步步走，最终让 AI Agent有能力处理复杂任务。</p>
</li>
<li>
<p>ReAct 范式就像是 Agent 的 “行为准则”，定下了 “先思考、再行动、收反馈” 的核心逻辑，确保它做决策时有条理、不混乱。事件驱动模型则搭起了系统的 “骨架”，所有交互都靠事件流转来推进，各个模块不用硬绑在一起，能灵活应对各种情况。</p>
</li>
</ul>
</li>
<li>
<p><strong>Runtime</strong>：负责执行动作，并发送回观察结果。</p>
<ul>
<li><strong>Sandbox</strong>：运行命令的运行时环境部分，例如在 Docker 内部。</li>
<li>Runtime 和 Memory 这些组件是系统的关键 “器官”：Runtime 会提供一个隔离的执行环境，保证代码运行时安全又稳定，不会搞乱其他部分；Memory 则把历史数据管得明明白白，给 Agent 做决策提供过往经验。</li>
</ul>
</li>
<li>
<p><strong>Server</strong>：通过 HTTP 管理 OpenHands 会话，例如驱动前端。</p>
<ul>
<li><strong>Session</strong>：保存单个 EventStream、单个 AgentController 和单个 Runtime。通常代表一个单一任务（但可能包括几个用户提示）。</li>
<li><strong>ConversationManager</strong>：维护一个活动会话列表，并确保请求被路由到正确的会话。</li>
</ul>
</li>
</ul>
<p>核心组件交互关系如下：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b429c27dcc1a402a97f3e1f30be19f4b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg572X6KW_55qE5oCd6ICD:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769433231&amp;x-signature=MDZTJJA8bynUXkh9gEBZhDAxE9Y%3D" alt="OpenHands-核心组件交互关系" loading="lazy"/></p>
<p>OpenHands-核心组件交互关系</p>
<p>这个流程展示了 OpenHands 作为一个 AI 软件开发Agent平台的完整架构，从用户交互到核心执行的完整数据流和组件关系。</p>
<ol>
<li>
<p>用户输入阶段</p>
<ol>
<li>用户通过 Web 界面、CLI 或 API 发起请求</li>
<li>服务器接收请求并创建会话</li>
<li>事件通过事件流系统传递</li>
</ol>
</li>
<li>
<p>Agent 处理阶段</p>
<ol>
<li>Controller 根据配置初始化相应 Agent</li>
<li>Agent 基于当前状态和历史生成决策</li>
<li>通过工具系统执行具体操作</li>
</ol>
</li>
<li>
<p>执行阶段</p>
<ol>
<li>Runtime 环境执行具体命令或代码</li>
<li>插件系统提供额外功能支持</li>
<li>安全系统监控执行过程</li>
</ol>
</li>
<li>
<p>反馈阶段</p>
<ol>
<li>执行结果作为 Observation 返回</li>
<li>更新 Agent 状态和记忆</li>
<li>将结果返回给用户</li>
</ol>
</li>
</ol>
<h3 data-id="heading-14">0xFF 参考</h3>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.all-hands.dev%2Fopenhands%2Fusage%2Farchitecture%2Fbackend" target="_blank" title="https://docs.all-hands.dev/openhands/usage/architecture/backend" ref="nofollow noopener noreferrer">docs.all-hands.dev/openhands/u…</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F1936485868761257658" target="_blank" title="https://zhuanlan.zhihu.com/p/1936485868761257658" ref="nofollow noopener noreferrer">当AI Agent从“玩具”走向“工具”，我们该关注什么？Openhands架构解析【第二篇：Agent 相关核心概念】</a> <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.zhihu.com%2Fpeople%2Fdreamrenderx" target="_blank" title="https://www.zhihu.com/people/dreamrenderx" ref="nofollow noopener noreferrer">克里</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F1936175201323825087" target="_blank" title="https://zhuanlan.zhihu.com/p/1936175201323825087" ref="nofollow noopener noreferrer">当AI Agent从“玩具”走向“工具”，我们该关注什么？Openhands架构解析【第一篇：系列导读】</a> <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.zhihu.com%2Fpeople%2Fdreamrenderx" target="_blank" title="https://www.zhihu.com/people/dreamrenderx" ref="nofollow noopener noreferrer">克里</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F1940436682949244630" target="_blank" title="https://zhuanlan.zhihu.com/p/1940436682949244630" ref="nofollow noopener noreferrer">Coding Agent之Openhands解析(含代码)</a> <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.zhihu.com%2Fpeople%2Fwu-long-ming-cha-56" target="_blank" title="https://www.zhihu.com/people/wu-long-ming-cha-56" ref="nofollow noopener noreferrer">Arrow</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F1940824548485347192" target="_blank" title="https://zhuanlan.zhihu.com/p/1940824548485347192" ref="nofollow noopener noreferrer">OpenHands 源码解读</a> <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.zhihu.com%2Fpeople%2Fxiao-hui-66-72" target="_blank" title="https://www.zhihu.com/people/xiao-hui-66-72" ref="nofollow noopener noreferrer">一力辉</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F1968688671378093192" target="_blank" title="https://zhuanlan.zhihu.com/p/1968688671378093192" ref="nofollow noopener noreferrer">【Agent工程】01-Agent工程技术洞察、挑战以及解决方案</a> <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.zhihu.com%2Fpeople%2Fwldandan" target="_blank" title="https://www.zhihu.com/people/wldandan" ref="nofollow noopener noreferrer">王磊</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.anthropic.com%2Fengineering%2Fbuilding-effective-agents" target="_blank" title="https://www.anthropic.com/engineering/building-effective-agents" ref="nofollow noopener noreferrer">Building effective agents</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F-BvGnwEbgrFknZ6I-pYfjw" target="_blank" title="https://mp.weixin.qq.com/s/-BvGnwEbgrFknZ6I-pYfjw" ref="nofollow noopener noreferrer">从代码生成到自主决策：打造一个Coding驱动的“自我编程”Agent</a> 阿里云开发者</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F1951318616042631326" target="_blank" title="https://zhuanlan.zhihu.com/p/1951318616042631326" ref="nofollow noopener noreferrer">从 Prompt 到 Context：基于 1400+ 论文的 Context Engineering 系统综述</a> 阿里云开发者</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F1948375162039804773" target="_blank" title="https://zhuanlan.zhihu.com/p/1948375162039804773" ref="nofollow noopener noreferrer">Claude Code 深度拆解：一个顶级AI编程工具的核心架构</a> 阿里云开发者</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzk0MjIwODQ2NA%3D%3D%26mid%3D2247485335%26idx%3D1%26sn%3D2966d272496d757696401d0b27b7a97a%26chksm%3Dc39a89bf69181b5351ee005d9915f4421191b6eb9b8d7833bf5a20eebc74772114da3f41133a%26mpshare%3D1%26scene%3D1%26srcid%3D11156OroWY1YJfDyRmvO25A5%26sharer_shareinfo%3D4415f8a41c58f4e4f12e4cedde93066e%26sharer_shareinfo_first%3D4415f8a41c58f4e4f12e4cedde93066e%23rd" target="_blank" title="https://mp.weixin.qq.com/s?__biz=Mzk0MjIwODQ2NA==&amp;mid=2247485335&amp;idx=1&amp;sn=2966d272496d757696401d0b27b7a97a&amp;chksm=c39a89bf69181b5351ee005d9915f4421191b6eb9b8d7833bf5a20eebc74772114da3f41133a&amp;mpshare=1&amp;scene=1&amp;srcid=11156OroWY1YJfDyRmvO25A5&amp;sharer_shareinfo=4415f8a41c58f4e4f12e4cedde93066e&amp;sharer_shareinfo_first=4415f8a41c58f4e4f12e4cedde93066e#rd" ref="nofollow noopener noreferrer">从思考到行动：深度解析类Manus AI Agent架构设计与未来演进</a> AnthroTech AI</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F703618853" target="_blank" title="https://zhuanlan.zhihu.com/p/703618853" ref="nofollow noopener noreferrer">AI程序员之OpenDevin源码剖析</a> <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.zhihu.com%2Fpeople%2Fzheng-guo-hua-82" target="_blank" title="https://www.zhihu.com/people/zheng-guo-hua-82" ref="nofollow noopener noreferrer">goofy</a></p>
<p>The OpenHands Software Agent SDK: A Composable and Extensible Foundation for Production Agents 2511.03690v1</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fassets.jimmysong.io%2Fbooks%2Fmachine-learning-systems-zh-20251023.pdf" target="_blank" title="https://assets.jimmysong.io/books/machine-learning-systems-zh-20251023.pdf" ref="nofollow noopener noreferrer">机器学习系统教程 AI ⼯程原理与实践</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fxindoo%2Fagentic-design-patterns" target="_blank" title="https://github.com/xindoo/agentic-design-patterns" ref="nofollow noopener noreferrer">Agentic Design Patterns（中文翻译项目）</a></p>
<p>AI原生应用架构白皮书</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F1977044815716832440" target="_blank" title="https://zhuanlan.zhihu.com/p/1977044815716832440" ref="nofollow noopener noreferrer">2025必看系列：AI如何重新定义研究？万字长文讲透「Deep Research」</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F1975514242754049684" target="_blank" title="https://zhuanlan.zhihu.com/p/1975514242754049684" ref="nofollow noopener noreferrer">Agent开发实践：从想法到产品——SSE、上下文工程与流式解析关键技术攻坚</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F1976305837011116648" target="_blank" title="https://zhuanlan.zhihu.com/p/1976305837011116648" ref="nofollow noopener noreferrer">深入AI Agent内核：Google gemini-cli 源码深度解构</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F1975511012347249929" target="_blank" title="https://zhuanlan.zhihu.com/p/1975511012347249929" ref="nofollow noopener noreferrer">Agent开发实践：从想法到产品——系统架构设计实践</a></p>
<p>本文使用 <a href="https://link.juejin.cn?target=https%3A%2F%2Fmarkdown.com.cn" target="_blank" title="https://markdown.com.cn" ref="nofollow noopener noreferrer">markdown.com.cn</a> 排版</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[《实时渲染》第2章-图形渲染管线-2.2应用程序阶段]]></title>    <link>https://juejin.cn/post/7596905015367008256</link>    <guid>https://juejin.cn/post/7596905015367008256</guid>    <pubDate>2026-01-19T14:01:50.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7596905015367008256" data-draft-id="7596869784538677248" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="《实时渲染》第2章-图形渲染管线-2.2应用程序阶段"/> <meta itemprop="keywords" content="计算机图形学"/> <meta itemprop="datePublished" content="2026-01-19T14:01:50.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="charlee44"/> <meta itemprop="url" content="https://juejin.cn/user/1117549770846872"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            《实时渲染》第2章-图形渲染管线-2.2应用程序阶段
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1117549770846872/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    charlee44
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-19T14:01:50.000Z" title="Mon Jan 19 2026 14:01:50 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">实时渲染</h2>
<h3 data-id="heading-1">2. 图形渲染管线</h3>
<blockquote>
<p>链条的坚固程度取决于它最薄弱的环节。
--匿名者</p>
</blockquote>
<p>本章介绍实时图形渲染的核心组件，即图形渲染管线，也简称为“管线”。管线的主要功能是通过给定虚拟相机、三维对象、光源等，生成或渲染二维图像。因此，渲染管线是实时渲染的基础工具。使用管线的过程如图2.1所示。图像中对象的位置和形状由它们的几何形状、环境特征以及相机在该环境中的位置决定。对象的外观受材料属性、光源、纹理（应用于表面的图像）和着色方程的影响。</p>
<div align="center">
<p><img src="https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/d95783d1a1d947bfb5dcee935e0c6f84~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgY2hhcmxlZTQ0:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiMTExNzU0OTc3MDg0Njg3MiJ9&amp;rk3s=e9ecf3d6&amp;x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018&amp;x-orig-expires=1768917642&amp;x-orig-sign=a4wij8VYre0xrQ7edMavd6S15rc%3D" alt="转存失败，建议直接上传图片文件" loading="lazy"/></p>
</div>
<div align="center">
<p><strong>图2.1</strong>. 在左图中，一个虚拟相机位于金字塔的顶端（四条线会聚的地方）。仅渲染视图体积内的图元。对于透视渲染的图像（如这里的情况），视图体积是一个平截头体(frustum,复数为frusta），即具有矩形底部的截棱锥。右图显示了相机“看到”的内容。请注意，左侧图像中的红色甜甜圈形状不在右侧的渲染中，因为它位于视锥体之外。此外，左图中扭曲的蓝色棱镜被剪裁在平截头体的顶平面上。</p>
</div>
<p>我们将解释渲染管线的不同阶段，重点是功能而不是实现。应用这些阶段的相关细节将在后面的章节中介绍。</p>
<h4 data-id="heading-2">2.1 架构</h4>
<p>在现实世界中，管线的概念以许多不同的形式表现出来，从工厂装配线到快餐厨房。它也适用于图形渲染。管线由几个阶段组成[715]，每个阶段执行一个更大任务的一部分。</p>
<p>每一个流水线阶段都是并行执行，但是其都依赖于前一阶段的结果。理想情况下，一个非流水线系统然后被分成n个流水线级，可以提供n倍的加速。这种性能的提高是使用流水线的主要原因。例如，可以由一系列人快速准备大量三明治——一个准备面包，另一个添加肉，另一个添加浇头。每个人都将结果传递给排队的下一个人，然后立即开始制作下一个三明治。如果每个人需要20秒来完成他们的任务，那么每20秒一个三明治的最大速度是可能的，每分钟三个。流水线阶段并行执行，但它们会暂停，直到最慢的阶段完成其任务。例如，假设肉类添加阶段变得更加复杂，需要30秒。现在可以达到的最佳速度是每分钟两个三明治。对于这个特定的管线，肉阶段是瓶颈，因为它决定了整个生产的速度。据说浇头阶段在等待肉类阶段完成期间饿死了（顾客也是如此）。</p>
<p>这种管线结构也可以在实时计算机图形的上下文中找到。实时渲染管线粗略划分为四个主要阶段——应用程序、几何处理、光栅化和像素处理——如图2.2所示。渲染管线引擎用于实时计算机图形应用程序，其核心正是这种结构；因此这种管线结构是后续章节讨论的重要基础。这些阶段中的每一个通常本身就是一个管道，这意味着它由几个子阶段组成。我们区分此处显示的功能阶段及其实现结构。一个功能阶段有一个特定的任务要执行，但没有指定任务在管道中的执行方式。一个给定的实现可以将两个功能阶段合并为一个单元或使用可编程内核执行，同时它将另一个更耗时的功能阶段划分为几个硬件单元。</p>
<div align="center">
<p><img src="https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/a85d8a25c0d846e4af2faf6f7754655a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgY2hhcmxlZTQ0:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiMTExNzU0OTc3MDg0Njg3MiJ9&amp;rk3s=e9ecf3d6&amp;x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018&amp;x-orig-expires=1768917642&amp;x-orig-sign=gGTob78UXKZqYCp9nlGBhaaIzXU%3D" alt="转存失败，建议直接上传图片文件" loading="lazy"/></p>
</div>
<div align="center">
<p><strong>图2.2</strong>. 渲染管线的基本结构，包括四个阶段：应用程序、几何处理、光栅化和像素处理。这些阶段中的每一个本身都可以是一个流水线，如几何处理阶段下方所示，或者一个阶段可以（部分）并行化，如像素处理阶段下方所示。在这个例子中，应用程序阶段是一个单一的进程，但这个阶段也可以是流水线或并行的。请注意，光栅化阶段会查找图元内部的像素，例如三角形。</p>
</div>
<p>渲染速度可以用每秒帧数(FPS)来表示，即每秒渲染的图像数量。也可以用赫兹(Hz)来表示，它只是1/秒的表示法，即更新频率。仅说明渲染图像所需的时间（以毫秒(ms)为单位）也很常见。生成图像的时间通常会有所不同，具体取决于每帧期间执行的计算的复杂性。每秒帧数用于表示特定帧的速率或一段时间内的平均性能。赫兹用于硬件，例如设置为固定速率的显示器。</p>
<p>顾名思义，应用程序阶段由应用程序驱动，因此通常在通用CPU上运行的软件中实现。这些CPU通常包括能够并行处理多个执行线程的多个内核。这使CPU能够有效地运行由应用程序阶段负责的各种任务。一些传统上在CPU上执行的任务包括碰撞检测、全局加速算法、动画、物理模拟等，具体取决于应用程序的类型。下一个主要阶段是几何处理，它处理变换、投影和所有其他类型的几何处理。此阶段计算要绘制的内容、应如何绘制以及应在何处绘制。几何阶段通常在包含许多可编程内核和固定操作硬件的图形处理单元(GPU)上执行。光栅化阶段通常将三个顶点作为输入，形成一个三角形，并找到该三角形内的所有像素，然后将这些像素转发到下一个阶段。最后，像素处理阶段对每个像素执行一个程序以确定其颜色，并可能执行深度测试以查看它是否可见。它还可以执行逐像素操作，例如将新计算的颜色与先前的颜色混合。光栅化和像素处理阶段也完全在GPU上处理。所有这些阶段及其内部管道将在接下来的四节中讨论。有关GPU如何处理这些阶段的更多详细信息，请参见<a href="https://link.juejin.cn?target=%25E7%25AC%25AC3%25E7%25AB%25A0" target="_blank" title="%E7%AC%AC3%E7%AB%A0" ref="nofollow noopener noreferrer">第3章</a>。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Git Stash 使用笔记：从一次 PowerShell 的“神秘报错”说起]]></title>    <link>https://juejin.cn/post/7596698363964702758</link>    <guid>https://juejin.cn/post/7596698363964702758</guid>    <pubDate>2026-01-19T12:04:55.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7596698363964702758" data-draft-id="7596698363964686374" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Git Stash 使用笔记：从一次 PowerShell 的“神秘报错”说起"/> <meta itemprop="keywords" content="程序员"/> <meta itemprop="datePublished" content="2026-01-19T12:04:55.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="自由生长2024"/> <meta itemprop="url" content="https://juejin.cn/user/1591748569862670"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Git Stash 使用笔记：从一次 PowerShell 的“神秘报错”说起
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1591748569862670/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    自由生长2024
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-19T12:04:55.000Z" title="Mon Jan 19 2026 12:04:55 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    6
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>摘要：在 PowerShell 中使用 <code>git stash</code> 时，<code>stash@{0}</code> 需加双引号（如 <code>"stash@{0}"</code>），否则花括号会被错误解析，导致“unknown switch 'e'”等诡异报错。正确使用 <code>drop</code> 可直接删除 stash 而不恢复内容。</p>
<h2 data-id="heading-0">Git Stash 使用笔记：从一次 PowerShell 的“神秘报错”说起</h2>
<p>最近在使用 <code>git stash</code> 时，遇到了一个令人困惑的错误：</p>
<pre><code class="hljs language-powershell" lang="powershell">PS &gt; git stash pop stash@{0}
error: unknown switch `e'
</code></pre>
<p>明明命令写得完全正确，却提示“未知开关 <code>e</code>”——我根本没输入 <code>-e</code> 啊！<br/>
经过排查，才发现问题根源不在 Git，而在于 <strong>PowerShell 对特殊字符的解析机制</strong>。<br/>
这篇笔记就围绕这个真实问题，梳理 <code>git stash</code> 的核心用法和在 Windows PowerShell 中的注意事项。</p>
<hr/>
<h3 data-id="heading-1">一、问题复现：为什么 <code>git stash pop stash@{0}</code> 报错？</h3>
<h4 data-id="heading-2">❌ 错误命令（在 PowerShell 中）：</h4>
<pre><code class="hljs language-powershell" lang="powershell">git stash pop stash@{0}
</code></pre>
<h4 data-id="heading-3">💥 报错信息：</h4>
<pre><code class="hljs language-go" lang="go"><span class="hljs-type">error</span>: unknown <span class="hljs-keyword">switch</span> <span class="hljs-string">`e'
</span></code></pre>
<h4 data-id="heading-4">🔍 原因分析：</h4>
<p>在 <strong>PowerShell</strong> 中，花括号 <code>{}</code> 是<strong>保留字符</strong>，常用于字符串格式化（如 <code>"Hello {0}" -f "World"</code>）。<br/>
当你输入 <code>stash@{0}</code> 时，PowerShell 会尝试解析 <code>{0}</code>，可能将其替换或转义，导致实际传给 Git 的参数变成类似 <code>stash@e</code> 或其他乱码，Git 于是认为你传了一个非法选项 <code>-e</code>。</p>
<blockquote>
<p>📌 注意：这个问题<strong>只出现在 PowerShell（或某些 CMD 环境）</strong>，在 Git Bash、Linux 或 macOS 终端中通常不会发生。</p>
</blockquote>
<hr/>
<h3 data-id="heading-5">二、解决方案：加引号！</h3>
<p>在 PowerShell 中，<strong>只要命令包含 <code>{}</code>、<code>$</code>、<code>@</code> 等特殊字符，务必用双引号包裹</strong>：</p>
<pre><code class="hljs language-powershell" lang="powershell">git stash pop "stash@{0}"
git stash apply "stash@{1}"
git stash drop "stash@{0}"
git stash show -p "stash@{0}"
</code></pre>
<p>✅ 加上引号后，PowerShell 不再解析 <code>{0}</code>，而是原样传递给 Git，问题迎刃而解。</p>
<hr/>
<h3 data-id="heading-6">三、常用 <code>git stash</code> 命令速查（PowerShell 安全版）</h3>








































<table><thead><tr><th>场景</th><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><strong>查看所有 stash</strong></td><td><code>git stash list</code></td><td>显示 stash 列表，如 <code>stash@{0}: WIP on main: ...</code></td></tr><tr><td><strong>查看 stash 内容</strong></td><td><code>git stash show -p "stash@{0}"</code></td><td>显示具体代码变更（必须加 <code>-p</code> 才看 diff）， 如果不加 stash@{0}就是默认对比HEAD和最新的stash</td></tr><tr><td><strong>恢复并删除 stash</strong></td><td><code>git stash pop "stash@{0}"</code></td><td>应用修改 + 从列表移除（默认操作最新 stash）</td></tr><tr><td><strong>仅恢复不删除</strong></td><td><code>git stash apply "stash@{0}"</code></td><td>保留 stash 记录，可多次 apply</td></tr><tr><td><strong>直接删除 stash</strong></td><td><code>git stash drop "stash@{0}"</code></td><td><strong>不恢复内容，仅删除记录</strong>（回答本文开头需求）</td></tr><tr><td><strong>清空所有 stash</strong></td><td><code>git stash clear</code></td><td>永久删除所有 stash（慎用！）</td></tr></tbody></table>
<blockquote>
<p>💡 小技巧：如果不指定 stash 名称（如 <code>git stash pop</code>），默认操作 <code>stash@{0}</code>（最新的那个）。</p>
</blockquote>
<hr/>
<h3 data-id="heading-7">四、最佳实践建议</h3>
<ol>
<li>
<p><strong>在 PowerShell 中始终对 <code>stash@{n}</code> 加双引号</strong><br/>
养成习惯：<code>"stash@{0}"</code> 而不是 <code>stash@{0}</code>。</p>
</li>
<li>
<p><strong>先看再操作</strong><br/>
恢复或删除前，先用 <code>git stash show -p "stash@{0}"</code> 确认内容。</p>
</li>
<li>
<p><strong>区分 <code>pop</code> / <code>apply</code> / <code>drop</code></strong></p>
<ul>
<li>想<strong>恢复并删掉</strong> → <code>pop</code></li>
<li>想<strong>恢复但保留</strong> → <code>apply</code></li>
<li>想<strong>直接删掉不要了</strong> → <code>drop</code>（这就是你最初的需求！）</li>
</ul>
</li>
<li>
<p><strong>避免依赖索引编号</strong><br/>
<code>stash@{0}</code> 会随 <code>drop</code> 或 <code>pop</code> 动态变化。如果要长期保留某个 stash，建议打标签或提交到临时分支。</p>
</li>
</ol>
<hr/>
<h3 data-id="heading-8">五、总结</h3>
<ul>
<li><code>git stash</code> 是开发者的好帮手，但<strong>环境差异可能引发“诡异”错误</strong>。</li>
<li>在 <strong>Windows PowerShell</strong> 中，<strong>花括号 <code>{}</code> 需要引号保护</strong>。</li>
<li>记住三个核心动作：<br/>
👀 <code>show</code>（看）、🔄 <code>apply/pop</code>（恢复）、🗑️ <code>drop</code>（删除）。</li>
</ul>
<p>下次再看到 <code>unknown switch 'e'</code>，别慌——八成是忘了加引号！</p>
<blockquote>
<p>🔄 附：如果你常用 PowerShell，也可以考虑改用 <strong>Git Bash</strong>，它对 Git 命令的兼容性更“原生”。</p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[拒绝等待！如何让 AI 一边修 Bug，一边重构代码，一边帮你review？]]></title>    <link>https://juejin.cn/post/7596904122865254451</link>    <guid>https://juejin.cn/post/7596904122865254451</guid>    <pubDate>2026-01-19T12:07:35.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7596904122865254451" data-draft-id="7596845113281216521" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="拒绝等待！如何让 AI 一边修 Bug，一边重构代码，一边帮你review？"/> <meta itemprop="keywords" content="AI编程,前端,后端"/> <meta itemprop="datePublished" content="2026-01-19T12:07:35.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="也无风雨也雾晴"/> <meta itemprop="url" content="https://juejin.cn/user/2175258804632332"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            拒绝等待！如何让 AI 一边修 Bug，一边重构代码，一边帮你review？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2175258804632332/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    也无风雨也雾晴
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-19T12:07:35.000Z" title="Mon Jan 19 2026 12:07:35 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">利用好Git Worktree + Claude Code：让 AI 帮你并行开发</h2>
<p>用 AI 写代码的时候，大家有没有遇到这样一个问题：它一次只能干一件事。</p>
<p>你让它重构一个模块，它就在那儿埋头干，你只能等着。想同时让它帮你修个 bug？不行，得排队。</p>
<p>其实可以用 Git Worktree 让多个 Claude Code 实例同时工作，各干各的，互不干扰。</p>
<h3 data-id="heading-1">Git Worktree 是什么</h3>
<p>简单说，Git Worktree 让你在同一个仓库下同时检出多个分支，每个分支有自己独立的工作目录。</p>
<p><strong>和 <code>git clone</code> 多份的区别</strong>：</p>
<ul>
<li><code>git clone</code> 多份：每份都有完整的 <code>.git</code> 目录，占用大量磁盘空间，分支之间互不知道</li>
<li><code>git worktree</code>：共享同一个 <code>.git</code> 目录，几乎不占额外空间，分支之间可以互相看到</li>
</ul>
<p><strong>目录结构示例</strong>：</p>
<pre><code class="hljs language-bash" lang="bash">my-project/              <span class="hljs-comment"># 主工作区，你自己在这里开发</span>
../worktrees/
  ├── feature-auth/      <span class="hljs-comment"># Claude 1 在这里做认证功能</span>
  ├── fix-bug-123/       <span class="hljs-comment"># Claude 2 在这里修 bug</span>
  └── refactor-api/      <span class="hljs-comment"># Claude 3 在这里重构 API</span>
</code></pre>
<p>每个目录都是完整的工作区，可以独立运行、独立提交、独立启动 Claude Code。</p>
<p><strong>形象点说</strong>：就像你有一个大办公室（<code>.git</code> 目录），里面有很多小隔间（worktree），每个隔间都在干不同的活，但共享同一套基础设施（Git 历史、配置等）。</p>
<h3 data-id="heading-2">基本用法</h3>
<h4 data-id="heading-3">创建 worktree</h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 创建新分支并检出到独立目录</span>
git worktree add ../worktrees/feature-auth -b feature/auth
​
<span class="hljs-comment"># 基于已有分支创建</span>
git worktree add ../worktrees/fix-bug origin/fix-bug-123
​
<span class="hljs-comment"># 基于某个 commit 创建</span>
git worktree add ../worktrees/hotfix abc123
</code></pre>
<h4 data-id="heading-4">在 worktree 中启动 Claude Code</h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-built_in">cd</span> ../worktrees/feature-auth
claude
</code></pre>
<p>这样就有了一个独立的 Claude Code 实例，在 <code>feature/auth</code> 分支上工作。你可以开多个终端，每个终端进入不同的 worktree，启动不同的 Claude Code 实例。</p>
<h4 data-id="heading-5">查看和清理</h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 查看所有 worktree</span>
git worktree list
​
<span class="hljs-comment"># 删除 worktree（会保留分支）</span>
git worktree remove ../worktrees/feature-auth
​
<span class="hljs-comment"># 清理失效的 worktree 引用</span>
git worktree prune
</code></pre>
<h4 data-id="heading-6">实际演示</h4>
<p>下面是我在本地仓库实际执行的命令和输出：</p>
<p><strong>1. 查看当前 worktree 状态</strong></p>
<pre><code class="hljs language-bash" lang="bash">$ git worktree list
/Users/tsk/JS  64d1da9 [master]
</code></pre>
<p>目前只有主工作区。</p>
<p><strong>2. 创建两个 worktree</strong></p>
<pre><code class="hljs language-csharp" lang="csharp">$ git worktree <span class="hljs-keyword">add</span> ../worktrees/demo-feature -b demo/<span class="hljs-function">feature
Preparing <span class="hljs-title">worktree</span> (<span class="hljs-params"><span class="hljs-keyword">new</span> branch <span class="hljs-string">'demo/feature'</span></span>)
HEAD <span class="hljs-keyword">is</span> now at 64d1da9 chore: 删除 demo HTML 文件。
​
$ git worktree <span class="hljs-keyword">add</span> ../worktrees/demo-bugfix -b demo/bugfix
Preparing <span class="hljs-title">worktree</span> (<span class="hljs-params"><span class="hljs-keyword">new</span> branch <span class="hljs-string">'demo/bugfix'</span></span>)
HEAD <span class="hljs-keyword">is</span> now at 64d1da9 chore: 删除 demo HTML 文件。
</span></code></pre>
<p><strong>3. 查看所有 worktree</strong></p>
<pre><code class="hljs language-bash" lang="bash">$ git worktree list
/Users/tsk/JS                      64d1da9 [master]
/Users/tsk/worktrees/demo-bugfix   64d1da9 [demo/bugfix]
/Users/tsk/worktrees/demo-feature  64d1da9 [demo/feature]
</code></pre>
<p>现在有 3 个工作区了，每个都在不同的分支上。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3bc712ce3b894e9e80107d046eb23755~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lmf5peg6aOO6Zuo5Lmf6Zu-5pm0:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769429255&amp;x-signature=vr%2FyBPri6P%2Bsr2ndJKVmFz8ADGs%3D" alt="image.png" loading="lazy"/></p>
<p><strong>4. 在不同 worktree 中分别提交</strong></p>
<pre><code class="hljs language-shell" lang="shell"><span class="hljs-meta prompt_"># </span><span class="bash">在 demo-feature 中提交</span>
<span class="hljs-meta prompt_">$ </span><span class="bash"><span class="hljs-built_in">cd</span> ../worktrees/demo-feature</span>
<span class="hljs-meta prompt_">$ </span><span class="bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">"# Demo Feature"</span> &gt; README-feature.md</span>
<span class="hljs-meta prompt_">$ </span><span class="bash">git add . &amp;&amp; git commit -m <span class="hljs-string">"feat: add feature readme"</span></span>
[demo/feature dbad1c0] feat: add feature readme
 1 file changed, 1 insertion(+)
 create mode 100644 README-feature.md
​
<span class="hljs-meta prompt_"># </span><span class="bash">在 demo-bugfix 中提交</span>
<span class="hljs-meta prompt_">$ </span><span class="bash"><span class="hljs-built_in">cd</span> ../worktrees/demo-bugfix</span>
<span class="hljs-meta prompt_">$ </span><span class="bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">"# Bugfix"</span> &gt; BUGFIX.md</span>
<span class="hljs-meta prompt_">$ </span><span class="bash">git add . &amp;&amp; git commit -m <span class="hljs-string">"fix: add bugfix notes"</span></span>
[demo/bugfix 00198c6] fix: add bugfix notes
 1 file changed, 1 insertion(+)
 create mode 100644 BUGFIX.md
</code></pre>
<p><strong>5. 查看分支历史</strong></p>
<pre><code class="hljs language-bash" lang="bash">$ git <span class="hljs-built_in">log</span> --oneline --all --graph -10
* 00198c6 (demo/bugfix) fix: add bugfix notes
| * dbad1c0 (demo/feature) feat: add feature readme
|/  
* 64d1da9 (HEAD -&gt; master, origin/master) chore: 删除 demo HTML 文件。
* 7a18ac3 feat(<span class="hljs-built_in">log</span>): 删除 Vercel React Skill 文档
* b7ccd2a feat(<span class="hljs-built_in">log</span>): add vscode-ai-commit extension
...
</code></pre>
<p>可以看到两个分支各自有了新的提交，从同一个基点分叉出来。</p>
<p><strong>6. 清理 worktree</strong></p>
<pre><code class="hljs language-shell" lang="shell"><span class="hljs-meta prompt_">$ </span><span class="bash">git worktree remove ../worktrees/demo-feature</span>
<span class="hljs-meta prompt_">$ </span><span class="bash">git worktree remove ../worktrees/demo-bugfix</span>
​
<span class="hljs-meta prompt_">$ </span><span class="bash">git worktree list</span>
/Users/tsk/JS  64d1da9 [master]
​
<span class="hljs-meta prompt_"># </span><span class="bash">删除分支（因为没有合并，需要用 -D 强制删除）</span>
<span class="hljs-meta prompt_">$ </span><span class="bash">git branch -D demo/feature demo/bugfix</span>
Deleted branch demo/feature (was dbad1c0).
Deleted branch demo/bugfix (was 00198c6).
</code></pre>
<p>整个过程就是这样，每个 worktree 都是独立的工作空间，可以同时在不同分支上工作。</p>
<h3 data-id="heading-7">实际工作流</h3>
<p>假设你有三个任务要做：</p>
<ol start="0">
<li>实现用户认证模块（预计 2 小时）</li>
<li>修复一个支付相关的 bug（预计 30 分钟）</li>
<li>重构 API 层（预计 3 小时）</li>
</ol>
<p>传统做法是一个一个来，总共需要 5.5 小时。用 worktree + Claude Code，可以这样：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 终端 1：创建认证功能的 worktree</span>
git worktree add ../worktrees/auth -b feature/auth
<span class="hljs-built_in">cd</span> ../worktrees/auth
claude
<span class="hljs-comment"># 告诉 Claude：实现用户认证模块，包括登录、注册、token 管理</span>
​
<span class="hljs-comment"># 终端 2：创建修 bug 的 worktree</span>
git worktree add ../worktrees/fix-payment -b fix/payment-bug
<span class="hljs-built_in">cd</span> ../worktrees/fix-payment
claude
<span class="hljs-comment"># 告诉 Claude：修复支付模块的 xxx bug</span>
​
<span class="hljs-comment"># 终端 3：创建重构的 worktree</span>
git worktree add ../worktrees/refactor-api -b refactor/api-layer
<span class="hljs-built_in">cd</span> ../worktrees/refactor-api
claude
<span class="hljs-comment"># 告诉 Claude：重构 API 层，统一错误处理和响应格式</span>
</code></pre>
<p>三个 Claude 同时干活，互不干扰。理论上，如果任务足够独立，总耗时可以压缩到最长任务的时间（3 小时），效率提升 <strong>45%</strong> 。</p>
<p>你可以在主工作区继续做自己的事，偶尔切过去看看进度，或者用 Plan Mode 让 Claude 先说清楚打算怎么做。</p>
<h3 data-id="heading-8">封装成命令</h3>
<p>每次敲这么多命令有点烦，可以封装一下：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 加到 ~/.zshrc 或 ~/.bashrc</span>
<span class="hljs-function"><span class="hljs-title">cw</span></span>() {
  <span class="hljs-built_in">local</span> branch=<span class="hljs-variable">$1</span>
  <span class="hljs-built_in">local</span> worktree_dir=<span class="hljs-string">"../worktrees/<span class="hljs-variable">$branch</span>"</span>
​
  <span class="hljs-keyword">if</span> [[ -z <span class="hljs-string">"<span class="hljs-variable">$branch</span>"</span> ]]; <span class="hljs-keyword">then</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"用法: cw &lt;分支名&gt;"</span>
    <span class="hljs-built_in">return</span> 1
  <span class="hljs-keyword">fi</span>
​
  <span class="hljs-comment"># 如果 worktree 不存在就创建</span>
  <span class="hljs-keyword">if</span> [[ ! -d <span class="hljs-string">"<span class="hljs-variable">$worktree_dir</span>"</span> ]]; <span class="hljs-keyword">then</span>
    git worktree add <span class="hljs-string">"<span class="hljs-variable">$worktree_dir</span>"</span> -b <span class="hljs-string">"<span class="hljs-variable">$branch</span>"</span> 2&gt;/dev/null || \
    git worktree add <span class="hljs-string">"<span class="hljs-variable">$worktree_dir</span>"</span> <span class="hljs-string">"<span class="hljs-variable">$branch</span>"</span>
  <span class="hljs-keyword">fi</span>
​
  <span class="hljs-built_in">cd</span> <span class="hljs-string">"<span class="hljs-variable">$worktree_dir</span>"</span>
  claude
}
</code></pre>
<p>用起来就一行：</p>
<pre><code class="hljs language-bash" lang="bash">cw feature/auth    <span class="hljs-comment"># 创建 worktree 并启动 Claude Code</span>
</code></pre>
<h3 data-id="heading-9">开发完怎么合并</h3>
<p>和普通分支开发一样，通过 PR 或者直接 merge。</p>
<h4 data-id="heading-10">通过 PR（推荐）</h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-built_in">cd</span> ../worktrees/feature-auth
git add .
git commit -m <span class="hljs-string">"feat: implement user authentication"</span>
git push -u origin feature/auth
​
<span class="hljs-comment"># 创建 PR（需要安装 GitHub CLI）</span>
gh <span class="hljs-built_in">pr</span> create --title <span class="hljs-string">"Add user authentication"</span> --body <span class="hljs-string">"实现用户认证功能"</span>
</code></pre>
<h4 data-id="heading-11">直接 merge</h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-built_in">cd</span> ~/projects/my-project  <span class="hljs-comment"># 回到主工作区</span>
git checkout main
git merge feature/auth
git push
</code></pre>
<h4 data-id="heading-12">合并后清理</h4>
<pre><code class="hljs language-bash" lang="bash">git worktree remove ../worktrees/feature-auth
git branch -d feature/auth
</code></pre>
<h3 data-id="heading-13">几个注意事项</h3>
<h4 data-id="heading-14">1. 任务要足够独立</h4>
<p>如果两个任务改的是同一批文件，并行开发反而会增加合并冲突。适合并行的是那些相对独立的功能模块。</p>
<p><strong>适合并行</strong>：</p>
<ul>
<li>前端组件 A + 后端 API B</li>
<li>功能模块 X + bug 修复 Y</li>
<li>数据库迁移 + 文档更新</li>
</ul>
<p><strong>不适合并行</strong>：</p>
<ul>
<li>同一个文件的两处修改</li>
<li>有强依赖关系的功能（B 依赖 A 的接口）</li>
</ul>
<h4 data-id="heading-15">2. 定期从 main 同步</h4>
<p>长时间不同步，分支会偏离主干太远，最后合并时冲突会很多。建议每天 merge 一次 main：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-built_in">cd</span> ../worktrees/feature-auth
git fetch origin
git merge origin/main
</code></pre>
<h4 data-id="heading-16">3. 用 Plan Mode 先确认方案</h4>
<p>Claude Code 有个 Plan Mode，在动手之前先让它说清楚打算怎么做。并行开发时更需要这个，避免 Claude 跑偏了你还不知道。</p>
<p>开启方法：</p>
<ul>
<li>VS Code：<code>Cmd/Ctrl + Shift + P</code> → <code>Claude Code: Toggle Plan Mode</code></li>
<li>CLI：启动时加 <code>--plan</code> 参数</li>
</ul>
<h4 data-id="heading-17">4. 别开太多</h4>
<p>API 有调用频率限制，开太多 worktree 同时跑 Claude 可能会触发限流。我自己的经验是 <strong>3-5 个</strong> 差不多了。</p>
<h4 data-id="heading-18">5. 注意依赖安装</h4>
<p>每个 worktree 共享 <code>.git</code>，但 <code>node_modules</code>、<code>venv</code> 这些是独立的。如果你在 worktree 里装了新依赖，记得在主工作区也装一遍。</p>
<h3 data-id="heading-19">适合什么场景</h3>
<p><strong>适合</strong>：</p>
<ul>
<li>多个独立功能同时开发</li>
<li>跑长任务（重构、迁移）的同时不想阻塞日常开发</li>
<li>让两个 Claude 各写一版，对比选优</li>
<li>跑 overnight 任务，第二天起来收代码</li>
<li>紧急 hotfix 和日常开发并行</li>
</ul>
<p><strong>不太适合</strong>：</p>
<ul>
<li>需求还没想清楚，还在探索阶段</li>
<li>任务之间有强依赖</li>
<li>项目很小，不值得这么折腾</li>
<li>团队协作（容易产生分支管理混乱）</li>
</ul>
<h3 data-id="heading-20">实际效果</h3>
<p>我在自己的项目里试了一周，大概的感受是：</p>
<ul>
<li><strong>时间节省</strong>：原本需要串行完成的 3 个任务，现在可以并行，总耗时减少约 40%</li>
<li><strong>心智负担降低</strong>：不用频繁切分支，每个任务都有独立的上下文</li>
<li><strong>代码质量提升</strong>：可以让两个 Claude 各写一版，选更好的那个</li>
<li><strong>适合长任务</strong>：重构、迁移这种耗时长的任务，可以放在后台跑，不影响日常开发</li>
</ul>
<p>但也有坑：</p>
<ul>
<li>合并冲突比预期多（因为没有及时同步 main）</li>
<li>有时候会忘记某个 worktree 还在跑，导致分支越来越多</li>
<li>需要手动管理多个终端窗口，有点乱</li>
</ul>
<h3 data-id="heading-21">参考资料</h3>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fincident.io%2Fblog%2Fshipping-faster-with-claude-code-and-git-worktrees" target="_blank" title="https://incident.io/blog/shipping-faster-with-claude-code-and-git-worktrees" ref="nofollow noopener noreferrer">incident.io - Shipping faster with Claude Code and Git Worktrees</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fmotlin.com%2Fblog%2Fclaude-code-worktree" target="_blank" title="https://motlin.com/blog/claude-code-worktree" ref="nofollow noopener noreferrer">motlin.com - Claude Code: Parallel Development with /worktree</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgit-scm.com%2Fdocs%2Fgit-worktree" target="_blank" title="https://git-scm.com/docs/git-worktree" ref="nofollow noopener noreferrer">Git 官方文档 - git-worktree</a></li>
</ul>
<hr/>
<p>如果你觉得这篇文章有帮助，欢迎关注我的 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ftt-a1i" target="_blank" title="https://github.com/tt-a1i" ref="nofollow noopener noreferrer">GitHub</a>，下面是我的一些开源项目：</p>
<p><strong>Claude Code Skills</strong>（按需加载，意图自动识别，不浪费 token，<a href="https://juejin.cn/post/7578714735307735066" target="_blank" title="https://juejin.cn/post/7578714735307735066">介绍文章</a>）：</p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ftt-a1i%2Fcode-review-skill" target="_blank" title="https://github.com/tt-a1i/code-review-skill" ref="nofollow noopener noreferrer">code-review-skill</a> - 代码审查技能，覆盖 React 19、Vue 3、TypeScript、Rust 等约 9000 行规则（<a href="https://juejin.cn/post/7578709098255908902" target="_blank" title="https://juejin.cn/post/7578709098255908902">详细介绍</a>）</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ftt-a1i%2F5-whys-skill" target="_blank" title="https://github.com/tt-a1i/5-whys-skill" ref="nofollow noopener noreferrer">5-whys-skill</a> - 5 Whys 根因分析，说"找根因"自动激活</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ftt-a1i%2Ffirst-principles-skill" target="_blank" title="https://github.com/tt-a1i/first-principles-skill" ref="nofollow noopener noreferrer">first-principles-skill</a> - 第一性原理思考，适合架构设计和技术选型</li>
</ul>
<p><strong>qwen/gemini/claude - cli 原理学习网站</strong>：</p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ftt-a1i%2Fcoding-cli-guide" target="_blank" title="https://github.com/tt-a1i/coding-cli-guide" ref="nofollow noopener noreferrer">coding-cli-guide</a>（<a href="https://link.juejin.cn?target=https%3A%2F%2Ftt-a1i.github.io%2Fcoding-cli-guide%2F%3Ftab%3Dstart-here" target="_blank" title="https://tt-a1i.github.io/coding-cli-guide/?tab=start-here" ref="nofollow noopener noreferrer">学习网站</a>）- 学习 qwen-cli 时整理的笔记，40+ 交互式动画演示 AI CLI 内部机制</li>
</ul>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/08e50020ab1f45428cd22e53af91a555~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lmf5peg6aOO6Zuo5Lmf6Zu-5pm0:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769429255&amp;x-signature=TuWkroMnIYRdDiCkI9%2BsumvfA5Q%3D" alt="coding-cli-guide" loading="lazy"/></p>
<p><strong>全栈项目</strong>（适合学习现代技术栈）：</p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ftt-a1i%2Fprompt-vault" target="_blank" title="https://github.com/tt-a1i/prompt-vault" ref="nofollow noopener noreferrer">prompt-vault</a> - Prompt 管理器，用的都是最新的技术栈，适合用来学习了解最新的前端全栈开发范式：Next.js 15 + React 19 + tRPC 11 + Supabase 全栈示例，clone 下来配个免费 Supabase 就能跑</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ftt-a1i%2Fchat_edit" target="_blank" title="https://github.com/tt-a1i/chat_edit" ref="nofollow noopener noreferrer">chat_edit</a> - 双模式 AI 应用（聊天+富文本编辑），Vue 3.5 + TypeScript + Vite 5 + Quill 2.0 + IndexedDB</li>
</ul>
<p><strong>VS Code 插件</strong>：</p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ftt-a1i%2Fvscode-ai-commit" target="_blank" title="https://github.com/tt-a1i/vscode-ai-commit" ref="nofollow noopener noreferrer">vscode-ai-commit</a> - 一键生成 commit message，支持 Conventional Commits，兼容任何 OpenAI 格式接口</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[基于 YOLOv8 的边坡排水沟堵塞智能检测系统设计与工程实现 [目标检测完整源码]]]></title>    <link>https://juejin.cn/post/7596906923892129802</link>    <guid>https://juejin.cn/post/7596906923892129802</guid>    <pubDate>2026-01-19T12:09:24.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7596906923892129802" data-draft-id="7596698363964719142" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="基于 YOLOv8 的边坡排水沟堵塞智能检测系统设计与工程实现 [目标检测完整源码]"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-01-19T12:09:24.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="我是杰尼"/> <meta itemprop="url" content="https://juejin.cn/user/4200579899599495"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            基于 YOLOv8 的边坡排水沟堵塞智能检测系统设计与工程实现 [目标检测完整源码]
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4200579899599495/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    我是杰尼
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-19T12:09:24.000Z" title="Mon Jan 19 2026 12:09:24 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">基于 YOLOv8 的边坡排水沟堵塞智能检测系统设计与工程实现 [目标检测完整源码]</h2>
<h3 data-id="heading-1">一、问题背景：为什么要“自动识别排水沟堵塞”？</h3>
<p>在山区公路、水利工程、高边坡治理等场景中，<strong>排水沟是否畅通</strong>直接关系到边坡稳定性与工程安全。一旦排水沟被泥沙、落石、杂物堵塞，极易在降雨条件下引发：</p>
<ul>
<li>边坡渗水压力骤增</li>
<li>局部冲刷、塌陷</li>
<li>滑坡、泥石流等次生灾害</li>
</ul>
<p>传统的排水沟巡检主要依赖人工踏勘或定期巡查，不仅<strong>效率低、覆盖面有限</strong>，在雨后或危险区域甚至存在明显的安全隐患。</p>
<p>随着无人机巡检、固定监控摄像头的普及，现场已经具备了<strong>大量图像与视频数据</strong>，关键问题转变为：</p>
<blockquote>
<p>能否利用计算机视觉技术，自动识别排水沟是否存在堵塞风险？
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8d5e2169316c4448b60ea48e975e7f34~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oiR5piv5p2w5bC8:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769429364&amp;x-signature=5GJSC6G3VS4sy9642o5r3TONAYM%3D" alt="在这里插入图片描述" loading="lazy"/></p>
</blockquote>
<h3 data-id="heading-2">源码下载与效果演示</h3>
<p>哔哩哔哩视频下方观看：
<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1KZgHzJEhn%2F" target="_blank" title="https://www.bilibili.com/video/BV1KZgHzJEhn/" ref="nofollow noopener noreferrer">www.bilibili.com/video/BV1KZ…</a></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c0a6ebed5f3b48f6b0abd4036f58d583~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oiR5piv5p2w5bC8:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769429364&amp;x-signature=n3EIilgUzI9ht0zFEpZzplQtO04%3D" alt="在这里插入图片描述" loading="lazy"/></p>
<p>包含：</p>
<p>📦完整项目源码</p>
<p>📦 预训练模型权重</p>
<p>🗂️ 数据集地址（含标注脚本</p>
<hr/>
<h3 data-id="heading-3">二、总体方案概述</h3>
<p>本项目基于 <strong>YOLOv8 目标检测框架</strong>，构建了一套面向工程应用的 <strong>边坡排水沟堵塞智能识别系统</strong>，并通过 <strong>PyQt5</strong> 封装为可视化桌面工具，实现从模型到应用的完整闭环。</p>
<h4 data-id="heading-4">系统核心能力包括：</h4>
<ul>
<li>对排水沟状态进行自动识别与分类</li>
<li>支持图片 / 视频 / 摄像头等多种输入源</li>
<li>实时可视化检测结果与置信度</li>
<li>检测结果可保存、可复核、可二次分析</li>
</ul>
<p>系统既可作为<strong>工程巡检辅助工具</strong>，也可作为<strong>YOLOv8 工程化实战示例</strong>用于教学与研究。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/44c2f38272544906a890f96208c72828~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oiR5piv5p2w5bC8:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769429364&amp;x-signature=n20fL%2BmZuzLgiag9OFU7t2mydzs%3D" alt="在这里插入图片描述" loading="lazy"/></p>
<hr/>
<h3 data-id="heading-5">三、系统架构设计</h3>
<p>整体系统采用“<strong>模型推理层 + 应用交互层</strong>”的分层设计：</p>
<pre><code class="hljs language-markdown" lang="markdown">┌──────────────┐
│  数据输入层  │  ← 图片 / 视频 / 摄像头 / 无人机
└──────┬───────┘
<span class="hljs-code">       │
┌──────▼───────┐
│ YOLOv8 推理层│  ← 堵塞目标检测
└──────┬───────┘
       │
┌──────▼───────┐
│ 结果解析模块 │  ← 类别 / 置信度 / 坐标
└──────┬───────┘
       │
┌──────▼───────┐
│ PyQt5 界面层 │  ← 可视化展示与交互
└──────────────┘
</span></code></pre>
<p>这种结构的优势在于：</p>
<ul>
<li><strong>模型与界面解耦</strong>，便于后期替换或升级模型</li>
<li>推理逻辑可独立部署为服务</li>
<li>UI 层只关注交互与展示，工程可维护性高
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9ac75c66d3ef4e299ad9e301ef7e90b9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oiR5piv5p2w5bC8:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769429364&amp;x-signature=uGSKJOqcs2CNRIh4qmrq3tgIRXw%3D" alt="在这里插入图片描述" loading="lazy"/></li>
</ul>
<hr/>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d6e7fab81acd4acd9c4acd4c9ac31a9f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oiR5piv5p2w5bC8:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769429364&amp;x-signature=M0msvowEKdjRTYdReuEV96oSd0s%3D" alt="在这里插入图片描述" loading="lazy"/></p>
<h3 data-id="heading-6">四、检测目标与数据设计</h3>
<h4 data-id="heading-7">4.1 检测类别定义</h4>
<p>根据工程实际需求，将排水沟状态划分为三类：</p>





















<table><thead><tr><th>类别编号</th><th>含义说明</th></tr></thead><tbody><tr><td>0</td><td>排水沟畅通 / 正常</td></tr><tr><td>1</td><td>存在局部遮挡或轻微淤积</td></tr><tr><td>2</td><td>明显堵塞，影响排水功能</td></tr></tbody></table>
<p>这种分级方式相比“是否堵塞”的二分类，更有利于<strong>风险评估与运维决策</strong>。</p>
<hr/>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f7531baf18ee4581914bc9ae21f90f44~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oiR5piv5p2w5bC8:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769429364&amp;x-signature=q5yCloIj3p02GBGraCrW7nVy7dA%3D" alt="在这里插入图片描述" loading="lazy"/></p>
<h4 data-id="heading-8">4.2 数据集组织方式</h4>
<p>采用 YOLO 标准数据集格式：</p>
<pre><code class="hljs language-text" lang="text">dataset/
├── images/
│   ├── train
│   ├── val
│   └── test
└── labels/
    ├── train
    ├── val
    └── test
</code></pre>
<p>标注文件使用 <strong>归一化坐标格式</strong>：</p>
<pre><code class="hljs language-text" lang="text">class_id x_center y_center width height
</code></pre>
<p>这种结构与 Ultralytics YOLOv8 完全兼容，可直接用于训练与推理。</p>
<hr/>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e424fb1b80bc4c46b360e595676c10dd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oiR5piv5p2w5bC8:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769429364&amp;x-signature=g0cQ30w49%2BELSUNJ8GnaTk%2B4vHs%3D" alt="在这里插入图片描述" loading="lazy"/></p>
<h3 data-id="heading-9">五、YOLOv8 模型训练与优化策略</h3>
<h4 data-id="heading-10">5.1 为什么选择 YOLOv8？</h4>
<p>YOLOv8 相比早期 YOLO 系列，在工程实践中具有明显优势：</p>
<ul>
<li>Anchor-Free 设计，降低调参复杂度</li>
<li>对小目标、细长结构更友好</li>
<li>原生支持 ONNX / TensorRT 导出</li>
<li>推理接口简洁，易于二次封装</li>
</ul>
<p>对于排水沟这种<strong>形态不规则、尺度变化大的目标</strong>，YOLOv8 在精度与速度之间取得了良好平衡。</p>
<hr/>
<h4 data-id="heading-11">5.2 训练命令示例</h4>
<pre><code class="hljs language-bash" lang="bash">yolo detect train \
  data=drain.yaml \
  model=yolov8s.pt \
  epochs=100 \
  batch=16 \
  imgsz=640
</code></pre>
<p>在实际训练中，重点关注以下指标：</p>
<ul>
<li><code>mAP@0.5</code>：整体检测能力</li>
<li>混淆矩阵：不同堵塞等级的区分情况</li>
<li>推理速度：是否满足实时性需求</li>
</ul>
<hr/>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5b83a2bf31744e8ca84fc72497ec1780~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oiR5piv5p2w5bC8:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769429364&amp;x-signature=VuYNY67onLy9Ha%2BpDtrOtL%2FAd10%3D" alt="在这里插入图片描述" loading="lazy"/></p>
<h3 data-id="heading-12">六、推理流程与结果解析</h3>
<p>YOLOv8 推理接口非常适合工程调用，核心代码如下：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> ultralytics <span class="hljs-keyword">import</span> YOLO

model = YOLO(<span class="hljs-string">"best.pt"</span>)
results = model(<span class="hljs-string">"test.jpg"</span>, conf=<span class="hljs-number">0.3</span>)

<span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> results:
    <span class="hljs-keyword">for</span> box <span class="hljs-keyword">in</span> r.boxes:
        cls = <span class="hljs-built_in">int</span>(box.cls)
        score = <span class="hljs-built_in">float</span>(box.conf)
        <span class="hljs-built_in">print</span>(cls, score)
</code></pre>
<p>每个检测框都包含：</p>
<ul>
<li>类别 ID</li>
<li>置信度</li>
<li>边界框坐标</li>
</ul>
<p>这些信息会被进一步传递到 UI 层进行可视化渲染。</p>
<hr/>
<h3 data-id="heading-13">七、PyQt5 可视化系统设计</h3>
<p>为了降低使用门槛，系统提供了完整的桌面界面，主要功能包括：</p>
<ul>
<li>一键加载图片或视频</li>
<li>实时显示检测结果</li>
<li>支持暂停、截图、结果保存</li>
<li>自动管理输出目录</li>
</ul>
<p>即便不具备深度学习背景，也可以通过界面直接完成检测任务。</p>
<hr/>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/37dd054aa441493880c1292d2aa943ec~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oiR5piv5p2w5bC8:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769429364&amp;x-signature=UEnpYVfzD7SOtA2FXKgFGiUu9VA%3D" alt="在这里插入图片描述" loading="lazy"/></p>
<h3 data-id="heading-14">八、应用场景与扩展方向</h3>
<p>该系统可直接应用于：</p>
<ul>
<li>边坡巡检无人机数据分析</li>
<li>水利设施日常运维</li>
<li>智慧工地安全监测</li>
<li>地质灾害风险辅助评估</li>
</ul>
<p>在此基础上，还可以进一步扩展：</p>
<ul>
<li>与 GIS 系统联动，生成风险分布图</li>
<li>接入报警规则，实现堵塞自动告警</li>
<li>模型升级为分割任务，精确定位淤积区域</li>
</ul>
<hr/>
<h3 data-id="heading-15">九、总结</h3>
<p>本文从工程实际问题出发，完整介绍了一套 <strong>基于 YOLOv8 的边坡排水沟堵塞检测系统</strong> 的设计思路与实现路径。该系统不仅验证了 YOLOv8 在工程巡检场景下的实用价值，也展示了 <strong>“模型 + UI”一体化交付</strong> 的典型落地方式。</p>
<p>对于希望将目标检测真正应用到真实工程场景中的开发者而言，这类项目比单纯跑模型指标更具参考意义。</p>
<p><strong>AI 不止于论文，更重要的是解决现实问题。</strong></p>
<p>本文围绕边坡排水沟堵塞这一典型工程安全隐患，系统性地介绍了一个基于 YOLOv8 的智能检测解决方案。从问题背景、系统架构、数据与模型设计，到推理流程和可视化应用实现，完整展示了目标检测技术在实际工程场景中的落地路径。该系统兼顾检测精度、实时性与易用性，通过引入图形化界面有效降低了使用门槛，可直接服务于边坡巡检、水利运维和地质灾害预警等应用场景。整体实践表明，将先进的深度学习模型与工程化设计相结合，是推动智慧水利与智能巡检落地的关键方向。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[MCP 入门 01：MCP 的本质及脚手架搭建]]></title>    <link>https://juejin.cn/post/7596906473306177586</link>    <guid>https://juejin.cn/post/7596906473306177586</guid>    <pubDate>2026-01-19T12:18:58.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7596906473306177586" data-draft-id="7596890557545676846" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="MCP 入门 01：MCP 的本质及脚手架搭建"/> <meta itemprop="keywords" content="前端,后端,JavaScript"/> <meta itemprop="datePublished" content="2026-01-19T12:18:58.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="摸鱼的春哥"/> <meta itemprop="url" content="https://juejin.cn/user/1714893870865303"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            MCP 入门 01：MCP 的本质及脚手架搭建
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1714893870865303/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    摸鱼的春哥
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-19T12:18:58.000Z" title="Mon Jan 19 2026 12:18:58 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>用写后端 API 的方式，给 AI 装上“眼睛”和“手”。</p>
</blockquote>
<h2 data-id="heading-0">背景：为什么我们需要MCP？</h2>
<p>作为开发者，你肯定用过 ChatGPT 或 Claude 写代码。它们很强，但有一个致命痛点：它们是“瞎”的。</p>
<ul>
<li>
<p>它看不见你公司内网的 API。</p>
</li>
<li>
<p>它连不上你本地的数据库。</p>
</li>
<li>
<p>它不知道你刚写的低代码平台配置长什么样。</p>
</li>
</ul>
<p>以前，解决这个问题的办法是 Ctrl+C / Ctrl+V，把代码贴给它。但如果数据有 1GB 呢？如果需要实时操作呢？难道需要每次都粘贴一遍吗？</p>
<p>太麻烦了！</p>
<p>我们需要一种协议，能让 <code>AI</code> 在必要的时候，能自己去找这些信息！</p>
<p>这，就是 MCP (Model Context Protocol)!</p>
<h2 data-id="heading-1">一、MCP 的本质</h2>
<blockquote>
<p>你可以把它当成一个 <code>HTTP</code> 本地服务。但你需要明白，这只是类比，它目前支持两种主流协议：Stdio 本地通信 和 SSE (Server-Sent Events over HTTP) 网络服务。</p>
</blockquote>
<p>抛开那些官方定义的“大模型上下文协议”，作为前端/全栈开发者，你只需要记住一句话：</p>
<blockquote>
<p>MCP Server 就是一个“后端 API 服务”，而 AI 是你的“前端 UI”。</p>
</blockquote>
<blockquote>
<p>你按规范定义接口，AI找你要数据的时候你返给它就完事儿了。</p>
</blockquote>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1255065406f5478ab1435a12340f3188~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pG46bG855qE5pil5ZOl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769429938&amp;x-signature=nZnb77A2JZ6IxJYla9KKygYuaMk%3D" alt="" loading="lazy"/></p>
<p>以下是 <code>Web</code>开发的一些概念，映射到 <code>MCP</code> 里，你一看就懂：</p>






























<table><thead><tr><th>传统 Web 开发</th><th>MCP 开发模式</th><th>解释</th></tr></thead><tbody><tr><td>Frontend (React/Vue)</td><td>AI Client (Claude/OpenCode)</td><td>AI 负责理解用户意图，决定“点击”哪个按钮。</td></tr><tr><td>Backend (Express/Koa)</td><td>MCP Server (你的脚本)</td><td>你写的逻辑，负责干活（查库、调接口）。</td></tr><tr><td>REST/GraphQL</td><td>MCP Protocol</td><td>两者通讯的标准化协议（基于 JSON-RPC）。</td></tr><tr><td>Click Event</td><td>Tool Call</td><td>用户说“查下订单”，AI 触发工具调用。</td></tr></tbody></table>
<p>一个标准的 MCP Server 主要提供4种能力，对应到后端概念非常直观：</p>
<h3 data-id="heading-2">MCP 核心接口说明</h3>
<ol>
<li>
<p><strong>核心接口一：能力握手 (initialize)</strong></p>
<ul>
<li><strong>HTTP 类比</strong>：<code>GET /api/health</code> 或 <code>OPTIONS /</code></li>
<li><strong>MCP 协议方法</strong>：<code>initialize</code></li>
<li><strong>作用</strong>：这是整个协议的入口。当 AI（Client）第一次连接你的 MCP Server 时，它会发送这个请求。你的 Server 必须返回一个固定的 JSON 结构，告诉 AI：“我是谁（Server名），版本多少，我支持哪些能力（Resources? Tools? Prompts？）”。</li>
</ul>
</li>
<li>
<p><strong>核心接口二：资源层 (resources/*)</strong></p>
<ul>
<li><strong>总体描述</strong>：这对应 REST API 中的 <code>GET</code> 请求。它是只读的，用于把数据“喂”给 AI。</li>
<li><strong>动作</strong>：
<ul>
<li><strong>列表</strong>
<ul>
<li>HTTP 类比：<code>GET /api/files</code></li>
<li>MCP 协议方法：<code>resources/list</code></li>
<li>作用：告诉 AI 我这里有哪些文件/数据源可供查阅。</li>
</ul>
</li>
<li><strong>读取</strong>
<ul>
<li>HTTP 类比：<code>GET /api/files/:id</code></li>
<li>MCP 协议方法：<code>resources/read</code></li>
<li>作用：AI 指定一个 URI (如 <code>lcp://app/001</code>)，你返回具体的内容文本。</li>
</ul>
</li>
</ul>
</li>
<li><strong>本质</strong>：这里的接口就是让 AI 能够“看到”你系统里的数据，但不能改。</li>
</ul>
</li>
<li>
<p><strong>核心接口三：工具层 (tools/*)</strong></p>
<ul>
<li><strong>总体描述</strong>：这对应 REST API 中的 <code>POST</code> 请求。它是可执行的，用于让 AI“操作”你的系统。这是最核心的部分。</li>
<li><strong>动作</strong>：
<ul>
<li><strong>列表</strong>
<ul>
<li>HTTP 类比：<code>GET /api/functions</code> (Swagger)</li>
<li>MCP 协议方法：<code>tools/list</code></li>
<li>作用：告诉 AI 我有哪些函数可以调用（包括参数结构 JSON Schema）。</li>
</ul>
</li>
<li><strong>调用</strong>
<ul>
<li>HTTP 类比：<code>POST /api/execute</code></li>
<li>MCP 协议方法：<code>tools/call</code></li>
<li>作用：AI 发送函数名和参数（JSON），你执行逻辑并返回结果。</li>
</ul>
</li>
</ul>
</li>
<li><strong>本质</strong>：你的业务逻辑（查库、改配置、发邮件）全部封装在这里。</li>
</ul>
</li>
<li>
<p><strong>核心接口四：提示词层 (prompts/*)</strong></p>
<ul>
<li><strong>总体描述</strong>：这对应模板服务。</li>
<li><strong>动作</strong>：
<ul>
<li><strong>列表</strong>
<ul>
<li>HTTP 类比：<code>GET /api/templates</code></li>
<li>MCP 协议方法：<code>prompts/list</code></li>
<li>作用：告诉 AI 我有哪些预设的对话模板。</li>
</ul>
</li>
<li><strong>获取</strong>
<ul>
<li>HTTP 类比：<code>POST /api/render_template</code></li>
<li>MCP 协议方法：<code>prompts/get</code></li>
<li>作用：AI 选择一个模板，你把填充好上下文的 Prompt 返回给它。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 data-id="heading-3">二、 动手搭建一个基于 Node.js 的脚手架</h2>
<blockquote>
<p>也可以不是 <code>Nodejs</code>，可以是 <code>Python</code>。但我的读者大部分是前端，咱还是以<code>Nodejs</code>为例。</p>
</blockquote>
<ol>
<li>初始化项目
找个文件夹，像初始化任何前端项目一样：</li>
</ol>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-built_in">mkdir</span> my-first-mcp
<span class="hljs-built_in">cd</span> my-first-mcp
npm init -y
</code></pre>
<ol>
<li>安装依赖
我们需要两个核心包：</li>
</ol>
<ul>
<li>
<p>@modelcontextprotocol/sdk: 官方 SDK，处理通讯协议。</p>
</li>
<li>
<p>zod: 类似于 TypeScript 的运行时校验。AI 经常会传错参数，Zod 是最好的防线。</p>
</li>
</ul>
<pre><code class="hljs language-bash" lang="bash">npm install @modelcontextprotocol/sdk zod
</code></pre>
<ol>
<li>配置 ESM
打开 package.json，添加 "type": "module"，这样我们就能直接用 import 爽写代码。</li>
</ol>
<pre><code class="hljs language-JSON" lang="JSON"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"my-first-mcp"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"module"</span><span class="hljs-punctuation">,</span> 
  <span class="hljs-attr">"dependencies"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span> ... <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<ol>
<li>编写核心代码 (index.js)</li>
</ol>
<p>我们在 index.js 里写一个最简单的 Server，模拟查询你们公司低代码平台的状态。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-meta">#!/usr/bin/env node</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Server</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"@modelcontextprotocol/sdk/server/index.js"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">StdioServerTransport</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"@modelcontextprotocol/sdk/server/stdio.js"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">CallToolRequestSchema</span>, <span class="hljs-title class_">ListToolsRequestSchema</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"@modelcontextprotocol/sdk/types.js"</span>;
<span class="hljs-keyword">import</span> { z } <span class="hljs-keyword">from</span> <span class="hljs-string">"zod"</span>;

<span class="hljs-comment">// 1. 实例化 Server</span>
<span class="hljs-keyword">const</span> server = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>(
  { <span class="hljs-attr">name</span>: <span class="hljs-string">"lcp-helper"</span>, <span class="hljs-attr">version</span>: <span class="hljs-string">"1.0.0"</span> },
  { <span class="hljs-attr">capabilities</span>: { <span class="hljs-attr">tools</span>: {} } }
);

<span class="hljs-comment">// 2. 告诉 AI 我们有哪些工具 (相当于 Swagger/OpenAPI 文档)</span>
server.<span class="hljs-title function_">setRequestHandler</span>(<span class="hljs-title class_">ListToolsRequestSchema</span>, <span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">tools</span>: [
      {
        <span class="hljs-attr">name</span>: <span class="hljs-string">"get_app_info"</span>,
        <span class="hljs-attr">description</span>: <span class="hljs-string">"查询低代码平台中某个应用的状态和负责人"</span>,
        <span class="hljs-attr">inputSchema</span>: {
          <span class="hljs-attr">type</span>: <span class="hljs-string">"object"</span>,
          <span class="hljs-attr">properties</span>: {
            <span class="hljs-attr">appId</span>: { <span class="hljs-attr">type</span>: <span class="hljs-string">"string"</span>, <span class="hljs-attr">description</span>: <span class="hljs-string">"应用ID (如 app_001)"</span> },
          },
          <span class="hljs-attr">required</span>: [<span class="hljs-string">"appId"</span>],
        },
      },
    ],
  };
});

<span class="hljs-comment">// 3. 实现工具逻辑 (相当于 SpringBoot里的 Controller)</span>
server.<span class="hljs-title function_">setRequestHandler</span>(<span class="hljs-title class_">CallToolRequestSchema</span>, <span class="hljs-keyword">async</span> (request) =&gt; {
  <span class="hljs-keyword">if</span> (request.<span class="hljs-property">params</span>.<span class="hljs-property">name</span> === <span class="hljs-string">"get_app_info"</span>) {
    <span class="hljs-keyword">const</span> args = z.<span class="hljs-title function_">object</span>({ <span class="hljs-attr">appId</span>: z.<span class="hljs-title function_">string</span>() }).<span class="hljs-title function_">parse</span>(request.<span class="hljs-property">params</span>.<span class="hljs-property">arguments</span>);
    
    <span class="hljs-comment">// 这里可以换成真实的 axios 请求</span>
    <span class="hljs-comment">// const res = await axios.get(`http://api.internal.com/apps/${args.appId}`);</span>
    <span class="hljs-keyword">const</span> mockData = {
      <span class="hljs-attr">app_001</span>: { <span class="hljs-attr">name</span>: <span class="hljs-string">"HR系统"</span>, <span class="hljs-attr">status</span>: <span class="hljs-string">"Online"</span> },
      <span class="hljs-attr">app_002</span>: { <span class="hljs-attr">name</span>: <span class="hljs-string">"财务系统"</span>, <span class="hljs-attr">status</span>: <span class="hljs-string">"Down"</span> }
    };
    
    <span class="hljs-keyword">const</span> result = mockData[args.<span class="hljs-property">appId</span>] || { <span class="hljs-attr">error</span>: <span class="hljs-string">"Not Found"</span> };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">content</span>: [{ <span class="hljs-attr">type</span>: <span class="hljs-string">"text"</span>, <span class="hljs-attr">text</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(result) }],
    };
  }
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"工具不存在"</span>);
});

<span class="hljs-comment">// 4. 启动服务</span>
<span class="hljs-keyword">const</span> transport = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StdioServerTransport</span>();
<span class="hljs-keyword">await</span> server.<span class="hljs-title function_">connect</span>(transport);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"MCP Server running..."</span>);
</code></pre>
<h2 data-id="heading-4">三、 连接与调试：让 AI 连上你的后端</h2>
<p>写完了 Server，我们需要一个 Client (AI) 来连接它。</p>
<p>我们以 字节的 <code>Trae</code> 为例：</p>
<ol>
<li>点右上角的设置按钮，找到 <code>MCP</code> 选项。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/14f82fc261494f95bba1e5cebcbb9885~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pG46bG855qE5pil5ZOl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769429938&amp;x-signature=LIQTabD8po877u%2BeBUqmbbx0XiA%3D" alt="" loading="lazy"/></li>
</ol>
<p>选择 “手动添加”</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0f86e67eaded4fca9a457ed0d24be700~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pG46bG855qE5pil5ZOl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769429938&amp;x-signature=TLswf2y5mlQOSCNwKdf6rjVXplc%3D" alt="" loading="lazy"/></p>
<p>粘贴如下json配置，注意把路径改成你的工程目录：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"mcpServers"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"my-lcp-helper"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"command"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"node"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"args"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
        <span class="hljs-string">"/你的项目绝对路径/my-first-mcp/index.js"</span>
      <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"env"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">"NODE_ENV"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"production"</span>
      <span class="hljs-punctuation">}</span>
    <span class="hljs-punctuation">}</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p>然后你就能看到：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/60965910607c4b6ab321d4e23ad6941d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pG46bG855qE5pil5ZOl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769429938&amp;x-signature=%2BKhLw8N4zoeSwUQsIrSBwX%2FWSYE%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-5">四、 测试你的 MCP Server</h2>
<p>打开 <code>Trae</code> 的 AI 对话框，对话类型选“Builder With MCP”，输入：</p>
<blockquote>
<p>帮我查一下 app_001 这个应用现在是什么状态？</p>
</blockquote>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6205dc6b20c0495fa13f317e677a449e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pG46bG855qE5pil5ZOl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769429938&amp;x-signature=1McrwDrIe6xB4paB5Kl7sNHD3Co%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-6">五、 一些 Tips</h2>
<ul>
<li>
<p>禁忌的 console.log: MCP 默认使用 Stdio (标准输入输出) 通讯。</p>
<ul>
<li>
<p>OpenCode 监听你的 stdout 获取数据。</p>
</li>
<li>
<p>如果你写了 console.log("debug")，它会污染 JSON 数据流，导致连接直接报错断开。</p>
</li>
<li>
<p>解法： 调试信息一律用 console.error()，或者写到本地 log 文件里。</p>
</li>
</ul>
</li>
<li>
<p>绝对路径: 在配置文件中，永远使用绝对路径指向你的 index.js。因为 AI 启动时，工作目录可能不在你的项目里。</p>
</li>
<li>
<p>Token 安全: 不要把 API Token 硬编码在 JS 里。使用 process.env.MY_TOKEN，并在 OpenCode 的配置文件里的 env 字段注入它。</p>
</li>
</ul>
<h2 data-id="heading-7">六、 小结</h2>
<p>现在你已经搭建了一个最基础的“只读” MCP。下节课我们可以学习更复杂一些的场景。</p>
<p>下课！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[构建高性能异步图片服务器：从扁平存储到哈希分片]]></title>    <link>https://juejin.cn/post/7596926832912662591</link>    <guid>https://juejin.cn/post/7596926832912662591</guid>    <pubDate>2026-01-19T12:39:54.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7596926832912662591" data-draft-id="7593240931287433268" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="构建高性能异步图片服务器：从扁平存储到哈希分片"/> <meta itemprop="keywords" content="Python,后端"/> <meta itemprop="datePublished" content="2026-01-19T12:39:54.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Lupino"/> <meta itemprop="url" content="https://juejin.cn/user/3051900006579256"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            构建高性能异步图片服务器：从扁平存储到哈希分片
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3051900006579256/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Lupino
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-19T12:39:54.000Z" title="Mon Jan 19 2026 12:39:54 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在构建图片上传与处理服务时，随着文件数量从几万增长到千万级别，原始的“扁平化存储”和“同步处理”模式会迅速遇到瓶颈。本文总结了一套基于 Python (Sanic) 的高性能图片服务重构方案，涵盖了<strong>异步 I/O</strong>、<strong>哈希分片存储</strong>、<strong>无阻塞计算</strong>以及<strong>前后端协同</strong>的全链路优化。</p>
<h2 data-id="heading-0">一、 核心痛点</h2>
<p>在重构之前，系统存在以下主要问题：</p>
<ol>
<li><strong>文件系统瓶颈</strong>：所有文件存放在同一个根目录下，导致 <code>inode</code> 查找变慢，<code>os.listdir</code> 等操作在文件数过百万时会消耗巨大内存并阻塞系统。</li>
<li><strong>Event Loop 阻塞</strong>：图片缩放（<code>pyvips</code>）和文件删除（<code>os.remove</code>）是同步的 CPU/IO 密集型操作，直接运行在 Sanic 的异步循环中会卡死整个 Web 服务，导致高并发下 Ping 值飙升。</li>
<li><strong>缺乏扩展性</strong>：前端 URL 依赖后端数据库查询，无法利用 CDN 高效分发。</li>
</ol>
<h2 data-id="heading-1">二、 后端架构优化 (Python)</h2>
<h3 data-id="heading-2">1. 存储策略：哈希分片 (Hash Sharding)</h3>
<p>为了解决单目录文件过多的问题，我们采用了基于 SHA256 哈希的分层存储结构。</p>
<ul>
<li><strong>旧结构</strong>：<code>/uploads/abcdef12345.png</code></li>
<li><strong>新结构</strong>：<code>/uploads/ab/cd/abcdef12345.png</code></li>
</ul>
<p>通过取哈希值的前 4 位生成两级子目录（<code>256 * 256</code>），可以将千万级文件均匀分散到 65,536 个文件夹中，每个文件夹仅存放数百个文件，确保存储性能线性扩展。</p>
<p>Python</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># file.py 核心逻辑</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">get_shard_relative_path</span>(<span class="hljs-params">file_key: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:
    <span class="hljs-string">"""生成的路径结构: ab/cd/"""</span>
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(file_key) &lt; <span class="hljs-number">4</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>
    <span class="hljs-keyword">return</span> os.path.join(file_key[:<span class="hljs-number">2</span>], file_key[<span class="hljs-number">2</span>:<span class="hljs-number">4</span>])
</code></pre>
<h3 data-id="heading-3">2. 异步化与线程池 (AsyncIO + Thread Pool)</h3>
<p>为了保证 Sanic 的高并发能力，我们严格区分了 <strong>I/O 绑定</strong> 和 <strong>CPU 绑定</strong> 任务。</p>
<ul>
<li><strong>文件写入</strong>：使用 <code>aiofiles</code> 实现真正的异步写入。</li>
<li><strong>CPU/阻塞 IO</strong>：将图片缩放（Pyvips）和文件删除/查找操作封装在 <code>asyncio.to_thread</code> 中，放入线程池运行，避免阻塞主循环。</li>
</ul>
<p>Python</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> asyncio
<span class="hljs-keyword">import</span> aiofiles

<span class="hljs-comment"># 异步写入文件</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">save_file</span>(<span class="hljs-params">file_path: <span class="hljs-built_in">str</span>, content: <span class="hljs-built_in">bytes</span></span>) -&gt; <span class="hljs-literal">None</span>:
    folder = os.path.dirname(file_path)
    <span class="hljs-comment"># 异步创建目录（防止 mkdir 阻塞）</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(folder):
        <span class="hljs-keyword">await</span> asyncio.to_thread(os.makedirs, folder, exist_ok=<span class="hljs-literal">True</span>)
    
    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiofiles.<span class="hljs-built_in">open</span>(file_path, <span class="hljs-string">'wb'</span>) <span class="hljs-keyword">as</span> fp:
        <span class="hljs-keyword">await</span> fp.write(content)

<span class="hljs-comment"># 无阻塞的删除操作</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">safe_remove_file</span>(<span class="hljs-params">fid: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:
    <span class="hljs-comment"># ... 获取 file_key ...</span>
    <span class="hljs-comment"># 将耗时的 glob 查找和 remove 操作扔给线程池</span>
    <span class="hljs-keyword">await</span> asyncio.to_thread(_remove_related_files_sync, file_key)
</code></pre>
<h2 data-id="heading-4">三、 历史数据迁移</h2>
<p>针对现存的扁平结构文件，我们设计了安全的迁移脚本 <code>migrate.py</code>。</p>
<ul>
<li><strong>内存安全</strong>：使用 <code>os.scandir</code> 和 <code>glob.iglob</code> 替代 <code>os.listdir</code>，采用迭代器模式，即使遍历数亿文件也不会爆内存。</li>
<li><strong>原子性</strong>：利用 <code>os.rename</code> 在同一文件系统下的原子性，迁移瞬间完成。</li>
<li><strong>安全模式</strong>：默认开启 <code>DRY_RUN</code>，先空跑验证路径逻辑，再执行实际移动。</li>
</ul>
<p>Python</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-comment"># 迁移逻辑片段</span>
<span class="hljs-attr">shard_part</span> = get_shard_folder(filename) <span class="hljs-comment"># 计算 ab/cd</span>
<span class="hljs-attr">target_dir</span> = os.path.join(UPLOAD_PATH, shard_part)
<span class="hljs-comment"># 移动文件</span>
os.rename(entry.path, os.path.join(target_dir, filename))
</code></pre>
<h2 data-id="heading-5">四、 前端路由适配 (JavaScript/TypeScript)</h2>
<p>为了配合后端的存储变更，前端不再依赖后端返回完整 URL，而是根据 <code>file_key</code> 自动计算分片路径。这不仅减轻了数据库压力，还支持了动态的图片尺寸调整（<code>_fw</code> 参数）。</p>
<h3 data-id="heading-6">智能 URL 生成器</h3>
<p>JavaScript</p>
<pre><code class="hljs language-ini" lang="ini">/**
 * 前端根据 Hash 自动生成分片路径
 * 输入: <span class="hljs-attr">key</span>=<span class="hljs-string">"abcde..."</span>, ext=<span class="hljs-string">"png"</span>, size=<span class="hljs-number">200</span>
 * 输出: /uploads/ab/cd/abcde..._fw200.png
 */
export function getFileUrl(fileKey, fileExt, <span class="hljs-attr">size</span> = <span class="hljs-number">0</span>) {
  const <span class="hljs-attr">shard1</span> = fileKey.slice(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>)<span class="hljs-comment">;</span>
  const <span class="hljs-attr">shard2</span> = fileKey.slice(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>)<span class="hljs-comment">;</span>
  
  let <span class="hljs-attr">fileName</span> = `<span class="hljs-variable">${fileKey}</span>.<span class="hljs-variable">${fileExt}</span>`<span class="hljs-comment">;</span>
  if (size &gt; 0) {
    <span class="hljs-attr">fileName</span> = `<span class="hljs-variable">${fileKey}</span>_fw<span class="hljs-variable">${size}</span>.<span class="hljs-variable">${fileExt}</span>`<span class="hljs-comment">;</span>
  }

  return `${BASE_URL}/${shard1}/${shard2}/${fileName}`<span class="hljs-comment">;</span>
}
</code></pre>
<h3 data-id="heading-7">存量 URL 修复</h3>
<p>对于历史数据中存储的旧版 URL（不带分片路径），我们提供了一个 <code>fixFileUrl</code> 函数进行运行时自动修复。</p>
<p>JavaScript</p>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-comment">// 输入: "http://cdn.com/abcdef123.png"</span>
<span class="hljs-comment">// 输出: "http://cdn.com/ab/cd/abcdef123.png"</span>
<span class="hljs-function"><span class="hljs-keyword">export</span> function <span class="hljs-title">fixFileUrl</span><span class="hljs-params">(url, size = <span class="hljs-number">0</span>)</span> </span>{
    <span class="hljs-comment">// 自动检测是否缺少分片路径并注入</span>
    <span class="hljs-comment">// 自动处理 _fw 尺寸参数的替换</span>
}
</code></pre>
<h2 data-id="heading-8">五、 Sanic 路由集成</h2>
<p>最后，在 Web 层面上，我们确保路由处理函数也是完全异步的，能够从容应对高并发请求。</p>
<p>Python</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">'/upload/&lt;file_name:path&gt;'</span></span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">serve_uploaded_file</span>(<span class="hljs-params">request, file_name</span>):
    <span class="hljs-comment"># 在线程池中计算真实路径（包含可能发生的图片缩放计算）</span>
    real_path = <span class="hljs-keyword">await</span> asyncio.to_thread(file.get_real_file_path, file_name)

    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> real_path <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> os.path.exists(real_path):
        <span class="hljs-keyword">return</span> response.text(<span class="hljs-string">"File not found"</span>, status=<span class="hljs-number">404</span>)

    <span class="hljs-comment"># 高效流式发送</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> response.file(real_path)
</code></pre>
<h2 data-id="heading-9">总结</h2>
<p>通过这次重构，我们将一个基础的图片上传功能升级为企业级的高性能文件服务。</p>
<ol>
<li><strong>性能</strong>：消除了主线程阻塞，大幅提升了并发吞吐量 (RPS)。</li>
<li><strong>扩展性</strong>：哈希分片彻底解决了文件系统 inode 限制，支持亿级文件存储。</li>
<li><strong>可维护性</strong>：代码遵循 PEP 8，逻辑清晰，前后端通过确定性的 Hash 算法解耦。</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[基于 Nginx 与 Shell 的轻量级蓝绿部署实践：以 RuoYi-Admin 为例]]></title>    <link>https://juejin.cn/post/7596926832912646207</link>    <guid>https://juejin.cn/post/7596926832912646207</guid>    <pubDate>2026-01-19T12:39:07.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7596926832912646207" data-draft-id="7593262196843724852" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="基于 Nginx 与 Shell 的轻量级蓝绿部署实践：以 RuoYi-Admin 为例"/> <meta itemprop="keywords" content="后端,Java"/> <meta itemprop="datePublished" content="2026-01-19T12:39:07.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Lupino"/> <meta itemprop="url" content="https://juejin.cn/user/3051900006579256"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            基于 Nginx 与 Shell 的轻量级蓝绿部署实践：以 RuoYi-Admin 为例
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3051900006579256/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Lupino
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-19T12:39:07.000Z" title="Mon Jan 19 2026 12:39:07 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在持续集成/持续部署 (CI/CD) 的流程中，<strong>蓝绿部署 (Blue/Green Deployment)</strong> 是一种通过运行两个相同的生产环境（版本不同）来减少停机时间和风险的策略。</p>
<p>本文将介绍如何不依赖复杂的容器编排工具（如 K8s），仅使用 <strong>Nginx</strong>、<strong>Systemd</strong> 和 <strong>Bash Shell</strong>，为 Java 应用（如 RuoYi-Admin）构建一套稳健的蓝绿部署系统。</p>
<h2 data-id="heading-0">1. 核心架构设计</h2>
<p>我们的目标是实现<strong>零停机发布</strong>。系统由两个环境组成：</p>
<ul>
<li><strong>Blue (A)</strong> : 当前在线环境，承载用户流量。</li>
<li><strong>Green (B)</strong> : 待发布环境，部署新版本代码。</li>
</ul>
<p>切换机制：</p>
<p>通过修改 Nginx 的 upstream 配置文件指向，并重载 Nginx (reload)，将流量瞬间从旧环境切到新环境。</p>
<p><strong>目录结构示例：</strong></p>
<p>Plaintext</p>
<pre><code class="hljs language-bash" lang="bash">/data/deploy/
├── nginx/
│   ├── AorB           <span class="hljs-comment"># 状态文件，记录下一次该发 A 还是 B</span>
│   ├── upstream.conf  <span class="hljs-comment"># Nginx 实际引用的配置文件</span>
│   ├── ruoyi-admin.a.conf.tmpl <span class="hljs-comment"># 指向端口 9001 的模板</span>
│   └── ruoyi-admin.b.conf.tmpl <span class="hljs-comment"># 指向端口 9002 的模板</span>
└── system/
    ├── prod/ruoyi-admin.jar    <span class="hljs-comment"># 待发布的最新包</span>
    ├── ruoyi-admin.a.jar       <span class="hljs-comment"># A 环境运行包</span>
    └── ruoyi-admin.b.jar       <span class="hljs-comment"># B 环境运行包</span>
</code></pre>
<h2 data-id="heading-1">2. 生产级部署脚本 (Shell Implementation)</h2>
<p>以下是优化后的生产环境部署脚本。它集成了健康检查、超时控制和自动回滚逻辑。</p>
<p>Bash</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-meta">#!/usr/bin/env bash</span>

<span class="hljs-comment"># --- 1. 配置区域 ---</span>
ROOT=<span class="hljs-string">"/data/deploy"</span>
AB_FILE=<span class="hljs-string">"<span class="hljs-variable">${ROOT}</span>/nginx/AorB"</span>
JAR_SRC=<span class="hljs-string">"<span class="hljs-variable">${ROOT}</span>/system/prod/ruoyi-admin.jar"</span>

<span class="hljs-comment"># 健康检查配置：30次重试 * 2秒间隔 = 60秒超时</span>
MAX_RETRIES=30
SLEEP_SEC=2

<span class="hljs-comment"># 初始化状态文件</span>
<span class="hljs-keyword">if</span> [ ! -f <span class="hljs-string">"<span class="hljs-variable">$AB_FILE</span>"</span> ]; <span class="hljs-keyword">then</span> <span class="hljs-built_in">echo</span> <span class="hljs-string">"A"</span> &gt; <span class="hljs-string">"<span class="hljs-variable">$AB_FILE</span>"</span>; <span class="hljs-keyword">fi</span>
TARGET_KEY=$(<span class="hljs-built_in">cat</span> <span class="hljs-string">"<span class="hljs-variable">${AB_FILE}</span>"</span>)

<span class="hljs-function"><span class="hljs-title">log</span></span>() { <span class="hljs-built_in">echo</span> -e <span class="hljs-string">"<span class="hljs-subst">$(date +'%Y-%m-%d %H:%M:%S')</span> <span class="hljs-variable">$1</span>"</span>; }

<span class="hljs-comment"># --- 2. 健康检查函数 ---</span>
<span class="hljs-function"><span class="hljs-title">check_health</span></span>() {
    <span class="hljs-built_in">local</span> port=<span class="hljs-variable">$1</span>
    <span class="hljs-built_in">local</span> count=0
    <span class="hljs-built_in">local</span> url=<span class="hljs-string">"http://127.0.0.1:<span class="hljs-variable">${port}</span>/auth/code"</span> <span class="hljs-comment"># 根据实际业务接口调整</span>

    <span class="hljs-built_in">log</span> <span class="hljs-string">"正在检查端口 <span class="hljs-variable">${port}</span> 的健康状态..."</span>

    <span class="hljs-keyword">while</span> [ <span class="hljs-variable">$count</span> -lt <span class="hljs-variable">$MAX_RETRIES</span> ]; <span class="hljs-keyword">do</span>
        <span class="hljs-comment"># 静默捕获 curl 输出</span>
        <span class="hljs-built_in">local</span> resp=$(curl -s <span class="hljs-string">"<span class="hljs-variable">${url}</span>"</span>)

        <span class="hljs-comment"># 判定逻辑：根据业务返回的关键字符判断</span>
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$resp</span>"</span> | grep -q <span class="hljs-string">"操作成功"</span>; <span class="hljs-keyword">then</span>
            <span class="hljs-built_in">log</span> <span class="hljs-string">"健康检查通过 (Success)。"</span>
            <span class="hljs-built_in">return</span> 0
        <span class="hljs-keyword">elif</span> <span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$resp</span>"</span> | grep -q <span class="hljs-string">"Visit too frequently"</span>; <span class="hljs-keyword">then</span>
            <span class="hljs-built_in">log</span> <span class="hljs-string">"健康检查通过 (Rate Limit)。"</span>
            <span class="hljs-built_in">return</span> 0
        <span class="hljs-keyword">fi</span>

        <span class="hljs-built_in">echo</span> -n <span class="hljs-string">"."</span>
        <span class="hljs-built_in">sleep</span> <span class="hljs-variable">$SLEEP_SEC</span>
        ((count++))
    <span class="hljs-keyword">done</span>

    <span class="hljs-built_in">log</span> <span class="hljs-string">"\n错误：健康检查超时 (60s)。"</span>
    <span class="hljs-built_in">return</span> 1
}

<span class="hljs-comment"># --- 3. 部署核心逻辑 ---</span>
<span class="hljs-function"><span class="hljs-title">deploy</span></span>() {
    <span class="hljs-built_in">local</span> target=<span class="hljs-variable">$1</span>      <span class="hljs-comment"># e.g., "a"</span>
    <span class="hljs-built_in">local</span> port=<span class="hljs-variable">$2</span>        <span class="hljs-comment"># e.g., 9001</span>
    <span class="hljs-built_in">local</span> old_target=<span class="hljs-variable">$3</span>  <span class="hljs-comment"># e.g., "b"</span>

    <span class="hljs-built_in">log</span> <span class="hljs-string">"=== 开始部署环境: <span class="hljs-variable">${target}</span> (端口 <span class="hljs-variable">${port}</span>) ==="</span>

    <span class="hljs-comment"># 步骤 A: 复制 JAR 包</span>
    <span class="hljs-keyword">if</span> ! <span class="hljs-built_in">cp</span> <span class="hljs-string">"<span class="hljs-variable">${JAR_SRC}</span>"</span> <span class="hljs-string">"<span class="hljs-variable">${ROOT}</span>/system/ruoyi-admin.<span class="hljs-variable">${target}</span>.jar"</span>; <span class="hljs-keyword">then</span>
        <span class="hljs-built_in">log</span> <span class="hljs-string">"错误：JAR 包复制失败。"</span>
        <span class="hljs-built_in">exit</span> 1
    <span class="hljs-keyword">fi</span>

    <span class="hljs-comment"># 步骤 B: 启动新服务</span>
    <span class="hljs-built_in">log</span> <span class="hljs-string">"正在启动 Systemd 服务: ruoyi-admin.<span class="hljs-variable">${target}</span> ..."</span>
    sudo systemctl start <span class="hljs-string">"ruoyi-admin.<span class="hljs-variable">${target}</span>"</span>

    <span class="hljs-comment"># 步骤 C: 执行健康检查</span>
    <span class="hljs-keyword">if</span> ! check_health <span class="hljs-string">"<span class="hljs-variable">$port</span>"</span>; <span class="hljs-keyword">then</span>
        <span class="hljs-built_in">log</span> <span class="hljs-string">"部署失败：服务无法启动或接口异常。正在停止新服务..."</span>
        sudo systemctl stop <span class="hljs-string">"ruoyi-admin.<span class="hljs-variable">${target}</span>"</span>
        <span class="hljs-built_in">exit</span> 1
    <span class="hljs-keyword">fi</span>

    <span class="hljs-comment"># 步骤 D: 切换流量 (Nginx)</span>
    <span class="hljs-built_in">log</span> <span class="hljs-string">"服务健康。正在切换 Nginx 流量..."</span>
    <span class="hljs-built_in">cp</span> <span class="hljs-string">"<span class="hljs-variable">${ROOT}</span>/nginx/ruoyi-admin.<span class="hljs-variable">${target}</span>.conf.tmpl"</span> <span class="hljs-string">"<span class="hljs-variable">${ROOT}</span>/nginx/upstream.conf"</span>

    <span class="hljs-comment"># 预检 Nginx 配置，防止配置错误导致整个服务挂掉</span>
    <span class="hljs-keyword">if</span> ! sudo nginx -t; <span class="hljs-keyword">then</span>
        <span class="hljs-built_in">log</span> <span class="hljs-string">"错误：Nginx 配置测试失败，取消切换。"</span>
        <span class="hljs-built_in">exit</span> 1
    <span class="hljs-keyword">fi</span>

    sudo nginx -s reload
    <span class="hljs-built_in">log</span> <span class="hljs-string">"Nginx 重载成功，流量已切换。"</span>

    <span class="hljs-comment"># 步骤 E: 下线旧服务</span>
    <span class="hljs-built_in">log</span> <span class="hljs-string">"正在停止旧服务: ruoyi-admin.<span class="hljs-variable">${old_target}</span> ..."</span>
    sudo systemctl stop <span class="hljs-string">"ruoyi-admin.<span class="hljs-variable">${old_target}</span>"</span>

    <span class="hljs-comment"># 步骤 F: 更新状态标记</span>
    <span class="hljs-built_in">local</span> next_target=<span class="hljs-string">"A"</span>
    [ <span class="hljs-string">"<span class="hljs-variable">$target</span>"</span> == <span class="hljs-string">"a"</span> ] &amp;&amp; next_target=<span class="hljs-string">"B"</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$next_target</span>"</span> &gt; <span class="hljs-string">"<span class="hljs-variable">${AB_FILE}</span>"</span>

    <span class="hljs-built_in">log</span> <span class="hljs-string">"=== 部署成功。下一次发布目标: <span class="hljs-variable">${next_target}</span> ==="</span>
}

<span class="hljs-comment"># --- 4. 主流程入口 ---</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"本次发布目标: <span class="hljs-variable">$TARGET_KEY</span>"</span>

<span class="hljs-keyword">if</span> [ <span class="hljs-string">"<span class="hljs-variable">$TARGET_KEY</span>"</span> == <span class="hljs-string">"A"</span> ]; <span class="hljs-keyword">then</span>
    deploy <span class="hljs-string">"a"</span> 9001 <span class="hljs-string">"b"</span>
<span class="hljs-keyword">elif</span> [ <span class="hljs-string">"<span class="hljs-variable">$TARGET_KEY</span>"</span> == <span class="hljs-string">"B"</span> ]; <span class="hljs-keyword">then</span>
    deploy <span class="hljs-string">"b"</span> 9002 <span class="hljs-string">"a"</span>
<span class="hljs-keyword">else</span>
    <span class="hljs-built_in">log</span> <span class="hljs-string">"错误：状态文件内容异常 (<span class="hljs-variable">$TARGET_KEY</span>)，必须为 A 或 B。"</span>
    <span class="hljs-built_in">exit</span> 1
<span class="hljs-keyword">fi</span>
</code></pre>
<h2 data-id="heading-2">3. 技术要点解析</h2>
<h3 data-id="heading-3">3.1 拒绝无限等待 (Timeout Mechanism)</h3>
<p>旧脚本中常见的错误是使用 while true 轮询服务状态。如果新代码引入了 Bug 导致 Spring Boot 启动报错，脚本会陷入死循环，阻塞 CI/CD 流水线。</p>
<p>改进： 引入计数器 count 和最大重试次数 MAX_RETRIES。一旦超时，脚本立即退出并返回错误码（Non-zero exit code），通知发布系统构建失败。</p>
<h3 data-id="heading-4">3.2 优雅的流量切换</h3>
<p>Nginx 的 reload 命令是平滑的，它不会中断现有的连接。</p>
<p>关键步骤：</p>
<ol>
<li><code>cp ... upstream.conf</code>: 覆盖配置文件。</li>
<li><code>nginx -t</code>: <strong>必须</strong>先测试配置文件的语法正确性。</li>
<li><code>nginx -s reload</code>: 仅在测试通过后重载。</li>
</ol>
<h3 data-id="heading-5">3.3 状态管理与幂等性</h3>
<p>使用一个简单的文本文件 (<code>AorB</code>) 来持久化存储当前的状态。这比依赖内存或复杂的数据库更可靠且易于调试。脚本的逻辑是“读当前 -&gt; 部署当前 -&gt; 写入下一次”，形成闭环。</p>
<h3 data-id="heading-6">3.4 容错处理 (Fail-Safe)</h3>
<p>脚本中加入了大量的错误检查（<code>|| exit 1</code>）。</p>
<ul>
<li><strong>场景</strong>：如果 <code>cp</code> 命令因为磁盘满失败了，脚本会立即停止，而不是去启动一个空文件。</li>
<li><strong>场景</strong>：如果健康检查失败，脚本会主动调用 <code>stop</code> 命令清理刚才启动的脏进程，保持环境整洁。</li>
</ul>
<h2 data-id="heading-7">4. 总结</h2>
<p>通过这段 Shell 脚本，我们以极低的成本实现了 Java 应用的自动化蓝绿部署。它具备了商业级发布系统的基本要素：<strong>可观测性</strong>（日志）、<strong>健壮性</strong>（超时与回滚）和<strong>零停机能力</strong>。</p>
<p>对于中小型项目，这往往是比迁移到 Kubernetes 性价比更高的选择。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[【保姆级教程】Ubuntu 环境下 Docker 安装与网络代理配置指南]]></title>    <link>https://juejin.cn/post/7596883689827123263</link>    <guid>https://juejin.cn/post/7596883689827123263</guid>    <pubDate>2026-01-19T12:40:26.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7596883689827123263" data-draft-id="7593338828196708392" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="【保姆级教程】Ubuntu 环境下 Docker 安装与网络代理配置指南"/> <meta itemprop="keywords" content="Docker,容器"/> <meta itemprop="datePublished" content="2026-01-19T12:40:26.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Lupino"/> <meta itemprop="url" content="https://juejin.cn/user/3051900006579256"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            【保姆级教程】Ubuntu 环境下 Docker 安装与网络代理配置指南
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3051900006579256/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Lupino
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-19T12:40:26.000Z" title="Mon Jan 19 2026 12:40:26 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在 Linux 服务器（Ubuntu）上部署服务时，Docker 是最基础的工具。但在国内网络环境下，不仅安装过程可能缓慢，安装后的镜像拉取（<code>docker pull</code>）也常因网络超时而失败。</p>
<p>本文整合了<strong>官方标准安装步骤</strong>与<strong>网络代理配置方案</strong>，助您在 Ubuntu 上快速搭建稳定的 Docker 环境。</p>
<hr/>
<h2 data-id="heading-0">第一部分：安装 Docker Engine (标准版)</h2>
<p>我们推荐使用 Docker 官方源安装，以确保版本最新且稳定。</p>
<h3 data-id="heading-1">1. 卸载旧版本（可选）</h3>
<p>如果系统之前安装过旧版 Docker，建议先清理，避免冲突：</p>
<p>Bash</p>
<pre><code class="hljs language-arduino" lang="arduino">sudo apt-get remove docker docker-engine docker.io containerd runc
</code></pre>
<h3 data-id="heading-2">2. 配置官方软件源</h3>
<p>安装必要的依赖工具，并添加 Docker 的 GPG 密钥和仓库地址：</p>
<p>Bash</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 更新索引并安装依赖</span>
sudo apt-get update
sudo apt-get install ca-certificates curl gnupg

<span class="hljs-comment"># 添加 Docker 官方 GPG 密钥</span>
sudo install -m 0755 -d /etc/apt/keyrings
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
sudo <span class="hljs-built_in">chmod</span> a+r /etc/apt/keyrings/docker.gpg

<span class="hljs-comment"># 写入软件源信息</span>
<span class="hljs-built_in">echo</span> \
  <span class="hljs-string">"deb [arch=<span class="hljs-subst">$(dpkg --print-architecture)</span> signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
  <span class="hljs-subst">$(. /etc/os-release &amp;&amp; echo <span class="hljs-string">"<span class="hljs-variable">$VERSION_CODENAME</span>"</span>)</span> stable"</span> | \
  sudo <span class="hljs-built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null
</code></pre>
<h3 data-id="heading-3">3. 正式安装</h3>
<p>更新索引（让系统识别新加入的源）并安装：</p>
<p>Bash</p>
<pre><code class="hljs language-sql" lang="sql">sudo apt<span class="hljs-operator">-</span><span class="hljs-keyword">get</span> <span class="hljs-keyword">update</span>
sudo apt<span class="hljs-operator">-</span><span class="hljs-keyword">get</span> install docker<span class="hljs-operator">-</span>ce docker<span class="hljs-operator">-</span>ce<span class="hljs-operator">-</span>cli containerd.io docker<span class="hljs-operator">-</span>buildx<span class="hljs-operator">-</span>plugin docker<span class="hljs-operator">-</span>compose<span class="hljs-operator">-</span>plugin
</code></pre>
<hr/>
<h2 data-id="heading-4">第二部分：配置 Docker 代理 (解决镜像拉取失败)</h2>
<p>安装完成后，直接运行 <code>docker pull</code> 往往会超时。最彻底的解决方法是让 Docker 守护进程（Daemon）走代理。</p>
<h3 data-id="heading-5">1. 创建 Systemd 配置目录</h3>
<p>Docker 服务由 systemd 管理，我们需要覆盖其默认配置。</p>
<p>Bash</p>
<pre><code class="hljs language-bash" lang="bash">sudo <span class="hljs-built_in">mkdir</span> -p /etc/systemd/system/docker.service.d
</code></pre>
<h3 data-id="heading-6">2. 编辑代理配置文件</h3>
<p>创建文件 <code>/etc/systemd/system/docker.service.d/http-proxy.conf</code>：</p>
<p>Bash</p>
<pre><code class="hljs language-bash" lang="bash">sudo nano /etc/systemd/system/docker.service.d/http-proxy.conf
</code></pre>
<h3 data-id="heading-7">3. 填入代理信息</h3>
<p>将下方内容的 <code>127.0.0.1:7890</code> 替换为您实际的代理服务器 IP 和端口（例如局域网内的 Clash/V2Ray 端口）：</p>
<p>Ini, TOML</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-section">[Service]</span>
<span class="hljs-attr">Environment</span>=<span class="hljs-string">"HTTP_PROXY=http://127.0.0.1:7890"</span>
<span class="hljs-attr">Environment</span>=<span class="hljs-string">"HTTPS_PROXY=http://127.0.0.1:7890"</span>
<span class="hljs-attr">Environment</span>=<span class="hljs-string">"NO_PROXY=localhost,127.0.0.1,::1"</span>
</code></pre>
<p><em>(注：<code>NO_PROXY</code> 用于确保本地通讯不走代理，保持性能。)</em></p>
<h3 data-id="heading-8">4. 重载配置并重启服务</h3>
<p>修改 systemd 配置后，必须执行重载才能生效：</p>
<p>Bash</p>
<pre><code class="hljs">sudo systemctl daemon-reload
sudo systemctl restart docker
</code></pre>
<hr/>
<h2 data-id="heading-9">第三部分：验证与优化</h2>
<h3 data-id="heading-10">1. 检查代理是否生效</h3>
<p>运行以下命令，查看输出的环境变量中是否包含 Proxy 信息：</p>
<p>Bash</p>
<pre><code class="hljs language-javascript" lang="javascript">sudo docker info | grep <span class="hljs-title class_">Proxy</span>
</code></pre>
<p><em>如果输出显示了您配置的 IP 和端口，说明配置成功。</em></p>
<h3 data-id="heading-11">2. 测试拉取镜像</h3>
<p>运行 Hello World 容器，测试是否能连通 Docker Hub：</p>
<p>Bash</p>
<pre><code class="hljs language-arduino" lang="arduino">sudo docker run hello-world
</code></pre>
<h3 data-id="heading-12">3. (可选) 免 Sudo 使用 Docker</h3>
<p>默认情况下 Docker 需要 root 权限。如果您想直接使用 <code>docker</code> 命令而不是 <code>sudo docker</code>，请执行：</p>
<p>Bash</p>
<pre><code class="hljs language-bash" lang="bash">sudo groupadd docker          <span class="hljs-comment"># 创建组（通常已存在）</span>
sudo usermod -aG docker <span class="hljs-variable">$USER</span> <span class="hljs-comment"># 将当前用户加入组</span>
newgrp docker                 <span class="hljs-comment"># 立即刷新组权限</span>
</code></pre>
<hr/>
<p><strong>总结</strong>：通过上述步骤，您已经拥有了一个安装规范、且具备科学网络环境的 Docker 平台，可以顺畅地拉取和运行各类容器服务了。</p>
<p><strong>下一步：</strong> 需要为您介绍如何使用 <strong>Portainer</strong> 来通过网页图形化界面管理这些 Docker 容器吗？</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[OpenSearch 容器报错 "GC did not bring memory usage down" 的排查与解决]]></title>    <link>https://juejin.cn/post/7596926832912678975</link>    <guid>https://juejin.cn/post/7596926832912678975</guid>    <pubDate>2026-01-19T12:40:59.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7596926832912678975" data-draft-id="7593258683750449186" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="OpenSearch 容器报错 &quot;GC did not bring memory usage down&quot; 的排查与解决"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-01-19T12:40:59.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Lupino"/> <meta itemprop="url" content="https://juejin.cn/user/3051900006579256"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            OpenSearch 容器报错 "GC did not bring memory usage down" 的排查与解决
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3051900006579256/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Lupino
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-19T12:40:59.000Z" title="Mon Jan 19 2026 12:40:59 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在运维 OpenSearch（或 Elasticsearch）容器时，我们可能会遇到服务响应变慢，最终导致节点崩溃的情况。查看日志时，最显著的特征是大量的垃圾回收（GC）日志，以及内存无法释放的警告。</p>
<p>本文将基于一个真实的 Docker 容器日志案例，分析其背后的原因——<strong>堆内存耗尽（Heap Starvation）</strong> ，并提供完整的解决方案。</p>
<h2 data-id="heading-0">1. 故障现象</h2>
<p>OpenSearch 节点运行一段时间后，日志中开始疯狂刷屏以下内容：</p>
<p>Plaintext</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-attr">[INFO ]</span><span class="hljs-selector-attr">[o.o.i.b.HierarchyCircuitBreakerService]</span> attempting <span class="hljs-selector-tag">to</span> trigger G1GC due <span class="hljs-selector-tag">to</span> high heap usage <span class="hljs-selector-attr">[128000752]</span>
<span class="hljs-selector-attr">[INFO ]</span><span class="hljs-selector-attr">[o.o.i.b.HierarchyCircuitBreakerService]</span> GC did not bring memory usage down, before <span class="hljs-selector-attr">[128000752]</span>, after <span class="hljs-selector-attr">[129132568]</span>, allocations <span class="hljs-selector-attr">[1]</span>, duration <span class="hljs-selector-attr">[3]</span>
<span class="hljs-selector-attr">[INFO ]</span><span class="hljs-selector-attr">[o.o.i.b.HierarchyCircuitBreakerService]</span> attempting <span class="hljs-selector-tag">to</span> trigger G1GC due <span class="hljs-selector-tag">to</span> high heap usage <span class="hljs-selector-attr">[128004120]</span>
<span class="hljs-selector-attr">[INFO ]</span><span class="hljs-selector-attr">[o.o.i.b.HierarchyCircuitBreakerService]</span> GC did not bring memory usage down...
</code></pre>
<p><strong>关键指标分析：</strong></p>
<ul>
<li><strong>频率极高</strong>：几乎每隔几秒甚至几毫秒就尝试一次 GC。</li>
<li><strong>结果无效</strong>：日志明确指出 <code>GC did not bring memory usage down</code>（GC 未能降低内存使用）。</li>
<li><strong>数值异常</strong>：日志中的 <code>[128000752]</code> 单位是字节，换算下来大约只有 <strong>122 MB</strong>。</li>
</ul>
<h2 data-id="heading-1">2. 深度解读：为什么会发生？</h2>
<p>这一现象通常被称为 <strong>"Stop-the-world"</strong> 的前兆或 <strong>Heap Starvation（堆内存饥饿）</strong> 。</p>
<ol>
<li>
<p>内存分配过小：</p>
<p>从日志数值看，OpenSearch 仅分配了约 128MB 的堆内存。对于基于 Java 的搜索引擎来说，这几乎是“无法生存”的。OpenSearch 启动加载索引元数据、插件和缓存就需要消耗大量内存。</p>
</li>
<li>
<p>GC 机制失效：</p>
<p>JVM 的 G1GC（垃圾回收器）试图清理内存，但发现堆中所有的对象都是“存活”的（Live Objects），无法回收。</p>
</li>
<li>
<p>熔断机制（Circuit Breaker）：</p>
<p>OpenSearch 内部有熔断机制防止 OOM（内存溢出），它检测到内存过高，主动触发 GC，但由于物理上限太低，这种挣扎是徒劳的，最终会导致节点 Crash。</p>
</li>
</ol>
<h2 data-id="heading-2">3. 解决方案</h2>
<p>如果是通过 Docker 或 Docker Compose 部署，通常是因为没有显式配置 JVM 内存参数，导致其使用了极低的默认值。</p>
<h3 data-id="heading-3">第一步：调整 Docker Compose 配置</h3>
<p>我们需要通过环境变量 <code>OPENSEARCH_JAVA_OPTS</code> 来手动指定堆内存大小（Heap Size）。</p>
<p><strong>建议配置：</strong></p>
<ul>
<li><strong>开发/测试环境</strong>：至少 <code>512m</code> 或 <code>1g</code>。</li>
<li><strong>生产环境</strong>：建议设置为物理内存的 50%（例如 8G 内存机器给 4G），上限通常不超过 32G。</li>
</ul>
<p>修改 <code>docker-compose.yml</code>：</p>
<p>YAML</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">'3'</span>
<span class="hljs-attr">services:</span>
  <span class="hljs-attr">opensearch:</span>
    <span class="hljs-attr">image:</span> <span class="hljs-string">opensearchproject/opensearch:latest</span>
    <span class="hljs-attr">container_name:</span> <span class="hljs-string">opensearch-1</span>
    <span class="hljs-attr">environment:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">discovery.type=single-node</span>
      <span class="hljs-comment"># ✅ 核心修复：显式设置堆内存大小（此处示例为 1GB）</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">"OPENSEARCH_JAVA_OPTS=-Xms1024m -Xmx1024m"</span>
      <span class="hljs-comment"># ✅ 推荐：锁定内存，防止 swap 导致性能下降</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">bootstrap.memory_lock=true</span> 
    <span class="hljs-attr">ulimits:</span>
      <span class="hljs-attr">memlock:</span>
        <span class="hljs-attr">soft:</span> <span class="hljs-number">-1</span>
        <span class="hljs-attr">hard:</span> <span class="hljs-number">-1</span>
    <span class="hljs-attr">ports:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-number">9200</span><span class="hljs-string">:9200</span>
      <span class="hljs-bullet">-</span> <span class="hljs-number">9600</span><span class="hljs-string">:9600</span>
</code></pre>
<h3 data-id="heading-4">第二步：调整宿主机内核参数（必须）</h3>
<p>OpenSearch 使用 <code>mmapfs</code> 存储索引，默认的 Linux 参数通常太小，会导致启动报错。必须在<strong>宿主机</strong>（运行 Docker 的机器）上执行：</p>
<p>Bash</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 临时生效（重启后失效）</span>
sudo sysctl -w vm.max_map_count=262144

<span class="hljs-comment"># 永久生效（推荐）</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"vm.max_map_count=262144"</span> | sudo <span class="hljs-built_in">tee</span> -a /etc/sysctl.conf
sudo sysctl -p
</code></pre>
<h3 data-id="heading-5">第三步：重启服务</h3>
<p>Bash</p>
<pre><code class="hljs">docker-compose down
docker-compose up -d
</code></pre>
<h2 data-id="heading-6">4. 验证修复</h2>
<p>服务启动后，可以通过以下命令检查内存分配是否生效：</p>
<p>Bash</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 查看容器状态</span>
docker stats opensearch-1
</code></pre>
<p>或者直接请求 API 查看 JVM 统计信息：</p>
<p>Bash</p>
<pre><code class="hljs language-sql" lang="sql">curl <span class="hljs-operator">-</span>X <span class="hljs-keyword">GET</span> "https://localhost:9200/_nodes/stats/jvm?pretty" <span class="hljs-operator">-</span>k <span class="hljs-operator">-</span>u admin:admin
</code></pre>
<p><em>(注：如果有配置账号密码，请替换 admin:admin)</em></p>
<p>在返回的 JSON 中，关注 <code>jvm.mem.heap_max_in_bytes</code>，确认其数值已接近你设置的大小（例如 1GB 约为 1073741824）。</p>
<h2 data-id="heading-7">总结</h2>
<p>看到 <code>GC did not bring memory usage down</code> 只有一种含义：<strong>给的内存太少了</strong>。不要试图通过调整 GC 算法来解决此问题，直接增加 <code>-Xms</code> 和 <code>-Xmx</code> 是最直接、最有效的方案。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Spring Test 从入门到实战]]></title>    <link>https://juejin.cn/post/7596845113281085449</link>    <guid>https://juejin.cn/post/7596845113281085449</guid>    <pubDate>2026-01-19T11:19:41.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7596845113281085449" data-draft-id="7596904122865106995" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Spring Test 从入门到实战"/> <meta itemprop="keywords" content="Spring"/> <meta itemprop="datePublished" content="2026-01-19T11:19:41.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="雨中飘荡的记忆"/> <meta itemprop="url" content="https://juejin.cn/user/694547077666606"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Spring Test 从入门到实战
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/694547077666606/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    雨中飘荡的记忆
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-19T11:19:41.000Z" title="Mon Jan 19 2026 11:19:41 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">Spring Test 从入门到实战</h2>
<blockquote>
<p><strong>摘要</strong>：本文将带你从零开始，循序渐进地学习Spring Test框架。你将掌握单元测试、集成测试、Mock测试等核心技能！</p>
</blockquote>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f09ea3890c174ac6973b7bf48e9bfb53~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuo5Lit6aOY6I2h55qE6K6w5b-G:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769426381&amp;x-signature=CMerEpth9KK2fb9gNgOH0gjkblY%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-1">Spring Test 概述</h3>
<p>Spring Test是Spring框架提供的测试模块，它简化了Spring应用程序的测试过程。通过Spring Test，我们可以：</p>
<ul>
<li><strong>快速编写测试</strong>：无需手动创建Spring上下文</li>
<li><strong>依赖注入</strong>：自动注入测试所需的Bean</li>
<li><strong>事务管理</strong>：支持测试中的事务回滚</li>
<li><strong>集成测试</strong>：轻松进行Web层、Service层的集成测试</li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1cd101095d2845959d8e9dff7e4b324d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuo5Lit6aOY6I2h55qE6K6w5b-G:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769426381&amp;x-signature=QChmXEQ2NSiknK%2F9K9o26WIB2eI%3D" alt="" loading="lazy"/></p>
<h4 data-id="heading-2">核心优势</h4>
<ol>
<li><strong>简化配置</strong>：通过注解自动配置测试环境</li>
<li><strong>上下文缓存</strong>：提高测试执行效率</li>
<li><strong>丰富的断言</strong>：提供多种断言方法</li>
<li><strong>Mock支持</strong>：与Mockito完美集成</li>
</ol>
<h3 data-id="heading-3">环境搭建</h3>
<h4 data-id="heading-4">Maven依赖配置</h4>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- Spring Boot Test Starter --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- JUnit 5 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- Mockito --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mockito<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mockito-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- AssertJ --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.assertj<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>assertj-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>
</code></pre>
<h3 data-id="heading-5">核心注解详解</h3>
<h4 data-id="heading-6">1. @SpringBootTest</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@SpringBootTest</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceTest</span> {

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> UserService userService;

    <span class="hljs-meta">@Test</span>
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testFindUserById</span><span class="hljs-params">()</span> {
        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userService.findUserById(<span class="hljs-number">1L</span>);
        assertThat(user).isNotNull();
        assertThat(user.getId()).isEqualTo(<span class="hljs-number">1L</span>);
    }
}
</code></pre>
<h4 data-id="heading-7">2. @TestConfiguration</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@TestConfiguration</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">TestConfig</span> {

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-keyword">public</span> UserService <span class="hljs-title function_">userService</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserService</span>();
    }
}
</code></pre>
<h4 data-id="heading-8">3. @AutoConfigureMockMvc</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@SpringBootTest</span>
<span class="hljs-meta">@AutoConfigureMockMvc</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">UserControllerTest</span> {

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> MockMvc mockMvc;

    <span class="hljs-meta">@Test</span>
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testGetUser</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception {
        mockMvc.perform(get(<span class="hljs-string">"/api/users/1"</span>))
               .andExpect(status().isOk())
               .andExpect(jsonPath(<span class="hljs-string">"$.id"</span>).value(<span class="hljs-number">1</span>));
    }
}
</code></pre>
<h3 data-id="heading-9">测试生命周期</h3>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/00de66675e8f416d85e8c41addb27d0c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuo5Lit6aOY6I2h55qE6K6w5b-G:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769426381&amp;x-signature=UvhoHhdwA3xSkjbwnZYuBVzF7LQ%3D" alt="" loading="lazy"/></p>
<h4 data-id="heading-10">生命周期方法</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@SpringBootTest</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">LifecycleTest</span> {

    <span class="hljs-meta">@BeforeAll</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setup</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// 在所有测试方法执行前运行一次</span>
        System.out.println(<span class="hljs-string">"BeforeAll: 初始化测试环境"</span>);
    }

    <span class="hljs-meta">@BeforeEach</span>
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeEach</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// 在每个测试方法执行前运行</span>
        System.out.println(<span class="hljs-string">"BeforeEach: 准备测试数据"</span>);
    }

    <span class="hljs-meta">@Test</span>
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> {
        System.out.println(<span class="hljs-string">"Test1: 执行测试"</span>);
    }

    <span class="hljs-meta">@Test</span>
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span> {
        System.out.println(<span class="hljs-string">"Test2: 执行测试"</span>);
    }

    <span class="hljs-meta">@AfterEach</span>
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterEach</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// 在每个测试方法执行后运行</span>
        System.out.println(<span class="hljs-string">"AfterEach: 清理测试数据"</span>);
    }

    <span class="hljs-meta">@AfterAll</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tearDown</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// 在所有测试方法执行后运行一次</span>
        System.out.println(<span class="hljs-string">"AfterAll: 清理测试环境"</span>);
    }
}
</code></pre>
<h3 data-id="heading-11">实战案例</h3>
<h4 data-id="heading-12">案例1：用户服务单元测试</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@SpringBootTest</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceTest</span> {

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> UserService userService;

    <span class="hljs-meta">@Test</span>
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testCreateUser</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// Given</span>
        <span class="hljs-type">UserDTO</span> <span class="hljs-variable">userDTO</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDTO</span>(<span class="hljs-string">"张三"</span>, <span class="hljs-string">"zhangsan@example.com"</span>);

        <span class="hljs-comment">// When</span>
        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userService.createUser(userDTO);

        <span class="hljs-comment">// Then</span>
        assertThat(user).isNotNull();
        assertThat(user.getName()).isEqualTo(<span class="hljs-string">"张三"</span>);
        assertThat(user.getEmail()).isEqualTo(<span class="hljs-string">"zhangsan@example.com"</span>);
        assertThat(user.getId()).isNotNull();
    }

    <span class="hljs-meta">@Test</span>
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testCreateUserWithExistingEmail</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// Given</span>
        <span class="hljs-type">UserDTO</span> <span class="hljs-variable">userDTO</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDTO</span>(<span class="hljs-string">"李四"</span>, <span class="hljs-string">"zhangsan@example.com"</span>);

        <span class="hljs-comment">// When &amp; Then</span>
        assertThrows(UserAlreadyExistsException.class, () -&gt; {
            userService.createUser(userDTO);
        });
    }
}
</code></pre>
<h4 data-id="heading-13">案例2：REST API集成测试</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@SpringBootTest</span>
<span class="hljs-meta">@AutoConfigureMockMvc</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">UserControllerTest</span> {

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> MockMvc mockMvc;

    <span class="hljs-meta">@Test</span>
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testGetUserById</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-comment">// When &amp; Then</span>
        mockMvc.perform(get(<span class="hljs-string">"/api/users/1"</span>))
               .andExpect(status().isOk())
               .andExpect(jsonPath(<span class="hljs-string">"$.id"</span>).value(<span class="hljs-number">1</span>))
               .andExpect(jsonPath(<span class="hljs-string">"$.name"</span>).value(<span class="hljs-string">"张三"</span>));
    }

    <span class="hljs-meta">@Test</span>
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testCreateUser</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-comment">// Given</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">userJson</span> <span class="hljs-operator">=</span> <span class="hljs-string">"""
            {
                "name": "王五",
                "email": "wangwu@example.com"
            }
            """</span>;

        <span class="hljs-comment">// When &amp; Then</span>
        mockMvc.perform(post(<span class="hljs-string">"/api/users"</span>)
               .contentType(MediaType.APPLICATION_JSON)
               .content(userJson))
               .andExpect(status().isCreated())
               .andExpect(jsonPath(<span class="hljs-string">"$.name"</span>).value(<span class="hljs-string">"王五"</span>));
    }
}
</code></pre>
<h4 data-id="heading-14">案例3：使用Mock进行测试</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@SpringBootTest</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceWithMockTest</span> {

    <span class="hljs-meta">@MockBean</span>
    <span class="hljs-keyword">private</span> UserRepository userRepository;

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> UserService userService;

    <span class="hljs-meta">@Test</span>
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testFindUserById_NotFound</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// Given</span>
        when(userRepository.findById(<span class="hljs-number">1L</span>)).thenReturn(Optional.empty());

        <span class="hljs-comment">// When &amp; Then</span>
        assertThrows(UserNotFoundException.class, () -&gt; {
            userService.findUserById(<span class="hljs-number">1L</span>);
        });
    }

    <span class="hljs-meta">@Test</span>
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testUpdateUser_Success</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// Given</span>
        <span class="hljs-type">User</span> <span class="hljs-variable">existingUser</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-number">1L</span>, <span class="hljs-string">"张三"</span>, <span class="hljs-string">"zhangsan@example.com"</span>);
        when(userRepository.findById(<span class="hljs-number">1L</span>)).thenReturn(Optional.of(existingUser));
        when(userRepository.save(any(User.class))).thenReturn(existingUser);

        <span class="hljs-type">UserDTO</span> <span class="hljs-variable">updateDTO</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDTO</span>(<span class="hljs-string">"张三三"</span>, <span class="hljs-string">"zhangsan3@example.com"</span>);

        <span class="hljs-comment">// When</span>
        <span class="hljs-type">User</span> <span class="hljs-variable">updatedUser</span> <span class="hljs-operator">=</span> userService.updateUser(<span class="hljs-number">1L</span>, updateDTO);

        <span class="hljs-comment">// Then</span>
        assertThat(updatedUser.getEmail()).isEqualTo(<span class="hljs-string">"zhangsan3@example.com"</span>);
        verify(userRepository).save(any(User.class));
    }
}
</code></pre>
<h4 data-id="heading-15">案例4：事务测试</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@SpringBootTest</span>
<span class="hljs-meta">@Transactional</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">TransactionalUserServiceTest</span> {

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> UserService userService;

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> UserRepository userRepository;

    <span class="hljs-meta">@Test</span>
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testCreateUser_WithTransaction</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// Given</span>
        <span class="hljs-type">UserDTO</span> <span class="hljs-variable">userDTO</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDTO</span>(<span class="hljs-string">"赵六"</span>, <span class="hljs-string">"zhaoliu@example.com"</span>);

        <span class="hljs-comment">// When</span>
        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userService.createUser(userDTO);

        <span class="hljs-comment">// Then</span>
        assertThat(user).isNotNull();
        assertThat(userRepository.count()).isEqualTo(<span class="hljs-number">1</span>);
    }

    <span class="hljs-meta">@Test</span>
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testCreateUser_WithoutTransaction</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// Given</span>
        <span class="hljs-type">UserDTO</span> <span class="hljs-variable">userDTO</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDTO</span>(<span class="hljs-string">"钱七"</span>, <span class="hljs-string">"qianqi@example.com"</span>);

        <span class="hljs-comment">// When</span>
        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userService.createUserWithoutTransaction(userDTO);

        <span class="hljs-comment">// Then</span>
        assertThat(user).isNotNull();
        <span class="hljs-comment">// 数据会被回滚</span>
        assertThat(userRepository.count()).isEqualTo(<span class="hljs-number">0</span>);
    }
}
</code></pre>
<h3 data-id="heading-16">高级特性</h3>
<h4 data-id="heading-17">1. 参数化测试</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@ParameterizedTest</span>
<span class="hljs-meta">@ValueSource(strings = {"test1@example.com", "test2@example.com", "test3@example.com"})</span>
<span class="hljs-keyword">void</span> <span class="hljs-title function_">testEmailValidation</span><span class="hljs-params">(String email)</span> {
    assertThat(EmailValidator.isValidEmail(email)).isTrue();
}

<span class="hljs-meta">@ParameterizedTest</span>
<span class="hljs-meta">@MethodSource("provideUserDTOs")</span>
<span class="hljs-keyword">void</span> <span class="hljs-title function_">testCreateUserWithDifferentData</span><span class="hljs-params">(UserDTO userDTO)</span> {
    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userService.createUser(userDTO);
    assertThat(user).isNotNull();
    assertThat(user.getEmail()).isEqualTo(userDTO.getEmail());
}

<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Stream&lt;Arguments&gt; <span class="hljs-title function_">provideUserDTOs</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">return</span> Stream.of(
        Arguments.of(<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDTO</span>(<span class="hljs-string">"用户1"</span>, <span class="hljs-string">"user1@example.com"</span>)),
        Arguments.of(<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDTO</span>(<span class="hljs-string">"用户2"</span>, <span class="hljs-string">"user2@example.com"</span>)),
        Arguments.of(<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDTO</span>(<span class="hljs-string">"用户3"</span>, <span class="hljs-string">"user3@example.com"</span>))
    );
}
</code></pre>
<h4 data-id="heading-18">2. 性能测试</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@SpringBootTest</span>
<span class="hljs-meta">@BenchmarkMode(Mode.AverageTime)</span>
<span class="hljs-meta">@OutputTimeUnit(TimeUnit.MILLISECONDS)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PerformanceTest</span> {

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> UserService userService;

    <span class="hljs-meta">@Test</span>
    <span class="hljs-meta">@Benchmark</span>
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testUserServicePerformance</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// 测试性能</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) {
            userService.findUserById((<span class="hljs-type">long</span>) i);
        }
    }
}
</code></pre>
<h4 data-id="heading-19">测试覆盖率</h4>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fc7a66d8d22d475c988902fe43c65e10~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuo5Lit6aOY6I2h55qE6K6w5b-G:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769426381&amp;x-signature=Lpdk%2FkZYoKct%2FR6%2FRUrucT%2FCalc%3D" alt="" loading="lazy"/></p>
<h4 data-id="heading-20">如何提高测试覆盖率</h4>
<ol>
<li><strong>单元测试</strong>：覆盖所有业务逻辑分支</li>
<li><strong>边界测试</strong>：测试边界条件和异常情况</li>
<li><strong>集成测试</strong>：验证组件间的交互</li>
<li><strong>端到端测试</strong>：验证完整的业务流程</li>
</ol>
<h4 data-id="heading-21">覆盖率工具</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 使用JaCoCo进行覆盖率分析</span>
&lt;plugin&gt;
    &lt;groupId&gt;org.jacoco&lt;/groupId&gt;
    &lt;artifactId&gt;jacoco-maven-plugin&lt;/artifactId&gt;
    &lt;version&gt;<span class="hljs-number">0.8</span><span class="hljs-number">.7</span>&lt;/version&gt;
    &lt;executions&gt;
        &lt;execution&gt;
            &lt;goals&gt;
                &lt;goal&gt;prepare-agent&lt;/goal&gt;
            &lt;/goals&gt;
        &lt;/execution&gt;
        &lt;execution&gt;
            &lt;id&gt;report&lt;/id&gt;
            &lt;phase&gt;test&lt;/phase&gt;
            &lt;goals&gt;
                &lt;goal&gt;report&lt;/goal&gt;
            &lt;/goals&gt;
        &lt;/execution&gt;
    &lt;/executions&gt;
&lt;/plugin&gt;
</code></pre>
<h3 data-id="heading-22">最佳实践</h3>
<h4 data-id="heading-23">1. 测试命名规范</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 好的命名</span>
<span class="hljs-meta">@Test</span>
<span class="hljs-keyword">void</span> <span class="hljs-title function_">shouldCreateUserWhenValidDataProvided</span><span class="hljs-params">()</span> {}

<span class="hljs-comment">// 不好的命名</span>
<span class="hljs-meta">@Test</span>
<span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> {}
</code></pre>
<h4 data-id="heading-24">2. 测试结构</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Test</span>
<span class="hljs-keyword">void</span> <span class="hljs-title function_">testFeature</span><span class="hljs-params">()</span> {
    <span class="hljs-comment">// 1. Arrange (准备测试数据)</span>
    <span class="hljs-type">UserDTO</span> <span class="hljs-variable">userDTO</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDTO</span>(<span class="hljs-string">"张三"</span>, <span class="hljs-string">"zhangsan@example.com"</span>);
    <span class="hljs-comment">// 2. Act (执行测试操作)</span>
    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userService.createUser(userDTO);
    <span class="hljs-comment">// 3. Assert (验证结果)</span>
    assertThat(user).isNotNull();
    assertThat(user.getName()).isEqualTo(<span class="hljs-string">"张三"</span>);
}
</code></pre>
<h4 data-id="heading-25">3. 异步测试</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Test</span>
<span class="hljs-keyword">void</span> <span class="hljs-title function_">testAsyncOperation</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException {
    <span class="hljs-comment">// Given</span>
    CompletableFuture&lt;User&gt; future = userService.asyncCreateUser(
        <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDTO</span>(<span class="hljs-string">"李四"</span>, <span class="hljs-string">"lisi@example.com"</span>));

    <span class="hljs-comment">// When</span>
    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> future.get();

    <span class="hljs-comment">// Then</span>
    assertThat(user).isNotNull();
    assertThat(user.getName()).isEqualTo(<span class="hljs-string">"李四"</span>);
}
</code></pre>
<h3 data-id="heading-26">依赖关系</h3>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/655728266d4c4ce19b4d00d0fcdf0ef8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuo5Lit6aOY6I2h55qE6K6w5b-G:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769426381&amp;x-signature=2Q37czkRXQkvbGCb7y3Sh7cUhFg%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-27">总结</h3>
<p>Spring Test是Java开发中不可或缺的工具，掌握它将大大提高你的开发效率和代码质量。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[回溯算法：选→钻→退→删，掌握穷举的艺术]]></title>    <link>https://juejin.cn/post/7596926832912351295</link>    <guid>https://juejin.cn/post/7596926832912351295</guid>    <pubDate>2026-01-19T11:17:39.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7596926832912351295" data-draft-id="7596883689826861119" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="回溯算法：选→钻→退→删，掌握穷举的艺术"/> <meta itemprop="keywords" content="后端,JavaScript,算法"/> <meta itemprop="datePublished" content="2026-01-19T11:17:39.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="颜酱"/> <meta itemprop="url" content="https://juejin.cn/user/905653309941495"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            回溯算法：选→钻→退→删，掌握穷举的艺术
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/905653309941495/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    颜酱
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-19T11:17:39.000Z" title="Mon Jan 19 2026 11:17:39 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读19分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">回溯算法：选→钻→退→删，掌握穷举的艺术</h2>
<p>回溯算法是算法领域的核心思想之一，尤其在处理「穷举所有可能解」的问题时堪称"神器"。本文将从核心思路出发，通过"选一个数→钻到底→退回来→删掉这个数→选下一个数→再钻到底"这个固定节奏，带你彻底掌握回溯算法。</p>
<h3 data-id="heading-1">一、回溯核心原理：选→钻→退→删的固定节奏</h3>
<h4 data-id="heading-2">一句话记牢回溯的执行过程</h4>
<p><strong>选一个数→钻到底→退回来→删掉这个数→选下一个数→再钻到底，直到所有数都试完，最后收集所有符合条件的路径。</strong></p>
<p>选了就往下钻，走不通就退回来擦脚印，换条路再试。很多人一开始都会被递归的多层调用绕晕，但只要抓住 <strong>push（选数）→ 递归（钻深层）→ pop（擦脚印）</strong> 这个固定节奏，再结合剪枝提前止损，所有回溯题都能套模板解决～</p>
<h4 data-id="heading-3">核心四要素</h4>
<p>任何回溯问题都能拆解为以下4个核心部分：</p>






























<table><thead><tr><th>要素</th><th>作用</th><th>示例（组合总和）</th></tr></thead><tbody><tr><td><strong>路径</strong></td><td>已经做出的选择（比如选了哪些数）</td><td><code>path = [2,3]</code>（表示选了2和3）</td></tr><tr><td><strong>选择列表</strong></td><td>当前步骤可选择的选项（比如还能选哪些数）</td><td><code>nums = [2,3,6,7]</code>，已选2则可选3/6/7</td></tr><tr><td><strong>终止条件</strong></td><td>什么时候停止探索（找到解/走到底）</td><td>路径和等于目标值，或路径和超过目标值</td></tr><tr><td><strong>剪枝</strong></td><td>提前排除无效路径（核心优化）</td><td>路径和超过目标值，直接停止当前路径</td></tr></tbody></table>
<h4 data-id="heading-4">关键理解</h4>
<ul>
<li><strong>递归是"往下钻"</strong>：每选一个数，就递归调用backtrack，相当于"往下走一步"</li>
<li><strong>return 是"往回退"</strong>：触发终止条件（找到解/和超了），就结束当前递归，回到上一层</li>
<li><strong>pop 是"擦脚印"</strong>：回到上一层后，必须执行<code>path.pop()</code>，把刚才选的数删掉，才能"换另一个数选"</li>
<li><strong>for 循环是"选岔路"</strong>：每一层的 for 循环，就是在当前位置选不同的数（岔路），试完一条再试下一条</li>
</ul>
<h4 data-id="heading-5">通用模板</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 回溯核心函数</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">backtrack</span>(<span class="hljs-params">路径, 选择列表, 其他参数</span>) {
  <span class="hljs-comment">// 1. 终止条件：找到解，记录结果并返回</span>
  <span class="hljs-keyword">if</span> (满足终止条件) {
    结果列表.<span class="hljs-title function_">push</span>(路径的拷贝); <span class="hljs-comment">// 注意：要拷贝，否则会被后续修改</span>
    <span class="hljs-keyword">return</span>;
  }

  <span class="hljs-comment">// 2. 遍历所有可选选项</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> 选项 <span class="hljs-keyword">of</span> 选择列表) {
    <span class="hljs-comment">// 剪枝：提前排除无效选项（关键优化）</span>
    <span class="hljs-keyword">if</span> (选项无效) <span class="hljs-keyword">continue</span>;

    <span class="hljs-comment">// 3. 做选择：把当前选项加入路径（选数）</span>
    路径.<span class="hljs-title function_">push</span>(选项);

    <span class="hljs-comment">// 4. 递归探索：基于当前选择，继续往下走（钻到底）</span>
    <span class="hljs-title function_">backtrack</span>(路径, 新的选择列表, 其他参数);

    <span class="hljs-comment">// 5. 撤销选择（回溯核心）：回到上一步，换选项（退回来→删掉这个数）</span>
    路径.<span class="hljs-title function_">pop</span>();
  }
}

<span class="hljs-comment">// 主函数</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">solveProblem</span>(<span class="hljs-params">参数</span>) {
  <span class="hljs-keyword">const</span> 结果列表 = []; <span class="hljs-comment">// 存储所有符合条件的解</span>
  <span class="hljs-title function_">backtrack</span>([], 初始选择列表, 初始参数); <span class="hljs-comment">// 初始路径为空</span>
  <span class="hljs-keyword">return</span> 结果列表;
}
</code></pre>
<h3 data-id="heading-6">二、入门示例：组合总和（可视化理解）</h3>
<p>为了让你快速理解回溯的核心节奏，我们先从<strong>组合总和</strong>这个经典入门题入手，通过可视化打印完整展示「选→探→撤」的全过程。</p>
<h4 data-id="heading-7">题目描述</h4>
<p>给定一个无重复元素的数组 <code>candidates</code> 和一个目标数 <code>target</code>，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合（数字可以无限制重复被选取）。</p>
<ul>
<li>示例：输入 <code>candidates = [2,3,7]</code>，<code>target = 7</code>，输出 <code>[[2,2,3],[7]]</code>。</li>
</ul>
<h4 data-id="heading-8">完整代码实现</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">/**
 * 组合总和：找所有和为目标值的组合（可视化打印版）
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number[]</span>} <span class="hljs-variable">candidates</span> - 候选数组
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number</span>} <span class="hljs-variable">target</span> - 目标和
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">number[][]</span>} - 所有符合条件的组合
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">combinationSum</span>(<span class="hljs-params">candidates, target</span>) {
  <span class="hljs-keyword">const</span> result = []; <span class="hljs-comment">// 存储最终结果</span>
  candidates.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b); <span class="hljs-comment">// 排序便于剪枝</span>
  <span class="hljs-keyword">let</span> recursionLevel = <span class="hljs-number">0</span>; <span class="hljs-comment">// 标记递归层级，用于可视化缩进</span>

  <span class="hljs-comment">// 回溯函数：path=当前路径，sum=当前路径和，start=起始索引（避免重复组合）</span>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">backtrack</span>(<span class="hljs-params">path, sum, start</span>) {
    <span class="hljs-comment">// 层级+1，生成缩进（每级2个空格）</span>
    recursionLevel++;
    <span class="hljs-keyword">const</span> indent = <span class="hljs-string">'  '</span>.<span class="hljs-title function_">repeat</span>(recursionLevel - <span class="hljs-number">1</span>);
    <span class="hljs-keyword">const</span> levelTag = <span class="hljs-string">`【层级<span class="hljs-subst">${recursionLevel}</span>】`</span>;

    <span class="hljs-comment">// 🟢 调用阶段：打印当前层级初始状态</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(
      <span class="hljs-string">`<span class="hljs-subst">${indent}</span>🟢 <span class="hljs-subst">${levelTag}</span> 调用阶段 → path=<span class="hljs-subst">${<span class="hljs-built_in">JSON</span>.stringify(path)}</span>, sum=<span class="hljs-subst">${sum}</span>, start=<span class="hljs-subst">${start}</span>`</span>
    );

    <span class="hljs-comment">// 终止条件1：路径和等于目标值，记录结果</span>
    <span class="hljs-keyword">if</span> (sum === target) {
      result.<span class="hljs-title function_">push</span>([...path]); <span class="hljs-comment">// 拷贝路径，避免后续修改</span>
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(
        <span class="hljs-string">`<span class="hljs-subst">${indent}</span>✅ <span class="hljs-subst">${levelTag}</span> 找到有效组合 → <span class="hljs-subst">${<span class="hljs-built_in">JSON</span>.stringify(path)}</span>，result=<span class="hljs-subst">${<span class="hljs-built_in">JSON</span>.stringify(result)}</span>`</span>
      );
      <span class="hljs-comment">// 层级-1，准备返回</span>
      recursionLevel--;
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${indent}</span>🔴 <span class="hljs-subst">${levelTag}</span> 返回阶段 → 找到解，回到上一层`</span>);
      <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-comment">// 终止条件2：路径和超过目标值，直接返回（剪枝）</span>
    <span class="hljs-keyword">if</span> (sum &gt; target) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${indent}</span>🚫 <span class="hljs-subst">${levelTag}</span> 剪枝 → sum=<span class="hljs-subst">${sum}</span> &gt; target=<span class="hljs-subst">${target}</span>，直接返回`</span>);
      recursionLevel--;
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${indent}</span>🔴 <span class="hljs-subst">${levelTag}</span> 返回阶段 → 剪枝返回，回到上一层`</span>);
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-comment">// 遍历选择列表（从start开始，避免重复组合）</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = start; i &lt; candidates.<span class="hljs-property">length</span>; i++) {
      <span class="hljs-keyword">const</span> num = candidates[i];
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${indent}</span>🔍 <span class="hljs-subst">${levelTag}</span> 遍历i=<span class="hljs-subst">${i}</span> → 尝试选数字<span class="hljs-subst">${num}</span>，当前sum=<span class="hljs-subst">${sum}</span>`</span>);

      <span class="hljs-comment">// 排序剪枝：当前数+已选和&gt;目标值，后续数更大，无需继续</span>
      <span class="hljs-keyword">if</span> (sum + num &gt; target) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(
          <span class="hljs-string">`<span class="hljs-subst">${indent}</span>🚫 <span class="hljs-subst">${levelTag}</span> 排序剪枝 → <span class="hljs-subst">${sum}</span>+<span class="hljs-subst">${num}</span>=<span class="hljs-subst">${sum + num}</span> &gt; <span class="hljs-subst">${target}</span>，break循环`</span>
        );
        <span class="hljs-keyword">break</span>;
      }

      <span class="hljs-comment">// 做选择：加入当前数（选数）</span>
      path.<span class="hljs-title function_">push</span>(num);
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(
        <span class="hljs-string">`<span class="hljs-subst">${indent}</span>✅ <span class="hljs-subst">${levelTag}</span> 选数字<span class="hljs-subst">${num}</span> → path=<span class="hljs-subst">${<span class="hljs-built_in">JSON</span>.stringify(path)}</span>, sum=<span class="hljs-subst">${sum + num}</span>`</span>
      );

      <span class="hljs-comment">// 🟡 暂停阶段：调用下一层，当前层级暂停</span>
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${indent}</span>🟡 <span class="hljs-subst">${levelTag}</span> 暂停阶段 → 调用下一层backtrack，等待返回`</span>);
      <span class="hljs-comment">// 递归探索：数字可重复选，所以start仍为i（钻到底）</span>
      <span class="hljs-title function_">backtrack</span>(path, sum + num, i);
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${indent}</span>🔴 <span class="hljs-subst">${levelTag}</span> 返回阶段 → 从下一层返回，继续执行`</span>);

      <span class="hljs-comment">// 撤销选择：回溯核心（退回来→删掉这个数）</span>
      path.<span class="hljs-title function_">pop</span>();
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(
        <span class="hljs-string">`<span class="hljs-subst">${indent}</span>🔵 <span class="hljs-subst">${levelTag}</span> 撤销阶段 → 撤销数字<span class="hljs-subst">${num}</span> → path=<span class="hljs-subst">${<span class="hljs-built_in">JSON</span>.stringify(path)}</span>, sum=<span class="hljs-subst">${sum}</span>`</span>
      );
    }

    <span class="hljs-comment">// 层级-1，准备返回</span>
    recursionLevel--;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${indent}</span>🔴 <span class="hljs-subst">${levelTag}</span> 返回阶段 → for循环结束，回到上一层`</span>);
  }

  <span class="hljs-comment">// 初始调用：空路径、和为0、从索引0开始</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'========== 开始执行组合总和 =========='</span>);
  <span class="hljs-title function_">backtrack</span>([], <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'========== 执行结束 =========='</span>);
  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">// 测试：输入 [2,3,7], 7 → 输出 [[2,2,3],[7]]</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'最终结果：'</span>, <span class="hljs-title function_">combinationSum</span>([<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>], <span class="hljs-number">7</span>));
</code></pre>
<p>各个图标的含义：</p>
<ul>
<li>🟢 调用阶段：进入递归时的状态</li>
<li>🔍 遍历阶段：尝试选择数字</li>
<li>✅ 选择阶段：成功选择数字</li>
<li>🟡 暂停阶段：调用下一层递归</li>
<li>🔴 返回阶段：从下一层返回</li>
<li>🔵 撤销阶段：删除数字（擦脚印）</li>
<li>🚫 剪枝阶段：提前终止无效路径</li>
</ul>
<p><strong>控制台输出示例：</strong></p>
<pre><code class="hljs language-plaintext" lang="plaintext">========== 开始执行组合总和 ==========
🟢 【层级1】 调用阶段 → path=[], sum=0, start=0
🔍 【层级1】 遍历i=0 → 尝试选数字2，当前sum=0
✅ 【层级1】 选数字2 → path=[2], sum=2
🟡 【层级1】 暂停阶段 → 调用下一层backtrack，等待返回
  🟢 【层级2】 调用阶段 → path=[2], sum=2, start=0
  🔍 【层级2】 遍历i=0 → 尝试选数字2，当前sum=2
  ✅ 【层级2】 选数字2 → path=[2,2], sum=4
  🟡 【层级2】 暂停阶段 → 调用下一层backtrack，等待返回
    🟢 【层级3】 调用阶段 → path=[2,2], sum=4, start=0
    🔍 【层级3】 遍历i=0 → 尝试选数字2，当前sum=4
    ✅ 【层级3】 选数字2 → path=[2,2,2], sum=6
    🟡 【层级3】 暂停阶段 → 调用下一层backtrack，等待返回
      🟢 【层级4】 调用阶段 → path=[2,2,2], sum=6, start=0
      🔍 【层级4】 遍历i=0 → 尝试选数字2，当前sum=6
      🚫 【层级4】 排序剪枝 → 6+2=8 &gt; 7，break循环
      🔴 【层级4】 返回阶段 → for循环结束，回到上一层
    🔴 【层级3】 返回阶段 → 从下一层返回，继续执行
    🔵 【层级3】 撤销阶段 → 撤销数字2 → path=[2,2], sum=4
    🔍 【层级3】 遍历i=1 → 尝试选数字3，当前sum=4
    ✅ 【层级3】 选数字3 → path=[2,2,3], sum=7
    🟡 【层级3】 暂停阶段 → 调用下一层backtrack，等待返回
      🟢 【层级4】 调用阶段 → path=[2,2,3], sum=7, start=1
      ✅ 【层级4】 找到有效组合 → [2,2,3]，result=[[2,2,3]]
      🔴 【层级4】 返回阶段 → 找到解，回到上一层
    🔴 【层级3】 返回阶段 → 从下一层返回，继续执行
    🔵 【层级3】 撤销阶段 → 撤销数字3 → path=[2,2], sum=4
    🔍 【层级3】 遍历i=2 → 尝试选数字7，当前sum=4
    🚫 【层级3】 排序剪枝 → 4+7=11 &gt; 7，break循环
    🔴 【层级3】 返回阶段 → for循环结束，回到上一层
  🔴 【层级2】 返回阶段 → 从下一层返回，继续执行
  🔵 【层级2】 撤销阶段 → 撤销数字2 → path=[2], sum=2
  🔍 【层级2】 遍历i=1 → 尝试选数字3，当前sum=2
  ✅ 【层级2】 选数字3 → path=[2,3], sum=5
  🟡 【层级2】 暂停阶段 → 调用下一层backtrack，等待返回
    🟢 【层级3】 调用阶段 → path=[2,3], sum=5, start=1
    🔍 【层级3】 遍历i=1 → 尝试选数字3，当前sum=5
    🚫 【层级3】 排序剪枝 → 5+3=8 &gt; 7，break循环
    🔴 【层级3】 返回阶段 → for循环结束，回到上一层
  🔴 【层级2】 返回阶段 → 从下一层返回，继续执行
  🔵 【层级2】 撤销阶段 → 撤销数字3 → path=[2], sum=2
  🔍 【层级2】 遍历i=2 → 尝试选数字7，当前sum=2
  🚫 【层级2】 排序剪枝 → 2+7=9 &gt; 7，break循环
  🔴 【层级2】 返回阶段 → for循环结束，回到上一层
🔴 【层级1】 返回阶段 → 从下一层返回，继续执行
🔵 【层级1】 撤销阶段 → 撤销数字2 → path=[], sum=0
🔍 【层级1】 遍历i=1 → 尝试选数字3，当前sum=0
✅ 【层级1】 选数字3 → path=[3], sum=3
🟡 【层级1】 暂停阶段 → 调用下一层backtrack，等待返回
  🟢 【层级2】 调用阶段 → path=[3], sum=3, start=1
  🔍 【层级2】 遍历i=1 → 尝试选数字3，当前sum=3
  ✅ 【层级2】 选数字3 → path=[3,3], sum=6
  🟡 【层级2】 暂停阶段 → 调用下一层backtrack，等待返回
    🟢 【层级3】 调用阶段 → path=[3,3], sum=6, start=1
    🔍 【层级3】 遍历i=1 → 尝试选数字3，当前sum=6
    🚫 【层级3】 排序剪枝 → 6+3=9 &gt; 7，break循环
    🔴 【层级3】 返回阶段 → for循环结束，回到上一层
  🔴 【层级2】 返回阶段 → 从下一层返回，继续执行
  🔵 【层级2】 撤销阶段 → 撤销数字3 → path=[3], sum=3
  🔍 【层级2】 遍历i=2 → 尝试选数字7，当前sum=3
  🚫 【层级2】 排序剪枝 → 3+7=10 &gt; 7，break循环
  🔴 【层级2】 返回阶段 → for循环结束，回到上一层
🔴 【层级1】 返回阶段 → 从下一层返回，继续执行
🔵 【层级1】 撤销阶段 → 撤销数字3 → path=[], sum=0
🔍 【层级1】 遍历i=2 → 尝试选数字7，当前sum=0
✅ 【层级1】 选数字7 → path=[7], sum=7
🟡 【层级1】 暂停阶段 → 调用下一层backtrack，等待返回
  🟢 【层级2】 调用阶段 → path=[7], sum=7, start=2
  ✅ 【层级2】 找到有效组合 → [7]，result=[[2,2,3],[7]]
  🔴 【层级2】 返回阶段 → 找到解，回到上一层
🔴 【层级1】 返回阶段 → 从下一层返回，继续执行
🔵 【层级1】 撤销阶段 → 撤销数字7 → path=[], sum=0
🔴 【层级1】 返回阶段 → for循环结束，回到上一层
========== 执行结束 ==========
最终结果： [ [ 2, 2, 3 ], [ 7 ] ]
</code></pre>
<h4 data-id="heading-9">执行流程解析</h4>
<p>以 <code>candidates = [2,3,7]</code>, <code>target = 7</code> 为例：</p>
<ol>
<li><strong>选2</strong> → path=[2], sum=2 → <strong>钻到底</strong>（递归）</li>
<li><strong>选2</strong> → path=[2,2], sum=4 → <strong>钻到底</strong>（递归）</li>
<li><strong>选2</strong> → path=[2,2,2], sum=6 → <strong>钻到底</strong>（递归）</li>
<li><strong>选2</strong> → sum=8 &gt; 7，剪枝，<strong>退回来</strong></li>
<li><strong>删掉2</strong> → path=[2,2], sum=6 → <strong>选下一个数3</strong></li>
<li><strong>选3</strong> → path=[2,2,3], sum=7 ✅ 找到解，<strong>退回来</strong></li>
<li><strong>删掉3</strong> → path=[2,2], sum=6 → <strong>选下一个数7</strong></li>
<li>剪枝，<strong>退回来</strong> → path=[2], sum=2 → 继续尝试...</li>
<li>最终收集到 <code>[[2,2,3],[7]]</code></li>
</ol>
<h3 data-id="heading-10">三、回溯算法常见题型及解题方法</h3>
<h4 data-id="heading-11">1. 组合问题</h4>
<h5 data-id="heading-12">核心特征</h5>
<ul>
<li>不考虑元素顺序，每个组合唯一（如<code>[2,3]</code>和<code>[3,2]</code>算同一个）</li>
<li>用<code>start</code>参数控制"不回头选"，避免生成重复组合</li>
<li>数字可重复选（组合总和）/不可重复选（组合），仅需调整<code>start</code>参数（重复选传<code>i</code>，不重复选传<code>i+1</code>）</li>
</ul>
<h5 data-id="heading-13">LeetCode 题目详解</h5>
<h6 data-id="heading-14"><a href="https://link.juejin.cn?target=https%3A%2F%2Fleetcode.cn%2Fproblems%2Fcombination-sum%2F" target="_blank" title="https://leetcode.cn/problems/combination-sum/" ref="nofollow noopener noreferrer">39. 组合总和</a></h6>
<p><strong>题目描述：</strong></p>
<p>给定一个<strong>无重复元素</strong>的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code>，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的<strong>所有不同组合</strong>，并以列表形式返回。你可以按<strong>任意顺序</strong>返回这些组合。</p>
<p><code>candidates</code> 中的<strong>同一个数字可以无限制重复被选取</strong>。如果至少一个数字的被选数量不同，则两种组合是不同的。</p>
<p><strong>示例 1：</strong></p>
<pre><code class="hljs language-ini" lang="ini">输入：<span class="hljs-attr">candidates</span> = [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>], target = <span class="hljs-number">7</span>
输出：<span class="hljs-section">[[2,2,3]</span>,<span class="hljs-section">[7]]</span>
解释：
2 和 3 可以形成一组候选，2 + 2 + <span class="hljs-attr">3</span> = <span class="hljs-number">7</span>。注意 <span class="hljs-number">2</span> 可以使用多次。
7 也是一个候选， <span class="hljs-attr">7</span> = <span class="hljs-number">7</span>。
所以这两种组合是唯一的答案。
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code class="hljs language-ini" lang="ini">输入: <span class="hljs-attr">candidates</span> = [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>], target = <span class="hljs-number">8</span>
输出: <span class="hljs-section">[[2,2,2,2]</span>,<span class="hljs-section">[2,3,3]</span>,<span class="hljs-section">[3,5]]</span>
</code></pre>
<p><strong>解决方案：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">/**
 * 39. 组合总和
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number[]</span>} <span class="hljs-variable">candidates</span> - 无重复元素的候选数组
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number</span>} <span class="hljs-variable">target</span> - 目标和
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">number[][]</span>} 所有符合条件的组合
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">combinationSum</span>(<span class="hljs-params">candidates, target</span>) {
  <span class="hljs-keyword">const</span> res = [];
  candidates.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b); <span class="hljs-comment">// 排序便于剪枝</span>

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">backtrack</span>(<span class="hljs-params">path, sum, start</span>) {
    <span class="hljs-comment">// 终止条件：找到有效解</span>
    <span class="hljs-keyword">if</span> (sum === target) {
      res.<span class="hljs-title function_">push</span>([...path]);
      <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-comment">// 剪枝：和超过目标值</span>
    <span class="hljs-keyword">if</span> (sum &gt; target) <span class="hljs-keyword">return</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = start; i &lt; candidates.<span class="hljs-property">length</span>; i++) {
      <span class="hljs-keyword">const</span> num = candidates[i];
      <span class="hljs-comment">// 排序剪枝：后续数更大，无需继续</span>
      <span class="hljs-keyword">if</span> (sum + num &gt; target) <span class="hljs-keyword">break</span>;

      <span class="hljs-comment">// 选数</span>
      path.<span class="hljs-title function_">push</span>(num);
      <span class="hljs-comment">// 钻到底：数字可重复选，所以start仍为i</span>
      <span class="hljs-title function_">backtrack</span>(path, sum + num, i);
      <span class="hljs-comment">// 退回来→删掉这个数</span>
      path.<span class="hljs-title function_">pop</span>();
    }
  }

  <span class="hljs-title function_">backtrack</span>([], <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
  <span class="hljs-keyword">return</span> res;
}
</code></pre>
<p><strong>易错点：</strong></p>
<ul>
<li>忘记排序导致剪枝失效</li>
<li><code>start</code>参数传错（重复选传<code>i</code>，不重复选传<code>i+1</code>）</li>
<li>忘记拷贝路径（<code>[...path]</code>）</li>
</ul>
<hr/>
<h6 data-id="heading-15"><a href="https://link.juejin.cn?target=https%3A%2F%2Fleetcode.cn%2Fproblems%2Fcombination-sum-ii%2F" target="_blank" title="https://leetcode.cn/problems/combination-sum-ii/" ref="nofollow noopener noreferrer">40. 组合总和 II</a></h6>
<p><strong>题目描述：</strong></p>
<p>给定一个候选人编号的集合 <code>candidates</code> 和一个目标数 <code>target</code>，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p>
<p><code>candidates</code> 中的<strong>每个数字在每个组合中只能使用一次</strong>。</p>
<p>**注意：**解集不能包含重复的组合。</p>
<p><strong>示例 1：</strong></p>
<pre><code class="hljs language-ini" lang="ini">输入: <span class="hljs-attr">candidates</span> = [<span class="hljs-number">10</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>], target = <span class="hljs-number">8</span>,
输出:
<span class="hljs-section">[
[1,1,6]</span>,
<span class="hljs-section">[1,2,5]</span>,
<span class="hljs-section">[1,7]</span>,
<span class="hljs-section">[2,6]</span>
]
</code></pre>
<p><strong>解决方案：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">/**
 * 40. 组合总和 II
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number[]</span>} <span class="hljs-variable">candidates</span> - 可能包含重复元素的候选数组
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number</span>} <span class="hljs-variable">target</span> - 目标和
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">number[][]</span>} 所有符合条件的组合（不重复）
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">combinationSum2</span>(<span class="hljs-params">candidates, target</span>) {
  <span class="hljs-keyword">const</span> res = [];
  candidates.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b); <span class="hljs-comment">// 排序便于剪枝和去重</span>

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">backtrack</span>(<span class="hljs-params">path, sum, start</span>) {
    <span class="hljs-comment">// 终止条件：找到有效解</span>
    <span class="hljs-keyword">if</span> (sum === target) {
      res.<span class="hljs-title function_">push</span>([...path]);
      <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-comment">// 剪枝：和超过目标值</span>
    <span class="hljs-keyword">if</span> (sum &gt; target) <span class="hljs-keyword">return</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = start; i &lt; candidates.<span class="hljs-property">length</span>; i++) {
      <span class="hljs-keyword">const</span> num = candidates[i];

      <span class="hljs-comment">// 去重剪枝：跳过重复元素（关键！）</span>
      <span class="hljs-comment">// i &gt; start 确保同一层不选重复数字，但不同层可以选</span>
      <span class="hljs-keyword">if</span> (i &gt; start &amp;&amp; candidates[i] === candidates[i - <span class="hljs-number">1</span>]) {
        <span class="hljs-keyword">continue</span>;
      }

      <span class="hljs-comment">// 排序剪枝</span>
      <span class="hljs-keyword">if</span> (sum + num &gt; target) <span class="hljs-keyword">break</span>;

      <span class="hljs-comment">// 选数</span>
      path.<span class="hljs-title function_">push</span>(num);
      <span class="hljs-comment">// 钻到底：数字不可重复选，所以start传i+1</span>
      <span class="hljs-title function_">backtrack</span>(path, sum + num, i + <span class="hljs-number">1</span>);
      <span class="hljs-comment">// 退回来→删掉这个数</span>
      path.<span class="hljs-title function_">pop</span>();
    }
  }

  <span class="hljs-title function_">backtrack</span>([], <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
  <span class="hljs-keyword">return</span> res;
}
</code></pre>
<p><strong>易错点：</strong></p>
<ul>
<li>去重逻辑错误：应该是<code>i &gt; start</code>而不是<code>i &gt; 0</code>（允许不同层选相同数字）</li>
<li>忘记排序导致去重失效</li>
</ul>
<hr/>
<h6 data-id="heading-16"><a href="https://link.juejin.cn?target=https%3A%2F%2Fleetcode.cn%2Fproblems%2Fcombinations%2F" target="_blank" title="https://leetcode.cn/problems/combinations/" ref="nofollow noopener noreferrer">77. 组合</a></h6>
<p><strong>题目描述：</strong></p>
<p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p>
<p>你可以按<strong>任何顺序</strong>返回答案。</p>
<p><strong>示例 1：</strong></p>
<pre><code class="hljs language-ini" lang="ini">输入：<span class="hljs-attr">n</span> = <span class="hljs-number">4</span>, k = <span class="hljs-number">2</span>
输出：
<span class="hljs-section">[
  [2,4]</span>,
  <span class="hljs-section">[3,4]</span>,
  <span class="hljs-section">[2,3]</span>,
  <span class="hljs-section">[1,2]</span>,
  <span class="hljs-section">[1,3]</span>,
  <span class="hljs-section">[1,4]</span>,
]
</code></pre>
<p><strong>解决方案：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">/**
 * 77. 组合
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number</span>} <span class="hljs-variable">n</span> - 范围 [1, n]
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number</span>} <span class="hljs-variable">k</span> - 组合长度
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">number[][]</span>} 所有可能的k个数的组合
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">combine</span>(<span class="hljs-params">n, k</span>) {
  <span class="hljs-keyword">const</span> res = [];

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">backtrack</span>(<span class="hljs-params">path, start</span>) {
    <span class="hljs-comment">// 终止条件：路径长度等于k</span>
    <span class="hljs-keyword">if</span> (path.<span class="hljs-property">length</span> === k) {
      res.<span class="hljs-title function_">push</span>([...path]);
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-comment">// 剪枝：剩余可选数字不够</span>
    <span class="hljs-comment">// 还需要选 k - path.length 个数，从start到n还有 n - start + 1 个数</span>
    <span class="hljs-comment">// 如果 n - start + 1 &lt; k - path.length，则无法凑够k个数</span>
    <span class="hljs-keyword">if</span> (n - start + <span class="hljs-number">1</span> &lt; k - path.<span class="hljs-property">length</span>) <span class="hljs-keyword">return</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = start; i &lt;= n; i++) {
      <span class="hljs-comment">// 选数</span>
      path.<span class="hljs-title function_">push</span>(i);
      <span class="hljs-comment">// 钻到底：不重复选，所以start传i+1</span>
      <span class="hljs-title function_">backtrack</span>(path, i + <span class="hljs-number">1</span>);
      <span class="hljs-comment">// 退回来→删掉这个数</span>
      path.<span class="hljs-title function_">pop</span>();
    }
  }

  <span class="hljs-title function_">backtrack</span>([], <span class="hljs-number">1</span>);
  <span class="hljs-keyword">return</span> res;
}
</code></pre>
<p><strong>易错点：</strong></p>
<ul>
<li>范围错误：应该是<code>[1, n]</code>，循环条件是<code>i &lt;= n</code>而不是<code>i &lt; n</code></li>
<li>忘记剪枝优化导致超时</li>
</ul>
<hr/>
<h6 data-id="heading-17"><a href="https://link.juejin.cn?target=https%3A%2F%2Fleetcode.cn%2Fproblems%2Fcombination-sum-iii%2F" target="_blank" title="https://leetcode.cn/problems/combination-sum-iii/" ref="nofollow noopener noreferrer">216. 组合总和 III</a></h6>
<p><strong>题目描述：</strong></p>
<p>找出所有相加之和为 <code>n</code> 的 <code>k</code> 个数的组合，且满足下列条件：</p>
<ul>
<li>只使用数字1到9</li>
<li>每个数字<strong>最多使用一次</strong></li>
</ul>
<p>返回<strong>所有可能的有效组合的列表</strong>。该列表不能包含相同的组合两次，组合可以以任何顺序返回。</p>
<p><strong>示例 1：</strong></p>
<pre><code class="hljs language-ini" lang="ini">输入: <span class="hljs-attr">k</span> = <span class="hljs-number">3</span>, n = <span class="hljs-number">7</span>
输出: <span class="hljs-section">[[1,2,4]]</span>
解释:
1 + 2 + <span class="hljs-attr">4</span> = <span class="hljs-number">7</span>
没有其他符合的组合了。
</code></pre>
<p><strong>解决方案：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">/**
 * 216. 组合总和 III
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number</span>} <span class="hljs-variable">k</span> - 组合长度
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number</span>} <span class="hljs-variable">n</span> - 目标和
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">number[][]</span>} 所有符合条件的组合
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">combinationSum3</span>(<span class="hljs-params">k, n</span>) {
  <span class="hljs-keyword">const</span> res = [];

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">backtrack</span>(<span class="hljs-params">path, sum, start</span>) {
    <span class="hljs-comment">// 终止条件1：找到有效解（长度和和都满足）</span>
    <span class="hljs-keyword">if</span> (path.<span class="hljs-property">length</span> === k &amp;&amp; sum === n) {
      res.<span class="hljs-title function_">push</span>([...path]);
      <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-comment">// 终止条件2：长度已满但和不满足，或和已超</span>
    <span class="hljs-keyword">if</span> (path.<span class="hljs-property">length</span> === k || sum &gt;= n) <span class="hljs-keyword">return</span>;

    <span class="hljs-comment">// 剪枝：剩余可选数字不够</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-number">9</span> - start + <span class="hljs-number">1</span> &lt; k - path.<span class="hljs-property">length</span>) <span class="hljs-keyword">return</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = start; i &lt;= <span class="hljs-number">9</span>; i++) {
      <span class="hljs-comment">// 剪枝：当前数加上已选和超过目标值</span>
      <span class="hljs-keyword">if</span> (sum + i &gt; n) <span class="hljs-keyword">break</span>;

      <span class="hljs-comment">// 选数</span>
      path.<span class="hljs-title function_">push</span>(i);
      <span class="hljs-comment">// 钻到底：数字不可重复选，所以start传i+1</span>
      <span class="hljs-title function_">backtrack</span>(path, sum + i, i + <span class="hljs-number">1</span>);
      <span class="hljs-comment">// 退回来→删掉这个数</span>
      path.<span class="hljs-title function_">pop</span>();
    }
  }

  <span class="hljs-title function_">backtrack</span>([], <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);
  <span class="hljs-keyword">return</span> res;
}
</code></pre>
<hr/>
<h4 data-id="heading-18">2. 排列问题</h4>
<h5 data-id="heading-19">核心特征</h5>
<ul>
<li>考虑元素顺序，每个排列唯一（如<code>[1,2]</code>和<code>[2,1]</code>算不同排列）</li>
<li>用<code>used</code>数组控制"不重复选"，循环从0开始（允许选任意未选过的数字）</li>
<li>含重复数字的排列（全排列II）需增加"去重剪枝"</li>
</ul>
<h5 data-id="heading-20">LeetCode 题目详解</h5>
<h6 data-id="heading-21"><a href="https://link.juejin.cn?target=https%3A%2F%2Fleetcode.cn%2Fproblems%2Fpermutations%2F" target="_blank" title="https://leetcode.cn/problems/permutations/" ref="nofollow noopener noreferrer">46. 全排列</a></h6>
<p><strong>题目描述：</strong></p>
<p>给定一个<strong>不含重复数字</strong>的数组 <code>nums</code>，返回其<strong>所有可能的全排列</strong>。你可以<strong>按任意顺序</strong>返回答案。</p>
<p><strong>示例 1：</strong></p>
<pre><code class="hljs language-ini" lang="ini">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]
输出：<span class="hljs-section">[[1,2,3]</span>,<span class="hljs-section">[1,3,2]</span>,<span class="hljs-section">[2,1,3]</span>,<span class="hljs-section">[2,3,1]</span>,<span class="hljs-section">[3,1,2]</span>,<span class="hljs-section">[3,2,1]]</span>
</code></pre>
<p><strong>解决方案：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">/**
 * 46. 全排列
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number[]</span>} <span class="hljs-variable">nums</span> - 不含重复数字的数组
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">number[][]</span>} 所有全排列
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">permute</span>(<span class="hljs-params">nums</span>) {
  <span class="hljs-keyword">const</span> res = [];
  <span class="hljs-keyword">const</span> len = nums.<span class="hljs-property">length</span>;
  <span class="hljs-keyword">const</span> used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(len).<span class="hljs-title function_">fill</span>(<span class="hljs-literal">false</span>); <span class="hljs-comment">// 标记哪些数字已使用</span>

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">backtrack</span>(<span class="hljs-params">path</span>) {
    <span class="hljs-comment">// 终止条件：路径长度等于数组长度</span>
    <span class="hljs-keyword">if</span> (path.<span class="hljs-property">length</span> === len) {
      res.<span class="hljs-title function_">push</span>([...path]);
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-comment">// 遍历所有可选数字（排列从0开始，允许选任意未选过的数字）</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) {
      <span class="hljs-comment">// 剪枝：跳过已选数字</span>
      <span class="hljs-keyword">if</span> (used[i]) <span class="hljs-keyword">continue</span>;

      <span class="hljs-comment">// 选数</span>
      used[i] = <span class="hljs-literal">true</span>;
      path.<span class="hljs-title function_">push</span>(nums[i]);

      <span class="hljs-comment">// 钻到底</span>
      <span class="hljs-title function_">backtrack</span>(path);

      <span class="hljs-comment">// 退回来→删掉这个数</span>
      path.<span class="hljs-title function_">pop</span>();
      used[i] = <span class="hljs-literal">false</span>;
    }
  }

  <span class="hljs-title function_">backtrack</span>([]);
  <span class="hljs-keyword">return</span> res;
}
</code></pre>
<p><strong>易错点：</strong></p>
<ul>
<li>忘记使用<code>used</code>数组导致重复选同一个数字</li>
<li>循环应该从0开始，不是从<code>start</code>开始（排列需要考虑所有位置）</li>
</ul>
<hr/>
<h6 data-id="heading-22"><a href="https://link.juejin.cn?target=https%3A%2F%2Fleetcode.cn%2Fproblems%2Fpermutations-ii%2F" target="_blank" title="https://leetcode.cn/problems/permutations-ii/" ref="nofollow noopener noreferrer">47. 全排列 II</a></h6>
<p><strong>题目描述：</strong></p>
<p>给定一个可包含重复数字的序列 <code>nums</code>，<strong>按任意顺序</strong>返回所有不重复的全排列。</p>
<p><strong>示例 1：</strong></p>
<pre><code class="hljs language-ini" lang="ini">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]
输出：
<span class="hljs-section">[[1,1,2]</span>,
 <span class="hljs-section">[1,2,1]</span>,
 <span class="hljs-section">[2,1,1]]</span>
</code></pre>
<p><strong>解决方案：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">/**
 * 47. 全排列 II
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number[]</span>} <span class="hljs-variable">nums</span> - 可能包含重复数字的数组
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">number[][]</span>} 所有不重复的全排列
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">permuteUnique</span>(<span class="hljs-params">nums</span>) {
  <span class="hljs-keyword">const</span> res = [];
  <span class="hljs-keyword">const</span> len = nums.<span class="hljs-property">length</span>;
  <span class="hljs-keyword">const</span> used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(len).<span class="hljs-title function_">fill</span>(<span class="hljs-literal">false</span>);
  nums.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b); <span class="hljs-comment">// 排序便于去重</span>

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">backtrack</span>(<span class="hljs-params">path</span>) {
    <span class="hljs-comment">// 终止条件：路径长度等于数组长度</span>
    <span class="hljs-keyword">if</span> (path.<span class="hljs-property">length</span> === len) {
      res.<span class="hljs-title function_">push</span>([...path]);
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) {
      <span class="hljs-comment">// 剪枝1：跳过已选数字</span>
      <span class="hljs-keyword">if</span> (used[i]) <span class="hljs-keyword">continue</span>;

      <span class="hljs-comment">// 剪枝2：去重（关键！）</span>
      <span class="hljs-comment">// 如果当前数字和前一个数字相同，且前一个数字未被使用，则跳过</span>
      <span class="hljs-comment">// 这确保相同数字按顺序使用，避免重复排列</span>
      <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] === nums[i - <span class="hljs-number">1</span>] &amp;&amp; !used[i - <span class="hljs-number">1</span>]) {
        <span class="hljs-keyword">continue</span>;
      }

      <span class="hljs-comment">// 选数</span>
      used[i] = <span class="hljs-literal">true</span>;
      path.<span class="hljs-title function_">push</span>(nums[i]);

      <span class="hljs-comment">// 钻到底</span>
      <span class="hljs-title function_">backtrack</span>(path);

      <span class="hljs-comment">// 退回来→删掉这个数</span>
      path.<span class="hljs-title function_">pop</span>();
      used[i] = <span class="hljs-literal">false</span>;
    }
  }

  <span class="hljs-title function_">backtrack</span>([]);
  <span class="hljs-keyword">return</span> res;
}
</code></pre>
<p><strong>易错点：</strong></p>
<ul>
<li>去重逻辑错误：应该是<code>!used[i - 1]</code>而不是<code>used[i - 1]</code>
<ul>
<li><code>!used[i - 1]</code>：前一个相同数字未被使用，说明我们在同一层尝试重复数字，应该跳过</li>
<li><code>used[i - 1]</code>：前一个相同数字已被使用，说明我们在不同层，可以使用</li>
</ul>
</li>
</ul>
<hr/>
<h4 data-id="heading-23">3. 子集问题</h4>
<h5 data-id="heading-24">核心特征</h5>
<ul>
<li>找出所有可能的子集（包括空集）</li>
<li>用<code>start</code>参数控制不回头选，无需严格终止条件（每次递归都记录路径）</li>
<li>含重复数字的子集（子集II）需增加"去重剪枝"</li>
</ul>
<h5 data-id="heading-25">LeetCode 题目详解</h5>
<h6 data-id="heading-26"><a href="https://link.juejin.cn?target=https%3A%2F%2Fleetcode.cn%2Fproblems%2Fsubsets%2F" target="_blank" title="https://leetcode.cn/problems/subsets/" ref="nofollow noopener noreferrer">78. 子集</a></h6>
<p><strong>题目描述：</strong></p>
<p>给你一个整数数组 <code>nums</code>，数组中的元素<strong>互不相同</strong>。返回该数组所有可能的子集（幂集）。</p>
<p>解集<strong>不能</strong>包含重复的子集。你可以按<strong>任意顺序</strong>返回解集。</p>
<p><strong>示例 1：</strong></p>
<pre><code class="hljs language-ini" lang="ini">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]
输出：<span class="hljs-section">[[]</span>,<span class="hljs-section">[1]</span>,<span class="hljs-section">[2]</span>,<span class="hljs-section">[1,2]</span>,<span class="hljs-section">[3]</span>,<span class="hljs-section">[1,3]</span>,<span class="hljs-section">[2,3]</span>,<span class="hljs-section">[1,2,3]]</span>
</code></pre>
<p><strong>解决方案：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">/**
 * 78. 子集
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number[]</span>} <span class="hljs-variable">nums</span> - 不含重复元素的数组
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">number[][]</span>} 所有子集
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">subsets</span>(<span class="hljs-params">nums</span>) {
  <span class="hljs-keyword">const</span> res = [];

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">backtrack</span>(<span class="hljs-params">path, start</span>) {
    <span class="hljs-comment">// 每次递归都记录路径（无需严格终止条件）</span>
    res.<span class="hljs-title function_">push</span>([...path]);

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = start; i &lt; nums.<span class="hljs-property">length</span>; i++) {
      <span class="hljs-comment">// 选数</span>
      path.<span class="hljs-title function_">push</span>(nums[i]);

      <span class="hljs-comment">// 钻到底：不重复选，所以start传i+1</span>
      <span class="hljs-title function_">backtrack</span>(path, i + <span class="hljs-number">1</span>);

      <span class="hljs-comment">// 退回来→删掉这个数</span>
      path.<span class="hljs-title function_">pop</span>();
    }
  }

  <span class="hljs-title function_">backtrack</span>([], <span class="hljs-number">0</span>);
  <span class="hljs-keyword">return</span> res;
}
</code></pre>
<p><strong>易错点：</strong></p>
<ul>
<li>忘记在每次递归开始时记录路径（子集问题需要在每个节点都记录，不只是叶子节点）</li>
</ul>
<hr/>
<h6 data-id="heading-27"><a href="https://link.juejin.cn?target=https%3A%2F%2Fleetcode.cn%2Fproblems%2Fsubsets-ii%2F" target="_blank" title="https://leetcode.cn/problems/subsets-ii/" ref="nofollow noopener noreferrer">90. 子集 II</a></h6>
<p><strong>题目描述：</strong></p>
<p>给你一个整数数组 <code>nums</code>，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。</p>
<p>解集<strong>不能</strong>包含重复的子集。返回的解集中，子集可以按<strong>任意顺序</strong>排列。</p>
<p><strong>示例 1：</strong></p>
<pre><code class="hljs language-ini" lang="ini">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>]
输出：<span class="hljs-section">[[]</span>,<span class="hljs-section">[1]</span>,<span class="hljs-section">[1,2]</span>,<span class="hljs-section">[1,2,2]</span>,<span class="hljs-section">[2]</span>,<span class="hljs-section">[2,2]]</span>
</code></pre>
<p><strong>解决方案：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">/**
 * 90. 子集 II
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number[]</span>} <span class="hljs-variable">nums</span> - 可能包含重复元素的数组
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">number[][]</span>} 所有不重复的子集
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">subsetsWithDup</span>(<span class="hljs-params">nums</span>) {
  <span class="hljs-keyword">const</span> res = [];
  nums.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b); <span class="hljs-comment">// 排序便于去重</span>

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">backtrack</span>(<span class="hljs-params">path, start</span>) {
    <span class="hljs-comment">// 每次递归都记录路径</span>
    res.<span class="hljs-title function_">push</span>([...path]);

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = start; i &lt; nums.<span class="hljs-property">length</span>; i++) {
      <span class="hljs-comment">// 去重剪枝：跳过重复元素（关键！）</span>
      <span class="hljs-comment">// i &gt; start 确保同一层不选重复数字，但不同层可以选</span>
      <span class="hljs-keyword">if</span> (i &gt; start &amp;&amp; nums[i] === nums[i - <span class="hljs-number">1</span>]) {
        <span class="hljs-keyword">continue</span>;
      }

      <span class="hljs-comment">// 选数</span>
      path.<span class="hljs-title function_">push</span>(nums[i]);

      <span class="hljs-comment">// 钻到底：不重复选，所以start传i+1</span>
      <span class="hljs-title function_">backtrack</span>(path, i + <span class="hljs-number">1</span>);

      <span class="hljs-comment">// 退回来→删掉这个数</span>
      path.<span class="hljs-title function_">pop</span>();
    }
  }

  <span class="hljs-title function_">backtrack</span>([], <span class="hljs-number">0</span>);
  <span class="hljs-keyword">return</span> res;
}
</code></pre>
<p><strong>易错点：</strong></p>
<ul>
<li>去重逻辑和组合总和II相同，但容易忘记排序</li>
</ul>
<hr/>
<h3 data-id="heading-28">四、回溯算法核心优化：剪枝</h3>
<p>剪枝是提升回溯效率的关键，常见剪枝策略：</p>
<ol>
<li><strong>提前终止</strong>：如组合总和中"路径和超过目标值直接返回"</li>
<li><strong>排序剪枝</strong>：先排序候选数组，遇到"当前值+已选和&gt;目标值"时，后续值更大，直接break</li>
<li><strong>重复剪枝</strong>：如子集II/全排列II中，跳过重复元素（<code>if (i &gt; start &amp;&amp; nums[i] === nums[i-1]) continue</code>）</li>
<li><strong>约束剪枝</strong>：如N皇后中，提前判断位置是否合法，不合法则跳过</li>
<li><strong>数量剪枝</strong>：如组合问题中，剩余可选数字不够时直接返回</li>
</ol>
<h3 data-id="heading-29">五、总结</h3>
<ol>
<li><strong>核心思想</strong>：回溯 = 深度优先遍历 + 状态回退 + 剪枝，核心是"选→探→撤"</li>
<li><strong>固定节奏</strong>：<strong>push（选数）→ 递归（钻深层）→ pop（擦脚印）</strong>，抓住这个节奏就能解决所有回溯题</li>
<li><strong>模板复用</strong>：
<ul>
<li>组合/子集：用<code>start</code>参数避免重复，循环从<code>start</code>开始</li>
<li>排列：用<code>used</code>数组避免重复选，循环从0开始</li>
</ul>
</li>
<li><strong>优化关键</strong>：剪枝是减少无效递归的核心，能让回溯效率提升一个量级</li>
</ol>
<p>回溯算法看似复杂，但只要抓住"选→钻→退→删"这个固定节奏和"剪枝优化"这个核心，就能轻松应对各类回溯问题。建议从简单的组合问题入手，逐步过渡到排列、子集问题，多写多练就能融会贯通。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[AI 写文章风格飘忽不定？用 SKILL 让它学会你的「味道」！这是一篇 100% AI 写作的文章]]></title>    <link>https://juejin.cn/post/7596865421612236854</link>    <guid>https://juejin.cn/post/7596865421612236854</guid>    <pubDate>2026-01-19T11:22:43.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7596865421612236854" data-draft-id="7596905751110271039" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="AI 写文章风格飘忽不定？用 SKILL 让它学会你的「味道」！这是一篇 100% AI 写作的文章"/> <meta itemprop="keywords" content="前端,AI编程"/> <meta itemprop="datePublished" content="2026-01-19T11:22:43.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="不如摸鱼去"/> <meta itemprop="url" content="https://juejin.cn/user/26044011388510"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            AI 写文章风格飘忽不定？用 SKILL 让它学会你的「味道」！这是一篇 100% AI 写作的文章
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/26044011388510/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    不如摸鱼去
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-19T11:22:43.000Z" title="Mon Jan 19 2026 11:22:43 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/dc8af2ee580d484fb350abc6e4018555~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5aaC5pG46bG85Y67:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769426563&amp;x-signature=oTy5%2F2VwJji9GATXs2AWJw%2BPY8c%3D" alt="" loading="lazy"/></p>
<p>大家好，我是不如摸鱼去，欢迎来到我的 AI Coding 分享专栏。</p>
<p>你是不是也遇到过这样的问题：让 AI 帮忙写文章，结果出来的内容虽然逻辑清晰，但总感觉「不像自己写的」？换个话题再写，风格又变了？今天我们来聊聊如何用 SKILL 技术，让 AI 学会你的写作风格，输出「有你味道」的内容。</p>
<blockquote>
<p>本文所述的 SKILL 技术可在 Google 的 Gemini CLI、Claude Code 等 AI 工具中使用，其他 AI 工具也有类似的概念。</p>
</blockquote>
<hr/>
<h2 data-id="heading-0">🤔 问题分析</h2>
<h3 data-id="heading-1">AI 写作的痛点</h3>
<p>用 AI 写文章，我们经常遇到这些问题：</p>
<ol>
<li><strong>风格不一致</strong>：同一个 AI，今天写的活泼，明天写的严肃</li>
<li><strong>缺少个人特色</strong>：输出的内容四平八稳，但没有辨识度</li>
<li><strong>上下文有限</strong>：每次对话都要重新描述「我想要什么样的风格」</li>
<li><strong>难以复用</strong>：好不容易调教好了，换个话题又要重来</li>
</ol>
<h3 data-id="heading-2">核心难点</h3>
<p>传统的做法是在每次对话时，用 System Prompt 或者对话开头告诉 AI「你要用什么风格写」。但这样做有几个问题：</p>
<ul>
<li>每次都要手动输入，效率低</li>
<li>描述不全面，AI 理解有偏差</li>
<li>无法沉淀和迭代</li>
</ul>
<hr/>
<h2 data-id="heading-3">💡 SKILL 是什么？</h2>
<p>SKILL 是一种扩展 AI 能力的技术规范，可以理解为「AI 能力插件」。它通过一个结构化的文件（通常是 <code>SKILL.md</code>），告诉 AI 在特定场景下应该<strong>如何思考</strong>和<strong>如何行动</strong>。</p>
<h3 data-id="heading-4">SKILL 的组成</h3>
<p>一个标准的 SKILL 包含以下内容：</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-meta">---</span>
<span class="hljs-attr">name:</span> <span class="hljs-string">skill-name</span>
<span class="hljs-attr">description:</span> <span class="hljs-string">技能的一句话描述</span>
<span class="hljs-meta">---
</span>
<span class="hljs-comment"># 技能标题</span>

[<span class="hljs-string">详细的指令内容</span>]
</code></pre>
<p><strong>Frontmatter 部分</strong>（<code>---</code> 之间）定义了元数据：</p>
<ul>
<li><code>name</code>：技能的唯一标识</li>
<li><code>description</code>：技能的简短描述，AI 会根据这个判断是否需要使用该技能</li>
</ul>
<p><strong>正文部分</strong> 则是详细的指令，可以包括：</p>
<ul>
<li>使用场景说明</li>
<li>行为规范</li>
<li>模板和示例</li>
<li>注意事项</li>
</ul>
<h3 data-id="heading-5">SKILL vs System Prompt</h3>






























<table><thead><tr><th>维度</th><th>System Prompt</th><th>SKILL</th></tr></thead><tbody><tr><td>持久性</td><td>每次对话需重新设置</td><td>写一次，随处可用</td></tr><tr><td>复杂度</td><td>适合简短指令</td><td>可包含完整规范文档</td></tr><tr><td>协作性</td><td>难以分享</td><td>可版本控制、团队共享</td></tr><tr><td>可迭代</td><td>需要手动维护</td><td>同代码一样迭代优化</td></tr></tbody></table>
<hr/>
<h2 data-id="heading-6">🎯 用 SKILL 打造个人写作风格</h2>
<h3 data-id="heading-7">我的实践</h3>
<p>作为一个喜欢分享技术文章的开发者，我希望 AI 写出来的内容能延续我的风格。于是我做了这件事：</p>
<ol>
<li><strong>分析自己的历史文章</strong>（大约 30+ 篇）</li>
<li><strong>总结写作特点</strong>（语言风格、结构习惯、常用表达）</li>
<li><strong>整理成 SKILL 文件</strong></li>
</ol>
<p>下面是我总结的几个关键维度：</p>
<h3 data-id="heading-8">1. 语言风格</h3>
<p>我的文章偏向口语化、亲切的表达：</p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section">### 语言风格</span>

<span class="hljs-bullet">1.</span> <span class="hljs-strong">**口语化亲切**</span>
<span class="hljs-bullet">   -</span> ✅ "你是不是也曾为了..."
<span class="hljs-bullet">   -</span> ✅ "如果你也在为...而烦恼，不妨试试这个方案！"
<span class="hljs-bullet">   -</span> ✅ "还要啥自行车呢"

<span class="hljs-bullet">2.</span> <span class="hljs-strong">**自我调侃**</span>
<span class="hljs-bullet">   -</span> "从我的名字「不如摸鱼去」就可以看出来，我是个向往摸鱼的人"

<span class="hljs-bullet">3.</span> <span class="hljs-strong">**适度幽默**</span>
<span class="hljs-bullet">   -</span> 善用 emoji 🔥 🤝 😩 📅 🌟 🚀 等
</code></pre>
<h3 data-id="heading-9">2. 文章结构模板</h3>
<p>针对不同类型的文章，我总结了对应的模板：</p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section">### 技术教程类</span>

<span class="hljs-strong">**开头模板**</span>：
大家好，我是不如摸鱼去，wot-ui的主要维护者，欢迎来到我的 [领域] 分享专栏。

<span class="hljs-strong">**结构**</span>：
<span class="hljs-bullet">1.</span> 引言/背景（问题引入）
<span class="hljs-bullet">2.</span> 问题分析（存在什么问题、核心难点）
<span class="hljs-bullet">3.</span> 解决方案架构（整体思路）
<span class="hljs-bullet">4.</span> 实现详解（分步骤、带代码）
<span class="hljs-bullet">5.</span> 使用方式（实际应用场景）
<span class="hljs-bullet">6.</span> 总结（优势罗列、号召行动）
<span class="hljs-bullet">7.</span> 相关资源/相关文章
</code></pre>
<h3 data-id="heading-10">3. 常用表达收集</h3>
<p>把自己常用的句式也整理进去：</p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section">### 开头语</span>
<span class="hljs-bullet">-</span> <span class="hljs-code">`大家好，我是不如摸鱼去，[身份描述]，欢迎来到我的 [专栏名] 分享专栏。`</span>

<span class="hljs-section">### 总结语</span>
<span class="hljs-bullet">-</span> <span class="hljs-code">`如果你也在为 xxx 而烦恼，不妨试试这个方案！`</span>
<span class="hljs-bullet">-</span> <span class="hljs-code">`希望对各位有所启发`</span>

<span class="hljs-section">### 号召语</span>
<span class="hljs-bullet">-</span> <span class="hljs-code">`感兴趣的小伙伴可以自行探索`</span>
</code></pre>
<h3 data-id="heading-11">4. 标题风格</h3>
<p>我比较喜欢用疑问句 + 解决方案的标题模式：</p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section">### 标题吸引力</span>
<span class="hljs-bullet">-</span> 疑问句：<span class="hljs-code">`xxx 无法实现 xxx？这个方法做到了！`</span>
<span class="hljs-bullet">-</span> 问题+方案：<span class="hljs-code">`xxx 卡脖子？1 个插件搞定`</span>
<span class="hljs-bullet">-</span> 数字化：<span class="hljs-code">`10 分钟`</span>、<span class="hljs-code">`4 步接入`</span>
</code></pre>
<hr/>
<h2 data-id="heading-12">🔧 如何使用 SKILL</h2>
<h3 data-id="heading-13">文件位置</h3>
<p>将 SKILL 文件放在项目的 <code>.gemini/skills/</code> 目录下：</p>
<pre><code class="hljs language-objectivec" lang="objectivec">my-blog/
├── .gemini/
│   └── skills/
│       └── writing-style/
│           └── <span class="hljs-built_in">SKILL</span>.md    # 写作风格 <span class="hljs-built_in">SKILL</span>
├── docs/
│   └── ...
└── ...
</code></pre>
<h3 data-id="heading-14">触发方式</h3>
<p>当 AI 检测到你的需求与 SKILL 的描述匹配时，会自动加载对应的 SKILL。你也可以通过 <code>@</code> 符号主动引用：</p>
<pre><code class="hljs language-ini" lang="ini">@<span class="hljs-section">[writing-style]</span> 帮我写一篇关于 Vue3 组合式 API 的文章
</code></pre>
<h3 data-id="heading-15">实际效果</h3>
<p>使用 SKILL 后，AI 生成的文章会：</p>
<ol>
<li><strong>自动使用我的开头格式</strong>：「大家好，我是不如摸鱼去...」</li>
<li><strong>遵循我的结构习惯</strong>：问题引入 → 分析 → 解决方案 → 总结</li>
<li><strong>使用我的表达方式</strong>：口语化、善用 emoji、积极正面</li>
<li><strong>保持标题风格</strong>：疑问句 + 解决方案模式</li>
</ol>
<hr/>
<h2 data-id="heading-16">🚀 进阶玩法</h2>
<h3 data-id="heading-17">1. 多 SKILL 组合</h3>
<p>你可以创建多个 SKILL，针对不同场景：</p>
<pre><code class="hljs language-perl" lang="perl">.gemini/skills/
├── writing-style/      <span class="hljs-comment"># 通用写作风格</span>
├── tech-tutorial/      <span class="hljs-comment"># 技术教程专用</span>
├── <span class="hljs-keyword">open</span>-source-<span class="hljs-keyword">log</span>/    <span class="hljs-comment"># 开源日志专用</span>
└── year-end-summary/   <span class="hljs-comment"># 年终总结专用</span>
</code></pre>
<h3 data-id="heading-18">2. 团队协作</h3>
<p>SKILL 是纯文本文件，可以纳入版本控制：</p>
<ul>
<li>团队成员共享写作规范</li>
<li>通过 PR 迭代优化</li>
<li>新人快速上手团队风格</li>
</ul>
<h3 data-id="heading-19">3. 持续优化</h3>
<p>定期回顾 AI 的输出，将好的表达加入 SKILL，形成正循环：</p>
<ol>
<li>AI 输出 → 人工审核</li>
<li>发现好的表达 → 加入 SKILL</li>
<li>发现问题 → 补充注意事项</li>
<li>下次输出 → 质量提升</li>
</ol>
<hr/>
<h2 data-id="heading-20">📝 总结</h2>
<p>通过 SKILL 技术，我们成功解决了 AI 写作风格不一致的问题：</p>
<ol>
<li><strong>一次整理，永久复用</strong>：把写作风格沉淀成文档</li>
<li><strong>自动触发，无需手动</strong>：AI 会根据任务自动加载</li>
<li><strong>可版本控制</strong>：像代码一样管理和迭代</li>
<li><strong>团队可协作</strong>：整个团队共享统一的写作规范</li>
</ol>
<p>SKILL 的本质是「教会 AI 一项技能」。写作风格只是一个应用场景，你还可以用它来规范代码风格、定义项目架构、设置审查标准等等。</p>
<p>如果你也在为 AI 输出不稳定而烦恼，不妨试试 SKILL 方案！</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/74f2e9de5c0f45ed8aa1b4e54b64f028~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5aaC5pG46bG85Y67:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769426563&amp;x-signature=5a6P7HquihumSRxzURCJLm6GGZU%3D" alt="" loading="lazy"/></p>
<hr/>
<h2 data-id="heading-21">🔗 相关资源</h2>
<ul>
<li>Gemini CLI (<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fanthropics%2Fgemini-cli" target="_blank" title="https://github.com/anthropics/gemini-cli" ref="nofollow noopener noreferrer">github.com/anthropics/…</a>) - Google 推出的 AI 命令行工具</li>
<li>wot-ui (<a href="https://link.juejin.cn?target=https%3A%2F%2Fwot-ui.cn%2F" target="_blank" title="https://wot-ui.cn/" ref="nofollow noopener noreferrer">wot-ui.cn/</a>) - 我维护的 uni-app 组件库</li>
</ul>
<hr/>
<h2 data-id="heading-22">往期精彩</h2>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FYH7v_c0MNZ39IheitqYLLw" target="_blank" title="https://mp.weixin.qq.com/s/YH7v_c0MNZ39IheitqYLLw" ref="nofollow noopener noreferrer">当年偷偷玩小霸王，现在偷偷用 Trae Solo 复刻坦克大战</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FrHJVlbVg8PkGpzfEEtZmIw" target="_blank" title="https://mp.weixin.qq.com/s/rHJVlbVg8PkGpzfEEtZmIw" ref="nofollow noopener noreferrer">uni-app 无法实现全局 Toast？这个方法做到了！</a></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[2026年AI开发新标准来了！Chat Completion已过时，Open Responses横空出世！]]></title>    <link>https://juejin.cn/post/7596905751110352959</link>    <guid>https://juejin.cn/post/7596905751110352959</guid>    <pubDate>2026-01-19T11:36:55.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7596905751110352959" data-draft-id="7596896373053505599" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="2026年AI开发新标准来了！Chat Completion已过时，Open Responses横空出世！"/> <meta itemprop="keywords" content="人工智能,AIGC,LangChain"/> <meta itemprop="datePublished" content="2026-01-19T11:36:55.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="倔强青铜三"/> <meta itemprop="url" content="https://juejin.cn/user/2942757076730455"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            2026年AI开发新标准来了！Chat Completion已过时，Open Responses横空出世！
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2942757076730455/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    倔强青铜三
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-19T11:36:55.000Z" title="Mon Jan 19 2026 11:36:55 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    1
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><strong>原文链接：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fhuggingface.co%2Fblog%2Fopen-responses" target="_blank" title="https://huggingface.co/blog/open-responses" ref="nofollow noopener noreferrer">huggingface.co/blog/open-r…</a><br/>
<strong>作者：</strong> Shaun Smith, Ben Burtenshaw, Merve, Pedro Cuenca<br/>
<strong>译者：</strong> 倔强青铜三</p>
<h2 data-id="heading-0">前言</h2>
<p>大家好，我是<strong>倔强青铜三</strong>。欢迎关注我，<strong>微信公众号：倔强青铜三</strong>。欢迎点赞、收藏、关注，一键三连！！！</p>
<h2 data-id="heading-1">什么是 Open Responses？</h2>
<p>Open Responses 是一个新的<strong>开放推理标准</strong>。由 OpenAI 发起，开源 AI 社区构建，并由 Hugging Face 生态系统支持，Open Responses 基于 Responses API，专为<strong>智能体的未来</strong>而设计。在这篇博客中，我们将了解 Open Responses 的工作原理以及为什么开源社区应该使用它。</p>
<blockquote>
<p>我已经弄了一个<code>Open Responses </code>中文镜像站点<a href="https://link.juejin.cn?target=https%3A%2F%2Fopenresponses-cn.top%2F" target="_blank" title="https://openresponses-cn.top/" ref="nofollow noopener noreferrer">openresponses-cn.top</a>，把<code>Open Responses</code>文档进行了中文翻译，方便大家学习！</p>
</blockquote>
<p><strong>聊天机器人的时代已经过去，智能体主导着推理工作负载。</strong> 开发者正在转向能够推理、规划并在长时间范围内行动的自主系统。尽管发生了这种转变，但生态系统中大部分仍在使用 <strong>Chat Completion</strong> 格式，该格式专为轮次对话而设计，对于智能体用例来说<strong>力不从心</strong>。</p>
<p><strong>Responses</strong> 格式旨在解决这些限制，但它是封闭的，没有被广泛采用。<strong>Chat Completion</strong> 格式仍然是事实上的标准，尽管存在替代方案。</p>
<p>智能体工作流需求与根深蒂固的接口之间的这种不匹配，推动了对开放推理标准的需求。在未来几个月里，我们将与社区和推理提供商合作，实施并调整 Open Responses 为一个共享的格式，实际上能够取代聊天完成。</p>
<p>Open Responses 建立在 OpenAI 于 2025 年 3 月推出的 <strong>Responses API</strong> 的方向之上，它用一个一致的方式取代了现有的 Completion 和 Assistants API：</p>
<ul>
<li>生成文本、图像和 JSON 结构化输出</li>
<li>通过基于任务的单独端点创建视频内容</li>
<li>在提供商端运行智能体循环，自主执行工具调用并返回最终结果</li>
</ul>
<h3 data-id="heading-2">什么是 Open Responses？</h3>
<p>Open Responses 扩展并开源了 Responses API，使构建者和路由提供商更容易互操作并就共享利益进行协作。</p>
<p>一些关键点包括：</p>
<ul>
<li>默认无状态，支持需要加密推理的提供商</li>
<li>标准化的模型配置参数</li>
<li>流式传输被建模为一系列语义事件，而不是原始文本或对象增量</li>
<li>通过特定于某些模型提供商的可配置参数进行扩展</li>
</ul>
<h3 data-id="heading-3">我们需要了解什么才能使用 Open Responses？</h3>
<p>我们将简要探索影响大多数社区成员的核心变化。如果你想深入了解规范，请查看 <strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fopenresponses-cn.top%2F" target="_blank" title="https://openresponses-cn.top/" ref="nofollow noopener noreferrer">Open Responses 文档</a></strong></p>
<h4 data-id="heading-4">客户端请求 Open Responses</h4>
<p>客户端对 Open Responses 的请求与现有的 Responses API 类似。下面我们演示使用 curl 向 Open Responses API 发出的请求。我们正在调用一个代理端点，该端点使用 Open Responses API 模式路由到推理提供商。</p>
<pre><code class="hljs language-bash" lang="bash">curl https://evalstate-openresponses.hf.space/v1/responses \\
   -H <span class="hljs-string">"Content-Type: application/json"</span> \\
   -H <span class="hljs-string">"Authorization: Bearer <span class="hljs-variable">$HF_TOKEN</span>"</span> \\
   -H <span class="hljs-string">"OpenResponses-Version: latest"</span> \\
   -N \\
   -d <span class="hljs-string">'{}
         "model": "moonshotai/Kimi-K2-Thinking:nebius",
         "input": "explain the theory of life"
       {}'</span>
</code></pre>
<h4 data-id="heading-5">推理客户端和提供商的变化</h4>
<p>已经支持 Responses API 的客户端可以以相对较少的努力迁移到 Open Responses。主要变化涉及推理内容的暴露方式：</p>
<p><strong>扩展的推理可见性：</strong> Open Responses 为推理项目形式化了三个可选字段：</p>
<ul>
<li><code>content</code>（原始推理跟踪）</li>
<li><code>encrypted_content</code>（提供商特定的保护内容）</li>
<li><code>summary</code>（从原始跟踪中清理）</li>
</ul>
<p>OpenAI 模型以前只暴露 <code>summary</code> 和 <code>encrypted_content</code>。使用 Open Responses，提供商可以通过 API 暴露其原始推理。</p>
<p>从以前只返回摘要和加密内容的提供商迁移的客户端现在将有机会在所选提供商支持时接收和处理原始推理流。</p>
<p>实现更丰富的状态更改和有效负载，包括更详细的可观察性——例如，托管的代码解释器可以发送特定的 <code>interpreting</code> 状态，以在长时间运行的操作期间改善智能体和用户的可见性。</p>
<p>对于模型提供商来说，如果他们已经遵守 Responses API 规范，那么实施 Open Responses 的更改应该是直截了当的。对于路由器，现在有机会标准化一致的端点并在需要时支持配置选项进行自定义。</p>
<p>随着提供商继续创新，某些功能将在基本规范中标准化。</p>
<p>总之，迁移到 Open Responses 将使推理体验更加一致并提高质量，因为传统 Completions API 的未记录扩展、解释和变通方法在 Open Responses 中被规范化。</p>
<p>你可以在下面看到如何流式传输推理块。</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"model"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"moonshotai/Kimi-K2-Thinking:together"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"input"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
    <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"message"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"role"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"user"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"content"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"explain photosynthesis."</span>
    <span class="hljs-punctuation">}</span>
  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"stream"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p>以下是获取 Open Response 和使用 OpenAI Responses 进行推理增量之间的区别：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 开放权重模型流式传输原始推理</span>
<span class="hljs-attr">event</span>: response.<span class="hljs-property">reasoning</span>.<span class="hljs-property">delta</span>
<span class="hljs-attr">data</span>: {<span class="hljs-string">"delta"</span>: <span class="hljs-string">"User asked: 'Where should I eat...' Step 1: Parse location..."</span>}

<span class="hljs-comment">// 具有加密推理的模型发送摘要，或由开放权重模型作为便利发送</span>
<span class="hljs-attr">event</span>: response.<span class="hljs-property">reasoning_summary_text</span>.<span class="hljs-property">delta</span>
<span class="hljs-attr">data</span>: {<span class="hljs-string">"delta"</span>: <span class="hljs-string">"Determined user wants restaurant recommendations"</span>}
</code></pre>
<h4 data-id="heading-6">Open Responses 用于路由</h4>
<p>Open Responses 区分"<strong>模型提供商</strong>"（提供推理的人）和"<strong>路由器</strong>"（在多个提供商之间编排的中间人）。</p>
<p>客户端现在可以在发出请求时指定提供商以及提供商特定的 API 选项，允许中间路由器在上游提供商之间编排请求。</p>
<h4 data-id="heading-7">工具</h4>
<p>Open Responses 原生支持两类工具：<strong>内部</strong>和<strong>外部</strong>。</p>
<p>外部托管工具在模型提供商的系统之外实施。例如，要执行的客户端功能或 MCP 服务器。内部托管工具在模型提供商的系统内。例如，OpenAI 的文件搜索或 Google Drive 集成。模型调用、执行并完全在提供商的基础设施内检索结果，无需开发人员干预。</p>
<h4 data-id="heading-8">子代理循环</h4>
<p>Open Responses 形式化了智能体循环，它通常由推理、工具调用和响应生成的重复循环组成，使模型能够自主完成多步骤任务。</p>
<p>循环操作如下：</p>
<ol>
<li>API 接收用户请求并从模型采样</li>
<li>如果模型发出工具调用，API 会执行它（内部或外部）</li>
<li>工具结果反馈给模型以继续推理</li>
<li>循环重复，直到模型发出完成信号</li>
</ol>
<p>对于内部托管工具，提供商管理整个循环；执行工具，将结果返回给模型，并流式传输输出。这意味着多步骤工作流（如"搜索文档、总结发现、然后起草电子邮件"）使用单个请求。</p>
<p>客户端通过 <code>max_tool_calls</code> 限制迭代次数，通过 <code>tool_choice</code> 约束可调用工具来控制循环行为：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"model"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"zai-org/GLM-4.7"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"input"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Find Q3 sales data and email a summary to the team"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"tools"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>...<span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"max_tool_calls"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">10</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"tool_choice"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"auto"</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p>响应包含所有中间项目：工具调用、结果、推理。</p>
<h2 data-id="heading-9">总结</h2>
<p>Open Responses 扩展并改进了 Responses API，提供更丰富和更详细的内容定义、兼容性和部署选项。它还提供了一种在主推理调用期间执行子代理循环的标准方法，为 AI 应用程序打开强大的功能。</p>
<blockquote>
<p>我已经弄了一个<code>Open Responses </code>中文镜像站点<a href="https://link.juejin.cn?target=https%3A%2F%2Fopenresponses-cn.top%2F" target="_blank" title="https://openresponses-cn.top/" ref="nofollow noopener noreferrer">openresponses-cn.top</a>，把<code>Open Responses</code>文档进行了中文翻译，方便大家学习！</p>
</blockquote>
<p><strong>欢迎关注我的微信公众号：倔强青铜三，获取更多 AI 自动化和开发技巧分享！</strong></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Hibernate（51）Hibernate的查询缓存如何使用？]]></title>    <link>https://juejin.cn/post/7596864700509601826</link>    <guid>https://juejin.cn/post/7596864700509601826</guid>    <pubDate>2026-01-19T11:51:03.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7596864700509601826" data-draft-id="7596864700509585442" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Hibernate（51）Hibernate的查询缓存如何使用？"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-01-19T11:51:03.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Victor356"/> <meta itemprop="url" content="https://juejin.cn/user/3492507879476878"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Hibernate（51）Hibernate的查询缓存如何使用？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3492507879476878/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Victor356
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-19T11:51:03.000Z" title="Mon Jan 19 2026 11:51:03 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>Hibernate的查询缓存（Query Cache）可以显著提高重复查询的性能。查询缓存存储的是查询结果的集合，而不是单个实体。要使用查询缓存，需要启用Hibernate的二级缓存，并对特定的查询启用缓存。以下是详细的使用步骤和代码示例。</p>
<h3 data-id="heading-0">1. 添加依赖</h3>
<p>首先，确保在项目中添加了Hibernate和缓存提供者的依赖。以下是使用Ehcache作为缓存提供者的Maven依赖配置：</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- Hibernate Core --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.hibernate<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hibernate-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.6.3.Final<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- Ehcache --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.ehcache<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ehcache<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.9.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- Hibernate Ehcache Integration --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.hibernate<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hibernate-ehcache<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.6.3.Final<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>
</code></pre>
<h3 data-id="heading-1">2. 配置Hibernate</h3>
<p>在Hibernate的配置文件 <code>hibernate.cfg.xml</code> 中启用二级缓存和查询缓存，并指定Ehcache作为缓存提供者。</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">hibernate-configuration</span> <span class="hljs-keyword">PUBLIC</span>
        <span class="hljs-string">"-//Hibernate/Hibernate Configuration DTD 3.0//EN"</span>
        <span class="hljs-string">"http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">hibernate-configuration</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">session-factory</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- 数据库连接配置 --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.connection.driver_class"</span>&gt;</span>com.mysql.cj.jdbc.Driver<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.connection.url"</span>&gt;</span>jdbc:mysql://localhost:3306/your_database<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.connection.username"</span>&gt;</span>your_username<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.connection.password"</span>&gt;</span>your_password<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>

        <span class="hljs-comment">&lt;!-- Hibernate 属性配置 --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.dialect"</span>&gt;</span>org.hibernate.dialect.MySQLDialect<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.show_sql"</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.format_sql"</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>

        <span class="hljs-comment">&lt;!-- 启用二级缓存和查询缓存 --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.cache.use_second_level_cache"</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.cache.region.factory_class"</span>&gt;</span>org.hibernate.cache.jcache.JCacheRegionFactory<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.javax.cache.provider"</span>&gt;</span>org.ehcache.jsr107.EhcacheCachingProvider<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.cache.use_query_cache"</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>

        <span class="hljs-comment">&lt;!-- 映射类 --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">mapping</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.example.domain.Product"</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">session-factory</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">hibernate-configuration</span>&gt;</span>
</code></pre>
<h3 data-id="heading-2">3. 配置Ehcache</h3>
<p>创建Ehcache的配置文件 <code>ehcache.xml</code>，并将其放置在类路径的根目录下。</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">config</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">'http://www.w3.org/2001/XMLSchema-instance'</span>
        <span class="hljs-attr">xmlns</span>=<span class="hljs-string">'http://www.ehcache.org/v3'</span>
        <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://www.ehcache.org/v3 http://www.ehcache.org/schema/ehcache-core-3.0.xsd"</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">cache</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">"com.example.domain.Product"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">key-type</span>&gt;</span>java.lang.Long<span class="hljs-tag">&lt;/<span class="hljs-name">key-type</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">value-type</span>&gt;</span>com.example.domain.Product<span class="hljs-tag">&lt;/<span class="hljs-name">value-type</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">expiry</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">ttl</span> <span class="hljs-attr">unit</span>=<span class="hljs-string">"seconds"</span>&gt;</span>600<span class="hljs-tag">&lt;/<span class="hljs-name">ttl</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">expiry</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">heap</span> <span class="hljs-attr">unit</span>=<span class="hljs-string">"entries"</span>&gt;</span>1000<span class="hljs-tag">&lt;/<span class="hljs-name">heap</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">offheap</span> <span class="hljs-attr">unit</span>=<span class="hljs-string">"MB"</span>&gt;</span>100<span class="hljs-tag">&lt;/<span class="hljs-name">offheap</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">cache</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">cache</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">"org.hibernate.cache.internal.StandardQueryCache"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">key-type</span>&gt;</span>java.lang.String<span class="hljs-tag">&lt;/<span class="hljs-name">key-type</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">value-type</span>&gt;</span>java.lang.Object<span class="hljs-tag">&lt;/<span class="hljs-name">value-type</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">expiry</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">ttl</span> <span class="hljs-attr">unit</span>=<span class="hljs-string">"seconds"</span>&gt;</span>600<span class="hljs-tag">&lt;/<span class="hljs-name">ttl</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">expiry</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">heap</span> <span class="hljs-attr">unit</span>=<span class="hljs-string">"entries"</span>&gt;</span>1000<span class="hljs-tag">&lt;/<span class="hljs-name">heap</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">offheap</span> <span class="hljs-attr">unit</span>=<span class="hljs-string">"MB"</span>&gt;</span>100<span class="hljs-tag">&lt;/<span class="hljs-name">offheap</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">cache</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">cache</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">"org.hibernate.cache.spi.UpdateTimestampsCache"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">key-type</span>&gt;</span>java.lang.String<span class="hljs-tag">&lt;/<span class="hljs-name">key-type</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">value-type</span>&gt;</span>java.lang.Long<span class="hljs-tag">&lt;/<span class="hljs-name">value-type</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">expiry</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">ttl</span> <span class="hljs-attr">unit</span>=<span class="hljs-string">"seconds"</span>&gt;</span>600<span class="hljs-tag">&lt;/<span class="hljs-name">ttl</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">expiry</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">heap</span> <span class="hljs-attr">unit</span>=<span class="hljs-string">"entries"</span>&gt;</span>1000<span class="hljs-tag">&lt;/<span class="hljs-name">heap</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">offheap</span> <span class="hljs-attr">unit</span>=<span class="hljs-string">"MB"</span>&gt;</span>100<span class="hljs-tag">&lt;/<span class="hljs-name">offheap</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">cache</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">config</span>&gt;</span>
</code></pre>
<h3 data-id="heading-3">4. 配置实体类</h3>
<p>在需要缓存的实体类上添加缓存注解。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">import</span> javax.persistence.*;
<span class="hljs-keyword">import</span> org.hibernate.annotations.Cache;
<span class="hljs-keyword">import</span> org.hibernate.annotations.CacheConcurrencyStrategy;

<span class="hljs-meta">@Entity</span>
<span class="hljs-meta">@Table(name = "product")</span>
<span class="hljs-meta">@Cacheable</span>
<span class="hljs-meta">@Cache(usage = CacheConcurrencyStrategy.READ_WRITE)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Product</span> {
    <span class="hljs-meta">@Id</span>
    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span>
    <span class="hljs-keyword">private</span> Long id;

    <span class="hljs-meta">@Column(name = "name")</span>
    <span class="hljs-keyword">private</span> String name;

    <span class="hljs-meta">@Column(name = "price")</span>
    <span class="hljs-keyword">private</span> Double price;

    <span class="hljs-comment">// Getters and Setters</span>
}
</code></pre>
<h3 data-id="heading-4">5. 使用查询缓存</h3>
<p>以下代码展示了如何使用Hibernate的查询缓存。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">import</span> org.hibernate.Session;
<span class="hljs-keyword">import</span> org.hibernate.SessionFactory;
<span class="hljs-keyword">import</span> org.hibernate.Transaction;
<span class="hljs-keyword">import</span> org.hibernate.cfg.Configuration;
<span class="hljs-keyword">import</span> org.hibernate.query.Query;

<span class="hljs-keyword">import</span> java.util.List;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HibernateQueryCacheExample</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> SessionFactory sessionFactory;

    <span class="hljs-keyword">static</span> {
        <span class="hljs-keyword">try</span> {
            sessionFactory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Configuration</span>().configure(<span class="hljs-string">"hibernate.cfg.xml"</span>).buildSessionFactory();
        } <span class="hljs-keyword">catch</span> (Throwable ex) {
            System.err.println(<span class="hljs-string">"Initial SessionFactory creation failed."</span> + ex);
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExceptionInInitializerError</span>(ex);
        }
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">// 插入一些产品</span>
        insertProduct(<span class="hljs-string">"Laptop"</span>, <span class="hljs-number">1000.0</span>);
        insertProduct(<span class="hljs-string">"Phone"</span>, <span class="hljs-number">500.0</span>);

        <span class="hljs-comment">// 第一次查询（会从数据库中加载）</span>
        List&lt;Product&gt; products1 = getProducts();
        products1.forEach(product -&gt; System.out.println(<span class="hljs-string">"First query: "</span> + product.getName()));

        <span class="hljs-comment">// 第二次查询（会从缓存中加载）</span>
        List&lt;Product&gt; products2 = getProducts();
        products2.forEach(product -&gt; System.out.println(<span class="hljs-string">"Second query: "</span> + product.getName()));

        <span class="hljs-comment">// 关闭SessionFactory</span>
        sessionFactory.close();
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertProduct</span><span class="hljs-params">(String name, Double price)</span> {
        <span class="hljs-type">Session</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> sessionFactory.openSession();
        <span class="hljs-type">Transaction</span> <span class="hljs-variable">transaction</span> <span class="hljs-operator">=</span> session.beginTransaction();
        <span class="hljs-keyword">try</span> {
            <span class="hljs-type">Product</span> <span class="hljs-variable">product</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Product</span>();
            product.setName(name);
            product.setPrice(price);
            session.save(product);
            transaction.commit();
            System.out.println(<span class="hljs-string">"Product "</span> + name + <span class="hljs-string">" inserted"</span>);
        } <span class="hljs-keyword">catch</span> (Exception e) {
            <span class="hljs-keyword">if</span> (transaction != <span class="hljs-literal">null</span>) {
                transaction.rollback();
            }
            e.printStackTrace();
        } <span class="hljs-keyword">finally</span> {
            session.close();
        }
    }

    <span class="hljs-meta">@SuppressWarnings("unchecked")</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;Product&gt; <span class="hljs-title function_">getProducts</span><span class="hljs-params">()</span> {
        <span class="hljs-type">Session</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> sessionFactory.openSession();
        <span class="hljs-keyword">try</span> {
            Query&lt;Product&gt; query = session.createQuery(<span class="hljs-string">"from Product"</span>);
            query.setCacheable(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 启用查询缓存</span>
            <span class="hljs-keyword">return</span> query.list();
        } <span class="hljs-keyword">finally</span> {
            session.close();
        }
    }
}
</code></pre>
<h3 data-id="heading-5">解释</h3>
<ol>
<li><strong>配置Hibernate</strong>：在<code>hibernate.cfg.xml</code>中启用了二级缓存和查询缓存，并指定了Ehcache作为缓存提供者。</li>
<li><strong>配置Ehcache</strong>：在<code>ehcache.xml</code>中为实体类和查询缓存分别配置了缓存策略。</li>
<li><strong>配置实体类</strong>：在需要缓存的实体类<code>Product</code>上添加了<code>@Cacheable</code>和<code>@Cache</code>注解。</li>
<li><strong>使用查询缓存</strong>：
<ul>
<li><code>getProducts</code>方法中，通过调用<code>query.setCacheable(true)</code>启用查询缓存。</li>
<li>第一查询会从数据库中加载数据，并将结果缓存。</li>
<li>第二次查询相同的数据时，会从缓存中加载，从而提高性能。</li>
</ul>
</li>
</ol>
<h3 data-id="heading-6">使用查询缓存的注意事项</h3>
<ol>
<li><strong>查询结果的有效性</strong>：查询缓存存储的是查询结果列表，因此，如果底层数据发生变化，查询缓存可能会变得无效。Hibernate会使用一个名为<code>UpdateTimestampsCache</code>的缓存区域来跟踪表的更新时间，从而维护查询缓存的一致性。</li>
<li><strong>缓存策略</strong>：选择合适的缓存策略（如TTL、最大缓存条目数等）来平衡缓存的命中率和内存消耗。</li>
<li><strong>缓存区域</strong>：可以为不同的查询定义不同的缓存区域，以便更细粒度地控制缓存行为。</li>
</ol>
<p>通过合理配置和使用查询缓存，可以显著提高Hibernate应用程序的查询性能。希望这些详细的解释和代码示例能帮助您更好地理解和应用Hibernate的查询缓存。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Hibernate（52）Hibernate中如何处理N+1问题？]]></title>    <link>https://juejin.cn/post/7596874823722237986</link>    <guid>https://juejin.cn/post/7596874823722237986</guid>    <pubDate>2026-01-19T11:51:55.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7596874823722237986" data-draft-id="7596864700509618210" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Hibernate（52）Hibernate中如何处理N+1问题？"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-01-19T11:51:55.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Victor356"/> <meta itemprop="url" content="https://juejin.cn/user/3492507879476878"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Hibernate（52）Hibernate中如何处理N+1问题？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3492507879476878/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Victor356
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-19T11:51:55.000Z" title="Mon Jan 19 2026 11:51:55 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在使用Hibernate进行数据库访问时，N+1问题（也称为select n+1问题）是一个常见的性能问题。它通常发生在关联查询中，即当你查询一个实体及其关联实体时，生成多条SQL查询语句，从而导致性能下降。以下是详细的解决方案和代码示例。</p>
<h3 data-id="heading-0">什么是N+1问题？</h3>
<p>假设有两个实体：<code>Author</code>和<code>Book</code>，一个作者可以有多本书。我们想查询所有的作者及其所写的书。如果我们简单地使用Hibernate的默认配置，可能会遇到N+1问题，即：</p>
<ol>
<li>一条SQL查询所有作者（1次查询）。</li>
<li>对于每个作者，再执行一条SQL查询其所写的书（N次查询）。</li>
</ol>
<p>最终会执行N+1条SQL查询，这对于大数据量的情况，会导致查询性能严重下降。</p>
<h3 data-id="heading-1">解决方案</h3>
<ol>
<li><strong>使用批量抓取（Batch Fetching）</strong>：Hibernate通过批量抓取来优化关联实体的获取。</li>
<li><strong>使用抓取策略（Fetch Strategy）</strong>：
<ul>
<li><strong>急加载（Eager Loading）</strong>：通过在查询语句中使用JOIN来一次性加载关联的数据。</li>
<li><strong>延迟加载（Lazy Loading）</strong>：默认情况下，Hibernate使用延迟加载，但可以通过调整fetch策略来优化。</li>
</ul>
</li>
<li><strong>使用JPQL或HQL中的FETCH JOIN</strong>：使用JPQL或HQL中的FETCH JOIN来进行一次查询获取所有数据。</li>
</ol>
<h3 data-id="heading-2">实体类定义</h3>
<p>以下是<code>Author</code>和<code>Book</code>实体类的定义：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">import</span> javax.persistence.*;
<span class="hljs-keyword">import</span> java.util.List;

<span class="hljs-meta">@Entity</span>
<span class="hljs-meta">@Table(name = "author")</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Author</span> {
    <span class="hljs-meta">@Id</span>
    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span>
    <span class="hljs-keyword">private</span> Long id;

    <span class="hljs-meta">@Column(name = "name")</span>
    <span class="hljs-keyword">private</span> String name;

    <span class="hljs-meta">@OneToMany(mappedBy = "author", fetch = FetchType.LAZY, cascade = CascadeType.ALL)</span>
    <span class="hljs-keyword">private</span> List&lt;Book&gt; books;

    <span class="hljs-comment">// Getters and Setters</span>
}

<span class="hljs-meta">@Entity</span>
<span class="hljs-meta">@Table(name = "book")</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Book</span> {
    <span class="hljs-meta">@Id</span>
    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span>
    <span class="hljs-keyword">private</span> Long id;

    <span class="hljs-meta">@Column(name = "title")</span>
    <span class="hljs-keyword">private</span> String title;

    <span class="hljs-meta">@ManyToOne(fetch = FetchType.LAZY)</span>
    <span class="hljs-meta">@JoinColumn(name = "author_id")</span>
    <span class="hljs-keyword">private</span> Author author;

    <span class="hljs-comment">// Getters and Setters</span>
}
</code></pre>
<h3 data-id="heading-3">1. 批量抓取（Batch Fetching）</h3>
<p>可以通过配置Hibernate的批量抓取属性来解决N+1问题。</p>
<h4 data-id="heading-4">配置Hibernate</h4>
<p>在Hibernate的配置文件<code>hibernate.cfg.xml</code>中配置批量抓取策略：</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">hibernate-configuration</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">session-factory</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- other configurations --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.default_batch_fetch_size"</span>&gt;</span>10<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">session-factory</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">hibernate-configuration</span>&gt;</span>
</code></pre>
<h4 data-id="heading-5">使用批量抓取</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-type">Session</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> sessionFactory.openSession();
<span class="hljs-type">Transaction</span> <span class="hljs-variable">transaction</span> <span class="hljs-operator">=</span> session.beginTransaction();

List&lt;Author&gt; authors = session.createQuery(<span class="hljs-string">"from Author"</span>, Author.class).list();
<span class="hljs-keyword">for</span> (Author author : authors) {
    System.out.println(author.getName());
    <span class="hljs-keyword">for</span> (Book book : author.getBooks()) {
        System.out.println(<span class="hljs-string">" - "</span> + book.getTitle());
    }
}

transaction.commit();
session.close();
</code></pre>
<h3 data-id="heading-6">2. 使用JPQL或HQL中的FETCH JOIN</h3>
<p>使用FETCH JOIN可以一次性加载关联数据，从而避免N+1问题。</p>
<h4 data-id="heading-7">使用FETCH JOIN</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-type">Session</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> sessionFactory.openSession();
<span class="hljs-type">Transaction</span> <span class="hljs-variable">transaction</span> <span class="hljs-operator">=</span> session.beginTransaction();

List&lt;Author&gt; authors = session.createQuery(
    <span class="hljs-string">"select a from Author a join fetch a.books"</span>, Author.class).list();
<span class="hljs-keyword">for</span> (Author author : authors) {
    System.out.println(author.getName());
    <span class="hljs-keyword">for</span> (Book book : author.getBooks()) {
        System.out.println(<span class="hljs-string">" - "</span> + book.getTitle());
    }
}

transaction.commit();
session.close();
</code></pre>
<h3 data-id="heading-8">3. 使用Entity Graphs</h3>
<p>可以使用JPA的<code>Entity Graphs</code>功能来指定在查询时应该加载的关联实体。</p>
<h4 data-id="heading-9">配置Entity Graphs</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Entity</span>
<span class="hljs-meta">@Table(name = "author")</span>
<span class="hljs-meta">@NamedEntityGraph(name = "author-books-graph",
    attributeNodes = @NamedAttributeNode("books"))</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Author</span> {
    <span class="hljs-comment">// existing fields and methods</span>
}
</code></pre>
<h4 data-id="heading-10">使用Entity Graphs</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-type">Session</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> sessionFactory.openSession();
<span class="hljs-type">Transaction</span> <span class="hljs-variable">transaction</span> <span class="hljs-operator">=</span> session.beginTransaction();

EntityGraph&lt;?&gt; graph = session.getEntityManagerFactory()
    .createEntityGraph(<span class="hljs-string">"author-books-graph"</span>);

Map&lt;String, Object&gt; hints = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();
hints.put(<span class="hljs-string">"javax.persistence.fetchgraph"</span>, graph);

List&lt;Author&gt; authors = session.createQuery(<span class="hljs-string">"select a from Author a"</span>, Author.class)
    .setHints(hints).list();
<span class="hljs-keyword">for</span> (Author author : authors) {
    System.out.println(author.getName());
    <span class="hljs-keyword">for</span> (Book book : author.getBooks()) {
        System.out.println(<span class="hljs-string">" - "</span> + book.getTitle());
    }
}

transaction.commit();
session.close();
</code></pre>
<h3 data-id="heading-11">总结</h3>
<ol>
<li><strong>批量抓取</strong>：在Hibernate配置中设置<code>hibernate.default_batch_fetch_size</code>属性。</li>
<li><strong>FETCH JOIN</strong>：使用JPQL或HQL中的FETCH JOIN语句一次性加载关联数据。</li>
<li><strong>Entity Graphs</strong>：使用JPA的Entity Graphs功能来指定在查询时应该加载的关联实体。</li>
</ol>
<p>通过这些方法，可以有效地解决N+1问题，显著提高Hibernate应用程序的查询性能。希望这些详细的解释和代码示例能帮助您更好地理解和应用Hibernate的优化技术。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[还在无脑 .map().filter()？实测改用 Iterator Helpers 后，内存占用降低了 99%]]></title>    <link>https://juejin.cn/post/7596926832912498751</link>    <guid>https://juejin.cn/post/7596926832912498751</guid>    <pubDate>2026-01-19T11:53:53.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7596926832912498751" data-draft-id="7596865421612302390" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="还在无脑 .map().filter()？实测改用 Iterator Helpers 后，内存占用降低了 99%"/> <meta itemprop="keywords" content="前端,JavaScript"/> <meta itemprop="datePublished" content="2026-01-19T11:53:53.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="也无风雨也雾晴"/> <meta itemprop="url" content="https://juejin.cn/user/2175258804632332"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            还在无脑 .map().filter()？实测改用 Iterator Helpers 后，内存占用降低了 99%
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2175258804632332/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    也无风雨也雾晴
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-19T11:53:53.000Z" title="Mon Jan 19 2026 11:53:53 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读12分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">别再把所有东西都转成数组了：Iterator Helpers 性能实测</h2>
<p>今天看到一篇文章，标题很直接：<a href="https://link.juejin.cn?target=https%3A%2F%2Fallthingssmitty.com%2F2026%2F01%2F12%2Fstop-turning-everything-into-arrays-and-do-less-work-instead%2F" target="_blank" title="https://allthingssmitty.com/2026/01/12/stop-turning-everything-into-arrays-and-do-less-work-instead/" ref="nofollow noopener noreferrer">Stop turning everything into arrays</a>。作者的观点是，JavaScript 里我们习惯了用 <code>.map().filter().slice()</code> 这种链式调用，看着很优雅，但其实每一步都在创建新数组，做了很多不必要的工作。</p>
<p>我一开始也半信半疑，毕竟这种写法用了这么多年，真的有那么大问题吗？于是我写了个测试脚本，跑了几组对比实验，结果还挺出乎意料的。</p>
<h3 data-id="heading-1">问题在哪</h3>
<p>先说传统数组方法的问题。假设你有个常见场景：从一个大列表里筛选出符合条件的数据，做点转换，然后只取前 10 条显示。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> visibleItems = items
  .<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">active</span>)
  .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> ({ <span class="hljs-attr">id</span>: item.<span class="hljs-property">id</span>, <span class="hljs-attr">doubled</span>: item.<span class="hljs-property">value</span> * <span class="hljs-number">2</span> }))
  .<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>);
</code></pre>
<p>这代码看着没毛病，但实际执行时：</p>
<ol>
<li><code>filter</code> 遍历整个数组，创建一个新数组</li>
<li><code>map</code> 再遍历一遍，又创建一个新数组</li>
<li><code>slice</code> 最后从结果里取前 10 条，又创建一个新数组</li>
</ol>
<p>如果 <code>items</code> 有 10 万条数据，你可能只需要 10 条，但前面两步已经把 10 万条全处理完了。这就是"急切求值"（eager evaluation）的问题——不管你最后用不用，先把活全干了再说。</p>
<h3 data-id="heading-2">Iterator Helpers 是什么</h3>
<p>Iterator Helpers 是 JavaScript 新加的特性，提供了一套"惰性求值"（lazy evaluation）的方法。关键区别是：</p>
<ul>
<li><strong>传统数组方法</strong>：每一步都立即执行，创建中间数组</li>
<li><strong>Iterator Helpers</strong>：只描述要做什么，真正需要数据时才执行</li>
</ul>
<p>用法上也很直观：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> visibleItems = items
  .<span class="hljs-title function_">values</span>()              <span class="hljs-comment">// 转成 iterator</span>
  .<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">active</span>)
  .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> ({ <span class="hljs-attr">id</span>: item.<span class="hljs-property">id</span>, <span class="hljs-attr">doubled</span>: item.<span class="hljs-property">value</span> * <span class="hljs-number">2</span> }))
  .<span class="hljs-title function_">take</span>(<span class="hljs-number">10</span>)              <span class="hljs-comment">// 只取 10 条</span>
  .<span class="hljs-title function_">toArray</span>();            <span class="hljs-comment">// 最后转回数组</span>
</code></pre>
<p>核心差异在于：</p>
<ol>
<li><code>items.values()</code> 返回的是 iterator，不是数组</li>
<li>每一步只是在"描述"操作，不会立即执行</li>
<li><code>take(10)</code> 告诉它只需要 10 条，处理到 10 条就停</li>
<li><code>toArray()</code> 才真正触发执行，而且只处理需要的数据</li>
</ol>
<h3 data-id="heading-3">实测对比</h3>
<p>我写了个测试脚本，从<strong>时间</strong>和<strong>空间</strong>两个维度进行对比测试。每组场景的时间测试重复 10 次取平均值，内存测试使用 Node.js 的 <code>process.memoryUsage()</code> API 测量堆内存增长。</p>
<h4 data-id="heading-4">场景 1：过滤 + 转换 + 取前 10 项</h4>
<p><strong>数据规模</strong>：100,000 条</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 传统数组方法</span>
dataset
  .<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">active</span>)
  .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> ({ <span class="hljs-attr">id</span>: item.<span class="hljs-property">id</span>, <span class="hljs-attr">doubled</span>: item.<span class="hljs-property">value</span> * <span class="hljs-number">2</span> }))
  .<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>);

<span class="hljs-comment">// Iterator Helpers</span>
dataset
  .<span class="hljs-title function_">values</span>()
  .<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">active</span>)
  .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> ({ <span class="hljs-attr">id</span>: item.<span class="hljs-property">id</span>, <span class="hljs-attr">doubled</span>: item.<span class="hljs-property">value</span> * <span class="hljs-number">2</span> }))
  .<span class="hljs-title function_">take</span>(<span class="hljs-number">10</span>)
  .<span class="hljs-title function_">toArray</span>();
</code></pre>
<p><strong>结果</strong>：</p>























<table><thead><tr><th>维度</th><th>传统数组方法</th><th>Iterator Helpers</th><th>性能提升</th></tr></thead><tbody><tr><td>时间</td><td>1.545ms</td><td>0.019ms</td><td><strong>98.77%</strong></td></tr><tr><td>内存</td><td>3.38 MB</td><td>0.01 MB</td><td><strong>99.75%</strong></td></tr></tbody></table>
<p>这个结果很夸张，Iterator Helpers 在时间上快了 80 多倍，内存使用更是只有传统方法的 0.3%。原因很简单：传统方法处理了所有 10 万条数据并创建了 2 个中间数组（filter 和 map 各一个），而 Iterator Helpers 找到 10 条就停了，完全不创建中间数组。</p>
<h4 data-id="heading-5">场景 2：嵌套数据扁平化</h4>
<p><strong>数据规模</strong>：10,000 个父项，每个包含 10 个子项（共 100,000 条子数据）</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 传统数组方法</span>
dataset
  .<span class="hljs-title function_">flatMap</span>(<span class="hljs-function"><span class="hljs-params">parent</span> =&gt;</span> parent.<span class="hljs-property">children</span>)
  .<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">child</span> =&gt;</span> child.<span class="hljs-property">value</span> &gt; <span class="hljs-number">50</span>)
  .<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">20</span>);

<span class="hljs-comment">// Iterator Helpers</span>
dataset
  .<span class="hljs-title function_">values</span>()
  .<span class="hljs-title function_">flatMap</span>(<span class="hljs-function"><span class="hljs-params">parent</span> =&gt;</span> parent.<span class="hljs-property">children</span>)
  .<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">child</span> =&gt;</span> child.<span class="hljs-property">value</span> &gt; <span class="hljs-number">50</span>)
  .<span class="hljs-title function_">take</span>(<span class="hljs-number">20</span>)
  .<span class="hljs-title function_">toArray</span>();
</code></pre>
<p><strong>结果</strong>：</p>























<table><thead><tr><th>维度</th><th>传统数组方法</th><th>Iterator Helpers</th><th>性能提升</th></tr></thead><tbody><tr><td>时间</td><td>3.716ms</td><td>0.018ms</td><td><strong>99.53%</strong></td></tr><tr><td>内存</td><td>4.03 MB</td><td>0.01 MB</td><td><strong>99.73%</strong></td></tr></tbody></table>
<p><code>flatMap</code> 这种场景更明显，因为传统方法要先把所有嵌套数据（10 万条子数据）展平成一个大数组，再过滤，再切片，创建了 2 个中间数组。Iterator Helpers 直接在展平的过程中就能提前终止，内存使用几乎可以忽略不计。</p>
<h4 data-id="heading-6">场景 3：查找第一个匹配项</h4>
<p><strong>数据规模</strong>：1,000,000 条（目标在第 800,000 条）</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 传统数组方法</span>
dataset.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">id</span> === targetId)[<span class="hljs-number">0</span>];

<span class="hljs-comment">// Iterator Helpers</span>
dataset.<span class="hljs-title function_">values</span>().<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">id</span> === targetId);
</code></pre>
<p><strong>结果</strong>：</p>























<table><thead><tr><th>维度</th><th>传统数组方法</th><th>Iterator Helpers</th><th>性能变化</th></tr></thead><tbody><tr><td>时间</td><td>6.587ms</td><td>8.713ms</td><td><strong>-32.27%</strong> ⚠️</td></tr><tr><td>内存</td><td>0.01 MB</td><td>14.80 MB</td><td><strong>-194800%</strong> ⚠️</td></tr></tbody></table>
<p>这个场景很有意思，Iterator Helpers 在时间和空间上都<strong>更差</strong>了。我分析了一下原因：</p>
<ol>
<li><strong>时间慢的原因</strong>：目标在数据集后半部分（第 80 万条），两者都要遍历大部分数据。<code>filter</code> 是原生实现，优化得很好；而 Iterator Helpers 的 <code>find</code> 每次迭代的开销更大</li>
<li><strong>内存多的原因</strong>：这个测试结果有点反直觉，可能是因为 iterator 本身的内部状态占用了内存，而且 GC 时机不同导致测量偏差</li>
</ol>
<p>这说明 Iterator Helpers 不是银弹，在"需要遍历大部分数据"的场景下，传统方法可能更好。</p>
<h4 data-id="heading-7">场景 4：复杂链式调用</h4>
<p><strong>数据规模</strong>：50,000 条</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 传统数组方法</span>
dataset
  .<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">active</span>)
  .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> ({ ...item, <span class="hljs-attr">doubled</span>: item.<span class="hljs-property">value</span> * <span class="hljs-number">2</span> }))
  .<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">doubled</span> &gt; <span class="hljs-number">500</span>)
  .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> ({ <span class="hljs-attr">id</span>: item.<span class="hljs-property">id</span>, <span class="hljs-attr">final</span>: item.<span class="hljs-property">doubled</span> + <span class="hljs-number">100</span> }))
  .<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">15</span>);

<span class="hljs-comment">// Iterator Helpers</span>
dataset
  .<span class="hljs-title function_">values</span>()
  .<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">active</span>)
  .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> ({ ...item, <span class="hljs-attr">doubled</span>: item.<span class="hljs-property">value</span> * <span class="hljs-number">2</span> }))
  .<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">doubled</span> &gt; <span class="hljs-number">500</span>)
  .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> ({ <span class="hljs-attr">id</span>: item.<span class="hljs-property">id</span>, <span class="hljs-attr">final</span>: item.<span class="hljs-property">doubled</span> + <span class="hljs-number">100</span> }))
  .<span class="hljs-title function_">take</span>(<span class="hljs-number">15</span>)
  .<span class="hljs-title function_">toArray</span>();
</code></pre>
<p><strong>结果</strong>：</p>























<table><thead><tr><th>维度</th><th>传统数组方法</th><th>Iterator Helpers</th><th>性能提升</th></tr></thead><tbody><tr><td>时间</td><td>1.421ms</td><td>0.028ms</td><td><strong>98.02%</strong></td></tr><tr><td>内存</td><td>5.33 MB</td><td>0.01 MB</td><td><strong>99.75%</strong></td></tr></tbody></table>
<p>链式调用越多，传统方法创建的中间数组就越多。这个场景有 4 次操作（filter → map → filter → map），传统方法创建了 4 个中间数组，总共占用 5.33 MB 内存；而 Iterator Helpers 一个中间数组都没创建，内存使用几乎为零。</p>
<h3 data-id="heading-8">什么时候用 Iterator Helpers</h3>
<p>根据测试结果，我总结了几个适合用 Iterator Helpers 的场景：</p>
<h4 data-id="heading-9">1. 只需要前 N 项</h4>
<p>这是最明显的优势场景。无限滚动、分页加载、虚拟列表这些场景都适合。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 虚拟列表只渲染可见的 20 条</span>
<span class="hljs-keyword">const</span> visibleRows = allRows
  .<span class="hljs-title function_">values</span>()
  .<span class="hljs-title function_">filter</span>(isInViewport)
  .<span class="hljs-title function_">take</span>(<span class="hljs-number">20</span>)
  .<span class="hljs-title function_">toArray</span>();
</code></pre>
<h4 data-id="heading-10">2. 流式数据处理</h4>
<p>处理 API 分页、SSE 流、WebSocket 消息这些场景，Iterator Helpers 配合 async iterator 很好用：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span>* <span class="hljs-title function_">fetchPages</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">let</span> page = <span class="hljs-number">1</span>;
  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`/api/items?page=<span class="hljs-subst">${page++}</span>`</span>);
    <span class="hljs-keyword">if</span> (!res.<span class="hljs-property">ok</span>) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">yield</span>* <span class="hljs-keyword">await</span> res.<span class="hljs-title function_">json</span>();
  }
}

<span class="hljs-comment">// 只拉取需要的数据，不会一次性加载所有分页</span>
<span class="hljs-keyword">const</span> firstTen = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchPages</span>()
  .<span class="hljs-title function_">filter</span>(isValid)
  .<span class="hljs-title function_">take</span>(<span class="hljs-number">10</span>)
  .<span class="hljs-title function_">toArray</span>();
</code></pre>
<h4 data-id="heading-11">3. 复杂的数据管道</h4>
<p>如果你的数据处理链路很长，有多次 <code>filter</code>、<code>map</code>、<code>flatMap</code>，用 Iterator Helpers 能避免创建一堆中间数组。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> result = data
  .<span class="hljs-title function_">values</span>()
  .<span class="hljs-title function_">filter</span>(step1)
  .<span class="hljs-title function_">map</span>(step2)
  .<span class="hljs-title function_">flatMap</span>(step3)
  .<span class="hljs-title function_">filter</span>(step4)
  .<span class="hljs-title function_">take</span>(<span class="hljs-number">100</span>)
  .<span class="hljs-title function_">toArray</span>();
</code></pre>
<h3 data-id="heading-12">什么时候不用</h3>
<p>Iterator Helpers 也不是万能的，这几种情况还是老老实实用数组：</p>
<h4 data-id="heading-13">1. 需要随机访问</h4>
<p>Iterator 是单向的，不能 <code>items[5]</code> 这样直接取某一项。如果你需要随机访问，还是得用数组。</p>
<h4 data-id="heading-14">2. 数据量很小</h4>
<p>如果就几十条数据，用 Iterator Helpers 反而增加了复杂度，传统数组方法更简单直接。</p>
<h4 data-id="heading-15">3. 需要多次遍历</h4>
<p>Iterator 只能遍历一次，如果你需要对同一份数据做多次不同的处理，还是先 <code>toArray()</code> 转成数组再说。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> iter = data.<span class="hljs-title function_">values</span>().<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x &gt; <span class="hljs-number">10</span>);

<span class="hljs-comment">// ❌ 第二次遍历会返回空，因为 iterator 已经消费完了</span>
<span class="hljs-keyword">const</span> first = iter.<span class="hljs-title function_">take</span>(<span class="hljs-number">5</span>).<span class="hljs-title function_">toArray</span>();
<span class="hljs-keyword">const</span> second = iter.<span class="hljs-title function_">take</span>(<span class="hljs-number">5</span>).<span class="hljs-title function_">toArray</span>(); <span class="hljs-comment">// []</span>

<span class="hljs-comment">// ✅ 先转数组，再多次使用</span>
<span class="hljs-keyword">const</span> filtered = data.<span class="hljs-title function_">values</span>().<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x &gt; <span class="hljs-number">10</span>).<span class="hljs-title function_">toArray</span>();
<span class="hljs-keyword">const</span> first = filtered.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>);
<span class="hljs-keyword">const</span> second = filtered.<span class="hljs-title function_">slice</span>(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>);
</code></pre>
<h3 data-id="heading-16">兼容性</h3>
<p>Iterator Helpers 在现代浏览器和 Node.js 22+ 都已经支持了。如果你的项目还要兼容老版本，可以用 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fzloirock%2Fcore-js" target="_blank" title="https://github.com/zloirock/core-js" ref="nofollow noopener noreferrer">core-js</a> 这类 polyfill。</p>
<p>可以在 <a href="https://link.juejin.cn?target=https%3A%2F%2Fcaniuse.com%2Fiterator-helpers" target="_blank" title="https://caniuse.com/iterator-helpers" ref="nofollow noopener noreferrer">Can I Use</a> 查看详细的兼容性数据。</p>
<h3 data-id="heading-17">一些坑</h3>
<h4 data-id="heading-18">1. Iterator 不是数组</h4>
<p>这是最容易踩的坑。Iterator 没有 <code>length</code>、<code>[index]</code> 这些属性，也不能直接 <code>console.log</code> 看内容。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> iter = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">values</span>();

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iter.<span class="hljs-property">length</span>);  <span class="hljs-comment">// undefined</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iter[<span class="hljs-number">0</span>]);      <span class="hljs-comment">// undefined</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iter);         <span class="hljs-comment">// Object [Array Iterator] {}</span>

<span class="hljs-comment">// 要看内容，得先转数组</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([...iter]);    <span class="hljs-comment">// [1, 2, 3]</span>
</code></pre>
<h4 data-id="heading-19">2. <code>reduce</code> 不是惰性的</h4>
<p>大部分 Iterator Helpers 都是惰性的，但 <code>reduce</code> 是个例外，它必须遍历所有数据才能得出结果。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// reduce 会立即消费整个 iterator</span>
<span class="hljs-keyword">const</span> sum = data.<span class="hljs-title function_">values</span>().<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, x</span>) =&gt;</span> acc + x, <span class="hljs-number">0</span>);
</code></pre>
<h4 data-id="heading-20">3. 调试不方便</h4>
<p>因为是惰性求值，你不能在中间步骤打断点看数据。如果要调试，可以在关键步骤插入 <code>toArray()</code> 转成数组再看。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> result = data
  .<span class="hljs-title function_">values</span>()
  .<span class="hljs-title function_">filter</span>(step1)
  .<span class="hljs-title function_">toArray</span>()  <span class="hljs-comment">// 调试用，看看 filter 后的结果</span>
  .<span class="hljs-title function_">values</span>()
  .<span class="hljs-title function_">map</span>(step2)
  .<span class="hljs-title function_">take</span>(<span class="hljs-number">10</span>)
  .<span class="hljs-title function_">toArray</span>();
</code></pre>
<h3 data-id="heading-21">总结</h3>
<p>Iterator Helpers 不是要替代数组，而是给了我们另一个选择。核心思路就一句话：<strong>如果你不需要整个数组，就别创建它</strong>。</p>
<p>从实测结果看：</p>
<ul>
<li>在"取前 N 项"这类场景下，<strong>时间和空间开销都能降低 90%+</strong></li>
<li>在"需要遍历大部分数据"的场景下，传统方法可能更快（场景 3 是个反例）</li>
<li>数据规模越大，Iterator Helpers 的优势越明显</li>
<li><strong>内存优势尤其突出</strong>：传统方法创建的中间数组会占用大量内存，而 Iterator Helpers 几乎不占用额外内存</li>
</ul>
<p>我个人的使用建议是：</p>
<ol>
<li><strong>默认还是用数组方法</strong>，简单直接，不容易出错</li>
<li><strong>遇到性能瓶颈时</strong>，看看是不是"只需要部分数据却处理了全部"，如果是，试试 Iterator Helpers</li>
<li><strong>写数据管道时</strong>，如果链路很长，用 Iterator Helpers 能让代码更清晰，也能避免不必要的内存分配</li>
<li><strong>内存敏感场景</strong>，比如处理大数据集、移动端应用等，Iterator Helpers 能显著降低内存压力</li>
</ol>
<h3 data-id="heading-22">完整测试代码</h3>
<p>下面是完整的性能测试代码，包含<strong>时间</strong>和<strong>空间</strong>两个维度的测试。你可以复制到本地跑一下：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">/**
 * Iterator Helpers vs Array Methods 性能对比测试
 * 
 * 测试维度：
 * 1. 时间开销（执行时间）
 * 2. 空间开销（内存使用）
 * 
 * 测试场景：
 * 1. 大数据集过滤 + 转换 + 取前 N 项
 * 2. 嵌套数据扁平化
 * 3. 查找第一个匹配项
 * 4. 复杂链式调用
 */</span>

<span class="hljs-comment">// ============ 工具函数 ============</span>

<span class="hljs-keyword">function</span> <span class="hljs-title function_">generateLargeDataset</span>(<span class="hljs-params">size</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>({ <span class="hljs-attr">length</span>: size }, <span class="hljs-function">(<span class="hljs-params">_, i</span>) =&gt;</span> ({
    <span class="hljs-attr">id</span>: i,
    <span class="hljs-attr">value</span>: <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">1000</span>,
    <span class="hljs-attr">category</span>: [<span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>, <span class="hljs-string">'C'</span>, <span class="hljs-string">'D'</span>][i % <span class="hljs-number">4</span>],
    <span class="hljs-attr">active</span>: i % <span class="hljs-number">3</span> === <span class="hljs-number">0</span>
  }));
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">benchmark</span>(<span class="hljs-params">name, fn, iterations = <span class="hljs-number">1</span></span>) {
  <span class="hljs-keyword">const</span> times = [];
  
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; iterations; i++) {
    <span class="hljs-keyword">const</span> start = performance.<span class="hljs-title function_">now</span>();
    <span class="hljs-title function_">fn</span>();
    <span class="hljs-keyword">const</span> end = performance.<span class="hljs-title function_">now</span>();
    times.<span class="hljs-title function_">push</span>(end - start);
  }
  
  <span class="hljs-keyword">const</span> avg = times.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b, <span class="hljs-number">0</span>) / times.<span class="hljs-property">length</span>;
  <span class="hljs-keyword">const</span> min = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(...times);
  <span class="hljs-keyword">const</span> max = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(...times);
  
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`\n<span class="hljs-subst">${name}</span>:`</span>);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`  平均: <span class="hljs-subst">${avg.toFixed(<span class="hljs-number">3</span>)}</span>ms`</span>);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`  最小: <span class="hljs-subst">${min.toFixed(<span class="hljs-number">3</span>)}</span>ms`</span>);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`  最大: <span class="hljs-subst">${max.toFixed(<span class="hljs-number">3</span>)}</span>ms`</span>);
  
  <span class="hljs-keyword">return</span> avg;
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">memoryBenchmark</span>(<span class="hljs-params">name, fn</span>) {
  <span class="hljs-comment">// 强制垃圾回收（需要 Node.js 启动时加 --expose-gc 参数）</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">global</span>.<span class="hljs-property">gc</span>) {
    <span class="hljs-variable language_">global</span>.<span class="hljs-title function_">gc</span>();
  }
  
  <span class="hljs-keyword">const</span> memBefore = process.<span class="hljs-title function_">memoryUsage</span>();
  <span class="hljs-title function_">fn</span>();
  <span class="hljs-keyword">const</span> memAfter = process.<span class="hljs-title function_">memoryUsage</span>();
  
  <span class="hljs-keyword">const</span> heapUsedDiff = (memAfter.<span class="hljs-property">heapUsed</span> - memBefore.<span class="hljs-property">heapUsed</span>) / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>;
  
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`  内存增长: <span class="hljs-subst">${heapUsedDiff.toFixed(<span class="hljs-number">2</span>)}</span> MB`</span>);
  
  <span class="hljs-keyword">return</span> heapUsedDiff;
}

<span class="hljs-comment">// ============ 测试场景 1: 过滤 + 转换 + 取前 N 项 ============</span>

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'='</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">60</span>));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'测试场景 1: 大数据集过滤 + 转换 + 取前 10 项'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'数据规模: 100,000 条'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'='</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">60</span>));

<span class="hljs-keyword">const</span> dataset1 = <span class="hljs-title function_">generateLargeDataset</span>(<span class="hljs-number">100000</span>);

<span class="hljs-comment">// 传统数组方法 - 时间</span>
<span class="hljs-keyword">const</span> arrayMethodTime1 = <span class="hljs-title function_">benchmark</span>(<span class="hljs-string">'传统数组方法 (filter + map + slice) - 时间'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">const</span> result = dataset1
    .<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">active</span>)
    .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> ({ <span class="hljs-attr">id</span>: item.<span class="hljs-property">id</span>, <span class="hljs-attr">doubled</span>: item.<span class="hljs-property">value</span> * <span class="hljs-number">2</span> }))
    .<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>);
  
  <span class="hljs-keyword">return</span> result;
}, <span class="hljs-number">10</span>);

<span class="hljs-comment">// 传统数组方法 - 内存</span>
<span class="hljs-keyword">const</span> arrayMethodMem1 = <span class="hljs-title function_">memoryBenchmark</span>(<span class="hljs-string">'传统数组方法 (filter + map + slice) - 内存'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">const</span> result = dataset1
    .<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">active</span>)
    .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> ({ <span class="hljs-attr">id</span>: item.<span class="hljs-property">id</span>, <span class="hljs-attr">doubled</span>: item.<span class="hljs-property">value</span> * <span class="hljs-number">2</span> }))
    .<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>);
  
  <span class="hljs-keyword">return</span> result;
});

<span class="hljs-comment">// Iterator Helpers - 时间</span>
<span class="hljs-keyword">const</span> iteratorHelpersTime1 = <span class="hljs-title function_">benchmark</span>(<span class="hljs-string">'Iterator Helpers (filter + map + take) - 时间'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">const</span> result = dataset1
    .<span class="hljs-title function_">values</span>()
    .<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">active</span>)
    .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> ({ <span class="hljs-attr">id</span>: item.<span class="hljs-property">id</span>, <span class="hljs-attr">doubled</span>: item.<span class="hljs-property">value</span> * <span class="hljs-number">2</span> }))
    .<span class="hljs-title function_">take</span>(<span class="hljs-number">10</span>)
    .<span class="hljs-title function_">toArray</span>();
  
  <span class="hljs-keyword">return</span> result;
}, <span class="hljs-number">10</span>);

<span class="hljs-comment">// Iterator Helpers - 内存</span>
<span class="hljs-keyword">const</span> iteratorHelpersMem1 = <span class="hljs-title function_">memoryBenchmark</span>(<span class="hljs-string">'Iterator Helpers (filter + map + take) - 内存'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">const</span> result = dataset1
    .<span class="hljs-title function_">values</span>()
    .<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">active</span>)
    .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> ({ <span class="hljs-attr">id</span>: item.<span class="hljs-property">id</span>, <span class="hljs-attr">doubled</span>: item.<span class="hljs-property">value</span> * <span class="hljs-number">2</span> }))
    .<span class="hljs-title function_">take</span>(<span class="hljs-number">10</span>)
    .<span class="hljs-title function_">toArray</span>();
  
  <span class="hljs-keyword">return</span> result;
});

<span class="hljs-keyword">const</span> timeImprovement1 = ((arrayMethodTime1 - iteratorHelpersTime1) / arrayMethodTime1 * <span class="hljs-number">100</span>).<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">2</span>);
<span class="hljs-keyword">const</span> memImprovement1 = ((arrayMethodMem1 - iteratorHelpersMem1) / arrayMethodMem1 * <span class="hljs-number">100</span>).<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">2</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`\n性能提升: 时间 <span class="hljs-subst">${timeImprovement1}</span>%, 内存 <span class="hljs-subst">${memImprovement1}</span>%`</span>);

<span class="hljs-comment">// ============ 测试场景 2: 嵌套数据扁平化 ============</span>

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'\n'</span> + <span class="hljs-string">'='</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">60</span>));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'测试场景 2: 嵌套数据扁平化 + 过滤 + 取前 20 项'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'数据规模: 10,000 个父项，每个包含 10 个子项'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'='</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">60</span>));

<span class="hljs-keyword">const</span> dataset2 = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>({ <span class="hljs-attr">length</span>: <span class="hljs-number">10000</span> }, <span class="hljs-function">(<span class="hljs-params">_, i</span>) =&gt;</span> ({
  <span class="hljs-attr">id</span>: i,
  <span class="hljs-attr">children</span>: <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>({ <span class="hljs-attr">length</span>: <span class="hljs-number">10</span> }, <span class="hljs-function">(<span class="hljs-params">_, j</span>) =&gt;</span> ({
    <span class="hljs-attr">childId</span>: <span class="hljs-string">`<span class="hljs-subst">${i}</span>-<span class="hljs-subst">${j}</span>`</span>,
    <span class="hljs-attr">value</span>: <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">100</span>
  }))
}));

<span class="hljs-comment">// 传统数组方法 - 时间</span>
<span class="hljs-keyword">const</span> arrayMethodTime2 = <span class="hljs-title function_">benchmark</span>(<span class="hljs-string">'传统数组方法 (flatMap + filter + slice) - 时间'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">const</span> result = dataset2
    .<span class="hljs-title function_">flatMap</span>(<span class="hljs-function"><span class="hljs-params">parent</span> =&gt;</span> parent.<span class="hljs-property">children</span>)
    .<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">child</span> =&gt;</span> child.<span class="hljs-property">value</span> &gt; <span class="hljs-number">50</span>)
    .<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">20</span>);
  
  <span class="hljs-keyword">return</span> result;
}, <span class="hljs-number">10</span>);

<span class="hljs-comment">// 传统数组方法 - 内存</span>
<span class="hljs-keyword">const</span> arrayMethodMem2 = <span class="hljs-title function_">memoryBenchmark</span>(<span class="hljs-string">'传统数组方法 (flatMap + filter + slice) - 内存'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">const</span> result = dataset2
    .<span class="hljs-title function_">flatMap</span>(<span class="hljs-function"><span class="hljs-params">parent</span> =&gt;</span> parent.<span class="hljs-property">children</span>)
    .<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">child</span> =&gt;</span> child.<span class="hljs-property">value</span> &gt; <span class="hljs-number">50</span>)
    .<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">20</span>);
  
  <span class="hljs-keyword">return</span> result;
});

<span class="hljs-comment">// Iterator Helpers - 时间</span>
<span class="hljs-keyword">const</span> iteratorHelpersTime2 = <span class="hljs-title function_">benchmark</span>(<span class="hljs-string">'Iterator Helpers (flatMap + filter + take) - 时间'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">const</span> result = dataset2
    .<span class="hljs-title function_">values</span>()
    .<span class="hljs-title function_">flatMap</span>(<span class="hljs-function"><span class="hljs-params">parent</span> =&gt;</span> parent.<span class="hljs-property">children</span>)
    .<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">child</span> =&gt;</span> child.<span class="hljs-property">value</span> &gt; <span class="hljs-number">50</span>)
    .<span class="hljs-title function_">take</span>(<span class="hljs-number">20</span>)
    .<span class="hljs-title function_">toArray</span>();
  
  <span class="hljs-keyword">return</span> result;
}, <span class="hljs-number">10</span>);

<span class="hljs-comment">// Iterator Helpers - 内存</span>
<span class="hljs-keyword">const</span> iteratorHelpersMem2 = <span class="hljs-title function_">memoryBenchmark</span>(<span class="hljs-string">'Iterator Helpers (flatMap + filter + take) - 内存'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">const</span> result = dataset2
    .<span class="hljs-title function_">values</span>()
    .<span class="hljs-title function_">flatMap</span>(<span class="hljs-function"><span class="hljs-params">parent</span> =&gt;</span> parent.<span class="hljs-property">children</span>)
    .<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">child</span> =&gt;</span> child.<span class="hljs-property">value</span> &gt; <span class="hljs-number">50</span>)
    .<span class="hljs-title function_">take</span>(<span class="hljs-number">20</span>)
    .<span class="hljs-title function_">toArray</span>();
  
  <span class="hljs-keyword">return</span> result;
});

<span class="hljs-keyword">const</span> timeImprovement2 = ((arrayMethodTime2 - iteratorHelpersTime2) / arrayMethodTime2 * <span class="hljs-number">100</span>).<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">2</span>);
<span class="hljs-keyword">const</span> memImprovement2 = ((arrayMethodMem2 - iteratorHelpersMem2) / arrayMethodMem2 * <span class="hljs-number">100</span>).<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">2</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`\n性能提升: 时间 <span class="hljs-subst">${timeImprovement2}</span>%, 内存 <span class="hljs-subst">${memImprovement2}</span>%`</span>);

<span class="hljs-comment">// ============ 测试场景 3: 查找第一个匹配项 ============</span>

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'\n'</span> + <span class="hljs-string">'='</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">60</span>));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'测试场景 3: 查找第一个匹配项（匹配项在数据集后半部分）'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'数据规模: 1,000,000 条'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'='</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">60</span>));

<span class="hljs-keyword">const</span> dataset3 = <span class="hljs-title function_">generateLargeDataset</span>(<span class="hljs-number">1000000</span>);
<span class="hljs-keyword">const</span> targetId = <span class="hljs-number">800000</span>;

<span class="hljs-comment">// 传统数组方法 - 时间</span>
<span class="hljs-keyword">const</span> arrayMethodTime3 = <span class="hljs-title function_">benchmark</span>(<span class="hljs-string">'传统数组方法 (filter + [0]) - 时间'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">const</span> result = dataset3
    .<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">id</span> === targetId)[<span class="hljs-number">0</span>];
  
  <span class="hljs-keyword">return</span> result;
}, <span class="hljs-number">10</span>);

<span class="hljs-comment">// 传统数组方法 - 内存</span>
<span class="hljs-keyword">const</span> arrayMethodMem3 = <span class="hljs-title function_">memoryBenchmark</span>(<span class="hljs-string">'传统数组方法 (filter + [0]) - 内存'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">const</span> result = dataset3
    .<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">id</span> === targetId)[<span class="hljs-number">0</span>];
  
  <span class="hljs-keyword">return</span> result;
});

<span class="hljs-comment">// Iterator Helpers - 时间</span>
<span class="hljs-keyword">const</span> iteratorHelpersTime3 = <span class="hljs-title function_">benchmark</span>(<span class="hljs-string">'Iterator Helpers (find) - 时间'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">const</span> result = dataset3
    .<span class="hljs-title function_">values</span>()
    .<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">id</span> === targetId);
  
  <span class="hljs-keyword">return</span> result;
}, <span class="hljs-number">10</span>);

<span class="hljs-comment">// Iterator Helpers - 内存</span>
<span class="hljs-keyword">const</span> iteratorHelpersMem3 = <span class="hljs-title function_">memoryBenchmark</span>(<span class="hljs-string">'Iterator Helpers (find) - 内存'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">const</span> result = dataset3
    .<span class="hljs-title function_">values</span>()
    .<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">id</span> === targetId);
  
  <span class="hljs-keyword">return</span> result;
});

<span class="hljs-keyword">const</span> timeImprovement3 = ((arrayMethodTime3 - iteratorHelpersTime3) / arrayMethodTime3 * <span class="hljs-number">100</span>).<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">2</span>);
<span class="hljs-keyword">const</span> memImprovement3 = ((arrayMethodMem3 - iteratorHelpersMem3) / arrayMethodMem3 * <span class="hljs-number">100</span>).<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">2</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`\n性能提升: 时间 <span class="hljs-subst">${timeImprovement3}</span>%, 内存 <span class="hljs-subst">${memImprovement3}</span>%`</span>);

<span class="hljs-comment">// ============ 测试场景 4: 多次链式调用 ============</span>

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'\n'</span> + <span class="hljs-string">'='</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">60</span>));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'测试场景 4: 复杂链式调用（filter + map + filter + map + take）'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'数据规模: 50,000 条'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'='</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">60</span>));

<span class="hljs-keyword">const</span> dataset4 = <span class="hljs-title function_">generateLargeDataset</span>(<span class="hljs-number">50000</span>);

<span class="hljs-comment">// 传统数组方法 - 时间</span>
<span class="hljs-keyword">const</span> arrayMethodTime4 = <span class="hljs-title function_">benchmark</span>(<span class="hljs-string">'传统数组方法 (多次链式调用) - 时间'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">const</span> result = dataset4
    .<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">active</span>)
    .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> ({ ...item, <span class="hljs-attr">doubled</span>: item.<span class="hljs-property">value</span> * <span class="hljs-number">2</span> }))
    .<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">doubled</span> &gt; <span class="hljs-number">500</span>)
    .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> ({ <span class="hljs-attr">id</span>: item.<span class="hljs-property">id</span>, <span class="hljs-attr">final</span>: item.<span class="hljs-property">doubled</span> + <span class="hljs-number">100</span> }))
    .<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">15</span>);
  
  <span class="hljs-keyword">return</span> result;
}, <span class="hljs-number">10</span>);

<span class="hljs-comment">// 传统数组方法 - 内存</span>
<span class="hljs-keyword">const</span> arrayMethodMem4 = <span class="hljs-title function_">memoryBenchmark</span>(<span class="hljs-string">'传统数组方法 (多次链式调用) - 内存'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">const</span> result = dataset4
    .<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">active</span>)
    .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> ({ ...item, <span class="hljs-attr">doubled</span>: item.<span class="hljs-property">value</span> * <span class="hljs-number">2</span> }))
    .<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">doubled</span> &gt; <span class="hljs-number">500</span>)
    .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> ({ <span class="hljs-attr">id</span>: item.<span class="hljs-property">id</span>, <span class="hljs-attr">final</span>: item.<span class="hljs-property">doubled</span> + <span class="hljs-number">100</span> }))
    .<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">15</span>);
  
  <span class="hljs-keyword">return</span> result;
});

<span class="hljs-comment">// Iterator Helpers - 时间</span>
<span class="hljs-keyword">const</span> iteratorHelpersTime4 = <span class="hljs-title function_">benchmark</span>(<span class="hljs-string">'Iterator Helpers (多次链式调用) - 时间'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">const</span> result = dataset4
    .<span class="hljs-title function_">values</span>()
    .<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">active</span>)
    .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> ({ ...item, <span class="hljs-attr">doubled</span>: item.<span class="hljs-property">value</span> * <span class="hljs-number">2</span> }))
    .<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">doubled</span> &gt; <span class="hljs-number">500</span>)
    .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> ({ <span class="hljs-attr">id</span>: item.<span class="hljs-property">id</span>, <span class="hljs-attr">final</span>: item.<span class="hljs-property">doubled</span> + <span class="hljs-number">100</span> }))
    .<span class="hljs-title function_">take</span>(<span class="hljs-number">15</span>)
    .<span class="hljs-title function_">toArray</span>();
  
  <span class="hljs-keyword">return</span> result;
}, <span class="hljs-number">10</span>);

<span class="hljs-comment">// Iterator Helpers - 内存</span>
<span class="hljs-keyword">const</span> iteratorHelpersMem4 = <span class="hljs-title function_">memoryBenchmark</span>(<span class="hljs-string">'Iterator Helpers (多次链式调用) - 内存'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">const</span> result = dataset4
    .<span class="hljs-title function_">values</span>()
    .<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">active</span>)
    .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> ({ ...item, <span class="hljs-attr">doubled</span>: item.<span class="hljs-property">value</span> * <span class="hljs-number">2</span> }))
    .<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">doubled</span> &gt; <span class="hljs-number">500</span>)
    .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> ({ <span class="hljs-attr">id</span>: item.<span class="hljs-property">id</span>, <span class="hljs-attr">final</span>: item.<span class="hljs-property">doubled</span> + <span class="hljs-number">100</span> }))
    .<span class="hljs-title function_">take</span>(<span class="hljs-number">15</span>)
    .<span class="hljs-title function_">toArray</span>();
  
  <span class="hljs-keyword">return</span> result;
});

<span class="hljs-keyword">const</span> timeImprovement4 = ((arrayMethodTime4 - iteratorHelpersTime4) / arrayMethodTime4 * <span class="hljs-number">100</span>).<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">2</span>);
<span class="hljs-keyword">const</span> memImprovement4 = ((arrayMethodMem4 - iteratorHelpersMem4) / arrayMethodMem4 * <span class="hljs-number">100</span>).<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">2</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`\n性能提升: 时间 <span class="hljs-subst">${timeImprovement4}</span>%, 内存 <span class="hljs-subst">${memImprovement4}</span>%`</span>);

<span class="hljs-comment">// ============ 总结 ============</span>

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'\n'</span> + <span class="hljs-string">'='</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">60</span>));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'总结'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'='</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">60</span>));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`
场景 1 (过滤+转换+取前N项):
  时间提升: <span class="hljs-subst">${timeImprovement1}</span>%
  内存提升: <span class="hljs-subst">${memImprovement1}</span>%

场景 2 (嵌套数据扁平化):
  时间提升: <span class="hljs-subst">${timeImprovement2}</span>%
  内存提升: <span class="hljs-subst">${memImprovement2}</span>%

场景 3 (查找第一个匹配项):
  时间提升: <span class="hljs-subst">${timeImprovement3}</span>%
  内存提升: <span class="hljs-subst">${memImprovement3}</span>%

场景 4 (复杂链式调用):
  时间提升: <span class="hljs-subst">${timeImprovement4}</span>%
  内存提升: <span class="hljs-subst">${memImprovement4}</span>%

结论:
- Iterator Helpers 在需要"取前 N 项"的场景下优势明显
- 时间和空间开销都能显著降低
- 数据规模越大，提升越显著
- 惰性求值避免了不必要的中间数组创建
- 在查找场景下，Iterator Helpers 可以提前终止，避免遍历整个数组
`</span>);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'\n提示: 运行时加上 --expose-gc 参数可以获得更准确的内存测试结果'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'命令: node --expose-gc iterator-helpers-benchmark.js'</span>);
</code></pre>
<h3 data-id="heading-23">实际运行输出</h3>
<p>在我的环境（Node.js 22+）下，使用 <code>node --expose-gc iterator-helpers-benchmark.js</code> 运行上面的代码，得到以下结果：</p>
<pre><code class="hljs language-markdown" lang="markdown">============================================================
测试场景 1: 大数据集过滤 + 转换 + 取前 10 项
<span class="hljs-section">数据规模: 100,000 条
============================================================</span>

传统数组方法 (filter + map + slice) - 时间:
  平均: 1.545ms
  最小: 0.920ms
  最大: 2.993ms
  内存增长: 3.38 MB

Iterator Helpers (filter + map + take) - 时间:
  平均: 0.019ms
  最小: 0.003ms
  最大: 0.126ms
  内存增长: 0.01 MB

性能提升: 时间 98.77%, 内存 99.75%

============================================================
测试场景 2: 嵌套数据扁平化 + 过滤 + 取前 20 项
<span class="hljs-section">数据规模: 10,000 个父项，每个包含 10 个子项
============================================================</span>

传统数组方法 (flatMap + filter + slice) - 时间:
  平均: 3.716ms
  最小: 2.263ms
  最大: 8.936ms
  内存增长: 4.03 MB

Iterator Helpers (flatMap + filter + take) - 时间:
  平均: 0.018ms
  最小: 0.004ms
  最大: 0.120ms
  内存增长: 0.01 MB

性能提升: 时间 99.53%, 内存 99.73%

============================================================
测试场景 3: 查找第一个匹配项（匹配项在数据集后半部分）
<span class="hljs-section">数据规模: 1,000,000 条
============================================================</span>

传统数组方法 (filter + [0]) - 时间:
  平均: 6.587ms
  最小: 5.605ms
  最大: 11.103ms
  内存增长: 0.01 MB

Iterator Helpers (find) - 时间:
  平均: 8.713ms
  最小: 7.893ms
  最大: 9.545ms
  内存增长: 14.80 MB

性能提升: 时间 -32.27%, 内存 -194800.20%

============================================================
测试场景 4: 复杂链式调用（filter + map + filter + map + take）
<span class="hljs-section">数据规模: 50,000 条
============================================================</span>

传统数组方法 (多次链式调用) - 时间:
  平均: 1.421ms
  最小: 0.840ms
  最大: 2.797ms
  内存增长: 5.33 MB

Iterator Helpers (多次链式调用) - 时间:
  平均: 0.028ms
  最小: 0.005ms
  最大: 0.220ms
  内存增长: 0.01 MB

性能提升: 时间 98.02%, 内存 99.75%

============================================================
<span class="hljs-section">总结
============================================================</span>

场景 1 (过滤+转换+取前N项):
  时间提升: 98.77%
  内存提升: 99.75%

场景 2 (嵌套数据扁平化):
  时间提升: 99.53%
  内存提升: 99.73%

场景 3 (查找第一个匹配项):
  时间提升: -32.27%
  内存提升: -194800.20%

场景 4 (复杂链式调用):
  时间提升: 98.02%
  内存提升: 99.75%

结论:
<span class="hljs-bullet">-</span> Iterator Helpers 在需要"取前 N 项"的场景下优势明显
<span class="hljs-bullet">-</span> 时间和空间开销都能显著降低
<span class="hljs-bullet">-</span> 数据规模越大，提升越显著
<span class="hljs-bullet">-</span> 惰性求值避免了不必要的中间数组创建
<span class="hljs-bullet">-</span> 在查找场景下，Iterator Helpers 可以提前终止，避免遍历整个数组

提示: 运行时加上 --expose-gc 参数可以获得更准确的内存测试结果
命令: node --expose-gc iterator-helpers-benchmark.js
</code></pre>
<p>从输出可以看到：</p>
<p><strong>场景 1-2、4（"取前 N 项"类场景）</strong>：</p>
<ul>
<li>时间提升：98%+</li>
<li>内存提升：99%+</li>
<li>Iterator Helpers 在时间和空间上都有压倒性优势</li>
</ul>
<p><strong>场景 3（查找匹配项）</strong>：</p>
<ul>
<li>时间下降：32%（Iterator Helpers 更慢）</li>
<li>内存异常：这个结果看起来有问题，可能是 GC 时机导致的测量误差</li>
<li>这个场景不适合用 Iterator Helpers</li>
</ul>
<p><strong>关键发现</strong>：</p>
<ol>
<li><strong>内存优势极其明显</strong>：在适合的场景下，Iterator Helpers 的内存使用只有传统方法的 0.3%</li>
<li><strong>中间数组是大头</strong>：场景 4 创建了 4 个中间数组，占用 5.33 MB；Iterator Helpers 几乎为零</li>
<li><strong>不是所有场景都适用</strong>：场景 3 证明了 Iterator Helpers 不是银弹</li>
</ol>
<hr/>
<p>如果你觉得这篇文章有帮助，欢迎关注我的 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ftt-a1i" target="_blank" title="https://github.com/tt-a1i" ref="nofollow noopener noreferrer">GitHub</a>，下面是我的一些开源项目：</p>
<p><strong>Claude Code Skills</strong>（按需加载，意图自动识别，不浪费 token，<a href="https://juejin.cn/post/7578714735307735066" target="_blank" title="https://juejin.cn/post/7578714735307735066">介绍文章</a>）：</p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ftt-a1i%2Fcode-review-skill" target="_blank" title="https://github.com/tt-a1i/code-review-skill" ref="nofollow noopener noreferrer">code-review-skill</a> - 代码审查技能，覆盖 React 19、Vue 3、TypeScript、Rust 等约 9000 行规则（<a href="https://juejin.cn/post/7578709098255908902" target="_blank" title="https://juejin.cn/post/7578709098255908902">详细介绍</a>）</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ftt-a1i%2F5-whys-skill" target="_blank" title="https://github.com/tt-a1i/5-whys-skill" ref="nofollow noopener noreferrer">5-whys-skill</a> - 5 Whys 根因分析，说"找根因"自动激活</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ftt-a1i%2Ffirst-principles-skill" target="_blank" title="https://github.com/tt-a1i/first-principles-skill" ref="nofollow noopener noreferrer">first-principles-skill</a> - 第一性原理思考，适合架构设计和技术选型</li>
</ul>
<p><strong>qwen/gemini/claude - cli 原理学习网站</strong>：</p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ftt-a1i%2Fcoding-cli-guide" target="_blank" title="https://github.com/tt-a1i/coding-cli-guide" ref="nofollow noopener noreferrer">coding-cli-guide</a>（<a href="https://link.juejin.cn?target=https%3A%2F%2Ftt-a1i.github.io%2Fcoding-cli-guide%2F%3Ftab%3Dstart-here" target="_blank" title="https://tt-a1i.github.io/coding-cli-guide/?tab=start-here" ref="nofollow noopener noreferrer">学习网站</a>）- 学习 qwen-cli 时整理的笔记，40+ 交互式动画演示 AI CLI 内部机制</li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/08e50020ab1f45428cd22e53af91a555~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lmf5peg6aOO6Zuo5Lmf6Zu-5pm0:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769428433&amp;x-signature=42pKbeP5eSeGsR4oemsuo9S4nh0%3D" alt="coding-cli-guide" loading="lazy"/></p>
<p><strong>全栈项目</strong>（适合学习现代技术栈）：</p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ftt-a1i%2Fprompt-vault" target="_blank" title="https://github.com/tt-a1i/prompt-vault" ref="nofollow noopener noreferrer">prompt-vault</a> - Prompt 管理器，用的都是最新的技术栈，适合用来学习了解最新的前端全栈开发范式：Next.js 15 + React 19 + tRPC 11 + Supabase 全栈示例，clone 下来配个免费 Supabase 就能跑</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ftt-a1i%2Fchat_edit" target="_blank" title="https://github.com/tt-a1i/chat_edit" ref="nofollow noopener noreferrer">chat_edit</a> - 双模式 AI 应用（聊天+富文本编辑），Vue 3.5 + TypeScript + Vite 5 + Quill 2.0 + IndexedDB</li>
</ul>
<p><strong>VS Code 插件</strong>：</p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ftt-a1i%2Fvscode-ai-commit" target="_blank" title="https://github.com/tt-a1i/vscode-ai-commit" ref="nofollow noopener noreferrer">vscode-ai-commit</a> - 一键生成 commit message，支持 Conventional Commits，兼容任何 OpenAI 格式接口</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[带你玩转俄罗斯 rustore支付接入 横空出世]]></title>    <link>https://juejin.cn/post/7596670644286767104</link>    <guid>https://juejin.cn/post/7596670644286767104</guid>    <pubDate>2026-01-19T09:52:54.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7596670644286767104" data-draft-id="7596864700508766242" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="带你玩转俄罗斯 rustore支付接入 横空出世"/> <meta itemprop="keywords" content="Android"/> <meta itemprop="datePublished" content="2026-01-19T09:52:54.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="xq9527"/> <meta itemprop="url" content="https://juejin.cn/user/1239904848712184"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            带你玩转俄罗斯 rustore支付接入 横空出世
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1239904848712184/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    xq9527
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-19T09:52:54.000Z" title="Mon Jan 19 2026 09:52:54 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    18
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">RuStore 支付接入实战指南</h2>
<h3 data-id="heading-1">前言导读</h3>
<p>各位同学大家好，有段时间没有见面了。应业务需求，最近整理了一份 <strong>RuStore</strong>（俄罗斯应用商店）支付接入的完整教程。本文将带大家一步步完成支付功能的集成，废话不多说，我们正式开始！</p>
<h3 data-id="heading-2">具体实现</h3>
<h4 data-id="heading-3">0. 支付流程总览</h4>
<p>在开始编写代码之前，我们先通过流程图梳理一下 RuStore 支付的完整交互逻辑。</p>
<pre><code class="hljs language-mermaid" lang="mermaid">graph TD
    Start[开始] --&gt; Init[1. 初始化 SDK]
    Init --&gt; Auth{2. 检查用户授权}
    Auth -- 未授权 --&gt; Login[引导用户登录]
    Auth -- 已授权 --&gt; CheckAvail{3. 检查支付可用性}
    CheckAvail -- 不可用 --&gt; Error[提示错误/结束]
    CheckAvail -- 可用 --&gt; QueryProd[4. 查询商品详情]
    QueryProd --&gt; CheckProd{商品有效?}
    CheckProd -- 无效 --&gt; Error
    CheckProd -- 有效 --&gt; Pay[5. 发起支付 launchBillingFlow]
    Pay --&gt; PayResult{支付结果}
    PayResult -- 失败/取消 --&gt; HandleFail[处理失败]
    PayResult -- 成功 --&gt; LocalRecord[6. 本地记录订单]
    LocalRecord --&gt; Consume[7. 验证并消耗商品 consumeAsync]
    Consume --&gt; ConsumeResult{消耗成功?}
    ConsumeResult -- 是 --&gt; Deliver[发放道具/服务]
    ConsumeResult -- 否 --&gt; Retry[保留状态等待补单]
    Deliver --&gt; End[结束]
    
    subgraph 补单流程
    Boot[启动/检查] --&gt; QueryInv[8. 查询未消耗订单 queryInventoryAsync]
    QueryInv --&gt; HasInv{有未消耗订单?}
    HasInv -- 是 --&gt; Consume
    HasInv -- 否 --&gt; End
    end
</code></pre>
<h4 data-id="heading-4">1. 添加依赖</h4>
<p>在模块级的 <code>build.gradle.kts</code> (或 <code>build.gradle</code>) 文件中添加 RuStore SDK 的依赖。推荐使用 BOM (Bill of Materials) 来管理版本。</p>
<pre><code class="hljs language-kotlin" lang="kotlin">dependencies {
    <span class="hljs-comment">// 使用 BOM 管理版本，确保各模块版本一致</span>
    implementation(platform(<span class="hljs-string">"ru.rustore.sdk:bom:2025.08.01"</span>))
    implementation(<span class="hljs-string">"ru.rustore.sdk:pay"</span>)
}
</code></pre>
<h4 data-id="heading-5">2. 配置 AndroidManifest</h4>
<p>在 <code>AndroidManifest.xml</code> 的 <code>&lt;application&gt;</code> 标签内添加以下配置。</p>
<p><strong>1. 添加元数据 (Meta-data)</strong>
这些元数据用于标识应用 Scheme 和 RuStore 控制台的应用 ID。</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">application</span> <span class="hljs-attr">...</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- 替换为你的 App Scheme --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta-data</span> 
        <span class="hljs-attr">android:name</span>=<span class="hljs-string">"sdk_pay_scheme_value"</span> 
        <span class="hljs-attr">android:value</span>=<span class="hljs-string">"yourappscheme"</span> /&gt;</span> 
 
    <span class="hljs-comment">&lt;!-- 替换为 RuStore 控制台的应用 ID --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta-data</span> 
        <span class="hljs-attr">android:name</span>=<span class="hljs-string">"console_app_id_value"</span> 
        <span class="hljs-attr">android:value</span>=<span class="hljs-string">"xxxxxx"</span> /&gt;</span>
        
    <span class="hljs-comment">&lt;!-- 下面配置 Activity --&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">application</span>&gt;</span>
</code></pre>
<p><strong>2. 配置 Intent-Filter</strong>
在处理支付回调的 Activity（通常是发起支付的 Activity）中配置 <code>intent-filter</code>，以便接收支付结果的回调。请确保 <code>android:scheme</code> 的值与上面 meta-data 中的 <code>sdk_pay_scheme_value</code> 保持一致。</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">activity</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">".YourPaymentActivity"</span> <span class="hljs-attr">android:exported</span>=<span class="hljs-string">"true"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span> 
         <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"android.intent.action.VIEW"</span> /&gt;</span> 
         <span class="hljs-tag">&lt;<span class="hljs-name">category</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"android.intent.category.DEFAULT"</span> /&gt;</span> 
         <span class="hljs-tag">&lt;<span class="hljs-name">category</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"android.intent.category.BROWSABLE"</span> /&gt;</span> 
         <span class="hljs-comment">&lt;!-- 必须与 sdk_pay_scheme_value 一致 --&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">data</span> <span class="hljs-attr">android:scheme</span>=<span class="hljs-string">"yourappscheme"</span> /&gt;</span> 
     <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span> 
<span class="hljs-tag">&lt;/<span class="hljs-name">activity</span>&gt;</span>
</code></pre>
<h4 data-id="heading-6">3. 初始化 SDK 与生命周期处理</h4>
<p>在 Activity 或 Application 中初始化 <code>RuStorePayClient</code>，并处理生命周期回调（用于接收支付结果）。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">private</span> RuStorePayClient ruStorePayClient;
<span class="hljs-keyword">private</span> IntentInteractor intentInteractor;
<span class="hljs-keyword">private</span> Activity mActivity;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(Activity activity)</span> {
    <span class="hljs-built_in">this</span>.mActivity = activity;
    <span class="hljs-comment">// 获取 RuStorePayClient 实例</span>
    ruStorePayClient = RuStorePayClient.Companion.getInstance();
    
    <span class="hljs-comment">// 初始化后建议进行一些预检查</span>
    checkUserAuthorization();
}

<span class="hljs-comment">/**
 * 在 Activity 的 onCreate 中调用
 * <span class="hljs-doctag">@param</span> activity
 * <span class="hljs-doctag">@param</span> savedInstanceState
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Activity activity, Bundle savedInstanceState)</span> {
    <span class="hljs-comment">// 必须调用 super</span>
    <span class="hljs-built_in">super</span>.onCreate(activity, savedInstanceState);
    <span class="hljs-keyword">if</span> (savedInstanceState == <span class="hljs-literal">null</span>) {
        intentInteractor = RuStorePayClient.Companion.getInstance().getIntentInteractor();
        intentInteractor.proceedIntent(activity.getIntent());
    }
}

<span class="hljs-comment">/**
 * 在 Activity 的 onNewIntent 中调用
 * <span class="hljs-doctag">@param</span> intent
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onNewIntent</span><span class="hljs-params">(Intent intent)</span> {
    <span class="hljs-comment">// 必须调用 super</span>
    <span class="hljs-built_in">super</span>.onNewIntent(intent);
    <span class="hljs-keyword">if</span> (intentInteractor != <span class="hljs-literal">null</span>) {
        intentInteractor.proceedIntent(intent);
    }
}
</code></pre>
<h4 data-id="heading-7">4. 检查用户授权状态</h4>
<p>在发起支付前，检查用户是否已登录 RuStore 账号。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkUserAuthorization</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">if</span> (ruStorePayClient == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;

    ruStorePayClient.getUserInteractor().getUserAuthorizationStatus()
            .addOnSuccessListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OnSuccessListener</span>&lt;UserAuthorizationStatus&gt;() {
                <span class="hljs-meta">@Override</span>
                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onSuccess</span><span class="hljs-params">(UserAuthorizationStatus status)</span> {
                    <span class="hljs-keyword">switch</span> (status) {
                        <span class="hljs-keyword">case</span> AUTHORIZED:
                            Log.d(<span class="hljs-string">"RuStoreSdk"</span>, <span class="hljs-string">"用户已授权"</span>);
                            <span class="hljs-keyword">break</span>;
                        <span class="hljs-keyword">case</span> UNAUTHORIZED:
                            Log.w(<span class="hljs-string">"RuStoreSdk"</span>, <span class="hljs-string">"用户未授权，请引导用户登录"</span>);
                            <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 处理未授权逻辑，例如提示用户登录</span>
                            <span class="hljs-keyword">break</span>;
                    }
                }
            })
            .addOnFailureListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OnFailureListener</span>() {
                <span class="hljs-meta">@Override</span>
                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onFailure</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Throwable throwable)</span> {
                    Log.e(<span class="hljs-string">"RuStoreSdk"</span>, <span class="hljs-string">"检查授权失败: "</span> + throwable.getMessage());
                }
            });
}
</code></pre>
<h4 data-id="heading-8">5. 检查支付服务可用性</h4>
<p>确认用户的设备环境是否支持支付功能。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkPurchaseAvailability</span><span class="hljs-params">(String userId, String productId, String cpOrderId)</span> {
    <span class="hljs-keyword">if</span> (ruStorePayClient == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;

    ruStorePayClient.getPurchaseInteractor().getPurchaseAvailability()
            .addOnSuccessListener(result -&gt; {
                <span class="hljs-keyword">if</span> (result <span class="hljs-keyword">instanceof</span> PurchaseAvailabilityResult.Available) {
                    <span class="hljs-comment">// 支付服务可用，继续查询商品详情</span>
                    checkProductIdToPay(mActivity, userId, productId, cpOrderId);
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result <span class="hljs-keyword">instanceof</span> PurchaseAvailabilityResult.Unavailable) {
                    <span class="hljs-comment">// 支付服务不可用</span>
                    PurchaseAvailabilityResult.<span class="hljs-type">Unavailable</span> <span class="hljs-variable">unavailable</span> <span class="hljs-operator">=</span> (PurchaseAvailabilityResult.Unavailable) result;
                    Log.e(<span class="hljs-string">"RuStoreSdk"</span>, <span class="hljs-string">"支付不可用: "</span> + unavailable.getCause().getMessage());
                    afterPaySDK(mActivity, <span class="hljs-literal">false</span>, <span class="hljs-number">1001</span>, <span class="hljs-string">"Payment Unavailable"</span>);
                }
            })
            .addOnFailureListener(throwable -&gt; {
                Log.e(<span class="hljs-string">"RuStoreSdk"</span>, <span class="hljs-string">"检查支付可用性出错"</span>, throwable);
                afterPaySDK(mActivity, <span class="hljs-literal">false</span>, <span class="hljs-number">1001</span>, <span class="hljs-string">"Check Availability Failed"</span>);
            });
}
</code></pre>
<h4 data-id="heading-9">6. 查询商品详情</h4>
<p>在发起支付前，验证商品 ID 是否有效，并获取商品信息。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkProductIdToPay</span><span class="hljs-params">(Activity activity, <span class="hljs-keyword">final</span> String userId,
                                <span class="hljs-keyword">final</span> String productIdStr, <span class="hljs-keyword">final</span> String cpOrderId)</span> {
    List&lt;ProductId&gt; productIds = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
    <span class="hljs-keyword">try</span> {
        productIds.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ProductId</span>(productIdStr));
        ruStorePayClient.getProductInteractor().getProducts(productIds)
                .addOnSuccessListener(products -&gt; {
                    <span class="hljs-keyword">if</span> (products == <span class="hljs-literal">null</span> || products.isEmpty()) {
                        Log.e(<span class="hljs-string">"RuStoreSdk"</span>, <span class="hljs-string">"未查询到商品信息: "</span> + productIdStr);
                        <span class="hljs-keyword">return</span>;
                    }
                    
                    <span class="hljs-keyword">for</span> (Product product : products) {
                        Log.d(<span class="hljs-string">"RuStoreSdk"</span>, <span class="hljs-string">"查询到商品: "</span> + product.getProductId().getValue());
                        <span class="hljs-keyword">if</span> (productIdStr.equals(product.getProductId().getValue())) {
                            <span class="hljs-comment">// 商品有效，发起支付</span>
                            launchBillingFlow(activity, userId, productIdStr, cpOrderId);
                        }
                    }
                })
                .addOnFailureListener(throwable -&gt; {
                    Log.e(<span class="hljs-string">"RuStoreSdk"</span>, <span class="hljs-string">"查询商品失败"</span>, throwable);
                });

    } <span class="hljs-keyword">catch</span> (Exception e) {
        Log.e(<span class="hljs-string">"RuStoreSdk"</span>, <span class="hljs-string">"查询商品异常"</span>, e);
    }
}
</code></pre>
<h4 data-id="heading-10">7. 调起支付页面</h4>
<p>构建支付参数并拉起 RuStore 收银台。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">/**
 * 调起支付
 * <span class="hljs-doctag">@param</span> activity 上下文
 * <span class="hljs-doctag">@param</span> userId 用户ID
 * <span class="hljs-doctag">@param</span> productIdStr 商品ID
 * <span class="hljs-doctag">@param</span> cpOrderId 订单号
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">launchBillingFlow</span><span class="hljs-params">(Activity activity, <span class="hljs-keyword">final</span> String userId,
                              <span class="hljs-keyword">final</span> String productIdStr, <span class="hljs-keyword">final</span> String cpOrderId)</span> {
    <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">// 构建支付参数</span>
        <span class="hljs-comment">// ProductId: 商品ID</span>
        <span class="hljs-comment">// Quantity: 数量 (默认1)</span>
        <span class="hljs-comment">// OrderId: 订单号 (UUID)</span>
        <span class="hljs-comment">// DeveloperPayload: 透传参数</span>
        <span class="hljs-comment">// AppUserId: 应用用户ID</span>
        <span class="hljs-type">ProductPurchaseParams</span> <span class="hljs-variable">params</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProductPurchaseParams</span>(
                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProductId</span>(productIdStr),
                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Quantity</span>(<span class="hljs-number">1</span>),
                <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderId</span>(cpOrderId),
                <span class="hljs-keyword">new</span> <span class="hljs-title class_">DeveloperPayload</span>(cpOrderId),
                <span class="hljs-keyword">new</span> <span class="hljs-title class_">AppUserId</span>(userId),
                <span class="hljs-literal">null</span>
        );

        ruStorePayClient.getPurchaseInteractor().purchase(params, PreferredPurchaseType.ONE_STEP)
                .addOnSuccessListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OnSuccessListener</span>&lt;ProductPurchaseResult&gt;() {
                    <span class="hljs-meta">@Override</span>
                    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onSuccess</span><span class="hljs-params">(ProductPurchaseResult paymentResult)</span> {
                        handlePaymentSuccess(paymentResult, cpOrderId);
                    }
                })
                .addOnFailureListener(throwable -&gt; {
                    Log.e(<span class="hljs-string">"RuStoreSdk"</span>, <span class="hljs-string">"支付失败"</span>, throwable);
                    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 处理支付失败逻辑</span>
                })
                .addOnCompletionListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OnCompletionListener</span>() {
                     <span class="hljs-meta">@Override</span>
                     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onComplete</span><span class="hljs-params">(Throwable throwable)</span> {
                         <span class="hljs-comment">// 支付失败或取消等完成状态</span>
                         Log.v(<span class="hljs-string">"RuStoreSdk"</span>, <span class="hljs-string">"addOnCompletionListener"</span>);
                     }
                 });
    } <span class="hljs-keyword">catch</span> (Exception e) {
        Log.e(<span class="hljs-string">"RuStoreSdk"</span>, <span class="hljs-string">"调起支付异常"</span>, e);
    }
}

<span class="hljs-comment">// 处理支付成功回调</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handlePaymentSuccess</span><span class="hljs-params">(ProductPurchaseResult paymentResult, String cpOrderId)</span> {
    <span class="hljs-keyword">if</span> (paymentResult <span class="hljs-keyword">instanceof</span> ProductPurchaseResult.Success) {
         <span class="hljs-comment">// 注意：新版 SDK 可能返回不同的 Result 类型，请根据实际 SDK 版本调整</span>
         ProductPurchaseResult.<span class="hljs-type">Success</span> <span class="hljs-variable">successResult</span> <span class="hljs-operator">=</span> (ProductPurchaseResult.Success) paymentResult;
         <span class="hljs-comment">// 如果需要从 Success 对象中获取更多特定信息</span>
    }
    
    <span class="hljs-comment">// 获取支付详情</span>
    <span class="hljs-type">PurchaseId</span> <span class="hljs-variable">purchaseId</span> <span class="hljs-operator">=</span> paymentResult.getPurchaseId(); <span class="hljs-comment">// 购买标识符。</span>
    <span class="hljs-type">ProductId</span> <span class="hljs-variable">productId</span> <span class="hljs-operator">=</span> paymentResult.getProductId();    <span class="hljs-comment">// 购买产品的标识符。</span>
    <span class="hljs-type">InvoiceId</span> <span class="hljs-variable">invoiceId</span> <span class="hljs-operator">=</span> paymentResult.getInvoiceId();    <span class="hljs-comment">// 发票标识符。</span>
    <span class="hljs-type">OrderId</span> <span class="hljs-variable">orderId</span> <span class="hljs-operator">=</span> paymentResult.getOrderId();          <span class="hljs-comment">// 唯一的付款标识符。</span>
    <span class="hljs-type">PurchaseType</span> <span class="hljs-variable">purchaseType</span> <span class="hljs-operator">=</span> paymentResult.getPurchaseType(); <span class="hljs-comment">// 购买类型。</span>
    <span class="hljs-type">Quantity</span> <span class="hljs-variable">quantity</span> <span class="hljs-operator">=</span> paymentResult.getQuantity();       <span class="hljs-comment">// 产品数量。</span>
    <span class="hljs-type">boolean</span> <span class="hljs-variable">sandbox</span> <span class="hljs-operator">=</span> paymentResult.getSandbox();          <span class="hljs-comment">// 沙盒标志。</span>
    
    Log.v(<span class="hljs-string">"RuStoreSdk"</span>, <span class="hljs-string">"支付成功 - invoiceId:"</span> + invoiceId);
    Log.v(<span class="hljs-string">"RuStoreSdk"</span>, <span class="hljs-string">"支付成功 - productId:"</span> + productId);
    Log.v(<span class="hljs-string">"RuStoreSdk"</span>, <span class="hljs-string">"支付成功 - orderId:"</span> + orderId);
    Log.v(<span class="hljs-string">"RuStoreSdk"</span>, <span class="hljs-string">"支付成功 - sandbox:"</span> + sandbox);
    Log.v(<span class="hljs-string">"RuStoreSdk"</span>, <span class="hljs-string">"支付成功 - purchaseId:"</span> + purchaseId);
    
    <span class="hljs-comment">// 1. 本地数据上报/记录 (模拟业务逻辑)</span>
    <span class="hljs-comment">// insertOrUpdateSssDataByOriginalJson(...);</span>

    <span class="hljs-comment">// 2. 验证票据并消耗商品 (关键步骤)</span>
    consumeAsync(mActivity, orderId.getValue(), purchaseId.getValue(), 
                 productId.getValue(), invoiceId.getValue(), sandbox, cpOrderId);
}
</code></pre>
<h4 data-id="heading-11">8. 确认交易 / 消耗商品 (Consume)</h4>
<p>RuStore 支付通常采用“两步支付”模式或需要“消耗”商品。对于消耗型商品（如游戏币），支付成功后必须调用确认/消耗接口，否则无法再次购买。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">/**
 * 消耗/确认订单
 * <span class="hljs-doctag">@param</span> activity 上下文
 * <span class="hljs-doctag">@param</span> orderId 订单ID
 * <span class="hljs-doctag">@param</span> purchaseId 购买ID
 * <span class="hljs-doctag">@param</span> productId 商品ID
 * <span class="hljs-doctag">@param</span> invoiceId 发票ID
 * <span class="hljs-doctag">@param</span> isSandbox 是否沙盒
 * <span class="hljs-doctag">@param</span> cpOrderId 开发者订单号
 */</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">consumeAsync</span><span class="hljs-params">(Activity activity, String orderId, String purchaseId, 
                          String productId, String invoiceId, <span class="hljs-type">boolean</span> isSandbox, String cpOrderId)</span> {
    <span class="hljs-keyword">try</span> {
        Log.d(<span class="hljs-string">"RuStoreSdk"</span>, <span class="hljs-string">"开始消耗订单: "</span> + purchaseId);
        
        <span class="hljs-keyword">if</span> (ruStorePayClient != <span class="hljs-literal">null</span>) {
            ruStorePayClient.getPurchaseInteractor().confirmTwoStepPurchase(
                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">PurchaseId</span>(purchaseId),
                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">DeveloperPayload</span>(cpOrderId)
            ).addOnSuccessListener(unit -&gt; {
                Log.d(<span class="hljs-string">"RuStoreSdk"</span>, <span class="hljs-string">"订单消耗/确认成功: "</span> + purchaseId);
                <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 1. 发放道具给用户</span>
                <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 2. 通知服务端订单完成</span>
            }).addOnFailureListener(throwable -&gt; {
                Log.e(<span class="hljs-string">"RuStoreSdk"</span>, <span class="hljs-string">"订单消耗/确认失败: "</span> + throwable.getMessage());
                <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 处理消耗失败，可能需要重试或记录日志</span>
            });
        }
    } <span class="hljs-keyword">catch</span> (Throwable throwable) {
        Log.e(<span class="hljs-string">"RuStoreSdk"</span>, <span class="hljs-string">"consumeAsync 异常"</span>, throwable);
    }
}
</code></pre>
<h4 data-id="heading-12">9. 补单机制：查询未消耗订单</h4>
<p>在应用启动或特定时机，检查是否有已支付但未消耗的订单（例如支付后网络断开导致未回调），并进行补单处理。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">/**
 * 查询是否存在未消耗商品
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">queryInventoryAsync</span><span class="hljs-params">()</span> {
    Log.d(<span class="hljs-string">"RuStoreSdk"</span>, <span class="hljs-string">"开始查询未消耗订单..."</span>);
    <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">if</span> (ruStorePayClient == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;

        <span class="hljs-comment">// 查询状态为 PAID (已支付) 的 CONSUMABLE (消耗型) 商品</span>
        ruStorePayClient.getPurchaseInteractor().getPurchases(ProductType.CONSUMABLE_PRODUCT, ProductPurchaseStatus.PAID)
                .addOnSuccessListener(purchases -&gt; {
                    <span class="hljs-keyword">if</span> (purchases != <span class="hljs-literal">null</span> &amp;&amp; !purchases.isEmpty()) {
                        Log.d(<span class="hljs-string">"RuStoreSdk"</span>, <span class="hljs-string">"发现未消耗订单数: "</span> + purchases.size());
                        <span class="hljs-keyword">for</span> (Purchase purchase : purchases) {
                            <span class="hljs-comment">// 处理每一笔掉单</span>
                            handleUnconsumedPurchase(purchase);
                        }
                    } <span class="hljs-keyword">else</span> {
                        Log.d(<span class="hljs-string">"RuStoreSdk"</span>, <span class="hljs-string">"无未消耗订单"</span>);
                    }
                })
                .addOnFailureListener(error -&gt; {
                    Log.e(<span class="hljs-string">"RuStoreSdk"</span>, <span class="hljs-string">"查询未消耗订单失败"</span>, error);
                });
    } <span class="hljs-keyword">catch</span> (Exception e) {
        Log.e(<span class="hljs-string">"RuStoreSdk"</span>, <span class="hljs-string">"queryInventoryAsync 异常"</span>, e);
    }
}

<span class="hljs-comment">/**
 * 处理单笔未消耗订单
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleUnconsumedPurchase</span><span class="hljs-params">(Purchase purchase)</span> {
    <span class="hljs-type">String</span> <span class="hljs-variable">orderId</span> <span class="hljs-operator">=</span> purchase.getOrderId().getValue();
    <span class="hljs-type">String</span> <span class="hljs-variable">purchaseId</span> <span class="hljs-operator">=</span> purchase.getPurchaseId().getValue();
    <span class="hljs-type">String</span> <span class="hljs-variable">productId</span> <span class="hljs-operator">=</span> purchase.getProductId().getValue(); 
    <span class="hljs-type">String</span> <span class="hljs-variable">invoiceId</span> <span class="hljs-operator">=</span> purchase.getInvoiceId().getValue();
    <span class="hljs-type">boolean</span> <span class="hljs-variable">isSandbox</span> <span class="hljs-operator">=</span> purchase.getSandbox();
    
    Log.d(<span class="hljs-string">"RuStoreSdk"</span>, <span class="hljs-string">"处理补单 OrderId: "</span> + orderId);

    <span class="hljs-comment">// 重新执行消耗/验证流程</span>
    <span class="hljs-comment">// 注意：这里的最后一个参数传 orderId 作为 cpOrderId，具体视业务逻辑而定</span>
    consumeAsync(mActivity, orderId, purchaseId, productId, invoiceId, isSandbox, orderId);
}
</code></pre>
<h3 data-id="heading-13">总结</h3>
<p>以上就是接入 RuStore 支付的核心流程。关键点在于：</p>
<ol>
<li><strong>初始化</strong>：确保 SDK 正确初始化。</li>
<li><strong>支付流程</strong>：查询 -&gt; 支付 -&gt; 消耗。</li>
<li><strong>异常处理</strong>：务必实现 <code>queryInventoryAsync</code> 补单机制，防止用户支付后未发货。</li>
</ol>
<p>希望这篇教程能帮助大家快速接入 RuStore 支付！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[2026 年 PHP 函数式编程 优势与实际应用]]></title>    <link>https://juejin.cn/post/7595808703075303450</link>    <guid>https://juejin.cn/post/7595808703075303450</guid>    <pubDate>2026-01-18T00:25:20.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7595808703075303450" data-draft-id="7595894884957863987" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="2026 年 PHP 函数式编程 优势与实际应用"/> <meta itemprop="keywords" content="后端,PHP"/> <meta itemprop="datePublished" content="2026-01-18T00:25:20.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="BingoGo"/> <meta itemprop="url" content="https://juejin.cn/user/993614242266077"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            2026 年 PHP 函数式编程 优势与实际应用
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/993614242266077/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    BingoGo
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-18T00:25:20.000Z" title="Sun Jan 18 2026 00:25:20 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-18
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">2026 年 PHP 函数式编程 优势与实际应用</h2>
<p>函数式编程（FP）已经存在几十年了，但近年来在实际开发中用得越来越多。这篇文章整理一下 FP 的核心概念和实际应用场景。</p>
<h3 data-id="heading-1">什么是函数式编程</h3>
<p>在深入优势和应用之前，先快速回顾一下函数式编程是什么。</p>
<p>函数式编程的核心是把计算当作数学函数的求值。它是一种声明式编程风格，描述的是"要什么"，而不是"怎么做"。在 FP 中，函数是一等公民，可以作为参数传递给其他函数，可以从函数返回，也可以赋值给变量。</p>
<p>FP 的一个核心原则是不可变性——一旦给变量赋值，就不能再改变。这消除了副作用，让代码更可预测、更容易调试。另一个基本概念是纯函数，对于相同的输入总是产生相同的输出，不会修改任何外部状态。</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fcatchadmin.com%2Fpost%2F2026-01%2Ffunctional-programming-paradigms-2026" target="_blank" title="https://catchadmin.com/post/2026-01/functional-programming-paradigms-2026" ref="nofollow noopener noreferrer">原文 2026 年 PHP 函数式编程 优势与实际应用</a></p>
<h3 data-id="heading-2">为什么开发者应该关注函数式编程</h3>
<h4 data-id="heading-3">更简洁、更易维护的代码</h4>
<p>函数式编程鼓励编写模块化、易于理解的代码。因为函数是纯的（不修改状态），意外行为的空间更小，代码库更干净。这让调试、测试和后续修改都更容易。</p>
<p>假设你在做一个 PHP 项目。使用函数式技术可以减少副作用，确保应用逻辑被隔离成更小的、可复用的代码片段。这也让后续更新或重构更容易，因为函数式代码的依赖通常更少。</p>
<h4 data-id="heading-4">并发和并行</h4>
<p>现代软件的一个挑战是处理并发和并行。随着多核处理器和分布式系统的普及，编写能高效处理多任务的代码比以往更重要。</p>
<p>函数式编程在这方面有明显优势：因为函数避免修改共享状态，它们天生是线程安全的。这让编写并发应用更容易，不用担心竞态条件或死锁。</p>
<p>比如一个需要处理大数据集的 PHP 应用。使用不可变数据结构和并行处理技术，可以确保应用的不同部分并发运行而不互相干扰。</p>
<h4 data-id="heading-5">更好的抽象和复用</h4>
<p>函数式编程促进高层抽象的创建。函数可以轻松组合、传递，在应用的不同部分复用。</p>
<p>比如在 PHP 中，与其写重复的代码处理某些操作，不如写小的纯函数，然后灵活地组合起来。这减少了代码重复，更好地遵循 DRY（Don't Repeat Yourself）原则。</p>
<h4 data-id="heading-6">PHP 中的函数式工具</h4>
<p>PHP 不是纯函数式语言，但内置的 <code>array_map()</code>、<code>array_filter()</code>、<code>array_reduce()</code> 等函数提供了基本的函数式操作能力。第三方库如 Ramda、Lodash 也可以用。</p>
<h3 data-id="heading-7">函数式编程的核心原则</h3>
<p>下面探讨函数式编程的一些核心原则，以及它们在实际编程中的应用。</p>
<h4 data-id="heading-8">不可变性</h4>
<p>在函数式编程中，数据是不可变的。一旦设置了值，就不能改变。这个概念减少了与可变状态变化相关的 bug，简化了对程序行为的理解。</p>
<p>PHP 示例：</p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addItemToList</span>(<span class="hljs-params"><span class="hljs-variable">$list</span>, <span class="hljs-variable">$item</span></span>) </span>{
    <span class="hljs-comment">// 创建一个包含新元素的新列表</span>
    <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">array_merge</span>(<span class="hljs-variable">$list</span>, [<span class="hljs-variable">$item</span>]);
}

<span class="hljs-variable">$list</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-variable">$newList</span> = <span class="hljs-title function_ invoke__">addItemToList</span>(<span class="hljs-variable">$list</span>, <span class="hljs-number">4</span>);

<span class="hljs-title function_ invoke__">print_r</span>(<span class="hljs-variable">$list</span>);     <span class="hljs-comment">// 输出: [1, 2, 3]（原列表不变）</span>
<span class="hljs-title function_ invoke__">print_r</span>(<span class="hljs-variable">$newList</span>);  <span class="hljs-comment">// 输出: [1, 2, 3, 4]（包含新元素的新列表）</span>
</code></pre>
<p>这个例子中，原始的 <code>$list</code> 保持不变，因为 PHP 数组是按值传递的。这展示了不可变性——原始数据结构被保留，返回的是包含新元素的新结构。</p>
<h4 data-id="heading-9">纯函数</h4>
<p>纯函数对于相同的输入总是产生相同的输出，不会产生任何副作用。这让纯函数可预测且易于测试。</p>
<p>PHP 示例：</p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">square</span>(<span class="hljs-params"><span class="hljs-variable">$number</span></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-variable">$number</span> * <span class="hljs-variable">$number</span>;
}

<span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">square</span>(<span class="hljs-number">4</span>); <span class="hljs-comment">// 输出: 16</span>
</code></pre>
<p><code>square()</code> 函数是纯的，因为对于相同的输入（4）总是产生相同的输出（16），而且不修改任何外部状态。</p>
<h4 data-id="heading-10">高阶函数</h4>
<p>高阶函数是可以接受其他函数作为参数或返回函数的函数。这实现了强大的抽象和代码复用。</p>
<p>PHP 示例：</p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">applyFunction</span>(<span class="hljs-params"><span class="hljs-variable">$func</span>, <span class="hljs-variable">$value</span></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-variable">$func</span>(<span class="hljs-variable">$value</span>);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">double</span>(<span class="hljs-params"><span class="hljs-variable">$x</span></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-variable">$x</span> * <span class="hljs-number">2</span>;
}

<span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">applyFunction</span>(<span class="hljs-string">'double'</span>, <span class="hljs-number">5</span>); <span class="hljs-comment">// 输出: 10</span>
</code></pre>
<p>这个例子中，<code>applyFunction()</code> 是一个高阶函数，因为它接受另一个函数（<code>double()</code>）作为参数并应用到一个值上。</p>
<h4 data-id="heading-11">函数组合</h4>
<p>函数组合是把简单函数组合成更复杂函数的过程。这让你可以从更小的、可复用的组件构建复杂行为。</p>
<p>PHP 示例：</p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params"><span class="hljs-variable">$x</span>, <span class="hljs-variable">$y</span></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-variable">$x</span> + <span class="hljs-variable">$y</span>;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">multiply</span>(<span class="hljs-params"><span class="hljs-variable">$x</span>, <span class="hljs-variable">$y</span></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-variable">$x</span> * <span class="hljs-variable">$y</span>;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addThenMultiply</span>(<span class="hljs-params"><span class="hljs-variable">$x</span>, <span class="hljs-variable">$y</span>, <span class="hljs-variable">$z</span></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">multiply</span>(<span class="hljs-title function_ invoke__">add</span>(<span class="hljs-variable">$x</span>, <span class="hljs-variable">$y</span>), <span class="hljs-variable">$z</span>);
}

<span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">addThenMultiply</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">// 输出: 20（add(2, 3) = 5, multiply(5, 4) = 20）</span>
</code></pre>
<p>这里，<code>addThenMultiply()</code> 函数展示了如何把更小的函数组合起来创建新功能。这鼓励代码复用和模块化。</p>
<h3 data-id="heading-12">函数式编程的实际应用</h3>
<p>函数式编程不只是理论概念——它正在实际应用中使用。下面看看函数式编程在不同领域的一些实际例子。</p>
<h4 data-id="heading-13">数据转换和 ETL 流程</h4>
<p>在数据密集型应用中，比如数据转换或 ETL（Extract, Transform, Load）流程，函数式编程表现出色。它让开发者可以不可变地操作大数据集，使用高层抽象进行转换。</p>
<p>PHP 示例：</p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-variable">$data</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];

<span class="hljs-comment">// 使用函数式方法处理数据</span>
<span class="hljs-variable">$result</span> = <span class="hljs-title function_ invoke__">array_map</span>(fn(<span class="hljs-variable">$x</span>) =&gt; <span class="hljs-variable">$x</span> * <span class="hljs-number">2</span>, <span class="hljs-variable">$data</span>);  <span class="hljs-comment">// 每个值翻倍</span>
<span class="hljs-variable">$result</span> = <span class="hljs-title function_ invoke__">array_filter</span>(<span class="hljs-variable">$result</span>, fn(<span class="hljs-variable">$x</span>) =&gt; <span class="hljs-variable">$x</span> &gt; <span class="hljs-number">5</span>); <span class="hljs-comment">// 只保留大于 5 的值</span>

<span class="hljs-title function_ invoke__">print_r</span>(<span class="hljs-variable">$result</span>);  <span class="hljs-comment">// 输出: [6, 8, 10]</span>
</code></pre>
<p>这个例子中，我们使用 <code>array_map()</code> 和 <code>array_filter()</code> 不可变地转换和过滤数据集，这是函数式编程中的常见模式。</p>
<h4 data-id="heading-14">分布式系统中的并发</h4>
<p>函数式编程对不可变性和纯函数的强调，使它成为并发和并行处理任务的理想选择。你可以放心地编写并发应用，不用担心竞态条件。</p>
<p>比如，在 PHP 中构建一个并发处理用户请求的分布式系统时，可以确保数据完整性，而不会引入与可变共享状态相关的 bug。</p>
<h4 data-id="heading-15">构建 API 端点和微服务</h4>
<p>构建微服务或 API 时，函数式编程可以帮助创建简洁、易维护的端点。通过确保每个函数处理特定任务且是纯的、确定性的，可以让每个微服务更容易测试和扩展。</p>
<h3 data-id="heading-16">小结</h3>
<p>函数式编程的核心是不可变性、纯函数和高阶函数。这些概念在并发处理、数据转换等场景下比较实用。PHP 虽然不是纯函数式语言，但内置函数和第三方库已经提供了足够的支持。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Kotlin 协程与 Flow 完全指南]]></title>    <link>https://juejin.cn/post/7596906473305817138</link>    <guid>https://juejin.cn/post/7596906473305817138</guid>    <pubDate>2026-01-19T09:55:18.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7596906473305817138" data-draft-id="7596906473305800754" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Kotlin 协程与 Flow 完全指南"/> <meta itemprop="keywords" content="Android"/> <meta itemprop="datePublished" content="2026-01-19T09:55:18.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="aykon"/> <meta itemprop="url" content="https://juejin.cn/user/3984285870883080"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Kotlin 协程与 Flow 完全指南
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3984285870883080/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    aykon
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-19T09:55:18.000Z" title="Mon Jan 19 2026 09:55:18 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    6
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读14分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">Kotlin 协程与 Flow 完全指南</h2>
<blockquote>
<p>本文档涵盖了 Kotlin 协程和 Flow 的基础知识、示例代码、源码解析以及两者的对比</p>
</blockquote>
<hr/>
<h3 data-id="heading-1">目录</h3>
<ul>
<li><a href="#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86kotlin-%E5%8D%8F%E7%A8%8B" title="#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86kotlin-%E5%8D%8F%E7%A8%8B">第一部分：Kotlin 协程</a>
<ul>
<li><a href="#%E5%8D%8F%E7%A8%8B%E5%9F%BA%E7%A1%80" title="#%E5%8D%8F%E7%A8%8B%E5%9F%BA%E7%A1%80">协程基础</a></li>
<li><a href="#%E5%8D%8F%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5" title="#%E5%8D%8F%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5">协程核心概念</a></li>
<li><a href="#%E5%8D%8F%E7%A8%8B%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81" title="#%E5%8D%8F%E7%A8%8B%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81">协程示例代码</a></li>
<li><a href="#%E5%8D%8F%E7%A8%8B%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90" title="#%E5%8D%8F%E7%A8%8B%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90">协程源码解析</a></li>
</ul>
</li>
<li><a href="#%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86kotlin-flow" title="#%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86kotlin-flow">第二部分：Kotlin Flow</a>
<ul>
<li><a href="#flow-%E5%9F%BA%E7%A1%80" title="#flow-%E5%9F%BA%E7%A1%80">Flow 基础</a></li>
<li><a href="#flow-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5" title="#flow-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5">Flow 核心概念</a></li>
<li><a href="#flow-%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81" title="#flow-%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81">Flow 示例代码</a></li>
<li><a href="#flow-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90" title="#flow-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90">Flow 源码解析</a></li>
</ul>
</li>
<li><a href="#%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86%E5%8D%8F%E7%A8%8B%E4%B8%8E-flow-%E5%AF%B9%E6%AF%94" title="#%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86%E5%8D%8F%E7%A8%8B%E4%B8%8E-flow-%E5%AF%B9%E6%AF%94">第三部分：协程与 Flow 对比</a></li>
</ul>
<hr/>
<h2 data-id="heading-2">第一部分：Kotlin 协程</h2>
<h3 data-id="heading-3">协程基础</h3>
<h4 data-id="heading-4">什么是协程？</h4>
<p>协程（Coroutine）是一种并发编程的方式，允许在单个线程内实现多个任务的协作式多任务。Kotlin 协程通过 <code>suspend</code> 函数实现"挂起和恢复"机制，让异步代码看起来像同步代码一样简洁。</p>
<h4 data-id="heading-5">协程的核心优势</h4>
<ol>
<li><strong>轻量级</strong>：可以在单个线程中运行成千上万个协程</li>
<li><strong>内存泄漏更少</strong>：使用结构化并发管理协程生命周期</li>
<li><strong>内置取消支持</strong>：协程可以协作式地取消</li>
<li><strong>Jetpack 集成</strong>：与 Android Jetpack 库深度集成</li>
</ol>
<h4 data-id="heading-6">协程的基本组成</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 协程的三大核心要素</span>
<span class="hljs-comment">// 1. 协程作用域 (CoroutineScope)</span>
<span class="hljs-comment">// 2. 协程构建器 (Coroutine Builders: launch, async, runBlocking)</span>
<span class="hljs-comment">// 3. 协程上下文 (CoroutineContext)</span>
</code></pre>
<hr/>
<h3 data-id="heading-7">协程核心概念</h3>
<h4 data-id="heading-8">1. 挂起函数 (Suspend Function)</h4>
<p>挂起函数是协程的基础，它只能在协程内部或其他挂起函数中调用。</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">import</span> kotlinx.coroutines.delay
<span class="hljs-keyword">import</span> kotlinx.coroutines.coroutineScope
<span class="hljs-keyword">import</span> kotlinx.coroutines.runBlocking

<span class="hljs-comment">/**
 * 挂起函数示例
 * suspend 关键字标记的函数可以被挂起，而不会阻塞线程
 */</span>
<span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fetchData</span><span class="hljs-params">()</span></span>: String {
    <span class="hljs-comment">// delay 是一个挂起函数，不会阻塞线程</span>
    delay(<span class="hljs-number">1000</span>) <span class="hljs-comment">// 模拟网络请求延迟</span>
    <span class="hljs-keyword">return</span> <span class="hljs-string">"数据加载完成"</span>
}

<span class="hljs-comment">/**
 * 普通函数无法调用挂起函数
 * fun normalFunction() {
 *     fetchData() // 编译错误：挂起函数只能在协程或挂起函数中调用
 * }

/**
 * 在协程中调用挂起函数
 */</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> = runBlocking { <span class="hljs-comment">// runBlocking 创建一个协程作用域</span>
    <span class="hljs-keyword">val</span> result = fetchData() <span class="hljs-comment">// 可以调用挂起函数</span>
    println(result)
}
</code></pre>
<h4 data-id="heading-9">2. 协程作用域 (CoroutineScope)</h4>
<p>协程作用域定义了协程的生命周期范围。</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">import</span> kotlinx.coroutines.*

<span class="hljs-comment">/**
 * 协程作用域示例
 */</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> = runBlocking {
    <span class="hljs-comment">// launch 在当前作用域内启动一个新协程</span>
    launch {
        delay(<span class="hljs-number">200</span>)
        println(<span class="hljs-string">"Task from launch"</span>)
    }

    <span class="hljs-comment">// async 启动一个新协程并返回 Deferred 结果</span>
    <span class="hljs-keyword">val</span> deferred: Deferred&lt;String&gt; = async {
        delay(<span class="hljs-number">100</span>)
        <span class="hljs-keyword">return</span><span class="hljs-symbol">@async</span> <span class="hljs-string">"Task from async"</span>
    }

    println(<span class="hljs-string">"等待子协程完成..."</span>)
    println(deferred.await()) <span class="hljs-comment">// await() 获取 async 的结果</span>
}
</code></pre>
<h4 data-id="heading-10">3. 协程上下文 (CoroutineContext)</h4>
<p>协程上下文是一组定义协程行为的元素集合。</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">import</span> kotlinx.coroutines.*

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> = runBlocking {
    <span class="hljs-comment">// CoroutineContext 的四个核心元素：</span>
    <span class="hljs-comment">// 1. Job：协程的句柄，用于取消和管理</span>
    <span class="hljs-comment">// 2. Dispatcher：确定协程在哪个线程执行</span>
    <span class="hljs-comment">// 3. CoroutineName：协程的名称</span>
    <span class="hljs-comment">// 4. CoroutineExceptionHandler：异常处理器</span>

    <span class="hljs-comment">// 组合多个上下文元素</span>
    <span class="hljs-keyword">val</span> context: CoroutineContext = CoroutineName(<span class="hljs-string">"MyCoroutine"</span>) + Dispatchers.Default

    launch(context) {
        println(<span class="hljs-string">"协程运行在: <span class="hljs-subst">${Thread.currentThread().name}</span>"</span>)
    }
}
</code></pre>
<h4 data-id="heading-11">4. Job 与协程生命周期</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">import</span> kotlinx.coroutines.*

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> = runBlocking {
    <span class="hljs-comment">// Job 管理协程的生命周期</span>
    <span class="hljs-keyword">val</span> job = launch {
        repeat(<span class="hljs-number">5</span>) { i -&gt;
            delay(<span class="hljs-number">500</span>)
            println(<span class="hljs-string">"协程执行: <span class="hljs-variable">$i</span>"</span>)
        }
    }

    <span class="hljs-comment">// Job 的状态：New -&gt; Active -&gt; Completing -&gt; Completed</span>
    <span class="hljs-comment">//           或：New -&gt; Active -&gt; Cancelling -&gt; Cancelled</span>

    println(<span class="hljs-string">"Job 状态: <span class="hljs-subst">${job.isActive}</span>"</span>) <span class="hljs-comment">// true</span>
    println(<span class="hljs-string">"Job 是否完成: <span class="hljs-subst">${job.isCompleted}</span>"</span>) <span class="hljs-comment">// false</span>

    delay(<span class="hljs-number">1200</span>)
    job.cancel() <span class="hljs-comment">// 取消协程</span>

    <span class="hljs-comment">// 等待协程结束</span>
    job.join()
}
</code></pre>
<hr/>
<h3 data-id="heading-12">协程示例代码</h3>
<h4 data-id="heading-13">示例 1：并发执行多个任务</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">import</span> kotlinx.coroutines.*
<span class="hljs-keyword">import</span> kotlin.system.measureTimeMillis

<span class="hljs-comment">/**
 * 并发执行多个任务
 * 使用 async 启动多个并发任务，然后用 await 等待所有结果
 */</span>
<span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fetchUserData</span><span class="hljs-params">()</span></span>: String {
    delay(<span class="hljs-number">500</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-string">"用户数据"</span>
}

<span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fetchUserOrders</span><span class="hljs-params">()</span></span>: String {
    delay(<span class="hljs-number">800</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-string">"订单数据"</span>
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> = runBlocking {
    <span class="hljs-keyword">val</span> time = measureTimeMillis {
        <span class="hljs-comment">// 并发执行两个任务</span>
        <span class="hljs-keyword">val</span> deferred1 = async { fetchUserData() }
        <span class="hljs-keyword">val</span> deferred2 = async { fetchUserOrders() }

        <span class="hljs-comment">// 等待两个任务都完成</span>
        <span class="hljs-keyword">val</span> userData = deferred1.await()
        <span class="hljs-keyword">val</span> userOrders = deferred2.await()

        println(<span class="hljs-string">"结果: <span class="hljs-variable">$userData</span>, <span class="hljs-variable">$userOrders</span>"</span>)
    }
    println(<span class="hljs-string">"总耗时: <span class="hljs-subst">${time}</span>ms"</span>) <span class="hljs-comment">// 约 800ms（并行执行）</span>
}
</code></pre>
<h4 data-id="heading-14">示例 2：异常处理</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">import</span> kotlinx.coroutines.*
<span class="hljs-keyword">import</span> java.lang.Exception

<span class="hljs-comment">/**
 * 协程异常处理示例
 */</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> = runBlocking {
    <span class="hljs-comment">// 方式1：使用 try-catch</span>
    <span class="hljs-keyword">try</span> {
        launch {
            delay(<span class="hljs-number">100</span>)
            <span class="hljs-keyword">throw</span> ArithmeticException(<span class="hljs-string">"计算错误"</span>)
        }
    } <span class="hljs-keyword">catch</span> (e: Exception) {
        println(<span class="hljs-string">"捕获异常: <span class="hljs-subst">${e.message}</span>"</span>)
    }

    <span class="hljs-comment">// 方式2：使用 CoroutineExceptionHandler</span>
    <span class="hljs-keyword">val</span> handler = CoroutineExceptionHandler { _, exception -&gt;
        println(<span class="hljs-string">"处理器捕获: <span class="hljs-subst">${exception.message}</span>"</span>)
    }

    <span class="hljs-keyword">val</span> job = launch(handler) {
        <span class="hljs-keyword">throw</span> IllegalStateException(<span class="hljs-string">"非法状态"</span>)
    }

    job.join()
}
</code></pre>
<h4 data-id="heading-15">示例 3：超时处理</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">import</span> kotlinx.coroutines.*
<span class="hljs-keyword">import</span> kotlinx.coroutines.TimeoutCancellationException
<span class="hljs-keyword">import</span> kotlin.system.measureTimeMillis

<span class="hljs-comment">/**
 * 超时处理示例
 */</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> = runBlocking {
    <span class="hljs-comment">// withTimeout：超时后抛出异常</span>
    <span class="hljs-keyword">try</span> {
        withTimeout(<span class="hljs-number">1000</span>) {
            delay(<span class="hljs-number">2000</span>)
            println(<span class="hljs-string">"这行不会执行"</span>)
        }
    } <span class="hljs-keyword">catch</span> (e: TimeoutCancellationException) {
        println(<span class="hljs-string">"操作超时"</span>)
    }

    <span class="hljs-comment">// withTimeoutOrNull：超时后返回 null</span>
    <span class="hljs-keyword">val</span> result = withTimeoutOrNull(<span class="hljs-number">1000</span>) {
        delay(<span class="hljs-number">2000</span>)
        <span class="hljs-string">"完成"</span>
    }
    println(<span class="hljs-string">"结果: <span class="hljs-variable">$result</span>"</span>) <span class="hljs-comment">// null</span>
}
</code></pre>
<h4 data-id="heading-16">示例 4：结构化并发</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">import</span> kotlinx.coroutines.*

<span class="hljs-comment">/**
 * 结构化并发示例
 * 父协程会等待所有子协程完成
 */</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> = runBlocking {
    launch {
        launch {
            delay(<span class="hljs-number">300</span>)
            println(<span class="hljs-string">"子协程 3 完成"</span>)
        }
        launch {
            delay(<span class="hljs-number">200</span>)
            println(<span class="hljs-string">"子协程 2 完成"</span>)
        }
        delay(<span class="hljs-number">100</span>)
        println(<span class="hljs-string">"子协程 1 完成"</span>)
    }

    <span class="hljs-comment">// runBlocking 会等待所有子协程完成</span>
    println(<span class="hljs-string">"主协程等待中..."</span>)
}
</code></pre>
<h4 data-id="heading-17">示例 5：协程调度器 (Dispatchers)</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">import</span> kotlinx.coroutines.*

<span class="hljs-comment">/**
 * Dispatchers 决定协程在哪个线程执行
 */</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> = runBlocking {
    <span class="hljs-comment">// Dispatchers.Main：主线程（Android UI 线程）</span>
    <span class="hljs-comment">// Dispatchers.IO：IO 密集型任务（网络、文件操作）</span>
    <span class="hljs-comment">// Dispatchers.Default：CPU 密集型任务（计算、排序）</span>
    <span class="hljs-comment">// Dispatchers.Unconfined：不限制线程，继承调用者线程</span>

    launch(Dispatchers.Default) {
        println(<span class="hljs-string">"Default: <span class="hljs-subst">${Thread.currentThread().name}</span>"</span>)
    }

    launch(Dispatchers.IO) {
        println(<span class="hljs-string">"IO: <span class="hljs-subst">${Thread.currentThread().name}</span>"</span>)
    }

    launch {
        println(<span class="hljs-string">"Inherited: <span class="hljs-subst">${Thread.currentThread().name}</span>"</span>)
    }
}
</code></pre>
<h4 data-id="heading-18">示例 6：Channel 通信</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">import</span> kotlinx.coroutines.*
<span class="hljs-keyword">import</span> kotlinx.coroutines.channels.Channel

<span class="hljs-comment">/**
 * Channel 用于协程间通信
 */</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> = runBlocking {
    <span class="hljs-keyword">val</span> channel = Channel&lt;<span class="hljs-built_in">Int</span>&gt;()

    <span class="hljs-comment">// 生产者协程</span>
    launch {
        <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.5</span>) {
            delay(<span class="hljs-number">100</span>)
            channel.send(i) <span class="hljs-comment">// 发送数据</span>
            println(<span class="hljs-string">"发送: <span class="hljs-variable">$i</span>"</span>)
        }
        channel.close() <span class="hljs-comment">// 关闭通道</span>
    }

    <span class="hljs-comment">// 消费者协程</span>
    launch {
        <span class="hljs-keyword">for</span> (value <span class="hljs-keyword">in</span> channel) {
            println(<span class="hljs-string">"接收: <span class="hljs-variable">$value</span>"</span>)
        }
    }
}
</code></pre>
<h4 data-id="heading-19">示例 7：协程上下文切换</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">import</span> kotlinx.coroutines.*

<span class="hljs-comment">/**
 * 使用 withContext 切换协程上下文
 */</span>
<span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fetchData</span><span class="hljs-params">()</span></span>: String = withContext(Dispatchers.IO) {
    <span class="hljs-comment">// 在 IO 线程执行网络请求</span>
    delay(<span class="hljs-number">500</span>)
    <span class="hljs-keyword">return</span><span class="hljs-symbol">@withContext</span> <span class="hljs-string">"从网络获取的数据"</span>
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> = runBlocking {
    println(<span class="hljs-string">"主线程: <span class="hljs-subst">${Thread.currentThread().name}</span>"</span>)

    <span class="hljs-comment">// withContext 会挂起当前协程，在指定上下文执行，完成后恢复</span>
    <span class="hljs-keyword">val</span> result = fetchData()

    println(<span class="hljs-string">"结果: <span class="hljs-variable">$result</span>"</span>)
    println(<span class="hljs-string">"恢复后线程: <span class="hljs-subst">${Thread.currentThread().name}</span>"</span>)
}
</code></pre>
<hr/>
<h3 data-id="heading-20">协程源码解析</h3>
<h4 data-id="heading-21">1. suspend 函数的编译期转换</h4>
<p>Kotlin 编译器将 <code>suspend</code> 函数转换为状态机实现。</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 源代码</span>
<span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fetchUser</span><span class="hljs-params">()</span></span>: User {
    <span class="hljs-keyword">val</span> token = getToken()
    <span class="hljs-keyword">val</span> user = getUser(token)
    <span class="hljs-keyword">return</span> user
}

<span class="hljs-comment">// 编译后的伪代码（简化版）</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fetchUser</span><span class="hljs-params">(cont: <span class="hljs-type">Continuation</span>&lt;<span class="hljs-type">User</span>&gt;)</span></span>: Any {
    <span class="hljs-comment">// 状态标签</span>
    label: {
        <span class="hljs-keyword">when</span> (cont.label) {
            <span class="hljs-number">0</span> -&gt; {
                <span class="hljs-comment">// 第一次调用，获取 token</span>
                <span class="hljs-keyword">val</span> token = getToken()
                <span class="hljs-comment">// 保存状态，设置下一次的 label</span>
                cont.label = <span class="hljs-number">1</span>
                <span class="hljs-comment">// 挂起并返回</span>
                <span class="hljs-keyword">return</span> getTokenSuspended(token, cont)
            }
            <span class="hljs-number">1</span> -&gt; {
                <span class="hljs-comment">// 恢复后，从挂起点继续</span>
                <span class="hljs-keyword">val</span> token = cont <span class="hljs-keyword">as</span>? Token ?: <span class="hljs-keyword">throw</span> AssertionError()
                <span class="hljs-keyword">val</span> user = getUser(token)
                <span class="hljs-keyword">return</span> user
            }
        }
    }
}
</code></pre>
<p><strong>关键点：</strong></p>
<ul>
<li><code>suspend</code> 函数编译后添加一个 <code>Continuation</code> 参数</li>
<li>使用状态机模式管理挂起点</li>
<li>每个挂起点对应一个状态标签</li>
</ul>
<h4 data-id="heading-22">2. Continuation 接口解析</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// Continuation 接口定义</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Continuation</span>&lt;<span class="hljs-type">in T</span>&gt; {
    <span class="hljs-comment">// 协程的上下文</span>
    <span class="hljs-keyword">val</span> context: CoroutineContext

    <span class="hljs-comment">// 恢复协程执行，成功时调用</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span>
}

<span class="hljs-comment">// 扩展函数（简化使用）</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> Continuation<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">resume</span><span class="hljs-params">(value: <span class="hljs-type">T</span>)</span></span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> Continuation<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">resumeWithException</span><span class="hljs-params">(exception: <span class="hljs-type">Throwable</span>)</span></span>
</code></pre>
<p><strong>工作原理：</strong></p>
<ul>
<li><code>Continuation</code> 表示协程的延续（即"接下来要做什么"）</li>
<li>挂起时保存 <code>Continuation</code>，恢复时调用 <code>resumeWith</code></li>
<li>通过 CPS（Continuation-Passing Style）实现协程</li>
</ul>
<h4 data-id="heading-23">3. CoroutineScope 源码解析</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">/**
 * CoroutineScope 接口定义
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">CoroutineScope</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">val</span> coroutineContext: CoroutineContext
}

<span class="hljs-comment">/**
 * 扩展函数 launch
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> CoroutineScope.<span class="hljs-title">launch</span><span class="hljs-params">(
    context: <span class="hljs-type">CoroutineContext</span> = EmptyCoroutineContext,
    start: <span class="hljs-type">CoroutineStart</span> = CoroutineStart.DEFAULT,
    block: <span class="hljs-type">suspend</span> <span class="hljs-type">CoroutineScope</span>.() -&gt; <span class="hljs-type">Unit</span>
)</span></span>: Job {
    <span class="hljs-comment">// 合并上下文：新协程继承父作用域的上下文，并加上自定义 context</span>
    <span class="hljs-keyword">val</span> newContext = newCoroutineContext(context)

    <span class="hljs-comment">// 创建协程</span>
    <span class="hljs-keyword">val</span> coroutine = <span class="hljs-keyword">if</span> (start.isLazy)
        LazyStandaloneCoroutine(newContext, block) <span class="hljs-keyword">else</span>
        StandaloneCoroutine(newContext, active = <span class="hljs-literal">true</span>)

    <span class="hljs-comment">// 启动协程</span>
    coroutine.start(start, coroutine, block)
    <span class="hljs-keyword">return</span> coroutine
}
</code></pre>
<p><strong>关键点：</strong></p>
<ul>
<li><code>CoroutineScope</code> 只是一个持有 <code>CoroutineContext</code> 的接口</li>
<li><code>launch</code> 创建新的协程并返回 <code>Job</code></li>
<li>子协程继承父作用域的上下文（结构化并发的基础）</li>
</ul>
<h4 data-id="heading-24">4. Job 源码解析</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">/**
 * Job 接口定义
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Job</span> : <span class="hljs-type">CoroutineContext.Element</span> {
    <span class="hljs-comment">// Job 的状态</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">val</span> isActive: <span class="hljs-built_in">Boolean</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">val</span> isCompleted: <span class="hljs-built_in">Boolean</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">val</span> isCancelled: <span class="hljs-built_in">Boolean</span>

    <span class="hljs-comment">// 取消协程</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">cancel</span><span class="hljs-params">(cause: <span class="hljs-type">CancellationException</span>? = <span class="hljs-literal">null</span>)</span></span>

    <span class="hljs-comment">// 等待协程完成（挂起函数）</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">join</span><span class="hljs-params">()</span></span>

    <span class="hljs-comment">// 携带结果的子接口</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Deferred</span>&lt;<span class="hljs-type">out T</span>&gt; : <span class="hljs-type">Job</span> {
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">await</span><span class="hljs-params">()</span></span>: T
    }
}

<span class="hljs-comment">/**
 * Job 状态机转换
 *
 * 状态转换路径：
 * 1. New -&gt; Active -&gt; Completing -&gt; Completed
 * 2. New -&gt; Active -&gt; Cancelling -&gt; Cancelled
 * 3. New -&gt; Active -&gt; Cancelling -&gt; Completed（处理异常后）
 */</span>
</code></pre>
<p><strong>Job 状态详解：</strong></p>
<ul>
<li><code>New</code>：协程已创建但未启动</li>
<li><code>Active</code>：协程正在运行</li>
<li><code>Completing</code>：协程正在完成（等待子协程）</li>
<li><code>Completed</code>：协程已成功完成</li>
<li><code>Cancelling</code>：协程正在取消</li>
<li><code>Cancelled</code>：协程已取消</li>
</ul>
<h4 data-id="heading-25">5. Dispatcher 调度器源码</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">/**
 * CoroutineDispatcher 抽象类
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CoroutineDispatcher</span> :
    <span class="hljs-type">AbstractCoroutineContextElement</span>(ContinuationInterceptor), ContinuationInterceptor {

    <span class="hljs-comment">// 调度核心方法：将任务分发到指定线程</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dispatch</span><span class="hljs-params">(context: <span class="hljs-type">CoroutineContext</span>, block: <span class="hljs-type">Runnable</span>)</span></span>

    <span class="hljs-comment">// 恢复执行：可能在同一线程直接恢复</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isDispatchNeeded</span><span class="hljs-params">(context: <span class="hljs-type">CoroutineContext</span>)</span></span>: <span class="hljs-built_in">Boolean</span> = <span class="hljs-literal">true</span>

    <span class="hljs-comment">// 拦截 continuation，实现调度</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">interceptContinuation</span><span class="hljs-params">(
        continuation: <span class="hljs-type">Continuation</span>&lt;<span class="hljs-type">T</span>&gt;
    )</span></span>: Continuation&lt;T&gt; = DispatchedContinuation(<span class="hljs-keyword">this</span>, continuation)
}

<span class="hljs-comment">/**
 * Dispatchers.Default 实现
 */</span>
<span class="hljs-keyword">internal</span> <span class="hljs-keyword">object</span> DefaultScheduler : SchedulerCoroutineDispatcher() {
    <span class="hljs-comment">// 使用 CPU 密集型任务的线程池</span>
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> corePoolSize: <span class="hljs-built_in">Int</span>
        <span class="hljs-keyword">get</span>() = Runtime.getRuntime().availableProcessors() - <span class="hljs-number">1</span>

    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> maxPoolSize: <span class="hljs-built_in">Int</span>
        <span class="hljs-keyword">get</span>() = corePoolSize * <span class="hljs-number">128</span>

    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> idleWorkerKeepAliveNs: <span class="hljs-built_in">Long</span>
        <span class="hljs-keyword">get</span>() = <span class="hljs-number">60_000_000_000L</span> <span class="hljs-comment">// 60 秒</span>
}

<span class="hljs-comment">/**
 * Dispatchers.IO 实现
 */</span>
<span class="hljs-keyword">internal</span> <span class="hljs-keyword">object</span> IoScheduler : ExecutorCoroutineDispatcher() {
    <span class="hljs-comment">// 使用 IO 密集型任务的线程池</span>
    <span class="hljs-comment">// 支持更多的线程数（最大 64 个或内核数的倍数）</span>
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> executor: Executor
        <span class="hljs-keyword">get</span>() = ThreadPoolExecutor(
            corePoolSize, maxPoolSize,
            <span class="hljs-number">60L</span>, TimeUnit.SECONDS,
            SynchronousQueue()
        )
}
</code></pre>
<p><strong>调度器工作原理：</strong></p>
<ol>
<li>调度器拦截 <code>Continuation</code></li>
<li>使用 <code>dispatch</code> 方法将 Runnable 分发到线程池</li>
<li>在目标线程执行 <code>Continuation.resumeWith</code></li>
</ol>
<h4 data-id="heading-26">6. withContext 实现原理</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">/**
 * withContext 源码（简化）
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">withContext</span><span class="hljs-params">(
    context: <span class="hljs-type">CoroutineContext</span>,
    block: <span class="hljs-type">suspend</span> <span class="hljs-type">CoroutineScope</span>.() -&gt; <span class="hljs-type">T</span>
)</span></span>: T {
    <span class="hljs-comment">// 1. 保存旧上下文</span>
    <span class="hljs-keyword">val</span> oldContext = coroutineContext

    <span class="hljs-comment">// 2. 创建新上下文</span>
    <span class="hljs-keyword">val</span> newContext = newCoroutineContext(oldContext, context)

    <span class="hljs-comment">// 3. 检查是否需要切换线程</span>
    <span class="hljs-keyword">if</span> (newContext.dispatcher == oldContext.dispatcher) {
        <span class="hljs-comment">// 同一调度器，直接执行</span>
        <span class="hljs-keyword">return</span> block.startCoroutineCancellable(<span class="hljs-keyword">this</span>, newContext)
    }

    <span class="hljs-comment">// 4. 切换调度器并执行</span>
    <span class="hljs-keyword">return</span> suspendCoroutineUninterceptedOrReturn { uCont -&gt;
        <span class="hljs-keyword">val</span> dispatcher = newContext.dispatcher
        <span class="hljs-keyword">val</span> dispatch = dispatcher.isDispatchNeeded(newContext)

        <span class="hljs-keyword">if</span> (dispatch) {
            <span class="hljs-comment">// 分发到新线程</span>
            dispatcher.dispatch(newContext) {
                block.startCoroutineCancellable(uCont.intercepted(), newContext)
            }
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// 直接执行</span>
            block.startCoroutineCancellable(uCont.intercepted(), newContext)
        }
    }
}
</code></pre>
<p><strong>withContext vs async/await：</strong></p>
<ul>
<li><code>withContext</code>：挂起当前协程，执行完后恢复（更轻量）</li>
<li><code>async/await</code>：创建新的协程并发执行</li>
</ul>
<h4 data-id="heading-27">7. 协程取消机制</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">/**
 * 协程取消的核心：协作式取消
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractCoroutine</span>&lt;<span class="hljs-type">in T</span>&gt; ... {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">cancel</span><span class="hljs-params">(cause: <span class="hljs-type">CancellationException</span>?)</span></span> {
        <span class="hljs-comment">// 1. 标记为取消状态</span>
        _state.compareAndSet(ACTIVE, COMPLETING)

        <span class="hljs-comment">// 2. 通知子协程取消</span>
        cancelChildren()

        <span class="hljs-comment">// 3. 执行取消回调</span>
        handleCancellationException(cause)
    }
}

<span class="hljs-comment">/**
 * 挂起函数检查取消状态
 */</span>
<span class="hljs-keyword">internal</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">yieldIfNeed</span><span class="hljs-params">()</span></span> {
    <span class="hljs-comment">// 每次挂起恢复时检查</span>
    Thread.currentThread().let { thread -&gt;
        <span class="hljs-keyword">if</span> (thread.isInterrupted) {
            <span class="hljs-keyword">throw</span> CancellationException(<span class="hljs-string">"Thread interrupted"</span>)
        }
    }
}

<span class="hljs-comment">/**
 * 挂起点自动检查取消
 */</span>
<span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">delay</span><span class="hljs-params">(time: <span class="hljs-type">Long</span>)</span></span> {
    <span class="hljs-comment">// delay 内部会检查协程是否被取消</span>
    <span class="hljs-keyword">return</span> suspendCancellableCoroutine { cont -&gt;
        cont.context.ensureActive()
        <span class="hljs-comment">// ... 实际延迟逻辑</span>
    }
}
</code></pre>
<p><strong>取消的关键点：</strong></p>
<ul>
<li>协程取消是协作式的，需要主动检查</li>
<li>所有挂起函数会自动检查取消状态</li>
<li>使用 <code>ensureActive()</code> 或 <code>yield()</code> 在计算密集代码中检查</li>
</ul>
<hr/>
<h2 data-id="heading-28">第二部分：Kotlin Flow</h2>
<h3 data-id="heading-29">Flow 基础</h3>
<h4 data-id="heading-30">什么是 Flow？</h4>
<p>Flow 是 Kotlin 协程库中用于处理异步数据流的 API。它代表一个可以异步发出的值序列。</p>
<h4 data-id="heading-31">Flow 的特点</h4>
<ol>
<li><strong>冷流（Cold Stream）</strong>：只有在收集时才会开始发射数据</li>
<li><strong>响应式</strong>：支持多个操作符进行数据转换</li>
<li><strong>背压支持</strong>：天然支持背压，不需要特殊处理</li>
<li><strong>协程友好</strong>：与协程深度集成，支持挂起函数</li>
</ol>
<h4 data-id="heading-32">Flow 基本结构</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// Flow 的三部分：</span>
<span class="hljs-comment">// 1. 上游（Upstream）：数据生产者</span>
<span class="hljs-comment">// 2. 中间操作符（Intermediate Operators）：数据转换</span>
<span class="hljs-comment">// 3. 终端操作符（Terminal Operator）：数据消费者</span>
</code></pre>
<hr/>
<h3 data-id="heading-33">Flow 核心概念</h3>
<h4 data-id="heading-34">1. Flow 的基本创建</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">import</span> kotlinx.coroutines.*
<span class="hljs-keyword">import</span> kotlinx.coroutines.flow.*

<span class="hljs-comment">/**
 * Flow 基础示例
 */</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> = runBlocking {
    <span class="hljs-comment">// 创建一个简单的 Flow</span>
    <span class="hljs-keyword">val</span> flow: Flow&lt;<span class="hljs-built_in">Int</span>&gt; = flow {
        <span class="hljs-comment">// 上游：发射数据</span>
        emit(<span class="hljs-number">1</span>)
        emit(<span class="hljs-number">2</span>)
        emit(<span class="hljs-number">3</span>)
    }

    <span class="hljs-comment">// 收集 Flow</span>
    flow.collect { value -&gt;
        <span class="hljs-comment">// 终端操作：消费数据</span>
        println(<span class="hljs-string">"收到: <span class="hljs-variable">$value</span>"</span>)
    }
}
</code></pre>
<h4 data-id="heading-35">2. Flow 的冷流特性</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">import</span> kotlinx.coroutines.*
<span class="hljs-keyword">import</span> kotlinx.coroutines.flow.*

<span class="hljs-comment">/**
 * 冷流特性：只有被 collect 时才会开始发射
 */</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> = runBlocking {
    <span class="hljs-comment">// 创建 Flow（此时不会执行）</span>
    <span class="hljs-keyword">val</span> flow = flow {
        println(<span class="hljs-string">"开始发射数据"</span>)
        emit(<span class="hljs-number">1</span>)
        delay(<span class="hljs-number">100</span>)
        emit(<span class="hljs-number">2</span>)
    }

    println(<span class="hljs-string">"Flow 已创建"</span>)

    delay(<span class="hljs-number">1000</span>)

    <span class="hljs-comment">// 第一次收集</span>
    println(<span class="hljs-string">"第一次收集"</span>)
    flow.collect { println(<span class="hljs-string">"收集器1: <span class="hljs-variable">$it</span>"</span>) }

    <span class="hljs-comment">// 第二次收集（会重新执行）</span>
    println(<span class="hljs-string">"第二次收集"</span>)
    flow.collect { println(<span class="hljs-string">"收集器2: <span class="hljs-variable">$it</span>"</span>) }
}
</code></pre>
<h4 data-id="heading-36">3. Flow 操作符</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">import</span> kotlinx.coroutines.*
<span class="hljs-keyword">import</span> kotlinx.coroutines.flow.*

<span class="hljs-comment">/**
 * Flow 常用操作符
 */</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> = runBlocking {
    flow {
        emit(<span class="hljs-number">1</span>)
        emit(<span class="hljs-number">2</span>)
        emit(<span class="hljs-number">3</span>)
        emit(<span class="hljs-number">4</span>)
    }
    <span class="hljs-comment">// 中间操作符（转换）</span>
    .filter { it % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> }      <span class="hljs-comment">// 过滤偶数</span>
    .map { it * <span class="hljs-number">2</span> }              <span class="hljs-comment">// 乘以 2</span>
    .take(<span class="hljs-number">2</span>)                     <span class="hljs-comment">// 只取前两个</span>
    .onEach { println(<span class="hljs-string">"处理: <span class="hljs-variable">$it</span>"</span>) }
    <span class="hljs-comment">// 终端操作符（消费）</span>
    .collect { value -&gt;
        println(<span class="hljs-string">"最终结果: <span class="hljs-variable">$value</span>"</span>)
    }
}
</code></pre>
<hr/>
<h3 data-id="heading-37">Flow 示例代码</h3>
<h4 data-id="heading-38">示例 1：基础 Flow 使用</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">import</span> kotlinx.coroutines.*
<span class="hljs-keyword">import</span> kotlinx.coroutines.flow.*

<span class="hljs-comment">/**
 * 基础 Flow 示例
 */</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> = runBlocking {
    <span class="hljs-comment">// 方式1：使用 flow 构建器</span>
    <span class="hljs-keyword">val</span> numbers = flow {
        <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.5</span>) {
            delay(<span class="hljs-number">100</span>)
            emit(i) <span class="hljs-comment">// 发射值</span>
        }
    }

    <span class="hljs-comment">// 收集数据</span>
    numbers.collect { value -&gt;
        println(<span class="hljs-string">"收到: <span class="hljs-variable">$value</span>"</span>)
    }

    <span class="hljs-comment">// 方式2：使用 flowOf</span>
    flowOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
        .collect { println(<span class="hljs-string">"flowOf: <span class="hljs-variable">$it</span>"</span>) }

    <span class="hljs-comment">// 方式3：使用 asFlow</span>
    listOf(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>).asFlow()
        .collect { println(<span class="hljs-string">"asFlow: <span class="hljs-variable">$it</span>"</span>) }
}
</code></pre>
<h4 data-id="heading-39">示例 2：Flow 转换操作符</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">import</span> kotlinx.coroutines.*
<span class="hljs-keyword">import</span> kotlinx.coroutines.flow.*

<span class="hljs-comment">/**
 * Flow 转换操作符
 */</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> = runBlocking {
    flow {
        emit(<span class="hljs-number">1</span>)
        emit(<span class="hljs-number">2</span>)
        emit(<span class="hljs-number">3</span>)
    }
    .map { it * <span class="hljs-number">2</span> }              <span class="hljs-comment">// 转换：[2, 4, 6]</span>
    .filter { it &gt; <span class="hljs-number">2</span> }           <span class="hljs-comment">// 过滤：[4, 6]</span>
    .transform { value -&gt;
        emit(<span class="hljs-string">"前缀: <span class="hljs-variable">$value</span>"</span>)    <span class="hljs-comment">// 发射多个值</span>
        emit(<span class="hljs-string">"后缀: <span class="hljs-variable">$value</span>"</span>)
    }
    .collect { println(<span class="hljs-string">"结果: <span class="hljs-variable">$it</span>"</span>) }
}
</code></pre>
<h4 data-id="heading-40">示例 3：Flow 限流操作符</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">import</span> kotlinx.coroutines.*
<span class="hljs-keyword">import</span> kotlinx.coroutines.flow.*

<span class="hljs-comment">/**
 * 限流操作符
 */</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> = runBlocking {
    <span class="hljs-comment">// debounce：防抖，只在静默一段时间后发射最新值</span>
    flow {
        emit(<span class="hljs-number">1</span>)
        delay(<span class="hljs-number">100</span>)
        emit(<span class="hljs-number">2</span>)
        delay(<span class="hljs-number">100</span>)
        emit(<span class="hljs-number">3</span>)
        delay(<span class="hljs-number">1000</span>) <span class="hljs-comment">// 静默足够长</span>
        emit(<span class="hljs-number">4</span>)
    }
    .debounce(<span class="hljs-number">500</span>)
    .collect { println(<span class="hljs-string">"debounce: <span class="hljs-variable">$it</span>"</span>) }

    <span class="hljs-comment">// sample：采样，按固定时间间隔采样</span>
    flow {
        repeat(<span class="hljs-number">10</span>) {
            emit(it)
            delay(<span class="hljs-number">100</span>)
        }
    }
    .sample(<span class="hljs-number">300</span>)
    .collect { println(<span class="hljs-string">"sample: <span class="hljs-variable">$it</span>"</span>) }

    <span class="hljs-comment">// throttleFirst：节流，在时间窗口内只发射第一个值</span>
    flow {
        repeat(<span class="hljs-number">10</span>) {
            emit(it)
            delay(<span class="hljs-number">100</span>)
        }
    }
    .debounce(<span class="hljs-number">50</span>)
    .collect { println(<span class="hljs-string">"throttle: <span class="hljs-variable">$it</span>"</span>) }
}
</code></pre>
<h4 data-id="heading-41">示例 4：Flow 的异常处理</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">import</span> kotlinx.coroutines.*
<span class="hljs-keyword">import</span> kotlinx.coroutines.flow.*

<span class="hljs-comment">/**
 * Flow 异常处理
 */</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> = runBlocking {
    <span class="hljs-comment">// 方式1：try-catch</span>
    <span class="hljs-keyword">try</span> {
        flow {
            emit(<span class="hljs-number">1</span>)
            <span class="hljs-keyword">throw</span> RuntimeException(<span class="hljs-string">"错误"</span>)
        }
        .collect { println(it) }
    } <span class="hljs-keyword">catch</span> (e: Exception) {
        println(<span class="hljs-string">"捕获: <span class="hljs-subst">${e.message}</span>"</span>)
    }

    <span class="hljs-comment">// 方式2：catch 操作符</span>
    flow {
        emit(<span class="hljs-number">1</span>)
        <span class="hljs-keyword">throw</span> IllegalStateException(<span class="hljs-string">"错误2"</span>)
    }
    .<span class="hljs-keyword">catch</span> { e -&gt;
        println(<span class="hljs-string">"catch 操作符: <span class="hljs-subst">${e.message}</span>"</span>)
        emit(<span class="hljs-number">0</span>) <span class="hljs-comment">// 发射默认值</span>
    }
    .collect { println(<span class="hljs-string">"恢复: <span class="hljs-variable">$it</span>"</span>) }

    <span class="hljs-comment">// 方式3：onCompletion</span>
    flow {
        emit(<span class="hljs-number">1</span>)
        emit(<span class="hljs-number">2</span>)
    }
    .onCompletion { cause -&gt;
        println(<span class="hljs-string">"完成，异常: <span class="hljs-variable">$cause</span>"</span>)
    }
    .collect { println(it) }
}
</code></pre>
<h4 data-id="heading-42">示例 5：Flow 的完成处理</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">import</span> kotlinx.coroutines.*
<span class="hljs-keyword">import</span> kotlinx.coroutines.flow.*

<span class="hljs-comment">/**
 * Flow 完成处理
 */</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> = runBlocking {
    flow {
        emit(<span class="hljs-number">1</span>)
        emit(<span class="hljs-number">2</span>)
        <span class="hljs-comment">// emit(3)</span>
    }
    .onEach { println(<span class="hljs-string">"发射: <span class="hljs-variable">$it</span>"</span>) }
    .onEmpty { println(<span class="hljs-string">"流为空"</span>) }        <span class="hljs-comment">// 流为空时调用</span>
    .onStart { println(<span class="hljs-string">"开始收集"</span>) }       <span class="hljs-comment">// 收集开始时调用</span>
    .onCompletion { cause -&gt;
        println(<span class="hljs-string">"收集完成，异常: <span class="hljs-variable">$cause</span>"</span>)  <span class="hljs-comment">// 收集完成时调用</span>
    }
    .collect { println(<span class="hljs-string">"收到: <span class="hljs-variable">$it</span>"</span>) }
}
</code></pre>
<h4 data-id="heading-43">示例 6：Flow 的线程切换</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">import</span> kotlinx.coroutines.*
<span class="hljs-keyword">import</span> kotlinx.coroutines.flow.*

<span class="hljs-comment">/**
 * Flow 线程切换：flowOn
 */</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> = runBlocking {
    flow {
        <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.3</span>) {
            println(<span class="hljs-string">"上游: <span class="hljs-subst">${Thread.currentThread().name}</span>"</span>)
            emit(i)
        }
    }
    .flowOn(Dispatchers.Default) <span class="hljs-comment">// 上游在 Default 线程</span>
    .map { value -&gt;
        println(<span class="hljs-string">"map: <span class="hljs-subst">${Thread.currentThread().name}</span>"</span>)
        value * <span class="hljs-number">2</span>
    }
    .flowOn(Dispatchers.IO) <span class="hljs-comment">// map 在 IO 线程</span>
    .collect { value -&gt;
        println(<span class="hljs-string">"下游: <span class="hljs-subst">${Thread.currentThread().name}</span>, 值: <span class="hljs-variable">$value</span>"</span>)
    }
    <span class="hljs-comment">// 下游继承主协程的上下文（Main 线程）</span>
}
</code></pre>
<h4 data-id="heading-44">示例 7：Flow 的缓冲与背压</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">import</span> kotlinx.coroutines.*
<span class="hljs-keyword">import</span> kotlinx.coroutines.flow.*

<span class="hljs-comment">/**
 * Flow 背压处理
 */</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> = runBlocking {
    <span class="hljs-comment">// buffer：缓冲区，上游可以快速发射</span>
    <span class="hljs-keyword">val</span> time = measureTimeMillis {
        flow {
            repeat(<span class="hljs-number">5</span>) {
                delay(<span class="hljs-number">100</span>)
                emit(it)
                println(<span class="hljs-string">"发射: <span class="hljs-variable">$it</span>"</span>)
            }
        }
        .buffer(capacity = <span class="hljs-number">3</span>) <span class="hljs-comment">// 缓冲区大小为 3</span>
        .collect { value -&gt;
            delay(<span class="hljs-number">300</span>) <span class="hljs-comment">// 消费较慢</span>
            println(<span class="hljs-string">"消费: <span class="hljs-variable">$value</span>"</span>)
        }
    }
    println(<span class="hljs-string">"总耗时: <span class="hljs-subst">${time}</span>ms"</span>)

    <span class="hljs-comment">// conflate：只保留最新的值，中间值会被丢弃</span>
    flow {
        repeat(<span class="hljs-number">10</span>) {
            delay(<span class="hljs-number">50</span>)
            emit(it)
        }
    }
    .conflate()
    .collect { value -&gt;
        delay(<span class="hljs-number">200</span>)
        println(<span class="hljs-string">"conflate: <span class="hljs-variable">$value</span>"</span>)
    }

    <span class="hljs-comment">// collectLatest：收到新值时取消之前的处理</span>
    flow {
        repeat(<span class="hljs-number">10</span>) {
            delay(<span class="hljs-number">50</span>)
            emit(it)
        }
    }
    .collectLatest { value -&gt;
        println(<span class="hljs-string">"开始处理: <span class="hljs-variable">$value</span>"</span>)
        delay(<span class="hljs-number">200</span>)
        println(<span class="hljs-string">"完成处理: <span class="hljs-variable">$value</span>"</span>)
    }
}
</code></pre>
<h4 data-id="heading-45">示例 8：Flow 的组合</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">import</span> kotlinx.coroutines.*
<span class="hljs-keyword">import</span> kotlinx.coroutines.flow.*

<span class="hljs-comment">/**
 * Flow 组合操作符
 */</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> = runBlocking {
    <span class="hljs-comment">// zip：组合两个流，等待两者都发射</span>
    <span class="hljs-keyword">val</span> flow1 = flowOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).onEach { delay(<span class="hljs-number">100</span>) }
    <span class="hljs-keyword">val</span> flow2 = flowOf(<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>, <span class="hljs-string">"C"</span>).onEach { delay(<span class="hljs-number">150</span>) }

    flow1.zip(flow2) { a, b -&gt; <span class="hljs-string">"<span class="hljs-variable">$a</span> -&gt; <span class="hljs-variable">$b</span>"</span> }
        .collect { println(<span class="hljs-string">"zip: <span class="hljs-variable">$it</span>"</span>) }

    <span class="hljs-comment">// combine：任意流发射时都组合</span>
    flow1.combine(flow2) { a, b -&gt; <span class="hljs-string">"<span class="hljs-variable">$a</span> -&gt; <span class="hljs-variable">$b</span>"</span> }
        .collect { println(<span class="hljs-string">"combine: <span class="hljs-variable">$it</span>"</span>) }

    <span class="hljs-comment">// merge：合并多个流</span>
    merge(
        flowOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>),
        flowOf(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)
    )
    .collect { println(<span class="hljs-string">"merge: <span class="hljs-variable">$it</span>"</span>) }

    <span class="hljs-comment">// flatMapConcat：顺序展平</span>
    flowOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
        .flatMapConcat { value -&gt;
            flowOf(<span class="hljs-string">"<span class="hljs-variable">$value</span>-a"</span>, <span class="hljs-string">"<span class="hljs-variable">$value</span>-b"</span>)
        }
        .collect { println(<span class="hljs-string">"flatMapConcat: <span class="hljs-variable">$it</span>"</span>) }

    <span class="hljs-comment">// flatMapMerge：并发展平</span>
    flowOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
        .flatMapMerge { value -&gt;
            flowOf(<span class="hljs-string">"<span class="hljs-variable">$value</span>-a"</span>, <span class="hljs-string">"<span class="hljs-variable">$value</span>-b"</span>)
        }
        .collect { println(<span class="hljs-string">"flatMapMerge: <span class="hljs-variable">$it</span>"</span>) }

    <span class="hljs-comment">// flatMapLatest：取消之前的展平</span>
    flowOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
        .onEach { delay(<span class="hljs-number">100</span>) }
        .flatMapLatest { value -&gt;
            flow {
                emit(value)
                delay(<span class="hljs-number">150</span>)
                emit(value + <span class="hljs-number">10</span>)
            }
        }
        .collect { println(<span class="hljs-string">"flatMapLatest: <span class="hljs-variable">$it</span>"</span>) }
}
</code></pre>
<h4 data-id="heading-46">示例 9：StateFlow 与 SharedFlow</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">import</span> kotlinx.coroutines.*
<span class="hljs-keyword">import</span> kotlinx.coroutines.flow.*

<span class="hljs-comment">/**
 * StateFlow：状态持有流
 * 特点：
 * 1. 始终有值
 * 2. 新订阅者会立即收到最新值
 * 3. 只有值变化时才会发射（去重）
 */</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">StateFlowExample</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> _state = MutableStateFlow(<span class="hljs-number">0</span>)
    <span class="hljs-keyword">val</span> state: StateFlow&lt;<span class="hljs-built_in">Int</span>&gt; = _state

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span></span> {
        _state.value++
    }
}

<span class="hljs-comment">/**
 * SharedFlow：事件流
 * 特点：
 * 1. 不持有初始值
 * 2. 可以配置重放数量和缓冲区大小
 * 3. 适合事件场景
 */</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">SharedFlowExample</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> _events = MutableSharedFlow&lt;<span class="hljs-built_in">Int</span>&gt;(
        replay = <span class="hljs-number">1</span>,              <span class="hljs-comment">// 重放数量</span>
        onBufferOverflow = BufferOverflow.DROP_OLDEST <span class="hljs-comment">// 缓冲策略</span>
    )
    <span class="hljs-keyword">val</span> events: SharedFlow&lt;<span class="hljs-built_in">Int</span>&gt; = _events

    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sendEvent</span><span class="hljs-params">(value: <span class="hljs-type">Int</span>)</span></span> {
        _events.emit(value)
    }
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> = runBlocking {
    <span class="hljs-comment">// StateFlow 示例</span>
    <span class="hljs-keyword">val</span> stateFlow = MutableStateFlow(<span class="hljs-number">0</span>)

    launch {
        stateFlow.collect { value -&gt;
            println(<span class="hljs-string">"StateFlow 收到: <span class="hljs-variable">$value</span>"</span>)
        }
    }

    delay(<span class="hljs-number">100</span>)
    stateFlow.value = <span class="hljs-number">1</span>
    stateFlow.value = <span class="hljs-number">2</span>
    stateFlow.value = <span class="hljs-number">2</span> <span class="hljs-comment">// 重复值不会发射</span>

    <span class="hljs-comment">// SharedFlow 示例</span>
    <span class="hljs-keyword">val</span> sharedFlow = MutableSharedFlow&lt;<span class="hljs-built_in">Int</span>&gt;(
        replay = <span class="hljs-number">2</span>
    )

    <span class="hljs-comment">// 先发送一些值</span>
    sharedFlow.emit(<span class="hljs-number">1</span>)
    sharedFlow.emit(<span class="hljs-number">2</span>)

    delay(<span class="hljs-number">100</span>)

    <span class="hljs-comment">// 新订阅者会收到 replay 的值</span>
    launch {
        sharedFlow.collect { value -&gt;
            println(<span class="hljs-string">"SharedFlow 收到: <span class="hljs-variable">$value</span>"</span>)
        }
    }

    delay(<span class="hljs-number">100</span>)
    sharedFlow.emit(<span class="hljs-number">3</span>)
}
</code></pre>
<h4 data-id="heading-47">示例 10：Flow 的终端操作符</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">import</span> kotlinx.coroutines.*
<span class="hljs-keyword">import</span> kotlinx.coroutines.flow.*

<span class="hljs-comment">/**
 * Flow 终端操作符
 */</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> = runBlocking {
    <span class="hljs-comment">// toList：收集为列表</span>
    <span class="hljs-keyword">val</span> list = flowOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).toList()
    println(<span class="hljs-string">"toList: <span class="hljs-variable">$list</span>"</span>)

    <span class="hljs-comment">// toSet：收集为集合</span>
    <span class="hljs-keyword">val</span> <span class="hljs-keyword">set</span> = flowOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).toSet()
    println(<span class="hljs-string">"toSet: <span class="hljs-variable">$set</span>"</span>)

    <span class="hljs-comment">// first：取第一个值</span>
    <span class="hljs-keyword">val</span> first = flowOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).first()
    println(<span class="hljs-string">"first: <span class="hljs-variable">$first</span>"</span>)

    <span class="hljs-comment">// single：确保只有一个值</span>
    <span class="hljs-keyword">val</span> single = flowOf(<span class="hljs-number">42</span>).single()
    println(<span class="hljs-string">"single: <span class="hljs-variable">$single</span>"</span>)

    <span class="hljs-comment">// reduce：归约</span>
    <span class="hljs-keyword">val</span> sum = flowOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>).reduce { acc, value -&gt; acc + value }
    println(<span class="hljs-string">"reduce sum: <span class="hljs-variable">$sum</span>"</span>)

    <span class="hljs-comment">// fold：带初始值的归约</span>
    <span class="hljs-keyword">val</span> product = flowOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>).fold(<span class="hljs-number">1</span>) { acc, value -&gt; acc * value }
    println(<span class="hljs-string">"fold product: <span class="hljs-variable">$product</span>"</span>)

    <span class="hljs-comment">// collect：收集所有值</span>
    flowOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).collect { println(<span class="hljs-string">"collect: <span class="hljs-variable">$it</span>"</span>) }

    <span class="hljs-comment">// launchIn：在协程作用域中收集</span>
    flow {
        repeat(<span class="hljs-number">3</span>) {
            delay(<span class="hljs-number">100</span>)
            emit(it)
        }
    }
    .onEach { println(<span class="hljs-string">"launchIn: <span class="hljs-variable">$it</span>"</span>) }
    .launchIn(<span class="hljs-keyword">this</span>) <span class="hljs-comment">// 在 this 作用域中启动</span>
}
</code></pre>
<hr/>
<h3 data-id="heading-48">Flow 源码解析</h3>
<h4 data-id="heading-49">1. Flow 接口定义</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">/**
 * Flow 接口定义
 * Flow 是一个冷流，只有在收集时才会执行
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Flow</span>&lt;<span class="hljs-type">out T</span>&gt; {
    <span class="hljs-comment">/**
     * 收集流发出的值
     * <span class="hljs-doctag">@param</span> collector 收集器，接收发出的值
     */</span>
    <span class="hljs-meta">@Suppress(<span class="hljs-string">"UNCHECKED_CAST"</span>)</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">collect</span><span class="hljs-params">(collector: <span class="hljs-type">FlowCollector</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span>
}

<span class="hljs-comment">/**
 * FlowCollector 接口
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">FlowCollector</span>&lt;<span class="hljs-type">in T</span>&gt; {
    <span class="hljs-comment">/**
     * 发射一个值到流
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">emit</span><span class="hljs-params">(value: <span class="hljs-type">T</span>)</span></span>
}
</code></pre>
<p><strong>关键点：</strong></p>
<ul>
<li>Flow 接口只有一个 <code>collect</code> 方法</li>
<li>Flow 是只读的，不支持发射操作</li>
<li>使用冷流模式：不收集不执行</li>
</ul>
<h4 data-id="heading-50">2. flow 构建器实现</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">/**
 * flow 构建器实现
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">flow</span><span class="hljs-params">(
    <span class="hljs-meta">@BuilderInference</span> block: <span class="hljs-type">suspend</span> <span class="hljs-type">FlowCollector</span>&lt;<span class="hljs-type">T</span>&gt;.() -&gt; <span class="hljs-type">Unit</span>
)</span></span>: Flow&lt;T&gt; = SafeFlow(block)

<span class="hljs-comment">/**
 * SafeFlow 内部实现
 */</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SafeFlow</span>&lt;<span class="hljs-type">T</span>&gt;(
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> block: <span class="hljs-keyword">suspend</span> FlowCollector&lt;T&gt;.() -&gt; <span class="hljs-built_in">Unit</span>
) : AbstractFlow&lt;T&gt;() {

    <span class="hljs-comment">/**
     * collectSafely 实现实际的收集逻辑
     */</span>
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">collectSafely</span><span class="hljs-params">(collector: <span class="hljs-type">FlowCollector</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> {
        <span class="hljs-comment">// 调用用户定义的 block，在 collector 上执行</span>
        collector.block()
    }
}

<span class="hljs-comment">/**
 * AbstractFlow 抽象类
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractFlow</span>&lt;<span class="hljs-type">T</span>&gt; : <span class="hljs-type">Flow</span>&lt;<span class="hljs-type">T</span>&gt; {

    <span class="hljs-comment">/**
     * collect 实现
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">collect</span><span class="hljs-params">(collector: <span class="hljs-type">FlowCollector</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> {
        <span class="hljs-comment">// 创建收集上下文</span>
        <span class="hljs-keyword">val</span> collectContext = collector <span class="hljs-keyword">as</span>? SafeCollector ?: error(<span class="hljs-string">"..."</span>)

        <span class="hljs-comment">// 调用子类实现的 collectSafely</span>
        collectSafely(collector)
    }

    <span class="hljs-comment">/**
     * 子类需要实现的安全收集方法
     */</span>
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">collectSafely</span><span class="hljs-params">(collector: <span class="hljs-type">FlowCollector</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span>
}
</code></pre>
<p><strong>工作原理：</strong></p>
<ul>
<li><code>flow { }</code> 创建一个 <code>SafeFlow</code> 实例</li>
<li><code>SafeFlow</code> 保存用户提供的 lambda</li>
<li>调用 <code>collect</code> 时执行 lambda，开始发射数据</li>
</ul>
<h4 data-id="heading-51">3. Flow 操作符链实现</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">/**
 * 操作符链的核心：每个操作符都返回一个新的 Flow
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T, R&gt;</span> Flow<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">map</span><span class="hljs-params">(
    <span class="hljs-keyword">crossinline</span> transform: <span class="hljs-type">suspend</span> (<span class="hljs-type">value</span>: <span class="hljs-type">T</span>) -&gt; <span class="hljs-type">R</span>
)</span></span>: Flow&lt;R&gt; = flow {
    <span class="hljs-comment">// this 是 FlowCollector&lt;R&gt;（新流的 collector）</span>
    collect { value -&gt;
        <span class="hljs-comment">// 收集上游的值</span>
        emit(transform(value)) <span class="hljs-comment">// 转换后发射到新流</span>
    }
}

<span class="hljs-comment">/**
 * filter 操作符实现
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> Flow<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">filter</span><span class="hljs-params">(
    predicate: <span class="hljs-type">suspend</span> (<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">Boolean</span>
)</span></span>: Flow&lt;T&gt; = flow {
    collect { value -&gt;
        <span class="hljs-keyword">if</span> (predicate(value)) {
            emit(value) <span class="hljs-comment">// 符合条件才发射</span>
        }
    }
}

<span class="hljs-comment">/**
 * 使用示例
 */</span>
<span class="hljs-keyword">val</span> flow = flowOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
    .map { it * <span class="hljs-number">2</span> }     <span class="hljs-comment">// 返回新 Flow1</span>
    .filter { it &gt; <span class="hljs-number">2</span> }  <span class="hljs-comment">// 返回新 Flow2</span>

<span class="hljs-comment">// 等价于：</span>
<span class="hljs-keyword">val</span> flow2 = flow {
    flowOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).collect { value -&gt;
        <span class="hljs-keyword">val</span> transformed = value * <span class="hljs-number">2</span>
        <span class="hljs-keyword">if</span> (transformed &gt; <span class="hljs-number">2</span>) {
            emit(transformed)
        }
    }
}
</code></pre>
<p><strong>关键点：</strong></p>
<ul>
<li>每个操作符创建新的 Flow 实例</li>
<li>操作符内部通过 <code>collect</code> 收集上游</li>
<li>转换后通过 <code>emit</code> 发射到下游</li>
<li>形成操作符链：<code>collect</code> 链式调用</li>
</ul>
<h4 data-id="heading-52">4. flowOn 线程切换原理</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">/**
 * flowOn 实现线程切换
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> Flow<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">flowOn</span><span class="hljs-params">(
    context: <span class="hljs-type">CoroutineContext</span>
)</span></span>: Flow&lt;T&gt; = flow {
    <span class="hljs-comment">// 创建一个调度器</span>
    <span class="hljs-keyword">val</span> dispatcher = context[ContinuationInterceptor] <span class="hljs-keyword">as</span>? CoroutineDispatcher

    <span class="hljs-comment">// 在上游使用新上下文收集</span>
    coroutineScope {
        <span class="hljs-comment">// 切换到指定上下文</span>
        withContext(context) {
            <span class="hljs-comment">// 在新线程中收集上游</span>
            <span class="hljs-keyword">this</span><span class="hljs-symbol">@flow</span>.collect { value -&gt;
                <span class="hljs-comment">// 发射到下游（下游在原来的线程）</span>
                emit(value)
            }
        }
    }
}

<span class="hljs-comment">/**
 * 更精确的实现（简化版）
 */</span>
<span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FlowOnFlow</span>&lt;<span class="hljs-type">T</span>&gt;(
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> upstream: Flow&lt;T&gt;,
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> context: CoroutineContext
) : Flow&lt;T&gt; {

    <span class="hljs-keyword">override</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">collect</span><span class="hljs-params">(collector: <span class="hljs-type">FlowCollector</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> {
        <span class="hljs-comment">// 上游使用新上下文</span>
        upstream.collect(<span class="hljs-keyword">object</span> : FlowCollector&lt;T&gt; {
            <span class="hljs-keyword">override</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">emit</span><span class="hljs-params">(value: <span class="hljs-type">T</span>)</span></span> {
                <span class="hljs-comment">// 切换上下文发射</span>
                withContext(context) {
                    collector.emit(value)
                }
            }
        })
    }
}
</code></pre>
<p><strong>flowOn 工作原理：</strong></p>
<ol>
<li><code>flowOn</code> 在调用位置之前的所有操作符使用新上下文</li>
<li><code>flowOn</code> 之后的所有操作符使用原上下文</li>
<li>通过缓冲机制实现上下游解耦</li>
</ol>
<h4 data-id="heading-53">5. 背压处理机制</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">/**
 * buffer 操作符实现
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> Flow<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">buffer</span><span class="hljs-params">(
    capacity: <span class="hljs-type">Int</span> = BUFFERED
)</span></span>: Flow&lt;T&gt; = channelFlow {
    <span class="hljs-comment">// 创建 Channel 作为缓冲区</span>
    <span class="hljs-keyword">val</span> channel = Channel&lt;T&gt;(capacity)

    <span class="hljs-comment">// 上游协程：快速发射到 Channel</span>
    launch {
        collect { value -&gt;
            channel.send(value)
        }
        channel.close()
    }

    <span class="hljs-comment">// 下游：从 Channel 接收</span>
    channel.consumeEach { value -&gt;
        send(value)
    }
}

<span class="hljs-comment">/**
 * conflate 操作符：只保留最新值
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> Flow<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">conflate</span><span class="hljs-params">()</span></span>: Flow&lt;T&gt; = buffer(CONFLATED)

<span class="hljs-comment">/**
 * collectLatest 操作符：收到新值取消旧的处理
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> Flow<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">collectLatest</span><span class="hljs-params">(
    action: <span class="hljs-type">suspend</span> (<span class="hljs-type">value</span>: <span class="hljs-type">T</span>) -&gt; <span class="hljs-type">Unit</span>
)</span></span> = flow {
    <span class="hljs-comment">// 当前任务的 Job</span>
    <span class="hljs-keyword">var</span> currentJob: Job? = <span class="hljs-literal">null</span>

    collect { value -&gt;
        <span class="hljs-comment">// 取消之前的任务</span>
        currentJob?.cancel()
        <span class="hljs-comment">// 启动新任务</span>
        currentJob = launch {
            action(value)
        }
    }
}.collect()
</code></pre>
<p><strong>背压处理策略：</strong></p>
<ul>
<li><code>buffer</code>：缓冲区满时挂起上游</li>
<li><code>conflate</code>：缓冲区满时丢弃最旧的值</li>
<li><code>collectLatest</code>：缓冲区满时取消当前处理</li>
</ul>
<h4 data-id="heading-54">6. SharedFlow 实现原理</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">/**
 * SharedFlow 接口
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">SharedFlow</span>&lt;<span class="hljs-type">out T</span>&gt; : <span class="hljs-type">Flow</span>&lt;<span class="hljs-type">T</span>&gt; {
    <span class="hljs-keyword">val</span> replayCache: List&lt;T&gt;
}

<span class="hljs-comment">/**
 * MutableSharedFlow 实现
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MutableSharedFlow</span>&lt;<span class="hljs-type">T</span>&gt; : <span class="hljs-type">SharedFlow</span>&lt;<span class="hljs-type">T</span>&gt;, <span class="hljs-type">FlowCollector</span>&lt;<span class="hljs-type">T</span>&gt; {
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">emit</span><span class="hljs-params">(value: <span class="hljs-type">T</span>)</span></span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">tryEmit</span><span class="hljs-params">(value: <span class="hljs-type">T</span>)</span></span>: <span class="hljs-built_in">Boolean</span>
}

<span class="hljs-comment">/**
 * SharedFlow 内部实现（简化）
 */</span>
<span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SharedFlowImpl</span>&lt;<span class="hljs-type">T</span>&gt;(
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> replayCapacity: <span class="hljs-built_in">Int</span>,
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> bufferCapacity: <span class="hljs-built_in">Int</span>,
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> onBufferOverflow: BufferOverflow
) : MutableSharedFlow&lt;T&gt; {

    <span class="hljs-comment">// 订阅者列表</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> collectors = mutableListOf&lt;SharedFlowCollector&gt;()

    <span class="hljs-comment">// 缓冲区</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> buffer = ArrayDeque&lt;Any?&gt;()

    <span class="hljs-comment">// 重放缓存</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> replayCache = ArrayDeque&lt;Any?&gt;()

    <span class="hljs-keyword">override</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">emit</span><span class="hljs-params">(value: <span class="hljs-type">T</span>)</span></span> {
        synchronized(<span class="hljs-keyword">this</span>) {
            <span class="hljs-comment">// 添加到重放缓存</span>
            <span class="hljs-keyword">if</span> (replayCapacity &gt; <span class="hljs-number">0</span>) {
                replayCache.addLast(value)
                <span class="hljs-keyword">if</span> (replayCache.size &gt; replayCapacity) {
                    replayCache.removeFirst()
                }
            }

            <span class="hljs-comment">// 发射给所有订阅者</span>
            collectors.forEach { collector -&gt;
                collector.emit(value)
            }
        }
    }

    <span class="hljs-keyword">override</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">collect</span><span class="hljs-params">(collector: <span class="hljs-type">FlowCollector</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> {
        <span class="hljs-keyword">val</span> sharedCollector = SharedFlowCollector(collector)
        collectors.add(sharedCollector)

        <span class="hljs-comment">// 发送重放缓存</span>
        replayCache.forEach { value -&gt;
            collector.emit(value <span class="hljs-keyword">as</span> T)
        }

        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 等待新值</span>
            sharedCollector.wait()
        } <span class="hljs-keyword">finally</span> {
            collectors.remove(sharedCollector)
        }
    }
}
</code></pre>
<p><strong>SharedFlow 工作原理：</strong></p>
<ul>
<li>维护一个订阅者列表</li>
<li>每个 <code>emit</code> 广播给所有订阅者</li>
<li>使用 <code>replayCache</code> 缓存最近的值</li>
</ul>
<h4 data-id="heading-55">7. StateFlow 实现原理</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">/**
 * StateFlow 接口
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">StateFlow</span>&lt;<span class="hljs-type">out T</span>&gt; : <span class="hljs-type">SharedFlow</span>&lt;<span class="hljs-type">T</span>&gt; {
    <span class="hljs-keyword">val</span> value: T
}

<span class="hljs-comment">/**
 * MutableStateFlow 实现（简化）
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MutableStateFlow</span>&lt;<span class="hljs-type">T</span>&gt; : <span class="hljs-type">StateFlow</span>&lt;<span class="hljs-type">T</span>&gt;, <span class="hljs-type">MutableSharedFlow</span>&lt;<span class="hljs-type">T</span>&gt; {
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">var</span> value: T
}

<span class="hljs-comment">/**
 * StateFlow 内部实现
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StateFlowImpl</span>&lt;<span class="hljs-type">T</span>&gt;(
    initialValue: T
) : MutableStateFlow&lt;T&gt; {

    <span class="hljs-comment">// 当前值（volatile 保证可见性）</span>
    <span class="hljs-meta">@Volatile</span>
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">var</span> value: T = initialValue

    <span class="hljs-comment">// 订阅者集合</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> collectors = mutableSetOf&lt;StateFlowCollector&gt;()

    <span class="hljs-keyword">override</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">emit</span><span class="hljs-params">(newValue: <span class="hljs-type">T</span>)</span></span> {
        <span class="hljs-keyword">val</span> oldValue = value
        value = newValue

        <span class="hljs-comment">// 只有值变化时才通知订阅者</span>
        <span class="hljs-keyword">if</span> (oldValue != newValue) {
            synchronized(collectors) {
                collectors.forEach { collector -&gt;
                    collector.emit(newValue)
                }
            }
        }
    }

    <span class="hljs-keyword">override</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">collect</span><span class="hljs-params">(collector: <span class="hljs-type">FlowCollector</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> {
        <span class="hljs-keyword">val</span> stateCollector = StateFlowCollector(collector)

        <span class="hljs-comment">// 立即发送当前值</span>
        collector.emit(value)

        synchronized(collectors) {
            collectors.add(stateCollector)
        }

        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 等待新值</span>
            stateCollector.wait()
        } <span class="hljs-keyword">finally</span> {
            synchronized(collectors) {
                collectors.remove(stateCollector)
            }
        }
    }
}
</code></pre>
<p><strong>StateFlow 特点：</strong></p>
<ul>
<li>始终持有当前值</li>
<li>新订阅者立即收到当前值</li>
<li>值相同时不重复发射</li>
</ul>
<h4 data-id="heading-56">8. Flow 的异常处理机制</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">/**
 * catch 操作符实现
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> Flow<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">catch</span><span class="hljs-params">(
    action: <span class="hljs-type">suspend</span> <span class="hljs-type">FlowCollector</span>&lt;<span class="hljs-type">T</span>&gt;.(<span class="hljs-type">cause</span>: <span class="hljs-type">Throwable</span>) -&gt; <span class="hljs-type">Unit</span>
)</span></span>: Flow&lt;T&gt; = flow {
    <span class="hljs-keyword">try</span> {
        collect { value -&gt;
            emit(value)
        }
    } <span class="hljs-keyword">catch</span> (e: Throwable) {
        <span class="hljs-comment">// 在收集器上执行异常处理</span>
        action(e)
    }
}

<span class="hljs-comment">/**
 * onCompletion 操作符实现
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> Flow<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">onCompletion</span><span class="hljs-params">(
    action: <span class="hljs-type">suspend</span> <span class="hljs-type">FlowCollector</span>&lt;<span class="hljs-type">T</span>&gt;.(<span class="hljs-type">cause</span>: <span class="hljs-type">Throwable</span>?) -&gt; <span class="hljs-type">Unit</span>
)</span></span>: Flow&lt;T&gt; = flow {
    <span class="hljs-keyword">try</span> {
        collect { value -&gt;
            emit(value)
        }
    } <span class="hljs-keyword">finally</span> {
        <span class="hljs-comment">// 无论成功还是异常都执行</span>
        action(<span class="hljs-literal">null</span>)
    }
}

<span class="hljs-comment">/**
 * retryWhen 操作符：重试机制
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> Flow<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">retryWhen</span><span class="hljs-params">(
    predicate: <span class="hljs-type">suspend</span> (<span class="hljs-type">cause</span>: <span class="hljs-type">Throwable</span>, <span class="hljs-type">attempt</span>: <span class="hljs-type">Long</span>) -&gt; <span class="hljs-type">Boolean</span>
)</span></span>: Flow&lt;T&gt; = flow {
    <span class="hljs-keyword">var</span> attempt = <span class="hljs-number">0L</span>
    <span class="hljs-keyword">var</span> shallRetry: <span class="hljs-built_in">Boolean</span>

    <span class="hljs-keyword">do</span> {
        shallRetry = <span class="hljs-literal">false</span>
        <span class="hljs-keyword">try</span> {
            collect { value -&gt;
                emit(value)
            }
        } <span class="hljs-keyword">catch</span> (e: Throwable) {
            <span class="hljs-keyword">if</span> (predicate(e, attempt)) {
                attempt++
                shallRetry = <span class="hljs-literal">true</span>
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">throw</span> e
            }
        }
    } <span class="hljs-keyword">while</span> (shallRetry)
}
</code></pre>
<hr/>
<h2 data-id="heading-57">第三部分：协程与 Flow 对比</h2>
<h3 data-id="heading-58">核心差异</h3>
<h4 data-id="heading-59">1. 设计理念</h4>






























<table><thead><tr><th>特性</th><th>协程 (Coroutine)</th><th>Flow</th></tr></thead><tbody><tr><td><strong>用途</strong></td><td>执行单个异步任务</td><td>处理异步数据流</td></tr><tr><td><strong>返回值</strong></td><td>单个结果</td><td>多个值的序列</td></tr><tr><td><strong>执行模式</strong></td><td>热启动（创建即运行）</td><td>冷启动（收集时才运行）</td></tr><tr><td><strong>模型</strong></td><td>函数式（输入 -&gt; 输出）</td><td>流式（连续的数据流）</td></tr></tbody></table>
<h4 data-id="heading-60">2. 代码对比</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">import</span> kotlinx.coroutines.*
<span class="hljs-keyword">import</span> kotlinx.coroutines.flow.*

<span class="hljs-comment">/**
 * 协程 vs Flow 对比
 */</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> = runBlocking {
    <span class="hljs-comment">// ========================================</span>
    <span class="hljs-comment">// 场景1：获取单个结果</span>
    <span class="hljs-comment">// ========================================</span>

    <span class="hljs-comment">// 使用协程：适合单个异步操作</span>
    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fetchUser</span><span class="hljs-params">()</span></span>: User {
        delay(<span class="hljs-number">100</span>)
        <span class="hljs-keyword">return</span> User(<span class="hljs-string">"张三"</span>)
    }

    <span class="hljs-keyword">val</span> user = fetchUser() <span class="hljs-comment">// 一次调用，一次结果</span>
    println(<span class="hljs-string">"协程结果: <span class="hljs-variable">$user</span>"</span>)

    <span class="hljs-comment">// 使用 Flow：即使单个结果也用流</span>
    <span class="hljs-keyword">val</span> userFlow: Flow&lt;User&gt; = flow {
        emit(User(<span class="hljs-string">"张三"</span>))
    }

    userFlow.collect { user -&gt;
        println(<span class="hljs-string">"Flow 结果: <span class="hljs-variable">$user</span>"</span>)
    }

    <span class="hljs-comment">// ========================================</span>
    <span class="hljs-comment">// 场景2：处理多个值</span>
    <span class="hljs-comment">// ========================================</span>

    <span class="hljs-comment">// 使用协程：需要返回 List</span>
    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fetchUsers</span><span class="hljs-params">()</span></span>: List&lt;User&gt; {
        delay(<span class="hljs-number">100</span>)
        <span class="hljs-keyword">return</span> listOf(User(<span class="hljs-string">"张三"</span>), User(<span class="hljs-string">"李四"</span>))
    }

    <span class="hljs-keyword">val</span> users = fetchUsers()
    users.forEach { println(<span class="hljs-string">"协程批量: <span class="hljs-variable">$it</span>"</span>) }

    <span class="hljs-comment">// 使用 Flow：自然地处理多个值</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">userFlow</span><span class="hljs-params">()</span></span>: Flow&lt;User&gt; = flow {
        repeat(<span class="hljs-number">10</span>) { i -&gt;
            delay(<span class="hljs-number">50</span>)
            emit(User(<span class="hljs-string">"用户<span class="hljs-variable">$i</span>"</span>))
        }
    }

    userFlow().collect { user -&gt;
        println(<span class="hljs-string">"Flow 流式: <span class="hljs-variable">$user</span>"</span>)
    }

    <span class="hljs-comment">// ========================================</span>
    <span class="hljs-comment">// 场景3：实时数据更新</span>
    <span class="hljs-comment">// ========================================</span>

    <span class="hljs-comment">// 协程方式：需要轮询或回调</span>
    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">pollForUpdates</span><span class="hljs-params">()</span></span>: List&lt;User&gt; {
        <span class="hljs-comment">// 需要定时轮询</span>
        delay(<span class="hljs-number">1000</span>)
        <span class="hljs-keyword">return</span> fetchUsers()
    }

    <span class="hljs-comment">// Flow 方式：自然地推送更新</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">userUpdates</span><span class="hljs-params">()</span></span>: Flow&lt;User&gt; = callbackFlow {
        <span class="hljs-comment">// 模拟实时更新</span>
        repeat(<span class="hljs-number">10</span>) { i -&gt;
            delay(<span class="hljs-number">500</span>)
            trySend(User(<span class="hljs-string">"更新<span class="hljs-variable">$i</span>"</span>))
        }
        close()
    }

    userUpdates().collect { update -&gt;
        println(<span class="hljs-string">"实时更新: <span class="hljs-variable">$update</span>"</span>)
    }
}
</code></pre>
<h3 data-id="heading-61">适用场景对比</h3>
<h4 data-id="heading-62">协程适合的场景</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">import</span> kotlinx.coroutines.*

<span class="hljs-comment">/**
 * 协程最佳实践场景
 */</span>
<span class="hljs-keyword">object</span> CoroutineUseCases {

    <span class="hljs-comment">// 1. 网络请求（单次）</span>
    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fetchUserProfile</span><span class="hljs-params">(userId: <span class="hljs-type">String</span>)</span></span>: Profile {
        <span class="hljs-keyword">return</span> withContext(Dispatchers.IO) {
            <span class="hljs-comment">// 网络调用</span>
            Profile(<span class="hljs-string">"用户"</span>, <span class="hljs-number">25</span>)
        }
    }

    <span class="hljs-comment">// 2. 数据库操作（单次）</span>
    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">saveUser</span><span class="hljs-params">(user: <span class="hljs-type">User</span>)</span></span> {
        withContext(Dispatchers.IO) {
            <span class="hljs-comment">// 数据库插入</span>
            database.insert(user)
        }
    }

    <span class="hljs-comment">// 3. 并发执行多个独立任务</span>
    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">loadDashboard</span><span class="hljs-params">()</span></span>: Dashboard {
        coroutineScope {
            <span class="hljs-keyword">val</span> profile = async { fetchUserProfile(<span class="hljs-string">"123"</span>) }
            <span class="hljs-keyword">val</span> orders = async { fetchUserOrders(<span class="hljs-string">"123"</span>) }
            <span class="hljs-keyword">val</span> notifications = async { fetchNotifications() }

            Dashboard(profile.await(), orders.await(), notifications.await())
        }
    }

    <span class="hljs-comment">// 4. 批量处理</span>
    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">processBatch</span><span class="hljs-params">(items: <span class="hljs-type">List</span>&lt;<span class="hljs-type">Item</span>&gt;)</span></span>: List&lt;Result&gt; {
        <span class="hljs-keyword">return</span> withContext(Dispatchers.Default) {
            items.map { item -&gt;
                processItem(item) <span class="hljs-comment">// CPU 密集型计算</span>
            }
        }
    }
}
</code></pre>
<h4 data-id="heading-63">Flow 适合的场景</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">import</span> kotlinx.coroutines.*
<span class="hljs-keyword">import</span> kotlinx.coroutines.flow.*

<span class="hljs-comment">/**
 * Flow 最佳实践场景
 */</span>
<span class="hljs-keyword">object</span> FlowUseCases {

    <span class="hljs-comment">// 1. 实时数据流（WebSocket、传感器）</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">websocketUpdates</span><span class="hljs-params">()</span></span>: Flow&lt;Message&gt; = callbackFlow {
        <span class="hljs-keyword">val</span> socket = WebSocket { message -&gt;
            trySend(message) <span class="hljs-comment">// 实时推送</span>
        }

        awaitClose { socket.close() }
    }

    <span class="hljs-comment">// 2. UI 事件流</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">clickEvents</span><span class="hljs-params">(view: <span class="hljs-type">View</span>)</span></span>: Flow&lt;ClickEvent&gt; = callbackFlow {
        <span class="hljs-keyword">val</span> listener = View.OnClickListener { event -&gt;
            trySend(ClickEvent(event))
        }

        view.setOnClickListener(listener)
        awaitClose { view.setOnClickListener(<span class="hljs-literal">null</span>) }
    }

    <span class="hljs-comment">// 3. 分页加载</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">paginatedNews</span><span class="hljs-params">()</span></span>: Flow&lt;Article&gt; = flow {
        <span class="hljs-keyword">var</span> page = <span class="hljs-number">1</span>
        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
            <span class="hljs-keyword">val</span> articles = fetchArticlesPage(page)
            articles.forEach { emit(it) }
            <span class="hljs-keyword">if</span> (articles.isEmpty()) <span class="hljs-keyword">break</span>
            page++
        }
    }

    <span class="hljs-comment">// 4. 数据库变化监听</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">observeUsers</span><span class="hljs-params">()</span></span>: Flow&lt;User&gt; = callbackFlow {
        <span class="hljs-keyword">val</span> observer = <span class="hljs-keyword">object</span> : DatabaseObserver&lt;User&gt; {
            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onChange</span><span class="hljs-params">(<span class="hljs-keyword">data</span>: <span class="hljs-type">User</span>)</span></span> {
                trySend(<span class="hljs-keyword">data</span>)
            }
        }

        database.registerObserver(observer)
        awaitClose { database.unregisterObserver(observer) }
    }

    <span class="hljs-comment">// 5. 搜索防抖</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">search</span><span class="hljs-params">(queryFlow: <span class="hljs-type">Flow</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span>: Flow&lt;Result&gt; =
        queryFlow
            .debounce(<span class="hljs-number">300</span>)                      <span class="hljs-comment">// 防抖</span>
            .filter { it.length &gt;= <span class="hljs-number">2</span> }          <span class="hljs-comment">// 最小长度</span>
            .distinctUntilChanged()             <span class="hljs-comment">// 去重</span>
            .map { query -&gt; performSearch(query) }
            .<span class="hljs-keyword">catch</span> { e -&gt; emit(Result.Error(e)) }

    <span class="hljs-comment">// 6. StateFlow：UI 状态管理</span>
    <span class="hljs-keyword">class</span> <span class="hljs-title class_">ViewModel</span> {
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> _uiState = MutableStateFlow(UiState.Idle)
        <span class="hljs-keyword">val</span> uiState: StateFlow&lt;UiState&gt; = _uiState

        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">loadData</span><span class="hljs-params">()</span></span> {
            _uiState.value = UiState.Loading
            viewModelScope.launch {
                <span class="hljs-keyword">val</span> result = fetchData()
                _uiState.value = UiState.Success(result)
            }
        }
    }

    <span class="hljs-comment">// 7. SharedFlow：事件总线</span>
    <span class="hljs-keyword">object</span> EventBus {
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> _events = MutableSharedFlow&lt;Event&gt;()
        <span class="hljs-keyword">val</span> events: SharedFlow&lt;Event&gt; = _events

        <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sendEvent</span><span class="hljs-params">(event: <span class="hljs-type">Event</span>)</span></span> {
            _events.emit(event)
        }
    }
}
</code></pre>
<h3 data-id="heading-64">性能对比</h3>
<h4 data-id="heading-65">1. 内存开销</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">import</span> kotlinx.coroutines.*
<span class="hljs-keyword">import</span> kotlinx.coroutines.flow.*

<span class="hljs-comment">/**
 * 协程 vs Flow 性能对比
 */</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> = runBlocking {
    <span class="hljs-comment">// 协程：一次性加载所有数据到内存</span>
    <span class="hljs-keyword">val</span> time1 = measureTimeMillis {
        <span class="hljs-keyword">val</span> <span class="hljs-keyword">data</span> = loadAllData() <span class="hljs-comment">// 返回 List&lt;10000条&gt;</span>
        processList(<span class="hljs-keyword">data</span>)
    }
    println(<span class="hljs-string">"协程（一次性加载）: <span class="hljs-subst">${time1}</span>ms"</span>)

    <span class="hljs-comment">// Flow：流式处理，低内存占用</span>
    <span class="hljs-keyword">val</span> time2 = measureTimeMillis {
        dataFlow()
            .take(<span class="hljs-number">100</span>) <span class="hljs-comment">// 只处理前100条</span>
            .collect { item -&gt;
                processItem(item)
            }
    }
    println(<span class="hljs-string">"Flow（流式处理）: <span class="hljs-subst">${time2}</span>ms"</span>)
}

<span class="hljs-comment">// 模拟大数据集</span>
<span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">loadAllData</span><span class="hljs-params">()</span></span>: List&lt;<span class="hljs-built_in">Int</span>&gt; {
    <span class="hljs-keyword">return</span> (<span class="hljs-number">1.</span><span class="hljs-number">.10000</span>).toList()
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dataFlow</span><span class="hljs-params">()</span></span>: Flow&lt;<span class="hljs-built_in">Int</span>&gt; = flow {
    repeat(<span class="hljs-number">10000</span>) { emit(it) }
}
</code></pre>
<h4 data-id="heading-66">2. 背压处理</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">/**
 * 背压处理对比
 */</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> = runBlocking {
    <span class="hljs-comment">// 协程：需要手动实现背压</span>
    launch {
        <span class="hljs-keyword">val</span> channel = Channel&lt;<span class="hljs-built_in">Int</span>&gt;(capacity = <span class="hljs-number">10</span>)
        <span class="hljs-comment">// 生产者</span>
        launch {
            repeat(<span class="hljs-number">1000</span>) { i -&gt;
                channel.send(i) <span class="hljs-comment">// 满时挂起</span>
            }
            channel.close()
        }
        <span class="hljs-comment">// 消费者</span>
        launch {
            <span class="hljs-keyword">for</span> (value <span class="hljs-keyword">in</span> channel) {
                delay(<span class="hljs-number">100</span>) <span class="hljs-comment">// 慢速消费</span>
                println(<span class="hljs-string">"消费: <span class="hljs-variable">$value</span>"</span>)
            }
        }
    }

    <span class="hljs-comment">// Flow：内置背压支持</span>
    flow {
        repeat(<span class="hljs-number">1000</span>) { i -&gt;
            emit(i) <span class="hljs-comment">// 自动处理背压</span>
        }
    }
    .buffer(<span class="hljs-number">10</span>) <span class="hljs-comment">// 缓冲区</span>
    .conflate() <span class="hljs-comment">// 或只保留最新值</span>
    .collect { value -&gt;
        delay(<span class="hljs-number">100</span>)
        println(<span class="hljs-string">"Flow: <span class="hljs-variable">$value</span>"</span>)
    }
}
</code></pre>
<h3 data-id="heading-67">总结对比表</h3>

































































<table><thead><tr><th>维度</th><th>协程 (Coroutine)</th><th>Flow</th></tr></thead><tbody><tr><td><strong>返回类型</strong></td><td>单个值 <code>T</code></td><td>流 <code>Flow&lt;T&gt;</code></td></tr><tr><td><strong>执行时机</strong></td><td>立即执行</td><td>收集时执行（冷流）</td></tr><tr><td><strong>背压处理</strong></td><td>需要手动实现（Channel）</td><td>内置支持（buffer、conflate）</td></tr><tr><td><strong>操作符</strong></td><td>基本无操作符</td><td>丰富的操作符（map、filter 等）</td></tr><tr><td><strong>取消</strong></td><td><code>job.cancel()</code></td><td><code>collect</code> 协程取消</td></tr><tr><td><strong>异常处理</strong></td><td>try-catch</td><td>catch、onCompletion 操作符</td></tr><tr><td><strong>线程切换</strong></td><td><code>withContext</code></td><td><code>flowOn</code></td></tr><tr><td><strong>状态管理</strong></td><td>需要自己实现</td><td>StateFlow、SharedFlow</td></tr><tr><td><strong>适用场景</strong></td><td>单次异步任务</td><td>连续数据流、实时更新</td></tr><tr><td><strong>学习曲线</strong></td><td>简单</td><td>相对复杂</td></tr><tr><td><strong>性能</strong></td><td>单次操作更轻量</td><td>流式处理更高效</td></tr></tbody></table>
<h3 data-id="heading-68">选择建议</h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">/**
 * 选择指南
 */</span>
<span class="hljs-keyword">object</span> ChoiceGuide {

    <span class="hljs-comment">// ✅ 使用协程的场景：</span>
    <span class="hljs-comment">// 1. 单次网络请求</span>
    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getUser</span><span class="hljs-params">(id: <span class="hljs-type">String</span>)</span></span>: User

    <span class="hljs-comment">// 2. 数据库 CRUD 操作</span>
    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">insertUser</span><span class="hljs-params">(user: <span class="hljs-type">User</span>)</span></span>

    <span class="hljs-comment">// 3. 文件读写</span>
    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">readFile</span><span class="hljs-params">(path: <span class="hljs-type">String</span>)</span></span>: ByteArray

    <span class="hljs-comment">// 4. 并发执行多个独立任务</span>
    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">loadAll</span><span class="hljs-params">()</span></span>: Data = coroutineScope {
        <span class="hljs-keyword">val</span> a = async { loadA() }
        <span class="hljs-keyword">val</span> b = async { loadB() }
        Data(a.await(), b.await())
    }

    <span class="hljs-comment">// ✅ 使用 Flow 的场景：</span>
    <span class="hljs-comment">// 1. 实时数据流</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">observeMessages</span><span class="hljs-params">()</span></span>: Flow&lt;Message&gt;

    <span class="hljs-comment">// 2. 分页加载</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">loadPages</span><span class="hljs-params">()</span></span>: Flow&lt;Item&gt;

    <span class="hljs-comment">// 3. 搜索框防抖</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">search</span><span class="hljs-params">(query: <span class="hljs-type">Flow</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span>: Flow&lt;Result&gt;

    <span class="hljs-comment">// 4. UI 状态管理</span>
    <span class="hljs-keyword">val</span> uiState: StateFlow&lt;UiState&gt;

    <span class="hljs-comment">// 5. 事件总线</span>
    <span class="hljs-keyword">val</span> events: SharedFlow&lt;Event&gt;

    <span class="hljs-comment">// 6. 数据库变化监听</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">observeUsers</span><span class="hljs-params">()</span></span>: Flow&lt;User&gt;

    <span class="hljs-comment">// 7. 定时任务</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">ticker</span><span class="hljs-params">()</span></span>: Flow&lt;<span class="hljs-built_in">Unit</span>&gt; = flow {
        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
            emit(<span class="hljs-built_in">Unit</span>)
            delay(<span class="hljs-number">1000</span>)
        }
    }

    <span class="hljs-comment">// ✅ 两者结合使用：</span>
    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">loadAndUpdate</span><span class="hljs-params">()</span></span> {
        viewModelScope.launch {
            <span class="hljs-comment">// 协程：加载数据</span>
            <span class="hljs-keyword">val</span> users = fetchUsers()

            <span class="hljs-comment">// Flow：发送更新</span>
            usersFlow.emitAll(users.asFlow())
        }
    }
}
</code></pre>
<hr/>
<h3 data-id="heading-69">参考资源</h3>
<h4 data-id="heading-70">官方文档</h4>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fkotlinlang.org%2Fdocs%2Fcoroutines-overview.html" target="_blank" title="https://kotlinlang.org/docs/coroutines-overview.html" ref="nofollow noopener noreferrer">Kotlin 协程官方文档</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.android.com%2Fkotlin%2Fcoroutines" target="_blank" title="https://developer.android.com/kotlin/coroutines" ref="nofollow noopener noreferrer">Android 协程指南</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fkotlinlang.org%2Fdocs%2Fflow.html" target="_blank" title="https://kotlinlang.org/docs/flow.html" ref="nofollow noopener noreferrer">Kotlin Flow 官方文档</a></li>
</ul>
<h4 data-id="heading-71">推荐阅读</h4>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fbook.kotlincn.net%2Ftext%2Fcoroutines-basics.html" target="_blank" title="https://book.kotlincn.net/text/coroutines-basics.html" ref="nofollow noopener noreferrer">协程基础 - Kotlin 中文文档</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.android.com%2Fkotlin%2Fflow%2Fstateflow-and-sharedflow" target="_blank" title="https://developer.android.com/kotlin/flow/stateflow-and-sharedflow" ref="nofollow noopener noreferrer">StateFlow 和 SharedFlow - Android 官方</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fmy.oschina.net%2Femacs_9695949%2Fblog%2F19073966" target="_blank" title="https://my.oschina.net/emacs_9695949/blog/19073966" ref="nofollow noopener noreferrer">Kotlin 协程深度解析</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Flishuaiqi.top%2F2025%2F10%2F16%2Fkotlin%2Fkotlin-cotoutine-coroutine_flow_flowon%2F" target="_blank" title="https://lishuaiqi.top/2025/10/16/kotlin/kotlin-cotoutine-coroutine_flow_flowon/" ref="nofollow noopener noreferrer">Flow 线程切换原理</a></li>
</ul>
<hr/>
<blockquote>
<p><strong>结语</strong>：协程和 Flow 是 Kotlin 异步编程的两大支柱。协程适合处理单个异步任务，而 Flow 适合处理异步数据流。理解它们的差异并根据场景选择合适的工具，是编写高效 Kotlin 代码的关键。</p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[prompt 工程学习总结]]></title>    <link>https://juejin.cn/post/7596926832912220223</link>    <guid>https://juejin.cn/post/7596926832912220223</guid>    <pubDate>2026-01-19T10:05:03.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7596926832912220223" data-draft-id="7596865421612040246" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="prompt 工程学习总结"/> <meta itemprop="keywords" content="算法,人工智能"/> <meta itemprop="datePublished" content="2026-01-19T10:05:03.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="矮人三等"/> <meta itemprop="url" content="https://juejin.cn/user/4350105576808472"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            prompt 工程学习总结
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4350105576808472/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    矮人三等
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-19T10:05:03.000Z" title="Mon Jan 19 2026 10:05:03 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读17分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">1 提示词工程</h2>
<ol>
<li>
<p>Zero-Shot /  Few-Shot</p>
<ol>
<li>
<p>注：这个词语在学习gpt系列中 <a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2FLian_Ge_Blog%2Farticle%2Fdetails%2F156238343%3Fspm%3D1001.2014.3001.5502" target="_blank" title="https://blog.csdn.net/Lian_Ge_Blog/article/details/156238343?spm=1001.2014.3001.5502" ref="nofollow noopener noreferrer">gpt3</a> 的时候提及过，Zero-Shot/Few-Shot 的概念并非 GPT-3 首创，但 GPT-3 是首个让大语言模型（LLM）的 Zero/Few-Shot 能力大规模落地并引发行业关注的模型。</p>
</li>
<li>
<p><strong>Zero-Shot</strong> 依赖模型的通用知识，适合简单任务；</p>
</li>
<li>
<p><strong>Few-Shot</strong> 通过示例降低任务理解难度，适合复杂或特定场景 。</p>
</li>
<li>
<p>Zero-Shot：(零样本提示)：不给任何示例，直接用自然语言描述任务要求让模型来完成</p>
<ol>
<li>核心原理：利用模型预训练时学到的通用知识，映射新任务与已知概念的关联</li>
<li>使用场景：简单分类、基础文本生成、任务描述明确的场景</li>
</ol>
<pre><code class="hljs language-text" lang="text">示例:
提示词："将以下英文句子翻译成中文：'Hello, how are you?'"
模型输出："你好，最近怎么样？"
此场景中，模型未获得任何翻译示例，仅通过自身知识完成任务
</code></pre>
</li>
<li>
<p>Few-Shot(少样本提示)：在提示词中提供少量任务示例，帮助模型理解任务逻辑并生成答案 。</p>
<ol>
<li>核心原理：基于<strong>小样本归纳</strong>，让模型快速适配特定任务范式，降低微调成本</li>
<li>使用场景：数据稀缺的定制化任务、格式约束严格的输出（如结构化报告）</li>
</ol>
<pre><code class="hljs language-text" lang="text">请判断以下句子的情绪是「积极」还是「消极」：

示例1：今天的阳光特别好，心情也跟着明媚起来 → 积极
示例2：错过末班车，又淋了雨，真的太倒霉了 → 消极
示例3：新入手的书内容超精彩，熬夜都想读完 → 积极

现在请判断：
句子：这款新出的耳机音质超棒，佩戴也很舒服 → "积极"(模型输出)
</code></pre>
</li>
</ol>
</li>
<li>
<p>COT(Chain-of-Thought)：通过提示引导模型将复杂问题拆解为<strong>分步推理链条</strong>，逐步推导答案，而非直接给出结论。核心思想是让模型显式表达“思考过程”，类似人类解决问题时的逐步分析。
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ad0136a19a0e4db4ad92941db1e38f2d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55-u5Lq65LiJ562J:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769421902&amp;x-signature=GgSwXB6H7vUH1lrmcRuUkeT5Ro0%3D" alt="在这里插入图片描述" loading="lazy"/></p>
<ol>
<li>
<p>区别于传统的 Prompt 从输入直接到输出的映射 &lt;input——&gt;output&gt; 的方式，CoT 完成了从输入到思维链再到输出的映射，即 &lt;input——&gt;reasoning chain——&gt;output&gt;</p>
</li>
<li>
<p>使用场景：数学计算、逻辑推理、多步骤决策</p>
<pre><code class="hljs language-text" lang="text">普通提示：
问题：1个书架有3层，每层放5本书，共有多少本书？
答案：15本

cot 提示：
问题：1个书架有3层，每层放5本书，共有多少本书？
推理：
1. 每层5本书，3层的总书数 = 5 × 3
2. 5 × 3 = 15
答案：15本
</code></pre>
</li>
<li>
<p>一个完整的包含 CoT 的 Prompt 往往由指令（Instruction），逻辑依据（Rationale），示例（Exemplars）三部分组成</p>
<ol>
<li>一般而言指令用于描述问题并且告知大模型的输出格式</li>
<li>逻辑依据即指 CoT 的中间推理过程，可以包含问题的解决方案、中间推理步骤以及与问题相关的任何外部知识</li>
<li>示例则指以少样本的方式为大模型提供输入输出对的基本格式，每一个示例都包含：问题，推理过程与答案。</li>
</ol>
</li>
<li>
<p>零样本思维链（Zero-Shot CoT）：无需示例，仅通过提示词（如“请分步骤思考”）触发模型生成思维链。适用于快速引导模型进行推理。</p>
</li>
<li>
<p>少样本思维链（Few-Shot CoT）：提供少量带思维链的示例，让模型模仿示例结构进行推理。例如，先给出几个问题及其分解步骤，再让模型处理新问题</p>
</li>
</ol>
</li>
<li>
<p>ToT（Tree of Thought，思维树）:将问题求解视为<strong>树状搜索过程</strong>：模型生成多个可能的解题路径（分支），对每条路径的中间结果进行评估，选择最优分支继续探索，直至找到答案。
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a2919e84718342e0b8d27603d37c4cef~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55-u5Lq65LiJ562J:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769421902&amp;x-signature=Mj5u4d8Xz3KgRaWo0vgT74I22ak%3D" alt="在这里插入图片描述" loading="lazy"/></p>
<ol>
<li>在ToT中，为了帮助模型识别最有效的思维序列，系统使用了常用的搜索算法，比如广度优先搜索（BFS）和深度优先搜索（DFS）。
<ol>
<li>BFS:核心是 <strong>“层层推进”</strong>：先访问离起点最近的节点（当前层），再依次访问下一层的所有节点，像 “水波扩散” 一样。
<ol>
<li>核心数据结构：<strong>队列（Queue）</strong>（先进先出，类比排队取餐）。</li>
<li>通俗理解：找迷宫出口时，先搜完当前位置周围的所有路径，再往更远的地方搜。</li>
</ol>
</li>
<li>DFS:核心是 <strong>“一条路走到黑”</strong>：沿着一条路径一直走到尽头，再回溯（退回来）走其他未探索的路径。
<ol>
<li>核心数据结构：<strong>栈（Stack）</strong>（后进先出，类比摞起来的盘子）或<strong>递归</strong>（递归本质是调用栈，类比套娃）。</li>
<li>通俗理解：找迷宫出口时，先往一个方向走到死胡同，再回头换方向继续走。</li>
</ol>
</li>
</ol>
</li>
<li>使用场景：创意生成、复杂规划、多解问题</li>
<li>优势：
<ol>
<li>避免单一思维链的局限性，通过并行探索提升解题成功率。</li>
<li>适用于存在多个可行解的场景，可优化答案质量。</li>
<li>ToT的灵活性和适应性比 COT更强。</li>
</ol>
</li>
</ol>
</li>
<li>
<p>GoT（Graph-of-Thoughts，思维图谱）：将问题拆解为<strong>图结构</strong>，节点代表关键概念或中间结论，边代表概念间的关系（如因果关系、依赖关系）。模型通过遍历图节点，整合多源信息进行推理(不是很熟悉知识图谱，此处仅了解)。
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6a7dea6ad0464c7c84608b7192c53bba~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55-u5Lq65LiJ562J:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769421902&amp;x-signature=WC3n%2F9t4s8E%2BcnHzBGNB%2Fl6AJX0%3D" alt="在这里插入图片描述" loading="lazy"/></p>
<ol>
<li>使用场景：知识图谱构建、多源信息融合推理，复杂知识推理，跨领域问答</li>
<li>优势：
<ol>
<li>支持处理多维度、非线性的复杂关系，适合需要全局视角的任务。</li>
<li>可扩展性强，易于整合外部知识库。</li>
</ol>
</li>
</ol>
</li>
<li>
<p>PoT（Plan of Thought，思维规划）：强调<strong>预先制定解决问题的总体规划</strong>，将任务分解为明确的阶段或子目标，按计划逐步执行
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cc855d29dbed414a994517c5b92b4e82~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55-u5Lq65LiJ562J:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769421902&amp;x-signature=QK4KT1fu2Tq33fLalAkt07m72SI%3D" alt="在这里插入图片描述" loading="lazy"/></p>
<ol>
<li>PoT是将问答背后的推理过程公式化为一个<strong>可执行程序（Program）</strong>，将程序解释器输出作为最终答案的一部分。
<ol>
<li>思维程序（PoT）是一种独特的LLM推理方法。它不仅仅是生成自然语言答案，而是要求创建一个可执行程序，可以在Python等程序解释器上运行，从而产生实际的结果。这样，PoT的表达更加清晰、准确，尤其是对于需要进行数值计算的数学类型逻辑问题更是如此。</li>
<li>需要注意的是，PoT的程序执行不一定针对最终答案，而是可以作为最终答案的中间步骤的一部分。</li>
</ol>
</li>
<li>核心方法
<ol>
<li>分层规划：将任务分为高层目标（如“完成市场分析报告”）和低层子任务（如“数据收集→趋势分析→结论撰写”）。</li>
<li>时序约束：提示模型考虑任务的时间顺序和依赖关系（如“必须先完成A，才能进行B”）。</li>
<li>动态调整：在执行过程中根据反馈优化计划（如遇到障碍时切换子任务顺序）。</li>
</ol>
</li>
<li>使用场景：复杂数学运算、数据处理、规则化推理</li>
<li>优势
<ol>
<li>提升任务执行的条理性，减少冗余或遗漏。</li>
<li>适合需要分阶段完成的复杂任务，降低认知负荷</li>
</ol>
</li>
<li>总结与趋势
<ol>
<li>CoT仍是基础范式，尤其适合教育、逻辑推理场景。</li>
<li>GoT凭借图结构的灵活性，成为处理复杂任务的新标杆，可能逐步取代ToT。</li>
<li>PoT在需要高精度计算的领域（如工程、金融）具有不可替代性。</li>
</ol>
</li>
<li>实践经验：
<ol>
<li>简单问题：优先使用CoT，保持推理的简洁性。</li>
<li>开放问题：尝试ToT，探索多种可能性后再收敛答案。</li>
<li>复杂知识问题：结合GoT，利用外部知识图谱增强推理深度。</li>
<li>长流程任务：采用PoT，确保任务按计划有序推进。</li>
</ol>
</li>
<li>实际使用：与大模型手动交互； 工程化封装成模板</li>
</ol>








































<table><thead><tr><th>框架</th><th>核心逻辑</th><th>结构特点</th><th>适用任务类型</th><th><strong>典型场景</strong></th></tr></thead><tbody><tr><td><strong>CoT</strong></td><td>线性分步推理</td><td>链式结构</td><td>单路径、逐步推导问题</td><td>数学题、逻辑推理</td></tr><tr><td><strong>ToT</strong></td><td>多路径搜索与评估</td><td>树状结构</td><td>多解探索、需全局优化的问题</td><td>游戏策略、创意生成</td></tr><tr><td><strong>GoT</strong></td><td>图结构关系整合</td><td>网状结构</td><td>多维度关联、跨领域推理问题</td><td>知识图谱问答、复杂因果分析</td></tr><tr><td><strong>PoT</strong></td><td>分层规划与任务分解</td><td>层级结构</td><td>分阶段执行、时序依赖问题</td><td>项目管理、长文本生成</td></tr></tbody></table>
</li>
<li>
<p>ReAct(Reason-Act 推理 - 行动模式)： 让模型交替执行 “思考下一步动作” 和 “执行工具调用”，实现闭环决策
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fc9b27b36e20424faff4b27e0a1618ec~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55-u5Lq65LiJ562J:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769421902&amp;x-signature=QpyjYBR7C3krMaTiOMjILDO7TQo%3D" alt="在这里插入图片描述" loading="lazy"/></p>
<ol>
<li>虽然CoT增强了大模型的推理能力，但它的推理过程主要依赖大模型内部的知识库，缺乏与外部世界的实时互动，这可能导致知识滞后、产生错误信息或让错误不断传递。ReAct（Reasoning and Action）框架则依据结合“推理”（Reasoning）与“行动”（Action），解决了这一挑战。
<ol>
<li>它让大模型在推理时能与外部工具或环境互动，获取最新信息、执行具体操作，并根据反馈调整后续步骤。</li>
<li>这种动态交互让大模型具备了“边思考边行动、边观察边调整”的能力，核心运作机制可总结为“思考（Thought）→行动（Action）→观察（Observation）”的循环。</li>
</ol>
</li>
<li>流程：接收目标→推理第一步行动→执行→观察结果→基于结果推理第二步行动→循环直至完成目标；无预先完整规划，依赖实时反馈动态决策，强调 “思考 - 行动 - 反馈” 的闭环
<ol>
<li>Thought (思考): Agent 首先基于当前目标和之前的观察进行内部“思考”。这通常是利用 LLM 生成一段描述当前状态、分析问题、制定下一步行动策略或分解任务的文本。</li>
<li>Action (行动):基于思考的结果，Agent 决定执行一个具体的行动。这通常是调用一个工具（如搜索引擎、计算器、API）并附带必要的参数，或者是向用户请求更多信息，甚至是判断任务已经完成并生成最终答案。</li>
<li>Observation (观察): 执行行动后，Agent 会从环境或工具那里获得一个结果或反馈，这就是“观察”。例如，搜索引擎返回的搜索结果、API 调用的输出、代码执行的错误信息等。</li>
<li>回到 Thought: Agent将这个观察结果纳入考量，开始新一轮的思考，评估上一步行动的效果，判断是否必须调整策略，并规划下一步的行动。这个循环不断重复，直到 Agent 判断任务目标已经达成。</li>
</ol>
</li>
<li>prompt 的巧妙设计：
<ol>
<li>管用思考 (Thought): 指示LLM 分析当前状况、回顾目标、评估已有信息、识别知识差距、制定行动计划。常常包含 “Think step-by-step” 或类似的指令。</li>
<li>做出行动决策 (Action):指示 LLM 以特定格式（如 JSON）输出要调用的器具名称和参数，或者输出最终答案。</li>
<li>解读观察结果 (Observation):帮助 LLM 理解软件返回的信息，并将其融入下一步的思考中。</li>
<li>Prompt 还需要包含可用工具的描述以及一些示例（Few-shot examples），来帮助 LLM 更好地理解如何在这个循环中工作。</li>
</ol>
</li>
<li>优点分析
<ol>
<li>灵活性高: ReAct 能够根据每一步的观察结果动态调整策略，对预料之外的情况或工具执行失败具有较强的适应性。</li>
<li>处理知识密集型任务: 经过迭代地应用工具（如搜索）获取信息，ReAct 能较好地处理需外部知识的任务。</li>
<li>透明度: “Thought”步骤提供了 Agent 决策过程的中间记录，便于理解和调试。</li>
</ol>
</li>
<li>缺点分析
<ol>
<li>可能陷入无效循环: 如果 Agent 的思考或工具使用出现偏差，可能会导致在几个步骤之间重复循环而无法取得进展。</li>
<li>效率较低: 每一步都需 LLM 进行思考和决策，对于长流程任务，LLM 调用次数多，可能导致较高的延迟和成本。</li>
<li>错误累积: 前一步的错误（如错误的思考或应用调用失败）可能会影响后续步骤，导致最终结果偏差。</li>
</ol>
</li>
<li>使用场景：智能体（Agent）、需要外部工具的任务（如信息检索、数据分析）
<ol>
<li>任务简单、无需长期规划（如单轮问答、API 调用）。</li>
<li>希望快速部署，避免训练成本。</li>
</ol>
</li>
</ol>
</li>
<li>
<p>Plan-Act（规划 - 执行）模式：一种<strong>线性的 “先规划后执行” 模式</strong>，核心是 “先制定完整计划，再按计划逐步执行”，无中间<strong>反馈调整</strong>环节：</p>
<ol>
<li>
<p>流程：接收目标→拆解为固定子任务序列→按顺序执行所有步骤→输出结果；</p>
</li>
<li>
<p>特点：规划阶段一次性确定所有行动路径，执行过程中不根据实际结果修改计划；</p>
</li>
<li>
<p><strong>Plan-and-Execute 框架：结构化规划与顺序执行</strong>：与 ReAct 的迭代试错不同，Plan-and-Execute (P-a-E) 采取了一种更结构化、更线性的途径。</p>
<ol>
<li>
<p>Planning (规划) 阶段: 首先，Agent（通常通过一次或少数几次 LLM 调用）基于用户给定的初始目标，生成一个完整的、通常是分步骤的执行计划。这个计划列出了为达成目标所需执行的所有步骤及其顺序。</p>
</li>
<li>
<p>Execution (执行) 阶段: 然后，Agent严格按照预先制定的计划，一步一步地顺序执行。通常每一步会涉及调用一个或多个程序。只有当前步骤成功达成后，才会进入下一步。</p>
</li>
<li>
<p>规划器 (Planner): 负责一个专门的 LLM 调用，其 Prompt 旨在输出一个清晰的步骤列表或带有依赖关系的计划就是理解初始目标并生成结构化的执行计划。这通常。计划的质量直接决定了 Agent 的最终表现。</p>
</li>
<li>
<p>执行器 (Executor): 负责解析计划，并按顺序调度工具执行每个步骤。它需要管理步骤间的状态传递（如上一步的输出作为下一步的输入），但不负责重新规划（除非设计了非常复杂的错误处理逻辑）。</p>
</li>
<li>
<p>注：这些都更偏向于在 Agent 中使用，以下为介绍的三种模式的对比，以及落地较多的四种范式</p>



































<table><thead><tr><th>维度</th><th>Plan-Act 模式</th><th>ReAct 模式</th></tr></thead><tbody><tr><td><strong>规划方式</strong></td><td>预先制定完整、固定的计划</td><td>无预先计划，每步动态推理</td></tr><tr><td><strong>反馈机制</strong></td><td>无执行中反馈，计划一旦确定不修改</td><td>每步执行后均根据结果反馈调整策略</td></tr><tr><td><strong>灵活性</strong></td><td>低，无法应对计划外的异常情况</td><td>高，可适配环境变化或意外结果</td></tr><tr><td><strong>适用场景</strong></td><td>简单、确定性高的任务（如固定流程自动化）</td><td>繁琐、不确定性高的任务（如多平台比价、故障排查）</td></tr><tr><td><strong>决策逻辑</strong></td><td>静态的 “计划驱动”</td><td>动态的 “反馈驱动”</td></tr></tbody></table>
</li>
</ol>






























<table><thead><tr><th>范式名称</th><th>核心价值</th><th>典型应用</th></tr></thead><tbody><tr><td><strong>Self-Consistency（自洽性推理）</strong></td><td>大幅降低模型幻觉，提升结果可靠性</td><td>数学计算、常识问答、事实性检索</td></tr><tr><td><strong>Self-Refine（自我优化推理）</strong></td><td>迭代提升内容质量，无需人工介入</td><td>文案撰写、报告生成、代码优化</td></tr><tr><td>Least-to-Most（由易到难提示）</td><td>拆解复杂问题，攻克 “无从下手” 的任务</td><td>数学证明、复杂代码编写、多步骤决策</td></tr><tr><td>Reflexion（反思式推理）</td><td>让模型从错误中学习，优化后续执行</td><td>工具调用调试、多轮对话纠错、故障排查</td></tr></tbody></table>
</li>
</ol>
</li>
</ol>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fad6601cd7984d208cbee4c8290bcf06~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55-u5Lq65LiJ562J:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769421902&amp;x-signature=nOQbgBmzbzGHggoyw47M6shCqqU%3D" alt="在这里插入图片描述" loading="lazy"/></p>
<h2 data-id="heading-1">2 结构化提示框架</h2>
<ol>
<li>注：上面的都是提示词工程的不同思路方法，结构化提示框架更像是对提示词工程的一个规范模板，避免遗漏信息，按照模板填写对应信息即可，以下为当前主流的提示词工程框架及其核心要素、适用场景</li>
<li>ICIO 框架
<ol>
<li>核心要素：
<ol>
<li>Instruction（任务）：明确AI需要完成的具体任务（如翻译、写作）。</li>
<li>Context（背景）：提供任务相关的上下文信息（如使用场景、目标受众）。</li>
<li>Input Data（输入数据）：指定需要处理的具体数据（如待翻译的文本）。</li>
<li>Output Indicator（输出格式）：定义输出的风格、格式或类型（如正式商务英语）。</li>
</ol>
</li>
<li>适用场景：数据转换（文本翻译、清洗）、内容创作（报告、文案）、技术任务（代码生成）。</li>
</ol>
</li>
<li>CRISPE 框架
<ol>
<li>核心要素：
<ol>
<li>Capacity and Role（角色）：设定AI的角色（如数学老师）。</li>
<li>Insight（背景）：提供角色扮演的上下文（如学生年龄、学习环境）。</li>
<li>Statement（任务）：具体任务描述（如解答数学问题）。</li>
<li>Personality（格式）：回答的风格（如友好、鼓励性语言）。</li>
<li>Experiment（实验）：请求多个示例或变体。</li>
</ol>
</li>
<li>适用场景：角色模拟（教师、顾问）、个性化互动（幽默/正式语气）、多样化输出（多方案生成）。</li>
</ol>
</li>
<li>BROKE 框架
<ol>
<li>核心要素：
<ol>
<li>Background（背景）：项目或任务的背景信息。</li>
<li>Role（角色）：AI需扮演的角色（如项目经理）。</li>
<li>Objectives（目标）：明确任务目标（如制定项目计划）。</li>
<li>Key Result（关键结果）：输出的格式要求（如甘特图）。</li>
<li>Evolve（改进）：根据反馈迭代优化。</li>
</ol>
</li>
<li>适用场景：项目管理（资源分配）、创意设计（多轮优化）、数据分析（动态调整）。</li>
</ol>
</li>
<li>RASCEF 框架
<ol>
<li>核心要素：
<ol>
<li>Role（角色）：定义AI身份（如营销专家）。</li>
<li>Action（行动）：具体任务（如制定邮件策略）。</li>
<li>Script（步骤）：分步骤流程（如分析受众→设计内容）。</li>
<li>Content（上下文）：背景信息（如公司定位）。</li>
<li>Example（示例）：输出示例（如健康饮食推文）。</li>
<li>Format（格式）：指定结构（如列表、段落）。</li>
</ol>
</li>
<li>适用场景：专业咨询（营销策略）、流程管理（项目管理）、标准化输出（模板化内容）。</li>
</ol>
</li>
<li>CO-STAR 框架
<ol>
<li>核心要素：
<ol>
<li>Context（上下文）：任务背景。</li>
<li>Objective（目标）：明确核心任务。</li>
<li>Style（风格）：模仿特定写作风格。</li>
<li>Tone（语气）：情感基调（正式/幽默）。</li>
<li>Audience（受众）：目标用户群体。</li>
<li>Response（回复格式）：输出结构（如列表、报告）。</li>
</ol>
</li>
<li>适用场景：广告文案、社交媒体内容、个性化报告。</li>
</ol>
</li>
<li>RODES 框架
<ol>
<li>核心要素
<ol>
<li>Role（角色）：详细定义AI身份（如病毒推文作家）。</li>
<li>Objective（目标）：具体任务（如撰写280字推文）。</li>
<li>Details（细节）：约束条件（如禁用表情符号）。</li>
<li>Examples（示例）：输入-输出范例。</li>
<li>Sense Check（感知检查）：确认AI理解需求。</li>
</ol>
</li>
<li>适用场景：社交媒体运营、创意内容生成、新手友好型提示设计。</li>
</ol>
</li>
<li>选择参考：
<ol>
<li>技术任务：优先使用ICIO或BROKE，确保逻辑清晰。</li>
<li>创意内容：CRISPE或RODES更适合角色化、风格化需求。</li>
<li>复杂流程：RASCEF和CO-STAR提供结构化支持。</li>
</ol>
</li>
<li>使用方法：手动交互/工程化封装</li>
</ol>








































<table><thead><tr><th>框架</th><th>核心特点</th><th>适用领域</th></tr></thead><tbody><tr><td>ICIO</td><td>任务明确、格式标准化</td><td>技术任务、翻译、报告</td></tr><tr><td>CRISPE</td><td>角色扮演、多方案生成</td><td>教育、咨询、个性化互动</td></tr><tr><td>BROKE</td><td>动态优化、项目管理导向</td><td>长期项目、数据分析</td></tr><tr><td>RASCEF</td><td>流程化步骤、全面结构化</td><td>专业咨询、复杂流程管理</td></tr><tr><td>CO-STAR</td><td>多维度定制（风格/受众）</td><td>广告、社交媒体</td></tr><tr><td>RODES</td><td>新手友好、强调示例与反馈</td><td>创意内容、标准化输出</td></tr></tbody></table>
<h2 data-id="heading-2">参考资料</h2>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.cnblogs.com%2Fljbguanli%2Fp%2F19453654" target="_blank" title="https://www.cnblogs.com/ljbguanli/p/19453654" ref="nofollow noopener noreferrer">1</a> <a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fweixin_44986037%2Farticle%2Fdetails%2F148028458" target="_blank" title="https://blog.csdn.net/weixin_44986037/article/details/148028458" ref="nofollow noopener noreferrer">2</a></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Android JNI 开发完全指南]]></title>    <link>https://juejin.cn/post/7596709272976179246</link>    <guid>https://juejin.cn/post/7596709272976179246</guid>    <pubDate>2026-01-19T09:58:04.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7596709272976179246" data-draft-id="7596845113280888841" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Android JNI 开发完全指南"/> <meta itemprop="keywords" content="Android"/> <meta itemprop="datePublished" content="2026-01-19T09:58:04.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="aykon"/> <meta itemprop="url" content="https://juejin.cn/user/3984285870883080"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Android JNI 开发完全指南
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3984285870883080/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    aykon
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-19T09:58:04.000Z" title="Mon Jan 19 2026 09:58:04 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    13
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读13分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">Android JNI 开发完全指南</h2>
<h3 data-id="heading-1">目录</h3>
<ol>
<li><a href="#1-jni-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5" title="#1-jni-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5">JNI 基础概念</a></li>
<li><a href="#2-external-%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3" title="#2-external-%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3">external 关键字详解</a></li>
<li><a href="#3-jni-%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83" title="#3-jni-%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83">JNI 命名规范</a></li>
<li><a href="#4-so-%E5%BA%93%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6" title="#4-so-%E5%BA%93%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6">so 库加载机制</a></li>
<li><a href="#5-jvm-%E6%96%B9%E6%B3%95%E6%9F%A5%E6%89%BE%E4%B8%8E%E7%BC%93%E5%AD%98" title="#5-jvm-%E6%96%B9%E6%B3%95%E6%9F%A5%E6%89%BE%E4%B8%8E%E7%BC%93%E5%AD%98">JVM 方法查找与缓存</a></li>
<li><a href="#6-jni-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F" title="#6-jni-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F">JNI 类型系统</a></li>
<li><a href="#7-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86" title="#7-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86">内存管理</a></li>
<li><a href="#8-%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B" title="#8-%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B">实战案例</a></li>
<li><a href="#9-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5" title="#9-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5">最佳实践</a></li>
<li><a href="#10-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98" title="#10-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98">常见问题</a></li>
</ol>
<hr/>
<h3 data-id="heading-2">1. JNI 基础概念</h3>
<h4 data-id="heading-3">1.1 什么是 JNI？</h4>
<p><strong>JNI (Java Native Interface)</strong> 是 Java 平台的标准编程接口，允许 Java 代码与使用其他编程语言（主要是 C/C++）编写的应用程序和库进行交互。</p>
<pre><code class="hljs language-kotlin" lang="kotlin">┌─────────────────────────────────────────────────────────┐
│  Java/Kotlin 层                                         │
│  ├─ Activity/Fragment                                  │
│  ├─ 业务逻辑                                            │
│  └─ <span class="hljs-keyword">external</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">nativeMethod</span><span class="hljs-params">()</span></span>  ← 调用 Native 方法     │
└─────────────────────────────────────────────────────────┘
                          ↓ JNI
┌─────────────────────────────────────────────────────────┐
│  JNI 接口层                                             │
│  ├─ JNIEnv (JNI 环境指针)                              │
│  ├─ 类型转换                                            │
│  └─ 方法调用                                            │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│  Native 层 (C/C++)                                      │
│  ├─ 高性能计算                                          │
│  ├─ FFmpeg/OpenCV 等库                                 │
│  └─ 硬件加速                                            │
└─────────────────────────────────────────────────────────┘
</code></pre>
<h4 data-id="heading-4">1.2 为什么使用 JNI？</h4>






























<table><thead><tr><th>应用场景</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><strong>性能优化</strong></td><td>C/C++ 执行效率高，适合计算密集型任务</td><td>图像处理、音视频编解码</td></tr><tr><td><strong>复用现有库</strong></td><td>使用成熟的 C/C++ 库</td><td>FFmpeg、OpenCV、OpenGL</td></tr><tr><td><strong>硬件访问</strong></td><td>某些硬件只提供 C 层接口</td><td>相机、传感器、NFC</td></tr><tr><td><strong>代码保护</strong></td><td>Native 代码反编译难度高</td><td>核心算法、加密逻辑</td></tr></tbody></table>
<h4 data-id="heading-5">1.3 JNI 的组成部分</h4>
<pre><code class="hljs language-markdown" lang="markdown">JNI 包含三个核心部分：

<span class="hljs-bullet">1.</span> Kotlin/Java 代码
<span class="hljs-bullet">   -</span> 声明 native 方法
<span class="hljs-bullet">   -</span> 加载 Native 库

<span class="hljs-bullet">2.</span> JNI 接口层
<span class="hljs-bullet">   -</span> JNIEnv <span class="hljs-emphasis">*env：JNI 环境指针
   - 类型转换函数
   - 调用 Java 方法

3. Native 代码 (C/C++)
   - 实现 native 方法
   - 调用系统库
   - 性能敏感操作
</span></code></pre>
<hr/>
<h3 data-id="heading-6">2. external 关键字详解</h3>
<h4 data-id="heading-7">2.1 external 的含义</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// Kotlin 层声明</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">external</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">compressImage</span><span class="hljs-params">(path: <span class="hljs-type">String</span>)</span></span>: <span class="hljs-built_in">Boolean</span>
<span class="hljs-comment">//        ^^^^^^^^</span>
<span class="hljs-comment">//        声明此方法的实现由 Native 代码提供</span>
</code></pre>
<p><strong>关键点：</strong></p>
<ul>
<li>❌ 不是直接调用 C 方法</li>
<li>✅ 是声明："方法实现位于 Native 库中，JVM 会去找"</li>
<li>✅ 类似于接口声明，通过 JNI 命名规范关联到 C++ 实现</li>
</ul>
<h4 data-id="heading-8">2.2 external 的工作流程</h4>
<pre><code class="hljs language-kotlin" lang="kotlin">┌─────────────────────────────────────────────────────────┐
│ 步骤 <span class="hljs-number">1</span>: Kotlin 代码                                    │
├─────────────────────────────────────────────────────────┤
│ <span class="hljs-keyword">external</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">compressImage</span><span class="hljs-params">(path: <span class="hljs-type">String</span>)</span></span>: <span class="hljs-built_in">Boolean</span>      │
│   <span class="hljs-comment">// 只声明，不实现                                      │</span>
└─────────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────────┐
│ 步骤 <span class="hljs-number">2</span>: 加载 Native 库                                 │
├─────────────────────────────────────────────────────────┤
│ System.loadLibrary(<span class="hljs-string">"ffmpegandoridlibrary"</span>)             │
│ <span class="hljs-comment">// 加载 libffmpegandoridlibrary.so                     │</span>
│ <span class="hljs-comment">// dlopen() 系统调用打开 .so 文件                       │</span>
└─────────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────────┐
│ 步骤 <span class="hljs-number">3</span>: 运行时方法查找                                 │
├─────────────────────────────────────────────────────────┤
│ JVM 通过 JNI 命名规范查找：                             │
│ Java_com_package_Class_method_name                     │
│                                                         │
│ 在 .so 符号表中查找对应函数                             │
└─────────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────────┐
│ 步骤 <span class="hljs-number">4</span>: C++ 实现                                       │
├─────────────────────────────────────────────────────────┤
│ extern <span class="hljs-string">"C"</span>                                             │
│ JNIEXPORT jboolean JNICALL                             │
│ Java_com_package_Class_method_name(JNIEnv *env, ...) { │
│     <span class="hljs-comment">// 具体实现代码                                     │</span>
│ }                                                       │
└─────────────────────────────────────────────────────────┘
</code></pre>
<h4 data-id="heading-9">2.3 为什么用 external？</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 对比：普通方法 vs external 方法</span>

<span class="hljs-comment">// 普通方法 - 实现在 Kotlin 中</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">add</span><span class="hljs-params">(a: <span class="hljs-type">Int</span>, b: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> {
    <span class="hljs-keyword">return</span> a + b  <span class="hljs-comment">// 代码在这里</span>
}

<span class="hljs-comment">// external 方法 - 实现在 Native 中</span>
<span class="hljs-keyword">external</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">compressImage</span><span class="hljs-params">(path: <span class="hljs-type">String</span>)</span></span>: <span class="hljs-built_in">Boolean</span>
<span class="hljs-comment">// 代码在 C++ 中，通过 JNI 调用</span>
</code></pre>
<hr/>
<h3 data-id="heading-10">3. JNI 命名规范</h3>
<h4 data-id="heading-11">3.1 命名规则</h4>
<p>JNI 函数名必须严格按照以下格式：</p>
<pre><code class="hljs language-kotlin" lang="kotlin">Java_&lt;包名路径&gt;_&lt;类名&gt;_&lt;方法名&gt;

示例：
Kotlin: com.aykon.demo.ffmpegandoridlibrary.ImageCompress.compressImageFromPath()
         │            │                     │         └─────────┬────────┘
         │            │                     │                   │
         │            └─────────────────────┴─────────────────── 方法名
         │                                                        method_name
         └────────────────────────────────────────────────────── 类名
                                                                Class

JNI 函数名:
Java_com_aykon_demo_ffmpegandoridlibrary_image_ImageCompress_compressImageFromPath
│    │   │  │    └─────────┬──────────────┘ └───────┬────────┘ └───────┬───────
│    │   │  │              │                         │                │
│    │   │  └──────────────┴─────────────────────────┴──────────────── method name
│    │   └─────────────────────────────────────────────────────────── <span class="hljs-keyword">class</span> <span class="hljs-title class_">name</span>
│    └─────────────────────────────────────────────────────────────── <span class="hljs-keyword">package</span> segments
└─────────────────────────────────────────────────────────────────── JNI prefix
</code></pre>
<h4 data-id="heading-12">3.2 命名转换规则</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// Kotlin 代码</span>
<span class="hljs-keyword">package</span> com.example.myapp

<span class="hljs-keyword">class</span> <span class="hljs-title class_">ImageProcessor</span> {
    <span class="hljs-keyword">external</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">processImage</span><span class="hljs-params">(path: <span class="hljs-type">String</span>)</span></span>: <span class="hljs-built_in">Boolean</span>
}
</code></pre>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// 对应的 C++ 函数名</span>
<span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span>
<span class="hljs-function">JNIEXPORT jboolean JNICALL
<span class="hljs-title">Java_com_example_myapp_ImageProcessor_processImage</span><span class="hljs-params">(
    JNIEnv *env,
    jobject thiz,
    jstring path
)</span> </span>{
    <span class="hljs-comment">// 实现</span>
}
</code></pre>
<h4 data-id="heading-13">3.3 包名转换规则</h4>
<pre><code class="hljs">com.aykon.demo.ffmpegandoridlibrary
  ↓
com_aykon_demo_ffmpegandoridlibrary
    ↓ 全部用下划线替换点号
com_aykon_demo_ffmpegandoridlibrary
</code></pre>
<h4 data-id="heading-14">3.4 方法重载的处理</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// Kotlin 中允许重载</span>
<span class="hljs-keyword">external</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-keyword">data</span>: <span class="hljs-type">ByteArray</span>)</span></span>
<span class="hljs-keyword">external</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-keyword">data</span>: <span class="hljs-type">String</span>)</span></span>
</code></pre>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// JNI 会添加签名后缀</span>
Java_..._process__3_3B                    <span class="hljs-comment">// ByteArray</span>
Java_..._process__Ljava_lang_String_2     <span class="hljs-comment">// String</span>

<span class="hljs-comment">// 建议：避免重载，使用不同方法名</span>
<span class="hljs-function">external fun <span class="hljs-title">processBytes</span><span class="hljs-params">(data: ByteArray)</span>
external fun <span class="hljs-title">processString</span><span class="hljs-params">(data: String)</span>
</span></code></pre>
<h4 data-id="heading-15">3.5 extern "C" 的作用</h4>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// 不使用 extern "C"</span>
<span class="hljs-function">JNIEXPORT jboolean JNICALL <span class="hljs-title">myFunction</span><span class="hljs-params">(...)</span>  <span class="hljs-comment">// ❌ C++ 会修饰名称</span>
<span class="hljs-comment">// 符号表: _Z12myFunctionP7JNIEnv_P8_jstring</span>

<span class="hljs-comment">// 使用 extern "C"</span>
<span class="hljs-keyword">extern</span> "C" </span>{
    <span class="hljs-function">JNIEXPORT jboolean JNICALL <span class="hljs-title">myFunction</span><span class="hljs-params">(...)</span>  <span class="hljs-comment">// ✅ 保持原名</span>
    <span class="hljs-comment">// 符号表: myFunction</span>
}
</span></code></pre>
<p><strong>必须使用 <code>extern "C"</code> 的原因：</strong></p>
<ol>
<li>C++ 支持函数重载，会修饰函数名</li>
<li>JVM 需要精确匹配函数名</li>
<li>C 语言不修饰名称，保证符号一致</li>
</ol>
<hr/>
<h3 data-id="heading-16">4. so 库加载机制</h3>
<h4 data-id="heading-17">4.1 加载过程</h4>
<pre><code class="hljs language-bash" lang="bash">┌─────────────────────────────────────────────────────────┐
│ 1. System.loadLibrary() 调用                           │
├─────────────────────────────────────────────────────────┤
│ System.loadLibrary(<span class="hljs-string">"ffmpegandoridlibrary"</span>)             │
│                                                         │
│ 内部执行：Runtime.getRuntime().loadLibrary()            │
└─────────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────────┐
│ 2. 构造库文件名                                         │
├─────────────────────────────────────────────────────────┤
│ 输入: <span class="hljs-string">"ffmpegandoridlibrary"</span>                           │
│                                                         │
│ 添加前缀: lib + name + .so                             │
│ 结果: libffmpegandoridlibrary.so                       │
└─────────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────────┐
│ 3. 搜索库文件                                           │
├─────────────────────────────────────────────────────────┤
│ 按优先级搜索以下路径：                                  │
│                                                         │
│ 1. System.getProperty(<span class="hljs-string">"java.library.path"</span>)            │
│ 2. APK 中的 lib 目录                                   │
│    ├── lib/arm64-v8a/libxxx.so                        │
│    ├── lib/armeabi-v7a/libxxx.so                      │
│    └── lib/x86/libxxx.so                              │
│ 3. 系统库路径 /system/lib64                           │
│ 4. 应用私有路径 /data/app/.../lib                      │
└─────────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────────┐
│ 4. 加载库到内存                                         │
├─────────────────────────────────────────────────────────┤
│ 使用系统调用 dlopen() 打开 .so 文件                    │
│                                                         │
│ dlopen(<span class="hljs-string">"libffmpegandoridlibrary.so"</span>, RTLD_LAZY)       │
│                                                         │
│ 执行：                                                  │
│ - 读取 .so 文件头（ELF 格式）                          │
│ - 加载代码段到内存                                     │
│ - 加载数据段到内存                                     │
│ - 解析符号表                                           │
│ - 重定位地址                                           │
└─────────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────────┐
│ 5. 注册 JNI 方法                                       │
├─────────────────────────────────────────────────────────┤
│ JVM 扫描 .so 符号表，查找 JNI 函数                     │
│                                                         │
│ 模式 1: 自动命名规范查找                               │
│   Java_..._method_name                                 │
│                                                         │
│ 模式 2: JNI_OnLoad 手动注册                            │
│   JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM *vm, ...) { │
│       // 注册函数                                       │
│   }                                                     │
└─────────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────────┐
│ 6. 加载完成                                             │
├─────────────────────────────────────────────────────────┤
│ 库已加载，可以调用 external 方法                        │
└─────────────────────────────────────────────────────────┘
</code></pre>
<h4 data-id="heading-18">4.2 多库加载示例</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 加载多个 Native 库</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">NativeLib</span> {
    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> {
        <span class="hljs-keyword">init</span> {
            <span class="hljs-comment">// 按依赖顺序加载</span>
            System.loadLibrary(<span class="hljs-string">"avutil"</span>)        <span class="hljs-comment">// FFmpeg 工具库</span>
            System.loadLibrary(<span class="hljs-string">"avcodec"</span>)       <span class="hljs-comment">// FFmpeg 编解码库</span>
            System.loadLibrary(<span class="hljs-string">"avformat"</span>)      <span class="hljs-comment">// FFmpeg 格式库</span>
            System.loadLibrary(<span class="hljs-string">"swscale"</span>)       <span class="hljs-comment">// FFmpeg 缩放库</span>
            System.loadLibrary(<span class="hljs-string">"ffmpegandroid"</span>) <span class="hljs-comment">// 主库</span>
        }
    }
}
</code></pre>
<h4 data-id="heading-19">4.3 CMake 配置</h4>
<pre><code class="hljs language-cmake" lang="cmake"># CMakeLists.txt

# 添加 FFmpeg 预编译库
add_library(libavutil SHARED IMPORTED)
set_target_properties(libavutil PROPERTIES
    IMPORTED_LOCATION ${CMAKE_SOURCE_DIR}/lib/${CMAKE_ANDROID_ARCH_ABI}/libavutil.so)

# 编译主库
add_library(ffmpegandroid SHARED
    ffmpegandoridlibrary.cpp
    imageprocessor.cpp
)

# 链接库
target_link_libraries(ffmpegandroid
    libavutil
    libavcodec
    libavformat
    log          # Android 日志库
    android      # Android 原生库
)
</code></pre>
<h4 data-id="heading-20">4.4 库的依赖关系</h4>
<pre><code class="hljs language-erlang" lang="erlang">主库: libffmpegandoridlibrary.so
  ↓ 依赖
  ├─ libavutil.so      (工具函数)
  ├─ libavcodec.so     (编解码器)
  ├─ libavformat.so    (格式处理)
  ├─ libswscale.so     (图像缩放)
  └─ libswresample.so  (音频重采样)

所有库都会打包到 APK 中:
APK/
  └─ lib/
      ├─ arm64-v8a/
      │   ├─ libffmpegandoridlibrary.so
      │   ├─ libavutil.so
      │   └─ ...
      └─ armeabi-v7a/
          └─ ...
</code></pre>
<hr/>
<h3 data-id="heading-21">5. JVM 方法查找与缓存</h3>
<h4 data-id="heading-22">5.1 全局缓存架构</h4>
<pre><code class="hljs language-ini" lang="ini">┌─────────────────────────────────────────────────────────────────┐
│ JVM Native 方法管理 (每个 ClassLoader 一个实例)                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │ 已加载的 .so 库列表                                      │  │
│  │ ┌────────────────────────────────────────────────────┐  │  │
│  │ │ <span class="hljs-section">[0]</span> libffmpegandoridlibrary.so  ← 主库            │  │  │
│  │ │ <span class="hljs-section">[1]</span> libavutil.so                               │  │  │
│  │ │ <span class="hljs-section">[2]</span> libavcodec.so                              │  │  │
│  │ │ <span class="hljs-section">[3]</span> libswscale.so                              │  │  │
│  │ └────────────────────────────────────────────────────┘  │  │
│  └──────────────────────────────────────────────────────────┘  │
│                                                                  │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │ 方法缓存表 (全局哈希表)                                  │  │
│  │ ┌────────────────────────────────────────────────────┐  │  │
│  │ │ Key: (类名 + 方法名 + 签名)                       │  │  │
│  │ │ Value: (库句柄 + 函数指针)                         │  │  │
│  │ ├────────────────────────────────────────────────────┤  │  │
│  │ │ "NativeLib.stringFromJNI()V"                       │  │  │
│  │ │   → (lib<span class="hljs-section">[0]</span>, 0x12345678)                          │  │  │
│  │ │                                                     │  │  │
│  │ │ "ImageCompress.compressImage(Ljava/lang/String<span class="hljs-comment">;)Z" │  │  │</span>
│  │ │   → (lib<span class="hljs-section">[0]</span>, 0x34567890)                          │  │  │
│  │ │                                                     │  │  │
│  │ │ "ImageCompress.getMetadata(Ljava/lang/String<span class="hljs-comment">;)..." │  │  │</span>
│  │ │   → (lib<span class="hljs-section">[0]</span>, 0x78901234)                          │  │  │
│  │ └────────────────────────────────────────────────────┘  │  │
│  └──────────────────────────────────────────────────────────┘  │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
</code></pre>
<h4 data-id="heading-23">5.2 方法查找流程</h4>
<pre><code class="hljs language-css" lang="css">第一次调用 external 方法：
┌─────────────────────────────────────────────────────────┐
│ 调用: <span class="hljs-built_in">stringFromJNI</span>()                                   │
└─────────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────────┐
│ 步骤 <span class="hljs-number">1</span>: 检查缓存                                       │
├─────────────────────────────────────────────────────────┤
│ 查找 Key: <span class="hljs-string">"NativeLib.stringFromJNI()V"</span>                 │
│ 结果: 未找到                                           │
└─────────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────────┐
│ 步骤 <span class="hljs-number">2</span>: 构造 JNI 函数名                                │
├─────────────────────────────────────────────────────────┤
│ Java_com_aykon_demo_..._NativeLib_stringFromJNI           │
└─────────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────────┐
│ 步骤 <span class="hljs-number">3</span>: 遍历已加载库查找                               │
├─────────────────────────────────────────────────────────┤
│ 库[<span class="hljs-number">0</span>]: libffmpegandoridlibrary.so                      │
│   <span class="hljs-built_in">dlsym</span>(<span class="hljs-string">"Java_..._stringFromJNI"</span>)                      │
│   ✅ 找到函数指针: <span class="hljs-number">0</span>x12345678                          │
└─────────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────────┐
│ 步骤 <span class="hljs-number">4</span>: 存入缓存                                       │
├─────────────────────────────────────────────────────────┤
│ 缓存[<span class="hljs-string">"NativeLib.stringFromJNI()V"</span>] = (lib[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>x12345678) │
└─────────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────────┐
│ 步骤 <span class="hljs-number">5</span>: 执行函数                                       │
├─────────────────────────────────────────────────────────┤
│ 跳转到函数指针 <span class="hljs-number">0</span>x12345678 执行                          │
└─────────────────────────────────────────────────────────┘

第二次调用同一方法：
┌─────────────────────────────────────────────────────────┐
│ 调用: <span class="hljs-built_in">stringFromJNI</span>()                                   │
└─────────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────────┐
│ 检查缓存: 命中！                                        │
│ 直接返回函数指针: <span class="hljs-number">0</span>x12345678  ← 非常快！               │
└─────────────────────────────────────────────────────────┘
</code></pre>
<h4 data-id="heading-24">5.3 性能对比</h4>

























<table><thead><tr><th>操作</th><th>第一次调用</th><th>后续调用</th></tr></thead><tbody><tr><td>查找方式</td><td>遍历符号表 O(n)</td><td>哈希表查找 O(1)</td></tr><tr><td>性能</td><td>较慢（微秒级）</td><td>极快（纳秒级）</td></tr><tr><td>缓存</td><td>否</td><td>是</td></tr></tbody></table>
<h4 data-id="heading-25">5.4 多个库的查找顺序</h4>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// 如果有多个库都实现了同名函数（虽然不推荐）</span>

<span class="hljs-comment">// 加载顺序</span>
System.<span class="hljs-built_in">loadLibrary</span>(<span class="hljs-string">"libraryA"</span>)  <span class="hljs-comment">// [0]</span>
System.<span class="hljs-built_in">loadLibrary</span>(<span class="hljs-string">"libraryB"</span>)  <span class="hljs-comment">// [1]</span>
System.<span class="hljs-built_in">loadLibrary</span>(<span class="hljs-string">"libraryC"</span>)  <span class="hljs-comment">// [2]</span>

<span class="hljs-comment">// 查找顺序</span>
调用 <span class="hljs-function">external <span class="hljs-title">method</span><span class="hljs-params">()</span>
  → 查找 libraryA ✅ 找到就使用
  → 否则查找 libraryB
  → 否则查找 libraryC
  → 都找不到 → UnsatisfiedLinkError
</span></code></pre>
<hr/>
<h3 data-id="heading-26">6. JNI 类型系统</h3>
<h4 data-id="heading-27">6.1 基本类型映射</h4>

































































<table><thead><tr><th>Kotlin 类型</th><th>JNI 类型</th><th>C++ 类型</th><th>说明</th></tr></thead><tbody><tr><td><code>Boolean</code></td><td><code>jboolean</code></td><td><code>uint8_t</code></td><td>0 或 1</td></tr><tr><td><code>Byte</code></td><td><code>jbyte</code></td><td><code>int8_t</code></td><td>8 位有符号整数</td></tr><tr><td><code>Char</code></td><td><code>jchar</code></td><td><code>uint16_t</code></td><td>16 位 Unicode 字符</td></tr><tr><td><code>Short</code></td><td><code>jshort</code></td><td><code>int16_t</code></td><td>16 位有符号整数</td></tr><tr><td><code>Int</code></td><td><code>jint</code></td><td><code>int32_t</code></td><td>32 位有符号整数</td></tr><tr><td><code>Long</code></td><td><code>jlong</code></td><td><code>int64_t</code></td><td>64 位有符号整数</td></tr><tr><td><code>Float</code></td><td><code>jfloat</code></td><td><code>float</code></td><td>32 位浮点数</td></tr><tr><td><code>Double</code></td><td><code>jdouble</code></td><td><code>double</code></td><td>64 位浮点数</td></tr><tr><td><code>Unit/void</code></td><td><code>void</code></td><td><code>void</code></td><td>无返回值</td></tr></tbody></table>
<h4 data-id="heading-28">6.2 对象类型映射</h4>


















































<table><thead><tr><th>Kotlin 类型</th><th>JNI 类型</th><th>说明</th></tr></thead><tbody><tr><td><code>String</code></td><td><code>jstring</code></td><td>需要转换才能使用</td></tr><tr><td><code>Any</code> / 对象</td><td><code>jobject</code></td><td>任意 Java 对象</td></tr><tr><td><code>Class</code></td><td><code>jclass</code></td><td>类对象</td></tr><tr><td><code>Array&lt;T&gt;</code></td><td><code>jarray</code></td><td>数组基类</td></tr><tr><td><code>ByteArray</code></td><td><code>jbyteArray</code></td><td>字节数组</td></tr><tr><td><code>IntArray</code></td><td><code>jintArray</code></td><td>整数数组</td></tr><tr><td><code>Object[]</code></td><td><code>jobjectArray</code></td><td>对象数组</td></tr><tr><td><code>Throwable</code></td><td><code>jthrowable</code></td><td>异常对象</td></tr></tbody></table>
<h4 data-id="heading-29">6.3 JNI 函数签名</h4>
<p>JNI 方法签名用于唯一标识方法，格式：<code>(参数类型...)返回类型</code></p>
<pre><code class="hljs language-arduino" lang="arduino">基础类型签名：
B - <span class="hljs-type">byte</span>
C - <span class="hljs-type">char</span>
D - <span class="hljs-type">double</span>
F - <span class="hljs-type">float</span>
I - <span class="hljs-type">int</span>
J - <span class="hljs-type">long</span>
S - <span class="hljs-type">short</span>
Z - <span class="hljs-type">boolean</span>
V - <span class="hljs-type">void</span>

对象类型签名：
L包名/类名;  例如：Ljava/lang/<span class="hljs-type">String</span>;

数组类型签名：
[类型  例如：[I 表示 <span class="hljs-type">int</span>[]
        [[I 表示 <span class="hljs-type">int</span>[][]
</code></pre>
<p><strong>示例：</strong></p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// Kotlin 方法签名</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">process</span><span class="hljs-params">(input: <span class="hljs-type">String</span>, count: <span class="hljs-type">Int</span>, flag: <span class="hljs-type">Boolean</span>)</span></span>: String
</code></pre>
<pre><code class="hljs language-javascript" lang="javascript">对应的 <span class="hljs-variable constant_">JNI</span> 签名：
(<span class="hljs-title class_">Ljava</span>/lang/<span class="hljs-title class_">String</span>;<span class="hljs-variable constant_">IZ</span>)<span class="hljs-title class_">Ljava</span>/lang/<span class="hljs-title class_">String</span>;
│                │ │ │          │
│                │ │ │          └─ 返回 <span class="hljs-title class_">String</span>
│                │ │ └───────────── <span class="hljs-title class_">Boolean</span>
│                │ └─────────────── <span class="hljs-title class_">Int</span>
│                └───────────────── <span class="hljs-title class_">String</span> 参数
└─────────────────────────── 方法开始
</code></pre>
<p><strong>复杂示例：</strong></p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">example</span><span class="hljs-params">(
    str: <span class="hljs-type">String</span>,
    bytes: <span class="hljs-type">ByteArray</span>,
    listener: <span class="hljs-type">MyListener</span>,
    count: <span class="hljs-type">Int</span>
)</span></span>: <span class="hljs-built_in">Boolean</span>
</code></pre>
<pre><code class="hljs language-arduino" lang="arduino">JNI 签名:
(Ljava/lang/<span class="hljs-type">String</span>;[BLcom/example/MyListener;I)Z
│                │  │                 │    └─ 返回 <span class="hljs-type">boolean</span>
│                │  │                 └─────── Int
│                │  └───────────────────────── Listener 对象
│                └──────────────────────────── ByteArray
└─────────────────────────────────────── <span class="hljs-type">String</span>
</code></pre>
<h4 data-id="heading-30">6.4 JNIEnv 接口</h4>
<p><code>JNIEnv</code> 是指向 JNI 函数表的指针，提供了大量操作函数：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">JNIEnv</span> {
    <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">JNINativeInterface</span>* functions;

    <span class="hljs-comment">// 版本信息</span>
    <span class="hljs-function">jint <span class="hljs-title">GetVersion</span><span class="hljs-params">()</span></span>;

    <span class="hljs-comment">// 类操作</span>
    <span class="hljs-function">jclass <span class="hljs-title">FindClass</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name)</span></span>;

    <span class="hljs-comment">// 对象操作</span>
    <span class="hljs-function">jobject <span class="hljs-title">AllocObject</span><span class="hljs-params">(jclass clazz)</span></span>;
    <span class="hljs-function">jobject <span class="hljs-title">NewObject</span><span class="hljs-params">(jclass clazz, jmethodID methodID, ...)</span></span>;

    <span class="hljs-comment">// 方法操作</span>
    <span class="hljs-function">jmethodID <span class="hljs-title">GetMethodID</span><span class="hljs-params">(jclass clazz, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* name, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* sig)</span></span>;
    <span class="hljs-function">jmethodID <span class="hljs-title">GetStaticMethodID</span><span class="hljs-params">(jclass clazz, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* name, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* sig)</span></span>;

    <span class="hljs-comment">// 字段操作</span>
    <span class="hljs-function">jfieldID <span class="hljs-title">GetFieldID</span><span class="hljs-params">(jclass clazz, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* name, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* sig)</span></span>;
    <span class="hljs-function">jint <span class="hljs-title">GetIntField</span><span class="hljs-params">(jobject obj, jfieldID fieldID)</span></span>;

    <span class="hljs-comment">// 字符串操作</span>
    <span class="hljs-function">jstring <span class="hljs-title">NewStringUTF</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* str)</span></span>;
    <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">GetStringUTFChars</span><span class="hljs-params">(jstring str, jboolean* isCopy)</span></span>;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ReleaseStringUTFChars</span><span class="hljs-params">(jstring str, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* utf)</span></span>;

    <span class="hljs-comment">// 数组操作</span>
    <span class="hljs-function">jsize <span class="hljs-title">GetArrayLength</span><span class="hljs-params">(jarray array)</span></span>;
    <span class="hljs-function">jint* <span class="hljs-title">GetIntArrayElements</span><span class="hljs-params">(jintArray array, jboolean* isCopy)</span></span>;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ReleaseIntArrayElements</span><span class="hljs-params">(jintArray array, jint* elems, jint mode)</span></span>;

    <span class="hljs-comment">// 异常处理</span>
    <span class="hljs-function">jboolean <span class="hljs-title">ExceptionCheck</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ExceptionDescribe</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ExceptionClear</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function">jint <span class="hljs-title">ThrowNew</span><span class="hljs-params">(jclass clazz, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* msg)</span></span>;

    <span class="hljs-comment">// 内存管理</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DeleteLocalRef</span><span class="hljs-params">(jobject localRef)</span></span>;
    <span class="hljs-function">jobject <span class="hljs-title">NewGlobalRef</span><span class="hljs-params">(jobject obj)</span></span>;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DeleteGlobalRef</span><span class="hljs-params">(jobject globalRef)</span></span>;
};
</code></pre>
<hr/>
<h3 data-id="heading-31">7. 内存管理</h3>
<h4 data-id="heading-32">7.1 JNI 内存类型</h4>
<pre><code class="hljs language-markdown" lang="markdown">JNI 中有三种引用类型：

<span class="hljs-bullet">1.</span> Local Reference (局部引用)
<span class="hljs-bullet">   -</span> 生命周期：仅在当前 Native 方法执行期间
<span class="hljs-bullet">   -</span> 自动释放：方法返回时自动释放
<span class="hljs-bullet">   -</span> 创建方式：大部分 JNI 函数返回的引用
<span class="hljs-bullet">   -</span> 示例：jstring, jobject, jclass

<span class="hljs-bullet">2.</span> Global Reference (全局引用)
<span class="hljs-bullet">   -</span> 生命周期：显式释放之前一直有效
<span class="hljs-bullet">   -</span> 手动释放：必须调用 DeleteGlobalRef()
<span class="hljs-bullet">   -</span> 创建方式：NewGlobalRef()
<span class="hljs-bullet">   -</span> 用途：跨方法、跨线程共享

<span class="hljs-bullet">3.</span> Weak Global Reference (弱全局引用)
<span class="hljs-bullet">   -</span> 生命周期：GC 可以随时回收
<span class="hljs-bullet">   -</span> 手动释放：建议调用 DeleteWeakGlobalRef()
<span class="hljs-bullet">   -</span> 创建方式：NewWeakGlobalRef()
<span class="hljs-bullet">   -</span> 用途：缓存，不强引用
</code></pre>
<h4 data-id="heading-33">7.2 局部引用管理</h4>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// ✅ 正确：短生命周期方法</span>
<span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span>
JNIEXPORT jstring JNICALL
Java_..._simpleMethod(JNIEnv *env, jobject thiz) {
    jstring str = env-&gt;<span class="hljs-built_in">NewStringUTF</span>(<span class="hljs-string">"Hello"</span>);  <span class="hljs-comment">// 局部引用</span>
    <span class="hljs-comment">// ... 使用 str ...</span>
    <span class="hljs-keyword">return</span> str;  <span class="hljs-comment">// 自动释放</span>
}

<span class="hljs-comment">// ❌ 错误：循环中创建大量局部引用</span>
<span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span>
JNIEXPORT <span class="hljs-type">void</span> JNICALL
Java_..._wrongMethod(JNIEnv *env, jobject thiz, jint count) {
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) {
        jstring str = env-&gt;<span class="hljs-built_in">NewStringUTF</span>(<span class="hljs-string">"test"</span>);  <span class="hljs-comment">// 创建 10000 个！</span>
        <span class="hljs-comment">// 可能导致局部引用表溢出</span>
    }
}

<span class="hljs-comment">// ✅ 正确：循环中手动释放</span>
<span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span>
JNIEXPORT <span class="hljs-type">void</span> JNICALL
Java_..._correctMethod(JNIEnv *env, jobject thiz, jint count) {
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) {
        jstring str = env-&gt;<span class="hljs-built_in">NewStringUTF</span>(<span class="hljs-string">"test"</span>);
        <span class="hljs-comment">// ... 使用 str ...</span>
        env-&gt;<span class="hljs-built_in">DeleteLocalRef</span>(str);  <span class="hljs-comment">// 立即释放</span>
    }
}
</code></pre>
<h4 data-id="heading-34">7.3 字符串内存管理</h4>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// GetStringUTFChars / ReleaseStringUTFChars 成对使用</span>
<span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span>
JNIEXPORT <span class="hljs-type">void</span> JNICALL
Java_..._processString(JNIEnv *env, jobject thiz, jstring input) {
    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *cStr = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">// 初始化为 NULL</span>

    <span class="hljs-comment">// 转换：jstring → C 字符串</span>
    cStr = env-&gt;<span class="hljs-built_in">GetStringUTFChars</span>(input, <span class="hljs-literal">NULL</span>);
    <span class="hljs-keyword">if</span> (cStr == <span class="hljs-literal">NULL</span>) {
        <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// 内存不足</span>
    }

    <span class="hljs-comment">// 使用 C 字符串</span>
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Input: %s\n"</span>, cStr);

    <span class="hljs-comment">// 必须释放！</span>
    env-&gt;<span class="hljs-built_in">ReleaseStringUTFChars</span>(input, cStr);
}
</code></pre>
<h4 data-id="heading-35">7.4 数组内存管理</h4>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span>
JNIEXPORT jint JNICALL
Java_..._sumArray(JNIEnv *env, jobject thiz, jintArray array) {
    jint *cArray = <span class="hljs-literal">NULL</span>;
    jint sum = <span class="hljs-number">0</span>;

    <span class="hljs-comment">// 获取数组元素</span>
    cArray = env-&gt;<span class="hljs-built_in">GetIntArrayElements</span>(array, <span class="hljs-literal">NULL</span>);
    <span class="hljs-keyword">if</span> (cArray == <span class="hljs-literal">NULL</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// 失败</span>
    }

    <span class="hljs-comment">// 获取长度</span>
    jsize length = env-&gt;<span class="hljs-built_in">GetArrayLength</span>(array);

    <span class="hljs-comment">// 处理数组</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) {
        sum += cArray[i];
    }

    <span class="hljs-comment">// 释放数组</span>
    <span class="hljs-comment">// mode: 0 = 复制回去并释放，JNI_ABORT = 不复制直接释放</span>
    env-&gt;<span class="hljs-built_in">ReleaseIntArrayElements</span>(array, cArray, <span class="hljs-number">0</span>);

    <span class="hljs-keyword">return</span> sum;
}
</code></pre>
<h4 data-id="heading-36">7.5 全局引用示例</h4>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// 全局变量存储缓存</span>
<span class="hljs-type">static</span> jclass gStringClass = <span class="hljs-literal">NULL</span>;
<span class="hljs-type">static</span> jmethodID gStringConstructor = <span class="hljs-literal">NULL</span>;

<span class="hljs-comment">// 初始化函数</span>
<span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span>
JNIEXPORT <span class="hljs-type">void</span> JNICALL
Java_..._initCache(JNIEnv *env, jobject thiz) {
    <span class="hljs-comment">// 查找类</span>
    jclass localClass = env-&gt;<span class="hljs-built_in">FindClass</span>(<span class="hljs-string">"java/lang/String"</span>);

    <span class="hljs-comment">// 创建全局引用</span>
    gStringClass = (jclass)env-&gt;<span class="hljs-built_in">NewGlobalRef</span>(localClass);

    <span class="hljs-comment">// 删除局部引用（已有全局引用，不需要局部了）</span>
    env-&gt;<span class="hljs-built_in">DeleteLocalRef</span>(localClass);

    <span class="hljs-comment">// 获取方法 ID（不需要释放）</span>
    gStringConstructor = env-&gt;<span class="hljs-built_in">GetMethodID</span>(gStringClass, <span class="hljs-string">"&lt;init&gt;"</span>, <span class="hljs-string">"([B)V"</span>);
}

<span class="hljs-comment">// 使用缓存的引用</span>
<span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span>
JNIEXPORT jstring JNICALL
Java_..._createString(JNIEnv *env, jobject thiz, jbyteArray bytes) {
    <span class="hljs-comment">// 使用全局引用（无需再次查找）</span>
    <span class="hljs-keyword">return</span> (jstring)env-&gt;<span class="hljs-built_in">NewObject</span>(gStringClass, gStringConstructor, bytes);
}

<span class="hljs-comment">// 清理函数</span>
<span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span>
JNIEXPORT <span class="hljs-type">void</span> JNICALL
Java_..._cleanup(JNIEnv *env, jobject thiz) {
    <span class="hljs-keyword">if</span> (gStringClass != <span class="hljs-literal">NULL</span>) {
        env-&gt;<span class="hljs-built_in">DeleteGlobalRef</span>(gStringClass);
        gStringClass = <span class="hljs-literal">NULL</span>;
    }
}
</code></pre>
<hr/>
<h3 data-id="heading-37">8. 实战案例</h3>
<h4 data-id="heading-38">8.1 添加 Native 方法完整流程</h4>
<h5 data-id="heading-39">场景：实现获取图片元数据的 Native 方法</h5>
<p><strong>步骤 1：定义 Kotlin 数据类</strong></p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// ImageMetadata.kt</span>
<span class="hljs-keyword">package</span> com.example.ffmpeg

<span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ImageMetadata</span>(
    <span class="hljs-keyword">val</span> width: <span class="hljs-built_in">Int</span>,
    <span class="hljs-keyword">val</span> height: <span class="hljs-built_in">Int</span>,
    <span class="hljs-keyword">val</span> format: String,
    <span class="hljs-keyword">val</span> fileSize: <span class="hljs-built_in">Long</span>
) {
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getResolution</span><span class="hljs-params">()</span></span>: String = <span class="hljs-string">"<span class="hljs-subst">${width}</span>x<span class="hljs-subst">${height}</span>"</span>

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getReadableSize</span><span class="hljs-params">()</span></span>: String {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">when</span> {
            fileSize &lt; <span class="hljs-number">1024</span> -&gt; <span class="hljs-string">"<span class="hljs-subst">${fileSize}</span>B"</span>
            fileSize &lt; <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> -&gt; <span class="hljs-string">"<span class="hljs-subst">${fileSize / <span class="hljs-number">1024</span>}</span>KB"</span>
            <span class="hljs-keyword">else</span> -&gt; <span class="hljs-string">"<span class="hljs-subst">${fileSize / (<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>)}</span>MB"</span>
        }
    }
}
</code></pre>
<p><strong>步骤 2：在接口中声明方法</strong></p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// IImageCompress.kt</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">IImageCompress</span> {
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getMetadata</span><span class="hljs-params">(imagePath: <span class="hljs-type">String</span>)</span></span>: ImageMetadata?
}
</code></pre>
<p><strong>步骤 3：在实现类中调用 Native</strong></p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// ImageCompress.kt</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ImageCompress</span> : <span class="hljs-type">IImageCompress</span> {

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getMetadata</span><span class="hljs-params">(imagePath: <span class="hljs-type">String</span>)</span></span>: ImageMetadata? {
        <span class="hljs-keyword">if</span> (imagePath.isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>

        <span class="hljs-keyword">val</span> file = File(imagePath)
        <span class="hljs-keyword">if</span> (!file.exists()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>

        <span class="hljs-comment">// 调用 Native 方法</span>
        <span class="hljs-keyword">return</span> getImageMetadataNative(imagePath)
    }

    <span class="hljs-comment">// 声明 Native 方法</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">external</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getImageMetadataNative</span><span class="hljs-params">(path: <span class="hljs-type">String</span>)</span></span>: ImageMetadata?
}
</code></pre>
<p><strong>步骤 4：实现 C++ JNI 函数</strong></p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// ffmpegandoridlibrary.cpp</span>

<span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span>
<span class="hljs-function">JNIEXPORT jobject JNICALL
<span class="hljs-title">Java_com_example_ffmpeg_ImageCompress_getImageMetadataNative</span><span class="hljs-params">(
        JNIEnv *env,
        jobject thiz,
        jstring imagePath)</span> </span>{

    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *cPath = <span class="hljs-literal">NULL</span>;
    AVFormatContext *formatCtx = <span class="hljs-literal">NULL</span>;
    jobject metadataObj = <span class="hljs-literal">NULL</span>;

    <span class="hljs-comment">// 1. 验证输入</span>
    <span class="hljs-keyword">if</span> (imagePath == <span class="hljs-literal">NULL</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
    }

    <span class="hljs-comment">// 2. 转换字符串</span>
    cPath = env-&gt;<span class="hljs-built_in">GetStringUTFChars</span>(imagePath, <span class="hljs-literal">NULL</span>);
    <span class="hljs-keyword">if</span> (cPath == <span class="hljs-literal">NULL</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
    }

    <span class="hljs-comment">// 3. 打开文件（使用 FFmpeg）</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">avformat_open_input</span>(&amp;formatCtx, cPath, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>) != <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">goto</span> CLEANUP;
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">avformat_find_stream_info</span>(formatCtx, <span class="hljs-literal">NULL</span>) &lt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">goto</span> CLEANUP;
    }

    <span class="hljs-comment">// 4. 获取元数据</span>
    <span class="hljs-type">int</span> videoStreamIndex = <span class="hljs-built_in">av_find_best_stream</span>(
        formatCtx, AVMEDIA_TYPE_VIDEO, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>
    );

    <span class="hljs-keyword">if</span> (videoStreamIndex &lt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">goto</span> CLEANUP;
    }

    AVStream *stream = formatCtx-&gt;streams[videoStreamIndex];
    AVCodecParameters *codecPar = stream-&gt;codecpar;

    <span class="hljs-comment">// 获取文件大小</span>
    <span class="hljs-type">int64_t</span> fileSize = <span class="hljs-number">0</span>;
    FILE *file = <span class="hljs-built_in">fopen</span>(cPath, <span class="hljs-string">"rb"</span>);
    <span class="hljs-keyword">if</span> (file) {
        <span class="hljs-built_in">fseek</span>(file, <span class="hljs-number">0</span>, SEEK_END);
        fileSize = <span class="hljs-built_in">ftell</span>(file);
        <span class="hljs-built_in">fclose</span>(file);
    }

    <span class="hljs-comment">// 5. 创建 Kotlin 对象</span>
    jclass metadataClass = env-&gt;<span class="hljs-built_in">FindClass</span>(<span class="hljs-string">"com/example/ffmpeg/ImageMetadata"</span>);
    <span class="hljs-keyword">if</span> (metadataClass == <span class="hljs-literal">NULL</span>) {
        <span class="hljs-keyword">goto</span> CLEANUP;
    }

    <span class="hljs-comment">// 查找构造函数: (I I J Ljava/lang/String; J)</span>
    jmethodID constructor = env-&gt;<span class="hljs-built_in">GetMethodID</span>(
        metadataClass, <span class="hljs-string">"&lt;init&gt;"</span>, <span class="hljs-string">"(IILjava/lang/String;J)V"</span>
    );

    jstring formatStr = env-&gt;<span class="hljs-built_in">NewStringUTF</span>(<span class="hljs-string">"jpeg"</span>);

    metadataObj = env-&gt;<span class="hljs-built_in">NewObject</span>(
        metadataClass, constructor,
        codecPar-&gt;width,           <span class="hljs-comment">// Int width</span>
        codecPar-&gt;height,          <span class="hljs-comment">// Int height</span>
        formatStr,                 <span class="hljs-comment">// String format</span>
        (jlong)fileSize            <span class="hljs-comment">// Long fileSize</span>
    );

    <span class="hljs-comment">// 6. 清理局部引用</span>
    env-&gt;<span class="hljs-built_in">DeleteLocalRef</span>(formatStr);
    env-&gt;<span class="hljs-built_in">DeleteLocalRef</span>(metadataClass);

CLEANUP:
    <span class="hljs-comment">// 7. 释放资源</span>
    <span class="hljs-keyword">if</span> (formatCtx) {
        <span class="hljs-built_in">avformat_close_input</span>(&amp;formatCtx);
    }
    <span class="hljs-keyword">if</span> (cPath) {
        env-&gt;<span class="hljs-built_in">ReleaseStringUTFChars</span>(imagePath, cPath);
    }

    <span class="hljs-keyword">return</span> metadataObj;
}
</code></pre>
<p><strong>步骤 5：使用方法</strong></p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 在 Kotlin 代码中使用</span>
<span class="hljs-keyword">val</span> metadata = FFmpegCompress.getImageCompress()
    .getMetadata(<span class="hljs-string">"/sdcard/photo.jpg"</span>)

metadata?.let {
    println(<span class="hljs-string">"分辨率: <span class="hljs-subst">${it.getResolution()}</span>"</span>)
    println(<span class="hljs-string">"格式: <span class="hljs-subst">${it.format}</span>"</span>)
    println(<span class="hljs-string">"大小: <span class="hljs-subst">${it.getReadableSize()}</span>"</span>)
}
</code></pre>
<h4 data-id="heading-40">8.2 回调机制实现</h4>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// C++ 端：回调 Java 方法</span>

<span class="hljs-comment">// 1. 定义回调接口方法</span>
jmethodID onProgressMethod = env-&gt;<span class="hljs-built_in">GetMethodID</span>(
    listenerClass,
    <span class="hljs-string">"onProgress"</span>,
    <span class="hljs-string">"(II)V"</span>  <span class="hljs-comment">// (int, int) -&gt; void</span>
);

<span class="hljs-comment">// 2. 调用回调</span>
env-&gt;<span class="hljs-built_in">CallVoidMethod</span>(listener, onProgressMethod, <span class="hljs-number">50</span>, <span class="hljs-number">100</span>);

<span class="hljs-comment">// 3. 检查异常</span>
<span class="hljs-keyword">if</span> (env-&gt;<span class="hljs-built_in">ExceptionCheck</span>()) {
    env-&gt;<span class="hljs-built_in">ExceptionDescribe</span>();
    env-&gt;<span class="hljs-built_in">ExceptionClear</span>();
}
</code></pre>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// Kotlin 端：定义回调接口</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">ProgressListener</span> {
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onProgress</span><span class="hljs-params">(current: <span class="hljs-type">Int</span>, total: <span class="hljs-type">Int</span>)</span></span>
}

<span class="hljs-comment">// 使用</span>
comressor.enqueue(<span class="hljs-keyword">object</span> : ProgressListener {
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onProgress</span><span class="hljs-params">(current: <span class="hljs-type">Int</span>, total: <span class="hljs-type">Int</span>)</span></span> {
        println(<span class="hljs-string">"进度: <span class="hljs-variable">$current</span> / <span class="hljs-variable">$total</span>"</span>)
    }
})
</code></pre>
<hr/>
<h3 data-id="heading-41">9. 最佳实践</h3>
<h4 data-id="heading-42">9.1 命名规范</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// ✅ 推荐：避免重载，使用明确的方法名</span>
<span class="hljs-keyword">external</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">processImage</span><span class="hljs-params">(path: <span class="hljs-type">String</span>)</span></span>: <span class="hljs-built_in">Boolean</span>
<span class="hljs-keyword">external</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">processImageBytes</span><span class="hljs-params">(<span class="hljs-keyword">data</span>: <span class="hljs-type">ByteArray</span>)</span></span>: <span class="hljs-built_in">Boolean</span>

<span class="hljs-comment">// ❌ 不推荐：重载会导致签名复杂</span>
<span class="hljs-keyword">external</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-keyword">data</span>: <span class="hljs-type">String</span>)</span></span>: <span class="hljs-built_in">Boolean</span>
<span class="hljs-keyword">external</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-keyword">data</span>: <span class="hljs-type">ByteArray</span>)</span></span>: <span class="hljs-built_in">Boolean</span>
</code></pre>
<h4 data-id="heading-43">9.2 错误处理</h4>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// ✅ 推荐：统一清理标签</span>
<span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span>
JNIEXPORT jboolean JNICALL
Java_..._safeMethod(JNIEnv *env, jobject thiz, jstring input) {
    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *cInput = <span class="hljs-literal">NULL</span>;
    jboolean result = JNI_FALSE;

    <span class="hljs-comment">// 参数验证</span>
    <span class="hljs-keyword">if</span> (input == <span class="hljs-literal">NULL</span>) {
        <span class="hljs-keyword">return</span> JNI_FALSE;
    }

    <span class="hljs-comment">// 资源获取</span>
    cInput = env-&gt;<span class="hljs-built_in">GetStringUTFChars</span>(input, <span class="hljs-literal">NULL</span>);
    <span class="hljs-keyword">if</span> (cInput == <span class="hljs-literal">NULL</span>) {
        <span class="hljs-keyword">return</span> JNI_FALSE;  <span class="hljs-comment">// OOM</span>
    }

    <span class="hljs-comment">// 业务逻辑</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">doWork</span>(cInput) != <span class="hljs-number">0</span>) {
        <span class="hljs-comment">// 抛出异常</span>
        jclass exc = env-&gt;<span class="hljs-built_in">FindClass</span>(<span class="hljs-string">"java/lang/IllegalArgumentException"</span>);
        env-&gt;<span class="hljs-built_in">ThrowNew</span>(exc, <span class="hljs-string">"Operation failed"</span>);
        env-&gt;<span class="hljs-built_in">DeleteLocalRef</span>(exc);
        <span class="hljs-keyword">goto</span> CLEANUP;
    }

    result = JNI_TRUE;

CLEANUP:
    <span class="hljs-comment">// 统一清理</span>
    <span class="hljs-keyword">if</span> (cInput != <span class="hljs-literal">NULL</span>) {
        env-&gt;<span class="hljs-built_in">ReleaseStringUTFChars</span>(input, cInput);
    }
    <span class="hljs-keyword">return</span> result;
}
</code></pre>
<h4 data-id="heading-44">9.3 性能优化</h4>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// ✅ 推荐：缓存 jclass 和 jmethodID</span>
<span class="hljs-type">static</span> jclass gCachedClass = <span class="hljs-literal">NULL</span>;
<span class="hljs-type">static</span> jmethodID gCachedMethod = <span class="hljs-literal">NULL</span>;

<span class="hljs-comment">// 初始化时缓存</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">initCache</span><span class="hljs-params">(JNIEnv *env)</span> </span>{
    jclass local = env-&gt;<span class="hljs-built_in">FindClass</span>(<span class="hljs-string">"java/lang/String"</span>);
    gCachedClass = (jclass)env-&gt;<span class="hljs-built_in">NewGlobalRef</span>(local);
    gCachedMethod = env-&gt;<span class="hljs-built_in">GetMethodID</span>(gCachedClass, <span class="hljs-string">"getBytes"</span>, <span class="hljs-string">"()[B"</span>);
    env-&gt;<span class="hljs-built_in">DeleteLocalRef</span>(local);
}

<span class="hljs-comment">// 使用时直接使用缓存</span>
<span class="hljs-function">jbyteArray <span class="hljs-title">stringToBytes</span><span class="hljs-params">(JNIEnv *env, jstring str)</span> </span>{
    <span class="hljs-keyword">return</span> (jbyteArray)env-&gt;<span class="hljs-built_in">CallObjectMethod</span>(str, gCachedMethod);
}
</code></pre>
<h4 data-id="heading-45">9.4 线程安全</h4>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// ✅ JNI 方法本身是线程安全的</span>
<span class="hljs-comment">// 但共享数据需要加锁</span>

<span class="hljs-type">static</span> <span class="hljs-type">pthread_mutex_t</span> gLock = PTHREAD_MUTEX_INITIALIZER;

<span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span>
JNIEXPORT <span class="hljs-type">void</span> JNICALL
Java_..._threadSafeMethod(JNIEnv *env, jobject thiz) {
    <span class="hljs-comment">// 加锁</span>
    <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;gLock);

    <span class="hljs-comment">// 访问共享资源</span>
    <span class="hljs-comment">// ...</span>

    <span class="hljs-comment">// 解锁</span>
    <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;gLock);
}
</code></pre>
<h4 data-id="heading-46">9.5 调试技巧</h4>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// Android 日志输出</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;android/log.h&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_TAG <span class="hljs-string">"FFmpegNative"</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> LOGI(...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> LOGE(...) __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__)</span>

<span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span>
JNIEXPORT <span class="hljs-type">void</span> JNICALL
Java_..._debugMethod(JNIEnv *env, jobject thiz) {
    <span class="hljs-built_in">LOGI</span>(<span class="hljs-string">"Method called"</span>);
    <span class="hljs-built_in">LOGE</span>(<span class="hljs-string">"Error occurred: %s"</span>, <span class="hljs-string">"details"</span>);
}
</code></pre>
<hr/>
<h3 data-id="heading-47">10. 常见问题</h3>
<h4 data-id="heading-48">10.1 UnsatisfiedLinkError</h4>
<pre><code class="hljs language-markdown" lang="markdown">错误：java.lang.UnsatisfiedLinkError: No implementation found for method

原因：
<span class="hljs-bullet">1.</span> JNI 函数名不匹配
<span class="hljs-bullet">2.</span> 没有加载 .so 库
<span class="hljs-bullet">3.</span> .so 库架构不匹配
<span class="hljs-bullet">4.</span> extern "C" 缺失

解决：
<span class="hljs-bullet">1.</span> 检查函数名是否完全匹配
<span class="hljs-bullet">2.</span> 确保调用 System.loadLibrary()
<span class="hljs-bullet">3.</span> 检查 CPU 架构（arm64-v8a, armeabi-v7a）
<span class="hljs-bullet">4.</span> 添加 extern "C"
</code></pre>
<h4 data-id="heading-49">10.2 内存泄漏</h4>
<pre><code class="hljs language-objectivec" lang="objectivec">问题：GetStringUTFChars 后没有 Release

解决：使用 <span class="hljs-keyword">goto</span> <span class="hljs-built_in">CLEANUP</span> 模式
</code></pre>
<h4 data-id="heading-50">10.3 局部引用溢出</h4>
<pre><code class="hljs language-scss" lang="scss">问题：循环中创建大量局部引用

解决：及时 <span class="hljs-built_in">DeleteLocalRef</span>()
</code></pre>
<h4 data-id="heading-51">10.4 多线程问题</h4>
<pre><code class="hljs">问题：JNIEnv 不能跨线程使用

解决：每个线程通过 JavaVM 获取自己的 JNIEnv
</code></pre>
<pre><code class="hljs language-cpp" lang="cpp">JavaVM *gVM = <span class="hljs-literal">NULL</span>;

<span class="hljs-comment">// JNI_OnLoad 保存 JavaVM</span>
<span class="hljs-function">JNIEXPORT jint JNICALL <span class="hljs-title">JNI_OnLoad</span><span class="hljs-params">(JavaVM *vm, <span class="hljs-type">void</span> *reserved)</span> </span>{
    gVM = vm;
    <span class="hljs-keyword">return</span> JNI_VERSION_1_6;
}

<span class="hljs-comment">// 在新线程中获取 JNIEnv</span>
<span class="hljs-function">JNIEnv* <span class="hljs-title">getJNIEnv</span><span class="hljs-params">()</span> </span>{
    JNIEnv *env = <span class="hljs-literal">NULL</span>;
    gVM-&gt;<span class="hljs-built_in">GetEnv</span>((<span class="hljs-type">void</span>**)&amp;env, JNI_VERSION_1_6);
    <span class="hljs-keyword">if</span> (env == <span class="hljs-literal">NULL</span>) {
        <span class="hljs-comment">// 线程附加</span>
        gVM-&gt;<span class="hljs-built_in">AttachCurrentThread</span>(&amp;env, <span class="hljs-literal">NULL</span>);
    }
    <span class="hljs-keyword">return</span> env;
}
</code></pre>
<hr/>
<h3 data-id="heading-52">总结</h3>
<p>本文档涵盖了 Android JNI 开发的核心知识点：</p>
<ol>
<li><strong>JNI 基础</strong>：理解 Kotlin 和 C/C++ 交互的桥梁</li>
<li><strong>external 关键字</strong>：声明 Native 方法的关键字</li>
<li><strong>命名规范</strong>：Java 方法到 C 函数的映射规则</li>
<li><strong>库加载机制</strong>：.so 文件如何被 JVM 加载和使用</li>
<li><strong>方法查找缓存</strong>：JVM 如何高效查找 Native 方法</li>
<li><strong>类型系统</strong>：Kotlin 和 C++ 类型的对应关系</li>
<li><strong>内存管理</strong>：Local/Global/Weak 引用的生命周期</li>
<li><strong>实战案例</strong>：完整的 Native 方法实现流程</li>
<li><strong>最佳实践</strong>：命名、错误处理、性能优化</li>
<li><strong>常见问题</strong>：错误排查和解决方案</li>
</ol>
<p>掌握这些知识点，你就可以熟练地在 Android 项目中使用 JNI 进行高性能开发！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Mybatis插件原理及分页插件]]></title>    <link>https://juejin.cn/post/7596181746082955314</link>    <guid>https://juejin.cn/post/7596181746082955314</guid>    <pubDate>2026-01-18T14:11:33.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7596181746082955314" data-draft-id="7595895132261302323" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Mybatis插件原理及分页插件"/> <meta itemprop="keywords" content="Java,架构,源码阅读"/> <meta itemprop="datePublished" content="2026-01-18T14:11:33.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="程序员侠客行"/> <meta itemprop="url" content="https://juejin.cn/user/556801719828361"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Mybatis插件原理及分页插件
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/556801719828361/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    程序员侠客行
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-18T14:11:33.000Z" title="Sun Jan 18 2026 14:11:33 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-18
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>Mybatis框架允许用户通过自定义拦截器来改变SQL的执行行为，例如在SQL执行追加分页语句、统计SQL执行耗时等。<strong>自定义拦截器也被称为Mybatis插件，插件是 MyBatis 扩展核心功能的常用方式。</strong></p>
<blockquote>
<p>注：本文中源码来自mybatis 3.4.x版本，地址<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmybatis%2Fmybatis-3.git" target="_blank" title="https://github.com/mybatis/mybatis-3.git" ref="nofollow noopener noreferrer">github.com/mybatis/myb…</a></p>
</blockquote>
<h2 data-id="heading-0">一 插件原理</h2>
<h3 data-id="heading-1">1.1 配置插件信息</h3>
<p>在Mybatis主配置文件中，通过标签来注册自定义插件。如</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span> <span class="hljs-attr">interceptor</span>=<span class="hljs-string">"com.example.MyCustomPlugin"</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- 可选：传递属性给插件
        &lt;property name="name" value="page"/&gt;
    &lt;/plugin&gt;
&lt;/plugins&gt;
</span></code></pre>
<p>在XMLConfigBuilder#parseConfiguration中，会解析plugins标签内容，创建Interceptor并注册到Configuration的InterceptorChain interceptorChain。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fc0fe777186e40f898155ff89fd9159e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY5L6g5a6i6KGM:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769350292&amp;x-signature=vTq9vmmJ09YEOR9j%2FpowsblYq%2F4%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-2">1.2 声明拦截器</h3>
<p>MyBatis 插件本质是基于动态代理实现的，只能拦截四大核心对象的方法：</p>
<ul>
<li><code>Executor</code>：执行器（负责 SQL 执行、缓存管理）</li>
<li><code>StatementHandler</code>：SQL 语句处理器（负责 SQL 构建、参数设置）</li>
<li><code>ParameterHandler</code>：参数处理器（负责参数解析）</li>
<li><code>ResultSetHandler</code>：结果集处理器（负责结果集映射）</li>
</ul>
<p>为什么是这4大组件呢？Configuration作为这些组件的创建工厂，会应用拦截器并返回代理对象（以StatementHandler为例）</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f033b0d7303a46a3b81c3d38302a36d2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY5L6g5a6i6KGM:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769350292&amp;x-signature=0aop%2FfoyKZCNf0Z2pAgzsYufMYI%3D" alt="" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/94f45da419444992a080d5bab14b04cf~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY5L6g5a6i6KGM:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769350292&amp;x-signature=pgjv8%2FzTfhk65ARJVsS7i3iJYB4%3D" alt="" loading="lazy"/></p>
<p>自定义插件需要实现Interceptor接口</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/01aeed30ec1248ebb58e1f705fbff15c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY5L6g5a6i6KGM:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769350292&amp;x-signature=TbbRGiHyKjtkj7xb239ktadsaPw%3D" alt="" loading="lazy"/></p>
<p>其中，Invocation封装了目标对象、方法及参数信息，通过它来获取上述4个组件对象的所有信息。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Invocation</span> {

  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object target;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Method method;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object[] args;
  <span class="hljs-comment">// 回调原方法</span>
  <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">proceed</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InvocationTargetException, IllegalAccessException {
    <span class="hljs-keyword">return</span> method.invoke(target, args);
  }
}
</code></pre>
<h3 data-id="heading-3">1.3 创建代理对象</h3>
<p>为了方便创建<code>Executor</code>等的代理对象，Mybatis提供了一个Plugin工具类。关键代码如下：
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9147206faafa49c48af1620a1d464305~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY5L6g5a6i6KGM:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769350292&amp;x-signature=0DnLWGEe3aTlclWbvOmODrtkZG8%3D" alt="" loading="lazy"/>Plugin类实现了InvocationHandler接口，即采用JDK动态代理来创建代理对象。当<code>Executor</code>执行某个方法时，如果方法被指定需要增强，就会先执行Interceptor#intercept方法。</p>
<p>Plugin#getSignatureMap方法，会解析Interceptor实现类的Intercepts注解信息，得到拦截范围。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// @Intercepts 注解：指定拦截的对象和方法（核心）</span>
<span class="hljs-meta">@Intercepts({
    // @Signature：单个拦截规则
    // type：拦截的核心对象（Executor/StatementHandler 等）
    // method：拦截的方法名（比如 Executor 的 query 方法）
    // args：拦截方法的参数类型（用于区分重载方法）
    @Signature(
        type = Executor.class,
        method = "query",
        args = {org.apache.ibatis.mapping.MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class}
    )
})</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCustomPlugin</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Interceptor</span> {
}
</code></pre>
<h3 data-id="heading-4">1.4 自定义插件示例</h3>
<p>我们只需要实现Interceptor接口，在intercept()中编写增强逻辑，通过plugin()返回一个代理对象，就能自定义一个Mybatis插件了。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Intercepts({
    @Signature(
        type = Executor.class,
        method = "query",
        args = {org.apache.ibatis.mapping.MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class}
    )
})</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCustomPlugin</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Interceptor</span> {
    <span class="hljs-keyword">private</span> String name;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Invocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable {
        Object[] args = invocation.getArgs();
        System.out.println(<span class="hljs-string">"SQL 执行参数："</span> + args[<span class="hljs-number">1</span>]);
        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> invocation.proceed();
        System.out.println(<span class="hljs-string">"===== query 方法执行完成 ====="</span>);
        <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-comment">// 生成代理对象</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">plugin</span><span class="hljs-params">(Object target)</span> {
        <span class="hljs-keyword">return</span> Plugin.wrap(target, <span class="hljs-built_in">this</span>);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setProperties</span><span class="hljs-params">(Properties properties)</span> {
        <span class="hljs-built_in">this</span>.name = properties.getProperty(<span class="hljs-string">"name"</span>);
    }
}
</code></pre>
<h2 data-id="heading-5">二 自定义分页插件</h2>
<h3 data-id="heading-6">2.1 Mybatis自带分页功能</h3>
<p>其实，Mybatis支持分页查询，只可惜是内存分页，仍然会查询全部数据，只是在内存中过滤。</p>
<p>使用RowBounds类，通过 offset（偏移量）和 limit（限制数量）控制所要处理的结果集范围，相当于执行了 resultList.subList(offset, offset + limit)。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// SqlSession中</span>
&lt;E&gt; List&lt;E&gt; <span class="hljs-title function_">selectList</span><span class="hljs-params">(String statement, Object parameter, RowBounds rowBounds)</span>;
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a5b5b7a1c734418d86e2bc1a872db0f8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY5L6g5a6i6KGM:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769350292&amp;x-signature=4c38cFt%2Bo3C6E30faf6IKkMoSNA%3D" alt="" loading="lazy"/>
在处理ResultSet时，跳过offset条，限制最多处理limit条。
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a53eab57dad5473a84a65a34c828e106~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY5L6g5a6i6KGM:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769350292&amp;x-signature=MCjjxiK0JMPVTxhvGEfagMSZi9w%3D" alt="" loading="lazy"/></p>
<p><strong>RowBounds只适合数据量不大的场景，生产环境通常使用物理分页插件替代。</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-type">SqlSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession();
<span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> session.getMapper(UserMapper.class);
<span class="hljs-comment">// 跳过前10条，返回最多20条记录</span>
<span class="hljs-type">RowBounds</span> <span class="hljs-variable">rowBounds</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RowBounds</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);
List&lt;User&gt; user = mapper.selectByAge(<span class="hljs-number">20</span>, rowBounds);
</code></pre>
<h3 data-id="heading-7">2.2 自定义分页插件</h3>
<p>基于我们掌握的插件原理，完全可以自行定义一个分页插件。</p>
<p>首先，我们声明一个Page类来封装分页参数</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Page</span>&lt;T&gt; {
  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">pageNo</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;      <span class="hljs-comment">// 当前页码</span>
  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">pageSize</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;    <span class="hljs-comment">// 每页大小</span>
  <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> total;           <span class="hljs-comment">// 总记录数</span>
  <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> totalPage;   	<span class="hljs-comment">// 总页数</span>
  <span class="hljs-comment">// 省略getter/setter</span>
}
</code></pre>
<p>再创建拦截器，拦截 StatementHandler 的 prepare 方法，改写 SQL 添加分页语句，并额外查询一次总记录数。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">import</span> java.sql.Connection;
<span class="hljs-keyword">import</span> java.sql.PreparedStatement;
<span class="hljs-keyword">import</span> java.sql.ResultSet;
<span class="hljs-keyword">import</span> java.util.List;
<span class="hljs-keyword">import</span> java.util.Properties;
<span class="hljs-keyword">import</span> org.apache.ibatis.executor.statement.RoutingStatementHandler;
<span class="hljs-keyword">import</span> org.apache.ibatis.executor.statement.StatementHandler;
<span class="hljs-keyword">import</span> org.apache.ibatis.mapping.BoundSql;
<span class="hljs-keyword">import</span> org.apache.ibatis.mapping.MappedStatement;
<span class="hljs-keyword">import</span> org.apache.ibatis.mapping.ParameterMapping;
<span class="hljs-keyword">import</span> org.apache.ibatis.reflection.SystemMetaObject;
<span class="hljs-keyword">import</span> org.apache.ibatis.scripting.defaults.DefaultParameterHandler;

<span class="hljs-comment">/**
 * MySQL 分页插件
 * 拦截 StatementHandler 的 prepare 方法，改写 SQL 添加分页语句
 */</span>
<span class="hljs-meta">@Intercepts({
    @Signature(type = StatementHandler.class, method = "prepare", args = {Connection.class, Integer.class})
})</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PageInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Interceptor</span> {

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Invocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable {
        <span class="hljs-type">RoutingStatementHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> (RoutingStatementHandler) invocation.getTarget();
        <span class="hljs-type">StatementHandler</span> <span class="hljs-variable">delegate</span> <span class="hljs-operator">=</span> (StatementHandler) SystemMetaObject.forObject(handler).getValue(<span class="hljs-string">"delegate"</span>);
        <span class="hljs-type">MappedStatement</span> <span class="hljs-variable">mappedStatement</span> <span class="hljs-operator">=</span> (MappedStatement) SystemMetaObject.forObject(delegate).getValue(<span class="hljs-string">"mappedStatement"</span>);

        <span class="hljs-comment">// 获取 BoundSql</span>
        <span class="hljs-type">BoundSql</span> <span class="hljs-variable">boundSql</span> <span class="hljs-operator">=</span> delegate.getBoundSql();
        <span class="hljs-type">Object</span> <span class="hljs-variable">parameterObject</span> <span class="hljs-operator">=</span> boundSql.getParameterObject();

        <span class="hljs-comment">// 判断参数是否为 Page 对象</span>
        <span class="hljs-keyword">if</span> (parameterObject <span class="hljs-keyword">instanceof</span> Page) {
            Page&lt;?&gt; page = (Page&lt;?&gt;) parameterObject;
            <span class="hljs-type">String</span> <span class="hljs-variable">originalSql</span> <span class="hljs-operator">=</span> boundSql.getSql();

            <span class="hljs-comment">// 1. 查询总记录数</span>
            <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> (Connection) invocation.getArgs()[<span class="hljs-number">0</span>];
            <span class="hljs-type">long</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.queryTotal(connection, page, mappedStatement);
            page.setTotal(total);
            page.setTotalPage(total % page.getPageSize() == <span class="hljs-number">0</span> ? total / page.getPageSize() : total / page.getPageSize() + <span class="hljs-number">1</span>);
            
            <span class="hljs-comment">// 2. 改写 SQL，添加 LIMIT 分页</span>
            <span class="hljs-type">String</span> <span class="hljs-variable">pageSql</span> <span class="hljs-operator">=</span> originalSql + <span class="hljs-string">" LIMIT "</span> + page.getOffset() + <span class="hljs-string">", "</span> + page.getPageSize();

            <span class="hljs-comment">// 通过反射修改 BoundSql 中的 SQL</span>
            SystemMetaObject.forObject(boundSql).setValue(<span class="hljs-string">"sql"</span>, pageSql);
        }
        <span class="hljs-keyword">return</span> invocation.proceed();
    }

    <span class="hljs-comment">/**
   * 查询总记录数
   */</span>
  <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-title function_">queryTotal</span><span class="hljs-params">(Connection connection, Object parameterObject, MappedStatement mappedStatement)</span> <span class="hljs-keyword">throws</span> Exception {
    <span class="hljs-type">BoundSql</span> <span class="hljs-variable">boundSql</span> <span class="hljs-operator">=</span> mappedStatement.getBoundSql(parameterObject);
    <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">"SELECT COUNT(*) FROM ("</span> + boundSql.getSql() + <span class="hljs-string">") tmp_count"</span>;
    <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;
    <span class="hljs-type">ResultSet</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">try</span> {
      ps = connection.prepareStatement(sql);
      <span class="hljs-comment">// 设置参数（如果有）</span>
      <span class="hljs-keyword">if</span> (boundSql.getParameterMappings() != <span class="hljs-literal">null</span> &amp;&amp; !boundSql.getParameterMappings().isEmpty()) {
        List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();
        <span class="hljs-type">BoundSql</span> <span class="hljs-variable">countSql</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BoundSql</span>(mappedStatement.getConfiguration(), sql, parameterMappings, parameterObject);
        <span class="hljs-type">DefaultParameterHandler</span> <span class="hljs-variable">parameterHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultParameterHandler</span>(mappedStatement, parameterObject, countSql);
        parameterHandler.setParameters(ps);
      }

      rs = ps.executeQuery();
      <span class="hljs-keyword">if</span> (rs.next()) {
        <span class="hljs-keyword">return</span> rs.getLong(<span class="hljs-number">1</span>);
      }
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    } <span class="hljs-keyword">finally</span> {
      <span class="hljs-keyword">if</span> (rs != <span class="hljs-literal">null</span>) {
        rs.close();
      }
      <span class="hljs-keyword">if</span> (ps != <span class="hljs-literal">null</span>) {
        ps.close();
      }
    }
  }


  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">plugin</span><span class="hljs-params">(Object target)</span> {
    <span class="hljs-comment">// 只拦截 StatementHandler</span>
    <span class="hljs-keyword">if</span> (target <span class="hljs-keyword">instanceof</span> StatementHandler) {
      <span class="hljs-keyword">return</span> Plugin.wrap(target, <span class="hljs-built_in">this</span>);
    }
    <span class="hljs-keyword">return</span> target;
  }

  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setProperties</span><span class="hljs-params">(Properties properties)</span> {
  }
}
</code></pre>
<p>在Mybatis主配置中添加插件。</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span> <span class="hljs-attr">interceptor</span>=<span class="hljs-string">"com.example.PageInterceptor"</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>
</code></pre>
<p>创建UserQuery类，封装查询条件。执行查询后，就能从UserQuery中获取total等。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserQuery</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Page</span>&lt;User&gt; {

  <span class="hljs-keyword">private</span> String name;          <span class="hljs-comment">// 姓名（模糊查询）</span>
  <span class="hljs-keyword">private</span> Integer minAge;       <span class="hljs-comment">// 最小年龄</span>
  <span class="hljs-keyword">private</span> Integer maxAge;       <span class="hljs-comment">// 最大年龄</span>
  <span class="hljs-keyword">private</span> String sex;
  <span class="hljs-comment">// 省略getter/setter</span>
}
</code></pre>
<pre><code class="hljs language-java" lang="java"><span class="hljs-type">UserQuery</span> <span class="hljs-variable">query</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserQuery</span>();
query.setPageNum(<span class="hljs-number">1</span>);
query.setPageSize(<span class="hljs-number">20</span>);
query.setName(<span class="hljs-string">"张三"</span>);
query.setMinAge(<span class="hljs-number">20</span>);
query.setMaxAge(<span class="hljs-number">40</span>);
List&lt;User&gt; users = userMapper.selectByPage(query);
<span class="hljs-type">long</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> query.getTotal();
<span class="hljs-type">long</span> <span class="hljs-variable">totalPage</span> <span class="hljs-operator">=</span> query.getTotalPage();
</code></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[【技术专题】AI大模型应用开发入门-拥抱Hugging Face与Transformers生态 - 基于BERT文本分类模型微调]]></title>    <link>https://juejin.cn/post/7596709272976064558</link>    <guid>https://juejin.cn/post/7596709272976064558</guid>    <pubDate>2026-01-19T09:43:15.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7596709272976064558" data-draft-id="7596698363964096550" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="【技术专题】AI大模型应用开发入门-拥抱Hugging Face与Transformers生态 - 基于BERT文本分类模型微调"/> <meta itemprop="keywords" content="人工智能"/> <meta itemprop="datePublished" content="2026-01-19T09:43:15.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="小锋java1234"/> <meta itemprop="url" content="https://juejin.cn/user/4152222342709933"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            【技术专题】AI大模型应用开发入门-拥抱Hugging Face与Transformers生态 - 基于BERT文本分类模型微调
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4152222342709933/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    小锋java1234
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-19T09:43:15.000Z" title="Mon Jan 19 2026 09:43:15 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读14分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>大家好，我是锋哥。最近连载更新《AI大模型应用开发入门-拥抱Hugging Face与Transformers生态》技术专题。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c9ed9d66e2f0492290168c5ed9f7163a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP6ZSLamF2YTEyMzQ=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769420595&amp;x-signature=keA%2FiGkRKSn37iE8vphMx7PN7Uk%3D" alt="QQ截图20260117190029.jpg" loading="lazy"/> 本课程主要介绍和讲解Hugging Face和Transformers，包括加载预训练模型，自定义数据集，模型推理，模型微调，模型性能评估等。是AI大模型应用开发的入门必备知识。 同时也配套视频教程<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV11L6RBwE8m%2F" title="https://link.juejin.cn?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV11L6RBwE8m%2F" target="_blank">《2027版 AI大模型应用开发入门-拥抱Hugging Face与Transformers生态 视频教程(无废话版) 玩命更新中~》</a></p>
<h2 data-id="heading-0">模型微调简介</h2>
<p><strong>模型微调</strong>（Model Fine-Tuning） 是迁移学习中的一种核心技术，指在一个已经预训练好的大型通用模型（称为<strong>基座模型</strong>）的基础上，使用<strong>特定领域或任务的数据集</strong>进行额外的、有针对性的训练，使模型适应新任务的过程。</p>
<p><strong>通俗比喻：</strong></p>
<ul>
<li><strong>预训练</strong>：让一个学生（模型）读完整个图书馆的书，获得广泛的通识知识。</li>
<li><strong>微调</strong>：然后让这个学生专攻某一个学科（例如医学或法律），学习这个领域的专业书籍和案例，从而成为该领域的专家。</li>
</ul>
<h2 data-id="heading-1">为什么需要微调？（优势）</h2>
<ol start="0">
<li><strong>降低数据需求</strong>：从头训练一个大模型（如LLM或CV大模型）需要海量数据和巨大的算力。微调只需相对少量的高质量专业数据即可，成本极低。</li>
<li><strong>节省计算资源和时间</strong>：预训练模型已经学会了通用的特征表示（如语言规则、图像纹理），微调只需在此基础上“微调”参数，训练速度快得多。</li>
<li><strong>提升特定任务性能</strong>：在目标领域（如医疗问答、法律文书分析、特定风格的绘画）上，微调后的模型性能远优于直接使用通用模型。</li>
<li><strong>避免灾难性遗忘</strong>：与从头学习相比，微调是一种温和的调整，能在保持模型通用能力的同时，增强其专业能力。</li>
</ol>
<h2 data-id="heading-2">基于BERT模型微调训练</h2>
<h3 data-id="heading-3">1，自定义数据集</h3>
<p>首先我们准备下训练和测试数据。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c6d4c47df3174676ae06edc9f921c014~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP6ZSLamF2YTEyMzQ=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769420595&amp;x-signature=LT6Gg9qdCfZgVR4tgpMo8hQUY7c%3D" alt="image.png" loading="lazy"/></p>
<p>8千多条的训练集数据，2千多条的测试集数据。</p>
<p>我们之所以要自定义数据集，是因为需要去适配训练模型需要的数据格式。</p>
<p>自定义数据集参考代码：</p>
<pre><code class="hljs language-ini" lang="ini">from datasets import load_dataset
from torch.utils.data import Dataset
​
​
<span class="hljs-comment"># 自定义数据集</span>
class MyDataset(Dataset):
​
    def __init__(self, split):
        <span class="hljs-comment"># 加载训练集</span>
        <span class="hljs-attr">train_dataset</span> = load_dataset(path=<span class="hljs-string">"csv"</span>, data_files=<span class="hljs-string">"../weibo_senti_8k_train.csv"</span>)
        <span class="hljs-comment"># 加载测试集</span>
        <span class="hljs-attr">test_dataset</span> = load_dataset(path=<span class="hljs-string">"csv"</span>, data_files=<span class="hljs-string">"../weibo_senti_2k_test.csv"</span>)
        if <span class="hljs-attr">split</span> == <span class="hljs-string">'train'</span>:
            <span class="hljs-attr">self.data</span> = train_dataset[<span class="hljs-string">'train'</span>]
        elif <span class="hljs-attr">split</span> == <span class="hljs-string">'test'</span>:
            <span class="hljs-attr">self.data</span> = test_dataset[<span class="hljs-string">'train'</span>]
​
    <span class="hljs-comment"># 获取数据集大小</span>
    def __len__(self):
        return len(self.data)
​
    <span class="hljs-comment"># 获取数据集的某个元素</span>
    def __getitem__(self, index):
        <span class="hljs-attr">sentence</span> = self.data[index][<span class="hljs-string">'sentence'</span>]
        <span class="hljs-attr">label</span> = self.data[index][<span class="hljs-string">'label'</span>]
        return sentence, label
​
​
if <span class="hljs-attr">__name__</span> == <span class="hljs-string">'__main__'</span>:
    <span class="hljs-attr">train_dataset</span> = MyDataset(<span class="hljs-string">'train'</span>)
    <span class="hljs-attr">test_dataset</span> = MyDataset(<span class="hljs-string">'test'</span>)
    print(train_dataset<span class="hljs-section">[0]</span>)
    print(test_dataset<span class="hljs-section">[0]</span>)
</code></pre>
<p>运行结果：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/82098dd957f74b1fb7e70c6baef17e9f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP6ZSLamF2YTEyMzQ=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769420595&amp;x-signature=cHoiPcnDFXzYHP1Qv785IEhrvGU%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-4">2，对训练输入文本进行编码</h3>
<p>对传入的数据进行训练之前，我们需要对数据进行编码。</p>
<p>我们通过分词器的batch_encode_plus方法进行批量编码；</p>
<p>实例代码：</p>
<pre><code class="hljs language-ini" lang="ini">from transformers import BertTokenizer
​
<span class="hljs-comment"># 加载分词器</span>
<span class="hljs-attr">tokenizer</span> = BertTokenizer.from_pretrained(<span class="hljs-string">'../Bert-base-chinese'</span>)
​
<span class="hljs-comment"># 准备测试文本</span>
<span class="hljs-attr">sents</span> = [<span class="hljs-string">'床前明月光，疑似地上霜，举头望明月，低头思故乡'</span>, <span class="hljs-string">'今天天气不错'</span>, <span class="hljs-string">'很开心'</span>]
​
<span class="hljs-comment"># 批量编码句子</span>
<span class="hljs-attr">out</span> = tokenizer.batch_encode_plus(
    <span class="hljs-attr">batch_text_or_text_pairs</span>=sents,  <span class="hljs-comment"># 输入的文本</span>
    <span class="hljs-attr">add_special_tokens</span>=<span class="hljs-literal">True</span>,  <span class="hljs-comment"># 添加特殊标记</span>
    <span class="hljs-attr">max_length</span>=<span class="hljs-number">10</span>,  <span class="hljs-comment"># 最大长度</span>
    <span class="hljs-attr">padding</span>=<span class="hljs-string">'max_length'</span>,  <span class="hljs-comment"># 填充</span>
    <span class="hljs-attr">truncation</span>=<span class="hljs-literal">True</span>,  <span class="hljs-comment"># 截断</span>
    <span class="hljs-attr">return_tensors</span>=<span class="hljs-string">'pt'</span>,  <span class="hljs-comment"># 返回pytorch张量</span>
    <span class="hljs-attr">return_token_type_ids</span>=<span class="hljs-literal">True</span>,  <span class="hljs-comment"># 返回token_type_ids  区分不同句子或段落的类型标识</span>
    <span class="hljs-attr">return_attention_mask</span>=<span class="hljs-literal">True</span>,  <span class="hljs-comment"># 返回attention_mask  标记有效token位置的掩码</span>
    <span class="hljs-attr">return_special_tokens_mask</span>=<span class="hljs-literal">True</span>  <span class="hljs-comment"># 返回special_tokens_mask 标识特殊token（如[CLS]、[SEP]）的位置掩码</span>
)
print(out)
for k, v in out.items():
    print(k, v)
​
<span class="hljs-comment"># 解码文本数据</span>
for i in range(len(sents)):
    print(sents<span class="hljs-section">[i]</span> + "--编码后：", tokenizer.decode(out<span class="hljs-section">['input_ids']</span><span class="hljs-section">[i]</span>))
</code></pre>
<p>运行输出：</p>
<pre><code class="hljs language-lua" lang="lua">{<span class="hljs-string">'input_ids'</span>: tensor(<span class="hljs-string">[[ 101, 2414, 1184, 3209, 3299, 1045, 8024, 4542,  849,  102],
        [ 101,  791, 1921, 1921, 3698,  679, 7231,  102,    0,    0],
        [ 101, 2523, 2458, 2552,  102,    0,    0,    0,    0,    0]]</span>), <span class="hljs-string">'token_type_ids'</span>: tensor(<span class="hljs-string">[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]</span>), <span class="hljs-string">'special_tokens_mask'</span>: tensor(<span class="hljs-string">[[1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 1, 1, 1],
        [1, 0, 0, 0, 1, 1, 1, 1, 1, 1]]</span>), <span class="hljs-string">'attention_mask'</span>: tensor(<span class="hljs-string">[[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 0, 0],
        [1, 1, 1, 1, 1, 0, 0, 0, 0, 0]]</span>)}
input_ids tensor(<span class="hljs-string">[[ 101, 2414, 1184, 3209, 3299, 1045, 8024, 4542,  849,  102],
        [ 101,  791, 1921, 1921, 3698,  679, 7231,  102,    0,    0],
        [ 101, 2523, 2458, 2552,  102,    0,    0,    0,    0,    0]]</span>)
token_type_ids tensor(<span class="hljs-string">[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]</span>)
special_tokens_mask tensor(<span class="hljs-string">[[1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 1, 1, 1],
        [1, 0, 0, 0, 1, 1, 1, 1, 1, 1]]</span>)
attention_mask tensor(<span class="hljs-string">[[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 0, 0],
        [1, 1, 1, 1, 1, 0, 0, 0, 0, 0]]</span>)
床前明月光，疑似地上霜，举头望明月，低头思故乡<span class="hljs-comment">--编码后： [CLS] 床 前 明 月 光 ， 疑 似 [SEP]</span>
今天天气不错<span class="hljs-comment">--编码后： [CLS] 今 天 天 气 不 错 [SEP] [PAD] [PAD]</span>
很开心<span class="hljs-comment">--编码后： [CLS] 很 开 心 [SEP] [PAD] [PAD] [PAD] [PAD] [PAD]</span>
</code></pre>
<h3 data-id="heading-5">3，定义增量模型，也就是下游任务</h3>
<p>我们定义增量模型，主要是在Bert模型最后加一个全连接层，实现二分类任务。进行前向传播的时候，我们要使用torch.no_grad()冻结Bert模型参数，不需计算梯度，获取最后一层Bert隐藏层输出，调用自定义的全连接层，进行增量模型训练。</p>
<p>示例代码：</p>
<pre><code class="hljs language-ruby" lang="ruby"><span class="hljs-comment"># 使用设备（GPU/CPU）</span>
device = torch.device(<span class="hljs-string">"cuda"</span> <span class="hljs-keyword">if</span> torch.cuda.is_available() <span class="hljs-keyword">else</span> <span class="hljs-string">"cpu"</span>)
print(device)
​
<span class="hljs-comment"># 加载预训练模型</span>
pretrained_model = <span class="hljs-title class_">BertModel</span>.from_pretrained(<span class="hljs-string">'./Bert-base-chinese'</span>).to(device)
​
​
<span class="hljs-comment"># 定义下游任务（增量模型）</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">DownStreamModel</span>(torch.nn.<span class="hljs-title class_">Module</span>):
​
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):
        <span class="hljs-variable language_">super</span>(<span class="hljs-title class_">DownStreamModel</span>, <span class="hljs-variable language_">self</span>).__init__()
        <span class="hljs-comment"># 下游加一个全连接层，实现二分类任务</span>
        <span class="hljs-variable language_">self</span>.fc = torch.nn.<span class="hljs-title class_">Linear</span>(<span class="hljs-number">768</span>, <span class="hljs-number">2</span>)
​
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>, input_ids, attention_mask, token_type_ids</span>):
        with torch.no_grad():  <span class="hljs-comment"># 冻结Bert模型参数，不需计算梯度</span>
            <span class="hljs-comment"># 获取最后一层隐藏层输出</span>
            output = pretrained_model(input_ids=input_ids, attention_mask=attention_mask, token_type_ids=token_type_ids)
        <span class="hljs-comment"># 增量模型参与训练</span>
        out = <span class="hljs-variable language_">self</span>.fc(output.last_hidden_state[<span class="hljs-symbol">:</span>, <span class="hljs-number">0</span>, <span class="hljs-symbol">:</span>])
        <span class="hljs-keyword">return</span> out
</code></pre>
<p><code>output.last_hidden_state[:, 0, :]</code> 是用来获取模型输出的隐藏状态（通常是进入模型的最后一层隐藏状态）的一个特定切片。让我们逐个参数进行详细解析：</p>
<p><strong>1. <code>output</code></strong></p>
<p><code>output</code> 通常是通过对输入数据（如文本、图像等）运行某个深度学习模型（例如 BERT、GPT、Transformers 等）后返回的对象，它包含多个属性，其中一个重要的属性是 <code>last_hidden_state</code>。</p>
<p><strong>2. <code>last_hidden_state</code></strong></p>
<p><code>last_hidden_state</code> 是模型最后一层的隐藏状态，它的形状通常是 <code>(batch_size, sequence_length, hidden_size)</code>，具体的含义如下：</p>
<ul>
<li><strong>batch_size</strong>：处理的样本数量。在一次前向传播中，模型可以并行处理多个输入样本。</li>
<li><strong>sequence_length</strong>：输入序列的长度。对于处理文本来说，它表示词汇的数量，可以是句子中词的个数。</li>
<li><strong>hidden_size</strong>：每个隐藏状态的维度，代表模型的输出特征维数。通常在模型架构中定义，例如对于 BERT-base 隐藏大小为 768。</li>
</ul>
<p><strong>3. <code>[:, 0, :]</code></strong></p>
<p>这里的切片操作用来访问 <code>last_hidden_state</code> 的一部分，具体解释如下：</p>
<ul>
<li><strong>:</strong> ：表示选择所有的样本。由于 <code>batch_size</code> 是第一个维度，所以把 <code>:</code> 放在这个位置表示选取当前批次的所有样本。</li>
<li><strong>0</strong>：表示选择第一个时刻的隐藏状态。在 NLP 中，特别是像 BERT 这样的模型中，第一位置的隐藏状态通常对应于 <code>[CLS]</code> token（分类 token），它是用来进行句子级别的任务（例如分类）的。</li>
<li><strong>:</strong> ：表示选择所有的特征维度（<code>hidden_size</code>）。这意味着我们提取每个样本的第一个位置（即 <code>[CLS]</code> token）对应的全部隐藏状态特征。</li>
</ul>
<p><strong>综合</strong></p>
<p>因此，<code>output.last_hidden_state[:, 0, :]</code> 表示提取所有输入样本的 <code>[CLS]</code> token 的隐藏状态向量，这通常用于下游任务，如文本分类、问答、情感分析等，因为 <code>[CLS]</code> token 的表示通常是整段文本的语义聚合。</p>
<p><strong>例子</strong></p>
<p>如果有一个输入批次大小为 4，并且每个输入序列的隐藏状态大小为 768，那么 <code>output.last_hidden_state[:, 0, :]</code> 的返回结果将是一个形状为 <code>(4, 768)</code> 的张量，其中每一行对应一个输入样本的 <code>[CLS]</code> token 的隐藏状态。</p>
<h3 data-id="heading-6">4，训练模型</h3>
<p>前面我们已经定义好了数据集，以及文本编码处理，包括增量模型定义。接下来我们来进行增量模型微调训练。</p>
<p>实例代码：</p>
<pre><code class="hljs language-ini" lang="ini">import torch
from datasets import load_dataset
from torch.utils.data import Dataset, DataLoader
from transformers import BertTokenizer, BertModel
​
​
<span class="hljs-comment"># 自定义数据集</span>
class MyDataset(Dataset):
​
    def __init__(self, split):
        <span class="hljs-comment"># 加载训练集</span>
        <span class="hljs-attr">train_dataset</span> = load_dataset(path=<span class="hljs-string">"csv"</span>, data_files=<span class="hljs-string">"./weibo_senti_8k_train.csv"</span>)
        <span class="hljs-comment"># 加载测试集</span>
        <span class="hljs-attr">test_dataset</span> = load_dataset(path=<span class="hljs-string">"csv"</span>, data_files=<span class="hljs-string">"./weibo_senti_2k_test.csv"</span>)
        if <span class="hljs-attr">split</span> == <span class="hljs-string">'train'</span>:
            <span class="hljs-attr">self.data</span> = train_dataset[<span class="hljs-string">'train'</span>]
        elif <span class="hljs-attr">split</span> == <span class="hljs-string">'test'</span>:
            <span class="hljs-attr">self.data</span> = test_dataset[<span class="hljs-string">'train'</span>]
​
    <span class="hljs-comment"># 获取数据集大小</span>
    def __len__(self):
        return len(self.data)
​
    <span class="hljs-comment"># 获取数据集的某个元素</span>
    def __getitem__(self, index):
        <span class="hljs-attr">sentence</span> = self.data[index][<span class="hljs-string">'sentence'</span>]
        <span class="hljs-attr">label</span> = self.data[index][<span class="hljs-string">'label'</span>]
        return sentence, label
​
​
<span class="hljs-comment"># 加载分词器</span>
<span class="hljs-attr">tokenizer</span> = BertTokenizer.from_pretrained(<span class="hljs-string">'./Bert-base-chinese'</span>)
​
<span class="hljs-comment"># 使用设备（GPU/CPU）</span>
<span class="hljs-attr">device</span> = torch.device(<span class="hljs-string">"cuda"</span> if torch.cuda.is_available() else <span class="hljs-string">"cpu"</span>)
print(device)
​
<span class="hljs-comment"># 加载预训练模型</span>
<span class="hljs-attr">pretrained_model</span> = BertModel.from_pretrained(<span class="hljs-string">'./Bert-base-chinese'</span>).to(device)
​
​
<span class="hljs-comment"># 定义下游任务（增量模型）</span>
class DownStreamModel(torch.nn.Module):
​
    def __init__(self):
        super(DownStreamModel, self).__init__()
        <span class="hljs-comment"># 下游加一个全连接层，实现二分类任务</span>
        <span class="hljs-attr">self.fc</span> = torch.nn.Linear(<span class="hljs-number">768</span>, <span class="hljs-number">2</span>)
​
    def forward(self, input_ids, attention_mask, token_type_ids):
        with torch.no_grad():  <span class="hljs-comment"># 冻结Bert模型参数，不需计算梯度</span>
            <span class="hljs-comment"># 获取最后一层隐藏层输出</span>
            <span class="hljs-attr">output</span> = pretrained_model(input_ids=input_ids, attention_mask=attention_mask, token_type_ids=token_type_ids)
        <span class="hljs-comment"># 增量模型参与训练</span>
        <span class="hljs-attr">out</span> = self.fc(output.last_hidden_state[:, <span class="hljs-number">0</span>, :])
        return out
​
​
<span class="hljs-comment"># 对传入数据进行编码</span>
def collate_fn(data):
    <span class="hljs-attr">sents</span> = [i[<span class="hljs-number">0</span>] for i in data]
    <span class="hljs-attr">labels</span> = [i[<span class="hljs-number">1</span>] for i in data]
    <span class="hljs-comment"># 编码</span>
    <span class="hljs-comment"># 批量编码句子</span>
    <span class="hljs-attr">out</span> = tokenizer.batch_encode_plus(
        <span class="hljs-attr">batch_text_or_text_pairs</span>=sents,  <span class="hljs-comment"># 输入的文本</span>
        <span class="hljs-attr">add_special_tokens</span>=<span class="hljs-literal">True</span>,  <span class="hljs-comment"># 添加特殊标记</span>
        <span class="hljs-attr">max_length</span>=<span class="hljs-number">256</span>,  <span class="hljs-comment"># 最大长度</span>
        <span class="hljs-attr">padding</span>=<span class="hljs-string">'max_length'</span>,  <span class="hljs-comment"># 填充</span>
        <span class="hljs-attr">truncation</span>=<span class="hljs-literal">True</span>,  <span class="hljs-comment"># 截断</span>
        <span class="hljs-attr">return_tensors</span>=<span class="hljs-string">'pt'</span>,  <span class="hljs-comment"># 返回pytorch张量</span>
        <span class="hljs-attr">return_token_type_ids</span>=<span class="hljs-literal">True</span>,  <span class="hljs-comment"># 返回token_type_ids  区分不同句子或段落的类型标识</span>
        <span class="hljs-attr">return_attention_mask</span>=<span class="hljs-literal">True</span>,  <span class="hljs-comment"># 返回attention_mask  标记有效token位置的掩码</span>
        <span class="hljs-attr">return_special_tokens_mask</span>=<span class="hljs-literal">True</span>  <span class="hljs-comment"># 返回special_tokens_mask 标识特殊token（如[CLS]、[SEP]）的位置掩码</span>
    )
    return out<span class="hljs-section">['input_ids']</span>, out<span class="hljs-section">['attention_mask']</span>, out<span class="hljs-section">['token_type_ids']</span>, torch.tensor(labels)
​
​
<span class="hljs-comment"># 创建数据集</span>
<span class="hljs-attr">train_dataset</span> = MyDataset(<span class="hljs-string">'train'</span>)  <span class="hljs-comment"># 训练集</span>
<span class="hljs-attr">train_loader</span> = DataLoader(
    <span class="hljs-attr">dataset</span>=train_dataset,  <span class="hljs-comment"># 数据集</span>
    <span class="hljs-attr">batch_size</span>=<span class="hljs-number">200</span>,  <span class="hljs-comment"># 批次大小</span>
    <span class="hljs-attr">shuffle</span>=<span class="hljs-literal">True</span>,  <span class="hljs-comment"># 是否打乱数据</span>
    <span class="hljs-attr">drop_last</span>=<span class="hljs-literal">True</span>,  <span class="hljs-comment"># 丢弃最后一个批次数据</span>
    <span class="hljs-attr">collate_fn</span>=collate_fn  <span class="hljs-comment"># 对加载的数据进行编码</span>
)
​
<span class="hljs-attr">test_dataset</span> = MyDataset(<span class="hljs-string">'test'</span>)  <span class="hljs-comment"># 测试集</span>
<span class="hljs-attr">test_loader</span> = DataLoader(
    <span class="hljs-attr">dataset</span>=test_dataset,  <span class="hljs-comment"># 数据集</span>
    <span class="hljs-attr">batch_size</span>=<span class="hljs-number">200</span>,  <span class="hljs-comment"># 批次大小</span>
    <span class="hljs-attr">shuffle</span>=<span class="hljs-literal">True</span>,  <span class="hljs-comment"># 是否打乱数据</span>
    <span class="hljs-attr">drop_last</span>=<span class="hljs-literal">True</span>,  <span class="hljs-comment"># 丢弃最后一个批次数据</span>
    <span class="hljs-attr">collate_fn</span>=collate_fn  <span class="hljs-comment"># 对加载的数据进行编码</span>
)
​
if <span class="hljs-attr">__name__</span> == <span class="hljs-string">'__main__'</span>:
    <span class="hljs-attr">model</span> = DownStreamModel().to(device)  <span class="hljs-comment"># 创建模型</span>
    <span class="hljs-attr">optimizer</span> = torch.optim.AdamW(model.parameters())  <span class="hljs-comment"># 优化器</span>
    <span class="hljs-attr">criterion</span> = torch.nn.CrossEntropyLoss()  <span class="hljs-comment"># 定义损失函数</span>
    <span class="hljs-attr">best_val_acc</span> = <span class="hljs-number">0</span>  <span class="hljs-comment"># 保存最好的准确率</span>
    <span class="hljs-attr">EPOCH</span> = <span class="hljs-number">3</span>  <span class="hljs-comment"># 训练轮数</span>
    for epoch in range(EPOCH):  <span class="hljs-comment"># 训练轮数</span>
        for i, (input_ids, attention_mask, token_type_ids, labels) in enumerate(train_loader):  <span class="hljs-comment"># 批次数据</span>
            <span class="hljs-attr">out</span> = model(input_ids=input_ids.to(device), attention_mask=attention_mask.to(device),
                        <span class="hljs-attr">token_type_ids</span>=token_type_ids.to(device))  <span class="hljs-comment"># 模型输出</span>
            <span class="hljs-attr">loss</span> = criterion(out, labels.to(device))  <span class="hljs-comment"># 计算损失</span>
            optimizer.zero_grad()  <span class="hljs-comment"># 清空梯度</span>
            loss.backward()  <span class="hljs-comment"># 反向传播</span>
            optimizer.step()  <span class="hljs-comment"># 优化器更新参数</span>
            <span class="hljs-comment"># 每隔5个批次输出训练结果</span>
            if i % <span class="hljs-attr">5</span> == <span class="hljs-number">0</span>:
                <span class="hljs-attr">out</span> = out.argmax(dim=<span class="hljs-number">1</span>)  <span class="hljs-comment"># 获取预测结果</span>
                <span class="hljs-attr">acc</span> = (out == labels.to(device)).sum().item() / len(labels)  <span class="hljs-comment"># 计算准确率</span>
                print("EPOCH:{}--第{}批次--损失:{}--准确率:{}".format(epoch + 1, i + 1, loss.item(), acc))
</code></pre>
<p>运行结果：</p>
<pre><code class="hljs language-lua" lang="lua">cuda
EPOCH:<span class="hljs-number">1</span><span class="hljs-comment">--第1批次--损失:0.5008983016014099--准确率:0.78</span>
EPOCH:<span class="hljs-number">1</span><span class="hljs-comment">--第6批次--损失:0.5052810907363892--准确率:0.75</span>
EPOCH:<span class="hljs-number">1</span><span class="hljs-comment">--第11批次--损失:0.4850313067436218--准确率:0.755</span>
EPOCH:<span class="hljs-number">1</span><span class="hljs-comment">--第16批次--损失:0.4301462471485138--准确率:0.83</span>
EPOCH:<span class="hljs-number">1</span><span class="hljs-comment">--第21批次--损失:0.39388778805732727--准确率:0.85</span>
EPOCH:<span class="hljs-number">1</span><span class="hljs-comment">--第26批次--损失:0.3695535361766815--准确率:0.855</span>
EPOCH:<span class="hljs-number">1</span><span class="hljs-comment">--第31批次--损失:0.35825812816619873--准确率:0.855</span>
EPOCH:<span class="hljs-number">1</span><span class="hljs-comment">--第36批次--损失:0.3288692533969879--准确率:0.875</span>
EPOCH:<span class="hljs-number">2</span><span class="hljs-comment">--第1批次--损失:0.31738394498825073--准确率:0.885</span>
EPOCH:<span class="hljs-number">2</span><span class="hljs-comment">--第6批次--损失:0.3121739625930786--准确率:0.87</span>
EPOCH:<span class="hljs-number">2</span><span class="hljs-comment">--第11批次--损失:0.30510687828063965--准确率:0.895</span>
EPOCH:<span class="hljs-number">2</span><span class="hljs-comment">--第16批次--损失:0.305753618478775--准确率:0.865</span>
EPOCH:<span class="hljs-number">2</span><span class="hljs-comment">--第21批次--损失:0.24456100165843964--准确率:0.92</span>
EPOCH:<span class="hljs-number">2</span><span class="hljs-comment">--第26批次--损失:0.2233615517616272--准确率:0.93</span>
EPOCH:<span class="hljs-number">2</span><span class="hljs-comment">--第31批次--损失:0.2816208302974701--准确率:0.89</span>
EPOCH:<span class="hljs-number">2</span><span class="hljs-comment">--第36批次--损失:0.24931633472442627--准确率:0.915</span>
EPOCH:<span class="hljs-number">3</span><span class="hljs-comment">--第1批次--损失:0.3053100109100342--准确率:0.885</span>
EPOCH:<span class="hljs-number">3</span><span class="hljs-comment">--第6批次--损失:0.2515011727809906--准确率:0.9</span>
EPOCH:<span class="hljs-number">3</span><span class="hljs-comment">--第11批次--损失:0.24241474270820618--准确率:0.915</span>
EPOCH:<span class="hljs-number">3</span><span class="hljs-comment">--第16批次--损失:0.2211739420890808--准确率:0.925</span>
EPOCH:<span class="hljs-number">3</span><span class="hljs-comment">--第21批次--损失:0.24276195466518402--准确率:0.91</span>
EPOCH:<span class="hljs-number">3</span><span class="hljs-comment">--第26批次--损失:0.27010777592658997--准确率:0.895</span>
EPOCH:<span class="hljs-number">3</span><span class="hljs-comment">--第31批次--损失:0.24304606020450592--准确率:0.9</span>
EPOCH:<span class="hljs-number">3</span><span class="hljs-comment">--第36批次--损失:0.26476508378982544--准确率:0.905</span>
</code></pre>
<h3 data-id="heading-7">5，评估模型</h3>
<p>模型训练好之后，我们要对模型进行性能评估，以及保存最优模型参数。</p>
<p>示例代码：</p>
<pre><code class="hljs language-ini" lang="ini">import torch
from datasets import load_dataset
from torch.utils.data import Dataset, DataLoader
from transformers import BertTokenizer, BertModel
​
​
<span class="hljs-comment"># 自定义数据集</span>
class MyDataset(Dataset):
​
    def __init__(self, split):
        <span class="hljs-comment"># 加载训练集</span>
        <span class="hljs-attr">train_dataset</span> = load_dataset(path=<span class="hljs-string">"csv"</span>, data_files=<span class="hljs-string">"./weibo_senti_8k_train.csv"</span>)
        <span class="hljs-comment"># 加载测试集</span>
        <span class="hljs-attr">test_dataset</span> = load_dataset(path=<span class="hljs-string">"csv"</span>, data_files=<span class="hljs-string">"./weibo_senti_2k_test.csv"</span>)
        if <span class="hljs-attr">split</span> == <span class="hljs-string">'train'</span>:
            <span class="hljs-attr">self.data</span> = train_dataset[<span class="hljs-string">'train'</span>]
        elif <span class="hljs-attr">split</span> == <span class="hljs-string">'test'</span>:
            <span class="hljs-attr">self.data</span> = test_dataset[<span class="hljs-string">'train'</span>]
​
    <span class="hljs-comment"># 获取数据集大小</span>
    def __len__(self):
        return len(self.data)
​
    <span class="hljs-comment"># 获取数据集的某个元素</span>
    def __getitem__(self, index):
        <span class="hljs-attr">sentence</span> = self.data[index][<span class="hljs-string">'sentence'</span>]
        <span class="hljs-attr">label</span> = self.data[index][<span class="hljs-string">'label'</span>]
        return sentence, label
​
​
<span class="hljs-comment"># 加载分词器</span>
<span class="hljs-attr">tokenizer</span> = BertTokenizer.from_pretrained(<span class="hljs-string">'./Bert-base-chinese'</span>)
​
<span class="hljs-comment"># 使用设备（GPU/CPU）</span>
<span class="hljs-attr">device</span> = torch.device(<span class="hljs-string">"cuda"</span> if torch.cuda.is_available() else <span class="hljs-string">"cpu"</span>)
print(device)
​
<span class="hljs-comment"># 加载预训练模型</span>
<span class="hljs-attr">pretrained_model</span> = BertModel.from_pretrained(<span class="hljs-string">'./Bert-base-chinese'</span>).to(device)
​
​
<span class="hljs-comment"># 定义下游任务（增量模型）</span>
class DownStreamModel(torch.nn.Module):
​
    def __init__(self):
        super(DownStreamModel, self).__init__()
        <span class="hljs-comment"># 下游加一个全连接层，实现二分类任务</span>
        <span class="hljs-attr">self.fc</span> = torch.nn.Linear(<span class="hljs-number">768</span>, <span class="hljs-number">2</span>)
​
    def forward(self, input_ids, attention_mask, token_type_ids):
        with torch.no_grad():  <span class="hljs-comment"># 冻结Bert模型参数，不需计算梯度</span>
            <span class="hljs-comment"># 获取最后一层隐藏层输出</span>
            <span class="hljs-attr">output</span> = pretrained_model(input_ids=input_ids, attention_mask=attention_mask, token_type_ids=token_type_ids)
        <span class="hljs-comment"># 增量模型参与训练</span>
        <span class="hljs-attr">out</span> = self.fc(output.last_hidden_state[:, <span class="hljs-number">0</span>, :])
        return out
​
​
<span class="hljs-comment"># 对传入数据进行编码</span>
def collate_fn(data):
    <span class="hljs-attr">sents</span> = [i[<span class="hljs-number">0</span>] for i in data]
    <span class="hljs-attr">labels</span> = [i[<span class="hljs-number">1</span>] for i in data]
    <span class="hljs-comment"># 编码</span>
    <span class="hljs-comment"># 批量编码句子</span>
    <span class="hljs-attr">out</span> = tokenizer.batch_encode_plus(
        <span class="hljs-attr">batch_text_or_text_pairs</span>=sents,  <span class="hljs-comment"># 输入的文本</span>
        <span class="hljs-attr">add_special_tokens</span>=<span class="hljs-literal">True</span>,  <span class="hljs-comment"># 添加特殊标记</span>
        <span class="hljs-attr">max_length</span>=<span class="hljs-number">256</span>,  <span class="hljs-comment"># 最大长度</span>
        <span class="hljs-attr">padding</span>=<span class="hljs-string">'max_length'</span>,  <span class="hljs-comment"># 填充</span>
        <span class="hljs-attr">truncation</span>=<span class="hljs-literal">True</span>,  <span class="hljs-comment"># 截断</span>
        <span class="hljs-attr">return_tensors</span>=<span class="hljs-string">'pt'</span>,  <span class="hljs-comment"># 返回pytorch张量</span>
        <span class="hljs-attr">return_token_type_ids</span>=<span class="hljs-literal">True</span>,  <span class="hljs-comment"># 返回token_type_ids  区分不同句子或段落的类型标识</span>
        <span class="hljs-attr">return_attention_mask</span>=<span class="hljs-literal">True</span>,  <span class="hljs-comment"># 返回attention_mask  标记有效token位置的掩码</span>
        <span class="hljs-attr">return_special_tokens_mask</span>=<span class="hljs-literal">True</span>  <span class="hljs-comment"># 返回special_tokens_mask 标识特殊token（如[CLS]、[SEP]）的位置掩码</span>
    )
    return out<span class="hljs-section">['input_ids']</span>, out<span class="hljs-section">['attention_mask']</span>, out<span class="hljs-section">['token_type_ids']</span>, torch.tensor(labels)
​
​
<span class="hljs-comment"># 创建数据集</span>
<span class="hljs-attr">train_dataset</span> = MyDataset(<span class="hljs-string">'train'</span>)  <span class="hljs-comment"># 训练集</span>
<span class="hljs-attr">train_loader</span> = DataLoader(
    <span class="hljs-attr">dataset</span>=train_dataset,  <span class="hljs-comment"># 数据集</span>
    <span class="hljs-attr">batch_size</span>=<span class="hljs-number">200</span>,  <span class="hljs-comment"># 批次大小</span>
    <span class="hljs-attr">shuffle</span>=<span class="hljs-literal">True</span>,  <span class="hljs-comment"># 是否打乱数据</span>
    <span class="hljs-attr">drop_last</span>=<span class="hljs-literal">True</span>,  <span class="hljs-comment"># 丢弃最后一个批次数据</span>
    <span class="hljs-attr">collate_fn</span>=collate_fn  <span class="hljs-comment"># 对加载的数据进行编码</span>
)
​
<span class="hljs-attr">test_dataset</span> = MyDataset(<span class="hljs-string">'test'</span>)  <span class="hljs-comment"># 测试集</span>
<span class="hljs-attr">test_loader</span> = DataLoader(
    <span class="hljs-attr">dataset</span>=test_dataset,  <span class="hljs-comment"># 数据集</span>
    <span class="hljs-attr">batch_size</span>=<span class="hljs-number">200</span>,  <span class="hljs-comment"># 批次大小</span>
    <span class="hljs-attr">shuffle</span>=<span class="hljs-literal">True</span>,  <span class="hljs-comment"># 是否打乱数据</span>
    <span class="hljs-attr">drop_last</span>=<span class="hljs-literal">True</span>,  <span class="hljs-comment"># 丢弃最后一个批次数据</span>
    <span class="hljs-attr">collate_fn</span>=collate_fn  <span class="hljs-comment"># 对加载的数据进行编码</span>
)
​
if <span class="hljs-attr">__name__</span> == <span class="hljs-string">'__main__'</span>:
    <span class="hljs-attr">model</span> = DownStreamModel().to(device)  <span class="hljs-comment"># 创建模型</span>
    <span class="hljs-attr">optimizer</span> = torch.optim.AdamW(model.parameters())  <span class="hljs-comment"># 优化器</span>
    <span class="hljs-attr">criterion</span> = torch.nn.CrossEntropyLoss()  <span class="hljs-comment"># 定义损失函数</span>
    <span class="hljs-attr">best_val_acc</span> = <span class="hljs-number">0</span>  <span class="hljs-comment"># 保存最好的准确率</span>
    <span class="hljs-attr">EPOCH</span> = <span class="hljs-number">3</span>  <span class="hljs-comment"># 训练轮数</span>
    for epoch in range(EPOCH):  <span class="hljs-comment"># 训练轮数</span>
        for i, (input_ids, attention_mask, token_type_ids, labels) in enumerate(train_loader):  <span class="hljs-comment"># 批次数据</span>
            <span class="hljs-attr">out</span> = model(input_ids=input_ids.to(device), attention_mask=attention_mask.to(device),
                        <span class="hljs-attr">token_type_ids</span>=token_type_ids.to(device))  <span class="hljs-comment"># 模型输出</span>
            <span class="hljs-attr">loss</span> = criterion(out, labels.to(device))  <span class="hljs-comment"># 计算损失</span>
            optimizer.zero_grad()  <span class="hljs-comment"># 清空梯度</span>
            loss.backward()  <span class="hljs-comment"># 反向传播</span>
            optimizer.step()  <span class="hljs-comment"># 优化器更新参数</span>
            <span class="hljs-comment"># 每隔5个批次输出训练结果</span>
            if i % <span class="hljs-attr">5</span> == <span class="hljs-number">0</span>:
                <span class="hljs-attr">out</span> = out.argmax(dim=<span class="hljs-number">1</span>)  <span class="hljs-comment"># 获取预测结果</span>
                <span class="hljs-attr">acc</span> = (out == labels.to(device)).sum().item() / len(labels)  <span class="hljs-comment"># 计算准确率</span>
                print("EPOCH:{}--第{}批次--损失:{}--准确率:{}".format(epoch + 1, i + 1, loss.item(), acc))
    <span class="hljs-comment"># 验证模型</span>
    model.eval()  <span class="hljs-comment"># 评估模式 Dropout关闭</span>
    with torch.no_grad():  <span class="hljs-comment"># 评估模式，不需要计算梯度</span>
        for i, (input_ids, attention_mask, token_type_ids, labels) in enumerate(test_loader):
            <span class="hljs-attr">out</span> = model(input_ids=input_ids.to(device), attention_mask=attention_mask.to(device),
                        <span class="hljs-attr">token_type_ids</span>=token_type_ids.to(device))
            <span class="hljs-attr">out</span> = out.argmax(dim=<span class="hljs-number">1</span>)
            <span class="hljs-attr">acc</span> = (out == labels.to(device)).sum().item() / len(labels)
            if acc &gt; best_val_acc:
                <span class="hljs-attr">best_val_acc</span> = acc
                torch.save(model.state_dict(), "best_model.pth")
                print(f"测试集准确率EPOCH：{epoch}-第{i}批次:模型保存，准确率:{acc}")
        <span class="hljs-comment"># 保存最后一轮模型</span>
        torch.save(model.state_dict(), "last_model.pth")
        print(f"最后一轮模型保存，:准确率:{acc}")
</code></pre>
<p>运行结果：</p>
<pre><code class="hljs language-makefile" lang="makefile">cuda
<span class="hljs-section">EPOCH:1--第1批次--损失:0.6369971632957458--准确率:0.695</span>
<span class="hljs-section">EPOCH:1--第6批次--损失:0.6052521467208862--准确率:0.685</span>
<span class="hljs-section">EPOCH:1--第11批次--损失:0.5286625623703003--准确率:0.77</span>
<span class="hljs-section">EPOCH:1--第16批次--损失:0.4174182415008545--准确率:0.83</span>
<span class="hljs-section">EPOCH:1--第21批次--损失:0.41344115138053894--准确率:0.81</span>
<span class="hljs-section">EPOCH:1--第26批次--损失:0.3910037875175476--准确率:0.87</span>
<span class="hljs-section">EPOCH:1--第31批次--损失:0.3680213987827301--准确率:0.85</span>
<span class="hljs-section">EPOCH:1--第36批次--损失:0.3817676901817322--准确率:0.855</span>
<span class="hljs-section">EPOCH:2--第1批次--损失:0.3963841199874878--准确率:0.84</span>
<span class="hljs-section">EPOCH:2--第6批次--损失:0.3516421914100647--准确率:0.85</span>
<span class="hljs-section">EPOCH:2--第11批次--损失:0.330654114484787--准确率:0.845</span>
<span class="hljs-section">EPOCH:2--第16批次--损失:0.3345922529697418--准确率:0.865</span>
<span class="hljs-section">EPOCH:2--第21批次--损失:0.3087370693683624--准确率:0.885</span>
<span class="hljs-section">EPOCH:2--第26批次--损失:0.25769323110580444--准确率:0.92</span>
<span class="hljs-section">EPOCH:2--第31批次--损失:0.2792946696281433--准确率:0.885</span>
<span class="hljs-section">EPOCH:2--第36批次--损失:0.29899129271507263--准确率:0.905</span>
<span class="hljs-section">EPOCH:3--第1批次--损失:0.3139827847480774--准确率:0.855</span>
<span class="hljs-section">EPOCH:3--第6批次--损失:0.27809959650039673--准确率:0.895</span>
<span class="hljs-section">EPOCH:3--第11批次--损失:0.2725857198238373--准确率:0.885</span>
<span class="hljs-section">EPOCH:3--第16批次--损失:0.30161210894584656--准确率:0.885</span>
<span class="hljs-section">EPOCH:3--第21批次--损失:0.26055067777633667--准确率:0.925</span>
<span class="hljs-section">EPOCH:3--第26批次--损失:0.22951321303844452--准确率:0.895</span>
<span class="hljs-section">EPOCH:3--第31批次--损失:0.2995443642139435--准确率:0.87</span>
<span class="hljs-section">EPOCH:3--第36批次--损失:0.3246515691280365--准确率:0.87</span>
<span class="hljs-section">测试集准确率EPOCH：2-第0批次:模型保存，准确率:0.975</span>
<span class="hljs-section">最后一轮模型保存，:准确率:0.955</span>
</code></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[打破堆积困局：优化堆积条形图的对比效果]]></title>    <link>https://juejin.cn/post/7595974133097807906</link>    <guid>https://juejin.cn/post/7595974133097807906</guid>    <pubDate>2026-01-18T07:22:16.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7595974133097807906" data-draft-id="7595896809652748328" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="打破堆积困局：优化堆积条形图的对比效果"/> <meta itemprop="keywords" content="Python,数据可视化,数据分析"/> <meta itemprop="datePublished" content="2026-01-18T07:22:16.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="databook"/> <meta itemprop="url" content="https://juejin.cn/user/3526889035006702"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            打破堆积困局：优化堆积条形图的对比效果
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3526889035006702/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    databook
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-18T07:22:16.000Z" title="Sun Jan 18 2026 07:22:16 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-18
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{color:#595959;font-size:15px;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(60,10,30,.04) 3%,transparent 0),linear-gradient(1turn,rgba(60,10,30,.04) 3%,transparent 0);background-size:20px 20px;background-position:50%}.markdown-body p{color:#595959;font-size:15px;line-height:2;font-weight:400}.markdown-body p+p{margin-top:16px}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{padding:30px 0;margin:0;color:#135ce0}.markdown-body h1{position:relative;text-align:center;font-size:22px;margin:50px 0}.markdown-body h1:before{position:absolute;content:"";top:-10px;left:50%;width:32px;height:32px;transform:translateX(-50%);background-size:100% 100%;opacity:.36;background-repeat:no-repeat;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABfVBMVEX///8Ad/8AgP8AgP8AgP8Aff8AgP8Af/8AgP8AVf8Af/8Af/8AgP8AgP8Af/8Afv8AAP8Afv8Afv8Aef8AgP8AdP8Afv8AgP8AgP8Acf8Ae/8AgP8Af/8AgP8Af/8Af/8AfP8Afv8AgP8Af/8Af/8Afv8Afv8AgP8Afv8AgP8Af/8Af/8AgP8AgP8Afv8AgP8Af/8AgP8AgP8AgP8Ae/8Afv8Af/8AgP8Af/8AgP8Af/8Af/8Aff8Af/8Abf8AgP8Af/8AgP8Af/8Af/8Afv8AgP8AgP8Afv8Afv8AgP8Af/8Aff8AgP8Afv8AgP8Aff8AgP8AfP8AgP8Ae/8AgP8Af/8AgP8AgP8AgP8Afv8AgP8AgP8AgP8Afv8AgP8AgP8AgP8AgP8AgP8Af/8AgP8Af/8Af/8Aev8Af/8AgP8Aff8Afv8AgP8AgP8AgP8Af/8AgP8Af/8Af/8AgP8Afv8AgP8AgP8AgP8AgP8Af/8AeP8Af/8Af/8Af//////rzEHnAAAAfXRSTlMAD7CCAivatxIDx5EMrP19AXdLEwgLR+6iCR/M0yLRzyFF7JupSXn8cw6v60Q0QeqzKtgeG237HMne850/6Qeq7QaZ+WdydHtj+OM3qENCMRYl1B3K2U7wnlWE/mhlirjkODa9FN/BF7/iNV/2kASNZpX1Wlf03C4stRGxgUPclqoAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEaBzgZ4yeM3AAAAT9JREFUOMvNUldbwkAQvCAqsSBoABE7asSOBRUVVBQNNuy9996789+9cMFAMHnVebmdm+/bmdtbQv4dOFOW2UjPzgFyLfo6nweKfIMOBYWwFtmMPGz2Yj2pJI0JDq3udJW6VVbmKa9I192VQFV1ktXUAl5NB0cd4KpnORqsEO2ZIRpF9gJfE9Dckqq0KuZt7UAH5+8EPF3spjsRpCeQNO/tA/qDwIDA+OCQbBoKA8NOdjMySgcZGVM6jwcgRuUiSs0nlPFNSrEpJfU0jTLD6llqbvKxei7OzvkFNQohi0vAsj81+MoqsCaoPOQFgus/1LyxichW+hS2JWCHZ7VlF9jb187pIAYcHiViHAMnp5mTjJ8B5xeEXF4B1ze/fTh/C0h398DDI9HB07O8ci+vRBdvdGnfP4gBuM8vw7X/G3wDmFhFZEdxzjMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDEtMjZUMDc6NTY6MjUrMDE6MDA67pVWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAxLTI2VDA3OjU2OjI1KzAxOjAwS7Mt6gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAWdEVYdFRpdGxlAGp1ZWppbl9sb2dvIGNvcHlxapmKAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC)}.markdown-body h2{position:relative;font-size:20px;border-left:4px solid;padding:0 0 0 10px;margin:30px 0}.markdown-body h3{font-size:16px}.markdown-body ul{list-style:disc outside;margin-left:2em;margin-top:1em}.markdown-body li{line-height:2;color:#595959}.markdown-body img.loaded{margin:0 auto;display:block}.markdown-body blockquote{background:#fff9f9;margin:2em 0;padding:2px 20px;border-left:4px solid #b2aec5}.markdown-body blockquote p{color:#666;line-height:2}.markdown-body a{color:#036aca;border-bottom:1px solid rgba(3,106,202,.8);font-weight:400;text-decoration:none}.markdown-body em strong,.markdown-body strong{color:#036aca}.markdown-body hr{border-top:1px solid #135ce0}.markdown-body pre{overflow:auto}.markdown-body code,.markdown-body pre{overflow:auto;position:relative;line-height:1.75;font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body table{border-collapse:collapse;margin:1rem 0;overflow-x:auto}.markdown-body table td,.markdown-body table th{border:1px solid #dfe2e5;padding:.6em 1em}.markdown-body table tr{border-top:1px solid #dfe2e5}.markdown-body table tr:nth-child(2n){background-color:#f6f8fa}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在数据可视化中，<strong>堆积条形图</strong> 擅长展示 <strong>“整体与构成”</strong> 的关系，但当每个柱子内的分段超过4个时，读者很难同时追踪各段的长度、位置与颜色映射， <strong>误读概率显著上升</strong>。</p>
<p>更糟的是，若不同类别的总量差异很大，堆积结构会放大视觉错觉，导致“看起来差不多”的结论失真。</p>
<p>今天，本文将尝试探索一下改进堆积条形图的呈现方式，让复杂数据对比变得一目了然。</p>
<p>如果大家有更好的方式，也欢迎指教，交流。<strong>完整的代码</strong>会在文末提供共享的地址。</p>
<h2 data-id="heading-0">1. 堆积条形图的困境</h2>
<p><strong>堆积条形图</strong>就像一道精心摆盘的多层蛋糕，当层数不多时，我们能轻松分辨每层的高度差异。</p>
<p>但当蛋糕层数超过4层，要比较某一特定口味在多个蛋糕中的含量就变得异常困难。</p>
<p>下面我们用<code>Python</code>模拟一个常见的堆积条形图场景：调查某产品5个功能模块的用户满意度（5个维度），共收集了4个季度的数据。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 模拟数据：4个季度，5个满意度维度（强烈反对、反对、中立、同意、坚决同意）</span>
quarters = [<span class="hljs-string">"第一季度"</span>, <span class="hljs-string">"第二季度"</span>, <span class="hljs-string">"第三季度"</span>, <span class="hljs-string">"第四季度"</span>]
categories = [<span class="hljs-string">"强烈反对"</span>, <span class="hljs-string">"反对"</span>, <span class="hljs-string">"中立"</span>, <span class="hljs-string">"同意"</span>, <span class="hljs-string">"坚决同意"</span>]
colors = [<span class="hljs-string">"#FF6B6B"</span>, <span class="hljs-string">"#FF9F6B"</span>, <span class="hljs-string">"#D6CBCB"</span>, <span class="hljs-string">"#6BCF7F"</span>, <span class="hljs-string">"#4D96FF"</span>]

<span class="hljs-comment"># 每个季度的满意度分布（百分比）</span>
data = np.array(
    [
        [<span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">25</span>, <span class="hljs-number">40</span>, <span class="hljs-number">20</span>],  <span class="hljs-comment"># 第一季度</span>
        [<span class="hljs-number">3</span>, <span class="hljs-number">8</span>, <span class="hljs-number">20</span>, <span class="hljs-number">45</span>, <span class="hljs-number">24</span>],  <span class="hljs-comment"># 第二季度</span>
        [<span class="hljs-number">4</span>, <span class="hljs-number">12</span>, <span class="hljs-number">18</span>, <span class="hljs-number">43</span>, <span class="hljs-number">23</span>],  <span class="hljs-comment"># 第三季度</span>
        [<span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">50</span>, <span class="hljs-number">27</span>],  <span class="hljs-comment"># 第四季度</span>
    ]
)

<span class="hljs-comment"># 传统横向堆积条形图</span>
fig, ax = plt.subplots(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, figsize=(<span class="hljs-number">14</span>, <span class="hljs-number">4</span>), gridspec_kw={<span class="hljs-string">"width_ratios"</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>]})

<span class="hljs-comment"># 左图：传统横向堆积条形图</span>
<span class="hljs-comment"># ... 省略 ...</span>

<span class="hljs-comment"># 右图：横向堆叠条形图的改进版，添加分隔线</span>
<span class="hljs-comment"># ... 省略 ...</span>

plt.tight_layout()
plt.show()
</code></pre>

<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a4a944949d5f4141a21ddd7390882fb1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgZGF0YWJvb2s=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769325736&amp;x-signature=VV%2FTkJeonMm1IOMY4mJ6NkT%2FElY%3D" alt="" loading="lazy"/></p>
<p>这个横向堆积条形图展示了每个季度用户满意度的完整分布，随便右边的图稍微做了一些改进，</p>
<p>但如果我们想回答以下问题就会遇到困难：</p>
<ul>
<li><strong>"坚决同意"</strong> 的比例在哪个季度最高？</li>
<li><strong>"反对"</strong> 和 <strong>"强烈反对"</strong> 的比例如何随时间变化？</li>
</ul>
<h2 data-id="heading-1">2. 拆解重构--多个子图</h2>
<p>与其把所有食材炖在一锅里，不如将它们分盘摆放。</p>
<p>我们将<strong>堆积条形图</strong>拆解为5个小图，每个小图只关注一个满意度维度的季度变化。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> matplotlib.gridspec <span class="hljs-keyword">as</span> gridspec

fig = plt.figure(figsize=(<span class="hljs-number">12</span>, <span class="hljs-number">6</span>))
gs = gridspec.GridSpec(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>, figure=fig, hspace=<span class="hljs-number">0.3</span>, wspace=<span class="hljs-number">0.4</span>)
<span class="hljs-comment"># 拆解堆积条形图：为每个类别创建单独的横向子图</span>
axes = []
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):
    axes.append(fig.add_subplot(gs[<span class="hljs-number">0</span>, i]))

<span class="hljs-comment"># 为每个满意度维度创建一个横向条形图</span>
<span class="hljs-keyword">for</span> i, (category, color, ax) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(<span class="hljs-built_in">zip</span>(categories, colors, axes)):
    <span class="hljs-comment"># ... 省略 ...</span>

ax = fig.add_subplot(gs[<span class="hljs-number">1</span>, :]) <span class="hljs-comment"># 第1行，所有列 (等同于 gs[1, 0:5])</span>
<span class="hljs-comment"># ... 省略 ...</span>

plt.show()
</code></pre>

<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a4c9b599c9344074a99f8e386d9210e6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgZGF0YWJvb2s=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769325736&amp;x-signature=hpyP%2BAZdvQB3w%2BMII0U8vZDAOS4%3D" alt="" loading="lazy"/></p>
<p>拆解后的图表确实提升了单一维度的对比效果，但仍有一个明显问题：我们的视线需要在多个图表间来回跳跃，无法形成统一的视觉印象。</p>
<p>这就像阅读一本分散在多个页面的表格，需要不断翻页对照。</p>
<h2 data-id="heading-2">3. 双向对比--蝴蝶图</h2>
<p><strong>蝴蝶图</strong>（也称为人口金字塔图或双向条形图）是数据可视化的"瑞士军刀"，特别适合展示对立或双向比较的数据。</p>
<p>它的设计哲学是：让对比在中心轴两侧自然展开，就像蝴蝶展开双翅。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 4. 创建画布</span>
fig, ax = plt.subplots(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>,figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">6</span>))
y_pos = np.arange(<span class="hljs-built_in">len</span>(quarters))
<span class="hljs-comment"># 拆分数据列</span>
strongly_disagree = data[:, <span class="hljs-number">0</span>]
disagree          = data[:, <span class="hljs-number">1</span>]
neutral           = data[:, <span class="hljs-number">2</span>]
agree             = data[:, <span class="hljs-number">3</span>]
strongly_agree    = data[:, <span class="hljs-number">4</span>]

<span class="hljs-comment"># ==========================================</span>
<span class="hljs-comment"># 核心逻辑修改：以中立(Neutral)的中心为0点</span>
<span class="hljs-comment"># ==========================================</span>
<span class="hljs-comment"># 1. 绘制中立 (灰色)：跨越 0 轴</span>
<span class="hljs-comment"># left 从 -width/2 开始，这样 0 就在正中间</span>

<span class="hljs-comment"># 2. 绘制左侧 (负面情绪)：向左堆叠</span>
<span class="hljs-comment"># 反对 (Green)：起始位置在 -neutral/2 的左边</span>

<span class="hljs-comment"># 强烈反对 (Purple)：起始位置在 反对 的左边</span>

<span class="hljs-comment"># 3. 绘制右侧 (正面情绪)：向右堆叠</span>
<span class="hljs-comment"># 同意 (Orange)：起始位置在 neutral/2</span>

<span class="hljs-comment"># 强烈同意 (Red)：起始位置在 同意 的右边</span>

<span class="hljs-comment"># 5. 美化图表</span>
<span class="hljs-comment"># 添加中间的基准线 (穿过中立条形)</span>
<span class="hljs-comment"># ... 省略 ...</span>
plt.show()
</code></pre>

<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/dfcc88fbd7ea4b479296930a493d5467~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgZGF0YWJvb2s=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769325736&amp;x-signature=F3IfS7gZBAnHjT0O4K2aLbQlexE%3D" alt="" loading="lazy"/></p>
<p><strong>蝴蝶图</strong>和一般的堆积条形图放在一起，可以明显看出两者在数据展示逻辑和视觉重心上有显著区别。</p>
<p><strong>蝴蝶图</strong>侧重于展示 <strong>“对立态度的对比”</strong>，适合看正反两面的力量悬殊以及整体的情绪倾向，而且也便于比较同侧的数据。</p>
<h2 data-id="heading-3">4. 总结</h2>
<p>总之，<strong>堆积条形图</strong>像一锅大杂烩，当食材（数据维度）过多时，我们很难品尝（分析）到每种食材的原味。</p>
<p>通过拆解和重构，我们获得了更清晰的视角。而蝴蝶图则像一位优雅的舞者，将对比数据以对称的方式展开，既保留了整体视野，又强化了局部对比。</p>
<p>优秀的数据可视化不在于展示所有信息，而在于以最少的认知成本传达最多的洞察。</p>
<p>下次当我们面对多维数据对比的挑战时，不妨试试横向蝴蝶图这把"瑞士军刀"，它可能会给你带来意想不到的清晰与美感。</p>
<p>绘制文中图像的完整代码共享在：<a href="https://link.juejin.cn?target=https%3A%2F%2Furl11.ctfile.com%2Ff%2F45455611-8606783265-a93d12%3Fp%3D6872" target="_blank" title="https://url11.ctfile.com/f/45455611-8606783265-a93d12?p=6872" ref="nofollow noopener noreferrer">优化堆积条形图.ipynb</a> (访问密码: 6872)</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[# JavaScript 算法详解：Hash表在字母异位词分组的应用（小白也能看懂）]]></title>    <link>https://juejin.cn/post/7596639774267310122</link>    <guid>https://juejin.cn/post/7596639774267310122</guid>    <pubDate>2026-01-19T05:44:39.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7596639774267310122" data-draft-id="7596773213943070762" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="# JavaScript 算法详解：Hash表在字母异位词分组的应用（小白也能看懂）"/> <meta itemprop="keywords" content="JavaScript"/> <meta itemprop="datePublished" content="2026-01-19T05:44:39.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="用户80110532256"/> <meta itemprop="url" content="https://juejin.cn/user/1927884034804425"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            # JavaScript 算法详解：Hash表在字母异位词分组的应用（小白也能看懂）
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1927884034804425/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    用户80110532256
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-19T05:44:39.000Z" title="Mon Jan 19 2026 05:44:39 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    3
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">JavaScript 算法详解：Hash表在字母异位词分组的应用（小白也能看懂）</h2>
<blockquote>
<p>本文将从零基础开始，用最通俗的语言详细解释 JavaScript 中「字母异位词分组」算法，就像老师在课堂上讲解一样。</p>
</blockquote>
<h3 data-id="heading-1">什么是「字母异位词分组」？</h3>
<p>首先我们来看一个生活中的例子：</p>
<ul>
<li><code>"listen"</code>（听） 和 <code>"silent"</code>（安静） 这两个单词，它们的字母都是一样的，只是顺序不同 → 这就是<strong>字母异位词</strong></li>
<li><code>"eat"</code> 和 <code>"tea"</code> 也是一样的道理</li>
</ul>
<p>现在的问题是：给你一堆单词，把所有字母异位词<strong>分到一组</strong>。</p>
<p>比如给你：<code>["eat", "tea", "tan", "ate", "nat", "bat"]</code></p>
<p>应该分成：</p>
<ul>
<li>第一组：<code>["eat", "tea", "ate"]</code> （它们都是由 a,e,t 组成的）</li>
<li>第二组：<code>["tan", "nat"]</code> （它们都是由 a,n,t 组成的）</li>
<li>第三组：<code>["bat"]</code> （只有它一个）</li>
</ul>
<hr/>
<h3 data-id="heading-2">JavaScript 代码详细解释</h3>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-selector-tag">var</span> groupAnagrams = <span class="hljs-built_in">function</span>(strs) {
  const m = new <span class="hljs-built_in">Map</span>(); <span class="hljs-comment">// 1. 创建一个"分类盒子"</span>

  for (const s of strs) { <span class="hljs-comment">// 2. 挨个看每个单词</span>
    <span class="hljs-comment">// 3. 把单词的字母重新排列（排序）</span>
    const sortedS = s<span class="hljs-selector-class">.split</span>('')<span class="hljs-selector-class">.sort</span>()<span class="hljs-selector-class">.join</span>('');

    if (!m.has(sortedS)) { <span class="hljs-comment">// 4. 检查有没有这种"字母组合"的盒子</span>
      m<span class="hljs-selector-class">.set</span>(sortedS, []); <span class="hljs-comment">// 5. 如果没有，就新建一个空盒子</span>
    }

    <span class="hljs-comment">// 6. 把单词放进对应的盒子里</span>
    m<span class="hljs-selector-class">.get</span>(sortedS)<span class="hljs-selector-class">.push</span>(s);
  }

  <span class="hljs-comment">// 7. 把所有的盒子拿出来，组成一个大包裹返回</span>
  return Array<span class="hljs-selector-class">.from</span>(m.values());
};
</code></pre>
<hr/>
<h3 data-id="heading-3">一步步详细拆解</h3>
<h4 data-id="heading-4">1. <code>var groupAnagrams = function(strs) {</code></h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">var</span> groupAnagrams = <span class="hljs-keyword">function</span>(<span class="hljs-params">strs</span>) {
</code></pre>
<ul>
<li><code>groupAnagrams</code> 是<strong>函数的名字</strong>（就像一个机器的名字叫"分词机"）</li>
<li><code>strs</code> 是<strong>输入参数</strong>（就像你把一堆单词扔进机器）</li>
<li><code>function</code> 是告诉电脑："我定义一个函数，名字叫 <code>groupAnagrams</code>，它会接收一个叫 <code>strs</code> 的参数"</li>
</ul>
<blockquote>
<p>比如：<code>groupAnagrams(["eat", "tea"])</code> → 你把 <code>["eat", "tea"]</code> 传给函数</p>
</blockquote>
<h4 data-id="heading-5">2. <code>const m = new Map();</code></h4>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">m</span> = new Map()<span class="hljs-comment">;</span>
</code></pre>
<ul>
<li><code>const</code>：声明一个<strong>常量</strong>（不能被修改的变量），就像一个<strong>标签</strong></li>
<li><code>m</code>：这是给这个东西起的名字，就像"分类柜"</li>
<li><code>new Map()</code>：创建一个"<strong>哈希表</strong>"（可以想象成一个有很多抽屉的柜子）</li>
</ul>
<blockquote>
<p><strong>Map 就像一个智能分类柜</strong>：</p>
<ul>
<li>你可以给它一个"钥匙"（key），它就能给你对应的"物品"（value）</li>
<li>比如：<code>柜子.放东西("钥匙A", "苹果")</code> → 把苹果放在钥匙A对应的抽屉里</li>
<li><code>柜子.拿东西("钥匙A")</code> → 拿到苹果</li>
</ul>
</blockquote>
<h4 data-id="heading-6">3. <code>for (const s of strs) {</code></h4>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> s of strs) {
</code></pre>
<ul>
<li><code>for</code>：表示"循环"（重复做某件事）</li>
<li><code>const s</code>：每次循环时，用 <code>s</code> 来代表当前的单词</li>
<li><code>of strs</code>：在 <code>strs</code> 数组中一个一个地取单词</li>
</ul>
<blockquote>
<p>如果 <code>strs = ["eat", "tea", "tan"]</code>：</p>
<ul>
<li>第1次循环：<code>s = "eat"</code></li>
<li>第2次循环：<code>s = "tea"</code></li>
<li>第3次循环：<code>s = "tan"</code></li>
</ul>
</blockquote>
<h4 data-id="heading-7">4. <code>const sortedS = s.split('').sort().join('');</code></h4>
<p>这是最神奇的一步！我们来拆开看：</p>
<h5 data-id="heading-8">4.1 <code>s.split('')</code></h5>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-string">"eat"</span>.<span class="hljs-built_in">split</span>(<span class="hljs-string">''</span>) → [<span class="hljs-string">"e"</span>, <span class="hljs-string">"a"</span>, <span class="hljs-string">"t"</span>]
</code></pre>
<ul>
<li><code>split('')</code>：把字符串<strong>拆成</strong>一个个字母组成的数组</li>
</ul>
<h5 data-id="heading-9">4.2 <code>.sort()</code></h5>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-selector-attr">[<span class="hljs-string">"e"</span>, <span class="hljs-string">"a"</span>, <span class="hljs-string">"t"</span>]</span><span class="hljs-selector-class">.sort</span>() → <span class="hljs-selector-attr">[<span class="hljs-string">"a"</span>, <span class="hljs-string">"e"</span>, <span class="hljs-string">"t"</span>]</span>
</code></pre>
<ul>
<li><code>sort()</code>：把数组里的元素<strong>按字母顺序排列</strong></li>
</ul>
<h5 data-id="heading-10">4.3 <code>.join('')</code></h5>
<pre><code class="hljs language-bash" lang="bash">[<span class="hljs-string">"a"</span>, <span class="hljs-string">"e"</span>, <span class="hljs-string">"t"</span>].<span class="hljs-built_in">join</span>(<span class="hljs-string">''</span>) → <span class="hljs-string">"aet"</span>
</code></pre>
<ul>
<li><code>join('')</code>：把数组里的元素<strong>拼接成</strong>一个字符串</li>
</ul>
<blockquote>
<p>所以：</p>
<ul>
<li><code>"eat"</code> → <code>"aet"</code></li>
<li><code>"tea"</code> → <code>"aet"</code> ← 它们排序后是一样的！</li>
<li><code>"tan"</code> → <code>"ant"</code></li>
</ul>
</blockquote>
<h4 data-id="heading-11">5. <code>if (!m.has(sortedS)) {</code></h4>
<pre><code class="hljs language-less" lang="less"><span class="hljs-selector-tag">if</span> (!m.<span class="hljs-built_in">has</span>(sortedS)) {
</code></pre>
<ul>
<li><code>if</code>：表示"如果...那么..."</li>
<li><code>!</code>：表示"不是"、"不存在"</li>
<li><code>m.has(sortedS)</code>：询问分类柜 <code>m</code>："你有没有叫 <code>sortedS</code> 这个钥匙的抽屉？"</li>
</ul>
<blockquote>
<p>如果 <code>sortedS = "aet"</code>：</p>
<ul>
<li><code>m.has("aet")</code> → 问："有没有钥匙叫 'aet' 的抽屉？"</li>
<li><code>!m.has("aet")</code> → "如果没有的话..."</li>
</ul>
</blockquote>
<h4 data-id="heading-12">6. <code>m.set(sortedS, []);</code></h4>
<pre><code class="hljs language-ini" lang="ini">m.set(sortedS, <span class="hljs-section">[]</span>)<span class="hljs-comment">;</span>
</code></pre>
<ul>
<li><code>m.set(key, value)</code>：往分类柜里放东西</li>
<li><code>sortedS</code>：钥匙（比如 <code>"aet"</code>）</li>
<li><code>[]</code>：一个空数组（就像一个空盒子）</li>
</ul>
<blockquote>
<p><code>m.set("aet", [])</code> → 创建一个钥匙叫 "aet" 的抽屉，里面放一个空盒子</p>
</blockquote>
<h4 data-id="heading-13">7. <code>m.get(sortedS).push(s);</code></h4>
<pre><code class="hljs language-scss" lang="scss">m<span class="hljs-selector-class">.get</span>(sortedS)<span class="hljs-selector-class">.push</span>(s);
</code></pre>
<ul>
<li><code>m.get(sortedS)</code>：拿到钥匙 <code>sortedS</code> 对应的抽屉里的盒子</li>
<li><code>.push(s)</code>：把单词 <code>s</code> 放进这个盒子</li>
</ul>
<blockquote>
<p>如果 <code>sortedS = "aet"</code>, <code>s = "eat"</code>：</p>
<ul>
<li><code>m.get("aet")</code> → 拿到装着字母异位词的盒子</li>
<li><code>.push("eat")</code> → 把 "eat" 放进去</li>
</ul>
</blockquote>
<h4 data-id="heading-14">8. <code>return Array.from(m.values());</code></h4>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-keyword">return</span> Array.<span class="hljs-keyword">from</span>(m.values());
</code></pre>
<ul>
<li><code>m.values()</code>：拿出分类柜里<strong>所有抽屉里的东西</strong>（所有装着单词的盒子）</li>
<li><code>Array.from()</code>：把这些东西变成一个数组</li>
<li><code>return</code>：把结果交给外面的人</li>
</ul>
<hr/>
<h3 data-id="heading-15">实际运行过程演示</h3>
<p>让我们用 <code>["eat", "tea", "tan"]</code> 来追踪整个过程：</p>





























































<table><thead><tr><th>步骤</th><th><code>s</code></th><th><code>sortedS</code></th><th><code>m</code> 的状态</th><th>操作</th></tr></thead><tbody><tr><td>1</td><td>"eat"</td><td>"aet"</td><td><code>{}</code></td><td><code>m.set("aet", [])</code> → <code>{"aet": []}</code></td></tr><tr><td/><td/><td/><td/><td><code>m.get("aet").push("eat")</code> → <code>{"aet": ["eat"]}</code></td></tr><tr><td>2</td><td>"tea"</td><td>"aet"</td><td><code>{"aet": ["eat"]}</code></td><td><code>m.has("aet")</code> 为 true，跳过 <code>set</code></td></tr><tr><td/><td/><td/><td/><td><code>m.get("aet").push("tea")</code> → <code>{"aet": ["eat", "tea"]}</code></td></tr><tr><td>3</td><td>"tan"</td><td>"ant"</td><td><code>{"aet": ["eat", "tea"]}</code></td><td><code>m.has("ant")</code> 为 false</td></tr><tr><td/><td/><td/><td/><td><code>m.set("ant", [])</code> → <code>{"aet": ["eat", "tea"], "ant": []}</code></td></tr><tr><td/><td/><td/><td/><td><code>m.get("ant").push("tan")</code> → <code>{"aet": ["eat", "tea"], "ant": ["tan"]}</code></td></tr></tbody></table>
<p>最后 <code>m.values()</code> 得到：<code>[["eat", "tea"], ["tan"]]</code></p>
<hr/>
<h3 data-id="heading-16">核心思想总结</h3>
<blockquote>
<p><strong>"字母异位词"排序后完全一样，所以可以用排序后的字符串作为"分类标签"</strong></p>
</blockquote>
<p>就像：</p>
<ul>
<li><code>"eat"</code>, <code>"tea"</code>, <code>"ate"</code> 都属于 <code>"aet"</code> 类别</li>
<li><code>"tan"</code>, <code>"nat"</code> 都属于 <code>"ant"</code> 类别</li>
</ul>
<hr/>
<h3 data-id="heading-17">JavaScript 语法小知识</h3>




























































<table><thead><tr><th>语法</th><th>含义</th><th>例子</th></tr></thead><tbody><tr><td><code>const</code></td><td>声明常量</td><td><code>const x = 5;</code></td></tr><tr><td><code>new Map()</code></td><td>创建哈希表</td><td><code>const map = new Map();</code></td></tr><tr><td><code>for...of</code></td><td>遍历数组</td><td><code>for(const item of array)</code></td></tr><tr><td><code>split()</code></td><td>拆分字符串</td><td><code>"abc".split('') → ["a", "b", "c"]</code></td></tr><tr><td><code>sort()</code></td><td>排序</td><td><code>["c", "a", "b"].sort() → ["a", "b", "c"]</code></td></tr><tr><td><code>join()</code></td><td>连接数组</td><td><code>["a", "b", "c"].join('') → "abc"</code></td></tr><tr><td><code>push()</code></td><td>添加元素</td><td><code>arr.push(item)</code></td></tr><tr><td><code>has()</code></td><td>检查键是否存在</td><td><code>map.has(key)</code></td></tr><tr><td><code>set()</code></td><td>设置键值对</td><td><code>map.set(key, value)</code></td></tr><tr><td><code>get()</code></td><td>获取值</td><td><code>map.get(key)</code></td></tr></tbody></table>
<hr/>
<h3 data-id="heading-18">总结</h3>
<p>这个算法巧妙地利用了：</p>
<ol>
<li><strong>排序</strong>：让字母异位词变得"一样"</li>
<li><strong>哈希表</strong>：快速分类存储</li>
<li><strong>循环</strong>：逐个处理每个单词</li>
</ol>
<p>最终实现了高效的字母异位词分组！</p>
<hr/>
<hr/>
<blockquote>
<p>你还在学习 JavaScript 的路上吗？在评论区分享你遇到的困惑，我们一起讨论！</p>
</blockquote>
<p>#javascript #算法 #前端开发 #面试准备 #编程入门</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[手把手教你搭建 Nginx-RTMP 流媒体服务器（Ubuntu/Windows）]]></title>    <link>https://juejin.cn/post/7596066987471405098</link>    <guid>https://juejin.cn/post/7596066987471405098</guid>    <pubDate>2026-01-17T17:09:55.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7596066987471405098" data-draft-id="7596092713078882340" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="手把手教你搭建 Nginx-RTMP 流媒体服务器（Ubuntu/Windows）"/> <meta itemprop="keywords" content="音视频开发,直播"/> <meta itemprop="datePublished" content="2026-01-17T17:09:55.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="EZ在线工具网"/> <meta itemprop="url" content="https://juejin.cn/user/494154918666608"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            手把手教你搭建 Nginx-RTMP 流媒体服务器（Ubuntu/Windows）
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/494154918666608/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    EZ在线工具网
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-17T17:09:55.000Z" title="Sat Jan 17 2026 17:09:55 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">作者简介</h2>
<p>👋Hi，我是 <a href="https://link.juejin.cn?target=https%3A%2F%2Fezwebtools.net" target="_blank" title="https://ezwebtools.net" ref="nofollow noopener noreferrer">EZ 在线工具网</a>的站长，专注于多媒体在线视频技术与浏览器端工具开发。</p>
<blockquote>
<p><strong>EZ 在线工具网</strong> 是一个以 <strong>在线视频处理</strong> 为核心的工具平台，提供包括 <strong>M3U8 在线播放、M3U8 转 MP4、RTMP / HLS 流测试、FFmpeg 在线转码</strong> 等功能，全部可直接在浏览器中使用，无需安装客户端。</p>
</blockquote>
<h2 data-id="heading-1">引言</h2>
<p>随着直播行业的爆发，B站、抖音、视频号已经成为我们生活的一部分。但你是否想过，这些光鲜亮丽的直播背后，技术原理是什么？如果我们想自己做一个私服，或者在内网搭建一个监控推流服务器，该怎么做？本文将从零开始，超详细地教你在 Ubuntu 和 Windows 两大主流平台上，手把手编译、配置、并跑通 Nginx-RTMP 流媒体服务器。让你不仅“知其然”，更“知其所以然”。</p>
<h2 data-id="heading-2">为什么选择 Nginx-RTMP？</h2>
<p>在流媒体领域，协议繁多，列如：RTMP、 HLS,、FLV, WebRTC等，服务器也有 SRS, ZLMediaKit, Nginx-RTMP 等。为什么偏偏选 Nginx-RTMP？
我总结了概括以下优点：</p>
<ul>
<li><strong>高性能</strong> ： 众所周知，Nginx 的高并发能力天下闻名。</li>
<li><strong>极度轻量</strong>：资源占用极低，一台 1H1G 的云服务器就能扛住几百路推流。</li>
<li><strong>配置简单</strong>：一个 nginx.conf 走天下。</li>
<li><strong>功能强大</strong>：支持 RTMP 推流，同时支持 HTTP-FLV 和 HLS 播放，完美兼容 PC 和移动端。
本文目标：搭建一台服务器，实现 OBS 推流 -&gt; 服务器 -&gt; VLC/浏览器 播放 的完整闭环。</li>
</ul>
<h2 data-id="heading-3">前期准备</h2>
<p>工欲善其事，必先利其器。请准备好以下环境：</p>
<ul>
<li><strong>一台服务器/电脑</strong>：云服务器（推荐 Ubuntu 20.04/22.04）或者本地 Windows 电脑。</li>
<li><strong>推流工具：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fobsproject.com%2F" target="_blank" title="https://obsproject.com/" ref="nofollow noopener noreferrer">OBS Studio</a>（开源免费，推流界的瑞士军刀）。</li>
<li><strong>播放工具：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.videolan.org%2F" target="_blank" title="https://www.videolan.org/" ref="nofollow noopener noreferrer">VLC Media Player</a>（万能播放器）。</li>
<li><strong>代码编辑器：</strong> VS Code、Notepad++ 或 Vim。</li>
</ul>
<h2 data-id="heading-4">Ubuntu 平台搭建</h2>
<p>为了方便演示，这里使用的是Ubuntu，这里不用 <code>apt install</code>，因为官方源里的 Nginx 不带 <code>RTMP 模块</code>，所以需要从源码编译，听起来很吓人？其实就是复制粘贴几行命令的事。😎</p>
<h3 data-id="heading-5">安装编译依赖</h3>
<p>打开终端，依次执行以下命令：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 更新软件源</span>
sudo apt-get update

<span class="hljs-comment"># 安装编译工具和依赖库</span>
sudo apt-get install build-essential libpcre3 libpcre3-dev libssl-dev zlib1g-dev unzip wget
</code></pre>
<h3 data-id="heading-6">下载 Nginx 和 RTMP 模块</h3>
<p>我们需要两个压缩包：Nginx 源码包、Nginx-RTMP-Module 模块包。</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 创建一个工作目录</span>
<span class="hljs-built_in">mkdir</span> ~/nginx-build &amp;&amp; <span class="hljs-built_in">cd</span> ~/nginx-build

<span class="hljs-comment"># 下载 Nginx (推荐 1.20.x 版本，稳定)</span>
wget http://nginx.org/download/nginx-1.20.2.tar.gz

<span class="hljs-comment"># 下载 RTMP 模块 (作者 arut 的原版)</span>
wget https://github.com/arut/nginx-rtmp-module/archive/master.zip
</code></pre>
<h3 data-id="heading-7">解压与配置</h3>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 解压</span>
tar -zxvf nginx-1.20.2.tar.gz
unzip master.zip

<span class="hljs-comment"># 进入 Nginx 目录</span>
<span class="hljs-built_in">cd</span> nginx-1.20.2
</code></pre>
<p><strong>最关键的一步来了：配置编译参数。</strong>
我们要告诉 Nginx：除了自带的功能，把旁边那个 <code>nginx-rtmp-module</code> 也打包进去。</p>
<pre><code class="hljs language-bash" lang="bash">./configure \
--prefix=/usr/local/nginx \
--add-module=../nginx-rtmp-module-master \
--with-http_ssl_module \
--with-http_v2_module
</code></pre>
<blockquote>
<p><strong>参数解释</strong>：</p>
<ul>
<li><code>--prefix</code>：指定安装目录，方便管理。</li>
<li><code>--add-module</code>：指定 RTMP 模块源码路径，注意是上一级目录的 master 文件夹。</li>
<li><code>--with-http_ssl_module</code>：开启 SSL 支持，注意：HLS 必须用 HTTPS。</li>
</ul>
</blockquote>
<p>如果没有报错，最后会显示 "configured successfully"。</p>
<h3 data-id="heading-8">编译与安装</h3>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 编译（make），-j4 表示用 4 个核心编译，速度快，可以根据机器配置设置核心数</span>
make -j4

sudo make install
</code></pre>
<p>安装完成后，你的 Nginx 就在 <code>/usr/local/nginx</code> 目录下了。</p>
<p><img src="https://fastly.jsdelivr.net/gh/bucketio/img18@main/2026/01/17/1768641403098-fbacca4c-babb-4fd1-8632-008ccb5962c8.png" alt="编译安装Nginx-RTMP" loading="lazy"/></p>
<h3 data-id="heading-9">Ubuntu 系统服务配置</h3>
<p>创建 systemd 服务文件：</p>
<pre><code class="hljs language-bash" lang="bash">sudo vim /etc/systemd/system/nginx-rtmp.service
</code></pre>
<p>添加以下内容：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-section">[Unit]</span>
<span class="hljs-attr">Description</span>=nginx-rtmp server
<span class="hljs-attr">After</span>=network.target

<span class="hljs-section">[Service]</span>
<span class="hljs-attr">Type</span>=forking
<span class="hljs-attr">PIDFile</span>=/usr/local/nginx/logs/nginx.pid
<span class="hljs-attr">ExecStart</span>=/usr/local/nginx/sbin/nginx
<span class="hljs-attr">ExecReload</span>=/usr/local/nginx/sbin/nginx -s reload
<span class="hljs-attr">ExecStop</span>=/usr/local/nginx/sbin/nginx -s quit
<span class="hljs-attr">PrivateTmp</span>=<span class="hljs-literal">true</span>

<span class="hljs-section">[Install]</span>
<span class="hljs-attr">WantedBy</span>=multi-user.target
</code></pre>
<p>启用服务:</p>
<pre><code class="hljs language-bash" lang="bash">sudo systemctl <span class="hljs-built_in">enable</span> nginx-rtmp
sudo systemctl start nginx-rtmp
</code></pre>
<hr/>
<h2 data-id="heading-10">Windows 平台搭建</h2>
<p>Windows 编译环境太麻烦，好在有大神做了编译好的二进制包。</p>
<h3 data-id="heading-11">下载解压</h3>
<ol>
<li>访问 GitHub 仓库：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Filluspas%2Fnginx-rtmp-win32%2Freleases" target="_blank" title="https://github.com/illuspas/nginx-rtmp-win32/releases" ref="nofollow noopener noreferrer">illuspas/nginx-rtmp-win32</a>。</li>
<li>下载最新的 <code>nginx-rtmp-win32-1.2.1.zip</code>。</li>
<li>解压到非中文路径，例如 <code>D:\nginx-rtmp</code>。</li>
</ol>
<p><img src="https://fastly.jsdelivr.net/gh/bucketio/img11@main/2026/01/17/1768641459264-b25aacb3-ea47-4be1-9913-ec5d7c2e0eab.png" alt="Windows Nginx RTMP" loading="lazy"/></p>
<p>看到 <code>nginx.exe</code> 了吗？这就是我们的主角。</p>
<hr/>
<h2 data-id="heading-12">核心配置：nginx.conf 详解</h2>
<p>无论 Ubuntu 还是 Windows，灵魂都在 <code>conf/nginx.conf</code> 文件里。
用编辑器打开它，找到 <code>http { ... }</code> 部分，<strong>在它的外面同级位置</strong>，添加以下 <code>rtmp</code> 配置：</p>
<pre><code class="hljs language-nginx" lang="nginx">rtmp {
    server {
        listen 1935; # RTMP 默认端口
        chunk_size 4096;

        application live {
            live on;             # 开启直播模式
            record off;          # 关闭录制（节省硬盘）
            allow publish 127.0.0.1; # 允许推流的客户端 IP，生产环境建议改成内网 IP 或密码验证
            
            # 开启 HLS 切片
            hls on;
            hls_path /tmp/hls;   # Ubuntu 路径
            # hls_path D:/nginx-rtmp/temp/hls; # Windows 路径，注意反斜杠
            hls_fragment 3s;     # 每个切片 3 秒
            hls_playlist_length 10s; # 播放列表长度 10 秒
        }
    }
}

http {
    include       mime.types;
    default_type  application/octet-stream;
    sendfile        on;
    keepalive_timeout  65;

    server {
        listen       80; # HTTP 默认端口，用于播放 HLS
        server_name  localhost;

        # HLS 播放配置
        location /hls {
            types {
                application/vnd.apple.mpegurl m3u8;
                video/mp2t ts;
            }
            root /tmp; # Ubuntu
            # root D:/nginx-rtmp/temp; # Windows
            add_header Cache-Control no-cache;
        }
    }
}
</code></pre>
<p><strong>配置保存后：</strong></p>
<ul>
<li><strong>Ubuntu</strong>：<code>sudo /usr/local/nginx/sbin/nginx</code> 启动。</li>
<li><strong>Windows</strong>：双击 <code>nginx.exe</code> 启动（会闪一个黑窗口）。</li>
</ul>
<blockquote>
<p><strong>防火墙注意</strong>：务必开放 <strong>1935</strong> (推流) 和 <strong>80</strong> (播放) 端口！</p>
<ul>
<li>Ubuntu: <code>sudo ufw allow 1935 &amp;&amp; sudo ufw allow 80</code></li>
<li>Windows: 防火墙高级设置 -&gt; 入站规则 -&gt; 新建规则 -&gt; 端口 -&gt; TCP 1935, 80。</li>
</ul>
</blockquote>
<p><img src="https://fastly.jsdelivr.net/gh/bucketio/img7@main/2026/01/17/1768641500793-fd6ef477-1d0e-4daf-9139-3ae603d4cba4.png" alt="Windows 防火墙端口放行设置" loading="lazy"/></p>
<hr/>
<h2 data-id="heading-13">实战推流：OBS 连接服务器</h2>
<p>根据实际情况替换掉下方的服务器，我这里的IP是 <code>192.168.1.3</code>。</p>
<h3 data-id="heading-14">OBS 设置</h3>
<ol>
<li>
<p><strong>来源</strong>：添加“显示器采集”或“视频捕获设备”。</p>
</li>
<li>
<p><strong>设置 -&gt; 直播</strong>：</p>
<ul>
<li>服务：自定义</li>
<li><strong>服务器</strong>：<code>rtmp://192.168.1.3/live</code></li>
<li><strong>推流码</strong>：<code>test</code> 这个可以自定义，相当于房间号</li>
</ul>
</li>
<li>
<p><strong>设置 -&gt; 输出</strong>：</p>
<ul>
<li>码率：2000 Kbps (2Mbps) 足够清晰。</li>
<li>输出模式-&gt;关键帧间隔：2 秒。</li>
</ul>
</li>
</ol>
<p><img src="https://fastly.jsdelivr.net/gh/bucketio/img11@main/2026/01/17/1768641593728-f60addeb-eb1f-48ff-9996-508a67cae21f.png" alt="OBS Studio 推流设置" loading="lazy"/></p>
<h3 data-id="heading-15">点击“开始推流”</h3>
<p>如果 OBS 右下角显示“正在推流”，且码率不是 0，恭喜你！数据已经发出去了！</p>
<hr/>
<h2 data-id="heading-16">实战拉流：三种方式看直播</h2>
<p>推上去了，怎么看？有三种主流协议。</p>

































<table><thead><tr><th align="left">协议</th><th align="left">URL 格式</th><th align="left">延迟</th><th align="left">优点</th><th align="left">缺点</th></tr></thead><tbody><tr><td align="left"><strong>RTMP</strong></td><td align="left"><code>rtmp://ip/live/test</code></td><td align="left">1-3 秒</td><td align="left">极低延迟</td><td align="left">浏览器不支持，需播放器</td></tr><tr><td align="left"><strong>HTTP-FLV</strong></td><td align="left"><code>http://ip/live/test.flv</code></td><td align="left">2-5 秒</td><td align="left">低延迟，网页可播</td><td align="left">需 flv.js 支持</td></tr><tr><td align="left"><strong>HLS</strong></td><td align="left"><code>http://ip/hls/test.m3u8</code></td><td align="left">10-30 秒</td><td align="left">兼容性最好</td><td align="left">延迟高</td></tr></tbody></table>
<h4 data-id="heading-17">方式一：VLC 播放</h4>
<ol>
<li>打开 VLC -&gt; 媒体 -&gt; 打开网络串流。</li>
<li>输入：<code>rtmp://你的IP/live/test</code></li>
<li>回车，画面出来了！</li>
</ol>
<p><img src="https://fastly.jsdelivr.net/gh/bucketio/img14@main/2026/01/17/1768641618230-542da0a1-35b1-4b89-84fc-dc2336018b14.png" alt="VLC 播放器成功播放画面" loading="lazy"/></p>
<h4 data-id="heading-18">方式二：浏览器播放 HLS（Safari/Edge）</h4>
<p>直接在地址栏输入：<code>http://你的IP/hls/test.m3u8</code>
Safari 和 Edge 原生支持 HLS，直接就能看。Chrome 需要插件。</p>
<h4 data-id="heading-19">方式三：网页播放 HTTP-FLV</h4>
<p>这里推荐EZ在线工具网的<a href="https://link.juejin.cn?target=https%3A%2F%2Fezwebtools.net%2Frtmp-player" target="_blank" title="https://ezwebtools.net/rtmp-player" ref="nofollow noopener noreferrer">FLV/RTMP在线播放器</a>，免去开发的麻烦。非常适合RTMP直播流测试，支持RTMP和FLV格式，实时直播流信息、截图等功能。</p>
<p>如果想自己编写，可以参考B站开源的<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FBilibili%2Fflv.js" target="_blank" title="https://github.com/Bilibili/flv.js" ref="nofollow noopener noreferrer">flv.js</a>。
创建一个 <code>index.html</code> 文件，贴入以下代码：</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Nginx-RTMP 直播<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.bootcss.com/flv.js/1.5.0/flv.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>我的直播间<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"videoElement"</span> <span class="hljs-attr">controls</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"800"</span> <span class="hljs-attr">height</span>=<span class="hljs-string">"450"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
        <span class="hljs-keyword">if</span> (flvjs.<span class="hljs-title function_">isSupported</span>()) {
            <span class="hljs-keyword">var</span> videoElement = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'videoElement'</span>);
            <span class="hljs-keyword">var</span> flvPlayer = flvjs.<span class="hljs-title function_">createPlayer</span>({
                <span class="hljs-attr">type</span>: <span class="hljs-string">'flv'</span>,
                <span class="hljs-attr">url</span>: <span class="hljs-string">'http://你的IP/live/test.flv'</span> <span class="hljs-comment">// 注意这里是 flv</span>
            });
            flvPlayer.<span class="hljs-title function_">attachMediaElement</span>(videoElement);
            flvPlayer.<span class="hljs-title function_">load</span>();
            flvPlayer.<span class="hljs-title function_">play</span>();
        }
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<blockquote>
<p><strong>注意</strong>：上面的 <code>nginx.conf</code> 默认没开 flv，要开的话在 <code>rtmp -&gt; application live</code> 里加一句 <code>allow publish 127.0.0.1;</code> 然后在 <code>http server</code> 里加：</p>
<pre><code class="hljs language-nginx" lang="nginx">location /live {
    flv_live on;
    chunked_transfer_encoding on;
    add_header 'Access-Control-Allow-Origin' '*';
}
</code></pre>
</blockquote>
<p><img src="https://fastly.jsdelivr.net/gh/bucketio/img10@main/2026/01/17/1768641638542-bd3ec67f-2a7a-4899-8dd7-3ba3db861467.png" alt="FLV/RTMP在线播放器" loading="lazy"/></p>
<hr/>
<h2 data-id="heading-20">进阶：内网穿透，让外网访问</h2>
<p>如果你是在自己电脑上搭的（Windows），朋友想看怎么办？你没有公网 IP。</p>
<p>有三种方案：</p>
<ol>
<li><strong>花生壳/Frp</strong>：简单，但免费版限速。</li>
<li><strong>Zerotier/Hamachi</strong>：组建虚拟局域网，朋友装个客户端，用内网 IP 访问。</li>
<li><strong>Ngrok</strong>：国外工具，稳定但要钱。</li>
</ol>
<p><strong>最傻瓜的方法（路由器端口映射）：</strong>
如果你有光猫拨号的公网 IP：</p>
<ol>
<li>登录路由器（192.168.1.1）。</li>
<li>找到“虚拟服务器”或“端口转发”。</li>
<li>添加两条：
<ul>
<li>外部端口 1935 -&gt; 内部 IP（你电脑IP） -&gt; 内部端口 1935</li>
<li>外部端口 80 -&gt; 内部 IP（你电脑IP） -&gt; 内部端口 80</li>
</ul>
</li>
<li>推流地址填你的<strong>公网 IP</strong> 即可。</li>
</ol>
<hr/>
<h2 data-id="heading-21">常见问题排查</h2>






























<table><thead><tr><th align="left">现象</th><th align="left">原因</th><th align="left">解决方法</th></tr></thead><tbody><tr><td align="left">OBS 推流报错 <code>connection refused</code></td><td align="left">防火墙挡了 / Nginx没开</td><td align="left">检查防火墙和进程</td></tr><tr><td align="left">OBS 推流成功，VLC 黑屏</td><td align="left">编码格式不对</td><td align="left">OBS 视频编码改为 H.264，音频改为 AAC</td></tr><tr><td align="left">公网无法访问，内网可以</td><td align="left">没做端口映射 / 没公网IP</td><td align="left">去路由器做映射，或用 Frp</td></tr><tr><td align="left">HLS 播放 404</td><td align="left">Nginx 配置路径不对</td><td align="left">检查 <code>hls_path</code> 和 <code>location /hls</code> 的 <code>root</code> 是否对应</td></tr></tbody></table>
<p><strong>查看日志是个好习惯！</strong></p>
<ul>
<li>Ubuntu: <code>tail -f /usr/local/nginx/logs/error.log</code></li>
<li>Windows: <code>logs/error.log</code></li>
</ul>
<hr/>
<h2 data-id="heading-22">总结与展望</h2>
<p>恭喜你！你已经掌握了流媒体服务器最核心的搭建技术。</p>
<p><strong>回顾一下我们做了什么：</strong></p>
<ol>
<li>搞定了Ubuntu / Windows Nginx-RTMP模块的环境搭建。</li>
<li>对配置文件 <code>nginx.conf</code>进行了RTMP推流的配置。</li>
<li>打通了 OBS -&gt; Nginx -&gt; VLC 的链路。</li>
</ol>
<p><strong>下一步可以玩什么？</strong></p>
<ul>
<li><strong>录制回放</strong>：配置 <code>record all;</code> 和 <code>exec_record_done</code> 脚本，实现直播自动录制并上传到点播系统。</li>
<li><strong>多码率</strong>：配置 <code>ffmpeg</code> 转码，让用户根据网速选择 720P/1080P。</li>
<li><strong>鉴权</strong>：防止别人乱推流，配置 <code>on_publish</code> 接口回调验证密钥。</li>
<li><strong>WebRTC</strong>：Nginx-RTMP 延迟还是有点高，想做连麦互动？去研究 ZLMediaKit 或 SRS，它们原生支持 WebRTC，延迟能到 500ms 以内。</li>
</ul>
<h2 data-id="heading-23">参考资料</h2>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fezwebtools.net%2Frtmp-player" target="_blank" title="https://ezwebtools.net/rtmp-player" ref="nofollow noopener noreferrer">FLV/RTMP在线播放器</a>]</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Farut%2Fnginx-rtmp-module%2Fwiki" target="_blank" title="https://github.com/arut/nginx-rtmp-module/wiki" ref="nofollow noopener noreferrer">Nginx-RTMP Module官方文档</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fobsproject.com%2Fwiki%2FStreaming" target="_blank" title="https://obsproject.com/wiki/Streaming" ref="nofollow noopener noreferrer">OBS Studio推流设置指南</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.videolan.org%2Fvlc%2Fdocumentation%2F" target="_blank" title="https://www.videolan.org/vlc/documentation/" ref="nofollow noopener noreferrer">VLC播放器使用教程</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ffatedier%2Ffrp" target="_blank" title="https://github.com/fatedier/frp" ref="nofollow noopener noreferrer">Frp内网穿透工具</a></li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[单实例多MCP聚合服务：两种实现方案深度对比]]></title>    <link>https://juejin.cn/post/7596883689826762815</link>    <guid>https://juejin.cn/post/7596883689826762815</guid>    <pubDate>2026-01-19T10:07:06.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7596883689826762815" data-draft-id="7596865421612007478" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="单实例多MCP聚合服务：两种实现方案深度对比"/> <meta itemprop="keywords" content="前端,MCP"/> <meta itemprop="datePublished" content="2026-01-19T10:07:06.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="betterhyq"/> <meta itemprop="url" content="https://juejin.cn/user/708557910842296"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            单实例多MCP聚合服务：两种实现方案深度对比
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/708557910842296/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    betterhyq
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-19T10:07:06.000Z" title="Mon Jan 19 2026 10:07:06 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读15分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>方案1：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fbetterhyq%2Fhoneycomb-nginx%2F" target="_blank" title="https://github.com/betterhyq/honeycomb-nginx/" ref="nofollow noopener noreferrer">github.com/betterhyq/h…</a><br/>
方案2：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fbetterhyq%2Fhoneycomb%2F" target="_blank" title="https://github.com/betterhyq/honeycomb/" ref="nofollow noopener noreferrer">github.com/betterhyq/h…</a></p>
</blockquote>
<h2 data-id="heading-0">一、引言</h2>
<p>在 AI 应用开发中，Model Context Protocol (MCP) 作为连接 AI 工具与外部服务的标准协议，正变得越来越重要。然而，当我们需要同时运行多个 MCP 服务时，传统的单服务单端口部署方式会带来诸多问题：</p>
<ul>
<li><strong>端口管理复杂</strong>：每个 MCP 服务需要占用独立端口，随着服务数量增长，端口分配和管理变得繁琐</li>
<li><strong>资源浪费</strong>：每个服务独立进程，内存和 CPU 资源消耗较大</li>
<li><strong>部署维护困难</strong>：需要为每个服务单独配置、监控和更新</li>
<li><strong>客户端配置复杂</strong>：AI 应用需要配置多个不同的服务地址和端口</li>
</ul>
<p>为了解决这些问题，我们探索了两种<strong>单实例多MCP聚合服务</strong>的实现方案：<strong>方案1（Nginx反向代理）<strong>和</strong>方案2（Express统一服务）</strong>。本文将深入对比这两种方案的架构设计、实现细节、优缺点及适用场景，帮助开发者根据实际需求选择最合适的方案。</p>
<p><strong>文章价值</strong>：</p>
<ul>
<li>理解单实例多MCP聚合服务的核心设计思想</li>
<li>掌握两种不同技术栈的实现方案</li>
<li>学会根据业务场景选择合适的技术方案</li>
<li>了解 MCP 协议在实际项目中的应用实践</li>
</ul>
<p><strong>适用人群</strong>：</p>
<ul>
<li>Node.js 后端开发工程师</li>
<li>AI 应用开发者</li>
<li>系统架构师</li>
<li>对 MCP 协议感兴趣的开发者</li>
</ul>
<p><strong>前置知识</strong>：</p>
<ul>
<li>JavaScript/TypeScript 基础</li>
<li>Node.js 和 Express 框架</li>
<li>HTTP 协议和 SSE（Server-Sent Events）</li>
<li>Nginx 基础配置</li>
<li>MCP 协议基本概念</li>
</ul>
<hr/>
<h2 data-id="heading-1">二、核心理论基础</h2>
<h3 data-id="heading-2">2.1 MCP 协议简介</h3>
<p>Model Context Protocol (MCP) 是由 Anthropic 提出的标准协议，用于 AI 应用与外部工具和服务之间的通信。MCP 支持多种传输方式，包括：</p>
<ul>
<li><strong>HTTP Stream</strong>：基于 HTTP 的流式传输</li>
<li><strong>SSE (Server-Sent Events)</strong>：服务器推送事件，适合长连接场景</li>
<li><strong>WebSocket</strong>：双向通信协议</li>
</ul>
<p>MCP 的核心概念包括：</p>
<ul>
<li><strong>Tools（工具）</strong>：可被 AI 调用的功能单元，每个工具包含名称、描述、输入/输出 Schema</li>
<li><strong>Resources（资源）</strong>：可被 AI 访问的数据资源</li>
<li><strong>Prompts（提示）</strong>：预定义的提示模板</li>
</ul>
<h3 data-id="heading-3">2.2 单实例多MCP聚合服务的核心思想</h3>
<p>单实例多MCP聚合服务的核心思想是：<strong>在一个进程实例中同时运行多个 MCP 服务，通过统一的入口对外提供服务，客户端通过标识符（如 Header 参数）来区分和访问不同的 MCP 服务</strong>。</p>
<p>这种设计的优势：</p>
<ol>
<li><strong>资源高效</strong>：多个服务共享同一个进程，减少内存和 CPU 开销</li>
<li><strong>统一管理</strong>：集中配置、监控和日志管理</li>
<li><strong>简化部署</strong>：只需部署一个服务实例，降低运维复杂度</li>
<li><strong>灵活扩展</strong>：可以动态添加、删除或更新 MCP 服务</li>
</ol>
<h3 data-id="heading-4">2.3 两种方案的技术路线对比</h3>








































<table><thead><tr><th>维度</th><th>方案1：Nginx反向代理</th><th>方案2：Express统一服务</th></tr></thead><tbody><tr><td><strong>架构模式</strong></td><td>反向代理 + 多端口服务</td><td>单端口 + 路由分发</td></tr><tr><td><strong>服务隔离</strong></td><td>物理隔离（独立端口）</td><td>逻辑隔离（内存映射）</td></tr><tr><td><strong>路由方式</strong></td><td>HTTP Header (<code>X-Target-Port</code>)</td><td>HTTP Header (<code>MCP_ID</code>)</td></tr><tr><td><strong>服务管理</strong></td><td>静态配置（config.json）</td><td>动态管理（数据库）</td></tr><tr><td><strong>配置方式</strong></td><td>文件配置</td><td>可视化界面 + API</td></tr><tr><td><strong>扩展性</strong></td><td>需要重启服务</td><td>支持热更新</td></tr></tbody></table>
<hr/>
<h2 data-id="heading-5">三、方案1：Nginx反向代理方案</h2>
<h3 data-id="heading-6">3.1 架构设计</h3>
<p>方案1采用 <strong>Nginx 反向代理 + 多端口 MCP 服务</strong> 的架构：</p>
<pre><code class="hljs language-scss" lang="scss">客户端请求
    ↓
Nginx (端口<span class="hljs-number">80</span>)
    ↓ (根据 X-Target-Port header)
后端 MCP 服务集群
    ├── 服务<span class="hljs-number">1</span> (端口<span class="hljs-number">8080</span>)
    ├── 服务<span class="hljs-number">2</span> (端口<span class="hljs-number">8081</span>)
    ├── 服务<span class="hljs-number">3</span> (端口<span class="hljs-number">8082</span>)
    └── 服务<span class="hljs-number">4</span> (端口<span class="hljs-number">8083</span>)
</code></pre>
<p><strong>核心流程</strong>：</p>
<ol>
<li>客户端发送请求到 Nginx（端口80），在 Header 中携带 <code>X-Target-Port</code> 指定目标端口</li>
<li>Nginx 根据 <code>X-Target-Port</code> 动态路由到对应的后端 MCP 服务</li>
<li>后端服务处理请求并返回响应</li>
</ol>
<h3 data-id="heading-7">3.2 环境准备</h3>
<p><strong>软硬件环境</strong>：</p>
<ul>
<li>Node.js &gt;= 22.0.0</li>
<li>pnpm &gt;= 8.0.0</li>
<li>Nginx &gt;= 1.21</li>
<li>Docker（可选，用于容器化部署）</li>
</ul>
<p><strong>项目依赖</strong>：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"dependencies"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"fastmcp"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"^0.1.0"</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<h3 data-id="heading-8">3.3 核心功能实现</h3>
<h4 data-id="heading-9">模块1：MCP 服务启动管理</h4>
<p><strong>实现目标</strong>：根据配置文件动态启动多个独立的 MCP 服务实例，每个服务运行在独立端口。</p>
<p><strong>核心代码</strong>（<code>src/index.ts</code>）：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">import</span> config <span class="hljs-keyword">from</span> <span class="hljs-string">"../config.json"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">FastMCP</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"fastmcp"</span>;
<span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">"node:path"</span>;
<span class="hljs-keyword">import</span> { fileURLToPath } <span class="hljs-keyword">from</span> <span class="hljs-string">"node:url"</span>;

<span class="hljs-keyword">const</span> __filename = <span class="hljs-title function_">fileURLToPath</span>(<span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">url</span>);
<span class="hljs-keyword">const</span> __dirname = path.<span class="hljs-title function_">dirname</span>(__filename);

<span class="hljs-keyword">const</span> <span class="hljs-title function_">start</span> = (<span class="hljs-params"/>) =&gt; {
  config.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">async</span> (mcpConfig) =&gt; {
    <span class="hljs-comment">// 创建 FastMCP 服务器实例</span>
    <span class="hljs-keyword">const</span> server = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FastMCP</span>({
      <span class="hljs-attr">name</span>: mcpConfig.<span class="hljs-property">name</span>,
      <span class="hljs-attr">version</span>: mcpConfig.<span class="hljs-property">version</span> <span class="hljs-keyword">as</span> <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-built_in">number</span>}</span>.<span class="hljs-subst">${<span class="hljs-built_in">number</span>}</span>.<span class="hljs-subst">${<span class="hljs-built_in">number</span>}</span>`</span>,
    });
    
    <span class="hljs-comment">// 动态导入服务模块并注册工具</span>
    <span class="hljs-keyword">const</span> { <span class="hljs-attr">default</span>: registerTools } = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(
      path.<span class="hljs-title function_">join</span>(__dirname, mcpConfig.<span class="hljs-property">entry</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-string">".ts"</span>, <span class="hljs-string">".mjs"</span>))
    );
    <span class="hljs-title function_">registerTools</span>(server);
    
    <span class="hljs-comment">// 启动服务，监听指定端口</span>
    server.<span class="hljs-title function_">start</span>({
      <span class="hljs-attr">transportType</span>: <span class="hljs-string">"httpStream"</span>,
      <span class="hljs-attr">httpStream</span>: {
        <span class="hljs-attr">host</span>: <span class="hljs-string">"0.0.0.0"</span>,
        <span class="hljs-attr">port</span>: mcpConfig.<span class="hljs-property">port</span>,  <span class="hljs-comment">// 每个服务独立端口</span>
      },
    });
  });
};

<span class="hljs-title function_">start</span>();
</code></pre>
<p><strong>代码解析</strong>：</p>
<ul>
<li>使用 <code>FastMCP</code> 框架简化 MCP 服务开发</li>
<li>通过 <code>config.json</code> 配置文件驱动，支持动态加载服务模块</li>
<li>每个服务实例独立监听不同端口，实现物理隔离</li>
<li>使用动态导入（<code>import()</code>）实现模块的按需加载</li>
</ul>
<p><strong>配置文件</strong>（<code>config.json</code>）：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">[</span>
  <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Common MCP Server"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"version"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"1.0.0"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"entry"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"servers/_common/index.ts"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"port"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">8080</span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Temperature Conversion MCP Server"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"version"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"1.0.0"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"entry"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"servers/temperatureConversion/index.ts"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"port"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">8081</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">]</span>
</code></pre>
<h4 data-id="heading-10">模块2：Nginx 反向代理配置</h4>
<p><strong>实现目标</strong>：配置 Nginx 根据 <code>X-Target-Port</code> header 动态路由请求到对应的后端服务端口。</p>
<p><strong>核心配置</strong>（<code>docker/nginx.conf</code>）：</p>
<pre><code class="hljs language-nginx" lang="nginx">http {
    # 使用 map 指令根据 X-Target-Port header 动态构建后端地址
    map $http_x_target_port $backend_upstream {
        default "http://0.0.0.0:8080";  # 默认端口
        "~^(\d+)$" "http://0.0.0.0:$1";  # 如果 X-Target-Port 是数字，使用该端口
    }

    server {
        listen 80;
        server_name _;

        location / {
            # 使用动态构建的后端地址
            proxy_pass $backend_upstream;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
    
            # SSE (Server-Sent Events) 配置
            proxy_http_version 1.1;
            proxy_buffering off;  # 关闭缓冲，支持流式传输
            proxy_cache off;
            proxy_set_header Connection "keep-alive"; 
            proxy_read_timeout 86400s;  # 长连接超时时间
            proxy_send_timeout 60s;
        }
    }
}
</code></pre>
<p><strong>配置解析</strong>：</p>
<ul>
<li><code>map</code> 指令：根据 <code>$http_x_target_port</code>（Nginx 自动将 Header 中的 <code>-</code> 转换为 <code>_</code>）动态构建后端地址</li>
<li><code>proxy_pass $backend_upstream</code>：使用动态变量进行反向代理</li>
<li>SSE 配置：关闭缓冲、设置长连接超时，确保流式传输正常工作</li>
</ul>
<p><strong>效果验证</strong>：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 测试服务1（端口8080）</span>
curl -H <span class="hljs-string">"X-Target-Port: 8080"</span> http://localhost/sse

<span class="hljs-comment"># 测试服务2（端口8081）</span>
curl -H <span class="hljs-string">"X-Target-Port: 8081"</span> http://localhost/sse
</code></pre>
<h4 data-id="heading-11">模块3：MCP 服务工具注册</h4>
<p><strong>实现目标</strong>：在每个服务模块中注册具体的工具函数。</p>
<p><strong>示例代码</strong>（<code>servers/temperatureConversion/index.ts</code>）：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">FastMCP</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"fastmcp"</span>;
<span class="hljs-keyword">import</span> { z } <span class="hljs-keyword">from</span> <span class="hljs-string">"zod"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">registerTools</span>(<span class="hljs-params">server: FastMCP</span>) {
  <span class="hljs-comment">// 注册温度转换工具</span>
  server.<span class="hljs-title function_">tool</span>(
    <span class="hljs-string">"convert_temperature"</span>,
    <span class="hljs-string">"将温度在不同单位之间转换（摄氏度、华氏度、开尔文）"</span>,
    {
      <span class="hljs-attr">temperature</span>: z.<span class="hljs-title function_">number</span>().<span class="hljs-title function_">describe</span>(<span class="hljs-string">"要转换的温度值"</span>),
      <span class="hljs-attr">from</span>: z.<span class="hljs-title function_">enum</span>([<span class="hljs-string">"celsius"</span>, <span class="hljs-string">"fahrenheit"</span>, <span class="hljs-string">"kelvin"</span>]).<span class="hljs-title function_">describe</span>(<span class="hljs-string">"源温度单位"</span>),
      <span class="hljs-attr">to</span>: z.<span class="hljs-title function_">enum</span>([<span class="hljs-string">"celsius"</span>, <span class="hljs-string">"fahrenheit"</span>, <span class="hljs-string">"kelvin"</span>]).<span class="hljs-title function_">describe</span>(<span class="hljs-string">"目标温度单位"</span>),
    },
    <span class="hljs-keyword">async</span> ({ temperature, <span class="hljs-keyword">from</span>, to }) =&gt; {
      <span class="hljs-comment">// 转换逻辑</span>
      <span class="hljs-keyword">let</span> celsius = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">from</span> === <span class="hljs-string">"celsius"</span>) celsius = temperature;
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">from</span> === <span class="hljs-string">"fahrenheit"</span>) celsius = (temperature - <span class="hljs-number">32</span>) * <span class="hljs-number">5</span> / <span class="hljs-number">9</span>;
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">from</span> === <span class="hljs-string">"kelvin"</span>) celsius = temperature - <span class="hljs-number">273.15</span>;

      <span class="hljs-keyword">let</span> result = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">if</span> (to === <span class="hljs-string">"celsius"</span>) result = celsius;
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (to === <span class="hljs-string">"fahrenheit"</span>) result = celsius * <span class="hljs-number">9</span> / <span class="hljs-number">5</span> + <span class="hljs-number">32</span>;
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (to === <span class="hljs-string">"kelvin"</span>) result = celsius + <span class="hljs-number">273.15</span>;

      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">content</span>: [
          {
            <span class="hljs-attr">type</span>: <span class="hljs-string">"text"</span>,
            <span class="hljs-attr">text</span>: <span class="hljs-string">`<span class="hljs-subst">${temperature}</span>°<span class="hljs-subst">${<span class="hljs-keyword">from</span>}</span> = <span class="hljs-subst">${result.toFixed(<span class="hljs-number">2</span>)}</span>°<span class="hljs-subst">${to}</span>`</span>,
          },
        ],
      };
    }
  );
}
</code></pre>
<h3 data-id="heading-12">3.4 常见问题&amp;踩坑指南</h3>
<p><strong>问题1：Nginx 502 Bad Gateway</strong></p>
<p><strong>现象</strong>：客户端请求返回 502 错误</p>
<p><strong>原因</strong>：</p>
<ul>
<li>后端 MCP 服务未启动</li>
<li>端口配置错误</li>
<li>Nginx 无法连接到后端服务</li>
</ul>
<p><strong>解决方案</strong>：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 检查后端服务是否运行</span>
lsof -i:8080
lsof -i:8081

<span class="hljs-comment"># 检查 Nginx 配置语法</span>
nginx -t

<span class="hljs-comment"># 查看 Nginx 错误日志</span>
<span class="hljs-built_in">tail</span> -f /var/log/nginx/error.log
</code></pre>
<p><strong>问题2：SSE 连接断开</strong></p>
<p><strong>现象</strong>：SSE 连接建立后很快断开</p>
<p><strong>原因</strong>：Nginx 默认的 <code>proxy_read_timeout</code> 过短</p>
<p><strong>解决方案</strong>：在 Nginx 配置中增加超时时间：</p>
<pre><code class="hljs language-nginx" lang="nginx">proxy_read_timeout 86400s;  # 24小时
proxy_send_timeout 60s;
</code></pre>
<p><strong>问题3：端口冲突</strong></p>
<p><strong>现象</strong>：服务启动失败，提示端口被占用</p>
<p><strong>原因</strong>：多个服务配置了相同端口</p>
<p><strong>解决方案</strong>：</p>
<ul>
<li>检查 <code>config.json</code> 确保每个服务端口唯一</li>
<li>使用 <code>lsof -i:端口号</code> 查找占用进程并关闭</li>
</ul>
<hr/>
<h2 data-id="heading-13">四、方案2：Express统一服务方案</h2>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6af9add5174446cd8c466769cec5646e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgYmV0dGVyaHlx:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769422025&amp;x-signature=cTpcBUJz8dSMTabQvv3IbttGVn4%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-14">4.1 架构设计</h3>
<p>方案2采用 <strong>Express 单端口 + 内存映射管理</strong> 的架构：</p>
<pre><code class="hljs language-scss" lang="scss">客户端请求
    ↓
Express 服务器 (端口<span class="hljs-number">3002</span>)
    ↓ (根据 MCP_ID header)
MCP 服务管理器
    ↓
Map&lt;configId, McpHandlers&gt;
    ├── 服务<span class="hljs-number">1</span> (ID: <span class="hljs-number">1</span>)
    ├── 服务<span class="hljs-number">2</span> (ID: <span class="hljs-number">2</span>)
    ├── 服务<span class="hljs-number">3</span> (ID: <span class="hljs-number">3</span>)
    └── 服务<span class="hljs-number">4</span> (ID: <span class="hljs-number">4</span>)
    ↓
SQL<span class="hljs-selector-class">.js</span> 数据库 (配置持久化)
</code></pre>
<p><strong>核心流程</strong>：</p>
<ol>
<li>客户端发送请求到 Express 服务器（端口3002），在 Header 中携带 <code>MCP_ID</code> 指定服务ID</li>
<li>Express 路由处理器解析 <code>MCP_ID</code>，从内存映射表（<code>Map&lt;configId, McpHandlers&gt;</code>）中获取对应的 handlers</li>
<li>调用对应的 MCP handler 处理请求并返回响应</li>
<li>配置信息存储在 SQL.js 数据库中，支持动态创建、更新和删除</li>
</ol>
<h3 data-id="heading-15">4.2 环境准备</h3>
<p><strong>软硬件环境</strong>：</p>
<ul>
<li>Node.js &gt;= 24.11.1</li>
<li>pnpm &gt;= 10.25.0</li>
<li>SQL.js（内置，无需额外数据库服务）</li>
</ul>
<p><strong>项目依赖</strong>：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"dependencies"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"@modelcontextprotocol/sdk"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"^1.0.0"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"express"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"^5.0.0"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"express-mcp-handler"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"^1.0.0"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"sql.js"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"^1.10.0"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"kysely"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"^0.27.0"</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<h3 data-id="heading-16">4.3 核心功能实现</h3>
<h4 data-id="heading-17">模块1：MCP 服务动态管理</h4>
<p><strong>实现目标</strong>：从数据库加载配置，动态创建 MCP 服务实例，并维护内存映射表。</p>
<p><strong>核心代码</strong>（<code>packages/honeycomb-server/src/mcp.ts</code>）：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">McpServer</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"@modelcontextprotocol/sdk/server/mcp.js"</span>;
<span class="hljs-keyword">import</span> { sseHandlers } <span class="hljs-keyword">from</span> <span class="hljs-string">"express-mcp-handler"</span>;
<span class="hljs-keyword">import</span> { z } <span class="hljs-keyword">from</span> <span class="hljs-string">"zod"</span>;

<span class="hljs-comment">/**
 * 批量创建 MCP 服务并返回 handlers 映射
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createMcpServices</span>(<span class="hljs-params"/>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">number</span>, <span class="hljs-title class_">McpHandlers</span>&gt;&gt; {
  <span class="hljs-keyword">const</span> databaseClient = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getDatabaseClient</span>();
  <span class="hljs-comment">// 从数据库加载所有配置（包含关联的工具）</span>
  <span class="hljs-keyword">const</span> allConfigsWithTools = <span class="hljs-keyword">await</span> databaseClient.<span class="hljs-title function_">getAllConfigsWithTools</span>();

  <span class="hljs-keyword">const</span> handlersMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">number</span>, <span class="hljs-title class_">McpHandlers</span>&gt;();

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> config <span class="hljs-keyword">of</span> allConfigsWithTools) {
    <span class="hljs-comment">// 只创建状态为 RUNNING 的服务</span>
    <span class="hljs-keyword">if</span> (config.<span class="hljs-property">status</span> !== <span class="hljs-title class_">StatusEnum</span>.<span class="hljs-property">RUNNING</span>) {
      <span class="hljs-keyword">continue</span>;
    }

    <span class="hljs-comment">// 创建 MCP 服务器实例</span>
    <span class="hljs-keyword">const</span> server = <span class="hljs-keyword">new</span> <span class="hljs-title class_">McpServer</span>({
      <span class="hljs-attr">name</span>: config.<span class="hljs-property">name</span>,
      <span class="hljs-attr">version</span>: config.<span class="hljs-property">version</span>,
      <span class="hljs-attr">description</span>: config.<span class="hljs-property">description</span>,
    });

    <span class="hljs-comment">// 批量注册工具</span>
    config.<span class="hljs-property">tools</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">tool</span>) =&gt;</span> {
      <span class="hljs-comment">// 解析 JSON Schema 并转换为 Zod schema</span>
      <span class="hljs-keyword">const</span> inputSchemaObj = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(tool.<span class="hljs-property">input_schema</span>);
      <span class="hljs-keyword">const</span> outputSchemaObj = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(tool.<span class="hljs-property">output_schema</span>);
      <span class="hljs-keyword">const</span> inputSchema = <span class="hljs-title function_">jsonSchemaToZod</span>(inputSchemaObj);
      <span class="hljs-keyword">const</span> outputSchema = <span class="hljs-title function_">jsonSchemaToZod</span>(outputSchemaObj);

      <span class="hljs-comment">// 注册工具</span>
      server.<span class="hljs-title function_">registerTool</span>(
        tool.<span class="hljs-property">name</span>,
        {
          <span class="hljs-attr">description</span>: tool.<span class="hljs-property">description</span>,
          inputSchema,
          outputSchema,
        },
        <span class="hljs-keyword">async</span> ({ input }) =&gt; {
          <span class="hljs-comment">// 执行工具回调逻辑</span>
          <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 实现实际的工具回调</span>
          <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">content</span>: [
              { <span class="hljs-attr">type</span>: <span class="hljs-string">"text"</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">`测试: <span class="hljs-subst">${<span class="hljs-built_in">JSON</span>.stringify(input)}</span>`</span> },
            ],
          };
        },
      );
    });

    <span class="hljs-comment">// 创建 SSE handlers</span>
    <span class="hljs-keyword">const</span> handlers = <span class="hljs-title function_">sseHandlers</span>(<span class="hljs-function">() =&gt;</span> server, {
      <span class="hljs-attr">onError</span>: <span class="hljs-function">(<span class="hljs-params">error: <span class="hljs-built_in">Error</span>, sessionId?: <span class="hljs-built_in">string</span></span>) =&gt;</span> {
        consola.<span class="hljs-title function_">error</span>(<span class="hljs-string">`[SSE][<span class="hljs-subst">${config.name}</span>] 错误:`</span>, error);
      },
    });

    <span class="hljs-comment">// 使用配置ID作为key存储handlers</span>
    handlersMap.<span class="hljs-title function_">set</span>(config.<span class="hljs-property">id</span>!, handlers);
  }

  <span class="hljs-keyword">return</span> handlersMap;
}
</code></pre>
<p><strong>代码解析</strong>：</p>
<ul>
<li>使用 <code>Map&lt;number, McpHandlers&gt;</code> 存储服务ID到handlers的映射关系</li>
<li>从数据库动态加载配置，支持运行时更新</li>
<li>只创建状态为 <code>RUNNING</code> 的服务，实现服务的启停控制</li>
<li>使用 <code>express-mcp-handler</code> 库创建 SSE handlers，简化 MCP 协议处理</li>
</ul>
<h4 data-id="heading-18">模块2：路由分发机制</h4>
<p><strong>实现目标</strong>：根据 <code>MCP_ID</code> header 从内存映射表中获取对应的 handlers 并处理请求。</p>
<p><strong>核心代码</strong>（<code>packages/honeycomb-server/src/mcp.ts</code>）：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">/**
 * 创建路由处理器（根据 MCP_ID 选择对应的 handler）
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createMcpRouteHandler</span>(<span class="hljs-params">
  handlersMap: <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">number</span>, McpHandlers&gt;,
  handlerType: <span class="hljs-string">"get"</span> | <span class="hljs-string">"post"</span>,
</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">
    req: express.Request,
    res: express.Response,
    next: express.NextFunction,
  </span>) =&gt;</span> {
    <span class="hljs-comment">// 解析 MCP_ID</span>
    <span class="hljs-keyword">const</span> mcpIdHeader = req.<span class="hljs-property">headers</span>.<span class="hljs-property">mcp_id</span> || req.<span class="hljs-property">headers</span>.<span class="hljs-property">MCP_ID</span>;
    <span class="hljs-keyword">const</span> mcpId = mcpIdHeader 
      ? <span class="hljs-built_in">parseInt</span>(<span class="hljs-keyword">typeof</span> mcpIdHeader === <span class="hljs-string">"string"</span> ? mcpIdHeader : mcpIdHeader[<span class="hljs-number">0</span>], <span class="hljs-number">10</span>)
      : <span class="hljs-literal">null</span>;

    <span class="hljs-keyword">if</span> (mcpId === <span class="hljs-literal">null</span> || <span class="hljs-title class_">Number</span>.<span class="hljs-built_in">isNaN</span>(mcpId)) {
      res.<span class="hljs-title function_">status</span>(<span class="hljs-number">400</span>).<span class="hljs-title function_">json</span>({
        <span class="hljs-attr">error</span>: <span class="hljs-string">"缺少或无效的 MCP_ID header 参数"</span>,
        <span class="hljs-attr">message</span>: <span class="hljs-string">"请在请求 Header 中添加 MCP_ID 或 mcp_id 参数（数字类型）"</span>,
      });
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-comment">// 从映射表中获取对应的 handlers</span>
    <span class="hljs-keyword">const</span> handlers = handlersMap.<span class="hljs-title function_">get</span>(mcpId);

    <span class="hljs-keyword">if</span> (!handlers) {
      res.<span class="hljs-title function_">status</span>(<span class="hljs-number">404</span>).<span class="hljs-title function_">json</span>({
        <span class="hljs-attr">error</span>: <span class="hljs-string">`未找到 ID 为 <span class="hljs-subst">${mcpId}</span> 的 MCP 配置`</span>,
        <span class="hljs-attr">message</span>: <span class="hljs-string">`请检查 MCP_ID 是否正确，当前可用的 MCP ID: <span class="hljs-subst">${<span class="hljs-built_in">Array</span>.<span class="hljs-keyword">from</span>(handlersMap.keys()).join(<span class="hljs-string">", "</span>)}</span>`</span>,
      });
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-comment">// 调用对应的 handler（GET 或 POST）</span>
    <span class="hljs-keyword">const</span> targetHandler =
      handlerType === <span class="hljs-string">"get"</span> ? handlers.<span class="hljs-property">getHandler</span> : handlers.<span class="hljs-property">postHandler</span>;
    <span class="hljs-title function_">targetHandler</span>(req, res, next);
  };
}
</code></pre>
<p><strong>路由注册</strong>（<code>packages/honeycomb-server/src/app.ts</code>）：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 注册 SSE 端点</span>
app.<span class="hljs-title function_">get</span>(<span class="hljs-string">"/sse"</span>, <span class="hljs-title function_">createMcpRouteHandler</span>(mcpHandlersMap, <span class="hljs-string">"get"</span>));
app.<span class="hljs-title function_">post</span>(<span class="hljs-string">"/messages"</span>, <span class="hljs-title function_">createMcpRouteHandler</span>(mcpHandlersMap, <span class="hljs-string">"post"</span>));
</code></pre>
<p><strong>代码解析</strong>：</p>
<ul>
<li>通过中间件函数实现路由分发，支持 GET 和 POST 两种请求方式</li>
<li>从请求 Header 中解析 <code>MCP_ID</code>，支持大小写不敏感</li>
<li>提供详细的错误提示，包括当前可用的 MCP ID 列表</li>
<li>使用函数式编程，返回 Express 中间件函数</li>
</ul>
<h4 data-id="heading-19">模块3：配置管理与服务刷新</h4>
<p><strong>实现目标</strong>：提供 REST API 管理 MCP 配置，支持动态刷新服务。</p>
<p><strong>核心代码</strong>（<code>packages/honeycomb-server/src/routes/configs.ts</code>）：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">/**
 * POST /api/config/:id/start - 启动服务
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">startConfigHandler</span>(<span class="hljs-params">
  req: express.Request,
  res: express.Response,
  handlersMap: <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">number</span>, McpHandlers&gt;,
</span>) {
  <span class="hljs-keyword">const</span> id = <span class="hljs-title function_">validateIdParam</span>(req);
  <span class="hljs-keyword">const</span> databaseClient = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getDatabaseClient</span>();

  <span class="hljs-comment">// 更新数据库状态为 RUNNING</span>
  <span class="hljs-keyword">await</span> databaseClient.<span class="hljs-title function_">updateConfig</span>(id, {
    <span class="hljs-attr">status</span>: <span class="hljs-title class_">StatusEnum</span>.<span class="hljs-property">RUNNING</span>,
    <span class="hljs-attr">last_modified</span>: <span class="hljs-title function_">getCurrentTimeString</span>(),
  });
  <span class="hljs-keyword">await</span> databaseClient.<span class="hljs-title function_">save</span>();

  <span class="hljs-comment">// 刷新 MCP 服务（重新加载所有配置）</span>
  <span class="hljs-keyword">await</span> <span class="hljs-title function_">refreshMcpServices</span>(handlersMap);

  <span class="hljs-keyword">const</span> updatedConfig = <span class="hljs-keyword">await</span> databaseClient.<span class="hljs-title function_">getConfigWithTools</span>(id);
  res.<span class="hljs-title function_">json</span>(<span class="hljs-title function_">createSuccessResponse</span>(<span class="hljs-title function_">dbToVO</span>(updatedConfig)));
}

<span class="hljs-comment">/**
 * 刷新 MCP 服务（重新加载所有配置）
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">refreshMcpServices</span>(<span class="hljs-params">
  handlersMap: <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">number</span>, McpHandlers&gt;,
</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; {
  <span class="hljs-comment">// 清空现有映射</span>
  handlersMap.<span class="hljs-title function_">clear</span>();
  
  <span class="hljs-comment">// 重新创建所有服务</span>
  <span class="hljs-keyword">const</span> newHandlersMap = <span class="hljs-keyword">await</span> <span class="hljs-title function_">createMcpServices</span>();
  
  <span class="hljs-comment">// 更新映射表</span>
  newHandlersMap.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">handlers, id</span>) =&gt;</span> {
    handlersMap.<span class="hljs-title function_">set</span>(id, handlers);
  });
}
</code></pre>
<p><strong>代码解析</strong>：</p>
<ul>
<li>通过 REST API 提供配置的 CRUD 操作</li>
<li>启动/停止服务时更新数据库状态并刷新内存映射表</li>
<li><code>refreshMcpServices</code> 函数实现服务的热更新，无需重启进程</li>
<li>使用 SQL.js 作为轻量级数据库，无需额外数据库服务</li>
</ul>
<h4 data-id="heading-20">模块4：JSON Schema 到 Zod 转换</h4>
<p><strong>实现目标</strong>：将数据库中存储的 JSON Schema 转换为 Zod schema，用于 MCP 工具的参数校验。</p>
<p><strong>核心代码</strong>：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">/**
 * 将 JSON Schema 转换为 Zod schema
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">jsonSchemaToZod</span>(<span class="hljs-params">schemaObj: Record&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">any</span>&gt;</span>): z.<span class="hljs-property">ZodObject</span>&lt;<span class="hljs-built_in">any</span>&gt; {
  <span class="hljs-keyword">const</span> <span class="hljs-attr">shape</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, z.<span class="hljs-property">ZodTypeAny</span>&gt; = {};

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, value] <span class="hljs-keyword">of</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(schemaObj)) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">"object"</span> &amp;&amp; value !== <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">const</span> fieldSchema = value <span class="hljs-keyword">as</span> { <span class="hljs-keyword">type</span>?: <span class="hljs-built_in">string</span>; description?: <span class="hljs-built_in">string</span> };
      <span class="hljs-keyword">let</span> <span class="hljs-attr">zodType</span>: z.<span class="hljs-property">ZodTypeAny</span>;

      <span class="hljs-comment">// 根据 JSON Schema 的 type 创建对应的 Zod 类型</span>
      <span class="hljs-keyword">switch</span> (fieldSchema.<span class="hljs-property">type</span>) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">"string"</span>:
          zodType = z.<span class="hljs-title function_">string</span>();
          <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-string">"number"</span>:
          zodType = z.<span class="hljs-title function_">number</span>();
          <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-string">"integer"</span>:
          zodType = z.<span class="hljs-title function_">number</span>().<span class="hljs-title function_">int</span>();
          <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-string">"boolean"</span>:
          zodType = z.<span class="hljs-title function_">boolean</span>();
          <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-string">"array"</span>:
          zodType = z.<span class="hljs-title function_">array</span>(z.<span class="hljs-title function_">any</span>());
          <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-string">"object"</span>:
          zodType = z.<span class="hljs-title function_">object</span>({});
          <span class="hljs-keyword">break</span>;
        <span class="hljs-attr">default</span>:
          zodType = z.<span class="hljs-title function_">any</span>();
      }

      <span class="hljs-comment">// 如果有 description，添加描述</span>
      <span class="hljs-keyword">if</span> (fieldSchema.<span class="hljs-property">description</span>) {
        zodType = zodType.<span class="hljs-title function_">describe</span>(fieldSchema.<span class="hljs-property">description</span>);
      }

      shape[key] = zodType;
    } <span class="hljs-keyword">else</span> {
      shape[key] = z.<span class="hljs-title function_">any</span>();
    }
  }

  <span class="hljs-keyword">return</span> z.<span class="hljs-title function_">object</span>(shape);
}
</code></pre>
<p><strong>代码解析</strong>：</p>
<ul>
<li>支持常见的 JSON Schema 类型到 Zod 类型的转换</li>
<li>保留字段描述信息，提升 API 文档质量</li>
<li>对于不支持的类型，使用 <code>z.any()</code> 作为兜底</li>
</ul>
<h3 data-id="heading-21">4.4 常见问题&amp;踩坑指南</h3>
<p><strong>问题1：MCP_ID 未找到</strong></p>
<p><strong>现象</strong>：返回 404 错误，提示未找到对应的 MCP 配置</p>
<p><strong>原因</strong>：</p>
<ul>
<li>服务未启动（状态不是 RUNNING）</li>
<li>MCP_ID 输入错误</li>
<li>服务被删除但客户端仍在使用旧ID</li>
</ul>
<p><strong>解决方案</strong>：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 通过 API 查询所有可用的服务</span>
curl http://localhost:3002/api/configs

<span class="hljs-comment"># 检查服务状态</span>
<span class="hljs-comment"># 确保服务状态为 "running"</span>
</code></pre>
<p><strong>问题2：服务刷新后连接断开</strong></p>
<p><strong>现象</strong>：调用刷新 API 后，现有的 SSE 连接断开</p>
<p><strong>原因</strong>：<code>refreshMcpServices</code> 会清空并重建所有服务实例，导致现有连接失效</p>
<p><strong>解决方案</strong>：</p>
<ul>
<li>这是预期行为，客户端需要重新建立连接</li>
<li>可以在刷新前通知客户端，或实现连接迁移机制</li>
</ul>
<p><strong>问题3：数据库文件权限问题</strong></p>
<p><strong>现象</strong>：SQL.js 数据库文件无法写入</p>
<p><strong>原因</strong>：文件权限不足或文件被锁定</p>
<p><strong>解决方案</strong>：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 检查文件权限</span>
<span class="hljs-built_in">ls</span> -l mcp.db

<span class="hljs-comment"># 修改文件权限</span>
<span class="hljs-built_in">chmod</span> 644 mcp.db
</code></pre>
<hr/>
<h2 data-id="heading-22">五、两种方案对比分析</h2>
<h3 data-id="heading-23">5.1 架构对比</h3>



































<table><thead><tr><th>维度</th><th>方案1：Nginx反向代理</th><th>方案2：Express统一服务</th></tr></thead><tbody><tr><td><strong>服务隔离</strong></td><td>物理隔离（独立端口、独立进程）</td><td>逻辑隔离（同一进程、内存映射）</td></tr><tr><td><strong>资源消耗</strong></td><td>较高（多进程）</td><td>较低（单进程）</td></tr><tr><td><strong>扩展性</strong></td><td>需要修改配置并重启</td><td>支持热更新，无需重启</td></tr><tr><td><strong>配置管理</strong></td><td>静态文件（config.json）</td><td>动态数据库（SQL.js）</td></tr><tr><td><strong>运维复杂度</strong></td><td>中等（需要管理Nginx和多个服务）</td><td>较低（单一服务）</td></tr></tbody></table>
<h3 data-id="heading-24">5.2 性能对比</h3>
<p><strong>方案1优势</strong>：</p>
<ul>
<li>服务之间完全隔离，单个服务崩溃不影响其他服务</li>
<li>Nginx 作为成熟的反向代理，性能稳定可靠</li>
<li>可以针对不同服务进行独立的性能调优</li>
</ul>
<p><strong>方案2优势</strong>：</p>
<ul>
<li>单进程架构，内存占用更少</li>
<li>无需经过 Nginx 转发，减少网络跳数</li>
<li>服务创建和销毁更快（内存操作 vs 进程管理）</li>
</ul>
<h3 data-id="heading-25">5.3 适用场景</h3>
<p><strong>方案1适用于</strong>：</p>
<ul>
<li>需要严格服务隔离的场景</li>
<li>已有 Nginx 基础设施的项目</li>
<li>服务数量相对固定，不频繁变更</li>
<li>需要独立监控和日志的场景</li>
</ul>
<p><strong>方案2适用于</strong>：</p>
<ul>
<li>需要动态管理服务的场景</li>
<li>资源受限的环境（如边缘计算）</li>
<li>需要可视化配置管理的场景</li>
<li>快速迭代和开发测试环境</li>
</ul>
<h3 data-id="heading-26">5.4 技术选型建议</h3>
<p><strong>选择方案1，如果</strong>：</p>
<ul>
<li>✅ 你的团队熟悉 Nginx 配置</li>
<li>✅ 需要生产级的高可用性</li>
<li>✅ 服务数量较少且相对稳定</li>
<li>✅ 需要独立的服务监控和日志</li>
</ul>
<p><strong>选择方案2，如果</strong>：</p>
<ul>
<li>✅ 需要频繁添加/删除服务</li>
<li>✅ 希望提供用户友好的配置界面</li>
<li>✅ 资源受限，需要优化内存使用</li>
<li>✅ 快速开发和迭代</li>
</ul>
<hr/>
<h2 data-id="heading-27">六、进阶优化&amp;扩展场景</h2>
<h3 data-id="heading-28">6.1 性能优化方向</h3>
<p><strong>方案1优化</strong>：</p>
<ul>
<li><strong>连接池管理</strong>：配置 Nginx upstream 连接池，复用后端连接</li>
<li><strong>负载均衡</strong>：为同一服务配置多个后端实例，实现负载均衡</li>
<li><strong>缓存策略</strong>：对静态资源或频繁查询的结果进行缓存</li>
</ul>
<p><strong>方案2优化</strong>：</p>
<ul>
<li><strong>懒加载服务</strong>：按需创建服务实例，减少启动时间</li>
<li><strong>服务预热</strong>：在服务启动时预加载常用服务</li>
<li><strong>连接复用</strong>：实现 SSE 连接池，减少连接建立开销</li>
</ul>
<h3 data-id="heading-29">6.2 扩展应用场景</h3>
<p><strong>场景1：服务版本管理</strong></p>
<ul>
<li>支持同一服务的多个版本并存</li>
<li>通过 Header 参数（如 <code>MCP-Version</code>）选择版本</li>
<li>实现灰度发布和版本回滚</li>
</ul>
<p><strong>场景2：服务监控和告警</strong></p>
<ul>
<li>集成 Prometheus 监控指标</li>
<li>实现服务健康检查接口</li>
<li>配置告警规则（如服务响应时间、错误率）</li>
</ul>
<p><strong>场景3：多租户支持</strong></p>
<ul>
<li>为不同租户隔离服务实例和配置</li>
<li>通过租户ID（Tenant ID）进行路由</li>
<li>实现资源配额和限流</li>
</ul>
<h3 data-id="heading-30">6.3 生产环境注意事项</h3>
<p><strong>安全性</strong>：</p>
<ul>
<li>实现请求认证和授权（如 JWT Token）</li>
<li>对 Header 参数进行校验和过滤，防止注入攻击</li>
<li>配置 HTTPS，加密传输数据</li>
</ul>
<p><strong>高可用性</strong>：</p>
<ul>
<li>实现服务健康检查，自动剔除异常服务</li>
<li>配置服务重启策略和故障恢复机制</li>
<li>实现配置备份和恢复</li>
</ul>
<p><strong>可观测性</strong>：</p>
<ul>
<li>集成结构化日志（如 Winston、Pino）</li>
<li>实现分布式追踪（如 OpenTelemetry）</li>
<li>配置告警和通知机制</li>
</ul>
<hr/>
<h2 data-id="heading-31">七、总结与展望</h2>
<h3 data-id="heading-32">7.1 核心内容总结</h3>
<p>本文深入对比了两种单实例多MCP聚合服务的实现方案：</p>
<ol>
<li>
<p><strong>方案1（Nginx反向代理）</strong>：采用物理隔离的方式，每个 MCP 服务运行在独立端口，通过 Nginx 反向代理统一对外提供服务。适合需要严格服务隔离、服务数量相对固定的场景。</p>
</li>
<li>
<p><strong>方案2（Express统一服务）</strong>：采用逻辑隔离的方式，所有 MCP 服务运行在同一进程，通过内存映射表管理，支持动态创建和销毁。适合需要频繁变更服务、资源受限的场景。</p>
</li>
</ol>
<p>两种方案各有优劣，开发者应根据实际业务需求、团队技术栈和运维能力进行选择。</p>
<h3 data-id="heading-33">7.2 技术局限性</h3>
<p><strong>方案1局限性</strong>：</p>
<ul>
<li>需要额外的 Nginx 组件，增加系统复杂度</li>
<li>服务数量受端口数量限制（理论上最多65535个）</li>
<li>配置变更需要重启服务，不够灵活</li>
</ul>
<p><strong>方案2局限性</strong>：</p>
<ul>
<li>单进程架构，单个服务崩溃可能影响整体稳定性</li>
<li>内存映射表需要手动管理，容易出现内存泄漏</li>
<li>SQL.js 数据库不适合高并发写入场景</li>
</ul>
<h3 data-id="heading-34">7.3 未来探索方向</h3>
<ol>
<li>
<p><strong>混合方案</strong>：结合两种方案的优点，实现分层的服务管理（如按服务类型分组，组内使用方案2，组间使用方案1）</p>
</li>
<li>
<p><strong>服务网格集成</strong>：将 MCP 服务接入 Istio 等服务网格，实现更强大的流量管理、安全策略和可观测性</p>
</li>
<li>
<p><strong>云原生部署</strong>：支持 Kubernetes 部署，实现自动扩缩容、服务发现和配置管理</p>
</li>
<li>
<p><strong>协议扩展</strong>：支持更多 MCP 传输方式（如 WebSocket、gRPC），提升性能和灵活性</p>
</li>
<li>
<p><strong>工具市场</strong>：构建 MCP 工具市场，支持工具的发布、分享和版本管理</p>
</li>
</ol>
<hr/>
<h2 data-id="heading-35">八、参考资料</h2>
<ol>
<li>
<p><strong>MCP 协议官方文档</strong></p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fmodelcontextprotocol.io%2F" target="_blank" title="https://modelcontextprotocol.io/" ref="nofollow noopener noreferrer">Model Context Protocol Specification</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmodelcontextprotocol%2Ftypescript-sdk" target="_blank" title="https://github.com/modelcontextprotocol/typescript-sdk" ref="nofollow noopener noreferrer">MCP SDK for TypeScript</a></li>
</ul>
</li>
<li>
<p><strong>技术文档</strong></p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fjlowin%2Ffastmcp" target="_blank" title="https://github.com/jlowin/fastmcp" ref="nofollow noopener noreferrer">FastMCP 框架文档</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fexpressjs.com%2F" target="_blank" title="https://expressjs.com/" ref="nofollow noopener noreferrer">Express 官方文档</a></li>
<li><a href="https://link.juejin.cn?target=http%3A%2F%2Fnginx.org%2Fen%2Fdocs%2Fhttp%2Fngx_http_proxy_module.html" target="_blank" title="http://nginx.org/en/docs/http/ngx_http_proxy_module.html" ref="nofollow noopener noreferrer">Nginx 反向代理配置指南</a></li>
</ul>
</li>
<li>
<p><strong>相关项目</strong></p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fbetterhyq%2Fhoneycomb" target="_blank" title="https://github.com/betterhyq/honeycomb" ref="nofollow noopener noreferrer">Honeycomb 项目源码</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmodelcontextprotocol%2Ftypescript-sdk%2Ftree%2Fmain%2Fpackages%2Fexpress-mcp-handler" target="_blank" title="https://github.com/modelcontextprotocol/typescript-sdk/tree/main/packages/express-mcp-handler" ref="nofollow noopener noreferrer">express-mcp-handler</a></li>
</ul>
</li>
<li>
<p><strong>SSE 协议</strong></p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FServer-sent_events" target="_blank" title="https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events" ref="nofollow noopener noreferrer">Server-Sent Events 规范</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.html5rocks.com%2Fen%2Ftutorials%2Feventsource%2Fbasics%2F" target="_blank" title="https://www.html5rocks.com/en/tutorials/eventsource/basics/" ref="nofollow noopener noreferrer">SSE 最佳实践</a></li>
</ul>
</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[开源版 Cowork 爆火，逼得 Anthropic 下放 Cowork]]></title>    <link>https://juejin.cn/post/7596709272976261166</link>    <guid>https://juejin.cn/post/7596709272976261166</guid>    <pubDate>2026-01-19T10:12:19.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7596709272976261166" data-draft-id="7596698363964375078" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="开源版 Cowork 爆火，逼得 Anthropic 下放 Cowork"/> <meta itemprop="keywords" content="人工智能"/> <meta itemprop="datePublished" content="2026-01-19T10:12:19.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="新智元"/> <meta itemprop="url" content="https://juejin.cn/user/952600743642312"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            开源版 Cowork 爆火，逼得 Anthropic 下放 Cowork
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/952600743642312/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    新智元
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-19T10:12:19.000Z" title="Mon Jan 19 2026 10:12:19 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f15c68532bd04d1da956261cca4da345~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5paw5pm65YWD:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769422339&amp;x-signature=4wfkQFmce9Rk5K5dDV5jO1zhz%2Fs%3D" alt="" loading="lazy"/></p>
<h5 data-id="heading-0"><strong>「【新智元导读】仅用两天开发出的开源项目 Openwork，如何逼迫 AI 巨头 Anthropic 低头？面对免费、更快、更安全的开源竞品，Anthropic 紧急将原本 <img src="" alt="" loading="lazy"/>20 档位。这场「官方逼死同人」的反向剧本，揭示了 AI 智能体时代的定价权，正在从巨头手中滑落。」</strong></h5>
<p>2026 年 1 月，硅谷发生了一场没有硝烟的定价权战争。</p>
<p>战场的两端，一方是估值 1830 亿美元、拥有顶尖算力的 AI 巨头 Anthropic，另一方是 GitHub 上一个名为 Openwork 的开源项目，由几名开发者在两天黑客松（编程马拉松，Hackathon）中拼凑而成。</p>
<p>以前你问 AI：「怎么整理这些发票？」它会给你列个步骤一二三。</p>
<p>Cowork 的逻辑是：「把这些发票整理好。」</p>
<p>然后它会自己扫描文件夹，识别文件名，提取金额，创建一个 Excel，填入数据，最后发给你确认。</p>
<p>它在行动，而非单纯对话。</p>
<p>这种「甚至不需要你动脑子」的能力，曾是 Anthropic 划分用户阶层的金线。</p>
<p>Max 用户付出的 100 美元，是「数字员工」的工资。</p>
<p>Openwork 的出现，让这笔工资显得滑稽。</p>
<p>既然开源代码能让用户零成本拥有一个「数字员工」，Anthropic 就无法再以稀缺性为由索要高价。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/37033e2bbd2a420c885e7edad1e8d244~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5paw5pm65YWD:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769422339&amp;x-signature=C0n5o1MRQ6oESh%2Fzyew0C5i85Yc%3D" alt="" loading="lazy"/></p>
<p><strong>「只有降低门槛」</strong></p>
<p><strong>「才能保住入口」</strong></p>
<p>Anthropic 的反应迅速且决绝。</p>
<p>将 Cowork 下放给 20 美元的 Pro 用户，看似损失了 Max 用户的溢价，实则是为了保住更珍贵的资产：桌面入口。</p>
<p>如果任由 Openwork 发展，极客和开发者会迅速倒向开源生态。在 Openwork 的框架下，Anthropic 只是众多模型供应商中的一个选项。</p>
<p>用户今天可以用 Claude，明天就可以换成 GPT-5 或者 DeepSeek。这种「管道化」的危机，是任何平台型公司都无法接受的。</p>
<p>20 美元是一个精妙的定价。</p>
<p>它击穿了普通用户的心理防线。</p>
<p>对于大多数非技术人员，去 GitHub 下载源码、配置环境、申请 API Key 依然是一件麻烦事。</p>
<p>Anthropic 赌的是，为了省去这些折腾，用户愿意支付 20 美元买一个「开箱即用」的官方服务。</p>
<p>这是一场用「便利性」对抗「自由度」的博弈。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b717df5bf6144d19b6726efda0b75172~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5paw5pm65YWD:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769422339&amp;x-signature=vcTtGevqTQEONyDgOWPomtewlm8%3D" alt="" loading="lazy"/></p>
<p><strong>「技术平权的加速」</strong></p>
<p>2026 年初的这一幕，可能将作为 AI 落地史上的经典案例被反复提及。</p>
<p>它证明了在智能体时代，应用层的护城河比想象中更浅。</p>
<p>只要底层模型的 API 是开放的，任何昂贵的闭源应用，都会在极短时间内迎来开源社区的降维打击。</p>
<p>Openwork 就像一条鲶鱼，搅动了原本沉闷的定价体系。</p>
<p>它不仅迫使巨头低头，更加速了 AI 智能体从「高科技展示品」向「日用工具」的转化。</p>
<p>对于用户而言，无论选择开源的 Openwork 还是降价后的 Cowork，都是赢家。</p>
<p>当技术试图通过高价自我神化时，代码总会找到回归大众的路径。</p>
<p>参考资料：</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.accomplish.ai%2Fopenwork%2F" target="_blank" title="https://www.accomplish.ai/openwork/" ref="nofollow noopener noreferrer">www.accomplish.ai/openwork/</a></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Rust实用工具特型-Copy]]></title>    <link>https://juejin.cn/post/7596684490660872226</link>    <guid>https://juejin.cn/post/7596684490660872226</guid>    <pubDate>2026-01-19T08:19:52.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7596684490660872226" data-draft-id="7596342451349913640" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Rust实用工具特型-Copy"/> <meta itemprop="keywords" content="Rust"/> <meta itemprop="datePublished" content="2026-01-19T08:19:52.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="噗噜噗噜啪"/> <meta itemprop="url" content="https://juejin.cn/user/4037062427148462"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Rust实用工具特型-Copy
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4037062427148462/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    噗噜噗噜啪
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-19T08:19:52.000Z" title="Mon Jan 19 2026 08:19:52 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    2
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{color:#595959;font-size:15px;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(60,10,30,.04) 3%,transparent 0),linear-gradient(1turn,rgba(60,10,30,.04) 3%,transparent 0);background-size:20px 20px;background-position:50%}.markdown-body p{color:#595959;font-size:15px;line-height:2;font-weight:400}.markdown-body p+p{margin-top:16px}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{padding:30px 0;margin:0;color:#135ce0}.markdown-body h1{position:relative;text-align:center;font-size:22px;margin:50px 0}.markdown-body h1:before{position:absolute;content:"";top:-10px;left:50%;width:32px;height:32px;transform:translateX(-50%);background-size:100% 100%;opacity:.36;background-repeat:no-repeat;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABfVBMVEX///8Ad/8AgP8AgP8AgP8Aff8AgP8Af/8AgP8AVf8Af/8Af/8AgP8AgP8Af/8Afv8AAP8Afv8Afv8Aef8AgP8AdP8Afv8AgP8AgP8Acf8Ae/8AgP8Af/8AgP8Af/8Af/8AfP8Afv8AgP8Af/8Af/8Afv8Afv8AgP8Afv8AgP8Af/8Af/8AgP8AgP8Afv8AgP8Af/8AgP8AgP8AgP8Ae/8Afv8Af/8AgP8Af/8AgP8Af/8Af/8Aff8Af/8Abf8AgP8Af/8AgP8Af/8Af/8Afv8AgP8AgP8Afv8Afv8AgP8Af/8Aff8AgP8Afv8AgP8Aff8AgP8AfP8AgP8Ae/8AgP8Af/8AgP8AgP8AgP8Afv8AgP8AgP8AgP8Afv8AgP8AgP8AgP8AgP8AgP8Af/8AgP8Af/8Af/8Aev8Af/8AgP8Aff8Afv8AgP8AgP8AgP8Af/8AgP8Af/8Af/8AgP8Afv8AgP8AgP8AgP8AgP8Af/8AeP8Af/8Af/8Af//////rzEHnAAAAfXRSTlMAD7CCAivatxIDx5EMrP19AXdLEwgLR+6iCR/M0yLRzyFF7JupSXn8cw6v60Q0QeqzKtgeG237HMne850/6Qeq7QaZ+WdydHtj+OM3qENCMRYl1B3K2U7wnlWE/mhlirjkODa9FN/BF7/iNV/2kASNZpX1Wlf03C4stRGxgUPclqoAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEaBzgZ4yeM3AAAAT9JREFUOMvNUldbwkAQvCAqsSBoABE7asSOBRUVVBQNNuy9996789+9cMFAMHnVebmdm+/bmdtbQv4dOFOW2UjPzgFyLfo6nweKfIMOBYWwFtmMPGz2Yj2pJI0JDq3udJW6VVbmKa9I192VQFV1ktXUAl5NB0cd4KpnORqsEO2ZIRpF9gJfE9Dckqq0KuZt7UAH5+8EPF3spjsRpCeQNO/tA/qDwIDA+OCQbBoKA8NOdjMySgcZGVM6jwcgRuUiSs0nlPFNSrEpJfU0jTLD6llqbvKxei7OzvkFNQohi0vAsj81+MoqsCaoPOQFgus/1LyxichW+hS2JWCHZ7VlF9jb187pIAYcHiViHAMnp5mTjJ8B5xeEXF4B1ze/fTh/C0h398DDI9HB07O8ci+vRBdvdGnfP4gBuM8vw7X/G3wDmFhFZEdxzjMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDEtMjZUMDc6NTY6MjUrMDE6MDA67pVWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAxLTI2VDA3OjU2OjI1KzAxOjAwS7Mt6gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAWdEVYdFRpdGxlAGp1ZWppbl9sb2dvIGNvcHlxapmKAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC)}.markdown-body h2{position:relative;font-size:20px;border-left:4px solid;padding:0 0 0 10px;margin:30px 0}.markdown-body h3{font-size:16px}.markdown-body ul{list-style:disc outside;margin-left:2em;margin-top:1em}.markdown-body li{line-height:2;color:#595959}.markdown-body img.loaded{margin:0 auto;display:block}.markdown-body blockquote{background:#fff9f9;margin:2em 0;padding:2px 20px;border-left:4px solid #b2aec5}.markdown-body blockquote p{color:#666;line-height:2}.markdown-body a{color:#036aca;border-bottom:1px solid rgba(3,106,202,.8);font-weight:400;text-decoration:none}.markdown-body em strong,.markdown-body strong{color:#036aca}.markdown-body hr{border-top:1px solid #135ce0}.markdown-body pre{overflow:auto}.markdown-body code,.markdown-body pre{overflow:auto;position:relative;line-height:1.75;font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body table{border-collapse:collapse;margin:1rem 0;overflow-x:auto}.markdown-body table td,.markdown-body table th{border:1px solid #dfe2e5;padding:.6em 1em}.markdown-body table tr{border-top:1px solid #dfe2e5}.markdown-body table tr:nth-child(2n){background-color:#f6f8fa}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><code>Copy</code> trait 让简单类型在赋值或传参时自动复制，不转移所有权。</p>
<p>它特殊在哪？不需要你写任何代码，就是个「标记」，告诉编译器「这玩意儿可以按位复制」。</p>
<h2 data-id="heading-0">核心概念</h2>
<p>默认情况下，Rust 的赋值会转移所有权：</p>
<pre><code class="hljs language-ini" lang="ini">let <span class="hljs-attr">s1</span> = String::from(<span class="hljs-string">"hello"</span>)<span class="hljs-comment">;</span>
let <span class="hljs-attr">s2</span> = s1<span class="hljs-comment">;  // s1 的所有权转移给 s2</span>
// println!("{}", s1)<span class="hljs-comment">;  // 错误！s1 已失效</span>
</code></pre>
<p>但对于简单类型，这样太麻烦了：</p>
<pre><code class="hljs language-ini" lang="ini">let <span class="hljs-attr">x</span> = <span class="hljs-number">5</span><span class="hljs-comment">;</span>
let <span class="hljs-attr">y</span> = x<span class="hljs-comment">;  // x 自动复制，还能用</span>
println!("{}", x)<span class="hljs-comment">;  // 没问题</span>
</code></pre>
<p>这就是 <code>Copy</code>：赋值时自动复制，原来的值还在。</p>
<h3 data-id="heading-1">Copy vs Clone</h3>



































<table><thead><tr><th>特性</th><th>Copy</th><th>Clone</th></tr></thead><tbody><tr><td>调用方式</td><td>自动（隐式）</td><td>手动调用 <code>.clone()</code></td></tr><tr><td>成本</td><td>廉价（按位复制）</td><td>可能昂贵（深拷贝）</td></tr><tr><td>适用类型</td><td>简单类型（栈数据）</td><td>任何类型</td></tr><tr><td>trait 类型</td><td>标记 trait（无方法）</td><td>普通 trait（有 <code>clone</code> 方法）</td></tr><tr><td>实现方式</td><td><code>#[derive(Copy, Clone)]</code></td><td><code>#[derive(Clone)]</code> 或手动实现</td></tr></tbody></table>
<h3 data-id="heading-2">Copy trait 定义</h3>
<pre><code class="hljs language-rust" lang="rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Copy</span>: <span class="hljs-built_in">Clone</span> {
    <span class="hljs-comment">// 空的！</span>
}
</code></pre>
<p>两个关键点：</p>
<ul>
<li><strong>Copy 继承自 Clone</strong>：想实现 <code>Copy</code> 必须先实现 <code>Clone</code></li>
<li><strong>没有方法</strong>：编译器看到这个标记就知道可以按位复制了</li>
</ul>
<h2 data-id="heading-3">底层原理</h2>
<h3 data-id="heading-4">按位复制是啥？</h3>
<p>就是把内存里的字节原样复制到新位置，像复印机：</p>
<pre><code class="hljs language-ini" lang="ini">let x: <span class="hljs-attr">i32</span> = <span class="hljs-number">42</span><span class="hljs-comment">;  // 内存：00 00 00 2A（4 字节）</span>
let <span class="hljs-attr">y</span> = x<span class="hljs-comment">;        // 把这 4 个字节复制到新位置</span>
</code></pre>
<p>快得很，一条 CPU 指令搞定。所以 Rust 允许它隐式发生。</p>
<h3 data-id="heading-5">String 为啥不能 Copy？</h3>
<p><code>String</code> 在栈上存指针、长度、容量，真正的数据在堆上：</p>
<pre><code class="hljs language-css" lang="css">栈：<span class="hljs-selector-attr">[ptr | len: 5 | cap: 5]</span>
      ↓
堆：  <span class="hljs-selector-attr">[h]</span><span class="hljs-selector-attr">[e]</span><span class="hljs-selector-attr">[l]</span><span class="hljs-selector-attr">[l]</span><span class="hljs-selector-attr">[o]</span>
</code></pre>
<p>如果按位复制：</p>
<pre><code class="hljs language-rust" lang="rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">s1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">"hello"</span>);
<span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">s2</span> = s1;  <span class="hljs-comment">// 假设能 Copy</span>
<span class="hljs-comment">// 现在 s1 和 s2 的指针都指向同一块堆内存</span>
<span class="hljs-comment">// 离开作用域时，s1 释放内存，s2 也释放</span>
<span class="hljs-comment">// 💥 double free！</span>
</code></pre>
<p>所以 Copy 有个铁律：<strong>按位复制后，原值和新值必须能独立存在</strong>。</p>
<h2 data-id="heading-6">哪些类型能 Copy？</h2>
<h3 data-id="heading-7">能 Copy 的</h3>









































<table><thead><tr><th>类型</th><th>示例</th></tr></thead><tbody><tr><td>所有整数类型</td><td><code>i8</code>, <code>i32</code>, <code>u64</code>, <code>isize</code> 等</td></tr><tr><td>所有浮点类型</td><td><code>f32</code>, <code>f64</code></td></tr><tr><td>布尔类型</td><td><code>bool</code></td></tr><tr><td>字符类型</td><td><code>char</code></td></tr><tr><td>不可变引用</td><td><code>&amp;T</code>（注意：<code>&amp;mut T</code> 不能 Copy）</td></tr><tr><td>元组（所有元素都 Copy）</td><td><code>(i32, bool)</code></td></tr><tr><td>数组（元素类型 Copy）</td><td><code>[i32; 10]</code></td></tr><tr><td>函数指针</td><td><code>fn(i32) -&gt; i32</code></td></tr></tbody></table>
<h3 data-id="heading-8">不能 Copy 的</h3>

































<table><thead><tr><th>类型</th><th>原因</th></tr></thead><tbody><tr><td><code>String</code></td><td>拥有堆内存</td></tr><tr><td><code>Vec&lt;T&gt;</code></td><td>拥有堆内存</td></tr><tr><td><code>Box&lt;T&gt;</code></td><td>拥有堆内存</td></tr><tr><td><code>Rc&lt;T&gt;</code>, <code>Arc&lt;T&gt;</code></td><td>需要管理引用计数</td></tr><tr><td><code>&amp;mut T</code></td><td>可变引用必须唯一</td></tr><tr><td>实现了 <code>Drop</code> 的类型</td><td>需要自定义清理逻辑</td></tr></tbody></table>
<h3 data-id="heading-9">自定义类型咋办？</h3>
<p>所有字段都是 Copy，就能派生：</p>
<pre><code class="hljs language-rust" lang="rust"><span class="hljs-meta">#[derive(Copy, Clone)]</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> {
    x: <span class="hljs-type">i32</span>,
    y: <span class="hljs-type">i32</span>,
}

<span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">p1</span> = Point { x: <span class="hljs-number">1</span>, y: <span class="hljs-number">2</span> };
<span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">p2</span> = p1;  <span class="hljs-comment">// 自动复制</span>
<span class="hljs-built_in">println!</span>(<span class="hljs-string">"{}, {}"</span>, p1.x, p2.x);  <span class="hljs-comment">// 都能用</span>
</code></pre>
<p>记得同时派生 <code>Clone</code>，因为 <code>Copy</code> 继承自它。</p>
<h2 data-id="heading-10">使用场景</h2>
<h3 data-id="heading-11">小型数据结构</h3>
<pre><code class="hljs language-rust" lang="rust"><span class="hljs-comment">// 坐标点：8 字节，适合 Copy</span>
<span class="hljs-meta">#[derive(Copy, Clone)]</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> {
    x: <span class="hljs-type">f32</span>,
    y: <span class="hljs-type">f32</span>,
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">distance</span>(p1: Point, p2: Point) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">f32</span> {
    <span class="hljs-comment">// 按值传递，自动复制</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">dx</span> = p1.x - p2.x;
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">dy</span> = p1.y - p2.y;
    (dx * dx + dy * dy).<span class="hljs-title function_ invoke__">sqrt</span>()
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">origin</span> = Point { x: <span class="hljs-number">0.0</span>, y: <span class="hljs-number">0.0</span> };
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">point</span> = Point { x: <span class="hljs-number">3.0</span>, y: <span class="hljs-number">4.0</span> };
    
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">d</span> = <span class="hljs-title function_ invoke__">distance</span>(origin, point);
    <span class="hljs-comment">// origin 和 point 仍然可用！</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"距离: {}"</span>, d);
}
</code></pre>
<h3 data-id="heading-12">配置参数</h3>
<pre><code class="hljs language-arduino" lang="arduino">#[<span class="hljs-built_in">derive</span>(Copy, Clone)]
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Config</span> {
    width: u32,
    height: u32,
    fullscreen: <span class="hljs-type">bool</span>,
}

<span class="hljs-function">fn <span class="hljs-title">apply_config</span><span class="hljs-params">(config: Config)</span> </span>{
    <span class="hljs-comment">// 按值传递，不需要引用</span>
    println!(<span class="hljs-string">"设置分辨率: {}x{}"</span>, config.width, config.height);
}

<span class="hljs-function">fn <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    let config = Config {
        width: <span class="hljs-number">1920</span>,
        height: <span class="hljs-number">1080</span>,
        fullscreen: <span class="hljs-literal">true</span>,
    };
    
    <span class="hljs-built_in">apply_config</span>(config);  <span class="hljs-comment">// 自动复制</span>
    <span class="hljs-built_in">apply_config</span>(config);  <span class="hljs-comment">// 可以多次使用</span>
}
</code></pre>
<h3 data-id="heading-13">数学运算</h3>
<pre><code class="hljs language-rust" lang="rust"><span class="hljs-meta">#[derive(Copy, Clone)]</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Color</span> {
    r: <span class="hljs-type">u8</span>,
    g: <span class="hljs-type">u8</span>,
    b: <span class="hljs-type">u8</span>,
}

<span class="hljs-keyword">impl</span> <span class="hljs-title class_">Color</span> {
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">blend</span>(<span class="hljs-keyword">self</span>, other: Color) <span class="hljs-punctuation">-&gt;</span> Color {
        <span class="hljs-comment">// 按值接收，自动复制</span>
        Color {
            r: (<span class="hljs-keyword">self</span>.r <span class="hljs-keyword">as</span> <span class="hljs-type">u16</span> + other.r <span class="hljs-keyword">as</span> <span class="hljs-type">u16</span>) <span class="hljs-keyword">as</span> <span class="hljs-type">u8</span> / <span class="hljs-number">2</span>,
            g: (<span class="hljs-keyword">self</span>.g <span class="hljs-keyword">as</span> <span class="hljs-type">u16</span> + other.g <span class="hljs-keyword">as</span> <span class="hljs-type">u16</span>) <span class="hljs-keyword">as</span> <span class="hljs-type">u8</span> / <span class="hljs-number">2</span>,
            b: (<span class="hljs-keyword">self</span>.b <span class="hljs-keyword">as</span> <span class="hljs-type">u16</span> + other.b <span class="hljs-keyword">as</span> <span class="hljs-type">u16</span>) <span class="hljs-keyword">as</span> <span class="hljs-type">u8</span> / <span class="hljs-number">2</span>,
        }
    }
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">red</span> = Color { r: <span class="hljs-number">255</span>, g: <span class="hljs-number">0</span>, b: <span class="hljs-number">0</span> };
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">blue</span> = Color { r: <span class="hljs-number">0</span>, g: <span class="hljs-number">0</span>, b: <span class="hljs-number">255</span> };
    
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">purple</span> = red.<span class="hljs-title function_ invoke__">blend</span>(blue);  <span class="hljs-comment">// red 和 blue 仍然可用</span>
}
</code></pre>
<h2 data-id="heading-14">常见坑</h2>
<h3 data-id="heading-15">小类型不等于能 Copy</h3>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-comment">// 错！就算只有一个字段，String 不是 Copy</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Name</span> {
    value: <span class="hljs-type">String</span>,
}

<span class="hljs-comment">// 编译错误</span>
<span class="hljs-comment">// #[derive(Copy, Clone)]</span>
<span class="hljs-comment">// struct Name { value: String }</span>
</code></pre>
<p>一个字段不是 Copy，整个结构体就不行。</p>
<h3 data-id="heading-16">Copy 和 Drop 不能共存</h3>
<pre><code class="hljs language-rust" lang="rust"><span class="hljs-meta">#[derive(Copy, Clone)]</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Resource</span> {
    id: <span class="hljs-type">i32</span>,
}

<span class="hljs-comment">// 错！Copy 类型不能实现 Drop</span>
<span class="hljs-keyword">impl</span> <span class="hljs-title class_">Drop</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Resource</span> {
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">drop</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) {
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"释放资源 {}"</span>, <span class="hljs-keyword">self</span>.id);
    }
}
</code></pre>
<p>为啥？Copy 类型会被隐式复制多次，有 Drop 的话同一个资源会被释放多次。</p>
<h3 data-id="heading-17">大结构体别 Copy</h3>
<pre><code class="hljs language-rust" lang="rust"><span class="hljs-comment">// 别这么干！1024 字节</span>
<span class="hljs-meta">#[derive(Copy, Clone)]</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">BigData</span> {
    buffer: [<span class="hljs-type">u8</span>; <span class="hljs-number">1024</span>],
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">process</span>(data: BigData) {
    <span class="hljs-comment">// 每次调用复制 1024 字节</span>
}
</code></pre>
<p>超过 16-32 字节的，用引用。</p>
<h3 data-id="heading-18">可变引用不能 Copy</h3>
<pre><code class="hljs language-ini" lang="ini">let mut <span class="hljs-attr">x</span> = <span class="hljs-number">5</span><span class="hljs-comment">;</span>
let <span class="hljs-attr">r1</span> = &amp;mut x<span class="hljs-comment">;</span>
let <span class="hljs-attr">r2</span> = r1<span class="hljs-comment">;  // 所有权转移</span>

// println!("{}", r1)<span class="hljs-comment">;  // 错！r1 失效了</span>
</code></pre>
<p>可变引用必须唯一，能 Copy 就会有多个可变引用指向同一个值，违反借用规则。</p>
<h2 data-id="heading-19">Copy vs Clone 怎么选？</h2>



































<table><thead><tr><th>情况</th><th>用啥</th><th>示例</th></tr></thead><tbody><tr><td>简单数值</td><td><code>Copy</code></td><td><code>i32</code>, <code>f64</code>, <code>bool</code></td></tr><tr><td>小结构体（≤16 字节）</td><td><code>Copy</code></td><td><code>Point</code>, <code>Color</code></td></tr><tr><td>有堆数据</td><td>只 <code>Clone</code></td><td><code>String</code>, <code>Vec&lt;T&gt;</code></td></tr><tr><td>大结构体（&gt;16 字节）</td><td>只 <code>Clone</code> 或引用</td><td>配置对象</td></tr><tr><td>需要自定义清理</td><td>只 <code>Clone</code></td><td>实现了 <code>Drop</code> 的</td></tr></tbody></table>
<h2 data-id="heading-20">最佳实践</h2>
<h3 data-id="heading-21">能 Copy 就 Copy</h3>
<p>满足条件就实现，代码简洁：</p>
<pre><code class="hljs language-less" lang="less"><span class="hljs-comment">// 有 Copy：简洁</span>
<span class="hljs-selector-tag">fn</span> <span class="hljs-selector-tag">add</span>(<span class="hljs-attribute">a</span>: Point, <span class="hljs-attribute">b</span>: Point) <span class="hljs-selector-tag">-</span>&gt; <span class="hljs-selector-tag">Point</span> { ... }

<span class="hljs-comment">// 没 Copy：得用引用或 clone</span>
<span class="hljs-selector-tag">fn</span> <span class="hljs-selector-tag">add</span>(<span class="hljs-attribute">a</span>: &amp;Point, <span class="hljs-attribute">b</span>: &amp;Point) <span class="hljs-selector-tag">-</span>&gt; <span class="hljs-selector-tag">Point</span> { ... }
</code></pre>
<h3 data-id="heading-22">保持小巧</h3>
<p>想 Copy 就别超过 16 字节：</p>
<pre><code class="hljs language-rust" lang="rust"><span class="hljs-comment">// 好：8 字节</span>
<span class="hljs-meta">#[derive(Copy, Clone)]</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> { x: <span class="hljs-type">f32</span>, y: <span class="hljs-type">f32</span> }

<span class="hljs-comment">// 别：1024 字节</span>
<span class="hljs-meta">#[derive(Copy, Clone)]</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">BigBuffer</span> { data: [<span class="hljs-type">u8</span>; <span class="hljs-number">1024</span>] }
</code></pre>
<h3 data-id="heading-23">写文档</h3>
<p>实现了 Copy 就说一声：</p>
<pre><code class="hljs language-rust" lang="rust"><span class="hljs-comment">/// 2D 坐标点（Copy，复制很便宜）</span>
<span class="hljs-meta">#[derive(Copy, Clone)]</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> {
    x: <span class="hljs-type">f32</span>,
    y: <span class="hljs-type">f32</span>,
}
</code></pre>
<h3 data-id="heading-24">别滥用</h3>
<p>类型代表「资源」或「唯一实体」，别 Copy：</p>
<pre><code class="hljs language-rust" lang="rust"><span class="hljs-comment">// 别 Copy：代表唯一的文件句柄</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">File</span> {
    fd: <span class="hljs-type">i32</span>,
}

<span class="hljs-comment">// 可以 Copy：就是个数值</span>
<span class="hljs-meta">#[derive(Copy, Clone)]</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">FileDescriptor</span>(<span class="hljs-type">i32</span>);
</code></pre>
<h2 data-id="heading-25">总结</h2>
<ul>
<li>Copy 是隐式的按位复制，赋值时自动复制</li>
<li>只有简单类型能 Copy：不能有堆数据、不能实现 Drop</li>
<li>Copy 必须配合 Clone，因为它继承自 Clone</li>
<li>适合小型栈数据，超过 16 字节考虑用引用</li>
</ul>
<p>Copy 让简单类型用起来像其他语言的基本类型一样自然，但 Rust 的规则保证了这种便利是安全的。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item>  </channel></rss>