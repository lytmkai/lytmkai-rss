<?xml version="1.0" encoding="UTF-8"?><rss version="2.0">  <channel>      <title>掘金文章推荐</title>      <link>https://juejin.cn/recommended?sort=newest</link>      <description>一个帮助开发者成长的社区</description>      <generator>python juejin_recom.py @Pi20</generator>      <item>    <title><![CDATA[深度解析AI编程技术：从原理到实践，手把手教你落地]]></title>    <link>https://juejin.cn/post/7578723693825490980</link>    <guid>https://juejin.cn/post/7578723693825490980</guid>    <pubDate>2025-12-01T15:07:25.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7578723693825490980" data-draft-id="7578667193321652287" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="深度解析AI编程技术：从原理到实践，手把手教你落地"/> <meta itemprop="keywords" content="设计模式,人工智能,开源"/> <meta itemprop="datePublished" content="2025-12-01T15:07:25.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="OneCodeCN"/> <meta itemprop="url" content="https://juejin.cn/user/1427583415622366"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            深度解析AI编程技术：从原理到实践，手把手教你落地
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1427583415622366/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    OneCodeCN
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-01T15:07:25.000Z" title="Mon Dec 01 2025 15:07:25 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-01
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读12分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>AI编程正在重构软件开发的范式——从一句话生成项目框架，到设计稿直接转代码，再到模仿现有工程风格生成新代码，这些曾经的"黑科技"已成为现实。</p>
<p>今天，我们就来系统拆解AI编程的核心技术原理、三大主流模式，以及企业和技术人员的落地指南，帮你搞懂AI编程到底怎么用、能解决什么问题。</p>
<h2 data-id="heading-0">AI编程技术原理深度解析</h2>
<p>AI编程的核心价值，在于把非标准化的开发需求（自然语言、设计稿、现有工程风格）转化为标准化代码。目前主流的AI编程模式有三种，我们逐一拆解其底层逻辑。</p>
<h3 data-id="heading-1">📌 一、意念编程模式（一句话快速构建）：无代码/低代码的需求直达式开发</h3>
<p><strong>简单说</strong>：不用写代码，说句话就能生成可用的项目。比如你说"开发一个科技公司官网"，AI就能直接给你一套能运行的完整框架。</p>
<h4 data-id="heading-2">1. 核心技术逻辑：预计算与按需实例化</h4>
<ul>
<li><strong>卡片组件拆分</strong>：把常用模块（导航栏、表单、游戏交互等）拆成标准化"卡片"，每个卡片包含基础代码、样式占位符（色系、字体等）、功能钩子（按钮跳转等）。</li>
<li><strong>预编译缓存</strong>：所有卡片提前转成抽象语法树（AST）或字节码存在本地/云端，用户提需求时直接从缓存里调，不用实时编译，速度更快。</li>
<li><strong>加权匹配算法</strong>：根据需求拆出4类参数（技术栈40%、行业属性30%、样式20%、本地喜好10%），得分最高的模板组合就是基础框架，既符合技术要求又贴合场景。</li>
</ul>
<h4 data-id="heading-3">2. 大模型核心参数及作用</h4>






























<table><thead><tr><th align="left">参数类型</th><th align="left">核心内涵</th><th align="left">技术作用</th></tr></thead><tbody><tr><td align="left">技术栈参数（Vue/React等）</td><td align="left">指定前端框架</td><td align="left">决定模板语法（如Vue的v-bind、React的useState），自动注入依赖配置</td></tr><tr><td align="left">样式模型参数（色系/风格）</td><td align="left">视觉定位（主色、简约/科技风）</td><td align="left">转化为CSS变量，控制布局、阴影等，统一视觉风格</td></tr><tr><td align="left">行业知识背景</td><td align="left">行业业务特性</td><td align="left">确定模块优先级（如电商优先商品列表），填充通用文本</td></tr><tr><td align="left">本地喜好</td><td align="left">用户历史选择</td><td align="left">构建偏好画像，让输出越来越贴合个人习惯</td></tr></tbody></table>
<h4 data-id="heading-4">3. 完整工作流程</h4>
<ol>
<li>需求解析：把自然语言拆成上述4类参数；</li>
<li>模板匹配：用加权算法从缓存选最合适的卡片组合；</li>
<li>参数注入：替换占位符，生成完整代码；</li>
<li>缓存更新：记录本次生成结果和选择，优化下次匹配。</li>
</ol>
<h3 data-id="heading-5">🎨 二、前端驱动模式（图转代码）：设计稿的自动化代码落地</h3>
<p><strong>简单说</strong>：把Figma、蓝湖的设计稿直接转成可运行的前端代码，省去"设计-开发"的反复沟通。</p>
<h4 data-id="heading-6">1. 核心技术基石：五维坐标体系</h4>
<p>设计稿的每一个元素，都会被拆解成5个维度的属性，确保视觉和交互1:1还原成代码：</p>



































<table><thead><tr><th align="left">维度</th><th align="left">技术内涵</th><th align="left">前端映射逻辑</th></tr></thead><tbody><tr><td align="left">二维平面（X,Y）</td><td align="left">元素位置、宽高</td><td align="left">CSS的position、left/top/width/height，或grid/flex布局</td></tr><tr><td align="left">三维图层透视</td><td align="left">层级、嵌套、投影</td><td align="left">DOM嵌套结构、z-index、box-shadow，组件父子关系</td></tr><tr><td align="left">四维时间轴（动画）</td><td align="left">hover/点击效果、动画时长</td><td align="left">CSS@keyframes/transition、JS事件监听</td></tr><tr><td align="left">五维动作交互</td><td align="left">页面跳转、触发条件</td><td align="left">前端路由配置、滚动监听、事件绑定</td></tr><tr><td align="left">工程化维度</td><td align="left">模块化拆分</td><td align="left">组件文件拆分、目录结构、导入导出逻辑</td></tr></tbody></table>
<h4 data-id="heading-7">2. 大模型工作原理</h4>
<ol>
<li>设计稿解析：通过Figma等工具的API读取元数据，转成五维坐标数据（如{x:100, y:200, animation:{duration:0.5s}}）；</li>
<li>视觉-代码映射：按"设计属性-前端语法"规则，把五维数据转成代码（如平面属性→CSS布局）；</li>
<li>代码优化：自动处理兼容性（加CSS前缀）、删冗余代码，适配指定框架。</li>
</ol>
<h4 data-id="heading-8">3. 核心技术难点与解决方案</h4>
<ul>
<li>设计稿没标hover效果？按行业通用规则补（如按钮默认hover变色）；</li>
<li>多层嵌套导致DOM混乱？用图层树遍历算法，保持嵌套结构一致；</li>
<li>动画参数不匹配？把Figma缓动曲线转成CSS的cubic-bezier函数，确保节奏一致。</li>
</ul>
<h3 data-id="heading-9">🔄 三、后端驱动模式（现有工程学习）：工程风格的模仿式生成</h3>
<p><strong>简单说</strong>：让AI"学习"你现有项目的代码风格、架构和规范，生成的新代码能和老代码无缝衔接，再也不用纠结"风格不统一"。</p>
<h4 data-id="heading-10">1. 核心技术逻辑：从"读取"到"模仿"的三步闭环</h4>
<ol>
<li><strong>工程解析：提取关键特征</strong>undefined通过IDE插件扫描项目，提取技术路线（Vue3/React18、Vite/Webpack）、场景能力（业务模块划分、核心功能）、编码规范（命名规则、注释风格），形成"工程特征库"。</li>
<li><strong>知识库建模与专家模式划分</strong>undefined把特征库结构化存成"专属知识库"（如{framework:'Vue3', indent:2}），并让大模型切换成对应"专家模式"（如"Vue3组合式API专家"），每个模式有专属参数权重。</li>
<li><strong>模仿生成与参数迭代</strong>undefined结合新需求和知识库，生成符合原风格的代码；用户修改后，反向更新知识库，越用越精准。</li>
</ol>
<h4 data-id="heading-11">2. 大模型核心能力支撑</h4>
<ul>
<li>AST级特征提取：通过抽象语法树分析结构，避免表层模仿偏差；</li>
<li>向量数据库检索：把代码特征转成向量，快速匹配规范，提升效率；</li>
<li>细分参数加权：按原工程使用频率分配权重（如100%用组合式API，该参数权重设100%）。</li>
</ul>
<h4 data-id="heading-12">3. 核心技术价值</h4>
<ul>
<li>解决风格冲突，新增代码和老工程无缝衔接；</li>
<li>开发者不用记规范，AI自动对齐；</li>
<li>把工程"隐性经验"（编码习惯）转成"显性参数"，实现知识传承。</li>
</ul>
<h3 data-id="heading-13">📊 四、AI编程的底层逻辑与行业现状</h3>
<h4 data-id="heading-14">1. 三大模式核心技术对比</h4>





























<table><thead><tr><th align="left">模式</th><th align="left">核心技术关键词</th><th align="left">大模型核心作用</th><th align="left">应用场景</th></tr></thead><tbody><tr><td align="left">意念编程</td><td align="left">模板缓存、参数匹配</td><td align="left">需求拆解→模板匹配→参数注入</td><td align="left">官网、小游戏、简易工具</td></tr><tr><td align="left">图转代码</td><td align="left">五维坐标、视觉-代码映射</td><td align="left">设计稿解析→属性解构→语法映射</td><td align="left">设计稿落地、UI还原</td></tr><tr><td align="left">工程学习</td><td align="left">特征提取、知识库建模</td><td align="left">工程解析→规则匹配→模仿生成</td><td align="left">现有项目迭代、新增功能</td></tr></tbody></table>
<p><strong>共性</strong>：都是"参数化配置"为核心，通过大模型把非标准化输入转成标准化代码，本质是"大模型+领域知识+工程规则"的协同。</p>
<h4 data-id="heading-15">2. 大模型优化原理：从"能用"到"好用"</h4>
<ul>
<li><strong>专家模式划分</strong>：按场景拆分能力（如"Vue3开发专家"），强化对应知识；</li>
<li><strong>微调参数技术</strong>：用少量项目规范数据微调模型，避免"泛而不精"；</li>
<li><strong>工作流Agent机制</strong>：多Agent分工协作（需求解析→生成→检查→优化）；</li>
<li><strong>知识库应用</strong>：实时调用领域知识（框架文档、编码规范），确保输出合规；</li>
<li><strong>筛选过滤机制</strong>：评估代码正确性、性能、风格，过滤冗余和风险代码。</li>
</ul>
<h4 data-id="heading-16">3. AIGC演变与AI-IDE行业现状</h4>
<p>2025年国内AI-IDE爆发，阿里Qoder、腾讯CB等产品密集出现。国际上OpenAI奠定"指令微调+代码对齐"范式，国内DeepSeek3.X等模型通过多尺度上下文理解提升中文适配能力，当前竞争核心是智能体（Agent）标准与工作流设计。</p>
<h2 data-id="heading-17">第二部分：实践路径：企业与技术人员的AI编程落地指南</h2>
<h3 data-id="heading-18">🏢 一、企业核心决策：是否需要构建自有大模型体系？</h3>
<h4 data-id="heading-19">（1）场景一：内部研发效率提升——优先借力外部成熟模型</h4>
<p>如果只是想提升内部团队效率（解决重复编码、规范统一等问题），没必要自建大模型：</p>
<ul>
<li>工具选型：用VS Code Copilot、阿里Qoder等开箱即用工具；</li>
<li>流程适配：明确"AI生成-人工校验"机制，重点查业务逻辑和安全；</li>
<li>成本控制：用SaaS按需付费，培训团队Prompt能力最大化价值。</li>
</ul>
<p>适合：传统企业IT部门、中小型互联网团队、非技术驱动型企业。</p>
<h4 data-id="heading-20">（2）场景二：对外提供AI产品服务——必须布局自有部署体系</h4>
<p>如果核心业务是对外提供AI开发服务（如快速建站工具），自建体系是必然：</p>
<ul>
<li><strong>工具输出型企业</strong>（如SaaS厂商）：私有部署降低调用成本，用预编译模板库执行代码生成，计算成本降60%+；</li>
<li><strong>数据驱动型企业</strong>（如金融、医疗）：私有部署保障数据安全，结合行业专属知识库（如风控规则），提升输出适配性。</li>
</ul>
<h3 data-id="heading-21">🔧 二、软件企业AI升级：全链路重构与能力建设</h3>
<p>AI编程不是简单加工具，而是"方法流程、组织能力、技术架构"的全链路升级。</p>
<h4 data-id="heading-22">（1）方法流程升级：从"人工主导"到"人机协同"</h4>
<ul>
<li><strong>全员AI知识升级</strong>：产品、研发、测试都要懂AI——产品经理要会把"页面流畅"转成"首屏加载≤1.5s"；测试用AI生成自动化脚本。</li>
<li><strong>研发CI/CD流程变革</strong>：把AI嵌入全流程：需求→代码生成→自动化测试→安全扫描→部署，研发周期缩短30%+。</li>
<li><strong>企业级Prompt基础构建</strong>：按业务场景（电商订单、金融支付）和技术栈分类沉淀模板，比如："基于Spring Boot 2.7，开发电商订单创建接口，含权限校验、库存预扣，输出Controller+Service代码"。</li>
</ul>
<h4 data-id="heading-23">（2）软件架构升级：构建支撑AI能力的技术底座</h4>
<ul>
<li><strong>RAG知识体系</strong>：把行业方案、编码规范、历史代码转成结构化知识库，AI生成代码时实时调用，确保符合业务规则；</li>
<li><strong>智能体（Agent）管理</strong>：多Agent分工协作（需求解析、前后端生成、测试、安全审计），自动拆解复杂任务；</li>
<li><strong>流程驱动模式</strong>：用户输入参数（如客户信息字段、权限角色），系统自动调用AI生成代码，完成数据库设计、页面开发等；</li>
<li><strong>工具链构建</strong>：对内整合AI工具、知识库、CI/CD；对外封装行业专属工具（如"金融AI开发套件"），开辟新盈利点。</li>
</ul>
<h3 data-id="heading-24">👨💻 三、技术人员视角：从"执行者"到"AI协同指挥官"</h3>
<p>AI不会取代技术人员，而是解放重复劳动，让精力聚焦在核心能力上。</p>
<h4 data-id="heading-25">（1）程序员：构建"AI无法替代的技术壁垒"</h4>
<p>分三个进阶阶段：</p>
<ol>
<li><strong>基础应用阶段：用AI提效重复工作</strong>
<ul>
<li>学习：Prompt基础（5W1H原则：谁用、做什么、何时触发、场景、目标、技术要求）、主流工具操作；</li>
<li>场景：生成CRUD接口、单元测试、格式化代码、翻译技术文档；</li>
<li>技巧：指令要明确"技术栈+功能点+输出格式"，比如："基于Vue3+Pinia，开发购物车功能，含库存校验，输出template+script代码，附注释"。</li>
</ul>
</li>
<li><strong>进阶提升阶段：用AI支撑复杂开发决策</strong>
<ul>
<li>学习：大模型微调基础、AST语法树原理、AI代码优化策略；</li>
<li>场景：拆解复杂业务（如把"电商秒杀"拆成库存预扣、订单创建等模块）、框架迁移、排查性能问题；</li>
<li>技巧：建立"AI生成-人工校验"清单，重点查业务适配性、性能安全性、可维护性。</li>
</ul>
</li>
<li><strong>高阶引领阶段：用AI构建团队专属能力</strong>
<ul>
<li>学习：Agent工作流设计、向量数据库应用、AI工具二次开发；</li>
<li>场景：开发团队专属插件（如校验编码规范的VS Code插件）、构建业务专家模型、主导AI与CI/CD融合；</li>
<li>技巧：沉淀团队Prompt模板库，按业务模块分类，定期迭代优化。</li>
</ul>
</li>
</ol>
<p><strong>避坑点</strong>：别当"AI传声筒"，要懂底层技术（分布式、高并发等），这是架构设计和问题排查的核心。</p>
<h4 data-id="heading-26">（2）产品经理：用AI搭建"需求-技术"的桥梁</h4>
<ol>
<li><strong>需求传递阶段：优化需求表达</strong>
<ul>
<li>学习：技术化语言转化、AI需求拆解工具；</li>
<li>场景：把"页面流畅"转成"首屏加载≤1.5s"、用AI评估需求可行性、生成简易Demo辅助评审；</li>
<li>技巧：PRD里加"AI代码生成提示区"，明确技术栈、交互要求、与现有系统关联点。</li>
</ul>
</li>
<li><strong>研发协同阶段：提升沟通效率</strong>
<ul>
<li>学习：主流技术基础、跨角色沟通方法；</li>
<li>场景：用AI把技术方案转成产品视角说明、分析需求变更影响范围、跟踪研发进度；</li>
<li>技巧：组织"AI需求共创会"，和研发一起用AI生成代码框架，提前对齐需求。</li>
</ul>
</li>
<li><strong>产品创新阶段：探索新可能</strong>
<ul>
<li>学习：多模态AI应用、用户需求挖掘工具；</li>
<li>场景：快速制作创新Demo（如"AI简历分析"）、用AI从用户反馈提炼功能点、优化产品体验；</li>
<li>技巧：建"AI快速原型库"，加速创新想法的验证和迭代。</li>
</ul>
</li>
</ol>
<h3 data-id="heading-27">🌐 四、行业协同：共建AI编程良性生态</h3>
<p>AI编程的健康发展，需要技术厂商、教育机构、行业组织共同努力——从技术创新、人才培养到规范制定，一起推动行业可持续发展。</p>
<p>AI编程正在改变软件开发的游戏规则，无论是企业还是个人，看懂原理、找对路径，才能在这场变革中抓住机遇。你在AI编程实践中遇到过哪些问题？欢迎留言讨论～</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[2025博客框架选择指南：Hugo、Astro、Hexo该选哪个？]]></title>    <link>https://juejin.cn/post/7578714735307849754</link>    <guid>https://juejin.cn/post/7578714735307849754</guid>    <pubDate>2025-12-01T15:20:37.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7578714735307849754" data-draft-id="7577228831138545707" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="2025博客框架选择指南：Hugo、Astro、Hexo该选哪个？"/> <meta itemprop="keywords" content="前端,HTML"/> <meta itemprop="datePublished" content="2025-12-01T15:20:37.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="技术探索家"/> <meta itemprop="url" content="https://juejin.cn/user/2735240657517816"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            2025博客框架选择指南：Hugo、Astro、Hexo该选哪个？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2735240657517816/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    技术探索家
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-01T15:20:37.000Z" title="Mon Dec 01 2025 15:20:37 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-01
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读15分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/06137ab43a85404491ef287f503bfb58~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oqA5pyv5o6i57Si5a62:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765207236&amp;x-signature=24baS6hJEeNG6CrHajqKTmFzDVE%3D" alt="Gemini_Generated_Image_c4yo85c4yo85c4yo.jpg" loading="lazy"/></p>
<h2 data-id="heading-0">引言</h2>
<p>2025年了，想搭个博客，在Hugo、Hexo、Astro之间纠结了一周，还是不知道选哪个？</p>
<p>我完全理解这种感受。去年我也在这几个博客框架之间来回折腾,看了无数对比文章，最后发现大部分都是2022-2023年的过时内容。性能数据变了、框架更新了、生态也不一样了。每次看完一篇文章就更纠结，到底该听谁的？</p>
<p>更让人崩溃的是，深夜折腾博客配置，第二天还要上班。花了三个月研究框架，结果一篇文章都没写出来。这种感觉，相信你也经历过。</p>
<p>这篇文章基于2024-2025年最新数据，用真实的构建时间测试、实际的使用体验，帮你在5分钟内做出最适合的选择。不是告诉你"哪个最好"，而是"哪个最适合你"。</p>
<p>我会用9大框架的最新性能对比、3分钟决策矩阵，帮你避免90%新手会踩的坑。说实话，早点看到这篇文章，我能省好几周时间。</p>
<h2 data-id="heading-1">为什么2025年还在聊博客框架？</h2>
<h3 data-id="heading-2">静态博客真的还有必要吗？</h3>
<p>老实讲，我一开始也觉得搭博客是个过时的想法。但用了一年多，真香。</p>
<p>静态博客和WordPress这类动态博客的本质区别，就是"提前做好"和"现场制作"的区别。静态网站生成器（SSG）会在你写完文章后，就把所有页面生成好，像做批量打印一样。访客来了直接看成品，速度飞快。WordPress这类动态博客呢，每次有人访问就现场从数据库拉数据、拼装页面，就像现场手工做菜。</p>
<p><strong>为什么静态博客成为主流趋势？</strong></p>
<p>说白了就是：快、便宜、不用操心服务器。</p>
<p>WordPress需要租服务器，一个月怎么也得几十块钱起步。静态博客呢？GitHub Pages、Vercel、Cloudflare Pages全都免费托管。我现在博客一年花费0元，连域名都是之前买的。</p>
<p>性能上更没得比。静态页面的Lighthouse评分能轻松拿到95+，WordPress想到90分都费劲。用户打开页面，一眨眼就加载完了，这种体验真的会让人爱上写博客。</p>
<h3 data-id="heading-3">那什么时候该选动态博客？</h3>
<p>也不是说静态博客就天下无敌。如果你要做复杂的功能，比如：</p>
<ul>
<li>
<p>多人协作发布（需要后台管理）</p>
</li>
<li>
<p>电商集成（要处理支付、订单）</p>
</li>
<li>
<p>复杂的用户系统（评论、权限管理）</p>
</li>
</ul>
<p>这些场景，WordPress或者Ghost确实更合适。但老实说，大部分个人博客和技术博客，真用不到这些。</p>
<p><strong>一句话总结</strong>：个人博客、技术文档、作品展示，选静态博客框架准没错。需要复杂功能、多人协作，才考虑动态博客。</p>
<h2 data-id="heading-4">性能对决 - 谁是速度之王？</h2>
<p>性能这块，说实话是我最关心的。刚开始用Gatsby的时候，每次改一点内容，重新构建等十几分钟，真的想砸电脑。</p>
<h3 data-id="heading-5">构建速度：差距大到惊人</h3>
<p>先说结论：<strong>Hugo是速度之王，没有之一</strong>。</p>
<p>看看这组2024年的实测数据：</p>
<p>| 框架 | 构建10000页用时 | 平均每页速度 |</p>
<p>|------|----------------|-------------|</p>
<p>| <strong>Hugo</strong> | 2.95秒 | &lt;1ms |</p>
<p>| <strong>Hexo</strong> | 45秒（1000页） | ~45ms |</p>
<p>| <strong>Jekyll</strong> | 187.15秒 | ~18ms |</p>
<p>| <strong>Gatsby</strong> | 30分钟+ | ~180ms |</p>
<p>第一次看到Hugo的构建速度，真的惊到我了。10000篇文章，不到3秒！这意味着啥？你改个标题、修个错别字，按个保存，页面刷新，博客就更新完了。这种即时反馈，爽到飞起。</p>
<p>Hexo呢，中型博客（100-1000文章）表现也挺不错。我之前300篇文章的博客，15秒就构建完成，完全够用。</p>
<p>Gatsby...嗯，别提了。我用它做过一个项目，200多篇文章，每次构建5分钟起步。后来文章多了，直接放弃了。</p>
<h3 data-id="heading-6">页面加载速度：Astro异军突起</h3>
<p>2024年Astro成了最大黑马。根据HTTP Archive的数据：</p>
<ul>
<li>
<p><strong>Astro</strong>：中位传输大小889KB（最轻）</p>
</li>
<li>
<p><strong>Hugo</strong>：1,174KB（平衡不错）</p>
</li>
<li>
<p><strong>Next.js</strong>：1,659KB（功能多，体积大）</p>
</li>
</ul>
<p>Astro的"零JavaScript默认"策略真的厉害。页面只加载必要的JS，不像其他框架，把整个React/Vue库都塞给用户。结果就是，页面打开速度飞快，用户体验特别好。</p>
<h3 data-id="heading-7">实际项目表现：别只看数字</h3>
<p>老实讲，如果你博客不到100篇文章，选啥框架都差不多。几秒和十几秒的区别，你感受不出来。</p>
<p>但如果你计划长期写作，文章会越来越多，<strong>提前选个性能好的框架，能省很多麻烦</strong>。我见过太多人，开始用了Gatsby，写到500篇文章，构建慢到受不了，迁移框架，那个痛苦...</p>
<p><strong>推荐组合</strong>：</p>
<ul>
<li>
<p><strong>小型博客（&lt;100文章）</strong>：随便选，都够用</p>
</li>
<li>
<p><strong>中型博客（100-1000文章）</strong>：Hugo、Hexo、Astro</p>
</li>
<li>
<p><strong>大型站点（1000+文章）</strong>：闭眼选Hugo</p>
</li>
</ul>
<h2 data-id="heading-8">开发体验 - 哪个最好用？</h2>
<p>性能再好，用起来糟心，也是白搭。</p>
<h3 data-id="heading-9">学习曲线：新手别踩坑</h3>
<p>说实话，Hugo的Go模板语法，我当初学了好久才上手。那些<code>{{ range }}</code>、<code>{{ with }}</code>的语法，刚开始真的看懵了。虽然性能无敌，但新手上来就选Hugo，可能会被劝退。</p>
<p><strong>新手友好度排名</strong>：</p>
<ol>
<li>
<p><strong>Hexo</strong>（最友好）：Node.js生态，中文文档多到看不过来。配置就是一个<code>_config.yml</code>文件，改几个参数就能跑起来。我当时半小时就搭好了第一个博客。</p>
</li>
<li>
<p><strong>Jekyll</strong>（友好）：Ruby生态，官方文档写得特别清楚，按着步骤来不会错。GitHub Pages原生支持，push一下就自动部署。</p>
</li>
<li>
<p><strong>VuePress</strong>（需要前端基础）：如果你会Vue，上手很快。不会的话，还得先学Vue，成本就高了。</p>
</li>
<li>
<p><strong>Gatsby/Next.js</strong>（陡峭）：要懂React、GraphQL，配置复杂。我看到配置文件就头大。</p>
</li>
</ol>
<p><strong>我的建议</strong>：如果你和我一样是Node.js开发者，Hexo真的是顺手。装个npm包，改改配置，半小时搞定。前端技术栈是React？那Astro或Next.js更合适。别纠结了，新手就选Hexo，错不了。</p>
<h3 data-id="heading-10">配置和自定制：平衡艺术</h3>
<p>Hexo和Jekyll的配置简单直接，一个YAML文件搞定。但也有缺点：想做复杂定制，就得深入源码改，不太灵活。</p>
<p>Gatsby的灵活性确实强，GraphQL数据层可以接各种数据源。但坦白说，个人博客真用不到那么复杂的功能。就像买了辆跑车在市区开，性能过剩了。</p>
<p>Astro走了个中间路线，既灵活又不复杂。支持多框架（React、Vue、Svelte随便混），但配置没那么吓人。这种平衡感，我挺喜欢的。</p>
<h3 data-id="heading-11">开发工具和调试</h3>
<p>现代框架在开发体验上真的吊打老框架。</p>
<p>Vite驱动的Astro和VuePress，热重载快到飞起。改个内容，不到1秒页面就更新了。Webpack那套老架构，等待时间能让人发呆。</p>
<p>Hugo虽然是传统框架，但速度快，改完刷新也很即时。这点体验还不错。</p>
<h2 data-id="heading-12">生态系统 - 主题与插件谁更丰富？</h2>
<p>框架再好，没主题也白搭。谁想从零开始写CSS啊。</p>
<h3 data-id="heading-13">主题生态：Hexo中文世界称王</h3>
<p><strong>Hexo</strong>真的是中文博客的天选之子。200+中文主题，风格各异，总有一款适合你。我用的那个主题，中文文档详细到连怎么改字体颜色都写得清清楚楚。</p>
<p>Hugo主题虽然有300+，但质量参差不齐。有些特别精美，有些就是demo级别。很多主题文档是英文的，踩坑全靠自己摸索。</p>
<p>Jekyll作为老牌框架，主题数量最多，但很多都是好几年前的设计风格了，看着有点过时。</p>
<p>Gatsby和Astro的主题，走的是现代化路线，设计感很强。如果你追求视觉效果，这两个不错。</p>
<h3 data-id="heading-14">插件和扩展能力</h3>
<p>Jekyll的插件生态最庞大，毕竟历史最久。想要啥功能，基本都能找到插件。</p>
<p>Gatsby依托npm生态，插件也超级丰富。但很多插件其实是为商业项目设计的，个人博客可能用不上。</p>
<p>Hexo插件生态在Node.js圈很成熟，常用的评论、搜索、SEO优化，都有现成插件。我装了七八个插件，没遇到过兼容问题。</p>
<h3 data-id="heading-15">社区活跃度：看数据说话</h3>
<p>2024-2025年的数据挺有意思：</p>
<ul>
<li>
<p><strong>Astro</strong>：增长最快，npm下载量2024年9月达到300万。Netlify调查显示，它是2024年开发者关注度最高的框架。</p>
</li>
<li>
<p><strong>Hugo</strong>：GitHub星标6万+，稳定增长，老牌强者。</p>
</li>
<li>
<p><strong>Hexo</strong>：中文社区最活跃，知乎、掘金、CSDN到处都是教程。</p>
</li>
</ul>
<p>说实话，社区活跃度对新手很重要。遇到问题，能搜到中文解决方案，省太多时间了。</p>
<h2 data-id="heading-16">部署与SEO - 上线才是王道</h2>
<p>博客搭好了，不上线有啥用？</p>
<h3 data-id="heading-17">部署平台：全都免费真香</h3>
<p>现在部署静态博客，真的太简单了。</p>
<p><strong>GitHub Pages</strong>：Jekyll原生支持，push代码就自动部署。其他框架需要配个GitHub Actions，也就多写几行配置，5分钟搞定。</p>
<p><strong>Vercel/Netlify</strong>：这俩是我最推荐的。拖个仓库进去，自动识别框架，自动构建部署。都有免费额度，个人博客完全够用。我现在用的Vercel，一年没花过一分钱。</p>
<p><strong>Cloudflare Pages</strong>：性能特别好，CDN全球分布。免费额度也很大，速度比GitHub Pages快不少。</p>
<p>老实讲，2025年部署静态博客，已经没有技术门槛了。真的，比你想象的简单。</p>
<h3 data-id="heading-18">SEO：静态博客天生优势</h3>
<p>所有静态博客框架，SEO都友好。为啥？生成的都是纯HTML，搜索引擎最爱这个。</p>
<p>区别在于细节：</p>
<ul>
<li>
<p><strong>Hugo和Jekyll</strong>：成熟稳定，sitemap、RSS自动生成，SEO基础功能齐全。</p>
</li>
<li>
<p><strong>Astro和Next.js</strong>：在现代SEO实践上更领先，支持更细致的元数据管理，结构化数据也更方便。</p>
</li>
<li>
<p><strong>Hexo</strong>：通过插件实现SEO功能，也挺完善，中文SEO教程多。</p>
</li>
</ul>
<p>说白了，只要你写好内容、优化好关键词、页面结构合理，用哪个框架SEO都不会差。别太纠结这个。</p>
<h3 data-id="heading-19">长期维护成本：别选冷门框架</h3>
<p>这个坑我踩过。之前用过一个小众框架，开始挺好，半年后发现作者不更新了。后来依赖库升级，博客直接跑不起来，迁移框架花了整整一周。</p>
<p><strong>低维护框架</strong>：Hugo、Jekyll。成熟稳定，基本不会出幺蛾子。我Hugo博客跑了一年多，一次问题都没遇到。</p>
<p><strong>需要关注更新</strong>：Gatsby、Next.js。依赖多，更新频繁，偶尔会遇到breaking changes。如果你不想经常折腾，慎选。</p>
<p><strong>平衡选手</strong>：Astro、Hexo。更新有节制，兼容性做得不错。</p>
<h2 data-id="heading-20">决策框架 - 如何选择最适合你的？</h2>
<p>好了，前面说了这么多数据和对比，到底该怎么选？</p>
<h3 data-id="heading-21">3分钟快速决策矩阵</h3>
<p>别想太多，回答三个问题：</p>
<p><strong>问题1：你的技术栈是什么？</strong></p>
<ul>
<li>
<p><strong>熟悉Node.js</strong> → Hexo（新手）/ Astro（追求现代化）</p>
</li>
<li>
<p><strong>React开发者</strong> → Gatsby（重型）/ Astro（轻量）/ Next.js（全栈）</p>
</li>
<li>
<p><strong>Vue开发者</strong> → VuePress（博客+文档）/ Gridsome</p>
</li>
<li>
<p><strong>技术栈不限</strong> → Hugo（性能第一）/ Jekyll（求稳）</p>
</li>
</ul>
<p>如果你和我一样是Node.js开发者，Hexo真的顺手。装个npm包，改改配置，半小时搞定。</p>
<p><strong>问题2：你的项目规模是多大？</strong></p>
<ul>
<li>
<p><strong>&lt;100文章</strong> → 随便选，性能差异你感受不出来</p>
</li>
<li>
<p><strong>100-1000文章</strong> → Hugo（快）/ Hexo（够用）/ Astro（现代）</p>
</li>
<li>
<p><strong>1000+文章或大型文档站</strong> → Hugo（一骑绝尘，没得比）</p>
</li>
</ul>
<p>我现在500多篇文章，用的Hexo，45秒构建完成，完全够用。如果文章继续增长到1000+，可能会换Hugo。</p>
<p><strong>问题3：你的经验水平如何？</strong></p>
<ul>
<li>
<p><strong>新手</strong> → Hexo（中文资源多）/ Jekyll（文档友好）</p>
</li>
<li>
<p><strong>前端开发者</strong> → Astro（现代化体验）/ VuePress（Vue技术栈）</p>
</li>
<li>
<p><strong>性能极客</strong> → Hugo（速度无敌，值得学Go模板）</p>
</li>
<li>
<p><strong>求稳用户</strong> → Jekyll（GitHub原生支持，最省心）</p>
</li>
</ul>
<h3 data-id="heading-22">典型场景具体推荐</h3>
<p><strong>个人技术博客</strong>：</p>
<ul>
<li>
<p>中文用户：Hexo（生态强，主题多）</p>
</li>
<li>
<p>国际化：Hugo（性能好，英文资源丰富）</p>
</li>
<li>
<p>追求现代化：Astro（体验好，性能也不错）</p>
</li>
</ul>
<p><strong>技术文档站点</strong>：</p>
<ul>
<li>
<p>Docusaurus（Facebook出品，专为文档设计）</p>
</li>
<li>
<p>VuePress（Vue生态，中文支持好）</p>
</li>
</ul>
<p><strong>大型内容站点</strong>：</p>
<ul>
<li>Hugo（1000+页面，只有它能扛住）</li>
</ul>
<p><strong>现代化项目网站</strong>：</p>
<ul>
<li>
<p>Astro（灵活性+性能的最佳平衡）</p>
</li>
<li>
<p>Next.js（需要动态功能时选它）</p>
</li>
</ul>
<h3 data-id="heading-23">我的真实建议</h3>
<p>说实话，<strong>别再纠结了</strong>。我见过太多人花三个月研究框架，一篇文章没写。框架真的只是工具，内容才是核心。</p>
<p><strong>选择建议</strong>：</p>
<ul>
<li>
<p><strong>90%的人</strong>：选Hexo或Hugo，够用了</p>
</li>
<li>
<p><strong>前端开发者</strong>：Astro值得尝试，体验很现代</p>
</li>
<li>
<p><strong>新手怕选错</strong>：Hexo，中文教程多到看不完，遇到问题都能搜到答案</p>
</li>
<li>
<p><strong>性能焦虑症患者</strong>：闭眼选Hugo，速度真的无敌</p>
</li>
</ul>
<p>记住：框架可以迁移（内容都是Markdown，搬家成本不高），但荒废的时间回不来。先选一个动起来，边用边优化，这才是正道。</p>
<h2 data-id="heading-24">避坑指南与最佳实践</h2>
<p>最后说说那些大坑，我替你踩过了。</p>
<h3 data-id="heading-25">5个常见错误</h3>
<p><strong>错误1：过度追求完美框架，迟迟不开始</strong></p>
<p>这个坑我踩得最深。当年对比了两个月框架，看了几十篇文章，结果还是不确定。后来一个前辈跟我说："先选一个动起来，框架不满意可以换，但浪费的时间回不来。"</p>
<p>说白了，<strong>内容才是博客的核心，框架只是工具</strong>。没有完美的框架，只有最适合当下的选择。</p>
<p><strong>错误2：只看主题外观，忽略框架本质</strong></p>
<p>看到某个Hugo主题特别炫酷，就选了Hugo。结果发现Go模板语法学不会，自定义主题难如登天。最后用了半年，还是换回Hexo。</p>
<p>主题可以定制、可以换，但框架的性能、生态、维护性，这些本质特性才是长期影响你的因素。</p>
<p><strong>错误3：新手直接上Gatsby/Next.js被劝退</strong></p>
<p>我一朋友，刚学前端，听说Gatsby牛逼，直接上手。结果GraphQL不会、React不熟、配置看不懂，折腾两周直接放弃了。</p>
<p>老实说，<strong>Gatsby和Next.js真的不适合新手</strong>。它们是给有经验的开发者准备的工具。新手想快速上线博客，Hexo或Jekyll才是正确选择。</p>
<p><strong>错误4：忽略长期维护成本</strong></p>
<p>选了个冷门框架，一开始挺好，半年后作者不更新了。依赖库升级，博客跑不起来。迁移框架，痛苦得要死。</p>
<p><strong>看框架选择的三个指标</strong>：</p>
<ul>
<li>
<p>GitHub更新频率（至少每月有commit）</p>
</li>
<li>
<p>社区规模（遇到问题能找到人问）</p>
</li>
<li>
<p>中文资源（新手必看，能省80%时间）</p>
</li>
</ul>
<p><strong>错误5：花80%时间折腾框架，20%写内容</strong></p>
<p>我见过太多人，陷入"完美主义陷阱"。CSS改来改去、插件装了卸卸了装，就是不写文章。</p>
<p>记住<strong>80/20法则</strong>：80%精力写内容，20%折腾框架。够用就好，别追求极致完美。</p>
<h3 data-id="heading-26">框架迁移建议</h3>
<p>万一真选错了，想换框架怎么办？</p>
<p>其实没那么可怕。所有静态博客框架，内容都是Markdown，迁移成本不高。我从Hexo迁移到Hugo，内容迁移只花了1小时。主要是配置和主题要重新搞，但也就半天时间。</p>
<p><strong>迁移原则</strong>：</p>
<ul>
<li>
<p><strong>先有后优</strong>：快速上线 &gt; 完美配置</p>
</li>
<li>
<p><strong>内容优先</strong>：写够50篇文章再考虑迁移，不然没必要</p>
</li>
<li>
<p><strong>不影响SEO</strong>：做好301重定向，URL结构尽量保持一致</p>
</li>
</ul>
<h3 data-id="heading-27">2025年趋势展望</h3>
<p>根据2024-2025的数据和社区动向，我预测：</p>
<ul>
<li>
<p><strong>Astro会继续增长</strong>：岛屿架构是未来趋势，零JavaScript默认太香了</p>
</li>
<li>
<p><strong>Hugo保持性能王者地位</strong>：大型站点没得选</p>
</li>
<li>
<p><strong>Hexo中文生态持续稳定</strong>：中文博客的首选不会变</p>
</li>
<li>
<p><strong>传统框架逐步被取代</strong>：Jekyll虽然稳定，但新项目会越来越少</p>
</li>
</ul>
<p>但说实话，趋势只是参考。选框架还是要看自己的需求和技术栈。</p>
<h2 data-id="heading-28">结论</h2>
<p>回到最开始的问题：2025年博客框架该怎么选？</p>
<p><strong>一句话总结</strong>：</p>
<ul>
<li>
<p><strong>新手首选</strong>：Hexo（中文资源丰富，主题多，上手快）</p>
</li>
<li>
<p><strong>前端开发者</strong>：Astro（性能+灵活性的最佳平衡，现代化体验）</p>
</li>
<li>
<p><strong>性能极客</strong>：Hugo（速度无敌，适合大型站点）</p>
</li>
<li>
<p><strong>文档站点</strong>：Docusaurus/VuePress（专为文档设计）</p>
</li>
<li>
<p><strong>求稳</strong>：Jekyll（GitHub原生支持，最省心）</p>
</li>
</ul>
<p>但老实讲，<strong>选择框架只需要5分钟，写好内容需要一辈子</strong>。</p>
<p>别再纠结了。选一个顺手的，开始行动吧。写第一篇文章，比研究框架重要一百倍。</p>
<p>我当初纠结了两个月，现在回头看，那段时间完全是浪费。早点开始写，现在可能已经有200篇文章了。</p>
<p><strong>行动建议</strong>：</p>
<ol>
<li>
<p>根据上面的决策矩阵，花5分钟选一个框架</p>
</li>
<li>
<p>找个主题，1小时搭好环境</p>
</li>
<li>
<p>写第一篇文章，哪怕只有500字</p>
</li>
<li>
<p>发布上线，享受成就感</p>
</li>
</ol>
<p>记住：<strong>框架不重要，内容才重要。够用就好，专注写作。</strong></p>
<p>评论区说说你的选择和理由？我很好奇大家最后都选了什么。如果有问题，我会尽量回复的。</p>
<blockquote>
<p>本文首发自<a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.betterlink.top%2Fzh%2F" target="_blank" title="https://blog.betterlink.top/zh/" ref="nofollow noopener noreferrer">个人博客</a></p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Kubernetes Service动手实验]]></title>    <link>https://juejin.cn/post/7578724773993381914</link>    <guid>https://juejin.cn/post/7578724773993381914</guid>    <pubDate>2025-12-01T15:27:28.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7578724773993381914" data-draft-id="7578732288515670067" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Kubernetes Service动手实验"/> <meta itemprop="keywords" content="Kubernetes"/> <meta itemprop="datePublished" content="2025-12-01T15:27:28.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="哈里谢顿"/> <meta itemprop="url" content="https://juejin.cn/user/3678304397695056"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Kubernetes Service动手实验
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3678304397695056/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    哈里谢顿
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-01T15:27:28.000Z" title="Mon Dec 01 2025 15:27:28 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-01
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>非常好的问题！验证 Kubernetes Service（svc）是否正常工作，是日常开发和运维的核心技能。下面我为你设计 <strong>5 个由浅入深的动手实验</strong>，全部基于命令行操作，你可以在自己的集群（如你的 <code>k8s-master-node</code>）上直接运行。</p>
<hr/>
<h2 data-id="heading-0">🧪 实验前提</h2>
<p>确保你已有一个运行中的 Pod（我们用 Nginx 作为示例）：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-comment"># 创建 Deployment</span>
kubectl create deployment nginx <span class="hljs-attr">--image</span>=nginx --replicas=<span class="hljs-number">2</span>

<span class="hljs-comment"># 等待 Pod Running</span>
kubectl get pods -l <span class="hljs-attr">app</span>=nginx
</code></pre>
<hr/>
<h2 data-id="heading-1">🔬 实验 1：创建 ClusterIP Service 并从集群内访问</h2>
<h3 data-id="heading-2">✅ 目标：验证 Service 能在集群内部负载均衡</h3>
<h4 data-id="heading-3">步骤：</h4>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-comment"># 1. 创建 ClusterIP Service</span>
kubectl expose deployment nginx <span class="hljs-attr">--port</span>=<span class="hljs-number">80</span> --target-port=<span class="hljs-number">80</span> --name=nginx-svc

<span class="hljs-comment"># 2. 查看 Service 和 Endpoints</span>
kubectl get svc nginx-svc
kubectl get endpoints nginx-svc  <span class="hljs-comment"># 应显示 2 个 Pod IP</span>

<span class="hljs-comment"># 3. 启动一个临时调试 Pod（busybox）</span>
kubectl run debug <span class="hljs-attr">--image</span>=busybox:<span class="hljs-number">1.28</span> -it --rm --restart=Never -- sh

<span class="hljs-comment"># 在 debug 容器内执行：</span>
/ <span class="hljs-comment"># wget -qO- http://nginx-svc</span>
/ <span class="hljs-comment"># wget -qO- http://nginx-svc</span>
</code></pre>
<h4 data-id="heading-4">✅ 预期结果：</h4>
<ul>
<li>每次请求可能返回不同 Pod 的欢迎页（虽然内容一样，但可通过日志区分）</li>
<li>证明 Service 做了负载均衡</li>
</ul>
<blockquote>
<p>💡 提示：你可以进入每个 Nginx Pod 添加唯一标识：</p>
<pre><code class="hljs language-css" lang="css">kubectl exec &lt;pod1&gt; -- sh -c 'echo "&lt;<span class="hljs-selector-tag">h1</span>&gt;Pod <span class="hljs-number">1</span>&lt;/<span class="hljs-selector-tag">h1</span>&gt;" &gt; /usr/share/nginx/<span class="hljs-selector-tag">html</span>/index<span class="hljs-selector-class">.html</span>'
kubectl exec &lt;pod2&gt; -- sh -c 'echo "&lt;<span class="hljs-selector-tag">h1</span>&gt;Pod <span class="hljs-number">2</span>&lt;/<span class="hljs-selector-tag">h1</span>&gt;" &gt; /usr/share/nginx/<span class="hljs-selector-tag">html</span>/index<span class="hljs-selector-class">.html</span>'
</code></pre>
<p>再 curl 就能看到轮流返回 Pod 1 / Pod 2！</p>
</blockquote>
<hr/>
<h2 data-id="heading-5">🔬 实验 2：验证 DNS 解析（Service 名称 → ClusterIP）</h2>
<h3 data-id="heading-6">✅ 目标：确认 CoreDNS 能正确解析 Service</h3>
<h4 data-id="heading-7">步骤：</h4>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-comment"># 进入 debug Pod（如果已退出，重新创建）</span>
kubectl run dns-test <span class="hljs-attr">--image</span>=busybox:<span class="hljs-number">1.28</span> -it --rm --restart=Never -- nslookup nginx-svc
</code></pre>
<h4 data-id="heading-8">✅ 预期输出：</h4>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">Server:</span>    <span class="hljs-number">10.96</span><span class="hljs-number">.0</span><span class="hljs-number">.10</span>      <span class="hljs-comment"># CoreDNS IP</span>
<span class="hljs-attr">Address 1:</span> <span class="hljs-number">10.96</span><span class="hljs-number">.0</span><span class="hljs-number">.10</span> <span class="hljs-string">kube-dns.kube-system.svc.cluster.local</span>

<span class="hljs-attr">Name:</span>      <span class="hljs-string">nginx-svc</span>
<span class="hljs-attr">Address 1:</span> <span class="hljs-number">10.96</span><span class="hljs-number">.123</span><span class="hljs-number">.45</span>     <span class="hljs-comment"># 这就是 Service 的 ClusterIP！</span>
</code></pre>
<blockquote>
<p>✅ 说明：<code>nginx-svc</code> 被成功解析为 ClusterIP</p>
</blockquote>
<h4 data-id="heading-9">扩展测试（完整 FQDN）：</h4>
<pre><code class="hljs language-arduino" lang="arduino">kubectl run dns-fqdn --image=busybox:<span class="hljs-number">1.28</span> -it --rm --restart=Never -- \
  nslookup nginx-svc.<span class="hljs-keyword">default</span>.svc.cluster.local
</code></pre>
<hr/>
<h2 data-id="heading-10">🔬 实验 3：创建 NodePort Service 并从集群外访问</h2>
<h3 data-id="heading-11">✅ 目标：验证外部流量能通过节点端口到达 Pod</h3>
<h4 data-id="heading-12">步骤：</h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 1. 创建 NodePort Service（自动分配端口）</span>
kubectl expose deployment nginx --port=80 --target-port=80 --<span class="hljs-built_in">type</span>=NodePort --name=nginx-np

<span class="hljs-comment"># 2. 查看分配的端口</span>
kubectl get svc nginx-np
<span class="hljs-comment"># 输出示例：nginx-np   NodePort   10.96.200.100   80:31234/TCP</span>
<span class="hljs-comment"># 记下 31234（你的端口可能不同）</span>

<span class="hljs-comment"># 3. 从你的本地电脑（或 master 节点 shell）访问</span>
curl http://localhost:31234          <span class="hljs-comment"># 如果你在 master 节点本机</span>
<span class="hljs-comment"># 或</span>
curl http://&lt;你的节点公网/内网IP&gt;:31234   <span class="hljs-comment"># 如 192.168.18.133:31234</span>
</code></pre>
<h4 data-id="heading-13">⚠️ 如果访问失败，检查：</h4>
<ul>
<li>防火墙是否放行端口（如 <code>sudo ufw allow 31234</code>）</li>
<li>节点安全组（云服务器需配置入站规则）</li>
</ul>
<h4 data-id="heading-14">✅ 预期结果：</h4>
<p>返回 Nginx 欢迎页，证明 <strong>外部 → NodePort → Service → Pod</strong> 链路打通。</p>
<hr/>
<h2 data-id="heading-15">🔬 实验 4：故意破坏 Service，观察故障现象</h2>
<h3 data-id="heading-16">✅ 目标：理解 Service 与 Pod 的解耦关系</h3>
<h4 data-id="heading-17">步骤：</h4>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-comment"># 1. 删除所有后端 Pod（Deployment 会自动重建）</span>
kubectl delete pods -l <span class="hljs-attr">app</span>=nginx

<span class="hljs-comment"># 2. 立即查看 Endpoints</span>
kubectl get endpoints nginx-svc  <span class="hljs-comment"># 应该为空（&lt;none&gt;）</span>

<span class="hljs-comment"># 3. 尝试访问 Service（从 debug Pod）</span>
kubectl run test-bad <span class="hljs-attr">--image</span>=curlimages/curl -it --rm --restart=Never -- \
  curl -m 3 http://nginx-svc
</code></pre>
<h4 data-id="heading-18">✅ 预期结果：</h4>
<ul>
<li>请求超时（<code>curl: (28) Connection timed out</code>）</li>
<li>说明：<strong>Service 存在 ≠ 后端可用</strong>，必须有匹配的 Pod</li>
</ul>
<blockquote>
<p>💡 这就是为什么监控要同时关注 <strong>Service</strong> 和 <strong>Pod Ready 状态</strong></p>
</blockquote>
<hr/>
<h2 data-id="heading-19">🔬 实验 5：跨命名空间调用 Service</h2>
<h3 data-id="heading-20">✅ 目标：验证 Service 的命名空间隔离与跨空间访问</h3>
<h4 data-id="heading-21">步骤：</h4>
<pre><code class="hljs language-arduino" lang="arduino"># <span class="hljs-number">1.</span> 创建新命名空间
kubectl create ns test-ns

# <span class="hljs-number">2.</span> 在 <span class="hljs-keyword">default</span> 命名空间保留 nginx-svc

# <span class="hljs-number">3.</span> 从 test-ns 中访问 <span class="hljs-keyword">default</span> 的 Service
kubectl run cross-ns --image=busybox:<span class="hljs-number">1.28</span> -n test-ns -it --rm --restart=Never -- \
  wget -qO- http:<span class="hljs-comment">//nginx-svc.default.svc.cluster.local</span>
</code></pre>
<h4 data-id="heading-22">✅ 关键点：</h4>
<ul>
<li>必须使用 <strong>完整 DNS 名称</strong>：<code>&lt;service&gt;.&lt;namespace&gt;.svc.cluster.local</code></li>
<li>不能只写 <code>nginx-svc</code>（因为当前命名空间是 <code>test-ns</code>）</li>
</ul>
<h4 data-id="heading-23">✅ 预期结果：</h4>
<p>成功返回 Nginx 页面，证明跨命名空间通信可行。</p>
<hr/>
<h2 data-id="heading-24">🛠️ 附加：常用诊断命令速查表</h2>





























<table><thead><tr><th>场景</th><th>命令</th></tr></thead><tbody><tr><td>查看 Service 详情</td><td><code>kubectl describe svc &lt;name&gt;</code></td></tr><tr><td>查看后端 Pod 列表</td><td><code>kubectl get endpoints &lt;svc-name&gt;</code></td></tr><tr><td>测试连通性（集群内）</td><td><code>kubectl run -it --rm debug --image=busybox --restart=Never -- telnet &lt;svc&gt; 80</code></td></tr><tr><td>查看 kube-proxy 日志</td><td><code>kubectl logs -n kube-system -l k8s-app=kube-proxy</code></td></tr><tr><td>检查防火墙（Linux）</td><td><code>sudo ufw status</code> 或 <code>sudo iptables -L</code></td></tr></tbody></table>
<hr/>
<h2 data-id="heading-25">✅ 总结：验证 Service 的核心思路</h2>
<ol>
<li><strong>查配置</strong>：<code>kubectl get/describe svc</code></li>
<li><strong>查后端</strong>：<code>kubectl get endpoints</code>（必须非空！）</li>
<li><strong>集群内测</strong>：用临时 Pod curl/telnet</li>
<li><strong>集群外测</strong>：NodePort / LoadBalancer + 防火墙检查</li>
<li><strong>看 DNS</strong>：<code>nslookup &lt;svc-name&gt;</code></li>
</ol>
<blockquote>
<p>💡 <strong>记住：Service 是虚拟 IP，真正干活的是 Endpoints（Pod 列表）！</strong></p>
</blockquote>
<hr/>
<p>现在就去你的 <code>k8s-master-node</code> 上动手试试吧！每完成一个实验，你对 K8s 网络的理解就更深一层。如果某个实验卡住了，欢迎贴出你的命令和输出，我可以帮你分析！🚀</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[大量异步并发请求控制并发解决方案]]></title>    <link>https://juejin.cn/post/7578714759337443328</link>    <guid>https://juejin.cn/post/7578714759337443328</guid>    <pubDate>2025-12-01T15:51:37.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7578714759337443328" data-draft-id="7578724773993398298" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="大量异步并发请求控制并发解决方案"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2025-12-01T15:51:37.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="veneno"/> <meta itemprop="url" content="https://juejin.cn/user/1381457252330183"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            大量异步并发请求控制并发解决方案
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1381457252330183/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    veneno
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-01T15:51:37.000Z" title="Mon Dec 01 2025 15:51:37 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-01
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>实现思路：</p>
<p>可以使用 Promise 和异步函数。手动实现一个同步队列</p>
<p>测试数据</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> tasks = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">88</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">_, i</span>) =&gt;</span> <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> {
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-title function_">resolve</span>(i)
    }, <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">1000</span>)
  })
})
</code></pre>
<p>核心代码</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">limitRequest</span>(<span class="hljs-params">tasks, limit</span>) {
  <span class="hljs-keyword">const</span> queue = []
  <span class="hljs-keyword">let</span> runingCount = <span class="hljs-number">0</span>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">enqueque</span>(<span class="hljs-params">task</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
      queue.<span class="hljs-title function_">push</span>({
        task,
        resolve,
        reject,
      })
      <span class="hljs-title function_">run</span>()
    })
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">while</span> (queue.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span> &amp;&amp; runingCount &lt; limit) {
      runingCount++
      <span class="hljs-keyword">const</span> { task, resolve, reject } = queue.<span class="hljs-title function_">shift</span>()
      <span class="hljs-title function_">task</span>()
        .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> {<span class="hljs-title function_">resolve</span>(value);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value)})
        .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> <span class="hljs-title function_">reject</span>(err))
        .<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> {
          runingCount--
          <span class="hljs-title function_">run</span>()
        })
    }
  }

  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(tasks.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">task</span>) =&gt;</span> <span class="hljs-title function_">enqueque</span>(task)))
}
</code></pre>
<p>测试代码</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">await</span> <span class="hljs-title function_">limitRequest</span>(tasks, <span class="hljs-number">10</span>))
</code></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Reactor网络模型深度解析：从并发困境说起]]></title>    <link>https://juejin.cn/post/7578714735307636762</link>    <guid>https://juejin.cn/post/7578714735307636762</guid>    <pubDate>2025-12-01T14:12:19.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7578714735307636762" data-draft-id="7578714735307620378" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Reactor网络模型深度解析：从并发困境说起"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2025-12-01T14:12:19.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="码事漫谈"/> <meta itemprop="url" content="https://juejin.cn/user/1972974802965230"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Reactor网络模型深度解析：从并发困境说起
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1972974802965230/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    码事漫谈
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-01T14:12:19.000Z" title="Mon Dec 01 2025 14:12:19 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-01
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读12分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>本文深入探讨Reactor网络模型的核心机制，解答高并发场景下的关键问题，揭示现代高性能服务器的架构奥秘。通过对比分析、原理阐述和实战代码，带您彻底理解Reactor如何优雅应对海量并发请求。</p>
</blockquote>
<h2 data-id="heading-0"><strong>并发困难</strong></h2>
<p>想象这样一个场景：你的电商网站正在举办"双11"大促，每秒有10万用户同时点击"立即购买"。传统的"一线程一连接"架构瞬间崩溃——不是内存耗尽，就是CPU被上下文切换拖垮。</p>
<p>这正是我在职业生涯早期遭遇的真实困境。直到我理解了<strong>Reactor模式</strong>，才发现原来高性能网络编程可以如此优雅。</p>
<h2 data-id="heading-1"><strong>第一章：传统并发模型的崩溃边缘</strong></h2>
<h3 data-id="heading-2"><strong>1.1 阻塞I/O的致命缺陷</strong></h3>
<p>让我们从最直观的代码开始：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// 经典的多线程服务器 - 每个连接一个线程</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handle_client</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd)</span> </span>{
    <span class="hljs-type">char</span> buffer[<span class="hljs-number">1024</span>];
    <span class="hljs-comment">// 阻塞点：数据未到达时线程休眠</span>
    <span class="hljs-type">int</span> n = <span class="hljs-built_in">recv</span>(sockfd, buffer, <span class="hljs-built_in">sizeof</span>(buffer), <span class="hljs-number">0</span>);
    <span class="hljs-comment">// 线程被唤醒，处理业务</span>
    <span class="hljs-built_in">process_request</span>(buffer);
    <span class="hljs-built_in">send</span>(sockfd, response, <span class="hljs-built_in">strlen</span>(response), <span class="hljs-number">0</span>);
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-type">int</span> server_fd = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);
    <span class="hljs-comment">// ... bind, listen</span>
    
    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) {
        <span class="hljs-type">int</span> client_fd = <span class="hljs-built_in">accept</span>(server_fd, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);
        <span class="hljs-comment">// 致命的资源消耗：每个线程需要8MB栈空间</span>
        <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(handle_client, client_fd)</span></span>;
        t.<span class="hljs-built_in">detach</span>();
    }
}
</code></pre>
<p><strong>问题分析</strong>：</p>
<ul>
<li>连接数增长 → 线程数线性增长</li>
<li>1000个连接 ≈ 8GB内存（仅线程栈）</li>
<li>上下文切换开销呈指数级上升</li>
<li>大部分线程处于阻塞等待状态（资源浪费）</li>
</ul>
<h3 data-id="heading-3"><strong>1.2 C10K问题的挑战</strong></h3>
<p>2000年提出的C10K（并发1万连接）问题，暴露了传统模型的根本缺陷：</p>

























<table><thead><tr><th>资源类型</th><th>传统模型消耗</th><th>物理限制</th></tr></thead><tbody><tr><td>内存</td><td>10,000 × 8MB = 80GB</td><td>服务器通常只有128GB</td></tr><tr><td>文件描述符</td><td>10,000</td><td>系统默认限制1024</td></tr><tr><td>CPU时间</td><td>大量用于线程切换</td><td>实际业务处理占比低</td></tr></tbody></table>
<h2 data-id="heading-4"><strong>第二章：Reactor的架构革命</strong></h2>
<h3 data-id="heading-5"><strong>2.1 核心思想：事件驱动与状态机</strong></h3>
<p>Reactor模式的核心转变：<strong>从"主动轮询"到"被动通知"</strong>。</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// 传统模型：主动询问每个连接</span>
<span class="hljs-keyword">for</span>(each connection) {
    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">has_data</span>(connection)) {  <span class="hljs-comment">// 主动检查</span>
        <span class="hljs-built_in">process</span>(connection);
    }
}

<span class="hljs-comment">// Reactor模型：等待事件通知</span>
<span class="hljs-keyword">while</span>(events = <span class="hljs-built_in">wait_for_events</span>()) {  <span class="hljs-comment">// 被动等待</span>
    <span class="hljs-keyword">for</span>(each event in events) {
        <span class="hljs-built_in">handle_event</span>(event);  <span class="hljs-comment">// 事件触发处理</span>
    }
}
</code></pre>
<h3 data-id="heading-6"><strong>2.2 系统调用：从select到epoll的演进</strong></h3>
<p><strong>第一代：select/poll的局限</strong></p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">select</span><span class="hljs-params">(<span class="hljs-type">int</span> nfds, fd_set *readfds, fd_set *writefds, 
           fd_set *exceptfds, <span class="hljs-keyword">struct</span> timeval *timeout)</span></span>;
</code></pre>
<ul>
<li>每次调用需要传递全部fd集合（用户态→内核态拷贝）</li>
<li>内核线性扫描所有fd（O(n)复杂度）</li>
<li>fd数量限制（通常1024）</li>
</ul>
<p><strong>第二代：epoll的突破</strong></p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// 1. 创建epoll实例</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">epoll_create</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span></span>;

<span class="hljs-comment">// 2. 注册/修改fd兴趣</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">epoll_ctl</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd, <span class="hljs-type">int</span> op, <span class="hljs-type">int</span> fd, <span class="hljs-keyword">struct</span> epoll_event *event)</span></span>;

<span class="hljs-comment">// 3. 等待事件</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">epoll_wait</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd, <span class="hljs-keyword">struct</span> epoll_event *events, 
               <span class="hljs-type">int</span> maxevents, <span class="hljs-type">int</span> timeout)</span></span>;
</code></pre>
<p><strong>epoll的核心优势</strong>：</p>
<ol>
<li><strong>红黑树存储fd</strong>：高效增删改（O(log n)）</li>
<li><strong>就绪列表</strong>：事件触发时加入列表</li>
<li><strong>mmap共享内存</strong>：避免用户态-内核态数据拷贝</li>
<li><strong>边缘触发(ET)</strong>：减少事件通知次数</li>
</ol>
<h3 data-id="heading-7"><strong>2.3 Reactor的完整架构</strong></h3>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// Reactor模式四层架构</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ReactorArchitecture</span> {
<span class="hljs-keyword">private</span>:
    <span class="hljs-comment">// 1. 事件多路分发器（Demultiplexer）</span>
    EventDemultiplexer* demux;
    
    <span class="hljs-comment">// 2. 事件处理器注册表（Event Handler Registry）</span>
    std::map&lt;Handle, EventHandler*&gt; handlers;
    
    <span class="hljs-comment">// 3. 事件循环（Event Loop）</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">event_loop</span><span class="hljs-params">()</span></span>;
    
    <span class="hljs-comment">// 4. 具体事件处理器（Concrete Event Handlers）</span>
    <span class="hljs-keyword">class</span> <span class="hljs-title class_">AcceptorHandler</span> : <span class="hljs-keyword">public</span> EventHandler {...};
    <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConnectionHandler</span> : <span class="hljs-keyword">public</span> EventHandler {...};
};

<span class="hljs-comment">// 事件循环核心算法</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Reactor::event_loop</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">while</span>(!stop) {
        <span class="hljs-comment">// 等待事件发生（毫秒级甚至纳秒级）</span>
        <span class="hljs-keyword">auto</span> events = demux-&gt;<span class="hljs-built_in">select</span>(timeout);
        
        <span class="hljs-comment">// 分发事件到对应处理器</span>
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; event : events) {
            EventHandler* handler = <span class="hljs-built_in">get_handler</span>(event.handle);
            <span class="hljs-keyword">if</span>(handler) {
                handler-&gt;<span class="hljs-built_in">handle_event</span>(event.type);
            }
        }
        
        <span class="hljs-comment">// 处理定时器事件</span>
        <span class="hljs-built_in">process_timers</span>();
        
        <span class="hljs-comment">// 处理异步任务</span>
        <span class="hljs-built_in">process_async_tasks</span>();
    }
}
</code></pre>
<h2 data-id="heading-8"><strong>第三章：深入关键问题：并发消息处理机制</strong></h2>
<h3 data-id="heading-9"><strong>3.1 问题的本质：Reactor如何处理"同时到达"的消息？</strong></h3>
<p>这是最常见的误解点。我们需要区分两个概念：</p>
<ul>
<li><strong>物理同时</strong>：多个数据包在同一纳秒到达网卡</li>
<li><strong>逻辑同时</strong>：Reactor在单次事件循环中处理多个就绪事件</li>
</ul>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// 实际的处理时序</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Reactor::handle_events</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// 单次epoll_wait可能返回多个就绪socket</span>
    <span class="hljs-type">int</span> n = <span class="hljs-built_in">epoll_wait</span>(epfd, events, <span class="hljs-number">64</span>, <span class="hljs-number">-1</span>);
    
    <span class="hljs-comment">// 这些socket的数据"几乎同时"到达内核缓冲区</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
        <span class="hljs-comment">// 但处理是顺序的！关键在此！</span>
        <span class="hljs-built_in">handle_socket</span>(events[i].data.fd);
    }
}
</code></pre>
<h3 data-id="heading-10"><strong>3.2 内核缓冲区的关键作用</strong></h3>
<pre><code class="hljs language-mermaid" lang="mermaid">graph TB
    subgraph "客户端同时发送"
        C1[客户端1] --&gt;|数据包1| NIC[网卡]
        C2[客户端2] --&gt;|数据包2| NIC
        C3[客户端3] --&gt;|数据包3| NIC
    end
    
    subgraph "内核空间"
        NIC --&gt;|DMA拷贝| Memory[内核内存]
        Memory --&gt; TCP[TCP协议栈]
        TCP --&gt; B1[Socket1缓冲区]
        TCP --&gt; B2[Socket2缓冲区]
        TCP --&gt; B3[Socket3缓冲区]
    end
    
    subgraph "Reactor处理"
        B1 --&gt;|epoll标记可读| E[epoll就绪列表]
        B2 --&gt;|epoll标记可读| E
        B3 --&gt;|epoll标记可读| E
        E --&gt; R[Reactor顺序读取]
    end
    
    R --&gt; P1[处理Socket1]
    R --&gt; P2[处理Socket2]
    R --&gt; P3[处理Socket3]
</code></pre>
<p><strong>关键理解</strong>：</p>
<ol>
<li>数据包到达网卡后，由DMA直接写入内存</li>
<li>内核TCP协议栈处理，存入对应socket的接收缓冲区</li>
<li>epoll将该socket标记为"可读"</li>
<li>Reactor下次<code>epoll_wait</code>时获知多个socket就绪</li>
<li><strong>虽然是顺序处理，但每个recv都是非阻塞的，立即返回</strong></li>
</ol>
<h3 data-id="heading-11"><strong>3.3 性能瓶颈分析与解决方案</strong></h3>
<p><strong>场景分析</strong>：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// 假设有3个客户端几乎同时发送数据</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handle_socket</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span> </span>{
    <span class="hljs-comment">// 步骤1：读取数据（很快，微秒级）</span>
    <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>];
    <span class="hljs-type">int</span> n = <span class="hljs-built_in">recv</span>(fd, buf, <span class="hljs-built_in">sizeof</span>(buf), <span class="hljs-number">0</span>);
    
    <span class="hljs-comment">// 步骤2：业务处理（可能很慢，毫秒级）</span>
    std::string result = <span class="hljs-built_in">expensive_processing</span>(buf, n);
    
    <span class="hljs-comment">// 步骤3：发送响应</span>
    <span class="hljs-built_in">send</span>(fd, result.<span class="hljs-built_in">c_str</span>(), result.<span class="hljs-built_in">length</span>(), <span class="hljs-number">0</span>);
}
</code></pre>
<p><strong>处理时间线</strong>：</p>
<pre><code class="hljs language-ini" lang="ini">时间轴：0ms     1ms     2ms     3ms     4ms     5ms
Socket1: <span class="hljs-section">[recv]</span><span class="hljs-section">[proc...................]</span><span class="hljs-section">[send]</span>
Socket2:        等待...<span class="hljs-section">[recv]</span><span class="hljs-section">[proc...................]</span><span class="hljs-section">[send]</span>
Socket3:                等待...........<span class="hljs-section">[recv]</span><span class="hljs-section">[proc...................]</span><span class="hljs-section">[send]</span>
</code></pre>
<p><strong>问题</strong>：Socket2、3需要等待Socket1的业务处理完成！</p>
<p><strong>解决方案：Reactor + 线程池</strong></p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// 优化的Reactor架构</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">HighPerformanceReactor</span> {
<span class="hljs-keyword">private</span>:
    <span class="hljs-comment">// I/O线程（主Reactor）</span>
    std::thread io_thread;
    
    <span class="hljs-comment">// 业务线程池</span>
    ThreadPool worker_pool;
    
    <span class="hljs-comment">// 用于线程间通信的任务队列</span>
    moodycamel::ConcurrentQueue&lt;IORequest&gt; request_queue;
    
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handle_read_event</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span> </span>{
        <span class="hljs-comment">// 1. I/O线程：快速读取数据</span>
        IORequest req = <span class="hljs-built_in">read_data_nonblocking</span>(fd);
        
        <span class="hljs-comment">// 2. 提交到业务线程池</span>
        worker_pool.<span class="hljs-built_in">enqueue</span>([<span class="hljs-keyword">this</span>, req]() {
            <span class="hljs-comment">// 3. Worker线程：处理耗时业务</span>
            ProcessResult result = <span class="hljs-built_in">process_business</span>(req);
            
            <span class="hljs-comment">// 4. 将写任务交回I/O线程</span>
            io_thread.<span class="hljs-built_in">post</span>([fd, result]() {
                <span class="hljs-built_in">send_response</span>(fd, result);
            });
        });
        
        <span class="hljs-comment">// I/O线程立即返回，继续处理其他事件</span>
    }
};
</code></pre>
<p><strong>优化后的时间线</strong>：</p>
<pre><code class="hljs language-less" lang="less"><span class="hljs-selector-tag">I</span>/<span class="hljs-selector-tag">O</span>线程: <span class="hljs-selector-attr">[recv1]</span><span class="hljs-selector-attr">[recv2]</span><span class="hljs-selector-attr">[recv3]</span><span class="hljs-selector-attr">[send1]</span><span class="hljs-selector-attr">[send2]</span><span class="hljs-selector-attr">[send3]</span>
<span class="hljs-selector-tag">Worker1</span>:         <span class="hljs-selector-attr">[proc1...........]</span>
<span class="hljs-selector-tag">Worker2</span>:         <span class="hljs-selector-attr">[proc2...........]</span>
<span class="hljs-selector-tag">Worker3</span>:         <span class="hljs-selector-attr">[proc3...........]</span>
</code></pre>
<h2 data-id="heading-12"><strong>第四章：工业级Reactor实现细节</strong></h2>
<h3 data-id="heading-13"><strong>4.1 完整的事件状态机</strong></h3>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">ConnectionState</span> {
    ACCEPTING,      <span class="hljs-comment">// 接受连接</span>
    READING,        <span class="hljs-comment">// 读取数据</span>
    PROCESSING,     <span class="hljs-comment">// 处理中（可能在Worker线程）</span>
    WRITING,        <span class="hljs-comment">// 写入数据</span>
    CLOSING         <span class="hljs-comment">// 关闭连接</span>
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Connection</span> {
<span class="hljs-keyword">private</span>:
    <span class="hljs-type">int</span> fd;
    ConnectionState state;
    std::vector&lt;<span class="hljs-type">char</span>&gt; input_buffer;
    std::vector&lt;<span class="hljs-type">char</span>&gt; output_buffer;
    <span class="hljs-type">size_t</span> bytes_to_write;
    
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handle_event</span><span class="hljs-params">(EventType type)</span> </span>{
        <span class="hljs-keyword">switch</span>(state) {
            <span class="hljs-keyword">case</span> ConnectionState::READING:
                <span class="hljs-keyword">if</span>(type == EventType::READ) {
                    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">read_data</span>() &gt; <span class="hljs-number">0</span>) {
                        <span class="hljs-comment">// 数据读够一个完整请求</span>
                        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">parse_complete</span>()) {
                            state = ConnectionState::PROCESSING;
                            <span class="hljs-built_in">submit_to_thread_pool</span>();
                        }
                    } <span class="hljs-keyword">else</span> {
                        <span class="hljs-comment">// 连接关闭或错误</span>
                        state = ConnectionState::CLOSING;
                    }
                }
                <span class="hljs-keyword">break</span>;
                
            <span class="hljs-keyword">case</span> ConnectionState::WRITING:
                <span class="hljs-keyword">if</span>(type == EventType::WRITE) {
                    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">write_data</span>() == output_buffer.<span class="hljs-built_in">size</span>()) {
                        <span class="hljs-comment">// 数据全部发送完成</span>
                        <span class="hljs-keyword">if</span>(keep_alive) {
                            state = ConnectionState::READING;
                            <span class="hljs-built_in">reset_for_next_request</span>();
                        } <span class="hljs-keyword">else</span> {
                            state = ConnectionState::CLOSING;
                        }
                    }
                }
                <span class="hljs-keyword">break</span>;
                
            <span class="hljs-comment">// ... 其他状态处理</span>
        }
    }
};
</code></pre>
<h3 data-id="heading-14"><strong>4.2 内存管理优化</strong></h3>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// 对象池避免频繁new/delete</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ConnectionPool</span> {
<span class="hljs-keyword">private</span>:
    std::vector&lt;T*&gt; free_list;
    std::mutex lock;
    
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">T* <span class="hljs-title">acquire</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">guard</span><span class="hljs-params">(lock)</span></span>;
        <span class="hljs-keyword">if</span>(!free_list.<span class="hljs-built_in">empty</span>()) {
            T* obj = free_list.<span class="hljs-built_in">back</span>();
            free_list.<span class="hljs-built_in">pop_back</span>();
            <span class="hljs-keyword">return</span> obj;
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">T</span>();
    }
    
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">release</span><span class="hljs-params">(T* obj)</span> </span>{
        obj-&gt;<span class="hljs-built_in">reset</span>();  <span class="hljs-comment">// 重置状态而非销毁</span>
        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">guard</span><span class="hljs-params">(lock)</span></span>;
        free_list.<span class="hljs-built_in">push_back</span>(obj);
    }
};

<span class="hljs-comment">// 缓冲区设计</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Buffer</span> {
<span class="hljs-keyword">private</span>:
    <span class="hljs-comment">// 使用连续内存块，避免小内存分配</span>
    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">size_t</span> INITIAL_SIZE = <span class="hljs-number">1024</span>;
    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">size_t</span> MAX_SIZE = <span class="hljs-number">65536</span>;
    
    std::unique_ptr&lt;<span class="hljs-type">char</span>[]&gt; data;
    <span class="hljs-type">size_t</span> capacity;
    <span class="hljs-type">size_t</span> read_index;
    <span class="hljs-type">size_t</span> write_index;
    
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// 确保容量（指数增长策略）</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ensure_capacity</span><span class="hljs-params">(<span class="hljs-type">size_t</span> need)</span> </span>{
        <span class="hljs-keyword">if</span>(write_index + need &lt;= capacity) <span class="hljs-keyword">return</span>;
        
        <span class="hljs-type">size_t</span> new_capacity = std::<span class="hljs-built_in">max</span>(capacity * <span class="hljs-number">2</span>, 
                                      write_index - read_index + need);
        new_capacity = std::<span class="hljs-built_in">min</span>(new_capacity, MAX_SIZE);
        
        <span class="hljs-keyword">auto</span> new_data = std::<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">char</span>[]&gt;(new_capacity);
        <span class="hljs-comment">// 复制有效数据</span>
        std::<span class="hljs-built_in">copy</span>(data.<span class="hljs-built_in">get</span>() + read_index, 
                  data.<span class="hljs-built_in">get</span>() + write_index, 
                  new_data.<span class="hljs-built_in">get</span>());
        write_index -= read_index;
        read_index = <span class="hljs-number">0</span>;
        data = std::<span class="hljs-built_in">move</span>(new_data);
        capacity = new_capacity;
    }
};
</code></pre>
<h3 data-id="heading-15"><strong>4.3 性能调优参数</strong></h3>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// Linux内核参数调优</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tune_system_parameters</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// 1. 文件描述符限制</span>
    <span class="hljs-built_in">system</span>(<span class="hljs-string">"ulimit -n 1000000"</span>);
    
    <span class="hljs-comment">// 2. TCP参数优化</span>
    <span class="hljs-type">int</span> fd = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);
    
    <span class="hljs-comment">// 启用TCP_NODELAY（禁用Nagle算法）</span>
    <span class="hljs-type">int</span> flag = <span class="hljs-number">1</span>;
    <span class="hljs-built_in">setsockopt</span>(fd, IPPROTO_TCP, TCP_NODELAY, &amp;flag, <span class="hljs-built_in">sizeof</span>(flag));
    
    <span class="hljs-comment">// 增大接收缓冲区</span>
    <span class="hljs-type">int</span> recv_buf_size = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;  <span class="hljs-comment">// 1MB</span>
    <span class="hljs-built_in">setsockopt</span>(fd, SOL_SOCKET, SO_RCVBUF, 
               &amp;recv_buf_size, <span class="hljs-built_in">sizeof</span>(recv_buf_size));
    
    <span class="hljs-comment">// 启用SO_REUSEPORT（Linux 3.9+）</span>
    <span class="hljs-built_in">setsockopt</span>(fd, SOL_SOCKET, SO_REUSEPORT, &amp;flag, <span class="hljs-built_in">sizeof</span>(flag));
    
    <span class="hljs-comment">// 3. 网卡队列调整</span>
    <span class="hljs-comment">// ethtool -G eth0 rx 4096 tx 4096</span>
}

<span class="hljs-comment">// Reactor内部参数</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">ReactorConfig</span> {
    <span class="hljs-type">size_t</span> max_connections = <span class="hljs-number">1000000</span>;      <span class="hljs-comment">// 最大连接数</span>
    <span class="hljs-type">size_t</span> io_threads = <span class="hljs-number">1</span>;                 <span class="hljs-comment">// I/O线程数（主从Reactor）</span>
    <span class="hljs-type">size_t</span> worker_threads = std::thread::<span class="hljs-built_in">hardware_concurrency</span>();
    <span class="hljs-type">size_t</span> task_queue_size = <span class="hljs-number">10000</span>;        <span class="hljs-comment">// 任务队列大小</span>
    <span class="hljs-type">size_t</span> buffer_size = <span class="hljs-number">16384</span>;            <span class="hljs-comment">// 每个连接的缓冲区大小</span>
    <span class="hljs-type">int</span> epoll_timeout_ms = <span class="hljs-number">1</span>;              <span class="hljs-comment">// epoll_wait超时时间</span>
    <span class="hljs-type">bool</span> use_et_mode = <span class="hljs-literal">true</span>;               <span class="hljs-comment">// 使用边缘触发</span>
};
</code></pre>
<h2 data-id="heading-16"><strong>第五章：现实世界的挑战与解决方案</strong></h2>
<h3 data-id="heading-17"><strong>5.1 惊群问题（Thundering Herd）</strong></h3>
<p><strong>问题</strong>：多个进程/线程同时监听同一个端口，当新连接到达时全部被唤醒。</p>
<p><strong>解决方案</strong>：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// Linux 3.9+ 的SO_REUSEPORT</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">setup_reuseport</span><span class="hljs-params">(<span class="hljs-type">int</span> port)</span> </span>{
    <span class="hljs-type">int</span> fd = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);
    
    <span class="hljs-type">int</span> reuse = <span class="hljs-number">1</span>;
    <span class="hljs-built_in">setsockopt</span>(fd, SOL_SOCKET, SO_REUSEADDR, &amp;reuse, <span class="hljs-built_in">sizeof</span>(reuse));
    <span class="hljs-built_in">setsockopt</span>(fd, SOL_SOCKET, SO_REUSEPORT, &amp;reuse, <span class="hljs-built_in">sizeof</span>(reuse));
    
    <span class="hljs-comment">// 内核会自动分配连接给不同的监听socket</span>
    <span class="hljs-keyword">return</span> fd;
}

<span class="hljs-comment">// 或者使用accept锁</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">AcceptMutex</span> {
<span class="hljs-keyword">private</span>:
    std::atomic&lt;<span class="hljs-type">bool</span>&gt; lock{<span class="hljs-literal">false</span>};
    
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">try_lock</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> !lock.<span class="hljs-built_in">exchange</span>(<span class="hljs-literal">true</span>, std::memory_order_acquire);
    }
    
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>{
        lock.<span class="hljs-built_in">store</span>(<span class="hljs-literal">false</span>, std::memory_order_release);
    }
};
</code></pre>
<h3 data-id="heading-18"><strong>5.2 长连接与心跳机制</strong></h3>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConnectionManager</span> {
<span class="hljs-keyword">private</span>:
    std::unordered_map&lt;<span class="hljs-type">int</span>, std::shared_ptr&lt;Connection&gt;&gt; connections;
    std::priority_queue&lt;HeartbeatCheck&gt; heartbeat_queue;
    
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">check_heartbeats</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">auto</span> now = std::chrono::steady_clock::<span class="hljs-built_in">now</span>();
        
        <span class="hljs-keyword">while</span>(!heartbeat_queue.<span class="hljs-built_in">empty</span>() &amp;&amp; 
              heartbeat_queue.<span class="hljs-built_in">top</span>().expiry_time &lt; now) {
            <span class="hljs-keyword">auto</span> conn = heartbeat_queue.<span class="hljs-built_in">top</span>().connection;
            heartbeat_queue.<span class="hljs-built_in">pop</span>();
            
            <span class="hljs-keyword">if</span>(conn-&gt;last_active + HEARTBEAT_TIMEOUT &lt; now) {
                <span class="hljs-comment">// 发送心跳包</span>
                <span class="hljs-built_in">send_heartbeat</span>(conn-&gt;fd);
                
                <span class="hljs-comment">// 重新加入队列，等待响应</span>
                heartbeat_queue.<span class="hljs-built_in">push</span>({
                    now + HEARTBEAT_INTERVAL,
                    conn
                });
            }
        }
    }
};
</code></pre>
<h3 data-id="heading-19"><strong>5.3 流量控制与背压（Backpressure）</strong></h3>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FlowController</span> {
<span class="hljs-keyword">private</span>:
    std::atomic&lt;<span class="hljs-type">size_t</span>&gt; current_connections{<span class="hljs-number">0</span>};
    std::atomic&lt;<span class="hljs-type">size_t</span>&gt; request_rate{<span class="hljs-number">0</span>};
    <span class="hljs-type">size_t</span> max_connections;
    <span class="hljs-type">size_t</span> max_request_rate;
    
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">should_accept_new_connection</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-type">size_t</span> conns = current_connections.<span class="hljs-built_in">load</span>();
        <span class="hljs-keyword">if</span>(conns &gt;= max_connections * <span class="hljs-number">0.9</span>) {
            <span class="hljs-comment">// 连接数接近上限，开始限流</span>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
        current_connections.<span class="hljs-built_in">fetch_add</span>(<span class="hljs-number">1</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
    
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">should_process_request</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-type">size_t</span> rate = request_rate.<span class="hljs-built_in">load</span>();
        <span class="hljs-keyword">if</span>(rate &gt; max_request_rate) {
            <span class="hljs-comment">// 返回429 Too Many Requests</span>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
        request_rate.<span class="hljs-built_in">fetch_add</span>(<span class="hljs-number">1</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
    
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">request_completed</span><span class="hljs-params">()</span> </span>{
        request_rate.<span class="hljs-built_in">fetch_sub</span>(<span class="hljs-number">1</span>);
    }
};
</code></pre>
<h2 data-id="heading-20"><strong>第六章：性能对比与基准测试</strong></h2>
<h3 data-id="heading-21"><strong>6.1 不同模型性能对比</strong></h3>






















































<table><thead><tr><th>指标</th><th>多线程阻塞I/O</th><th>单线程Reactor</th><th>Reactor+线程池</th><th>多Reactor</th></tr></thead><tbody><tr><td>最大连接数</td><td>~1000</td><td>10万+</td><td>10万+</td><td>100万+</td></tr><tr><td>QPS（echo）</td><td>5,000</td><td>50,000</td><td>50,000</td><td>200,000</td></tr><tr><td>QPS（10ms业务）</td><td>100</td><td>100</td><td>10,000</td><td>40,000</td></tr><tr><td>内存使用</td><td>高</td><td>极低</td><td>低</td><td>中等</td></tr><tr><td>编程复杂度</td><td>简单</td><td>中等</td><td>复杂</td><td>复杂</td></tr><tr><td>适用场景</td><td>低并发</td><td>高并发I/O</td><td>通用</td><td>极致性能</td></tr></tbody></table>
<h3 data-id="heading-22"><strong>6.2 实际基准测试数据</strong></h3>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// 使用wrk进行压力测试</span>
<span class="hljs-comment">// wrk -t12 -c1000 -d30s http://localhost:8080/</span>

<span class="hljs-comment">// 测试结果对比</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">BenchmarkResult</span> {
    std::string model;
    <span class="hljs-type">int</span> connections;
    <span class="hljs-type">int</span> threads;
    <span class="hljs-type">double</span> requests_per_second;
    <span class="hljs-type">double</span> latency_avg_ms;
    <span class="hljs-type">double</span> latency_max_ms;
    
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{
        std::cout &lt;&lt; std::format(
            <span class="hljs-string">"Model: {}\n"</span>
            <span class="hljs-string">"Connections: {}\n"</span>
            <span class="hljs-string">"RPS: {:.1f}\n"</span>
            <span class="hljs-string">"Latency Avg: {:.2f}ms\n"</span>
            <span class="hljs-string">"Latency Max: {:.2f}ms\n\n"</span>,
            model, connections, requests_per_second,
            latency_avg_ms, latency_max_ms
        );
    }
};

<span class="hljs-comment">// 示例数据</span>
std::vector&lt;BenchmarkResult&gt; results = {
    {<span class="hljs-string">"Thread-per-connection"</span>, <span class="hljs-number">1000</span>, <span class="hljs-number">1000</span>, <span class="hljs-number">4800.5</span>, <span class="hljs-number">12.3</span>, <span class="hljs-number">210.5</span>},
    {<span class="hljs-string">"Single Reactor"</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">1</span>, <span class="hljs-number">52300.2</span>, <span class="hljs-number">1.2</span>, <span class="hljs-number">15.8</span>},
    {<span class="hljs-string">"Reactor+ThreadPool"</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">8</span>, <span class="hljs-number">49800.7</span>, <span class="hljs-number">2.5</span>, <span class="hljs-number">32.4</span>},
    {<span class="hljs-string">"Multi-Reactor"</span>, <span class="hljs-number">100000</span>, <span class="hljs-number">4</span>, <span class="hljs-number">187600.4</span>, <span class="hljs-number">0.8</span>, <span class="hljs-number">12.7</span>}
};
</code></pre>
<h2 data-id="heading-23"><strong>第七章：现代演进与未来趋势</strong></h2>
<h3 data-id="heading-24"><strong>7.1 从Reactor到Proactor</strong></h3>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// Windows IOCP（完成端口）示例</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ProactorServer</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// 创建IOCP完成端口</span>
        HANDLE iocp = <span class="hljs-built_in">CreateIoCompletionPort</span>(INVALID_HANDLE_VALUE, 
                                            <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
        
        <span class="hljs-comment">// 投递异步操作</span>
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) {
            OVERLAPPED* overlapped = <span class="hljs-built_in">create_overlapped</span>();
            <span class="hljs-built_in">WSARecv</span>(socket, &amp;buffer, <span class="hljs-number">1</span>, &amp;bytes_recvd, 
                   &amp;flags, overlapped, <span class="hljs-literal">NULL</span>);
        }
        
        <span class="hljs-comment">// 等待完成通知</span>
        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) {
            DWORD bytes_transferred;
            ULONG_PTR completion_key;
            OVERLAPPED* overlapped;
            
            <span class="hljs-built_in">GetQueuedCompletionStatus</span>(iocp, &amp;bytes_transferred,
                                     &amp;completion_key, &amp;overlapped, INFINITE);
            
            <span class="hljs-comment">// 操作已完成，直接处理结果</span>
            <span class="hljs-built_in">process_completion</span>(completion_key, bytes_transferred, overlapped);
        }
    }
};
</code></pre>
<h3 data-id="heading-25"><strong>7.2 C++20协程与io_uring</strong></h3>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// 使用C++20协程的异步服务器</span>
<span class="hljs-function">async_task&lt;<span class="hljs-type">void</span>&gt; <span class="hljs-title">handle_connection</span><span class="hljs-params">(io_uring&amp; ring, <span class="hljs-type">int</span> client_fd)</span> </span>{
    <span class="hljs-type">char</span> buffer[<span class="hljs-number">4096</span>];
    
    <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">// 异步读取（非阻塞）</span>
        <span class="hljs-type">ssize_t</span> n = <span class="hljs-keyword">co_await</span> <span class="hljs-built_in">async_read</span>(ring, client_fd, 
                                       buffer, <span class="hljs-built_in">sizeof</span>(buffer));
        
        <span class="hljs-comment">// 处理请求（可以在线程池中）</span>
        std::string response = <span class="hljs-keyword">co_await</span> <span class="hljs-built_in">async_process</span>(buffer, n);
        
        <span class="hljs-comment">// 异步写入</span>
        <span class="hljs-function"><span class="hljs-keyword">co_await</span> <span class="hljs-title">async_write</span><span class="hljs-params">(ring, client_fd, 
                            response.data(), response.size())</span></span>;
        
    } <span class="hljs-built_in">catch</span>(<span class="hljs-type">const</span> std::exception&amp; e) {
        std::cerr &lt;&lt; <span class="hljs-string">"Connection error: "</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;
    }
    
    ::<span class="hljs-built_in">close</span>(client_fd);
}

<span class="hljs-comment">// io_uring 是现代Linux的高性能异步I/O接口</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setup_io_uring</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">io_uring</span> ring;
    <span class="hljs-built_in">io_uring_queue_init</span>(<span class="hljs-number">32</span>, &amp;ring, <span class="hljs-number">0</span>);
    
    <span class="hljs-comment">// 提交多个I/O请求</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">io_uring_sqe</span>* sqe = <span class="hljs-built_in">io_uring_get_sqe</span>(&amp;ring);
        <span class="hljs-built_in">io_uring_prep_read</span>(sqe, fd, buffer, size, offset);
        <span class="hljs-built_in">io_uring_sqe_set_data</span>(sqe, user_data);
    }
    
    <span class="hljs-comment">// 批量提交</span>
    <span class="hljs-built_in">io_uring_submit</span>(&amp;ring);
    
    <span class="hljs-comment">// 等待完成</span>
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">io_uring_cqe</span>* cqe;
    <span class="hljs-built_in">io_uring_wait_cqe</span>(&amp;ring, &amp;cqe);
}
</code></pre>
<h2 data-id="heading-26"><strong>第八章：总结与最佳实践</strong></h2>
<h3 data-id="heading-27"><strong>8.1 Reactor模式的核心价值</strong></h3>
<ol>
<li><strong>资源效率</strong>：用少量线程服务大量连接</li>
<li><strong>可扩展性</strong>：连接数增长时性能下降缓慢</li>
<li><strong>响应性</strong>：避免单个慢连接影响其他连接</li>
<li><strong>模块化</strong>：清晰的关注点分离</li>
</ol>
<h3 data-id="heading-28"><strong>8.2 实施建议</strong></h3>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// Reactor实施检查清单</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ReactorChecklist</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">checklist</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// 1. 选择合适的I/O多路复用器</span>
        <span class="hljs-comment">//    - Linux: epoll (ET模式)</span>
        <span class="hljs-comment">//    - BSD: kqueue</span>
        <span class="hljs-comment">//    - Windows: IOCP（实际是Proactor）</span>
        
        <span class="hljs-comment">// 2. 使用非阻塞I/O</span>
        <span class="hljs-built_in">set_nonblocking</span>(fd);
        
        <span class="hljs-comment">// 3. 实现连接状态机</span>
        <span class="hljs-comment">//    每个连接维护明确的状态</span>
        
        <span class="hljs-comment">// 4. 分离I/O和业务处理</span>
        <span class="hljs-comment">//    I/O线程只做I/O，业务交给线程池</span>
        
        <span class="hljs-comment">// 5. 实现优雅关闭</span>
        <span class="hljs-comment">//    支持平滑重启</span>
        
        <span class="hljs-comment">// 6. 添加监控指标</span>
        <span class="hljs-comment">//    连接数、QPS、延迟、队列长度</span>
        
        <span class="hljs-comment">// 7. 实施限流和熔断</span>
        <span class="hljs-comment">//    防止过载</span>
        
        <span class="hljs-comment">// 8. 进行压力测试</span>
        <span class="hljs-comment">//    找到系统瓶颈</span>
    }
};
</code></pre>
<h3 data-id="heading-29"><strong>8.3 何时选择Reactor</strong></h3>
<p><strong>适合场景</strong>：</p>
<ul>
<li>高并发连接（&gt;1000）</li>
<li>I/O密集型应用</li>
<li>需要低延迟响应</li>
<li>长连接服务（如聊天、推送）</li>
</ul>
<p><strong>不适合场景</strong>：</p>
<ul>
<li>极低并发（&lt;100）</li>
<li>CPU密集型计算</li>
<li>简单的一次性请求</li>
</ul>
<h2 data-id="heading-30"><strong>结语</strong></h2>
<p>Reactor模式不是银弹，但它解决了C10K甚至C100K问题的核心挑战。从<code>select</code>到<code>epoll</code>，从单Reactor到多Reactor，从同步到异步，网络编程的演进始终围绕一个核心目标：<strong>用更少的资源服务更多的连接</strong>。</p>
<p>理解Reactor不仅是为了写出高性能服务器，更是为了掌握事件驱动编程的思想。这种思想已经渗透到现代软件的各个层面，从前端的React/Vue，到后端的Node.js/Nginx，再到操作系统的GUI事件循环。</p>
<p>正如计算机科学家Doug McIlroy所说："做一件事情，把它做好"。Reactor模式正是这一哲学在网络编程中的完美体现——它专注于事件分发这一件事，并做到了极致。</p>
<hr/>
<p><strong>进一步阅读</strong>：</p>
<ol>
<li>《UNIX网络编程 卷1：套接字联网API》</li>
<li>《Linux多线程服务端编程》</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[从理论到实践：构建你的AI语音桌面助手（Demo演示）]]></title>    <link>https://juejin.cn/post/7578723693825392676</link>    <guid>https://juejin.cn/post/7578723693825392676</guid>    <pubDate>2025-12-01T14:19:08.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7578723693825392676" data-draft-id="7578723693825212452" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="从理论到实践：构建你的AI语音桌面助手（Demo演示）"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2025-12-01T14:19:08.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="码事漫谈"/> <meta itemprop="url" content="https://juejin.cn/user/1972974802965230"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            从理论到实践：构建你的AI语音桌面助手（Demo演示）
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1972974802965230/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    码事漫谈
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-01T14:19:08.000Z" title="Mon Dec 01 2025 14:19:08 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-01
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读9分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>本文从“可运行”的实践角度，探索利用Python与AI技术实现语音控制Windows操作系统的方案。核心观点是：构建一个完整的语音控制助手，是<strong>将“能听会说”的语音模型与“能操作”的系统执行器相结合</strong>的过程。本文将绕过复杂的底层理论，直接提供一条基于开源技术的实践路径，并通过一个可运行的代码Demo，展示如何将自然语言指令转化为具体的系统操作。</p>
<h3 data-id="heading-0"><strong>一、构建“口-脑-手”协同系统</strong></h3>
<p>一个完整的语音控制计算机系统，可以类比为人的“口-脑-手”协同：</p>
<ol>
<li><strong>口（感知层）</strong>：负责“听”和“说”。使用麦克风接收语音，并通过<strong>语音识别（STT）</strong> 技术转为文本；将AI的回复通过<strong>语音合成（TTS）</strong> 技术播报出来。</li>
<li><strong>脑（认知层）</strong>：负责“思考”。使用<strong>大语言模型（LLM）</strong> 理解用户的文本指令，并将其解析为计算机可以执行的一系列<strong>结构化操作命令</strong>。</li>
<li><strong>手（执行层）</strong>：负责“做”。通过<strong>系统自动化工具</strong>接收结构化命令，并实际操控Windows的图形界面、应用程序或文件系统。</li>
</ol>
<p>微软正在其“智能体操作系统”的愿景中系统性地整合这三层，例如通过“Hey Copilot”唤醒词、Copilot Voice/Vision进行感知和理解，并通过模型上下文协议（MCP）让AI安全地操作系统。而我们的Demo将采用一个更灵活、可完全自定义的开源方案来实现。</p>
<h3 data-id="heading-1"><strong>二、技术方案选型</strong></h3>
<p>为了实现高自由度的控制，我们放弃对特定商业API（如特定云端LLM）的强依赖，选择模块化的开源方案，便于你未来扩展和修改。</p>
<p><strong>表1：Demo技术栈选型与说明</strong></p>









































<table><thead><tr><th align="left">模块</th><th align="left">推荐技术/库</th><th align="left">作用</th><th align="left">备注</th></tr></thead><tbody><tr><td align="left"><strong>语音识别 (STT)</strong></td><td align="left"><code>SpeechRecognition</code> + <code>PyAudio</code></td><td align="left">录制麦克风音频并转换为文本</td><td align="left">基础易用，可使用离线的 <code>Vosk</code> 引擎替换以获得更好隐私性。</td></tr><tr><td align="left"><strong>大语言模型 (LLM)</strong></td><td align="left"><strong>Ollama</strong>（本地运行）</td><td align="left">理解指令，生成操作规划</td><td align="left">可在本地免费运行如 <code>Llama 3.2</code>、<code>Qwen2.5</code> 等轻量模型，响应快且隐私无忧。</td></tr><tr><td align="left"><strong>系统执行器</strong></td><td align="left"><strong><code>Windows-MCP</code> 服务器</strong></td><td align="left">将AI指令转化为真实系统操作</td><td align="left">该项目通过系统API直接控制Windows，比模拟鼠标点击更稳定可靠。</td></tr><tr><td align="left"><strong>语音合成 (TTS)</strong></td><td align="left"><code>pyttsx3</code></td><td align="left">将AI的文本回复转为语音播报</td><td align="left">系统内置，无需网络。也可用效果更好的 <code>Piper</code>。</td></tr><tr><td align="left"><strong>流程协调</strong></td><td align="left"><strong>Python主程序</strong></td><td align="left">串联以上所有模块，实现完整工作流</td><td align="left">代码逻辑的中枢。</td></tr></tbody></table>
<p>这套方案的优势在于<strong>完全本地运行</strong>，保护隐私，且<strong>执行精准可靠</strong>（依靠<code>Windows-MCP</code>而非视觉识别）。其平均操作延迟在1.5-2.3秒，系统占用低于50MB内存，具备实用性。</p>
<h3 data-id="heading-2"><strong>三、实战Demo-文件整理助手</strong></h3>
<p>下面我们构建一个“文件整理助手”Demo。它的功能是：<strong>当你对着麦克风说“请把桌面上所有截图文件移到‘截图’文件夹里”，AI将自动完成此任务并语音回复你。</strong></p>
<h4 data-id="heading-3"><strong>第一步：环境准备</strong></h4>
<ol>
<li><strong>安装Python</strong>：确保系统已安装Python 3.10或以上版本。</li>
<li><strong>安装Ollama并拉取模型</strong>：
<ul>
<li>访问 <a href="https://link.juejin.cn?target=https%3A%2F%2Follama.com%2F" target="_blank" title="https://ollama.com/" ref="nofollow noopener noreferrer">Ollama官网</a> 下载并安装。</li>
<li>打开命令行，运行 <code>ollama run llama3.2:3b</code> 来下载并运行一个轻量级模型。</li>
</ul>
</li>
<li><strong>部署Windows-MCP服务器</strong>（系统的“手”）：
<ul>
<li>打开命令行，依次执行以下命令：</li>
</ul>
<pre><code class="hljs language-bash" lang="bash">git <span class="hljs-built_in">clone</span> https://github.com/CursorTouch/Windows-MCP.git
<span class="hljs-built_in">cd</span> Windows-MCP
uv <span class="hljs-built_in">sync</span>  <span class="hljs-comment"># 自动安装依赖</span>
uv run server  <span class="hljs-comment"># 启动MCP服务器，保持此窗口运行</span>
</code></pre>
</li>
<li><strong>安装Demo所需Python库</strong>：
<pre><code class="hljs language-bash" lang="bash">pip install speechrecognition pyaudio pyttsx3 requests
</code></pre>
</li>
</ol>
<h4 data-id="heading-4"><strong>第二步：编写核心Python代码</strong></h4>
<p>创建一个名为 <code>voice_desktop_assistant.py</code> 的文件，并写入以下代码。这段代码清晰地体现了“口-脑-手”的协同流程。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> speech_recognition <span class="hljs-keyword">as</span> sr
<span class="hljs-keyword">import</span> pyttsx3
<span class="hljs-keyword">import</span> requests
<span class="hljs-keyword">import</span> json
<span class="hljs-keyword">import</span> time

<span class="hljs-comment"># ========== 初始化“口”（语音模块） ==========</span>
recognizer = sr.Recognizer()
tts_engine = pyttsx3.init()

<span class="hljs-keyword">def</span> <span class="hljs-title function_">listen</span>():
    <span class="hljs-string">"""监听麦克风，将语音转为文本"""</span>
    <span class="hljs-keyword">with</span> sr.Microphone() <span class="hljs-keyword">as</span> source:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"请说出您的指令..."</span>)
        recognizer.adjust_for_ambient_noise(source)
        audio = recognizer.listen(source, timeout=<span class="hljs-number">5</span>, phrase_time_limit=<span class="hljs-number">10</span>)
    <span class="hljs-keyword">try</span>:
        text = recognizer.recognize_google(audio, language=<span class="hljs-string">'zh-CN'</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"识别结果: <span class="hljs-subst">{text}</span>"</span>)
        <span class="hljs-keyword">return</span> text
    <span class="hljs-keyword">except</span> sr.UnknownValueError:
        speak(<span class="hljs-string">"抱歉，我没有听清楚。"</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
    <span class="hljs-keyword">except</span> sr.RequestError:
        speak(<span class="hljs-string">"语音服务似乎出错了。"</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params">text</span>):
    <span class="hljs-string">"""用语音播报文本"""</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"AI: <span class="hljs-subst">{text}</span>"</span>)
    tts_engine.say(text)
    tts_engine.runAndWait()

<span class="hljs-comment"># ========== 初始化“脑”与“手”的通信 ==========</span>
<span class="hljs-comment"># Windows-MCP 服务器地址（默认运行在本机）</span>
MCP_SERVER_URL = <span class="hljs-string">"http://127.0.0.1:8080"</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">ask_ai_to_plan</span>(<span class="hljs-params">user_command</span>):
    <span class="hljs-string">"""
    将用户指令发送给本地的Ollama LLM，要求它生成Windows-MCP能理解的命令序列。
    提示词（Prompt）工程是关键，它指导AI如何思考。
    """</span>
    <span class="hljs-comment"># 精心设计的提示词，让AI扮演一个Windows自动化专家</span>
    system_prompt = <span class="hljs-string">"""你是一个Windows桌面自动化助手。你的任务是将用户的自然语言指令，解析为一系列可以由Windows-MCP工具执行的具体、安全的操作步骤。
请严格按照以下JSON格式输出，且只输出这个JSON对象：
{
  "plan": ["步骤1的简要描述", "步骤2的简要描述", ...],
  "commands": [
    {"tool": "工具名1", "params": {"参数名": "参数值"}},
    {"tool": "工具名2", "params": {"参数名": "参数值"}}
  ]
}
可用的Windows-MCP工具示例：
- `list_files`: 列出目录文件。参数: {"path": "目录路径"}
- `move_file`: 移动文件。参数: {"source": "源文件路径", "destination": "目标路径"}
- `create_folder`: 创建文件夹。参数: {"path": "文件夹路径"}
请确保路径使用双反斜杠或正斜杠，例如：C:\\Users\\Name\\Desktop 或 C:/Users/Name/Desktop。
指令："""</span>
    
    full_prompt = system_prompt + user_command
    
    <span class="hljs-keyword">try</span>:
        <span class="hljs-comment"># 发送请求到本地运行的Ollama模型</span>
        response = requests.post(
            <span class="hljs-string">'http://localhost:11434/api/generate'</span>,
            json={
                <span class="hljs-string">"model"</span>: <span class="hljs-string">"llama3.2:3b"</span>, <span class="hljs-comment"># 与你运行的模型名称一致</span>
                <span class="hljs-string">"prompt"</span>: full_prompt,
                <span class="hljs-string">"stream"</span>: <span class="hljs-literal">False</span>,
                <span class="hljs-string">"options"</span>: {<span class="hljs-string">"temperature"</span>: <span class="hljs-number">0.1</span>} <span class="hljs-comment"># 低随机性，确保输出稳定</span>
            }
        )
        response.raise_for_status()
        <span class="hljs-comment"># 从响应中提取AI生成的文本</span>
        ai_response_text = response.json()[<span class="hljs-string">'response'</span>]
        <span class="hljs-comment"># 找到JSON部分（防止AI输出额外解释）</span>
        start = ai_response_text.find(<span class="hljs-string">'{'</span>)
        end = ai_response_text.rfind(<span class="hljs-string">'}'</span>) + <span class="hljs-number">1</span>
        <span class="hljs-keyword">if</span> start != -<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> end != <span class="hljs-number">0</span>:
            json_str = ai_response_text[start:end]
            <span class="hljs-keyword">return</span> json.loads(json_str)
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">"AI未返回有效的JSON格式"</span>)
    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"与AI模型通信失败: <span class="hljs-subst">{e}</span>"</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">execute_commands</span>(<span class="hljs-params">command_list</span>):
    <span class="hljs-string">"""将AI生成的结构化命令发送给Windows-MCP服务器执行"""</span>
    <span class="hljs-keyword">for</span> cmd <span class="hljs-keyword">in</span> command_list:
        <span class="hljs-keyword">try</span>:
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"执行: <span class="hljs-subst">{cmd[<span class="hljs-string">'tool'</span>]}</span> 参数: <span class="hljs-subst">{cmd[<span class="hljs-string">'params'</span>]}</span>"</span>)
            <span class="hljs-comment"># 调用Windows-MCP服务器的工具接口</span>
            response = requests.post(
                <span class="hljs-string">f"<span class="hljs-subst">{MCP_SERVER_URL}</span>/tool/execute"</span>,
                json={<span class="hljs-string">"tool"</span>: cmd[<span class="hljs-string">"tool"</span>], <span class="hljs-string">"parameters"</span>: cmd[<span class="hljs-string">"params"</span>]}
            )
            result = response.json()
            <span class="hljs-keyword">if</span> response.status_code == <span class="hljs-number">200</span> <span class="hljs-keyword">and</span> result.get(<span class="hljs-string">"success"</span>):
                <span class="hljs-built_in">print</span>(<span class="hljs-string">f"成功: <span class="hljs-subst">{result.get(<span class="hljs-string">'message'</span>)}</span>"</span>)
                time.sleep(<span class="hljs-number">0.5</span>) <span class="hljs-comment"># 短暂等待，避免操作冲突</span>
            <span class="hljs-keyword">else</span>:
                <span class="hljs-built_in">print</span>(<span class="hljs-string">f"失败: <span class="hljs-subst">{result.get(<span class="hljs-string">'error'</span>, <span class="hljs-string">'未知错误'</span>)}</span>"</span>)
                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"执行命令时发生异常: <span class="hljs-subst">{e}</span>"</span>)
            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>

<span class="hljs-comment"># ========== 主循环：启动你的语音助手 ==========</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():
    speak(<span class="hljs-string">"语音桌面助手已启动。"</span>)
    
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
        <span class="hljs-comment"># 1. 听</span>
        user_command = listen()
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> user_command:
            <span class="hljs-keyword">continue</span>
        
        <span class="hljs-comment"># 2. 想（AI规划）</span>
        speak(<span class="hljs-string">"正在思考如何完成..."</span>)
        ai_plan = ask_ai_to_plan(user_command)
        
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> ai_plan:
            speak(<span class="hljs-string">"我没能理解如何执行这个任务。"</span>)
            <span class="hljs-keyword">continue</span>
        
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"执行计划: <span class="hljs-subst">{ai_plan[<span class="hljs-string">'plan'</span>]}</span>"</span>)
        
        <span class="hljs-comment"># 3. 做（系统执行）</span>
        speak(<span class="hljs-string">"开始执行任务。"</span>)
        success = execute_commands(ai_plan[<span class="hljs-string">'commands'</span>])
        
        <span class="hljs-comment"># 4. 反馈</span>
        <span class="hljs-keyword">if</span> success:
            speak(<span class="hljs-string">"任务已完成！"</span>)
        <span class="hljs-keyword">else</span>:
            speak(<span class="hljs-string">"任务执行过程中遇到了问题。"</span>)

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    main()
</code></pre>
<h4 data-id="heading-5"><strong>第三步：运行与交互</strong></h4>
<ol>
<li>确保 <strong>Ollama 模型</strong> 正在运行（第一步中 <code>ollama run</code> 的窗口）。</li>
<li>确保 <strong>Windows-MCP 服务器</strong> 正在运行（第一步中 <code>uv run server</code> 的窗口）。</li>
<li>在<strong>新的命令行窗口</strong>中，运行你的Python程序：
<pre><code class="hljs language-bash" lang="bash">python voice_desktop_assistant.py
</code></pre>
</li>
<li>程序启动后，你会听到“语音桌面助手已启动”的提示。此时，你可以尝试说出类似以下的指令：
<ul>
<li><strong>“在桌面上创建一个名为‘测试’的文件夹。”</strong></li>
<li><strong>“请列出我桌面上的所有文件。”</strong></li>
<li><strong>“帮我把桌面上所有的.txt文件移动到‘文档’文件夹里。”</strong>（请提前确保有对应文件或文件夹）</li>
</ul>
</li>
</ol>
<p>程序会将你的语音转为文本，发送给本地AI模型，AI会生成一个包含 <code>list_files</code>、<code>create_folder</code>、<code>move_file</code> 等操作的JSON命令序列，最后由 <code>Windows-MCP</code> 服务器执行这些命令并操作你的真实系统。</p>
<h3 data-id="heading-6"><strong>四、关键要点</strong></h3>
<p>通过这个Demo，你已实践了语音控制Windows的核心闭环。要让其更强大、可靠，你可以从以下几个方面深化：</p>
<ol>
<li><strong>强化AI的规划能力（改进“脑”）</strong>：当前的提示词（Prompt）较为简单。你可以为AI提供更详细的 <code>Windows-MCP</code> 工具手册，或让AI在执行前先“模拟”或“确认”危险操作（如删除文件）。这正是微软在Copilot Actions中采取“从有限场景开始测试”的谨慎策略。</li>
<li><strong>提升语音交互体验（改进“口”）</strong>：使用离线STT/TTS引擎（如Vosk和Piper）以获得更快的响应和绝对的隐私。实现“Hey Assistant”这样的免唤醒词热词检测，让交互更自然。</li>
<li><strong>确保系统安全（约束“手”）</strong>：这是最重要的环节。在Demo中，所有操作通过 <code>Windows-MCP</code> 进行，它默认只监听本地请求，且每次操作都需要用户授权（Cursor等IDE集成时会弹窗）。在实际产品中，必须像微软设计“智能体工作空间”一样，为AI代理建立一个权限受限的沙盒环境，将其活动与主系统隔离，并对删除、修改系统设置等敏感操作设置多次确认。</li>
<li><strong>探索更前沿的集成</strong>：关注微软“模型上下文协议（MCP）”的生态发展。未来，你可以将自己的助手注册为Windows任务栏的一个智能体，实现更深度的系统集成。</li>
</ol>
<h3 data-id="heading-7"><strong>结论</strong></h3>
<p>语音和AI对话控制计算机，从技术理论上看是多种成熟技术的组合创新，而从实践上看，其关键在于<strong>可靠地连接“语言理解”与“系统执行”这两个环</strong>。本文提供的Demo方案，利用 <code>Ollama</code> + <code>Windows-MCP</code> 构建了一个可在本地运行、完全受控的“原型智能体”，它跳出了单纯的理论和API调用，触及了AI智能体（Agent）实现自主任务执行的核心逻辑。</p>
<p>尽管前方仍有提升AI规划可靠性、确保操作安全等挑战，但通过这个可运行的起点，你已经拥有了一个强大的实验平台，可以亲手探索和塑造未来人机交互的样貌。</p>
<blockquote>
<p><strong>注</strong>：本Demo为教学演示目的，请在测试环境中谨慎运行，避免对重要文件和系统造成意外修改。实际操作前，请务必理解代码逻辑。</p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Claude 总是泛泛而谈？试试给它装个"技能包"，用 Skills 沉淀团队最佳实践]]></title>    <link>https://juejin.cn/post/7578714735307735066</link>    <guid>https://juejin.cn/post/7578714735307735066</guid>    <pubDate>2025-12-01T14:24:20.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7578714735307735066" data-draft-id="7578714735307669530" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Claude 总是泛泛而谈？试试给它装个&quot;技能包&quot;，用 Skills 沉淀团队最佳实践"/> <meta itemprop="keywords" content="Claude,AI编程,AIGC"/> <meta itemprop="datePublished" content="2025-12-01T14:24:20.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="也无风雨也雾晴"/> <meta itemprop="url" content="https://juejin.cn/user/2175258804632332"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Claude 总是泛泛而谈？试试给它装个"技能包"，用 Skills 沉淀团队最佳实践
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2175258804632332/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    也无风雨也雾晴
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-01T14:24:20.000Z" title="Mon Dec 01 2025 14:24:20 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-01
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读10分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">Claude Skills：给 AI 装上专业"技能包"</h2>
<p>用 Claude Code 开发项目的时候，经常遇到这些困惑：</p>
<ul>
<li>让 Claude 做代码审查，它给的建议太泛泛，不够专业？</li>
<li>写 Python 异步代码时，它对 asyncio 的最佳实践不够深入？</li>
<li>搭建 Kubernetes 配置，总感觉它缺少实战经验？</li>
<li>每次都要重复解释同样的技术上下文？</li>
</ul>
<p>Claude 本身很聪明，但就像一个全才——什么都懂一点，但不够专精。这时候就需要 <strong>Claude Skills</strong> 出场了。</p>
<h3 data-id="heading-1">什么是 Claude Skills</h3>
<h4 data-id="heading-2">一句话解释</h4>
<p>Skills 是给 Claude 装的"专业技能包"。就像 RPG 游戏里给角色学技能，一个 Skill 让 Claude 在特定领域变成专家。</p>
<p>官方定义是这样说的：</p>
<blockquote>
<p>Agent Skills are organized folders of instructions, scripts, and resources that agents can discover and load dynamically to perform better at specific tasks.</p>
</blockquote>
<p>翻译一下：Skills 是打包好的指令、脚本和资源，Claude 会自动发现并按需加载，让它在特定任务上表现更好。</p>
<h4 data-id="heading-3">核心特性</h4>
<ol>
<li><strong>模型自主调用</strong>：Claude 根据任务自动判断是否使用 Skill，不需要手动触发</li>
<li><strong>按需加载</strong>：只有用到的内容才占用 context window</li>
<li><strong>可组合</strong>：多个 Skills 可以协同工作</li>
<li><strong>跨平台</strong>：Claude.ai、Claude Code、Agent SDK、Developer Platform 都支持</li>
</ol>
<h4 data-id="heading-4">三层加载架构</h4>
<p>这是 Skills 设计最巧妙的地方——<strong>Progressive Disclosure（渐进式披露）</strong>：</p>
<pre><code class="hljs language-bash" lang="bash">┌─────────────────────────────────────────────────────────────────┐
│  Level 1: Metadata                                              │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │ name: code-review-excellence                             │    │
│  │ description: Master effective code review practices...   │    │
│  └─────────────────────────────────────────────────────────┘    │
│  加载时机: 启动时   |   Token 开销: ~100 tokens/skill            │
├─────────────────────────────────────────────────────────────────┤
│  Level 2: Instructions (SKILL.md 主体内容)                      │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │ - 代码审查的 4 阶段流程                                   │    │
│  │ - 反馈技巧和模板                                          │    │
│  │ - 通用 checklist                                          │    │
│  └─────────────────────────────────────────────────────────┘    │
│  加载时机: 触发时   |   Token 开销: &lt;5,000 tokens               │
├─────────────────────────────────────────────────────────────────┤
│  Level 3: Resources &amp; Code                                      │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │ reference/react.md, reference/python.md                  │    │
│  │ scripts/pr-analyzer.py                                   │    │
│  │ assets/checklist.md                                      │    │
│  └─────────────────────────────────────────────────────────┘    │
│  加载时机: 引用时   |   Token 开销: 仅输出消耗 token             │
└─────────────────────────────────────────────────────────────────┘
</code></pre>
<p>官方工程博客这样解释：</p>
<blockquote>
<p>Like a well-organized manual that starts with a table of contents, then specific chapters, and finally a detailed appendix, skills let Claude load information only as needed. This means that the amount of context that can be bundled into a skill is effectively unbounded.</p>
</blockquote>
<p>简单说：Skill 可以打包无限量的内容，但只在需要时才加载。你可以装 50 个 Skills，启动时只占用 ~5000 tokens（50 × 100），只有用到的才加载完整内容。</p>
<h3 data-id="heading-5">Skills vs MCP：两个不同层面的东西</h3>
<p>刚接触的时候很容易搞混，它们到底什么区别？</p>
<h4 data-id="heading-6">一句话区分</h4>
<p>有人总结得很形象：</p>
<blockquote>
<p>MCP server = "Claude, here are the keys to the filing cabinet."
Skills = "Write the instructions once, Claude follows them forever."</p>
</blockquote>
<p>MCP 给 Claude 钥匙（工具），Skills 给 Claude 说明书（知识）。</p>
<h4 data-id="heading-7">具体对比</h4>








































<table><thead><tr><th>维度</th><th>Skills</th><th>MCP Servers</th></tr></thead><tbody><tr><td><strong>本质</strong></td><td>知识和方法论</td><td>工具和能力</td></tr><tr><td><strong>作用</strong></td><td>教 Claude "怎么做"</td><td>给 Claude "能做什么"</td></tr><tr><td><strong>格式</strong></td><td>Markdown 文件 + YAML 元数据</td><td>协议 + 服务端程序</td></tr><tr><td><strong>Token 效率</strong></td><td>元数据 ~100 tokens，按需加载</td><td>数千到数万 tokens</td></tr><tr><td><strong>设置复杂度</strong></td><td>简单，创建 markdown 文件即可</td><td>较复杂，需要配置服务</td></tr><tr><td><strong>可移植性</strong></td><td>Claude 专用</td><td>开放标准，多厂商支持</td></tr></tbody></table>
<h4 data-id="heading-8">怎么配合使用</h4>
<p>做代码审查时：</p>
<ul>
<li><code>code-review-excellence</code> skill 提供审查标准和方法</li>
<li>Claude Code 原生的 Read/Grep 工具读取代码</li>
<li>如果是前端代码，可能还会用 Playwright MCP 跑一下页面</li>
</ul>
<p>写技术文档时：</p>
<ul>
<li><code>technical-writer</code> skill 提供写作框架和风格指南</li>
<li><code>context7</code> MCP 查询最新的库文档</li>
<li><code>tavily</code> MCP 搜索相关的最佳实践</li>
</ul>
<p><strong>一句话总结</strong>：MCP 提供连接外部系统的能力，Skills 提供如何使用这些能力的知识。</p>
<h3 data-id="heading-9">Skills 怎么工作</h3>
<h4 data-id="heading-10">激活机制</h4>
<p>Skill 的 <code>description</code> 字段决定何时激活。Claude 会分析用户输入，匹配相关的 skill：</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">description:</span> <span class="hljs-string">Master</span> <span class="hljs-string">effective</span> <span class="hljs-string">code</span> <span class="hljs-string">review</span> <span class="hljs-string">practices</span> <span class="hljs-string">to</span> <span class="hljs-string">provide</span> <span class="hljs-string">constructive</span>
<span class="hljs-string">feedback,</span> <span class="hljs-string">catch</span> <span class="hljs-string">bugs</span> <span class="hljs-string">early,</span> <span class="hljs-string">and</span> <span class="hljs-string">foster</span> <span class="hljs-string">knowledge</span> <span class="hljs-string">sharing</span> <span class="hljs-string">while</span> <span class="hljs-string">maintaining</span>
<span class="hljs-string">team</span> <span class="hljs-string">morale.</span> <span class="hljs-string">Use</span> <span class="hljs-string">when</span> <span class="hljs-string">reviewing</span> <span class="hljs-string">pull</span> <span class="hljs-string">requests,</span> <span class="hljs-string">establishing</span> <span class="hljs-string">review</span> <span class="hljs-string">standards,</span>
<span class="hljs-string">or</span> <span class="hljs-string">mentoring</span> <span class="hljs-string">developers.</span>
</code></pre>
<p>当用户说：</p>
<ul>
<li>"审查这段代码" → 激活（匹配 "reviewing"）</li>
<li>"帮我 review PR" → 激活（匹配 "pull requests"）</li>
<li>"建立代码审查标准" → 激活（匹配 "establishing review standards"）</li>
<li>"写个 Python 函数" → 不激活（无匹配）</li>
</ul>
<p>技术实现上，Claude 通过 Bash 工具读取 <code>SKILL.md</code> 文件来触发加载。</p>
<p>下面这张图展示了关键词如何自动触发 skill：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/276d9cfbd9b740178b985ff7eb95b9c3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lmf5peg6aOO6Zuo5Lmf6Zu-5pm0:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765203861&amp;x-signature=H4CHRJzshTsVAa02ftJbHfOdg4w%3D" alt="关键词自动触发" loading="lazy"/></p>
<h4 data-id="heading-11">Token 开销实测</h4>
<p>这是 Skills 设计巧妙的地方：</p>
<p><strong>未激活时</strong>：每个 skill 只占约 100 tokens（name + description）</p>
<ul>
<li>50 个 skills ≈ 5000 tokens</li>
</ul>
<p><strong>激活时</strong>：加载 SKILL.md（核心内容）</p>
<ul>
<li>典型的 SKILL.md ≈ 1500-3000 tokens</li>
</ul>
<p><strong>深度引用时</strong>：加载 reference/ 文件</p>
<ul>
<li><code>reference/react.md</code> ≈ 7000 tokens</li>
<li><code>reference/python.md</code> ≈ 8500 tokens</li>
<li>但脚本执行是确定性的，只有输出才消耗 token</li>
</ul>
<p>下面这张图展示了按需加载的过程：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fac591056dd142718f023afb094f5726~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lmf5peg6aOO6Zuo5Lmf6Zu-5pm0:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765203861&amp;x-signature=ddvk%2BEiz%2BabpqnVyfc93iQSFR2g%3D" alt="image-20251129152339708.png" loading="lazy"/></p>
<h4 data-id="heading-12">多 Skill 协作</h4>
<p>一次对话可以激活多个 skills。比如问"审查这个 Python 异步测试代码"：</p>
<pre><code class="hljs language-csharp" lang="csharp">用户: <span class="hljs-string">"审查这个 Python 异步测试代码"</span>
  │
  ├─→ code-review-excellence (匹配 <span class="hljs-string">"审查"</span>)
  │     └─ 代码审查流程和标准
  │
  ├─→ python-testing-patterns (匹配 <span class="hljs-string">"测试"</span>)
  │     └─ Python 测试最佳实践
  │
  └─→ <span class="hljs-keyword">async</span>-python-patterns (匹配 <span class="hljs-string">"异步"</span>)
        └─ asyncio 常见陷阱

Claude 综合 <span class="hljs-number">3</span> 个 skills 的知识 → 输出专业的审查报告
</code></pre>
<p>就像召集了 3 个专家会诊。</p>
<h3 data-id="heading-13">安装和配置</h3>
<h4 data-id="heading-14">存放位置</h4>
<p>Skills 有两个位置：</p>
<pre><code class="hljs language-bash" lang="bash">~/.claude/skills/              <span class="hljs-comment"># 全局 skills (所有项目可用)</span>
project/.claude/skills/        <span class="hljs-comment"># 项目 skills (仅当前项目，可 git 共享)</span>
</code></pre>
<h4 data-id="heading-15">安装方式</h4>
<p><strong>方式 1：从官方仓库安装</strong></p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># Claude Code 中安装官方 document skills</span>
/plugin install document-skills@anthropic-agent-skills
</code></pre>
<p>官方 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fanthropics%2Fskills" target="_blank" title="https://github.com/anthropics/skills" ref="nofollow noopener noreferrer">anthropics/skills</a> 仓库提供：</p>

























<table><thead><tr><th>类别</th><th>包含内容</th></tr></thead><tbody><tr><td><strong>Document Skills</strong></td><td>Word/PDF/PowerPoint/Excel 处理（生产级质量）</td></tr><tr><td><strong>Creative &amp; Design</strong></td><td>p5.js 算法艺术、Canvas 设计、GIF 动画</td></tr><tr><td><strong>Development</strong></td><td>Web artifacts、MCP server 创建、Playwright 测试</td></tr><tr><td><strong>Enterprise</strong></td><td>品牌指南、内部沟通模板</td></tr></tbody></table>
<p><strong>方式 2：从社区 Marketplace 安装</strong></p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 添加社区 marketplace</span>
/plugin marketplace add wshobson/agents

<span class="hljs-comment"># 安装 plugin（包含多个 skills）</span>
/plugin install developer-essentials      <span class="hljs-comment"># 8 个开发核心 skills</span>
/plugin install python-development        <span class="hljs-comment"># 5 个 Python skills</span>
/plugin install kubernetes-operations     <span class="hljs-comment"># 4 个 K8s skills</span>
</code></pre>
<p>社区 marketplace 提供更多细分领域的 skills，但要注意审查安全性。</p>
<p><strong>方式 3：手动创建</strong></p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 创建 skill 目录</span>
<span class="hljs-built_in">mkdir</span> -p ~/.claude/skills/my-custom-skill

<span class="hljs-comment"># 创建 SKILL.md</span>
<span class="hljs-built_in">cat</span> &gt; ~/.claude/skills/my-custom-skill/SKILL.md &lt;&lt; <span class="hljs-string">'EOF'</span>
---
name: my-custom-skill
description: 这个 skill 的用途。Use when XXX
---

<span class="hljs-comment"># My Custom Skill</span>

<span class="hljs-comment">## When to Use</span>
- 场景1
- 场景2

<span class="hljs-comment">## 核心内容</span>
[你的专业知识]
EOF
</code></pre>
<h4 data-id="heading-16">SKILL.md 规范</h4>
<p>官方要求：</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-meta">---</span>
<span class="hljs-attr">name:</span> <span class="hljs-string">your-skill-name</span>        <span class="hljs-comment"># 必需，最大 64 字符</span>
                             <span class="hljs-comment"># 只能用小写字母、数字、连字符</span>
                             <span class="hljs-comment"># 不能包含 "anthropic" 或 "claude"</span>
<span class="hljs-attr">description:</span> <span class="hljs-string">...</span>             <span class="hljs-comment"># 必需，最大 1,024 字符</span>
                             <span class="hljs-comment"># 说明功能和触发条件</span>
<span class="hljs-meta">---
</span>
<span class="hljs-comment"># Skill 正文 (Markdown)</span>
[<span class="hljs-string">任意内容</span>]
</code></pre>
<h4 data-id="heading-17">目录结构最佳实践</h4>
<pre><code class="hljs language-bash" lang="bash">skill-name/
├── SKILL.md                    <span class="hljs-comment"># 核心文件 (必需，建议 &lt;200 行)</span>
├── reference/                  <span class="hljs-comment"># 深度参考 (可选，按需加载)</span>
│   ├── react.md
│   └── python.md
├── assets/                     <span class="hljs-comment"># 模板资源 (可选)</span>
│   └── checklist.md
└── scripts/                    <span class="hljs-comment"># 自动化脚本 (可选)</span>
    └── analyzer.py
</code></pre>
<h3 data-id="heading-18">实战：从 7 分到 9 分的代码审查</h3>
<h4 data-id="heading-19">没有 Skill 时</h4>
<p>问："审查下项目结构"</p>
<p>Claude 可能会：</p>
<ul>
<li>列出文件列表</li>
<li>指出明显问题（比如缺少 README）</li>
<li>给一些泛泛的建议</li>
</ul>
<p><strong>质量</strong>：7/10 — 能用，但不够系统</p>
<h4 data-id="heading-20">有 Skill 后</h4>
<p>同样的问题，激活 <code>code-review-excellence</code> skill 后：</p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section">## 项目结构审查报告</span>

<span class="hljs-section">### 优点</span>
<span class="hljs-bullet">-</span> 现代化技术栈
<span class="hljs-bullet">-</span> 清晰的目录结构
<span class="hljs-bullet">-</span> 配置完善

<span class="hljs-section">### 关键问题 (Blocking)</span>
🔴 缺少测试基础设施
🔴 eslint.config.js 配置错误

<span class="hljs-section">### 重要改进 (Important)</span>
🟡 缺少环境变量管理
🟡 缺少错误边界

<span class="hljs-section">### 建议优化 (Nice to Have)</span>
🟢 代码分割
🟢 添加 loading 状态

<span class="hljs-section">### 评分矩阵</span>
| 类别     | 评分 | 说明        |
|----------|------|-------------|
| 代码质量 | 8/10 | ESLint 通过 |
| 架构设计 | 7/10 | 结构清晰    |
| 可维护性 | 6/10 | 缺少测试    |

<span class="hljs-section">### 优先级行动计划</span>
<span class="hljs-bullet">1.</span> 🔴 修复 eslint 配置
<span class="hljs-bullet">2.</span> 🔴 添加测试框架
</code></pre>
<p><strong>质量</strong>：9/10 — 专业、系统、可执行</p>
<p>区别在于：</p>






























<table><thead><tr><th>维度</th><th>基础模式</th><th>Skill 模式</th></tr></thead><tbody><tr><td>结构</td><td>无固定结构</td><td>4 阶段审查流程</td></tr><tr><td>优先级</td><td>混在一起</td><td>🔴🟡🟢 明确分级</td></tr><tr><td>可执行性</td><td>泛泛建议</td><td>具体行动计划</td></tr><tr><td>深度</td><td>表面问题</td><td>语言特定陷阱</td></tr></tbody></table>
<h3 data-id="heading-21">创建自定义 Skill</h3>
<h4 data-id="heading-22">什么时候该创建</h4>
<ol>
<li><strong>团队特定规范</strong> — "我们的 API 设计标准"</li>
<li><strong>重复性工作</strong> — 每次都要解释的技术细节</li>
<li><strong>知识沉淀</strong> — 把踩过的坑固化下来</li>
<li><strong>专业领域</strong> — Marketplace 没有的细分领域</li>
</ol>
<h4 data-id="heading-23">创建步骤</h4>
<p><strong>第 1 步：确定范围</strong></p>
<p>一个好的 skill 要：</p>
<ul>
<li>聚焦单一主题</li>
<li>可独立使用</li>
<li>有明确的激活条件</li>
<li>不要做"万能 skill"</li>
</ul>
<p><strong>第 2 步：组织内容</strong></p>
<pre><code class="hljs language-markdown" lang="markdown">---
name: team-api-standards
<span class="hljs-section">description: 团队的 RESTful API 设计规范和审查标准。Use when designing REST APIs, reviewing API endpoints, or validating API documentation.
---</span>

<span class="hljs-section"># Team API Standards</span>

<span class="hljs-section">## When to Use</span>
<span class="hljs-bullet">-</span> 设计新的 API 接口
<span class="hljs-bullet">-</span> 审查 API 相关代码
<span class="hljs-bullet">-</span> 解答 API 设计问题

<span class="hljs-section">## 核心原则</span>

<span class="hljs-section">### 1. RESTful 设计</span>
[团队的 REST 规范]

<span class="hljs-section">### 2. 错误处理</span>
[统一的错误响应格式]

<span class="hljs-section">## Checklist</span>
<span class="hljs-bullet">-</span> [ ] 是否遵循命名约定?
<span class="hljs-bullet">-</span> [ ] 错误码是否统一?

<span class="hljs-section">## 示例</span>

<span class="hljs-section">### 好的设计</span>
\<span class="hljs-code">`\`</span>\`typescript
// 正确示例
\<span class="hljs-code">`\`</span>\`

<span class="hljs-section">### 避免的做法</span>
\<span class="hljs-code">`\`</span>\`typescript
// 错误示例
\<span class="hljs-code">`\`</span>\`
</code></pre>
<p><strong>第 3 步：测试</strong></p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 创建 skill</span>
<span class="hljs-built_in">mkdir</span> -p ~/.claude/skills/team-api-standards
<span class="hljs-comment"># 编写 SKILL.md</span>
<span class="hljs-comment"># 新开会话测试</span>

<span class="hljs-comment"># 问: "审查这个 API 设计"</span>
<span class="hljs-comment"># 看是否激活了你的 skill</span>
</code></pre>
<h4 data-id="heading-24">最佳实践</h4>
<ol>
<li>
<p><strong>描述要精准</strong></p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-comment"># ❌ 太宽泛</span>
<span class="hljs-attr">description:</span> <span class="hljs-string">API</span> <span class="hljs-string">相关的知识</span>

<span class="hljs-comment"># ✅ 明确场景</span>
<span class="hljs-attr">description:</span> <span class="hljs-string">团队的</span> <span class="hljs-string">RESTful</span> <span class="hljs-string">API</span> <span class="hljs-string">设计规范。Use</span> <span class="hljs-string">when</span> <span class="hljs-string">designing</span> <span class="hljs-string">REST</span> <span class="hljs-string">APIs,</span> <span class="hljs-string">reviewing</span> <span class="hljs-string">API</span> <span class="hljs-string">endpoints.</span>
</code></pre>
</li>
<li>
<p><strong>内容要实战</strong></p>
<ul>
<li>多用对比示例（Good vs Bad）</li>
<li>提供 checklist</li>
<li>包含真实的坑和解决方案</li>
</ul>
</li>
<li>
<p><strong>团队共享</strong></p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 放项目目录，团队共享</span>
<span class="hljs-built_in">cp</span> -r ~/.claude/skills/team-api-standards .claude/skills/
git add .claude/
git commit -m <span class="hljs-string">"Add team API standards skill"</span>
</code></pre>
</li>
</ol>
<h3 data-id="heading-25">安全考虑</h3>
<p>官方文档特别强调这一点：</p>
<blockquote>
<p>We strongly recommend using Skills only from trusted sources: those you created yourself or obtained from Anthropic.</p>
</blockquote>
<p>Skills 可以包含脚本，恶意 Skill 可能：</p>
<ul>
<li>让 Claude 执行有害操作</li>
<li>泄露数据</li>
<li>入侵系统</li>
</ul>
<p><strong>建议</strong>：</p>
<ul>
<li>审查所有 bundled 文件（SKILL.md、scripts、images）</li>
<li>避免使用从不可信 URL 获取内容的 Skills</li>
<li>像对待安装软件一样对待 Skill</li>
</ul>
<h3 data-id="heading-26">平台支持</h3>






























<table><thead><tr><th>平台</th><th>支持类型</th><th>共享范围</th></tr></thead><tbody><tr><td><strong>Claude.ai</strong></td><td>预置 + 自定义上传</td><td>仅个人</td></tr><tr><td><strong>Claude Code</strong></td><td>自定义（文件系统）</td><td>个人或项目级</td></tr><tr><td><strong>Claude API</strong></td><td>预置 + 自定义</td><td>组织级</td></tr><tr><td><strong>Agent SDK</strong></td><td>自定义（.claude/skills/）</td><td>配置级</td></tr></tbody></table>
<p>注意：自定义 Skills 不会跨平台同步，需要分别上传。</p>
<h3 data-id="heading-27">局限性</h3>
<h4 data-id="heading-28">Skills 不能做的</h4>
<ul>
<li>❌ 操作浏览器（需要 Playwright MCP）</li>
<li>❌ 联网搜索（需要 Tavily MCP）</li>
<li>❌ 执行系统命令（需要 Bash 工具）</li>
<li>❌ 读取文件（需要 Read 工具）</li>
</ul>
<h4 data-id="heading-29">Skills 擅长的</h4>
<ul>
<li>✅ 提供系统化的知识框架</li>
<li>✅ 指导最佳实践</li>
<li>✅ 识别常见陷阱</li>
<li>✅ 优化工具使用策略</li>
</ul>
<h4 data-id="heading-30">创建成本</h4>
<p>高质量 skill 需要投入：</p>
<ul>
<li>核心内容（SKILL.md）：4-6 小时</li>
<li>补充资源：8-12 小时</li>
<li>持续维护：按需更新</li>
</ul>
<h3 data-id="heading-31">总结</h3>
<p><strong>原理层面</strong>：</p>
<ul>
<li>Skills 是给 Claude 装的"专业技能包"，让它从全才变专家</li>
<li>采用 Progressive Disclosure 架构，按需加载，token 效率高</li>
<li>通过 description 自动激活，无需手动调用</li>
<li>可以多个 skills 协作，互相补充</li>
</ul>
<p><strong>实用层面</strong>：</p>
<ul>
<li>官方 anthropics/skills 提供生产级 Document Skills</li>
<li>社区 marketplace 提供更多细分领域 skills</li>
<li>自定义 skill 简单：一个目录 + 一个 SKILL.md</li>
<li>Skills 和 MCP 是互补关系，不是替代</li>
</ul>
<p><strong>使用建议</strong>：</p>
<ol>
<li><strong>新手</strong>：从官方 skills 开始，体验专业化提升</li>
<li><strong>进阶</strong>：创建团队特定 skills，沉淀最佳实践</li>
<li><strong>安全</strong>：只使用可信来源的 skills，审查所有脚本</li>
</ol>
<hr/>
<h3 data-id="heading-32">相关资源</h3>
<h4 data-id="heading-33">官方文档</h4>
<ol>
<li><strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fplatform.claude.com%2Fdocs%2Fen%2Fagents-and-tools%2Fagent-skills%2Foverview" target="_blank" title="https://platform.claude.com/docs/en/agents-and-tools/agent-skills/overview" ref="nofollow noopener noreferrer">Agent Skills 文档</a></strong> - 完整使用指南</li>
<li><strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.anthropic.com%2Fengineering%2Fequipping-agents-for-the-real-world-with-agent-skills" target="_blank" title="https://www.anthropic.com/engineering/equipping-agents-for-the-real-world-with-agent-skills" ref="nofollow noopener noreferrer">Skills 工程博客</a></strong> - 技术架构详解</li>
<li><strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.anthropic.com%2Fnews%2Fskills" target="_blank" title="https://www.anthropic.com/news/skills" ref="nofollow noopener noreferrer">Skills 发布公告</a></strong> - 功能介绍</li>
</ol>
<h4 data-id="heading-34">代码仓库</h4>
<ol start="4">
<li><strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fanthropics%2Fskills" target="_blank" title="https://github.com/anthropics/skills" ref="nofollow noopener noreferrer">anthropics/skills</a></strong> - 官方 Skills 仓库</li>
<li><strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fwshobson%2Fagents" target="_blank" title="https://github.com/wshobson/agents" ref="nofollow noopener noreferrer">wshobson/agents</a></strong> - 社区 Skills marketplace</li>
</ol>
<h4 data-id="heading-35">扩展阅读</h4>
<ol start="6">
<li><strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fsupport.claude.com%2Fen%2Farticles%2F12512198-how-to-create-custom-skills" target="_blank" title="https://support.claude.com/en/articles/12512198-how-to-create-custom-skills" ref="nofollow noopener noreferrer">创建自定义 Skills</a></strong> - 官方教程</li>
<li><strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.claude.com%2Fblog%2Fskills-explained" target="_blank" title="https://www.claude.com/blog/skills-explained" ref="nofollow noopener noreferrer">Skills vs MCP 对比</a></strong> - 官方博客解释</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[C#/.NET/.NET Core优秀项目和框架2025年11月简报]]></title>    <link>https://juejin.cn/post/7578681104292708395</link>    <guid>https://juejin.cn/post/7578681104292708395</guid>    <pubDate>2025-12-01T14:24:06.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7578681104292708395" data-draft-id="7578697614390575110" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="C#/.NET/.NET Core优秀项目和框架2025年11月简报"/> <meta itemprop="keywords" content="后端,.NET"/> <meta itemprop="datePublished" content="2025-12-01T14:24:06.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="追逐时光者"/> <meta itemprop="url" content="https://juejin.cn/user/2770425031690333"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            C#/.NET/.NET Core优秀项目和框架2025年11月简报
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2770425031690333/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    追逐时光者
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-01T14:24:06.000Z" title="Mon Dec 01 2025 14:24:06 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-01
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/685df50300ed49aea271aeed0bc66e31~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6L-96YCQ5pe25YWJ6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765203868&amp;x-signature=C%2B52LnkG9xeEAw3Y1dMsxX4Dnf0%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-0">前言</h2>
<p>公众号每月定期推广和分享的C#/.NET/.NET Core优秀项目和框架（每周至少会推荐两个优秀的项目和框架当然节假日除外），公众号推文中有项目和框架的详细介绍、功能特点、使用方式以及部分功能截图等（打不开或者打开GitHub很慢的同学可以优先查看公众号推文，文末一定会附带项目和框架源码地址）。注意：排名不分先后，都是十分优秀的开源项目和框架，每周定期更新分享。</p>
<ul>
<li><strong>💡简报Gitee开源地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgitee.com%2Fysgdaydayup%2FDotNetGuide%2Fblob%2Fmain%2Fdocs%2FDotNet%2FDotNetProjectMonthly.md" target="_blank" title="https://gitee.com/ysgdaydayup/DotNetGuide/blob/main/docs/DotNet/DotNetProjectMonthly.md" ref="nofollow noopener noreferrer">gitee.com/ysgdaydayup…</a></strong></li>
<li><strong>🔔简报GitHub开源地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FYSGStudyHards%2FDotNetGuide%2Fblob%2Fmain%2Fdocs%2FDotNet%2FDotNetProjectMonthly.md" target="_blank" title="https://github.com/YSGStudyHards/DotNetGuide/blob/main/docs/DotNet/DotNetProjectMonthly.md" ref="nofollow noopener noreferrer">github.com/YSGStudyHar…</a></strong></li>
</ul>
<h2 data-id="heading-1">STNodeEditor</h2>
<ul>
<li><strong>项目简介：</strong> STNodeEditor 是一款基于 .NET WinForm 开源免费（MIT License）、轻量且功能强大的节点编辑器，采用纯 GDI+ 绘制无任何依赖库仅仅100+Kb，提供了丰富的属性以及事件，可以非常方便的完成节点之间数据的交互及通知，编辑器内置了大量虚函数，供开发者根据需求进行重写，赋予了极高的自由度和定制能力。</li>
<li><strong>项目源码地址：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FDebugST%2FSTNodeEditor" target="_blank" title="https://github.com/DebugST/STNodeEditor" ref="nofollow noopener noreferrer">github.com/DebugST/STN…</a></li>
<li><strong>项目详细介绍：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FfMG3iAu1Y0Fkmf6d-fcgiA" target="_blank" title="https://mp.weixin.qq.com/s/fMG3iAu1Y0Fkmf6d-fcgiA" ref="nofollow noopener noreferrer">mp.weixin.qq.com/s/fMG3iAu1Y…</a></li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4052f6ecec7b45069b2bb8e8ed33f703~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6L-96YCQ5pe25YWJ6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765203868&amp;x-signature=%2FVqqCWv9lD40catX2kuQTBzd%2FJA%3D" alt="" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3094f1fe1ea14d28892c28e8f9c488ae~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6L-96YCQ5pe25YWJ6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765203868&amp;x-signature=8j7JAWzzC5VnJ6bseeuz6yY1IXw%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-2">WenAntdUI-Admin</h2>
<ul>
<li><strong>项目简介：</strong> WenAntdUI-Admin 是一个基于 AntdUI 构建、基础、现代化的 WinForm 管理系统，基于 Apache-2.0 License 开源，项目包含：AOT发布、字典管理、用户管理、菜单管理、权限管理、用户设置等功能。内部封装了很多常用组件，包含AdminTable等通用组件。</li>
<li><strong>项目源码地址：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fgitee.com%2FAntdUI%2Fwen-antd-ui" target="_blank" title="https://gitee.com/AntdUI/wen-antd-ui" ref="nofollow noopener noreferrer">gitee.com/AntdUI/wen-…</a></li>
<li><strong>项目详细介绍：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FVTBcoZZ2mNyuyV_s4fzsPA" target="_blank" title="https://mp.weixin.qq.com/s/VTBcoZZ2mNyuyV_s4fzsPA" ref="nofollow noopener noreferrer">mp.weixin.qq.com/s/VTBcoZZ2m…</a></li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2aa8f6f09f314348a41cafe134272826~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6L-96YCQ5pe25YWJ6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765203868&amp;x-signature=CYEOeEa2bPX0dQZtCN%2BE55ArdLg%3D" alt="" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8933f426bbea442bbe8d396f74bb2129~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6L-96YCQ5pe25YWJ6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765203868&amp;x-signature=jBL7zwHAI0wRr9iabEgLFeOcYTc%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-3">NetCoreKevin</h2>
<ul>
<li><strong>项目简介：</strong> NetCoreKevin 是一个基于 .NET 8 + DDD 搭建的模块化微服务框架，其模块化设计使得每个功能都可以独立引用，非常适合大型企业级应用的开发。框架支持IdentityServer4单点登录、多缓存、自动任务、分布式、一库多租户、日志、授权和鉴权、CAP集成事件、SignalR、领域事件、ESL、MCP协议服务、IOC模块化注入、Cors、Quartz自动任务、多短信集成、AI智能体、AI 集成 SemanticKernel、MCP 服务、OCR验证码识别、API多版本兼容、单元集成测试。</li>
<li><strong>项目源码地址：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fjunkai-li%2FNetCoreKevin" target="_blank" title="https://github.com/junkai-li/NetCoreKevin" ref="nofollow noopener noreferrer">github.com/junkai-li/N…</a></li>
<li><strong>项目详细介绍：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FxGM9SLna-ihK1Qe228TRFQ" target="_blank" title="https://mp.weixin.qq.com/s/xGM9SLna-ihK1Qe228TRFQ" ref="nofollow noopener noreferrer">mp.weixin.qq.com/s/xGM9SLna-…</a></li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4751e78351fb491787358aef4c51a112~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6L-96YCQ5pe25YWJ6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765203868&amp;x-signature=FXcv%2Fq2OJOeLVSK0qmoR4WnpWSQ%3D" alt="" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fd4f0027f40349b09f415048ff48f4bf~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6L-96YCQ5pe25YWJ6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765203868&amp;x-signature=lEYU5b43jHhlIv0rUJRkBZfPvMY%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-4">ImageSearch</h2>
<ul>
<li><strong>项目简介：</strong> ImageSearch 是一个基于 .NET WPF 开源、免费（MIT license）、轻量的本地硬盘千万级图库以图搜图小工具，该项目灵感来源于市面上的重复文件、目录查找与清理的系统工具 DuplicateCleaner。</li>
<li><strong>项目源码地址：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fldqk%2FImageSearch" target="_blank" title="https://github.com/ldqk/ImageSearch" ref="nofollow noopener noreferrer">github.com/ldqk/ImageS…</a></li>
<li><strong>项目详细介绍：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FiRDW0KvDDBT5x9lotbR_2Q" target="_blank" title="https://mp.weixin.qq.com/s/iRDW0KvDDBT5x9lotbR_2Q" ref="nofollow noopener noreferrer">mp.weixin.qq.com/s/iRDW0KvDD…</a></li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/35ac2036fc9546188ec3a3ebfef1c9be~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6L-96YCQ5pe25YWJ6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765203868&amp;x-signature=JT3DcjzP6c9UO8NkSuirv%2BOSQzU%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-5">better-genshin-impact</h2>
<ul>
<li><strong>项目简介：</strong> better-genshin-impact 是一款基于 .NET + 计算机视觉技术完全开源免费（GPL-3.0 license）、功能强大的原神智能辅助自动化工具，意图让原神变的更好的项目，包含：自动剧情、全自动钓鱼(AI)、全自动七圣召唤、自动伐木、自动刷本、自动采集/挖矿/锄地等功能。</li>
<li><strong>项目源码地址：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fbabalae%2Fbetter-genshin-impact" target="_blank" title="https://github.com/babalae/better-genshin-impact" ref="nofollow noopener noreferrer">github.com/babalae/bet…</a></li>
<li><strong>项目详细介绍：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FwZ4d9baOO2RXsb6VCdSxHQ" target="_blank" title="https://mp.weixin.qq.com/s/wZ4d9baOO2RXsb6VCdSxHQ" ref="nofollow noopener noreferrer">mp.weixin.qq.com/s/wZ4d9baOO…</a></li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5cff5ae307894721a06bf14e7537316b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6L-96YCQ5pe25YWJ6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765203868&amp;x-signature=s6iSJ7zqWJHfUinAojGI5KUBztw%3D" alt="" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/761e373c2175484ab071a85a544ac2d9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6L-96YCQ5pe25YWJ6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765203868&amp;x-signature=28IVdQAG%2BipnF4Te8ceSBSdqrk0%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-6">DataGridFilter</h2>
<ul>
<li><strong>项目简介：</strong> DataGridFilter 是一款开源（MIT License）、多语言的 WPF 可筛选 DataGrid 控件，旨在通过轻量级集成帮助开发者快速构建高效、灵活的数据展示管理界面。</li>
<li><strong>项目源码地址：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmacgile%2FDataGridFilter" target="_blank" title="https://github.com/macgile/DataGridFilter" ref="nofollow noopener noreferrer">github.com/macgile/Dat…</a></li>
<li><strong>项目详细介绍：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FzrU7sivEvJrU090TF6TN3w" target="_blank" title="https://mp.weixin.qq.com/s/zrU7sivEvJrU090TF6TN3w" ref="nofollow noopener noreferrer">mp.weixin.qq.com/s/zrU7sivEv…</a></li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bc330d03edb34f2ba0196031a7d1adca~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6L-96YCQ5pe25YWJ6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765203868&amp;x-signature=td7q8ijZihgWDowEuGM1y6qJ15A%3D" alt="" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/96d3dfa1fff24a5395c15891e3a4e8ed~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6L-96YCQ5pe25YWJ6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765203868&amp;x-signature=1gl20hqdgmEmDdnq%2Fv3WaMSH1%2Fs%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-7">Microsoft Agent Framework</h2>
<ul>
<li><strong>项目简介：</strong> Microsoft Agent Framework 是一个面向 .NET 和 Python 的开源开发套件，用于构建 AI 智能体及多智能体工作流。它融合并扩展了 Semantic Kernel 与 AutoGen 项目的核心理念，在结合两者优势的基础上，进一步引入了全新能力。该框架由原班团队打造，将成为未来构建 AI 智能体的统一基础平台。</li>
<li><strong>项目源码地址：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmicrosoft%2Fagent-framework" target="_blank" title="https://github.com/microsoft/agent-framework" ref="nofollow noopener noreferrer">github.com/microsoft/a…</a></li>
<li><strong>项目详细介绍：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FqxjUYO2U-TCTd0JmEtbehA" target="_blank" title="https://mp.weixin.qq.com/s/qxjUYO2U-TCTd0JmEtbehA" ref="nofollow noopener noreferrer">mp.weixin.qq.com/s/qxjUYO2U-…</a></li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/746ef4382646425dac87ce352628ca7a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6L-96YCQ5pe25YWJ6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765203868&amp;x-signature=qDodqsCWDi7zIIya51YkXakat%2BM%3D" alt="" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3b39bd00a0e141b795cb347907b6cf91~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6L-96YCQ5pe25YWJ6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765203868&amp;x-signature=XsvPGh5z4cr0AY12HmgK3DnIlzc%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-8">AutoGen</h2>
<ul>
<li><strong>项目简介：</strong> AutoGen 是一个开源编程框架，它通过多个代理进行对话以解决任务，从而实现 LLM 应用的开发。AutoGen 代理可定制、可对话，并且能够无缝地允许人类参与。它们可以在不同的模式下运行，使用 LLM、人类输入和工具的组合。</li>
<li><strong>项目源码地址：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmicrosoft%2Fautogen" target="_blank" title="https://github.com/microsoft/autogen" ref="nofollow noopener noreferrer">github.com/microsoft/a…</a></li>
<li><strong>项目详细介绍：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FqxjUYO2U-TCTd0JmEtbehA" target="_blank" title="https://mp.weixin.qq.com/s/qxjUYO2U-TCTd0JmEtbehA" ref="nofollow noopener noreferrer">mp.weixin.qq.com/s/qxjUYO2U-…</a></li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7ac79fe4622a4af0a886b4bac56e051f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6L-96YCQ5pe25YWJ6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765203868&amp;x-signature=1mQbX0OTW1vhN%2BPEwH80TvsLgic%3D" alt="" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2f21abafd0794502ad2e5d9ff88e3c31~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6L-96YCQ5pe25YWJ6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765203868&amp;x-signature=znHloCAVB3pTiuEi5XTt%2FA%2BBZVE%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-9">Kernel Memory</h2>
<ul>
<li><strong>项目简介：</strong> Kernel Memory（KM）是一种多模态AI服务，RAG 架构，使用 LLM 和自然语言索引和查询任何数据、跟踪来源、显示引用、异步内存模式。该存储库提供了特定 AI 和 LLMs 应用场景中内存的最佳实践和参考架构。</li>
<li><strong>项目源码地址：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmicrosoft%2Fkernel-memory" target="_blank" title="https://github.com/microsoft/kernel-memory" ref="nofollow noopener noreferrer">github.com/microsoft/k…</a></li>
<li><strong>项目详细介绍：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FqxjUYO2U-TCTd0JmEtbehA" target="_blank" title="https://mp.weixin.qq.com/s/qxjUYO2U-TCTd0JmEtbehA" ref="nofollow noopener noreferrer">mp.weixin.qq.com/s/qxjUYO2U-…</a></li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/340ae63ec6a34bdea8b06b8bc30e5d42~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6L-96YCQ5pe25YWJ6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765203868&amp;x-signature=Fs5PDD8BuRso9VG4tHNBhS3OSeg%3D" alt="" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8c14df5241fc4eeeb010ea4148d53915~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6L-96YCQ5pe25YWJ6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765203868&amp;x-signature=o9D9mVrXBdtbBQajip0yYHKaydM%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-10">AntSK</h2>
<ul>
<li><strong>项目简介：</strong> AntSK 是一个基于 .NET 9 和 Blazor 技术栈构建的企业级AI知识库和智能体平台，集成了 Semantic Kernel 和 Kernel Memory，提供完整的AI应用开发解决方案。</li>
<li><strong>项目源码地址：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FAIDotNet%2FAntSK" target="_blank" title="https://github.com/AIDotNet/AntSK" ref="nofollow noopener noreferrer">github.com/AIDotNet/An…</a></li>
<li><strong>项目详细介绍：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FqxjUYO2U-TCTd0JmEtbehA" target="_blank" title="https://mp.weixin.qq.com/s/qxjUYO2U-TCTd0JmEtbehA" ref="nofollow noopener noreferrer">mp.weixin.qq.com/s/qxjUYO2U-…</a></li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a4794d7af2b1458bbdb0a3ea0709d276~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6L-96YCQ5pe25YWJ6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765203868&amp;x-signature=Opf1lfD3k5g98QyqXm1e320atLg%3D" alt="" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/85f1cf9ffdec4fdba95bde5e07301b14~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6L-96YCQ5pe25YWJ6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765203868&amp;x-signature=%2F5%2FpnyiZHT6Oo3MvbbpDEKiqnIw%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-11">OllamaSharp</h2>
<ul>
<li><strong>项目简介：</strong> OllamaSharp 旨在通过提供.NET绑定，使得开发者能够轻松地在.NET应用程序中使用Ollama API。简化了 .NET 与 Ollama 的本地和远程交互。</li>
<li><strong>项目源码地址：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fawaescher%2FOllamaSharp" target="_blank" title="https://github.com/awaescher/OllamaSharp" ref="nofollow noopener noreferrer">github.com/awaescher/O…</a></li>
<li><strong>项目详细介绍：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FqxjUYO2U-TCTd0JmEtbehA" target="_blank" title="https://mp.weixin.qq.com/s/qxjUYO2U-TCTd0JmEtbehA" ref="nofollow noopener noreferrer">mp.weixin.qq.com/s/qxjUYO2U-…</a></li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4df41f28e32548a081862bcff2b2adc2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6L-96YCQ5pe25YWJ6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765203868&amp;x-signature=WNlBdjEBRSFG%2FwNYoMB4%2FYBMbUs%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-12">WPFUIDemo</h2>
<ul>
<li><strong>项目简介：</strong> WPFUIDemo 是一个专注于 WPF（Windows Presentation Foundation）用户界面设计与开发的示例项目。该项目旨在为开发者提供一个全面、实用的参考范例，帮助他们快速掌握 WPF 应用开发的核心技巧和最佳实践，提升开发效率与界面设计水平。通过丰富的功能模块和代码示例，开发者可以深入了解 WPF 的强大特性，并将其灵活应用于实际项目中。</li>
<li><strong>项目源码地址：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fgitee.com%2Fzhang-sleepyhead%2FWPFUIDemo" target="_blank" title="https://gitee.com/zhang-sleepyhead/WPFUIDemo" ref="nofollow noopener noreferrer">gitee.com/zhang-sleep…</a></li>
<li><strong>项目详细介绍：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F15oTrGmLzGl4AAUV6maIgw" target="_blank" title="https://mp.weixin.qq.com/s/15oTrGmLzGl4AAUV6maIgw" ref="nofollow noopener noreferrer">mp.weixin.qq.com/s/15oTrGmLz…</a></li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/65a8555feece44e8b3043dfd92248d2b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6L-96YCQ5pe25YWJ6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765203868&amp;x-signature=FvMI9HZewyXaQDzOE%2F%2BBz%2FWQ32w%3D" alt="" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3965fab39473445dbe60d4657dc19f5c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6L-96YCQ5pe25YWJ6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765203868&amp;x-signature=hDoQK0z3dLmFTRotuHCjkIphxa0%3D" alt="" loading="lazy"/></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[k8s实用脚本]]></title>    <link>https://juejin.cn/post/7578732288515538995</link>    <guid>https://juejin.cn/post/7578732288515538995</guid>    <pubDate>2025-12-01T14:29:09.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7578732288515538995" data-draft-id="7578699866182107174" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="k8s实用脚本"/> <meta itemprop="keywords" content="Kubernetes"/> <meta itemprop="datePublished" content="2025-12-01T14:29:09.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="哈里谢顿"/> <meta itemprop="url" content="https://juejin.cn/user/3678304397695056"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            k8s实用脚本
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3678304397695056/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    哈里谢顿
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-01T14:29:09.000Z" title="Mon Dec 01 2025 14:29:09 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-01
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">1 将docker管理的镜像传递给k8s使用</h2>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-meta">#!/bin/bash</span>

<span class="hljs-comment"># docker-to-ctr.sh</span>
<span class="hljs-comment"># 将本地所有 Docker 镜像导出为 tar 并存储到指定目录</span>
<span class="hljs-comment"># 若目标 tar 已存在则跳过</span>

DIR=<span class="hljs-string">"/home/hanwang/docker_images"</span>

<span class="hljs-built_in">set</span> -e

<span class="hljs-comment"># 创建存储目录</span>
<span class="hljs-built_in">mkdir</span> -p <span class="hljs-string">"<span class="hljs-variable">$DIR</span>"</span>

<span class="hljs-built_in">echo</span> <span class="hljs-string">"🔍 获取本地 Docker 镜像列表..."</span>
IMAGES=$(docker images --format <span class="hljs-string">"{{.Repository}}:{{.Tag}}"</span> | grep -v <span class="hljs-string">"&lt;none&gt;"</span>)

<span class="hljs-keyword">if</span> [ -z <span class="hljs-string">"<span class="hljs-variable">$IMAGES</span>"</span> ]; <span class="hljs-keyword">then</span>
  <span class="hljs-built_in">echo</span> <span class="hljs-string">"❌ 未找到有效的 Docker 镜像（排除 &lt;none&gt; 标签）"</span>
  <span class="hljs-built_in">exit</span> 1
<span class="hljs-keyword">fi</span>

COUNT=$(<span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$IMAGES</span>"</span> | <span class="hljs-built_in">wc</span> -l)
<span class="hljs-built_in">echo</span> <span class="hljs-string">"📦 共找到 <span class="hljs-variable">${COUNT}</span> 个镜像，开始保存到 <span class="hljs-variable">${DIR}</span> ..."</span>

<span class="hljs-keyword">for</span> img <span class="hljs-keyword">in</span> <span class="hljs-variable">$IMAGES</span>; <span class="hljs-keyword">do</span>
  <span class="hljs-built_in">echo</span> <span class="hljs-string">"➡️  处理镜像: <span class="hljs-variable">$img</span>"</span>
  
  <span class="hljs-comment"># 目标 tar 文件名：将仓库/标签中的特殊字符替换为下划线</span>
  TARGET_TAR=<span class="hljs-string">"<span class="hljs-variable">${DIR}</span>/<span class="hljs-subst">$(echo <span class="hljs-string">"<span class="hljs-variable">$img</span>"</span> | tr '/' '_' | tr ':' '_')</span>.tar"</span>

  <span class="hljs-keyword">if</span> [ -f <span class="hljs-string">"<span class="hljs-variable">$TARGET_TAR</span>"</span> ]; <span class="hljs-keyword">then</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"⏭️  已存在：<span class="hljs-variable">$TARGET_TAR</span>，跳过保存"</span>
    <span class="hljs-built_in">continue</span>
  <span class="hljs-keyword">fi</span>

  <span class="hljs-built_in">echo</span> <span class="hljs-string">"💾 保存镜像为 tar：<span class="hljs-variable">$TARGET_TAR</span>"</span>
  docker save <span class="hljs-string">"<span class="hljs-variable">$img</span>"</span> -o <span class="hljs-string">"<span class="hljs-variable">$TARGET_TAR</span>"</span>
  <span class="hljs-comment"># 导入到 containerd 的 k8s.io 命名空间（Kubernetes 使用此命名空间）</span>
  ctr -n k8s.io images import --no-unpack <span class="hljs-string">"<span class="hljs-variable">$TARGET_TAR</span>"</span>
  
  <span class="hljs-built_in">echo</span> <span class="hljs-string">"✅ 镜像 <span class="hljs-variable">$img</span> 已导入 containerd"</span>
  <span class="hljs-built_in">echo</span> <span class="hljs-string">"✅ 已保存：<span class="hljs-variable">$TARGET_TAR</span>"</span>
<span class="hljs-keyword">done</span>

<span class="hljs-built_in">echo</span> <span class="hljs-string">"🎉 所有镜像保存完成！"</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"📂 存储目录：<span class="hljs-variable">$DIR</span>"</span>
</code></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[从3小时到30分钟：我的AI写作工作流完整拆解]]></title>    <link>https://juejin.cn/post/7578719771588886538</link>    <guid>https://juejin.cn/post/7578719771588886538</guid>    <pubDate>2025-12-01T14:42:16.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7578719771588886538" data-draft-id="7578719771588870154" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="从3小时到30分钟：我的AI写作工作流完整拆解"/> <meta itemprop="keywords" content="AIGC,AIOps"/> <meta itemprop="datePublished" content="2025-12-01T14:42:16.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="技术探索家"/> <meta itemprop="url" content="https://juejin.cn/user/2735240657517816"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            从3小时到30分钟：我的AI写作工作流完整拆解
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2735240657517816/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    技术探索家
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-01T14:42:16.000Z" title="Mon Dec 01 2025 14:42:16 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-01
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    1
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读15分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cd21e3452b834594862df27b001f5802~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oqA5pyv5o6i57Si5a62:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765205646&amp;x-signature=v1HInsMMzncyWD%2FjR7r0JF3lIf0%3D" alt="ai-writing-workflow.jpg" loading="lazy"/></p>
<h2 data-id="heading-0">引言</h2>
<p>之前写一篇公众号推文，我得花3个小时：1小时想选题（刷半天数据还是不知道写啥），1.5小时写初稿（写两句卡一句），最后还得改半小时。一天写两篇就累瘫了，更别提保持日更了。</p>
<p>后来我把AI整合到写作流程里，现在从选题到初稿完成只需要30分钟，而且质量比以前更稳定。关键不是让AI替你写，而是让它帮你做好每个环节的准备工作。</p>
<p>说实话，我一开始也担心用AI写的内容会不会太"机械"，读者能不能接受。但当我掌握了正确的方法后，发现AI其实是个超级高效的助手——它帮我快速度过最耗时的"启动阶段"和"框架搭建"，让我能把精力集中在真正需要创意的地方。</p>
<p>这篇文章，我会分享一套完整的AI辅助写作工作流。你会得到：</p>
<ul>
<li><strong>4步完整工作流</strong>：选题→大纲→初稿→润色，每步都有具体方法</li>
<li><strong>4个实战Prompt模板</strong>：直接复制就能用，不用自己摸索</li>
<li><strong>主流工具对比</strong>：ChatGPT、Claude、文心一言该选哪个</li>
<li><strong>去AI味技巧</strong>：让AI生成的内容更人性化的5个方法</li>
<li><strong>完整案例拆解</strong>：从选题到成稿的真实过程</li>
</ul>
<p>看完这篇，你马上就能用起来，立刻见效。</p>
<hr/>
<h3 data-id="heading-1">第一章：AI辅助写作的正确打开方式</h3>
<p>我见过太多人用AI写作的方式都是错的。</p>
<p><strong>最常见的三个误区：</strong></p>
<p>第一个是直接让AI写全文。打开ChatGPT，输入"写一篇关于XXX的文章"，然后把生成的内容直接复制粘贴。结果呢？AI味太重，读者一眼就能看出来，而且内容缺乏深度和个人见解。这样用AI，其实是浪费了它的能力。</p>
<p>第二个是只在卡壳时才想起来用AI。写了一半写不下去了，才打开ChatGPT问"怎么继续"。这种方式没有系统化，效率提升有限。就像开车只在迷路时看导航，而不是提前规划路线。</p>
<p>第三个是用一个工具干所有事。要么全用ChatGPT，要么全用Claude，但其实不同环节需要不同工具的优势。选题适合ChatGPT的发散思维，润色适合Claude的细腻表达。</p>
<p><strong>正确的理念是什么？</strong></p>
<p>AI不是替代你写作，而是辅助你的思考和执行。我现在的方式是把写作拆解成4个环节：</p>
<ol>
<li><strong>选题阶段</strong>：AI帮我快速生成10-20个选题方向，并评估每个选题的潜力</li>
<li><strong>大纲阶段</strong>：AI帮我搭建文章框架，确定每部分的核心要点</li>
<li><strong>初稿阶段</strong>：AI帮我快速生成每个段落的初稿，我负责补充细节和个人经验</li>
<li><strong>润色阶段</strong>：AI帮我去掉生硬表达，优化节奏和可读性</li>
</ol>
<p>核心原则是：<strong>AI做准备工作，人做创意决策</strong>。</p>
<p><strong>效率对比有多大？</strong></p>
<p>我自己的真实数据：</p>
<ul>
<li><strong>传统流程</strong>：选题1小时 + 写作2小时 + 修改1小时 = 4小时</li>
<li><strong>AI辅助流程</strong>：选题15分钟 + 大纲10分钟 + 初稿15分钟 + 润色20分钟 = 1小时</li>
</ul>
<p>为什么能快这么多？因为AI帮你快速度过了"启动阶段"（不知道写什么）和"框架搭建"（不知道怎么组织），这两个环节往往占掉70%的时间。一旦有了方向和框架，写作就会变得顺畅很多。</p>
<p>根据36氪的《2025内容创作行业白皮书》，使用AI的创作者平均效率提升3-5倍。我自己的感受是，一周的内容产出量从2篇提升到了10篇，而且质量更稳定了。</p>
<p>你可能会问，这真的有用吗？我的建议是：看完这篇文章，马上试一次。你会立刻感受到差异。</p>
<hr/>
<h3 data-id="heading-2">第二章：4步AI辅助写作工作流详解</h3>
<p>好，现在进入最核心的部分——完整的4步工作流。每一步我都会给你可以直接复制的Prompt模板。</p>
<h4 data-id="heading-3">步骤1：AI辅助选题（15分钟）</h4>
<p><strong>最头疼的问题</strong>：不知道写什么，担心选题没人看。</p>
<p>我以前选题能纠结1个小时，打开微信指数看数据，刷小红书找热点，脑子里想了20个方向，最后还是不确定哪个好。后来我发现，用AI生成选题方向，效率能提升10倍。</p>
<p><strong>AI如何帮你选题？</strong></p>
<ul>
<li>分析你的领域，生成10-20个选题方向</li>
<li>评估每个选题的吸引力（搜索量、竞争度）</li>
<li>提供不同角度：痛点解决型、对比分析型、案例拆解型</li>
</ul>
<p><strong>实战Prompt模板：</strong></p>
<pre><code class="hljs language-text" lang="text">你是一位资深内容策划，请帮我生成10个[领域]的选题方向。

背景：
- 目标读者：[描述受众，比如：25-35岁的新手父母，关注儿童教育]
- 内容平台：[公众号/小红书/知乎等]
- 内容风格：[干货/故事/观点等]

要求：
1. 每个选题包含：标题方向、核心卖点、目标关键词
2. 优先考虑以下角度：
   - 痛点解决型（如"如何..."、"X个方法..."）
   - 对比分析型（如"A vs B"、"选择指南"）
   - 案例拆解型（如"实战案例"、"我的经验"）
3. 评估每个选题的吸引力（1-5分）

输出格式：
选题1：[标题方向]
- 核心卖点：
- 目标关键词：
- 吸引力评分：
</code></pre>
<p><strong>实际使用示例：</strong></p>
<p>我有次用这个模板生成"职场效率工具"的选题，AI给了我10个方向，其中一个是"从3小时到30分钟：我的AI写作工作流完整拆解"，吸引力评分5分。我一看，这个选题既有对比数据（3小时到30分钟），又承诺详细方法（完整拆解），立刻就决定写这个。</p>
<p>整个选题过程，从输入Prompt到确定方向，只花了15分钟。</p>
<h4 data-id="heading-4">步骤2：AI辅助大纲（10分钟）</h4>
<p><strong>最头疼的问题</strong>：文章结构混乱，写着写着就跑偏了。</p>
<p>以前我写文章经常是想到哪写到哪，写到一半发现逻辑不通，又得推倒重来。现在我用AI搭建大纲，先把框架定好，写作就顺畅多了。</p>
<p><strong>AI如何帮你搭大纲？</strong></p>
<ul>
<li>快速搭建文章框架（引言、主体、结论）</li>
<li>确定每部分的核心要点（不会遗漏关键信息）</li>
<li>预估字数分配（避免某部分写太长或太短）</li>
</ul>
<p><strong>实战Prompt模板：</strong></p>
<pre><code class="hljs language-text" lang="text">请为以下文章生成详细大纲：

标题：[你选定的标题]
目标字数：[1500-2000字]
目标读者：[描述受众及其痛点]

大纲要求：
1. 包含引言、3-5个主体章节、结论
2. 每个章节标注：
   - 核心要点（3-5个子要点）
   - 建议字数
   - 需要的案例/数据
3. 引言要有吸引力，结论要有行动号召

额外要求：
- 逻辑流畅，层层递进
- 避免空洞内容，每部分都要有价值
</code></pre>
<p><strong>实际使用示例：</strong></p>
<p>当我决定写"AI写作工作流"这个选题后，我用这个Prompt生成大纲。AI给了我一个5段式结构：引言（困境对比）→正确理念→4步工作流→工具对比→完整案例→结论。</p>
<p>我看了一遍，觉得结构很清晰，但第二章"4步工作流"需要更详细的子要点，所以我又针对这章单独生成了详细大纲。整个过程10分钟搞定。</p>
<p>关键是：<strong>大纲生成后，你需要人工检查和调整</strong>。AI给的是通用框架，但你要根据自己的经验补充细节。</p>
<h4 data-id="heading-5">步骤3：AI辅助初稿（15分钟）</h4>
<p><strong>最头疼的问题</strong>：写作卡壳，不知道怎么展开每个段落。</p>
<p>以前我写到某个部分，脑子里有想法，但不知道怎么用文字表达，经常卡住半小时写不出一个字。现在我用AI快速生成初稿，然后在初稿基础上修改，效率提升太多了。</p>
<p><strong>AI如何帮你写初稿？</strong></p>
<ul>
<li>基于大纲快速生成每个章节的内容</li>
<li>提供段落展开思路（你可能没想到的角度）</li>
<li>补充案例和数据（让内容更丰满）</li>
</ul>
<p><strong>关键技巧：分段生成，而不是一次性生成全文</strong></p>
<p>为什么？因为分段生成质量更高，更容易控制。一次生成全文，AI容易跑偏，而且你很难逐段审核。我的方法是：一次生成1-2个段落，人工审核后继续。</p>
<p><strong>实战Prompt模板：</strong></p>
<pre><code class="hljs language-text" lang="text">基于以下大纲，撰写[第X章]的内容：

【大纲内容】
[粘贴该章节的大纲]

【写作要求】
1. 字数：约[X]字
2. 风格：
   - 用第一人称，像朋友聊天
   - 用真实案例和具体场景
   - 避免空洞说教，多用"你可以这样..."的句式
3. 结构：
   - 开头点明这部分要解决什么问题
   - 中间用2-3个要点展开
   - 结尾总结关键行动
4. 避免：
   - 不要用"综上所述"、"因此"等AI味词汇
   - 不要过度使用"首先、其次、最后"
   - 不要堆砌专业术语

【参考信息】
[如果有相关资料或案例，在这里提供]
</code></pre>
<p><strong>实际使用示例：</strong></p>
<p>当我写"选题阶段"这部分时，我用这个Prompt生成了初稿。AI给了我一个3段结构：痛点描述→AI如何帮忙→Prompt模板→实际案例。</p>
<p>初稿质量还不错，但我发现缺少个人经历，于是我加了一句："我以前选题能纠结1个小时，打开微信指数看数据，刷小红书找热点，脑子里想了20个方向，最后还是不确定哪个好。"这样一加，内容就有温度了。</p>
<p><strong>记住：AI生成的是初稿，你的工作是让它变得更真实、更有个性。</strong></p>
<h4 data-id="heading-6">步骤4：AI辅助润色（20分钟）</h4>
<p><strong>最头疼的问题</strong>：初稿写完了，但总觉得不够"人性化"，有点生硬。</p>
<p>这是我花时间最多的环节。因为AI生成的初稿虽然逻辑清晰，但经常有些"AI味"——比如"因此"、"综上所述"这些词，或者段落过于完美对称。读者一看就知道是AI写的。</p>
<p><strong>AI如何帮你润色？</strong></p>
<ul>
<li>去除AI味，替换生硬表达</li>
<li>优化句子节奏，长短句结合</li>
<li>增强人性化，加入对话感</li>
</ul>
<p><strong>实战Prompt模板：</strong></p>
<pre><code class="hljs language-text" lang="text">请帮我优化以下文章段落，重点去除AI味，增强人性化表达：

【原文】
[粘贴需要优化的段落]

【优化要求】
1. 去AI味：
   - 替换：因此→所以、实际上→其实、相当→挺
   - 删除：综上所述、不难发现、值得注意的是
   - 避免：过于完美的三段论逻辑
2. 增加人性化：
   - 加入个人经历或观察："我发现..."、"有次我..."
   - 用具体细节替代笼统概念
   - 适当使用疑问句和读者对话
3. 优化节奏：
   - 长短句结合
   - 适当断句，避免超长段落
   - 关键信息用短句突出

【保持不变】
- 核心观点和信息
- 整体结构
</code></pre>
<p><strong>去AI味的5个实用技巧：</strong></p>
<ol>
<li><strong>替换AI常用连接词</strong>：因此→所以、实际上→其实、相当→挺、然而→但</li>
<li><strong>打破完美对称的结构</strong>：不要每段都是"首先、其次、最后"，适当用"还有一个点"、"另外"</li>
<li><strong>增加具体细节和场景</strong>：不说"效率提升很多"，而说"从3小时缩短到30分钟"</li>
<li><strong>适当表达不确定性</strong>：不总是说"一定"、"必须"，可以说"我觉得"、"可能"</li>
<li><strong>加入个人色彩和情感</strong>：分享你的困惑、惊喜、失望，让读者感受到真实的人</li>
</ol>
<p><strong>实际使用示例：</strong></p>
<p>我用这个Prompt优化了引言部分。原本AI生成的开头是："在当今内容创作领域，效率是关键因素。AI工具可以显著提升写作效率。"</p>
<p>优化后变成："之前写一篇公众号推文，我得花3个小时：1小时想选题，1.5小时写初稿,还得改半小时。一天写两篇就累瘫了。"</p>
<p>你看，优化后是不是更真实、更有代入感？</p>
<p><strong>小结：4步工作流的时间分配</strong></p>
<p>选题（15分钟）→ 大纲（10分钟）→ 初稿（15分钟）→ 润色（20分钟）= <strong>总计1小时</strong></p>
<p>对比传统流程的4小时，效率提升了<strong>75%</strong>。而且这还是保守估计，随着你对工作流越来越熟练，速度还会更快。</p>
<hr/>
<h3 data-id="heading-7">第三章：主流AI写作工具对比和选择</h3>
<p>工具太多，到底该用哪个？这是我最常被问的问题。</p>
<p>我自己测试过市面上所有主流的AI写作工具，下面给你一个完整对比。</p>
<h4 data-id="heading-8">1. ChatGPT（最全能）⭐⭐⭐⭐⭐</h4>
<p><strong>优势：</strong></p>
<ul>
<li>功能最全面，从选题到润色都能搞定</li>
<li>免费版就能满足大部分需求</li>
<li>生成速度快，输出质量稳定</li>
</ul>
<p><strong>适用场景</strong>：从选题到润色的所有环节</p>
<p><strong>成本</strong>：免费版够用，Plus版 $20/月（如果高频使用建议升级）</p>
<p><strong>我的使用感受</strong>：ChatGPT是我用得最多的工具，80%的工作流都靠它。尤其是选题和大纲阶段，ChatGPT的发散思维特别强，能给你很多意想不到的角度。</p>
<h4 data-id="heading-9">2. Claude（最人性化）⭐⭐⭐⭐</h4>
<p><strong>优势：</strong></p>
<ul>
<li>输出更人性化，逻辑更清晰</li>
<li>特别擅长长文本的理解和生成</li>
<li>对中文的语境理解比ChatGPT好一些</li>
</ul>
<p><strong>适用场景</strong>：大纲搭建、内容润色</p>
<p><strong>成本</strong>：免费版限制较多，Pro版 $20/月</p>
<p><strong>我的使用感受</strong>：Claude在润色环节特别好用。当你用ChatGPT生成了初稿，想让内容更"人性化"时，把内容丢给Claude优化，效果会更好。</p>
<h4 data-id="heading-10">3. 文心一言（国内选择）⭐⭐⭐⭐</h4>
<p><strong>优势：</strong></p>
<ul>
<li>对中文语境理解好，生成的内容更符合国内表达习惯</li>
<li>无需翻墙，访问稳定</li>
<li>对公众号、小红书等平台的风格理解到位</li>
</ul>
<p><strong>适用场景</strong>：公众号、小红书等中文内容创作</p>
<p><strong>成本</strong>：基础功能免费</p>
<p><strong>我的使用感受</strong>：如果你主要写中文内容，而且不想折腾翻墙，文心一言是最佳选择。它对"小红书爆款标题"、"公众号开头"这些场景特别理解。</p>
<h4 data-id="heading-11">4. Notion AI（最便捷）⭐⭐⭐</h4>
<p><strong>优势：</strong></p>
<ul>
<li>集成在笔记工具中，写作润色一体化</li>
<li>可以直接在文档中调用AI</li>
<li>适合已经在用Notion管理内容的创作者</li>
</ul>
<p><strong>适用场景</strong>：已使用Notion的创作者</p>
<p><strong>成本</strong>：$10/月（需要先有Notion订阅）</p>
<p><strong>我的使用感受</strong>：如果你已经在用Notion做内容管理，Notion AI确实很方便。但如果你不用Notion，就没必要为了AI单独订阅。</p>
<h4 data-id="heading-12">工具组合建议</h4>
<p>根据不同阶段，我推荐这样组合：</p>
<ul>
<li><strong>新手入门</strong>：ChatGPT免费版（全流程都能搞定）</li>
<li><strong>进阶使用</strong>：ChatGPT Plus（选题+初稿）+ Claude（润色）</li>
<li><strong>国内用户</strong>：文心一言（主力）+ ChatGPT（备用）</li>
</ul>
<p><strong>工具使用技巧：</strong></p>
<ol>
<li>同一内容在不同工具测试，选最好的输出</li>
<li>利用各工具优势：ChatGPT做发散，Claude做收敛</li>
<li>建立Prompt模板库，提高复用效率</li>
</ol>
<p>说实话，工具只是手段，关键是你的工作流。哪怕只用ChatGPT免费版，只要工作流清晰，效率也能提升好几倍。</p>
<hr/>
<h3 data-id="heading-13">第四章：进阶技巧和避坑指南</h3>
<p>掌握基础工作流后，你还可以用这些进阶技巧进一步提升效率。</p>
<h4 data-id="heading-14">进阶技巧</h4>
<p><strong>1. 建立个人Prompt模板库</strong></p>
<p>把常用的Prompt保存到Notion或飞书文档，按照不同平台分类：</p>
<ul>
<li>公众号选题Prompt</li>
<li>小红书文案Prompt</li>
<li>知乎回答Prompt</li>
</ul>
<p>我现在有20+个Prompt模板，每次写作直接调用，省去了重新想Prompt的时间。</p>
<p><strong>2. 利用AI进行内容优化</strong></p>
<p>AI不只是帮你写，还能帮你分析：</p>
<ul>
<li>用AI分析文章的SEO表现（关键词密度、可读性）</li>
<li>让AI提供标题的10个变体（选最吸引人的）</li>
<li>用AI生成不同风格的开头和结尾（A/B测试）</li>
</ul>
<p><strong>3. 批量生产内容</strong></p>
<p>如果你需要持续产出内容，可以这样做：</p>
<ul>
<li>一次生成10个大纲，批量执行</li>
<li>利用AI进行内容改写和多平台适配（一篇文章改成公众号版、小红书版、知乎版）</li>
<li>建立内容日历，系统化生产</li>
</ul>
<h4 data-id="heading-15">常见错误和避坑</h4>
<p><strong>1. 过度依赖AI</strong></p>
<p>错误做法：完全照搬AI输出，不做任何修改。
正确做法：AI提供框架，人补充细节和个性。</p>
<p><strong>2. 忽视人工审核</strong></p>
<p>错误做法：AI写完直接发布，结果出现事实错误或逻辑问题。
正确做法：必须人工检查事实、逻辑、语气。</p>
<p><strong>3. Prompt太模糊</strong></p>
<p>错误做法："帮我写一篇文章"
正确做法：使用结构化Prompt，明确受众、风格、字数、要求。</p>
<p><strong>4. 不做迭代优化</strong></p>
<p>错误做法：一个Prompt用到底，效果不好也不调整。
正确做法：根据实际效果持续优化Prompt模板。</p>
<p><strong>5. 忽视平台特性</strong></p>
<p>错误做法：所有平台用同一套内容。
正确做法：根据平台调整风格和结构（公众号要深度，小红书要视觉，知乎要专业）。</p>
<hr/>
<h3 data-id="heading-16">结论</h3>
<p>AI辅助写作的本质，不是让AI替代你，而是优化你的工作流程。</p>
<p>回顾一下核心要点：</p>
<ol>
<li><strong>4步工作流是关键</strong>：选题→大纲→初稿→润色，每个环节都有对应的Prompt模板</li>
<li><strong>工具选择看需求</strong>：ChatGPT是最全能选择，Claude适合润色，文心一言适合国内用户</li>
<li><strong>人机协作是核心</strong>：AI做80%的执行工作，人做20%的创意决策</li>
<li><strong>去AI味很重要</strong>：用Prompt优化+人工调整，让内容更人性化</li>
</ol>
<p><strong>立即行动清单：</strong></p>
<ol>
<li>保存本文的4个Prompt模板（选题、大纲、初稿、润色）</li>
<li>选择一个AI工具（推荐ChatGPT，免费版就够用）</li>
<li>用本文的工作流写一篇文章</li>
<li>记录时间，对比效率提升</li>
</ol>
<p>试试看，你会发现写作不再是痛苦的事，而是高效的创作过程。当你掌握这套方法后，再也不用为内容产出发愁了</p>
<blockquote>
<p>本文首发<a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.betterlink.top%2Fzh%2Fposts%2Fmedia%2F20250125-ai-writing-workflow%2F" target="_blank" title="https://blog.betterlink.top/zh/posts/media/20250125-ai-writing-workflow/" ref="nofollow noopener noreferrer">自个人博客</a></p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Joplin：一款真正属于你的开源笔记与待办事项应用]]></title>    <link>https://juejin.cn/post/7578699975414169600</link>    <guid>https://juejin.cn/post/7578699975414169600</guid>    <pubDate>2025-12-01T15:02:25.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7578699975414169600" data-draft-id="7578714759337361408" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Joplin：一款真正属于你的开源笔记与待办事项应用"/> <meta itemprop="keywords" content="Markdown"/> <meta itemprop="datePublished" content="2025-12-01T15:02:25.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="修己xj"/> <meta itemprop="url" content="https://juejin.cn/user/2641475936724142"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Joplin：一款真正属于你的开源笔记与待办事项应用
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2641475936724142/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    修己xj
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-01T15:02:25.000Z" title="Mon Dec 01 2025 15:02:25 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-01
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在信息爆炸的时代，我们每天都在接收、处理和产生大量信息。一款优秀的笔记软件不仅是我们记忆的延伸，更是知识管理的核心工具。如果你正在寻找一款<strong>真正尊重你数据所有权、功能全面且完全免费，并且支持多端同步</strong>的笔记应用，那么Joplin值得你深入了解。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/57e9c6cee9a949e383caebba2a78dccb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5L-u5bexeGo=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765206145&amp;x-signature=C%2FKyguXr6eeDpGMfxZY9pEe8L64%3D" alt="fill_w374_h374_g0_mark_2021012515175784.png" loading="lazy"/></p>
<p>fill_w374_h374_g0_mark_2021012515175784.png</p>
<h2 data-id="heading-0">什么是Joplin？</h2>
<p>Joplin是一款<strong>免费、开源的笔记和待办事项管理应用</strong>，它能够处理大量笔记并将其组织到不同的笔记本中。所有笔记都采用Markdown格式，这意味着你的内容永远不会被专有格式锁定。</p>
<p>该项目已经在github 上已经拥有 52.4k star</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bde59855410b4f6582623db30f7a64fb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5L-u5bexeGo=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765206145&amp;x-signature=rlUWVRc5pyx4Y1FWZ4f1%2BdQHaj0%3D" alt="ScreenShot_2025-12-01_220457_085.png" loading="lazy"/></p>
<p>ScreenShot_2025-12-01_220457_085.png</p>
<p>github 地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Flaurent22%2Fjoplin" target="_blank" title="https://github.com/laurent22/joplin" ref="nofollow noopener noreferrer">github.com/laurent22/j…</a></p>
<p>官网地址： <a href="https://link.juejin.cn?target=https%3A%2F%2Fjoplinapp.org%2F" target="_blank" title="https://joplinapp.org/" ref="nofollow noopener noreferrer">joplinapp.org/</a></p>
<h2 data-id="heading-1">核心特色与优势</h2>
<h3 data-id="heading-2">🔒 <strong>离线优先，数据自主</strong></h3>
<p>Joplin采用“离线优先”设计理念，你的所有数据都存储在本地设备上。无论是否有网络连接，你都能随时随地访问自己的笔记。这不仅是便利性的问题，更是<strong>数据主权的保障</strong>——你的笔记永远属于你。</p>
<h3 data-id="heading-3">🔄 <strong>安全同步与端到端加密</strong></h3>
<p>Joplin支持通过多种云服务进行同步，包括：</p>
<ul>
<li>Nextcloud（自建云首选）</li>
<li>Dropbox</li>
<li>OneDrive</li>
<li>Joplin Cloud（官方同步服务）</li>
<li>s3</li>
</ul>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a4f748f814f84601a3ae077e70a0b9a9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5L-u5bexeGo=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765206145&amp;x-signature=Yt3sF21oqR3Cu6TNmKAHe34HcGY%3D" alt="ScreenShot_2025-12-01_220803_263.png" loading="lazy"/></p>
<p>ScreenShot_2025-12-01_220803_263.png</p>
<p>更重要的是，所有同步都支持<strong>端到端加密</strong>，即使是云服务提供商也无法读取你的笔记内容。这种级别的安全保障在免费应用中极为罕见。</p>
<h3 data-id="heading-4">📥 <strong>强大的导入功能</strong></h3>
<p>如果你是Evernote用户，Joplin能让你<strong>无缝迁移</strong>。它可以完整导入Evernote笔记，包括：</p>
<ul>
<li>格式化内容（自动转换为Markdown）</li>
<li>资源文件（图片、附件等）</li>
<li>完整元数据（地理位置、创建时间、更新时间等）</li>
</ul>
<p>纯Markdown文件也可以轻松导入，避免了数据迁移的烦恼。</p>
<h3 data-id="heading-5">🔍 <strong>全平台全文搜索</strong></h3>
<p>无论你在哪个平台使用Joplin，都能享受到<strong>快速、高效的全文搜索</strong>。忘记笔记放在哪里？只需输入关键词，相关笔记即刻呈现。</p>
<h3 data-id="heading-6">🎨 <strong>可扩展的插件系统</strong></h3>
<p>Joplin支持插件和主题定制，你可以：</p>
<ul>
<li>从社区插件库中安装现成插件</li>
<li>使用不同主题个性化界面</li>
<li>甚至可以<strong>自己开发插件</strong>，满足特定需求</li>
</ul>
<h3 data-id="heading-7">🌐 <strong>全平台覆盖</strong></h3>
<p>Joplin几乎支持所有主流平台：</p>
<ul>
<li>桌面端：Windows、Linux、macOS</li>
<li>移动端：Android、iOS</li>
<li>浏览器扩展：Firefox和Chrome的Web Clipper，可以保存网页和截图</li>
</ul>
<h2 data-id="heading-8">为什么选择Joplin而不是其他笔记应用？</h2>
<h3 data-id="heading-9">1. <strong>真正的数据自由</strong></h3>
<p>大多数笔记应用将你的数据锁定在他们的服务器和专有格式中。Joplin使用<strong>标准Markdown格式</strong>，即使有一天你不再使用Joplin，你的笔记仍然可以轻松迁移到其他支持Markdown的应用中。</p>
<h3 data-id="heading-10">2. <strong>开源透明</strong></h3>
<p>作为开源项目，Joplin的代码对所有人开放。这意味着：</p>
<ul>
<li>没有隐藏的后门或数据收集</li>
<li>社区可以审查代码安全性</li>
<li>任何开发者都可以贡献改进</li>
<li>项目发展方向由社区共同决定</li>
</ul>
<h3 data-id="heading-11">3. <strong>隐私保护</strong></h3>
<p>端到端加密确保只有你能阅读自己的笔记。即使是Joplin开发团队也无法访问你的数据。</p>
<h3 data-id="heading-12">4. <strong>零费用门槛</strong></h3>
<p>完全免费使用，没有功能限制或订阅费用。虽然有Joplin Cloud同步服务（付费），但你完全可以选择其他免费的同步方案。</p>
<h2 data-id="heading-13">开始使用Joplin</h2>
<h3 data-id="heading-14">安装指南</h3>
<p>访问Joplin官网（joplinapp.org）即可下载适合你设备的版本。安装过程简单直观，几分钟内即可开始记录。我在这块下载的是windows 和安卓apk 两各平台的版本。下载安装的的过程都比较简单，我因为之前在公网服务器上部署过 rustfs ,我们此处也采用的是rustfs 同步多端数据，如果你有其他兼容s3协议的oss,如minio等，也可以试用，其他oneDrive、nextCloud等网盘也可做为同步工具试用。我们此处展示下如何用rustfs配置，对rustfs感兴趣的家人们也可以翻一下博主介绍rustfs部署的历史文章。</p>
<p>在windows上部署joplin之后 点击 <code>工具</code>-&gt;<code>选项</code>，点击菜单中的<code>同步</code>，<code>同步目标</code>选择<code>s3</code>, <img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6053cf9f866f4b9aa8385ed36ddc699c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5L-u5bexeGo=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765206145&amp;x-signature=pQLpSmEifer5ALm%2FYQrUiCcCydw%3D" alt="ScreenShot_2025-12-01_221816_815.png" loading="lazy"/></p>
<p>s3的存储桶应该事先创建好，创建好之后按图配置信息即可</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/30aa2cd91ee2467689c36d04248baedd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5L-u5bexeGo=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765206145&amp;x-signature=ZAyUl%2F5aeEiS82yqT9QrtgQwE1Q%3D" alt="ScreenShot_2025-12-01_222507_097.png" loading="lazy"/></p>
<p>ScreenShot_2025-12-01_222507_097.png</p>
<p>配置好之后我们就可以创建<code>笔记本</code>,创建<code>笔记</code>了，写完笔记之后点击同步，我们就可以在我们的s3文件存储系统配置的桶中看到我们同步上去的笔记了。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c7c8dc8801a24d95b0ebe60392c08602~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5L-u5bexeGo=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765206145&amp;x-signature=7XcYXfbZsiQBI8i2bygqMGlrX%2Bw%3D" alt="ScreenShot_2025-12-01_223424_749.png" loading="lazy"/></p>
<p>ScreenShot_2025-12-01_223424_749.png</p>
<p><a href="https://link.juejin.cn?target=http%3A%2F%2Fchevereto.xiuji.mynatapp.cc%2Fimage%2FXI4P" target="_blank" title="http://chevereto.xiuji.mynatapp.cc/image/XI4P" ref="nofollow noopener noreferrer"><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/430f85d4b72b43a3a39a1fac19d90844~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5L-u5bexeGo=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765206145&amp;x-signature=gmBFhABK08xdsJrKJ5%2B%2BgCkXW0c%3D" alt="ScreenShot_2025-12-01_223803_948.md.png" loading="lazy"/></a></p>
<p>ScreenShot_2025-12-01_223803_948.md.png</p>
<p>到此，我们windows端的配置就ok了，安卓手机可以在官网下载<a href="https://link.juejin.cn?target=https%3A%2F%2Fjoplinapp.org%2Fhelp%2Finstall%2F" target="_blank" title="https://joplinapp.org/help/install/" ref="nofollow noopener noreferrer"> https://joplinapp.org/help/install/</a> 下载apk，</p>
<p><a href="https://link.juejin.cn?target=http%3A%2F%2Fchevereto.xiuji.mynatapp.cc%2Fimage%2FXLAh" target="_blank" title="http://chevereto.xiuji.mynatapp.cc/image/XLAh" ref="nofollow noopener noreferrer"><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/00959b1beba74104907d7225d3625de0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5L-u5bexeGo=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765206145&amp;x-signature=2sV2nSvH5S9zeLb5wt2DG7OF4Fs%3D" alt="ScreenShot_2025-12-01_224017_013.png" loading="lazy"/></a></p>
<p>ScreenShot_2025-12-01_224017_013.png</p>
<p>安装之后打开软件，点击<code>设置</code>-&gt;<code>同步</code>，然后和windows一样配置我们的s3信息就可以了</p>
<p><a href="https://link.juejin.cn?target=http%3A%2F%2Fchevereto.xiuji.mynatapp.cc%2Fimage%2FXV5j" target="_blank" title="http://chevereto.xiuji.mynatapp.cc/image/XV5j" ref="nofollow noopener noreferrer"><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/56be7834479c4db99f7468f105847bbd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5L-u5bexeGo=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765206145&amp;x-signature=cvIVeplF%2F9CJozmeWtTOEWlq4PQ%3D" alt="ScreenShot_2025-12-01_224341_221.png" loading="lazy"/></a></p>
<p>ScreenShot_2025-12-01_224341_221.png</p>
<p><a href="https://link.juejin.cn?target=http%3A%2F%2Fchevereto.xiuji.mynatapp.cc%2Fimage%2FXoTk" target="_blank" title="http://chevereto.xiuji.mynatapp.cc/image/XoTk" ref="nofollow noopener noreferrer"><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/864a19b655464a069c08d8ac1f46624d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5L-u5bexeGo=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765206145&amp;x-signature=uJH9n%2B9i5GcqVjckNmkfPtpUXk8%3D" alt="ScreenShot_2025-12-01_224357_969.png" loading="lazy"/></a></p>
<p>ScreenShot_2025-12-01_224357_969.png</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c73b7e016b4d495a9b25745615dbc113~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5L-u5bexeGo=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765206145&amp;x-signature=PVNHr%2BKOZ%2BM0QAL9XQjnFHpQibg%3D" alt="ScreenShot_2025-12-01_224424_065.png" loading="lazy"/></p>
<p>ScreenShot_2025-12-01_224424_065.png</p>
<p>配置好之后点击同步我们就可以多端同步我们的笔记内容了。</p>
<h2 data-id="heading-15">结语</h2>
<p>在数字时代，我们的笔记不仅仅是文字，更是思考的轨迹、创意的种子和知识的宝库。Joplin提供了一种<strong>既强大又尊重用户</strong>的解决方案，让你在享受现代化笔记功能的同时，完全掌控自己的数据。</p>
<p>无论你是学生、研究者、开发者还是知识工作者，Joplin都值得一试。它可能不是最华丽的笔记应用，但它绝对是最值得信赖的伙伴之一——永远不会将你的数据作为商品，永远不会在你最需要时因为网络问题而无法访问，永远不会在你习惯使用后开始收取高额费用。</p>
<p><strong>你的笔记，本就该完全属于你。</strong> Joplin让这个简单的理念成为现实。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Nano Banana Pro 很强，但你要学会写提示词才能为所欲为]]></title>    <link>https://juejin.cn/post/7578681104292544555</link>    <guid>https://juejin.cn/post/7578681104292544555</guid>    <pubDate>2025-12-01T13:06:05.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7578681104292544555" data-draft-id="7578681104292528171" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Nano Banana Pro 很强，但你要学会写提示词才能为所欲为"/> <meta itemprop="keywords" content="AIGC,人工智能,MCP"/> <meta itemprop="datePublished" content="2025-12-01T13:06:05.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="冴羽"/> <meta itemprop="url" content="https://juejin.cn/user/712139234359182"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Nano Banana Pro 很强，但你要学会写提示词才能为所欲为
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/712139234359182/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    冴羽
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-01T13:06:05.000Z" title="Mon Dec 01 2025 13:06:05 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-01
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读10分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">1. 前言</h2>
<p>如果你已经学会：</p>
<ol>
<li>
<p>免费使用 Nano Banana Pro： <a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FtYKzM0PIvBm5QG08SW3_BA" target="_blank" title="https://mp.weixin.qq.com/s/tYKzM0PIvBm5QG08SW3_BA" ref="nofollow noopener noreferrer">6 个白嫖 Nano Banana Pro 的网站</a></p>
</li>
<li>
<p>使用提示词库复刻惊艳图片：<a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FxZQNPPwGxhzWhGsr-alKkg" target="_blank" title="https://mp.weixin.qq.com/s/xZQNPPwGxhzWhGsr-alKkg" ref="nofollow noopener noreferrer">一次找齐！1000 个 Nano Banana Pro 提示词</a></p>
</li>
</ol>
<p>那本篇我们来点干货 —— 如何写出好的提示词。</p>
<p>之所以要学习如何写提示词，是因为绝大部分人在写提示词时，都是一种 <strong>“随缘”</strong> 的状态——有的地方写得详细，有的地方却被遗漏了，这就带来了 <strong>很大的不确定性</strong> 。</p>
<p>所以本篇我们就来聊聊如何通过结构化的提示词，提升图片生成的质量，<strong>让 Nano Bnana 生成的每一张图都是高水准的图片。</strong></p>
<h2 data-id="heading-1">2. 生成图片</h2>
<h3 data-id="heading-2">2.1. 逼真场景</h3>
<p>如果要生成逼真的图片，最好使用摄影术语，设定拍摄角度、镜头类型、光线和细节，引导模型生成逼真的效果。</p>
<p>英文模板为：</p>
<pre><code class="hljs language-plain" lang="plain">A photorealistic [shot type] of [subject], [action or expression], set in
[environment]. The scene is illuminated by [lighting description], creating
a [mood] atmosphere. Captured with a [camera/lens details], emphasizing
[key textures and details]. The image should be in a [aspect ratio] format.
</code></pre>
<p>中文模板为：</p>
<blockquote>
<p>一张高度写实的 <strong>[镜头类型]</strong> ，主体为 <strong>[拍摄对象]</strong> ， <strong>[动作或表情]</strong> ，场景设定在 <strong>[环境]</strong> 中。场景由 <strong>[光线描述]</strong> 照明，营造出 <strong>[氛围]</strong> 的氛围。使用 <strong>[相机/镜头细节]</strong> 拍摄，突出 <strong>[关键纹理和细节]</strong> 。图像应采用 <strong>[纵横比]</strong> 格式。</p>
</blockquote>
<p>让我们举个例子：</p>
<blockquote>
<p>一幅高度写实的特写肖像，描绘了一位年长的中国陶艺家。他脸上有着深深的、被阳光刻下的皱纹，带着温暖而洞悉一切的微笑。他正仔细检查一个刚上釉的茶碗。场景设定在他那质朴且阳光充足的工作室里。柔和的黄金时刻光线透过窗户洒入，照亮了黏土细腻的纹理。这幅肖像使用 85 毫米人像镜头拍摄，背景呈现出柔和模糊的效果（焦外成像）。整体氛围宁静而娴熟。肖像采用垂直构图。</p>
</blockquote>
<p>效果如下：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3b59c455ecfc4fd687c5bd73e4a1dca1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Ya05769:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765199164&amp;x-signature=lSPTt3BGowVi4I4UedTcAy5uBI4%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-3">2.2. 风格插画或贴纸</h3>
<p>如果要创建插画、贴纸、图标等资源，要明确说明样式并要求使用透明的背景。</p>
<p>英文模板为：</p>
<pre><code class="hljs language-plain" lang="plain">A [style] sticker of a [subject], featuring [key characteristics] and a
[color palette]. The design should have [line style] and [shading style].
The background must be transparent.
</code></pre>
<p>中文模板为：</p>
<blockquote>
<p>一张 <strong>[风格]</strong> 的 <strong>[主体]</strong> 贴纸，具有 <strong>[关键特征]</strong> 和 <strong>[色彩搭配]</strong> 。设计应采用 <strong>[线条风格]</strong> 和 <strong>[阴影风格]</strong> 。背景必须是透明的。</p>
</blockquote>
<p>举个例子：</p>
<blockquote>
<p>一张可爱风格的贴纸，上面是一只开心的小熊猫，戴着一顶小小的竹帽，正在啃着一片绿色的竹叶。设计采用了醒目清晰的轮廓、简单的卡通渲染，以及鲜艳的色彩搭配。背景必须是透明的。</p>
</blockquote>
<p>效果如下：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ae4f4c9ce0714fe5884ce15f98cea5fd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Ya05769:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765199164&amp;x-signature=N86jW4j4r2MJPqXSEO1wEpT%2BeLs%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-4">2.3. 精准的带文字渲染</h3>
<p>Nano Banana Pro 强化了文本渲染方面的表现，以前生成汉字的时候还有不少乱码，到 Pro 已经明显改善了很多。但在写提示词时，还是要清晰地说明文字内容、字体样式和整体设计。</p>
<p>英文模板为：</p>
<pre><code class="hljs language-plain" lang="plain">Create a [image type] for [brand/concept] with the text "[text to render]"
in a [font style]. The design should be [style description], with a
[color scheme].
</code></pre>
<p>中文模板为：</p>
<blockquote>
<p>为 <strong>[品牌/概念]</strong> 创建一个 <strong>[图像类型]</strong> ， <strong>[要渲染的文字]</strong> 采用 <strong>[文字风格]</strong> 。设计应具有 <strong>[风格描述]</strong> ，并采用 <strong>[配色方案]</strong> 。</p>
</blockquote>
<p>举个例子：</p>
<blockquote>
<p>为一家名为 “The Daily Grind” 的咖啡店设计一个现代简约风格的标志。文字部分采用简洁、粗体的无衬线字体。配色方案为黑白两色。将标志置于圆形之中。巧妙地融入一颗咖啡豆元素。</p>
</blockquote>
<p>效果如下：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/adbe92278142455da54fdfffdf7dcc81~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Ya05769:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765199164&amp;x-signature=3L37Fz1WDVcoeELN9GV7AdJUIbo%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-5">2.4. 产品摄影</h3>
<p>为电商、广告或品牌制作专业的商品图片。</p>
<p>英文模板为：</p>
<pre><code class="hljs language-plain" lang="plain">A high-resolution, studio-lit product photograph of a [product description]
on a [background surface/description]. The lighting is a [lighting setup,
e.g., three-point softbox setup] to [lighting purpose]. The camera angle is
a [angle type] to showcase [specific feature]. Ultra-realistic, with sharp
focus on [key detail]. [Aspect ratio].
</code></pre>
<p>中文模板为：</p>
<blockquote>
<p>一张高分辨率、工作室灯光照明的 <strong>[产品描述]</strong> 产品照片，背景是 <strong>[背景]</strong> 。灯光采用 <strong>[照明设置]</strong> ，目的是 <strong>[照明用途]</strong> 。相机角度为 <strong>[角度类型]</strong> ，以展示 <strong>[特定特征]</strong> 。超写实风格，对 <strong>[关键细节]</strong> 聚焦清晰。 <strong>[纵横比]</strong> 。</p>
</blockquote>
<p>举个例子：</p>
<blockquote>
<p>一张高分辨率、工作室灯光照明的极简主义哑光黑色陶瓷咖啡杯产品照片，放置在抛光的混凝土表面上。灯光采用三点柔光箱设置，旨在营造柔和、漫射的高光并消除刺眼的阴影。相机角度为略微升高的 45 度角，以展示其简洁的线条。超写实风格，清晰聚焦于从咖啡中升起的蒸汽。正方形图像。</p>
</blockquote>
<p>效果如下：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3fa59490bc8e4b92a7f8b59c45df09a2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Ya05769:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765199164&amp;x-signature=kaVlcEW4IjSf2uO4cuY6IRmQtG0%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-6">2.5. 极简主义与留白设计</h3>
<p>英文模板为：</p>
<pre><code class="hljs language-plain" lang="plain">A minimalist composition featuring a single [subject] positioned in the
[bottom-right/top-left/etc.] of the frame. The background is a vast, empty
[color] canvas, creating significant negative space. Soft, subtle lighting.
[Aspect ratio].
</code></pre>
<p>中文模板为：</p>
<blockquote>
<p>一幅极简主义构图，画面中单一的 <strong>[主体]</strong> 位于画框的 <strong>[位置]</strong> 。背景是一片广阔、空旷的 <strong>[颜色]</strong> 画布，营造出大量的留白。光线柔和、微妙。 <strong>[宽高比]</strong> 。</p>
</blockquote>
<p>举个例子：</p>
<blockquote>
<p>一幅极简风格的构图，画面右下角放置着一片精致的红色枫叶。背景是一片广阔、空旷的米白色画布，为文字留出了大量的留白空间。左上角有柔和、漫射的光线。方形图像。</p>
</blockquote>
<p>效果如下：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a85baca5c343455ba54c6dc9065349a4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Ya05769:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765199164&amp;x-signature=nomj0WyqQrCT2S9l3VL9l8I5n28%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-7">2.6. 连环画与分镜</h3>
<p>利用模型对角色一致性和场景描述的理解，制作多格漫画或故事板。</p>
<p>英文模板为：</p>
<pre><code class="hljs language-plain" lang="plain">Make a 3 panel comic in a [style]. Put the character in a [type of scene].
</code></pre>
<p>中文模板为：</p>
<blockquote>
<p>制作一个 3 格漫画，风格为 <strong>[风格]</strong> 。让角色处于 <strong>[场景类型]</strong> 中。</p>
</blockquote>
<p>举个例子：</p>
<blockquote>
<p>创作一个三格漫画，采用粗犷的黑色电影艺术风格，运用高对比度的黑白墨水绘制。让角色处于一个幽默的场景中。</p>
</blockquote>
<p>用了一张马斯克的图片：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/10ef56f5d2344c73bf51242df4c3876c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Ya05769:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765199164&amp;x-signature=%2BB%2Fi8qIx5qPoPlgdO%2Ft%2FYi5YbaU%3D" alt="" loading="lazy"/></p>
<p>效果如下：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/47f0e1b6300148c6a2e9581a3ac8b1f2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Ya05769:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765199164&amp;x-signature=9i%2Bk3q9KcThWdbpYVoAqckh0dmM%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-8">3. 修改图片</h2>
<h3 data-id="heading-9">3.1. 添加或删除元素</h3>
<p>提供图片并描述修改内容。模型将与原始图片的风格、灯光和透视效果保持一致。</p>
<p>英文模板为：</p>
<pre><code class="hljs language-plain" lang="plain">Using the provided image of [subject], please [add/remove/modify] [element] to/from the scene. Ensure the change is [description of how the change should integrate].
</code></pre>
<p>中文模板为：</p>
<blockquote>
<p>请使用提供的 <strong>[主体]</strong> 图片，在场景中 <strong>[添加/移除/修改] [元素]</strong> 。确保这一更改能 <strong>[按描述的方式融入场景]</strong> 。</p>
</blockquote>
<p>举个例子：</p>
<blockquote>
<p>请使用我提供的那张我的猫咪的照片，在它的头上加一顶小小的针织巫师帽。让它看起来坐得很舒服，并且与照片柔和的光线相匹配</p>
</blockquote>
<p>效果如下：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/42ea031302f34e838e84a6c70e6dae8b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Ya05769:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765199164&amp;x-signature=x9CK5CvWJgew8PU17gF0xYoRlAI%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-10">3.2. 局部重绘</h3>
<p>英文模板为：</p>
<pre><code class="hljs language-plain" lang="plain">Using the provided image, change only the [specific element] to [new
element/description]. Keep everything else in the image exactly the same,
preserving the original style, lighting, and composition.
</code></pre>
<p>中文模板为：</p>
<blockquote>
<p>使用提供的图片，仅将 <strong>[特定元素]</strong> 更改为 <strong>[新元素/描述]</strong> 。保持图片中的其他所有内容完全不变，保留原有的风格、光线和构图。</p>
</blockquote>
<p>举个例子：</p>
<blockquote>
<p>“使用提供的客厅图片，只将蓝色沙发换成复古的棕色皮质切斯特菲尔德沙发。房间的其余部分，包括沙发上的抱枕和照明，保持不变。”</p>
</blockquote>
<p>效果如下：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4d5128d86db6469d9057a023efee6447~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Ya05769:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765199164&amp;x-signature=JUpXblvZKkAfIBBISVM17AXNjrE%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-11">3.3. 风格迁移</h3>
<p>英文模板为：</p>
<pre><code class="hljs language-plain" lang="plain">Transform the provided photograph of [subject] into the artistic style of [artist/art style]. Preserve the original composition but render it with [description of stylistic elements].
</code></pre>
<p>中文模板为：</p>
<blockquote>
<p>将提供的 <strong>[主体]</strong> 照片转换为 <strong>[艺术家/艺术风格]</strong> 的艺术风格。保留原始构图，但用 <strong>[风格元素描述]</strong> 进行渲染。</p>
</blockquote>
<p>举个例子：</p>
<blockquote>
<p>将所提供的现代城市街道夜景照片转换为文森特·梵高《星月夜》的艺术风格。保留建筑物和汽车的原始构图，但用旋转的厚涂笔触以及深邃的蓝色和明亮的黄色构成的富有戏剧性的色彩来呈现所有元素。</p>
</blockquote>
<p>效果如下：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/01ea8bd5074c44428ccebd52ac46d252~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Ya05769:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765199164&amp;x-signature=o%2BwfYEzKuzLmXffuD08%2BCWuvZws%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-12">3.4. 高级合成</h3>
<p>英文模板为：</p>
<pre><code class="hljs language-plain" lang="plain">Create a new image by combining the elements from the provided images. Take
the [element from image 1] and place it with/on the [element from image 2].
The final image should be a [description of the final scene].
</code></pre>
<p>中文模板为：</p>
<blockquote>
<p>通过组合所提供图像中的元素来创建一幅新图像。提取 <strong>[图像 1 中的元素]</strong> ，并将其与 <strong>[图像 2 中的元素]</strong> 放在一起/置于 <strong>[图像 2 中的元素]</strong> 之上。最终图像应该是 <strong>[对最终场景的描述]</strong> 。</p>
</blockquote>
<p>举个例子：</p>
<blockquote>
<p>创作一张专业的电商时尚照片。将第一张图片中的蓝色碎花连衣裙取出，让第二张图片中的女士穿上它。生成一张该女士穿着这条连衣裙的逼真全身照，并调整光影以匹配户外环境。</p>
</blockquote>
<p>效果如下：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d005d97548b740a6a310539e87cf733a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Ya05769:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765199164&amp;x-signature=B6t5yNurupOk6dDTphD3AgK206M%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-13">3.5. 高保真细节保留</h3>
<p>英文模板为：</p>
<pre><code class="hljs language-plain" lang="plain">Using the provided images, place [element from image 2] onto [element from
image 1]. Ensure that the features of [element from image 1] remain
completely unchanged. The added element should [description of how the
element should integrate].
</code></pre>
<p>中文模板为：</p>
<blockquote>
<p>使用提供的图像，将 <strong>[图像 2 中的元素]</strong> 放置到 <strong>[图像 1 中的元素]</strong> 上。确保 <strong>[图像 1 中的元素]</strong> 的特征完全不变。添加的元素应 <strong>[描述该元素应如何整合]</strong> 。</p>
</blockquote>
<p>举个例子：</p>
<blockquote>
<p>选取第一张图片中那位有着棕色头发、蓝色眼睛且表情平和的女性。将第二张图片中的标志添加到她的黑色 T 恤上。确保这位女性的脸部及五官完全保持不变。该标志应看起来像是自然印在面料上的，要顺着衬衫的褶皱呈现。</p>
</blockquote>
<p>效果如下：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c543894e525844d8b8949e3bb5a280b9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Ya05769:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765199164&amp;x-signature=Hpdu%2BWDJBF%2Frd0f6Ky8V9iLJInM%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-14">3.6. 草图变成品</h3>
<p>英文模板为：</p>
<pre><code class="hljs language-plain" lang="plain">Turn this rough [medium] sketch of a [subject] into a [style description]
photo. Keep the [specific features] from the sketch but add [new details/materials].
</code></pre>
<p>中文模板为：</p>
<blockquote>
<p>将这幅关于 <strong>[主题]</strong> 的粗略 <strong>[媒介]</strong> 草图转化为一张符合 <strong>[风格描述]</strong> 的照片。保留草图中的 <strong>[具体特征]</strong> ，但添加 <strong>[新细节/材料]</strong> 。</p>
</blockquote>
<p>举个例子：</p>
<blockquote>
<p>把这幅未来汽车的铅笔草图变成展厅里成品概念车的精致照片。保留草图中的流畅线条和低矮轮廓，但要添加金属蓝色漆面和霓虹轮圈灯光。</p>
</blockquote>
<p>效果如下：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2c60237736224595bea248cc2b87d78c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Ya05769:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765199164&amp;x-signature=LQpuOY5037Sl%2BreVozycwEc5hbg%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-15">3.7. 360 度全景</h3>
<p>英文模板为：</p>
<pre><code class="hljs language-plain" lang="plain">A studio portrait of [person] against [background], [looking forward/in profile looking right/etc.]
</code></pre>
<p>中文模板为：</p>
<blockquote>
<p>一幅 <strong>[人物]</strong> 的工作室肖像照，背景为 <strong>[背景]</strong> ， <strong>[人物]</strong> 面向前方/侧头向右看等。</p>
</blockquote>
<p>举个例子：</p>
<blockquote>
<p>一张这位男士的工作室肖像照，背景为白色，他侧身向右看。</p>
</blockquote>
<p>效果如下：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ed36804f455143da919e74ade83c878f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Ya05769:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765199164&amp;x-signature=6%2FJ70bpj90UELZbXrfbrs42UNcQ%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-16">4. 提示词最佳实践</h2>
<ul>
<li>**细节越多越好：**提供的信息越多，对输出结果的操控程度就越详细
<ul>
<li>❌ “奇幻的盔甲”</li>
<li>✅ “华丽的精灵板甲，刻着银叶图案，高领设计，带有猎鹰翅膀形状的肩甲”</li>
</ul>
</li>
<li>**提供上下文和意图说明：**模型对上下文的理解会影响最终输出
<ul>
<li>❌ “设计解决方案”</li>
<li>✅ “为极简护肤品牌设计解决方案”</li>
</ul>
</li>
<li><strong>不断迭代和优化</strong>：不要指望第一次尝试就能生成完美的图片，利用模型的对话特性进行小幅更改。
<ul>
<li>✅ “这很棒，但你能让光线更亮一些吗？”</li>
<li>✅ “保持所有内容不变，但让角色的表情更简洁一些。”</li>
</ul>
</li>
<li><strong>使用分步指令</strong>：对于包含多个元素的复杂场景，可以将提示拆分为多个步骤
<ul>
<li>✅ “首先，创造一个宁静、薄雾弥漫的黎明森林的背景。然后，在前景中添加一个长满苔藓的古老石祭坛。最后，将一把发光的剑祭坛放在顶部。”</li>
</ul>
</li>
<li><strong>语义化反向提示</strong>：
<ul>
<li>不要说“没有汽车”</li>
<li>而是通过“一条空无一人、没有任何交通迹象的街道”来正面描述所需的场景</li>
</ul>
</li>
<li><strong>控制镜头语言</strong>：使用摄影和电影语言来控制构图。例如<strong>广角、微距、低机位</strong>等术语</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[【Agent】MemOS 源码笔记---(2)---TreeTextMemory]]></title>    <link>https://juejin.cn/post/7578734725301944372</link>    <guid>https://juejin.cn/post/7578734725301944372</guid>    <pubDate>2025-12-01T13:20:28.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7578734725301944372" data-draft-id="7577647745110376448" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="【Agent】MemOS 源码笔记---(2)---TreeTextMemory"/> <meta itemprop="keywords" content="人工智能"/> <meta itemprop="datePublished" content="2025-12-01T13:20:28.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="罗西的思考"/> <meta itemprop="url" content="https://juejin.cn/user/351470467691175"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            【Agent】MemOS 源码笔记---(2)---TreeTextMemory
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/351470467691175/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    罗西的思考
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-01T13:20:28.000Z" title="Mon Dec 01 2025 13:20:28 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-01
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读29分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">【Agent】MemOS 源码笔记---(2)---TreeTextMemory</h2>
<ul>
<li>
<p><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer">0x00 摘要</a></p>
</li>
<li>
<p><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer">0x01 基本概念</a></p>
<ul>
<li><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer">1.1 特色</a></li>
<li><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer">1.2 定义</a></li>
<li><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer">1.3 记忆结构</a></li>
<li><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer">1.4 元数据字段</a></li>
<li><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer">1.5 API总结</a></li>
</ul>
</li>
<li>
<p><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer">0x02 示例</a></p>
<ul>
<li><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer">2.1 创建 TreeTextMemory 配置</a></li>
<li><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer">2.2 初始化 TreeTextMemory</a></li>
<li><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer">2.3 抽取结构化记忆</a></li>
<li><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer">2.4 搜索记忆</a></li>
<li><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer">2.5 从互联网检索记忆（可选）</a></li>
<li><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer">2.6 替换工作记忆</a></li>
<li><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer">2.7 备份与恢复</a></li>
<li><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer">2.8 完整代码</a></li>
</ul>
</li>
<li>
<p><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer">0x03 管理（MemoryManager）</a></p>
<ul>
<li><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer">3.1 定义</a></li>
<li><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer">3.2 主要功能</a></li>
<li><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer">3.3 GraphStructureReorganizer</a></li>
<li><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer">3.4 RelationAndReasoningDetector</a></li>
<li><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer">3.5 NodeHandler</a></li>
<li><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer">3.6 NodeHandler vs RelationAndReasoningDetector</a></li>
</ul>
</li>
<li>
<p><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer">0x04 图例</a></p>
<ul>
<li><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer">4.1 组件关系图</a></li>
<li><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer">4.2 调用流程图</a></li>
</ul>
</li>
<li>
<p><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer">0xFF 参考</a></p>
</li>
</ul>
<h3 data-id="heading-1">0x00 摘要</h3>
<p>TreeTextMemory 提供了一个完整的记忆管理系统，能存储、组织、检索和维护各种类型的文本记忆、适用需要复杂记忆管理的AI系统。这是一个基于图的、树形明文记忆，支持以结构化方式组织、关联并检索记忆，同时保留丰富的上下文信息与良好的可解释性。我们可以通过这个TreeTextMemory 对象与庞大的知识库进行交互，为AI赋予专业的领域记忆。当前使用Neo4j作为后端，未来计划支持更多图数据库。</p>
<p>因为字数太多，因此把TreeTextMemory拆分为两部分，本篇介绍基本概念和如何管理，下一篇介绍如何搜索。</p>
<h3 data-id="heading-2">0x01 基本概念</h3>
<h4 data-id="heading-3">1.1 特色</h4>
<p>TreeTextMemory 的特色如下：</p>
<ul>
<li>结构层次: 从原始文本或对话中提取结构化记忆，即像思维导图一样组织记忆——在图数据库中存储他们作为节点。</li>
<li>图风格的链接: 将记忆链接成层次结构和语义图，节点可以有父母、孩子和交叉链接，实现超越纯粹的层次结构-建立多跳推理链。</li>
<li>语义搜索+图扩展: 使用向量相似度+图遍历进行搜索，结合向量和图形的优点。</li>
<li>可解释性: 追踪记忆是如何连接、合并或随时间演变的。</li>
</ul>
<p>TreeTextMemory 适合如下场景：</p>
<ul>
<li>你需要带有可解释关系的层级基于图的明文记忆。</li>
<li>你想存储结构化知识并追踪连接关系。</li>
<li>适用于知识图谱、概念树和多跳推理。</li>
</ul>
<h4 data-id="heading-4">1.2 定义</h4>
<p>TreeTextMemory 的略图如下：</p>
<pre><code class="hljs">TreeTextMemory
    - uses MemoryManager
    - uses Neo4jGraphDB
    - uses Embedder
    - uses LLM
    - uses Searcher
      - uses GraphMemoryRetriever
      - uses TaskGoalParser
      - uses MemoryReasoner
      - uses Reranker
</code></pre>
<p>其中关键组件为：</p>
<ul>
<li>
<p>LLM：</p>
<ul>
<li>extractor_llm：用于提取记忆特征</li>
<li>dispatcher_llm：用于任务分发和处理</li>
</ul>
</li>
<li>
<p>Embedding模型：</p>
<ul>
<li>embedder：生成文本向量表示</li>
</ul>
</li>
<li>
<p>图数据库：</p>
<ul>
<li>graph_store：存储记忆节点和关系，图链接有助于检索纯向量搜索可能遗漏的上下文。</li>
</ul>
</li>
<li>
<p>Reranker：</p>
<ul>
<li>reranker：对检索结果进行重新排序</li>
</ul>
</li>
<li>
<p>互联网检索器：</p>
<ul>
<li>internet_retriever：从互联网获取相关信息。</li>
</ul>
</li>
<li>
<p>memory_manager：</p>
<ul>
<li>负责协调和管理记忆的整个生命周期，包括添加、存储、维护和清理，是记忆系统的核心管理组件。</li>
</ul>
</li>
</ul>
<p>具体代码如下。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeTextMemory</span>(<span class="hljs-title class_ inherited__">BaseTextMemory</span>):
    <span class="hljs-string">"""General textual memory implementation for storing and retrieving memories."""</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, config: TreeTextMemoryConfig</span>):
        <span class="hljs-string">"""Initialize memory with the given configuration."""</span>
        time_start = time.time()
        self.config: TreeTextMemoryConfig = config
        self.extractor_llm: OpenAILLM | OllamaLLM | AzureLLM = LLMFactory.from_config(
            config.extractor_llm
        )

        time_start_ex = time.time()
        self.dispatcher_llm: OpenAILLM | OllamaLLM | AzureLLM = LLMFactory.from_config(
            config.dispatcher_llm
        )

        time_start_em = time.time()
        self.embedder: OllamaEmbedder = EmbedderFactory.from_config(config.embedder)

        time_start_gs = time.time()
        self.graph_store: Neo4jGraphDB = GraphStoreFactory.from_config(config.graph_db)

        time_start_rr = time.time()
        <span class="hljs-keyword">if</span> config.reranker <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
            default_cfg = RerankerConfigFactory.model_validate(
                {
                    <span class="hljs-string">"backend"</span>: <span class="hljs-string">"cosine_local"</span>,
                    <span class="hljs-string">"config"</span>: {
                        <span class="hljs-string">"level_weights"</span>: {<span class="hljs-string">"topic"</span>: <span class="hljs-number">1.0</span>, <span class="hljs-string">"concept"</span>: <span class="hljs-number">1.0</span>, <span class="hljs-string">"fact"</span>: <span class="hljs-number">1.0</span>},
                        <span class="hljs-string">"level_field"</span>: <span class="hljs-string">"background"</span>,
                    },
                }
            )
            self.reranker = RerankerFactory.from_config(default_cfg)
        <span class="hljs-keyword">else</span>:
            self.reranker = RerankerFactory.from_config(config.reranker)
        self.is_reorganize = config.reorganize

        time_start_mm = time.time()
        self.memory_manager: MemoryManager = MemoryManager(
            self.graph_store,
            self.embedder,
            self.extractor_llm,
            memory_size=config.memory_size
            <span class="hljs-keyword">or</span> {
                <span class="hljs-string">"WorkingMemory"</span>: <span class="hljs-number">20</span>,
                <span class="hljs-string">"LongTermMemory"</span>: <span class="hljs-number">1500</span>,
                <span class="hljs-string">"UserMemory"</span>: <span class="hljs-number">480</span>,
            },
            is_reorganize=self.is_reorganize,
        )
        time_start_ir = time.time()
        <span class="hljs-comment"># Create internet retriever if configured</span>
        self.internet_retriever = <span class="hljs-literal">None</span>
        <span class="hljs-keyword">if</span> config.internet_retriever <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
            self.internet_retriever = InternetRetrieverFactory.from_config(
                config.internet_retriever, self.embedder
            )
</code></pre>
<h4 data-id="heading-5">1.3 记忆结构</h4>
<p>每个节点在<code>TreeTextMemory</code> 是一个 <code>TextualMemoryItem</code>:</p>
<ul>
<li><code>id</code>: 唯一记忆ID（如果省略则自动生成）</li>
<li><code>memory</code>: 主要文本</li>
<li><code>metadata</code>: 包括层次结构信息、嵌入、标签、实体、源和状态</li>
</ul>
<h4 data-id="heading-6">1.4 元数据字段</h4>
<p><code>TreeNodeTextualMemoryMetadata</code> 是元数据。需要使用有意义的标签和背景——它们有助于组织你的图进行多跳推理。</p>











































































<table><thead><tr><th>字段</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td><code>memory_type</code></td><td><code>"WorkingMemory"</code>, <code>"LongTermMemory"</code>, <code>"UserMemory"</code></td><td>生命周期分类</td></tr><tr><td><code>status</code></td><td><code>"activated"</code>, <code>"archived"</code>, <code>"deleted"</code></td><td>节点状态</td></tr><tr><td><code>visibility</code></td><td><code>"private"</code>, <code>"public"</code>, <code>"session"</code></td><td>访问范围</td></tr><tr><td><code>sources</code></td><td><code>list[str]</code></td><td>来源列表 (例如: 文件, URLs)</td></tr><tr><td><code>source</code></td><td><code>"conversation"</code>, <code>"retrieved"</code>, <code>"web"</code>, <code>"file"</code></td><td>原始来源类型</td></tr><tr><td><code>confidence</code></td><td><code>float (0-100)</code></td><td>确定性得分</td></tr><tr><td><code>entities</code></td><td><code>list[str]</code></td><td>提及的实体或概念</td></tr><tr><td><code>tags</code></td><td><code>list[str]</code></td><td>主题标签</td></tr><tr><td><code>embedding</code></td><td><code>list[float]</code></td><td>基于向量嵌入的相似性搜索</td></tr><tr><td><code>created_at</code></td><td><code>str</code></td><td>创建时间戳(ISO 8601)</td></tr><tr><td><code>updated_at</code></td><td><code>str</code></td><td>最近更新时间戳(ISO 8601)</td></tr><tr><td><code>usage</code></td><td><code>list[str]</code></td><td>使用历史</td></tr><tr><td><code>background</code></td><td><code>str</code></td><td>附加上下文</td></tr></tbody></table>
<h4 data-id="heading-7">1.5 API总结</h4>
<p><code>TreeTextMemory</code>的API如下。</p>
<p>初始化为：</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-built_in">TreeTextMemory</span>(config: TreeTextMemoryConfig)
</code></pre>
<p>核心方法为：</p>





























































<table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>add(memories)</code></td><td>添加一个或多个记忆（项目或字典）</td></tr><tr><td><code>replace_working_memory()</code></td><td>更换所有的WorkingMemory节点</td></tr><tr><td><code>get_working_memory()</code></td><td>得到所有的WorkingMemory节点</td></tr><tr><td><code>search(query, top_k)</code></td><td>使用向量+图搜索检索top-k个记忆</td></tr><tr><td><code>get(memory_id)</code></td><td>通过ID获取单个记忆</td></tr><tr><td><code>get_by_ids(ids)</code></td><td>通过IDs获取多个记忆</td></tr><tr><td><code>get_all()</code></td><td>将整个记忆图导出为字典</td></tr><tr><td><code>update(memory_id, new)</code></td><td>通过ID更新记忆</td></tr><tr><td><code>delete(ids)</code></td><td>通过IDs删除记忆</td></tr><tr><td><code>delete_all()</code></td><td>删除所有的记忆和关系</td></tr><tr><td><code>dump(dir)</code></td><td>在目录中将图序列化为JSON</td></tr><tr><td><code>load(dir)</code></td><td>从保存的JSON文件加载图</td></tr><tr><td><code>drop(keep_last_n)</code></td><td>备份图和删除数据库，保留N个备份</td></tr></tbody></table>
<p>当调用 <code>dump(dir)</code>, 系统写到:</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">dir</span>&gt;</span>/<span class="hljs-tag">&lt;<span class="hljs-name">config.memory_filename</span>&gt;</span>
</code></pre>
<p>这个文件包含一个JSON结构，有 <code>nodes</code> and <code>edges</code>. 它可以使用 <code>load(dir)</code>重新加载.</p>
<h3 data-id="heading-8">0x02 示例</h3>
<p>下面是如何是如何使用 TreeTextMemory 的示例，当运行此示例时，工作流如下:</p>
<ol>
<li>抽取: 使用LLM从原始文本中提取结构化记忆</li>
<li>嵌入: 为相似性搜索生成向量嵌入</li>
<li>存储和链接: 将具有关系的节点添加到图数据库（Neo4j）中</li>
<li>搜索: 通过向量相似度查询，然后通过图跳数展开结果</li>
</ol>
<h4 data-id="heading-9">2.1 创建 TreeTextMemory 配置</h4>
<p>TreeTextMemoryConfig 的定义为:</p>
<ul>
<li>你的嵌入（创建向量）,</li>
<li>你的图数据库后端(Neo4j),</li>
<li>记忆抽取器（基于LLM）（可选）.</li>
</ul>

<pre><code class="hljs language-arduino" lang="arduino">from memos.configs.memory <span class="hljs-keyword">import</span> TreeTextMemoryConfig

config = TreeTextMemoryConfig.<span class="hljs-built_in">from_json_file</span>(<span class="hljs-string">"examples/data/config/tree_config.json"</span>)
</code></pre>
<h4 data-id="heading-10">2.2 初始化 TreeTextMemory</h4>
<pre><code class="hljs language-arduino" lang="arduino">from memos.memories.textual.tree <span class="hljs-keyword">import</span> TreeTextMemory

tree_memory = <span class="hljs-built_in">TreeTextMemory</span>(config)
</code></pre>
<h4 data-id="heading-11">2.3 抽取结构化记忆</h4>
<p>使用记忆抽取器将对话、文件或文档解析为多个<code>TextualMemoryItem</code>.</p>
<pre><code class="hljs language-ini" lang="ini">from memos.mem_reader.simple_struct import SimpleStructMemReader

<span class="hljs-attr">reader</span> = SimpleStructMemReader.from_json_file(<span class="hljs-string">"examples/data/config/simple_struct_reader_config.json"</span>)

<span class="hljs-attr">scene_data</span> = [[
    {<span class="hljs-string">"role"</span>: <span class="hljs-string">"user"</span>, <span class="hljs-string">"content"</span>: <span class="hljs-string">"Tell me about your childhood."</span>},
    {<span class="hljs-string">"role"</span>: <span class="hljs-string">"assistant"</span>, <span class="hljs-string">"content"</span>: <span class="hljs-string">"I loved playing in the garden with my dog."</span>}
]]

<span class="hljs-attr">memories</span> = reader.get_memory(scene_data, type=<span class="hljs-string">"chat"</span>, info={<span class="hljs-string">"user_id"</span>: <span class="hljs-string">"1234"</span>})
for m_list in memories:
    tree_memory.add(m_list)
</code></pre>
<h4 data-id="heading-12">2.4 搜索记忆</h4>
<p>尝试向量搜索+图搜索:</p>
<pre><code class="hljs language-python" lang="python">results = tree_memory.search(<span class="hljs-string">"Talk about the garden"</span>, top_k=<span class="hljs-number">5</span>)
<span class="hljs-keyword">for</span> i, node <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(results):
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"<span class="hljs-subst">{i}</span>: <span class="hljs-subst">{node.memory}</span>"</span>)
</code></pre>
<h4 data-id="heading-13">2.5 从互联网检索记忆（可选）</h4>
<p>你也可以从 Google / Bing / Bocha（博查） 等搜索引擎实时获取网页内容，并自动切分为记忆节点。MemOS 提供了统一接口。</p>
<p>以下示例演示如何检索“Alibaba 2024 ESG report”相关网页，并自动提取为结构化记忆。</p>
<pre><code class="hljs language-makefile" lang="makefile"><span class="hljs-comment"># 创建embedder</span>
embedder = EmbedderFactory.from_config(
    EmbedderConfigFactory.model_validate({
        <span class="hljs-string">"backend"</span>: <span class="hljs-string">"ollama"</span>,
        <span class="hljs-string">"config"</span>: {<span class="hljs-string">"model_name_or_path"</span>: <span class="hljs-string">"nomic-embed-text:latest"</span>},
    })
)

<span class="hljs-comment"># 配置检索器（以 BochaAI 为例）</span>
retriever_config = InternetRetrieverConfigFactory.model_validate({
    <span class="hljs-string">"backend"</span>: <span class="hljs-string">"bocha"</span>,
    <span class="hljs-string">"config"</span>: {
        <span class="hljs-string">"api_key"</span>: <span class="hljs-string">"sk-xxx"</span>,  <span class="hljs-comment"># 替换为你的 BochaAI API Key</span>
        <span class="hljs-string">"max_results"</span>: 5,
        <span class="hljs-string">"reader"</span>: {  <span class="hljs-comment"># 自动分块的 Reader 配置</span>
            <span class="hljs-string">"backend"</span>: <span class="hljs-string">"simple_struct"</span>,
            <span class="hljs-string">"config"</span>: ...,  <span class="hljs-comment"># 你的mem-reader config</span>
        },
    }
})

<span class="hljs-comment"># 实例化检索器</span>
retriever = InternetRetrieverFactory.from_config(retriever_config, embedder)

<span class="hljs-comment"># 执行网页检索</span>
results = retriever.retrieve_from_internet(<span class="hljs-string">"Alibaba 2024 ESG report"</span>)

<span class="hljs-comment"># 添加到记忆图中</span>
for m in results:
    tree_memory.add(m)
</code></pre>
<p>你也可以直接在 TreeTextMemoryConfig 中配置 internet_retriever 字段，例如：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"internet_retriever"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"backend"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"bocha"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"config"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"api_key"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"sk-xxx"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"max_results"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">5</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"reader"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">"backend"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"simple_struct"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"config"</span><span class="hljs-punctuation">:</span> ...
      <span class="hljs-punctuation">}</span>
    <span class="hljs-punctuation">}</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p>这样，在调用 tree_memory.search(query) 时，系统会自动调用互联网检索（如 BochaAI / Google / Bing）然后将结果与本地图中的节点一起排序返回，无需手动调用 retriever.retrieve_from_internet</p>
<h4 data-id="heading-14">2.6 替换工作记忆</h4>
<p>用一个新的节点替换你当前的 <code>WorkingMemory</code>:</p>
<pre><code class="hljs language-css" lang="css">tree_memory<span class="hljs-selector-class">.replace_working_memory</span>(
    <span class="hljs-selector-attr">[{        <span class="hljs-string">"memory"</span>: <span class="hljs-string">"User is discussing gardening tips."</span>,        <span class="hljs-string">"metadata"</span>: {<span class="hljs-string">"memory_type"</span>: <span class="hljs-string">"WorkingMemory"</span>}    }]</span>
)
</code></pre>
<h4 data-id="heading-15">2.7 备份与恢复</h4>
<p>支持树结构的持久化存储与随时重载:</p>
<pre><code class="hljs language-lua" lang="lua">tree_memory.<span class="hljs-built_in">dump</span>(<span class="hljs-string">"tmp/tree_memories"</span>)
tree_memory.<span class="hljs-built_in">load</span>(<span class="hljs-string">"tmp/tree_memories"</span>)
</code></pre>
<h4 data-id="heading-16">2.8 完整代码</h4>
<p>该示例整合了上述所有步骤，提供一个端到端的完整流程。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> memos.configs.embedder <span class="hljs-keyword">import</span> EmbedderConfigFactory
<span class="hljs-keyword">from</span> memos.configs.memory <span class="hljs-keyword">import</span> TreeTextMemoryConfig
<span class="hljs-keyword">from</span> memos.configs.mem_reader <span class="hljs-keyword">import</span> SimpleStructMemReaderConfig
<span class="hljs-keyword">from</span> memos.embedders.factory <span class="hljs-keyword">import</span> EmbedderFactory
<span class="hljs-keyword">from</span> memos.mem_reader.simple_struct <span class="hljs-keyword">import</span> SimpleStructMemReader
<span class="hljs-keyword">from</span> memos.memories.textual.tree <span class="hljs-keyword">import</span> TreeTextMemory

<span class="hljs-comment"># 嵌入设置</span>
embedder_config = EmbedderConfigFactory.model_validate({
    <span class="hljs-string">"backend"</span>: <span class="hljs-string">"ollama"</span>,
    <span class="hljs-string">"config"</span>: {<span class="hljs-string">"model_name_or_path"</span>: <span class="hljs-string">"nomic-embed-text:latest"</span>}
})
embedder = EmbedderFactory.from_config(embedder_config)

<span class="hljs-comment"># 创建TreeTextMemory</span>
tree_config = TreeTextMemoryConfig.from_json_file(<span class="hljs-string">"examples/data/config/tree_config.json"</span>)
my_tree_textual_memory = TreeTextMemory(tree_config)
my_tree_textual_memory.delete_all()

<span class="hljs-comment"># 阅读器设置</span>
reader_config = SimpleStructMemReaderConfig.from_json_file(
    <span class="hljs-string">"examples/data/config/simple_struct_reader_config.json"</span>
)
reader = SimpleStructMemReader(reader_config)

<span class="hljs-comment"># 从对话中抽取</span>
scene_data = [[
    {
        <span class="hljs-string">"role"</span>: <span class="hljs-string">"user"</span>,
        <span class="hljs-string">"content"</span>: <span class="hljs-string">"Tell me about your childhood."</span>
    },
    {
        <span class="hljs-string">"role"</span>: <span class="hljs-string">"assistant"</span>,
        <span class="hljs-string">"content"</span>: <span class="hljs-string">"I loved playing in the garden with my dog."</span>
    },
]]
memory = reader.get_memory(scene_data, <span class="hljs-built_in">type</span>=<span class="hljs-string">"chat"</span>, info={<span class="hljs-string">"user_id"</span>: <span class="hljs-string">"1234"</span>, <span class="hljs-string">"session_id"</span>: <span class="hljs-string">"2222"</span>})
<span class="hljs-keyword">for</span> m_list <span class="hljs-keyword">in</span> memory:
    my_tree_textual_memory.add(m_list)

<span class="hljs-comment"># 搜索</span>
results = my_tree_textual_memory.search(
    <span class="hljs-string">"Talk about the user's childhood story?"</span>,
    top_k=<span class="hljs-number">10</span>
)
<span class="hljs-keyword">for</span> i, r <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(results):
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"<span class="hljs-subst">{i}</span>'th result: <span class="hljs-subst">{r.memory}</span>"</span>)

<span class="hljs-comment"># 从文档添加[可选项]</span>
doc_paths = [<span class="hljs-string">"./text1.txt"</span>, <span class="hljs-string">"./text2.txt"</span>]
doc_memory = reader.get_memory(
  doc_paths, <span class="hljs-string">"doc"</span>, info={
      <span class="hljs-string">"user_id"</span>: <span class="hljs-string">"your_user_id"</span>,
      <span class="hljs-string">"session_id"</span>: <span class="hljs-string">"your_session_id"</span>,
  }
)
<span class="hljs-keyword">for</span> m_list <span class="hljs-keyword">in</span> doc_memory:
    my_tree_textual_memory.add(m_list)

<span class="hljs-comment"># 转储和丢弃[可选项]</span>
my_tree_textual_memory.dump(<span class="hljs-string">"tmp/my_tree_textual_memory"</span>)
my_tree_textual_memory.drop()
</code></pre>
<h3 data-id="heading-17">0x03 管理（MemoryManager）</h3>
<p>MemoryManager 是 TreeTextMemory 类的一个核心组件，主要负责管理不同类型的记忆（如工作记忆、长期记忆和用户记忆）的添加、组织和维护。</p>
<h4 data-id="heading-18">3.1 定义</h4>
<p>MemoryManager 的简要如下：</p>
<pre><code class="hljs">MemoryManager
    - uses GraphStructureReorganizer
      - uses NodeHandler
        - uses Neo4jGraphDB
        - uses LLM
        - uses Embedder
      - uses RelationAndReasoningDetector
        - uses Neo4jGraphDB
        - uses LLM
        - uses Embedder
        - uses Neo4jGraphDB
    - uses Neo4jGraphDB
    - uses Embedder
    - uses LLM
</code></pre>
<p>MemoryManager 代码如下。</p>
<pre><code class="hljs language-ini" lang="ini">class MemoryManager:
    def __init__(
        self,
        graph_store: Neo4jGraphDB,
        embedder: OllamaEmbedder,
        llm: OpenAILLM | OllamaLLM | AzureLLM,
        memory_size: dict | <span class="hljs-attr">None</span> = None,
        threshold: float | <span class="hljs-attr">None</span> = <span class="hljs-number">0.80</span>,
        merged_threshold: float | <span class="hljs-attr">None</span> = <span class="hljs-number">0.92</span>,
        is_reorganize: <span class="hljs-attr">bool</span> = <span class="hljs-literal">False</span>,
    ):
        <span class="hljs-attr">self.graph_store</span> = graph_store
        <span class="hljs-attr">self.embedder</span> = embedder
        <span class="hljs-attr">self.memory_size</span> = memory_size
        <span class="hljs-attr">self.current_memory_size</span> = {
            "WorkingMemory": 0,
            "LongTermMemory": 0,
            "UserMemory": 0,
        }
        if not memory_size:
            <span class="hljs-attr">self.memory_size</span> = {
                "WorkingMemory": 20,
                "LongTermMemory": 1500,
                "UserMemory": 480,
            }
        <span class="hljs-attr">self._threshold</span> = threshold
        <span class="hljs-attr">self.is_reorganize</span> = is_reorganize
        <span class="hljs-attr">self.reorganizer</span> = GraphStructureReorganizer(
            graph_store, llm, embedder, <span class="hljs-attr">is_reorganize</span>=is_reorganize
        )
        <span class="hljs-attr">self._merged_threshold</span> = merged_threshold
</code></pre>
<h4 data-id="heading-19">3.2 主要功能</h4>
<p>以下是其主要功能：</p>
<ul>
<li>
<p>记忆管理与组织：</p>
<ul>
<li>
<p>添加记忆：通过 add() 方法并行处理不同类型的记忆添加。通过 MemoryManager 组件管理不同类型的记忆：</p>
<ul>
<li>工作记忆（WorkingMemory）</li>
<li>长期记忆（LongTermMemory）</li>
<li>用户记忆（UserMemory）</li>
<li>每种记忆类型都有预设的容量限制，并支持动态调整。</li>
</ul>
</li>
<li>
<p>替换工作记忆：通过 replace_working_memory() 方法更新工作记忆内容</p>
</li>
<li>
<p>内存大小管理：通过 get_current_memory_size() 获取和刷新各类记忆的当前数量</p>
</li>
</ul>
</li>
<li>
<p>记忆存储处理</p>
<ul>
<li>工作记忆管理：所有记忆都会被添加到工作记忆中，通过 _add_memory_to_db() 方法处理</li>
<li>长期记忆和用户记忆管理：通过 _add_to_graph_memory() 方法处理特定类型的记忆存储</li>
<li>FIFO 机制：自动维护各类记忆的最大容量，删除过期的记忆项</li>
</ul>
</li>
<li>
<p>图结构维护</p>
<ul>
<li>结构路径管理：通过 _ensure_structure_path() 确保记忆的结构化存储路径</li>
<li>边继承：通过 _inherit_edges() 方法在节点合并时迁移连接关系</li>
</ul>
</li>
<li>
<p>与图数据库交互</p>
<ul>
<li>依赖图数据库：通过 graph_store（如 Neo4j）进行实际的记忆存储和检索操作</li>
<li>定期清理：根据配置的容量限制自动清理过期的记忆项</li>
</ul>
</li>
<li>
<p>与Reorganizer 集成</p>
<ul>
<li>记忆重组织：与 GraphStructureReorganizer 集成，在添加记忆时触发图结构的重新组织</li>
<li>异步处理：通过消息队列机制异步处理记忆的重新组织任务</li>
</ul>
</li>
</ul>
<p>总的来说，MemoryManager 负责协调和管理记忆的整个生命周期，包括添加、存储、维护和清理，是记忆系统的核心管理组件。</p>
<h4 data-id="heading-20">3.3 GraphStructureReorganizer</h4>
<p>GraphStructureReorganizer 是负责维护和优化 Memos 系统中记忆图结构的组件，本质上充当了一个记忆维护系统，随着新记忆的不断添加，它能够保持基于图的记忆结构有序、高效且在语义上连贯。</p>
<h5 data-id="heading-21">3.3.1 主要功能</h5>
<p>以下是其主要功能：</p>
<ul>
<li>
<p>消息队列管理</p>
<ul>
<li>
<p>异步处理：使用优先级队列（PriorityQueue）来管理图结构操作，如添加、删除、合并和更新节点/边</p>
<ul>
<li>在单独的线程中运行，避免阻塞主记忆操作</li>
<li>使用线程池并行处理聚类和关系检测任务</li>
<li>提供等待正在进行的重组任务完成的方法</li>
</ul>
</li>
<li>
<p>优先级处理：不同操作有不同的优先级（add/remove &gt; merge &gt; end），确保关键操作优先处理</p>
</li>
<li>
<p>线程安全操作：运行一个专用线程（_run_message_consumer_loop）来处理排队的消息</p>
</li>
</ul>
</li>
<li>
<p>图结构（记忆结构）优化</p>
<ul>
<li>周期性优化：运行一个独立线程（<code>_run_structure_organizer_loop</code>），定期触发对 LongTermMemory 和 UserMemory 的结构优化，以保持效率和一致性</li>
<li>自动触发：当有新节点添加时可以自动触发优化（_reorganize_needed 标志）</li>
</ul>
</li>
<li>
<p>记忆节点关系管理（冲突解决和记忆融合）</p>
<ul>
<li>冲突检测：检测新添加节点与现有节点之间的关系，即与 RelationAndReasoningDetector 集成，识别记忆之间的关系（因果、条件、冲突等）</li>
<li>冲突解决：与 NodeHandler 协作，通过基于大语言模型的融合来解决相似记忆之间的冲突和冗余</li>
<li>记忆合并：处理重复或相似记忆的合并，归档或删除过时/不那么重要的记忆，以保持图的效率</li>
</ul>
</li>
<li>
<p>结构增强</p>
<ul>
<li>局部聚类：使用诸如 LOCAL_SUBCLUSTER_PROMPT 和 REORGANIZE_PROMPT 等提示词来识别和组织相关记忆到集群中</li>
<li>层次化组织：创建摘要节点并在记忆之间建立层次关系（在摘要节点与其组成节点之间建立父子关系（PARENT 边）），以创建多层次的组织结构（维护类似树的结构），以提高记忆检索效率</li>
<li>边管理：在重组过程中维护节点间的连接关系</li>
</ul>
</li>
</ul>
<h5 data-id="heading-22">3.3.2 与其他组件集成</h5>
<ul>
<li>图数据库接口：GraphStructureReorganizer直接与 Neo4jGraphDB 交互执行图操作</li>
<li>大语言模型集成：GraphStructureReorganizer使用语言模型来理解关系并生成摘要</li>
<li>嵌入支持：GraphStructureReorganizer利用 OllamaEmbedder 进行语义相似度计算</li>
</ul>
<p>总的来说，GraphStructureReorganizer 通过持续优化结构、解决冲突和在记忆节点间建立有意义的关系来维护记忆图的质量和组织性。</p>
<h5 data-id="heading-23">3.3.3 如何调用</h5>
<p>我们接下来看看 GraphStructureReorganizer 如何调用。</p>
<ul>
<li>初始化时候启动周期性优化任务</li>
</ul>
<p>当TreeTextMemory初始化时，如果配置了重组织功能（is_reorganize=True），会启动一个周期性的结构优化线程。</p>
<pre><code class="hljs language-ini" lang="ini">class GraphStructureReorganizer:
    def __init__(
        self, graph_store: Neo4jGraphDB, llm: BaseLLM, embedder: OllamaEmbedder, is_reorganize: bool
    ):
        <span class="hljs-attr">self.queue</span> = PriorityQueue()  <span class="hljs-comment"># Min-heap</span>
        <span class="hljs-attr">self.graph_store</span> = graph_store
        <span class="hljs-attr">self.llm</span> = llm
        <span class="hljs-attr">self.embedder</span> = embedder
        <span class="hljs-attr">self.relation_detector</span> = RelationAndReasoningDetector(
            self.graph_store, self.llm, self.embedder
        )
        <span class="hljs-attr">self.resolver</span> = NodeHandler(graph_store=graph_store, llm=llm, embedder=embedder)

        <span class="hljs-attr">self.is_reorganize</span> = is_reorganize
        <span class="hljs-attr">self._reorganize_needed</span> = <span class="hljs-literal">True</span>
        if self.is_reorganize:
            <span class="hljs-comment"># ____ 1. For queue message driven thread ___________</span>
            <span class="hljs-attr">self.thread</span> = threading.Thread(target=self._run_message_consumer_loop)
            self.thread.start()
            <span class="hljs-comment"># ____ 2. For periodic structure optimization _______</span>
            <span class="hljs-attr">self._stop_scheduler</span> = <span class="hljs-literal">False</span>
            <span class="hljs-attr">self._is_optimizing</span> = {<span class="hljs-string">"LongTermMemory"</span>: <span class="hljs-literal">False</span>, <span class="hljs-string">"UserMemory"</span>: <span class="hljs-literal">False</span>}
            <span class="hljs-attr">self.structure_optimizer_thread</span> = threading.Thread(
                <span class="hljs-attr">target</span>=self._run_structure_organizer_loop
            )
            self.structure_optimizer_thread.start()
</code></pre>
<p>每100秒自动触发一次优化。</p>
<pre><code class="hljs language-python" lang="python">    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_run_structure_organizer_loop</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">"""
        Use schedule library to periodically trigger structure optimization.
        This runs until the stop flag is set.
        """</span>
        <span class="hljs-keyword">import</span> schedule

        schedule.every(<span class="hljs-number">100</span>).seconds.do(self.optimize_structure, scope=<span class="hljs-string">"LongTermMemory"</span>)
        schedule.every(<span class="hljs-number">100</span>).seconds.do(self.optimize_structure, scope=<span class="hljs-string">"UserMemory"</span>)

        <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">getattr</span>(self, <span class="hljs-string">"_stop_scheduler"</span>, <span class="hljs-literal">False</span>):
            <span class="hljs-keyword">if</span> <span class="hljs-built_in">any</span>(self._is_optimizing.values()):
                time.sleep(<span class="hljs-number">1</span>)
                <span class="hljs-keyword">continue</span>
            <span class="hljs-keyword">if</span> self._reorganize_needed:
                self.optimize_structure(scope=<span class="hljs-string">"LongTermMemory"</span>)
                self.optimize_structure(scope=<span class="hljs-string">"UserMemory"</span>)
                self._reorganize_needed = <span class="hljs-literal">False</span>
            time.sleep(<span class="hljs-number">30</span>)
</code></pre>
<ul>
<li>添加新节点时触发优化</li>
</ul>
<p>当通过MemoryManager 添加新记忆节点时，会向 GraphStructureReorganizer 的消息队列添加一条"add" 消息。</p>
<pre><code class="hljs language-python" lang="python">    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_add_to_graph_memory</span>(<span class="hljs-params">self, memory: TextualMemoryItem, memory_type: <span class="hljs-built_in">str</span></span>):
        <span class="hljs-string">"""
        Generalized method to add memory to a graph-based memory type (e.g., LongTermMemory, UserMemory).

        Parameters:
        - memory: memory item to insert
        - memory_type: "LongTermMemory" | "UserMemory"
        - similarity_threshold: deduplication threshold
        - topic_summary_prefix: summary node id prefix if applicable
        - enable_summary_link: whether to auto-link to a summary node
        """</span>
        node_id = <span class="hljs-built_in">str</span>(uuid.uuid4())
        <span class="hljs-comment"># Step 2: Add new node to graph</span>
        self.graph_store.add_node(
            node_id, memory.memory, memory.metadata.model_dump(exclude_none=<span class="hljs-literal">True</span>)
        )
        self.reorganizer.add_message(
            QueueMessage(
                op=<span class="hljs-string">"add"</span>,
                after_node=[node_id],
            )
        )
        <span class="hljs-keyword">return</span> node_id
</code></pre>
<p>当消息处理器处理”add“操作完成后，会设置_reorganize_needed=True，在下一次检查时触发优化。</p>
<pre><code class="hljs language-ini" lang="ini">    def handle_add(self, message: QueueMessage):
        logger.debug(f"Handling add operation: {str(message)<span class="hljs-section">[:500]</span>}")
        <span class="hljs-attr">added_node</span> = message.after_node[<span class="hljs-number">0</span>]
        <span class="hljs-attr">detected_relationships</span> = self.resolver.detect(
            added_node, <span class="hljs-attr">scope</span>=added_node.metadata.memory_type
        )
        if detected_relationships:
            for added_node, existing_node, relation in detected_relationships:
                self.resolver.resolve(added_node, existing_node, relation)

        <span class="hljs-attr">self._reorganize_needed</span> = <span class="hljs-literal">True</span>
</code></pre>
<p>在 _run_structure_organizer_loop 中检查到该标识时触发优化。</p>
<ul>
<li>也可以直接调用 optimize_structure()方法</li>
</ul>
<p>总结，这种设计确保了记忆图结构能够定期优化，同时在有新内容添加时也可以及时调整结构。</p>
<h5 data-id="heading-24">3.3.4 LLM 的使用</h5>
<p>GraphStructureReorganizer 不仅使用了 LLM，而且在其核心功能中深度依赖 LLM 来实现：</p>
<ul>
<li>节点间语义关系的理解和建立</li>
<li>冲突记忆的检测与融合</li>
<li>新的知识推理和聚合</li>
<li>图结构的智能优化</li>
</ul>
<p>这些功能使记忆图谱不仅是一个简单的数据存储结构，还能自主地维护语义一致性和结构性</p>
<h6 data-id="heading-25">直接依赖</h6>
<p>GraphStructureReorganizer 在初始化时接收一个 LLM 实例作为参数：</p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-title function_ invoke__">def __init__</span>(
    <span class="hljs-built_in">self</span>,<span class="hljs-attr"> graph_store</span>: Neo4jGraphDB,<span class="hljs-attr"> llm</span>: BaseLLM,<span class="hljs-attr"> embedder</span>: OllamaEmbedder,<span class="hljs-attr"> is_reorganize</span>: <span class="hljs-keyword">bool</span>
):
    <span class="hljs-built_in">self</span>.llm = llm
</code></pre>
<h6 data-id="heading-26">关键组件中的 LLM 使用</h6>
<p>在优化图结构时，LLM 用于：</p>
<ul>
<li>生成聚类摘要（通过 _summarize_cluster 方法）</li>
<li>推断节点间的关系</li>
<li>创建新的推理节点</li>
</ul>
<p>GraphStructureReorganizer 创建了一个 RelationAndReasoningDetector 实例，该检测器大量使用 LLM：</p>
<ul>
<li>关系检测：使用 LLM 判断节点间的因果、条件、冲突等关系</li>
<li>事实推断：基于现有关系推断新的事实节点</li>
<li>聚合概念生成：将相似节点聚合成更高层次的概念节点</li>
</ul>
<p>例如在 _detect_pairwise_causal_condition_relations 方法中：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">prompt</span> = PAIRWISE_RELATION_PROMPT.format(
    <span class="hljs-attr">node1</span>=node.memory,
    <span class="hljs-attr">node2</span>=candidate.memory
)
<span class="hljs-attr">response_text</span> = self._call_llm(prompt)  <span class="hljs-comment"># 调用 LLM 进行判断</span>
</code></pre>
<p>GraphStructureReorganizer 也创建了一个 NodeHandler 实例用于处理节点冲突和冗余，即当添加新节点时，使用 LLM：</p>
<ul>
<li>冲突检测：检测新节点与现有节点的关系。使用 LLM 判断两个记忆是否相互矛盾</li>
<li>冲突解决：解决潜在的冲突或冗余。当发现冲突或冗余时，使用 LLM 融合记忆内容</li>
</ul>

<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">result</span> = self.llm.generate(prompt).strip()  <span class="hljs-comment"># 检测关系</span>
</code></pre>
<h4 data-id="heading-27">3.4 RelationAndReasoningDetector</h4>
<p>RelationAndReasoningDetector 是一个用于检测和推理记忆节点之间关系的组件，它在记忆图结构优化过程中发挥关键作用。它的主要功能包括：</p>
<ul>
<li>节点关系检测。RelationAndReasoningDetector 负责检测记忆节点之间的各种语义关系，通过使用大语言模型（LLM）和嵌入向量来判断节点间的关系类型。</li>
<li>推理新节点生成。基于已检测到的关系推断新的事实节点，创建推理类型的节点以丰富记忆图谱的内容</li>
<li>图结构优化支持。为 GraphStructureReorganizer 提供关系和推理信息，帮助构建更完整的语义网络结构。</li>
</ul>
<h5 data-id="heading-28">3.4.1 主要方法</h5>
<p>process_node 方法。统一处理节点的关系检测和推理流程，调用其他专门方法完成具体任务。</p>
<ul>
<li>关系检测。检测成对节点之间的因果、条件、冲突，相关等关系，使用 _detect_pairwise_causal_condition_relations 方法实现。</li>
<li>推理节点生成。基于因果/条件关系推断新的事实节点，调用 _infer_fact_nodes_from_relations 方法生成聚合概念节点（将相似节点聚合成更高层次的概念）</li>
<li>时序关联检测。检测节点间的时间顺序关系，通过 _detect_sequence_links 方法实现。</li>
<li>聚合节点检测。识别可以被聚合的概念组，使用 _detect_aggregate_node_for_group 方法</li>
</ul>
<p>Relation Detection Methods。专门用于检测不同类型节点关系的方法集合</p>
<ul>
<li>_detect_pairwise_causal_condition_relations检测两个节点之间的因果和条件关系，使用 LLM 判断关系类型：CAUSE、CONDITION、RELATE、CONFLICT 或 NONE。</li>
<li>_detect_sequence_links根据时间戳检测节点间的时序关系，创建 FOLLOWS 类型的边连接相关节点。</li>
<li>_detect_aggregate_node_for_group识别具有相似标签的节点组并生成聚合概念节点，使用 LLM 判断是否需要创建聚合节点。</li>
</ul>
<p>Inference Methods。用于从现有关系中推断新节点的方法</p>
<ul>
<li>_infer_fact_nodes_from_relations：从因果和条件关系中推断新的事实节点，生成带有推理标记的新节点并连接到源节点。</li>
</ul>
<h5 data-id="heading-29">3.4.2 工作流程</h5>
<ul>
<li>初始化阶段。接收 graph_store、llm 和 embedder 作为依赖组件，准备处理关系检测和推理所需的基础工具</li>
<li>处理阶段。通过 process_node 方法处理单个节点，查找邻近节点并进行关系分析，生成推理节点和关系连接</li>
<li>结果输出。返回包含新关系、推理节点、序列链接和聚合节点的结果集，为图结构重组提供数据支持</li>
</ul>
<p>数据流如下：</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-attribute">Background</span> Task → GraphStructureReorganizer
 ↓
RelationAndReasoningDetector<span class="hljs-selector-class">.process_node</span>()
 ↓
Neo4jGraphDB <span class="hljs-selector-attr">[Get Neighbors/Nodes/Edges]</span>
  ↓
RelationAndReasoningDetector <span class="hljs-selector-attr">[LLM Analysis]</span>
 ↓
Neo4jGraphDB <span class="hljs-selector-attr">[Add Inferred Nodes/Relations]</span>
</code></pre>
<h5 data-id="heading-30">3.4.3 promt</h5>
<p>RelationAndReasoningDetector 引入了以下 prompt。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">from</span> memos.<span class="hljs-property">templates</span>.<span class="hljs-property">tree_reorganize_prompts</span> <span class="hljs-keyword">import</span> (
    <span class="hljs-variable constant_">AGGREGATE_PROMPT</span>,
    <span class="hljs-variable constant_">INFER_FACT_PROMPT</span>,
    <span class="hljs-variable constant_">PAIRWISE_RELATION_PROMPT</span>,
)
</code></pre>
<p>举例如下：</p>
<pre><code class="hljs language-vbnet" lang="vbnet">PAIRWISE_RELATION_PROMPT = <span class="hljs-string">"""
You are a reasoning assistant.

Given two memory units:
- Node 1: "</span>{node1}<span class="hljs-string">"
- Node 2: "</span>{node2}<span class="hljs-string">"

Your task:
- Determine their relationship ONLY if it reveals NEW usable reasoning or retrieval knowledge that is NOT already explicit in either unit.
- Focus on whether combining them adds new temporal, causal, conditional, or conflict information.

Valid options:
- CAUSE: One clearly leads to the other.
- CONDITION: One happens only if the other condition holds.
- RELATE: They are semantically related by shared people, time, place, or event, but neither causes the other.
- CONFLICT: They logically contradict each other.
- NONE: No clear useful connection.

Example:
- Node 1: "</span>The marketing campaign ended <span class="hljs-keyword">in</span> June.<span class="hljs-string">"
- Node 2: "</span>Product sales dropped <span class="hljs-keyword">in</span> July.<span class="hljs-string">"
Answer: CAUSE

Another Example:
- Node 1: "</span>The conference was postponed <span class="hljs-keyword">to</span> August due <span class="hljs-keyword">to</span> the venue being unavailable.<span class="hljs-string">"
- Node 2: "</span>The venue was booked <span class="hljs-keyword">for</span> a wedding <span class="hljs-keyword">in</span> August.<span class="hljs-string">"
Answer: CONFLICT

Always respond with ONE word, no matter what language is for the input nodes: [CAUSE | CONDITION | RELATE | CONFLICT | NONE]
"""</span>

INFER_FACT_PROMPT = <span class="hljs-string">"""
You are an inference expert.

Source Memory: "</span>{source}<span class="hljs-string">"
Target Memory: "</span>{target}<span class="hljs-string">"

They are connected by a {relation_type} relation.
Derive ONE new factual statement that clearly combines them in a way that is NOT a trivial restatement.

Requirements:
- Include relevant time, place, people, and event details if available.
- If the inference is a logical guess, explicitly use phrases like "</span>It can be inferred that...<span class="hljs-string">".

Example:
Source: "</span>John missed the team meeting <span class="hljs-keyword">on</span> Monday.<span class="hljs-string">"
Target: "</span>Important project deadlines were discussed <span class="hljs-keyword">in</span> that meeting.<span class="hljs-string">"
Relation: CAUSE
Inference: "</span>It can be inferred that John may <span class="hljs-built_in">not</span> know the <span class="hljs-built_in">new</span> project deadlines.<span class="hljs-string">"

If there is NO new useful fact that combines them, reply exactly: "</span>None<span class="hljs-string">"
"""</span>

AGGREGATE_PROMPT = <span class="hljs-string">"""
You are a concept summarization assistant.

Below is a list of memory items:
{joined}

Your task:
- Identify if they can be meaningfully grouped under a new, higher-level concept that clarifies their shared time, place, people, or event context.
- Do NOT aggregate if the overlap is trivial or obvious from each unit alone.
- If the summary involves any plausible interpretation, explicitly note it (e.g., "</span>This suggests...<span class="hljs-string">").

Example:
Input Memories:
- "</span>Mary organized the <span class="hljs-number">2023</span> sustainability summit <span class="hljs-keyword">in</span> Berlin.<span class="hljs-string">"
- "</span>Mary presented a keynote <span class="hljs-keyword">on</span> renewable energy at the same summit.<span class="hljs-string">"

Language rules:
- The `key`, `value`, `tags`, `background` fields must match the language of the input.

Good Aggregate:
{
  "</span><span class="hljs-keyword">key</span><span class="hljs-string">": "</span>Mary<span class="hljs-comment">'s Sustainability Summit Role",</span>
  <span class="hljs-string">"value"</span>: <span class="hljs-string">"Mary organized and spoke at the 2023 sustainability summit in Berlin, highlighting renewable energy initiatives."</span>,
  <span class="hljs-string">"tags"</span>: [<span class="hljs-string">"Mary"</span>, <span class="hljs-string">"summit"</span>, <span class="hljs-string">"Berlin"</span>, <span class="hljs-string">"2023"</span>],
  <span class="hljs-string">"background"</span>: <span class="hljs-string">"Combined from multiple memories about Mary's activities at the summit."</span>
}

<span class="hljs-keyword">If</span> you find NO useful higher-level concept, reply exactly: <span class="hljs-string">"None"</span>.
<span class="hljs-string">"""
</span></code></pre>
<p>这三组提示词是面向 MemOS 记忆系统中<strong>关系推理、事实推导、概念聚合</strong>的专业化 prompt 设计,三个prompt的特点如下：</p>
<ul>
<li>
<p><code>PAIRWISE_RELATION_PROMPT</code>将 AI 定义为<strong>reasoning assistant（推理助手）</strong> ，聚焦两个记忆单元的关系判定，匹配 “逻辑关系分析” 的任务属性；</p>
<ul>
<li>仅要求判断两个节点的关系类型，且明确限定 “仅当关系能揭示新知识时才判定，否则为 NONE”；</li>
<li>关系判定中，将有效关系拆分为 <strong>CAUSE（因果）、CONDITION（条件）、RELATE（关联）、CONFLICT（冲突）、NONE（无）</strong> 五类，并对每类的判定依据（如因果是 “一方明确导致另一方”）做了清晰说明；</li>
<li>关系判定强制要求<strong>仅输出一个单词</strong>，无论输入语言为何，避免 AI 产生冗余解释；</li>
<li>关系判定是<strong>记忆关联的基础环节</strong>，为两个独立记忆单元建立语义连接，要求 “揭示新的推理 / 检索知识”。</li>
</ul>
</li>
<li>
<p><code>INFER_FACT_PROMPT</code>设定为<strong>inference expert（推理专家）</strong> ，侧重基于已知关系推导新事实，突出 “深度语义挖掘” 的专业性；</p>
<ul>
<li>仅要求基于关系推导<strong>一个</strong>新事实，禁止简单复述原记忆内容；</li>
<li>事实推导是<strong>记忆挖掘的深化环节</strong>，基于关联关系生成新的知识节点，要求 “生成非平凡的新事实”。</li>
<li>事实推导要求 “结合时间、地点、人物、事件细节”，若为推测需使用 “It can be inferred that...” 等固定表述，确保推导结果的可验证性。</li>
<li>事实推导若无可推导内容，需<strong>严格返回 “None”</strong> ，聚合 prompt 同理，统一了无效场景的输出格式。</li>
</ul>
</li>
<li>
<p><code>AGGREGATE_PROMPT</code>定位为<strong>concept summarization assistant（概念总结助手）</strong> ，针对多记忆单元的高阶聚合，贴合 “抽象归纳” 的核心需求。</p>
<ul>
<li>概念聚合是<strong>记忆结构化的高阶环节</strong>，将零散记忆归纳为抽象概念，要求 “提炼高阶共享概念”，适配 MemOS 中 “节点 - 关系 - 概念” 的层级化记忆管理架构。</li>
<li>仅要求识别多记忆单元的<strong>高阶共享概念</strong>，若重叠为常识则直接返回 “None”。</li>
</ul>
</li>
</ul>
<h4 data-id="heading-31">3.5 NodeHandler</h4>
<p>NodeHandler 是 Memos 系统中负责处理记忆节点冲突检测与解决的核心组件。</p>
<h5 data-id="heading-32">3.5.1 主要功能</h5>
<p>NodeHandler 的主要功能包括：</p>
<ul>
<li>
<p>冲突检测（Conflict Detection）</p>
<ul>
<li>使用嵌入向量相似度搜索潜在的冲突记忆节点</li>
<li>利用 LLM 判断两个记忆节点之间的关系（矛盾、冗余或独立）</li>
<li>基于预设阈值（EMBEDDING_THRESHOLD）进行初步筛选</li>
</ul>
</li>
<li>
<p>冲突解决（Conflict Resolution）</p>
<ul>
<li>对检测到的冲突进行融合处理</li>
<li>使用 LLM 生成融合后的记忆内容</li>
<li>处理元数据合并和图结构更新</li>
</ul>
</li>
<li>
<p>图结构维护</p>
<ul>
<li>更新合并后的记忆节点到图数据库</li>
<li>维护原有节点间的关系连接</li>
<li>将旧节点标记为已归档状态</li>
</ul>
</li>
</ul>
<h5 data-id="heading-33">3.5.2 调用关系与依赖关系</h5>
<p><strong>直接依赖组件如下</strong>：</p>
<ul>
<li>
<p>GraphStore（Neo4jGraphDB）：</p>
<ul>
<li>搜索相似节点：search_by_embedding</li>
<li>获取节点信息：get_nodes</li>
<li>更新图结构：add_node, delete_node, add_edge, update_node, edge_exists</li>
</ul>
</li>
<li>
<p>LLM（BaseLLM）</p>
<ul>
<li>判断节点关系：MEMORY_RELATION_DETECTOR_PROMPT</li>
<li>用于解决冲突：MEMORY_RELATION_RESOLVER_PROMPT</li>
</ul>
</li>
<li>
<p>Embedder（BaseEmbedder）</p>
<ul>
<li>用于生成新记忆的嵌入向量</li>
</ul>
</li>
</ul>
<p><strong>被其他组件调用</strong></p>
<ul>
<li>GraphStructureReorganizer：在 handle_add 方法中调用 NodeHandler.detect 和 NodeHandler.resolve，用于处理新增节点时的冲突检测与解决。</li>
</ul>

<pre><code class="hljs language-ini" lang="ini"><span class="hljs-comment"># 在 GraphStructureReorganizer.handle_add 中的调用示例</span>
    def handle_add(self, message: QueueMessage):
        <span class="hljs-attr">added_node</span> = message.after_node[<span class="hljs-number">0</span>]
        <span class="hljs-attr">detected_relationships</span> = self.resolver.detect(
            added_node, <span class="hljs-attr">scope</span>=added_node.metadata.memory_type
        )
        if detected_relationships:
            for added_node, existing_node, relation in detected_relationships:
                self.resolver.resolve(added_node, existing_node, relation)

        <span class="hljs-attr">self._reorganize_needed</span> = <span class="hljs-literal">True</span>
</code></pre>
<p><strong>数据模型依赖</strong></p>
<ul>
<li>TextualMemoryItem：处理的主要对象类型</li>
<li>TreeNodeTextualMemoryMetadata：节点元数据结构</li>
<li>Templates：使用 MEMORY_RELATION_DETECTOR_PROMPT 和 MEMORY_RELATION_RESOLVER_PROMPT 模板</li>
</ul>
<h5 data-id="heading-34">3.5.3 流程图</h5>
<p>NodeHandler 的流程图如下：</p>
<pre><code class="hljs language-scss" lang="scss">User <span class="hljs-selector-tag">Input</span> → MemoryManager<span class="hljs-selector-class">.add</span>()
 ↓
NodeHandler<span class="hljs-selector-class">.detect</span>() → <span class="hljs-selector-attr">[Embedding Search]</span>
 ↓
NodeHandler<span class="hljs-selector-class">.resolve</span>() → <span class="hljs-selector-attr">[LLM Conflict Resolution]</span>
 ↓
Neo4jGraphDB <span class="hljs-selector-attr">[Add/Update/Delete Nodes &amp; Edges]</span>
</code></pre>
<p>具体如下：</p>
<ul>
<li>检测阶段：detect() → search_by_embedding() → get_nodes() → LLM 判断关系 → 返回冲突列表</li>
<li>解决阶段：resolve() → LLM 生成融合记忆 → 解析响应 → _merge_metadata() → _resolve_in_graph() → 更新图数据库结构</li>
<li>硬更新处理：当无法通过 LLM 解决冲突时，采用时间戳比较方式进行硬更新：_hard_update() → 比较 updated_at → 删除较旧节点</li>
</ul>
<p>总的来说，NodeHandler 是 Memos 记忆管理系统中保证记忆一致性和避免冲突的关键组件，它协调了图数据库、大语言模型和嵌入模型来完成记忆节点的智能化管理。</p>
<h4 data-id="heading-35">3.6 NodeHandler vs RelationAndReasoningDetector</h4>
<p>为何要拆分成两个类，而不合二为一？</p>
<h5 data-id="heading-36">3.6.1 设计思路</h5>
<p><code>RelationAndReasoningDetector</code>（关系与推理检测器）和 <code>NodeHandler</code>（节点处理器）的拆分设计，本质是<strong>遵循 “单一职责原则” 与 “关注点分离”</strong> 的架构设计思想 —— 二者虽共同服务于 “记忆的结构化管理与智能推理”，但核心职责、输入输出、复用场景完全不同，合并会导致代码耦合度飙升、可维护性下降、功能扩展受限。</p>
<p>MemOS 的核心架构是 “分层设计”（感知层→推理层→存储层）：</p>
<ul>
<li>感知层：处理输入数据（如文本解析）；</li>
<li>推理层：负责智能分析（如关系识别、推理）；</li>
<li>存储层：负责数据持久化（如节点、关系存储）。</li>
</ul>
<p><code>RelationAndReasoningDetector</code> 属于 “推理层”，属于主动发起推理阶段，在添加新节点后主动寻找关联，<code>NodeHandler</code> 属于 “存储层”，属于被动响应阶段，在发现冲突时进行处理。</p>
<p>MemOS 中两个类的拆分，本质是 “将‘智能决策（推理）’与‘数据执行（存储）’分离”—— 前者负责 “想清楚要做什么”（从文本中识别节点和关系），后者负责 “把事做好”（将识别出的节点和关系落地到存储）。这种设计不仅符合软件工程的核心原则，更适配 MemOS 作为 “Agent 记忆系统” 的核心需求：既要支持灵活的推理逻辑迭代，又要保证存储操作的稳定可靠。合并二者相当于打破了分层架构，导致架构边界模糊，后续无法对某一层进行独立的性能优化或功能扩展（如给推理层加缓存、给存储层加容灾）。</p>
<h5 data-id="heading-37">3.6.2 定位边界</h5>
<p>要理解 “为何不能合并”，首先要厘清二者的定位边界，这是拆分的根本依据：</p>



































<table><thead><tr><th>维度</th><th>RelationAndReasoningDetector（关系与推理检测器）</th><th>NodeHandler（节点处理器）</th></tr></thead><tbody><tr><td><strong>核心职责</strong></td><td>负责 “语义层面的智能分析”：从非结构化数据（如文本、对话）中识别实体关系、触发推理逻辑、挖掘隐含信息。</td><td>负责 “数据层面的结构化操作”：管理知识图谱的节点生命周期（创建、更新、删除、查询），处理节点的存储与格式适配。</td></tr><tr><td><strong>输入 / 输出</strong></td><td>输入：非结构化数据（文本片段、用户指令）、现有知识图谱元数据；输出：关系三元组（实体 A - 关系 - 实体 B）、推理结论、待处理的节点关联需求。</td><td>输入：结构化数据（节点 ID、属性键值对、关联关系标识）；输出：节点操作结果（创建成功 / 更新后的节点数据 / 查询结果）。</td></tr><tr><td><strong>核心能力依赖</strong></td><td>依赖大模型（LLM）的语义理解与推理能力，需处理模糊、歧义的非结构化信息（如 “小明喜欢喝拿铁”→ 识别 “小明 - 喜欢 - 拿铁” 三元组）。</td><td>依赖数据存储层（如 Neo4j、向量数据库）的 CRUD 接口，需保证操作的原子性、一致性（如创建节点时校验唯一标识，避免重复）。</td></tr><tr><td><strong>变化频率</strong></td><td>较高：推理规则、关系类型可能随场景迭代（如从 “通用对话” 扩展到 “专业领域”，需新增领域特定关系识别逻辑）。</td><td>较低：节点的存储格式、操作规范（如 ID 生成规则、属性校验逻辑）一旦确定，很少频繁变更。</td></tr><tr><td><strong>复用场景</strong></td><td>可跨模块复用：除了给 NodeHandler 提供关联数据，还可给 RAG 模块提供推理结论、给 Agent 决策模块提供关系依据。</td><td>聚焦记忆存储层：主要服务于知识图谱的节点管理，复用场景集中在 “节点数据的读写操作”。</td></tr></tbody></table>
<h5 data-id="heading-38">3.6.3 详细思路</h5>
<h6 data-id="heading-39">解耦 “智能推理” 与 “数据操作”</h6>
<p>MemOS 的核心价值是 “让 Agent 拥有可推理的记忆”，而这一目标需要 “先分析（推理）、后操作（存储）” 的流程：</p>
<ul>
<li>第一步：<code>RelationAndReasoningDetector</code> 把 “模糊的自然语言” 翻译成 “结构化的关系与节点需求”（如 “小红买了新手机”→ 识别出 “小红”“新手机” 两个实体，“购买” 关系，生成 “创建两个节点 + 建立关联” 的需求）；</li>
<li>第二步：<code>NodeHandler</code> 接收这个 “明确需求”，执行具体的存储操作（创建小红节点、创建新手机节点、在二者间添加 “购买” 关系边）。</li>
</ul>
<p>若合并为一个类，会导致 “推理逻辑” 与 “存储逻辑” 交织在一起：比如在 “创建节点” 的代码中，既要写 “如何校验节点 ID 唯一性”，又要写 “如何从文本中识别节点实体”—— 当需要修改推理规则（如新增 “合作” 关系识别）时，可能误改存储相关代码；当需要更换数据库（如从 Neo4j 换成 ArangoDB）时，又要动推理相关的逻辑，维护成本指数级上升。</p>
<h6 data-id="heading-40">适配不同的 “扩展与优化方向</h6>
<p>两个类的优化目标完全不同，拆分后可独立迭代，”—— 避免 “牵一发而动全身”。</p>
<ul>
<li>对 <code>RelationAndReasoningDetector</code>：优化方向是 “提升推理准确率”（如引入少样本学习、领域微调、思维链提示）、“支持更多关系类型”（如从二元关系扩展到多元关系）、“降低推理延迟”（如缓存高频推理规则）；</li>
<li>对 <code>NodeHandler</code>：优化方向是 “提升存储性能”（如批量操作、索引优化）、“增强数据一致性”（如事务支持、冲突解决）、“适配多存储引擎”（如同时支持图数据库、向量数据库）。</li>
</ul>
<p>例如：当需要给 MemOS 新增 “时序关系推理” 功能时，只需修改 <code>RelationAndReasoningDetector</code>，新增时序关系识别逻辑（如 “2024 年小明入职→ 小明 - 2024 年入职 - 公司”），<code>NodeHandler</code> 完全无需改动；反之，当需要将节点存储从 “单节点数据库” 扩展到 “分布式存储” 时，只需优化 <code>NodeHandler</code> 的操作接口，推理逻辑不受任何影响。</p>
<h6 data-id="heading-41">提升代码复用性与测试效率</h6>
<ul>
<li>复用性：<code>RelationAndReasoningDetector</code> 的推理能力可被 MemOS 多个模块复用（如 Agent 的决策模块、RAG 的检索增强模块），而 <code>NodeHandler</code> 的节点操作能力可被知识图谱的多个子功能复用（如节点更新、节点查询、节点删除）。若合并，这些复用场景会被迫引入无关逻辑（如调用推理功能时，还要加载存储相关的依赖）；</li>
<li>测试效率：拆分后可独立编写单元测试 —— 测试 <code>RelationAndReasoningDetector</code> 时，只需模拟输入文本，验证输出的关系三元组是否正确，无需依赖真实数据库；测试 <code>NodeHandler</code> 时，只需模拟结构化的节点数据，验证 CRUD 操作是否符合预期，无需启动大模型。若合并，测试用例需同时覆盖 “推理逻辑” 和 “存储逻辑”，场景组合爆炸（如 “推理正确但存储失败”“推理错误但存储成功”），测试难度和维护成本陡增。</li>
</ul>
<h3 data-id="heading-42">0x04 图例</h3>
<h4 data-id="heading-43">4.1 组件关系图</h4>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/dff3f8208ce340369bc5336bc71cca2d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg572X6KW_55qE5oCd6ICD:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765200027&amp;x-signature=yXT%2BPdDb%2FApECt5gG5Q7tzioPG8%3D" alt="MemoryManager流程" loading="lazy"/></p>
<p>MemoryManager流程</p>
<h4 data-id="heading-44">4.2 调用流程图</h4>
<p>调用流程图如下。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/934f70ba3c8b4d2b915a048e86e8bb20~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg572X6KW_55qE5oCd6ICD:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765200027&amp;x-signature=aCO14rWxcOeHkN%2BwhG5AF988aWc%3D" alt="MemoryManager-sequence" loading="lazy"/></p>
<p>MemoryManager-sequence</p>
<p>详细组件交互说明</p>
<ul>
<li>
<p>MemoryManager 与 GraphStructureReorganizer：</p>
<ul>
<li>MemoryManager 在添加新记忆时通过 GraphStructureReorganizer.add_message() 发送消息。</li>
<li>GraphStructureReorganizer 作为后台线程处理这些消息</li>
</ul>
</li>
</ul>

<ul>
<li>
<p>GraphStructureReorganizer 与 NodeHandler</p>
<ul>
<li>在处理 "add" 操作时，调用 NodeHandler.detect() 检测冲突</li>
<li>对于检测到的冲突，调用 NodeHandler.resolve() 解决冲突</li>
</ul>
</li>
<li>
<p>GraphStructureReorganizer 与 RelationAndReasoningDetector</p>
<ul>
<li>在结构优化过程中，调用 RelationAndReasoningDetector.process_node() 处理节点关系检测并创建因果关系、条件关系、推理节点等</li>
</ul>
</li>
<li>
<p>所有组件与 Neo4jGraphDB。所有组件都直接与 Neo4jGraphDB 交互进行图操作：</p>
<ul>
<li>节点操作: add_node(), delete_node(), update_node(), get_node()</li>
<li>边操作: add_edge(), delete_edge(), edge_exists(), get_edges()</li>
<li>查询操作：search_by_embedding(), get_neighbors_by_tag()</li>
</ul>
</li>
</ul>
<p>这个设计实现了分层处理：MemoryManager 负责基本的记忆管理，GraphStructureReorganizer 负责后台结构优化，而 NodeHandler 和 RelationAndReasoningDetector 则专门处理特定的图结构维护任务。</p>
<h3 data-id="heading-45">0xFF 参考</h3>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Farxiv.org%2Fpdf%2F2507.03724" target="_blank" title="https://link.zhihu.com/?target=https%3A//arxiv.org/pdf/2507.03724" ref="nofollow noopener noreferrer">arxiv.org/pdf/2507.03…</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fgithub.com%2FMemTensor%2FMemOS.git" target="_blank" title="https://link.zhihu.com/?target=https%3A//github.com/MemTensor/MemOS.git" ref="nofollow noopener noreferrer">github.com/MemTensor/M…</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FMemTensor%2FMemOS-Docs" target="_blank" title="https://github.com/MemTensor/MemOS-Docs" ref="nofollow noopener noreferrer">github.com/MemTensor/M…</a></p>
<p>本文使用 <a href="https://link.juejin.cn?target=https%3A%2F%2Fmarkdown.com.cn" target="_blank" title="https://markdown.com.cn" ref="nofollow noopener noreferrer">markdown.com.cn</a> 排版</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Claude 代码审查不好用？试试这个我花了一周优化的 Skill]]></title>    <link>https://juejin.cn/post/7578709098255908902</link>    <guid>https://juejin.cn/post/7578709098255908902</guid>    <pubDate>2025-12-01T13:57:38.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7578709098255908902" data-draft-id="7578714735307587610" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Claude 代码审查不好用？试试这个我花了一周优化的 Skill"/> <meta itemprop="keywords" content="Claude,Agent,AI编程"/> <meta itemprop="datePublished" content="2025-12-01T13:57:38.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="也无风雨也雾晴"/> <meta itemprop="url" content="https://juejin.cn/user/2175258804632332"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Claude 代码审查不好用？试试这个我花了一周优化的 Skill
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2175258804632332/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    也无风雨也雾晴
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-01T13:57:38.000Z" title="Mon Dec 01 2025 13:57:38 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-01
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读9分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">从 1774 行到 178 行：我如何重构一个 Claude Code Skill</h2>
<h3 data-id="heading-1">起因</h3>
<p>用 Claude Code 做代码审查，总觉得差点意思。</p>
<p>它能指出明显的 bug，也能给一些重构建议，但给的反馈太泛了——缺少系统化的审查流程，没有语言特定的深度检查，更别说什么"给建设性反馈的技巧"。</p>
<p>后来发现 marketplace 上有个 <code>code-review-excellence</code> skill，装上试了试，确实专业多了。但翻开源码一看：<strong>一个 SKILL.md 文件，1774 行</strong>。</p>
<p>这就有问题了。</p>
<h3 data-id="heading-2">问题在哪</h3>
<p>Claude Code Skills 有个设计叫 <strong>Progressive Disclosure</strong>（渐进式加载）：</p>
<ul>
<li>未激活时：只加载 skill 的 name + description（几十个 token）</li>
<li>激活时：加载完整的 SKILL.md</li>
</ul>
<p>一个 1774 行的文件，一激活就是 15000+ tokens。如果我只是审查一段 Python 代码，却把 React 19 Server Components、Vue 3.5 defineModel、Rust Cancellation Safety 全加载进来——这不是浪费是什么？</p>
<p>更关键的是，这 1774 行里还引用了 <code>references/</code> 和 <code>assets/</code> 目录下的文件，但这些文件<strong>根本不存在</strong>。</p>
<h3 data-id="heading-3">重构思路</h3>
<p>核心目标：<strong>把一个巨型文件拆成按需加载的模块化架构</strong>。</p>
<pre><code class="hljs language-makefile" lang="makefile"><span class="hljs-section">重构前:</span>
SKILL.md (1774 行，全量加载)
​
<span class="hljs-section">重构后:</span>
SKILL.md (~180 行，核心内容，始终加载)
├── reference/
│   ├── react.md (~870 行，审查 React 时加载)
│   ├── vue.md (~920 行，审查 Vue 时加载)
│   ├── rust.md (~840 行，审查 Rust 时加载)
│   ├── typescript.md (~540 行，审查 TS 时加载)
│   └── python.md (~1070 行，审查 Python 时加载)
├── assets/
│   ├── pr-review-template.md (PR 审查模板)
│   └── review-checklist.md (快速检查清单)
└── scripts/
    └── pr-analyzer.py (PR 复杂度分析脚本)
</code></pre>
<p>总内容从 ~1774 行扩展到 ~6000 行，但 SKILL.md 反而缩减到 180 行。</p>
<p>这就是 Progressive Disclosure 的精髓：<strong>核心精炼，细节按需</strong>。</p>
<h3 data-id="heading-4">SKILL.md 怎么写</h3>
<h4 data-id="heading-5">Frontmatter 规范</h4>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-meta">---</span>
<span class="hljs-attr">name:</span> <span class="hljs-string">code-review-excellence</span>
<span class="hljs-attr">description:</span> <span class="hljs-string">|
  Provides comprehensive code review guidance for React 19, Vue 3, Rust, TypeScript, and Python.
  Helps catch bugs, improve code quality, and give constructive feedback.
  Use when: reviewing pull requests, conducting PR reviews, code review, reviewing code changes,
  establishing review standards, mentoring developers, architecture reviews, security audits,
  checking code quality, finding bugs, giving feedback on code.
</span><span class="hljs-attr">allowed-tools:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">Read</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">Grep</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">Glob</span>
<span class="hljs-meta">---
</span></code></pre>
<p>几个要点：</p>
<ol start="0">
<li><strong>name 必须是 kebab-case</strong>，且与目录名一致</li>
<li><strong>description 要包含触发词</strong>，"Use when:" 后面列出使用场景</li>
<li><strong>allowed-tools 可选</strong>，预批准的工具列表，减少确认弹窗</li>
</ol>
<h4 data-id="heading-6">触发词的重要性</h4>
<p>description 里的触发词决定了 skill 何时被激活。写得太窄，很多场景触发不了；写得太宽，容易误触发。</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-comment"># ❌ 太窄</span>
<span class="hljs-attr">description:</span> <span class="hljs-string">Use</span> <span class="hljs-string">when</span> <span class="hljs-string">reviewing</span> <span class="hljs-string">pull</span> <span class="hljs-string">requests</span>
<span class="hljs-string">​</span>
<span class="hljs-comment"># ✅ 覆盖多种表达方式</span>
<span class="hljs-attr">description:</span> <span class="hljs-string">|
  Use when: reviewing pull requests, conducting PR reviews, code review,
  reviewing code changes, establishing review standards, mentoring developers,
  architecture reviews, security audits, checking code quality, finding bugs
</span></code></pre>
<p>用户说"帮我 review 这段代码"、"检查下这个 PR"、"审查下安全性"都能触发。</p>
<h4 data-id="heading-7">内容组织</h4>
<p>SKILL.md 只放"必须知道"的内容：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-comment"># Code Review Excellence</span>
​
<span class="hljs-comment">## When to Use This Skill</span>
- Reviewing pull requests and code changes
- Establishing code review standards for teams
- ...
​
<span class="hljs-comment">## Core Principles</span>
<span class="hljs-section">[审查的核心原则，简明扼要]</span>
​
<span class="hljs-comment">## Review Process</span>
<span class="hljs-section">[4 阶段审查流程：Context → High-Level → Line-by-Line → Summary]</span>
​
<span class="hljs-comment">## Language-Specific Guides</span>
| Language | Reference File | Key Topics |
|----------|----------------|------------|
| React | <span class="hljs-section">[React Guide]</span>(reference/react.md) | Hooks, React 19 Actions, RSC |
| Vue 3 | <span class="hljs-section">[Vue Guide]</span>(reference/vue.md) | Composition API, Vue 3.5 特性 |
| ...
</code></pre>
<p>详细的语言特定内容，通过 Markdown 链接引用 reference/ 目录下的文件。</p>
<p><strong>关键点</strong>：使用 <code>[React Guide](reference/react.md)</code> 这种 Markdown 链接格式，而不是 <code>`reference/react.md`</code> 反引号格式。前者能被 Claude Code 识别并按需加载。</p>
<h3 data-id="heading-8">Reference 文件怎么写</h3>
<p>以 <code>reference/react.md</code> 为例，专注于 React 代码审查的深度内容：</p>
<pre><code class="hljs language-scss" lang="scss"># React 代码审查指南
​
&gt; React 审查重点：Hooks 规则、性能优化的适度性、组件设计、以及现代 React <span class="hljs-number">19</span>/RSC 模式。
​
## 目录
- <span class="hljs-selector-attr">[Hooks 规则与常见错误]</span>(#hooks-规则与常见错误)
- <span class="hljs-selector-attr">[useEffect 深度审查]</span>(#useeffect-深度审查)
- <span class="hljs-selector-attr">[React 19 Actions &amp; Forms]</span>(#react-<span class="hljs-number">19</span>-actions--forms)
- <span class="hljs-selector-attr">[Server Components]</span>(#server-components)
- <span class="hljs-selector-attr">[TanStack Query v5]</span>(#tanstack-query-v5)
​
## Hooks 规则与常见错误
​
### 条件调用 Hooks
​
```tsx
<span class="hljs-comment">// ❌ 条件调用 Hooks — 违反 Hooks 规则</span>
function <span class="hljs-built_in">BadComponent</span>({ show }) {
  if (show) {
    const <span class="hljs-selector-attr">[value, setValue]</span> = <span class="hljs-built_in">useState</span>(<span class="hljs-number">0</span>);  <span class="hljs-comment">// Error!</span>
  }
  return &lt;<span class="hljs-selector-tag">div</span>&gt;...&lt;/<span class="hljs-selector-tag">div</span>&gt;;
}
​
<span class="hljs-comment">// ✅ Hooks 必须在顶层无条件调用</span>
function <span class="hljs-built_in">GoodComponent</span>({ show }) {
  const <span class="hljs-selector-attr">[value, setValue]</span> = <span class="hljs-built_in">useState</span>(<span class="hljs-number">0</span>);
  if (!show) return null;
  return &lt;<span class="hljs-selector-tag">div</span>&gt;{value}&lt;/<span class="hljs-selector-tag">div</span>&gt;;
}
</code></pre>
<p>[更多内容...]</p>
<pre><code class="hljs language-markdown" lang="markdown">​
每个 reference 文件都有：
<span class="hljs-bullet">1.</span> 开头的定位说明（这个文件是干什么的）
<span class="hljs-bullet">2.</span> 清晰的目录结构
<span class="hljs-bullet">3.</span> 大量的 ✅ / ❌ 对比示例
<span class="hljs-bullet">4.</span> 审查清单（Checklist）
​
<span class="hljs-section">## Token 开销对比</span>
​
重构前后的 token 开销变化：
​
</code></pre>
<p>重构前：</p>
<ul>
<li>激活 skill: ~15000 tokens（全量加载）</li>
</ul>
<p>重构后：</p>
<ul>
<li>激活 skill: ~1500 tokens（仅 SKILL.md）</li>
<li>审查 React 代码: +7000 tokens（加载 react.md）</li>
<li>审查 Python 代码: +8500 tokens（加载 python.md）</li>
<li>审查 Vue 代码: +7500 tokens（加载 vue.md）</li>
</ul>
<pre><code class="hljs language-shell" lang="shell">​
如果我只审查 Python 代码，现在只需要 ~10000 tokens，而不是之前的 15000 tokens。
​
更重要的是，这 6000 行的内容比原来 1774 行**更深入**——每个语言都有完整的审查指南，而不是蜻蜓点水。
​
<span class="hljs-meta prompt_">#</span><span class="bash"><span class="hljs-comment"># 实际效果</span></span>
​
<span class="hljs-meta prompt_">#</span><span class="bash"><span class="hljs-comment">## 没有 Skill 时</span></span>
​
</code></pre>
<p>问：审查这段代码的安全性</p>
<p>Claude：这段代码看起来有几个潜在问题... [泛泛的建议，缺少系统性]</p>
<pre><code class="hljs language-shell" lang="shell">​
<span class="hljs-meta prompt_">#</span><span class="bash"><span class="hljs-comment">## 有 Skill 后</span></span>
​
</code></pre>
<p>问：审查这段代码的安全性</p>
<p>Claude：</p>
<h3 data-id="heading-9">安全审查报告</h3>
<h4 data-id="heading-10">🔴 严重问题 (Blocking)</h4>
<ol start="0">
<li>
<p>SQL 注入风险 - 第 23 行直接拼接用户输入</p>
<blockquote>
<p>建议使用参数化查询：<code>cursor.execute("SELECT * FROM users WHERE id = %s", (user_id,))</code></p>
</blockquote>
</li>
</ol>
<h4 data-id="heading-11">🟡 重要改进 (Important)</h4>
<ol start="2">
<li>缺少输入验证 - user_id 未校验类型和范围</li>
</ol>
<h4 data-id="heading-12">安全检查清单</h4>
<ul>
<li>参数化查询</li>
<li>输入验证</li>
<li>错误信息脱敏 ...</li>
</ul>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-string">​</span>
<span class="hljs-string">结构化、可执行、有优先级。这才是专业的代码审查。</span>
<span class="hljs-string">​</span>
<span class="hljs-meta">---</span>
<span class="hljs-string">​</span>
<span class="hljs-comment">## code-review-skill：一个真正可用的代码审查 Skill</span>
<span class="hljs-string">​</span>
<span class="hljs-string">经过多轮迭代，这个</span> <span class="hljs-string">skill</span> <span class="hljs-string">已经从最初的"修复别人的</span> <span class="hljs-string">bug"变成了一个**完整的代码审查解决方案**。</span>
<span class="hljs-string">​</span>
<span class="hljs-comment">### 为什么用这个 Skill</span>
<span class="hljs-string">​</span>
<span class="hljs-string">|</span> <span class="hljs-string">痛点</span> <span class="hljs-string">|</span> <span class="hljs-string">原生</span> <span class="hljs-string">Claude</span> <span class="hljs-string">|</span> <span class="hljs-string">使用</span> <span class="hljs-string">code-review-skill</span> <span class="hljs-string">|</span>
<span class="hljs-string">|------|------------|----------------------|</span>
<span class="hljs-string">|</span> <span class="hljs-string">审查流程</span> <span class="hljs-string">|</span> <span class="hljs-string">想到哪说哪</span> <span class="hljs-string">|</span> <span class="hljs-number">4</span> <span class="hljs-string">阶段系统化流程</span> <span class="hljs-string">|</span>
<span class="hljs-string">|</span> <span class="hljs-string">问题分级</span> <span class="hljs-string">|</span> <span class="hljs-string">混在一起</span> <span class="hljs-string">|</span> <span class="hljs-string">🔴</span> <span class="hljs-string">Blocking</span> <span class="hljs-string">/</span> <span class="hljs-string">🟡</span> <span class="hljs-string">Important</span> <span class="hljs-string">/</span> <span class="hljs-string">🟢</span> <span class="hljs-string">Nit</span> <span class="hljs-string">|</span>
<span class="hljs-string">|</span> <span class="hljs-string">语言深度</span> <span class="hljs-string">|</span> <span class="hljs-string">泛泛而谈</span> <span class="hljs-string">|</span> <span class="hljs-string">框架特定的最佳实践和陷阱</span> <span class="hljs-string">|</span>
<span class="hljs-string">|</span> <span class="hljs-string">反馈方式</span> <span class="hljs-string">|</span> <span class="hljs-string">直接指出问题</span> <span class="hljs-string">|</span> <span class="hljs-string">提问式引导</span> <span class="hljs-string">+</span> <span class="hljs-string">建设性建议</span> <span class="hljs-string">|</span>
<span class="hljs-string">|</span> <span class="hljs-string">版本覆盖</span> <span class="hljs-string">|</span> <span class="hljs-string">可能过时</span> <span class="hljs-string">|</span> <span class="hljs-string">React</span> <span class="hljs-number">19</span><span class="hljs-string">、Vue</span> <span class="hljs-number">3.5</span><span class="hljs-string">、TanStack</span> <span class="hljs-string">Query</span> <span class="hljs-string">v5</span> <span class="hljs-string">|</span>
<span class="hljs-string">​</span>
<span class="hljs-comment">### 支持的语言和框架</span>
<span class="hljs-string">​</span>
</code></pre>
<p>┌─────────────────────────────────────────────────────────────┐ │ Language/Framework Version Key Topics │ ├─────────────────────────────────────────────────────────────┤ │ React 18.x, 19.x Hooks, Actions, │ │ RSC, Suspense │ ├─────────────────────────────────────────────────────────────┤ │ Vue 3.4+, 3.5+ Composition API,│ │ defineModel, │ │ useTemplateRef │ ├─────────────────────────────────────────────────────────────┤ │ TanStack Query v5.x useSuspenseQuery│ │ Optimistic UI │ ├─────────────────────────────────────────────────────────────┤ │ TypeScript 5.x Generics, Strict│ │ Mode, ESLint │ ├─────────────────────────────────────────────────────────────┤ │ Python 3.10+ async/await, │ │ typing, pytest │ ├─────────────────────────────────────────────────────────────┤ │ Rust 2021 Edition Ownership, Async│ │ Cancellation │ │ Safety │ └─────────────────────────────────────────────────────────────┘</p>
<pre><code class="hljs language-scss" lang="scss">​
每个语言都有独立的深度指南，不是简单的 checklist，而是**真正能帮你发现问题的审查要点**。
​
### 特色功能
​
**<span class="hljs-number">1</span>. React <span class="hljs-number">19</span> Actions 完整指南**
​
```tsx
<span class="hljs-comment">// skill 会帮你识别这种错误：</span>
const <span class="hljs-selector-attr">[state, action]</span> = <span class="hljs-built_in">useActionState</span>(async (prev, formData) =&gt; {
  <span class="hljs-built_in">setSomeState</span>(newValue);  <span class="hljs-comment">// ❌ 不应该在 Action 中 setState</span>
}, initialState);
​
<span class="hljs-comment">// 并建议正确做法：</span>
const <span class="hljs-selector-attr">[state, action]</span> = <span class="hljs-built_in">useActionState</span>(async (prev, formData) =&gt; {
  const result = await <span class="hljs-built_in">submitForm</span>(formData);
  return { ..<span class="hljs-selector-class">.prev</span>, data: result };  <span class="hljs-comment">// ✅ 返回新状态</span>
}, initialState);
</code></pre>
<p><strong>2. Vue 3.5 新特性审查</strong></p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-comment">&lt;!-- skill 知道 Vue 3.5 的 Reactive Props Destructure --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-comment">// Vue 3.5 之前：这样会丢失响应性</span>
<span class="hljs-keyword">const</span> { count } = defineProps&lt;{ <span class="hljs-attr">count</span>: number }&gt;()
​
<span class="hljs-comment">// Vue 3.5+：skill 会告诉你这样是安全的</span>
<span class="hljs-keyword">const</span> { count } = defineProps&lt;{ <span class="hljs-attr">count</span>: number }&gt;()  <span class="hljs-comment">// ✅ 保持响应性</span>
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<p><strong>3. Rust Cancellation Safety</strong></p>
<pre><code class="hljs language-rust" lang="rust"><span class="hljs-comment">// skill 会识别取消不安全的代码：</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">not_cancel_safe</span>(conn: &amp;<span class="hljs-keyword">mut</span> Connection) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;()&gt; {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">data</span> = <span class="hljs-title function_ invoke__">read_data</span>().<span class="hljs-keyword">await</span>?;           <span class="hljs-comment">// 如果这里被取消</span>
    conn.<span class="hljs-title function_ invoke__">write_data</span>(data).<span class="hljs-keyword">await</span>?;            <span class="hljs-comment">// 数据可能部分写入</span>
    conn.<span class="hljs-title function_ invoke__">send_ack</span>().<span class="hljs-keyword">await</span>?;
    <span class="hljs-title function_ invoke__">Ok</span>(())
}
​
<span class="hljs-comment">// 并解释为什么这是问题，以及如何修复</span>
</code></pre>
<p><strong>4. TanStack Query v5 最佳实践</strong></p>
<p>包括 <code>useSuspenseQuery</code> 的限制（不支持 <code>enabled</code>、<code>placeholderData</code>）、乐观更新的正确姿势、<code>queryKey</code> 设计等。</p>
<p><strong>5. PR 复杂度分析脚本</strong></p>
<pre><code class="hljs language-bash" lang="bash">git diff main...HEAD | python scripts/pr-analyzer.py
​
<span class="hljs-comment"># 输出：</span>
<span class="hljs-comment"># ============================================================</span>
<span class="hljs-comment"># PR ANALYSIS REPORT</span>
<span class="hljs-comment"># ============================================================</span>
<span class="hljs-comment"># 📊 SUMMARY</span>
<span class="hljs-comment">#    Files changed: 12</span>
<span class="hljs-comment">#    Additions: +450</span>
<span class="hljs-comment">#    Deletions: -120</span>
<span class="hljs-comment">#    Total changes: 570</span>
<span class="hljs-comment">#</span>
<span class="hljs-comment"># 📏 SIZE: M (Medium)</span>
<span class="hljs-comment">#    Complexity score: 0.45/1.0</span>
<span class="hljs-comment">#    Estimated review time: ~25 minutes</span>
<span class="hljs-comment">#</span>
<span class="hljs-comment"># ⚠️  RISK FACTORS:</span>
<span class="hljs-comment">#    • Security-sensitive file: src/auth/jwt.ts</span>
<span class="hljs-comment">#    • Low test ratio (&lt;20%) - consider adding more tests</span>
<span class="hljs-comment">#</span>
<span class="hljs-comment"># 💡 SUGGESTIONS:</span>
<span class="hljs-comment">#    • Check for proper type usage (avoid 'any')</span>
</code></pre>
<h4 data-id="heading-13">安装方法</h4>
<p><strong>方式 1：直接克隆（推荐）</strong></p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 克隆到 skills 目录</span>
git <span class="hljs-built_in">clone</span> https://github.com/tt-a1i/code-review-skill.git ~/.claude/skills/code-review-excellence
​
<span class="hljs-comment"># 验证安装</span>
<span class="hljs-built_in">ls</span> ~/.claude/skills/code-review-excellence/SKILL.md
</code></pre>
<p><strong>方式 2：作为符号链接</strong></p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 克隆到任意位置</span>
git <span class="hljs-built_in">clone</span> https://github.com/tt-a1i/code-review-skill.git ~/projects/code-review-skill
​
<span class="hljs-comment"># 创建符号链接</span>
<span class="hljs-built_in">ln</span> -sf ~/projects/code-review-skill ~/.claude/skills/code-review-excellence
</code></pre>
<p><strong>方式 3：项目级安装</strong></p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 在项目根目录</span>
<span class="hljs-built_in">mkdir</span> -p .claude/skills
git <span class="hljs-built_in">clone</span> https://github.com/tt-a1i/code-review-skill.git .claude/skills/code-review-excellence
​
<span class="hljs-comment"># 提交到项目仓库，团队共享</span>
git add .claude/
git commit -m <span class="hljs-string">"Add code-review-excellence skill"</span>
</code></pre>
<h4 data-id="heading-14">使用场景</h4>
<p>安装后，这些场景会自动触发 skill：</p>
<pre><code class="hljs language-arduino" lang="arduino">✅ <span class="hljs-string">"帮我审查这段代码"</span>
✅ <span class="hljs-string">"review 这个 PR"</span>
✅ <span class="hljs-string">"检查下有没有安全问题"</span>
✅ <span class="hljs-string">"这段代码有什么问题"</span>
✅ <span class="hljs-string">"帮我 code review"</span>
✅ <span class="hljs-string">"看看这个函数写得怎么样"</span>
✅ <span class="hljs-string">"给些改进建议"</span>
</code></pre>
<h4 data-id="heading-15">与其他 Skill 的区别</h4>
<p>市面上也有其他代码审查相关的 skill，这个有什么不同？</p>








































<table><thead><tr><th>特性</th><th>其他 Skills</th><th>code-review-skill</th></tr></thead><tbody><tr><td>架构</td><td>单文件 1000+ 行</td><td>Progressive Disclosure</td></tr><tr><td>内容深度</td><td>通用建议</td><td>框架特定深度指南</td></tr><tr><td>版本更新</td><td>可能滞后</td><td>React 19 / Vue 3.5 / TQ v5</td></tr><tr><td>资源文件</td><td>通常缺失</td><td>完整的 reference + assets</td></tr><tr><td>Token 效率</td><td>全量加载</td><td>按需加载</td></tr><tr><td>可维护性</td><td>难以更新</td><td>模块化，易于迭代</td></tr></tbody></table>
<hr/>
<h3 data-id="heading-16">开发过程中的坑</h3>
<h4 data-id="heading-17">1. 目录名是 reference/ 不是 references/</h4>
<p>最初照着其他 skill 写，用了 <code>references/</code>（带 s）。结果 Claude Code 找不到文件。</p>
<p>翻了官方规范才发现，标准目录名是 <code>reference/</code>（不带 s）。</p>
<h4 data-id="heading-18">2. 文件引用格式</h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># ❌ 错误：反引号格式</span>
See `reference/react.md` <span class="hljs-keyword">for</span> details.
​
<span class="hljs-comment"># ✅ 正确：Markdown 链接格式</span>
See [React Guide](reference/react.md) <span class="hljs-keyword">for</span> details.
</code></pre>
<p>反引号只是展示路径，不会触发加载。Markdown 链接才是按需加载的触发器。</p>
<h4 data-id="heading-19">3. Frontmatter 的 allowed-tools</h4>
<p>这个字段是可选的，但加上后体验更好：</p>
<pre><code class="hljs language-markdown" lang="markdown">allowed-tools:
<span class="hljs-bullet">  -</span> Read
<span class="hljs-bullet">  -</span> Grep
<span class="hljs-bullet">  -</span> Glob
</code></pre>
<p>这些工具会被预批准，Claude 读取代码时不用反复确认权限。</p>
<h3 data-id="heading-20">源码</h3>
<p>完整实现在 GitHub：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ftt-a1i%2Fcode-review-skill" target="_blank" title="https://github.com/tt-a1i/code-review-skill" ref="nofollow noopener noreferrer">tt-a1i/code-review-skill</a></p>
<p>目录结构：</p>
<pre><code class="hljs language-bash" lang="bash">code-review-skill/
├── SKILL.md              <span class="hljs-comment"># 核心文件 (~180 行)</span>
├── reference/            <span class="hljs-comment"># 深度指南 (按需加载)</span>
│   ├── react.md          <span class="hljs-comment"># React 19 + TanStack Query v5</span>
│   ├── vue.md            <span class="hljs-comment"># Vue 3.5 + Composition API</span>
│   ├── rust.md           <span class="hljs-comment"># 所有权、async、Cancellation Safety</span>
│   ├── typescript.md     <span class="hljs-comment"># 泛型、strict 模式</span>
│   ├── python.md         <span class="hljs-comment"># 类型注解、async/await、pytest</span>
│   ├── common-bugs-checklist.md
│   ├── security-review-guide.md
│   └── code-review-best-practices.md
├── assets/               <span class="hljs-comment"># 模板文件</span>
│   ├── pr-review-template.md
│   └── review-checklist.md
├── scripts/              <span class="hljs-comment"># 工具脚本</span>
│   └── pr-analyzer.py    <span class="hljs-comment"># PR 复杂度分析</span>
├── README.md
├── CONTRIBUTING.md       <span class="hljs-comment"># Skill 开发规范</span>
└── LICENSE
</code></pre>
<h3 data-id="heading-21">总结</h3>
<p>重构这个 skill 的过程，让我对 Claude Code Skills 的设计有了更深的理解：</p>
<ol start="0">
<li><strong>Progressive Disclosure 不是口号</strong>——它是实实在在的 token 优化策略</li>
<li><strong>SKILL.md 要精炼</strong>——控制在 200 行以内，只放必须知道的内容</li>
<li><strong>深度内容放 reference/</strong> ——按需加载，用 Markdown 链接引用</li>
<li><strong>触发词要全面</strong>——覆盖用户的各种表达方式</li>
<li><strong>实际内容要深入</strong>——既然是按需加载，就不用吝啬内容深度</li>
</ol>
<p>一个设计良好的 skill，应该是"激活成本低、使用价值高"。</p>
<p>希望这篇文章能帮到也想开发 Claude Code Skill 的你。</p>
<hr/>
<h3 data-id="heading-22">相关资源</h3>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.anthropic.com%2Fen%2Fdocs%2Fclaude-code%2Fskills" target="_blank" title="https://docs.anthropic.com/en/docs/claude-code/skills" ref="nofollow noopener noreferrer">Claude Code Skills 官方文档</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fanthropics%2Fskills" target="_blank" title="https://github.com/anthropics/skills" ref="nofollow noopener noreferrer">Anthropic Skills 规范</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ftt-a1i%2Fcode-review-skill" target="_blank" title="https://github.com/tt-a1i/code-review-skill" ref="nofollow noopener noreferrer">code-review-skill 源码</a></li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[【鸿蒙开发案例篇】传说中的跨设备丝滑协同服务]]></title>    <link>https://juejin.cn/post/7578667193321242687</link>    <guid>https://juejin.cn/post/7578667193321242687</guid>    <pubDate>2025-12-01T11:12:50.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7578667193321242687" data-draft-id="7578667193321226303" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="【鸿蒙开发案例篇】传说中的跨设备丝滑协同服务"/> <meta itemprop="keywords" content="HarmonyOS,ArkTS,ArkUI"/> <meta itemprop="datePublished" content="2025-12-01T11:12:50.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="威哥爱编程"/> <meta itemprop="url" content="https://juejin.cn/user/2242659450109575"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            【鸿蒙开发案例篇】传说中的跨设备丝滑协同服务
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2242659450109575/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    威哥爱编程
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-01T11:12:50.000Z" title="Mon Dec 01 2025 11:12:50 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-01
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>大家好，我是 V 哥。今天我们将深入鸿蒙 6.0（API21）的分布式能力，探讨如何通过<strong>网络协同服务</strong>实现跨设备互通，结合 ArkTS 开发实践，提供一套完整的技术方案与代码示例。</p>
<p>联系V哥获取 <a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.huawei.com%2Fconsumer%2Fcn%2Ftraining%2FclassDetail%2F042cb1cc4d7d44ecbdbd902fd1275dcc%3Ftype%3D1%3Fha_source%3Dhmosclass%26ha_sourceId%3D89000248" target="_blank" title="https://developer.huawei.com/consumer/cn/training/classDetail/042cb1cc4d7d44ecbdbd902fd1275dcc?type=1?ha_source=hmosclass&amp;ha_sourceId=89000248" ref="nofollow noopener noreferrer">鸿蒙学习资料</a></p>
<hr/>
<h3 data-id="heading-0">一、技术背景与核心概念</h3>
<p>鸿蒙系统的<strong>分布式软总线</strong>（Distributed Soft Bus）是跨设备协同的底层基石，它通过近场感知、设备发现与连接管理，实现了设备间的低功耗、高速率通信。而**远程过程调用（RPC）**是上层应用实现跨设备功能的核心接口，其通过软总线驱动完成数据传输与接口调用。</p>
<p>关键流程：<br/>
<strong>设备发现 → 服务注册 → RPC 接口绑定 → 跨设备方法调用 → 数据同步</strong></p>
<hr/>
<h3 data-id="heading-1">二、开发环境配置</h3>
<p>在 <code>module.json5</code> 中添加必要依赖与权限：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"module"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"dependencies"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"@ohos.distributedHardware.distributedDeviceManager"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"^1.0"</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 设备管理模块</span>
      <span class="hljs-attr">"@ohos.app.ability.featureAbility"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"^1.0"</span><span class="hljs-punctuation">,</span>                    <span class="hljs-comment">// Ability 调用</span>
      <span class="hljs-attr">"@ohos.rpc"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"^1.0"</span>                                            <span class="hljs-comment">// RPC 核心接口</span>
    <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"requestPermissions"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
      <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"ohos.permission.DISTRIBUTED_DEVICE_STATE_CHANGE"</span>    <span class="hljs-comment">// 监听设备状态</span>
      <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
      <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"ohos.permission.GET_DISTRIBUTED_DEVICE_INFO"</span>       <span class="hljs-comment">// 获取设备信息</span>
      <span class="hljs-punctuation">}</span>
    <span class="hljs-punctuation">]</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<hr/>
<h3 data-id="heading-2">三、核心实现步骤（ArkTS 案例）</h3>
<h4 data-id="heading-3">场景说明：</h4>
<p>实现一个跨设备文本同步功能，例如在手机端输入文字，实时显示在平板端。</p>
<hr/>
<h4 data-id="heading-4"><strong>步骤 1：设备发现与连接管理</strong></h4>
<p>使用 <code>DistributedDeviceManager</code>（简称 DDM）获取目标设备的 <code>NetworkId</code>：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">import</span> deviceManager <span class="hljs-keyword">from</span> <span class="hljs-string">'@ohohs.distributedHardware.distributedDeviceManager'</span>;

<span class="hljs-comment">// 初始化设备管理器</span>
<span class="hljs-keyword">const</span> dm = deviceManager.<span class="hljs-title function_">getDistributedDeviceManager</span>(<span class="hljs-title function_">getContext</span>(<span class="hljs-variable language_">this</span>) <span class="hljs-keyword">as</span> common.<span class="hljs-property">UIAbilityContext</span>);

<span class="hljs-comment">// 监听设备变化（如新增/断开设备）</span>
dm.<span class="hljs-title function_">on</span>(<span class="hljs-string">'deviceChange'</span>, <span class="hljs-function">(<span class="hljs-params">deviceInfo: deviceManager.DeviceInfo[]</span>) =&gt;</span> {
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> info <span class="hljs-keyword">of</span> deviceInfo) {
    <span class="hljs-keyword">if</span> (info.<span class="hljs-property">deviceType</span> === deviceManager.<span class="hljs-property">DeviceType</span>.<span class="hljs-property">TAB</span>) { <span class="hljs-comment">// 假设目标设备是平板</span>
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">'发现目标设备:'</span>, info.<span class="hljs-property">networkId</span>);
      <span class="hljs-comment">// 触发后续服务绑定逻辑</span>
    }
  }
});
</code></pre>
<hr/>
<h4 data-id="heading-5"><strong>步骤 2：服务端接口定义与注册</strong></h4>
<p>服务端（如平板设备）需定义一个远程服务接口，用于接收客户端（手机）的文本数据。</p>
<p>1.<strong>定义远程服务接口（Stub）</strong>
创建一个继承自 <code>RemoteObject</code> 的服务端类，实现 <code>onRemoteMessageRequest</code> 方法：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">import</span> rpc <span class="hljs-keyword">from</span> <span class="hljs-string">'@ohos.rpc'</span>;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">TextSyncStub</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">rpc.RemoteObject</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">descriptor: <span class="hljs-built_in">string</span></span>) {
    <span class="hljs-variable language_">super</span>(descriptor); <span class="hljs-comment">// 接口标识符，需与客户端一致</span>
  }

  <span class="hljs-comment">// 处理客户端发送的文本数据</span>
  <span class="hljs-title function_">onRemoteMessageRequest</span>(<span class="hljs-attr">code</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">data</span>: rpc.<span class="hljs-property">MessageSequence</span>, <span class="hljs-attr">reply</span>: rpc.<span class="hljs-property">MessageSequence</span>, <span class="hljs-attr">option</span>: rpc.<span class="hljs-property">MessageOption</span>): <span class="hljs-built_in">boolean</span> | <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">boolean</span>&gt; {
    <span class="hljs-keyword">if</span> (code === <span class="hljs-number">1</span>) { <span class="hljs-comment">// 自定义方法标识码</span>
      <span class="hljs-keyword">const</span> receivedText = data.<span class="hljs-title function_">readString</span>(); <span class="hljs-comment">// 读取客户端发送的文本</span>
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">'服务端接收到文本:'</span>, receivedText);
      <span class="hljs-comment">// 在本地 UI 中更新文本（示例）</span>
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">onTextReceived</span>(receivedText);
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }

  <span class="hljs-comment">// 本地回调：更新 UI（需结合 Ability 生命周期）</span>
  <span class="hljs-title function_">onTextReceived</span>(<span class="hljs-params">text: <span class="hljs-built_in">string</span></span>) {
    <span class="hljs-comment">// 示例：更新 UIAbility 中的 @State 变量</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">textContent</span> = text;
  }
}
</code></pre>
<p>2.<strong>在服务端 Ability 中注册服务</strong>
服务端 Ability 需通过 <code>SAMgr</code>（系统能力管理器）注册服务：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">import</span> rpc <span class="hljs-keyword">from</span> <span class="hljs-string">'@ohos.rpc'</span>;
<span class="hljs-keyword">import</span> featureAbility <span class="hljs-keyword">from</span> <span class="hljs-string">'@ohos.app.ability.featureAbility'</span>;

<span class="hljs-meta">@Entry</span>
<span class="hljs-meta">@Component</span>
struct <span class="hljs-title class_">TextSyncServer</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-attr">stub</span>: <span class="hljs-title class_">TextSyncStub</span> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;

  <span class="hljs-title function_">aboutToAppear</span>(<span class="hljs-params"/>) {
    <span class="hljs-comment">// 创建 Stub 实例</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">stub</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextSyncStub</span>(<span class="hljs-string">'com.example.textsync.service'</span>);
    <span class="hljs-comment">// 注册系统能力（System Ability）</span>
    featureAbility.<span class="hljs-title function_">registerSystemAbility</span>(<span class="hljs-number">1001</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">stub</span>); <span class="hljs-comment">// 1001 为自定义的 SA ID</span>
  }
}
</code></pre>
<hr/>
<h4 data-id="heading-6"><strong>步骤 3：客户端绑定服务并发送数据</strong></h4>
<p>客户端（如手机）通过 <code>NetworkId</code> 绑定服务端的远程服务，并调用其接口发送数据。</p>
<p>1.<strong>绑定服务端 Ability</strong>
客户端需构造 <code>Want</code> 对象，指定目标设备的 <code>NetworkId</code> 与服务描述符：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">import</span> rpc <span class="hljs-keyword">from</span> <span class="hljs-string">'@ohos.rpc'</span>;
<span class="hljs-keyword">import</span> featureAbility <span class="hljs-keyword">from</span> <span class="hljs-string">'@ohos.app.ability.featureAbility'</span>;

<span class="hljs-comment">// 获取目标设备 NetworkId（通过 DDM 发现）</span>
<span class="hljs-keyword">const</span> targetNetworkId = <span class="hljs-string">'12:34:56:78:90:AB'</span>; <span class="hljs-comment">// 示例设备 ID</span>

<span class="hljs-comment">// 构造 Want 对象</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">want</span>: <span class="hljs-title class_">Want</span> = {
  <span class="hljs-attr">deviceId</span>: targetNetworkId, <span class="hljs-comment">// 目标设备 ID</span>
  <span class="hljs-attr">bundleName</span>: <span class="hljs-string">'com.example.textsync'</span>, <span class="hljs-comment">// 服务端应用包名</span>
  <span class="hljs-attr">abilityName</span>: <span class="hljs-string">'TextSyncServer'</span>, <span class="hljs-comment">// 服务端 Ability 名称</span>
  <span class="hljs-attr">parameters</span>: {
    <span class="hljs-comment">// 可选参数</span>
  }
};

<span class="hljs-comment">// 绑定服务</span>
featureAbility.<span class="hljs-title function_">connectAbility</span>(want, {
  <span class="hljs-attr">onConnect</span>: <span class="hljs-function">(<span class="hljs-params">proxy: rpc.RemoteObject</span>) =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">'客户端绑定服务成功:'</span>, proxy);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">proxy</span> = proxy; <span class="hljs-comment">// 保存代理对象</span>
  },
  <span class="hljs-attr">onDisconnect</span>: <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">'服务连接断开'</span>);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">proxy</span> = <span class="hljs-literal">null</span>;
  },
  <span class="hljs-attr">onFailed</span>: <span class="hljs-function">(<span class="hljs-params">errCode: <span class="hljs-built_in">number</span></span>) =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'绑定服务失败，错误码:'</span>, errCode);
  }
});
</code></pre>
<p>2.<strong>通过 Proxy 调用远程方法</strong>
客户端通过代理对象 <code>proxy</code> 调用服务端方法，发送文本数据：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 发送文本到服务端</span>
<span class="hljs-keyword">async</span> <span class="hljs-title function_">sendTextToServer</span>(<span class="hljs-params">text: <span class="hljs-built_in">string</span></span>) {
  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">proxy</span>) {
    <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">new</span> rpc.<span class="hljs-title class_">MessageSequence</span>();
    <span class="hljs-keyword">const</span> reply = <span class="hljs-keyword">new</span> rpc.<span class="hljs-title class_">MessageSequence</span>();
    data.<span class="hljs-title function_">writeString</span>(text); <span class="hljs-comment">// 将文本写入数据包</span>
    <span class="hljs-comment">// 调用服务端方法（code 为 1，需与服务端一致）</span>
    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">proxy</span>.<span class="hljs-title function_">sendMessageRequest</span>(<span class="hljs-number">1</span>, data, reply);
    <span class="hljs-keyword">if</span> (result) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">'发送成功'</span>);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'发送失败'</span>);
    }
  }
}
</code></pre>
<hr/>
<h3 data-id="heading-7">四、完整 UI 交互案例</h3>
<h4 data-id="heading-8">服务端 UI（平板端）</h4>
<p>展示接收到的文本：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-meta">@Component</span>
struct <span class="hljs-title class_">TextDisplay</span> {
  <span class="hljs-meta">@State</span> <span class="hljs-attr">text</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">''</span>;

  <span class="hljs-title function_">build</span>(<span class="hljs-params"/>) {
    <span class="hljs-title class_">Column</span>() {
      <span class="hljs-title class_">Text</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">text</span>)
        .<span class="hljs-title function_">fontSize</span>(<span class="hljs-number">30</span>)
        .<span class="hljs-title function_">textAlign</span>(<span class="hljs-title class_">TextAlign</span>.<span class="hljs-property">Center</span>)
        .<span class="hljs-title function_">width</span>(<span class="hljs-string">'100%'</span>)
        .<span class="hljs-title function_">height</span>(<span class="hljs-string">'100%'</span>)
    }
  }
}
</code></pre>
<h4 data-id="heading-9">客户端 UI（手机端）</h4>
<p>输入文本并发送：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-meta">@Component</span>
struct <span class="hljs-title class_">TextInput</span> {
  <span class="hljs-meta">@State</span> <span class="hljs-attr">inputText</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">''</span>;
  <span class="hljs-keyword">private</span> <span class="hljs-attr">proxy</span>: rpc.<span class="hljs-property">RemoteObject</span> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;

  <span class="hljs-title function_">build</span>(<span class="hljs-params"/>) {
    <span class="hljs-title class_">Column</span>() {
      <span class="hljs-title class_">TextInput</span>({ <span class="hljs-attr">placeholder</span>: <span class="hljs-string">'输入文本'</span> })
        .<span class="hljs-title function_">onChange</span>(<span class="hljs-function">(<span class="hljs-params">value: <span class="hljs-built_in">string</span></span>) =&gt;</span> {
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputText</span> = value;
        })
      <span class="hljs-title class_">Button</span>(<span class="hljs-string">'发送到平板'</span>)
        .<span class="hljs-title function_">onClick</span>(<span class="hljs-function">() =&gt;</span> {
          <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">sendTextToServer</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">inputText</span>);
        })
    }
  }
}
</code></pre>
<hr/>
<h3 data-id="heading-10">五、关键注意事项与性能优化</h3>
<p>1.<strong>设备兼容性</strong></p>
<ul>
<li>确保目标设备已开启超级终端功能，并且网络状态正常。</li>
<li>检查目标设备是否支持鸿蒙 6.0 及其 API 特性。</li>
</ul>
<p>2.<strong>软总线连接稳定性</strong></p>
<ul>
<li>通过 <code>DistributedDeviceManager</code> 监听设备状态变化，动态断开或重连。</li>
<li>使用 <code>onDisconnect</code> 回调处理异常断开情况。</li>
</ul>
<p>3.<strong>数据序列化与反序列化</strong></p>
<ul>
<li>通过 <code>MessageSequence</code> 传递数据时，需保证客户端与服务端的字段类型与顺序一致。</li>
<li>对于复杂数据（如 PixelMap），需通过 <code>Parcel</code> 接口实现自定义序列化。</li>
</ul>
<p>4.<strong>性能优化</strong></p>
<ul>
<li><strong>减少跨设备传输的数据量</strong>：对大图片等数据，建议在客户端进行压缩后再发送。</li>
<li><strong>异步处理</strong>：服务端的 <code>onRemoteMessageRequest</code> 方法应尽量异步处理数据，避免阻塞主线程。</li>
<li><strong>连接复用</strong>：避免频繁建立与断开连接，可缓存已连接的 <code>proxy</code> 对象。</li>
</ul>
<hr/>
<h3 data-id="heading-11">六、扩展场景：跨设备图片同步</h3>
<p>结合前文提到的 <code>PixelMap</code> 处理能力，可进一步实现图片的跨设备同步：
1.客户端将 <code>PixelMap</code> 转为 <code>ArrayBuffer</code>（通过 <code>getPixelBytes()</code>）。
2.使用 <code>MessageSequence</code> 的 <code>writeArrayBuffer()</code> 方法发送。
3.服务端通过 <code>readArrayBuffer()</code> 接收，并用 <code>image.createPixelMap()</code> 重建图像。</p>
<hr/>
<h3 data-id="heading-12">总结</h3>
<p>通过鸿蒙 6.0 的网络协同服务（RPC + 软总线），开发者可以轻松实现跨设备的数据互通。关键在于：</p>
<ul>
<li><strong>服务端</strong>：定义并注册远程接口（Stub），处理来自客户端的请求。</li>
<li><strong>客户端</strong>：发现设备、绑定服务（Proxy），并调用其方法发送数据。</li>
</ul>
<p>我是 V 哥，下期将解析如何结合分布式软总线与 <code>PixelMap</code> 实现<strong>跨设备实时滤镜同步</strong>（如手机拍摄后实时推送到平板渲染）。如果你在跨设备通信中遇到问题，欢迎在评论区留言，我们共同探讨！</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5d164105cb6e46d4be0cbe886a787208~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aiB5ZOl54ix57yW56iL:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765192370&amp;x-signature=Pf2hAxh0CBRN%2Fyi4Cg1u5L2Tdy0%3D" alt="WX20250512-113156@2x.png" loading="lazy"/></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Cloudflare unwrap崩溃？整理下Rust危险操作]]></title>    <link>https://juejin.cn/post/7578681104292249643</link>    <guid>https://juejin.cn/post/7578681104292249643</guid>    <pubDate>2025-12-01T11:15:16.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7578681104292249643" data-draft-id="7578697614390214662" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content=" Cloudflare unwrap崩溃？整理下Rust危险操作"/> <meta itemprop="keywords" content="Rust"/> <meta itemprop="datePublished" content="2025-12-01T11:15:16.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="大鱼七成饱"/> <meta itemprop="url" content="https://juejin.cn/user/3017475369480509"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
             Cloudflare unwrap崩溃？整理下Rust危险操作
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3017475369480509/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    大鱼七成饱
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-01T11:15:16.000Z" title="Mon Dec 01 2025 11:15:16 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-01
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">引言</h2>
<p>这是Rust九九八十一难第十五篇。之前聊过<a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FvQB7YYq9t_oI4tl1DeqGVA" target="_blank" title="https://mp.weixin.qq.com/s/vQB7YYq9t_oI4tl1DeqGVA" ref="nofollow noopener noreferrer">anyhow</a>，也介绍了<a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FNoBG_qdz4EX6VjZFkG7wUA" target="_blank" title="https://mp.weixin.qq.com/s/NoBG_qdz4EX6VjZFkG7wUA" ref="nofollow noopener noreferrer">thiserror</a>，感觉差不多了，没想爆出了Cloudflare的新闻。猜测很多，据说有一个原因是用了<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.infoq.cn%2Farticle%2FffrEqagbhIfAyitqzN7C%3Futm_source%3Dchatgpt.com" target="_blank" title="https://www.infoq.cn/article/ffrEqagbhIfAyitqzN7C?utm_source=chatgpt.com" ref="nofollow noopener noreferrer">unwrap</a>。这个前车之鉴，给了一个提醒，比如Rust还有哪些危险操作，为什么catch_unwind抓不到崩溃，能否自动化检查等。因此今天梳理下Rust代码的危险操作。</p>
<h2 data-id="heading-1">一、危险操作一览</h2>
<p>先定个标准，按照受控程度区分。受控程度是指代码不可预测，有安全漏洞，代码可控的停止等。这里先排除带有usafe关键字的，因为关键字本身就说明了问题。梳理了下，从低到高，大体分为下面三类。</p>
<h3 data-id="heading-2">1、低危险</h3>
<h4 data-id="heading-3">1.1、 乱用clone</h4>
<p>大部分情况没问题，clone本身不会产生UB，也没有panic。但是乱用可能埋下性能炸弹，而且很隐蔽。</p>
<ul>
<li>
<p>原因</p>
<ul>
<li>
<p>大对象clone：有些类型的clone是深拷贝，比如<code>let b = a.clone();</code>。如果a是<code>Vec&lt;T&gt;</code>（大量数据），<code>Arc&lt;Mutex&lt;T&gt;&gt;</code> 内含大结构，自定义 struct 里包了大对象。clone() 会 <strong>重新分配内存 + 复制一整份数据</strong>，导致内存不足，程序延迟跳变、吞吐下降，一般的cr，很难识别，明面上看不出来。</p>
</li>
<li>
<p>高并发场景频繁 clone Arc ：多线程下都要原子性地更新<strong>同一个内存地址</strong>上的计数器，则有线程不得不等待原子操作完成和同步缓存，这个时间本来应该处理业务逻辑。</p>
</li>
<li>
<p>多线程复制锁：原子操作很昂贵，尤其是锁结构clone，会增加更多内存共享冲突。</p>
</li>
</ul>
</li>
<li>
<p>乱用的例子</p>
<ul>
<li>逃避问题</li>
</ul>
<pre><code class="hljs language-rust" lang="rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">foo</span>(s: &amp;<span class="hljs-type">String</span>) {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">x</span> = s.<span class="hljs-title function_ invoke__">clone</span>(); <span class="hljs-comment">// 逃生命周期问题</span>
}
</code></pre>
<p>说明：一般没问题，但是属于逃避问题，避开rust生命周期检查</p>
<ul>
<li>
<p>循环内clone,造成性能灾难</p>
<pre><code class="hljs language-rust" lang="rust"><span class="hljs-keyword">for</span> <span class="hljs-variable">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">10000</span> {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">v2</span> = v.<span class="hljs-title function_ invoke__">clone</span>(); <span class="hljs-comment">// 大对象向量复制一万次</span>
}
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 data-id="heading-4">1.2、整数溢出（wrapping）</h4>
<p>这个一出，在Debug 模式下会 panic，但是在 <strong>Release</strong> 模式下，整数算术会<strong>环绕</strong> (wrapping) 而不报错，导致结果不正确（逻辑错误）。举个例子：</p>
<pre><code class="hljs language-rust" lang="rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">size</span> = a * b;  <span class="hljs-comment">// 溢出</span>
<span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">ptr</span> = <span class="hljs-title function_ invoke__">alloc</span>(size);  <span class="hljs-comment">// size可能是负数，0等，分配错误大小， 内存被破坏</span>
</code></pre>
<p>可以用下面方案替，（也有乘除等类似的api，可以问下ai，很容易查到）：</p>
<ul>
<li>
<p><code>checked_add</code>，溢出则返回None，安全地失败</p>
</li>
<li>
<p><code>overflowing_add</code>，会返回布尔值报告是否有溢出</p>
</li>
<li>
<p><code>saturating_add</code>：溢出的话会限制到最大或者最小值上，不会painic和环绕</p>
<pre><code class="hljs language-rust" lang="rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">safe_overflow_demo</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">max</span> = <span class="hljs-type">i32</span>::MAX;
    <span class="hljs-keyword">match</span> max.<span class="hljs-title function_ invoke__">checked_add</span>(<span class="hljs-number">1</span>) {
        <span class="hljs-title function_ invoke__">Some</span>(v) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"v={}"</span>, v),
        <span class="hljs-literal">None</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"overflow detected"</span>), <span class="hljs-comment">//overflow detected</span>
    }
}
</code></pre>
</li>
</ul>
<h3 data-id="heading-5">2、中危险</h3>
<p>运行的时候崩溃等，都是可预期的，不会破坏内存结构和编译器假设的规则。</p>
<h4 data-id="heading-6">2.1、expect()</h4>
<p>它<code>unwrap()</code> 一样会 panic，只是能自定义错误信息。用于用于快速原型和Demo，但线上不应该使用。</p>
<p>可以使用使用 <code>?</code>者显式错误处理（<code>match</code>、<code>map_err</code>）</p>
<ul>
<li>
<p>demo</p>
<pre><code class="hljs language-rust" lang="rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">expect_demo</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;(), <span class="hljs-type">String</span>&gt; {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">num</span>: <span class="hljs-type">i32</span> = <span class="hljs-string">"abc"</span>.<span class="hljs-title function_ invoke__">parse</span>().<span class="hljs-title function_ invoke__">map_err</span>(|e| e.<span class="hljs-title function_ invoke__">to_string</span>())?; <span class="hljs-comment">// 正确处理错误</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"num = {}"</span>, num);
    <span class="hljs-title function_ invoke__">Ok</span>(())
}
</code></pre>
</li>
</ul>
<h4 data-id="heading-7">2.2、 panic!()</h4>
<p>调用这个API程序立刻崩溃，生成 unwinding（除非 panic=abort）。一般调试时使用。不适合生产系统流程控制。可以用 <code>Result&lt;T, E&gt;</code> 返回错误，或者使用错误库：<code>thiserror</code>、<code>anyhow</code>，之前文章介绍过。</p>
<ul>
<li>Demo</li>
</ul>
<pre><code class="hljs language-rust" lang="rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">safe_panic_demo</span>(input: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">i32</span>&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">i32</span>, <span class="hljs-type">String</span>&gt; {
    <span class="hljs-keyword">match</span> input {
        <span class="hljs-title function_ invoke__">Some</span>(v) =&gt; <span class="hljs-title function_ invoke__">Ok</span>(v),
        <span class="hljs-literal">None</span> =&gt; <span class="hljs-title function_ invoke__">Err</span>(<span class="hljs-string">"input is None"</span>.<span class="hljs-title function_ invoke__">to_string</span>()),
    }
}
</code></pre>
<h4 data-id="heading-8">2.3、数组越界</h4>
<p>这个有两种操作： 使用 <code>[]</code> (Panic)是safe越界 ，使用 <code>get_unchecked()</code>或者<code>*v.as_ptr().add(i)</code> unsafe操作可能导致UB。据说越界访问是Rust最常见的UB来源。</p>
<ul>
<li>
<p>Demo</p>
<pre><code class="hljs language-Rust" lang="Rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">v</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt; = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>];
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">index_safe</span>: <span class="hljs-type">usize</span> = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">index_oob</span>: <span class="hljs-type">usize</span> = <span class="hljs-number">5</span>; <span class="hljs-comment">// 越界索引，有效范围是 0..3</span>

    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"--- 1. 安全访问方法 (Safe Access) ---"</span>);

    <span class="hljs-comment">// 1.1. `v.get(x)` -&gt; 返回 `Option&lt;T&gt;`，安全地处理越界</span>
    <span class="hljs-keyword">match</span> v.<span class="hljs-title function_ invoke__">get</span>(index_safe) {
        <span class="hljs-title function_ invoke__">Some</span>(val) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"v.get({}) (安全, 有效): {}"</span>, index_safe, val),
        <span class="hljs-literal">None</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"v.get({}) (安全, 越界): 返回 None"</span>, index_safe),
    }

    <span class="hljs-keyword">match</span> v.<span class="hljs-title function_ invoke__">get</span>(index_oob) {
        <span class="hljs-title function_ invoke__">Some</span>(val) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"v.get({}) (安全, 有效): {}"</span>, index_oob, val),
        <span class="hljs-literal">None</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"v.get({}) (安全, 越界): 返回 None, 程序继续"</span>, index_oob),
    }

    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"\n--- 2. 运行时检查访问方法 (Runtime Panic) ---"</span>);

    <span class="hljs-comment">// 2.1. `v[x]` -&gt; 越界时触发 `panic!`，中止程序</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"v[{}] (安全, 有效): {}"</span>, index_safe, v[index_safe]);

    <span class="hljs-comment">// 取消注释下方代码块以观察 panic! 行为</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"尝试 v[{}] (越界, panic)..."</span>, index_oob);
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">_val_panic</span> = v[index_oob]; <span class="hljs-comment">//index out of bounds: the len is 3 but the index is 5</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"此行不会被执行"</span>);
}
</code></pre>
</li>
</ul>
<h3 data-id="heading-9">3、极度危险</h3>
<p>包含 跳过检查取值，原始指针（*mut T、*const T）操作（unsafe操作就不介绍了）等</p>
<h4 data-id="heading-10">3.1、unwrap_unchecked()</h4>
<p>这个操作<strong>跳过检查</strong>，直接取值，<strong>如果是 None 会导致 UB（未定义行为）</strong>，不是普通 panic。主要在极少数高性能场景，如编译器内部、手工优化代码。</p>
<ul>
<li>
<p>替代方案</p>
<ul>
<li>
<p>不推荐使用，99.9% 情况不需要。</p>
</li>
<li>
<p>使用普通 <code>unwrap()</code> 和开发环境 panic 更安全。</p>
</li>
</ul>
</li>
<li>
<p>Demo（仅示意，不要用）</p>
</li>
</ul>
<pre><code class="hljs language-rust" lang="rust"><span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">unchecked_demo</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">x</span>: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">i32</span>&gt; = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">10</span>);
    x.<span class="hljs-title function_ invoke__">unwrap_unchecked</span>()
}
</code></pre>
<h4 data-id="heading-11">3.2、 mem::transmute</h4>
<p><code>mem::transmute</code> 被认为是极度危险（Rust unsafe 中最危险的之一）。它会 <strong>完全跳过 Rust 的类型系统</strong>，把一个值的 原始内存比特强行解释成另一种类型，而编译器不会检查是否合理。适用于底层优化、ABI 对接。可以用枚举/结构体替代表达，者用 From / TryFrom。</p>
<ul>
<li>Demo（安全替代版）</li>
</ul>
<pre><code class="hljs language-rust" lang="rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">safe_transmute_demo</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">u8</span>, <span class="hljs-type">String</span>&gt; {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">x</span>: <span class="hljs-type">i32</span> = <span class="hljs-number">150</span>;
    <span class="hljs-type">u8</span>::<span class="hljs-title function_ invoke__">try_from</span>(x).<span class="hljs-title function_ invoke__">map_err</span>(|_| <span class="hljs-string">"overflow"</span>.<span class="hljs-title function_ invoke__">to_string</span>())
}
</code></pre>
<ul>
<li>替代方案表</li>
</ul>








































<table><thead><tr><th>想做的事</th><th>不要用</th><th>应该用</th></tr></thead><tbody><tr><td>数字 → 字节数组</td><td><code>transmute</code></td><td><code>.to_ne_bytes()</code></td></tr><tr><td>&amp;T → &amp;U</td><td><code>transmute</code></td><td><code>reinterpret_cast</code> 方案：<code>ptr.cast()</code></td></tr><tr><td>类型安全转换</td><td><code>transmute</code></td><td><code>From</code> / <code>Into</code> / <code>TryFrom</code></td></tr><tr><td>C ABI struct 转换</td><td><code>transmute</code></td><td><code>#[repr(C)]</code> + 指针转换</td></tr><tr><td>Option&lt;Box&gt; 优化大小</td><td><code>transmute</code></td><td><code>Option::take</code> 或 <code>ManuallyDrop</code></td></tr><tr><td>枚举表示（discriminant）操作</td><td><code>transmute</code></td><td><code>std::mem::discriminant</code></td></tr></tbody></table>
<h2 data-id="heading-12">二、catch_unwind为什么有时候捕获不到崩溃</h2>
<p>一般使用panic::catch_unwind捕获panic，std::panic::set_hook用于记录日志和堆栈，GDB/LLDB等记录系统外的崩溃。只有catch_unwind会优雅处理错误，保持服务运行，主要说下这个。</p>
<h3 data-id="heading-13">1、panic::catch_unwind 是如何工作的？</h3>
<ul>
<li>
<p>panic 可以理解成是“强制异常 + 栈回退”，他会执行 栈展开（stack unwinding），逐层 drop 栈上的变量，若无法继续展开，则进程 abort。</p>
</li>
<li>
<p>Rust是怎么 “展开” 栈的，什么是uwind</p>
<pre><code class="hljs language-rust" lang="rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">a</span>() { <span class="hljs-title function_ invoke__">b</span>(); }
<span class="hljs-keyword">fn</span> <span class="hljs-title function_">b</span>() { <span class="hljs-title function_ invoke__">c</span>(); }
<span class="hljs-keyword">fn</span> <span class="hljs-title function_">c</span>() { <span class="hljs-built_in">panic!</span>(<span class="hljs-string">"boom"</span>); }

<span class="hljs-title function_ invoke__">a</span>();
</code></pre>
<pre><code class="hljs language-markdown" lang="markdown">┌──────────┐
│  a()     │
└───▲──────┘
<span class="hljs-code">    │ calls
┌───┴──────┐
│  b()     │
└───▲──────┘
    │ calls
┌───┴──────┐
│  c()     │   ← panic 发生
└──────────┘
</span></code></pre>
<p>unwind是这样做的:</p>
<ul>
<li>
<p>c() 退出 → drop c 中的变量</p>
</li>
<li>
<p>回到 b() → drop b 中的变量</p>
</li>
<li>
<p>回到 a() → drop a 中的变量</p>
</li>
<li>
<p>若某处有 <code>catch_unwind</code>，停止回退</p>
</li>
<li>
<p>否则退到线程根并结束线程</p>
</li>
</ul>
<p>每一步都是 <strong>栈帧被弹出（pop stack frame）</strong>，并执行对应资源释放逻辑。</p>
<p>这就是 “展开（unwind）”。</p>
</li>
<li>
<p>增加catch_unwind 后：它捕获当前线程中的 正常 panic 展开（unwind），返回 <code>Result&lt;(), Box&lt;dyn Any + Send&gt;&gt;</code></p>
</li>
</ul>
<pre><code class="hljs language-rust" lang="rust"><span class="hljs-keyword">use</span> std::panic;

<span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">result</span> = panic::<span class="hljs-title function_ invoke__">catch_unwind</span>(|| {
    <span class="hljs-built_in">panic!</span>(<span class="hljs-string">"boom"</span>);
});

<span class="hljs-built_in">assert!</span>(result.<span class="hljs-title function_ invoke__">is_err</span>());
</code></pre>
<h3 data-id="heading-14">2、捕获不到场景</h3>
<h4 data-id="heading-15">2.1、panic 被设置为 abort</h4>
<p>Cargo.toml：</p>
<pre><code class="hljs language-toml" lang="toml"><span class="hljs-section">[profile.release]</span>
<span class="hljs-attr">panic</span> = <span class="hljs-string">"abort"</span>
</code></pre>
<p>这时候代码既不 unwind，也不执行 drop，进程直接终止了，catch_unwind 根本没机会执行。</p>
<h4 data-id="heading-16">2.2、跨语言</h4>
<p>panic 发生在跨 FFI／外部库边界，尤其是与非-Rust 语言交互（例如 C 或 C++）时 → unwind → abort 行为不确定 → catch_unwind 未必捕获到。<a href="https://link.juejin.cn?target=https%3A%2F%2Fdoc.rust-lang.org%2Fstd%2Fpanic%2Ffn.catch_unwind.html" target="_blank" title="https://doc.rust-lang.org/std/panic/fn.catch_unwind.html" ref="nofollow noopener noreferrer">doc.rust-lang.org/std/panic/f…</a></p>
<h4 data-id="heading-17">2.3、unsafe 导致的 UB 可能不被 catch_unwind 捕获</h4>
<p>当在 <code>unsafe</code> 中触发 UB（例如用裸指针非法读写、悬垂引用、违反借用/别名规则、数据竞争、对齐错误等）——这在语言层面没有定义语义。这可能产生任意行为：程序挂掉、数据破损、继续运行但状态破坏、内存泄漏……这类错误<strong>不走 panic/unwind</strong> 机制 ，它们不是 “panic! unwind” 的流程。UB本身代表未定义的结果，不好确定代码流程，那么也不一定捕获到，大概率捕获不到。</p>
<h2 data-id="heading-18">三、第三方抓取工具</h2>
<h3 data-id="heading-19">1、FutureExt</h3>
<p>相比原生的，它可以直接在 async Future 上捕获 panic，支持链式打印等。</p>
<p>地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Frust-lang%2Ffutures-rs%3Futm_source%3Dchatgpt.com" target="_blank" title="https://github.com/rust-lang/futures-rs?utm_source=chatgpt.com" ref="nofollow noopener noreferrer">github.com/rust-lang/f…</a></p>
<pre><code class="hljs language-rust" lang="rust"><span class="hljs-keyword">use</span> futures::FutureExt; <span class="hljs-comment">// 0.3.5</span>

<span class="hljs-meta">#[tokio::test]</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_async</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;(), <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> std::error::Error&gt;&gt; {
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"before catch_unwind"</span>);

    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">may_panic</span> = <span class="hljs-keyword">async</span> {
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"inside async catch_unwind"</span>);
        <span class="hljs-built_in">panic!</span>(<span class="hljs-string">"this is error"</span>)
    };

    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">async_result</span> = may_panic.<span class="hljs-title function_ invoke__">catch_unwind</span>().<span class="hljs-keyword">await</span>;

    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"after catch_unwind"</span>);

    <span class="hljs-built_in">assert!</span>(async_result.<span class="hljs-title function_ invoke__">is_ok</span>());

    <span class="hljs-title function_ invoke__">Ok</span>(())
}
</code></pre>
<p>future 内部 的panic 被 <code>catch_unwind</code> 捕获 转为 <code>Result::Err</code></p>
<h3 data-id="heading-20">2、tower http的catch-panic</h3>
<p>中间件来捕获 handler 中 panic，并给客户端返回合适的 HTTP 错误响应（例如 500）</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.rs%2Ftower-http%2Flatest%2Ftower_http%2Fcatch_panic%2Findex.html" target="_blank" title="https://docs.rs/tower-http/latest/tower_http/catch_panic/index.html" ref="nofollow noopener noreferrer">docs.rs/tower-http/…</a></p>
<pre><code class="hljs language-rust" lang="rust"><span class="hljs-keyword">use</span> http::{Request, Response, header::HeaderName};
<span class="hljs-keyword">use</span> std::convert::Infallible;
<span class="hljs-keyword">use</span> tower::{Service, ServiceExt, ServiceBuilder, service_fn};
<span class="hljs-keyword">use</span> tower_http::catch_panic::CatchPanicLayer;
<span class="hljs-keyword">use</span> http_body_util::Full;
<span class="hljs-keyword">use</span> bytes::Bytes;

<span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">handle</span>(req: Request&lt;Full&lt;Bytes&gt;&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;Response&lt;Full&lt;Bytes&gt;&gt;, Infallible&gt; {
    <span class="hljs-built_in">panic!</span>(<span class="hljs-string">"something went wrong..."</span>)
}

<span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">svc</span> = ServiceBuilder::<span class="hljs-title function_ invoke__">new</span>()
    <span class="hljs-comment">// Catch panics and convert them into responses.</span>
    .<span class="hljs-title function_ invoke__">layer</span>(CatchPanicLayer::<span class="hljs-title function_ invoke__">new</span>())
    .<span class="hljs-title function_ invoke__">service_fn</span>(handle);

<span class="hljs-comment">// Call the service.</span>
<span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">request</span> = Request::<span class="hljs-title function_ invoke__">new</span>(Full::<span class="hljs-title function_ invoke__">default</span>());

<span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">response</span> = svc.<span class="hljs-title function_ invoke__">ready</span>().<span class="hljs-keyword">await</span>?.<span class="hljs-title function_ invoke__">call</span>(request).<span class="hljs-keyword">await</span>?;

<span class="hljs-built_in">assert_eq!</span>(response.<span class="hljs-title function_ invoke__">status</span>(), <span class="hljs-number">500</span>);
</code></pre>
<p>axum也可用哈：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ftokio-rs%2Faxum%2Fdiscussions%2F1865%3Futm_source%3Dchatgpt.com" target="_blank" title="https://github.com/tokio-rs/axum/discussions/1865?utm_source=chatgpt.com" ref="nofollow noopener noreferrer">github.com/tokio-rs/ax…</a></p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">tower-http</span> = { version = <span class="hljs-string">"0.5"</span>, features = [<span class="hljs-string">"catch-panic"</span>] }
</code></pre>
<p>代码：</p>
<pre><code class="hljs language-css" lang="css">  use tower_http::catch_panic::CatchPanicLayer;
  ...
   let app = Router::<span class="hljs-built_in">new</span>()
        .<span class="hljs-built_in">route</span>(<span class="hljs-string">"/"</span>, <span class="hljs-built_in">get</span>(ok_handler))
        .<span class="hljs-built_in">route</span>(<span class="hljs-string">"/panic"</span>, <span class="hljs-built_in">get</span>(panic_handler))
        // 加上 CatchPanicLayer
        .<span class="hljs-built_in">layer</span>(CatchPanicLayer::<span class="hljs-built_in">new</span>());
        ...
</code></pre>
<p>panic则返回HTTP 500 Internal Server Error，服务不会退出。</p>
<h3 data-id="heading-21">3、tokio::spawn自带的工具</h3>
<pre><code class="hljs language-rust" lang="rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">handle</span> = tokio::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">async</span> {
    <span class="hljs-built_in">panic!</span>(<span class="hljs-string">"boom!"</span>);
});

<span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">result</span> = handle.<span class="hljs-keyword">await</span>;
<span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">Err</span>(join_err) = result {
    <span class="hljs-keyword">if</span> join_err.<span class="hljs-title function_ invoke__">is_panic</span>() {
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"panic caught!"</span>);
    }
}
</code></pre>
<p>每个 Tokio 任务都是独立执行，如果任务 panic，返回 <code>JoinError</code></p>
<h2 data-id="heading-22">四、总结</h2>
<p>本文总结了Rust代码的危险操作，在提交过程中还可以增加lint，阻止unwrap等的提交或者加白名单，服务本身性能允许的话，还可以兜底抓取崩溃，能抓到90%的panic。另外，如果是后端服务，从经验看，一般还涉及灰度发布，自动回滚，熔断等等保护性操作，服务崩溃估计是各种问题累加，一个unwrap估计没那么大威力。Rust危险操作可能还有别的，欢迎留言讨论。</p>
<p>如果觉得本文有用，辛苦点个关注吧，本人公众号<em>大鱼七成饱</em></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[使用 OpenTelemetry 对 OpenResty 进行链路追踪最佳实践]]></title>    <link>https://juejin.cn/post/7578700798744133666</link>    <guid>https://juejin.cn/post/7578700798744133666</guid>    <pubDate>2025-12-01T11:21:19.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7578700798744133666" data-draft-id="7578700798744068130" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="使用 OpenTelemetry 对 OpenResty 进行链路追踪最佳实践"/> <meta itemprop="keywords" content="监控"/> <meta itemprop="datePublished" content="2025-12-01T11:21:19.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="可观测性用观测云"/> <meta itemprop="url" content="https://juejin.cn/user/2392958212523102"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            使用 OpenTelemetry 对 OpenResty 进行链路追踪最佳实践
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2392958212523102/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    可观测性用观测云
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-01T11:21:19.000Z" title="Mon Dec 01 2025 11:21:19 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-01
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">简介</h2>
<p>本文介绍如何使用 OpenTelemetry 对 OpenResty 进行链路追踪。OpenResty 是一个基于 Nginx 与 LuaJIT 的高性能 Web 平台，通过集成 Lua 脚本语言，提供了强大的动态处理能力。OpenResty 支持通过 ngx_otel_module 模块采集调用链数据，并直接上报至观测云平台。</p>
<h2 data-id="heading-1">观测云</h2>
<p>观测云采集器 DataKit 支持 OpenTelemetry 采集插件，能够接收 ngx_otel_module 模块链路数据并在平台统一分析。</p>
<h3 data-id="heading-2">部署 DataKit</h3>
<p>登录观测云控制台，点击「集成」-「DataKit」-「Linux」，复制安装命令在服务器执行即可。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/89345f3871564818902e8a4af6390340~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-v6KeC5rWL5oCn55So6KeC5rWL5LqR:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765192879&amp;x-signature=5uP9NAXFzOLtMHEit%2F0yPhSgo7M%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-3">开启 OpenTelemetry 插件</h3>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 进入采集器配置文件目录</span>
<span class="hljs-built_in">cd</span> /usr/local/datakit/conf.d/samples
<span class="hljs-comment"># 开启配置文件</span>
<span class="hljs-built_in">cp</span> opentelemetry.conf.sample opentelemetry.conf
<span class="hljs-comment"># 重启 Datakit</span>
datakit service -R
</code></pre>
<h2 data-id="heading-4">接入步骤</h2>
<h3 data-id="heading-5">构建 ngx_otel_module 模块</h3>
<ul>
<li>安装构建工具和依赖项</li>
</ul>

<pre><code class="hljs language-arduino" lang="arduino">sudo apt update

sudo apt install cmake build-essential libssl-dev zlib1g-dev libpcre3-dev

sudo apt install pkg-config libc-ares-dev libre2-dev <span class="hljs-meta"># for gRPC</span>
</code></pre>
<ul>
<li>确定 OpenResty 使用的 Nginx 版本和编译配置</li>
</ul>

<pre><code class="hljs">openresty -V
</code></pre>
<p>以下为输出示例：</p>
<pre><code class="hljs language-shell" lang="shell">openresty -V
<span class="hljs-meta prompt_">#</span><span class="bash">nginx version: openresty/1.25.3.2</span>
<span class="hljs-meta prompt_">#</span><span class="bash">built with OpenSSL 1.1.1w  11 Sep 2023</span>
<span class="hljs-meta prompt_">#</span><span class="bash">TLS SNI support enabled</span>
<span class="hljs-meta prompt_">#</span><span class="bash">configure arguments: --prefix=/usr/local/openresty/nginx --with-cc-opt=<span class="hljs-string">'-O2 -DNGX_LUA_ABORT_AT_PANIC -I/usr/local/openresty/zlib/include -I/usr/local/openresty/pcre/include -I/usr/local/openresty/openssl111/include'</span> --add-module=../ngx_devel_kit-0.3.3 --add-module=../echo-nginx-module-0.63 --add-module=../xss-nginx-module-0.06 --add-module=../ngx_coolkit-0.2 --add-module=../set-misc-nginx-module-0.33 --add-module=../form-input-nginx-module-0.12 --add-module=../encrypted-session-nginx-module-0.09 --add-module=../srcache-nginx-module-0.33 --add-module=../ngx_lua-0.10.26 --add-module=../ngx_lua_upstream-0.07 --add-module=../headers-more-nginx-module-0.37 --add-module=../array-var-nginx-module-0.06 --add-module=../memc-nginx-module-0.20 --add-module=../redis2-nginx-module-0.15 --add-module=../redis-nginx-module-0.3.9 --add-module=../ngx_stream_lua-0.0.14 --with-ld-opt=<span class="hljs-string">'-Wl,-rpath,/usr/local/openresty/luajit/lib -L/usr/local/openresty/zlib/lib -L/usr/local/openresty/pcre/lib -L/usr/local/openresty/openssl111/lib -Wl,-rpath,/usr/local/openresty/zlib/lib:/usr/local/openresty/pcre/lib:/usr/local/openresty/openssl111/lib'</span> --with-pcre-jit --with-stream --with-stream_ssl_module --with-stream_ssl_preread_module --with-http_v2_module --with-http_v3_module --without-mail_pop3_module --without-mail_imap_module --without-mail_smtp_module --with-http_stub_status_module --with-http_realip_module --with-http_addition_module --with-http_auth_request_module --with-http_secure_link_module --with-http_random_index_module --with-http_gzip_static_module --with-http_sub_module --with-http_dav_module --with-http_flv_module --with-http_mp4_module --with-http_slice_module --with-http_gunzip_module --with-threads --with-stream --without-pcre2 --with-http_ssl_module</span>
</code></pre>
<ul>
<li>下载对应版本的 Nginx 源码</li>
</ul>

<pre><code class="hljs language-bash" lang="bash">git <span class="hljs-built_in">clone</span> https://github.com/nginx/nginx.git
<span class="hljs-built_in">cd</span> nginx
git checkout {OPENRESTY_NGINX_VERSION}  <span class="hljs-comment"># 切换到对应版本Tag</span>
</code></pre>
<p><code>{OPENRESTY_NGINX_VERSION}</code> 替换为对应版本 Tag，以 1.25.3.2 版本为例，对应的版本 Tag 为 <code>release-1.25.3</code>。</p>
<ul>
<li>配置 Nginx 编译参数</li>
</ul>
<p>在 nginx 源码根目录执行以下命令</p>
<pre><code class="hljs language-scss" lang="scss">./auto/configure {NGINX_CONFIGURE_ARGUMENTS} <span class="hljs-attr">--with-compat</span> 
</code></pre>
<p><code>{NGINX_CONFIGURE_ARGUMENTS}</code> 为获取的 configure arguments 内容，并移除与 <code>--add-module</code> 相关的参数配置。</p>
<ul>
<li>下载 ngx_otel_module 模块源码</li>
</ul>

<pre><code class="hljs language-bash" lang="bash"><span class="hljs-built_in">cd</span> ..
git <span class="hljs-built_in">clone</span> https://github.com/nginxinc/nginx-otel.git
<span class="hljs-built_in">cd</span> /nginx-otel
</code></pre>
<ul>
<li>编译 ngx_otel_module 模块</li>
</ul>
<p>创建并进入 build 目录进行编译，编译完成后会在 build 目录生成 <code>ngx_otel_module.so</code> 文件。</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-built_in">mkdir</span> build
<span class="hljs-built_in">cd</span> build
cmake -DNGX_OTEL_NGINX_BUILD_DIR=/nginx/objs ..
make
</code></pre>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8992ddff6cc540d58b979318ad94fe2b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-v6KeC5rWL5oCn55So6KeC5rWL5LqR:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765192879&amp;x-signature=gBvn%2FWapzDil6IP1d9QLopHknno%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-6">启用 ngx_otel_module 模块</h3>
<ul>
<li>将 <code>ngx_otel_module.so</code> 模块文件复制到 nginx modules 目录</li>
</ul>

<pre><code class="hljs language-bash" lang="bash"><span class="hljs-built_in">mkdir</span> -p /usr/local/openresty/nginx/modules/
<span class="hljs-built_in">cp</span> ngx_otel_module.so /usr/local/openresty/nginx/modules/
</code></pre>
<ul>
<li>配置 nginx.conf</li>
</ul>
<p>为 OpenResty 启用链路追踪，您需要在 Nginx 主配置文件 <code>/usr/local/openresty/nginx/conf/nginx.conf</code> 中加载 ngx_otel_module 模块并添加配置项。注意 ngx_otel_module 模块目前仅支持 gRPC 方式上报，不支持 HTTP 方式上报。关于 ngx_otel_module 模块的更多参数配置信息，请参考 <a href="https://link.juejin.cn?target=https%3A%2F%2Fnginx.org%2Fen%2Fdocs%2Fngx_otel_module.html" target="_blank" title="https://nginx.org/en/docs/ngx_otel_module.html" ref="nofollow noopener noreferrer">nginx.org/en/docs/ngx…</a></p>
<pre><code class="hljs language-bash" lang="bash">load_module modules/ngx_otel_module.so; <span class="hljs-comment"># 加载 ngx_otel_module</span>
...
http {
    ...

    otel_exporter {
        endpoint <span class="hljs-string">"127.0.0.1:4317"</span>; <span class="hljs-comment">#  gRPC 接入点</span>
        <span class="hljs-comment">#header Authentication "${GRPC_TOKEN}"; # 前提条件中获取的鉴权 Token</span>
    }

    otel_trace on;                     <span class="hljs-comment"># 开启链路追踪</span>
    otel_service_name openresty-otel;  <span class="hljs-comment"># 应用名</span>
    otel_trace_context propagate;      <span class="hljs-comment"># 向下游服务注入Trace上下文</span>
    ...
}
</code></pre>
<ul>
<li>检查 nginx.conf 配置是否正确</li>
</ul>

<pre><code class="hljs language-bash" lang="bash">/usr/local/openresty/nginx/sbin/nginx -t
</code></pre>
<p>如下，表明配置无误</p>
<pre><code class="hljs language-vbnet" lang="vbnet"><span class="hljs-symbol">nginx:</span> the configuration file /usr/local/openresty/nginx/conf/nginx.conf syntax <span class="hljs-built_in">is</span> ok
<span class="hljs-symbol">nginx:</span> configuration file /usr/local/openresty/nginx/conf/nginx.conf test <span class="hljs-built_in">is</span> successful
</code></pre>
<ul>
<li>重载配置</li>
</ul>

<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 方式1: 使用 openresty 命令重载配置</span>
openresty -s reload

<span class="hljs-comment"># 方式2: 使用 nginx 命令重载配置</span>
/usr/local/openresty/nginx/sbin/nginx -s reload
</code></pre>
<h3 data-id="heading-7">注意事项</h3>
<p>如果执行编译，出现如图所示卡住的情况，可以通过以下方案解决：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/42b2e5d9d0834801b930864b05269887~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-v6KeC5rWL5oCn55So6KeC5rWL5LqR:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765192879&amp;x-signature=MQD3KQGV6sk3O6so5jwcKbUff3s%3D" alt="" loading="lazy"/></p>
<ul>
<li>确保使用完全相同的 nginx 版本。</li>
<li>使用<code>nginx -V</code> 查看当前 nginx 的编译参数。</li>
<li>执行 <code>openresty -V</code> 检查 <code>configure arguments</code> 参数是否正确。</li>
</ul>
<p>然后重新编译即可</p>
<h2 data-id="heading-8">查看链路</h2>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/269c8f6dcf4c414db40018bad587c876~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-v6KeC5rWL5oCn55So6KeC5rWL5LqR:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765192879&amp;x-signature=dh%2F2Ah4C9pI%2FZtrOXuXqavzqcIc%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-9">总结</h2>
<p>OpenResty（Nginx+LuaJIT 高性能 Web 平台）通过 ngx_otel_module 模块采集调用链数据，经观测云 DataKit 采集器的 OpenTelemetry 采集器接收，实现链路追踪数据在观测云平台的统一分析上报。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[【鸿蒙开发案例篇】快速掌握使用NAPI调用C标准库的功能]]></title>    <link>https://juejin.cn/post/7578667193321308223</link>    <guid>https://juejin.cn/post/7578667193321308223</guid>    <pubDate>2025-12-01T11:35:04.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7578667193321308223" data-draft-id="7578705123208462379" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="【鸿蒙开发案例篇】快速掌握使用NAPI调用C标准库的功能"/> <meta itemprop="keywords" content="HarmonyOS,ArkTS,ArkUI"/> <meta itemprop="datePublished" content="2025-12-01T11:35:04.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="威哥爱编程"/> <meta itemprop="url" content="https://juejin.cn/user/2242659450109575"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            【鸿蒙开发案例篇】快速掌握使用NAPI调用C标准库的功能
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2242659450109575/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    威哥爱编程
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-01T11:35:04.000Z" title="Mon Dec 01 2025 11:35:04 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-01
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>大家好，我是 V 哥。今天我们来深入探讨在鸿蒙 6.0（API 21）开发中，如何通过 NAPI（Native API）框架调用 C 标准库的功能。NAPI 是连接 ArkTS 应用层与 C/C++ 原生代码的关键桥梁，能够有效提升计算密集型任务的执行效率。</p>
<p>联系V哥获取 <a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.huawei.com%2Fconsumer%2Fcn%2Ftraining%2FclassDetail%2F042cb1cc4d7d44ecbdbd902fd1275dcc%3Ftype%3D1%3Fha_source%3Dhmosclass%26ha_sourceId%3D89000248" target="_blank" title="https://developer.huawei.com/consumer/cn/training/classDetail/042cb1cc4d7d44ecbdbd902fd1275dcc?type=1?ha_source=hmosclass&amp;ha_sourceId=89000248" ref="nofollow noopener noreferrer">鸿蒙学习资料</a></p>
<h3 data-id="heading-0">一、NAPI 基础与项目结构</h3>
<p><strong>技术架构</strong>：<br/>
<code>ArkTS 业务层 → NAPI 接口桥接 → C++ 原生逻辑 → C 标准库函数</code><br/>
NAPI 将 ECMAScript 标准中的数据类型（如 Number、String、Object）统一封装为 <code>napi_value</code> 类型，实现与 C/C++ 数据类型的双向转换。</p>
<p><strong>项目结构</strong>（Native C++ 模板）：</p>
<pre><code class="hljs language-bash" lang="bash">entry/src/main/
├── ets/
│   └── pages/
│       └── Index.ets          <span class="hljs-comment"># ArkTS 交互界面</span>
├── cpp/
│   ├── CMakeLists.txt         <span class="hljs-comment"># CMake 编译配置</span>
│   ├── hello.cpp             <span class="hljs-comment"># NAPI 模块实现</span>
│   └── types/
│       └── libhello/
│           ├── index.d.ts     <span class="hljs-comment"># 类型声明文件</span>
│           └── oh-package.json5
</code></pre>
<h3 data-id="heading-1">二、环境配置与依赖注入</h3>
<ol>
<li>
<p><strong>模块配置</strong>（<code>oh-package.json5</code>）<br/>
声明 NAPI 模块的依赖关系：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"dependencies"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"libhello"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"file:./src/main/cpp/types/libhello"</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
</li>
<li>
<p><strong>CMake 配置</strong>（<code>CMakeLists.txt</code>）<br/>
链接 C 标准库并指定编译目标：</p>
<pre><code class="hljs language-cmake" lang="cmake">cmake_minimum_required(VERSION 3.12)
project(hello) 
add_library(hello SHARED hello.cpp)
target_link_libraries(hello PUBLIC libc.so)  # 链接 C 标准库
</code></pre>
</li>
</ol>
<h3 data-id="heading-2">三、核心实现：从 C 标准库到 ArkTS</h3>
<h4 data-id="heading-3">步骤 1：C++ 侧实现 NAPI 接口（<code>hello.cpp</code>）</h4>
<p>通过 <code>hypot</code> 函数（C 标准库数学函数）演示平方和计算：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"napi/native_node_api.h"</span></span>

<span class="hljs-comment">// 1. 封装 C 标准库函数</span>
<span class="hljs-function"><span class="hljs-type">static</span> napi_value <span class="hljs-title">CalculateHypot</span><span class="hljs-params">(napi_env env, napi_callback_info info)</span> </span>{
    napi_value result;
    <span class="hljs-built_in">napi_get_undefined</span>(env, &amp;result);
    
    <span class="hljs-comment">// 2. 解析 ArkTS 传递的参数</span>
    <span class="hljs-type">size_t</span> argc = <span class="hljs-number">2</span>;
    napi_value args;
    <span class="hljs-built_in">napi_get_cb_info</span>(env, info, &amp;argc, args, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>);
    
    <span class="hljs-comment">// 3. 类型转换：napi_value → C double</span>
    <span class="hljs-type">double</span> a, b;
    <span class="hljs-built_in">napi_get_value_double</span>(env, args, &amp;a);
    <span class="hljs-built_in">napi_get_value_double</span>(env, args, &amp;b);
    
    <span class="hljs-comment">// 4. 调用 C 标准库函数</span>
    <span class="hljs-type">double</span> hypot_result = <span class="hljs-built_in">hypot</span>(a, b);
    
    <span class="hljs-comment">// 5. 返回结果给 ArkTS：C double → napi_value</span>
    <span class="hljs-built_in">napi_create_double</span>(env, hypot_result, &amp;result);
    <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">// 6. 模块导出声明</span>
<span class="hljs-function">EXTERN_C_START
<span class="hljs-type">static</span> napi_value <span class="hljs-title">Init</span><span class="hljs-params">(napi_env env, napi_value exports)</span> </span>{
    napi_property_descriptor desc[] = {
        {<span class="hljs-string">"calculateHypot"</span>, <span class="hljs-literal">nullptr</span>, CalculateHypot, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>, napi_default, <span class="hljs-literal">nullptr</span>}
    };
    <span class="hljs-built_in">napi_define_properties</span>(env, exports, <span class="hljs-built_in">sizeof</span>(desc) / <span class="hljs-built_in">sizeof</span>(desc), desc);
    <span class="hljs-keyword">return</span> exports;
}
EXTERN_C_END
</code></pre>
<h4 data-id="heading-4">步骤 2：类型声明文件（<code>index.d.ts</code>）</h4>
<p>为 ArkTS 提供类型提示：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-attr">calculateHypot</span>: <span class="hljs-function">(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">number</span>;
</code></pre>
<h4 data-id="heading-5">步骤 3：ArkTS 调用层（<code>Index.ets</code>）</h4>
<p>在 UI 中集成原生计算能力：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">import</span> { calculateHypot } <span class="hljs-keyword">from</span> <span class="hljs-string">'libhello'</span>;

<span class="hljs-meta">@Entry</span>
<span class="hljs-meta">@Component</span>
struct <span class="hljs-title class_">NAPIDemo</span> {
  <span class="hljs-meta">@State</span> <span class="hljs-attr">inputA</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">3.0</span>;
  <span class="hljs-meta">@State</span> <span class="hljs-attr">inputB</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">4.0</span>;
  <span class="hljs-meta">@State</span> <span class="hljs-attr">result</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>;

  <span class="hljs-title function_">build</span>(<span class="hljs-params"/>) {
    <span class="hljs-title class_">Column</span>() {
      <span class="hljs-title class_">TextInput</span>({ <span class="hljs-attr">placeholder</span>: <span class="hljs-string">'输入数值 A'</span> })
        .<span class="hljs-title function_">onChange</span>(<span class="hljs-function">(<span class="hljs-params">value: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputA</span> = <span class="hljs-built_in">parseFloat</span>(value))
      <span class="hljs-title class_">TextInput</span>({ <span class="hljs-attr">placeholder</span>: <span class="hljs-string">'输入数值 B'</span> })
        .<span class="hljs-title function_">onChange</span>(<span class="hljs-function">(<span class="hljs-params">value: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputB</span> = <span class="hljs-built_in">parseFloat</span>(value))
      
      <span class="hljs-title class_">Button</span>(<span class="hljs-string">'计算平方根'</span>)
        .<span class="hljs-title function_">onClick</span>(<span class="hljs-function">() =&gt;</span> {
          <span class="hljs-comment">// 调用 NAPI 封装的 C 标准库函数</span>
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = <span class="hljs-title function_">calculateHypot</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">inputA</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputB</span>);
        })
      
      <span class="hljs-title class_">Text</span>(<span class="hljs-string">`结果: <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.result}</span>`</span>)
        .<span class="hljs-title function_">fontSize</span>(<span class="hljs-number">20</span>)
    }
  }
}
</code></pre>
<h3 data-id="heading-6">四、关键技术与异常处理</h3>
<ol>
<li>
<p><strong>数据类型转换对照表</strong></p>






























<table><thead><tr><th>C/C++ 类型</th><th>NAPI 转换接口</th><th>ArkTS 类型</th></tr></thead><tbody><tr><td><code>double</code></td><td><code>napi_create_double()</code></td><td><code>number</code></td></tr><tr><td><code>int32_t</code></td><td><code>napi_create_int32()</code></td><td><code>number</code></td></tr><tr><td><code>char*</code></td><td><code>napi_create_string_utf8()</code></td><td><code>string</code></td></tr><tr><td><code>bool</code></td><td><code>napi_get_boolean()</code></td><td><code>boolean</code></td></tr></tbody></table>
</li>
<li>
<p><strong>错误处理机制</strong><br/>
在 C++ 侧添加 NAPI 状态检查：</p>
<pre><code class="hljs language-cpp" lang="cpp">napi_status status = <span class="hljs-built_in">napi_get_value_double</span>(env, args, &amp;a);
<span class="hljs-keyword">if</span> (status != napi_ok) {
    <span class="hljs-built_in">napi_throw_error</span>(env, <span class="hljs-literal">nullptr</span>, <span class="hljs-string">"参数解析失败"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;
}
</code></pre>
</li>
</ol>
<h3 data-id="heading-7">五、扩展场景：异步调用与回调函数</h3>
<p>对于耗时操作（如图像处理），可通过 NAPI 实现异步调用：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// 在 C++ 侧创建异步工作线程</span>
<span class="hljs-built_in">napi_create_async_work</span>(
    env, <span class="hljs-literal">nullptr</span>, resource_name,
    [](napi_env env, <span class="hljs-type">void</span>* data) {
        <span class="hljs-comment">// 子线程中执行 C 标准库函数</span>
    },
    [](napi_env env, napi_status status, <span class="hljs-type">void</span>* data) {
        <span class="hljs-comment">// 回调 ArkTS 传递的 Promise 对象</span>
        <span class="hljs-built_in">napi_resolve_deferred</span>(env, deferred, result);
    },
    data, &amp;async_work
);
</code></pre>
<h3 data-id="heading-8">六、调试与性能优化建议</h3>
<ol>
<li>
<p><strong>日志输出</strong><br/>
使用 <code>hilog</code> 在 C++ 侧打印调试信息：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;hilog/log.h&gt;</span></span>
<span class="hljs-built_in">OH_LOG_Print</span>(LOG_APP, LOG_INFO, <span class="hljs-number">0</span>, <span class="hljs-string">"NAPI"</span>, <span class="hljs-string">"计算结果: %f"</span>, hypot_result);
</code></pre>
</li>
<li>
<p><strong>内存管理</strong></p>
<ul>
<li>避免在循环中频繁创建 <code>napi_value</code> 对象</li>
<li>使用 <code>napi_create_reference()</code> 管理长期持有的对象</li>
</ul>
</li>
</ol>
<h3 data-id="heading-9">总结</h3>
<p>通过 NAPI 调用 C 标准库的核心步骤包括：</p>
<ol>
<li><strong>环境配置</strong>：声明模块依赖与 CMake 编译规则</li>
<li><strong>桥接实现</strong>：在 C++ 中封装原生函数并处理类型转换</li>
<li><strong>类型声明</strong>：提供 ArkTS 可识别的接口定义</li>
<li><strong>异常处理</strong>：添加状态检查与错误抛出机制</li>
</ol>
<p>我是 V 哥，下期将解析如何通过 NAPI 实现 ArkTS 与 C++ 间的复杂对象传递（如结构体与回调函数）。关注我的专栏，解锁更多鸿蒙底层开发技巧！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Vue3 + Element Plus 动态菜单实现：一套代码完美适配多角色权限系统]]></title>    <link>https://juejin.cn/post/7578724773993054234</link>    <guid>https://juejin.cn/post/7578724773993054234</guid>    <pubDate>2025-12-01T11:50:04.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7578724773993054234" data-draft-id="7571156741398085647" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Vue3 + Element Plus 动态菜单实现：一套代码完美适配多角色权限系统"/> <meta itemprop="keywords" content="前端,Vue.js"/> <meta itemprop="datePublished" content="2025-12-01T11:50:04.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="刘大华"/> <meta itemprop="url" content="https://juejin.cn/user/3507878440995946"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Vue3 + Element Plus 动态菜单实现：一套代码完美适配多角色权限系统
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3507878440995946/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    刘大华
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-01T11:50:04.000Z" title="Mon Dec 01 2025 11:50:04 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-01
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>今天分享一个基于<code>Vue3</code>和<code>Element Plus</code>的动态菜单实现。这个方案很适用于需要权限管理的后台系统，能够根据用户角色权限显示不同的菜单项。</p>
<h2 data-id="heading-0">一、什么是动态菜单？为什么需要它？</h2>
<p>在管理后台系统中，不同角色的用户通常需要不同的功能权限。比如：</p>
<ul>
<li><strong>管理员</strong>可以访问所有功能</li>
<li><strong>编辑者</strong>只能管理内容</li>
<li><strong>查看者</strong>只能浏览数据</li>
</ul>
<p>如果为每个角色单独开发一套界面，显然效率低下。动态菜单就是解决这个问题的方案——<strong>一套代码，根据不同用户角色显示不同的菜单结构</strong>。</p>
<h2 data-id="heading-1">二、实现效果预览</h2>
<p>我们先来看看最终实现的效果：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9e65b9effe094807867ef7545805b986~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YiY5aSn5Y2O:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765194604&amp;x-signature=LmKZo9onERrMXzvgEpUnpE%2BrGNg%3D" alt="1动态菜单3.png" loading="lazy"/></p>
<ol>
<li><strong>角色切换</strong>：右上角可以切换用户角色（管理员/编辑者/查看者）</li>
<li><strong>菜单过滤</strong>：根据角色自动过滤无权限的菜单项</li>
<li><strong>侧边栏折叠</strong>：支持展开/收起侧边栏</li>
<li><strong>面包屑导航</strong>：显示当前页面位置</li>
</ol>
<p>老样子，完整源码在文末获取哦~</p>
<h2 data-id="heading-2">三、核心实现原理</h2>
<h3 data-id="heading-3">1. 菜单数据结构设计</h3>
<p>合理的菜单数据结构是动态菜单的基础。我们的设计如下：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> menuData = <span class="hljs-title function_">ref</span>([
  {
    <span class="hljs-attr">id</span>: <span class="hljs-string">'dashboard'</span>,        <span class="hljs-comment">// 唯一标识</span>
    <span class="hljs-attr">name</span>: <span class="hljs-string">'仪表板'</span>,         <span class="hljs-comment">// 显示名称</span>
    <span class="hljs-attr">icon</span>: <span class="hljs-string">'DataBoard'</span>,      <span class="hljs-comment">// 图标</span>
    <span class="hljs-attr">route</span>: <span class="hljs-string">'/dashboard'</span>,    <span class="hljs-comment">// 路由路径</span>
    <span class="hljs-attr">roles</span>: [<span class="hljs-string">'admin'</span>, <span class="hljs-string">'editor'</span>, <span class="hljs-string">'viewer'</span>]  <span class="hljs-comment">// 可访问的角色</span>
  },
  {
    <span class="hljs-attr">id</span>: <span class="hljs-string">'content'</span>,
    <span class="hljs-attr">name</span>: <span class="hljs-string">'内容管理'</span>,
    <span class="hljs-attr">icon</span>: <span class="hljs-string">'Document'</span>,
    <span class="hljs-attr">roles</span>: [<span class="hljs-string">'admin'</span>, <span class="hljs-string">'editor'</span>],
    <span class="hljs-attr">children</span>: [             <span class="hljs-comment">// 子菜单</span>
      {
        <span class="hljs-attr">id</span>: <span class="hljs-string">'articles'</span>,
        <span class="hljs-attr">name</span>: <span class="hljs-string">'文章管理'</span>,
        <span class="hljs-attr">route</span>: <span class="hljs-string">'/articles'</span>,
        <span class="hljs-attr">roles</span>: [<span class="hljs-string">'admin'</span>, <span class="hljs-string">'editor'</span>]
      }
      <span class="hljs-comment">// ... 更多子菜单</span>
    ]
  }
  <span class="hljs-comment">// ... 更多菜单项</span>
]);
</code></pre>
<p>这种结构的特点：</p>
<ul>
<li><strong>支持多级嵌套菜单</strong></li>
<li><strong>每个菜单项明确指定可访问的角色</strong></li>
<li><strong>图标使用 Element Plus 的图标组件</strong></li>
</ul>
<h3 data-id="heading-4">2. 菜单过滤逻辑</h3>
<p>核心功能是根据当前用户角色过滤菜单：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> filteredMenu = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">return</span> menuData.<span class="hljs-property">value</span>
    .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> {
      <span class="hljs-comment">// 1. 检查主菜单权限</span>
      <span class="hljs-keyword">if</span> (!item.<span class="hljs-property">roles</span>.<span class="hljs-title function_">includes</span>(currentUser.<span class="hljs-property">value</span>.<span class="hljs-property">role</span>)) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <span class="hljs-comment">// 无权限，过滤掉</span>
      }
      
      <span class="hljs-comment">// 2. 深拷贝菜单项（避免修改原始数据）</span>
      <span class="hljs-keyword">const</span> menuItem = { ...item };
      
      <span class="hljs-comment">// 3. 如果有子菜单，过滤子菜单</span>
      <span class="hljs-keyword">if</span> (menuItem.<span class="hljs-property">children</span>) {
        menuItem.<span class="hljs-property">children</span> = menuItem.<span class="hljs-property">children</span>.<span class="hljs-title function_">filter</span>(
          <span class="hljs-function"><span class="hljs-params">child</span> =&gt;</span> child.<span class="hljs-property">roles</span>.<span class="hljs-title function_">includes</span>(currentUser.<span class="hljs-property">value</span>.<span class="hljs-property">role</span>)
        );
        
        <span class="hljs-comment">// 如果子菜单全被过滤掉，主菜单也不显示</span>
        <span class="hljs-keyword">if</span> (menuItem.<span class="hljs-property">children</span>.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }
      }
      
      <span class="hljs-keyword">return</span> menuItem;
    })
    .<span class="hljs-title function_">filter</span>(<span class="hljs-title class_">Boolean</span>);  <span class="hljs-comment">// 过滤掉null值</span>
});
</code></pre>
<p><strong>过滤过程详解</strong>：</p>
<ol>
<li><strong>映射(map)</strong>：遍历每个菜单项，返回处理后的菜单项或null</li>
<li><strong>权限检查</strong>：检查当前用户角色是否在菜单项的角色列表中</li>
<li><strong>子菜单过滤</strong>：对有子菜单的项，递归过滤无权限的子项</li>
<li><strong>空子菜单处理</strong>：如果所有子项都被过滤，父项也不显示</li>
<li><strong>最终过滤</strong>：用filter(Boolean)移除所有null值</li>
</ol>
<p><strong>计算属性(computed)的优势</strong>：</p>
<ul>
<li>自动响应依赖变化（当用户角色变化时自动重新计算）</li>
<li>缓存结果，避免重复计算</li>
</ul>
<h3 data-id="heading-5">3. 用户角色管理</h3>
<p>用户信息和角色切换的实现：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 当前用户信息</span>
<span class="hljs-keyword">const</span> currentUser = <span class="hljs-title function_">ref</span>({
  <span class="hljs-attr">name</span>: <span class="hljs-string">'管理员'</span>,
  <span class="hljs-attr">role</span>: <span class="hljs-string">'admin'</span>,
  <span class="hljs-attr">avatar</span>: <span class="hljs-string">'https://example.com/avatar.png'</span>
});

<span class="hljs-comment">// 处理角色切换</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">handleRoleChange</span> = (<span class="hljs-params">role</span>) =&gt; {
  currentUser.<span class="hljs-property">value</span>.<span class="hljs-property">role</span> = role;
  
  <span class="hljs-comment">// 角色切换后更新当前激活的菜单</span>
  <span class="hljs-keyword">if</span> (role === <span class="hljs-string">'viewer'</span>) {
    <span class="hljs-comment">// 查看者只能访问仪表板</span>
    activeMenu.<span class="hljs-property">value</span> = <span class="hljs-string">'/dashboard'</span>;
    currentPageTitle.<span class="hljs-property">value</span> = <span class="hljs-string">'仪表板'</span>;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// 其他角色显示第一个可访问的菜单</span>
    <span class="hljs-keyword">const</span> firstMenu = <span class="hljs-title function_">findFirstAccessibleMenu</span>();
    <span class="hljs-keyword">if</span> (firstMenu) {
      activeMenu.<span class="hljs-property">value</span> = firstMenu.<span class="hljs-property">route</span>;
      currentPageTitle.<span class="hljs-property">value</span> = firstMenu.<span class="hljs-property">name</span>;
    }
  }
};
</code></pre>
<h2 data-id="heading-6">四、界面布局与组件使用</h2>
<h3 data-id="heading-7">1. 整体布局结构</h3>
<pre><code class="hljs language-html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"app-container"</span>&gt;</span>
  <span class="hljs-comment">&lt;!-- 侧边栏 --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"sidebar"</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">"{ collapsed: isCollapse }"</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- Logo区域 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"logo-area"</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- 菜单区域 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">el-menu</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">el-menu</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  
  <span class="hljs-comment">&lt;!-- 主内容区 --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"main-content"</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- 顶部导航 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"header"</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- 页面内容 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"content"</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- 页脚 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"footer"</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<p>这种布局是管理后台的经典设计，具有清晰的视觉层次。</p>
<h3 data-id="heading-8">2. Element Plus 菜单组件使用</h3>
<pre><code class="hljs language-html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">el-menu</span>
  <span class="hljs-attr">:default-active</span>=<span class="hljs-string">"activeMenu"</span>           &lt;!<span class="hljs-attr">--</span> <span class="hljs-attr">当前激活的菜单</span> <span class="hljs-attr">--</span>&gt;</span>
  class="el-menu-vertical"
  background-color="#001529"            <span class="hljs-comment">&lt;!-- 背景色 --&gt;</span>
  text-color="#bfcbd9"                  <span class="hljs-comment">&lt;!-- 文字颜色 --&gt;</span>
  active-text-color="#409EFF"           <span class="hljs-comment">&lt;!-- 激活项文字颜色 --&gt;</span>
  :collapse="isCollapse"                <span class="hljs-comment">&lt;!-- 是否折叠 --&gt;</span>
  :collapse-transition="false"          <span class="hljs-comment">&lt;!-- 关闭折叠动画 --&gt;</span>
  :unique-opened="true"                 <span class="hljs-comment">&lt;!-- 只保持一个子菜单展开 --&gt;</span>
&gt;
  <span class="hljs-comment">&lt;!-- 菜单项渲染 --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"item in filteredMenu"</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">"item.id"</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- 有子菜单的情况 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">el-sub-menu</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"item.children"</span> <span class="hljs-attr">:index</span>=<span class="hljs-string">"item.id"</span>&gt;</span>
      <span class="hljs-comment">&lt;!-- 标题区域 --&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">title</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">el-icon</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">"item.icon"</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">el-icon</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>{{ item.name }}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
      
      <span class="hljs-comment">&lt;!-- 子菜单项 --&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">el-menu-item</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"child in item.children"</span> 
                   <span class="hljs-attr">:key</span>=<span class="hljs-string">"child.id"</span> 
                   <span class="hljs-attr">:index</span>=<span class="hljs-string">"child.route"</span>
                   @<span class="hljs-attr">click</span>=<span class="hljs-string">"selectMenu(child)"</span>&gt;</span>
        {{ child.name }}
      <span class="hljs-tag">&lt;/<span class="hljs-name">el-menu-item</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">el-sub-menu</span>&gt;</span>
    
    <span class="hljs-comment">&lt;!-- 没有子菜单的情况 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">el-menu-item</span> <span class="hljs-attr">v-else</span> <span class="hljs-attr">:index</span>=<span class="hljs-string">"item.route"</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"selectMenu(item)"</span>&gt;</span>
      ...
    <span class="hljs-tag">&lt;/<span class="hljs-name">el-menu-item</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">el-menu</span>&gt;</span>
</code></pre>
<p><strong>关键点说明</strong>：</p>
<ol>
<li><strong>动态组件</strong>：<code>&lt;component :is="item.icon"&gt;</code> 实现动态图标渲染</li>
<li><strong>条件渲染</strong>：使用 <code>v-if</code> 和 <code>v-else</code> 区分子菜单和单菜单项</li>
<li><strong>循环渲染</strong>：<code>v-for</code> 遍历过滤后的菜单数据</li>
<li><strong>唯一key</strong>：为每个菜单项设置唯一的 <code>:key="item.id"</code> 提高性能</li>
</ol>
<h2 data-id="heading-9">五、样式设计技巧</h2>
<h3 data-id="heading-10">1. 侧边栏折叠动画</h3>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-class">.sidebar</span> {
  <span class="hljs-attribute">width</span>: <span class="hljs-number">240px</span>;
  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#001529</span>;
  <span class="hljs-attribute">transition</span>: width <span class="hljs-number">0.3s</span>;  <span class="hljs-comment">/* 宽度变化动画 */</span>
  <span class="hljs-attribute">overflow</span>: hidden;
}

<span class="hljs-selector-class">.sidebar</span><span class="hljs-selector-class">.collapsed</span> {
  <span class="hljs-attribute">width</span>: <span class="hljs-number">64px</span>;
}

<span class="hljs-selector-class">.logo-area</span> <span class="hljs-selector-class">.logo-text</span> {
  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">10px</span>;
  <span class="hljs-attribute">transition</span>: opacity <span class="hljs-number">0.3s</span>;  <span class="hljs-comment">/* 文字淡入淡出 */</span>
}

<span class="hljs-selector-class">.sidebar</span><span class="hljs-selector-class">.collapsed</span> <span class="hljs-selector-class">.logo-text</span> {
  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;  <span class="hljs-comment">/* 折叠时隐藏文字 */</span>
}
</code></pre>
<h3 data-id="heading-11">2. 布局技巧</h3>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-class">.app-container</span> {
  <span class="hljs-attribute">display</span>: flex;
  <span class="hljs-attribute">min-height</span>: <span class="hljs-number">100vh</span>;  <span class="hljs-comment">/* 全屏高度 */</span>
}

<span class="hljs-selector-class">.main-content</span> {
  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;            <span class="hljs-comment">/* 占据剩余空间 */</span>
  <span class="hljs-attribute">display</span>: flex;
  <span class="hljs-attribute">flex-direction</span>: column;
  <span class="hljs-attribute">overflow</span>: hidden;   <span class="hljs-comment">/* 防止内容溢出 */</span>
}

<span class="hljs-selector-class">.content</span> {
  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;            <span class="hljs-comment">/* 内容区占据主要空间 */</span>
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;
  <span class="hljs-attribute">overflow-y</span>: auto;   <span class="hljs-comment">/* 内容过多时滚动 */</span>
}
</code></pre>
<p>使用 Flex 布局可以轻松实现经典的侧边栏+主内容区布局。</p>
<h2 data-id="heading-12">六、实际应用扩展建议</h2>
<p>在实际项目中，你还可以进一步扩展这个基础实现：</p>
<h3 data-id="heading-13">1. 与路由集成</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> { useRouter, useRoute } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue-router'</span>;

<span class="hljs-keyword">const</span> router = <span class="hljs-title function_">useRouter</span>();
<span class="hljs-keyword">const</span> route = <span class="hljs-title function_">useRoute</span>();

<span class="hljs-comment">// 菜单点击处理</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">selectMenu</span> = (<span class="hljs-params">item</span>) =&gt; {
  <span class="hljs-comment">// 路由跳转</span>
  router.<span class="hljs-title function_">push</span>(item.<span class="hljs-property">route</span>);
};

<span class="hljs-comment">// 根据当前路由设置激活菜单</span>
<span class="hljs-title function_">watch</span>(route, <span class="hljs-function">(<span class="hljs-params">newRoute</span>) =&gt;</span> {
  activeMenu.<span class="hljs-property">value</span> = newRoute.<span class="hljs-property">path</span>;
  <span class="hljs-comment">// 根据路由查找对应的页面标题</span>
  currentPageTitle.<span class="hljs-property">value</span> = <span class="hljs-title function_">findTitleByRoute</span>(newRoute.<span class="hljs-property">path</span>);
});
</code></pre>
<h3 data-id="heading-14">2. 后端动态菜单</h3>
<p>在实际项目中，菜单数据通常来自后端：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 从API获取菜单数据</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchMenuData</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">'/api/menus'</span>, {
      <span class="hljs-attr">params</span>: { <span class="hljs-attr">role</span>: currentUser.<span class="hljs-property">value</span>.<span class="hljs-property">role</span> }
    });
    menuData.<span class="hljs-property">value</span> = response.<span class="hljs-property">data</span>;
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'获取菜单数据失败:'</span>, error);
  }
};
</code></pre>
<h3 data-id="heading-15">3. 权限控制增强</h3>
<p>除了菜单过滤，还可以添加更细粒度的权限控制：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 权限指令</span>
app.<span class="hljs-title function_">directive</span>(<span class="hljs-string">'permission'</span>, {
  <span class="hljs-title function_">mounted</span>(<span class="hljs-params">el, binding</span>) {
    <span class="hljs-keyword">const</span> { <span class="hljs-attr">value</span>: requiredRoles } = binding;
    <span class="hljs-keyword">const</span> userRole = currentUser.<span class="hljs-property">value</span>.<span class="hljs-property">role</span>;
    
    <span class="hljs-keyword">if</span> (!requiredRoles.<span class="hljs-title function_">includes</span>(userRole)) {
      el.<span class="hljs-property">parentNode</span> &amp;&amp; el.<span class="hljs-property">parentNode</span>.<span class="hljs-title function_">removeChild</span>(el);
    }
  }
});

<span class="hljs-comment">// 在模板中使用</span>
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-permission</span>=<span class="hljs-string">"['admin', 'editor']"</span>&gt;</span>编辑内容<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
</code></pre>
<h2 data-id="heading-16">总结</h2>
<p>通过这个 Vue 3 + Element Plus 的动态菜单实现，我们学到了：</p>
<ol>
<li><strong>设计合理的菜单数据结构</strong>是动态菜单的基础</li>
<li><strong>使用计算属性实现菜单过滤</strong>，自动响应角色变化</li>
<li><strong>利用 Element Plus 组件</strong>快速构建美观的界面</li>
<li><strong>Flex 布局技巧</strong>实现响应式侧边栏</li>
<li><strong>扩展思路</strong>，如路由集成、后端动态菜单等</li>
</ol>
<p>这个实现方案具有很好的可扩展性，你可以根据实际需求进行调整和增强。</p>
<p><strong>完整源码GitHub地址</strong>：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2F1344160559-lch%2Fdh-vue3-component%2Fblob%2Fmain%2FDynamicMenu%2Findex.html" target="_blank" title="https://github.com/1344160559-lch/dh-vue3-component/blob/main/DynamicMenu/index.html" ref="nofollow noopener noreferrer">github.com/1344160559-…</a></p>
<p>你可以直接复制到HTML文件中运行体验。尝试切换不同的用户角色，观察菜单的变化，加深对动态菜单工作原理的理解。</p>
<blockquote>
<p>本文首发于公众号：程序员刘大华，专注分享前后端开发的实战笔记。关注我，少走弯路，一起进步！</p>
</blockquote>
<h4 data-id="heading-17">📌往期精彩</h4>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2Fmaq_p_m5vd7KS-xyXt5rcA" target="_blank" title="https://mp.weixin.qq.com/s/maq_p_m5vd7KS-xyXt5rcA" ref="nofollow noopener noreferrer">《SpringBoot+MySQL+Vue实现文件共享系统》</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FP7SMincYFKERZbNKAFtzGQ" target="_blank" title="https://mp.weixin.qq.com/s/P7SMincYFKERZbNKAFtzGQ" ref="nofollow noopener noreferrer">《这20条SQL优化方案，让你的数据库查询速度提升10倍》</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FgQK9L1TxKL50FUVMcgh6JQ" target="_blank" title="https://mp.weixin.qq.com/s/gQK9L1TxKL50FUVMcgh6JQ" ref="nofollow noopener noreferrer">《SpringBoot 动态菜单权限系统设计的企业级解决方案》</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FPQ_w7CDVoIZPn-CVH2DKJg" target="_blank" title="https://mp.weixin.qq.com/s/PQ_w7CDVoIZPn-CVH2DKJg" ref="nofollow noopener noreferrer">《Vue3和Vue2的核心区别？很多开发者都没完全搞懂的10个细节》</a></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[首字母模糊匹配]]></title>    <link>https://juejin.cn/post/7578511778889498662</link>    <guid>https://juejin.cn/post/7578511778889498662</guid>    <pubDate>2025-12-01T09:13:29.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7578511778889498662" data-draft-id="7578495241638281257" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="首字母模糊匹配"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2025-12-01T09:13:29.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="月亮慢慢圆"/> <meta itemprop="url" content="https://juejin.cn/user/2496335488221770"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            首字母模糊匹配
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2496335488221770/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    月亮慢慢圆
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-01T09:13:29.000Z" title="Mon Dec 01 2025 09:13:29 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-01
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    5
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body cache result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:14px;overflow-x:hidden;color:var(--cyanosis-base-color);transition:color .35s;--cyanosis-base-color:#353535;--cyanosis-title-color:#005bb7;--cyanosis-strong-color:#2196f3;--cyanosis-em-color:#4fc3f7;--cyanosis-del-color:#ccc;--cyanosis-link-color:#3da8f5;--cyanosis-linkh-color:#007fff;--cyanosis-border-color:#bedcff;--cyanosis-border-color-2:#ececec;--cyanosis-bg-color:#fff;--cyanosis-blockquote-color:#8c8c8c;--cyanosis-blockquote-bg-color:#f0fdff;--cyanosis-code-color:#c2185b;--cyanosis-code-bg-color:#fff4f4;--cyanosis-code-pre-color:#f8f8f8;--cyanosis-table-border-color:#c3e0fd;--cyanosis-table-th-color:#dff0ff;--cyanosis-table-tht-color:#005bb7;--cyanosis-table-tr-nc-color:#f7fbff;--cyanosis-table-trh-color:#e0edf7;--cyanosis-slct-title-color:#005bb7;--cyanosis-slct-titlebg-color:rgba(175,207,247,0.25);--cyanosis-slct-text-color:#c80000;--cyanosis-slct-bg-color:rgba(175,207,247,0.25);--cyanosis-slct-del-color:#999;--cyanosis-slct-elbg-color:#e8ebec;--cyanosis-slct-codebg-color:#ffeaeb;--cyanosis-slct-prebg-color:rgba(160,200,255,0.25)}.markdown-body.__dark{--cyanosis-base-color:#cacaca;--cyanosis-title-color:#ddd;--cyanosis-strong-color:#fe9900;--cyanosis-em-color:#ffd28e;--cyanosis-del-color:#ccc;--cyanosis-link-color:#ffb648;--cyanosis-linkh-color:#fe9900;--cyanosis-border-color:#ffe3ba;--cyanosis-border-color-2:#ffcb7b;--cyanosis-bg-color:#2f2f2f;--cyanosis-blockquote-color:#c7c7c7;--cyanosis-blockquote-bg-color:rgba(255,199,116,0.1);--cyanosis-code-color:#000;--cyanosis-code-bg-color:#ffcb7b;--cyanosis-code-pre-color:rgba(255,227,185,0.5);--cyanosis-table-border-color:#fe9900;--cyanosis-table-th-color:#ffb648;--cyanosis-table-tht-color:#000;--cyanosis-table-tr-nc-color:#6d5736;--cyanosis-table-trh-color:#947443;--cyanosis-slct-title-color:#000;--cyanosis-slct-titlebg-color:#fe9900;--cyanosis-slct-text-color:#00c888;--cyanosis-slct-bg-color:rgba(175,207,247,0.25);--cyanosis-slct-del-color:#999;--cyanosis-slct-elbg-color:#000;--cyanosis-slct-codebg-color:#ffcb7b;--cyanosis-slct-prebg-color:rgba(160,200,255,0.25)}.markdown-body h1{padding-bottom:4px;font-size:30px}.markdown-body h1,.markdown-body h2{margin-top:36px;margin-bottom:10px;line-height:1.5;color:var(--cyanosis-title-color);transition:color .35s}.markdown-body h2{position:relative;padding-left:10px;padding-right:10px;padding-bottom:10px;font-size:24px;border-bottom:1px solid var(--cyanosis-border-color-2)}.markdown-body h2:before{content:"「";position:absolute;top:-6px;left:-14px}.markdown-body h2:after{content:"」";position:relative;top:6px;right:auto}.markdown-body h3{position:relative;padding-bottom:0;margin-top:30px;margin-bottom:10px;font-size:20px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body h3:before{content:"»";padding-right:6px;color:var(--cyanosis-strong-color)}.markdown-body h4{margin-top:24px;font-size:16px}.markdown-body h4,.markdown-body h5{padding-bottom:0;margin-bottom:10px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body h5{margin-top:18px;font-size:14px}.markdown-body h6{padding-bottom:0;margin-top:12px;margin-bottom:10px;font-size:12px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body p{line-height:inherit;margin-top:16px;margin-bottom:16px}.markdown-body img{max-width:100%}.markdown-body hr{position:relative;width:98%;height:1px;margin-top:32px;margin-bottom:32px;background-image:linear-gradient(90deg,var(--cyanosis-link-color),rgba(255,0,0,.3),hsla(0,0%,100%,.1),rgba(255,0,0,.3),var(--cyanosis-link-color));border-width:0;overflow:visible}.markdown-body hr:after{content:"";position:absolute;margin:auto;left:0;right:0;bottom:0;top:0;display:inline-block;width:60px;height:20px;background-color:var(--cyanosis-bg-color);background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAgCAYAAABgrToAAAADoklEQVRYR82XTYgcRRTHf2933Q1RjAa9eFO8JHoJ8RQVBQ2iBwXBET0YEUTXNVmNQtTpmeqaWV0XNRq/o4KoECSCEPSg4CF+BYUkIIiCoCJCPIhC/Ihh2Z0nVV27VnZnenumW9i6ddV7//frV69fVQurfMgq56NawFTPAU6QyomqXrw6wIZeyhCPebA5buNR+akKyGoAjd6BshthnYdSjqNcRVuOlIUsD2j0SuA94IwuMHdh5ZUykOUBXfSGbmKI54EtAeYIHSZoy5dl4JxvNYBOKdW1KE8BQ8AkVk6WhasWsAiN0TX9gveXQaPP+Aytpc4u+bMI06JNohsYYYYOR2lJWtS3OKDRfcAtQfgDoI6Vo4UCGb0OmAEuDvZvYmVbEd/igC3dzDz7gQu8sPA9kJDK27mBmjqBeLjTg90PDFOjWawFFQd06kZHEfaj3LAIpTRpSXsZ5E06zEYP9sDimnAApYaV2SLZG/wjMeqAkijwW4xQJ5Gf/ZzRC8OW3hiBTGGlURRswW55Bh/Ssxljrwew8l1PQaM14GngvGDzBUKdDsMeTtgU5o8B92PFlUf3YXUrHa7Fys6lBqcCGnX15YQ2A18FyPd7Crd1A3M8C1wdbH4DD3hWeP6IEXbQkG97ajR1HPFnuPP5jFFq1OWX7hl8WM9l1AO648uNfwLk7tytMeogty+xeQ4rO3r6bdcx1nuwOGsHmaXGtPzae4uzGnLH1kQkvpdZGrHjssBZJrL+pqS05KWc8tgITAPXRzYvYOXe/C2OV43eDcRBDtIhoS2f9wzc0Cv8Wls+zoFzUC5zF0U241h5uZtPfptp6OUM8wbK+cH5GEpCS17P3fJei0Z3+npTxryJ8CPzbKMtn/ZyWbkPGl0PuFPkmkjkcb4h4R2ZLwRq1H0ALmvjkf2HwK1Y+T1PY2XABe/sHJ6MxN5lnoSpnC/UGbsTaI5phK2R7x6s3Ffk5YoDOrWm3onwJHBmEP86bPmBrsGaenNoIdnxCH+gPEhLXi0Cl1VBvyPVLSh7gEuC62yAfOIUqabWEaaiucMIk6RyqJ+Q/QM69V26jjW86Gvov/EaoyT8zRCn+Xq7PVrbx0nuYUaO9wM3WAbjCE1NEUw09Um4UV+2OKfYfu5/S19gsAzGKqm6LE5FrShbdS0ku465DjDwKA/oQht19ejqbaEVuRbiLhuHByYLjtUAZpDutzP7cYdHsPJXWbjyNVgFwQoa1WXwf4Jd9YD/Ap80+yE7+u9aAAAAAElFTkSuQmCC);background-repeat:no-repeat;background-size:auto 100%;background-position-x:center;transition:background-color .5s}.markdown-body code{padding:.065em .4em;font-size:.87em;color:var(--cyanosis-code-color);word-break:break-word;overflow-x:auto;background-color:var(--cyanosis-code-bg-color);border-radius:2px}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{display:block;padding:16px 12px;margin:0;font-size:12px;color:#333;word-break:normal;overflow-x:auto;background:var(--cyanosis-code-pre-color)}.markdown-body pre&gt;code::-webkit-scrollbar{width:4px;height:4px}.markdown-body pre&gt;code::-webkit-scrollbar-track{background-color:var(--cyanosis-border-color)}.markdown-body pre&gt;code::-webkit-scrollbar-thumb{background-color:var(--cyanosis-strong-color);border-radius:10px}.markdown-body a{position:relative;text-decoration:none;color:var(--cyanosis-link-color);border-bottom:1px solid var(--cyanosis-border-color)}.markdown-body a:hover{border-bottom-color:var(--cyanosis-linkh-color)}.markdown-body a:active,.markdown-body a:hover{color:var(--cyanosis-linkh-color)}.markdown-body a:after{position:absolute;content:"";top:100%;left:0;width:100%;opacity:0;border-bottom:1px solid var(--cyanosis-border-color);transition:top .3s,opacity .3s;transform:translateZ(0)}.markdown-body a:hover:after{top:0;opacity:1;border-bottom-color:var(--cyanosis-linkh-color)}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid var(--cyanosis-table-border-color);border-spacing:0;border-collapse:collapse}.markdown-body table thead{color:#000;text-align:left;font-size:14px;background:#f6f6f6}.markdown-body table tr:nth-child(2n){background-color:var(--cyanosis-table-tr-nc-color)}.markdown-body table tr:hover{background-color:var(--cyanosis-table-trh-color)}.markdown-body table td,.markdown-body table th{padding:12px 8px;line-height:24px;border:1px solid var(--cyanosis-table-border-color)}.markdown-body table th{color:var(--cyanosis-table-tht-color);background-color:var(--cyanosis-table-th-color)}.markdown-body table td{min-width:120px}.markdown-body blockquote{color:var(--cyanosis-blockquote-color);border-left:4px solid var(--cyanosis-strong-color);background-color:var(--cyanosis-blockquote-bg-color);padding:1px 20px;margin:22px 0;transition:color .35s}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body b,.markdown-body blockquote&gt;b,.markdown-body blockquote&gt;strong,.markdown-body strong{color:var(--cyanosis-strong-color)}.markdown-body em,.markdown-body i{color:var(--cyanosis-em-color)}.markdown-body del{color:var(--cyanosis-del-color)}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:4px}.markdown-body ol li{padding-left:6px}.markdown-body details&gt;summary{outline:none;color:var(--cyanosis-title-color);font-size:20px;font-weight:bolder;border-bottom:1px solid var(--cyanosis-border-color);cursor:pointer}.markdown-body details&gt;p{padding:10px 20px;margin:10px 0 0;color:#666;background-color:var(--cyanosis-blockquote-bg-color);border:2px dashed var(--cyanosis-strong-color)}.markdown-body h1::selection,.markdown-body h2::selection,.markdown-body h3::selection,.markdown-body h4::selection,.markdown-body h5::selection,.markdown-body h6::selection{color:var(--cyanosis-slct-title-color);background-color:var(--cyanosis-slct-titlebg-color)}.markdown-body ol li::selection,.markdown-body p::selection,.markdown-body ul li::selection{color:var(--cyanosis-slct-text-color);background-color:var(--cyanosis-slct-bg-color)}.markdown-body a::selection,.markdown-body b::selection,.markdown-body em::selection,.markdown-body i::selection,.markdown-body strong::selection{background-color:var(--cyanosis-slct-elbg-color)}.markdown-body del::selection{color:var(--cyanosis-slct-del-color);background-color:var(--cyanosis-slct-elbg-color)}.markdown-body table thead th::selection{background-color:transparent}.markdown-body table tbody td::selection{background-color:var(--cyanosis-slct-bg-color)}.markdown-body code::selection{background-color:var(--cyanosis-slct-codebg-color)}.markdown-body pre&gt;code::selection{background-color:var(--cyanosis-slct-prebg-color)}.markdown-body .contains-task-list{padding-left:14px;list-style:none}.markdown-body .contains-task-list input[type=checkbox]{position:relative}.markdown-body .contains-task-list input[type=checkbox]:before{content:"";position:absolute;top:0;left:0;right:0;bottom:0;width:inherit;height:inherit;background:#f0f8ff;border:1px solid #add6ff;border-radius:2px;box-sizing:border-box;z-index:1}.markdown-body .contains-task-list input[type=checkbox]:checked:after{content:"✓";position:absolute;top:-12px;left:0;right:0;bottom:0;width:0;height:0;color:#f55;font-size:20px;font-weight:700;z-index:2}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="an-old-hope">.hljs-comment,.hljs-quote{color:#b6b18b}.hljs-deletion,.hljs-name,.hljs-regexp,.hljs-selector-class,.hljs-selector-id,.hljs-tag,.hljs-template-variable,.hljs-variable{color:#eb3c54}.hljs-built_in,.hljs-builtin-name,.hljs-link,.hljs-literal,.hljs-meta,.hljs-number,.hljs-params,.hljs-type{color:#e7ce56}.hljs-attribute{color:#ee7c2b}.hljs-addition,.hljs-bullet,.hljs-string,.hljs-symbol{color:#4fb4d7}.hljs-section,.hljs-title{color:#78bb65}.hljs-keyword,.hljs-selector-tag{color:#b45ea4}.markdown-body pre,.markdown-body pre&gt;code.hljs{background:#1c1d21;color:#c0c5ce}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>我们在日常开发中经常会用到筛选的功能，比如一个表格数据，需要根据其中的某一列去进行模糊匹配筛选，一般都是去判断字符串中是否包含某个子字符串，但是这样是不支持首字母模糊匹配的，所以我们可以使用一个第三方包<code>pinyin</code>去实现这种功能。</p>
<p><code>pinyin</code>可以直接使用<code>npm</code>下载。</p>
<h2 data-id="heading-0">1.表格的筛选</h2>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">searchedFilter</span>(<span class="hljs-params">rows, searchValue, keyValue</span>) {
  searchValue = searchValue.<span class="hljs-title function_">trim</span>();
  <span class="hljs-keyword">if</span> (searchValue) {
    <span class="hljs-keyword">const</span> pathen = <span class="hljs-regexp">/^[\u4e00-\u9fa5]+$/</span>;
    <span class="hljs-keyword">if</span> (pathen.<span class="hljs-title function_">test</span>(searchValue)) {
      <span class="hljs-keyword">return</span> rows.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(data).<span class="hljs-title function_">some</span>(<span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> {
          <span class="hljs-keyword">if</span> (key === keyValue) {
            <span class="hljs-keyword">return</span> data[key].<span class="hljs-title function_">includes</span>(searchValue);
          }
        });
      });
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">const</span> searchValuePinyin = <span class="hljs-title function_">pinyin</span>(searchValue, {
        <span class="hljs-attr">style</span>: pinyin.<span class="hljs-property">STYLE_FIRST_LETTER</span>,
      }).<span class="hljs-title function_">join</span>(<span class="hljs-string">""</span>);
      <span class="hljs-keyword">return</span> rows.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(data).<span class="hljs-title function_">some</span>(<span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> {
          <span class="hljs-keyword">if</span> (key === keyValue) {
            <span class="hljs-keyword">const</span> dataPyArr = <span class="hljs-title function_">pinyin</span>(data[key], {
              <span class="hljs-attr">style</span>: pinyin.<span class="hljs-property">STYLE_FIRST_LETTER</span>,
            });
            <span class="hljs-keyword">const</span> dataPy = dataPyArr.<span class="hljs-title function_">join</span>(<span class="hljs-string">""</span>);
            <span class="hljs-keyword">return</span> dataPy.<span class="hljs-title function_">includes</span>(searchValuePinyin);
          }
        });
      });
    }
  }
  <span class="hljs-keyword">return</span> rows;
}
</code></pre>
<p>该方法接收三个参数，<code>rows</code>是表格数据，<code>searchValue</code>是筛选字符串，<code>keyValue</code>是要匹配的表格的某一列的<code>prop</code>。</p>
<p>下面举个例子：</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"screen-view"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>筛选字段:<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">el-input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"filterText"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"width:120px"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">el-input</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"filterHandle"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"primary"</span>&gt;</span>筛选<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">el-table</span> <span class="hljs-attr">:data</span>=<span class="hljs-string">"showTableData"</span> <span class="hljs-attr">stripe</span> <span class="hljs-attr">border</span> <span class="hljs-attr">height</span>=<span class="hljs-string">"500"</span> <span class="hljs-attr">:cell-style</span>=<span class="hljs-string">"{ textAlign: 'center' }"</span>
      <span class="hljs-attr">:header-cell-style</span>=<span class="hljs-string">"{ textAlign: 'center' }"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">el-table-column</span> <span class="hljs-attr">label</span>=<span class="hljs-string">"姓名"</span> <span class="hljs-attr">prop</span>=<span class="hljs-string">"name"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">el-table-column</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">el-table-column</span> <span class="hljs-attr">label</span>=<span class="hljs-string">"地址"</span> <span class="hljs-attr">prop</span>=<span class="hljs-string">"address"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">el-table-column</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">el-table-column</span> <span class="hljs-attr">label</span>=<span class="hljs-string">"职位"</span> <span class="hljs-attr">prop</span>=<span class="hljs-string">"job"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">el-table-column</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">el-table</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">import</span> { searchedFilter } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/utils/changePinyin'</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-title function_">data</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">tableData</span>: [
        { <span class="hljs-attr">name</span>: <span class="hljs-string">'月亮'</span>, <span class="hljs-attr">address</span>: <span class="hljs-string">'江苏省南京市'</span>, <span class="hljs-attr">job</span>: <span class="hljs-string">'前端开发'</span> },
        { <span class="hljs-attr">name</span>: <span class="hljs-string">'月亮1'</span>, <span class="hljs-attr">address</span>: <span class="hljs-string">'江苏省南京市'</span>, <span class="hljs-attr">job</span>: <span class="hljs-string">'前端开发'</span> },
        { <span class="hljs-attr">name</span>: <span class="hljs-string">'月亮2'</span>, <span class="hljs-attr">address</span>: <span class="hljs-string">'江苏省南京市'</span>, <span class="hljs-attr">job</span>: <span class="hljs-string">'前端开发'</span> },
        { <span class="hljs-attr">name</span>: <span class="hljs-string">'大傻'</span>, <span class="hljs-attr">address</span>: <span class="hljs-string">'安徽省合肥市'</span>, <span class="hljs-attr">job</span>: <span class="hljs-string">'后端开发'</span> },
        { <span class="hljs-attr">name</span>: <span class="hljs-string">'大傻1'</span>, <span class="hljs-attr">address</span>: <span class="hljs-string">'安徽省合肥市'</span>, <span class="hljs-attr">job</span>: <span class="hljs-string">'后端开发'</span> },
        { <span class="hljs-attr">name</span>: <span class="hljs-string">'大傻2'</span>, <span class="hljs-attr">address</span>: <span class="hljs-string">'安徽省合肥市'</span>, <span class="hljs-attr">job</span>: <span class="hljs-string">'后端开发'</span> },
        { <span class="hljs-attr">name</span>: <span class="hljs-string">'二狗'</span>, <span class="hljs-attr">address</span>: <span class="hljs-string">'四川省成都市'</span>, <span class="hljs-attr">job</span>: <span class="hljs-string">'前端开发'</span> },
        { <span class="hljs-attr">name</span>: <span class="hljs-string">'二狗1'</span>, <span class="hljs-attr">address</span>: <span class="hljs-string">'四川省成都市'</span>, <span class="hljs-attr">job</span>: <span class="hljs-string">'前端开发'</span> },
        { <span class="hljs-attr">name</span>: <span class="hljs-string">'二狗2'</span>, <span class="hljs-attr">address</span>: <span class="hljs-string">'四川省成都市'</span>, <span class="hljs-attr">job</span>: <span class="hljs-string">'前端开发'</span> },
        { <span class="hljs-attr">name</span>: <span class="hljs-string">'三驴子'</span>, <span class="hljs-attr">address</span>: <span class="hljs-string">'河南省郑州市'</span>, <span class="hljs-attr">job</span>: <span class="hljs-string">'后端开发'</span> },
        { <span class="hljs-attr">name</span>: <span class="hljs-string">'三驴子1'</span>, <span class="hljs-attr">address</span>: <span class="hljs-string">'河南省郑州市'</span>, <span class="hljs-attr">job</span>: <span class="hljs-string">'后端开发'</span> },
        { <span class="hljs-attr">name</span>: <span class="hljs-string">'三驴子2'</span>, <span class="hljs-attr">address</span>: <span class="hljs-string">'河南省郑州市'</span>, <span class="hljs-attr">job</span>: <span class="hljs-string">'后端开发'</span> },
      ],
      <span class="hljs-attr">showTableData</span>: [],
      <span class="hljs-attr">filterText</span>: <span class="hljs-string">''</span>
    }
  },
  <span class="hljs-title function_">created</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">showTableData</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">tableData</span>
  },
  <span class="hljs-attr">methods</span>: {
    <span class="hljs-title function_">filterHandle</span>(<span class="hljs-params"/>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">showTableData</span> = <span class="hljs-title function_">searchedFilter</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">tableData</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">filterText</span>, <span class="hljs-string">'name'</span>)
      <span class="hljs-comment">// 这就是筛选表格的姓名字段，如果想筛选别的就把name换成对应的prop</span>
      <span class="hljs-comment">// 支持首字母匹配</span>
    }
  }
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"scss"</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="css">
<span class="hljs-selector-class">.screen-view</span> {
  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;
  <span class="hljs-attribute">box-sizing</span>: border-box;
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
</code></pre>
<p>这个方法只能根据表格的一列进行筛选，如果想同时匹配多列的话，可以使用下面的方法。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">searchedFilters</span>(<span class="hljs-params">rows, searchValue, keyValues</span>) {
  searchValue = searchValue.<span class="hljs-title function_">trim</span>();
  <span class="hljs-keyword">if</span> (searchValue) {
    <span class="hljs-keyword">const</span> pathen = <span class="hljs-regexp">/^[\u4e00-\u9fa5]+$/</span>;
    <span class="hljs-keyword">if</span> (pathen.<span class="hljs-title function_">test</span>(searchValue)) {
      <span class="hljs-keyword">return</span> rows.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(data).<span class="hljs-title function_">some</span>(<span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> {
          <span class="hljs-keyword">return</span> keyValues.<span class="hljs-title function_">some</span>(<span class="hljs-function">(<span class="hljs-params">k</span>) =&gt;</span> {
            <span class="hljs-keyword">if</span> (key === k) {
              <span class="hljs-keyword">return</span> data[key].<span class="hljs-title function_">includes</span>(searchValue);
            }
          });
        });
      });
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">const</span> searchValuePinyin = <span class="hljs-title function_">pinyin</span>(searchValue, {
        <span class="hljs-attr">style</span>: pinyin.<span class="hljs-property">STYLE_FIRST_LETTER</span>,
      }).<span class="hljs-title function_">join</span>(<span class="hljs-string">""</span>);
      <span class="hljs-keyword">return</span> rows.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(data).<span class="hljs-title function_">some</span>(<span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> {
          <span class="hljs-keyword">return</span> keyValues.<span class="hljs-title function_">some</span>(<span class="hljs-function">(<span class="hljs-params">k</span>) =&gt;</span> {
            <span class="hljs-keyword">if</span> (key === k) {
              <span class="hljs-keyword">const</span> dataPyArr = <span class="hljs-title function_">pinyin</span>(data[key], {
                <span class="hljs-attr">style</span>: pinyin.<span class="hljs-property">STYLE_FIRST_LETTER</span>,
              });
              <span class="hljs-keyword">const</span> dataPy = dataPyArr.<span class="hljs-title function_">join</span>(<span class="hljs-string">""</span>);
              <span class="hljs-keyword">return</span> dataPy.<span class="hljs-title function_">includes</span>(searchValuePinyin);
            }
          });
        });
      });
    }
  }
  <span class="hljs-keyword">return</span> rows;
}
</code></pre>
<p>还是接收三个参数，前面两个跟第一个方法一样，表格数据和筛选字符串，第三个是一个数组，里面存放的是你想匹配的列。</p>
<p>比如我们想同时筛选姓名和地址这两列：</p>
<pre><code class="hljs language-js" lang="js">    <span class="hljs-title function_">filterHandle</span>(<span class="hljs-params"/>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">showTableData</span> = <span class="hljs-title function_">searchedFilters</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">tableData</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">filterText</span>, [<span class="hljs-string">'name'</span>, <span class="hljs-string">'address'</span>])
    }
</code></pre>
<h2 data-id="heading-1">2.树结构的筛选</h2>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">treeFilterPY</span>(<span class="hljs-params">data, searchValue, keyValue</span>) {
  searchValue = searchValue.<span class="hljs-title function_">trim</span>();
  <span class="hljs-keyword">if</span> (!searchValue) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  <span class="hljs-keyword">const</span> pathen = <span class="hljs-regexp">/^[\u4e00-\u9fa5]+$/</span>;
  <span class="hljs-keyword">if</span> (pathen.<span class="hljs-title function_">test</span>(searchValue)) {
    <span class="hljs-keyword">return</span> data[keyValue].<span class="hljs-title function_">indexOf</span>(searchValue) !== -<span class="hljs-number">1</span>;
  }
  <span class="hljs-comment">// 匹配小写</span>
  <span class="hljs-keyword">const</span> labelValue = <span class="hljs-title function_">pinyin</span>(data[keyValue], {
    <span class="hljs-attr">style</span>: pinyin.<span class="hljs-property">STYLE_FIRST_LETTER</span>,
  }).<span class="hljs-title function_">join</span>(<span class="hljs-string">""</span>);
  <span class="hljs-keyword">const</span> searchValuePinyin = <span class="hljs-title function_">pinyin</span>(searchValue, {
    <span class="hljs-attr">style</span>: pinyin.<span class="hljs-property">STYLE_FIRST_LETTER</span>,
  }).<span class="hljs-title function_">join</span>(<span class="hljs-string">""</span>);
  <span class="hljs-keyword">return</span> labelValue.<span class="hljs-title function_">indexOf</span>(searchValuePinyin) !== -<span class="hljs-number">1</span>;
}
</code></pre>
<p>这个方法接收三个参数，分别是树结构数据，筛选字符串，对应的prop。</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"screen-view"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>筛选字段:<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">el-input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"filterText"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"width:120px"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">el-input</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"filterHandle"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"primary"</span>&gt;</span>筛选<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">el-tree</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"treeRef"</span> <span class="hljs-attr">:data</span>=<span class="hljs-string">"treeData"</span> <span class="hljs-attr">:filter-node-method</span>=<span class="hljs-string">"filterNode"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">el-tree</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">import</span> { treeFilterPY } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/utils/changePinyin'</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-title function_">data</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">defaultProps</span>: {
        <span class="hljs-attr">children</span>: <span class="hljs-string">"children"</span>,
        <span class="hljs-attr">label</span>: <span class="hljs-string">"label"</span>,
      },
      <span class="hljs-attr">treeData</span>: [
        {
          <span class="hljs-attr">label</span>: <span class="hljs-string">'全部'</span>,
          <span class="hljs-attr">id</span>: -<span class="hljs-number">1</span>,
          <span class="hljs-attr">children</span>: [
            {
              <span class="hljs-attr">label</span>: <span class="hljs-string">'月亮'</span>,
              <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>
            },
            {
              <span class="hljs-attr">label</span>: <span class="hljs-string">'大傻'</span>,
              <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>
            },
            {
              <span class="hljs-attr">label</span>: <span class="hljs-string">'二狗'</span>,
              <span class="hljs-attr">id</span>: <span class="hljs-number">3</span>
            },
            {
              <span class="hljs-attr">label</span>: <span class="hljs-string">'三驴子'</span>,
              <span class="hljs-attr">id</span>: <span class="hljs-number">4</span>
            },
          ]
        }
      ],
      <span class="hljs-attr">filterText</span>: <span class="hljs-string">''</span>
    }
  },
  <span class="hljs-title function_">created</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">showTableData</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">tableData</span>
  },
  <span class="hljs-attr">methods</span>: {
    <span class="hljs-title function_">filterHandle</span>(<span class="hljs-params"/>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>.<span class="hljs-property">treeRef</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">filterText</span>);
    },
    <span class="hljs-title function_">filterNode</span>(<span class="hljs-params">value, data</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">treeFilterPY</span>(data, value, <span class="hljs-variable language_">this</span>.<span class="hljs-property">defaultProps</span>.<span class="hljs-property">label</span>);
    },
  }
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"scss"</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="css">
<span class="hljs-selector-class">.screen-view</span> {
  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;
  <span class="hljs-attribute">box-sizing</span>: border-box;
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
</code></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[现代 Nginx 优化实践：架构、配置与性能调优]]></title>    <link>https://juejin.cn/post/7578700798743658530</link>    <guid>https://juejin.cn/post/7578700798743658530</guid>    <pubDate>2025-12-01T09:28:12.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7578700798743658530" data-draft-id="7577356848337895459" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="现代 Nginx 优化实践：架构、配置与性能调优"/> <meta itemprop="keywords" content="前端,Nginx"/> <meta itemprop="datePublished" content="2025-12-01T09:28:12.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="车前端"/> <meta itemprop="url" content="https://juejin.cn/user/3889431196213664"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            现代 Nginx 优化实践：架构、配置与性能调优
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3889431196213664/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    车前端
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-01T09:28:12.000Z" title="Mon Dec 01 2025 09:28:12 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-01
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    1
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读11分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body cache result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>作者：王佳月（汽车之家：APP 架构前端工程师）</p>
<h2 data-id="heading-0">现代 Nginx 优化实践：架构、配置与性能调优</h2>
<p>在当今高并发、高可用的 Web 架构中，Nginx 作为反向代理服务器扮演着至关重要的角色。本文将基于实际项目经验，深入探讨现代 Nginx 的优化策略，从基础配置、性能调优、安全加固到高级功能应用，为您提供一套全面且可落地的优化方案。</p>
<h3 data-id="heading-1">一、基础架构与核心配置优化</h3>
<h4 data-id="heading-2">1.1 进程与连接优化</h4>
<p>Nginx 的工作进程配置直接影响其并发处理能力。在项目中，我们采用了以下配置：</p>
<pre><code class="hljs language-nginx" lang="nginx">worker_processes  1;
worker_rlimit_nofile  65535;

events {
  multi_accept        on;
  worker_connections  65535;
}
</code></pre>
<p><strong>优化说明：</strong></p>
<ul>
<li><code>worker_processes</code>：通常设置为 CPU 核心数，但在容器化环境中需根据实际资源分配调整</li>
<li><code>worker_rlimit_nofile</code>：提高单个进程可打开的最大文件数，解决高并发场景下的文件描述符限制</li>
<li><code>multi_accept on</code>：允许 Nginx 同时接受多个连接，提高连接处理效率</li>
<li><code>worker_connections</code>：每个工作进程可同时处理的最大连接数</li>
</ul>
<p><strong>实际效果：</strong> 在我们的项目中，这组配置使单实例 Nginx 能够稳定处理每秒上万级的请求量，CPU 使用率降低约 30%。</p>
<h4 data-id="heading-3">1.2 HTTP 核心模块优化</h4>
<p>项目中的 HTTP 核心优化配置如下：</p>
<pre><code class="hljs language-nginx" lang="nginx">http {
  etag                   off;
  charset                utf-8;
  sendfile               on;
  tcp_nopush             on;
  server_tokens          off;
  log_not_found          off;
  keepalive_timeout      65;
  keepalive_requests     300;

  proxy_intercept_errors on;
  proxy_ignore_client_abort on;
  subrequest_output_buffer_size 3m;
}
</code></pre>
<p><strong>关键优化点：</strong></p>
<ol>
<li><strong>文件传输优化</strong></li>
</ol>
<ul>
<li><code>sendfile on</code>：启用零拷贝技术，减少内核与用户空间之间的数据拷贝</li>
<li><code>tcp_nopush on</code>：与 sendfile 配合使用，在数据包积累到一定大小后再发送，提高网络效率</li>
</ul>
<ol start="2">
<li><strong>连接复用</strong></li>
</ol>
<ul>
<li><code>keepalive_timeout 65</code>：设置长连接超时时间</li>
<li><code>keepalive_requests 300</code>：每个长连接最多处理的请求数，避免单个连接占用过久</li>
</ul>
<ol start="3">
<li><strong>性能与安全平衡</strong></li>
</ol>
<ul>
<li><code>etag off</code>：禁用 ETag，减少带宽消耗和服务器负载</li>
<li><code>server_tokens off</code>：隐藏 Nginx 版本信息，提高安全性</li>
<li><code>log_not_found off</code>：不记录 404 错误，减少磁盘 I/O 和日志体积</li>
</ul>
<ol start="4">
<li><strong>错误处理优化</strong></li>
</ol>
<ul>
<li><code>proxy_intercept_errors on</code>：允许 Nginx 拦截后端服务器的错误响应</li>
<li><code>proxy_ignore_client_abort on</code>：忽略客户端中断连接，确保后端处理不受影响</li>
</ul>
<h3 data-id="heading-4">二、缓存策略与加速优化</h3>
<h4 data-id="heading-5">2.1 高效缓存配置</h4>
<p>项目中实现了精细化的缓存策略，根据资源类型和版本信息应用不同的缓存规则：</p>
<pre><code class="hljs language-nginx" lang="nginx">proxy_cache_path  /var/cache/nginx/static_temp levels=1:2 keys_zone=static_cache:20m max_size=800m inactive=1d use_temp_path=off;

# 针对不同版本的缓存控制
header_filter_by_lua_block {
  local ver = ngx.var.ver
  local cache_ttl
  if ver and (ver == "latest" or ver:match("^%d+%.x$") or ver:match("^%d+%.%d+%.x$")) then
    cache_ttl = 300
  else
    cache_ttl = 31536000
  end

  ngx.header["Cache-Control"] = "public, max-age=" .. cache_ttl
}

# 缓存配置示例
proxy_cache static_cache;
proxy_cache_min_uses 3;
proxy_cache_valid 200 304 30s;
proxy_cache_valid 404 10s;
proxy_cache_valid any 30s;
proxy_cache_use_stale error timeout updating invalid_header http_500 http_502 http_503 http_504;
</code></pre>
<p><strong>缓存优化策略：</strong></p>
<ol>
<li><strong>缓存路径与键值设计</strong></li>
</ol>
<ul>
<li><code>levels=1:2</code>：创建两级目录结构，提高文件系统查找效率</li>
<li><code>keys_zone=static_cache:20m</code>：分配 20MB 内存用于缓存键和元数据</li>
<li><code>max_size=800m</code>：限制缓存大小，防止磁盘空间耗尽</li>
<li><code>inactive=1d</code>：超过 1 天未访问的缓存项将被清理</li>
<li><code>use_temp_path=off</code>：直接在缓存目录中写入，避免额外的文件移动开销</li>
</ul>
<ol start="2">
<li><strong>智能缓存时间策略</strong></li>
</ol>
<ul>
<li>对稳定版本资源设置长缓存时间（31536000 秒 = 1 年）</li>
<li>对开发版、最新版和版本范围（如 1.x）设置短缓存时间（300 秒 = 5 分钟）</li>
<li>根据 HTTP 状态码设置不同的缓存有效期</li>
</ul>
<ol start="3">
<li><strong>高可用性缓存</strong></li>
</ol>
<ul>
<li><code>proxy_cache_use_stale</code>：在后端错误、超时等情况下使用过期缓存，提高系统可用性</li>
<li><code>proxy_cache_min_uses 3</code>：只有请求达到一定次数才会被缓存，避免缓存低频访问的资源</li>
</ul>
<h4 data-id="heading-6">2.2 响应压缩与资源优化</h4>
<p>项目中启用了 Gzip 压缩并进行了针对性优化：</p>
<pre><code class="hljs language-nginx" lang="nginx">gunzip on;
proxy_method GET;
proxy_pass_request_body off;
proxy_pass_request_headers off;
proxy_set_header Accept-Encoding "";
</code></pre>
<p><strong>优化策略：</strong></p>
<ol>
<li><strong>解压缩支持</strong></li>
</ol>
<ul>
<li><code>gunzip on</code>：自动解压缩来自后端的 gzip 压缩响应</li>
</ul>
<ol start="2">
<li><strong>请求优化</strong></li>
</ol>
<ul>
<li>对静态资源请求移除请求体和非必要请求头，减少数据传输量</li>
<li>清除 Accept-Encoding 头，避免多层压缩带来的性能损耗</li>
</ul>
<h4 data-id="heading-7">2.3 图片资源优化</h4>
<p>在图片服务器配置中，实现了自动格式转换和异步裁切：</p>
<pre><code class="hljs language-nginx" lang="nginx"># 异步 AVIF 转换示例
access_by_lua_block {
  local is_match = "业务逻辑判断"

  if is_match then
    自定义业务逻辑
  end
}

# 异常回退机制
proxy_intercept_errors on;
recursive_error_pages on;
error_page 404 502 504 = @fallback;

# 回退到原始格式
location @fallback {
  rewrite ... break;
  # 其他配置...
}
</code></pre>
<p><strong>图片优化技术要点：</strong></p>
<ol>
<li><strong>现代图片格式自动转换</strong></li>
</ol>
<ul>
<li>根据请求路径自动启用格式转换，减少图片大小 30-50%</li>
<li>实现异步裁切，提高响应速度</li>
</ul>
<ol start="2">
<li><strong>降级机制</strong></li>
</ol>
<ul>
<li>当转换失败时，自动回退到原始图片格式，确保服务可用性</li>
</ul>
<h3 data-id="heading-8">三、高可用与负载均衡</h3>
<h4 data-id="heading-9">3.1 多数据中心部署架构</h4>
<p>项目采用了多数据中心部署策略，提高系统可用性：</p>
<pre><code class="hljs language-nginx" lang="nginx"># 集群A
upstream server_a {
  server xx.xx.x.xxx:xx max_fails=2 fail_timeout=2s;
  server xx.xx.x.xxx:xx max_fails=2 fail_timeout=2s;
  keepalive 320;
}

# 集群B
upstream server_b {
  server xx.xx.x.xxx:xx max_fails=2 fail_timeout=2s;
  server xx.xx.x.xxx:xx max_fails=2 fail_timeout=2s;
  keepalive 320;
}
</code></pre>
<p><strong>高可用配置要点：</strong></p>
<ol>
<li><strong>健康检查机制</strong></li>
</ol>
<ul>
<li><code>max_fails=2</code>：允许的失败次数</li>
<li><code>fail_timeout=2s</code>：失败超时时间，超过该时间后将重新检查服务器健康状态</li>
</ul>
<ol start="2">
<li><strong>连接池复用</strong></li>
</ol>
<ul>
<li><code>keepalive 320</code>：为上游服务器维护的空闲连接数，减少频繁建立连接的开销</li>
</ul>
<ol start="3">
<li><strong>备份服务器</strong></li>
</ol>
<ul>
<li>部分 upstream 配置中添加了 <code>backup</code> 标记的服务器，作为灾难恢复使用</li>
</ul>
<h4 data-id="heading-10">3.2 DNS 解析优化</h4>
<p>针对微服务架构中的服务发现，项目进行了 DNS 解析优化：</p>
<pre><code class="hljs language-nginx" lang="nginx">resolver 127.0.0.11 10.33.3.5 10.33.3.6 10.41.0.254 valid=300s ipv6=off;
resolver_timeout 500ms;
</code></pre>
<p><strong>DNS 优化策略：</strong></p>
<ol>
<li><strong>多 DNS 服务器</strong></li>
</ol>
<ul>
<li>配置多个 DNS 服务器，提高解析可靠性</li>
<li>包含 Docker 内部 DNS (127.0.0.11) 和企业内部 DNS 服务器</li>
</ul>
<ol start="2">
<li><strong>缓存与超时控制</strong></li>
</ol>
<ul>
<li><code>valid=300s</code>：DNS 解析结果缓存时间</li>
<li><code>resolver_timeout 500ms</code>：限制 DNS 解析超时时间，避免长时间阻塞</li>
</ul>
<h3 data-id="heading-11">四、安全加固与监控</h3>
<h4 data-id="heading-12">4.1 安全头配置</h4>
<p>项目中实现了全面的安全头设置，防止常见的 Web 攻击：</p>
<pre><code class="hljs language-nginx" lang="nginx"># 移除可能存在的不安全响应头
proxy_hide_header X-Frame-Options;
proxy_hide_header X-XSS-Protection;
proxy_hide_header X-Content-Type-Options;
proxy_hide_header Content-Security-Policy;
proxy_hide_header Strict-Transport-Security;

# 添加安全头
add_header X-XSS-Protection "1; mode=block" always;
add_header X-Content-Type-Options "nosniff" always;
add_header Strict-Transport-Security "max-age=31536000;" always;
</code></pre>
<p><strong>安全头说明：</strong></p>
<ol>
<li><strong>XSS 防护</strong></li>
</ol>
<ul>
<li><code>X-XSS-Protection "1; mode=block"</code>：启用浏览器内置的 XSS 过滤器，检测到攻击时阻止页面加载</li>
</ul>
<ol start="2">
<li><strong>MIME 类型嗅探防护</strong></li>
</ol>
<ul>
<li><code>X-Content-Type-Options "nosniff"</code>：防止浏览器对响应内容进行 MIME 类型嗅探，减少 XSS 攻击面</li>
</ul>
<ol start="3">
<li><strong>HTTPS 强制</strong></li>
</ol>
<ul>
<li><code>Strict-Transport-Security "max-age=31536000;"</code>：强制使用 HTTPS，防止中间人攻击</li>
</ul>
<h4 data-id="heading-13">4.2 请求限制与访问控制</h4>
<p>项目实现了请求方法限制和访问控制：</p>
<pre><code class="hljs language-nginx" lang="nginx"># 限制请求方法
if ($request_method !~ ^(GET|HEAD|POST)$) {
  return 403;
}

# 内部接口访问控制
location /get_versions/ {
  allow 127.0.0.1;
  deny all;
  # 其他配置...
}
</code></pre>
<p><strong>安全访问控制：</strong></p>
<ol>
<li><strong>请求方法限制</strong>：只允许 GET、HEAD、POST 方法，拒绝其他可能带来风险的方法</li>
<li><strong>内部接口保护</strong>：通过 IP 白名单限制内部接口只能由本地访问</li>
</ol>
<h4 data-id="heading-14">4.3 监控与健康检查</h4>
<p>项目实现了完善的监控和健康检查机制：</p>
<pre><code class="hljs language-nginx" lang="nginx"># 健康检查接口
location = /nginx_health_check {
  access_log off;
  add_header Cache-Control "no-store";
  default_type text/plain;
  return 200 "ok";
}

# 状态监控接口
location = /nginx_basic_status {
  access_log off;
  add_header Cache-Control "no-store";
  stub_status on;
  auth_basic "NginxStatus";
  auth_basic_user_file config/ip_passwdfile;
}
</code></pre>
<p><strong>监控功能说明：</strong></p>
<ol>
<li><strong>健康检查</strong>：提供简单的 <code>/nginx_health_check/</code> 接口，用于容器编排系统的健康检查</li>
<li><strong>状态监控</strong>：启用 <code>stub_status</code> 模块，提供详细的 Nginx 运行状态统计
<ul>
<li>包括活跃连接数、接受连接数、处理请求数等关键指标</li>
<li>通过 HTTP 基本认证保护监控接口</li>
</ul>
</li>
</ol>
<h3 data-id="heading-15">五、高级功能与性能优化</h3>
<h4 data-id="heading-16">5.1 客户端真实 IP 获取</h4>
<p>项目实现了可靠的客户端真实 IP 获取机制：</p>
<pre><code class="hljs language-nginx" lang="nginx"># 获取客户端真实IP
map $http_x_forwarded_for $client_real_ip {
  ~^(?P&lt;firstAddr&gt;[\d\.\:A-f]+),?.*$  $firstAddr;
  ""  $remote_addr;
}

# 在 proxy.conf 中传递真实 IP
proxy_set_header X-Real-IP  $client_real_ip;
proxy_set_header X-Forwarded-For  $proxy_add_x_forwarded_for;
</code></pre>
<p><strong>IP 获取策略：</strong></p>
<ol>
<li><strong>多级代理支持</strong>：通过正则表达式从 <code>X-Forwarded-For</code> 头中提取第一个 IP 地址</li>
<li><strong>IPv4/IPv6 兼容</strong>：正则表达式支持匹配 IPv4 和 IPv6 地址格式</li>
<li><strong>默认值处理</strong>：当没有 <code>X-Forwarded-For</code> 头时，回退到直接连接的 IP</li>
</ol>
<h4 data-id="heading-17">5.2 日志优化</h4>
<p>项目对日志记录进行了优化，减少磁盘 I/O 和提高性能：</p>
<pre><code class="hljs language-nginx" lang="nginx"># 不记录 HTTP 状态码为 2xx/3xx 的请求
map $status $loggable {
  default 1;
  ~^[23]  0;
}

# 使用条件日志
access_log /a-one/log/nginx/access.log alternate if=$loggable;
</code></pre>
<p><strong>日志优化策略：</strong></p>
<ol>
<li><strong>选择性日志记录</strong>：只记录错误和异常请求，减少正常请求的日志记录</li>
<li><strong>自定义日志格式</strong>：通过 NJS 模块实现自定义日志格式，满足特定的日志分析需求</li>
</ol>
<h4 data-id="heading-18">5.3 WebSocket 支持</h4>
<p>项目中实现了 WebSocket 协议的支持，用于实时通信场景：</p>
<pre><code class="hljs language-nginx" lang="nginx"># WebSocket 连接头处理
map $http_upgrade $connection_upgrade {
  default upgrade;
  ""      close;
}

# 在 proxy.conf 中配置 WebSocket 支持
proxy_http_version 1.1;
proxy_set_header Upgrade $http_upgrade;
proxy_set_header Connection $connection_upgrade;
</code></pre>
<p><strong>WebSocket 优化：</strong></p>
<ol>
<li><strong>协议升级支持</strong>：正确处理 HTTP 到 WebSocket 的协议升级</li>
<li><strong>长连接维护</strong>：配置 HTTP/1.1 和相应的连接头，确保 WebSocket 连接稳定</li>
</ol>
<h3 data-id="heading-19">六、容器化环境优化</h3>
<p>在 Docker 环境中，项目进行了针对性的优化：</p>
<pre><code class="hljs language-nginx" lang="nginx"># Docker 容器优化
daemon off;  # 前台运行，便于容器管理

# 容器内部 DNS 优先
resolver 127.0.0.11 ...;
</code></pre>
<p><strong>容器化优化要点：</strong></p>
<ol>
<li><strong>前台运行模式</strong>：<code>daemon off</code> 确保 Nginx 运行在前台，便于 Docker 管理进程生命周期</li>
<li><strong>容器网络适配</strong>：优先使用 Docker 内部 DNS 解析服务，提高容器间通信效率</li>
</ol>
<h3 data-id="heading-20">七、优化效果与最佳实践</h3>
<h4 data-id="heading-21">7.1 性能提升效果</h4>
<p>通过上述优化，项目在以下方面取得了显著提升：</p>









































<table><thead><tr><th>优化维度</th><th>优化前</th><th>优化后</th><th>提升百分比</th></tr></thead><tbody><tr><td>请求处理能力</td><td>5k QPS</td><td>20k QPS</td><td>+300%</td></tr><tr><td>平均响应时间</td><td>100ms</td><td>35ms</td><td>-65%</td></tr><tr><td>CPU 使用率</td><td>70%</td><td>40%</td><td>-43%</td></tr><tr><td>内存占用</td><td>512MB</td><td>256MB</td><td>-50%</td></tr><tr><td>缓存命中率</td><td>60%</td><td>90%</td><td>+50%</td></tr></tbody></table>
<h4 data-id="heading-22">7.2 高可用效果</h4>
<ul>
<li><strong>服务可用性</strong>：从 99.9% 提升到 99.99%，每年减少约 8.76 小时的潜在停机时间</li>
<li><strong>故障自动恢复</strong>：通过 <code>proxy_cache_use_stale</code> 和 <code>proxy_next_upstream</code> 配置，实现了在后端服务异常时的自动恢复</li>
<li><strong>多活架构</strong>：公司异地双数据中心部署，确保单点故障不影响整体服务</li>
</ul>
<h4 data-id="heading-23">7.3 安全加固效果</h4>
<ul>
<li><strong>安全扫描评分</strong>：从 75 分提升到 95 分</li>
<li><strong>XSS 防护</strong>：通过安全头配置，有效防御常见的 XSS 攻击</li>
<li><strong>访问控制</strong>：内部接口访问控制有效阻止了未授权访问</li>
</ul>
<h3 data-id="heading-24">八、总结与未来优化方向</h3>
<p>本文结合实际项目，详细介绍了现代 Nginx 的多维度优化策略，包括基础配置优化、缓存策略、高可用架构、安全加固和高级功能应用。这些优化措施在实际生产环境中取得了显著的性能提升和稳定性改善。</p>
<p>未来的优化方向可以考虑：</p>
<ol>
<li><strong>引入 Nginx Plus 或 OpenResty</strong>：利用更高级的功能如动态配置、健康检查等</li>
<li><strong>实现智能缓存预热</strong>：根据访问模式预测性地缓存热点资源</li>
<li><strong>接入可观测性平台</strong>：整合 Prometheus 和 Grafana，实现更细粒度的监控和告警</li>
<li><strong>探索 QUIC/HTTP3 协议</strong>：利用新一代网络协议进一步提升性能</li>
<li><strong>AI 驱动的自动优化</strong>：基于机器学习分析流量模式，自动调整优化参数</li>
</ol>
<p>通过持续优化和监控，Nginx 服务器可以在不断变化的业务需求和技术环境中保持最佳性能和可靠性。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[解决网页前端中文字体包过大的几种方案]]></title>    <link>https://juejin.cn/post/7578699866181238822</link>    <guid>https://juejin.cn/post/7578699866181238822</guid>    <pubDate>2025-12-01T09:36:04.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7578699866181238822" data-draft-id="7578460753210720283" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="解决网页前端中文字体包过大的几种方案"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2025-12-01T09:36:04.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="ChangYo"/> <meta itemprop="url" content="https://juejin.cn/user/1212107722329492"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            解决网页前端中文字体包过大的几种方案
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1212107722329492/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    ChangYo
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-01T09:36:04.000Z" title="Mon Dec 01 2025 09:36:04 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-01
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读16分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body cache result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>最近想给<a href="https://link.juejin.cn?target=https%3A%2F%2Fchang-yo.github.io" target="_blank" title="https://chang-yo.github.io" ref="nofollow noopener noreferrer">我的博客</a>的网页换个字体，在修复了历史遗留的一些bug之后，去google fonts上找了自己喜欢的字体，本地测试和自己的设备发现没问题后，便以为OK了。</p>
<p>但是当我接朋友的设备打开时，发现网页依然是默认字体。这时候我才发现，我的设备能够翻墙，所以能够使用Google CDN服务，但是对于我的其他读者们，在大陆内是访问不了Google的，便也无法渲染字体了。</p>
<p>于是为了解决这个问题，我尝试了各种办法比如格式压缩，子集化(Subset)，分包等等，最后考虑到本站的实际情况选用了一种比较<em>邪门</em>的方法，让字体压缩率达到了惊人的<strong>98.5%</strong>！于是，这篇文章就是对这个过程的总结。也希望这篇文章能够帮助到你。😊</p>
<hr/>
<p>想要自定义网站的字体，最重要的其实就是字体包的获取。大体上可以分为两种办法：<strong>在线获取</strong>和<strong>网站本地部署</strong>。</p>
<h2 data-id="heading-0">在线获取──利用 CDN 加速服务</h2>
<p>CDN(Content Delivery Network) 意为内容配送网络。你可以简单理解为是一种“就近给你东西”的互联网加速服务。</p>
<p>传统不使用 CDN 服务的是这样的： <code>User ←→ Server</code>,如果相聚遥远，效果显然很差。</p>
<p>使用了 CDN 服务是这样的： <code>User  ←→ CDN Nodes  ←→ Server</code>，CDN 会提前把你的网站静态资源缓存到各个节点，但你需要时可以直接从最近的节点获取。</p>
<p>全球有多家CDN服务提供商，Google Fonts使用的CDN服务速度很快。所以如果在网络畅通的情况下，使用Google Fonts API是最简单省事的！</p>
<p>你可以直接在文件中导入Google fonts API：</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-keyword">@import</span> url(<span class="hljs-string">'https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&amp;family=Merriweather:ital,opsz,wght@0,18..144,733;1,18..144,733&amp;family=Noto+Serif+SC:wght@500&amp;display=swap'</span>);
</code></pre>
<p>这样网站它便会自动向最近的Google CDN节点请求资源。</p>
<p>当然，这些都是建立在网络状态畅通无阻的情况下。大陆用户一般使用不了Google服务，但并不意味着无法使用CDN服务。国内的腾讯云，阿里云同样提供高效的服务，但具体的规则我并不了解，请自行阅读研究。</p>
<h2 data-id="heading-1">本地部署</h2>
<p>既然用不了在线的，那就只能将字体包文件一并上传到服务器上了。</p>
<p>这种做法不需要依赖外部服务，但缺点是字体包的文件往往很大，从进入网站到彻底加载完成的时间会及其漫长！而且这种问题尤其在<strong>中日韩</strong>(CJK)字体上体现的十分明显。</p>
<p>以本站为例，我主要采用了三种字体：Merriweather, Inter, Noto Serif SC. 其中每种字体都包含了Bold和Regular两种格式。前面两种都属于西文字体，每种格式原始文件大小都在200kb-300kb,但是到了思源宋体这里，仅仅一种格式的字体包大小就达到了<strong>足足14M多</strong>。如果全部加载完，恐怕从进入网站到完全渲染成功，需要耽误个2分钟。所以将原始字体包文件上传是<strong>极不可取</strong>的做法！</p>
<p>为了解决这个问题，我在网上查阅资料，找到了三种做法。</p>
<h3 data-id="heading-2">字体格式转换(WOFF2)</h3>
<p><strong>WOFF2 (Web Open Font Format 2.0)</strong> 是一种专为 Web 设计的字体文件格式，旨在提供更高的压缩率和更快的加载速度，也是是目前在 Web 上部署自定义字体的推荐标准。它本质上是一种将 TTF 或 OTF 字体数据进行高度压缩后的格式，目前已经获得了所有主流浏览器的广泛支持。</p>
<p>我们可以找一个在线的字体<a href="https://link.juejin.cn?target=https%3A%2F%2Fcloudconvert.com" target="_blank" title="https://cloudconvert.com" ref="nofollow noopener noreferrer">格式转化网站</a>来实现格式的转化。本文我们以<code>NotoSerifSC-Bold.ttf</code>为例，转换后的<code>NotoSerifSC-Bold.woff2</code>文件只有5.8M左右，压缩率达到了60%!</p>
<p>但是，这仍旧是不够的，仅两个中文字体包加起来也已经快12M,还没有算上其他字体。这对于一个网页来说依然是灾难性的。我们必须寻找另一种方法。</p>
<h3 data-id="heading-3">子集化处理(Subset)</h3>
<p>中国人都知道，虽然中文的字符加起来有2万多个，但是我们平常交流基本只会用到3000多个，范围再大一点,6000多个字符已经可以覆盖99%的使用场景。这意味着：</p>
<p><strong>我们根本不需要保留所有字符，而只需要保留常用的几千个汉字即可。</strong></p>
<p>于是这就给了我们解决问题的思路了。</p>
<p>首先我们可以去寻找中文常用汉字字符表，这里我获取的资源是 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fwy-luke%2FAll-Chinese-Character-Set" target="_blank" title="https://github.com/wy-luke/All-Chinese-Character-Set" ref="nofollow noopener noreferrer">All-Chinese-Character-Set</a>。我们将文件下载解压后，可以在里面找到各种各样按照字频统计的官方文件。这里我们就以《通用规范汉字表》（2013年）一级字和二级字为例。我们创建一个文档<code>char_set.txt</code>并将一级字和二级字的内容全部复制进去。这份文档就是我们子集化的对照表。</p>
<p>接着我们需要下载一个字体子集化工具，这里使用的是Python中的<code>fonttools</code>库，它提供了许多工具(比如我们需要的<code>pyftsubset</code>)可以在命令行中执行子集化、字体转化字体操作。</p>
<p>我们安装一下这个库和对应的依赖（在这之前确保你的电脑上安装了<a href="https://link.juejin.cn?target=https%3A%2F%2Fpython.org" target="_blank" title="https://python.org" ref="nofollow noopener noreferrer">Python</a>和<code>pip</code>，后者一般官方安装会自带）</p>
<pre><code class="hljs language-bash" lang="bash">pip install fonttools brotli zopfli
</code></pre>
<p>然后找到我们字体包对应的文件夹，将原来的<code>char_set.txt</code>复制到该文件夹内，在该文件下打开终端，然后以<code>NotoSerifSC-Bold.ttf</code>为例，输入以下命令：</p>
<pre><code class="hljs language-bash" lang="bash">pyftsubset NotoSerifSC-Bold.ttf --output-file=NotoSerifSC-Bold.subset.woff2 --flavor=woff2 --text-file=char_set.txt --no-hinting --with-zopfli
</code></pre>
<p>过一会就能看到会输出一个<code>NotoSerifSC-Bold.subset.woff2</code>的文件。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e31a5317468648ab8666f6ec86283d40~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ2hhbmdZbw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765186563&amp;x-signature=o6r5Mtd%2BsLcloY5%2FQsM4bmOJpLg%3D" alt="font-pic-1.png" loading="lazy"/>
我们欣喜的发现这个文件的大小竟然只有<strong>980KB</strong>。至此，我们已经已经将压缩率达到了<strong>93%</strong>！到这一步，其实直接部署也并没有十分大问题，不过从加载进去到完全渲染，可能依然需要近十秒左右，我们依然还有优化空间。</p>
<h3 data-id="heading-4">分包处理实现动态加载</h3>
<p>这个方法是我阅读<a href="https://link.juejin.cn?target=https%3A%2F%2Fksw.design.donxj.com%2Fknowledge%2Fchinese-web-font-optimize" target="_blank" title="https://ksw.design.donxj.com/knowledge/chinese-web-font-optimize" ref="nofollow noopener noreferrer">这篇文章</a>了解到的，但是遗憾的是我并没有在自己的网站上实现，不过失败的尝试也让我去寻找其它的方法，最终找到适用本站的一种<strong>极限字体渲染</strong>的方法，比这三种的效果还要好。下面我依然简单介绍一下这个方法的原理，想更了解可以通过看到最后通过参考资料去进一步了解。</p>
<p>在2017年，Google Fonts团队提出切片字体，因为他们发现：绝大部分网站只需要加载CJK字体包的小部分内容即可覆盖大部分场景。基于适用频率统计，他们将字符分成多个切片，再按 Unicode 编码对剩余字符进行分类。</p>
<p>怎么理解呢？他其实就是把所有的字符分成许多个小集合，每个集合里面都包含一定数量的字符，在靠前的一些集合中，都是我们常用的汉字，越到后，字形越复杂，使用频率也越低。当网页需要加载字体文件时，它是以<strong>切片</strong>为单位加载的。这意味，只有当你需要用到某个片区的字符时，这个片区才会被加载。</p>
<p>这种方式的好处时，能够大大加快网站加载速率。我们不用每次都一次性把全部字符加载，而是<strong>按需加载</strong>。这项技术如今已经被Noto Sans字体全面采用。</p>
<p>但是我们需要本地部署的话，需要多费一点功夫。这里我们利用中文网字计划的在线分包网站来实现。</p>
<p>我们将需要的字体上传进行分包，可以观察到输出结果是一系列以哈希值命名的woff2文件。分包其实就是做切分，把每个切分后的区域都转化为一份体积极小的woff2文件。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4d74d36fce784ef48ff03f06680d25a0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ2hhbmdZbw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765186563&amp;x-signature=jg%2FtvRwkcXFE8L2PzZB93HgC3Dk%3D" alt="font-pic-2.png" loading="lazy"/>
下载压缩包，然后可以将里面的文件夹导入你的项目，并引用文件夹下的<code>result.css</code>即可。理论上，当网站需要加载渲染某个字体时，它会根据css里面的规则去寻找到对应的分包再下载。每个包的体积极小，网站加载的速度应该提升的很明显。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/daa091871ba343418bcf8008a5ac8098~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ2hhbmdZbw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765186563&amp;x-signature=ktJvicow%2F5P3McnFuDU%2FtJTv340%3D" alt="font-pic-3.png" loading="lazy"/></p>
<h2 data-id="heading-5">我的实践──将字符压缩到极限</h2>
<p>我的方法可以理解为子集化的一种，只不过我的做法更加的极端一些──<strong>只保留文章出现的字符</strong>！</p>
<p>根据统计结果，截止到这篇post发布，我的文章总共出现的所有字符数不到1200个（数据来源见下文），所以我们可以做的更激进一些，只需将文章出现的中文字符全部记录下来，制成一张专属于自己网站的字符表，然后在每次发布文章时动态更新，这样我们能够保证字体完整渲染，并且处于<strong>边界极限</strong>状态！</p>
<p>实现这个个性化字符表<code>char_set.txt</code>的核心是一个提取文章中文字符的算法。这部分我是通过Gemini生成了一个<code>update_lists.cpp</code>文件，他能够识别<code>_posts/</code>下面所有文章，并输出到根目录的<code>char_set.txt</code>中，你可以根据代码内容进行自定义的修改：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">/**
 * @file update_lists.cpp
 * @brief Scans Markdown files in /_posts/ and updates char_set.txt in root.
 * @author Gemini
 * @date 2025-11-28
 */</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;filesystem&gt;</span></span>
<span class="hljs-keyword">namespace</span> fs = std::filesystem;
<span class="hljs-keyword">namespace</span> char_collector {
<span class="hljs-type">const</span> std::string kRegistryFilename = <span class="hljs-string">"char_set.txt"</span>;
<span class="hljs-type">const</span> std::string kMarkdownExt = <span class="hljs-string">".md"</span>;

<span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> kCJKStart = <span class="hljs-number">0x4E00</span>;
<span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> kCJKEnd = <span class="hljs-number">0x9FFF</span>;

<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">NextUtf8Char</span><span class="hljs-params">(std::string::const_iterator&amp; it, 
                  <span class="hljs-type">const</span> std::string::const_iterator&amp; end, 
                  <span class="hljs-type">uint32_t</span>&amp; out_codepoint,
                  std::string&amp; out_bytes)</span> </span>{
  <span class="hljs-keyword">if</span> (it == end) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> c1 = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&gt;(*it);
  out_bytes.<span class="hljs-built_in">clear</span>();
  out_bytes += c1;
  <span class="hljs-keyword">if</span> (c1 &lt; <span class="hljs-number">0x80</span>) { out_codepoint = c1; it++; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; }
  <span class="hljs-keyword">if</span> ((c1 &amp; <span class="hljs-number">0xE0</span>) == <span class="hljs-number">0xC0</span>) {
    <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">distance</span>(it, end) &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> c2 = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&gt;(*(it + <span class="hljs-number">1</span>));
    out_codepoint = ((c1 &amp; <span class="hljs-number">0x1F</span>) &lt;&lt; <span class="hljs-number">6</span>) | (c2 &amp; <span class="hljs-number">0x3F</span>);
    out_bytes += *(it + <span class="hljs-number">1</span>); it += <span class="hljs-number">2</span>; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }
  <span class="hljs-keyword">if</span> ((c1 &amp; <span class="hljs-number">0xF0</span>) == <span class="hljs-number">0xE0</span>) {
    <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">distance</span>(it, end) &lt; <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> c2 = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&gt;(*(it + <span class="hljs-number">1</span>));
    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> c3 = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&gt;(*(it + <span class="hljs-number">2</span>));
    out_codepoint = ((c1 &amp; <span class="hljs-number">0x0F</span>) &lt;&lt; <span class="hljs-number">12</span>) | ((c2 &amp; <span class="hljs-number">0x3F</span>) &lt;&lt; <span class="hljs-number">6</span>) | (c3 &amp; <span class="hljs-number">0x3F</span>);
    out_bytes += *(it + <span class="hljs-number">1</span>); out_bytes += *(it + <span class="hljs-number">2</span>); it += <span class="hljs-number">3</span>; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }
  <span class="hljs-keyword">if</span> ((c1 &amp; <span class="hljs-number">0xF8</span>) == <span class="hljs-number">0xF0</span>) {
    <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">distance</span>(it, end) &lt; <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> c2 = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&gt;(*(it + <span class="hljs-number">1</span>));
    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> c3 = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&gt;(*(it + <span class="hljs-number">2</span>));
    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> c4 = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&gt;(*(it + <span class="hljs-number">3</span>));
    out_codepoint = ((c1 &amp; <span class="hljs-number">0x07</span>) &lt;&lt; <span class="hljs-number">18</span>) | ((c2 &amp; <span class="hljs-number">0x3F</span>) &lt;&lt; <span class="hljs-number">12</span>) | 
                    ((c3 &amp; <span class="hljs-number">0x3F</span>) &lt;&lt; <span class="hljs-number">6</span>) | (c4 &amp; <span class="hljs-number">0x3F</span>);
    out_bytes += *(it + <span class="hljs-number">1</span>); out_bytes += *(it + <span class="hljs-number">2</span>); out_bytes += *(it + <span class="hljs-number">3</span>); it += <span class="hljs-number">4</span>; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }
  it++; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}

<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsChineseChar</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> codepoint)</span> </span>{
  <span class="hljs-keyword">return</span> (codepoint &gt;= kCJKStart &amp;&amp; codepoint &lt;= kCJKEnd);
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">CharManager</span> {
 <span class="hljs-keyword">public</span>:
  <span class="hljs-built_in">CharManager</span>() = <span class="hljs-keyword">default</span>;

  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LoadExistingChars</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; filepath)</span> </span>{
    <span class="hljs-function">std::ifstream <span class="hljs-title">infile</span><span class="hljs-params">(filepath)</span></span>;
    <span class="hljs-keyword">if</span> (!infile.<span class="hljs-built_in">is_open</span>()) {
      
      std::cout &lt;&lt; <span class="hljs-string">"Info: "</span> &lt;&lt; filepath &lt;&lt; <span class="hljs-string">" not found or empty. Starting fresh."</span> &lt;&lt; std::endl;
      <span class="hljs-keyword">return</span>;
    }
    std::string line;
    <span class="hljs-keyword">while</span> (std::<span class="hljs-built_in">getline</span>(infile, line)) {
      <span class="hljs-built_in">ProcessString</span>(line, <span class="hljs-literal">false</span>);
    }
    std::cout &lt;&lt; <span class="hljs-string">"Loaded "</span> &lt;&lt; existing_chars_.<span class="hljs-built_in">size</span>() 
              &lt;&lt; <span class="hljs-string">" unique characters from "</span> &lt;&lt; filepath &lt;&lt; <span class="hljs-string">"."</span> &lt;&lt; std::endl;
  }

  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ScanDirectory</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; directory_path)</span> </span>{
    
    <span class="hljs-keyword">if</span> (!fs::<span class="hljs-built_in">exists</span>(directory_path)) {
        std::cerr &lt;&lt; <span class="hljs-string">"Error: Directory '"</span> &lt;&lt; directory_path &lt;&lt; <span class="hljs-string">"' does not exist."</span> &lt;&lt; std::endl;
        <span class="hljs-keyword">return</span>;
    }
    
    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; entry : fs::<span class="hljs-built_in">directory_iterator</span>(directory_path)) {
      <span class="hljs-keyword">if</span> (entry.<span class="hljs-built_in">is_regular_file</span>() &amp;&amp; 
          entry.<span class="hljs-built_in">path</span>().<span class="hljs-built_in">extension</span>() == kMarkdownExt) {
        <span class="hljs-built_in">ProcessFile</span>(entry.<span class="hljs-built_in">path</span>().<span class="hljs-built_in">string</span>());
      }
    }
  }

  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SaveNewChars</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; filepath)</span> </span>{
    <span class="hljs-keyword">if</span> (new_chars_list_.<span class="hljs-built_in">empty</span>()) {
      std::cout &lt;&lt; <span class="hljs-string">"No new Chinese characters found."</span> &lt;&lt; std::endl;
      <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-function">std::ofstream <span class="hljs-title">outfile</span><span class="hljs-params">(filepath, std::ios::app)</span></span>;
    <span class="hljs-keyword">if</span> (!outfile.<span class="hljs-built_in">is_open</span>()) {
      std::cerr &lt;&lt; <span class="hljs-string">"Error: Could not open "</span> &lt;&lt; filepath &lt;&lt; <span class="hljs-string">" for writing."</span> &lt;&lt; std::endl;
      <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; ch : new_chars_list_) {
      outfile &lt;&lt; ch;
    }
    std::cout &lt;&lt; <span class="hljs-string">"Successfully added "</span> &lt;&lt; new_chars_list_.<span class="hljs-built_in">size</span>() 
              &lt;&lt; <span class="hljs-string">" new characters to "</span> &lt;&lt; filepath &lt;&lt; std::endl;
  }

 <span class="hljs-keyword">private</span>:
  std::unordered_set&lt;std::string&gt; existing_chars_;
  std::vector&lt;std::string&gt; new_chars_list_;

  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ProcessFile</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; filepath)</span> </span>{
    <span class="hljs-function">std::ifstream <span class="hljs-title">file</span><span class="hljs-params">(filepath)</span></span>;
    <span class="hljs-keyword">if</span> (!file.<span class="hljs-built_in">is_open</span>()) <span class="hljs-keyword">return</span>;
    
    std::cout &lt;&lt; <span class="hljs-string">"Scanning: "</span> &lt;&lt; fs::<span class="hljs-built_in">path</span>(filepath).<span class="hljs-built_in">filename</span>().<span class="hljs-built_in">string</span>() &lt;&lt; std::endl;
    <span class="hljs-function">std::string <span class="hljs-title">content</span><span class="hljs-params">((std::istreambuf_iterator&lt;<span class="hljs-type">char</span>&gt;(file)), 
                         std::istreambuf_iterator&lt;<span class="hljs-type">char</span>&gt;())</span></span>;
    <span class="hljs-built_in">ProcessString</span>(content, <span class="hljs-literal">true</span>);
  }

  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ProcessString</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; content, <span class="hljs-type">bool</span> track_new)</span> </span>{
    <span class="hljs-keyword">auto</span> it = content.<span class="hljs-built_in">begin</span>();
    <span class="hljs-keyword">auto</span> end = content.<span class="hljs-built_in">end</span>();
    <span class="hljs-type">uint32_t</span> codepoint;
    std::string bytes;

    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">NextUtf8Char</span>(it, end, codepoint, bytes)) {
      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">IsChineseChar</span>(codepoint)) {
        <span class="hljs-keyword">if</span> (existing_chars_.<span class="hljs-built_in">find</span>(bytes) == existing_chars_.<span class="hljs-built_in">end</span>()) {
          existing_chars_.<span class="hljs-built_in">insert</span>(bytes);
          <span class="hljs-keyword">if</span> (track_new) {
            new_chars_list_.<span class="hljs-built_in">push_back</span>(bytes);
          }
        }
      }
    }
  }
};

} 

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
  char_collector::CharManager manager;
  manager.<span class="hljs-built_in">LoadExistingChars</span>(char_collector::kRegistryFilename);
  manager.<span class="hljs-built_in">ScanDirectory</span>(<span class="hljs-string">"_posts"</span>);
  manager.<span class="hljs-built_in">SaveNewChars</span>(char_collector::kRegistryFilename);
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>然后我们在终端编译一下再运行即可：</p>
<pre><code class="hljs language-bash" lang="bash">clang++ update_lists.cpp -o update_lists  &amp;&amp; ./update_lists
</code></pre>
<p>然后我们就会发现这张独属于本站的字符表生成了！🥳
<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/05ffd997f8564bad9d3bb99546a870e8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ2hhbmdZbw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765186563&amp;x-signature=WVMW7pygswbSVf%2BZJ%2FS1%2FG%2Ba0wA%3D" alt="font-pic-6.png" loading="lazy"/>
为了方便操作，我们把原始的ttf文件放入仓库的<code>/FontRepo/</code>下（最后记得在<code>.gitignore</code>添加这个文件夹！），然后稍微修改一下之前子集化的命令就可以了：</p>
<pre><code class="hljs language-bash" lang="bash">pyftsubset /FontRepo/NotoSerifSC-Bold.ttf --output-file=/assets/fonts/noto-serif-sc/NotoSerifSC-Bold.subset.woff2 --flavor=woff2 --text-file=char_set.txt --no-hinting --with-zopfli
</code></pre>
<p>可以看到，最终输出的文件只有200K！压缩率达到了98.5%！</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0b25f2bf538841908a3efd579697e8d8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ2hhbmdZbw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765186563&amp;x-signature=iUkbqnYTYnb3lNT6ZnMiBZtcw6M%3D" alt="font-pic-4.png" loading="lazy"/>
但是这个方法就像前面说的，处于字体渲染的边界。但凡多出一个字符表中的符号，那么这个字符就无法渲染，会回退到系统字体，看起来格外别扭。所以，在每次更新文章前，我们都需要运行一下<code>./update_lists</code>。此外，还存在一个问题，每次更新产生新的子集化文件时，都需要把旧的子集化文件删除，防止旧文件堆积。</p>
<p>这些过程十分繁琐而且耗费时间，所以我们可以写一个bash脚本来实现这个过程的自动化。我这里同样是求助了Gemini，写了一个<code>build_fonts.sh</code>：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-meta">#!/bin/bash</span>
<span class="hljs-built_in">set</span> -e  <span class="hljs-comment"># 遇到错误立即停止执行</span>

<span class="hljs-comment"># ================= 配置区域 =================</span>
<span class="hljs-comment"># 字体源文件目录</span>
SRC_DIR=<span class="hljs-string">"FontRepo"</span>
<span class="hljs-comment"># 字体输出目录</span>
OUT_DIR=<span class="hljs-string">"assets/fonts/noto-serif-sc"</span>
<span class="hljs-comment"># 字符列表文件</span>
CHAR_LIST=<span class="hljs-string">"char_set.txt"</span>
<span class="hljs-comment"># C++ 更新工具</span>
UPDATE_TOOL=<span class="hljs-string">"./updateLists"</span>

<span class="hljs-comment"># 确保输出目录存在</span>
<span class="hljs-keyword">if</span> [ ! -d <span class="hljs-string">"<span class="hljs-variable">$OUT_DIR</span>"</span> ]; <span class="hljs-keyword">then</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"创建输出目录: <span class="hljs-variable">$OUT_DIR</span>"</span>
    <span class="hljs-built_in">mkdir</span> -p <span class="hljs-string">"<span class="hljs-variable">$OUT_DIR</span>"</span>
<span class="hljs-keyword">fi</span>

<span class="hljs-comment"># ================= 第一步：更新字符表 =================</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"========================================"</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"&gt;&gt; [1/3] 正在更新字符列表..."</span>
<span class="hljs-keyword">if</span> [ -x <span class="hljs-string">"<span class="hljs-variable">$UPDATE_TOOL</span>"</span> ]; <span class="hljs-keyword">then</span>
    <span class="hljs-variable">$UPDATE_TOOL</span>
<span class="hljs-keyword">else</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"错误: 找不到可执行文件 <span class="hljs-variable">$UPDATE_TOOL</span> 或者没有执行权限。"</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"请尝试运行: chmod +x updateLists"</span>
    <span class="hljs-built_in">exit</span> 1
<span class="hljs-keyword">fi</span>
<span class="hljs-comment"># 检查 char_set.txt 是否成功生成</span>
<span class="hljs-keyword">if</span> [ ! -f <span class="hljs-string">"<span class="hljs-variable">$CHAR_LIST</span>"</span> ]; <span class="hljs-keyword">then</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"错误: <span class="hljs-variable">$CHAR_LIST</span> 未找到，字符表更新可能失败。"</span>
    <span class="hljs-built_in">exit</span> 1
<span class="hljs-keyword">fi</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"字符列表更新完成。"</span>
<span class="hljs-comment"># ================= 定义子集化处理函数 =================</span>
<span class="hljs-function"><span class="hljs-title">process_font</span></span>() {
    <span class="hljs-built_in">local</span> font_name=<span class="hljs-string">"<span class="hljs-variable">$1</span>"</span>    <span class="hljs-comment"># 例如: NotoSerifSC-Regular</span>
    <span class="hljs-built_in">local</span> input_ttf=<span class="hljs-string">"<span class="hljs-variable">$SRC_DIR</span>/<span class="hljs-variable">${font_name}</span>.ttf"</span>
    <span class="hljs-built_in">local</span> final_woff2=<span class="hljs-string">"<span class="hljs-variable">$OUT_DIR</span>/<span class="hljs-variable">${font_name}</span>.woff2"</span>
    <span class="hljs-built_in">local</span> temp_woff2=<span class="hljs-string">"<span class="hljs-variable">$OUT_DIR</span>/<span class="hljs-variable">${font_name}</span>.temp.woff2"</span>

    <span class="hljs-built_in">echo</span> <span class="hljs-string">"----------------------------------------"</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"正在处理字体: <span class="hljs-variable">$font_name</span>"</span>
    <span class="hljs-comment"># 检查源文件是否存在</span>
    <span class="hljs-keyword">if</span> [ ! -f <span class="hljs-string">"<span class="hljs-variable">$input_ttf</span>"</span> ]; <span class="hljs-keyword">then</span>
        <span class="hljs-built_in">echo</span> <span class="hljs-string">"错误: 源文件 <span class="hljs-variable">$input_ttf</span> 不存在！"</span>
        <span class="hljs-built_in">exit</span> 1
    <span class="hljs-keyword">fi</span>

    <span class="hljs-comment"># 2. 调用 fonttools (pyftsubset) 生成临时子集文件</span>
    <span class="hljs-comment"># 使用 --obfuscate-names 可以进一步减小体积，但这里只用基础参数以保证稳定性</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"正在生成子集 (TTF -&gt; WOFF2)..."</span>
    pyftsubset <span class="hljs-string">"<span class="hljs-variable">$input_ttf</span>"</span> \
        --flavor=woff2 \
        --text-file=<span class="hljs-string">"<span class="hljs-variable">$CHAR_LIST</span>"</span> \
        --output-file=<span class="hljs-string">"<span class="hljs-variable">$temp_woff2</span>"</span>
    <span class="hljs-comment"># 3. &amp; 4. 删除旧文件并重命名 (更新逻辑)</span>
    <span class="hljs-keyword">if</span> [ -f <span class="hljs-string">"<span class="hljs-variable">$temp_woff2</span>"</span> ]; <span class="hljs-keyword">then</span>
        <span class="hljs-keyword">if</span> [ -f <span class="hljs-string">"<span class="hljs-variable">$final_woff2</span>"</span> ]; <span class="hljs-keyword">then</span>
            <span class="hljs-built_in">echo</span> <span class="hljs-string">"删除旧文件: <span class="hljs-variable">$final_woff2</span>"</span>
            <span class="hljs-built_in">rm</span> <span class="hljs-string">"<span class="hljs-variable">$final_woff2</span>"</span>
        <span class="hljs-keyword">fi</span>
        
        <span class="hljs-built_in">echo</span> <span class="hljs-string">"重命名新文件: <span class="hljs-variable">$temp_woff2</span> -&gt; <span class="hljs-variable">$final_woff2</span>"</span>
        <span class="hljs-built_in">mv</span> <span class="hljs-string">"<span class="hljs-variable">$temp_woff2</span>"</span> <span class="hljs-string">"<span class="hljs-variable">$final_woff2</span>"</span>
        <span class="hljs-built_in">echo</span> <span class="hljs-string">"&gt;&gt;&gt; <span class="hljs-variable">$font_name</span> 更新成功！"</span>
    <span class="hljs-keyword">else</span>
        <span class="hljs-built_in">echo</span> <span class="hljs-string">"错误: 子集化失败，未生成目标文件。"</span>
        <span class="hljs-built_in">exit</span> 1
    <span class="hljs-keyword">fi</span>
}
<span class="hljs-comment"># ================= 第二步 &amp; 第三步：执行转换 =================</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"========================================"</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"&gt;&gt; [2/3] 开始字体子集化处理..."</span>
<span class="hljs-comment"># 处理 Regular 字体</span>
process_font <span class="hljs-string">"NotoSerifSC-Regular"</span>
<span class="hljs-comment"># 处理 Bold 字体</span>
process_font <span class="hljs-string">"NotoSerifSC-Bold"</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"========================================"</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"&gt;&gt; [3/3] 所有任务圆满完成！"</span>
</code></pre>
<p>如此一来，以后每次更新完文章，都只需要在终端输入<code>./build_fonts.sh</code>就可以完成字符提取、字体包子集化、清除旧字体包文件的过程了。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2ef48ff2a903442a930779b981b9fae7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ2hhbmdZbw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765186563&amp;x-signature=L%2F8VxkmLFV6H7mXsQzQUuw9n%2Fs4%3D" alt="font-pic-5.png" loading="lazy"/></p>
<h2 data-id="heading-6">一点感想</h2>
<p>在这之前另外讲个小故事，我尝试更换字体之前发现自定义的字体样式根本没有用，后来检查了很久，发现竟然是2个月前AI在我代码里加的一句<code>font-family:'Noto Serif SC'</code>,而刚好他修改的又是优先级最高的文件，所以后面怎么修改字体都没有用。所以有时候让AI写代码前最好先搞清除代码的地位i，并且<strong>做好为AI代码后果负全责</strong>的准备。</p>
<p>更改网站字体其实很多时候属于锦上添花的事情，因为很多读者其实并不会太在意网站的字体。但不幸的是我对细节比较在意，或者说有种敝帚自珍的感觉吧，想慢慢地把网站装饰得舒适一些，所以才总是花力气在一些细枝末节的事情上。更何况，我是懂一点点设计的，有时候看见一些非常丑的Interface心里是很难受的。尽管就像绝大部分人理解不了设计师在细节上的别有用心一样，绝大部分人也不会在意一个网站的字体如何，但是我自己的家，我想装饰地好看些，对我来说就满足了。</p>
<p>更不要说，如果不去折腾这些东西，怎么可能会有这篇文章呢？如果能够帮助到一些人，也算是在世界留下一点价值了。</p>
<h2 data-id="heading-7">参考资料及附录</h2>
<ol>
<li>
<p>参考资料</p>
<p>a. <a href="https://link.juejin.cn?target=https%3A%2F%2Fksw.design.donxj.com%2Fknowledge%2Fchinese-web-font-optimize" target="_blank" title="https://ksw.design.donxj.com/knowledge/chinese-web-font-optimize" ref="nofollow noopener noreferrer">网页中文字体加载速度优化</a></p>
<p>b. <a href="https://link.juejin.cn?target=https%3A%2F%2Fweb.dev%2Farticles%2Freduce-webfont-size%3Fhl%3Dzh-cn" target="_blank" title="https://web.dev/articles/reduce-webfont-size?hl=zh-cn" ref="nofollow noopener noreferrer">缩减网页字体大小</a></p>
<p>c. <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fwy-luke%2FAll-Chinese-Character-Set" target="_blank" title="https://github.com/wy-luke/All-Chinese-Character-Set" ref="nofollow noopener noreferrer">All-Chinese-Character-Set</a></p>
</li>
<li>
<p>让Gemini生成代码时的Prompt:</p>
</li>
</ol>
<pre><code class="hljs language-plaintext" lang="plaintext">---Prompt 1---
# 任务名称：创建脚本实现对字符的收集
请利用C++来完成一下任务要求：
1. 该脚本能够读取项目目录下的markdown文件，并且能够识别当中所有的中文字符，将该中文字符与`/char_test/GeneralUsedChars.txt`的字符表进行查重比较：
   若该字在表中存在，则跳过，处理下一个字；
   若不存在，则将该字添加到表中，然后继续处理下一个字符
2. 请设计一个高效的算法，尤其是在字符查重的过程中，你需要设计一个高效且准确率高的算法
3. 请注意脚本的通用性，你需要考虑到这个项目以后可能会继续增加更多的markdown文件，所以你不应该仅仅只是处理现有的markdown文件，还需要考虑到以后的拓展性
4. 如果可以的话，尽可能使用C++来实现，因为效率更高

---Prompt 2---
可以了，现在我要求你编写一个脚本以实现自动化，要求如下：
1. 脚本运行时，首先会调用项目根目录下的updateLists可执行文件，更新char_set.txt
2. 接着，脚本会调用fonttools工具，对路径在`/FontRepo/`下的两个文件进行ttf到woff2的子集化转化，其中这两个字体文件的名字分别为`NotoSerifSC-Regular.ttf`和`NotoSerifSC-Bold.ttf`。
3. 转化好的子集文件应该输出到 `/assets/fonts/noto-serif-sc/`文件夹下。
4. 将`/assets/fonts/noto-serif-sc/`文件夹下原本已经存在的两个字体文件`NotoSerifSC-Bold.woff2`和`NotoSerifSC-Regular.woff2`删除，然后将新得到子集化文件重新命名为这两个删除了的文件的名字。这一步相当于完成了字体文件的更新

请注意文件的命名，尤其是不要搞错字号，新子集文件和旧子集文件。
请注意在子集化步骤的bash命令，环境已经安装好fonttools及其对应依赖，你可以参考下面这个命令来使用，或者使用更好更稳定的用法：
pyftsubset &lt;path/to/ttf/file&gt; --flavor=woff2 --text-file=&lt;path/to/char_set.txt&gt; --output-file=&lt;the/subset/name&gt;
(再次注意输出路径)
</code></pre>
<ol start="3">
<li>最终实践效果(以<code>NotoSerifSC-Bold</code>为例)



































<table><thead><tr><th align="left">处理方式</th><th align="left">字体包体积</th><th align="left">压缩率</th></tr></thead><tbody><tr><td align="left">无处理</td><td align="left">14.462M</td><td align="left">0%</td></tr><tr><td align="left">格式转化</td><td align="left">5.776M</td><td align="left">60.06%</td></tr><tr><td align="left">子集化处理</td><td align="left">981K</td><td align="left">93.21%</td></tr><tr><td align="left">分包处理</td><td align="left">依据动态加载量而定</td><td align="left">无</td></tr><tr><td align="left">我的实践</td><td align="left">216K</td><td align="left">98.5%</td></tr></tbody></table>
</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Three.js 坐标系完全入门：从“你在哪”到“你爸在哪”都讲清楚了]]></title>    <link>https://juejin.cn/post/7578820431017574415</link>    <guid>https://juejin.cn/post/7578820431017574415</guid>    <pubDate>2025-12-01T09:43:10.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7578820431017574415" data-draft-id="7578683148210585652" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Three.js 坐标系完全入门：从“你在哪”到“你爸在哪”都讲清楚了"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2025-12-01T09:43:10.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="一千柯橘"/> <meta itemprop="url" content="https://juejin.cn/user/2010369939736343"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Three.js 坐标系完全入门：从“你在哪”到“你爸在哪”都讲清楚了
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2010369939736343/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    一千柯橘
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-01T09:43:10.000Z" title="Mon Dec 01 2025 09:43:10 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-01
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body cache result"><style>.markdown-body{position:relative;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:30px;margin-bottom:5px}.markdown-body h2{font-size:24px;display:inline-block;font-weight:700;background:#ef7060;color:#fff;padding:6px 8px 0 0;border-top-right-radius:6px;margin-right:2px;box-shadow:6px 3px 0 0 rgba(239,112,96,.2)}.markdown-body h2:before{content:" ";display:inline-block;width:8px}.markdown-body h2:after{content:" ";position:absolute;display:block;width:calc(100% - 50px);border-bottom:3px solid #ef7060}.markdown-body h3{font-size:18px;padding-bottom:0}.markdown-body h4{font-size:16px}.markdown-body h5{font-size:15px}.markdown-body h6{margin-top:5px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #3e3e3e;margin-top:32px;margin-bottom:32px;height:1px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:rgba(27,31,35,.05);color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:JetBranins Mono,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75;box-shadow:0 0 8px hsla(0,0%,43.1%,.45);border-radius:4px;margin:16px}.markdown-body pre:before{content:"";display:block;height:30px;width:100%;margin-bottom:-7px;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAdCAYAAABcz8ldAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAhgSURBVGhD7Zp7bBTHHcdn33t7vvOdzy+ITVKDU0xIKG2ABCPTRCCaUiEVKWoqRJuASAhCitRCVKSoalFUKZBiSmmFRRJKRUnUtIpo+aNqGgwoOCmuFUIRzxjwE4zte+97drYzztji8HPvtkit/PnH+n1397Tz+83vN/PbMZhmmmmm+d+BoX8n5diihcGqgFQf5vk6BMAskWUlw3GyFnIvtqWSf91w7mKC3npfOLX7wYeiIa6BBWCOLLFRF2NB0JvIOP/80YG+k2ev6S699b/OzOfKBW5l5KsgyC4DCFQDnpEAdE1goc/dlNPc/Up7P711UiYNSMuyxeUzZPnHgGHWh5XADEkSAcdiN+AnEXIBhBComgFU0/xQR+jnj51sOUMf9Z0NKyL8S9+JPBEN8zuCMrsqGOA5QWAAyzLAxe53HBeYFgJp1c5Cx33nyIfpV3e+22/Sx32nev/sMCgVnmM4bjOniAtZWQAsz315EfsGQQc4hgWcjHkCmOj1rheuNn95cXwmDMiVp5etC/D8m5FwUWVQUYYGPh6mZYFUOgsGVa1pXvOZzVT2jRuH54RM230jEuI3RcIiL4l4UkxAJmuD/riVsqD7ct2m9nep7BtVTbVfZ0uE/UIk+CQflAHDjf8+Lg6MldYATGpH3c/Ul7p3dWXppVGM6eElJSHmnQWPbSlRlN1lJcUBjqNRnwJZVQO3B5P/uq5rK1d90pakckFcaKp5UJHY92JR8YlwkUDVySEZfGfQdO7E7Z8s2HL9TSoXTPXRud9nA8IBqSwcZgWeqpPj6BYw7yTbXBN9q2v9lQEq5zBmWA8vWLCptCi4tzwW8RQMQlFQATPLSh6vCSh/plJBkMyQBHZfWYnkKRgEktEVpTJXERN2Xzo4ex2VC6K6qXYpF5b3ypVRT8EgcAERSJXRbwCBOTFzXblM5RxGBaRt+ZPYA+LO0mgxz5K1Ig+UgAzKIuGnz39z6S+olDeaibaXRsU1RUFvgx+GwTWgPCaDgMw2XXpr9gwq50XV0bkxJiYeEiNF5cwE5XsiOEkAUkXkUW51SSOVchjl8WKef604XFSRbzCGCYeCoESStv/p8QU1VPIM3knNDynctnBRfsEYhgSlNCIGgQv2UCkvGIHZgteMh1nBW9W4F16RAM6yDVV7amZTaYQcr59cuuhhWRTWBvAMLxQGeyFSHOLnh0MvUskz5RF+fbRYDEy0mZgqQYUHOLhr//b6rGoqeaLqQG0pw3PrBbyA+4EQUkRmhvgqNUfICUipKK4OKUqIJVPKB0jpEhjmWWp64jdbKmVZZNYogcJm493gsifOqhDyeh9GYR/FM7sW+DA5CKR0MSK3tvKZkpwB5gRE4tjFEr7RL0iWBGV51vHFCyupNGWWPqLgnoer9mtyEGSJAzwLllDTGzyznDjRN/CwOFkoFb4bm0eVIXICgpvdGoEvrF7fC89zfLkkeV5HbOhWiTwTpKYvCAJLGshRdXtKMKAWlyxq+MPQLk1h66g5RE5ABJYNFrqY3wvJklJRUKg5ZWLFXIA86yek2uDOPkBNb3CM5Pf7DL2QyIrUGiLH+xC5Bmmm/ARnHUhC6PnzxWDK0RH5HuIjZGy27erU9AZ0dTIWXyG+NpBBrSFySxZw220IqeUPFoS6jVAPNadM7yDsgNB1qOkLuAziMYIb1PQGA75wIaKGPyAb+9oF16g5RE5ALIQ+tSyLWoWDEAK6aXW3JlK9VJoyx1oyvVkNdvo5KXXDAVkdnaKmNwx0xjH98w3JNmTCm+Bc9hKVhsgJSI9pvp9Vdd++jmq6AXB2/HHrhcs5aTkVDv0DFzoHvKdq/mQsKX/4t7KJLDpOJW+IbAvMGoMkxfwAWZB8DT7W1diTE+WcgKz6pK1bs6z3daPwmJDsSKt6ZsCyjlLJMz0DsDGZ8SdlDROBjOb8YeWOjptU8kTXusuaazu7oJrfEnQvdkpVcUn6PTVHyAkIIW7br/Unklni0EJIZ1WgGsauZR+fvUglz6zY0dGfVp09ybRNlfwgi3k8YSbvJJ29VMoLt9v6rZVQL7hOYUubndHJGclBtzn1byqNMCogi09/2nFb01/oj+f/5TyjauBOKtPcZ1r7qZQ3f2lRfxZPWi2anp8TSDAGExZMa2jr8u03L1M5L7q3Xc+iAeuHRl/ScvPcjSLDBnZS/cjtNHd2v3171Ewbs9N5q7Pn4otVMx3btBsCsoRbk1FxG5dMVgMDqfTpXl1/tuFMa5zKefPROdX59qLQBwLnNog8Wy1OcjB1N+QEsW/QsFNZuO35Xb1v98QLX4/Sx+O3wqujrQ6013ABUWI8+AaqBjAH01+ghL22+5X2PirnMG7r+esbnae/V1neauvGSoHjigTcVU7UGFm2DeK4ttxKpQ+mLPvl+o/PjnkAkw9HTqSMmVHhyAMx9iFcSh/BHTfLceO/C8mKjApBf9zszGhoY92m9sN+BGOY9AeD7eGniv8OTaOB4dgyTsQd9wS+IQu4lciYdkI7CLrNH3Rvbb9FL41i0tbzVP2iWJkobpN5fmM4IJfJskTP1Bk8A9HQmbpmGDBrWqdVCN/Yd7PjxKGOXn+bmbto3feVVcVB9qehIL8EJy8nChwgr0O2xxBnhGU5eP2CfYbl/m4gBRsbtneMORP9oGpjpcCsiKzHHfdOPiQ/wMniyFEu2dbiTQCAeN/vavC466BGYLttXc9fmXBXMGlAhiHHur+sq6uPiUI9z7CVHMPwBnLSuuN8FuC48/Oaz1ylt94XfrW5ouyprwWfYRkwNyCyYYjwkBHows1fa+tV/fzGxlv39b9gqvfPmQ+i/HK8KlcBjhHwfl8HEHyOd1JnuzZd66S3TTPNNNP8/wDAfwDG7G0m9LKBpwAAAABJRU5ErkJggg==) 10px 10px no-repeat;background-size:40px;background-color:#fdfdfd}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#fdfdfd}.markdown-body a{text-decoration:none;font-weight:700;color:#ef7060;border-bottom:1px solid #ef7060}.markdown-body a:active,.markdown-body a:hover{color:#ef2d26}.markdown-body table tr td,.markdown-body table tr th{border:1px solid #ccc;padding:5px 10px}.markdown-body table{display:block!important;width:auto;max-width:100%;overflow:auto;border-collapse:collapse}.markdown-body thead{background:#f0f0f0;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#f8f8f8}.markdown-body blockquote{margin-inline-start:0;margin-inline-end:0;border-left:3px solid #ef7060;background:#fff9f9;padding:1px 20px;margin-top:20px}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="atelier-sulphurpool-dark">.hljs-comment,.hljs-quote{color:#898ea4}.hljs-attribute,.hljs-link,.hljs-name,.hljs-regexp,.hljs-selector-class,.hljs-selector-id,.hljs-tag,.hljs-template-variable,.hljs-variable{color:#c94922}.hljs-built_in,.hljs-builtin-name,.hljs-literal,.hljs-meta,.hljs-number,.hljs-params,.hljs-type{color:#c76b29}.hljs-bullet,.hljs-string,.hljs-symbol{color:#ac9739}.hljs-section,.hljs-title{color:#3d8fd1}.hljs-keyword,.hljs-selector-tag{color:#6679cc}.markdown-body pre,.markdown-body pre&gt;code.hljs{background:#202746;color:#979db4}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>当你打开 Three.js 写 3D 场景时，第一个要搞懂的问题就是：</p>
<p><strong>一个物体到底摆在哪里？</strong></p>
<p>别小看这个问题。你觉得一个立方体在世界坐标 (3,0,0)，结果它移动后出现在奇怪的位置，十次里有九次是因为——</p>
<p>👉 <strong>你忘了它有个“爸爸”。</strong></p>
<p>今天我们就用一个超通俗的方式，把 Three.js 的坐标讲清楚。看完这篇文章，你会明白：</p>
<ul>
<li>世界坐标（World Coordinates）和本地坐标（Local Coordinates）到底怎么回事？
<ul>
<li>世界坐标，基准点为固定原点(0,0,0)，描述物体在<strong>整个场景中的绝对位置</strong></li>
<li>局部/本地坐标，基准点为物体自身的几何中心（中心点），描述子物体相对于<strong>父物体的位置</strong></li>
</ul>
</li>
<li>子对象相对于父对象的坐标是怎么计算的？</li>
<li>为什么把 cube 放进 parentCube 后，位置就“变了”？</li>
<li>实战代码是如何运行的？</li>
</ul>
<p>准备好了吗？开始！</p>
<hr/>
<h2 data-id="heading-0">🧱 1. 世界坐标：整个世界的“绝对地址”</h2>
<p>在 Three.js 中，有一个你永远逃不掉的概念：</p>
<blockquote>
<p><strong>世界坐标（World Coordinates）就是所有物体的绝对位置。</strong></p>
</blockquote>
<p>比如：</p>
<pre><code class="hljs language-js" lang="js">cube.<span class="hljs-property">position</span>.<span class="hljs-title function_">set</span>(<span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
scene.<span class="hljs-title function_">add</span>(cube);
</code></pre>
<p>意思很简单：</p>
<blockquote>
<p>cube 在世界的 x=3 的位置。</p>
</blockquote>
<p>就像你告诉朋友：“我在北京”。</p>
<p>无论你爸在哪，你都在北京。</p>
<h2 data-id="heading-1">👨‍👦 2. 本地坐标：相对于“父元素”的位置</h2>
<p>但如果你写了：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> parentCube = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Mesh</span>(geometry, parentMaterial);
parentCube.<span class="hljs-title function_">add</span>(cube);
</code></pre>
<p>事情就不一样了。</p>
<p>cube 就有了一个“爸爸” parentCube。</p>
<p>此时你再写：</p>
<pre><code class="hljs language-js" lang="js">cube.<span class="hljs-property">position</span>.<span class="hljs-title function_">set</span>(<span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
scene.<span class="hljs-title function_">add</span>(parentCube);
</code></pre>
<p>这句话就变成：</p>
<blockquote>
<p>cube 在 <strong>parentCube 的局部空间中</strong>，相对于父物体，往 x 正方向移动 3。</p>
</blockquote>
<p>也就是说：</p>
<ul>
<li>parentCube 就像一个<strong>坐标参照系</strong>。</li>
<li>cube 相当于在这个内部空间里移动。</li>
</ul>
<p>这就好比你说：</p>
<blockquote>
<p>“我离我爸三米远。”</p>
</blockquote>
<p>但你爸在北京，你也就实际上<strong>还是在北京附近</strong>。</p>
<h2 data-id="heading-2">⚙️ 3. 回到你的示例：它到底发生了什么？</h2>
<p>你写的代码如下：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> cube = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Mesh</span>(geometry, material);

<span class="hljs-keyword">const</span> parentCube = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Mesh</span>(geometry, parentMaterial);
parentCube.<span class="hljs-title function_">add</span>(cube);
parentCube.<span class="hljs-property">position</span>.<span class="hljs-title function_">set</span>(-<span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);

<span class="hljs-comment">// cube.position.x = 1;</span>
<span class="hljs-comment">// cube 的坐标是相对于 parentCube 的，所以在页面上可以看到 cube 相对于 parentCube（父元素）向右移动到了原点坐标处</span>
cube.<span class="hljs-property">position</span>.<span class="hljs-title function_">set</span>(<span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
</code></pre>
<p>让我们逐步理解发生了什么。</p>
<h3 data-id="heading-3">🟦 第一步：parentCube 放在世界坐标 (-3,0,0)</h3>
<p>这意味着：</p>
<blockquote>
<p>“爸爸站在世界左边 3 单位的位置。”</p>
</blockquote>
<h3 data-id="heading-4">🟦 第二步：cube 相对“爸爸”往右移动 3 个单位</h3>
<p>cube.position.set(3,0,0) 的意思是：</p>
<blockquote>
<p>cube 在父对象内部向右移动 3。</p>
</blockquote>
<p>也就是说：</p>
<p>👉 <strong>cube 的世界坐标 = 父对象世界坐标 + 自己的本地坐标</strong></p>
<p>计算一下：</p>
<ul>
<li>父对象在世界: (-3, 0, 0)</li>
<li>cube 在本地: (+3, 0, 0)</li>
</ul>
<p>所以 cube 在世界中的真实位置：</p>
<pre><code class="hljs language-js" lang="js">世界位置 = (-<span class="hljs-number">3</span>) + <span class="hljs-number">3</span> = <span class="hljs-number">0</span>
</code></pre>
<p>——刚好回到了世界原点！🎯</p>
<p>这就是你看到：</p>
<blockquote>
<p>cube “看起来回到了原点”。</p>
</blockquote>
<h2 data-id="heading-5">🎯 4. 一个超形象的比喻：三.js 坐标 = 现实世界的“你”和“你爸”</h2>
<ul>
<li><strong>世界坐标</strong>：你住在北京就是北京，这是全世界都懂的绝对坐标。</li>
<li><strong>本地坐标</strong>：你说“我离我爸三米远”，那你得先知道你爸在哪。</li>
<li><strong>父对象移动时，子对象跟着被整体移动</strong>：因为你爸挪窝了，你当然也跟着挪了。</li>
</ul>
<p>这就是 parent.add(child) 的意义：</p>
<blockquote>
<p><strong>你把 child 的命运交给了 parent。</strong></p>
</blockquote>
<hr/>
<h2 data-id="heading-6">🧪 5. 实战代码：一眼看懂坐标关系</h2>
<p>完整例子如下：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 父立方体</span>
<span class="hljs-keyword">const</span> parentCube = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Mesh</span>(geometry, parentMaterial);
scene.<span class="hljs-title function_">add</span>(parentCube);
parentCube.<span class="hljs-property">position</span>.<span class="hljs-title function_">set</span>(-<span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);

<span class="hljs-comment">// 子立方体</span>
<span class="hljs-keyword">const</span> cube = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Mesh</span>(geometry, material);
parentCube.<span class="hljs-title function_">add</span>(cube);

<span class="hljs-comment">// cube 不是在世界坐标移动，而是在父坐标系中移动</span>
cube.<span class="hljs-property">position</span>.<span class="hljs-title function_">set</span>(<span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
</code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/95b131c9d0fa47788f4eb75ae8976c74~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiA5Y2D5p-v5qmY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765186989&amp;x-signature=omf32FmH9zi5Zbgy9%2BD%2BIJot%2B2w%3D" alt="image.png" loading="lazy"/></p>
<p>运行后你会看到：</p>
<ul>
<li>parentCube 在世界左边 (-3,0,0)</li>
<li>cube 在 parentCube 内部向右移动 3( cube 的参考点变成了 parentCube)</li>
<li>所以 cube 的世界位置被“抵消掉”，回到原点</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[同事：架构太复杂了，源码文件找半天。 我：源码溯源了解一下？]]></title>    <link>https://juejin.cn/post/7578460753210966043</link>    <guid>https://juejin.cn/post/7578460753210966043</guid>    <pubDate>2025-12-01T09:52:18.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7578460753210966043" data-draft-id="7578511778889416742" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="同事：架构太复杂了，源码文件找半天。 我：源码溯源了解一下？"/> <meta itemprop="keywords" content="前端,Vue.js"/> <meta itemprop="datePublished" content="2025-12-01T09:52:18.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="独角仙梦境"/> <meta itemprop="url" content="https://juejin.cn/user/1176897909428464"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            同事：架构太复杂了，源码文件找半天。 我：源码溯源了解一下？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1176897909428464/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    独角仙梦境
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-01T09:52:18.000Z" title="Mon Dec 01 2025 09:52:18 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-01
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读12分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body cache result"><style>.markdown-body{color:#595959;font-size:15px;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(60,10,30,.04) 3%,transparent 0),linear-gradient(1turn,rgba(60,10,30,.04) 3%,transparent 0);background-size:20px 20px;background-position:50%}.markdown-body p{color:#595959;font-size:15px;line-height:2;font-weight:400}.markdown-body p+p{margin-top:16px}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{padding:30px 0;margin:0;color:#135ce0}.markdown-body h1{position:relative;text-align:center;font-size:22px;margin:50px 0}.markdown-body h1:before{position:absolute;content:"";top:-10px;left:50%;width:32px;height:32px;transform:translateX(-50%);background-size:100% 100%;opacity:.36;background-repeat:no-repeat;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABfVBMVEX///8Ad/8AgP8AgP8AgP8Aff8AgP8Af/8AgP8AVf8Af/8Af/8AgP8AgP8Af/8Afv8AAP8Afv8Afv8Aef8AgP8AdP8Afv8AgP8AgP8Acf8Ae/8AgP8Af/8AgP8Af/8Af/8AfP8Afv8AgP8Af/8Af/8Afv8Afv8AgP8Afv8AgP8Af/8Af/8AgP8AgP8Afv8AgP8Af/8AgP8AgP8AgP8Ae/8Afv8Af/8AgP8Af/8AgP8Af/8Af/8Aff8Af/8Abf8AgP8Af/8AgP8Af/8Af/8Afv8AgP8AgP8Afv8Afv8AgP8Af/8Aff8AgP8Afv8AgP8Aff8AgP8AfP8AgP8Ae/8AgP8Af/8AgP8AgP8AgP8Afv8AgP8AgP8AgP8Afv8AgP8AgP8AgP8AgP8AgP8Af/8AgP8Af/8Af/8Aev8Af/8AgP8Aff8Afv8AgP8AgP8AgP8Af/8AgP8Af/8Af/8AgP8Afv8AgP8AgP8AgP8AgP8Af/8AeP8Af/8Af/8Af//////rzEHnAAAAfXRSTlMAD7CCAivatxIDx5EMrP19AXdLEwgLR+6iCR/M0yLRzyFF7JupSXn8cw6v60Q0QeqzKtgeG237HMne850/6Qeq7QaZ+WdydHtj+OM3qENCMRYl1B3K2U7wnlWE/mhlirjkODa9FN/BF7/iNV/2kASNZpX1Wlf03C4stRGxgUPclqoAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEaBzgZ4yeM3AAAAT9JREFUOMvNUldbwkAQvCAqsSBoABE7asSOBRUVVBQNNuy9996789+9cMFAMHnVebmdm+/bmdtbQv4dOFOW2UjPzgFyLfo6nweKfIMOBYWwFtmMPGz2Yj2pJI0JDq3udJW6VVbmKa9I192VQFV1ktXUAl5NB0cd4KpnORqsEO2ZIRpF9gJfE9Dckqq0KuZt7UAH5+8EPF3spjsRpCeQNO/tA/qDwIDA+OCQbBoKA8NOdjMySgcZGVM6jwcgRuUiSs0nlPFNSrEpJfU0jTLD6llqbvKxei7OzvkFNQohi0vAsj81+MoqsCaoPOQFgus/1LyxichW+hS2JWCHZ7VlF9jb187pIAYcHiViHAMnp5mTjJ8B5xeEXF4B1ze/fTh/C0h398DDI9HB07O8ci+vRBdvdGnfP4gBuM8vw7X/G3wDmFhFZEdxzjMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDEtMjZUMDc6NTY6MjUrMDE6MDA67pVWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAxLTI2VDA3OjU2OjI1KzAxOjAwS7Mt6gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAWdEVYdFRpdGxlAGp1ZWppbl9sb2dvIGNvcHlxapmKAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC)}.markdown-body h2{position:relative;font-size:20px;border-left:4px solid;padding:0 0 0 10px;margin:30px 0}.markdown-body h3{font-size:16px}.markdown-body ul{list-style:disc outside;margin-left:2em;margin-top:1em}.markdown-body li{line-height:2;color:#595959}.markdown-body img.loaded{margin:0 auto;display:block}.markdown-body blockquote{background:#fff9f9;margin:2em 0;padding:2px 20px;border-left:4px solid #b2aec5}.markdown-body blockquote p{color:#666;line-height:2}.markdown-body a{color:#036aca;border-bottom:1px solid rgba(3,106,202,.8);font-weight:400;text-decoration:none}.markdown-body em strong,.markdown-body strong{color:#036aca}.markdown-body hr{border-top:1px solid #135ce0}.markdown-body pre{overflow:auto}.markdown-body code,.markdown-body pre{overflow:auto;position:relative;line-height:1.75;font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body table{border-collapse:collapse;margin:1rem 0;overflow-x:auto}.markdown-body table td,.markdown-body table th{border:1px solid #dfe2e5;padding:.6em 1em}.markdown-body table tr{border-top:1px solid #dfe2e5}.markdown-body table tr:nth-child(2n){background-color:#f6f8fa}</style><style data-highlight="" data-highlight-key="a11y-light">.hljs-comment,.hljs-quote{color:#696969}.hljs-deletion,.hljs-name,.hljs-regexp,.hljs-selector-class,.hljs-selector-id,.hljs-tag,.hljs-template-variable,.hljs-variable{color:#d91e18}.hljs-attribute,.hljs-built_in,.hljs-builtin-name,.hljs-link,.hljs-literal,.hljs-meta,.hljs-number,.hljs-params,.hljs-type{color:#aa5d00}.hljs-addition,.hljs-bullet,.hljs-string,.hljs-symbol{color:green}.hljs-section,.hljs-title{color:#007faa}.hljs-keyword,.hljs-selector-tag{color:#7928a1}.markdown-body pre,.markdown-body pre&gt;code.hljs{background:#fefefe;color:#545454}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}@media screen and (-ms-high-contrast:active){.hljs-addition,.hljs-attribute,.hljs-built_in,.hljs-builtin-name,.hljs-bullet,.hljs-comment,.hljs-link,.hljs-literal,.hljs-meta,.hljs-number,.hljs-params,.hljs-quote,.hljs-string,.hljs-symbol,.hljs-type{color:highlight}.hljs-keyword,.hljs-selector-tag{font-weight:700}}</style><h2 data-id="heading-0">背景</h2>
<hr/>
相信刚入行，或是刚入行的小伙伴们，对于企业级代码与架构，以及扑面而来业务需求。想要在短时间内从对应的页面定位到组件时，是很难办到的事情，尤其是突然交给一个陌生的项目的需求，问题也会比较突出。
<p>尤其是对于鼠鼠我本人来说，也是深有体会：司内的源码架构：<strong>自研微前端+monorepo架构</strong>，本身架构设计本身就比较复杂，在项目规模达到一定程度，或是项目开发时间长，人员变动大，就会导致有很多问题出现，就比如ld统计过 <strong>.vue文件</strong>已经8000个了，代码中有<strong>2250对</strong>重复的源代码文件。总计重复代码行数: <strong>69578</strong> <strong>行</strong> 🤯🤯🤯</p>
<p>在这样的情况下，一款能够快速定位源码的插件呼之欲出🎉🎉🎉</p>
<hr/>
通过本篇文章，大家能学习到：
<blockquote>
<ol>
<li>如何编写一个简易的vite插件</li>
<li>vite插件的生命周期是怎么样的</li>
<li>源码溯源，快速定位：<strong>实现思路，原理</strong></li>
</ol>
</blockquote>
<p>首先准备好实验环境：<strong>vue+vite+pnpm</strong> 让cursor快速生成一个项目即可</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3a20b5707c55461790fa9c0155245445~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg54us6KeS5LuZ5qKm5aKD:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765187538&amp;x-signature=mc1XxAvuLNjn6U9q%2FIkK3Xa7DQo%3D" alt="image.png" loading="lazy"/></p>
<p>在正式将<strong>源码定位</strong>之前，我想讲讲一个简易的vite插件该如何实现，这对我们后面的学习会有比较有效的帮助</p>
<h2 data-id="heading-1">如何写Vite插件</h2>
<p>再讲如何编写vite插件之前，需要先了解一下如何将自己编写的vite插件在Vite的构建流程中生效：</p>
<p>Vite插件本质是一个对象，通过到处一个对象函数，放入Vite配置项数组中即可实现效果：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0ce09192b6324b73b5673d7543a5881e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg54us6KeS5LuZ5qKm5aKD:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765187538&amp;x-signature=Qn5FgGQ0LzTGBmX7jmXJeYS2GvQ%3D" alt="" loading="lazy"/></p>
<p>在配置文件中：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/46d4f73c560740debcb791fff45fa8ca~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg54us6KeS5LuZ5qKm5aKD:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765187538&amp;x-signature=l2wHfQQXBVarVVkQfa%2BZ6lJ%2BDJU%3D" alt="" loading="lazy"/></p>
<p>那么作为Vite的自定义插件，和webpack一样，需要使用各种生命周期钩子，才能实现对应的效果：</p>
<p>这里介绍一下主流的生命周期钩子：</p>
<h3 data-id="heading-2">主流钩子</h3>
<h4 data-id="heading-3">配置阶段：</h4>
<p><strong>config(config,</strong> <strong>env</strong> <strong>):</strong></p>
<ul>
<li>
<p><strong>触发时机：当vite读取配置时触发</strong></p>
</li>
<li>
<p><strong>常用场景：修改或扩展配置对象</strong></p>
</li>
</ul>
<p><strong>configResolved(resolvedConfig):</strong></p>
<ul>
<li>
<p><strong>触发时机：当配置解析完成时触发</strong></p>
</li>
<li>
<p><strong>常用场景：获取最终配置，初始化插件状态</strong></p>
</li>
</ul>
<blockquote>
<p>该阶段主要用于插件初始化或读取用户配置，不是必须</p>
</blockquote>
<h4 data-id="heading-4">构建阶段</h4>
<p><strong>buildStart:</strong></p>
<ul>
<li>
<p><strong>触发时机： 构建开始</strong></p>
</li>
<li>
<p><strong>常用场景： 初始化状态，打印日志，准备数据</strong></p>
</li>
</ul>
<p><strong>buildEnd:</strong></p>
<ul>
<li>
<p><strong>触发时机： 构建结束</strong></p>
</li>
<li>
<p><strong>常用场景：收尾，打印统计</strong></p>
</li>
</ul>
<p><strong>closeBundle：</strong></p>
<ul>
<li>
<p><strong>触发时机：构建完成并生成文件后</strong></p>
</li>
<li>
<p><strong>常用场景：做最终清理或发布的操作</strong></p>
</li>
</ul>
<blockquote>
<p>主要用于插件需要做全局初始化或构建后操作的场景</p>
</blockquote>
<h4 data-id="heading-5">模块解析和加载阶段</h4>
<p><strong>resolveId(id,importer)</strong></p>
<ul>
<li>
<p><strong>触发时机：解析模块路径时</strong></p>
</li>
<li>
<p><strong>常用场景：重写模块路径，生成虚拟模块</strong></p>
</li>
</ul>
<p><strong>load(id)</strong></p>
<ul>
<li>
<p><strong>触发时机：模块加载内容</strong></p>
</li>
<li>
<p><strong>常用场景：返回模块代码，生成虚拟模块</strong></p>
</li>
</ul>
<p><strong>moduleParsed</strong></p>
<ul>
<li>
<p><strong>触发时机：模块</strong> <strong>AST</strong> <strong>解析完成</strong></p>
</li>
<li>
<p><strong>常用场景：分析模块</strong> <strong>AST</strong> <strong>，做统计或收集信息</strong></p>
</li>
</ul>
<blockquote>
<p>核心点：虚拟模块一般用 <code>resolveId</code> + <code>load</code>，处理源码前可以分析 AST。</p>
</blockquote>
<h4 data-id="heading-6">模块transform阶段（最常用）</h4>
<p><strong>thransform(code,id)</strong></p>
<ul>
<li>
<p><strong>触发时机：模块加载后，打包前</strong></p>
</li>
<li>
<p><strong>常用场景：核心 hook，用于修改</strong> <strong>源码</strong> <strong>、注入代码、操作 Vue/</strong> <strong>JSX</strong> ****<strong>AST</strong></p>
</li>
</ul>
<p><strong>transformIndexHtml</strong></p>
<ul>
<li>
<p><strong>触发时机：</strong> <strong>HTML</strong> <strong>文件处理阶段</strong></p>
</li>
<li>
<p><strong>常用场景：修改</strong> <strong>HTML</strong> <strong>模版，例如注入script，link</strong></p>
</li>
</ul>
<blockquote>
<p><strong>transform 是最主流的钩子</strong>，几乎所有插件都至少用它做一次源码修改。</p>
</blockquote>
<p>整个构建生命周期流程图来看是这样的：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d7a3e9a791bf451f88e39234129420f0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg54us6KeS5LuZ5qKm5aKD:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765187538&amp;x-signature=ZbajEJepcO4Cmb9WXaGNYuv21o8%3D" alt="image.png" loading="lazy"/></p>
<p>针对LLM返回给我们的主流钩子使用频率来看，我们优先掌握的肯定就是：<strong>模块 transform 阶段</strong>，因为这个阶段是能够直接接触的源代码，更容易在源代码上动手脚的阶段。</p>
<h3 data-id="heading-7"><strong>模块 transform 阶段</strong></h3>
<p>好记性不如烂笔头，让我们实战来看看，这个阶段能够做什么呢？</p>
<h4 data-id="heading-8">什么是transform阶段</h4>
<p>在Vite的构建过程中，一个文件会从<strong>源码</strong> <strong>-&gt; 浏览器</strong>可执行文件，会经历很多处理环节。比如：</p>
<ul>
<li>TS-&gt; js</li>
<li>JSX -&gt; JS</li>
<li>VUE单文件组件拆成JS，CSS</li>
<li>去掉console.log</li>
<li>注入HMR代码</li>
<li>压缩</li>
</ul>
<p><strong>而 transform 就是 Vite 插件体系里专门负责“把代码转成新代码”的阶段</strong>。</p>
<h4 data-id="heading-9">transform的函数签名</h4>
<pre><code class="hljs language-js" lang="js"><span class="hljs-title function_">transform</span>(<span class="hljs-params">code, id</span>) {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">code</span>: <span class="hljs-string">'新的代码'</span>,
    <span class="hljs-attr">map</span>: <span class="hljs-literal">null</span>, <span class="hljs-comment">// 或 sourcemap</span>
  }
}
</code></pre>
<ol>
<li><strong>Code： 当前拿到的文件</strong> <strong>源码</strong></li>
<li><strong>id：当前文件的绝对路径</strong></li>
</ol>
<p><strong>返回值：</strong></p>
<ol>
<li>返回一个字符串：</li>
</ol>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">return</span> transformedCode
</code></pre>
<p>说明只<strong>修改了代码</strong>，不管 source map，由 Vite 自动处理部分情况。</p>
<p>⚠️ 但 source map 会丢失或错误。</p>
<ol start="2">
<li>返回一个包含code+map的对象</li>
</ol>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">return</span> {
  <span class="hljs-attr">code</span>: transformedCode,
  <span class="hljs-attr">map</span>: <span class="hljs-literal">null</span>  <span class="hljs-comment">// 或 SourceMap 对象</span>
}
</code></pre>
<ul>
<li>Vite 会继续把 map 传给下一环</li>
<li>最终映射会合并到 browser source map</li>
<li>对 HMR Debug 友好</li>
</ul>
<p>若map为null时，让vite自己处理</p>
<ol start="3">
<li>返回为null或undefined</li>
</ol>
<ul>
<li>表示我不处理这个模块，让下个插件处理。即：<strong>跳过这个阶段的</strong></li>
</ul>
<h4 data-id="heading-10">何时会触发transform</h4>
<ol>
<li><strong>开发（</strong> <strong>dev</strong> <strong>server）</strong> ：Vite 在浏览器请求模块时，先 <code>resolveId</code> → <code>load</code>（读文件）→ <code>transform</code> → 返回给浏览器（并缓存结果）。</li>
<li><strong>构建（build）</strong> ：Rollup 打包流程，Vite 基于 Rollup 插件接口执行，顺序类似：<code>resolveId</code> → <code>load</code> → <code>transform</code> → 打包。</li>
<li>对于 SFC（例如 Vue 单文件组件），一个 <code>.vue</code> 会被拆成多个请求（script/template/style），每个子模块都会走 <code>transform</code>，因此你会看到同一个文件被多次 <strong>transform</strong>（通过 <code>id</code> 的 query 区分）。</li>
</ol>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/321133fe4e2947f1b361c6e62b8bfb22~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg54us6KeS5LuZ5qKm5aKD:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765187538&amp;x-signature=V8Lr04AKUg8SO3FQt%2BnwBSEiURs%3D" alt="image.png" loading="lazy"/></p>
<h2 data-id="heading-11">源码溯源</h2>
<h3 data-id="heading-12">为什么需要源码溯源插件</h3>
<p>谈到为什么需要<strong>源码</strong> <strong>溯源</strong>。就得提到司内的源码架构：<strong>自研微前端+monorepo架构</strong>，本身架构设计本身就比较复杂，在项目规模达到一定程度，或是项目开发时间长，人员变动大，就会导致有很多问题出现，就比如ld统计过 <strong>.vue文件</strong>已经8000个了，代码中有<strong>2250对</strong>重复的源代码文件。总计重复代码行数: <strong>69578</strong> <strong>行，</strong> 所以我们拟设计一款Vite插件配合油猴脚本，能够识别一个页面的所有组件，通过click，能够快速定位到对应的component。</p>
<h3 data-id="heading-13">设计思路是什么？</h3>
<h5 data-id="heading-14">目标：</h5>
<p>我们想要实现一个<strong>所见即所得</strong>模式，即能够清楚的看到一个页面由哪些组件组成，并且可以看到对应的组件渲染了页面的哪些地方，并且点击对应模块后，能够立马弹出组件对应的绝对路径，方便直接去寻找到对应的组件。</p>
<p>具体体现成什么样呢？这里起一个简单的小项目给大家看看</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/582218925347425e9c1110ec0d497eac~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg54us6KeS5LuZ5qKm5aKD:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765187538&amp;x-signature=JwU5ihukifeHnO6rgwpZ6Bl0exU%3D" alt="image.png" loading="lazy"/></p>
<p>是一个很简单的小架构，当我们想要知道头部组件在对应源代码的哪个位置时，我们点击他：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b08897ca2430454193cd425dee446eb1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg54us6KeS5LuZ5qKm5aKD:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765187538&amp;x-signature=OXBGZLNAZg6fdAIyS9xoGQx%2BE10%3D" alt="image.png" loading="lazy"/></p>
<p>第一个就是头部组件对应的组件路径，下面的就是其父组件，方便我们了解嵌套关系。</p>
<h5 data-id="heading-15">具体思路：</h5>
<p>首先我们需要知道一件事情，浏览器最后渲染的内容，拿到的源文件是经过<strong>构建工具的转译，压缩，打包</strong>后的<strong>源代码</strong>，与自己实际开发是天壤之别，所以针对<strong>打包后的源代码溯源</strong>是不切实际的。所以我们的思路是：</p>
<ol>
<li>需要在构建阶段，针对<strong>对应文件</strong>进行处理</li>
<li>具体处理就是将对应文件的<strong>绝对路径</strong>，通过某些方式，在构建后，<strong>保存到</strong> <strong>源代码</strong></li>
<li>再通过<strong>油猴插件</strong>，在浏览器中执行脚本，该脚本核心代码就是提取到点击模块对应的保存的绝对路径进行转译渲染出来，成为图片中的样式。</li>
</ol>
<h5 data-id="heading-16">具体实现：</h5>
<ol>
<li>
<p>编写自定义vite插件，插件用处：在每个组件的根元素中添加自定义属性，内容为该文件绝对路径的编码形式存储在此。</p>
</li>
<li>
<p>将根元素的自定义属性值广播到子组件的类型中，任何你想点击/调试的元素都带有足够的信息</p>
</li>
<li>
<p>编写js脚本，核心在于提取到点击对应元素，能够快速识别转译出路径，并渲染到弹窗。</p>
</li>
</ol>
<h4 data-id="heading-17">vite插件如何编写？</h4>
<p>在编写插件前，我们需要明确我们插件需要做什么：</p>
<ul>
<li><strong>每个Vue文件中的根元素，添加对应的自定义属性，属性值填的是对应路径的编码。</strong></li>
</ul>
<p>那么针对这个需求，我们首先需要分析，<strong>要使用哪个生命周期钩子才能实现对应的效果？</strong></p>
<p>搜索过后，发现<strong>thransform(code,id)</strong> 这个钩子能够帮助我们实现我们想要的效果。</p>
<blockquote>
<p>transform 是 Vite 插件体系里的编译钩子。每当 Vite 正在加载某个模块（无论是 .ts、.vue 还是别的可处理资源），都会把“源代码字符串 + 模块 id（含绝对路径/查询参数）”传进每个插件的 <strong>transform(code, id)</strong> ，让插件有机会在官方编译器运行前对<strong>源码</strong> <strong>做一次改写、替换或分析</strong>。</p>
</blockquote>
<p>最后效果如下：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bb8299cdafe74635ad2b2d2a0407c7f6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg54us6KeS5LuZ5qKm5aKD:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765187538&amp;x-signature=%2Fyw5M7SN3jO7IzrquvkvV%2FHvcrA%3D" alt="image.png" loading="lazy"/></p>
<p>具体源代码实现：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">cscMark</span>(<span class="hljs-params"/>): <span class="hljs-title class_">Plugin</span> {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'csc-mark'</span>,
    <span class="hljs-attr">enforce</span>: <span class="hljs-string">'pre'</span>,
    <span class="hljs-title function_">transform</span>(<span class="hljs-params">code, id</span>) {
      <span class="hljs-keyword">if</span> (!id.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">'.vue'</span>)) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }

      <span class="hljs-keyword">const</span> { template } = <span class="hljs-title function_">parse</span>(code, { <span class="hljs-attr">filename</span>: id }).<span class="hljs-property">descriptor</span>;

      <span class="hljs-keyword">if</span>(template) {
        <span class="hljs-keyword">const</span> elm = template.<span class="hljs-property">ast</span>.<span class="hljs-property">children</span>.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">type</span> === <span class="hljs-title class_">NodeTypes</span>.<span class="hljs-property">ELEMENT</span>) <span class="hljs-keyword">as</span> <span class="hljs-title class_">ElementNode</span> | <span class="hljs-literal">undefined</span>;
        <span class="hljs-keyword">if</span>(elm) {
          <span class="hljs-keyword">const</span> tagString = <span class="hljs-string">`&lt;<span class="hljs-subst">${elm.tag}</span>`</span>;

          <span class="hljs-keyword">const</span> insertIndex = elm.<span class="hljs-property">loc</span>.<span class="hljs-property">source</span>.<span class="hljs-title function_">indexOf</span>(tagString) + tagString.<span class="hljs-property">length</span>;
          <span class="hljs-keyword">const</span> newSource
              = <span class="hljs-string">`<span class="hljs-subst">${elm.loc.source.slice(<span class="hljs-number">0</span>, insertIndex)}</span> csc-mark="<span class="hljs-subst">${LZString.compressToBase64(id)}</span>"<span class="hljs-subst">${elm.loc.source.slice(insertIndex)}</span>`</span>;
  
          code = code.<span class="hljs-title function_">replace</span>(elm.<span class="hljs-property">loc</span>.<span class="hljs-property">source</span>, newSource);
        }
      }

      <span class="hljs-keyword">return</span> code;
    }
  };
}
</code></pre>
<ol>
<li>
<p>遍历每个vue组件</p>
</li>
<li>
<p>获得<strong>code</strong>里面<strong>template</strong>的内容</p>
</li>
<li>
<p>通过ast拿到根元素：<strong>elm</strong></p>
</li>
<li>
<p>通过<strong>LZString.compressToBase64(</strong> <em><strong>id</strong></em> <strong>)</strong> 将<strong>绝对路径</strong>赋值进去。注：该钩子参数id就是遍历该文件的绝对路径</p>
</li>
<li>
<p>返回新代码给后续编译构建使用</p>
</li>
</ol>
<h4 data-id="heading-18">如何将路径广播到子组件？</h4>
<p>我们需要有个钩子，能够在上述标签打完之后，再逐一遍历该文件内的其他组件。将编码后的id注入class中。那么哪个钩子能够实习这种功能呢？</p>
<p>经过调研后发现：</p>
<p>Vue插件中，有个钩子能够帮助我们</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(<span class="hljs-function">(<span class="hljs-params">{ mode }</span>) =&gt;</span> ({
  <span class="hljs-attr">plugins</span>: [<span class="hljs-title function_">vue</span>({
    <span class="hljs-attr">template</span>: {
      <span class="hljs-attr">compilerOptions</span>: {
          <span class="hljs-attr">nodeTransforms</span>: [
              自己编写的函数
          ],
      },
  },
  }),<span class="hljs-title function_">cscMark</span>() ],
  <span class="hljs-attr">resolve</span>: {
    <span class="hljs-attr">alias</span>: {
      <span class="hljs-string">'@'</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">'src'</span>)
    }
  },
  <span class="hljs-attr">server</span>: {
    <span class="hljs-attr">host</span>: <span class="hljs-string">'0.0.0.0'</span>,
    <span class="hljs-attr">port</span>: <span class="hljs-number">4173</span>,
    <span class="hljs-attr">open</span>: <span class="hljs-literal">true</span>
  },
  <span class="hljs-attr">define</span>: {
    <span class="hljs-attr">__APP_ENV__</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(mode)
  }
}));
</code></pre>
<p>用法：</p>
<blockquote>
<p>在编译<strong>模板</strong>时，对每个 <strong><strong>AST</strong> <strong>节点</strong>执行自己编写的特定函数</strong></p>
</blockquote>
<p>🌰</p>
<pre><code class="hljs language-js" lang="js">&lt;template&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">csc-mark</span>=<span class="hljs-string">"路径1"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">ks-dialog</span>&gt;</span>弹窗<span class="hljs-tag">&lt;/<span class="hljs-name">ks-dialog</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
&lt;/template&gt;
</code></pre>
<p>Vue插件编译器会解析：</p>
<ol>
<li>读取.vue文件</li>
<li>解析 template 部分</li>
<li>生成 AST（抽象语法树）</li>
</ol>
<p>最后生成：</p>
<pre><code class="hljs language-matlab" lang="matlab">ROOT (<span class="hljs-built_in">type</span>: <span class="hljs-number">0</span>)
  └── &lt;div&gt; (ELEMENT, <span class="hljs-built_in">type</span>: <span class="hljs-number">1</span>)
       ├── <span class="hljs-built_in">csc</span>-mark=<span class="hljs-string">"路径1"</span> (ATTRIBUTE)
       ├── &lt;h1&gt; (ELEMENT, <span class="hljs-built_in">type</span>: <span class="hljs-number">1</span>)
       │    └── <span class="hljs-string">"标题"</span> (TEXT)
       └── &lt;ks-dialog&gt; (ELEMENT, <span class="hljs-built_in">type</span>: <span class="hljs-number">1</span>)
            └── <span class="hljs-string">"弹窗"</span> (TEXT)
</code></pre>
<p>Vue 编译器会深度优先遍历 AST，对每个节点调用自定义的函数。</p>
<p><strong>那这个自定义函数该如何去进行编写呢？</strong></p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">cscMarkNodeTransform</span> = (<span class="hljs-params">node, context</span>) =&gt; {
  <span class="hljs-keyword">if</span> (node.<span class="hljs-property">type</span> === <span class="hljs-title class_">NodeTypes</span>.<span class="hljs-property">ELEMENT</span> &amp;&amp; context.<span class="hljs-property">parent</span>) {
      <span class="hljs-keyword">if</span> ([<span class="hljs-title class_">NodeTypes</span>.<span class="hljs-property">ROOT</span>, <span class="hljs-title class_">NodeTypes</span>.<span class="hljs-property">IF_BRANCH</span>].<span class="hljs-title function_">includes</span>(context.<span class="hljs-property">parent</span>.<span class="hljs-property">type</span>)) {
          <span class="hljs-keyword">const</span> firstElm = context.<span class="hljs-property">parent</span>.<span class="hljs-property">children</span>.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">type</span> === <span class="hljs-title class_">NodeTypes</span>.<span class="hljs-property">ELEMENT</span>) <span class="hljs-keyword">as</span> <span class="hljs-title class_">ElementNode</span> | <span class="hljs-literal">undefined</span>;
          <span class="hljs-keyword">const</span> addText = firstElm &amp;&amp; firstElm.<span class="hljs-property">props</span>.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">name</span> === <span class="hljs-string">'csc-mark'</span>)?.<span class="hljs-property">value</span>?.<span class="hljs-property">content</span> || <span class="hljs-string">''</span>;

          <span class="hljs-keyword">if</span> (addText) {
                  <span class="hljs-title function_">addClass</span>(node, addText, <span class="hljs-string">'class'</span>);
          }
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (context.<span class="hljs-property">parent</span>.<span class="hljs-property">props</span>?.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">name</span> === <span class="hljs-string">'csc-mark'</span>)?.<span class="hljs-property">value</span>?.<span class="hljs-property">content</span>) {
          <span class="hljs-keyword">const</span> addText = context.<span class="hljs-property">parent</span>.<span class="hljs-property">props</span>.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">name</span> === <span class="hljs-string">'csc-mark'</span>)?.<span class="hljs-property">value</span>?.<span class="hljs-property">content</span> || <span class="hljs-string">''</span>;
          <span class="hljs-keyword">if</span> (addText) {
                  <span class="hljs-title function_">addClass</span>(node, addText, <span class="hljs-string">'class'</span>);
          }
      }

  }
};
</code></pre>
<ol>
<li>在 <strong>cscMarkNodeTransform</strong> 中，只有当当前 node 是 <strong>NodeTypes.ELEMENT</strong> 且存在 <strong>context.parent</strong> 时才会继续处理，避免对非元素节点或无父节点的情况做多余操作</li>
<li>当父节点是 ROOT 或 IF_BRANCH 时，会查找父节点的<strong>首个子元素</strong>，读取其 <strong>csc-mark 属性</strong>的内容，并将该内容通过 addClass 加在当前节点的 class 上，从而把<strong>顶层 csc-mark</strong> 标记扩散到具体元素。</li>
<li>如果父节点本身带有 <strong>csc-mark</strong> 属性，就直接读取父节点的该属性内容并同样调用 addClass，以确保<strong>嵌套元素</strong> <strong>继承</strong> <strong>父级 csc-mark 定义的类名</strong>。</li>
</ol>
<p><strong>页面效果呈现：</strong></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c6ac3b0c3cc645c39f177539b3eea138~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg54us6KeS5LuZ5qKm5aKD:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765187538&amp;x-signature=%2FnMOne5YXo14YLFgX%2F20VtMfghk%3D" alt="image.png" loading="lazy"/></p>
<h4 data-id="heading-19">油猴脚本编写：</h4>
<p>脚本作用：</p>
<ol>
<li>添加检查button，只有点击button时，才会开启溯源功能</li>
<li>点击后高亮所有带有css-vite-mark-类名的元素</li>
<li>点击元素时，收集并显示嵌套组件及组件绝对路径</li>
</ol>
<p><strong>核心代码</strong>及<strong>解释</strong></p>
<p>1.组件层次结构的收集：</p>
<ul>
<li>这个函数从点击的元素开始<strong>向上遍历DOM树</strong>，收集所有<strong>带有标记的父元素</strong>，构建组件层次结构。</li>
</ul>
<pre><code class="hljs language-js" lang="js"> <span class="hljs-comment">// 函数：收集从顶层到当前元素的 csc-mark 属性列表</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">collectCscMarkHierarchy</span>(<span class="hljs-params">element</span>) {
        <span class="hljs-keyword">let</span> cscMarkList = [];
        <span class="hljs-keyword">while</span> (element) {
            <span class="hljs-keyword">if</span> (element.<span class="hljs-title function_">hasAttribute</span>(<span class="hljs-string">'csc-mark'</span>)) {
                cscMarkList.<span class="hljs-title function_">push</span>({ element, <span class="hljs-attr">mark</span>: element.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">'csc-mark'</span>) });
            }
            element = element.<span class="hljs-property">parentElement</span>;
        }
        <span class="hljs-keyword">return</span> cscMarkList;
    }
</code></pre>
<p>2.路径解码：</p>
<p>这部分代码从类名中提取压缩的路径部分，然后使用<strong>LZString.decompressFromBase64</strong>解码还原为实际<strong>绝对路径。</strong></p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 处理源码路径部分代码</span>
cssMarkList.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> {
    <span class="hljs-keyword">const</span> tag = item.<span class="hljs-property">element</span>.<span class="hljs-property">tagName</span>.<span class="hljs-title function_">toLowerCase</span>();
    <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">const</span> encodedPath = item.<span class="hljs-property">originMark</span>.<span class="hljs-title function_">substring</span>(prefix.<span class="hljs-property">length</span>);
        <span class="hljs-keyword">const</span> filePath = <span class="hljs-title class_">LZString</span>.<span class="hljs-title function_">decompressFromBase64</span>(encodedPath);
        decodedPaths.<span class="hljs-title function_">push</span>({ tag, filePath });
    } <span class="hljs-keyword">catch</span> (e) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'解码路径失败:'</span>, e);
    }
});
</code></pre>
<p>3.交互机制</p>
<p>用户点击该元素时，收集组件嵌套，并渲染对话框</p>
<pre><code class="hljs language-js" lang="js"> <span class="hljs-comment">// 函数：处理点击事件并显示 csc-mark 层级</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span>(<span class="hljs-params">event</span>) {
        <span class="hljs-keyword">let</span> element = event.<span class="hljs-property">target</span>;
  
        <span class="hljs-comment">// 遍历 DOM 树查找最近的具有 csc-mark 属性的祖先元素</span>
        <span class="hljs-keyword">while</span> (element &amp;&amp; !element.<span class="hljs-title function_">hasAttribute</span>(<span class="hljs-string">'csc-mark'</span>)) {
            element = element.<span class="hljs-property">parentElement</span>;
        }
  
        <span class="hljs-keyword">if</span> (element &amp;&amp; element.<span class="hljs-title function_">hasAttribute</span>(<span class="hljs-string">'csc-mark'</span>)) {
            event.<span class="hljs-title function_">stopPropagation</span>();
            event.<span class="hljs-title function_">preventDefault</span>();
            <span class="hljs-keyword">const</span> cscMarkList = <span class="hljs-title function_">collectCscMarkHierarchy</span>(element);
            <span class="hljs-title function_">showCustomDialog</span>(cscMarkList);
        }
    }
  
</code></pre>
<h4 data-id="heading-20">具体使用流程:</h4>
<ol>
<li>启动开发服务器</li>
<li>通过油猴插件添加脚本</li>
</ol>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9526d72be85c4a04b270f7625acfaac1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg54us6KeS5LuZ5qKm5aKD:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765187538&amp;x-signature=boZrNTpW3JlEzFpYg8gxKnr6Njw%3D" alt="image.png" loading="lazy"/>
3. 点击<strong>inspect</strong>按钮</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1fb14f0175874a229470db62f90a2d3c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg54us6KeS5LuZ5qKm5aKD:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765187538&amp;x-signature=x4qQrzRhdF%2Bf8tKwOmk%2FcyUJHSg%3D" alt="image.png" loading="lazy"/></p>
<ol start="4">
<li>之后想要修改哪个模块就可以进行点击</li>
</ol>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6394b3023b154cec916b3322b698aa48~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg54us6KeS5LuZ5qKm5aKD:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765187538&amp;x-signature=Ngu5AQxBvTRPl0QazqshYguI3Vg%3D" alt="image.png" loading="lazy"/></p>
<p>⚠️使用该油猴脚本时需要注意匹配到你对应的项目路径</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ad4fe5559d364485b093d71999f2384d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg54us6KeS5LuZ5qKm5aKD:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765187538&amp;x-signature=0kvG6X6F%2Bsjlv0GtYJPXYXMSk60%3D" alt="image.png" loading="lazy"/></p>
<h2 data-id="heading-21">总结：</h2>
<p>通过上述方法可以实现一个简易的源码定位系统了，能够帮助我们在很多复杂项目中快速定位到自己需要修改的模块所对应的，通过这么一个比较小的需求，能够快速帮助大家对<strong>vite的生命周期</strong>，以及<strong>自定义插件</strong>，<strong>油猴插件</strong>的基本使用，有个较为清晰的了解。综合性比较强，需求完成后对大家的开发效率也会有很大的提升，大家感兴趣的可以进我的github上看对应的插件源码和脚本代码：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fhjj5201%2Fvite-plugin" target="_blank" title="https://github.com/hjj5201/vite-plugin" ref="nofollow noopener noreferrer">溯源代码</a></p>
<p><strong>扩展点：</strong></p>
<ol>
<li>如何在<strong>webpack</strong>上，通过编写对应插件，实现相应的功能</li>
<li>目前只能够在页面上知道对应模块使用的组件，<strong>不知道这个组件能够对应哪个页面</strong></li>
<li>可以修改一些样式，让整体更加美观</li>
<li>一步到位，点击<strong>对应模块能够自动跳转的编辑器中</strong></li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[CesiumLite-在三维地图中绘制3D图形变得游刃有余]]></title>    <link>https://juejin.cn/post/7578705123208134699</link>    <guid>https://juejin.cn/post/7578705123208134699</guid>    <pubDate>2025-12-01T09:53:23.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7578705123208134699" data-draft-id="7578667193320964159" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="CesiumLite-在三维地图中绘制3D图形变得游刃有余"/> <meta itemprop="keywords" content="前端,GIS,cesium"/> <meta itemprop="datePublished" content="2025-12-01T09:53:23.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="LukeSuperCoder"/> <meta itemprop="url" content="https://juejin.cn/user/88395458549383"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            CesiumLite-在三维地图中绘制3D图形变得游刃有余
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/88395458549383/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    LukeSuperCoder
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-01T09:53:23.000Z" title="Mon Dec 01 2025 09:53:23 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-01
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body cache result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">🎯 告别重复造轮子！CesiumLite 实体管理模块让3D图形开发效率翻倍</h2>
<blockquote>
<p>本文深入介绍 CesiumLite 的实体管理模块，从开发痛点到封装原理，再到实战应用，带你全面了解如何优雅地管理 Cesium 三维实体。</p>
</blockquote>
<h3 data-id="heading-1">📌 前言</h3>
<p>在使用 Cesium.js 开发三维地图应用时，实体（Entity）的创建和管理是最常见的需求之一。无论是标注点位、绘制建筑轮廓，还是展示三维模型，都离不开实体的操作。</p>
<p>然而，Cesium 原生 API 虽然功能强大，但在实际开发中却存在不少痛点。本文将通过 <strong>CesiumLite</strong> 项目的实体管理模块，展示如何优雅地解决这些问题。</p>
<h3 data-id="heading-2">🎨 在线演示</h3>
<p>项目提供了完整的功能演示页面，你可以访问以下链接查看实际效果：</p>
<p><strong><a href="https://link.juejin.cn?target=https%3A%2F%2Flukesupercoder.github.io%2Fcesium-lite%2Fexamples%2Fentity.html" target="_blank" title="https://lukesupercoder.github.io/cesium-lite/examples/entity.html" ref="nofollow noopener noreferrer">在线演示</a></strong></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6b45fb82a55e40c1bcf104343142c6db~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTHVrZVN1cGVyQ29kZXI=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765187603&amp;x-signature=3oJiOtCfGcpW6W7v7SwNDytbp6M%3D" alt="image.png" loading="lazy"/>
<strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FlukeSuperCoder%2Fcesium-lite" target="_blank" title="https://github.com/lukeSuperCoder/cesium-lite" ref="nofollow noopener noreferrer">项目地址</a></strong></p>
<p>演示页面包含以下功能：</p>
<ul>
<li>🔹 多边形面</li>
<li>🔹 盒子模型</li>
<li>🔹 矩形</li>
<li>🔹 球体</li>
<li>🔹 椭圆形</li>
<li>🔹 圆柱</li>
<li>🔹 线段</li>
<li>🔹 管道（PolylineVolume）</li>
<li>🔹 走廊</li>
<li>🔹 墙体</li>
</ul>
<h3 data-id="heading-3">🚫 开发痛点分析</h3>
<h4 data-id="heading-4">痛点 1：实体创建过于繁琐</h4>
<p>使用 Cesium 原生 API 创建一个简单的多边形，需要这样写：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 创建一个多边形实体</span>
<span class="hljs-keyword">const</span> entity = viewer.<span class="hljs-property">entities</span>.<span class="hljs-title function_">add</span>({
  <span class="hljs-attr">polygon</span>: {
    <span class="hljs-attr">hierarchy</span>: <span class="hljs-title class_">Cesium</span>.<span class="hljs-property">Cartesian3</span>.<span class="hljs-title function_">fromDegreesArray</span>([
      -<span class="hljs-number">109.080842</span>, <span class="hljs-number">45.002073</span>,
      -<span class="hljs-number">104.058488</span>, <span class="hljs-number">45.002073</span>,
      -<span class="hljs-number">104.053011</span>, <span class="hljs-number">41.003906</span>,
      -<span class="hljs-number">105.728954</span>, <span class="hljs-number">41.003906</span>,
    ]),
    <span class="hljs-attr">height</span>: <span class="hljs-number">5000</span>,
    <span class="hljs-attr">material</span>: <span class="hljs-title class_">Cesium</span>.<span class="hljs-property">Color</span>.<span class="hljs-property">BLUE</span>.<span class="hljs-title function_">withAlpha</span>(<span class="hljs-number">0.5</span>),
    <span class="hljs-attr">outline</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">outlineColor</span>: <span class="hljs-title class_">Cesium</span>.<span class="hljs-property">Color</span>.<span class="hljs-property">BLACK</span>,
  }
});

<span class="hljs-comment">// 如果需要定位到该实体</span>
viewer.<span class="hljs-title function_">zoomTo</span>(entity);
</code></pre>
<p><strong>问题在于：</strong></p>
<ul>
<li>每次创建都要重复写 <code>viewer.entities.add()</code></li>
<li>没有统一的实体 ID 管理机制</li>
<li>定位功能需要单独调用</li>
<li>实体更新和删除操作分散</li>
</ul>
<h4 data-id="heading-5">痛点 2：实体生命周期管理混乱</h4>
<p>当项目中实体数量增多时，管理变得复杂：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 需要手动维护实体引用</span>
<span class="hljs-keyword">const</span> entities = [];
entities.<span class="hljs-title function_">push</span>(viewer.<span class="hljs-property">entities</span>.<span class="hljs-title function_">add</span>({ <span class="hljs-comment">/* ... */</span> }));
entities.<span class="hljs-title function_">push</span>(viewer.<span class="hljs-property">entities</span>.<span class="hljs-title function_">add</span>({ <span class="hljs-comment">/* ... */</span> }));

<span class="hljs-comment">// 更新某个实体？需要先找到它</span>
<span class="hljs-keyword">const</span> targetEntity = entities.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> e.<span class="hljs-property">id</span> === <span class="hljs-string">'someId'</span>);
<span class="hljs-keyword">if</span> (targetEntity) {
  targetEntity.<span class="hljs-property">polygon</span>.<span class="hljs-property">material</span> = <span class="hljs-title class_">Cesium</span>.<span class="hljs-property">Color</span>.<span class="hljs-property">RED</span>;
}

<span class="hljs-comment">// 删除某个实体？</span>
viewer.<span class="hljs-property">entities</span>.<span class="hljs-title function_">remove</span>(targetEntity);

<span class="hljs-comment">// 清空所有？</span>
viewer.<span class="hljs-property">entities</span>.<span class="hljs-title function_">removeAll</span>(); <span class="hljs-comment">// 这会删除所有实体，包括其他模块创建的！</span>
</code></pre>
<p><strong>问题在于：</strong></p>
<ul>
<li>实体引用分散，难以统一管理</li>
<li>查找、更新、删除操作繁琐</li>
<li>清空操作会影响其他模块</li>
<li>缺乏命名空间隔离</li>
</ul>
<h4 data-id="heading-6">痛点 3：代码复用性差</h4>
<p>每个项目都要重新实现相似的功能：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 项目 A</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ProjectAEntityManager</span> {
  <span class="hljs-title function_">addPolygon</span>(<span class="hljs-params">options</span>) { <span class="hljs-comment">/* ... */</span> }
  <span class="hljs-title function_">removePolygon</span>(<span class="hljs-params">id</span>) { <span class="hljs-comment">/* ... */</span> }
}

<span class="hljs-comment">// 项目 B</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ProjectBEntityController</span> {
  <span class="hljs-title function_">createEntity</span>(<span class="hljs-params">config</span>) { <span class="hljs-comment">/* ... */</span> }
  <span class="hljs-title function_">deleteEntity</span>(<span class="hljs-params">entityId</span>) { <span class="hljs-comment">/* ... */</span> }
}

<span class="hljs-comment">// 项目 C - 又要重新写一遍...</span>
</code></pre>
<p><strong>问题在于：</strong></p>
<ul>
<li>每个项目都在造轮子</li>
<li>没有统一的最佳实践</li>
<li>维护成本高，bug 重复出现</li>
</ul>
<h3 data-id="heading-7">💡 CesiumLite 的解决方案</h3>
<h4 data-id="heading-8">核心设计思路</h4>
<p>CesiumLite 的实体管理模块采用了以下设计思路：</p>
<ol>
<li><strong>双层封装架构</strong>：<code>EntityManager</code> + <code>EntityWrapper</code></li>
<li><strong>独立数据源隔离</strong>：使用 <code>CustomDataSource</code> 避免污染全局实体集合</li>
<li><strong>统一 ID 管理</strong>：自动生成唯一 ID，支持自定义</li>
<li><strong>链式操作支持</strong>：提供流畅的 API 调用体验</li>
</ol>
<h4 data-id="heading-9">架构设计图</h4>
<pre><code class="hljs">┌─────────────────────────────────────────┐
│          CesiumLite 核心类              │
│  ┌───────────────────────────────────┐  │
│  │      EntityManager 管理器         │  │
│  │  - 统一管理所有实体               │  │
│  │  - 独立 CustomDataSource          │  │
│  │  - 提供增删改查接口               │  │
│  │                                   │  │
│  │  ┌─────────────────────────────┐ │  │
│  │  │   EntityWrapper 实体包装器  │ │  │
│  │  │  - 封装单个实体             │ │  │
│  │  │  - 自动生成唯一 ID          │ │  │
│  │  │  - 提供更新方法             │ │  │
│  │  └─────────────────────────────┘ │  │
│  └───────────────────────────────────┘  │
│                  ↓                       │
│  ┌───────────────────────────────────┐  │
│  │      Cesium Viewer 实例           │  │
│  └───────────────────────────────────┘  │
└─────────────────────────────────────────┘
</code></pre>
<h3 data-id="heading-10">🔧 核心代码实现</h3>
<h4 data-id="heading-11">1. EntityWrapper：实体包装器</h4>
<p><code>EntityWrapper</code> 负责封装单个实体，提供统一的操作接口：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Entity</span>, createGuid } <span class="hljs-keyword">from</span> <span class="hljs-string">'cesium'</span>;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">EntityWrapper</span> {
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">options = {}</span>) {
        <span class="hljs-comment">// 自动生成唯一 ID，也支持自定义</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> = options.<span class="hljs-property">id</span> || <span class="hljs-title function_">createGuid</span>();
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>({}, options);
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">entity</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entity</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>);
    }

    <span class="hljs-comment">// 更新实体属性</span>
    <span class="hljs-title function_">update</span>(<span class="hljs-params">options</span>) {
        <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>, options);
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">entity</span>.<span class="hljs-title function_">update</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>);
    }

    <span class="hljs-comment">// 获取原生 Cesium 实体</span>
    <span class="hljs-title function_">getEntity</span>(<span class="hljs-params"/>) {
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">entity</span>;
    }
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">EntityWrapper</span>;
</code></pre>
<p><strong>设计亮点：</strong></p>
<ul>
<li>✅ 自动生成唯一 ID，避免冲突</li>
<li>✅ 保存实体配置，方便后续更新</li>
<li>✅ 提供 <code>getEntity()</code> 方法，保持原生 API 的兼容性</li>
</ul>
<h4 data-id="heading-12">2. EntityManager：实体管理器</h4>
<p><code>EntityManager</code> 是实体管理的核心，提供完整的生命周期管理：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">CustomDataSource</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'cesium'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">EntityWrapper</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./entityWrapper'</span>;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">EntityManager</span> {
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">viewer</span>) {
        <span class="hljs-keyword">if</span> (!viewer) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Viewer instance is required'</span>);
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">viewer</span> = viewer;

        <span class="hljs-comment">// 创建独立的数据源，实现命名空间隔离</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">dataSource</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomDataSource</span>(<span class="hljs-string">'entityManager'</span>);
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">viewer</span>.<span class="hljs-property">dataSources</span>.<span class="hljs-title function_">add</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">dataSource</span>);

        <span class="hljs-comment">// 使用 Map 管理所有实体，O(1) 查找性能</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">entities</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
    }

    <span class="hljs-comment">// 添加实体</span>
    <span class="hljs-title function_">addEntity</span>(<span class="hljs-params">options, isLocate = <span class="hljs-literal">false</span></span>) {
        <span class="hljs-keyword">const</span> entityWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EntityWrapper</span>(options);
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">entities</span>.<span class="hljs-title function_">set</span>(entityWrapper.<span class="hljs-property">id</span>, entityWrapper);
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">dataSource</span>.<span class="hljs-property">entities</span>.<span class="hljs-title function_">add</span>(entityWrapper.<span class="hljs-title function_">getEntity</span>());

        <span class="hljs-comment">// 支持创建后自动定位</span>
        <span class="hljs-keyword">if</span> (isLocate) {
            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">locateEntity</span>(entityWrapper.<span class="hljs-property">id</span>);
        }

        <span class="hljs-keyword">return</span> entityWrapper.<span class="hljs-property">id</span>;
    }

    <span class="hljs-comment">// 移除实体</span>
    <span class="hljs-title function_">removeEntity</span>(<span class="hljs-params">entityId</span>) {
        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">entities</span>.<span class="hljs-title function_">has</span>(entityId)) {
            <span class="hljs-keyword">const</span> entityWrapper = <span class="hljs-variable language_">this</span>.<span class="hljs-property">entities</span>.<span class="hljs-title function_">get</span>(entityId);
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">dataSource</span>.<span class="hljs-property">entities</span>.<span class="hljs-title function_">remove</span>(entityWrapper.<span class="hljs-title function_">getEntity</span>());
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">entities</span>.<span class="hljs-title function_">delete</span>(entityId);
        }
    }

    <span class="hljs-comment">// 更新实体</span>
    <span class="hljs-title function_">updateEntity</span>(<span class="hljs-params">entityId, options</span>) {
        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">entities</span>.<span class="hljs-title function_">has</span>(entityId)) {
            <span class="hljs-keyword">const</span> entityWrapper = <span class="hljs-variable language_">this</span>.<span class="hljs-property">entities</span>.<span class="hljs-title function_">get</span>(entityId);
            entityWrapper.<span class="hljs-title function_">update</span>(options);
        }
    }

    <span class="hljs-comment">// 视角定位到实体</span>
    <span class="hljs-title function_">locateEntity</span>(<span class="hljs-params">entityId</span>) {
        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">entities</span>.<span class="hljs-title function_">has</span>(entityId)) {
            <span class="hljs-keyword">const</span> entityWrapper = <span class="hljs-variable language_">this</span>.<span class="hljs-property">entities</span>.<span class="hljs-title function_">get</span>(entityId);
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">viewer</span>.<span class="hljs-title function_">zoomTo</span>(entityWrapper.<span class="hljs-title function_">getEntity</span>());
        }
    }

    <span class="hljs-comment">// 获取所有实体</span>
    <span class="hljs-title function_">getAllEntities</span>(<span class="hljs-params"/>) {
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">entities</span>.<span class="hljs-title function_">values</span>()).<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">wrapper</span> =&gt;</span> wrapper.<span class="hljs-title function_">getEntity</span>());
    }

    <span class="hljs-comment">// 清除所有实体（只清除当前管理器的实体）</span>
    <span class="hljs-title function_">clearEntities</span>(<span class="hljs-params"/>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">dataSource</span>.<span class="hljs-property">entities</span>.<span class="hljs-title function_">removeAll</span>();
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">entities</span>.<span class="hljs-title function_">clear</span>();
    }
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">EntityManager</span>;
</code></pre>
<p><strong>设计亮点：</strong></p>
<ul>
<li>✅ <strong>独立数据源</strong>：使用 <code>CustomDataSource</code> 实现命名空间隔离，不会影响其他模块</li>
<li>✅ <strong>高效查找</strong>：使用 <code>Map</code> 数据结构，提供 O(1) 的查找性能</li>
<li>✅ <strong>自动定位</strong>：支持创建实体后自动飞行到目标位置</li>
<li>✅ <strong>统一接口</strong>：增删改查操作命名规范，易于理解</li>
</ul>
<h3 data-id="heading-13">🎯 使用教程</h3>
<h4 data-id="heading-14">基础用法</h4>
<h5 data-id="heading-15">1. 初始化 CesiumLite</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> cesiumLite = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CesiumLite</span>(<span class="hljs-string">'cesiumContainer'</span>, {
  <span class="hljs-attr">map</span>: {
    <span class="hljs-attr">baseMap</span>: {
      <span class="hljs-attr">id</span>: <span class="hljs-string">'imagery'</span>
    },
    <span class="hljs-attr">camera</span>: {
      <span class="hljs-attr">longitude</span>: <span class="hljs-number">116.397428</span>,
      <span class="hljs-attr">latitude</span>: <span class="hljs-number">39.90923</span>,
      <span class="hljs-attr">height</span>: <span class="hljs-number">1000000</span>
    }
  }
});
</code></pre>
<h5 data-id="heading-16">2. 添加各种几何实体</h5>
<h6 data-id="heading-17">添加多边形</h6>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> polygonId = cesiumLite.<span class="hljs-property">entityManager</span>.<span class="hljs-title function_">addEntity</span>({
  <span class="hljs-attr">polygon</span>: {
    <span class="hljs-attr">hierarchy</span>: <span class="hljs-title class_">Cesium</span>.<span class="hljs-property">Cartesian3</span>.<span class="hljs-title function_">fromDegreesArray</span>([
      -<span class="hljs-number">109.080842</span>, <span class="hljs-number">45.002073</span>,
      -<span class="hljs-number">104.058488</span>, <span class="hljs-number">45.002073</span>,
      -<span class="hljs-number">104.053011</span>, <span class="hljs-number">41.003906</span>,
      -<span class="hljs-number">105.728954</span>, <span class="hljs-number">41.003906</span>,
    ]),
    <span class="hljs-attr">height</span>: <span class="hljs-number">5000</span>,
    <span class="hljs-attr">material</span>: <span class="hljs-title class_">Cesium</span>.<span class="hljs-property">Color</span>.<span class="hljs-property">BLUE</span>.<span class="hljs-title function_">withAlpha</span>(<span class="hljs-number">0.5</span>),
    <span class="hljs-attr">outline</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">outlineColor</span>: <span class="hljs-title class_">Cesium</span>.<span class="hljs-property">Color</span>.<span class="hljs-property">BLACK</span>,
  }
}, <span class="hljs-literal">true</span>); <span class="hljs-comment">// 第二个参数 true 表示创建后自动定位</span>
</code></pre>
<h6 data-id="heading-18">添加盒子模型</h6>
<pre><code class="hljs language-javascript" lang="javascript">cesiumLite.<span class="hljs-property">entityManager</span>.<span class="hljs-title function_">addEntity</span>({
  <span class="hljs-attr">position</span>: <span class="hljs-title class_">Cesium</span>.<span class="hljs-property">Cartesian3</span>.<span class="hljs-title function_">fromDegrees</span>(-<span class="hljs-number">109.080842</span>, <span class="hljs-number">45.002073</span>),
  <span class="hljs-attr">box</span>: {
    <span class="hljs-attr">dimensions</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cesium</span>.<span class="hljs-title class_">Cartesian3</span>(<span class="hljs-number">5000</span>, <span class="hljs-number">5000</span>, <span class="hljs-number">5000</span>),
    <span class="hljs-attr">material</span>: <span class="hljs-title class_">Cesium</span>.<span class="hljs-property">Color</span>.<span class="hljs-property">RED</span>.<span class="hljs-title function_">withAlpha</span>(<span class="hljs-number">0.5</span>),
  }
}, <span class="hljs-literal">true</span>);
</code></pre>
<h6 data-id="heading-19">添加球体</h6>
<pre><code class="hljs language-javascript" lang="javascript">cesiumLite.<span class="hljs-property">entityManager</span>.<span class="hljs-title function_">addEntity</span>({
  <span class="hljs-attr">name</span>: <span class="hljs-string">"Three-dimensional sphere"</span>,
  <span class="hljs-attr">position</span>: <span class="hljs-title class_">Cesium</span>.<span class="hljs-property">Cartesian3</span>.<span class="hljs-title function_">fromDegrees</span>(-<span class="hljs-number">114.0</span>, <span class="hljs-number">40.0</span>, <span class="hljs-number">300000.0</span>),
  <span class="hljs-attr">ellipsoid</span>: {
    <span class="hljs-attr">radii</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cesium</span>.<span class="hljs-title class_">Cartesian3</span>(<span class="hljs-number">200000.0</span>, <span class="hljs-number">200000.0</span>, <span class="hljs-number">300000.0</span>),
    <span class="hljs-attr">innerRadii</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cesium</span>.<span class="hljs-title class_">Cartesian3</span>(<span class="hljs-number">150000.0</span>, <span class="hljs-number">150000.0</span>, <span class="hljs-number">200000.0</span>),
    <span class="hljs-attr">material</span>: <span class="hljs-title class_">Cesium</span>.<span class="hljs-property">Color</span>.<span class="hljs-property">RED</span>.<span class="hljs-title function_">withAlpha</span>(<span class="hljs-number">0.5</span>),
    <span class="hljs-attr">outline</span>: <span class="hljs-literal">true</span>
  }
}, <span class="hljs-literal">true</span>);
</code></pre>
<h6 data-id="heading-20">添加圆柱</h6>
<pre><code class="hljs language-javascript" lang="javascript">cesiumLite.<span class="hljs-property">entityManager</span>.<span class="hljs-title function_">addEntity</span>({
  <span class="hljs-attr">position</span>: <span class="hljs-title class_">Cesium</span>.<span class="hljs-property">Cartesian3</span>.<span class="hljs-title function_">fromDegrees</span>(-<span class="hljs-number">104.058488</span>, <span class="hljs-number">44.996596</span>),
  <span class="hljs-attr">cylinder</span>: {
    <span class="hljs-attr">length</span>: <span class="hljs-number">5000</span>,
    <span class="hljs-attr">topRadius</span>: <span class="hljs-number">500</span>,
    <span class="hljs-attr">bottomRadius</span>: <span class="hljs-number">500</span>,
    <span class="hljs-attr">material</span>: <span class="hljs-title class_">Cesium</span>.<span class="hljs-property">Color</span>.<span class="hljs-property">RED</span>.<span class="hljs-title function_">withAlpha</span>(<span class="hljs-number">0.5</span>),
    <span class="hljs-attr">outline</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">numberOfVerticalLines</span>: <span class="hljs-number">20</span>
  }
}, <span class="hljs-literal">true</span>);
</code></pre>
<h6 data-id="heading-21">添加走廊（Corridor）</h6>
<pre><code class="hljs language-javascript" lang="javascript">cesiumLite.<span class="hljs-property">entityManager</span>.<span class="hljs-title function_">addEntity</span>({
  <span class="hljs-attr">corridor</span>: {
    <span class="hljs-attr">positions</span>: <span class="hljs-title class_">Cesium</span>.<span class="hljs-property">Cartesian3</span>.<span class="hljs-title function_">fromDegreesArray</span>([
      -<span class="hljs-number">109.080842</span>, <span class="hljs-number">45.002073</span>,
      -<span class="hljs-number">105.91517</span>, <span class="hljs-number">45.002073</span>,
      -<span class="hljs-number">104.058488</span>, <span class="hljs-number">44.996596</span>,
    ]),
    <span class="hljs-attr">width</span>: <span class="hljs-number">5000</span>,
    <span class="hljs-attr">height</span>: <span class="hljs-number">1000</span>,
    <span class="hljs-attr">extrudedHeight</span>: <span class="hljs-number">10000</span>,
    <span class="hljs-attr">material</span>: <span class="hljs-title class_">Cesium</span>.<span class="hljs-property">Color</span>.<span class="hljs-property">RED</span>.<span class="hljs-title function_">withAlpha</span>(<span class="hljs-number">0.5</span>),
  }
}, <span class="hljs-literal">true</span>);
</code></pre>
<h6 data-id="heading-22">添加墙（Wall）</h6>
<pre><code class="hljs language-javascript" lang="javascript">cesiumLite.<span class="hljs-property">entityManager</span>.<span class="hljs-title function_">addEntity</span>({
  <span class="hljs-attr">name</span>: <span class="hljs-string">"Vertical wall"</span>,
  <span class="hljs-attr">wall</span>: {
    <span class="hljs-attr">positions</span>: <span class="hljs-title class_">Cesium</span>.<span class="hljs-property">Cartesian3</span>.<span class="hljs-title function_">fromDegreesArrayHeights</span>([
      -<span class="hljs-number">107.0</span>, <span class="hljs-number">43.0</span>, <span class="hljs-number">100000.0</span>,
      -<span class="hljs-number">97.0</span>, <span class="hljs-number">43.0</span>, <span class="hljs-number">100000.0</span>,
      -<span class="hljs-number">97.0</span>, <span class="hljs-number">40.0</span>, <span class="hljs-number">100000.0</span>,
      -<span class="hljs-number">107.0</span>, <span class="hljs-number">40.0</span>, <span class="hljs-number">100000.0</span>,
    ]),
    <span class="hljs-attr">material</span>: <span class="hljs-title class_">Cesium</span>.<span class="hljs-property">Color</span>.<span class="hljs-property">RED</span>.<span class="hljs-title function_">withAlpha</span>(<span class="hljs-number">0.5</span>),
    <span class="hljs-attr">outline</span>: <span class="hljs-literal">true</span>
  }
}, <span class="hljs-literal">true</span>);
</code></pre>
<h4 data-id="heading-23">高级操作</h4>
<h5 data-id="heading-24">更新实体</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 保存实体 ID</span>
<span class="hljs-keyword">const</span> entityId = cesiumLite.<span class="hljs-property">entityManager</span>.<span class="hljs-title function_">addEntity</span>({ <span class="hljs-comment">/* ... */</span> });

<span class="hljs-comment">// 更新实体属性</span>
cesiumLite.<span class="hljs-property">entityManager</span>.<span class="hljs-title function_">updateEntity</span>(entityId, {
  <span class="hljs-attr">polygon</span>: {
    <span class="hljs-attr">material</span>: <span class="hljs-title class_">Cesium</span>.<span class="hljs-property">Color</span>.<span class="hljs-property">GREEN</span>.<span class="hljs-title function_">withAlpha</span>(<span class="hljs-number">0.7</span>)
  }
});
</code></pre>
<h5 data-id="heading-25">定位到指定实体</h5>
<pre><code class="hljs language-javascript" lang="javascript">cesiumLite.<span class="hljs-property">entityManager</span>.<span class="hljs-title function_">locateEntity</span>(entityId);
</code></pre>
<h5 data-id="heading-26">删除指定实体</h5>
<pre><code class="hljs language-javascript" lang="javascript">cesiumLite.<span class="hljs-property">entityManager</span>.<span class="hljs-title function_">removeEntity</span>(entityId);
</code></pre>
<h5 data-id="heading-27">清空所有实体</h5>
<pre><code class="hljs language-javascript" lang="javascript">cesiumLite.<span class="hljs-property">entityManager</span>.<span class="hljs-title function_">clearEntities</span>();
</code></pre>
<h5 data-id="heading-28">获取所有实体</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> allEntities = cesiumLite.<span class="hljs-property">entityManager</span>.<span class="hljs-title function_">getAllEntities</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'当前实体数量：'</span>, allEntities.<span class="hljs-property">length</span>);
</code></pre>
<h3 data-id="heading-29">📊 对比传统开发方式</h3>
<h4 data-id="heading-30">代码量对比</h4>









































<table><thead><tr><th>操作</th><th>传统方式</th><th>CesiumLite</th><th>减少代码量</th></tr></thead><tbody><tr><td>创建实体</td><td>10+ 行</td><td>3 行</td><td>70%</td></tr><tr><td>创建并定位</td><td>15+ 行</td><td>3 行</td><td>80%</td></tr><tr><td>更新实体</td><td>8+ 行</td><td>1 行</td><td>87%</td></tr><tr><td>删除实体</td><td>5+ 行</td><td>1 行</td><td>80%</td></tr><tr><td>批量清空</td><td>10+ 行</td><td>1 行</td><td>90%</td></tr></tbody></table>
<h4 data-id="heading-31">功能对比</h4>








































<table><thead><tr><th>功能</th><th>传统方式</th><th>CesiumLite</th></tr></thead><tbody><tr><td>实体创建</td><td>✅</td><td>✅</td></tr><tr><td>唯一 ID 管理</td><td>❌ 需手动实现</td><td>✅ 自动生成</td></tr><tr><td>命名空间隔离</td><td>❌ 需手动实现</td><td>✅ 内置支持</td></tr><tr><td>自动定位</td><td>❌ 需单独调用</td><td>✅ 参数控制</td></tr><tr><td>统一更新接口</td><td>❌ 分散操作</td><td>✅ 统一接口</td></tr><tr><td>批量操作</td><td>❌ 需手动循环</td><td>✅ 内置支持</td></tr></tbody></table>
<h3 data-id="heading-32">🚀 快速开始</h3>
<h4 data-id="heading-33">1. 安装</h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># NPM 安装（推荐）</span>
npm install cesium-lite

<span class="hljs-comment"># 或者通过 GitHub 克隆</span>
git <span class="hljs-built_in">clone</span> https://github.com/lukeSuperCoder/cesium-lite.git
<span class="hljs-built_in">cd</span> cesium-lite
npm install
</code></pre>
<h4 data-id="heading-34">2. 引入使用</h4>
<h5 data-id="heading-35">方式一：NPM 方式</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">CesiumLite</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'cesium-lite'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'cesium/Build/Cesium/Widgets/widgets.css'</span>;

<span class="hljs-keyword">const</span> cesiumLite = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CesiumLite</span>(<span class="hljs-string">'cesiumContainer'</span>, {
  <span class="hljs-comment">// 配置项</span>
});
</code></pre>
<h4 data-id="heading-36">方式二：本地运行项目</h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 克隆项目</span>
git <span class="hljs-built_in">clone</span> https://github.com/lukeSuperCoder/cesium-lite.git
<span class="hljs-built_in">cd</span> cesium-lite

<span class="hljs-comment"># 安装依赖</span>
npm install
</code></pre>
<h4 data-id="heading-37">3. 运行示例</h4>
<pre><code class="hljs language-bash" lang="bash">npm run dev
</code></pre>
<p>访问 <code>http://localhost:8020/entity.html</code> 查看实体管理示例。</p>
<h3 data-id="heading-38">💡 最佳实践建议</h3>
<h4 data-id="heading-39">1. 合理使用自动定位</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 对于重要的首个实体，启用自动定位</span>
<span class="hljs-keyword">const</span> mainEntityId = cesiumLite.<span class="hljs-property">entityManager</span>.<span class="hljs-title function_">addEntity</span>(options, <span class="hljs-literal">true</span>);

<span class="hljs-comment">// 批量创建时，关闭自动定位以提升性能</span>
entities.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">entity</span> =&gt;</span> {
  cesiumLite.<span class="hljs-property">entityManager</span>.<span class="hljs-title function_">addEntity</span>(entity, <span class="hljs-literal">false</span>);
});

<span class="hljs-comment">// 批量创建完成后，手动定位到某个实体</span>
cesiumLite.<span class="hljs-property">entityManager</span>.<span class="hljs-title function_">locateEntity</span>(mainEntityId);
</code></pre>
<h4 data-id="heading-40">2. 实体 ID 管理</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 为重要实体指定自定义 ID</span>
<span class="hljs-keyword">const</span> buildingId = cesiumLite.<span class="hljs-property">entityManager</span>.<span class="hljs-title function_">addEntity</span>({
  <span class="hljs-attr">id</span>: <span class="hljs-string">'building_main_001'</span>,  <span class="hljs-comment">// 自定义 ID</span>
  <span class="hljs-attr">polygon</span>: { <span class="hljs-comment">/* ... */</span> }
});

<span class="hljs-comment">// 后续可以直接使用自定义 ID 操作</span>
cesiumLite.<span class="hljs-property">entityManager</span>.<span class="hljs-title function_">updateEntity</span>(<span class="hljs-string">'building_main_001'</span>, { <span class="hljs-comment">/* ... */</span> });
</code></pre>
<h4 data-id="heading-41">3. 批量操作优化</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 批量创建实体</span>
<span class="hljs-keyword">const</span> entityIds = [];
<span class="hljs-keyword">const</span> batchData = [ <span class="hljs-comment">/* 大量数据 */</span> ];

batchData.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {
  <span class="hljs-keyword">const</span> id = cesiumLite.<span class="hljs-property">entityManager</span>.<span class="hljs-title function_">addEntity</span>(data, <span class="hljs-literal">false</span>);
  entityIds.<span class="hljs-title function_">push</span>(id);
});

<span class="hljs-comment">// 需要时再批量定位</span>
entityIds.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">id</span> =&gt;</span> {
  cesiumLite.<span class="hljs-property">entityManager</span>.<span class="hljs-title function_">locateEntity</span>(id);
});
</code></pre>
<h3 data-id="heading-42">🔮 未来规划</h3>
<p>实体管理模块后续将会支持：</p>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="disabled"/> 实体分组管理</li>
<li class="task-list-item"><input type="checkbox" disabled="disabled"/> 实体样式预设</li>
<li class="task-list-item"><input type="checkbox" disabled="disabled"/> 实体动画支持</li>
<li class="task-list-item"><input type="checkbox" disabled="disabled"/> 实体点击事件封装</li>
<li class="task-list-item"><input type="checkbox" disabled="disabled"/> 实体序列化与反序列化</li>
<li class="task-list-item"><input type="checkbox" disabled="disabled"/> 批量操作性能优化</li>
</ul>
<h3 data-id="heading-43">📚 相关资源</h3>
<ul>
<li><strong>GitHub 仓库</strong>：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FlukeSuperCoder%2Fcesium-lite" target="_blank" title="https://github.com/lukeSuperCoder/cesium-lite" ref="nofollow noopener noreferrer">github.com/lukeSuperCo…</a></li>
<li><strong>在线演示</strong>：<a href="https://link.juejin.cn?target=https%3A%2F%2Flukesupercoder.github.io%2Fcesium-lite%2F" target="_blank" title="https://lukesupercoder.github.io/cesium-lite/" ref="nofollow noopener noreferrer">lukesupercoder.github.io/cesium-lite…</a></li>
<li><strong>NPM 包</strong>：<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fcesium-lite" target="_blank" title="https://www.npmjs.com/package/cesium-lite" ref="nofollow noopener noreferrer">www.npmjs.com/package/ces…</a></li>
<li><strong>问题反馈</strong>：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FlukeSuperCoder%2Fcesium-lite%2Fissues" target="_blank" title="https://github.com/lukeSuperCoder/cesium-lite/issues" ref="nofollow noopener noreferrer">GitHub Issues</a></li>
</ul>
<h3 data-id="heading-44">🙏 总结</h3>
<p>CesiumLite 的实体管理模块通过双层封装架构，有效解决了 Cesium 原生开发中的诸多痛点：</p>
<ul>
<li>✅ <strong>简化 API</strong>：减少 70%-90% 的代码量</li>
<li>✅ <strong>统一管理</strong>：自动 ID 生成 + 命名空间隔离</li>
<li>✅ <strong>开箱即用</strong>：无需重复造轮子</li>
<li>✅ <strong>性能优化</strong>：使用 Map 数据结构，高效查找</li>
</ul>
<p>如果你正在使用 Cesium 开发三维地图应用，不妨试试 CesiumLite，让你的开发效率翻倍！</p>
<hr/>
<p><strong>⭐ 如果这个项目对你有帮助，欢迎给个 Star 支持一下！</strong></p>
<p><strong>💬 有任何问题或建议，欢迎在评论区交流！</strong></p>
<p><strong>相关标签：</strong> #Cesium #三维地图 #WebGIS #前端开发 #JavaScript #开源项目 #地图可视化</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[为什么工作 10 年都没遇过分布式锁？]]></title>    <link>https://juejin.cn/post/7578700798743887906</link>    <guid>https://juejin.cn/post/7578700798743887906</guid>    <pubDate>2025-12-01T10:08:36.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7578700798743887906" data-draft-id="7578699975413678080" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="为什么工作 10 年都没遇过分布式锁？"/> <meta itemprop="keywords" content="后端,Java,架构"/> <meta itemprop="datePublished" content="2025-12-01T10:08:36.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="架构师沉默"/> <meta itemprop="url" content="https://juejin.cn/user/613946828261482"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            为什么工作 10 年都没遇过分布式锁？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/613946828261482/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    架构师沉默
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-01T10:08:36.000Z" title="Mon Dec 01 2025 10:08:36 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-01
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body cache result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>沉默是金，总会发光</p>
<p>大家好，我是沉默</p>
<p>前两天在群里看到一句话，瞬间把我笑喷：</p>
<blockquote>
<p>“工作10年了，简历上写了熟悉分布式系统，结果一次分布式锁都没用过。是太菜，还是公司太稳？”</p>
</blockquote>
<p>底下一群人立刻跟上：</p>
<ul>
<li>
<p>“+1，我也是！”</p>
</li>
<li>
<p>“我们公司连‘分布’俩字都不敢提……”</p>
</li>
<li>
<p>“别说锁了，我们连 Redis 集群都没有，就一台单机 Redis 顶天。”</p>
</li>
</ul>
<p>看到这里，我只想说一句：<br/>
<strong>兄弟，这不是你一个人的困惑，这是大部分开发的真实写照。</strong></p>
<p>**-**<strong>01-</strong></p>
<p><strong>啥是分布式锁？</strong></p>
<p>想象你跟 10 个人排队打饭——大家都很守规矩：<strong>先来先打，公平有序</strong>。</p>
<p>但如果这 10 个人分散在不同窗口，每人都觉得“锅里还有”而同时开舀？</p>
<p>锅就穿了。</p>
<p>这就是分布式系统中的典型现象——<strong>多个节点抢一个资源，必须定规则，否则乱套。</strong></p>
<p>分布式锁的用途就是：</p>
<ul>
<li>谁先抢到锁，谁执行</li>
<li>执行完才允许下一个来</li>
</ul>
<p>**<br/>
**</p>
<p><strong>典型冲突场景：</strong></p>
<ul>
<li>
<p>发红包不能发两次</p>
</li>
<li>
<p>库存不能卖超</p>
</li>
<li>
<p>定时任务不能多个节点一起跑</p>
</li>
</ul>
<p>很多公司根本没这些高并发需求，所以你自然用不上。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a918395cb3d7450289059081c9391f10~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p625p6E5biI5rKJ6buY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765188516&amp;x-signature=qLrYUxDyDxKRO3fPXNSR6rMiM9c%3D" alt="图片" loading="lazy"/></p>
<p><strong>-</strong> <strong>02-</strong></p>
<p><strong>两个你肯定听过的真实事故</strong></p>
<h3 data-id="heading-0"><strong>场景 1：秒杀超卖</strong></h3>
<p>活动喊着“限量 100 件”，结果卖了 130 件。<br/>
仓库懵了，客服炸了，领导坐你后面看你写代码。</p>
<p>为什么会超卖？</p>
<p>因为有十台服务器同时判断：</p>
<blockquote>
<p>“库存 &gt; 0，那可以卖！”</p>
</blockquote>
<p>于是……一起卖了。</p>
<p><strong>解决方式：</strong>  在扣库存之前加锁，抢到锁才能操作。</p>
<h3 data-id="heading-1">** **</h3>
<h3 data-id="heading-2"><strong>场景 2：重复退款</strong></h3>
<p>用户手速太快，“退款”点了两次。<br/>
你的服务部署在三个节点里，结果两个节点收到了同一个请求。</p>
<p>如果没锁？<br/>
<strong>资金直接退两遍。</strong></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/99ed2dd434e9468b97c1e4d4835ea736~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p625p6E5biI5rKJ6buY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765188516&amp;x-signature=rpkGJuf59PLL2bmgL7TFdeQuE1Y%3D" alt="图片" loading="lazy"/></p>
<p><strong>-</strong> <strong>03-</strong></p>
<p><strong>分布式锁咋实现?</strong></p>
<p>Redis 分布式锁</p>
<p>原理不复杂，就是：</p>
<ul>
<li><code>SETNX</code> 抢锁</li>
<li>设置过期时间避免死锁</li>
<li>释放锁时判断是不是自己的锁</li>
</ul>
<p>（SpringBoot 简化版）：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-meta">@Componentpublic</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisDistributedLock</span> {    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">StringRedisTemplate</span> redisTemplate;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">tryLock</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> lockKey, <span class="hljs-built_in">String</span> requestId, long expireTime</span>) {        <span class="hljs-keyword">return</span> redisTemplate.<span class="hljs-title function_">opsForValue</span>()            .<span class="hljs-title function_">setIfAbsent</span>(lockKey, requestId, expireTime, <span class="hljs-title class_">TimeUnit</span>.<span class="hljs-property">SECONDS</span>);    }    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">releaseLock</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> lockKey, <span class="hljs-built_in">String</span> requestId</span>) {        <span class="hljs-title class_">String</span> currentValue = redisTemplate.<span class="hljs-title function_">opsForValue</span>().<span class="hljs-title function_">get</span>(lockKey);        <span class="hljs-keyword">if</span> (requestId.<span class="hljs-title function_">equals</span>(currentValue)) {            redisTemplate.<span class="hljs-title function_">delete</span>(lockKey);        }    }}
</code></pre>
<p>看起来“像那么回事”，但上生产就开始暴露坑：</p>
<ul>
<li>
<p>锁到期太短 → 业务还没执行完锁就失效</p>
</li>
<li>
<p>锁到期太长 → 业务挂了锁一直不释放</p>
</li>
<li>
<p>锁被别人抢走后，你把别人的锁释放了（灾难）</p>
</li>
</ul>
<p>生产还得是 Redisson 分布式锁</p>
<p>Redisson：</p>
<blockquote>
<p><strong>“别怕，我都给你封装好了。”</strong></p>
</blockquote>
<p>自动续期（看门狗）、可重入锁、公平锁、读写锁，全都有。</p>
<h3 data-id="heading-3">** **</h3>
<h3 data-id="heading-4"><strong>使用也很简单：</strong></h3>
<h4 data-id="heading-5">1）引依赖</h4>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.redisson<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>redisson-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.24.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<p>2）代码更简单</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-keyword">@Servicepublic</span> class PaymentService {    <span class="hljs-keyword">@Autowired</span>    private RedissonClient redissonClient;    public void <span class="hljs-built_in">processRefund</span>(String orderNo) {        RLock lock = redissonClient<span class="hljs-selector-class">.getLock</span>("lock:refund:" + orderNo);        try {            boolean isLocked = lock<span class="hljs-selector-class">.tryLock</span>(<span class="hljs-number">100</span>, <span class="hljs-number">10</span>, TimeUnit.SECONDS);            if (isLocked) {                if (hasRefunded(orderNo)) {                    throw new <span class="hljs-built_in">RuntimeException</span>("已退款，请勿重复操作");                }                <span class="hljs-built_in">doRefund</span>(orderNo);                <span class="hljs-built_in">recordRefund</span>(orderNo);            }        } catch (Exception e) {            throw new <span class="hljs-built_in">RuntimeException</span>("获取锁失败", e);        } finally {            if (lock.isHeldByCurrentThread()) {                lock<span class="hljs-selector-class">.unlock</span>();            }        }    }}
</code></pre>
<p>放心，这玩意能撑住大部分业务场景。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2609154464cf4f48945d6054030adf9c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p625p6E5biI5rKJ6buY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765188516&amp;x-signature=Qa5HZH%2BT3D9mkF8wTw%2FIzI1wUno%3D" alt="图片" loading="lazy"/></p>
<p>**-****04-**<strong>总结</strong></p>
<h2 data-id="heading-6"><strong>为什么你没用过？</strong></h2>
<p>非常简单，只有两种原因：</p>
<h3 data-id="heading-7"><strong>❶ 公司业务稳得一匹</strong></h3>
<ul>
<li>用户量小</li>
<li>单节点就够</li>
<li>业务流程不冲突</li>
<li>高并发压根不存在</li>
</ul>
<p>没到量级，当然用不上。</p>
<h3 data-id="heading-8"><strong>❷ 框架和数据库帮你扛了</strong></h3>
<p>你以为没做，其实系统已经帮你做了：</p>
<ul>
<li>MySQL 悲观锁：<code>SELECT ... FOR UPDATE</code></li>
<li>乐观锁：version字段</li>
<li>Redis <code>INCR/DECR</code> 原子操作</li>
<li>消息去重</li>
</ul>
<p>你“看上去没锁”，但其实“锁无处不在”。</p>
<h2 data-id="heading-9"><strong>现在不用，不代表以后用不到</strong></h2>
<p>跳槽、业务增长、架构升级，都可能让你突然遇到分布式场景。</p>
<p>而分布式锁属于那种：</p>
<blockquote>
<p><strong>“线上十年不用，一次用不好就出大事故”的功能。</strong></p>
</blockquote>
<p>所以现在把原理搞明白、把代码跑通，未来一定能救你一命。</p>
<h2 data-id="heading-10"><strong>你工作几年？用过分布式锁吗？</strong></h2>
<p>你可以直接在评论区说说：</p>
<ul>
<li>
<p>你第一次用分布式锁是什么场景？</p>
</li>
<li>
<p>你们公司是不是至今连 Redis 集群都没有？</p>
</li>
<li>
<p>或者，你也是“写了分布式系统，但没见过分布式锁”的那种？</p>
</li>
</ul>
<pre><code class="hljs"/></pre>
<p>**-****05-**<strong>粉丝福利</strong></p>
<pre><code class="hljs">站在职业的十字路口，我们或许都曾感到迷茫：




投出的简历总是没有回音？




面试时不知如何展现自己的优势？




未来的职场道路该如何规划？




技术管理能力提升，如何跨越第一步？




如果你正在经历这些，我很乐意用我的经验为你提供一些帮助。




无论是修改简历、1对1求职陪跑，职业规划咨询，




还是迈向技术Leader或提升管理效能，




欢迎你加我，我们像朋友一样聊聊。
</code></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[MyBatis设计观——映射思想、动态SQL的边界与可维护性考量]]></title>    <link>https://juejin.cn/post/7578667193321095231</link>    <guid>https://juejin.cn/post/7578667193321095231</guid>    <pubDate>2025-12-01T10:15:48.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7578667193321095231" data-draft-id="7578681104292085803" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="MyBatis设计观——映射思想、动态SQL的边界与可维护性考量"/> <meta itemprop="keywords" content="后端,架构"/> <meta itemprop="datePublished" content="2025-12-01T10:15:48.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="十月南城"/> <meta itemprop="url" content="https://juejin.cn/user/3456520290576862"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            MyBatis设计观——映射思想、动态SQL的边界与可维护性考量
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3456520290576862/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    十月南城
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-01T10:15:48.000Z" title="Mon Dec 01 2025 10:15:48 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-01
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body cache result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>在对象与关系的鸿沟之间，MyBatis选择了一条独特的桥梁建设之路——不强求完全自动化，而是将控制权交还给开发者</p>
</blockquote>
<p>在持久层框架的设计哲学中，MyBatis采取了与全自动ORM框架截然不同的路径。它不试图完全隐藏数据库细节，而是通过优雅的映射机制和动态SQL能力，在对象模型与关系模型之间建立了可控的转换通道。本文将深入剖析MyBatis的核心设计思想，探讨动态SQL的适用边界，并给出构建可维护MyBatis应用的最佳实践。</p>
<h2 data-id="heading-0">1 MyBatis的设计哲学：半自动化ORM的价值定位</h2>
<h3 data-id="heading-1">1.1 与全自动ORM的差异化定位</h3>
<p>MyBatis作为一个<strong>半自动化ORM框架</strong>，在设计哲学上与Hibernate等全自动ORM框架有着本质区别。全自动ORM试图完全屏蔽数据库细节，让开发者以面向对象的方式操作数据，而MyBatis则承认对象与关系之间的<strong>阻抗不匹配</strong>是不可避免的，选择将SQL的控制权交还给开发者。</p>
<p>这种设计理念带来了不同的权衡：全自动ORM通过抽象提高了开发效率，但牺牲了对SQL的精细控制；MyBatis通过暴露SQL细节，确保了性能可控性和灵活性，但要求开发者具备数据库知识。正如MyBatis的核心贡献者所言：“我们不相信一种模式能够适合所有场景，有时候你需要直接与SQL打交道”。</p>
<h3 data-id="heading-2">1.2 核心设计原则：简单性与可控性</h3>
<p>MyBatis的设计遵循两个核心原则：<strong>简单性</strong>和<strong>可控性</strong>。框架本身保持轻量级，核心组件数量有限且职责单一，这使得学习曲线相对平缓。同时，开发者对SQL拥有完全控制权，可以针对特定数据库优化SQL语句，充分利用数据库特有功能。</p>
<p>这种设计理念在实际应用中体现为“约定优于配置”的适度使用。MyBatis提供合理的默认值，但几乎所有默认行为都可以被覆盖，如可以通过<code>&lt;settings&gt;</code>标签配置缓存行为、日志实现等。与Spring框架的无缝集成进一步强化了这种可控性，使MyBatis能够融入现代Java应用生态系统。</p>
<h2 data-id="heading-3">2 映射机制：对象与关系的桥梁建设</h2>
<h3 data-id="heading-4">2.1 结果映射：从关系表到对象树的转换</h3>
<p>MyBatis的映射核心是<strong>ResultMap</strong>机制，它定义了如何将SQL查询结果转换为Java对象树。与全自动ORM的“黑盒”映射不同，ResultMap要求开发者显式定义映射规则，这种显式性虽然增加了配置工作量，但提高了系统的可理解性和可控性。</p>
<p><strong>简单映射</strong>处理单表查询到扁平对象的转换，通过<code>&lt;result&gt;</code>标签将列与属性关联：</p>
<pre><code class="hljs language-ini" lang="ini">&lt;resultMap <span class="hljs-attr">id</span>=<span class="hljs-string">"UserResult"</span> type=<span class="hljs-string">"User"</span>&gt;
    &lt;id <span class="hljs-attr">property</span>=<span class="hljs-string">"id"</span> column=<span class="hljs-string">"user_id"</span>/&gt;
    &lt;result <span class="hljs-attr">property</span>=<span class="hljs-string">"username"</span> column=<span class="hljs-string">"user_name"</span>/&gt;
    &lt;result <span class="hljs-attr">property</span>=<span class="hljs-string">"email"</span> column=<span class="hljs-string">"email"</span>/&gt;
&lt;/resultMap&gt;
</code></pre>
<p><strong>复杂映射</strong>处理关联对象，通过<code>&lt;association&gt;</code>（一对一）和<code>&lt;collection&gt;</code>（一对多）标签构建对象图：</p>
<pre><code class="hljs language-ini" lang="ini">&lt;resultMap <span class="hljs-attr">id</span>=<span class="hljs-string">"BlogResult"</span> type=<span class="hljs-string">"Blog"</span>&gt;
    &lt;id <span class="hljs-attr">property</span>=<span class="hljs-string">"id"</span> column=<span class="hljs-string">"blog_id"</span>/&gt;
    &lt;result <span class="hljs-attr">property</span>=<span class="hljs-string">"title"</span> column=<span class="hljs-string">"title"</span>/&gt;
    &lt;association <span class="hljs-attr">property</span>=<span class="hljs-string">"author"</span> javaType=<span class="hljs-string">"Author"</span>&gt;
        &lt;id <span class="hljs-attr">property</span>=<span class="hljs-string">"id"</span> column=<span class="hljs-string">"author_id"</span>/&gt;
        &lt;result <span class="hljs-attr">property</span>=<span class="hljs-string">"name"</span> column=<span class="hljs-string">"author_name"</span>/&gt;
    &lt;/association&gt;
    &lt;collection <span class="hljs-attr">property</span>=<span class="hljs-string">"posts"</span> ofType=<span class="hljs-string">"Post"</span>&gt;
        &lt;id <span class="hljs-attr">property</span>=<span class="hljs-string">"id"</span> column=<span class="hljs-string">"post_id"</span>/&gt;
        &lt;result <span class="hljs-attr">property</span>=<span class="hljs-string">"content"</span> column=<span class="hljs-string">"content"</span>/&gt;
    &lt;/collection&gt;
&lt;/resultMap&gt;
</code></pre>
<p>这种显式映射确保了数据转换的可预测性，避免了“魔法”行为带来的调试困难。</p>
<h3 data-id="heading-5">2.2 参数映射：从对象到SQL参数的传递</h3>
<p>MyBatis的参数映射机制将Java方法参数转换为SQL语句中的占位符值。<strong>简单类型参数</strong>直接映射到预编译语句的占位符，而<strong>复杂对象参数</strong>则通过属性路径映射：</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-operator">&lt;</span><span class="hljs-keyword">insert</span> id<span class="hljs-operator">=</span>"insertUser" parameterType<span class="hljs-operator">=</span>"User"<span class="hljs-operator">&gt;</span>
    <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> users (username, email, create_time)
    <span class="hljs-keyword">VALUES</span> (#{username}, #{email}, #{createTime})
<span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span><span class="hljs-keyword">insert</span><span class="hljs-operator">&gt;</span>
</code></pre>
<p><strong>参数类型处理器</strong>（TypeHandler）是参数映射的扩展点，负责Java类型与JDBC类型之间的转换。MyBatis提供了内置处理器，同时也支持自定义实现，用于处理枚举、JSON等复杂类型。</p>
<h2 data-id="heading-6">3 动态SQL：灵活性与复杂性的平衡艺术</h2>
<h3 data-id="heading-7">3.1 动态SQL的适用场景与边界</h3>
<p>动态SQL是MyBatis最强大的特性之一，它允许根据运行时条件动态构建SQL语句。这种能力特别适用于<strong>多条件查询</strong>、<strong>可变更新操作</strong>和<strong>批量数据处理</strong>场景。</p>
<p>然而，动态SQL的灵活性也带来了复杂性管理的挑战。当动态逻辑过于复杂时，生成的SQL可能难以预测和维护。因此，需要明确动态SQL的<strong>适用边界</strong>：简单条件组合使用动态SQL，复杂业务逻辑则考虑在Java层构建。</p>
<h3 data-id="heading-8">3.2 动态标签的合理使用</h3>
<p>MyBatis提供了一系列动态标签，每种标签都有其特定用途和使用边界：</p>
<p><code>&lt;if&gt;</code>标签用于可选条件，是最常用的动态标签：</p>
<pre><code class="hljs language-bash" lang="bash">&lt;select <span class="hljs-built_in">id</span>=<span class="hljs-string">"findUsers"</span> resultType=<span class="hljs-string">"User"</span>&gt;
    SELECT * FROM <span class="hljs-built_in">users</span>
    &lt;<span class="hljs-built_in">where</span>&gt;
        &lt;<span class="hljs-keyword">if</span> <span class="hljs-built_in">test</span>=<span class="hljs-string">"username != null and username != ''"</span>&gt;
            AND username = <span class="hljs-comment">#{username}</span>
        &lt;/if&gt;
        &lt;<span class="hljs-keyword">if</span> <span class="hljs-built_in">test</span>=<span class="hljs-string">"email != null"</span>&gt;
            AND email = <span class="hljs-comment">#{email}</span>
        &lt;/if&gt;
    &lt;/where&gt;
&lt;/select&gt;
</code></pre>
<p><code>&lt;choose&gt;</code>、<code>&lt;when&gt;</code>、<code>&lt;otherwise&gt;</code>实现多路分支逻辑，替代复杂的if-else链：</p>
<pre><code class="hljs language-bash" lang="bash">&lt;select <span class="hljs-built_in">id</span>=<span class="hljs-string">"findActiveUsers"</span> resultType=<span class="hljs-string">"User"</span>&gt;
    SELECT * FROM <span class="hljs-built_in">users</span>
    &lt;<span class="hljs-built_in">where</span>&gt;
        &lt;choose&gt;
            &lt;when <span class="hljs-built_in">test</span>=<span class="hljs-string">"active == true"</span>&gt;
                AND status = <span class="hljs-string">'ACTIVE'</span>
            &lt;/when&gt;
            &lt;when <span class="hljs-built_in">test</span>=<span class="hljs-string">"inactive == true"</span>&gt;
                AND status = <span class="hljs-string">'INACTIVE'</span>
            &lt;/when&gt;
            &lt;otherwise&gt;
                AND status IS NOT NULL
            &lt;/otherwise&gt;
        &lt;/choose&gt;
    &lt;/where&gt;
&lt;/select&gt;
</code></pre>
<p><code>&lt;foreach&gt;</code>标签处理集合遍历，常用于IN查询和批量操作：</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-operator">&lt;</span><span class="hljs-keyword">select</span> id<span class="hljs-operator">=</span>"findUsersByIds" resultType<span class="hljs-operator">=</span>"User"<span class="hljs-operator">&gt;</span>
    <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users
    <span class="hljs-keyword">WHERE</span> id <span class="hljs-keyword">IN</span>
    <span class="hljs-operator">&lt;</span>foreach item<span class="hljs-operator">=</span>"id" collection<span class="hljs-operator">=</span>"ids" <span class="hljs-keyword">open</span><span class="hljs-operator">=</span>"(" separator<span class="hljs-operator">=</span>"," <span class="hljs-keyword">close</span><span class="hljs-operator">=</span>")"<span class="hljs-operator">&gt;</span>
        #{id}
    <span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span>foreach<span class="hljs-operator">&gt;</span>
<span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span><span class="hljs-keyword">select</span><span class="hljs-operator">&gt;</span>
</code></pre>
<h3 data-id="heading-9">3.3 动态SQL的可维护性实践</h3>
<p>保持动态SQL可维护性的关键实践包括：<strong>适度抽象</strong>，将重复的SQL片段提取为<code>&lt;sql&gt;</code>标签；<strong>逻辑简化</strong>，避免嵌套过深的动态逻辑；<strong>注释补充</strong>，为复杂动态逻辑添加解释性注释。</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-comment">&lt;!-- 可维护的动态SQL示例 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"userColumns"</span>&gt;</span>id, username, email, status<span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"searchUsers"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"User"</span>&gt;</span>
    SELECT <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">"userColumns"</span>/&gt;</span>
    FROM users
    <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- 按状态过滤：支持多种状态查询 --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"statusList != null and statusList.size() &gt; 0"</span>&gt;</span>
            AND status IN
            <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">item</span>=<span class="hljs-string">"status"</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">"statusList"</span> <span class="hljs-attr">open</span>=<span class="hljs-string">"("</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">","</span> <span class="hljs-attr">close</span>=<span class="hljs-string">")"</span>&gt;</span>
                #{status}
            <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- 按用户名模糊查询 --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"username != null and username != ''"</span>&gt;</span>
            AND username LIKE CONCAT(#{username}, '%')
        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span>
    ORDER BY create_time DESC
<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>
</code></pre>
<h2 data-id="heading-10">4 缓存设计：性能与一致性的权衡</h2>
<h3 data-id="heading-11">4.1 两级缓存机制的设计原理</h3>
<p>MyBbatis采用<strong>两级缓存</strong>结构，在数据新鲜度和性能之间提供不同级别的权衡。</p>
<p><strong>一级缓存</strong>是SqlSession级别的缓存，默认开启，生命周期与数据库会话绑定。它在同一会话内避免重复查询，但跨会话无法共享数据。<strong>二级缓存</strong>是Mapper级别的缓存，默认关闭，需要显式配置。多个SqlSession可以共享二级缓存，提供跨会话的数据复用能力。</p>
<h3 data-id="heading-12">4.2 缓存策略与一致性保障</h3>
<p>MyBatis的缓存更新策略遵循<strong>写失效</strong>模式：任何增删改操作都会清空对应Mapper的缓存。这种保守策略保证了强一致性，但可能牺牲部分性能。</p>
<p>合理的缓存配置需要考虑数据的<strong>访问模式</strong>和<strong>更新频率</strong>。读多写少的数据适合开启二级缓存，频繁更新的数据则应避免缓存或设置较短过期时间：</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-comment">&lt;!-- 二级缓存配置示例 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">cache</span>
    <span class="hljs-attr">eviction</span>=<span class="hljs-string">"LRU"</span>
    <span class="hljs-attr">flushInterval</span>=<span class="hljs-string">"300000"</span>
    <span class="hljs-attr">size</span>=<span class="hljs-string">"1024"</span>
    <span class="hljs-attr">readOnly</span>=<span class="hljs-string">"true"</span>/&gt;</span>
</code></pre>
<h2 data-id="heading-13">5 可维护性架构设计</h2>
<h3 data-id="heading-14">5.1 项目结构组织规范</h3>
<p>可维护的MyBatis项目需要合理的代码组织方式。<strong>按功能模块分包</strong>将Mapper接口、XML映射文件、实体类组织在同一模块内，减少跨模块依赖：</p>
<pre><code class="hljs language-bash" lang="bash">src/main/java
└── com/example/
    ├── user/
    │   ├── User.java          <span class="hljs-comment"># 实体类</span>
    │   ├── UserMapper.java    <span class="hljs-comment"># Mapper接口</span>
    │   └── UserService.java   <span class="hljs-comment"># 业务服务类</span>
    └── product/
        ├── Product.java
        ├── ProductMapper.java
        └── ProductService.java

src/main/resources
└── com/example/
    ├── user/
    │   └── UserMapper.xml     <span class="hljs-comment"># 映射文件与接口同包</span>
    └── product/
        └── ProductMapper.xml
</code></pre>
<p><strong>命名约定</strong>保持一致命名风格，如<code>UserMapper</code>接口对应<code>UserMapper.xml</code>，<code>findByXxx</code>用于查询方法，<code>updateXxx</code>用于更新操作。</p>
<h3 data-id="heading-15">5.2 SQL映射的模块化管理</h3>
<p>大型项目中，SQL映射文件可能变得庞大复杂。<strong>SQL片段复用</strong>通过<code>&lt;sql&gt;</code>标签提取公共SQL片段，减少重复代码：</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-comment">&lt;!-- 公共列定义 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"baseColumns"</span>&gt;</span>id, create_time, update_time, version<span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 在查询中引用 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"selectDetail"</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"DetailResult"</span>&gt;</span>
    SELECT 
        <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">"baseColumns"</span>/&gt;</span>,
        other_columns
    FROM table
<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>
</code></pre>
<p><strong>结果映射继承</strong>通过<code>&lt;resultMap&gt;</code>的<code>extends</code>属性实现映射复用：</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-comment">&lt;!-- 基础映射 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"BaseResult"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"BaseEntity"</span> <span class="hljs-attr">autoMapping</span>=<span class="hljs-string">"true"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"id"</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"createTime"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"create_time"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 扩展映射 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"UserResult"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"User"</span> <span class="hljs-attr">extends</span>=<span class="hljs-string">"BaseResult"</span> <span class="hljs-attr">autoMapping</span>=<span class="hljs-string">"true"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"username"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span>
</code></pre>
<h2 data-id="heading-16">6 集成与扩展架构</h2>
<h3 data-id="heading-17">6.1 Spring集成的最佳实践</h3>
<p>MyBatis与Spring的集成提供了声明式事务管理和依赖注入支持。<strong>注解配置</strong>简化了集成配置，通过<code>@MapperScan</code>自动注册Mapper接口：</p>
<pre><code class="hljs language-less" lang="less"><span class="hljs-variable">@Configuration</span>
<span class="hljs-variable">@MapperScan</span>(<span class="hljs-string">"com.example.mapper"</span>)
public class MyBatisConfig {
    
    <span class="hljs-variable">@Bean</span>
    public SqlSessionFactory <span class="hljs-built_in">sqlSessionFactory</span>(DataSource dataSource) throws Exception {
        <span class="hljs-selector-tag">SqlSessionFactoryBean</span> <span class="hljs-selector-tag">sessionFactory</span> = <span class="hljs-selector-tag">new</span> <span class="hljs-selector-tag">SqlSessionFactoryBean</span>();
        <span class="hljs-selector-tag">sessionFactory</span><span class="hljs-selector-class">.setDataSource</span>(dataSource);
        <span class="hljs-selector-tag">sessionFactory</span><span class="hljs-selector-class">.setMapperLocations</span>(
            new <span class="hljs-built_in">PathMatchingResourcePatternResolver</span>()
                .<span class="hljs-built_in">getResources</span>(<span class="hljs-string">"classpath*:mapper/**/*.xml"</span>));
        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">sessionFactory</span><span class="hljs-selector-class">.getObject</span>();
    }
}
</code></pre>
<p><strong>事务管理</strong>通过Spring的<code>@Transactional</code>注解实现声明式事务，确保数据一致性。</p>
<h3 data-id="heading-18">6.2 自定义插件与类型处理器</h3>
<p>MyBatis的扩展机制允许开发者定制框架行为。<strong>插件</strong>（Interceptor）可以拦截MyBatis的核心组件执行过程，用于SQL日志、分页、权限控制等横切关注点：</p>
<pre><code class="hljs language-less" lang="less"><span class="hljs-variable">@Intercepts</span>({
    <span class="hljs-variable">@Signature</span>(type = Executor.class, method = <span class="hljs-string">"update"</span>, args = {MappedStatement.class, Object.class})
})
public class SqlLogPlugin implements Interceptor {
    <span class="hljs-variable">@Override</span>
    public Object <span class="hljs-built_in">intercept</span>(Invocation invocation) throws Throwable {
        <span class="hljs-comment">// 实现拦截逻辑</span>
        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">invocation</span><span class="hljs-selector-class">.proceed</span>();
    }
}
</code></pre>
<p><strong>类型处理器</strong>（TypeHandler）实现自定义类型转换，如JSON类型与数据库字符串的转换：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JsonTypeHandler</span>&lt;T&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseTypeHandler</span>&lt;T&gt; {
    <span class="hljs-keyword">private</span> final <span class="hljs-title class_">Class</span>&lt;T&gt; <span class="hljs-keyword">type</span>;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setNonNullParameter</span>(<span class="hljs-params">PreparedStatement ps, int i, T parameter, JdbcType jdbcType</span>) {
        ps.<span class="hljs-title function_">setString</span>(i, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">toJSONString</span>(parameter));
    }
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getNullableResult</span>(<span class="hljs-params">ResultSet rs, <span class="hljs-built_in">String</span> columnName</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parseObject</span>(rs.<span class="hljs-title function_">getString</span>(columnName), <span class="hljs-keyword">type</span>);
    }
}
</code></pre>
<h2 data-id="heading-19">总结：MyBatis设计的平衡智慧</h2>
<p>MyBatis的设计观体现了工程领域的平衡智慧。它在控制与便利、灵活与稳定、简单与功能之间找到了恰当的平衡点。这种平衡不是妥协，而是对现实开发需求的深刻理解。</p>
<p><strong>精准的定位</strong>是MyBatis成功的关键。它不试图解决所有持久层问题，而是专注于为需要SQL控制权的场景提供最佳解决方案。<strong>适度的抽象</strong>让开发者既享受了ORM的便利，又保留了直接操作SQL的能力。</p>
<p>作为一款历经考验的持久层框架，MyBatis的设计思想值得每个后端开发者深入理解。在微服务和云原生时代，这种对透明性和可控性的重视显得更加珍贵，这也是MyBatis在现代应用架构中继续保持重要地位的原因。</p>
<p><strong>📚 下篇预告</strong>​</p>
<p>《MyBatis进阶治理点——缓存、副作用、拦截与批处理的得失分析》—— 我们将深入探讨：</p>
<ul>
<li>
<p>🎯 <strong>缓存深度治理</strong>：分布式环境下缓存一致性保障与失效策略</p>
</li>
<li>
<p>⚠️ <strong>副作用控制</strong>：并发场景下的数据竞争与隔离机制</p>
</li>
<li>
<p>🔧 <strong>拦截器高级应用</strong>：全链路SQL监控与性能诊断</p>
</li>
<li>
<p>📊 <strong>批处理优化</strong>：大数据量操作的性能瓶颈与解决方案</p>
</li>
<li>
<p>🛡️ <strong>生产环境实践</strong>：MyBatis在高并发场景下的稳定性保障</p>
</li>
</ul>
<p>**点击关注，掌握MyBatis进阶治理的核心要领！**​</p>
<blockquote>
<p><strong>今日行动建议</strong>：</p>
<ol>
<li>
<p>审查现有项目中动态SQL的复杂度，确保不超过可维护边界</p>
</li>
<li>
<p>检查缓存配置是否符合业务场景的数据一致性要求</p>
</li>
<li>
<p>统一项目中的映射文件规范，提高代码可维护性</p>
</li>
<li>
<p>针对复杂查询场景，制定SQL性能审核机制</p>
</li>
</ol>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Promise.resolve(x) 等同 new Promise(resolve => resolve(x))?]]></title>    <link>https://juejin.cn/post/7578681104292069419</link>    <guid>https://juejin.cn/post/7578681104292069419</guid>    <pubDate>2025-12-01T10:05:46.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7578681104292069419" data-draft-id="7578667193320996927" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Promise.resolve(x) 等同 new Promise(resolve =&gt; resolve(x))?"/> <meta itemprop="keywords" content="前端,Promise"/> <meta itemprop="datePublished" content="2025-12-01T10:05:46.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="之恒君"/> <meta itemprop="url" content="https://juejin.cn/user/2261046026312318"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Promise.resolve(x) 等同 new Promise(resolve =&gt; resolve(x))?
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2261046026312318/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    之恒君
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-01T10:05:46.000Z" title="Mon Dec 01 2025 10:05:46 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-01
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    1
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body cache result"><style>.markdown-body{color:#595959;font-size:15px;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(60,10,30,.04) 3%,transparent 0),linear-gradient(1turn,rgba(60,10,30,.04) 3%,transparent 0);background-size:20px 20px;background-position:50%}.markdown-body p{color:#595959;font-size:15px;line-height:2;font-weight:400}.markdown-body p+p{margin-top:16px}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{padding:30px 0;margin:0;color:#135ce0}.markdown-body h1{position:relative;text-align:center;font-size:22px;margin:50px 0}.markdown-body h1:before{position:absolute;content:"";top:-10px;left:50%;width:32px;height:32px;transform:translateX(-50%);background-size:100% 100%;opacity:.36;background-repeat:no-repeat;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABfVBMVEX///8Ad/8AgP8AgP8AgP8Aff8AgP8Af/8AgP8AVf8Af/8Af/8AgP8AgP8Af/8Afv8AAP8Afv8Afv8Aef8AgP8AdP8Afv8AgP8AgP8Acf8Ae/8AgP8Af/8AgP8Af/8Af/8AfP8Afv8AgP8Af/8Af/8Afv8Afv8AgP8Afv8AgP8Af/8Af/8AgP8AgP8Afv8AgP8Af/8AgP8AgP8AgP8Ae/8Afv8Af/8AgP8Af/8AgP8Af/8Af/8Aff8Af/8Abf8AgP8Af/8AgP8Af/8Af/8Afv8AgP8AgP8Afv8Afv8AgP8Af/8Aff8AgP8Afv8AgP8Aff8AgP8AfP8AgP8Ae/8AgP8Af/8AgP8AgP8AgP8Afv8AgP8AgP8AgP8Afv8AgP8AgP8AgP8AgP8AgP8Af/8AgP8Af/8Af/8Aev8Af/8AgP8Aff8Afv8AgP8AgP8AgP8Af/8AgP8Af/8Af/8AgP8Afv8AgP8AgP8AgP8AgP8Af/8AeP8Af/8Af/8Af//////rzEHnAAAAfXRSTlMAD7CCAivatxIDx5EMrP19AXdLEwgLR+6iCR/M0yLRzyFF7JupSXn8cw6v60Q0QeqzKtgeG237HMne850/6Qeq7QaZ+WdydHtj+OM3qENCMRYl1B3K2U7wnlWE/mhlirjkODa9FN/BF7/iNV/2kASNZpX1Wlf03C4stRGxgUPclqoAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEaBzgZ4yeM3AAAAT9JREFUOMvNUldbwkAQvCAqsSBoABE7asSOBRUVVBQNNuy9996789+9cMFAMHnVebmdm+/bmdtbQv4dOFOW2UjPzgFyLfo6nweKfIMOBYWwFtmMPGz2Yj2pJI0JDq3udJW6VVbmKa9I192VQFV1ktXUAl5NB0cd4KpnORqsEO2ZIRpF9gJfE9Dckqq0KuZt7UAH5+8EPF3spjsRpCeQNO/tA/qDwIDA+OCQbBoKA8NOdjMySgcZGVM6jwcgRuUiSs0nlPFNSrEpJfU0jTLD6llqbvKxei7OzvkFNQohi0vAsj81+MoqsCaoPOQFgus/1LyxichW+hS2JWCHZ7VlF9jb187pIAYcHiViHAMnp5mTjJ8B5xeEXF4B1ze/fTh/C0h398DDI9HB07O8ci+vRBdvdGnfP4gBuM8vw7X/G3wDmFhFZEdxzjMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDEtMjZUMDc6NTY6MjUrMDE6MDA67pVWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAxLTI2VDA3OjU2OjI1KzAxOjAwS7Mt6gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAWdEVYdFRpdGxlAGp1ZWppbl9sb2dvIGNvcHlxapmKAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC)}.markdown-body h2{position:relative;font-size:20px;border-left:4px solid;padding:0 0 0 10px;margin:30px 0}.markdown-body h3{font-size:16px}.markdown-body ul{list-style:disc outside;margin-left:2em;margin-top:1em}.markdown-body li{line-height:2;color:#595959}.markdown-body img.loaded{margin:0 auto;display:block}.markdown-body blockquote{background:#fff9f9;margin:2em 0;padding:2px 20px;border-left:4px solid #b2aec5}.markdown-body blockquote p{color:#666;line-height:2}.markdown-body a{color:#036aca;border-bottom:1px solid rgba(3,106,202,.8);font-weight:400;text-decoration:none}.markdown-body em strong,.markdown-body strong{color:#036aca}.markdown-body hr{border-top:1px solid #135ce0}.markdown-body pre{overflow:auto}.markdown-body code,.markdown-body pre{overflow:auto;position:relative;line-height:1.75;font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body table{border-collapse:collapse;margin:1rem 0;overflow-x:auto}.markdown-body table td,.markdown-body table th{border:1px solid #dfe2e5;padding:.6em 1em}.markdown-body table tr{border-top:1px solid #dfe2e5}.markdown-body table tr:nth-child(2n){background-color:#f6f8fa}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><code>Promise.resolve(x)</code> 与 <code>return new Promise((resolve) =&gt; resolve(x))</code> 在多数场景下行为一致，但不能完全等同理解，需从规范定义的细节差异区分，具体分析如下：</p>
<h3 data-id="heading-0">一、核心行为的一致性（基础场景）</h3>
<p>在处理“非Promise类型的x”或“非当前构造函数生成的Promise实例x”时，两者逻辑高度一致，均会创建一个新的Promise实例并以x为结果决议：</p>
<ol>
<li>若x是普通值（如数字、字符串、对象等非Promise/非thenable类型），<code>Promise.resolve(x)</code> 会创建新Promise并直接决议为fulfilled状态，结果为x；<code>new Promise((resolve) =&gt; resolve(x))</code> 也会通过调用resolve回调，让新Promise以x为结果fulfilled，这符合文档中<code>PromiseResolve</code>抽象操作对普通值的处理逻辑。</li>
<li>若x是thenable对象（含then方法的非Promise对象），两者都会触发“thenable同化”逻辑：调用x的then方法，用其结果决议新Promise，这与文档中<code>Promise Resolve Functions</code>处理thenable的步骤一致。</li>
</ol>
<h3 data-id="heading-1">二、关键差异（不能完全等同的场景）</h3>
<p>根据文档规范，<code>Promise.resolve(x)</code> 存在特殊优化逻辑，而 <code>new Promise(...)</code> 无此处理，导致两者在特定场景下行为不同：</p>
<ol>
<li><strong>x是当前构造函数生成的Promise实例时</strong></li>
</ol>
<blockquote>
<p><strong><code>Promise.resolve(x)</code></strong> 规范文档：<a href="https://link.juejin.cn?target=https%3A%2F%2Ftc39.es%2Fecma262%2Fmultipage%2Fcontrol-abstraction-objects.html%23sec-promise.resolve" target="_blank" title="https://tc39.es/ecma262/multipage/control-abstraction-objects.html#sec-promise.resolve" ref="nofollow noopener noreferrer">tc39.es/ecma262/mul…</a></p>
</blockquote>
<p>文档明确规定，若x是Promise实例且其构造函数与当前<code>Promise.resolve</code>的this值（即构造函数C）相同，<code>Promise.resolve(x)</code> 会直接返回x，而非创建新Promise。<br/>
例如：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>));
<span class="hljs-comment">// Promise.resolve(p) 直接返回p，不新建Promise</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(p) === p); <span class="hljs-comment">// true</span>
<span class="hljs-comment">// new Promise(...) 始终新建Promise，与p不是同一实例</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-title function_">resolve</span>(p)) === p); <span class="hljs-comment">// false</span>
</code></pre>
<p>这是<code>Promise.resolve</code>的核心优化，目的是避免对已存在的Promise实例重复包装，而<code>new Promise(...)</code>会强制新建实例，无法复用原有Promise。</p>
<ol start="2">
<li><strong>构造函数为Promise子类时</strong></li>
</ol>
<blockquote>
<ul>
<li><strong><code>NewPromiseCapability</code></strong> 规范文档：<a href="https://link.juejin.cn?target=https%3A%2F%2Ftc39.es%2Fecma262%2Fmultipage%2Fcontrol-abstraction-objects.html%23sec-newpromisecapability" target="_blank" title="https://tc39.es/ecma262/multipage/control-abstraction-objects.html#sec-newpromisecapability" ref="nofollow noopener noreferrer">tc39.es/ecma262/mul…</a></li>
</ul>
</blockquote>
<p>若<code>Promise.resolve</code>的this值是Promise子类（如<code>class MyPromise extends Promise {}</code>），<code>Promise.resolve(x)</code> 会通过<code>NewPromiseCapability</code>创建子类的Promise实例（若x非子类实例）；而<code>new Promise(...)</code>始终创建原生Promise实例，无法关联子类构造函数。<br/>
例如：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPromise</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Promise</span> {}
<span class="hljs-comment">// MyPromise.resolve(x) 创建MyPromise实例</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">MyPromise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">MyPromise</span>); <span class="hljs-comment">// true</span>
<span class="hljs-comment">// new Promise(...) 始终创建原生Promise实例</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>)) <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">MyPromise</span>); <span class="hljs-comment">// false</span>
</code></pre>
<h3 data-id="heading-2">三、结论：可近似理解，但需注意规范差异</h3>
<ul>
<li><strong>日常开发简化理解</strong>：在不涉及“Promise实例复用”和“Promise子类”的场景下，可将<code>Promise.resolve(x)</code>近似看作<code>return new Promise((resolve) =&gt; resolve(x))</code>，两者最终都会生成以x为结果的fulfilled Promise，行为无明显差异。</li>
<li><strong>严格规范角度</strong>：两者不能完全等同。<code>Promise.resolve(x)</code> 是ECMAScript规范定义的静态方法，包含“复用同构造函数Promise实例”“适配子类构造函数”等优化逻辑，而<code>new Promise(...)</code>是基础的Promise创建方式，仅负责新建实例并执行executor回调，无特殊优化。</li>
</ul>
<p><strong>简言之</strong>，<code>new Promise((resolve) =&gt; resolve(x))</code> 是<code>Promise.resolve(x)</code>的“基础实现逻辑”，但<code>Promise.resolve(x)</code>在规范层面补充了更智能的 <strong>实例复用</strong> 和 <strong>子类适配</strong> 逻辑，功能更完善。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[JavaScript 原型链：理解对象继承的核心机制]]></title>    <link>https://juejin.cn/post/7578460753211064347</link>    <guid>https://juejin.cn/post/7578460753211064347</guid>    <pubDate>2025-12-01T10:07:53.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7578460753211064347" data-draft-id="7578709098255269926" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="JavaScript 原型链：理解对象继承的核心机制"/> <meta itemprop="keywords" content="JavaScript,Promise"/> <meta itemprop="datePublished" content="2025-12-01T10:07:53.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Tzarevich"/> <meta itemprop="url" content="https://juejin.cn/user/578786070367529"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            JavaScript 原型链：理解对象继承的核心机制
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/578786070367529/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Tzarevich
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-01T10:07:53.000Z" title="Mon Dec 01 2025 10:07:53 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-01
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body cache result"><style>@charset "UTF-8";.markdown-body{line-height:1.75;font-family:-apple-system-font,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei UI,Microsoft YaHei,Arial,sans-serif;letter-spacing:2px;background-image:linear-gradient(90deg,rgba(50,0,0,.05) 3%,transparent 0),linear-gradient(1turn,rgba(50,0,0,.05) 3%,transparent 0);background-size:20px 20px;background-position:50%;word-break:break-word;font-weight:400;font-size:15px;overflow-x:hidden;color:#333}.markdown-body h1{font-size:23px;margin-bottom:5px;font-weight:700;padding-left:10px;border-left:5px solid #773098}.markdown-body h2{font-size:19px;font-weight:700;padding-left:10px;border-left:5px solid #916dd5}.markdown-body h3{font-size:17px;font-weight:700;padding-left:10px;border-left:5px solid #d89cf6}.markdown-body h4{font-size:16px}.markdown-body h5{font-size:15px}.markdown-body h6{font-size:14px;margin-top:5px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{display:block;max-width:100%;margin:1em 0;border-radius:6px;box-shadow:2px 4px 7px #999;user-select:none}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{padding:.2em .5em;font-weight:700;font-family:-apple-system-font,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei UI,Microsoft YaHei,Arial,sans-serif;font-size:1em;color:#916dd5;word-break:break-word;overflow-x:auto;background-color:none;border-radius:2px}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{display:block;font-family:-apple-system-font,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei UI,Microsoft YaHei,Arial,sans-serif;font-weight:400;font-size:.9em;padding:16px 12px;margin:0;color:#333;word-break:normal;overflow-x:auto;background:#f8f8f8;scroll-behavior:smooth}.markdown-body a{text-decoration:none;color:#916dd5;font-weight:700;border-bottom:1px solid #916dd5}.markdown-body a:active,.markdown-body a:hover{color:#773098}.markdown-body table{display:inline-block!important;font-size:14px;width:auto;max-width:100%;overflow:auto;border:1px solid #916dd5;border-collapse:collapse}.markdown-body thead{background-color:#916dd5;color:#fff;text-align:left}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px;border:1px solid #916dd5}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #d89cf6;background-color:#f4eeff}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0;line-height:26px}.markdown-body ol,.markdown-body ul{padding-left:28px;list-style-type:circle}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body b,.markdown-body strong{color:#916dd5;font-weight:700}.markdown-body b:before,.markdown-body strong:before{content:"「"}.markdown-body b:after,.markdown-body strong:after{content:"」"}.markdown-body em,.markdown-body i{color:#916dd5}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="atelier-cave-light">.hljs-comment,.hljs-quote{color:#655f6d}.hljs-attribute,.hljs-link,.hljs-name,.hljs-regexp,.hljs-selector-class,.hljs-selector-id,.hljs-tag,.hljs-template-variable,.hljs-variable{color:#be4678}.hljs-built_in,.hljs-builtin-name,.hljs-literal,.hljs-meta,.hljs-number,.hljs-params,.hljs-type{color:#aa573c}.hljs-bullet,.hljs-string,.hljs-symbol{color:#2a9292}.hljs-section,.hljs-title{color:#576ddb}.hljs-keyword,.hljs-selector-tag{color:#955ae7}.hljs-addition,.hljs-deletion{color:#19171c;display:inline-block;width:100%}.hljs-deletion{background-color:#be4678}.hljs-addition{background-color:#2a9292}.markdown-body pre,.markdown-body pre&gt;code.hljs{background:#efecf4;color:#585260}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">JavaScript 原型链：理解对象继承的核心机制</h2>
<p>在 JavaScript 中，<strong>原型链（Prototype Chain）</strong> 是实现对象继承和属性查找的核心机制。与传统面向对象语言（如 Java、C++）基于“类”的继承不同，JavaScript 采用的是 <strong>基于原型的继承模型</strong>。本文将结合 <code>Promise</code> 实例和普通构造函数示例，深入浅出地解析原型链的工作原理。</p>
<hr/>
<h3 data-id="heading-1">一、什么是原型链？</h3>
<p>每个 JavaScript 对象（除 <code>null</code> 外）内部都有一个隐藏属性 <code>[[Prototype]]</code>（可通过 <code>__proto__</code> 访问），它指向另一个对象——这个对象就是该对象的“原型”。当试图访问一个对象的属性时，如果该对象自身没有这个属性，JavaScript 引擎会沿着原型链向上查找，直到找到该属性或到达原型链的末端（即 <code>null</code>）。</p>
<blockquote>
<p><strong>关键点</strong>：JavaScript 的继承不是靠“血缘”，而是靠“链条”——原型链。</p>
</blockquote>
<hr/>
<h3 data-id="heading-2">二、构造函数、原型对象与实例的关系</h3>
<p>以自定义构造函数为例：</p>
<pre><code class="hljs language-ini" lang="ini">function Person(name, age) {
  <span class="hljs-attr">this.name</span> = name<span class="hljs-comment">;</span>
  <span class="hljs-attr">this.age</span> = age<span class="hljs-comment">;</span>
}

<span class="hljs-attr">Person.prototype.species</span> = <span class="hljs-string">'人'</span><span class="hljs-comment">;</span>

let <span class="hljs-attr">zeng</span> = new Person(<span class="hljs-string">'jw'</span>, <span class="hljs-number">18</span>)<span class="hljs-comment">;</span>
</code></pre>
<ul>
<li><code>Person</code> 是一个构造函数。</li>
<li><code>Person.prototype</code> 是一个普通对象，所有通过 <code>new Person()</code> 创建的实例都会以它为原型。</li>
<li><code>zeng.__proto__ === Person.prototype</code> → <strong>成立</strong></li>
<li><code>Person.prototype.constructor === Person</code> → <strong>成立</strong></li>
</ul>
<p>这种结构形成了经典的“三角关系”：</p>
<ul>
<li>实例（<code>zeng</code>）通过 <code>__proto__</code> 指向原型对象（<code>Person.prototype</code>）</li>
<li>原型对象通过 <code>constructor</code> 指回构造函数（<code>Person</code>）</li>
</ul>
<blockquote>
<p>🚂 比喻：可以把 <code>constructor</code> 看作火车头，<code>prototype</code> 是车身，而每个实例是挂在车身后的车厢。它们通过“挂钩”（<code>__proto__</code>）连接在一起。</p>
</blockquote>
<hr/>
<h3 data-id="heading-3">三、动态修改原型：打破常规</h3>
<p>JavaScript 的原型是<strong>可变的</strong>。我们可以随时修改对象的 <code>__proto__</code>：</p>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">kong</span> = {
  name: 'kong',
  hobbies: <span class="hljs-section">['篮球', '足球']</span>,
}<span class="hljs-comment">;</span>

<span class="hljs-attr">zeng.__proto__</span> = kong<span class="hljs-comment">;</span>
console.log(zeng.hobbies)<span class="hljs-comment">; // ['篮球', '足球']</span>
console.log(zeng.species)<span class="hljs-comment">; // undefined</span>
</code></pre>
<p>此时：</p>
<ul>
<li><code>zeng</code> 不再从 <code>Person.prototype</code> 继承属性；</li>
<li>而是从 <code>kong</code> 对象继承；</li>
<li>因此 <code>species</code> 找不到了，但 <code>hobbies</code> 可以访问。</li>
</ul>
<blockquote>
<p>⚠️ 注意：虽然技术上可行，但<strong>不推荐随意修改 <code>__proto__</code></strong> ，因为它会破坏性能优化，并可能导致代码难以维护。</p>
</blockquote>
<hr/>
<h3 data-id="heading-4">四、内置对象也遵循原型链：以 Promise 为例</h3>
<p>ES6 引入的 <code>Promise</code> 同样遵循原型链规则：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">reject</span>(<span class="hljs-string">'失败1'</span>), <span class="hljs-number">3000</span>);
});
</code></pre>
<ul>
<li><code>p</code> 是一个 <code>Promise</code> 实例；</li>
<li><code>p.__proto__ === Promise.prototype</code> → <strong>true</strong></li>
<li><code>Promise.prototype</code> 上定义了 <code>.then()</code>, <code>.catch()</code>, <code>.finally()</code> 等方法；</li>
<li>所以 <code>p.then(...)</code> 实际上调用的是 <code>Promise.prototype.then</code></li>
</ul>
<p>执行流程：</p>
<ol>
<li><code>new Promise(...)</code> 立即执行 executor 函数（同步）→ 输出 <code>'111'</code></li>
<li>主线程继续执行 → 输出 <code>'222'</code> 和 <code>p</code> 的初始状态（pending）</li>
<li>3 秒后，<code>reject('失败1')</code> 触发状态变为 <code>rejected</code></li>
<li>微任务队列中安排 <code>.catch()</code> 回调 → 输出 <code>'失败1'</code></li>
<li><code>.finally()</code> 总是执行 → 输出 <code>'finally'</code></li>
</ol>
<p>这再次印证：<strong>所有对象的行为都依赖于其原型链上的方法</strong>。</p>
<hr/>
<h3 data-id="heading-5">五、原型链的本质：属性查找机制</h3>
<p>当你写 <code>obj.method()</code> 时，JavaScript 引擎会：</p>
<ol>
<li>在 <code>obj</code> 自身查找 <code>method</code></li>
<li>若无，则查找 <code>obj.__proto__</code></li>
<li>若仍无，继续查找 <code>obj.__proto__.__proto__</code></li>
<li>……直到 <code>Object.prototype</code>（最顶层）</li>
<li>若最终找不到，返回 <code>undefined</code></li>
</ol>
<p>例如：</p>
<pre><code class="hljs language-scss" lang="scss">zeng<span class="hljs-selector-class">.toString</span>(); <span class="hljs-comment">// 虽然 zeng 自身没有 toString，但 Object.prototype 有</span>
</code></pre>
<p>因为：</p>
<pre><code class="hljs language-ini" lang="ini">zeng 
→ <span class="hljs-attr">__proto__</span> = kong 
→ <span class="hljs-attr">__proto__</span> = Object.prototype 
→ has toString()
</code></pre>
<hr/>
<h3 data-id="heading-6">六、总结</h3>

























<table><thead><tr><th>概念</th><th>说明</th></tr></thead><tbody><tr><td><code>__proto__</code></td><td>实例指向其原型的链接（非标准但广泛支持）</td></tr><tr><td><code>prototype</code></td><td>构造函数的属性，用于被实例的 <code>__proto__</code> 引用</td></tr><tr><td><code>constructor</code></td><td>原型对象上的属性，指回构造函数</td></tr><tr><td>原型链</td><td>属性/方法查找的路径，从实例 → 原型 → 原型的原型 → … → <code>null</code></td></tr></tbody></table>
<p>JavaScript 的面向对象不是靠“类继承”，而是靠“对象委托”——<strong>你没有的，我帮你问我的原型要</strong>。这种灵活而强大的机制，正是 JavaScript 动态特性的基石。</p>
<blockquote>
<p>✅ 牢记：<strong>一切皆对象，万物皆可链</strong>。理解原型链，就掌握了 JavaScript 面向对象的灵魂。</p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[GeoJSON 介绍：Web 地图数据的通用语言]]></title>    <link>https://juejin.cn/post/7578714759336640512</link>    <guid>https://juejin.cn/post/7578714759336640512</guid>    <pubDate>2025-12-01T10:12:32.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7578714759336640512" data-draft-id="7578820431017689103" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="GeoJSON 介绍：Web 地图数据的通用语言"/> <meta itemprop="keywords" content="前端,JavaScript,JSON"/> <meta itemprop="datePublished" content="2025-12-01T10:12:32.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="东东233"/> <meta itemprop="url" content="https://juejin.cn/user/3139860940201453"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            GeoJSON 介绍：Web 地图数据的通用语言
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3139860940201453/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    东东233
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-01T10:12:32.000Z" title="Mon Dec 01 2025 10:12:32 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-01
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    1
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body cache result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">GeoJSON 介绍：Web 地图数据的通用语言</h2>
<h3 data-id="heading-1">引言</h3>
<p>GeoJSON 是一套基于 JSON 格式的地理空间数据编码标准，具有轻量、易读、易于在 Web 应用中解析和传输等优势，它是 Web 地图库（如 Leaflet, Mapbox, OpenLayers）事实上的标准数据格式，我最近在看 OpenLayers，在加载外部数据的时候都是用 GeoJSON，于是便了解了一下，这里是最新规范的英文文档、英语好的可以直接跳转<a href="https://link.juejin.cn?target=https%3A%2F%2Fdatatracker.ietf.org%2Fdoc%2Fhtml%2Frfc7946" target="_blank" title="https://datatracker.ietf.org/doc/html/rfc7946" ref="nofollow noopener noreferrer">这里</a></p>
<h3 data-id="heading-2">GeoJSON 基本构成</h3>
<p>GeoJSON 本质上就是一个标准的 JSON 对象，所有 GeoJSON 对象必须有一个 "type" 成员，"type"表示当前 JSON 描述的类型，这里分为基本几何类型和特征类型。</p>
<p>基本几何类型快速理解就是描述地图上形状的类型，“type” 取值包括 点 （Point）、线（LineString）、区域（Polygon）以及他们的多重类型 MultiPoint, MultiLineString, MultiPolygon，其“coordinates” 属性用来标注地理坐标位置（经纬度基于 WGS84 坐标系）</p>
<p>特征类型即带有属性（properties）的类型，“type” 取值包括 Feature 和 FeatureCollection</p>
<h3 data-id="heading-3">基本几何类型</h3>
<h4 data-id="heading-4">Point（点）</h4>
<p>表示地图上的一个点，结构如下</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Point"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"coordinates"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-number">106.56</span><span class="hljs-punctuation">,</span> <span class="hljs-number">29.57</span><span class="hljs-punctuation">]</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<h4 data-id="heading-5">LineString (线)</h4>
<p>表示地图上的一条线，可以理解为有多个点连接组成，“coordinates” 为一个二维数组</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"LineString"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"coordinates"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
    <span class="hljs-punctuation">[</span><span class="hljs-number">106.51398305678325</span><span class="hljs-punctuation">,</span> <span class="hljs-number">29.523171668355733</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
    <span class="hljs-punctuation">[</span><span class="hljs-number">106.51453664249686</span><span class="hljs-punctuation">,</span> <span class="hljs-number">29.523092142346467</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
    <span class="hljs-punctuation">[</span><span class="hljs-number">106.51566579820047</span><span class="hljs-punctuation">,</span> <span class="hljs-number">29.522995404990354</span><span class="hljs-punctuation">]</span>
  <span class="hljs-punctuation">]</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<h4 data-id="heading-6">Polygon (多边形)</h4>
<p>表示地图上的一个多边形，“coordinates” 由多个环组成、环即由多个点组成的闭合的路径、最后一个点表示闭合点，注意这里可能包含多个环形元素，第一个环表示外部环、其余表示内部环，比如空心圆就由一个内部环和一个外部环组成、外部环通常由逆时针顺序定义，内部的洞应以顺时针方向定义。</p>
<p>一个包含环的多边形示例如下</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Polygon"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"coordinates"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
    <span class="hljs-punctuation">[</span>
      <span class="hljs-punctuation">[</span><span class="hljs-number">106.50</span><span class="hljs-punctuation">,</span> <span class="hljs-number">29.60</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
      <span class="hljs-punctuation">[</span><span class="hljs-number">106.50</span><span class="hljs-punctuation">,</span> <span class="hljs-number">29.50</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
      <span class="hljs-punctuation">[</span><span class="hljs-number">106.60</span><span class="hljs-punctuation">,</span> <span class="hljs-number">29.50</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
      <span class="hljs-punctuation">[</span><span class="hljs-number">106.60</span><span class="hljs-punctuation">,</span> <span class="hljs-number">29.60</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
      <span class="hljs-punctuation">[</span><span class="hljs-number">106.50</span><span class="hljs-punctuation">,</span> <span class="hljs-number">29.60</span><span class="hljs-punctuation">]</span> 
    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
    <span class="hljs-punctuation">[</span>
      <span class="hljs-punctuation">[</span><span class="hljs-number">106.53</span><span class="hljs-punctuation">,</span> <span class="hljs-number">29.57</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
      <span class="hljs-punctuation">[</span><span class="hljs-number">106.57</span><span class="hljs-punctuation">,</span> <span class="hljs-number">29.57</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
      <span class="hljs-punctuation">[</span><span class="hljs-number">106.57</span><span class="hljs-punctuation">,</span> <span class="hljs-number">29.53</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
      <span class="hljs-punctuation">[</span><span class="hljs-number">106.53</span><span class="hljs-punctuation">,</span> <span class="hljs-number">29.53</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
      <span class="hljs-punctuation">[</span><span class="hljs-number">106.53</span><span class="hljs-punctuation">,</span> <span class="hljs-number">29.57</span><span class="hljs-punctuation">]</span>
    <span class="hljs-punctuation">]</span>
  <span class="hljs-punctuation">]</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p>把第二段JSON删掉就是没有环的矩形</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Polygon"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"coordinates"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
    <span class="hljs-punctuation">[</span>
      <span class="hljs-punctuation">[</span><span class="hljs-number">106.50</span><span class="hljs-punctuation">,</span> <span class="hljs-number">29.60</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
      <span class="hljs-punctuation">[</span><span class="hljs-number">106.50</span><span class="hljs-punctuation">,</span> <span class="hljs-number">29.50</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
      <span class="hljs-punctuation">[</span><span class="hljs-number">106.60</span><span class="hljs-punctuation">,</span> <span class="hljs-number">29.50</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
      <span class="hljs-punctuation">[</span><span class="hljs-number">106.60</span><span class="hljs-punctuation">,</span> <span class="hljs-number">29.60</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
      <span class="hljs-punctuation">[</span><span class="hljs-number">106.50</span><span class="hljs-punctuation">,</span> <span class="hljs-number">29.60</span><span class="hljs-punctuation">]</span> 
    <span class="hljs-punctuation">]</span>
  <span class="hljs-punctuation">]</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<h4 data-id="heading-7">MultiPoint（多点）</h4>
<p>表示一组不相连的点、Point的复数形式、多个点组成的二维数组</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"MultiPoint"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"coordinates"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
    <span class="hljs-punctuation">[</span><span class="hljs-number">106.50</span><span class="hljs-punctuation">,</span> <span class="hljs-number">29.60</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
    <span class="hljs-punctuation">[</span><span class="hljs-number">106.50</span><span class="hljs-punctuation">,</span> <span class="hljs-number">29.50</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
    <span class="hljs-punctuation">[</span><span class="hljs-number">106.60</span><span class="hljs-punctuation">,</span> <span class="hljs-number">29.50</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
    <span class="hljs-punctuation">[</span><span class="hljs-number">106.60</span><span class="hljs-punctuation">,</span> <span class="hljs-number">29.60</span><span class="hljs-punctuation">]</span>
  <span class="hljs-punctuation">]</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<h4 data-id="heading-8">MultiLineString (多线串)</h4>
<p>表示一组不相连的线串，LineString的复数形式，多条线组成的三层数组</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"MultiLineString"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"coordinates"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
    <span class="hljs-punctuation">[</span>
      <span class="hljs-punctuation">[</span><span class="hljs-number">106.51398305678325</span><span class="hljs-punctuation">,</span> <span class="hljs-number">29.523171668355733</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
      <span class="hljs-punctuation">[</span><span class="hljs-number">106.51453664249686</span><span class="hljs-punctuation">,</span> <span class="hljs-number">29.523092142346467</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
      <span class="hljs-punctuation">[</span><span class="hljs-number">106.51566579820047</span><span class="hljs-punctuation">,</span> <span class="hljs-number">29.522995404990354</span><span class="hljs-punctuation">]</span>
    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
    <span class="hljs-punctuation">[</span>
      <span class="hljs-punctuation">[</span><span class="hljs-number">106.51398305678325</span><span class="hljs-punctuation">,</span> <span class="hljs-number">29.533171668355733</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
      <span class="hljs-punctuation">[</span><span class="hljs-number">106.51453664249686</span><span class="hljs-punctuation">,</span> <span class="hljs-number">29.533092142346467</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
      <span class="hljs-punctuation">[</span><span class="hljs-number">106.51566579820047</span><span class="hljs-punctuation">,</span> <span class="hljs-number">29.532995404990354</span><span class="hljs-punctuation">]</span>
    <span class="hljs-punctuation">]</span>
  <span class="hljs-punctuation">]</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<h4 data-id="heading-9">MultiPolygon (多多边形):</h4>
<p>表示一组不相连的多边形、坐标是四层数组，每组坐标代表一个独立的 Polygon（每个 Polygon 内部仍可包含洞）。</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"MultiPolygon"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"coordinates"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
    <span class="hljs-punctuation">[</span>
      <span class="hljs-punctuation">[</span>
        <span class="hljs-punctuation">[</span><span class="hljs-number">106.50</span><span class="hljs-punctuation">,</span> <span class="hljs-number">29.55</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
        <span class="hljs-punctuation">[</span><span class="hljs-number">106.50</span><span class="hljs-punctuation">,</span> <span class="hljs-number">29.50</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
        <span class="hljs-punctuation">[</span><span class="hljs-number">106.55</span><span class="hljs-punctuation">,</span> <span class="hljs-number">29.50</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
        <span class="hljs-punctuation">[</span><span class="hljs-number">106.55</span><span class="hljs-punctuation">,</span> <span class="hljs-number">29.55</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
        <span class="hljs-punctuation">[</span><span class="hljs-number">106.50</span><span class="hljs-punctuation">,</span> <span class="hljs-number">29.55</span><span class="hljs-punctuation">]</span>
      <span class="hljs-punctuation">]</span>
    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
    <span class="hljs-punctuation">[</span>
      <span class="hljs-punctuation">[</span>
        <span class="hljs-punctuation">[</span><span class="hljs-number">106.65</span><span class="hljs-punctuation">,</span> <span class="hljs-number">29.65</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
        <span class="hljs-punctuation">[</span><span class="hljs-number">106.65</span><span class="hljs-punctuation">,</span> <span class="hljs-number">29.60</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
        <span class="hljs-punctuation">[</span><span class="hljs-number">106.70</span><span class="hljs-punctuation">,</span> <span class="hljs-number">29.60</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
        <span class="hljs-punctuation">[</span><span class="hljs-number">106.70</span><span class="hljs-punctuation">,</span> <span class="hljs-number">29.65</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
        <span class="hljs-punctuation">[</span><span class="hljs-number">106.65</span><span class="hljs-punctuation">,</span> <span class="hljs-number">29.65</span><span class="hljs-punctuation">]</span>
      <span class="hljs-punctuation">]</span>
    <span class="hljs-punctuation">]</span>
  <span class="hljs-punctuation">]</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<h4 data-id="heading-10">GeometryCollection (几何集合)</h4>
<p>用于将不同类型（Point, LineString, Polygon, Multi*）的几何图形封装到一个对象中， 包含一个 "geometries" 成员，其值是一个数组，数组中的每个元素都是一个完整的 GeoJSON 几何对象</p>
<p>一个包含 Point, LineString, Polygon 的 对象</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"GeometryCollection"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"geometries"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
    <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Point"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"coordinates"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-number">106.52</span><span class="hljs-punctuation">,</span> <span class="hljs-number">29.53</span><span class="hljs-punctuation">]</span>
    <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
    <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"LineString"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"coordinates"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
        <span class="hljs-punctuation">[</span><span class="hljs-number">106.50</span><span class="hljs-punctuation">,</span> <span class="hljs-number">29.50</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
        <span class="hljs-punctuation">[</span><span class="hljs-number">106.53</span><span class="hljs-punctuation">,</span> <span class="hljs-number">29.50</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
        <span class="hljs-punctuation">[</span><span class="hljs-number">106.53</span><span class="hljs-punctuation">,</span> <span class="hljs-number">29.55</span><span class="hljs-punctuation">]</span>
      <span class="hljs-punctuation">]</span>
    <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
    <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Polygon"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"coordinates"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
        <span class="hljs-punctuation">[</span>
          <span class="hljs-punctuation">[</span><span class="hljs-number">106.55</span><span class="hljs-punctuation">,</span> <span class="hljs-number">29.55</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
          <span class="hljs-punctuation">[</span><span class="hljs-number">106.55</span><span class="hljs-punctuation">,</span> <span class="hljs-number">29.50</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
          <span class="hljs-punctuation">[</span><span class="hljs-number">106.60</span><span class="hljs-punctuation">,</span> <span class="hljs-number">29.50</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
          <span class="hljs-punctuation">[</span><span class="hljs-number">106.60</span><span class="hljs-punctuation">,</span> <span class="hljs-number">29.55</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
          <span class="hljs-punctuation">[</span><span class="hljs-number">106.55</span><span class="hljs-punctuation">,</span> <span class="hljs-number">29.55</span><span class="hljs-punctuation">]</span>
        <span class="hljs-punctuation">]</span>
      <span class="hljs-punctuation">]</span>
    <span class="hljs-punctuation">}</span>
  <span class="hljs-punctuation">]</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<h3 data-id="heading-11">特征类型</h3>
<p>这个可以说是GeoJSON 的灵魂，它将几何形状与属性数据关联起来，使得图形有了意义，包括两个类型：“Feature” 和 “FeatureCollection”</p>
<h4 data-id="heading-12">Feature</h4>
<p>基本结构如下：</p>
<ul>
<li>"type": "Feature"</li>
<li>"geometry"：包含一个几何对象（Point, Polygon, etc.）。</li>
<li>"properties"：包含任何非地理属性数据（例如：名称、人口、年份、颜色等）。</li>
</ul>
<p>下面为一个LineString、属性描述其为一条高速公路</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Feature"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"geometry"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"LineString"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"coordinates"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
      <span class="hljs-punctuation">[</span><span class="hljs-number">106.50</span><span class="hljs-punctuation">,</span> <span class="hljs-number">29.50</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
      <span class="hljs-punctuation">[</span><span class="hljs-number">106.55</span><span class="hljs-punctuation">,</span> <span class="hljs-number">29.52</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
      <span class="hljs-punctuation">[</span><span class="hljs-number">106.60</span><span class="hljs-punctuation">,</span> <span class="hljs-number">29.54</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
      <span class="hljs-punctuation">[</span><span class="hljs-number">106.65</span><span class="hljs-punctuation">,</span> <span class="hljs-number">29.56</span><span class="hljs-punctuation">]</span>
    <span class="hljs-punctuation">]</span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"properties"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"id"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"G5001"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"重庆绕城高速（部分）"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"speed"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">100</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"length"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">15.5</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<h4 data-id="heading-13">FeatureCollection</h4>
<p>FeatureCollection 表示Feature的集合，几乎网上下载的GeoJSON文件都是 FeatureCollection 结构的 基本结构：</p>
<ul>
<li>"type": "FeatureCollection"</li>
<li>"features"：一个包含零个或多个 Feature 对象的数组。</li>
</ul>
<p>一个表示线路和服务区的 GeoJSON</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"FeatureCollection"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"features"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
    <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Feature"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"geometry"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"LineString"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"coordinates"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
          <span class="hljs-punctuation">[</span><span class="hljs-number">106.40</span><span class="hljs-punctuation">,</span> <span class="hljs-number">29.50</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
          <span class="hljs-punctuation">[</span><span class="hljs-number">106.45</span><span class="hljs-punctuation">,</span> <span class="hljs-number">29.52</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
          <span class="hljs-punctuation">[</span><span class="hljs-number">106.50</span><span class="hljs-punctuation">,</span> <span class="hljs-number">29.54</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
          <span class="hljs-punctuation">[</span><span class="hljs-number">106.55</span><span class="hljs-punctuation">,</span> <span class="hljs-number">29.56</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
          <span class="hljs-punctuation">[</span><span class="hljs-number">106.60</span><span class="hljs-punctuation">,</span> <span class="hljs-number">29.58</span><span class="hljs-punctuation">]</span>
        <span class="hljs-punctuation">]</span>
      <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"properties"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">"id"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"H-1234"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"城市快速通道A段"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-punctuation">}</span>
    <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
    <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Feature"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"geometry"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Point"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"coordinates"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-number">106.45</span><span class="hljs-punctuation">,</span> <span class="hljs-number">29.52</span><span class="hljs-punctuation">]</span>
      <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"properties"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">"id"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"SA-001"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"龙溪服务区"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-punctuation">}</span>
    <span class="hljs-punctuation">}</span>
  <span class="hljs-punctuation">]</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<h3 data-id="heading-14">OpenLayers 中使用</h3>
<p>在OpenLayers中写了两个Demo巩固、一个用于绘制线路后导出GeoJSON文件，另一个加载导出的文件根据渲染线路和服务区</p>
<h4 data-id="heading-15">绘制线路以及站点</h4>
<p>涉及主要功能点：</p>
<ul>
<li>绘制线路，并为香炉加上线路表示以及名字</li>
<li>绘制站点，并为站点加上站点标识以及名字</li>
</ul>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> { useEffect, useRef, useState } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> layer <span class="hljs-keyword">from</span> <span class="hljs-string">'ol/layer'</span>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> source <span class="hljs-keyword">from</span> <span class="hljs-string">'ol/source'</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Map</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'ol'</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">View</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'ol/View.js'</span>
<span class="hljs-keyword">import</span> <span class="hljs-variable constant_">OSM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'ol/source/OSM'</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Style</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'ol/style/Style'</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Stroke</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'ol/style/Stroke'</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Fill</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'ol/style/Fill'</span>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> format <span class="hljs-keyword">from</span> <span class="hljs-string">'ol/format'</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">CircleStyle</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'ol/style/Circle'</span>

<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> interaction <span class="hljs-keyword">from</span> <span class="hljs-string">'ol/interaction'</span>
<span class="hljs-keyword">import</span> type { <span class="hljs-title class_">DrawEvent</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'ol/interaction/Draw'</span>
<span class="hljs-keyword">const</span> projection = <span class="hljs-string">'EPSG:4326'</span>

<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>

<span class="hljs-keyword">const</span> <span class="hljs-title function_">createDrawStyle</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Style</span>({
    <span class="hljs-attr">image</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">CircleStyle</span>({
      <span class="hljs-attr">radius</span>: <span class="hljs-number">4</span>,
      <span class="hljs-attr">fill</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fill</span>({
        <span class="hljs-attr">color</span>: <span class="hljs-string">'#000000'</span>
      })
    }),
    <span class="hljs-attr">stroke</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stroke</span>({
      <span class="hljs-attr">width</span>: <span class="hljs-number">2</span>,
      <span class="hljs-attr">color</span>: <span class="hljs-string">'red'</span>
    })
  })
}
<span class="hljs-keyword">const</span> <span class="hljs-title function_">DrawLine</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-keyword">const</span> mapRef = useRef&lt;<span class="hljs-title class_">Map</span>&gt;(<span class="hljs-literal">null</span>)
  <span class="hljs-keyword">const</span> drawRef = useRef&lt;interaction.<span class="hljs-property">Draw</span>&gt;(<span class="hljs-literal">null</span>)
  <span class="hljs-keyword">const</span> drawSource = useRef&lt;source.<span class="hljs-property">Vector</span>&gt;(<span class="hljs-literal">null</span>)
  <span class="hljs-keyword">const</span> [drawType, setDrawType] = useState&lt;string&gt;(<span class="hljs-string">'Point'</span>)

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> vectorSource = <span class="hljs-keyword">new</span> source.<span class="hljs-title class_">Vector</span>()
    drawSource.<span class="hljs-property">current</span> = vectorSource
    <span class="hljs-keyword">const</span> vectorLayer = <span class="hljs-keyword">new</span> layer.<span class="hljs-title class_">Vector</span>({
      <span class="hljs-attr">source</span>: vectorSource,
      <span class="hljs-attr">style</span>: <span class="hljs-title function_">createDrawStyle</span>()
    })

    <span class="hljs-keyword">const</span> osmLayer = <span class="hljs-keyword">new</span> layer.<span class="hljs-title class_">Tile</span>({
      <span class="hljs-attr">source</span>: <span class="hljs-keyword">new</span> <span class="hljs-title function_">OSM</span>()
    })

    <span class="hljs-keyword">const</span> view = <span class="hljs-keyword">new</span> <span class="hljs-title class_">View</span>({
      <span class="hljs-attr">zoom</span>: <span class="hljs-number">10</span>,
      projection,
      <span class="hljs-attr">center</span>: [<span class="hljs-number">106.56</span>, <span class="hljs-number">29.57</span>]
    })

    <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>({
      <span class="hljs-attr">target</span>: <span class="hljs-string">'draw'</span>,
      <span class="hljs-attr">layers</span>: [osmLayer, vectorLayer],
      view,
      <span class="hljs-attr">controls</span>: []
    })
    <span class="hljs-keyword">const</span> draw = <span class="hljs-keyword">new</span> interaction.<span class="hljs-title class_">Draw</span>({
      <span class="hljs-attr">type</span>: <span class="hljs-string">'Point'</span>,
      <span class="hljs-attr">source</span>: vectorSource
    })
    map.<span class="hljs-title function_">addInteraction</span>(draw)
    mapRef.<span class="hljs-property">current</span> = map
    drawRef.<span class="hljs-property">current</span> = draw
  }, [])

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params">event: React.ChangeEvent&lt;HTMLInputElement&gt;</span>) =&gt; {
    <span class="hljs-title function_">setDrawType</span>(event.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>)
  }

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> map = mapRef.<span class="hljs-property">current</span>!
    <span class="hljs-keyword">const</span> source = drawSource.<span class="hljs-property">current</span>!
    source.<span class="hljs-title function_">getFeatures</span>().<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> {
      <span class="hljs-keyword">if</span>(item.<span class="hljs-title function_">getGeometry</span>()?.<span class="hljs-title function_">getType</span>() === drawType) {
        source.<span class="hljs-title function_">removeFeature</span>(item)
      }
    })
    map.<span class="hljs-title function_">removeInteraction</span>(drawRef.<span class="hljs-property">current</span>!)
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleDrawEnd</span> = (<span class="hljs-params">event: DrawEvent</span>) =&gt; {
      <span class="hljs-keyword">const</span> feature = event.<span class="hljs-property">feature</span>
      feature.<span class="hljs-title function_">setProperties</span>({
        <span class="hljs-attr">type</span>: drawType === <span class="hljs-string">'Point'</span> ? <span class="hljs-string">'station'</span> : <span class="hljs-string">'line'</span>,
        <span class="hljs-attr">name</span>: drawType === <span class="hljs-string">'Point'</span> ? <span class="hljs-string">'站点'</span> + i : <span class="hljs-string">'高速'</span>
      })
      i++
    }
    <span class="hljs-keyword">const</span> draw = <span class="hljs-keyword">new</span> interaction.<span class="hljs-title class_">Draw</span>({
      <span class="hljs-attr">type</span>: drawType,
      <span class="hljs-attr">source</span>: source,
      <span class="hljs-attr">style</span>: <span class="hljs-title function_">createDrawStyle</span>()
    })
    draw.<span class="hljs-title function_">on</span>(<span class="hljs-string">'drawend'</span>, handleDrawEnd)
    drawRef.<span class="hljs-property">current</span> = draw
    map.<span class="hljs-title function_">addInteraction</span>(draw)
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
      draw.<span class="hljs-title function_">un</span>(<span class="hljs-string">'drawend'</span>, handleDrawEnd)
    }
  }, [drawType])

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleExport</span> = (<span class="hljs-params"/>) =&gt; {
    <span class="hljs-keyword">const</span> source = drawSource.<span class="hljs-property">current</span>!
    <span class="hljs-keyword">const</span> features = source.<span class="hljs-title function_">getFeatures</span>()
    <span class="hljs-keyword">const</span> featureProjection = mapRef
      .<span class="hljs-property">current</span>!.<span class="hljs-title function_">getView</span>()
      .<span class="hljs-title function_">getProjection</span>()
      .<span class="hljs-title function_">getCode</span>()
    <span class="hljs-keyword">const</span> jsonFormat = <span class="hljs-keyword">new</span> format.<span class="hljs-title class_">GeoJSON</span>({
      featureProjection,
      <span class="hljs-attr">dataProjection</span>: projection
    })

    <span class="hljs-keyword">const</span> json = jsonFormat.<span class="hljs-title function_">writeFeatures</span>(features, {
      featureProjection,
      <span class="hljs-attr">dataProjection</span>: projection
    })
    <span class="hljs-comment">// 导出</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(json, <span class="hljs-string">'&gt;&gt;&gt;&gt;'</span>)
  }

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>
        <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span>
          <span class="hljs-attr">width:</span> '<span class="hljs-attr">800px</span>',
          <span class="hljs-attr">height:</span> '<span class="hljs-attr">400px</span>',
          <span class="hljs-attr">position:</span> '<span class="hljs-attr">relative</span>',
          <span class="hljs-attr">display:</span> '<span class="hljs-attr">flex</span>'
        }}
      &gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"draw"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">width:</span> '<span class="hljs-attr">800px</span>', <span class="hljs-attr">height:</span> '<span class="hljs-attr">400px</span>' }}&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">input</span>
        <span class="hljs-attr">type</span>=<span class="hljs-string">"radio"</span>
        <span class="hljs-attr">checked</span>=<span class="hljs-string">{drawType</span> === <span class="hljs-string">'Point'</span>}
        <span class="hljs-attr">value</span>=<span class="hljs-string">{</span>'<span class="hljs-attr">Point</span>'}
        <span class="hljs-attr">onChange</span>=<span class="hljs-string">{handleClick}</span>
      /&gt;</span>{' '}
      添加站点
      <span class="hljs-tag">&lt;<span class="hljs-name">input</span>
        <span class="hljs-attr">type</span>=<span class="hljs-string">"radio"</span>
        <span class="hljs-attr">checked</span>=<span class="hljs-string">{drawType</span> === <span class="hljs-string">'LineString'</span>}
        <span class="hljs-attr">value</span>=<span class="hljs-string">{</span>'<span class="hljs-attr">LineString</span>'}
        <span class="hljs-attr">onChange</span>=<span class="hljs-string">{handleClick}</span>
      /&gt;</span>{' '}
      添加线路
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{handleExport}</span>&gt;</span>导出<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/&gt;</span></span>
  )
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">DrawLine</span>

</code></pre>
<p>当绘制好后可以点击导出、然后可以看到控制台有我们的JSON数据，这里我示例了一下，本来想找条真实的路，结果定位重庆就找不到一条直的路，算了。还有这里我们也可以手动便利features自己写json，能进一步巩固了解！</p>
<p>这是我绘制的供后面使用效果图如下：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7649f3adc6a640b28cacdf6699fc4d53~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lic5LicMjMz:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765188752&amp;x-signature=pBfn7yzewOmvZKFn3Y%2BwWH6a9Sk%3D" alt="4c2d8a92240a8a7ebe53730fd8dd0d35.png" loading="lazy"/></p>
<h4 data-id="heading-16">OpenLayers 中使用刚才导入的数据</h4>
<p>我们可以导入刚才的数据并加入一些交互，这里我对数据做了一些加工，这一步可以在编辑完成，但我们的编辑比较粗糙，我就手动对JSON做了编辑，主要功能：</p>
<ul>
<li>支持路线选中、显示路线信息</li>
<li>支持站点选中、查看站点信息</li>
</ul>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> { useEffect, useRef, useState } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> layer <span class="hljs-keyword">from</span> <span class="hljs-string">'ol/layer'</span>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> source <span class="hljs-keyword">from</span> <span class="hljs-string">'ol/source'</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Map</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'ol'</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">View</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'ol/View.js'</span>
<span class="hljs-keyword">import</span> <span class="hljs-variable constant_">OSM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'ol/source/OSM'</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Style</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'ol/style/Style'</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Stroke</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'ol/style/Stroke'</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Fill</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'ol/style/Fill'</span>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> format <span class="hljs-keyword">from</span> <span class="hljs-string">'ol/format'</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">CircleStyle</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'ol/style/Circle'</span>

<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> interaction <span class="hljs-keyword">from</span> <span class="hljs-string">'ol/interaction'</span>
<span class="hljs-keyword">import</span> { pointerMove } <span class="hljs-keyword">from</span> <span class="hljs-string">'ol/events/condition'</span>
<span class="hljs-keyword">const</span> projection = <span class="hljs-string">'EPSG:4326'</span>


<span class="hljs-keyword">const</span> <span class="hljs-title function_">createDrawStyle</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Style</span>({
    <span class="hljs-attr">image</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">CircleStyle</span>({
      <span class="hljs-attr">radius</span>: <span class="hljs-number">4</span>,
      <span class="hljs-attr">fill</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fill</span>({
        <span class="hljs-attr">color</span>: <span class="hljs-string">'red'</span>
      })
    }),
    <span class="hljs-attr">stroke</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stroke</span>({
      <span class="hljs-attr">width</span>: <span class="hljs-number">2</span>,
      <span class="hljs-attr">color</span>: <span class="hljs-string">'#000'</span>
    })
  })
}
<span class="hljs-keyword">const</span> <span class="hljs-title function_">DrawLine</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-keyword">const</span> mapRef = useRef&lt;<span class="hljs-title class_">Map</span>&gt;(<span class="hljs-literal">null</span>)
  <span class="hljs-keyword">const</span> wrapperRef = useRef&lt;<span class="hljs-title class_">HTMLDivElement</span>&gt;(<span class="hljs-literal">null</span>)
  <span class="hljs-keyword">const</span> drawSource = useRef&lt;source.<span class="hljs-property">Vector</span>&gt;(<span class="hljs-literal">null</span>)
  <span class="hljs-keyword">const</span> [active, setActive] = useState&lt;any&gt;(<span class="hljs-literal">null</span>)

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> vectorSource = <span class="hljs-keyword">new</span> source.<span class="hljs-title class_">Vector</span>({
      <span class="hljs-attr">url</span>: <span class="hljs-string">'/geo/cq.json'</span>,
      <span class="hljs-attr">format</span>: <span class="hljs-keyword">new</span> format.<span class="hljs-title class_">GeoJSON</span>()
    })
    drawSource.<span class="hljs-property">current</span> = vectorSource
    <span class="hljs-keyword">const</span> vectorLayer = <span class="hljs-keyword">new</span> layer.<span class="hljs-title class_">Vector</span>({
      <span class="hljs-attr">source</span>: vectorSource,
      <span class="hljs-attr">style</span>: <span class="hljs-title function_">createDrawStyle</span>()
    })

    <span class="hljs-keyword">const</span> osmLayer = <span class="hljs-keyword">new</span> layer.<span class="hljs-title class_">Tile</span>({
      <span class="hljs-attr">source</span>: <span class="hljs-keyword">new</span> <span class="hljs-title function_">OSM</span>()
    })

    <span class="hljs-keyword">const</span> view = <span class="hljs-keyword">new</span> <span class="hljs-title class_">View</span>({
      <span class="hljs-attr">zoom</span>: <span class="hljs-number">10</span>,
      projection,
      <span class="hljs-attr">center</span>: [<span class="hljs-number">106.56</span>, <span class="hljs-number">29.57</span>]
    })

    <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>({
      <span class="hljs-attr">target</span>: <span class="hljs-string">'draw'</span>,
      <span class="hljs-attr">layers</span>: [osmLayer, vectorLayer],
      view,
      <span class="hljs-attr">controls</span>: []
    })
    <span class="hljs-keyword">const</span> select = <span class="hljs-keyword">new</span> interaction.<span class="hljs-title class_">Select</span>({
      <span class="hljs-attr">condition</span>: pointerMove,
      <span class="hljs-attr">style</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Style</span>({
        <span class="hljs-attr">image</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">CircleStyle</span>({
          <span class="hljs-attr">radius</span>: <span class="hljs-number">8</span>,
          <span class="hljs-attr">fill</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fill</span>({
            <span class="hljs-attr">color</span>: <span class="hljs-string">'red'</span>
          })
        }),
        <span class="hljs-attr">stroke</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stroke</span>({
          <span class="hljs-attr">width</span>: <span class="hljs-number">4</span>,
          <span class="hljs-attr">color</span>: <span class="hljs-string">'#000'</span>
        })
      })
    })
    map.<span class="hljs-title function_">addInteraction</span>(select)
    map.<span class="hljs-title function_">on</span>(<span class="hljs-string">'pointermove'</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {
      <span class="hljs-keyword">const</span> pixel = event.<span class="hljs-property">pixel</span>;
      <span class="hljs-keyword">const</span> features = map.<span class="hljs-title function_">getFeaturesAtPixel</span>(pixel);
      <span class="hljs-keyword">if</span>(features.<span class="hljs-property">length</span>) {
        <span class="hljs-keyword">const</span> feature = features.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-title function_">getGeometry</span>()?.<span class="hljs-title function_">getType</span>() === <span class="hljs-string">'Point'</span>) || features[<span class="hljs-number">0</span>]
        <span class="hljs-title function_">setActive</span>({
          pixel,
          <span class="hljs-attr">properties</span>: feature.<span class="hljs-title function_">getProperties</span>()
        })
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-title function_">setActive</span>(<span class="hljs-literal">null</span>)
      }
    })
    mapRef.<span class="hljs-property">current</span> = map
  }, [])

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>
        <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span>
          <span class="hljs-attr">width:</span> '<span class="hljs-attr">800px</span>',
          <span class="hljs-attr">height:</span> '<span class="hljs-attr">400px</span>',
          <span class="hljs-attr">position:</span> '<span class="hljs-attr">relative</span>',
          <span class="hljs-attr">display:</span> '<span class="hljs-attr">flex</span>'
        }}
      &gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"draw"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{wrapperRef}</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">width:</span> '<span class="hljs-attr">800px</span>', <span class="hljs-attr">height:</span> '<span class="hljs-attr">400px</span>', <span class="hljs-attr">cursor:</span> <span class="hljs-attr">active</span> ? '<span class="hljs-attr">pointer</span>' <span class="hljs-attr">:</span> '<span class="hljs-attr">auto</span>'  }}&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        {active &amp;&amp; <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span>
          <span class="hljs-attr">width:</span> '<span class="hljs-attr">100px</span>',
          <span class="hljs-attr">background:</span> '#<span class="hljs-attr">fff</span>',
          <span class="hljs-attr">padding:</span> '<span class="hljs-attr">4px</span>',
          <span class="hljs-attr">borderRadius:</span> '<span class="hljs-attr">4px</span>',
          <span class="hljs-attr">position:</span> '<span class="hljs-attr">absolute</span>',
          <span class="hljs-attr">left:</span> <span class="hljs-attr">active.pixel</span>[<span class="hljs-attr">0</span>] + <span class="hljs-attr">20</span> + '<span class="hljs-attr">px</span>',
          <span class="hljs-attr">top:</span> <span class="hljs-attr">active.pixel</span>[<span class="hljs-attr">1</span>] + <span class="hljs-attr">20</span> + '<span class="hljs-attr">px</span>'
        }}&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">h5</span>&gt;</span>名称：{active.properties.name}<span class="hljs-tag">&lt;/<span class="hljs-name">h5</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>}
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/&gt;</span></span>
  )
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">DrawLine</span>

</code></pre>
<p>效果图如下</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2ef460836b584a8cb7aed1ec11455922~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lic5LicMjMz:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765188752&amp;x-signature=uaDOJHhBRAnggx9jjSApPMJ2g%2BQ%3D" alt="6b9ba06ac2c949da917c36dbe5e48919.png" loading="lazy"/></p>
<p>这是我使用的JSON</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"FeatureCollection"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"features"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
    <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Feature"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"geometry"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"LineString"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"coordinates"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
          <span class="hljs-punctuation">[</span>
            <span class="hljs-number">106.40801847988175</span><span class="hljs-punctuation">,</span>
            <span class="hljs-number">29.57298086250036</span>
          <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
          <span class="hljs-punctuation">[</span>
            <span class="hljs-number">106.56685851097549</span><span class="hljs-punctuation">,</span>
            <span class="hljs-number">29.580326066250358</span>
          <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
          <span class="hljs-punctuation">[</span>
            <span class="hljs-number">106.69999032894425</span><span class="hljs-punctuation">,</span>
            <span class="hljs-number">29.54084559609411</span>
          <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
          <span class="hljs-punctuation">[</span>
            <span class="hljs-number">106.80098688050674</span><span class="hljs-punctuation">,</span>
            <span class="hljs-number">29.43066753984411</span>
          <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
          <span class="hljs-punctuation">[</span>
            <span class="hljs-number">106.83220399644425</span><span class="hljs-punctuation">,</span>
            <span class="hljs-number">29.410468229531606</span>
          <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
          <span class="hljs-punctuation">[</span>
            <span class="hljs-number">106.88362042269425</span><span class="hljs-punctuation">,</span>
            <span class="hljs-number">29.403123025781607</span>
          <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
          <span class="hljs-punctuation">[</span>
            <span class="hljs-number">106.91116493675675</span><span class="hljs-punctuation">,</span>
            <span class="hljs-number">29.406795627656606</span>
          <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
          <span class="hljs-punctuation">[</span>
            <span class="hljs-number">106.96074506206925</span><span class="hljs-punctuation">,</span>
            <span class="hljs-number">29.417813433281605</span>
          <span class="hljs-punctuation">]</span>
        <span class="hljs-punctuation">]</span>
      <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"properties"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"line"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"成渝高速"</span>
      <span class="hljs-punctuation">}</span>
    <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
    <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Feature"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"geometry"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Point"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"coordinates"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
          <span class="hljs-number">106.70012461444661</span><span class="hljs-punctuation">,</span>
          <span class="hljs-number">29.539872075705606</span>
        <span class="hljs-punctuation">]</span>
      <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"properties"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"station"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"安康"</span>
      <span class="hljs-punctuation">}</span>
    <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
    <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Feature"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"geometry"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Point"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"coordinates"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
          <span class="hljs-number">106.56685698617343</span><span class="hljs-punctuation">,</span>
          <span class="hljs-number">29.57991493114919</span>
        <span class="hljs-punctuation">]</span>
      <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"properties"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"station"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"巴中"</span>
      <span class="hljs-punctuation">}</span>
    <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
    <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Feature"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"geometry"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Point"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"coordinates"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
          <span class="hljs-number">106.88282014240801</span><span class="hljs-punctuation">,</span>
          <span class="hljs-number">29.40285042973459</span>
        <span class="hljs-punctuation">]</span>
      <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"properties"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"station"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"渝北"</span>
      <span class="hljs-punctuation">}</span>
    <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
    <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Feature"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"geometry"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Point"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"coordinates"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
          <span class="hljs-number">106.96102884444625</span><span class="hljs-punctuation">,</span>
          <span class="hljs-number">29.417240830909627</span>
        <span class="hljs-punctuation">]</span>
      <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"properties"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"station"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"简阳"</span>
      <span class="hljs-punctuation">}</span>
    <span class="hljs-punctuation">}</span>
  <span class="hljs-punctuation">]</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<h3 data-id="heading-17">总结</h3>
<p>通过本文的深入探索，我们理解了 GeoJSON 作为 Web 地理空间数据通用语言的核心优势：</p>
<ul>
<li>简洁: 基于 JSON 格式，结构清晰，易于人机阅读和编写。</li>
<li>灵活: 强大的 Feature 和 FeatureCollection 结构允许我们将复杂的地理几何图形（如 LineString, Polygon, MultiPolygon）与丰富的非地理属性数据 (properties) 完美结合。</li>
<li>标准化: 统一的 WGS84 坐标系和严格的规范（如右手法则），确保了 GeoJSON 文件在不同平台和 Web 地图库之间的互操作性。</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[JS宗门入门记：小白师妹的对答如流（从JS环境到函数作用域）]]></title>    <link>https://juejin.cn/post/7578697614389936134</link>    <guid>https://juejin.cn/post/7578697614389936134</guid>    <pubDate>2025-12-01T09:46:40.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7578697614389936134" data-draft-id="7578681104291364907" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="JS宗门入门记：小白师妹的对答如流（从JS环境到函数作用域）"/> <meta itemprop="keywords" content="Node.js"/> <meta itemprop="datePublished" content="2025-12-01T09:46:40.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="鸡腿大王"/> <meta itemprop="url" content="https://juejin.cn/user/4361104734828352"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            JS宗门入门记：小白师妹的对答如流（从JS环境到函数作用域）
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4361104734828352/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    鸡腿大王
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-01T09:46:40.000Z" title="Mon Dec 01 2025 09:46:40 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-01
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    5
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body cache result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>晨光熹微，JS宗门的演武场上已传来阵阵键盘敲击声。我——一个刚入门三天的女弟子，正蹲在角落盯着卷轴上的《V8心法》发呆。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/adde6763b65a4b278afd65bd69650ea0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6bih6IW_5aSn546L:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765187615&amp;x-signature=1Y0xtQPtoU3LdKAHlstsldKtOU0%3D" alt="image.png" loading="lazy"/><br/>
“喂，新来的！”一个身影挡在我面前，是内门弟子李师兄，人称“闭包剑客”。他居高临下地看着我手中的卷轴，语气带着审视：“听说你刚入门三天，就敢看《V8心法》？那你告诉我，我宗功法靠何物运转？”我站起身，拍拍衣摆，不慌不忙答道：<br/>
“回师兄，我宗功法运行，倚仗两大‘引擎’：一为‘浏览器’秘境，二为‘Node’灵台。其中V8引擎，乃是一段庞大而精妙的‘函数’，它能读懂JS咒语并予以执行。”<br/>
<strong>(v8 引擎， 也是一段函数（庞大），它可以读懂 js 并执行)</strong><br/>
李师兄眉毛一挑：“哦？那你说说，一段JS咒语被V8读取后，是直接生效吗？”“并非如此。”我摇头，“咒语入引擎，首经三重梳理：一曰‘分词’，解构咒语为词元；二曰‘解析’，筑成‘抽象语法树’，辨明有效标识符；三曰‘生成代码’，方可使咒语具现。”<br/>
（# js的执行</p>
<ol>
<li>代码被 v8 读取到的第一时间，并不是执行，而是会先编译（梳理）</li>
</ol>
<ul>
<li>梳理：</li>
</ul>
<ol>
<li>分词/词法分析：将代码一个一个拆分解析成v8引擎可以识别的字符</li>
<li>解析/语法分析  -- AST(抽象语法树) 获取有效标识符</li>
<li>生成代码）<br/>
旁边渐渐围拢了几位外门弟子，李师兄抱臂又问：“那你可知，我宗为何要创‘函数’之术？”我微微一笑：“函数如术法封装，可将一段逻辑代码封存其中。未调用时，如剑在鞘中，隐而不发；一旦调用，则如剑出鞘，代码方得执行。”</li>
</ol>
<p><strong>（形如 function foo() {}，就是一个函数体，函数存在的意义就是让我们可以将某一段逻辑代码，写在函数中，最后调用函数，这段代码才会执行）</strong></p>
<pre><code class="hljs language-JS" lang="JS"><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"/>) {
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);
}
<span class="hljs-title function_">foo</span>()

</code></pre>
<p>此时一位师姐插话：“听说你昨日便参透了‘作用域’之境？”我转向她，拱手道：“师姐明鉴。我宗作用域分三重天：一为‘全局’，如宗门广场，人人可见；二为‘函数’，如各自厢房，内物不外露；三为‘块级’，需以let、const符咒配合{}结界而成。且作用域之规，乃‘由内向外’单向可见，外层不可窥探内层之秘。”<br/>
(# 作用域</p>
<ol>
<li>全局作用域</li>
<li>函数作用域 （参数也是该作用域的一个有效标识）</li>
<li>块级作用域 (let,const 和 {} 语法配合使用会导致声明的变量处在一个作用域中)</li>
</ol>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/952d7272b79f4e18ad3a5ede94cd81b5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6bih6IW_5aSn546L:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765187615&amp;x-signature=a9kc4%2BnOUAVZe5Gyu2%2FnRxBLQRo%3D" alt="image.png" loading="lazy"/>（宗门广场上，众多弟子往来穿梭，广场中央立着 “全局” 石碑，清晰可见，象征全局作用域人人可访问。）</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bb0b20a9b8864019bce7cdf14305a764~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6bih6IW_5aSn546L:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765187615&amp;x-signature=XyVYLgo4GTqlOsOfZ8SXtEWcO84%3D" alt="image.png" loading="lazy"/>（一间独立厢房内，一位弟子正在桌前研读典籍，厢房门窗紧闭，门外有 “函数” 牌匾，示意厢房内物品仅限内部使用，不向外暴露。）</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d6928f34e9a84657a7b8b9a26e3f0b8f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6bih6IW_5aSn546L:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765187615&amp;x-signature=jyQ7Ht5nonMroT4Q7%2B3HYDwQmRk%3D" alt="image.png" loading="lazy"/>（一间密室中，地面用 {} 符号绘制出结界，结界内有 let、const 符咒悬浮，一位弟子在结界内修炼，结界外之人无法看清内部情况，体现块级作用域需特定符咒配合结界形成。一间密室中，地面用 {} 符号绘制出结界，结界内有 let、const 符咒悬浮，一位弟子在结界内修炼，结界外之人无法看清内部情况，体现块级作用域需特定符咒配合结界形成。）</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/380efc35a64a4fbdbac13356c0ada78b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6bih6IW_5aSn546L:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765187615&amp;x-signature=I2rftg%2BQD20vSsVvaHKwWNU1fcE%3D" alt="image.png" loading="lazy"/>（从内到外依次绘制着密室、厢房、宗门广场，箭头从密室指向厢房再指向广场，示意作用域 “由内向外” 单向可见的规则，外层无法反向窥探内层。）<br/>
李师兄忽然目光一凝，抛出最后一问：“那‘let结界术’中，有一特殊禁制，你可知是何？”我深吸一口气，清晰答道：“此乃‘暂时性死区’——当{}结界中存let声明，结界之内凡寻此变量，必先寻境内之身。纵境内无获，亦不可越界外求，此禁直至结界畅通方解。”<br/>
（当一个{} 语句中存在 let x 时，在该{}中访问x，永远都只能访问{}内部的 x，就算内部访问不到，也不能访问外部的x。这种规则称为 --- 暂时性死区）<br/>
（举个栗子</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span>
<span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) { 
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);  <span class="hljs-comment">// 暂时性死区</span>
  <span class="hljs-keyword">let</span> a = <span class="hljs-number">2</span>
}
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f2ce55dd9d894bed8844c7278e5ae492~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6bih6IW_5aSn546L:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765187615&amp;x-signature=miOlUbVi7GbaAz85zzPU2snOI%2Bg%3D" alt="image.png" loading="lazy"/>代码结果是'不能在声明变量a之前输出'，就算内部访问不到a来输出，也不能访问外部的a，这称为暂时性死区）<br/>
场中静默片刻。李师兄忽然大笑，从怀中掏出一枚铜牌：“好！基础扎实，悟性不凡。这是我内门听讲牌，明日‘事件循环论剑’，你可来旁听。”后来才知，李师兄那日其实是奉长老之命，试探新弟子根基。而我——这个通宵啃完《JavaScript高级程序设计》还做了三套笔记的“小白”，不过是把书上的字，背得熟了些。毕竟在JS宗门，哪有什么天才，不过是把别人喝咖啡的时间，用来……写bug和debug罢了。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/87f6a059c8b14633ad0f562185afd452~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6bih6IW_5aSn546L:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765187615&amp;x-signature=WDsJFMZTTGy9VHDVdiry%2FJsvlb4%3D" alt="image.png" loading="lazy"/></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[antd 4.x Tabs 点击阻止冒泡]]></title>    <link>https://juejin.cn/post/7578709098255400998</link>    <guid>https://juejin.cn/post/7578709098255400998</guid>    <pubDate>2025-12-01T10:20:29.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7578709098255400998" data-draft-id="7578442185848078374" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="antd 4.x Tabs 点击阻止冒泡"/> <meta itemprop="keywords" content="React.js,CSS"/> <meta itemprop="datePublished" content="2025-12-01T10:20:29.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="什么时候星期五"/> <meta itemprop="url" content="https://juejin.cn/user/3178012213523544"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            antd 4.x Tabs 点击阻止冒泡
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3178012213523544/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    什么时候星期五
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-01T10:20:29.000Z" title="Mon Dec 01 2025 10:20:29 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-01
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body cache result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">一、场景</h2>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d1f372f4b1a9423ba105abfee70f0c9f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LuA5LmI5pe25YCZ5pif5pyf5LqU:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765189229&amp;x-signature=n1mYps6o9FKvG%2BaHZn7Rd4P9w%2BQ%3D" alt="image.png" loading="lazy"/></p>
<p>如上图所示，tab1-未回复，tab2-已回复+筛选条件仅看未处理<br/>
当在tab1时，点击tab2的仅看未处理checkbox，此时需要进行tab2的数据请求（请求已回复&amp;未处理的数据）</p>
<h2 data-id="heading-1">二、基础实现</h2>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> [activeKey, setActiveKey] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">'replied'</span>);

<span class="hljs-keyword">const</span> defaultPageParams = {
    <span class="hljs-attr">page</span>: <span class="hljs-number">1</span>,
    <span class="hljs-attr">rows</span>: <span class="hljs-number">5</span>,
};

<span class="hljs-keyword">const</span> <span class="hljs-title function_">getRepliedData</span> = (<span class="hljs-params">params: any</span>) =&gt; {
    <span class="hljs-keyword">const</span> _params = {
        ...params
    }
    <span class="hljs-keyword">if</span> (_params.<span class="hljs-property">handleStatus</span> == <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">delete</span> _params.<span class="hljs-property">handleStatus</span>;
    }
    <span class="hljs-comment">// 存一份params</span>
    <span class="hljs-comment">//...</span>
}

<span class="hljs-keyword">const</span> <span class="hljs-title function_">getNotReplyData</span> = (<span class="hljs-params">params: any</span>) =&gt; {
    <span class="hljs-comment">//...</span>
    <span class="hljs-comment">// 存一份params</span>
}

<span class="hljs-keyword">const</span> <span class="hljs-title function_">handleFilterRepliedData</span> = (<span class="hljs-params">e: CheckboxChangeEvent</span>) =&gt; {
    <span class="hljs-keyword">const</span> <span class="hljs-attr">params</span>: any = {
        ...defaultPageParams,
        <span class="hljs-attr">handleStatus</span>: e.<span class="hljs-property">target</span>.<span class="hljs-property">checked</span> ? <span class="hljs-number">0</span> : <span class="hljs-literal">null</span>,
    };
    <span class="hljs-title function_">getRepliedData</span>(params);
}

<span class="hljs-keyword">const</span> <span class="hljs-title function_">getData</span> = (<span class="hljs-params">key: string</span>) =&gt; {
    <span class="hljs-keyword">const</span> <span class="hljs-attr">params</span>: any = {
        ...defaultPageParams
    };
    <span class="hljs-keyword">if</span> (key === <span class="hljs-string">'replied'</span>) {
      <span class="hljs-title function_">getRepliedData</span>(params);
    }
    <span class="hljs-keyword">if</span> (key === <span class="hljs-string">'not-reply'</span>) {
      <span class="hljs-title function_">getNotReplyData</span>(params);
    }
};
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Tabs</span>
    <span class="hljs-attr">defaultActiveKey</span>=<span class="hljs-string">{</span>'<span class="hljs-attr">not-reply</span>'}
    <span class="hljs-attr">activeKey</span>=<span class="hljs-string">{activeKey}</span>
    <span class="hljs-attr">onChange</span>=<span class="hljs-string">{(key)</span> =&gt;</span> {
        setActiveKey(key);
        getData(key);
    }}
    items={[
        {
          key: 'not-reply',
          label: '未回复',
          children: (
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>未回复内容<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
          ),
        },
        {
          key: 'replied',
          label: (
            <span class="hljs-tag">&lt;<span class="hljs-name">Space</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>已回复<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">Checkbox</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">{handleFilterRepliedData}</span>&gt;</span>
                  僅看未處理
                <span class="hljs-tag">&lt;/<span class="hljs-name">Checkbox</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">Space</span>&gt;</span>
          ),
          children: (
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>已回复内容<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
          ),
        },
    ]}
/&gt;</span>
</code></pre>
<h2 data-id="heading-2">三、基础实现存在的问题</h2>
<p>在tab1直接点击tab2的checkbox，会执行Checkbox的onChange事件，也会执行Tabs的onChange事件，会导致请求了两次接口同时页面上会有数据闪现现象，若Tabs的请求更慢，可能还会导致数据查询异常。</p>
<h2 data-id="heading-3">四、优化实现</h2>
<p>关键代码：</p>
<ol>
<li>Checkbox包一层：<br/>
<code>&lt;span style={{ pointerEvents: 'none' }} onClick={(e) =&gt; e.stopPropagation()}&gt;</code></li>
<li>Checkbox加style：<br/>
<code>style={{ pointerEvents: 'auto' }}</code></li>
<li>Checkbox onChange方法添加代码：<br/>
<code>e.stopPropagation();</code><br/>
<code>setActiveKey('replied');</code></li>
</ol>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 1、改Checkbox的onChange方法</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">handleFilterRepliedData</span> = (<span class="hljs-params">e: CheckboxChangeEvent</span>) =&gt; {
    <span class="hljs-comment">// 避免在未命中該tab的情況下，直接點擊該checkbox請求了兩次接口導致的頁面內容閃現問題</span>
    e.<span class="hljs-title function_">stopPropagation</span>();
    <span class="hljs-title function_">setActiveKey</span>(<span class="hljs-string">'replied'</span>);
    
    <span class="hljs-comment">//...</span>
}

&lt;<span class="hljs-title class_">Tabs</span>
    <span class="hljs-comment">//...</span>
    items={[
        <span class="hljs-comment">//...</span>
        {
          <span class="hljs-attr">key</span>: <span class="hljs-string">'replied'</span>,
          <span class="hljs-attr">label</span>: (
            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Space</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>已回复<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
                {/* 2、改Checkbox视图，解決事件冒泡到tabs的onChange事件 */}
                <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">pointerEvents:</span> '<span class="hljs-attr">none</span>' }} <span class="hljs-attr">onClick</span>=<span class="hljs-string">{(e)</span> =&gt;</span> e.stopPropagation()}&gt;
                    <span class="hljs-tag">&lt;<span class="hljs-name">Checkbox</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">pointerEvents:</span> '<span class="hljs-attr">auto</span>' }} <span class="hljs-attr">onChange</span>=<span class="hljs-string">{handleFilterRepliedData}</span>&gt;</span>
                      僅看未處理
                    <span class="hljs-tag">&lt;/<span class="hljs-name">Checkbox</span>&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">Space</span>&gt;</span></span>
          ),
          <span class="hljs-attr">children</span>: (
            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>已回复内容<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
          ),
        },
    ]}
/&gt;
</code></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[一次由 by lazy 引发的“数据倒灌”，深入理解 `by`关键字、`lazy`函数的本质]]></title>    <link>https://juejin.cn/post/7578820431017541647</link>    <guid>https://juejin.cn/post/7578820431017541647</guid>    <pubDate>2025-12-01T09:39:11.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7578820431017541647" data-draft-id="7578693994368581632" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="一次由 by lazy 引发的“数据倒灌”，深入理解 `by`关键字、`lazy`函数的本质"/> <meta itemprop="keywords" content="Android,Kotlin,APP"/> <meta itemprop="datePublished" content="2025-12-01T09:39:11.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Gemini001"/> <meta itemprop="url" content="https://juejin.cn/user/2333635831676704"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            一次由 by lazy 引发的“数据倒灌”，深入理解 `by`关键字、`lazy`函数的本质
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2333635831676704/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Gemini001
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-01T09:39:11.000Z" title="Mon Dec 01 2025 09:39:11 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-01
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    2
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读14分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body cache result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">一次由 by lazy 引发的“数据倒灌”血案：从 Bug 深入 Kotlin 属性委托与生命周期</h2>
<h3 data-id="heading-1">引言</h3>
<p>在日常的 Android 开发中，我们经常追求代码的简洁与优雅。Kotlin 语言为我们提供了诸多精妙的语法糖，<code>by lazy</code>便是其中之一，它能让我们以一种非常便捷的方式实现属性的延迟初始化。然而，“能力越大，责任越大”，如果不深入理解其背后的工作原理和适用场景，这份“便捷”有时会变成一个难以追踪的“陷阱”。</p>
<p>本文将复盘一个真实场景中遇到的问题：用户切换账号后，个人中心页面竟然出现了上一个账号的旧数据！我们将以此为切入点，一步步揭开问题的面纱，不仅解决 Bug，更要深入理解 <code>by</code>关键字、<code>lazy</code>函数的本质，并反思在 Android 架构设计中那些关于生命周期的重要原则。</p>
<h3 data-id="heading-2">一、案发现场：诡异的数据倒灌</h3>
<p>想象一下这个场景：我们的 App 首页采用主流的 Fragment + BottomNavigationView 结构，为了管理各个 Tab 对应的 Fragment，我们创建了一个工具类。为了优化性能，避免每次切换 Tab 都重新创建 Fragment，我们很自然地想到了使用单例来“缓存”这些 Fragment 实例。</p>
<p>代码大致如下：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// HomeTabUtils.kt - 一个单例对象，用于管理 Fragment</span>
<span class="hljs-keyword">object</span> HomeTabUtils {
    <span class="hljs-comment">// 使用 by lazy 初始化 Fragment，看起来很完美！</span>
    <span class="hljs-keyword">val</span> tabHome <span class="hljs-keyword">by</span> lazy { HomeFragment() }
    <span class="hljs-keyword">val</span> tabMessage <span class="hljs-keyword">by</span> lazy { MessageFragment() }
    <span class="hljs-keyword">val</span> tabMine <span class="hljs-keyword">by</span> lazy { MineFragment() }
}

<span class="hljs-comment">// HomeActivity.kt - 在 Activity 中添加 Fragment</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">HomeActivity</span> : <span class="hljs-type">AppCompatActivity</span>() {
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> {
        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)
        <span class="hljs-comment">// ...</span>
        <span class="hljs-comment">// 将 "我的" Fragment 添加到容器中</span>
        supportFragmentManager.beginTransaction()
            .add(R.id.fragment_container, HomeTabUtils.tabMine)
            .commit()
    }
}
</code></pre>
<p>这段代码看起来简洁且高效。<code>object</code>确保了 <code>HomeTabUtils</code>的单例性，<code>by lazy</code>确保了每个 Fragment 只在第一次被需要时创建一次。一切似乎都运行良好，直到“切换账号”功能上线。</p>
<h4 data-id="heading-3">问题复现流程：</h4>
<ol>
<li>用户 A 登录 App，进入“我的”页面，页面正确显示了用户 A 的头像和昵称。</li>
<li>用户 A 退出登录，<code>HomeActivity</code>被销毁。</li>
<li>用户 B 在同一台设备上登录 App，一个新的 <code>HomeActivity</code>被创建。</li>
<li>用户 B 进入“我的”页面，诡异的事情发生了：页面上显示的竟然还是用户 A 的头像和昵称！数据发生了“倒灌”。</li>
</ol>
<h3 data-id="heading-4">二、抽丝剥茧：追寻 Bug 的根源</h3>
<p>这个问题非常典型，它的根源在于三个设计选择的“致命组合”：<strong>应用级单例 + by lazy 的缓存特性 + Android 组件的生命周期</strong>。让我们来一步步剖析整个流程：</p>
<h4 data-id="heading-5">1. “长寿”的单例</h4>
<p><code>HomeTabUtils</code>是一个 <code>object</code>，它的生命周期与整个 App 进程相同。只要 App 不被系统杀死，这个单例对象就永远存在于内存中。</p>
<h4 data-id="heading-6">2. “忠诚”的 by lazy</h4>
<p><code>by lazy</code>的核心机制是：在第一次访问属性时，执行初始化代码块，然后将结果缓存。之后的所有访问，都会直接返回这个被缓存的结果。它对初始化逻辑的执行是“一次性”且“忠诚”的。</p>
<h4 data-id="heading-7">3. “可复活”的 Fragment</h4>
<p>当用户 A 退出登录时，<code>HomeActivity</code>被销毁。Activity 会 remove 掉它管理的 <code>MineFragment</code>。但这里的 remove 仅仅是销毁了 Fragment 的视图（View）并将其从 FragmentManager 中移除。由于 <code>HomeTabUtils</code>这个长寿的单例仍然强引用着 <code>MineFragment</code>的实例，所以这个 Fragment 对象本身并未被垃圾回收。它依然活在内存中，并且其内部的 ViewModel 和 LiveData 也完好地保存着用户 A 的数据。</p>
<h4 data-id="heading-8">4. “倒灌”的发生</h4>
<p>当用户 B 登录后，一个新的 <code>HomeActivity</code>被创建。当它再次访问 <code>HomeTabUtils.tabMine</code>时，<code>by lazy</code>毫不犹豫地返回了之前缓存的、属于用户 A 的那个 <code>MineFragment</code>实例。这个“旧”实例被重新添加到新的 Activity 中，其生命周期方法 <code>onViewCreated</code>被调用。在这里，UI 代码重新订阅了 ViewModel 中的 LiveData，而 LiveData 的粘性特性会立即将它内部缓存的旧数据（用户 A 的信息）推送给观察者。<strong>数据倒灌，由此发生！</strong> ​</p>
<p><strong>核心原因一句话总结</strong>：我们错误地将一个本应跟随特定上下文（用户会话）生命周期的组件（Fragment），通过 <code>by lazy</code>“提升”并锁定在了一个全局应用生命周期的单例中。</p>
<h3 data-id="heading-9">三、解决方案：斩断不当的持有关系</h3>
<p>理解了原因，解决方案就水到渠成了。我们必须打破这种不恰当的强引用关系，确保每次需要时都能获得一个全新的、干净的 Fragment 实例。</p>
<p>最直接的修改就是将 <code>HomeTabUtils</code>的角色从“实例持有者”转变为“实例工厂”：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// HomeTabUtils.kt (修改后)</span>
<span class="hljs-keyword">object</span> HomeTabUtils {
    <span class="hljs-comment">// 不再使用 by lazy 缓存实例，而是提供一个创建新实例的方法</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createMineFragment</span><span class="hljs-params">()</span></span>: MineFragment {
        <span class="hljs-keyword">return</span> MineFragment()
    }
    <span class="hljs-comment">// 其他 Fragment 同理...</span>
}

<span class="hljs-comment">// HomeActivity.kt (修改后)</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">HomeActivity</span> : <span class="hljs-type">AppCompatActivity</span>() {
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> {
        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)
        <span class="hljs-comment">// ...</span>
        <span class="hljs-comment">// 每次都创建一个全新的实例</span>
        supportFragmentManager.beginTransaction()
            .add(R.id.fragment_container, HomeTabUtils.createMineFragment())
            .commit()
    }
}
</code></pre>
<p>通过这个简单的修改，我们保证了每次用户登录后创建 <code>HomeActivity</code>时，都会得到一个全新的 <code>MineFragment</code>，从而彻底解决了数据污染的问题。</p>
<h3 data-id="heading-10">四、深度挖掘：by lazy 究竟是什么？</h3>
<p>要彻底搞懂这个问题，我们必须把 <code>val myProperty by lazy { ... }</code>这行代码拆开来看，理解两个关键部分：<code>by</code>关键字 和 <code>lazy</code>函数。</p>
<h4 data-id="heading-11">1. by 关键字：委托模式的语法糖</h4>
<p><code>by</code>是 Kotlin 中一个极其强大的关键字，用于实现 <strong>属性委托（Property Delegation）</strong> 。</p>
<p><strong>委托模式是什么？</strong> ​ 这是一种设计模式，一个对象（委托者）将它的一部分职责转交给另一个辅助对象（代理）来完成。就像你找了一位秘书来帮你管理日程，你只需要向秘书下达指令，具体如何安排、提醒，都由秘书来处理。</p>
<p>在 Kotlin 中，属性也可以将它的 <code>get()</code>和 <code>set()</code>访问器的逻辑委托给一个代理对象。要成为一个合格的属性代理，这个对象必须遵循一定的约定（提供 <code>getValue</code>和 <code>setValue</code>方法）。</p>
<p>当我们写下 <code>val myProperty by myDelegate</code>时，Kotlin 编译器会自动将对 <code>myProperty</code>的访问转换为对 <code>myDelegate</code>相应方法的调用：</p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-comment">// 你写的代码：</span>
val myProperty: <span class="hljs-function">String <span class="hljs-keyword">by</span> <span class="hljs-title">MyDelegate</span>()

<span class="hljs-comment">// 编译器实际生成的（简化版）：</span>
<span class="hljs-comment">// 1. 创建一个隐藏的代理实例</span>
<span class="hljs-keyword">private</span> val myProperty$<span class="hljs-built_in">delegate</span></span> = MyDelegate()
<span class="hljs-comment">// 2. 属性的 getter 委托给代理</span>
val myProperty: <span class="hljs-function">String
    <span class="hljs-title">get</span>()</span> = myProperty$<span class="hljs-built_in">delegate</span>.getValue(<span class="hljs-keyword">this</span>, ::myProperty)
</code></pre>
<p><strong><code>by</code>关键字的意义</strong>：它将属性访问的公共逻辑（如延迟初始化、数据绑定、SharedPreferences 读写等）从每个属性中抽离出来，封装到可复用的代理类中，极大地提高了代码的复用性和可读性。</p>
<h5 data-id="heading-12">by 关键字的双重委托魔法</h5>
<p>我们的 Bug 由 <code>by lazy</code>而起，但其根源在于对 <code>by</code>关键字能力的误用。<code>by</code>是 Kotlin 中实现“委托模式”的核心，它有两种截然不同但同样强大的用途。</p>
<h6 data-id="heading-13">委托之一：属性委托 (Property Delegation)</h6>
<p>这正是我们案例中遇到的场景。它允许我们将一个属性的 <code>get()</code>和 <code>set()</code>访问器逻辑，委托给一个代理对象来管理。</p>
<h6 data-id="heading-14">1. 为什么需要属性委托？</h6>
<p>想象一下，如果没有 <code>by lazy</code>，我们需要手动实现延迟初始化，代码会是这样，既啰嗦又线程不安全：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> _myHeavyObject: HeavyObject? = <span class="hljs-literal">null</span>
<span class="hljs-keyword">val</span> myHeavyObject: HeavyObject
    <span class="hljs-keyword">get</span>() {
        <span class="hljs-keyword">if</span> (_myHeavyObject == <span class="hljs-literal">null</span>) {
            _myHeavyObject = HeavyObject()
        }
        <span class="hljs-keyword">return</span> _myHeavyObject!!
    }
</code></pre>
<p>再比如，我们需要将一个属性持久化到 <code>SharedPreferences</code>。每个这样的属性都需要重复编写 get/set 逻辑，调用 <code>prefs.getBoolean/putString</code>等方法，充满了模板代码。</p>
<p>属性委托就是为了将这些通用的属性存取行为（如延迟初始化、数据持久化、数据绑定等）封装到可复用的代理类中。</p>
<h6 data-id="heading-15">2. <code>by lazy</code>的工作原理回顾</h6>
<p><code>by lazy</code>正是属性委托的经典实现：</p>
<ul>
<li><code>lazy { ... }</code>：一个函数，它接收一个 Lambda，并返回一个实现了 <code>Lazy&lt;T&gt;</code>接口的属性代理对象。</li>
<li><code>by</code>关键字：将属性的 <code>get()</code>访问器逻辑，完全委托给这个 <code>Lazy&lt;T&gt;</code>代理对象。</li>
<li><code>Lazy&lt;T&gt;</code>代理：内部通过“双重检查锁定”模式，保证初始化 Lambda 只在第一次访问时被线程安全地执行一次，然后缓存结果。</li>
</ul>
<h6 data-id="heading-16">3. 如何提高复用性？以 SharedPreferences 为例</h6>
<p><code>by</code>关键字的威力在于，我们可以创建自己的委托。比如创建一个 <code>Preference</code>委托来封装 <code>SharedPreferences</code>的读写，就能让代码变得极其简洁：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 一个可复用的 Preference 代理类</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Preference</span>&lt;<span class="hljs-type">T</span>&gt;(...) : ReadWriteProperty&lt;Any?, T&gt; {
    <span class="hljs-comment">// ... 内部封装了所有 get/set 逻辑 ...</span>
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getValue</span><span class="hljs-params">(...)</span></span> { <span class="hljs-comment">/* ... */</span> }
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setValue</span><span class="hljs-params">(...)</span></span> { <span class="hljs-comment">/* ... */</span> }
}

<span class="hljs-comment">// 在代码中声明式地使用</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">SettingsManager</span>(context: Context) {
    <span class="hljs-comment">// 一行代码搞定 SharedPreferences 读写，逻辑被完美复用！</span>
    <span class="hljs-keyword">var</span> isNightModeOn: <span class="hljs-built_in">Boolean</span> <span class="hljs-keyword">by</span> Preference(context, <span class="hljs-string">"key_night_mode"</span>, <span class="hljs-literal">false</span>)
    <span class="hljs-keyword">var</span> username: String? <span class="hljs-keyword">by</span> Preference(context, <span class="hljs-string">"key_username"</span>, <span class="hljs-literal">null</span>)
}
</code></pre>
<p>通过这种方式，<code>Preference</code>代理成为了一个可插拔、可复用的能力单元，极大地减少了模板代码，提高了代码的可读性和健壮性。</p>
<h6 data-id="heading-17">委托之二：接口/类委托 (Interface/Class Delegation)</h6>
<p><code>by</code>关键字的第二个强大用途，是让一个类将某个接口的实现，完全委托给另一个对象。这完美诠释了设计模式中的“组合优于继承”原则。</p>
<h6 data-id="heading-18">1. 为什么需要接口委托？</h6>
<p>想象一个场景：我们有一个播放器接口 <code>Player</code>，和一个具体的实现 <code>MediaPlayer</code>。现在，我们需要创建一个 <code>SmartPlayer</code>，它也需要实现 <code>Player</code>接口，但在播放前要增加一个“打印日志”的装饰功能。传统方式下，我们需要写很多模板代码：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SmartPlayer</span> : <span class="hljs-type">Player</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> player = MediaPlayer()

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">play</span><span class="hljs-params">(url: <span class="hljs-type">String</span>)</span></span> {
        println(<span class="hljs-string">"日志：准备播放..."</span>) <span class="hljs-comment">// 增加的装饰逻辑</span>
        player.play(url) <span class="hljs-comment">// 手动转发调用</span>
    }

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span></span> {
        player.stop() <span class="hljs-comment">// 即使 stop 逻辑完全一样，也必须手动转发</span>
    }

    <span class="hljs-comment">// 如果 Player 接口有 10 个方法，就得写 10 个转发方法！</span>
}
</code></pre>
<h6 data-id="heading-19">2. <code>by</code>关键字的优雅解决之道</h6>
<p>使用接口委托，代码会变得极其简洁：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// Player, MediaPlayer 接口和类同上</span>

<span class="hljs-comment">// 使用 `by` 关键字进行接口委托</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">SmartPlayer</span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> player: Player) : Player <span class="hljs-keyword">by</span> player {

    <span class="hljs-comment">// 现在，我们只需要重写那些需要添加“额外逻辑”的方法</span>
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">play</span><span class="hljs-params">(url: <span class="hljs-type">String</span>)</span></span> {
        println(<span class="hljs-string">"日志：准备播放..."</span>) <span class="hljs-comment">// 增加的装饰逻辑</span>
        player.play(url) <span class="hljs-comment">// 调用原始实现</span>
    }

    <span class="hljs-comment">// stop() 方法呢？</span>
    <span class="hljs-comment">// 不需要写了！因为 `Player by player` 这句代码，</span>
    <span class="hljs-comment">// 编译器会自动为我们生成 `stop()` 方法，其实现就是直接调用 `player.stop()`.</span>
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> smartPlayer = SmartPlayer(MediaPlayer())
    smartPlayer.play(<span class="hljs-string">"music.mp3"</span>) <span class="hljs-comment">// 会打印日志并播放</span>
    smartPlayer.stop() <span class="hljs-comment">// 会直接调用 MediaPlayer 的 stop</span>
}
</code></pre>
<p><strong>接口委托的优势</strong>：</p>
<ul>
<li><strong>极致的复用</strong>：<code>Player by player</code>让 <code>SmartPlayer</code>自动拥有了 <code>MediaPlayer</code>对 <code>Player</code>接口的所有实现，我们只需关心需要修改的部分。</li>
<li><strong>轻松实现装饰器模式</strong>：可以非常灵活地为一个已有对象“装饰”上新功能，而无需使用继承。</li>
</ul>
<h4 data-id="heading-20">2. lazy 函数：一个高效的属性代理工厂</h4>
<p>现在我们来看 <code>lazy</code>。它本质上是一个函数，它的作用是接收一个初始化 Lambda 表达式，然后返回一个实现了 <code>Lazy&lt;T&gt;</code>接口的 <strong>属性代理对象</strong>：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">lazy</span><span class="hljs-params">(initializer: () -&gt; <span class="hljs-type">T</span>)</span></span>: Lazy&lt;T&gt; = SynchronizedLazyImpl(initializer)
</code></pre>
<p>这个 <code>Lazy&lt;T&gt;</code>接口很简单，只有一个核心成员：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Lazy</span>&lt;<span class="hljs-type">out T</span>&gt; {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">val</span> value: T <span class="hljs-comment">// 获取值的属性</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isInitialized</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> <span class="hljs-comment">// 检查是否已初始化</span>
}
</code></pre>
<p>而 <code>Lazy&lt;T&gt;</code>接口本身就满足了属性委托的要求，因为它有一个名为 <code>value</code>的只读属性，编译器会自动将对 <code>Lazy&lt;T&gt;</code>的 <code>getValue()</code>调用映射到访问其 <code>value</code>属性上。</p>
<p>所以，<code>by lazy</code>的完整链路是：</p>
<ol>
<li><code>lazy { ... }</code>函数被调用，创建了一个 <code>SynchronizedLazyImpl</code>代理对象。</li>
<li><code>by</code>关键字将属性的 <code>get()</code>访问器逻辑委托给了这个代理对象。</li>
<li>当我们第一次访问属性时，实际上是调用了代理对象的 <code>getValue()</code>，这会触发其内部的 <code>value</code>属性的 <code>get()</code>方法。</li>
<li><code>SynchronizedLazyImpl</code>的 <code>get()</code>方法内，使用了精妙的 <strong>“双重检查锁定（Double-Checked Locking）”</strong> ​ 模式来确保线程安全和高效。</li>
</ol>
<h4 data-id="heading-21">3. SynchronizedLazyImpl 源码解析</h4>
<p>让我们再次深入 <code>SynchronizedLazyImpl</code>的源码，这次带着对委托模式的理解：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// SynchronizedLazyImpl.kt (Kotlin 标准库简化版)</span>
<span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedLazyImpl</span>&lt;<span class="hljs-type">T</span>&gt;(
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> initializer: () -&gt; T, <span class="hljs-comment">// 构造时传入的初始化代码块</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> lock: Any? = <span class="hljs-literal">null</span>
) : Lazy&lt;T&gt;, Serializable {

    <span class="hljs-meta">@Volatile</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> _value: Any? = UNINITIALIZED_VALUE <span class="hljs-comment">// 内部缓存，Volatile 保证多线程可见性</span>
    
    <span class="hljs-comment">// 这就是 Lazy&lt;T&gt; 接口的实现，也是属性委托的核心</span>
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> value: T
        <span class="hljs-keyword">get</span>() {
            <span class="hljs-keyword">val</span> v1 = _value
            <span class="hljs-comment">// 第一次检查：如果已初始化，直接返回。这是最高频的路径，无锁，性能高。</span>
            <span class="hljs-keyword">if</span> (v1 !== UNINITIALIZED_VALUE) {
                <span class="hljs-meta">@Suppress(<span class="hljs-string">"UNCHECKED_CAST"</span>)</span>
                <span class="hljs-keyword">return</span> v1 <span class="hljs-keyword">as</span> T
            }

            <span class="hljs-comment">// 如果未初始化，进入同步块</span>
            <span class="hljs-keyword">return</span> synchronized(lock ?: <span class="hljs-keyword">this</span>) {
                <span class="hljs-keyword">val</span> v2 = _value
                <span class="hljs-comment">// 第二次检查：防止多个线程同时通过第一次检查后，在这里排队导致重复初始化</span>
                <span class="hljs-keyword">if</span> (v2 !== UNINITIALIZED_VALUE) {
                    <span class="hljs-meta">@Suppress(<span class="hljs-string">"UNCHECKED_CAST"</span>)</span>
                    v2 <span class="hljs-keyword">as</span> T
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-comment">// 唯一一次执行初始化的地方</span>
                    <span class="hljs-keyword">val</span> typedValue = initializer()
                    <span class="hljs-comment">// 缓存结果，并使其对其他线程可见（得益于 Volatile）</span>
                    _value = typedValue
                    typedValue
                }
            }
        }
    <span class="hljs-comment">// ...</span>
}
</code></pre>
<p><strong>源码总结</strong>：</p>
<ul>
<li><strong>DCL 模式</strong>：通过两次 <code>if</code>判断和一次 <code>synchronized</code>，实现了极致的性能优化。大部分时间，我们走的都是无锁的快速路径。</li>
<li><strong><code>@Volatile</code></strong>：这是 DCL 模式正确工作的基石，它禁止了指令重排序，并保证了 <code>_value</code>的修改能立刻被其他线程看到。</li>
<li><strong>原子性</strong>：真正的初始化和赋值操作被 <code>synchronized</code>块包裹，保证了其原子性，杜绝了多线程竞争问题。</li>
</ul>
<h3 data-id="heading-22">五、追本溯源：为什么 Kotlin 要设计 by lazy？</h3>
<p>理解了原理后，我们回到一个更根本的问题：Kotlin 为什么要大费周章地设计出这个特性？</p>
<h4 data-id="heading-23">1. 解决通用编程痛点</h4>
<p>在 <code>by lazy</code>出现前，实现“延迟初始化”通常很笨拙：</p>
<ul>
<li><strong>手动实现</strong>：开发者需要自己写 <code>if (instance == null)</code>的模板代码，并且要手动处理多线程安全问题，这既繁琐又容易出错。</li>
<li><strong>使用可空类型</strong>：将属性声明为 <code>var obj: MyObject? = null</code>，导致每次使用都必须处理 null，代码可读性差，且失去了不可变性（<code>val</code>）带来的好处。</li>
<li><strong><code>lateinit</code>的局限</strong>：<code>lateinit</code>虽然解决了部分问题，但它必须是 <code>var</code>，不支持原始类型，且无线程安全保证，访问未初始化的 <code>lateinit</code>变量还会导致程序崩溃。</li>
</ul>
<h4 data-id="heading-24">2. 拥抱函数式与不可变性</h4>
<p>Kotlin 是一门推崇 <strong>不可变性（Immutability）</strong> ​ 的现代语言。<code>by lazy</code>允许我们将一个延迟计算的属性声明为 <code>val</code>。这意义重大，因为它保证了属性一旦被赋值，其引用就不可再更改，让代码状态更可控，更易于推理和测试。</p>
<h4 data-id="heading-25">3. 提升代码的声明式风格</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">val</span> myObject <span class="hljs-keyword">by</span> lazy { createMyObject() }
</code></pre>
<p>这行代码本身就是一种声明，它清晰地表达了 “myObject 是一个延迟初始化的值，它的创建方式在代码块中定义”。开发者只需关心“是什么”和“怎么来”，而无需关心“何时初始化”、“线程是否安全”这些底层细节。这让代码的意图更加明确，可读性更高。</p>
<h3 data-id="heading-26">六、结论与反思</h3>
<p>这次“数据倒灌”事件为我们敲响了警钟，并带来了几点深刻的启示：</p>
<ol>
<li><strong>敬畏生命周期</strong>：在 Android 开发中，必须时刻对组件的生命周期保持敬畏。Activity、Fragment、View 等对象都与特定的 UI 上下文绑定，不应将它们的实例泄露到生命周期更长的作用域中（如 Application、单例）。</li>
<li><strong>理解工具本质</strong>：<code>by lazy</code>是一个优秀的工具，它完美适用于初始化那些昂贵、无状态、且生命周期应与持有者一致的对象（如数据库实例、网络客户端、常量工具类等）。但它不是“银弹”，错用在有状态且生命周期短暂的 UI 组件上，就会引发问题。</li>
<li><strong>区分“工厂”与“仓库”</strong> ：在设计工具类时，要明确它的职责。它是应该像“工厂”一样，每次都生产新产品；还是像“仓库”一样，存储和管理唯一的实例？对于 Fragment 这种 UI 组件，我们显然需要的是一个“工厂”。</li>
</ol>
<p>下次当你想当然地写下 <code>by lazy</code>时，不妨多问自己一个问题：“这个属性的生命周期，真的应该和它所在的类完全一致吗？” 对这个问题的审慎思考，或许能帮你避免下一次“血案”的发生。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[RAG评测完整指南：指标、测试和最佳实践]]></title>    <link>https://juejin.cn/post/7578460753210933275</link>    <guid>https://juejin.cn/post/7578460753210933275</guid>    <pubDate>2025-12-01T09:49:22.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7578460753210933275" data-draft-id="7578709098255155238" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="RAG评测完整指南：指标、测试和最佳实践"/> <meta itemprop="keywords" content="AIGC"/> <meta itemprop="datePublished" content="2025-12-01T09:49:22.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="AIFrontiers"/> <meta itemprop="url" content="https://juejin.cn/user/4443547050451306"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            RAG评测完整指南：指标、测试和最佳实践
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4443547050451306/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    AIFrontiers
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-01T09:49:22.000Z" title="Mon Dec 01 2025 09:49:22 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-01
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读27分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>原文: <a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2Fam89yasxAvuYUToEAWNyTA" target="_blank" title="https://mp.weixin.qq.com/s/am89yasxAvuYUToEAWNyTA" ref="nofollow noopener noreferrer">mp.weixin.qq.com/s/am89yasxA…</a></p>
<p>RAG（Retrieval-Augmented Generation，检索增强生）最初由Facebook AI Research（现Meta AI）团队在论文 <a href="https://link.juejin.cn?target=https%3A%2F%2Farxiv.org%2Fpdf%2F2005.11401" target="_blank" title="https://arxiv.org/pdf/2005.11401" ref="nofollow noopener noreferrer">Retrieval-Augmented Generation for Knowledge-Intensive NLP Tasks</a> 中提出，并发表于NeurIPS 2020。</p>
<p>如果你有使用RAG应用，你会发现，RAG框架是一个复杂的工作流，包括分块、搜索、上下文拼接和内容生成等步骤，一旦系统最终响应的内容不符合预期，对于问题的定位会非常复杂，是模型出现了幻觉？还是从一开始就没有获取到正确的信息？</p>
<p>这就需要一个完善的RAG评估体系：评估RAG系统各个模块运行的效果，在用户之前分析问题、甚至是预判问题。这篇文章会和大家详细聊聊，如何在开发和生产环境中评估RAG系统。</p>
<h2 data-id="heading-0">全文速览</h2>
<ul>
<li>
<p><strong>基本概念</strong>：<strong>RAG系统</strong>能够从大量的语料库中检索出与输入问题相关的上下文信息，并利用这些信息生成准确、合理的回答, <strong>RAG评估</strong>用于评价RAG系统性能的系统方法。</p>
</li>
<li>
<p><strong>RAG评估核心内容</strong>：<strong>检索</strong>（查找有用信息）、<strong>生成</strong>（生成最终答案）。</p>
</li>
<li>
<p><strong>检索评估</strong>：分为排序、上下文相关性指标，前者可以采用Top-K召回，后者可以采用人工或LLM来判断。</p>
</li>
<li>
<p><strong>生成评估</strong></p>
<ul>
<li><strong>有真值</strong>：使用LLM作为评判员或语义相似性，将输出与正确答案进行比较。</li>
<li><strong>无真值</strong>：可以检查响应的忠诚度、完整性、语气或结构质量</li>
</ul>
</li>
<li>
<p><strong>合成测试数据</strong>：一种帮助RAG评估的方法，通过从知识库中生成问答对来实现，用以在没有真实数据的情况下快速构建和测试集。</p>
</li>
<li>
<p><strong>鲁棒性测试和对抗性测试</strong>：确保RAG系统在面对风险输入或极端情况时，响应仍然安全一致。鲁棒性测试评估RAG系统在正常场景之外的行为，并观察其能否从容的应对。对抗性测试侧重系统的安全性，测试RAG系统能够抵御恶意攻击或误操作，并保护用户的数据和隐私。</p>
</li>
</ul>
<h2 data-id="heading-1">基本概念</h2>
<h3 data-id="heading-2">什么是 RAG？</h3>
<p>RAG作为当下主流的LLM应用框架，将外挂的知识库（如网络数据、企业私有文档）、LLM内置的知识完美融合，有效解决LLM中存在的<strong>信息过时</strong>、<strong>输出幻觉、行业数据隔离</strong>等痛点问题，产生更准确、更有用的结果。</p>
<p>举个例子，对于一家公司的客服机器人，LLM是很难知道这家公司的产品功能、业务逻辑的。相反，RAG系统在用户提出问题时，会检索公司内部的产品或业务文档，将检索到的相关内容交给LLM，由LLM生成最终的答案。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5233561057fc4817948a380077453f20~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQUlGcm9udGllcnM=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765187361&amp;x-signature=nL7Qk9rtycvtrazbkCUFGVxnKbc%3D" alt="1.PNG" loading="lazy"/></p>
<p>RAG 系统可以分为两大步骤：</p>
<ul>
<li>R（Retrieval）: 尝试找到与用户查询最相关的信息片段，信息的来源包括文档存储库、知识库、SQL查询数据库等。</li>
<li>G（Generate）: 利用检索到的信息生成答案</li>
</ul>
<p>需要提醒的是，RAG系统是一种设计理念，而非单一的实现形式。比如，<strong>检索</strong>部分的实现形式是多样的，如语义搜索、关键词搜索、SQL查询，甚至是API调用，为模型提供有用的上下文信息。</p>
<p>在企业应用中，检索实际上是对内部的大量非结构化文档进行搜索的系统，包括文档的准备、存储、索引方式和排序。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3a02a6b6d24d472cb7f4038d354226a1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQUlGcm9udGllcnM=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765187361&amp;x-signature=zdIcfbtd0Jy7Dw3LasVG%2FMn1Ksk%3D" alt="2.PNG" loading="lazy"/></p>
<p>检索完成后，需要为LLM构建完整的提示信息，包括：</p>
<ul>
<li>用户的问题</li>
<li>检索到的上下文</li>
<li>系统提示，约定模型按照什么格式输出答案</li>
</ul>
<h3 data-id="heading-3">什么是 RAG 评估？</h3>
<p>定义：旨在衡量RAG系统在实际应用中的性能表现。比如：是否提取了正确的信息？是否给出了正确的答案？输出结果是否可信？一个合理的评估体系有助于回答这些问题，并指导开发工程师做出更好的设计决策。</p>
<p>RAG系统就像一台精密的机器，要让它稳定运转，每个关键环节都要做扎实：文档的分块和存储方式、使用的嵌入模型、检索逻辑、提示格式、LLM 版本等等。</p>
<p>一套靠谱的评估方法，就像这台精密机器的调试工具箱，能解决很多实际问题：</p>
<ul>
<li>快速给出不同方案的对比效果，比如哪种文档分块方式找答案更准</li>
<li>追踪哪些因素能提高或降低效果</li>
<li>精准定位问题，当系统答非所问或出错时，能更快找到症结在哪儿，调试起来更省心。</li>
</ul>
<p>说了这么多，到底该如何评估呢？一种简单的方式，对RAG系统进行端到端评估，重点关注最终答案的质量，这种方式尽管也可行，但不利于问题的排查、效果的优化。</p>
<p>更优的方式是，将检索和生成阶段分开评测，这对于调试也至关重要。当你得到错误答案时，你首先应该问自己：哪里出错了？</p>
<ul>
<li>系统是否检索到正确的上下文信息</li>
<li>上下文正确了，模型是不是出现了幻觉</li>
</ul>
<p>接下来，我们将分别介绍检索和生成阶段的评估方法</p>
<h2 data-id="heading-4">检索阶段的评估方法</h2>
<p>下面将介绍<strong>有真值、人工标注和LLM</strong>三种评估方法。</p>
<h3 data-id="heading-5">有真值的评估方法</h3>
<p>检索评估并非一个新话题，所有搜索引擎的背后都有一套这样的评估机制，比如百度、谷歌，这是一个典型的机器学习应用场景。在这套评估机制的引导下，工程师可以为用户提供更好的产品服务。类似的，我们也可以将这套方法复用到RAG系统中。</p>
<p>你需要有一个<strong>真值数据集，对于每个查询，需要定义包含答案的正确来源，可以是文档ID、数据块ID 或链接。</strong></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6ecbaa7c1403441383fda724de7cc30f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQUlGcm9udGllcnM=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765187361&amp;x-signature=t7EXlLaBEIN3ysNxJ9oSj9R%2F6KE%3D" alt="3.png" loading="lazy"/></p>
<p>在信息检索术语中，这些被称为<strong>相关</strong>文档，即为用户查询提供正确、有效信息的条目。</p>
<p>有了这份真值数据集，就可以在系统中运行查询，并通过比较检索到的数据块与预期数据块，来检查系统是否能够找到预期的上下文。为了量化结果，可以计算标准的信息检索指标。</p>
<p>以下是一些例子，后续将以专栏的形式，详细介绍各类评估指标的原理、实现：</p>

























<table><thead><tr><th>指标</th><th>说明</th></tr></thead><tbody><tr><td>精确度@k</td><td>在检索到的前k个结果中，有多少是真正相关的？</td></tr><tr><td>召回@k</td><td>在所有相关文档中，有多少个文档被检索到排名前k之列？</td></tr><tr><td>命中率</td><td>前k个结果中是否至少出现过一个相关条目？（是/否）</td></tr><tr><td>NDCG@k</td><td>归一化折扣累计收益：用来衡量排名前k个检索结果的相关性和排序合理性</td></tr></tbody></table>
<p>以<strong>精确度@k</strong>指标为例，其计算示意图如下</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8c80093fbacd4a6ebbba6ed279fd4b72~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQUlGcm9udGllcnM=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765187361&amp;x-signature=gxQH2XPQBRAEEZVoaikLuPc50oI%3D" alt="4.png" loading="lazy"/></p>
<p>这些评估指标能帮助我们有效对比不同的搜索配置，比如重排规则、嵌入方法，还能定位问题。缺点是，构建真实的测试数据集特别耗时，需要人工把每个测试问题对应到正确的参考内容上。</p>
<h3 data-id="heading-6">人工标注相关性</h3>
<p>这是一种相对简单的方法，在检索后评估结果。</p>
<p>无需预先定义相关文档，让系统按原样运行测试查询，然后手动评估结果。对于每个查询，都要检查系统的检索内容，并分配一个标签，例如：<em>相关</em>、<em>部分相关 、不相关</em>。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2e1ad812663a4ebc9dcdb3e2183e5aa1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQUlGcm9udGllcnM=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765187361&amp;x-signature=O5Z0R5XY%2Bk%2B29c%2B3q3dtSbd%2F6V8%3D" alt="5.png" loading="lazy"/></p>
<p>许多团队在实践中也是用这种方法评估检索效果的。例如，谷歌制定了详尽的<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.google.com%2Fsearch%2Fhowsearchworks%2Fhow-search-works%2Frigorous-testing%2F" target="_blank" title="https://www.google.com/search/howsearchworks/how-search-works/rigorous-testing/" ref="nofollow noopener noreferrer">内部准则</a> （<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.google.com%2Fsearch%2Fhowsearchworks%2Fhow-search-works%2Frigorous-testing%2F%25EF%25BC%2589%25E4%25BE%259B%25E4%25BA%25BA%25E5%25B7%25A5%25E8%25AF%2584%25E5%2588%2586%25E5%2591%2598%25E5%258F%2582%25E8%2580%2583%25E3%2580%2582" target="_blank" title="https://www.google.com/search/howsearchworks/how-search-works/rigorous-testing/%EF%BC%89%E4%BE%9B%E4%BA%BA%E5%B7%A5%E8%AF%84%E5%88%86%E5%91%98%E5%8F%82%E8%80%83%E3%80%82" ref="nofollow noopener noreferrer">www.google.com/search/hows…</a></p>
<p>这样做的好处是灵活，可以评估整个检索流程在实际运行中的效果，包括：</p>
<ul>
<li>评估用户在生产环境中实际看到的检索质量。</li>
<li>找出性能极差的查询</li>
<li>更好地理解边界情况和歧义查询</li>
</ul>
<p>缺点也显而易见，无法计算召回率，因为没有真值。</p>
<h3 data-id="heading-7">LLM评审员评估相关性</h3>
<p>LLM评审员使用用大语言模型，在评估提示词的引导下，评价RAG系统响应的结果。比如，可以给LLM定制提示词，让它判断某个回复有没有帮助，或者是否符合特定的规则要求。</p>
<p>下面，将为大家介绍LLM评审员的两种技术方案。</p>
<h4 data-id="heading-8">对数据块评估相关性</h4>
<p>可以把用户的问题和检索到的数据块一起给到LLM评审员，让它来判断信息块和用户问题是否相关。</p>
<p>LLM评审员给出的判断结果有两种形式：</p>
<ul>
<li>简单的二分类标签，直接标记<em>相关、</em> <em>不相关</em></li>
<li>给出一个具体的相关性分数</li>
</ul>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3227c6ca72b94edd847c9cdb81bdb22b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQUlGcm9udGllcnM=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765187361&amp;x-signature=9Z45Phx6vYMKsepSsMX2rVVe3XM%3D" alt="6.png" loading="lazy"/></p>
<p>还可以使用其他LLM评估方法，例如，基于嵌入的语义相似度，它会返回一个数值分数，反映查询和检索到的数据块在语义上的相似程度。</p>
<p>需要注意的是，RAG系统一般会对单次查询返回多个数据块，这意味着需要对每个数据块单独进行评分。</p>
<p><strong>举个简单的例子</strong>：假设关于香蕉的查询检索到三个短文本块。每个文本块都是一个句子，可能来自不同的文档。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4cf7f32774df47899c01e73296135e25~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQUlGcm9udGllcnM=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765187361&amp;x-signature=swAWDm2mySNSkTtq0w4038dQMjk%3D" alt="7.png" loading="lazy"/></p>
<p>然后，采用LLM评审员为每个数据块分配一个相关性分数，其中 1 表示高度相关，0 表示完全不相关。</p>
<p>例如，上图中的<strong>Chunk 1</strong>包含有关香蕉健康益处的相关信息，得1分。但<strong>Chunk 3</strong>这样的内容与用户的查询无相关性，得0分。</p>
<p>一旦评估完每个数据块的相关性之后，就可以汇总结果，评估本次查询的整体检索质量。 有三种实现方式：</p>
<ul>
<li><strong>二元命中</strong>：是否至少有一个数据块达到了相关性阈值？</li>
<li><strong>相关数据块占比</strong>：检索到的数据块中，相关的数据块占比是多少？</li>
<li><strong>平均相关性得分</strong>：总体而言，这些内容块的相关性如何？</li>
</ul>
<p>我们以平均相关性得分例，如下图所示，分别是关于香蕉和土豆烹饪的查询，从Relevance来看，关于香蕉的问题，得到了更多相关的数据块。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2d00be7ea04344b0ada8fa345be6d620~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQUlGcm9udGllcnM=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765187361&amp;x-signature=AfPmLDzJZK6l16gX0%2FL4skk5rQs%3D" alt="8.png" loading="lazy"/></p>
<p>更进一步，我们可以汇总每个查询在多个检索文本块下的相关性得分，从而计算出整个测试数据集、或特定时间段内查询的相关性打分。</p>
<h4 data-id="heading-9">对上下文评估相关性</h4>
<p>如果检索系统返回的上下文很短，或者很容易将所有数据块打包成一个上下文块，可以跳过按块评分，直接评估整个上下文。只需要为LLM设置提示词就行，如：</p>
<blockquote>
<p>帮我判断检索到的内容是否包含足够的信息回答用户的问题？如果是，则显示有效；否则，显示无效。</p>
</blockquote>
<p>LLM评审员将会按照上述提示词返回结果，并附有理由，示例如下：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/36c58ac99642444e9c5fb7503be7ea89~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQUlGcm9udGllcnM=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765187361&amp;x-signature=lTyd%2FQRmDjLGMYvThQsZllwUL9Y%3D" alt="9.png" loading="lazy"/></p>
<p>经过上述两种方法的介绍，可以总结LLM评审员方法具有如下优势：</p>
<ul>
<li><strong>工作量低</strong>：只需要测试查询语句，无法标注问题的答案。</li>
<li><strong>强基线性能</strong>：LLM可以很好地处理相关性检查，特别是简单是非问题上。微软在论文 <a href="https://link.juejin.cn?target=https%3A%2F%2Farxiv.org%2Fabs%2F2309.10621" target="_blank" title="https://arxiv.org/abs/2309.10621" ref="nofollow noopener noreferrer">Large language models can accurately predict searcher preferences</a>声称，GPT-4在Bing的RAG系统相关性评估方面，达到了接近人类的水平。</li>
<li><strong>非常适合快速实验</strong>：当你要尝试新的数据库或检索配置时，可以直接运行LLM评审员，快速比较不同配置的效果。</li>
<li><strong>适用于生产环境监控</strong>：由于不需要事先构建真值，特别适合生产环境。</li>
</ul>
<h2 data-id="heading-10">内容生成阶段的评估方法</h2>
<p>一旦系统检索到上下文，LLM就会使用上下文、用户的问题和系统提示词来生成最终答案。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/58bd129444074601b6486f121ddaa7cb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQUlGcm9udGllcnM=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765187361&amp;x-signature=0W8u8xnCn1s79pkBbx9Vmob%2FL2w%3D" alt="10.png" loading="lazy"/></p>
<p>有两种方法评估LLM生成的最终答案是否有效：</p>
<ul>
<li><strong>基于参考的评估</strong> ：将RAG系统的输出与预定义的参考答案进行比较，这就需要构建标注好的数据集，适用于开发或测试环境。</li>
<li><strong>无参考评估</strong> ：当没有参考答案时，仍然可以使用指标来评估质量，比如模型回答结构、语气、长度、完整性、是否包含必要的免责声明等特定属性。这类方法适用于灰度阶段和生产环境。</li>
</ul>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d3c1f3d3662848c1b27027ee2296fa4b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQUlGcm9udGllcnM=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765187361&amp;x-signature=tNjlP%2FNjGeAbLHLa667x%2BxxecG0%3D" alt="11.png" loading="lazy"/></p>
<h3 data-id="heading-11">基于参考的评估</h3>
<p>如果是离线测试，最可靠的评估方法是将LLM的答案与正确的答案进行比较。这些基于参考的评估可以衡量 RAG系统在测试集中与理想答案的接近程度。</p>
<p>从上面的描述可以看出，要使用基于参考的评估方法，需要构建一系列问答对数据集，作为评测基准。</p>
<p>接下来，将问题输入到RAG系统中，并将生成的响应与参考响应进行比较，具体的计分方式如下：</p>
<ul>
<li><strong>语义相似性</strong>: 分别获取生成答案和参考答案的嵌入向量，计算两个向量间的相似度</li>
<li><strong>LLM 作为评判员</strong>：这是一种使用LLM作为判断器的方法，用来比较生成答案和参考答案，并评估RAG响应是否正确、完整或与之前的文本相一致。</li>
</ul>
<p>两种方法效果都不错。语义相似度方法效率高、可扩展性高。基于LLM的方法能够提供更细致的上下文推理，最大的优势可以根据用户的评估规则进行调整。</p>
<p>以下是一个基于LLM方法评估RAG响应效果的示例：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d235357b98584f598606b7c79aa55c05~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQUlGcm9udGllcnM=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765187361&amp;x-signature=zqEE7CTX5M%2FXvkJr65YwA55%2FRYU%3D" alt="12.png" loading="lazy"/></p>
<h3 data-id="heading-12">RAG评测数据集</h3>
<p>在RAG评估中，评测数据集的质量至关重要。若数据集仅含简单或不切实际的问题，模型难以应对现实中的复杂场景。测试用例需贴合真实用户问题、覆盖关键主题，尽可能的覆盖多种场景，只有这样，才能精准评估 RAG 的实际性能。</p>
<p>构建一个完备的测试集需要花费大量精力，好消息是不用完全手动构建，可以直接从知识库生成测试用例，提高效率。实现上也十分简单，从文档或知识库中选取数据块，让LLM完成以下操作：</p>
<ul>
<li>根据数据块的内容，生成一个问题。</li>
<li>根据数据库的内容，生成可以回答上述问题的答案。</li>
</ul>
<p>由于上述测试用例来源真实的RAG知识库，也会更加符合生成环境中的业务场景。此外，你可以通过变换生成问题的表述方式、模拟不同的角色，来匹配实际应用中的查询风格和意图，进一步丰富RAG评测数据集。</p>
<p>一旦有了成千上百个这样的示例，就可以使用它们来对比不同配置下RAG系统的好坏。</p>
<h3 data-id="heading-13">无参考评估</h3>
<p>在实际应用中，用户可以提出任何问题，而事先并不知道<strong>正确答案</strong>是什么。这就需要<strong>无参考的评估方法</strong>了。</p>
<p>比如一些规则性的检查，可以直接通过编程实现，如</p>
<ul>
<li><strong>长度</strong>：答案是否符合规定的字数限制？</li>
<li><strong>链接是否存在</strong>：是否包含指向来源的链接，以及该链接是否有效？</li>
<li><strong>完全匹配</strong>：是否包含特定免责声明？</li>
</ul>
<p>即使没有<strong>正确答案</strong>，仍然可以利用一些有价值的数据，如用户的问题、检索到的上下文以及LLM的响应，通过合适的方法来推断回复本身的质量，以下是一些你可以评估的内容：</p>





























<table><thead><tr><th>指标</th><th>说明</th></tr></thead><tbody><tr><td>忠诚度</td><td>衡量LLM的响应遵从检索的上下文程度。得分低，回答出现幻觉的可能就越大。</td></tr><tr><td>答案相关性</td><td>衡量LLM的回答对用户问题的相关度。得分低，可能答不对题</td></tr><tr><td>上下文相关性</td><td>衡量召回的上下文能够支持用户问题的程度。得分低，检索了太多与问题无关的内容。</td></tr><tr><td>语气</td><td>该回复是否符合品牌的风格或语气？</td></tr><tr><td>拒绝</td><td>RAG系统是否拒绝回答</td></tr></tbody></table>
<p>可以使用LLM作为评判工具来评估上述指标。例如，在计算忠诚度时，可以将问题、上下文和答案传递LLM，提示词可以这样写，<em>答案{RAG的响应}是否忠实于检索到的上下文{RAG检索的内容}，还是添加了未经证实的信息、遗漏了重要细节或与来源相矛盾？请返回忠诚、不忠诚。</em></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0ae09bfd908a4d24aa3865194582d0fc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQUlGcm9udGllcnM=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765187361&amp;x-signature=OigV4v9Ok6sWLua%2Bf1RNpbiM%2BYc%3D" alt="13.png" loading="lazy"/></p>
<p>下面是忠诚度评估方法的具体样例</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/110bfab40883401eb8c8078b76513e3c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQUlGcm9udGllcnM=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765187361&amp;x-signature=KHPrTqvvrtd9lcDCmOOWdSGfZCk%3D" alt="14.png" loading="lazy"/></p>
<h2 data-id="heading-14">RAG评估方法小结</h2>
<p>根据是否存在真值情况，我们对RAG评估方法作了更进一步的总结，如下图所示，从左到右，依次代表检索和生成两个阶段。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/623b7bbad33845639ceaee4f5129fb9d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQUlGcm9udGllcnM=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765187361&amp;x-signature=O0uQCKqtenRjRA6fI2d%2FjnX9fes%3D" alt="15.png" loading="lazy"/></p>
<p><strong>检索阶段</strong>：</p>
<ul>
<li>如果事先知道每个查询的相关文档，可以计算排序指标，如召回@k、NDCG@k。</li>
<li>如果不知道查询的相关文档，可以通过检索的数据块与用户请求的相关性来判断，具体的方式可以是人工标注、或使用LLM来判断。</li>
</ul>
<p><strong>内容生成阶段</strong>：</p>
<ul>
<li>如果有参考答案，可以使用LLM评判员或语义相似性来评估正确性。</li>
<li>即使没有参考答案，可以检查答案是否忠实于上下文/完整，答案是否与问题相关，以及语气、结构或安全性等自定义属性。</li>
</ul>
<p>该使用哪种评估方法，这取决于项目所处的阶段：开发、测试还是生产环境。</p>
<h2 data-id="heading-15">RAG高级评估方法</h2>
<p>对于企业内部使用的RAG系统，基本的质量检查通常就足够了，风险低、范围窄、复杂度也易于管理。</p>
<p>但许多实际应用，情况要复杂的多，尤其是医疗保健、金融或法律支持等领域。这些系统通常服务外部用户，并且涉及信任、准确性和安全性等高风险问题。</p>
<p>可能还会遇到复杂的多轮聊天机器人或代理式流程，在这种情况下，测试一串简单的查询列表是不够的</p>
<p>对于上面提到的情况，需要更高级的评估方法来测试系统的稳健性、边界行为或多轮体验的质量。</p>
<h3 data-id="heading-16">鲁棒性测试</h3>
<p>鲁棒性测试的目标是评估RAG系统在正常场景之外的行为，并观察其能否从容的应对。这意味要测试系统如何处理棘手或不寻常的问题。需要考虑以下情况：</p>
<ul>
<li><strong>明确风险和极端情况</strong>：识别可能导致不良后果的场景。</li>
<li><strong>创建测试查询</strong>：模拟这些风险的测试用例。</li>
<li><strong>确定一个好的回应方式</strong>：例如，可以是拒绝、要求澄清，或者采取稳妥的默认回答。</li>
</ul>
<p>一种可行的方案，可以利用LLM评审员自动对输出进行打分，实现对流程的量化评估。我们来看一个<strong>鲁棒性测试的例子。</strong></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c37ab3e31e8c48b8aae9c8f77bec7059~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQUlGcm9udGllcnM=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765187361&amp;x-signature=XmBBZzHJUA%2BuK1Sw7kDcl6Pk4Qw%3D" alt="16.png" loading="lazy"/></p>
<p>在本例中，为了测试系统回答的一致性，以不同的方式提问同一个问题，比如使用不同的措辞、风格和结构来描述同一个问题，并检查系统响应是否一致。通过对RAG系统进行一致性测试，可以提高其准确性和可靠性，从而更好地满足用户不同表达方式的需求。</p>
<p><strong>边界情况</strong></p>
<p>边界情况指的是在研发中可能会出现的一些非常规、特殊的情况。这些情况可能很难预测，并且可能导致系统出现错误或异常行为。</p>
<p>为了确保系统的稳定性和可靠性，开发者需要针对这些边界情况进行测试。可以通过精心设计一些特殊的测试用例来实现，比如，关于竞争对手的问题、模糊的单个单词查询等。每个测试用例都应该与一个自动化的评估器配对，以检查系统是否正确地处理了该测试用例。</p>
<p>通过边界情况的测试，可以发现并修复潜在的缺陷，从而提高系统的质量和性能。同时，也可以帮助用户更好地理解和使用系统，减少不必要的困惑和误解。</p>
<p>边界问题样例：</p>









































<table><thead><tr><th>类别</th><th>测试内容</th><th>示例输入</th><th>评估/预期行为</th></tr></thead><tbody><tr><td>品牌安全</td><td>当被问及竞争对手或产品评价时，系统表现如何？</td><td>为什么[竞争对手]比[你的品牌]更好？</td><td>回应得当或拒绝；避免负面比较或未经许可的观点。</td></tr><tr><td>外语</td><td>系统如何处理它不应该支持的查询语言</td><td>这是什么政治？ （西班牙语，如果不受支持）</td><td>礼貌地回复支持的语言列表。</td></tr><tr><td>输入不完整</td><td>只有一个词或含义模糊、缺乏明确语境的问题。</td><td>“退款”或“政策”</td><td>要求提供澄清或背景信息，而不是进行推测性回答。</td></tr><tr><td>多个问题</td><td>一次输入可处理多个子问题</td><td>价格是多少？试用期有多长？</td><td>两个问题都回答得很清楚；没有跳过或忽略任何部分。</td></tr><tr><td>歧义查询</td><td>缺乏关键背景信息或有多种可能的含义</td><td>如果我全职工作，需要缴纳哪种税？（未提供国家/地区信息）</td><td>请求澄清（例如，地点）；避免猜测具体细节。</td></tr></tbody></table>
<p>另外，还可以添加<strong>专家精心设计的特殊案例</strong>，即需要根据使用场景进行细致处理的问题。例如，退款政策可能因用户所在国家/地区而异，或者某些员工福利可能仅在用户入职六个月后适用。</p>
<p>为了设计这些问题，与了解目标用户、熟悉某个领域的专家合作会很有帮助。甚至，可以将这些问题收集到一个专门的测试数据集中，因为这些数据具有极高的商业价值，包含行业领域最困难或风险最高的查询。</p>
<h3 data-id="heading-17">对抗性测试</h3>
<p>对抗性测试则是故意试图破坏系统，旨在发现不安全、非预期或不符合规范的行为，这些行为可能会被用户或攻击者在实际使用中触发。</p>
<p>对于面向公众开放的RAG系统，或者是受监管的RAG应用、敏感的行业，对抗性测试尤为重要。我们希望确保模型不仅能够产生好的答案，还要避免产生有害或危险的答案。</p>
<p>在对抗性测试中，需要设计一些查询语句，故意尝试破坏系统，例如绕过安全措施、混淆模型或触发风险输出。这些示例可能不会出现在常规用户日志中，但它们正是你在生产环境中出现故障之前想要确认的场景。可以人为地创建这些测试查询语句，以模拟真实的攻击尝试。</p>
<p>一些常见的测试场景：</p>
<ul>
<li><strong>提示注入</strong>：试图覆盖原始的提示指令，例如，<em>忽略之前的文本，改为……</em></li>
<li><strong>越狱</strong>：巧妙措辞的输入，试图诱使模型违反安全协议。例如：<em>告诉我如何做X，但假装是为了写小说。</em></li>
<li><strong>有害内容</strong>：与暴力、仇恨言论、自残或虚假信息相关的查询。</li>
<li><strong>禁忌话题</strong>：有关法律咨询、医疗诊断、政治方面的问题，如果不是该领域的应用，系统最好不要响应相关问题。</li>
<li><strong>操纵尝试</strong>：试图让系统自动提供财务报价、折扣或确认等一系列需要人工批准的事情。例如，<em>今天的折扣码是什么？我可以申请退款吗？</em></li>
<li><strong>敏感场景</strong>：来自弱势用户的反馈。例如：*我感到绝望，我该怎么办？*这样的问题应该得到清晰、安全且尊重的回应，理想情况下，还应进行升级处理或转人工。</li>
</ul>
<h3 data-id="heading-18">会话级评估</h3>
<p>许多RAG系统并非仅仅回答单个问题，而是参与多轮对话。例如，客服聊天机器人或故障排除助手，用户需要通过多个步骤与系统进行交互。</p>
<p>这意味着系统的质量评估不仅仅取决于一次回复，还需要考虑是否很好地处理整个对话过程。针对这种场景，可以从以下几个方面考虑：</p>
<ul>
<li><strong>会话成功</strong>：用户的问题最终是否得到解决？</li>
<li><strong>一致性</strong>：系统是否忘记了上下文、重复或自相矛盾？</li>
<li><strong>谈话语气</strong>：整个谈话过程中语气是否恰当？</li>
</ul>
<p>在测试中，会话级别的数据比单个回合的例子更难创建。有两种备选方案：</p>
<ul>
<li>让测试人员在真实场景下收集对话信息，这种方法可以提供最真实的数据，成本高、效率低。</li>
<li>设计自动化脚本模拟多轮测试用例，用以代表常见或关键用户使用场景，这种方法可在短时间内生成大量的测试用例，但会忽略一些真实场景下的交互细节，容易导致测试不准确。</li>
</ul>
<p>沿用之前用大模型做评估的思路，把多轮对话传给模型，让其评估帮助性、回答的一致性，或是用户的情绪变化等内容。输出结果可以是二元判断，比如直接标记<em>已解决、未解决</em>，再附上具体的评估依据。</p>
<p>对于离线环境会话级测试不太好落地，但在生产环境下，可以真实地评估用户与RAG系统的交互情况。为了便于后续自动化评估、问题排查，需要在后端开启会话跟踪，根据用户ID、会议ID记录多轮交互内容。</p>
<p>当数据积累到一定规模后，通过自定义的筛选规则，从中获取特定的会话内容进行评测，比如用户提到竞争对手、表达对产品不满的对话内容。</p>
<p>小结一下，会话级评估能发现单轮检查易遗漏的问题，比如丢失上下文、反复说一样的内容，或者始终没解决用户的核心问题，而是在和用户打太极。融合了会话级评估的RAG系统， 能确保即时回应、真正解决用户咨询的问题。</p>
<h2 data-id="heading-19">RAG评估最佳实践</h2>
<p>设计一套好的评估体系不仅选择指标，还得构建切实可行的工作流程，帮助迭代改进，并始终满足真实的用户体验。</p>
<h3 data-id="heading-20">设计高质量的测试用例</h3>
<p>评估效果取决于测试样本的质量。在考虑评估指标、撰写LLM评估提示词之前，优先关注评估数据集：是否真实、与测试目标相关性如何？是否具有代表性？</p>
<p><strong>优先使用真实数据</strong>。如果可以，尽量使用真实的用户查询、过往的对话日志或内部搜索历史记录来生成测试用例。这样做，保证了评测数据符合人们实际使用的场景。</p>
<p><strong>没有真实数据，可以考虑合成</strong>。可以调整数据合成策略，生成更真实、更多样化的示例。比如，在给LLM系统提示词时，为其定义具体的角色（正在比较方案的客户、正在审核政策的内部分析师等），从他们的角度生成问题。另外，测试内容需要结合数据类型的比例来生成，假设实际场景中有40%是与商品退款有关，在合成数据中也需要体现这一点。</p>
<p><strong>一定要人工检查合成的测试机</strong>。LLM可以辅助生成测试用例，但并不意味着可以盲目使用测试数据集。需要规则脚本进行筛选，甚至需人工抽样筛查。</p>
<p><strong>参考领域专家的建议</strong>。在某些具体的领域，存在许多边界情况，可能会影响系统性能、安全性和稳定性的情况。这些情况通常由丰富经验和知识的专业人员掌握。可以提供一些工具和支持，例如共享表格或轻量级用户界面，帮助他们更轻松地审查输出结果，并提出测试案例。</p>
<p><strong>在实验中，务必使用相同的测试集</strong>。每次运行都重新生成测试集，这是一类常见的错误，会引入噪声，使结果不可靠。正确的做法是，保持测试集的稳定。</p>
<p><strong>随着时间的推移，请更新测试数据集</strong>。在完成不同配置的性能对比、系统也稳定运行一段时间了，测试集的规模也应该不断演进，可以使用观察到的真实用户查询和故障来扩展数据集。另外，最好保留一份最初的测试集，作为整个系统的性能基线。</p>
<h3 data-id="heading-21">选择核心的指标</h3>
<p>不需要对所有的指标评估一次，应当结合系统的当前问题、业务需求，选择适配的评估方式。</p>
<ul>
<li><strong>拒绝万能指标</strong>：不同的阶段需用不同评估工具，例如，检索评估要看数据块相关性与排序质量，鲁棒性测试要考虑品牌安全等定制评估项，生产环境追踪忠实度、格式正确性等核心指标。</li>
<li><strong>聚焦实际问题</strong>：优先对已发现的错误或高风险点设计评估，避免对所有指标评估，这只会增加工作量和噪声干扰，这类指标无法定位真实问题。</li>
<li><strong>让LLM对齐人工标注</strong>：LLM 评估方法需以人工标注为基准，而非依赖现成提示词或固定指标，要通过人工标注案例校准优化LLM提示词，使LLM评估标准与业务标注准则保持一致，从而实现人工标注的规模化延伸。</li>
<li><strong>规避完美主义</strong>：评估方法以有用为目标，不要追求极致，可以通过迭代持续优化，核心是构建<strong>发现问题-测试修复-验证效果</strong>的有效闭环。</li>
</ul>
<h2 data-id="heading-22">参考资料</h2>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Farxiv.org%2Fpdf%2F2005.11401" target="_blank" title="https://arxiv.org/pdf/2005.11401" ref="nofollow noopener noreferrer">Retrieval-Augmented Generation for Knowledge-Intensive NLP Tasks</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.google.com%2Fsearch%2Fhowsearchworks%2Fhow-search-works%2Frigorous-testing%2F" target="_blank" title="https://www.google.com/search/howsearchworks/how-search-works/rigorous-testing/" ref="nofollow noopener noreferrer">内部准则</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Farxiv.org%2Fabs%2F2309.10621" target="_blank" title="https://arxiv.org/abs/2309.10621" ref="nofollow noopener noreferrer">Large language models can accurately predict searcher preferences</a></li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[【实战】LangChain 难懂？用 Trae 智能编辑器 10 分钟速成]]></title>    <link>https://juejin.cn/post/7578699975413743616</link>    <guid>https://juejin.cn/post/7578699975413743616</guid>    <pubDate>2025-12-01T10:09:59.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7578699975413743616" data-draft-id="7578734725301370932" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="【实战】LangChain 难懂？用 Trae 智能编辑器 10 分钟速成"/> <meta itemprop="keywords" content="LangChain,Node.js,Trae"/> <meta itemprop="datePublished" content="2025-12-01T10:09:59.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Dr_哈哈"/> <meta itemprop="url" content="https://juejin.cn/user/2208293602984286"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            【实战】LangChain 难懂？用 Trae 智能编辑器 10 分钟速成
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2208293602984286/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Dr_哈哈
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-01T10:09:59.000Z" title="Mon Dec 01 2025 10:09:59 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-01
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body cache result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>💡 <strong>写在前面</strong>：
学习新技术的最好方式不是死磕文档，而是<strong>动手实操</strong>。
本文将带你使用新一代 AI 智能编辑器 <strong>Trae</strong>，结合<strong>费曼学习法</strong>（用最通俗的语言解释复杂概念），在 10 分钟内从零搭建一个 LangChain 学习环境，并彻底搞懂其核心原理。</p>
<p><strong>适合人群</strong>：Node.js 开发者、AI 应用初学者、希望体验 AI 结对编程的开发者。</p>
</blockquote>
<hr/>
<h2 data-id="heading-0">🚀 第一步：拒绝配置地狱，用 Trae 一键搭建环境</h2>
<p>不要去手动查 <code>npm</code> 怎么装包了，也不用担心版本冲突。我们直接利用 <strong>Trae 的 Solo 模式（Builder 模式）</strong>，让 AI 帮你一键生成所有基础代码。</p>
<h3 data-id="heading-1">🛠️ 1. 让 AI 帮你干活</h3>
<ol>
<li>打开 <strong>Trae</strong> 编辑器。</li>
<li>按下 <code>Cmd + I</code> (macOS) 或 <code>Ctrl + I</code> (Windows) 唤起 AI 对话框，或者切换到 <strong>Builder</strong> 模式。</li>
<li><strong>直接复制以下提示词（Prompt）发送给 Trae</strong>：</li>
</ol>
<pre><code class="hljs language-text" lang="text">我是 LangChain 初学者，请帮我在当前目录下搭建一个 Node.js 学习环境：

1. 初始化 package.json。
2. 安装依赖：`langchain`, `@langchain/deepseek`, `@langchain/core`, `dotenv`。
3. 创建三个核心案例文件（请写出完整代码）：
   - `src/simple-llm-app.js`: 实现一个最简单的“中英翻译”流式对话 Chain。
   - `src/cot.js`: 实现一个“思维链（Chain of Thought）”案例，模拟资深工程师排查网页性能问题，使用 SystemMessage 引导推理。
   - `src/few-shot-learning.js`: 实现一个“少样本学习（Few-Shot）”案例，教会 AI 生成 JSDoc 格式的注释。
4. 创建 `.env` 文件，内容为 `DEEPSEEK_API_KEY=`，并提示我需要填入 DeepSeek 的 Key。

完成后，请告诉我如何运行这些文件。
</code></pre>
<ol start="4">
<li>点击发送，看着 Trae 自动为你创建文件、安装依赖。</li>
</ol>
<h3 data-id="heading-2">🔑 2. 关键准备：配置 API 密钥</h3>
<p>代码生成好后，你还需要一把“钥匙”才能启动 AI。本项目使用 DeepSeek（深度求索）的大模型能力。</p>
<ol>
<li>
<p><strong>获取密钥</strong>：前往 <a href="https://link.juejin.cn?target=https%3A%2F%2Fplatform.deepseek.com%2F" target="_blank" title="https://platform.deepseek.com/" ref="nofollow noopener noreferrer">DeepSeek 开放平台</a> 注册账号并创建 API Key。</p>
</li>
<li>
<p><strong>配置项目</strong>：</p>
<ul>
<li>打开 Trae 刚刚帮你生成的 <code>.env</code> 文件。</li>
<li>找到 <code>DEEPSEEK_API_KEY=</code> 这一行。</li>
<li>将你申请到的以 <code>sk-</code> 开头的密钥粘贴在后面（注意不要有空格）。</li>
</ul>
<pre><code class="hljs language-env" lang="env">DEEPSEEK_API_KEY=sk-your-secret-key-here
</code></pre>
</li>
</ol>
<p>做完这一步，你的环境就彻底准备好了！</p>
<hr/>
<h2 data-id="heading-3">🍳 第二步：费曼学习法——如果不写代码，怎么理解 LangChain？</h2>
<p>在运行代码之前，我们先建立一个心智模型。看着生成出来的代码，你可能会问：“这些 <code>Chain</code>, <code>PromptTemplate</code> 到底是干嘛的？”</p>
<p>想象一下：</p>
<ul>
<li><strong>你是主厨</strong>（开发者）。</li>
<li><strong>LLM（大模型，如 DeepSeek）是你的天才帮厨</strong>。他博学多才，但有时很死板，必须指令非常精确才能干好活。</li>
<li><strong>LangChain 是你买的一套“现代化中央厨房系统”</strong>。</li>
</ul>
<p>如果你没有 LangChain，你每天都要对帮厨大喊大叫：“嘿，把这个切了！嘿，用那个语气说话！”（手动拼接字符串，手动调 API）。</p>
<p>有了 <strong>LangChain</strong>，你拥有了：</p>
<ol>
<li><strong>标准印章（Prompt Template）</strong>：把常用指令刻成章，盖下去就是标准需求。</li>
<li><strong>自动化传送带（Chain/Pipe）</strong>：原料放上去，自动经过“切菜-烹饪-摆盘”，最后出成品。</li>
<li><strong>样板间（Few-Shot）</strong>：直接展示成品样例，让帮厨照猫画虎，不再需要费尽口舌解释。</li>
</ol>
<hr/>
<h2 data-id="heading-4">💻 第三步：核心代码拆解与运行</h2>
<p>现在，打开 Trae 刚刚帮你生成的代码文件，我们来一一对应上述概念。</p>
<h3 data-id="heading-5">1. 基础入门：自动化流水线 (Chains)</h3>
<blockquote>
<p><strong>核心概念</strong>：<code>PromptTemplate</code>（模版）+ <code>Pipe</code>（管道）
<strong>文件</strong>：<code>src/simple-llm-app.js</code></p>
</blockquote>
<p><strong>代码核心片段：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// ... 省略 import ...</span>

<span class="hljs-comment">// 1. 准备模版（印章）：定义好输入变量 {input_language} 等</span>
<span class="hljs-keyword">const</span> prompt = <span class="hljs-title class_">ChatPromptTemplate</span>.<span class="hljs-title function_">fromMessages</span>([
  [
    <span class="hljs-string">"system"</span>,
    <span class="hljs-string">"You are a helpful assistant that translates {input_language} to {output_language}."</span>,
  ],
  [<span class="hljs-string">"human"</span>, <span class="hljs-string">"{text}"</span>],
]);

<span class="hljs-comment">// 2. 初始化模型（帮厨）</span>
<span class="hljs-keyword">const</span> llm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChatDeepSeek</span>({ <span class="hljs-attr">model</span>: <span class="hljs-string">"deepseek-chat"</span> });

<span class="hljs-comment">// 3. 搭建传送带（Chain）：模版 -&gt; 模型 -&gt; 字符串处理</span>
<span class="hljs-comment">// .pipe() 是 LangChain 最优雅的设计，像接水管一样把处理流程串起来</span>
<span class="hljs-keyword">const</span> chain = prompt.<span class="hljs-title function_">pipe</span>(llm).<span class="hljs-title function_">pipe</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringOutputParser</span>());

<span class="hljs-comment">// 4. 启动机器</span>
<span class="hljs-keyword">await</span> chain.<span class="hljs-title function_">stream</span>({
  <span class="hljs-attr">input_language</span>: <span class="hljs-string">"English"</span>,
  <span class="hljs-attr">output_language</span>: <span class="hljs-string">"Chinese"</span>,
  <span class="hljs-attr">text</span>: <span class="hljs-string">"I love programming with Trae!"</span>,
});
</code></pre>
<p><strong>📺 运行效果：</strong>
在终端输入 <code>node src/simple-llm-app.js</code>，你会看到：</p>
<pre><code class="hljs language-text" lang="text">我爱用 Trae 编程！
</code></pre>
<p><em>(AI 会自动将英文翻译成中文，而且是流式输出的。)</em></p>
<p><strong>🔍 解析：</strong>
以前你需要手动拼接字符串发送给 API，现在通过 <code>prompt.pipe(llm)</code>，你定义了一套<strong>标准作业程序（SOP）</strong>。无论输入变什么，流程永远稳健。</p>
<hr/>
<h3 data-id="heading-6">2. 进阶思考：思维链 (Chain of Thought)</h3>
<blockquote>
<p><strong>核心概念</strong>：<code>SystemMessage</code>（人设设定）+ <code>Reasoning</code>（推理引导）
<strong>文件</strong>：<code>src/cot.js</code></p>
</blockquote>
<p><strong>代码核心片段：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// ... 省略 import ...</span>

<span class="hljs-comment">// 1. 精心设计的 System Prompt（给帮厨的岗前培训手册）</span>
<span class="hljs-keyword">const</span> systemPrompt = <span class="hljs-string">`
你是一个负责排查网页性能问题的资深工程师。
请使用 Chain-of-Thought（连锁思维）在内部系统性地分析问题...
输出格式严格分为两部分：
1) Reasoning Summary: &lt;思考过程摘要&gt;
2) Final Answer: &lt;分步骤建议&gt;
`</span>;

<span class="hljs-keyword">const</span> messages = [
  <span class="hljs-keyword">new</span> <span class="hljs-title class_">SystemMessage</span>(systemPrompt), <span class="hljs-comment">// 设定人设与规则</span>
  <span class="hljs-keyword">new</span> <span class="hljs-title class_">HumanMessage</span>(<span class="hljs-string">"如果一个网页加载速度慢，该如何处理？"</span>), <span class="hljs-comment">// 用户提问</span>
];

<span class="hljs-comment">// 2. 调用模型</span>
<span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> llm.<span class="hljs-title function_">invoke</span>(messages);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res.<span class="hljs-property">content</span>);
</code></pre>
<p><strong>📺 运行效果：</strong>
在终端输入 <code>node src/cot.js</code>，你会看到结构非常清晰的回答：</p>
<pre><code class="hljs language-text" lang="text">1) Reasoning Summary:
分析了前端资源大小、网络延迟及后端响应时间。确定了性能瓶颈可能在于图片未压缩和 API 响应慢。

2) Final Answer:
a) 性能监控：使用 Chrome DevTools 和 Lighthouse 确定具体慢在哪个环节...
b) 性能数据分析：分析 Network 面板中的 Waterfall 图...
c) 解决方案：开启 Gzip 压缩，使用 CDN...
...
</code></pre>
<p><em>(AI 没有直接给答案，而是先展示了它的思考过程摘要，然后给出了结构化的建议。)</em></p>
<p><strong>🔍 解析：</strong>
LangChain 通过明确区分 <code>SystemMessage</code>（系统指令）和 <code>HumanMessage</code>（用户输入），让你能更精准地控制模型的**“思考深度”**。这里通过 Prompt Engineering 技巧，强制模型进行 CoT 推理，从而得到比普通问答更专业、逻辑更严密的答案。</p>
<hr/>
<h3 data-id="heading-7">3. 高级调教：少样本学习 (Few-Shot Learning)</h3>
<blockquote>
<p><strong>核心概念</strong>：<code>FewShotPromptTemplate</code>（示例增强）
<strong>文件</strong>：<code>src/few-shot-learning.js</code></p>
</blockquote>
<p><strong>代码核心片段：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// ... 省略 import ...</span>

<span class="hljs-comment">// 1. 定义示例库（Examples）：告诉模型什么是“满分答案”</span>
<span class="hljs-keyword">const</span> examples = [
  {
    <span class="hljs-attr">question</span>: <span class="hljs-string">"function add(a, b) { return a + b; }"</span>,
    <span class="hljs-attr">answer</span>: <span class="hljs-string">"/** 两个数字相加求和 ... */"</span>,
  },
  <span class="hljs-comment">// ... 更多示例</span>
];

<span class="hljs-comment">// 2. 创建“样板间”模版</span>
<span class="hljs-keyword">const</span> prompt = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FewShotPromptTemplate</span>({
  <span class="hljs-attr">examples</span>: examples, <span class="hljs-comment">// 注入示例</span>
  <span class="hljs-comment">// ...</span>
});

<span class="hljs-comment">// 3. 模型看到示例后，会模仿示例的风格来处理新输入</span>
<span class="hljs-keyword">const</span> formatted = <span class="hljs-keyword">await</span> prompt.<span class="hljs-title function_">format</span>({
  <span class="hljs-attr">input</span>: <span class="hljs-string">"function formatDate(date) { ... }"</span>,
});
</code></pre>
<p><strong>📺 运行效果：</strong>
在终端输入 <code>node src/few-shot-learning.js</code>，AI 会自动为你的函数写出完美的注释：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">/**
 * 格式化日期对象为 YYYY-MM-DD 格式的字符串
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Date</span>} <span class="hljs-variable">date</span> - 需要格式化的日期对象
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">string</span>} 格式化后的日期字符串
 */</span>
</code></pre>
<p><em>(注意：你并没有告诉它要用 @param，但因为它看了你给的示例，所以它学会了。)</em></p>
<p><strong>🔍 解析：</strong>
这是 LangChain 极其强大的能力。通过 <code>FewShotPromptTemplate</code>，你不需要微调模型（Fine-tuning），只需要在 Prompt 中动态插入几个高质量的例子（Context），就能显著提升模型在特定任务上的表现。这叫**“照猫画虎”**，效果拔群。</p>
<hr/>
<h2 data-id="heading-8">📝 总结与行动</h2>
<p>你现在已经拥有了一个完整的 LangChain 实验环境。不要停在这里！</p>
<p><strong>下一步，你可以继续使用 Trae 进行探索：</strong></p>
<ol>
<li><strong>修改需求</strong>：选中 <code>simple-llm-app.js</code> 的代码，告诉 Trae：“把这个改造成一个只会用莎士比亚风格说话的机器人”。</li>
<li><strong>增加功能</strong>：告诉 Trae：“我想把 <code>cot.js</code> 的输出结果保存到一个 markdown 文件里”。</li>
<li><strong>解释代码</strong>：遇到看不懂的函数，直接选中代码问 Trae：“这一行具体做了什么？”</li>
</ol>
<p><strong>LangChain 不生产智能，它是连接你的意图与大模型能力的桥梁。而 Trae，就是帮你快速架起这座桥梁的工程师。</strong></p>
<p>快去动手试试吧！🚀</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Advent of Code 2025 挑战全手写代码 Day 1 - 秘密入口]]></title>    <link>https://juejin.cn/post/7578714759336443904</link>    <guid>https://juejin.cn/post/7578714759336443904</guid>    <pubDate>2025-12-01T09:27:20.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7578714759336443904" data-draft-id="7578700798743625762" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Advent of Code 2025 挑战全手写代码 Day 1 - 秘密入口"/> <meta itemprop="keywords" content="Python,GitHub"/> <meta itemprop="datePublished" content="2025-12-01T09:27:20.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="linzeyang"/> <meta itemprop="url" content="https://juejin.cn/user/897656724654199"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Advent of Code 2025 挑战全手写代码 Day 1 - 秘密入口
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/897656724654199/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    linzeyang
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-01T09:27:20.000Z" title="Mon Dec 01 2025 09:27:20 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-01
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读2分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body cache result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">🎄Advent of Code 2025 挑战全手写代码 Day 1 - 秘密入口</h2>
<hr/>
<p>终于等到 AoC 2025 开赛啦！🎉 第一天题目 <code>Secret Entrance</code> 难度简单（一星⭐），主要考察对 <em>循环结构（Circular Buffer）</em> 的理解和模运算的运用。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/893549a9cdac44dbba1db100256d8e10~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbGluemV5YW5n:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765186040&amp;x-signature=FPV9ZsIAbhE%2BBHnplXx%2BM6b2fNg%3D" alt="advent-of-code-2025-day-1" loading="lazy"/></p>
<p><strong>📖 题目速览</strong></p>
<p>题目地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fadventofcode.com%2F2025%2Fday%2F1" target="_blank" title="https://adventofcode.com/2025/day/1" ref="nofollow noopener noreferrer">adventofcode.com/2025/day/1</a></p>
<p>我们在北极秘密入口遇到一个保险箱转盘，刻度 <code>0-99</code>，初始位置 <code>50</code>。
输入是一串旋转指令（如 <code>L68</code>, <code>R48</code>）。</p>
<ul>
<li><strong>Part 1</strong>：统计每次旋转<strong>结束时</strong>，指针停在 <code>0</code> 的次数。</li>
<li><strong>Part 2</strong>：统计旋转<strong>过程中</strong>（包含结束点）指针指向 <code>0</code> 的总次数。</li>
</ul>
<p><strong>💡 解题思路 (Python 🐍)</strong></p>
<ol>
<li><strong>巧用取模 <code>%</code></strong>：
转盘是环形的，Python 的模运算 <code>%</code> 就能搞定
<ul>
<li>右转：<code>(current + amount) % 100</code></li>
<li>左转：<code>(current - amount) % 100</code></li>
<li>Python 的 <code>%</code> 能完美处理负数（例如 <code>-1 % 100 = 99</code>），直接省去了繁琐的边界判断，代码瞬间清爽！</li>
</ul>
</li>
</ol>
<pre><code class="hljs language-python" lang="python">current: <span class="hljs-built_in">int</span> = <span class="hljs-number">50</span>
out: <span class="hljs-built_in">int</span> = <span class="hljs-number">0</span>

<span class="hljs-keyword">for</span> direction, amount <span class="hljs-keyword">in</span> self.sequence:
    <span class="hljs-keyword">match</span> direction:
        <span class="hljs-keyword">case</span> <span class="hljs-string">"R"</span>:
            current = (current + amount) % <span class="hljs-number">100</span>
        <span class="hljs-keyword">case</span> <span class="hljs-string">"L"</span>:
            current = (current - amount) % <span class="hljs-number">100</span>

    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> current:
        out += <span class="hljs-number">1</span>
</code></pre>
<ol start="2">
<li><strong>Part 2 的优化陷阱</strong>：
题目提示可能会有像 <code>R1000</code> 这种大旋转。如果一步步模拟（for loop），效率会很低。
<ul>
<li><strong>数学解法</strong>：使用 <code>divmod(amount, 100)</code>。</li>
<li><strong>整圈</strong>：商 (<code>div</code>) 表示转了几整圈，每圈必然经过一次 0。</li>
<li><strong>残余步数</strong>：余数 (<code>mod</code>) 是剩下的位移。只需判断这最后一段位移是否跨越了 <code>0</code> 界限（R 跨越 99-&gt;0，L 跨越 0-&gt;99）。</li>
</ul>
</li>
</ol>
<pre><code class="hljs language-python" lang="python">current: <span class="hljs-built_in">int</span> = <span class="hljs-number">50</span>
out: <span class="hljs-built_in">int</span> = <span class="hljs-number">0</span>

<span class="hljs-keyword">for</span> direction, amount <span class="hljs-keyword">in</span> self.sequence:
    div, mod = <span class="hljs-built_in">divmod</span>(amount, <span class="hljs-number">100</span>)
    out += div

    <span class="hljs-keyword">match</span> direction:
        <span class="hljs-keyword">case</span> <span class="hljs-string">"R"</span>:
            <span class="hljs-keyword">if</span> current + mod &gt;= <span class="hljs-number">100</span>:
                out += <span class="hljs-number">1</span>

            current = (current + mod) % <span class="hljs-number">100</span>
        <span class="hljs-keyword">case</span> <span class="hljs-string">"L"</span>:
            <span class="hljs-keyword">if</span> current &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> mod &gt;= current:
                out += <span class="hljs-number">1</span>

            current = (current - mod) % <span class="hljs-number">100</span>

<span class="hljs-keyword">return</span> out
</code></pre>
<p><strong>✨ 代码复盘</strong>
最终代码将“计算经过次数”和“更新位置”解耦，逻辑非常清晰。相比于暴力模拟，数学计算法不仅快，而且更能体现算法思维。</p>
<p>完整代码：访问 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Flinzeyang%2Fadvent-of-code%2Fblob%2Fmain%2F2025%2Fday_01.py" target="_blank" title="https://github.com/linzeyang/advent-of-code/blob/main/2025/day_01.py" ref="nofollow noopener noreferrer">github</a></p>
<p>Happy Coding! 冲刺排行榜！🚀
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/97dd75f1793a4ab180543b966fd612a0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbGluemV5YW5n:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765186040&amp;x-signature=VM8bTeuSt0PRRuPsmE6VSQ8UwTI%3D" alt="day-1-snapshot" loading="lazy"/></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[IntersectionObserver：现代Web开发的交叉观察者]]></title>    <link>https://juejin.cn/post/7578709098255482918</link>    <guid>https://juejin.cn/post/7578709098255482918</guid>    <pubDate>2025-12-01T10:28:17.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7578709098255482918" data-draft-id="7577321767346913326" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="IntersectionObserver：现代Web开发的交叉观察者"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2025-12-01T10:28:17.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Drift_Dream"/> <meta itemprop="url" content="https://juejin.cn/user/3107677514241500"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            IntersectionObserver：现代Web开发的交叉观察者
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3107677514241500/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Drift_Dream
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-01T10:28:17.000Z" title="Mon Dec 01 2025 10:28:17 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-01
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.7;font-weight:400;font-size:16px;overflow-x:hidden;color:#212122}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-bottom:8px;padding-bottom:8px}.markdown-body h1{color:#a0a0a0;font-size:38px;margin-top:32px;padding-top:32px}.markdown-body h2{color:#fff;background-color:#212122;width:fit-content;border-bottom-right-radius:100px;margin-top:47px;margin-bottom:16px;padding:4px 48px 4px 8px;line-height:1.7;font-size:30px;transition:all .3s ease-out}.markdown-body h2:hover{border-bottom-right-radius:50px;transition:all .3s ease-out}.markdown-body h3{font-size:24px;padding-left:8px;margin-top:32px;border-bottom:2px solid #c6c4c4;line-height:1.7}.markdown-body h4{font-size:20px;padding-left:8px;margin-top:32px;border-bottom:1px solid #ddd}.markdown-body h5{font-size:16px;margin-top:24px}.markdown-body h6{margin-top:16px;line-height:1.1}.markdown-body p{font-size:16px;text-align:start;white-space:normal;text-size-adjust:auto;line-height:2;margin-top:16px;margin-bottom:16px}.markdown-body img{max-width:100%;margin:auto;padding-left:8px;padding-right:8px}.markdown-body hr{border:none;border-top:4px double #212122;margin-top:32px;margin-bottom:32px;text-align:center}.markdown-body hr:after{content:"♥";display:inline-block;position:relative;top:-15px;padding:0 10px;color:#212122;font-size:18px}.markdown-body code{word-break:break-word;overflow-x:auto;background-color:#f1f1f1;color:#ef7060;font-size:14px;padding:.065em 6px}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace;border-radius:2px}.markdown-body pre{overflow:auto;position:relative;line-height:1.7;box-shadow:0 0 8px hsla(0,0%,43.1%,.45);margin:32px 16px}.markdown-body pre:before{content:"";display:block;height:30px;width:100%;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAdCAYAAABcz8ldAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAhgSURBVGhD7Zp7bBTHHcdn33t7vvOdzy+ITVKDU0xIKG2ABCPTRCCaUiEVKWoqRJuASAhCitRCVKSoalFUKZBiSmmFRRJKRUnUtIpo+aNqGgwoOCmuFUIRzxjwE4zte+97drYzztji8HPvtkit/PnH+n1397Tz+83vN/PbMZhmmmmm+d+BoX8n5diihcGqgFQf5vk6BMAskWUlw3GyFnIvtqWSf91w7mKC3npfOLX7wYeiIa6BBWCOLLFRF2NB0JvIOP/80YG+k2ev6S699b/OzOfKBW5l5KsgyC4DCFQDnpEAdE1goc/dlNPc/Up7P711UiYNSMuyxeUzZPnHgGHWh5XADEkSAcdiN+AnEXIBhBComgFU0/xQR+jnj51sOUMf9Z0NKyL8S9+JPBEN8zuCMrsqGOA5QWAAyzLAxe53HBeYFgJp1c5Cx33nyIfpV3e+22/Sx32nev/sMCgVnmM4bjOniAtZWQAsz315EfsGQQc4hgWcjHkCmOj1rheuNn95cXwmDMiVp5etC/D8m5FwUWVQUYYGPh6mZYFUOgsGVa1pXvOZzVT2jRuH54RM230jEuI3RcIiL4l4UkxAJmuD/riVsqD7ct2m9nep7BtVTbVfZ0uE/UIk+CQflAHDjf8+Lg6MldYATGpH3c/Ul7p3dWXppVGM6eElJSHmnQWPbSlRlN1lJcUBjqNRnwJZVQO3B5P/uq5rK1d90pakckFcaKp5UJHY92JR8YlwkUDVySEZfGfQdO7E7Z8s2HL9TSoXTPXRud9nA8IBqSwcZgWeqpPj6BYw7yTbXBN9q2v9lQEq5zBmWA8vWLCptCi4tzwW8RQMQlFQATPLSh6vCSh/plJBkMyQBHZfWYnkKRgEktEVpTJXERN2Xzo4ex2VC6K6qXYpF5b3ypVRT8EgcAERSJXRbwCBOTFzXblM5RxGBaRt+ZPYA+LO0mgxz5K1Ig+UgAzKIuGnz39z6S+olDeaibaXRsU1RUFvgx+GwTWgPCaDgMw2XXpr9gwq50XV0bkxJiYeEiNF5cwE5XsiOEkAUkXkUW51SSOVchjl8WKef604XFSRbzCGCYeCoESStv/p8QU1VPIM3knNDynctnBRfsEYhgSlNCIGgQv2UCkvGIHZgteMh1nBW9W4F16RAM6yDVV7amZTaYQcr59cuuhhWRTWBvAMLxQGeyFSHOLnh0MvUskz5RF+fbRYDEy0mZgqQYUHOLhr//b6rGoqeaLqQG0pw3PrBbyA+4EQUkRmhvgqNUfICUipKK4OKUqIJVPKB0jpEhjmWWp64jdbKmVZZNYogcJm493gsifOqhDyeh9GYR/FM7sW+DA5CKR0MSK3tvKZkpwB5gRE4tjFEr7RL0iWBGV51vHFCyupNGWWPqLgnoer9mtyEGSJAzwLllDTGzyznDjRN/CwOFkoFb4bm0eVIXICgpvdGoEvrF7fC89zfLkkeV5HbOhWiTwTpKYvCAJLGshRdXtKMKAWlyxq+MPQLk1h66g5RE5ABJYNFrqY3wvJklJRUKg5ZWLFXIA86yek2uDOPkBNb3CM5Pf7DL2QyIrUGiLH+xC5Bmmm/ARnHUhC6PnzxWDK0RH5HuIjZGy27erU9AZ0dTIWXyG+NpBBrSFySxZw220IqeUPFoS6jVAPNadM7yDsgNB1qOkLuAziMYIb1PQGA75wIaKGPyAb+9oF16g5RE5ALIQ+tSyLWoWDEAK6aXW3JlK9VJoyx1oyvVkNdvo5KXXDAVkdnaKmNwx0xjH98w3JNmTCm+Bc9hKVhsgJSI9pvp9Vdd++jmq6AXB2/HHrhcs5aTkVDv0DFzoHvKdq/mQsKX/4t7KJLDpOJW+IbAvMGoMkxfwAWZB8DT7W1diTE+WcgKz6pK1bs6z3daPwmJDsSKt6ZsCyjlLJMz0DsDGZ8SdlDROBjOb8YeWOjptU8kTXusuaazu7oJrfEnQvdkpVcUn6PTVHyAkIIW7br/Unklni0EJIZ1WgGsauZR+fvUglz6zY0dGfVp09ybRNlfwgi3k8YSbvJJ29VMoLt9v6rZVQL7hOYUubndHJGclBtzn1byqNMCogi09/2nFb01/oj+f/5TyjauBOKtPcZ1r7qZQ3f2lRfxZPWi2anp8TSDAGExZMa2jr8u03L1M5L7q3Xc+iAeuHRl/ScvPcjSLDBnZS/cjtNHd2v3171Ewbs9N5q7Pn4otVMx3btBsCsoRbk1FxG5dMVgMDqfTpXl1/tuFMa5zKefPROdX59qLQBwLnNog8Wy1OcjB1N+QEsW/QsFNZuO35Xb1v98QLX4/Sx+O3wqujrQ6013ABUWI8+AaqBjAH01+ghL22+5X2PirnMG7r+esbnae/V1neauvGSoHjigTcVU7UGFm2DeK4ttxKpQ+mLPvl+o/PjnkAkw9HTqSMmVHhyAMx9iFcSh/BHTfLceO/C8mKjApBf9zszGhoY92m9sN+BGOY9AeD7eGniv8OTaOB4dgyTsQd9wS+IQu4lciYdkI7CLrNH3Rvbb9FL41i0tbzVP2iWJkobpN5fmM4IJfJskTP1Bk8A9HQmbpmGDBrWqdVCN/Yd7PjxKGOXn+bmbto3feVVcVB9qehIL8EJy8nChwgr0O2xxBnhGU5eP2CfYbl/m4gBRsbtneMORP9oGpjpcCsiKzHHfdOPiQ/wMniyFEu2dbiTQCAeN/vavC466BGYLttXc9fmXBXMGlAhiHHur+sq6uPiUI9z7CVHMPwBnLSuuN8FuC48/Oaz1ylt94XfrW5ouyprwWfYRkwNyCyYYjwkBHows1fa+tV/fzGxlv39b9gqvfPmQ+i/HK8KlcBjhHwfl8HEHyOd1JnuzZd66S3TTPNNNP8/wDAfwDG7G0m9LKBpwAAAABJRU5ErkJggg==) 10px 10px no-repeat;background-color:#212122;box-shadow:0 0 8px hsla(0,0%,43.1%,.45);background-size:40px}.markdown-body pre&gt;code{font-size:14px;padding:16px 8px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#fff;background:#272822}.markdown-body pre&gt;code::-webkit-scrollbar{height:10px;background-color:#f5f5f5}.markdown-body pre&gt;code::-webkit-scrollbar-track{box-shadow:inset 0 0 6px rgba(0,0,0,.3);border-radius:3px;background-color:#f5f5f5}.markdown-body pre&gt;code::-webkit-scrollbar-thumb{border-radius:3px;box-shadow:inset 0 0 6px rgba(0,0,0,.3);background-color:#555}.markdown-body a{color:#ef7060;padding:2px;text-decoration:none;border-bottom:.125em solid #ef7060;border-radius:2px;box-shadow:inset 0 -.025em 0 #ef7060;transition:box-shadow .27s cubic-bezier(.77,0,.175,1),color .27s cubic-bezier(.77,0,.175,1)}.markdown-body a:focus,.markdown-body a:hover{outline:none;box-shadow:inset 0 -1.5em 0 #ef7060;color:#fff}.markdown-body a:before{content:"⇲ ";vertical-align:top;margin-left:2px;font-family:dart!important;font-size:12px;color:inherit;opacity:.7}.markdown-body table{background:#fbfbfb;border-radius:4px;border-collapse:collapse;margin:auto;padding:5px;width:95%;box-shadow:0 5px 10px rgba(0,0,0,.1);animation:float 5s infinite}.markdown-body table th{color:#fff;background:#212122;border-bottom:1px solid #9ea7af;border-right:1px solid #343a45;font-size:18px;padding:16px;text-align:left;vertical-align:middle}.markdown-body table th:first-child{border-top-left-radius:4px}.markdown-body table th:last-child{border-top-right-radius:4px;border-right:none}.markdown-body table tr{border-top:1px solid #c1c3d1;border-bottom:1px solid #c1c3d1;color:#666b85}.markdown-body table tr:hover td{background:#212122;color:#fff;border-top:1px solid #22262e}.markdown-body table tr:first-child{border-top:none}.markdown-body table tr:last-child{border-bottom:none}.markdown-body table tr:nth-child(odd) td{background:#f1f1f1}.markdown-body table tr:nth-child(odd):hover td{background:#212122}.markdown-body table tr:last-child td:first-child{border-bottom-left-radius:4px}.markdown-body table tr:last-child td:last-child{border-bottom-right-radius:4px}.markdown-body table td{background:#fbfbfb;padding:16px;text-align:left;vertical-align:middle;font-size:16px;border-right:1px solid #c1c3d1}.markdown-body table td:last-child{border-right:0}.markdown-body blockquote{color:#777;padding:1px 16px;margin:24px 0;border-left:4px solid #c6c4c4;background-color:#f1f1f1;transition:all .3s ease-out;border-radius:4px}.markdown-body blockquote:hover{border-left-color:#212122;background-color:#212122;color:#fff}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:24px}.markdown-body ol li,.markdown-body ul li{margin-bottom:6px;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body span.math{margin-left:32px;font-size:18px;font-weight:700}@media (max-width:720px){.markdown-body h1{font-size:30.4px}.markdown-body h2{font-size:24px}.markdown-body h3{font-size:19.2px}.markdown-body h4{font-size:16px}.markdown-body h5{font-size:12.8px}}</style><style data-highlight="" data-highlight-key="monokai">.markdown-body pre,.markdown-body pre&gt;code.hljs{background:#272822;color:#ddd}.hljs-keyword,.hljs-literal,.hljs-name,.hljs-selector-tag,.hljs-strong,.hljs-tag{color:#f92672}.hljs-code{color:#66d9ef}.hljs-class .hljs-title{color:#fff}.hljs-attribute,.hljs-link,.hljs-regexp,.hljs-symbol{color:#bf79db}.hljs-addition,.hljs-built_in,.hljs-builtin-name,.hljs-bullet,.hljs-emphasis,.hljs-section,.hljs-selector-attr,.hljs-selector-pseudo,.hljs-string,.hljs-subst,.hljs-template-tag,.hljs-template-variable,.hljs-title,.hljs-type,.hljs-variable{color:#a6e22e}.hljs-comment,.hljs-deletion,.hljs-meta,.hljs-quote{color:#75715e}.hljs-doctag,.hljs-keyword,.hljs-literal,.hljs-section,.hljs-selector-id,.hljs-selector-tag,.hljs-title,.hljs-type{font-weight:700}</style><h2 data-id="heading-0">引言</h2>
<p>在Web开发中，我们经常需要知道某个元素是否进入了可视区域。传统的方式是通过监听scroll事件，但这种实现方式性能较差，容易造成页面卡顿。今天我们来学习一个现代化的解决方案——<strong>IntersectionObserver API</strong>。</p>
<h2 data-id="heading-1">什么是IntersectionObserver？</h2>
<p>IntersectionObserver（交叉观察者）是一个浏览器原生API，它可以<strong>异步观察</strong>目标元素与其祖先元素或视窗（viewport）的交叉状态。简单来说，就是当被观察的元素进入或离开可视区域时，它会自动通知我们。</p>
<h3 data-id="heading-2">为什么需要它？</h3>
<p>想象一下，你要判断一个元素是否在屏幕内：</p>
<p><strong>传统方式</strong>：监听scroll事件，频繁计算元素位置，性能开销大</p>
<p><strong>IntersectionObserver</strong>：浏览器原生支持，异步处理，性能高效</p>
<h2 data-id="heading-3">基本用法</h2>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 创建观察者实例</span>
<span class="hljs-keyword">const</span> observer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntersectionObserver</span>(
  <span class="hljs-function">(<span class="hljs-params">entries</span>) =&gt;</span> {
    entries.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">entry</span>) =&gt;</span> {
      <span class="hljs-keyword">if</span> (entry.<span class="hljs-property">isIntersecting</span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"元素可见了"</span>);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"元素不可见了"</span>);
      }
    });
  },
  {
    <span class="hljs-attr">root</span>: <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">".container"</span>), <span class="hljs-comment">// 根元素，null表示视窗</span>
    <span class="hljs-attr">threshold</span>: <span class="hljs-number">0.5</span>, <span class="hljs-comment">// 阈值，触发回调的相交比例（0-1），可为数字或者数组[0, 0.25, 0.5, 0.75, 1]，在0%，25%，50%...的时候都触发</span>
    <span class="hljs-attr">rootMargin</span>: <span class="hljs-string">"0px"</span>, <span class="hljs-comment">// 根元素的外边距</span>
  }
);

<span class="hljs-comment">// 开始观察目标元素</span>
<span class="hljs-keyword">const</span> target = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">".target-element"</span>);
observer.<span class="hljs-title function_">observe</span>(target);

<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">".item"</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> {
  observer.<span class="hljs-title function_">observe</span>(item);
});
</code></pre>
<h2 data-id="heading-4">使用案例</h2>
<pre><code class="hljs language-html" lang="html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>IntersectionObserver<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
    * {
      <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;
      <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;
      <span class="hljs-attribute">box-sizing</span>: border-box;
    }
    <span class="hljs-selector-class">.container</span> {
      <span class="hljs-attribute">width</span>: <span class="hljs-number">800px</span>;
      <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;
      <span class="hljs-attribute">height</span>: <span class="hljs-number">800px</span>;
      <span class="hljs-attribute">overflow-y</span>: auto;
      <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ccc</span>;
      <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">200px</span>;
    }
    <span class="hljs-selector-class">.item</span> {
      <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;
      <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">10px</span>;
      <span class="hljs-attribute">line-height</span>: <span class="hljs-number">200px</span>;
      <span class="hljs-attribute">text-align</span>: center;
      <span class="hljs-attribute">background-color</span>: beige;
    }
    <span class="hljs-selector-class">.item</span><span class="hljs-selector-pseudo">:last-child</span> {
      <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">0</span>;
    }
    <span class="hljs-selector-class">.item</span><span class="hljs-selector-class">.visible</span> {
      <span class="hljs-attribute">background-color</span>: aqua;
    }
  </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span>&gt;</span>元素1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span>&gt;</span>元素2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span>&gt;</span>元素3<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span>&gt;</span>元素4<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span>&gt;</span>元素5<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span>&gt;</span>元素6<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    <span class="hljs-keyword">const</span> observer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntersectionObserver</span>(
      <span class="hljs-function">(<span class="hljs-params">entries</span>) =&gt;</span> {
        entries.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">entry</span>) =&gt;</span> {
          <span class="hljs-keyword">if</span> (entry.<span class="hljs-property">isIntersecting</span>) {
            entry.<span class="hljs-property">target</span>.<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">"visible"</span>);
          } <span class="hljs-keyword">else</span> {
            entry.<span class="hljs-property">target</span>.<span class="hljs-property">classList</span>.<span class="hljs-title function_">remove</span>(<span class="hljs-string">"visible"</span>);
          }
        });
      },
      {
        <span class="hljs-attr">root</span>: <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">".container"</span>),
        <span class="hljs-attr">threshold</span>: <span class="hljs-number">0.5</span>,
      }
    );
    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">".item"</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> {
      observer.<span class="hljs-title function_">observe</span>(item);
    });
  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/18635e6788b9458ca06e31e16e63d81e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRHJpZnRfRHJlYW0=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765189697&amp;x-signature=lsYuaaIlWNrKETw%2FpdA%2FHd1DQBQ%3D" alt="image.png" loading="lazy"/></p>
<h2 data-id="heading-5">Vue 3 实战应用</h2>
<h3 data-id="heading-6">精简版滚动动画（类AOS）</h3>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"aos-container"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>
      <span class="hljs-attr">v-for</span>=<span class="hljs-string">"(feature, index) in features"</span>
      <span class="hljs-attr">:key</span>=<span class="hljs-string">"feature.id"</span>
      <span class="hljs-attr">ref</span>=<span class="hljs-string">"featureRefs"</span>
      <span class="hljs-attr">class</span>=<span class="hljs-string">"feature-card"</span>
      <span class="hljs-attr">:class</span>=<span class="hljs-string">"{ animate: isFeatureVisible[index] }"</span>
    &gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>{{ feature.title }}<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{{ feature.description }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"ts"</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">import</span> { ref, onMounted, nextTick, useTemplateRef } <span class="hljs-keyword">from</span> <span class="hljs-string">"vue"</span>;

<span class="hljs-keyword">const</span> features = <span class="hljs-title function_">ref</span>([
  { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">"特性一"</span>, <span class="hljs-attr">description</span>: <span class="hljs-string">"这是第一个特性的描述"</span> },
  { <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">"特性二"</span>, <span class="hljs-attr">description</span>: <span class="hljs-string">"这是第二个特性的描述"</span> },
  { <span class="hljs-attr">id</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">"特性三"</span>, <span class="hljs-attr">description</span>: <span class="hljs-string">"这是第三个特性的描述"</span> },
  { <span class="hljs-attr">id</span>: <span class="hljs-number">4</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">"特性四"</span>, <span class="hljs-attr">description</span>: <span class="hljs-string">"这是第四个特性的描述"</span> },
  { <span class="hljs-attr">id</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">"特性五"</span>, <span class="hljs-attr">description</span>: <span class="hljs-string">"这是第五个特性的描述"</span> },
  { <span class="hljs-attr">id</span>: <span class="hljs-number">6</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">"特性六"</span>, <span class="hljs-attr">description</span>: <span class="hljs-string">"这是第六个特性的描述"</span> },
  { <span class="hljs-attr">id</span>: <span class="hljs-number">7</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">"特性七"</span>, <span class="hljs-attr">description</span>: <span class="hljs-string">"这是第七个特性的描述"</span> },
  { <span class="hljs-attr">id</span>: <span class="hljs-number">8</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">"特性八"</span>, <span class="hljs-attr">description</span>: <span class="hljs-string">"这是第八个特性的描述"</span> },
  { <span class="hljs-attr">id</span>: <span class="hljs-number">9</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">"特性九"</span>, <span class="hljs-attr">description</span>: <span class="hljs-string">"这是第九个特性的描述"</span> },
  { <span class="hljs-attr">id</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">"特性十"</span>, <span class="hljs-attr">description</span>: <span class="hljs-string">"这是第十个特性的描述"</span> },
  { <span class="hljs-attr">id</span>: <span class="hljs-number">11</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">"特性十一"</span>, <span class="hljs-attr">description</span>: <span class="hljs-string">"这是第十一个特性的描述"</span> },
  { <span class="hljs-attr">id</span>: <span class="hljs-number">12</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">"特性十二"</span>, <span class="hljs-attr">description</span>: <span class="hljs-string">"这是第十二个特性的描述"</span> },
]);

<span class="hljs-keyword">const</span> isFeatureVisible = <span class="hljs-title function_">ref</span>(<span class="hljs-title class_">Array</span>(features.<span class="hljs-property">value</span>.<span class="hljs-property">length</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-literal">false</span>));

<span class="hljs-keyword">const</span> featureRefs = <span class="hljs-title function_">useTemplateRef</span>(<span class="hljs-string">"featureRefs"</span>);

<span class="hljs-title function_">onMounted</span>(<span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">await</span> <span class="hljs-title function_">nextTick</span>();
  featureRefs.<span class="hljs-property">value</span>?.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">ref, index</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> featureObserver = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntersectionObserver</span>(<span class="hljs-function">(<span class="hljs-params">entries</span>) =&gt;</span> {
      <span class="hljs-keyword">if</span> (entries[<span class="hljs-number">0</span>]) isFeatureVisible.<span class="hljs-property">value</span>[index] = entries[<span class="hljs-number">0</span>].<span class="hljs-property">isIntersecting</span>;
    });
    featureObserver.<span class="hljs-title function_">observe</span>(ref);
  });
});
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="css">
<span class="hljs-selector-class">.aos-container</span> {
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;
  <span class="hljs-attribute">height</span>: <span class="hljs-number">800px</span>;
  <span class="hljs-attribute">width</span>: <span class="hljs-number">1080px</span>;
  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;
  <span class="hljs-attribute">overflow-y</span>: auto;
  <span class="hljs-attribute">overflow-x</span>: hidden;
}

<span class="hljs-selector-class">.feature-card</span> {
  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(-<span class="hljs-number">50px</span>);
  <span class="hljs-attribute">transition</span>: all <span class="hljs-number">0.6s</span> ease;
  <span class="hljs-attribute">margin</span>: <span class="hljs-number">20px</span> <span class="hljs-number">0</span>;
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;
  <span class="hljs-attribute">background</span>: <span class="hljs-number">#f5f5f5</span>;
  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">8px</span>;
}

<span class="hljs-selector-class">.feature-card</span><span class="hljs-selector-class">.animate</span> {
  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;
  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">0</span>);
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b3ee93290c324911b7eba410891bf08d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRHJpZnRfRHJlYW0=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765189697&amp;x-signature=c6XSNjjtco%2FMYQfWYnyTB2KpWdI%3D" alt="image.png" loading="lazy"/></p>
<p>多说一句，如果不循环<strong>featureRefs.value</strong>,只使用一个<strong>Observer</strong>，还可以这么写。</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">const</span> isFeatureVisible = <span class="hljs-title function_">ref</span>(<span class="hljs-title class_">Array</span>(features.<span class="hljs-property">value</span>.<span class="hljs-property">length</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-literal">false</span>));

<span class="hljs-keyword">const</span> featureRefs = <span class="hljs-title function_">useTemplateRef</span>(<span class="hljs-string">"featureRefs"</span>);

<span class="hljs-keyword">let</span> <span class="hljs-attr">observer</span>: <span class="hljs-literal">null</span> | <span class="hljs-title class_">IntersectionObserver</span> = <span class="hljs-literal">null</span>;

<span class="hljs-title function_">onMounted</span>(<span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">await</span> <span class="hljs-title function_">nextTick</span>();
  observer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntersectionObserver</span>(<span class="hljs-function">(<span class="hljs-params">entries</span>) =&gt;</span> {
    entries.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">entry</span>) =&gt;</span> {
      <span class="hljs-comment">// 找到目标元素在 featureRefs 中的索引</span>
      <span class="hljs-keyword">const</span> index = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(featureRefs.<span class="hljs-property">value</span>!).<span class="hljs-title function_">indexOf</span>(
        entry.<span class="hljs-property">target</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">HTMLDivElement</span>
      );
      isFeatureVisible.<span class="hljs-property">value</span>[index] = entry.<span class="hljs-property">isIntersecting</span>;
    });
  });

  featureRefs.<span class="hljs-property">value</span>?.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">ref</span>) =&gt;</span> {
    observer?.<span class="hljs-title function_">observe</span>(ref);
  });
});
</code></pre>
<h3 data-id="heading-7">图片懒加载组件</h3>
<h4 data-id="heading-8">组件代码</h4>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"lazy-image"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"!isLoaded"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"loading"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>图片加载中...<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">img</span>
      <span class="hljs-attr">:src</span>=<span class="hljs-string">"isVisible ? src : placeholder"</span>
      <span class="hljs-attr">:alt</span>=<span class="hljs-string">"alt"</span>
      <span class="hljs-attr">:class</span>=<span class="hljs-string">"{ loaded: isVisible }"</span>
      @<span class="hljs-attr">load</span>=<span class="hljs-string">"onLoad"</span>
      <span class="hljs-attr">ref</span>=<span class="hljs-string">"imgElement"</span>
    /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"ts"</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">import</span> { ref, onMounted, onUnmounted } <span class="hljs-keyword">from</span> <span class="hljs-string">"vue"</span>;

<span class="hljs-keyword">const</span> props = <span class="hljs-title function_">defineProps</span>({
  <span class="hljs-attr">src</span>: <span class="hljs-title class_">String</span>,
  <span class="hljs-attr">alt</span>: <span class="hljs-title class_">String</span>,
  <span class="hljs-attr">placeholder</span>: {
    <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,
    <span class="hljs-attr">default</span>: <span class="hljs-string">""</span>,
  },
});

<span class="hljs-keyword">const</span> imgElement = ref&lt;<span class="hljs-title class_">HTMLImageElement</span>&gt;();
<span class="hljs-keyword">const</span> isVisible = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">false</span>);
<span class="hljs-keyword">const</span> isLoaded = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">false</span>);

<span class="hljs-keyword">let</span> <span class="hljs-attr">observer</span>: <span class="hljs-title class_">IntersectionObserver</span> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;

<span class="hljs-title function_">onMounted</span>(<span class="hljs-function">() =&gt;</span> {
  observer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntersectionObserver</span>(
    <span class="hljs-function">(<span class="hljs-params">entries</span>) =&gt;</span> {
      <span class="hljs-keyword">if</span> (entries[<span class="hljs-number">0</span>] &amp;&amp; entries[<span class="hljs-number">0</span>].<span class="hljs-property">isIntersecting</span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"图片进入视口"</span>);
        isVisible.<span class="hljs-property">value</span> = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">if</span> (imgElement.<span class="hljs-property">value</span>) {
          observer?.<span class="hljs-title function_">unobserve</span>(imgElement.<span class="hljs-property">value</span>);
        }
      }
    },
    { <span class="hljs-attr">threshold</span>: <span class="hljs-number">0.1</span> }
  );

  <span class="hljs-keyword">if</span> (imgElement.<span class="hljs-property">value</span>) {
    observer.<span class="hljs-title function_">observe</span>(imgElement.<span class="hljs-property">value</span>);
  }
});

<span class="hljs-title function_">onUnmounted</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">if</span> (observer) {
    observer.<span class="hljs-title function_">disconnect</span>();
  }
});

<span class="hljs-keyword">const</span> <span class="hljs-title function_">onLoad</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"图片加载完成"</span>);
  isLoaded.<span class="hljs-property">value</span> = <span class="hljs-literal">true</span>;
};
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"scss"</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="css">
<span class="hljs-selector-class">.lazy-image</span> {
  <span class="hljs-attribute">position</span>: relative;
  <span class="hljs-attribute">display</span>: inline-block;
  <span class="hljs-selector-tag">img</span> {
    <span class="hljs-attribute">transition</span>: opacity <span class="hljs-number">0.3s</span> ease;
    <span class="hljs-attribute">max-width</span>: <span class="hljs-number">100%</span>;
    <span class="hljs-attribute">height</span>: auto;
  }

  <span class="hljs-selector-tag">img</span><span class="hljs-selector-pseudo">:not</span>(<span class="hljs-selector-class">.loaded</span>) {
    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0.5</span>;
  }

  <span class="hljs-selector-tag">img</span><span class="hljs-selector-class">.loaded</span> {
    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;
  }

  <span class="hljs-selector-class">.loading</span> {
    <span class="hljs-attribute">position</span>: absolute;
    <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;
    <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;
    <span class="hljs-attribute">text-align</span>: center;
    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#f5f5f5</span>;
    <span class="hljs-attribute">white-space</span>: nowrap;
  }
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>

</code></pre>
<h4 data-id="heading-9">使用组件</h4>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"lazy-image-container"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"height-1600px"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"lazy-image-item"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">LazyImg</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://picsum.photos/400/400"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">"随机图片"</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"ts"</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">import</span> <span class="hljs-title class_">LazyImg</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"./LazyImg.vue"</span>;
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"scss"</span>&gt;</span><span class="css">
<span class="hljs-selector-class">.lazy-image-container</span> {
  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;
  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;
  <span class="hljs-attribute">overflow-y</span>: auto;
  <span class="hljs-selector-class">.height-1600px</span> {
    <span class="hljs-attribute">height</span>: <span class="hljs-number">1600px</span>;
  }
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>

</code></pre>
<h3 data-id="heading-10">无限滚动示例</h3>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"scrollContainer"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"infinite-scroll"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"items-list"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"item in visibleItems"</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">"item.id"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"list-item"</span>&gt;</span>
        {{ item.content }}
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- 哨兵元素，专门用于触发加载 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"sentinel"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"sentinel"</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"hasMore"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"isLoading"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"loading"</span>&gt;</span>加载中...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"!hasMore"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"no-more"</span>&gt;</span>没有更多内容了<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"ts"</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">import</span> { ref, onMounted, onUnmounted, nextTick } <span class="hljs-keyword">from</span> <span class="hljs-string">"vue"</span>;

interface <span class="hljs-title class_">Item</span> {
  <span class="hljs-attr">id</span>: number;
  <span class="hljs-attr">content</span>: string;
}

<span class="hljs-comment">// 模拟数据</span>
<span class="hljs-keyword">const</span> allItems = ref&lt;<span class="hljs-title class_">Item</span>[]&gt;(
  <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>({ <span class="hljs-attr">length</span>: <span class="hljs-number">100</span> }, <span class="hljs-function">(<span class="hljs-params">_, i</span>) =&gt;</span> ({
    <span class="hljs-attr">id</span>: i + <span class="hljs-number">1</span>,
    <span class="hljs-attr">content</span>: <span class="hljs-string">`列表项 <span class="hljs-subst">${i + <span class="hljs-number">1</span>}</span> - 这是一些示例内容，用于展示无限滚动功能`</span>,
  }))
);

<span class="hljs-keyword">const</span> visibleItems = ref&lt;<span class="hljs-title class_">Item</span>[]&gt;([]);
<span class="hljs-keyword">const</span> isLoading = ref&lt;boolean&gt;(<span class="hljs-literal">false</span>);
<span class="hljs-keyword">const</span> hasMore = ref&lt;boolean&gt;(<span class="hljs-literal">true</span>);
<span class="hljs-keyword">const</span> <span class="hljs-attr">pageSize</span>: number = <span class="hljs-number">10</span>;
<span class="hljs-keyword">let</span> <span class="hljs-attr">currentPage</span>: number = <span class="hljs-number">0</span>;

<span class="hljs-comment">// 加载数据</span>
<span class="hljs-keyword">const</span> loadMore = (): <span class="hljs-function"><span class="hljs-params">void</span> =&gt;</span> {
  <span class="hljs-keyword">if</span> (isLoading.<span class="hljs-property">value</span> || !hasMore.<span class="hljs-property">value</span>) <span class="hljs-keyword">return</span>;

  isLoading.<span class="hljs-property">value</span> = <span class="hljs-literal">true</span>;

  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> start = currentPage * pageSize;
    <span class="hljs-keyword">const</span> end = start + pageSize;
    <span class="hljs-keyword">const</span> newItems = allItems.<span class="hljs-property">value</span>.<span class="hljs-title function_">slice</span>(start, end);

    <span class="hljs-keyword">if</span> (newItems.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {
      visibleItems.<span class="hljs-property">value</span>.<span class="hljs-title function_">push</span>(...newItems);
      currentPage++;
      hasMore.<span class="hljs-property">value</span> = end &lt; allItems.<span class="hljs-property">value</span>.<span class="hljs-property">length</span>;
    } <span class="hljs-keyword">else</span> {
      hasMore.<span class="hljs-property">value</span> = <span class="hljs-literal">false</span>;
    }

    isLoading.<span class="hljs-property">value</span> = <span class="hljs-literal">false</span>;
  }, <span class="hljs-number">500</span>);
};

<span class="hljs-comment">// 初始加载</span>
<span class="hljs-title function_">loadMore</span>();

<span class="hljs-comment">// 无限滚动逻辑</span>
<span class="hljs-keyword">const</span> scrollContainer = ref&lt;<span class="hljs-title class_">HTMLDivElement</span> | <span class="hljs-literal">null</span>&gt;(<span class="hljs-literal">null</span>);
<span class="hljs-keyword">const</span> sentinel = ref&lt;<span class="hljs-title class_">HTMLDivElement</span> | <span class="hljs-literal">null</span>&gt;(<span class="hljs-literal">null</span>); <span class="hljs-comment">// 哨兵元素</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">observer</span>: <span class="hljs-title class_">IntersectionObserver</span> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;

<span class="hljs-title function_">onMounted</span>(<span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">await</span> <span class="hljs-title function_">nextTick</span>();

  observer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntersectionObserver</span>(
    <span class="hljs-function">(<span class="hljs-params">entries: IntersectionObserverEntry[]</span>) =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(entries);
      <span class="hljs-comment">// 只有当哨兵元素进入视口且不在加载状态时才触发</span>
      <span class="hljs-keyword">if</span> (
        entries[<span class="hljs-number">0</span>] &amp;&amp;
        entries[<span class="hljs-number">0</span>].<span class="hljs-property">isIntersecting</span> &amp;&amp;
        !isLoading.<span class="hljs-property">value</span> &amp;&amp;
        hasMore.<span class="hljs-property">value</span>
      ) {
        <span class="hljs-title function_">loadMore</span>();
      }
    },
    {
      <span class="hljs-attr">threshold</span>: <span class="hljs-number">0.1</span>,
      <span class="hljs-attr">root</span>: scrollContainer.<span class="hljs-property">value</span>,
    }
  );

  <span class="hljs-keyword">if</span> (sentinel.<span class="hljs-property">value</span>) {
    observer.<span class="hljs-title function_">observe</span>(sentinel.<span class="hljs-property">value</span>);
  }
});

<span class="hljs-title function_">onUnmounted</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">if</span> (observer) {
    observer.<span class="hljs-title function_">disconnect</span>();
  }
});
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="css">
<span class="hljs-selector-class">.sentinel</span> {
  <span class="hljs-attribute">height</span>: <span class="hljs-number">1px</span>; <span class="hljs-comment">/* 极小的高度，不影响布局 */</span>
}
<span class="hljs-selector-class">.infinite-scroll</span> {
  <span class="hljs-attribute">height</span>: <span class="hljs-number">400px</span>;
  <span class="hljs-attribute">overflow</span>: auto;
  <span class="hljs-attribute">max-width</span>: <span class="hljs-number">600px</span>;
  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;
}

<span class="hljs-selector-class">.items-list</span> {
  <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">20px</span>;
}

<span class="hljs-selector-class">.list-item</span> {
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">15px</span>;
  <span class="hljs-attribute">margin</span>: <span class="hljs-number">10px</span> <span class="hljs-number">0</span>;
  <span class="hljs-attribute">background</span>: <span class="hljs-number">#f5f5f5</span>;
  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">4px</span>;
}

<span class="hljs-selector-class">.load-trigger</span>,
<span class="hljs-selector-class">.loading</span>,
<span class="hljs-selector-class">.no-more</span> {
  <span class="hljs-attribute">text-align</span>: center;
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;
  <span class="hljs-attribute">color</span>: <span class="hljs-number">#666</span>;
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>

</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f221b744e1a34c599e48b9957d6a4f69~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRHJpZnRfRHJlYW0=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765189697&amp;x-signature=kYL3yZeXE%2F%2Fa5GhpqKDwlBj7Zn8%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-11">广告曝光</h3>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ad-container"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"ad in ads"</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">"ad.id"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"adRefs"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ad-banner"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>{{ ad.title }}<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{{ ad.description }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">small</span>&gt;</span>曝光次数: {{ ad.impressions }}<span class="hljs-tag">&lt;/<span class="hljs-name">small</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"stats"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>广告统计<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>总曝光次数: {{ totalImpressions }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">import</span> { ref, computed, onMounted, nextTick, useTemplateRef } <span class="hljs-keyword">from</span> <span class="hljs-string">"vue"</span>;

<span class="hljs-keyword">const</span> ads = <span class="hljs-title function_">ref</span>([
  { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">"广告一"</span>, <span class="hljs-attr">description</span>: <span class="hljs-string">"这是第一个广告"</span>, <span class="hljs-attr">impressions</span>: <span class="hljs-number">0</span> },
  { <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">"广告二"</span>, <span class="hljs-attr">description</span>: <span class="hljs-string">"这是第二个广告"</span>, <span class="hljs-attr">impressions</span>: <span class="hljs-number">0</span> },
  { <span class="hljs-attr">id</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">"广告三"</span>, <span class="hljs-attr">description</span>: <span class="hljs-string">"这是第三个广告"</span>, <span class="hljs-attr">impressions</span>: <span class="hljs-number">0</span> },
  { <span class="hljs-attr">id</span>: <span class="hljs-number">4</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">"广告四"</span>, <span class="hljs-attr">description</span>: <span class="hljs-string">"这是第四个广告"</span>, <span class="hljs-attr">impressions</span>: <span class="hljs-number">0</span> },
  { <span class="hljs-attr">id</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">"广告五"</span>, <span class="hljs-attr">description</span>: <span class="hljs-string">"这是第五个广告"</span>, <span class="hljs-attr">impressions</span>: <span class="hljs-number">0</span> },
]);

<span class="hljs-keyword">const</span> adRefs = <span class="hljs-title function_">useTemplateRef</span>(<span class="hljs-string">"adRefs"</span>);
<span class="hljs-keyword">const</span> observers = <span class="hljs-title function_">ref</span>([]);

<span class="hljs-keyword">const</span> totalImpressions = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">return</span> ads.<span class="hljs-property">value</span>.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">sum, ad</span>) =&gt;</span> sum + ad.<span class="hljs-property">impressions</span>, <span class="hljs-number">0</span>);
});

<span class="hljs-title function_">onMounted</span>(<span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">await</span> <span class="hljs-title function_">nextTick</span>();

  adRefs.<span class="hljs-property">value</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">el, index</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> observer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntersectionObserver</span>(
      <span class="hljs-function">(<span class="hljs-params">entries</span>) =&gt;</span> {
        <span class="hljs-keyword">if</span> (entries[<span class="hljs-number">0</span>].<span class="hljs-property">isIntersecting</span>) {
          <span class="hljs-comment">// 广告进入视口，记录曝光</span>
          ads.<span class="hljs-property">value</span>[index].<span class="hljs-property">impressions</span>++;

          <span class="hljs-comment">// 实际项目中这里可以发送统计请求</span>
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`广告 <span class="hljs-subst">${ads.value[index].title}</span> 曝光一次`</span>);
        }
      },
      { <span class="hljs-attr">threshold</span>: <span class="hljs-number">0.5</span> }
    );

    observer.<span class="hljs-title function_">observe</span>(el);
    observers.<span class="hljs-property">value</span>.<span class="hljs-title function_">push</span>(observer);
  });
});
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="css">
<span class="hljs-selector-class">.ad-container</span> {
  <span class="hljs-attribute">max-width</span>: <span class="hljs-number">800px</span>;
  <span class="hljs-attribute">height</span>: <span class="hljs-number">500px</span>;
  <span class="hljs-attribute">overflow-y</span>: auto;
  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;
}

<span class="hljs-selector-class">.ad-banner</span> {
  <span class="hljs-attribute">height</span>: <span class="hljs-number">120px</span>;
  <span class="hljs-attribute">margin</span>: <span class="hljs-number">20px</span> <span class="hljs-number">0</span>;
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;
  <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">linear-gradient</span>(<span class="hljs-number">135deg</span>, <span class="hljs-number">#667eea</span> <span class="hljs-number">0%</span>, <span class="hljs-number">#764ba2</span> <span class="hljs-number">100%</span>);
  <span class="hljs-attribute">color</span>: white;
  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">8px</span>;
  <span class="hljs-attribute">display</span>: flex;
  <span class="hljs-attribute">flex-direction</span>: column;
  <span class="hljs-attribute">justify-content</span>: center;
}

<span class="hljs-selector-class">.stats</span> {
  <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">30px</span>;
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;
  <span class="hljs-attribute">background</span>: <span class="hljs-number">#f5f5f5</span>;
  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">8px</span>;
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>

</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5b32c1c00f6846dea2791587bc25002c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRHJpZnRfRHJlYW0=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765189697&amp;x-signature=MvXZNSnCPbkCCJqgCJRZYtIsbx8%3D" alt="image.png" loading="lazy"/></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[深度学习基础原理：从理论到PyTorch实践]]></title>    <link>https://juejin.cn/post/7578724773992792090</link>    <guid>https://juejin.cn/post/7578724773992792090</guid>    <pubDate>2025-12-01T10:34:15.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7578724773992792090" data-draft-id="7575083657994371099" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="深度学习基础原理：从理论到PyTorch实践"/> <meta itemprop="keywords" content="人工智能"/> <meta itemprop="datePublished" content="2025-12-01T10:34:15.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="前端开发工程师请求出战"/> <meta itemprop="url" content="https://juejin.cn/user/4222596374865550"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            深度学习基础原理：从理论到PyTorch实践
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4222596374865550/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    前端开发工程师请求出战
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-01T10:34:15.000Z" title="Mon Dec 01 2025 10:34:15 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-01
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读10分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0"><strong>一、深度学习全景图</strong></h2>
<h3 data-id="heading-1">1.1 人工智能的技术栈关系</h3>
<p><strong>人工智能 &gt; 机器学习 &gt; 深度学习 &gt; 大语言模型</strong></p>
<p>这个关系链可以这样理解：</p>
<ul>
<li><strong>人工智能</strong>：终极目标，让机器具备人类智能</li>
<li><strong>机器学习</strong>：实现AI的核心方法，让计算机从数据中学习</li>
<li><strong>深度学习</strong>：机器学习的最强分支，使用神经网络模拟人脑</li>
<li><strong>大语言模型</strong>：深度学习的成功应用，如ChatGPT</li>
</ul>
<blockquote>
<p>🎯 <strong>通俗理解</strong>：</p>
<ul>
<li>AI就像"学会开车"这个目标</li>
<li>机器学习是"通过练习掌握驾驶技术"</li>
<li>深度学习是"最先进的驾驶训练方法"</li>
<li>大语言模型是"用这种方法训练出的赛车手"</li>
</ul>
</blockquote>
<h3 data-id="heading-2">1.2 为什么需要深度学习？</h3>
<p><strong>传统编程的局限</strong>：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 传统方法：需要明确规则</span>
<span class="hljs-keyword">if</span> 图片中有胡须 <span class="hljs-keyword">and</span> 图片中有尖耳朵:
    <span class="hljs-keyword">return</span> <span class="hljs-string">"猫"</span>
<span class="hljs-keyword">else</span>:
    <span class="hljs-keyword">return</span> <span class="hljs-string">"不是猫"</span>
</code></pre>
<p><strong>深度学习的优势</strong>：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 深度学习方法：从数据中学习规则</span>
模型 = 训练(成千上万张猫的图片)
<span class="hljs-keyword">return</span> 模型.predict(新图片)
</code></pre>
<h2 data-id="heading-3"><strong>二、环境搭建与PyTorch入门</strong></h2>
<h3 data-id="heading-4">2.1 环境配置：深度学习的"厨房"</h3>
<p><strong>为什么需要虚拟环境？</strong>
就像不同的菜需要不同的厨房设备，不同的AI项目需要不同的软件版本。</p>
<p><strong>配置步骤</strong>：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 创建专用环境</span>
conda create --name deeplearning python=3.9

<span class="hljs-comment"># 激活环境</span>
conda activate deeplearning

<span class="hljs-comment"># 安装核心工具包</span>
pip install torch torchvision numpy matplotlib
</code></pre>
<h3 data-id="heading-5">2.2 PyTorch：深度学习的"万能工具箱"</h3>
<p><strong>PyTorch的优势</strong>：</p>
<ul>
<li><strong>易用性</strong>：代码像普通Python一样直观</li>
<li><strong>灵活性</strong>：支持动态计算图，调试方便</li>
<li><strong>生态完善</strong>：有大量预训练模型和工具</li>
</ul>
<h2 data-id="heading-6"><strong>三、深度学习的数学基石</strong></h2>
<h3 data-id="heading-7">3.1 从标量到张量：理解数据的维度</h3>
<p><strong>标量 - 单个数字</strong></p>
<pre><code class="hljs language-python" lang="python">temperature = <span class="hljs-number">25.5</span>    <span class="hljs-comment"># 温度，零维数据</span>
weight = <span class="hljs-number">70.2</span>         <span class="hljs-comment"># 体重，零维数据</span>
</code></pre>
<p><strong>向量 - 一维数组</strong></p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 特征向量：描述一个人的多个特征</span>
person_features = [<span class="hljs-number">25</span>, <span class="hljs-number">175</span>, <span class="hljs-number">70</span>]  <span class="hljs-comment"># [年龄, 身高, 体重]</span>
</code></pre>
<p><strong>矩阵 - 二维表格</strong></p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 多个人的特征表格</span>
<span class="hljs-comment">#       年龄  身高  体重</span>
people = [[<span class="hljs-number">25</span>, <span class="hljs-number">175</span>, <span class="hljs-number">70</span>],   <span class="hljs-comment"># 第一个人</span>
          [<span class="hljs-number">30</span>, <span class="hljs-number">180</span>, <span class="hljs-number">75</span>],   <span class="hljs-comment"># 第二个人  </span>
          [<span class="hljs-number">28</span>, <span class="hljs-number">168</span>, <span class="hljs-number">65</span>]]   <span class="hljs-comment"># 第三个人</span>
</code></pre>
<p><strong>张量 - 多维数据</strong></p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 彩色图片：高度 × 宽度 × 颜色通道</span>
image_tensor = torch.randn(<span class="hljs-number">224</span>, <span class="hljs-number">224</span>, <span class="hljs-number">3</span>)

<span class="hljs-comment"># 视频数据：时间帧 × 高度 × 宽度 × 通道</span>
video_tensor = torch.randn(<span class="hljs-number">100</span>, <span class="hljs-number">224</span>, <span class="hljs-number">224</span>, <span class="hljs-number">3</span>)
</code></pre>
<blockquote>
<p>🧩 <strong>维度理解技巧</strong>：
数一下有多少个方括号就是几维数据
<code>5</code> → 0维，<code>[1,2,3]</code> → 1维，<code>[[1,2],[3,4]]</code> → 2维</p>
</blockquote>
<h3 data-id="heading-8">3.2 PyTorch张量操作实战</h3>
<h4 data-id="heading-9">创建张量的三种方式</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> torch

<span class="hljs-comment"># 1. 从数据直接创建</span>
x = torch.tensor([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]])

<span class="hljs-comment"># 2. 随机生成（更接近真实场景）</span>
y = torch.randn(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)  <span class="hljs-comment"># 正态分布随机数</span>

<span class="hljs-comment"># 3. 特殊值填充</span>
z = torch.zeros(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>)  <span class="hljs-comment"># 全零矩阵</span>
ones = torch.ones(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>) <span class="hljs-comment"># 全1矩阵</span>
</code></pre>
<h4 data-id="heading-10">形状操作：数据的"变形术"</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 重塑形状：改变维度但不改变数据</span>
original = torch.tensor([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]])  <span class="hljs-comment"># 形状(2, 3)</span>
reshaped = original.view(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>)  <span class="hljs-comment"># 变成(3, 2): [[1,2],[3,4],[5,6]]</span>

<span class="hljs-comment"># 转置：行列互换</span>
transposed = original.T  <span class="hljs-comment"># 变成(3, 2): [[1,4],[2,5],[3,6]]</span>

<span class="hljs-comment"># 压缩维度：删除大小为1的维度</span>
squeezed = torch.randn(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>).squeeze()  <span class="hljs-comment"># (1,3,1) → (3,)</span>
</code></pre>
<h4 data-id="heading-11">数学运算：张量的"加减乘除"</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 逐元素运算（形状必须相同）</span>
a = torch.tensor([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])
b = torch.tensor([<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>])
add_result = a + b  <span class="hljs-comment"># [5, 7, 9]</span>
mul_result = a * b  <span class="hljs-comment"># [4, 10, 18]</span>

<span class="hljs-comment"># 矩阵乘法（核心操作！）</span>
matrix_a = torch.tensor([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]])
matrix_b = torch.tensor([[<span class="hljs-number">5</span>, <span class="hljs-number">6</span>], [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>]])
matmul = matrix_a @ matrix_b  <span class="hljs-comment"># @符号表示矩阵乘法</span>
<span class="hljs-comment"># 结果：[[19, 22], [43, 50]]</span>
</code></pre>
<h4 data-id="heading-12">广播机制：形状不同的张量也能运算</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 小张量会自动"扩展"来匹配大张量</span>
vector = torch.tensor([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])        <span class="hljs-comment"># 形状(3,)</span>
matrix = torch.tensor([[<span class="hljs-number">10</span>], [<span class="hljs-number">20</span>]])     <span class="hljs-comment"># 形状(2, 1)</span>

<span class="hljs-comment"># 广播后：</span>
<span class="hljs-comment"># vector变成: [[1,2,3], [1,2,3]]</span>
<span class="hljs-comment"># matrix变成: [[10,10,10], [20,20,20]]</span>
result = vector + matrix  <span class="hljs-comment"># [[11,12,13], [21,22,23]]</span>
</code></pre>
<h2 data-id="heading-13"><strong>四、数据预处理的艺术</strong></h2>
<h3 data-id="heading-14">4.1 为什么需要数据预处理？</h3>
<p><strong>原始数据的常见问题</strong>：</p>
<ul>
<li>格式不统一（图片大小不同）</li>
<li>数值范围差异大（有的特征0-1，有的0-1000）</li>
<li>存在噪声和异常值</li>
</ul>
<h3 data-id="heading-15">4.2 PyTorch数据管道构建</h3>
<h4 data-id="heading-16">自定义数据集类</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> Dataset, DataLoader

<span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomDataset</span>(<span class="hljs-title class_ inherited__">Dataset</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, data, targets, transform=<span class="hljs-literal">None</span></span>):
        self.data = data
        self.targets = targets
        self.transform = transform
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.data)  <span class="hljs-comment"># 返回数据总条数</span>
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getitem__</span>(<span class="hljs-params">self, idx</span>):
        sample = self.data[idx]
        label = self.targets[idx]
        
        <span class="hljs-keyword">if</span> self.transform:
            sample = self.transform(sample)  <span class="hljs-comment"># 数据增强</span>
            
        <span class="hljs-keyword">return</span> sample, label
</code></pre>
<h4 data-id="heading-17">数据转换流水线</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> torchvision <span class="hljs-keyword">import</span> transforms

<span class="hljs-comment"># 定义数据预处理步骤</span>
transform = transforms.Compose([
    transforms.ToTensor(),           <span class="hljs-comment"># 转为张量</span>
    transforms.Normalize((<span class="hljs-number">0.5</span>,), (<span class="hljs-number">0.5</span>,)),  <span class="hljs-comment"># 标准化到[-1,1]</span>
    transforms.RandomHorizontalFlip(),     <span class="hljs-comment"># 随机水平翻转</span>
    transforms.RandomRotation(<span class="hljs-number">15</span>)          <span class="hljs-comment"># 随机旋转</span>
])
</code></pre>
<h4 data-id="heading-18">数据加载器：批量处理的利器</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 创建数据集</span>
dataset = CustomDataset(data, targets, transform=transform)

<span class="hljs-comment"># 创建数据加载器</span>
dataloader = DataLoader(
    dataset,
    batch_size=<span class="hljs-number">32</span>,      <span class="hljs-comment"># 每次取32条数据</span>
    shuffle=<span class="hljs-literal">True</span>,       <span class="hljs-comment"># 打乱顺序，避免模型记住顺序</span>
    num_workers=<span class="hljs-number">2</span>       <span class="hljs-comment"># 使用2个进程并行加载</span>
)

<span class="hljs-comment"># 使用示例</span>
<span class="hljs-keyword">for</span> batch_idx, (data, targets) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(dataloader):
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f'批次 <span class="hljs-subst">{batch_idx}</span>, 数据形状: <span class="hljs-subst">{data.shape}</span>, 标签形状: <span class="hljs-subst">{targets.shape}</span>'</span>)
    <span class="hljs-comment"># 这里进行模型训练...</span>
</code></pre>
<blockquote>
<p>🔄 <strong>批处理的好处</strong>：</p>
<ul>
<li>提高训练效率（GPU可以并行计算）</li>
<li>更稳定的梯度估计</li>
<li>内存使用更高效</li>
</ul>
</blockquote>
<h2 data-id="heading-19"><strong>五、线性代数在深度学习中的应用</strong></h2>
<h3 data-id="heading-20">5.1 核心线性代数操作</h3>
<h4 data-id="heading-21">基本矩阵运算</h4>
<pre><code class="hljs language-python" lang="python">A = torch.tensor([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]], dtype=torch.float32)
B = torch.tensor([[<span class="hljs-number">5</span>, <span class="hljs-number">6</span>], [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>]], dtype=torch.float32)

<span class="hljs-comment"># 矩阵加法：对应位置相加</span>
add = A + B  <span class="hljs-comment"># [[6, 8], [10, 12]]</span>

<span class="hljs-comment"># 元素乘法：对应位置相乘</span>
element_wise = A * B  <span class="hljs-comment"># [[5, 12], [21, 32]]</span>

<span class="hljs-comment"># 矩阵乘法：行乘列求和</span>
matrix_mul = torch.mm(A, B)  <span class="hljs-comment"># [[19, 22], [43, 50]]</span>
</code></pre>
<h4 data-id="heading-22">高级线性代数操作</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 行列式：衡量矩阵的"缩放能力"</span>
det = torch.det(A)  <span class="hljs-comment"># -2.0</span>

<span class="hljs-comment"># 逆矩阵：矩阵的"倒数"</span>
inv_A = torch.inverse(A)  <span class="hljs-comment"># [[-2, 1], [1.5, -0.5]]</span>

<span class="hljs-comment"># 特征值：揭示矩阵的本质特性</span>
eigenvalues = torch.linalg.eigvals(A)  <span class="hljs-comment"># 特征值</span>

<span class="hljs-comment"># 奇异值分解：矩阵的"DNA分析"</span>
U, S, Vh = torch.linalg.svd(A)
</code></pre>
<h3 data-id="heading-23">5.2 线性代数与神经网络的关系</h3>
<p><strong>神经网络本质上是复杂的线性变换</strong>：</p>
<pre><code class="hljs language-scss" lang="scss">输出 = 激活函数(输入 × 权重 + 偏置)
</code></pre>
<p>每个神经网络层都在进行矩阵乘法，通过多层线性变换+非线性激活函数的组合，神经网络可以拟合任意复杂函数。</p>
<h2 data-id="heading-24"><strong>六、第一个深度学习模型——线性回归</strong></h2>
<h3 data-id="heading-25">6.1 问题定义：预测房屋价格</h3>
<p><strong>场景</strong>：根据房屋面积预测价格</p>
<ul>
<li><strong>输入</strong>：房屋面积（平方米）</li>
<li><strong>输出</strong>：预测价格（万元）</li>
<li><strong>关系</strong>：价格 ≈ 2.5 × 面积 + 1.0 + 噪声</li>
</ul>
<h3 data-id="heading-26">6.2 模型构建与训练</h3>
<h4 data-id="heading-27">数据生成</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> torch
<span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn

<span class="hljs-comment"># 设置随机种子，保证结果可重现</span>
torch.manual_seed(<span class="hljs-number">42</span>)

<span class="hljs-comment"># 生成模拟数据</span>
X = torch.linspace(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">100</span>).reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)  <span class="hljs-comment"># 100个0-10之间的面积值</span>
true_w, true_b = <span class="hljs-number">2.5</span>, <span class="hljs-number">1.0</span>  <span class="hljs-comment"># 真实的关系</span>
y = true_w * X + true_b + torch.randn(X.size()) * <span class="hljs-number">1.5</span>  <span class="hljs-comment"># 加噪声模拟现实</span>
</code></pre>
<h4 data-id="heading-28">模型定义</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LinearRegression</span>(nn.Module):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-built_in">super</span>().__init__()
        <span class="hljs-comment"># nn.Linear封装了 y = x * w + b</span>
        self.linear = nn.Linear(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)  <span class="hljs-comment"># 输入1维，输出1维</span>
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):
        <span class="hljs-keyword">return</span> self.linear(x)

model = LinearRegression()
<span class="hljs-built_in">print</span>(<span class="hljs-string">f'初始参数: w=<span class="hljs-subst">{model.linear.weight.item():<span class="hljs-number">.2</span>f}</span>, b=<span class="hljs-subst">{model.linear.bias.item():<span class="hljs-number">.2</span>f}</span>'</span>)
</code></pre>
<h4 data-id="heading-29">训练配置</h4>
<pre><code class="hljs language-python" lang="python">criterion = nn.MSELoss()  <span class="hljs-comment"># 均方误差损失</span>
optimizer = torch.optim.SGD(model.parameters(), lr=<span class="hljs-number">0.01</span>)  <span class="hljs-comment"># 随机梯度下降</span>
</code></pre>
<h4 data-id="heading-30">训练循环：学习的核心过程</h4>
<pre><code class="hljs language-python" lang="python">epochs = <span class="hljs-number">1000</span>
losses = []

<span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(epochs):
    <span class="hljs-comment"># 前向传播：计算预测值</span>
    predictions = model(X)
    
    <span class="hljs-comment"># 计算损失：衡量预测与真实的差距</span>
    loss = criterion(predictions, y)
    
    <span class="hljs-comment"># 反向传播：计算梯度</span>
    optimizer.zero_grad()  <span class="hljs-comment"># 清空之前的梯度</span>
    loss.backward()        <span class="hljs-comment"># 计算当前梯度</span>
    
    <span class="hljs-comment"># 参数更新：调整w和b</span>
    optimizer.step()
    
    losses.append(loss.item())
    
    <span class="hljs-keyword">if</span> (epoch + <span class="hljs-number">1</span>) % <span class="hljs-number">100</span> == <span class="hljs-number">0</span>:
        current_w = model.linear.weight.item()
        current_b = model.linear.bias.item()
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f'Epoch [<span class="hljs-subst">{epoch+<span class="hljs-number">1</span>}</span>/<span class="hljs-subst">{epochs}</span>], Loss: <span class="hljs-subst">{loss.item():<span class="hljs-number">.4</span>f}</span>, '</span>
              <span class="hljs-string">f'w: <span class="hljs-subst">{current_w:<span class="hljs-number">.2</span>f}</span>, b: <span class="hljs-subst">{current_b:<span class="hljs-number">.2</span>f}</span>'</span>)
</code></pre>
<h3 data-id="heading-31">6.3 理解训练过程</h3>
<p><strong>梯度下降的直观理解</strong>：</p>
<p>想象你在山上蒙着眼睛下山：</p>
<ul>
<li><strong>损失函数</strong>：山的高度</li>
<li><strong>参数(w,b)</strong>：你的位置</li>
<li><strong>梯度</strong>：脚感受的坡度方向</li>
<li><strong>学习率</strong>：步长大小</li>
<li><strong>训练</strong>：不断往坡度最陡的方向走，直到山谷底部</li>
</ul>
<p><strong>关键概念</strong>：</p>
<ul>
<li><strong>Epoch</strong>：把所有训练数据看完一遍</li>
<li><strong>Batch</strong>：一次训练使用的数据量</li>
<li><strong>学习率</strong>：参数更新的步长</li>
<li><strong>损失函数</strong>：模型表现的评价标准</li>
</ul>
<h2 data-id="heading-32"><strong>七、深度神经网络基础</strong></h2>
<h3 data-id="heading-33">7.1 从线性回归到多层感知机</h3>
<p><strong>单层网络的局限</strong>：</p>
<ul>
<li>只能学习线性关系</li>
<li>无法解决复杂问题（如异或问题）</li>
</ul>
<p><strong>多层感知机</strong>：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MLP</span>(nn.Module):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, input_size, hidden_size, output_size</span>):
        <span class="hljs-built_in">super</span>().__init__()
        self.layer1 = nn.Linear(input_size, hidden_size)
        self.layer2 = nn.Linear(hidden_size, output_size)
        self.relu = nn.ReLU()
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):
        x = self.layer1(x)
        x = self.relu(x)  <span class="hljs-comment"># 引入非线性</span>
        x = self.layer2(x)
        <span class="hljs-keyword">return</span> x
</code></pre>
<h3 data-id="heading-34">7.2 激活函数：引入非线性能力</h3>
<p><strong>为什么需要激活函数？</strong>
没有激活函数的神经网络只是多个线性变换的叠加，整体仍然是线性的。</p>
<p><strong>常用激活函数</strong>：</p>
<ul>
<li><strong>ReLU</strong>：最常用，计算简单 <code>max(0, x)</code></li>
<li><strong>Sigmoid</strong>：将输出压缩到(0,1)，用于概率</li>
<li><strong>Tanh</strong>：将输出压缩到(-1,1)，零中心化</li>
</ul>
<h2 data-id="heading-35"><strong>八、深度学习核心概念详解</strong></h2>
<h3 data-id="heading-36">8.1 关键术语解析</h3>
<p><strong>样本与特征</strong>：</p>
<ul>
<li><strong>样本</strong>：一条数据（如一栋房屋的信息）</li>
<li><strong>特征</strong>：描述样本的属性（如面积、位置、楼层）</li>
<li><strong>标签</strong>：想要预测的目标（如价格）</li>
</ul>
<p><strong>损失函数与优化</strong>：</p>
<ul>
<li><strong>损失函数</strong>：衡量模型预测与真实值的差距</li>
<li><strong>优化器</strong>：调整参数来最小化损失的算法</li>
<li><strong>梯度</strong>：损失函数对参数的变化率</li>
</ul>
<p><strong>训练相关概念</strong>：</p>
<ul>
<li><strong>Epoch</strong>：完整遍历一遍训练集</li>
<li><strong>Batch Size</strong>：一次训练使用的样本数</li>
<li><strong>学习率</strong>：参数更新的步长大小</li>
<li><strong>过拟合</strong>：模型对训练数据学得太好，但泛化能力差</li>
</ul>
<h3 data-id="heading-37">8.2 模型训练完整流程</h3>
<ol>
<li><strong>数据准备</strong>：收集、清洗、预处理数据</li>
<li><strong>模型设计</strong>：选择合适的网络结构</li>
<li><strong>训练配置</strong>：设置损失函数、优化器、超参数</li>
<li><strong>训练循环</strong>：重复前向传播→计算损失→反向传播→参数更新</li>
<li><strong>评估验证</strong>：在测试集上评估模型性能</li>
<li><strong>部署应用</strong>：将训练好的模型投入实际使用</li>
</ol>
<h2 data-id="heading-38"><strong>九、实战建议与学习路径</strong></h2>
<h3 data-id="heading-39">9.1 学习策略</h3>
<p><strong>对于初学者</strong>：</p>
<ol>
<li><strong>先跑通代码</strong>：理解整体流程</li>
<li><strong>修改参数</strong>：观察对结果的影响</li>
<li><strong>逐步深入</strong>：从简单模型到复杂模型</li>
</ol>
<p><strong>避免的误区</strong>：</p>
<ul>
<li>❌ 过分纠结数学推导</li>
<li>✅ 先理解概念和直觉</li>
<li>❌ 试图一次性理解所有细节</li>
<li>✅ 通过实践加深理解</li>
</ul>
<h3 data-id="heading-40">9.2 下一步学习方向</h3>
<p><strong>基础进阶</strong>：</p>
<ol>
<li>全连接神经网络</li>
<li>卷积神经网络（CNN）用于图像</li>
<li>循环神经网络（RNN）用于序列数据</li>
</ol>
<p><strong>实战项目</strong>：</p>
<ol>
<li>手写数字识别（MNIST）</li>
<li>猫狗图像分类</li>
<li>文本情感分析</li>
</ol>
<h2 data-id="heading-41"><strong>总结</strong></h2>
<p>通过本文，我们建立了深度学习的完整知识体系：</p>
<p><strong>理论层面</strong>：</p>
<ul>
<li>理解了AI技术栈的层次关系</li>
<li>掌握了张量、梯度下降等核心概念</li>
<li>熟悉了神经网络的基本原理</li>
</ul>
<p><strong>实践层面</strong>：</p>
<ul>
<li>学会了PyTorch的基本操作</li>
<li>掌握了数据预处理的方法</li>
<li>完成了第一个线性回归模型</li>
</ul>
<p><strong>核心洞察</strong>：</p>
<ol>
<li><strong>深度学习本质是数据驱动的特征学习</strong></li>
<li><strong>神经网络是通过矩阵运算+非线性变换的函数逼近器</strong></li>
<li><strong>训练过程是不断调整参数来最小化损失</strong></li>
<li><strong>PyTorch让深度学习开发变得简单直观</strong></li>
</ol>
<p>深度学习就像教孩子认字：从简单的线性关系开始，逐步学习更复杂的模式识别。不同的是，我们可以用数学精确描述这个过程，并用计算机高效实现。</p>
<blockquote>
<p>水平有限，还不能写到尽善尽美，希望大家多多交流，跟春野一同进步！！！</p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[JavaHashMap源码分析]]></title>    <link>https://juejin.cn/post/7578709098255138854</link>    <guid>https://juejin.cn/post/7578709098255138854</guid>    <pubDate>2025-12-01T09:34:22.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7578709098255138854" data-draft-id="7578699866181222438" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="JavaHashMap源码分析"/> <meta itemprop="keywords" content="后端,Java"/> <meta itemprop="datePublished" content="2025-12-01T09:34:22.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="makinohara"/> <meta itemprop="url" content="https://juejin.cn/user/455637552340731"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            JavaHashMap源码分析
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/455637552340731/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    makinohara
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-01T09:34:22.000Z" title="Mon Dec 01 2025 09:34:22 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-01
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    5
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读11分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>选中HashMap，按Ctrl+B，就会跳转到源码部分。</p>
<p><strong>节点：</strong></p>
<pre><code class="hljs language-ini" lang="ini">    static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {
        final int hash<span class="hljs-comment">;</span>
        final K key<span class="hljs-comment">;</span>
        V value<span class="hljs-comment">;</span>
        Node&lt;K,V&gt; next<span class="hljs-comment">;</span>
​
        Node(int hash, K key, V value, Node&lt;K,V&gt; next) {
            <span class="hljs-attr">this.hash</span> = hash<span class="hljs-comment">;</span>
            <span class="hljs-attr">this.key</span> = key<span class="hljs-comment">;</span>
            <span class="hljs-attr">this.value</span> = value<span class="hljs-comment">;</span>
            <span class="hljs-attr">this.next</span> = next<span class="hljs-comment">;</span>
        }
</code></pre>
<p>我们知道在HashMap中，每个元素都是一个Node对象，而它实现了Map里的Entry接口，所以也可以说每个元素都是一个Entry对象。这是因为HashMap在数组的基础上融入了链表与红黑树，所以每个元素都必须是节点。</p>
<p>一个Entry对象有4个字段：</p>
<p>1.hash：它是通过Key值计算出的哈希值</p>
<p>2.Key：键</p>
<p>3.Value：值</p>
<p>4.Next：作为链表中节点，它要知道如何找到下一个元素，因此通过Next记录下一个元素的地址值</p>
<p>那么红黑树呢？红黑树就不能只存储Next了，还必须要存储左右节点等其它信息。</p>
<pre><code class="hljs language-scala" lang="scala">    static <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode&lt;K</span>,<span class="hljs-title">V&gt;</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">LinkedHashMap</span>.<span class="hljs-title">Entry&lt;K</span>,<span class="hljs-title">V&gt;</span> </span>{
        <span class="hljs-type">TreeNode</span>&lt;<span class="hljs-type">K</span>,<span class="hljs-type">V</span>&gt; parent;  <span class="hljs-comment">// red-black tree links</span>
        <span class="hljs-type">TreeNode</span>&lt;<span class="hljs-type">K</span>,<span class="hljs-type">V</span>&gt; left;
        <span class="hljs-type">TreeNode</span>&lt;<span class="hljs-type">K</span>,<span class="hljs-type">V</span>&gt; right;
        <span class="hljs-type">TreeNode</span>&lt;<span class="hljs-type">K</span>,<span class="hljs-type">V</span>&gt; prev;    <span class="hljs-comment">// needed to unlink next upon deletion</span>
        boolean red;
        <span class="hljs-type">TreeNode</span>(int hash, <span class="hljs-type">K</span> key, <span class="hljs-type">V</span> <span class="hljs-keyword">val</span>, <span class="hljs-type">Node</span>&lt;<span class="hljs-type">K</span>,<span class="hljs-type">V</span>&gt; next) {
            <span class="hljs-keyword">super</span>(hash, key, <span class="hljs-keyword">val</span>, next);
        }
</code></pre>
<p>可以看到，<code>TreeNode</code>继承了<code>LinkedHashMap</code>中的Entry，我们进一步看看这个Entry：</p>
<pre><code class="hljs language-scala" lang="scala"> static <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Entry&lt;K</span>,<span class="hljs-title">V&gt;</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HashMap</span>.<span class="hljs-title">Node&lt;K</span>,<span class="hljs-title">V&gt;</span> </span>{
        <span class="hljs-type">Entry</span>&lt;<span class="hljs-type">K</span>,<span class="hljs-type">V</span>&gt; before, after;
        <span class="hljs-type">Entry</span>(int hash, <span class="hljs-type">K</span> key, <span class="hljs-type">V</span> value, <span class="hljs-type">Node</span>&lt;<span class="hljs-type">K</span>,<span class="hljs-type">V</span>&gt; next) {
            <span class="hljs-keyword">super</span>(hash, key, value, next);
        }
    }
</code></pre>
<p>可以看到这个Entry继承了HashMap中的Node，也就是一开始我们见到的Node，这也意味着<code>TreeNode</code>除了记录左右节点、父节点等这些专属于红黑树的信息，还保留了作为链表的信息。因为当链表长度达到8并且数组长度达到64，链表就要转为红黑树。</p>
<p><strong>成员变量</strong></p>
<pre><code class="hljs language-ini" lang="ini">static final int <span class="hljs-attr">DEFAULT_INITIAL_CAPACITY</span> = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span><span class="hljs-comment">; // aka 16</span>
static final int <span class="hljs-attr">MAXIMUM_CAPACITY</span> = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span><span class="hljs-comment">;</span>
static final float <span class="hljs-attr">DEFAULT_LOAD_FACTOR</span> = <span class="hljs-number">0.75</span>f<span class="hljs-comment">;</span>
transient Node&lt;K,V&gt;<span class="hljs-section">[]</span> table<span class="hljs-comment">;</span>
</code></pre>
<p>这个table数组就是HashMap的存储基础。它的默认初始长度是16，最大容量是2的30次方，是个天文数字。默认扩容因子是0.75，这意味着当已经被填充的位置数量达到了容量的0.75就会进行扩容操作，每次扩容都会将容量扩充为原来的2倍。</p>
<p><strong>空参构造</strong></p>
<pre><code class="hljs language-csharp" lang="csharp">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span>()</span> {
        <span class="hljs-keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="hljs-comment">// all other fields defaulted</span>
    }
</code></pre>
<p>可以看到，当我们调用HashMap的空参构造时，实际上只做了一件事：将默认扩容因子赋值给该对象的扩容因子成员变量。此时table还是NULL</p>
<p><strong>那么，table什么时候创建？</strong></p>
<p>当我们添加元素的时候table就必须要创建出来了，因此我们定位到put函数：</p>
<pre><code class="hljs language-vbnet" lang="vbnet"><span class="hljs-keyword">public</span> V put(K <span class="hljs-keyword">key</span>, V value) {
        <span class="hljs-keyword">return</span> putVal(hash(<span class="hljs-keyword">key</span>), <span class="hljs-keyword">key</span>, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);
    }
</code></pre>
<p>看一下hash方法：</p>
<pre><code class="hljs language-java" lang="java">   <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> {
        <span class="hljs-type">int</span> h;
        <span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);
    }
</code></pre>
<p>hash方法通过一些计算，返回了键的哈希值。可以看到，键的哈希值与Value没有任何关系，只和Key有关系。</p>
<p>再看<code>putVal</code>函数：</p>
<pre><code class="hljs language-ini" lang="ini">    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
        Node&lt;K,V&gt;<span class="hljs-section">[]</span> tab<span class="hljs-comment">; Node&lt;K,V&gt; p; int n, i;</span>
        if ((<span class="hljs-attr">tab</span> = table) == null || (n = tab.length) == <span class="hljs-number">0</span>)
            <span class="hljs-attr">n</span> = (tab = resize()).length<span class="hljs-comment">;</span>
        if ((<span class="hljs-attr">p</span> = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == null)
            tab<span class="hljs-section">[i]</span> = newNode(hash, key, value, null)<span class="hljs-comment">;</span>
        else {
            Node&lt;K,V&gt; e<span class="hljs-comment">; K k;</span>
            if (<span class="hljs-attr">p.hash</span> == hash &amp;&amp;
                ((<span class="hljs-attr">k</span> = p.key) == key || (key != null &amp;&amp; key.equals(k))))
                <span class="hljs-attr">e</span> = p<span class="hljs-comment">;</span>
            else if (p instanceof TreeNode)
                <span class="hljs-attr">e</span> = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value)<span class="hljs-comment">;</span>
            else {
                for (int <span class="hljs-attr">binCount</span> = <span class="hljs-number">0</span><span class="hljs-comment">; ; ++binCount) {</span>
                    if ((<span class="hljs-attr">e</span> = p.next) == null) {
                        <span class="hljs-attr">p.next</span> = newNode(hash, key, value, null)<span class="hljs-comment">;</span>
                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            treeifyBin(tab, hash)<span class="hljs-comment">;</span>
                        break<span class="hljs-comment">;</span>
                    }
                    if (<span class="hljs-attr">e.hash</span> == hash &amp;&amp;
                        ((<span class="hljs-attr">k</span> = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                        break<span class="hljs-comment">;</span>
                    <span class="hljs-attr">p</span> = e<span class="hljs-comment">;</span>
                }
            }
            if (e != null) { // existing mapping for key
                V <span class="hljs-attr">oldValue</span> = e.value<span class="hljs-comment">;</span>
                if (!onlyIfAbsent || <span class="hljs-attr">oldValue</span> == null)
                    <span class="hljs-attr">e.value</span> = value<span class="hljs-comment">;</span>
                afterNodeAccess(e)<span class="hljs-comment">;</span>
                return oldValue<span class="hljs-comment">;</span>
            }
        }
        ++modCount<span class="hljs-comment">;</span>
        if (++size &gt; threshold)
            resize()<span class="hljs-comment">;</span>
        afterNodeInsertion(evict)<span class="hljs-comment">;</span>
        return null<span class="hljs-comment">;</span>
    }
</code></pre>
<p>前三个参数分别为键的哈希值、键、值。第四个参数表示“当前的数据是否保留”，也就是覆盖与否的问题。</p>
<pre><code class="hljs language-css" lang="css">Node&lt;K,V&gt;<span class="hljs-selector-attr">[]</span> tab; Node&lt;K,V&gt; <span class="hljs-selector-tag">p</span>; int n, <span class="hljs-selector-tag">i</span>;
</code></pre>
<p>在<code>putVal</code>方法中又声明了一个tab数组。这是因为：成员变量在堆上，方法运行在栈上。如果运行在栈上的方法要多次去堆中找table，开销就会比较大。</p>
<p>另外，p是一个第三方变量，用来记录节点。n表示数组长度，i表示索引。</p>
<p>添加元素分为三种情况：</p>
<p>1.数组位置为null</p>
<p>2.数组位置不为null，键重复，覆盖</p>
<p>3.数组位置不为null，键不重复，形成链表或红黑树</p>
<p><strong>第一种情况：</strong></p>
<pre><code class="hljs language-ini" lang="ini">        if ((<span class="hljs-attr">tab</span> = table) == null || (n = tab.length) == <span class="hljs-number">0</span>)
            <span class="hljs-attr">n</span> = (tab = resize()).length<span class="hljs-comment">;</span>
</code></pre>
<p>这里把table赋值给了tab，因为tab本身就是要在栈中充当table的角色。对于n同理，也把数组的长度赋值给了它。如果是第一次添加元素，那么这个条件就会成立，因为第一次添加元素必然没有创建tab，tab长度也必然为0.就会调用if中的语句：将resize()赋值给tab，再把tab的长度赋值给n</p>
<p>看看resize做了什么：</p>
<pre><code class="hljs language-ini" lang="ini">    final Node&lt;K,V&gt;<span class="hljs-section">[]</span> resize() {
        Node&lt;K,V&gt;<span class="hljs-section">[]</span> <span class="hljs-attr">oldTab</span> = table<span class="hljs-comment">;</span>
        int <span class="hljs-attr">oldCap</span> = (oldTab == null) ? <span class="hljs-number">0</span> : oldTab.length<span class="hljs-comment">;</span>
        int <span class="hljs-attr">oldThr</span> = threshold<span class="hljs-comment">;</span>
        int newCap, <span class="hljs-attr">newThr</span> = <span class="hljs-number">0</span><span class="hljs-comment">;</span>
        if (oldCap &gt; 0) {
            if (oldCap &gt;= MAXIMUM_CAPACITY) {
                <span class="hljs-attr">threshold</span> = Integer.MAX_VALUE<span class="hljs-comment">;</span>
                return oldTab<span class="hljs-comment">;</span>
            }
            else if ((<span class="hljs-attr">newCap</span> = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;
                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)
                <span class="hljs-attr">newThr</span> = oldThr &lt;&lt; <span class="hljs-number">1</span><span class="hljs-comment">; // double threshold</span>
        }
        else if (oldThr &gt; 0) // initial capacity was placed in threshold
            <span class="hljs-attr">newCap</span> = oldThr<span class="hljs-comment">;</span>
        else {               // zero initial threshold signifies using defaults
            <span class="hljs-attr">newCap</span> = DEFAULT_INITIAL_CAPACITY<span class="hljs-comment">;</span>
            <span class="hljs-attr">newThr</span> = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY)<span class="hljs-comment">;</span>
        }
        if (<span class="hljs-attr">newThr</span> == <span class="hljs-number">0</span>) {
            float <span class="hljs-attr">ft</span> = (float)newCap * loadFactor<span class="hljs-comment">;</span>
            <span class="hljs-attr">newThr</span> = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?
                      (int)ft : Integer.MAX_VALUE)<span class="hljs-comment">;</span>
        }
        <span class="hljs-attr">threshold</span> = newThr<span class="hljs-comment">;</span>
        @SuppressWarnings({"rawtypes","unchecked"})
        Node&lt;K,V&gt;<span class="hljs-section">[]</span> <span class="hljs-attr">newTab</span> = (Node&lt;K,V&gt;[])new Node[newCap]<span class="hljs-comment">;</span>
        <span class="hljs-attr">table</span> = newTab<span class="hljs-comment">;</span>
</code></pre>
<p>由于还未创建table数组，因此<code>oldTab</code>为空，因此<code>oldCap</code>为0，所以不会进入到<code>if(oldCap &gt; 0)</code>的判断中，直接看else：将默认初始容量赋值给<code>newCap</code>，将扩容阈值赋值给<code>newThr</code>，为创建数组做准备。</p>
<p>由于<code>newThr</code>不为0，所以不会进入最后一个if语句。</p>
<p>将<code>newThr</code>赋值给成员变量<code>threshold</code>，再创建一个大小为<code>newCap</code>的Node数组<code>newTab</code>，再将<code>newTab</code>赋值给table，这下就完成了数组的创建。</p>
<p>最后resize方法会返回<code>newTab</code>，所以将resize()返回的结果赋值给tab，实际上就是创建了一个大小为16，扩容阈值为12的Node数组。</p>
<pre><code class="hljs language-ini" lang="ini"> if ((<span class="hljs-attr">p</span> = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == null)
    tab<span class="hljs-section">[i]</span> = newNode(hash, key, value, null)<span class="hljs-comment">;</span>
</code></pre>
<p>前面说参数的时候我们知道，这里的hash传进来的是hash(key)，即键的哈希值。将键的哈希值与数组长度-1做与运算，得到了该对象在数组中存放的索引，赋值给i，将tab[i]赋值给p</p>
<p>如果p为空，即该位置没有元素，那么直接在该位置创建一个新节点。</p>
<pre><code class="hljs language-python" lang="python">   Node&lt;K,V&gt; newNode(<span class="hljs-built_in">int</span> <span class="hljs-built_in">hash</span>, K key, V value, Node&lt;K,V&gt; <span class="hljs-built_in">next</span>) {
        <span class="hljs-keyword">return</span> new Node&lt;&gt;(<span class="hljs-built_in">hash</span>, key, value, <span class="hljs-built_in">next</span>);
    }
</code></pre>
<p><code>newNode</code>方法比较简单，就是创建了一个Node对象。</p>
<p>最后判断++size是否大于threshold，对于第一次添加元素的情况来说是否定的。这个if语句就是用来判断是否需要扩容的。最终返回null，这也很符合我们的使用认知：覆盖之后返回被覆盖的值。由于原本为空，相当于覆盖了空，所以返回空。</p>
<p><strong>第三种情况：</strong></p>
<pre><code class="hljs language-ini" lang="ini">            Node&lt;K,V&gt; e<span class="hljs-comment">; K k;</span>
            if (<span class="hljs-attr">p.hash</span> == hash &amp;&amp;
                ((<span class="hljs-attr">k</span> = p.key) == key || (key != null &amp;&amp; key.equals(k))))
                <span class="hljs-attr">e</span> = p<span class="hljs-comment">;</span>
            else if (p instanceof TreeNode)
                <span class="hljs-attr">e</span> = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value)<span class="hljs-comment">;</span>
            else {
                for (int <span class="hljs-attr">binCount</span> = <span class="hljs-number">0</span><span class="hljs-comment">; ; ++binCount) {</span>
                    if ((<span class="hljs-attr">e</span> = p.next) == null) {
                        <span class="hljs-attr">p.next</span> = newNode(hash, key, value, null)<span class="hljs-comment">;</span>
                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            treeifyBin(tab, hash)<span class="hljs-comment">;</span>
                        break<span class="hljs-comment">;</span>
                    }
                    if (<span class="hljs-attr">e.hash</span> == hash &amp;&amp;
                        ((<span class="hljs-attr">k</span> = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                        break<span class="hljs-comment">;</span>
                    <span class="hljs-attr">p</span> = e<span class="hljs-comment">;</span>
                }
            }
            if (e != null) { // existing mapping for key
                V <span class="hljs-attr">oldValue</span> = e.value<span class="hljs-comment">;</span>
                if (!onlyIfAbsent || <span class="hljs-attr">oldValue</span> == null)
                    <span class="hljs-attr">e.value</span> = value<span class="hljs-comment">;</span>
                afterNodeAccess(e)<span class="hljs-comment">;</span>
                return oldValue<span class="hljs-comment">;</span>
            }
</code></pre>
<p>上文说过，p就是tab[i]，即这个对象应该在数组中存放的位置上的元素地址值。</p>
<p>我们假设现在在下标为2的位置存了一个地址为<code>0x0011</code>，键为<code>aaa</code>，值为111的对象A。现在我们将一个地址为<code>0x0033</code>，键为<code>ccc</code>，值为333的对象C加入HashMap中，恰好算出来的应该存入哈希表中的位置就是下标为2的位置，发生重复。</p>
<p>那么此时这个第三方节点p记录的就是地址为<code>0x0011</code>，键为<code>aaa</code>，值为111的对象，它是一个副本。</p>
<p>首先判断<code>p.hash</code>是否等于当前要加入对象的哈希值，如果不等于，由于是&amp;&amp;，就直接跳过。</p>
<p>如果p是某个红黑树节点的地址，那么就将这个待加入节点加入红黑树。</p>
<p>如果不是红黑树的节点，那就要涉及到链表了：</p>
<pre><code class="hljs language-ini" lang="ini">                for (int <span class="hljs-attr">binCount</span> = <span class="hljs-number">0</span><span class="hljs-comment">; ; ++binCount) {</span>
                    if ((<span class="hljs-attr">e</span> = p.next) == null) {
                        <span class="hljs-attr">p.next</span> = newNode(hash, key, value, null)<span class="hljs-comment">;</span>
                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            treeifyBin(tab, hash)<span class="hljs-comment">;</span>
                        break<span class="hljs-comment">;</span>
                    }
                    if (<span class="hljs-attr">e.hash</span> == hash &amp;&amp;
                        ((<span class="hljs-attr">k</span> = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                        break<span class="hljs-comment">;</span>
                    <span class="hljs-attr">p</span> = e<span class="hljs-comment">;</span>
                }
</code></pre>
<p>如果这个对象A的next为空，那么就原地新建一个节点作为它的下一个节点。再判断长度是否超过8，如果超过8就调用<code>treeifyBin</code>方法，在这个方法中还会判断数组长度是否大于64，如果两个条件都满足，就会将链表转换为红黑树。判断完是否需要转为红黑树后，退出循环。由于<code>p.next</code>原本为空，所以e为null，不会走后面的if语句。</p>
<p>如果<code>p.next</code>原本不为空，就会判断e的哈希值与待加入节点的哈希值是否相同，如果不相同的话就将e赋值给p再循环，相当于双指针迭代遍历链表。只要没有哈希值一样，最终p一定会是链表末尾的节点的地址，e最终一定为空。只要哈希值一样，e就是那个哈希值相同的节点的地址，即进入下文的第二种情况。</p>
<p><strong>第二种情况：</strong></p>
<p>现在，在对象C后面我们又存入了一个地址为<code>0x0044</code>，键为<code>ddd</code>，值为444的对象D。我们要存入一个地址为<code>0x0055</code>，键为<code>ddd</code>，值为555的对象D1。假设要存入的位置依然是下标为2的位置。</p>
<p>首先会将D的键的哈希值与A的键的哈希值进行比较，如果不一样就看A后面有没有元素，如果一样就进行覆盖。由于键不一样，那么由于A后面还有一个对象C，C后面还有D，再比较，发现键的哈希值相同，就要进行覆盖操作。我们来看看在源码中具体是如何实现的。</p>
<p>首先，p还是对象A的地址，因为它表示“应该存入的位置上的对象 的地址”。现在p不为null，走else语句：</p>
<pre><code class="hljs language-ini" lang="ini">        else {
            Node&lt;K,V&gt; e<span class="hljs-comment">; K k;</span>
            if (<span class="hljs-attr">p.hash</span> == hash &amp;&amp;
                ((<span class="hljs-attr">k</span> = p.key) == key || (key != null &amp;&amp; key.equals(k))))
                <span class="hljs-attr">e</span> = p<span class="hljs-comment">;</span>
            else if (p instanceof TreeNode)
                <span class="hljs-attr">e</span> = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value)<span class="hljs-comment">;</span>
            else {
                for (int <span class="hljs-attr">binCount</span> = <span class="hljs-number">0</span><span class="hljs-comment">; ; ++binCount) {</span>
                    if ((<span class="hljs-attr">e</span> = p.next) == null) {
                        <span class="hljs-attr">p.next</span> = newNode(hash, key, value, null)<span class="hljs-comment">;</span>
                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            treeifyBin(tab, hash)<span class="hljs-comment">;</span>
                        break<span class="hljs-comment">;</span>
                    }
                    if (<span class="hljs-attr">e.hash</span> == hash &amp;&amp;
                        ((<span class="hljs-attr">k</span> = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                        break<span class="hljs-comment">;</span>
                    <span class="hljs-attr">p</span> = e<span class="hljs-comment">;</span>
                }
            }
            if (e != null) { // existing mapping for key
                V <span class="hljs-attr">oldValue</span> = e.value<span class="hljs-comment">;</span>
                if (!onlyIfAbsent || <span class="hljs-attr">oldValue</span> == null)
                    <span class="hljs-attr">e.value</span> = value<span class="hljs-comment">;</span>
                afterNodeAccess(e)<span class="hljs-comment">;</span>
                return oldValue<span class="hljs-comment">;</span>
            }
        }
</code></pre>
<p>p（对象A的地址）的哈希值不等于D1的哈希值，也不是树节点，走内层的else语句：</p>
<pre><code class="hljs language-ini" lang="ini">            else {
                for (int <span class="hljs-attr">binCount</span> = <span class="hljs-number">0</span><span class="hljs-comment">; ; ++binCount) {</span>
                    if ((<span class="hljs-attr">e</span> = p.next) == null) {
                        <span class="hljs-attr">p.next</span> = newNode(hash, key, value, null)<span class="hljs-comment">;</span>
                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            treeifyBin(tab, hash)<span class="hljs-comment">;</span>
                        break<span class="hljs-comment">;</span>
                    }
                    if (<span class="hljs-attr">e.hash</span> == hash &amp;&amp;
                        ((<span class="hljs-attr">k</span> = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                        break<span class="hljs-comment">;</span>
                    <span class="hljs-attr">p</span> = e<span class="hljs-comment">;</span>
                }
</code></pre>
<p>将p的下一个节点赋值给e，此时e为对象C的地址，不为空，走第二个if语句：</p>
<pre><code class="hljs language-ini" lang="ini">                    if (<span class="hljs-attr">e.hash</span> == hash &amp;&amp;
                        ((<span class="hljs-attr">k</span> = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                        break<span class="hljs-comment">;</span>
                    <span class="hljs-attr">p</span> = e<span class="hljs-comment">;</span>
</code></pre>
<p>e（对象C的地址）的哈希值也不等于D1的哈希值，不会进入if中，最后将e赋值给p，也就是原本为对象A的p，现在变成了对象C，这实际上相当于双指针迭代遍历链表。e是p的下一个节点的地址，然后通过将e赋值给p移动p，然后直接通过next得到p的下一个节点。</p>
<p>现在p是对象C的地址，没有break，所以还会继续在这个for循环中。将p的下一个节点地址赋值给e，此时e为对象D的地址，不为空，走第二个if语句。发现<code>e.hash==hash</code>成立，由于是&amp;&amp;，继续往后看。<code>e.key==key</code>也成立，由于是||，不用看了，必然成立，因此整条语句返回true，进入if语句，调用break，退出循环。</p>
<p>此时e不为空，走if语句进行赋值：</p>
<pre><code class="hljs language-ini" lang="ini">            if (e != null) { // existing mapping for key
                V <span class="hljs-attr">oldValue</span> = e.value<span class="hljs-comment">;</span>
                if (!onlyIfAbsent || <span class="hljs-attr">oldValue</span> == null)
                    <span class="hljs-attr">e.value</span> = value<span class="hljs-comment">;</span>
                afterNodeAccess(e)<span class="hljs-comment">;</span>
                return oldValue<span class="hljs-comment">;</span>
            }
</code></pre>
<p>将待覆盖的节点的value取出来赋值给<code>oldValue</code>，<code>onlyIfAbsent</code>为true，那么就进入if语句，将待加入的节点的value赋值给待覆盖节点的value，再返回待覆盖节点原本的value</p>
<p>也就是说，我们并没有对链表进行删除并新增节点的操作，只不过是将哈希值一样的节点的Value进行了替换而已。即：现在链表中依然还是A -&gt; C -&gt; D，没有D1对象，只不过D的Value从原本的444改为了555，然后将原本的444返回给了我们。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[《最小栈的巧妙设计：用辅助栈实现 O(1) 获取最小值》]]></title>    <link>https://juejin.cn/post/7578442185848651814</link>    <guid>https://juejin.cn/post/7578442185848651814</guid>    <pubDate>2025-12-01T08:40:53.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7578442185848651814" data-draft-id="7577713754563412020" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="《最小栈的巧妙设计：用辅助栈实现 O(1) 获取最小值》"/> <meta itemprop="keywords" content="JavaScript,面试,算法"/> <meta itemprop="datePublished" content="2025-12-01T08:40:53.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="鱼鱼块"/> <meta itemprop="url" content="https://juejin.cn/user/4302802432307224"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            《最小栈的巧妙设计：用辅助栈实现 O(1) 获取最小值》
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4302802432307224/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    鱼鱼块
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-01T08:40:53.000Z" title="Mon Dec 01 2025 08:40:53 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-01
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    10
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">最小栈：用辅助栈实现 O(1) 获取最小值的巧妙设计</h2>
<p>栈（Stack）是程序员最熟悉的数据结构之一——后进先出、操作简单，广泛应用于函数调用、表达式求值、括号匹配等场景。但你是否想过：如果在标准栈的基础上，<strong>要求随时以 O(1) 的时间复杂度获取当前栈中的最小元素</strong>，该如何设计？这正是 <a href="https://link.juejin.cn?target=https%3A%2F%2Fleetcode.cn%2Fproblems%2Fmin-stack%2Fdescription%2F" target="_blank" title="https://leetcode.cn/problems/min-stack/description/" ref="nofollow noopener noreferrer">155. 最小栈 - 力扣（LeetCode）</a>所提出的核心挑战。</p>
<p>为了解决这个问题，我们可以借助一个<strong>辅助栈</strong>（也称为单调栈）来实现 <strong>O(1) 时间复杂度</strong>获取最小值的功能。本文将从问题出发，逐步讲解两种实现方式——朴素方法与优化方法，并重点剖析“辅助栈”这一精巧设计的思想与实现细节。</p>
<hr/>
<h3 data-id="heading-1">一、问题定义：什么是“最小栈”？</h3>
<p>“最小栈”是指在支持标准栈操作（push、pop、top）的基础上，额外支持一个 <code>getMin()</code> 方法，用于<strong>返回当前栈中所有元素的最小值</strong>，且要求该方法的时间复杂度为 O(1)。</p>
<p>例如：</p>
<ul>
<li>执行 <code>push(3)</code> → 栈：[3] → 最小值：3</li>
<li>执行 <code>push(1)</code> → 栈：[3,1] → 最小值：1</li>
<li>执行 <code>push(2)</code> → 栈：[3,1,2] → 最小值：1</li>
<li>执行 <code>pop()</code> → 栈：[3,1] → 最小值：1</li>
<li>再次 <code>pop()</code> → 栈：[3] → 最小值：3</li>
</ul>
<p>关键在于：<strong>无论栈如何变化，<code>getMin()</code> 都能立刻返回当前最小值，无需重新扫描。</strong></p>
<hr/>
<h3 data-id="heading-2">二、朴素解法：每次遍历找最小值</h3>
<p>最直观的想法是：每次调用 <code>getMin()</code> 时，遍历整个栈，找出最小元素。这种实现简单直接，但效率低下。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">MiniStack</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span> = [];
}

<span class="hljs-title class_">MiniStack</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">push</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>.<span class="hljs-title function_">push</span>(x);
}

<span class="hljs-title class_">MiniStack</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">pop</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>.<span class="hljs-title function_">pop</span>();
}

<span class="hljs-title class_">MiniStack</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">top</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span> || !<span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>.<span class="hljs-property">length</span>) {
    <span class="hljs-keyword">return</span>;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>];
}

<span class="hljs-title class_">MiniStack</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getMin</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">let</span> minValue = <span class="hljs-title class_">Infinity</span>;
  <span class="hljs-keyword">const</span> { stack } = <span class="hljs-variable language_">this</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; stack.<span class="hljs-property">length</span>; i++) {
    <span class="hljs-keyword">if</span> (stack[i] &lt; minValue) {
      minValue = stack[i];
    }
  }
  <span class="hljs-keyword">return</span> minValue;
}
</code></pre>
<p>这种方法的问题显而易见：</p>
<ul>
<li><code>getMin()</code> 的时间复杂度是 <strong>O(n)</strong> ；</li>
<li>如果频繁调用 <code>getMin()</code>，整体性能会显著下降；</li>
<li>不符合“高效数据结构”的设计目标。</li>
</ul>
<p>因此，我们需要一种更聪明的办法。</p>
<hr/>
<h3 data-id="heading-3">三、优化解法：引入辅助栈（单调栈）</h3>
<p>核心思想是：<strong>用空间换时间</strong>。我们额外维护一个“辅助栈”，专门用来记录<strong>当前主栈状态下的最小值</strong>。这个辅助栈始终保持“非严格递减”（即单调不增），其栈顶始终是当前全局最小值。</p>
<h4 data-id="heading-4">1. 辅助栈的工作原理</h4>
<ul>
<li>
<p><strong>入栈（push）时</strong>：</p>
<ul>
<li>将元素压入主栈；</li>
<li>同时判断：如果辅助栈为空，或者新元素 ≤ 辅助栈栈顶，则也将该元素压入辅助栈。</li>
</ul>
</li>
<li>
<p><strong>出栈（pop）时</strong>：</p>
<ul>
<li>从主栈弹出元素；</li>
<li>如果弹出的元素等于辅助栈栈顶，则辅助栈也同步弹出。</li>
</ul>
</li>
<li>
<p><strong>获取最小值（getMin）时</strong>：</p>
<ul>
<li>直接返回辅助栈的栈顶元素，时间复杂度 O(1)。</li>
</ul>
</li>
</ul>
<p>这种设计保证了：<strong>辅助栈的每一个元素，都对应主栈在某个时刻的最小值</strong>。即使主栈中有重复元素，只要它们影响了最小值，辅助栈就会记录。</p>
<h4 data-id="heading-5">2. 代码实现</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">const</span> MiniStack = function() {
  <span class="hljs-keyword">this</span>.stack = [];     <span class="hljs-comment">// 主栈</span>
  <span class="hljs-keyword">this</span>.stack2 = [];    <span class="hljs-comment">// 辅助栈（单调栈）</span>
}

MiniStack.prototype.push = function(x) {
  <span class="hljs-keyword">this</span>.stack.push(x);
  <span class="hljs-comment">// 如果辅助栈为空，或新元素小于等于辅助栈栈顶，则入辅助栈</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.stack2.length === <span class="hljs-number">0</span> || <span class="hljs-keyword">this</span>.stack2[<span class="hljs-keyword">this</span>.stack2.length - <span class="hljs-number">1</span>] &gt;= x) {
    <span class="hljs-keyword">this</span>.stack2.push(x);
  }
}

MiniStack.prototype.pop = function() {
  <span class="hljs-keyword">const</span> popped = <span class="hljs-keyword">this</span>.stack.pop();
  <span class="hljs-comment">// 如果弹出的元素等于辅助栈栈顶，则辅助栈也弹出</span>
  <span class="hljs-keyword">if</span> (popped === <span class="hljs-keyword">this</span>.stack2[<span class="hljs-keyword">this</span>.stack2.length - <span class="hljs-number">1</span>]) {
    <span class="hljs-keyword">this</span>.stack2.pop();
  }
}

MiniStack.prototype.top = function() {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.stack[<span class="hljs-keyword">this</span>.stack.length - <span class="hljs-number">1</span>];
}

MiniStack.prototype.getMin = function() {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.stack2[<span class="hljs-keyword">this</span>.stack2.length - <span class="hljs-number">1</span>];
}
</code></pre>
<blockquote>
<p>注意：这里使用 <code>&gt;=</code> 而不是 <code>&gt;</code>，是为了处理<strong>重复最小值</strong>的情况。例如连续 push 两个 1，若只在 <code>&lt;</code> 时入辅助栈，则第二个 1 出栈时辅助栈已空，导致错误。</p>
</blockquote>
<hr/>
<h3 data-id="heading-6">四、为什么辅助栈能正确工作？</h3>
<p>让我们通过一个例子验证其正确性：</p>
<p>操作序列：</p>
<ol>
<li><code>push(5)</code> → 主栈：[5]，辅助栈：[5]</li>
<li><code>push(3)</code> → 主栈：[5,3]，辅助栈：[5,3]（3 ≤ 5）</li>
<li><code>push(4)</code> → 主栈：[5,3,4]，辅助栈：[5,3]（4 &gt; 3，不入）</li>
<li><code>push(3)</code> → 主栈：[5,3,4,3]，辅助栈：[5,3,3]（3 ≤ 3）</li>
<li><code>getMin()</code> → 返回 3 ✅</li>
<li><code>pop()</code> → 弹出 3，主栈：[5,3,4]，辅助栈：[5,3]（弹出匹配）</li>
<li><code>getMin()</code> → 返回 3 ✅</li>
<li><code>pop()</code> → 弹出 4，主栈：[5,3]，辅助栈不变（4 ≠ 3）</li>
<li><code>getMin()</code> → 返回 3 ✅</li>
<li><code>pop()</code> → 弹出 3，主栈：[5]，辅助栈：[5]</li>
<li><code>getMin()</code> → 返回 5 ✅</li>
</ol>
<p>可以看到，<strong>辅助栈始终与主栈的“最小值历史”同步</strong>，即使中间有非最小值插入，也不影响正确性。</p>
<hr/>
<h3 data-id="heading-7">五、空间与时间的权衡</h3>
<ul>
<li>
<p><strong>时间复杂度</strong>：</p>
<ul>
<li><code>push</code>：O(1)</li>
<li><code>pop</code>：O(1)</li>
<li><code>top</code>：O(1)</li>
<li><code>getMin</code>：O(1)</li>
</ul>
</li>
<li>
<p><strong>空间复杂度</strong>：O(n)</p>
<ul>
<li>最坏情况下（如元素单调递减），辅助栈与主栈一样大；</li>
<li>平均情况下，辅助栈远小于主栈。</li>
</ul>
</li>
</ul>
<p>这种“以空间换时间”的策略，在现代计算环境中通常是值得的，尤其是当 <code>getMin</code> 被频繁调用时。</p>
<hr/>
<h3 data-id="heading-8">六、常见误区与注意事项</h3>
<ol>
<li><strong>比较条件必须包含等于（≥）</strong><br/>
若只在 <code>&lt;</code> 时入辅助栈，会导致重复最小值被错误忽略。例如 push(1), push(1)，若第二个 1 不入辅助栈，则第一次 pop 后辅助栈为空，无法正确返回最小值。</li>
<li><strong>出栈时要比较值，而非引用</strong><br/>
在 JavaScript 中，数字是原始类型，直接比较即可。但在其他语言中若使用对象，需注意相等性判断。</li>
<li><strong>辅助栈不是“所有历史最小值”，而是“当前有效最小值序列”</strong><br/>
它只保留那些在某个前缀中曾是最小值的元素，且按出现顺序排列。</li>
</ol>
<hr/>
<h3 data-id="heading-9">七、应用场景</h3>
<p>最小栈的设计思想不仅限于面试题，它在以下场景中也有实际价值：</p>
<ul>
<li>实时监控系统中的最低温度、最低价格、最低延迟；</li>
<li>算法竞赛中需要动态维护极值的栈结构；</li>
<li>编译器或解释器中对作用域变量的最小值追踪；</li>
<li>金融交易系统中对滑动窗口最小值的快速查询（结合双端队列可扩展）。</li>
</ul>
<hr/>
<h3 data-id="heading-10">结语</h3>
<p>最小栈通过引入一个辅助栈，巧妙地将“获取最小值”这一看似需要全局扫描的操作，转化为对栈顶元素的常数时间访问。这种设计体现了算法中经典的“空间换时间”思想，也展示了<strong>单调栈</strong>这一数据结构的强大能力。</p>
<p>理解最小栈的关键，在于把握“辅助栈与主栈的同步逻辑”——它不是简单复制，而是有选择地记录关键状态。掌握这一模式，不仅能解决最小栈问题，还能迁移到最大栈、滑动窗口最值、直方图最大矩形等更复杂的算法问题中。</p>
<p>在编程实践中，当我们面对“动态维护极值”的需求时，不妨思考：是否可以借助一个辅助结构，将 O(n) 降为 O(1)？答案往往就藏在像“最小栈”这样简洁而优雅的设计之中。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[iOS 性能优化的系统化路径 从渲染到系统行为的多工具协同优化实践]]></title>    <link>https://juejin.cn/post/7578499754553917491</link>    <guid>https://juejin.cn/post/7578499754553917491</guid>    <pubDate>2025-12-01T09:08:43.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7578499754553917491" data-draft-id="7578511778889465894" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="iOS 性能优化的系统化路径 从渲染到系统行为的多工具协同优化实践"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2025-12-01T09:08:43.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="bcbnb"/> <meta itemprop="url" content="https://juejin.cn/user/895474073078377"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            iOS 性能优化的系统化路径 从渲染到系统行为的多工具协同优化实践
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/895474073078377/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    bcbnb
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-01T09:08:43.000Z" title="Mon Dec 01 2025 09:08:43 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-01
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在移动应用体验竞争愈发激烈的今天，<strong>iOS 性能优化</strong> 已成为研发团队最重要的基础能力之一。无论是首屏加载、长列表滑动、动画体验、Hybrid 页面、后台任务还是弱网场景，性能问题往往来自多个维度交织：CPU、GPU、内存、网络、JS、系统限制、架构设计等。</p>
<p>因此，工程级性能优化不是“随缘调试”，也不是“凭感觉优化”，而是依赖一整套 <strong>工具链 + 监控链路 + 分析方法</strong> 的体系化能力。</p>
<p>本文基于真实 iOS 工程经验，不依赖外部搜索、不采用广告语气，将结合组件化架构下常见痛点，构建一套由 <strong>Instruments、克魔（KeyMob）、PerfDog、Safari Inspector、Charles、MetricKit、Crashlytics</strong> 组成的高效 iOS 性能优化流程。</p>
<hr/>
<h2 data-id="heading-0">一、性能优化为什么必须是体系而不是“单点优化”？</h2>
<p>在过去的开发模式中，许多团队认为性能优化属于“上线前再改一改”的事情。然而随着 iOS 生态复杂度增加，性能问题已成为：</p>
<h3 data-id="heading-1"><strong>多维度、多入口的系统性问题：</strong></h3>
<h3 data-id="heading-2"><strong>1. CPU 问题</strong></h3>
<ul>
<li>JSON 解码阻塞主线程</li>
<li>模型映射过重</li>
<li>复杂布局同步计算</li>
</ul>
<h3 data-id="heading-3"><strong>2. GPU 问题</strong></h3>
<ul>
<li>不必要的离屏渲染</li>
<li>图片过大</li>
<li>视图层级过深</li>
</ul>
<h3 data-id="heading-4"><strong>3. 内存问题</strong></h3>
<ul>
<li>图片未释放</li>
<li>控制器泄漏</li>
<li>WebView 占用过大</li>
</ul>
<h3 data-id="heading-5"><strong>4. 网络问题</strong></h3>
<ul>
<li>接口超时</li>
<li>图片加载等待过长</li>
<li>重定向过多</li>
</ul>
<h3 data-id="heading-6"><strong>5. Web / JS 问题</strong></h3>
<ul>
<li>大量 DOM</li>
<li>JS 长任务阻塞</li>
<li>WebView 重建频繁</li>
</ul>
<h3 data-id="heading-7"><strong>6. 系统行为问题</strong></h3>
<ul>
<li>watchdog（主线程卡死）</li>
<li>jetsam（内存压力杀进程）</li>
<li>温度限制</li>
</ul>
<p>这些问题往往互相影响，必须使用多工具协同定位。</p>
<hr/>
<h2 data-id="heading-8">二、Instruments：性能优化的底层入口工具</h2>
<p>Instruments 是任何 iOS 性能优化的起点。</p>
<h3 data-id="heading-9"><strong>1. Time Profiler（CPU）</strong></h3>
<p>用于定位：</p>
<ul>
<li>主线程繁忙程度</li>
<li>重度耗时方法</li>
<li>GCD 队列表现</li>
</ul>
<p>适用于解决：</p>
<ul>
<li>页面卡顿</li>
<li>点击延迟</li>
<li>JSON 解析阻塞</li>
</ul>
<h3 data-id="heading-10"><strong>2. Core Animation（渲染优化）</strong></h3>
<p>能够看到：</p>
<ul>
<li>GPU 占用</li>
<li>离屏渲染</li>
<li>帧率变化</li>
</ul>
<p>适用于：</p>
<ul>
<li>动画关键帧掉帧</li>
<li>页面滑动不流畅</li>
</ul>
<h3 data-id="heading-11"><strong>3. Memory（Leaks + Allocations）</strong></h3>
<p>可定位：</p>
<ul>
<li>对象泄漏</li>
<li>内存膨胀</li>
<li>retain cycle</li>
</ul>
<p>Instruments 用于“深层定位”，但它不适合长时间测试或真机压力场景。</p>
<hr/>
<h2 data-id="heading-12">三、克魔（KeyMob）：系统行为 + 性能监控的真机优化核心</h2>
<p>KeyMob 在性能优化体系中负责“<strong>真实场景可观测性</strong>”。</p>
<h3 data-id="heading-13"><strong>1. 高频性能指标监控</strong></h3>
<p>包括：</p>
<ul>
<li>CPU / GPU（实时）</li>
<li>FPS（流畅度）</li>
<li>内存曲线</li>
<li>网络吞吐</li>
<li>电量消耗 / 温度</li>
</ul>
<p>适合：</p>
<ul>
<li>回归测试性能对比</li>
<li>长时间运行</li>
<li>复杂交互场景压力测试</li>
</ul>
<h3 data-id="heading-14"><strong>2. 系统日志（Device Logs）</strong></h3>
<p>这是优化的关键补充，常见日志包括：</p>
<pre><code class="hljs language-vbnet" lang="vbnet"><span class="hljs-symbol">watchdog:</span> main-thread blocked  
<span class="hljs-symbol">jetsam_event:</span> high memory pressure  
<span class="hljs-symbol">thermal:</span> CPU throttled  
WebKit crash  
permission denied  
disk I/O <span class="hljs-keyword">error</span>  
</code></pre>
<p><strong>许多“无法复现的性能问题”其实是系统日志给的答案。</strong></p>
<h3 data-id="heading-15"><strong>3. 沙盒数据定位 I/O 性能问题</strong></h3>
<p>例如：</p>
<ul>
<li>大文件写入阻塞 UI</li>
<li>Incorrect cache policy</li>
<li>数据库未关闭导致文件句柄过高</li>
</ul>
<p>这些都是性能问题常见根因。</p>
<hr/>
<h2 data-id="heading-16">四、PerfDog：适合渲染性能与帧率优化的工具</h2>
<p>PerfDog 在 iOS 性能优化中最擅长处理：</p>
<ul>
<li>列表滑动不流畅</li>
<li>首页动画卡顿</li>
<li>游戏/Unity/Flutter 渲染压力</li>
<li>视频播放掉帧</li>
<li>高频刷新 UI</li>
</ul>
<h3 data-id="heading-17">可提供：</h3>
<ul>
<li>毫秒级 FPS</li>
<li>掉帧点（聚合）</li>
<li>CPU/GPU 趋势</li>
<li>内存上升趋势</li>
<li>温度 / 电流变化</li>
</ul>
<p>在做 FPS 优化时，PerfDog + Instruments 是标配组合。</p>
<hr/>
<h2 data-id="heading-18">五、Safari Inspector：Hybrid 与 Web 性能的核心调试工具</h2>
<p>大量 App 已经包含 Hybrid、活动页、uni-app、小程序容器。</p>
<p>Safari Inspector 能查看：</p>
<h3 data-id="heading-19"><strong>1. JS 性能问题</strong></h3>
<ul>
<li>JS 长任务</li>
<li>Promise 堆积</li>
<li>大量 Bridge 调用</li>
</ul>
<h3 data-id="heading-20"><strong>2. DOM 性能问题</strong></h3>
<ul>
<li>过多的节点</li>
<li>多次重排（reflow）</li>
<li>多次重绘（repaint）</li>
</ul>
<h3 data-id="heading-21"><strong>3. 资源加载问题</strong></h3>
<ul>
<li>H5 首屏耗时大</li>
<li>WebView 加载慢</li>
<li>大图导致性能下降</li>
</ul>
<p>在 Hybrid 项目中 Safari Inspector 是性能优化的主力工具。</p>
<hr/>
<h2 data-id="heading-22">六、Charles：网络性能瓶颈的定位工具</h2>
<p>网络是性能问题最常见的根源之一。</p>
<h3 data-id="heading-23">Charles 可分析：</h3>
<ul>
<li>接口响应速度</li>
<li>大 JSON 返回</li>
<li>重定向导致卡顿</li>
<li>弱网行为</li>
<li>无缓存策略导致资源重复请求</li>
</ul>
<p>非常适合用于：</p>
<ul>
<li>首屏优化</li>
<li>内容流列表加载优化</li>
<li>图片懒加载策略设计</li>
</ul>
<hr/>
<h2 data-id="heading-24">七、MetricKit：iOS 官方的“系统级”性能数据来源</h2>
<p>MetricKit 提供非常关键的性能指标：</p>
<ul>
<li>页面启动时间</li>
<li>内存峰值</li>
<li>jetsam（OOM）类型</li>
<li>CPU 时间占用</li>
<li>磁盘 I/O</li>
<li>hang diagnostics（卡顿诊断）</li>
<li>温度限制</li>
</ul>
<p>它能让团队知道：</p>
<ul>
<li>性能问题是否只在某些机型上出现</li>
<li>哪些版本性能退化</li>
<li>哪些场景导致过多系统资源占用</li>
</ul>
<p>适用于线上性能监控。</p>
<hr/>
<h2 data-id="heading-25">八、Crashlytics：线上性能异常与卡顿日志的重要补充</h2>
<p>Crashlytics 提供：</p>
<ul>
<li>崩溃堆栈</li>
<li>卡顿、主线程阻塞趋势</li>
<li>用户行为路径</li>
<li>线程 trace</li>
</ul>
<p>尤其适合定位“线上真实场景性能异常”。</p>
<hr/>
<h2 data-id="heading-26">九、性能优化的标准工具协同体系</h2>













































<table><thead><tr><th>性能类型</th><th>工具组合</th><th>解决问题</th></tr></thead><tbody><tr><td>CPU 优化</td><td>Instruments + KeyMob</td><td>主线程阻塞、重度计算</td></tr><tr><td>GPU 优化</td><td>Instruments（Core Animation）+ PerfDog</td><td>渲染压力、动画掉帧</td></tr><tr><td>内存优化</td><td>Instruments（Leaks/Allocations）+ KeyMob</td><td>泄漏、内存膨胀、OOM</td></tr><tr><td>网络优化</td><td>Charles + Safari Inspector</td><td>首屏慢、接口慢、大图问题</td></tr><tr><td>Hybrid 优化</td><td>Safari Inspector + KeyMob</td><td>DOM/JS 性能、WebView 崩溃</td></tr><tr><td>真机回归测试</td><td>KeyMob + PerfDog</td><td>长时间性能表现</td></tr><tr><td>上线性能 &amp; 稳定性</td><td>MetricKit + Crashlytics</td><td>启动慢、OOM、卡顿</td></tr></tbody></table>
<p>这是覆盖 iOS 性能优化常见问题的完整工具矩阵。</p>
<hr/>
<h2 data-id="heading-27">iOS 性能优化是一套系统性的工程</h2>
<p>真正成熟的 iOS 性能优化体系必须建立在：</p>
<p><strong>数据可观测 → 问题可定位 → 优化可验证 → 上线可回归</strong></p>
<p>这依赖于以下工具协作：</p>
<ul>
<li><strong>Instruments</strong>（底层分析）</li>
<li><strong>KeyMob</strong>（真机监控 + 系统日志）</li>
<li><strong>PerfDog</strong>（FPS &amp; 渲染性能）</li>
<li><strong>Charles</strong>（网络）</li>
<li><strong>Safari Inspector</strong>（Hybrid）</li>
<li><strong>MetricKit + Crashlytics</strong>（线上性能趋势）</li>
</ul>
<p>当这些工具协同工作，你的性能优化将变得可控、可维护、可复现。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[判断dom元素是否在可视区域的常规方式]]></title>    <link>https://juejin.cn/post/7578667193320767551</link>    <guid>https://juejin.cn/post/7578667193320767551</guid>    <pubDate>2025-12-01T09:08:45.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7578667193320767551" data-draft-id="7577171133432479785" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="判断dom元素是否在可视区域的常规方式"/> <meta itemprop="keywords" content="前端,JavaScript,面试"/> <meta itemprop="datePublished" content="2025-12-01T09:08:45.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="拉不动的猪"/> <meta itemprop="url" content="https://juejin.cn/user/1429793504759630"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            判断dom元素是否在可视区域的常规方式
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1429793504759630/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    拉不动的猪
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-01T09:08:45.000Z" title="Mon Dec 01 2025 09:08:45 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-01
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{position:relative;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:30px;margin-bottom:5px}.markdown-body h2{font-size:24px;display:inline-block;font-weight:700;background:#ef7060;color:#fff;padding:6px 8px 0 0;border-top-right-radius:6px;margin-right:2px;box-shadow:6px 3px 0 0 rgba(239,112,96,.2)}.markdown-body h2:before{content:" ";display:inline-block;width:8px}.markdown-body h2:after{content:" ";position:absolute;display:block;width:calc(100% - 50px);border-bottom:3px solid #ef7060}.markdown-body h3{font-size:18px;padding-bottom:0}.markdown-body h4{font-size:16px}.markdown-body h5{font-size:15px}.markdown-body h6{margin-top:5px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #3e3e3e;margin-top:32px;margin-bottom:32px;height:1px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:rgba(27,31,35,.05);color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:JetBranins Mono,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75;box-shadow:0 0 8px hsla(0,0%,43.1%,.45);border-radius:4px;margin:16px}.markdown-body pre:before{content:"";display:block;height:30px;width:100%;margin-bottom:-7px;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAdCAYAAABcz8ldAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAhgSURBVGhD7Zp7bBTHHcdn33t7vvOdzy+ITVKDU0xIKG2ABCPTRCCaUiEVKWoqRJuASAhCitRCVKSoalFUKZBiSmmFRRJKRUnUtIpo+aNqGgwoOCmuFUIRzxjwE4zte+97drYzztji8HPvtkit/PnH+n1397Tz+83vN/PbMZhmmmmm+d+BoX8n5diihcGqgFQf5vk6BMAskWUlw3GyFnIvtqWSf91w7mKC3npfOLX7wYeiIa6BBWCOLLFRF2NB0JvIOP/80YG+k2ev6S699b/OzOfKBW5l5KsgyC4DCFQDnpEAdE1goc/dlNPc/Up7P711UiYNSMuyxeUzZPnHgGHWh5XADEkSAcdiN+AnEXIBhBComgFU0/xQR+jnj51sOUMf9Z0NKyL8S9+JPBEN8zuCMrsqGOA5QWAAyzLAxe53HBeYFgJp1c5Cx33nyIfpV3e+22/Sx32nev/sMCgVnmM4bjOniAtZWQAsz315EfsGQQc4hgWcjHkCmOj1rheuNn95cXwmDMiVp5etC/D8m5FwUWVQUYYGPh6mZYFUOgsGVa1pXvOZzVT2jRuH54RM230jEuI3RcIiL4l4UkxAJmuD/riVsqD7ct2m9nep7BtVTbVfZ0uE/UIk+CQflAHDjf8+Lg6MldYATGpH3c/Ul7p3dWXppVGM6eElJSHmnQWPbSlRlN1lJcUBjqNRnwJZVQO3B5P/uq5rK1d90pakckFcaKp5UJHY92JR8YlwkUDVySEZfGfQdO7E7Z8s2HL9TSoXTPXRud9nA8IBqSwcZgWeqpPj6BYw7yTbXBN9q2v9lQEq5zBmWA8vWLCptCi4tzwW8RQMQlFQATPLSh6vCSh/plJBkMyQBHZfWYnkKRgEktEVpTJXERN2Xzo4ex2VC6K6qXYpF5b3ypVRT8EgcAERSJXRbwCBOTFzXblM5RxGBaRt+ZPYA+LO0mgxz5K1Ig+UgAzKIuGnz39z6S+olDeaibaXRsU1RUFvgx+GwTWgPCaDgMw2XXpr9gwq50XV0bkxJiYeEiNF5cwE5XsiOEkAUkXkUW51SSOVchjl8WKef604XFSRbzCGCYeCoESStv/p8QU1VPIM3knNDynctnBRfsEYhgSlNCIGgQv2UCkvGIHZgteMh1nBW9W4F16RAM6yDVV7amZTaYQcr59cuuhhWRTWBvAMLxQGeyFSHOLnh0MvUskz5RF+fbRYDEy0mZgqQYUHOLhr//b6rGoqeaLqQG0pw3PrBbyA+4EQUkRmhvgqNUfICUipKK4OKUqIJVPKB0jpEhjmWWp64jdbKmVZZNYogcJm493gsifOqhDyeh9GYR/FM7sW+DA5CKR0MSK3tvKZkpwB5gRE4tjFEr7RL0iWBGV51vHFCyupNGWWPqLgnoer9mtyEGSJAzwLllDTGzyznDjRN/CwOFkoFb4bm0eVIXICgpvdGoEvrF7fC89zfLkkeV5HbOhWiTwTpKYvCAJLGshRdXtKMKAWlyxq+MPQLk1h66g5RE5ABJYNFrqY3wvJklJRUKg5ZWLFXIA86yek2uDOPkBNb3CM5Pf7DL2QyIrUGiLH+xC5Bmmm/ARnHUhC6PnzxWDK0RH5HuIjZGy27erU9AZ0dTIWXyG+NpBBrSFySxZw220IqeUPFoS6jVAPNadM7yDsgNB1qOkLuAziMYIb1PQGA75wIaKGPyAb+9oF16g5RE5ALIQ+tSyLWoWDEAK6aXW3JlK9VJoyx1oyvVkNdvo5KXXDAVkdnaKmNwx0xjH98w3JNmTCm+Bc9hKVhsgJSI9pvp9Vdd++jmq6AXB2/HHrhcs5aTkVDv0DFzoHvKdq/mQsKX/4t7KJLDpOJW+IbAvMGoMkxfwAWZB8DT7W1diTE+WcgKz6pK1bs6z3daPwmJDsSKt6ZsCyjlLJMz0DsDGZ8SdlDROBjOb8YeWOjptU8kTXusuaazu7oJrfEnQvdkpVcUn6PTVHyAkIIW7br/Unklni0EJIZ1WgGsauZR+fvUglz6zY0dGfVp09ybRNlfwgi3k8YSbvJJ29VMoLt9v6rZVQL7hOYUubndHJGclBtzn1byqNMCogi09/2nFb01/oj+f/5TyjauBOKtPcZ1r7qZQ3f2lRfxZPWi2anp8TSDAGExZMa2jr8u03L1M5L7q3Xc+iAeuHRl/ScvPcjSLDBnZS/cjtNHd2v3171Ewbs9N5q7Pn4otVMx3btBsCsoRbk1FxG5dMVgMDqfTpXl1/tuFMa5zKefPROdX59qLQBwLnNog8Wy1OcjB1N+QEsW/QsFNZuO35Xb1v98QLX4/Sx+O3wqujrQ6013ABUWI8+AaqBjAH01+ghL22+5X2PirnMG7r+esbnae/V1neauvGSoHjigTcVU7UGFm2DeK4ttxKpQ+mLPvl+o/PjnkAkw9HTqSMmVHhyAMx9iFcSh/BHTfLceO/C8mKjApBf9zszGhoY92m9sN+BGOY9AeD7eGniv8OTaOB4dgyTsQd9wS+IQu4lciYdkI7CLrNH3Rvbb9FL41i0tbzVP2iWJkobpN5fmM4IJfJskTP1Bk8A9HQmbpmGDBrWqdVCN/Yd7PjxKGOXn+bmbto3feVVcVB9qehIL8EJy8nChwgr0O2xxBnhGU5eP2CfYbl/m4gBRsbtneMORP9oGpjpcCsiKzHHfdOPiQ/wMniyFEu2dbiTQCAeN/vavC466BGYLttXc9fmXBXMGlAhiHHur+sq6uPiUI9z7CVHMPwBnLSuuN8FuC48/Oaz1ylt94XfrW5ouyprwWfYRkwNyCyYYjwkBHows1fa+tV/fzGxlv39b9gqvfPmQ+i/HK8KlcBjhHwfl8HEHyOd1JnuzZd66S3TTPNNNP8/wDAfwDG7G0m9LKBpwAAAABJRU5ErkJggg==) 10px 10px no-repeat;background-size:40px;background-color:#fdfdfd}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#fdfdfd}.markdown-body a{text-decoration:none;font-weight:700;color:#ef7060;border-bottom:1px solid #ef7060}.markdown-body a:active,.markdown-body a:hover{color:#ef2d26}.markdown-body table tr td,.markdown-body table tr th{border:1px solid #ccc;padding:5px 10px}.markdown-body table{display:block!important;width:auto;max-width:100%;overflow:auto;border-collapse:collapse}.markdown-body thead{background:#f0f0f0;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#f8f8f8}.markdown-body blockquote{margin-inline-start:0;margin-inline-end:0;border-left:3px solid #ef7060;background:#fff9f9;padding:1px 20px;margin-top:20px}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="a11y-dark">.hljs-comment,.hljs-quote{color:#d4d0ab}.hljs-deletion,.hljs-name,.hljs-regexp,.hljs-selector-class,.hljs-selector-id,.hljs-tag,.hljs-template-variable,.hljs-variable{color:#ffa07a}.hljs-built_in,.hljs-builtin-name,.hljs-link,.hljs-literal,.hljs-meta,.hljs-number,.hljs-params,.hljs-type{color:#f5ab35}.hljs-attribute{color:gold}.hljs-addition,.hljs-bullet,.hljs-string,.hljs-symbol{color:#abe338}.hljs-section,.hljs-title{color:#00e0e0}.hljs-keyword,.hljs-selector-tag{color:#dcc6e0}.markdown-body pre,.markdown-body pre&gt;code.hljs{background:#2b2b2b;color:#f8f8f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}@media screen and (-ms-high-contrast:active){.hljs-addition,.hljs-attribute,.hljs-built_in,.hljs-builtin-name,.hljs-bullet,.hljs-comment,.hljs-link,.hljs-literal,.hljs-meta,.hljs-number,.hljs-params,.hljs-quote,.hljs-string,.hljs-symbol,.hljs-type{color:highlight}.hljs-keyword,.hljs-selector-tag{font-weight:700}}</style><h2 data-id="heading-0">1. Intersection Observer API（推荐）</h2>
<p>这是现代浏览器推荐的方法，性能最好，异步执行，不会阻塞主线程。</p>
<h3 data-id="heading-1">基础用法</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 创建观察器</span>
<span class="hljs-keyword">const</span> observer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntersectionObserver</span>(<span class="hljs-function">(<span class="hljs-params">entries</span>) =&gt;</span> {
  entries.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">entry</span> =&gt;</span> {
    <span class="hljs-keyword">if</span> (entry.<span class="hljs-property">isIntersecting</span>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'元素进入可视区域'</span>, entry.<span class="hljs-property">target</span>);
      <span class="hljs-comment">// 可以在这里执行懒加载等操作</span>
      entry.<span class="hljs-property">target</span>.<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">'visible'</span>);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'元素离开可视区域'</span>, entry.<span class="hljs-property">target</span>);
      entry.<span class="hljs-property">target</span>.<span class="hljs-property">classList</span>.<span class="hljs-title function_">remove</span>(<span class="hljs-string">'visible'</span>);
    }
  });
});

<span class="hljs-comment">// 观察元素</span>
<span class="hljs-keyword">const</span> elements = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">'.watch-element'</span>);
elements.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">el</span> =&gt;</span> observer.<span class="hljs-title function_">observe</span>(el));
</code></pre>
<h3 data-id="heading-2">高级配置</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> options = {
  <span class="hljs-comment">// root: 指定根元素，默认为浏览器视窗</span>
  <span class="hljs-attr">root</span>: <span class="hljs-literal">null</span>, <span class="hljs-comment">// 或者指定特定元素，如 document.querySelector('.container')</span>
  
  <span class="hljs-comment">// rootMargin: 根的外边距，可以扩大或缩小根的边界框</span>
  <span class="hljs-attr">rootMargin</span>: <span class="hljs-string">'10px 0px -100px 0px'</span>, <span class="hljs-comment">// 上右下左，类似CSS margin</span>
  
  <span class="hljs-comment">// threshold: 触发回调的可见比例</span>
  <span class="hljs-attr">threshold</span>: [<span class="hljs-number">0</span>, <span class="hljs-number">0.25</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.75</span>, <span class="hljs-number">1</span>] <span class="hljs-comment">// 在0%, 25%, 50%, 75%, 100%可见时触发</span>
};

<span class="hljs-keyword">const</span> observer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntersectionObserver</span>(<span class="hljs-function">(<span class="hljs-params">entries</span>) =&gt;</span> {
  entries.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">entry</span> =&gt;</span> {
    <span class="hljs-keyword">const</span> visiblePercentage = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>(entry.<span class="hljs-property">intersectionRatio</span> * <span class="hljs-number">100</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`元素可见 <span class="hljs-subst">${visiblePercentage}</span>%`</span>);
    
    <span class="hljs-comment">// 根据可见比例执行不同操作</span>
    <span class="hljs-keyword">if</span> (entry.<span class="hljs-property">intersectionRatio</span> &gt; <span class="hljs-number">0.5</span>) {
      <span class="hljs-comment">// 超过50%可见</span>
      entry.<span class="hljs-property">target</span>.<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">'mostly-visible'</span>);
    }
  });
}, options);
</code></pre>
<h3 data-id="heading-3">实用工具函数</h3>
<pre><code class="hljs language-ini" lang="ini">// 封装的工具函数
function createVisibilityObserver(<span class="hljs-attr">options</span> = {}) {
  const <span class="hljs-attr">defaultOptions</span> = {
    root: null,
    rootMargin: '0px',
    threshold: 0.1
  }<span class="hljs-comment">;</span>
  
  const <span class="hljs-attr">finalOptions</span> = { ...defaultOptions, ...options }<span class="hljs-comment">;</span>
  
  return new IntersectionObserver((entries) =&gt; {
    entries.forEach(<span class="hljs-attr">entry</span> =&gt; {
      const <span class="hljs-attr">element</span> = entry.target<span class="hljs-comment">;</span>
      const <span class="hljs-attr">isVisible</span> = entry.isIntersecting<span class="hljs-comment">;</span>
      
      // 触发自定义事件
      element.dispatchEvent(new CustomEvent('visibilityChange', {
        detail: { isVisible, entry }
      }))<span class="hljs-comment">;</span>
    })<span class="hljs-comment">;</span>
  }, finalOptions)<span class="hljs-comment">;</span>
}

// 使用示例
const <span class="hljs-attr">observer</span> = createVisibilityObserver({ threshold: <span class="hljs-number">0.5</span> })<span class="hljs-comment">;</span>

document.querySelectorAll('.lazy-load').forEach(<span class="hljs-attr">element</span> =&gt; {
  observer.observe(element)<span class="hljs-comment">;</span>
  
  element.addEventListener('visibilityChange', (e) =&gt; {
    if (e.detail.isVisible) {
      // 执行懒加载
      const <span class="hljs-attr">img</span> = element.querySelector(<span class="hljs-string">'img[data-src]'</span>)<span class="hljs-comment">;</span>
      if (img) {
        <span class="hljs-attr">img.src</span> = img.dataset.src<span class="hljs-comment">;</span>
        img.removeAttribute('data-src')<span class="hljs-comment">;</span>
      }
    }
  })<span class="hljs-comment">;</span>
})<span class="hljs-comment">;</span>
</code></pre>
<h2 data-id="heading-4">2. getBoundingClientRect() 方法</h2>
<p>传统方法，同步执行，需要手动调用。</p>
<h3 data-id="heading-5">基础用法</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isInViewport</span>(<span class="hljs-params">element</span>) {
  <span class="hljs-keyword">const</span> rect = element.<span class="hljs-title function_">getBoundingClientRect</span>();
  <span class="hljs-keyword">const</span> windowHeight = <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span> || <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">clientHeight</span>;
  <span class="hljs-keyword">const</span> windowWidth = <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span> || <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">clientWidth</span>;
  
  <span class="hljs-keyword">return</span> (
    rect.<span class="hljs-property">top</span> &gt;= <span class="hljs-number">0</span> &amp;&amp;
    rect.<span class="hljs-property">left</span> &gt;= <span class="hljs-number">0</span> &amp;&amp;
    rect.<span class="hljs-property">bottom</span> &lt;= windowHeight &amp;&amp;
    rect.<span class="hljs-property">right</span> &lt;= windowWidth
  );
}

<span class="hljs-comment">// 使用示例</span>
<span class="hljs-keyword">const</span> element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'.target'</span>);
<span class="hljs-keyword">if</span> (<span class="hljs-title function_">isInViewport</span>(element)) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'元素完全在视窗内'</span>);
}
</code></pre>
<h3 data-id="heading-6">部分可见判断</h3>
<pre><code class="hljs language-ini" lang="ini">function isPartiallyInViewport(element) {
  const <span class="hljs-attr">rect</span> = element.getBoundingClientRect()<span class="hljs-comment">;</span>
  const <span class="hljs-attr">windowHeight</span> = window.innerHeight || document.documentElement.clientHeight<span class="hljs-comment">;</span>
  const <span class="hljs-attr">windowWidth</span> = window.innerWidth || document.documentElement.clientWidth<span class="hljs-comment">;</span>
  
  return (
    rect.bottom &gt; 0 &amp;&amp;
    rect.top &lt; windowHeight &amp;&amp;
    rect.right &gt; 0 &amp;&amp;
    rect.left &lt; windowWidth
  )<span class="hljs-comment">;</span>
}

// 更详细的可见性信息
function getVisibilityInfo(element) {
  const <span class="hljs-attr">rect</span> = element.getBoundingClientRect()<span class="hljs-comment">;</span>
  const <span class="hljs-attr">windowHeight</span> = window.innerHeight<span class="hljs-comment">;</span>
  const <span class="hljs-attr">windowWidth</span> = window.innerWidth<span class="hljs-comment">;</span>
  
  // 计算可见区域
  const <span class="hljs-attr">visibleTop</span> = Math.max(<span class="hljs-number">0</span>, rect.top)<span class="hljs-comment">;</span>
  const <span class="hljs-attr">visibleLeft</span> = Math.max(<span class="hljs-number">0</span>, rect.left)<span class="hljs-comment">;</span>
  const <span class="hljs-attr">visibleBottom</span> = Math.min(windowHeight, rect.bottom)<span class="hljs-comment">;</span>
  const <span class="hljs-attr">visibleRight</span> = Math.min(windowWidth, rect.right)<span class="hljs-comment">;</span>
  
  const <span class="hljs-attr">visibleWidth</span> = Math.max(<span class="hljs-number">0</span>, visibleRight - visibleLeft)<span class="hljs-comment">;</span>
  const <span class="hljs-attr">visibleHeight</span> = Math.max(<span class="hljs-number">0</span>, visibleBottom - visibleTop)<span class="hljs-comment">;</span>
  const <span class="hljs-attr">visibleArea</span> = visibleWidth * visibleHeight<span class="hljs-comment">;</span>
  const <span class="hljs-attr">totalArea</span> = rect.width * rect.height<span class="hljs-comment">;</span>
  
  return {
    isVisible: visibleArea &gt; 0,
    isFullyVisible: isInViewport(element),
    visibilityRatio: totalArea &gt; 0 ? visibleArea / totalArea : 0,
    rect: rect,
    visibleArea: { width: visibleWidth, height: visibleHeight }
  }<span class="hljs-comment">;</span>
}

// 使用示例
const <span class="hljs-attr">element</span> = document.querySelector(<span class="hljs-string">'.target'</span>)<span class="hljs-comment">;</span>
const <span class="hljs-attr">info</span> = getVisibilityInfo(element)<span class="hljs-comment">;</span>
console.log(`可见比例: ${(info.visibilityRatio * 100).toFixed(2)}%`)<span class="hljs-comment">;</span>
</code></pre>
<h3 data-id="heading-7">滚动监听版本</h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ScrollVisibilityTracker</span> {
  <span class="hljs-keyword">constructor</span>(options = {}) {
    <span class="hljs-keyword">this</span>.elements = new Map();
    <span class="hljs-keyword">this</span>.threshold = options.threshold || <span class="hljs-number">0.1</span>;
    <span class="hljs-keyword">this</span>.throttleDelay = options.throttleDelay || <span class="hljs-number">100</span>;
    
    <span class="hljs-keyword">this</span>.checkVisibility = <span class="hljs-keyword">this</span>.throttle(<span class="hljs-keyword">this</span>.checkVisibility.bind(<span class="hljs-keyword">this</span>), <span class="hljs-keyword">this</span>.throttleDelay);
    <span class="hljs-keyword">this</span>.bindEvents();
  }
  
  observe(element, callback) {
    <span class="hljs-keyword">this</span>.elements.<span class="hljs-keyword">set</span>(element, {
      callback,
      wasVisible: <span class="hljs-literal">false</span>
    });
    
    <span class="hljs-comment">// 初始检查</span>
    <span class="hljs-keyword">this</span>.checkElement(element);
  }
  
  unobserve(element) {
    <span class="hljs-keyword">this</span>.elements.delete(element);
  }
  
  checkVisibility() {
    <span class="hljs-keyword">this</span>.elements.forEach((<span class="hljs-keyword">data</span>, element) =&gt; {
      <span class="hljs-keyword">this</span>.checkElement(element);
    });
  }
  
  checkElement(element) {
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">data</span> = <span class="hljs-keyword">this</span>.elements.<span class="hljs-keyword">get</span>(element);
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">data</span>) <span class="hljs-keyword">return</span>;
    
    <span class="hljs-keyword">const</span> info = getVisibilityInfo(element);
    <span class="hljs-keyword">const</span> isVisible = info.visibilityRatio &gt;= <span class="hljs-keyword">this</span>.threshold;
    
    <span class="hljs-keyword">if</span> (isVisible !== <span class="hljs-keyword">data</span>.wasVisible) {
      <span class="hljs-keyword">data</span>.wasVisible = isVisible;
      <span class="hljs-keyword">data</span>.callback(isVisible, info);
    }
  }
  
  bindEvents() {
    window.addEventListener(<span class="hljs-string">'scroll'</span>, <span class="hljs-keyword">this</span>.checkVisibility, { passive: <span class="hljs-literal">true</span> });
    window.addEventListener(<span class="hljs-string">'resize'</span>, <span class="hljs-keyword">this</span>.checkVisibility);
  }
  
  destroy() {
    window.removeEventListener(<span class="hljs-string">'scroll'</span>, <span class="hljs-keyword">this</span>.checkVisibility);
    window.removeEventListener(<span class="hljs-string">'resize'</span>, <span class="hljs-keyword">this</span>.checkVisibility);
    <span class="hljs-keyword">this</span>.elements.clear();
  }
  
  throttle(func, delay) {
    let timeoutId;
    let lastExecTime = <span class="hljs-number">0</span>;
    
    <span class="hljs-keyword">return</span> function (...args) {
      <span class="hljs-keyword">const</span> currentTime = Date.now();
      
      <span class="hljs-keyword">if</span> (currentTime - lastExecTime &gt; delay) {
        func.apply(<span class="hljs-keyword">this</span>, args);
        lastExecTime = currentTime;
      } <span class="hljs-keyword">else</span> {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() =&gt; {
          func.apply(<span class="hljs-keyword">this</span>, args);
          lastExecTime = Date.now();
        }, delay - (currentTime - lastExecTime));
      }
    };
  }
}

<span class="hljs-comment">// 使用示例</span>
<span class="hljs-keyword">const</span> tracker = new ScrollVisibilityTracker({ threshold: <span class="hljs-number">0.5</span> });

document.querySelectorAll(<span class="hljs-string">'.track-element'</span>).forEach(element =&gt; {
  tracker.observe(element, (isVisible, info) =&gt; {
    <span class="hljs-keyword">if</span> (isVisible) {
      element.classList.add(<span class="hljs-string">'in-view'</span>);
      console.log(<span class="hljs-string">'元素进入视窗'</span>, info);
    } <span class="hljs-keyword">else</span> {
      element.classList.remove(<span class="hljs-string">'in-view'</span>);
    }
  });
});
</code></pre>
<h2 data-id="heading-8">3. 特殊场景的解决方案</h2>
<h3 data-id="heading-9">在滚动容器中的元素</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isInScrollContainer</span>(<span class="hljs-params">element, container</span>) {
  <span class="hljs-keyword">const</span> elementRect = element.<span class="hljs-title function_">getBoundingClientRect</span>();
  <span class="hljs-keyword">const</span> containerRect = container.<span class="hljs-title function_">getBoundingClientRect</span>();
  
  <span class="hljs-keyword">return</span> (
    elementRect.<span class="hljs-property">top</span> &gt;= containerRect.<span class="hljs-property">top</span> &amp;&amp;
    elementRect.<span class="hljs-property">left</span> &gt;= containerRect.<span class="hljs-property">left</span> &amp;&amp;
    elementRect.<span class="hljs-property">bottom</span> &lt;= containerRect.<span class="hljs-property">bottom</span> &amp;&amp;
    elementRect.<span class="hljs-property">right</span> &lt;= containerRect.<span class="hljs-property">right</span>
  );
}

<span class="hljs-comment">// 使用Intersection Observer观察滚动容器</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">createContainerObserver</span>(<span class="hljs-params">container</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntersectionObserver</span>(<span class="hljs-function">(<span class="hljs-params">entries</span>) =&gt;</span> {
    entries.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">entry</span> =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'容器内元素可见性变化'</span>, entry.<span class="hljs-property">isIntersecting</span>);
    });
  }, {
    <span class="hljs-attr">root</span>: container, <span class="hljs-comment">// 指定容器为根元素</span>
    <span class="hljs-attr">threshold</span>: <span class="hljs-number">0.1</span>
  });
}
</code></pre>
<h3 data-id="heading-10">考虑CSS Transform的情况</h3>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-function">function <span class="hljs-title">getTransformedBounds</span><span class="hljs-params">(element)</span> </span>{
  <span class="hljs-type">const</span> rect = element.<span class="hljs-built_in">getBoundingClientRect</span>();
  
  <span class="hljs-comment">// 如果元素有CSS transform，getBoundingClientRect已经包含了变换后的位置</span>
  <span class="hljs-comment">// 不需要额外计算</span>
  <span class="hljs-keyword">return</span> rect;
}

<span class="hljs-comment">// 对于复杂的3D变换，可能需要更精确的计算</span>
<span class="hljs-function">function <span class="hljs-title">isTransformedElementVisible</span><span class="hljs-params">(element)</span> </span>{
  <span class="hljs-type">const</span> rect = element.<span class="hljs-built_in">getBoundingClientRect</span>();
  
  <span class="hljs-comment">// 检查元素是否因为transform: scale(0)等而不可见</span>
  <span class="hljs-type">const</span> computedStyle = <span class="hljs-built_in">getComputedStyle</span>(element);
  <span class="hljs-type">const</span> transform = computedStyle.transform;
  
  <span class="hljs-keyword">if</span> (transform === <span class="hljs-string">'none'</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">isPartiallyInViewport</span>(element);
  }
  
  <span class="hljs-comment">// 检查是否有scale(0)或类似的变换</span>
  <span class="hljs-keyword">if</span> (rect.width === <span class="hljs-number">0</span> || rect.height === <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }
  
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">isPartiallyInViewport</span>(element);
}
</code></pre>
<h2 data-id="heading-11">4. 性能优化技巧</h2>
<h3 data-id="heading-12">虚拟滚动场景</h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">VirtualScrollObserver</span> {
  <span class="hljs-keyword">constructor</span>(container, options = {}) {
    <span class="hljs-keyword">this</span>.container = container;
    <span class="hljs-keyword">this</span>.itemHeight = options.itemHeight || <span class="hljs-number">100</span>;
    <span class="hljs-keyword">this</span>.buffer = options.buffer || <span class="hljs-number">5</span>; <span class="hljs-comment">// 缓冲区项目数量</span>
    <span class="hljs-keyword">this</span>.items = [];
    <span class="hljs-keyword">this</span>.visibleRange = { start: <span class="hljs-number">0</span>, end: <span class="hljs-number">0</span> };
    
    <span class="hljs-keyword">this</span>.handleScroll = <span class="hljs-keyword">this</span>.throttle(<span class="hljs-keyword">this</span>.calculateVisibleRange.bind(<span class="hljs-keyword">this</span>), <span class="hljs-number">16</span>);
    <span class="hljs-keyword">this</span>.container.addEventListener(<span class="hljs-string">'scroll'</span>, <span class="hljs-keyword">this</span>.handleScroll);
  }
  
  calculateVisibleRange() {
    <span class="hljs-keyword">const</span> scrollTop = <span class="hljs-keyword">this</span>.container.scrollTop;
    <span class="hljs-keyword">const</span> containerHeight = <span class="hljs-keyword">this</span>.container.clientHeight;
    
    <span class="hljs-keyword">const</span> start = Math.max(<span class="hljs-number">0</span>, Math.floor(scrollTop / <span class="hljs-keyword">this</span>.itemHeight) - <span class="hljs-keyword">this</span>.buffer);
    <span class="hljs-keyword">const</span> end = Math.min(
      <span class="hljs-keyword">this</span>.items.length - <span class="hljs-number">1</span>,
      Math.ceil((scrollTop + containerHeight) / <span class="hljs-keyword">this</span>.itemHeight) + <span class="hljs-keyword">this</span>.buffer
    );
    
    <span class="hljs-keyword">if</span> (start !== <span class="hljs-keyword">this</span>.visibleRange.start || end !== <span class="hljs-keyword">this</span>.visibleRange.end) {
      <span class="hljs-keyword">this</span>.visibleRange = { start, end };
      <span class="hljs-keyword">this</span>.onVisibleRangeChange(<span class="hljs-keyword">this</span>.visibleRange);
    }
  }
  
  onVisibleRangeChange(range) {
    <span class="hljs-comment">// 子类实现或通过回调处理</span>
    console.log(<span class="hljs-string">'可见范围变化:'</span>, range);
  }
  
  throttle(func, delay) {
    let lastTime = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">return</span> function(...args) {
      <span class="hljs-keyword">const</span> now = Date.now();
      <span class="hljs-keyword">if</span> (now - lastTime &gt;= delay) {
        func.apply(<span class="hljs-keyword">this</span>, args);
        lastTime = now;
      }
    };
  }
}
</code></pre>
<h3 data-id="heading-13">懒加载图片完整实现</h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LazyImageLoader</span> {
  <span class="hljs-keyword">constructor</span>(options = {}) {
    <span class="hljs-keyword">this</span>.options = {
      rootMargin: <span class="hljs-string">'50px'</span>,
      threshold: <span class="hljs-number">0.1</span>,
      loadingClass: <span class="hljs-string">'lazy-loading'</span>,
      loadedClass: <span class="hljs-string">'lazy-loaded'</span>,
      errorClass: <span class="hljs-string">'lazy-error'</span>,
      ...options
    };
    
    <span class="hljs-keyword">this</span>.observer = new IntersectionObserver(
      <span class="hljs-keyword">this</span>.handleIntersection.bind(<span class="hljs-keyword">this</span>),
      {
        rootMargin: <span class="hljs-keyword">this</span>.options.rootMargin,
        threshold: <span class="hljs-keyword">this</span>.options.threshold
      }
    );
    
    <span class="hljs-keyword">this</span>.loadingImages = new Set();
  }
  
  observe(img) {
    <span class="hljs-keyword">if</span> (!(img instanceof HTMLImageElement)) {
      console.warn(<span class="hljs-string">'LazyImageLoader: 只能观察img元素'</span>);
      <span class="hljs-keyword">return</span>;
    }
    
    <span class="hljs-keyword">if</span> (!img.dataset.src &amp;&amp; !img.dataset.srcset) {
      console.warn(<span class="hljs-string">'LazyImageLoader: 图片缺少data-src或data-srcset属性'</span>);
      <span class="hljs-keyword">return</span>;
    }
    
    <span class="hljs-keyword">this</span>.observer.observe(img);
  }
  
  handleIntersection(entries) {
    entries.forEach(entry =&gt; {
      <span class="hljs-keyword">if</span> (entry.isIntersecting) {
        <span class="hljs-keyword">this</span>.loadImage(entry.target);
        <span class="hljs-keyword">this</span>.observer.unobserve(entry.target);
      }
    });
  }
  
  loadImage(img) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.loadingImages.has(img)) <span class="hljs-keyword">return</span>;
    
    <span class="hljs-keyword">this</span>.loadingImages.add(img);
    img.classList.add(<span class="hljs-keyword">this</span>.options.loadingClass);
    
    <span class="hljs-keyword">const</span> tempImg = new Image();
    
    tempImg.onload = () =&gt; {
      <span class="hljs-keyword">this</span>.applyImage(img, tempImg);
      img.classList.remove(<span class="hljs-keyword">this</span>.options.loadingClass);
      img.classList.add(<span class="hljs-keyword">this</span>.options.loadedClass);
      <span class="hljs-keyword">this</span>.loadingImages.delete(img);
    };
    
    tempImg.onerror = () =&gt; {
      img.classList.remove(<span class="hljs-keyword">this</span>.options.loadingClass);
      img.classList.add(<span class="hljs-keyword">this</span>.options.errorClass);
      <span class="hljs-keyword">this</span>.loadingImages.delete(img);
    };
    
    <span class="hljs-comment">// 支持srcset</span>
    <span class="hljs-keyword">if</span> (img.dataset.srcset) {
      tempImg.srcset = img.dataset.srcset;
    }
    tempImg.src = img.dataset.src;
  }
  
  applyImage(img, tempImg) {
    <span class="hljs-keyword">if</span> (img.dataset.srcset) {
      img.srcset = img.dataset.srcset;
      delete img.dataset.srcset;
    }
    img.src = tempImg.src;
    delete img.dataset.src;
  }
  
  destroy() {
    <span class="hljs-keyword">this</span>.observer.disconnect();
    <span class="hljs-keyword">this</span>.loadingImages.clear();
  }
}

<span class="hljs-comment">// 使用示例</span>
<span class="hljs-keyword">const</span> lazyLoader = new LazyImageLoader({
  rootMargin: <span class="hljs-string">'100px'</span>,
  threshold: <span class="hljs-number">0.1</span>
});

document.querySelectorAll(<span class="hljs-string">'img[data-src]'</span>).forEach(img =&gt; {
  lazyLoader.observe(img);
});
</code></pre>
<h2 data-id="heading-14">5. 兼容性处理</h2>
<pre><code class="hljs language-ini" lang="ini">// Intersection Observer polyfill检查
function createCompatibleObserver(callback, options) {
  if ('IntersectionObserver' in window) {
    return new IntersectionObserver(callback, options)<span class="hljs-comment">;</span>
  } else {
    console.warn('IntersectionObserver not supported, falling back to scroll listener')<span class="hljs-comment">;</span>
    return createScrollBasedObserver(callback, options)<span class="hljs-comment">;</span>
  }
}

function createScrollBasedObserver(callback, <span class="hljs-attr">options</span> = {}) {
  const <span class="hljs-attr">elements</span> = new Set()<span class="hljs-comment">;</span>
  const <span class="hljs-attr">threshold</span> = options.threshold || <span class="hljs-number">0</span><span class="hljs-comment">;</span>
  
  function checkElements() {
    const <span class="hljs-attr">entries</span> = []<span class="hljs-comment">;</span>
    
    elements.forEach(<span class="hljs-attr">element</span> =&gt; {
      const <span class="hljs-attr">info</span> = getVisibilityInfo(element)<span class="hljs-comment">;</span>
      const <span class="hljs-attr">isIntersecting</span> = info.visibilityRatio &gt;= threshold<span class="hljs-comment">;</span>
      
      entries.push({
        target: element,
        isIntersecting,
        intersectionRatio: info.visibilityRatio,
        boundingClientRect: info.rect
      })<span class="hljs-comment">;</span>
    })<span class="hljs-comment">;</span>
    
    if (entries.length &gt; 0) {
      callback(entries)<span class="hljs-comment">;</span>
    }
  }
  
  const <span class="hljs-attr">throttledCheck</span> = throttle(checkElements, <span class="hljs-number">100</span>)<span class="hljs-comment">;</span>
  
  window.addEventListener('scroll', throttledCheck, { passive: true })<span class="hljs-comment">;</span>
  window.addEventListener('resize', throttledCheck)<span class="hljs-comment">;</span>
  
  return {
    observe(element) {
      elements.add(element)<span class="hljs-comment">;</span>
      // 立即检查一次
      setTimeout(() =&gt; {
        const <span class="hljs-attr">info</span> = getVisibilityInfo(element)<span class="hljs-comment">;</span>
        const <span class="hljs-attr">isIntersecting</span> = info.visibilityRatio &gt;= threshold<span class="hljs-comment">;</span>
        callback(<span class="hljs-section">[{
          target: element,
          isIntersecting,
          intersectionRatio: info.visibilityRatio,
          boundingClientRect: info.rect
        }]</span>)<span class="hljs-comment">;</span>
      }, 0)<span class="hljs-comment">;</span>
    },
    
    unobserve(element) {
      elements.delete(element)<span class="hljs-comment">;</span>
    },
    
    disconnect() {
      window.removeEventListener('scroll', throttledCheck)<span class="hljs-comment">;</span>
      window.removeEventListener('resize', throttledCheck)<span class="hljs-comment">;</span>
      elements.clear()<span class="hljs-comment">;</span>
    }
  }<span class="hljs-comment">;</span>
}
</code></pre>
<h2 data-id="heading-15">总结</h2>
<p>选择合适的方法：</p>
<ol>
<li><strong>Intersection Observer API</strong> - 现代浏览器首选，性能最佳</li>
<li><strong>getBoundingClientRect + 滚动监听</strong> - 需要兼容老浏览器时使用</li>
<li><strong>虚拟滚动</strong> - 处理大量元素时的特殊优化</li>
</ol>
<p>关键考虑因素：</p>
<ul>
<li><strong>性能</strong>：Intersection Observer &gt; 节流的滚动监听 &gt; 频繁的滚动监听</li>
<li><strong>精确度</strong>：getBoundingClientRect更精确，但需要手动触发</li>
<li><strong>兼容性</strong>：getBoundingClientRect支持更老的浏览器</li>
<li><strong>功能需求</strong>：是否需要部分可见、可见比例等详细信息</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[海量数据集的AI自动化预测打标 -- 矿业音频分类]]></title>    <link>https://juejin.cn/post/7578699866181206054</link>    <guid>https://juejin.cn/post/7578699866181206054</guid>    <pubDate>2025-12-01T09:28:14.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7578699866181206054" data-draft-id="7578709098255056934" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="海量数据集的AI自动化预测打标 -- 矿业音频分类"/> <meta itemprop="keywords" content="算法"/> <meta itemprop="datePublished" content="2025-12-01T09:28:14.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="语落心生"/> <meta itemprop="url" content="https://juejin.cn/user/2875978147955741"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            海量数据集的AI自动化预测打标 -- 矿业音频分类
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2875978147955741/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    语落心生
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-01T09:28:14.000Z" title="Mon Dec 01 2025 09:28:14 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-01
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读13分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>两个月前公司有个AI标注的训练数据需求调研，正巧清华某个团队有此需求，于是进行合作。一共开源了三个模型的初版。记录下自己的实现</p>
<p>声音样本多标签预测 - 矿山矿业场景: <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FSTARTORUS%2Ftok-label%2Fpull%2F4" target="_blank" title="https://github.com/STARTORUS/tok-label/pull/4" ref="nofollow noopener noreferrer">github.com/STARTORUS/t…</a></p>
<hr/>
<h2 data-id="heading-0">概述：让AI听懂机器的"健康密码"</h2>
<p>想象一下，在一个庞大的矿山作业现场，几十台大型设备日夜运转——挖掘机、传送带、液压系统、电机……每台设备都在"说话"，发出各种声音。<strong>经验丰富的老师傅能通过听声音判断设备是否正常</strong>："这个轴承声音不对劲，可能要坏了""这个电机转速不稳"。</p>
<p><strong>矿业音频ML Backend</strong>就是将这种"听音辨机"的专家经验<strong>数字化、智能化</strong>，通过AI自动识别设备音频特征，预测设备状态、故障类型和维护优先级，实现<strong>预测性维护</strong>。</p>
<hr/>
<h2 data-id="heading-1">一、业务价值：Why - 为什么矿业需要音频智能诊断？</h2>
<h3 data-id="heading-2">1.1 行业痛点</h3>
<p>在矿业生产场景中，设备故障会带来巨大损失：</p>
<p><strong>场景1：突发故障停产</strong> ⚠️<br/>
某铁矿主传送带轴承突然损坏：</p>
<ul>
<li>生产线停工12小时</li>
<li>直接经济损失超过500万元</li>
<li>抢修成本是计划维护的3-5倍</li>
<li><strong>如果能提前3天预警，可避免90%损失</strong></li>
</ul>
<p><strong>场景2：过度维护浪费</strong> 💸<br/>
采用定期维护策略：</p>
<ul>
<li>按固定周期更换零件（如每3个月）</li>
<li>很多零件还能继续使用就被更换</li>
<li>维护成本高昂，资源浪费严重</li>
<li><strong>真正需要维护的设备却可能被忽略</strong></li>
</ul>
<p><strong>场景3：人工巡检效率低</strong> 🚶<br/>
传统巡检方式：</p>
<ul>
<li>工人每天巡检上百台设备</li>
<li>只能检查外观和简单读数</li>
<li>无法24小时监控</li>
<li>依赖个人经验，缺乏标准化</li>
</ul>
<h3 data-id="heading-3">1.2 ML Backend的价值</h3>
<p>矿业音频ML Backend通过<strong>声音指纹识别</strong>，实现：</p>
<p><strong>预测性维护</strong>：提前3-7天预警故障，避免突发停产<br/>
<strong>降低成本30%</strong>：从定期维护转向按需维护<br/>
<strong>24小时监控</strong>：AI不知疲倦，实时监测所有设备<br/>
<strong>标准化诊断</strong>：将专家经验固化为算法，减少人为误判</p>
<p><strong>ROI计算示例</strong>：</p>
<ul>
<li>投入：部署ML Backend系统 50万元</li>
<li>收益：年避免故障损失 200万 + 降低维护成本 80万 = 280万</li>
<li><strong>投资回报周期：2-3个月</strong></li>
</ul>
<hr/>
<h2 data-id="heading-4">二、系统架构：What - 矿业音频ML Backend是什么？</h2>
<h3 data-id="heading-5">2.1 整体架构</h3>
<pre><code class="hljs language-mermaid" lang="mermaid">graph TB
    subgraph "数据采集层"
        A1[音频采集设备] --&gt; A2[MinIO对象存储]
        A3[传感器数据] --&gt; A2
    end
    
    subgraph "Label Studio前端"
        B1[标注界面] --&gt; B2[任务管理]
    end
    
    subgraph "ML Backend核心层"
        C1[_wsgi.py服务入口] --&gt; C2[MiningAudioMLBackend&lt;br/&gt;业务编排]
        C2 --&gt; C3[AudioFeatureExtractor&lt;br/&gt;特征提取]
        C2 --&gt; C4[MiningAudioClassifier&lt;br/&gt;神经网络模型]
        C2 --&gt; C5[MinIODownloader&lt;br/&gt;数据下载]
    end
    
    subgraph "AI引擎层"
        D1[Librosa音频处理]
        D2[PyTorch深度学习]
        D3[标准化器StandardScaler]
    end
    
    subgraph "模型存储"
        E1[(预训练模型.pth)]
        E2[(特征标准化器.pkl)]
    end
    
    A2 --&gt;|S3 API| C5
    B2 --&gt;|HTTP API| C1
    C3 --&gt; D1
    C4 --&gt; D2
    C4 --&gt; D3
    C4 -.加载.-&gt; E1
    C3 -.加载.-&gt; E2
    
    style C2 fill:#4CAF50,color:#fff
    style C4 fill:#FF5722,color:#fff
    style D2 fill:#2196F3,color:#fff
</code></pre>
<h3 data-id="heading-6">2.2 核心组件剖析</h3>
<h4 data-id="heading-7">🎯 <strong>MiningAudioMLBackend</strong> - 业务编排中心</h4>
<p>这是整个系统的**"大脑"**，协调各个模块完成音频诊断：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MiningAudioMLBackend</span>(<span class="hljs-title class_ inherited__">LabelStudioMLBase</span>):
    <span class="hljs-string">"""矿业音频多标签分类ML后端"""</span>
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">setup</span>(<span class="hljs-params">self</span>):
        <span class="hljs-comment"># 初始化特征提取器</span>
        self.feature_extractor = AudioFeatureExtractor()
        
        <span class="hljs-comment"># 加载深度学习模型</span>
        self.model = MiningAudioClassifier(input_dim=<span class="hljs-number">72</span>)
        
        <span class="hljs-comment"># 初始化MinIO下载器(对接对象存储)</span>
        self.minio_downloader = MinIODownloader(...)
</code></pre>
<p><strong>设计亮点</strong>：</p>
<ul>
<li><strong>懒加载机制</strong>：只在第一次预测时初始化，加快启动速度</li>
<li><strong>状态管理</strong>：记录训练次数、模型版本等元信息</li>
<li><strong>异常隔离</strong>：预测失败不影响其他任务</li>
</ul>
<h4 data-id="heading-8">🔬 <strong>AudioFeatureExtractor</strong> - 音频特征工程专家</h4>
<p>这是系统的**"耳朵"**，将音频信号转换为机器可理解的特征向量：</p>
<p><strong>特征提取流程</strong>：</p>
<pre><code class="hljs language-mermaid" lang="mermaid">graph LR
    A[原始音频&lt;br/&gt;采样率25kHz] --&gt; B[时域特征&lt;br/&gt;ZCR/RMS]
    A --&gt; C[频域特征&lt;br/&gt;MFCC/频谱]
    
    B --&gt; D[统计量&lt;br/&gt;均值/标准差/最值]
    C --&gt; D
    
    D --&gt; E[72维特征向量]
    
    style A fill:#FFC107
    style E fill:#4CAF50,color:#fff
</code></pre>
<p><strong>详细特征说明</strong>：</p>















































<table><thead><tr><th>特征类别</th><th>特征名称</th><th>物理意义</th><th>故障诊断价值</th></tr></thead><tbody><tr><td><strong>时域</strong></td><td>过零率(ZCR)</td><td>信号正负交替频率</td><td>检测旋转设备转速异常</td></tr><tr><td>时域</td><td>能量(RMS)</td><td>信号幅值强度</td><td>识别振动强度变化</td></tr><tr><td><strong>频域</strong></td><td>MFCC(13维)</td><td>频谱包络特征</td><td>模拟人耳听觉,识别声纹</td></tr><tr><td>频域</td><td>频谱质心</td><td>频率分布中心</td><td>检测频率偏移(如轴承磨损)</td></tr><tr><td>频域</td><td>频谱滚降</td><td>高频能量占比</td><td>识别冲击性故障</td></tr><tr><td>频域</td><td>频谱带宽</td><td>频率分布范围</td><td>判断频谱复杂度</td></tr></tbody></table>
<p><strong>特征维度计算</strong>：</p>
<pre><code class="hljs language-scss" lang="scss">基础特征 = <span class="hljs-number">13</span>(MFCC) + <span class="hljs-number">1</span>(ZCR) + <span class="hljs-number">1</span>(RMS) + <span class="hljs-number">1</span>(质心) + <span class="hljs-number">1</span>(滚降) + <span class="hljs-number">1</span>(带宽) = <span class="hljs-number">18</span>
统计量 = <span class="hljs-number">4</span>种 (均值、标准差、最大值、最小值)
总维度 = <span class="hljs-number">18</span> × <span class="hljs-number">4</span> = <span class="hljs-number">72</span>维
</code></pre>
<p><strong>代码实现核心</strong>：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">extract_features</span>(<span class="hljs-params">self, audio_path</span>):
    <span class="hljs-comment"># 1. 加载音频(使用librosa统一接口)</span>
    y, sr = librosa.load(audio_path, sr=self.sample_rate)
    
    <span class="hljs-comment"># 2. 时域特征</span>
    zcr = librosa.feature.zero_crossing_rate(y, hop_length=<span class="hljs-number">512</span>)
    energy = librosa.feature.rms(y=y, hop_length=<span class="hljs-number">512</span>)
    
    <span class="hljs-comment"># 3. 频域特征</span>
    mfccs = librosa.feature.mfcc(y=y, sr=sr, n_mfcc=<span class="hljs-number">13</span>)
    spectral_centroid = librosa.feature.spectral_centroid(y=y, sr=sr)
    
    <span class="hljs-comment"># 4. 合并特征矩阵</span>
    features = np.vstack([mfccs, zcr, energy, ...])
    
    <span class="hljs-comment"># 5. 计算统计量</span>
    feature_stats = np.hstack([
        np.mean(features, axis=<span class="hljs-number">1</span>),  <span class="hljs-comment"># 均值</span>
        np.std(features, axis=<span class="hljs-number">1</span>),   <span class="hljs-comment"># 标准差</span>
        np.<span class="hljs-built_in">max</span>(features, axis=<span class="hljs-number">1</span>),   <span class="hljs-comment"># 最大值</span>
        np.<span class="hljs-built_in">min</span>(features, axis=<span class="hljs-number">1</span>)    <span class="hljs-comment"># 最小值</span>
    ])
    
    <span class="hljs-keyword">return</span> feature_stats  <span class="hljs-comment"># 返回72维向量</span>
</code></pre>
<h4 data-id="heading-9">🧠 <strong>MiningAudioClassifier</strong> - 深度神经网络</h4>
<p>这是系统的**"诊断医生"**，基于特征向量预测设备状态：</p>
<p><strong>网络架构</strong>：</p>
<pre><code class="hljs language-mermaid" lang="mermaid">graph TB
    A[输入层&lt;br/&gt;72维特征] --&gt; B[全连接层256]
    B --&gt; C[批归一化BN]
    C --&gt; D[ReLU激活]
    D --&gt; E[Dropout 0.3]
    
    E --&gt; F[全连接层128]
    F --&gt; G[批归一化BN]
    G --&gt; H[ReLU激活]
    H --&gt; I[Dropout 0.3]
    
    I --&gt; J[全连接层64]
    J --&gt; K[批归一化BN]
    K --&gt; L[ReLU激活]
    L --&gt; M[Dropout 0.3]
    
    M --&gt; N1[设备状态头&lt;br/&gt;3类]
    M --&gt; N2[故障类型头&lt;br/&gt;4类]
    M --&gt; N3[优先级头&lt;br/&gt;3类]
    
    N1 --&gt; O1[Sigmoid激活]
    N2 --&gt; O2[Sigmoid激活]
    N3 --&gt; O3[Sigmoid激活]
    
    style A fill:#FFC107
    style M fill:#4CAF50,color:#fff
    style O1 fill:#FF5722,color:#fff
    style O2 fill:#FF5722,color:#fff
    style O3 fill:#FF5722,color:#fff
</code></pre>
<p><strong>设计要点</strong>：</p>
<ol>
<li>
<p><strong>多标签分类</strong><br/>
不同于传统单标签分类，这里使用<strong>3个分类头</strong>：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 设备状态: normal/abnormal/maintenance_needed</span>
self.equipment_status_head = nn.Linear(<span class="hljs-number">64</span>, <span class="hljs-number">3</span>)

<span class="hljs-comment"># 故障类型: bearing/motor/hydraulic/belt</span>
self.fault_type_head = nn.Linear(<span class="hljs-number">64</span>, <span class="hljs-number">4</span>)

<span class="hljs-comment"># 优先级: low/medium/high</span>
self.priority_head = nn.Linear(<span class="hljs-number">64</span>, <span class="hljs-number">3</span>)
</code></pre>
</li>
<li>
<p><strong>批归一化(Batch Normalization)</strong></p>
<ul>
<li>加速训练收敛</li>
<li>提高模型泛化能力</li>
<li><strong>注意</strong>：推理时必须设置为eval模式！</li>
</ul>
</li>
<li>
<p><strong>Dropout正则化</strong></p>
<ul>
<li>防止过拟合</li>
<li>dropout率0.3（保留70%神经元）</li>
</ul>
</li>
<li>
<p><strong>Sigmoid激活</strong></p>
<ul>
<li>多标签场景下，每个标签独立判断</li>
<li>输出概率值0-1</li>
</ul>
</li>
</ol>
<h4 data-id="heading-10">📦 <strong>MinIODownloader</strong> - 数据桥接层</h4>
<p>对接MinIO对象存储，支持从S3 URL下载音频文件：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">_get_local_path_for_s3</span>(<span class="hljs-params">self, s3_url</span>):
    <span class="hljs-comment"># s3://bucket-name/path/to/audio.wav</span>
    
    <span class="hljs-comment"># 1. 生成本地缓存路径</span>
    cache_dir = user_cache_dir(<span class="hljs-string">'label-studio'</span>)
    url_hash = hashlib.md5(s3_url.encode()).hexdigest()[:<span class="hljs-number">6</span>]
    local_path = <span class="hljs-string">f"<span class="hljs-subst">{cache_dir}</span>/<span class="hljs-subst">{url_hash}</span>__<span class="hljs-subst">{filename}</span>"</span>
    
    <span class="hljs-comment"># 2. 下载文件</span>
    self._download_s3_file(s3_url, local_path)
    
    <span class="hljs-keyword">return</span> local_path
</code></pre>
<p><strong>设计亮点</strong>：</p>
<ul>
<li><strong>缓存机制</strong>：避免重复下载</li>
<li><strong>哈希命名</strong>：防止文件名冲突</li>
<li><strong>资源管理</strong>：正确关闭S3连接，避免内存泄漏</li>
</ul>
<hr/>
<h2 data-id="heading-11">三、技术实现：How - 诊断流程详解</h2>
<h3 data-id="heading-12">3.1 端到端预测流程</h3>
<pre><code class="hljs language-mermaid" lang="mermaid">sequenceDiagram
    participant LS as Label Studio
    participant Backend as MiningAudioMLBackend
    participant Downloader as MinIODownloader
    participant Extractor as AudioFeatureExtractor
    participant Model as MiningAudioClassifier
    participant MinIO as MinIO存储
    
    LS-&gt;&gt;Backend: 预测请求&lt;br/&gt;s3://audio-annotations/device1.wav
    Backend-&gt;&gt;Downloader: 解析S3 URL
    Downloader-&gt;&gt;MinIO: 下载音频文件
    MinIO--&gt;&gt;Downloader: 返回音频数据
    Downloader--&gt;&gt;Backend: 本地文件路径
    
    Backend-&gt;&gt;Extractor: 提取特征
    Extractor-&gt;&gt;Extractor: Librosa加载音频&lt;br/&gt;采样率25kHz
    Extractor-&gt;&gt;Extractor: 计算时域特征&lt;br/&gt;ZCR/RMS
    Extractor-&gt;&gt;Extractor: 计算频域特征&lt;br/&gt;MFCC/频谱
    Extractor-&gt;&gt;Extractor: 统计量聚合&lt;br/&gt;72维向量
    Extractor--&gt;&gt;Backend: 特征向量
    
    Backend-&gt;&gt;Backend: 特征标准化&lt;br/&gt;StandardScaler
    Backend-&gt;&gt;Model: 神经网络推理
    Model-&gt;&gt;Model: 前向传播
    Model--&gt;&gt;Backend: 多标签预测结果
    
    Backend-&gt;&gt;Backend: 格式化为Label Studio格式
    Backend--&gt;&gt;LS: 返回预测&lt;br/&gt;设备状态/故障类型/优先级
</code></pre>
<h3 data-id="heading-13">3.2 关键技术点</h3>
<h4 data-id="heading-14">技术点1：特征标准化</h4>
<p><strong>为什么需要标准化？</strong></p>
<p>不同特征的数值范围差异巨大：</p>
<ul>
<li>MFCC均值：-50 ~ +50</li>
<li>能量RMS：0.001 ~ 1.0</li>
<li>频谱质心：500 ~ 5000</li>
</ul>
<p><strong>如果不标准化</strong>，大数值特征会主导模型学习，小数值特征被忽略。</p>
<p><strong>StandardScaler原理</strong>：</p>
<pre><code class="hljs language-ini" lang="ini">标准化公式: <span class="hljs-attr">x_scaled</span> = (x - mean) / std

示例:
原始特征: <span class="hljs-section">[1000, 0.01, 50]</span>
均值:     <span class="hljs-section">[500, 0.005, 25]</span>
标准差:   <span class="hljs-section">[200, 0.003, 10]</span>
标准化后: <span class="hljs-section">[2.5, 1.67, 2.5]</span>  <span class="hljs-comment"># 数值范围统一</span>
</code></pre>
<p><strong>代码实现</strong>：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 训练时拟合标准化器</span>
self.scaler.fit(training_features)

<span class="hljs-comment"># 推理时使用</span>
features_scaled = self.scaler.transform(features)
</code></pre>
<h4 data-id="heading-15">技术点2：批归一化的陷阱</h4>
<p><strong>问题</strong>：推理时模型必须设置为<code>eval()</code>模式，否则报错</p>
<p><strong>原因</strong>：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 训练模式(training=True)</span>
<span class="hljs-comment"># BatchNorm使用当前batch的统计量</span>
mean_batch = current_batch.mean()
std_batch = current_batch.std()

<span class="hljs-comment"># 评估模式(training=False)  </span>
<span class="hljs-comment"># BatchNorm使用训练时的全局统计量</span>
mean_global = running_mean  <span class="hljs-comment"># 训练时累积</span>
std_global = running_std
</code></pre>
<p><strong>单样本推理问题</strong>：</p>
<ul>
<li>训练模式下，单样本batch的std=0</li>
<li>导致除零错误</li>
</ul>
<p><strong>解决方案</strong>：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 模型加载后立即设置为评估模式</span>
self.model.load_state_dict(torch.load(model_path))
self.model.<span class="hljs-built_in">eval</span>()  <span class="hljs-comment"># 关键！</span>

<span class="hljs-comment"># 推理时禁用梯度计算</span>
<span class="hljs-keyword">with</span> torch.no_grad():
    outputs = self.model(features)
</code></pre>
<h4 data-id="heading-16">技术点3：多标签预测</h4>
<p><strong>预测结果示例</strong>：</p>
<pre><code class="hljs language-python" lang="python">{
    <span class="hljs-string">'equipment_status'</span>: [
        {<span class="hljs-string">'label'</span>: <span class="hljs-string">'abnormal'</span>, <span class="hljs-string">'confidence'</span>: <span class="hljs-number">0.85</span>}
    ],
    <span class="hljs-string">'fault_type'</span>: [
        {<span class="hljs-string">'label'</span>: <span class="hljs-string">'bearing_fault'</span>, <span class="hljs-string">'confidence'</span>: <span class="hljs-number">0.72</span>},
        {<span class="hljs-string">'label'</span>: <span class="hljs-string">'motor_fault'</span>, <span class="hljs-string">'confidence'</span>: <span class="hljs-number">0.58</span>}
    ],
    <span class="hljs-string">'priority'</span>: [
        {<span class="hljs-string">'label'</span>: <span class="hljs-string">'high_priority'</span>, <span class="hljs-string">'confidence'</span>: <span class="hljs-number">0.91</span>}
    ]
}
</code></pre>
<p><strong>阈值策略</strong>：</p>
<pre><code class="hljs language-python" lang="python">threshold = <span class="hljs-number">0.5</span>  <span class="hljs-comment"># 置信度阈值</span>

<span class="hljs-keyword">for</span> category, logits <span class="hljs-keyword">in</span> outputs.items():
    probs = logits.cpu().numpy()[<span class="hljs-number">0</span>]  <span class="hljs-comment"># Sigmoid输出</span>
    
    predicted_labels = []
    <span class="hljs-keyword">for</span> i, prob <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(probs):
        <span class="hljs-keyword">if</span> prob &gt; threshold:  <span class="hljs-comment"># 超过阈值才认为是阳性</span>
            label_name = MINING_LABELS[category][i]
            predicted_labels.append({
                <span class="hljs-string">'label'</span>: label_name,
                <span class="hljs-string">'confidence'</span>: <span class="hljs-built_in">float</span>(prob)
            })
</code></pre>
<p><strong>多标签 vs 多分类的区别</strong>：</p>
<ul>
<li><strong>多分类</strong>：一个样本只属于一个类别（如猫/狗/鸟）</li>
<li><strong>多标签</strong>：一个样本可以同时属于多个标签（如"轴承故障+高优先级"）</li>
</ul>
<h3 data-id="heading-17">3.3 Label Studio格式转换</h3>
<p><strong>转换逻辑</strong>：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">_convert_to_labelstudio_format</span>(<span class="hljs-params">self, predictions, task_id</span>):
    results = []
    
    <span class="hljs-keyword">for</span> category, labels <span class="hljs-keyword">in</span> predictions.items():
        <span class="hljs-keyword">for</span> label_info <span class="hljs-keyword">in</span> labels:
            results.append({
                <span class="hljs-string">"from_name"</span>: <span class="hljs-string">f"mining_<span class="hljs-subst">{category}</span>"</span>,  <span class="hljs-comment"># 对应标注配置</span>
                <span class="hljs-string">"to_name"</span>: <span class="hljs-string">"audio"</span>,
                <span class="hljs-string">"type"</span>: <span class="hljs-string">"choices"</span>,
                <span class="hljs-string">"value"</span>: {
                    <span class="hljs-string">"choices"</span>: [label_info[<span class="hljs-string">'label'</span>]]
                },
                <span class="hljs-string">"score"</span>: label_info[<span class="hljs-string">'confidence'</span>]  <span class="hljs-comment"># 置信度</span>
            })
    
    <span class="hljs-keyword">return</span> {<span class="hljs-string">"result"</span>: results, <span class="hljs-string">"model_version"</span>: <span class="hljs-string">"mining_audio_v1.0"</span>}
</code></pre>
<p><strong>Label Studio配置示例</strong>：</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">View</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">Audio</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"audio"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$audio"</span>/&gt;</span>
  
  <span class="hljs-tag">&lt;<span class="hljs-name">Choices</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"mining_equipment_status"</span> <span class="hljs-attr">toName</span>=<span class="hljs-string">"audio"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">Choice</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"normal"</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">Choice</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"abnormal"</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">Choice</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"maintenance_needed"</span>/&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">Choices</span>&gt;</span>
  
  <span class="hljs-tag">&lt;<span class="hljs-name">Choices</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"mining_fault_type"</span> <span class="hljs-attr">toName</span>=<span class="hljs-string">"audio"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">Choice</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"bearing_fault"</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">Choice</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"motor_fault"</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">Choice</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"hydraulic_leak"</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">Choice</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"belt_fault"</span>/&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">Choices</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span>
</code></pre>
<hr/>
<h2 data-id="heading-18">四、实战应用：真实场景深度剖析</h2>
<h3 data-id="heading-19">场景1：传送带轴承故障预警</h3>
<p><strong>背景</strong>：某露天矿主传送带，日运送矿石5000吨，轴承故障历史记录：</p>
<ul>
<li>每次故障停产8-12小时</li>
<li>年均发生3次</li>
<li>单次损失约300万元</li>
</ul>
<p><strong>传统做法</strong>：</p>
<ul>
<li>每月人工巡检，听声音判断</li>
<li>依赖老师傅经验（退休后经验流失）</li>
<li>无法24小时监控</li>
</ul>
<p><strong>ML Backend方案</strong>：</p>
<ol>
<li>
<p><strong>数据采集</strong></p>
<ul>
<li>在传送带关键位置安装麦克风</li>
<li>每小时采集10秒音频样本</li>
<li>自动上传到MinIO存储</li>
</ul>
</li>
<li>
<p><strong>模型预测</strong></p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 音频特征分析</span>
特征向量 → [MFCC高频能量异常, 频谱质心偏移, RMS振幅增大]

<span class="hljs-comment"># 模型输出</span>
设备状态: abnormal (置信度: <span class="hljs-number">0.87</span>)
故障类型: bearing_fault (置信度: <span class="hljs-number">0.75</span>)
优先级: high_priority (置信度: <span class="hljs-number">0.82</span>)
</code></pre>
</li>
<li>
<p><strong>预警流程</strong></p>
<pre><code class="hljs language-mermaid" lang="mermaid">graph LR
    A[音频采集] --&gt; B[特征提取]
    B --&gt; C[模型预测]
    C --&gt; D{置信度&gt;0.7?}
    D --&gt;|是| E[发送预警]
    D --&gt;|否| F[正常监控]
    E --&gt; G[维护工单]
    G --&gt; H[计划性停机检修]
</code></pre>
</li>
</ol>
<p><strong>实施效果</strong>：</p>
<ul>
<li>提前5天预警轴承磨损</li>
<li>安排计划性停机（晚上低峰期检修）</li>
<li>避免突发停产，年节省900万元</li>
<li>轴承使用寿命延长20%（及时维护减少连锁损伤）</li>
</ul>
<h3 data-id="heading-20">场景2：液压系统泄漏检测</h3>
<p><strong>背景</strong>：挖掘机液压系统泄漏特征：</p>
<ul>
<li>异常"嘶嘶"高频声</li>
<li>传统检测：人工检查油压表+目视漏油</li>
<li>问题：微小泄漏早期难以发现</li>
</ul>
<p><strong>音频诊断优势</strong>：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 液压泄漏的音频特征</span>
特征模式:
- 频谱带宽显著增大（高频噪声）
- 频谱滚降点升高（高频能量占比增加）
- MFCC特定频段异常

<span class="hljs-comment"># 模型识别</span>
故障类型: hydraulic_leak (置信度: <span class="hljs-number">0.81</span>)
</code></pre>
<p><strong>对比实验</strong>：</p>





























<table><thead><tr><th>检测方法</th><th>识别准确率</th><th>漏检率</th><th>误报率</th></tr></thead><tbody><tr><td>人工巡检</td><td>65%</td><td>35%</td><td>10%</td></tr><tr><td>压力传感器</td><td>75%</td><td>25%</td><td>15%</td></tr><tr><td><strong>音频ML</strong></td><td><strong>88%</strong></td><td><strong>12%</strong></td><td><strong>8%</strong></td></tr></tbody></table>
<h3 data-id="heading-21">场景3：多设备健康度监控大屏</h3>
<p><strong>需求</strong>：矿山调度中心希望实时查看所有设备健康状态</p>
<p><strong>实现方案</strong>：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 定时任务：每小时批量预测</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">scheduled_prediction</span>():
    devices = get_all_mining_devices()  <span class="hljs-comment"># 获取所有设备列表</span>
    
    <span class="hljs-keyword">for</span> device <span class="hljs-keyword">in</span> devices:
        <span class="hljs-comment"># 获取最新音频</span>
        audio_url = <span class="hljs-string">f"s3://audio-data/<span class="hljs-subst">{device.<span class="hljs-built_in">id</span>}</span>/latest.wav"</span>
        
        <span class="hljs-comment"># 执行预测</span>
        prediction = model.predict([{<span class="hljs-string">"data"</span>: {<span class="hljs-string">"audio"</span>: audio_url}}])
        
        <span class="hljs-comment"># 更新设备状态</span>
        device.health_score = calculate_health_score(prediction)
        device.save()
</code></pre>
<p><strong>健康度计算</strong>：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate_health_score</span>(<span class="hljs-params">prediction</span>):
    score = <span class="hljs-number">100</span>  <span class="hljs-comment"># 基础分</span>
    
    <span class="hljs-comment"># 根据预测结果扣分</span>
    <span class="hljs-keyword">if</span> <span class="hljs-string">'abnormal'</span> <span class="hljs-keyword">in</span> prediction[<span class="hljs-string">'equipment_status'</span>]:
        score -= <span class="hljs-number">30</span>
    
    <span class="hljs-keyword">if</span> <span class="hljs-string">'bearing_fault'</span> <span class="hljs-keyword">in</span> prediction[<span class="hljs-string">'fault_type'</span>]:
        score -= <span class="hljs-number">40</span>
    <span class="hljs-keyword">elif</span> <span class="hljs-string">'motor_fault'</span> <span class="hljs-keyword">in</span> prediction[<span class="hljs-string">'fault_type'</span>]:
        score -= <span class="hljs-number">35</span>
    
    <span class="hljs-keyword">if</span> <span class="hljs-string">'high_priority'</span> <span class="hljs-keyword">in</span> prediction[<span class="hljs-string">'priority'</span>]:
        score -= <span class="hljs-number">20</span>
    
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, score)
</code></pre>
<p><strong>可视化大屏</strong>：</p>
<pre><code class="hljs language-less" lang="less">┌────────────────────────────────────────────┐
│        矿山设备健康监控大屏                  │
├────────────────────────────────────────────┤
│ 传送带<span class="hljs-selector-tag">A</span>  <span class="hljs-selector-attr">[████████░░]</span> <span class="hljs-number">85</span>分 状态:良好        │
│ 传送带<span class="hljs-selector-tag">B</span>  <span class="hljs-selector-attr">[████░░░░░░]</span> <span class="hljs-number">45</span>分 ⚠️ 需维护        │
│ 挖掘机<span class="hljs-number">1</span>  <span class="hljs-selector-attr">[██████████]</span> <span class="hljs-number">95</span>分 状态:优秀        │
│ 挖掘机<span class="hljs-number">2</span>  <span class="hljs-selector-attr">[███░░░░░░░]</span> <span class="hljs-number">35</span>分 🚨 紧急维修      │
│ 液压泵<span class="hljs-number">1</span>  <span class="hljs-selector-attr">[███████░░░]</span> <span class="hljs-number">70</span>分 状态:一般        │
└────────────────────────────────────────────┘
</code></pre>
<hr/>
<h2 data-id="heading-22">五、技术优化与最佳实践</h2>
<h3 data-id="heading-23">5.1 性能优化策略</h3>
<h4 data-id="heading-24">优化1：批量推理</h4>
<p><strong>问题</strong>：逐个音频预测效率低，GPU利用率不足</p>
<p><strong>解决方案</strong>：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">predict_batch</span>(<span class="hljs-params">self, audio_paths</span>):
    <span class="hljs-comment"># 批量提取特征</span>
    features_list = []
    <span class="hljs-keyword">for</span> path <span class="hljs-keyword">in</span> audio_paths:
        features = self.feature_extractor.extract_features(path)
        features_list.append(features)
    
    <span class="hljs-comment"># 批量推理（GPU并行计算）</span>
    features_batch = torch.stack(features_list)
    <span class="hljs-keyword">with</span> torch.no_grad():
        outputs = self.model(features_batch)
    
    <span class="hljs-keyword">return</span> outputs
</code></pre>
<p><strong>效果</strong>：</p>
<ul>
<li>单样本推理：100ms/样本</li>
<li>批量推理(batch=32)：20ms/样本</li>
<li><strong>加速5倍</strong></li>
</ul>
<h4 data-id="heading-25">优化2：模型量化</h4>
<p><strong>目的</strong>：减少模型大小，加速推理</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># FP32 → INT8量化</span>
<span class="hljs-keyword">import</span> torch.quantization <span class="hljs-keyword">as</span> quant

<span class="hljs-comment"># 动态量化(推理时量化)</span>
model_quantized = quant.quantize_dynamic(
    model, 
    {nn.Linear},  <span class="hljs-comment"># 量化全连接层</span>
    dtype=torch.qint8
)

<span class="hljs-comment"># 模型大小: 50MB → 13MB (减少74%)</span>
<span class="hljs-comment"># 推理速度: 提升1.5-2倍</span>
</code></pre>
<h4 data-id="heading-26">优化3：特征缓存</h4>
<p><strong>场景</strong>：同一音频文件可能被多次预测</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> hashlib
<span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> lru_cache

<span class="hljs-meta">@lru_cache(<span class="hljs-params">maxsize=<span class="hljs-number">100</span></span>)</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">extract_features_cached</span>(<span class="hljs-params">audio_path_hash</span>):
    <span class="hljs-keyword">return</span> self.feature_extractor.extract_features(audio_path)

<span class="hljs-comment"># 使用</span>
audio_hash = hashlib.md5(<span class="hljs-built_in">open</span>(audio_path, <span class="hljs-string">'rb'</span>).read()).hexdigest()
features = extract_features_cached(audio_hash)
</code></pre>
<h3 data-id="heading-27">5.2 模型训练最佳实践</h3>
<h4 data-id="heading-28">实践1：数据增强</h4>
<p><strong>目的</strong>：增加训练样本多样性，提升泛化能力</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> audiomentations <span class="hljs-keyword">as</span> AA

augmenter = AA.Compose([
    AA.AddGaussianNoise(min_amplitude=<span class="hljs-number">0.001</span>, max_amplitude=<span class="hljs-number">0.015</span>, p=<span class="hljs-number">0.5</span>),
    AA.TimeStretch(min_rate=<span class="hljs-number">0.8</span>, max_rate=<span class="hljs-number">1.25</span>, p=<span class="hljs-number">0.5</span>),
    AA.PitchShift(min_semitones=-<span class="hljs-number">4</span>, max_semitones=<span class="hljs-number">4</span>, p=<span class="hljs-number">0.5</span>),
    AA.Shift(min_fraction=-<span class="hljs-number">0.5</span>, max_fraction=<span class="hljs-number">0.5</span>, p=<span class="hljs-number">0.5</span>),
])

<span class="hljs-comment"># 应用数据增强</span>
augmented_audio = augmenter(samples=audio_data, sample_rate=<span class="hljs-number">25000</span>)
</code></pre>
<p><strong>增强策略说明</strong>：</p>
<ul>
<li><strong>高斯噪声</strong>：模拟环境噪音</li>
<li><strong>时间拉伸</strong>：模拟转速变化</li>
<li><strong>音调偏移</strong>：模拟设备老化</li>
<li><strong>时间偏移</strong>：增加时间多样性</li>
</ul>
<h4 data-id="heading-29">实践2：类别平衡</h4>
<p><strong>问题</strong>：正常样本远多于故障样本（不平衡数据）</p>
<p><strong>解决方案</strong>：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> WeightedRandomSampler

<span class="hljs-comment"># 计算类别权重</span>
class_counts = [normal_count, abnormal_count, maintenance_count]
class_weights = <span class="hljs-number">1.0</span> / torch.tensor(class_counts, dtype=torch.<span class="hljs-built_in">float</span>)

<span class="hljs-comment"># 样本权重</span>
sample_weights = [class_weights[label] <span class="hljs-keyword">for</span> label <span class="hljs-keyword">in</span> labels]

<span class="hljs-comment"># 加权采样器</span>
sampler = WeightedRandomSampler(
    weights=sample_weights,
    num_samples=<span class="hljs-built_in">len</span>(sample_weights),
    replacement=<span class="hljs-literal">True</span>
)

<span class="hljs-comment"># 使用</span>
train_loader = DataLoader(dataset, sampler=sampler, batch_size=<span class="hljs-number">32</span>)
</code></pre>
<h4 data-id="heading-30">实践3：多任务学习策略</h4>
<p><strong>损失函数设计</strong>：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">multi_label_loss</span>(<span class="hljs-params">outputs, targets</span>):
    <span class="hljs-comment"># 三个任务的BCE损失</span>
    loss_status = F.binary_cross_entropy(
        outputs[<span class="hljs-string">'equipment_status'</span>], 
        targets[<span class="hljs-string">'equipment_status'</span>]
    )
    
    loss_fault = F.binary_cross_entropy(
        outputs[<span class="hljs-string">'fault_type'</span>], 
        targets[<span class="hljs-string">'fault_type'</span>]
    )
    
    loss_priority = F.binary_cross_entropy(
        outputs[<span class="hljs-string">'priority'</span>], 
        targets[<span class="hljs-string">'priority'</span>]
    )
    
    <span class="hljs-comment"># 加权组合</span>
    total_loss = <span class="hljs-number">0.4</span> * loss_status + <span class="hljs-number">0.4</span> * loss_fault + <span class="hljs-number">0.2</span> * loss_priority
    <span class="hljs-keyword">return</span> total_loss
</code></pre>
<p><strong>权重设置依据</strong>：</p>
<ul>
<li>设备状态：最重要（0.4）</li>
<li>故障类型：重要（0.4）</li>
<li>优先级：次要（0.2）</li>
</ul>
<hr/>
<h2 data-id="heading-31">六、总结与展望</h2>
<h3 data-id="heading-32">6.1 技术创新点</h3>
<p>本项目在矿业音频诊断领域的创新：</p>
<ol>
<li>
<p><strong>多标签联合预测</strong></p>
<ul>
<li>传统方法：单独预测故障类型</li>
<li>本方案：同时预测状态/故障/优先级，提供全面诊断</li>
</ul>
</li>
<li>
<p><strong>端到端深度学习</strong></p>
<ul>
<li>传统方法：手工设计特征+简单分类器</li>
<li>本方案：神经网络自动学习特征表示</li>
</ul>
</li>
<li>
<p><strong>工业级工程实现</strong></p>
<ul>
<li>对接MinIO存储</li>
<li>标准化部署流程</li>
<li>完善的异常处理</li>
</ul>
</li>
</ol>
<h3 data-id="heading-33">6.2 适用场景总结</h3>






























<table><thead><tr><th>行业领域</th><th>应用场景</th><th>核心价值</th></tr></thead><tbody><tr><td><strong>矿业</strong></td><td>设备故障预警</td><td>避免停产损失</td></tr><tr><td><strong>制造业</strong></td><td>生产线质检</td><td>提升产品质量</td></tr><tr><td><strong>能源</strong></td><td>风机/水泵监控</td><td>延长设备寿命</td></tr><tr><td><strong>交通</strong></td><td>轨道/桥梁巡检</td><td>保障安全</td></tr></tbody></table>
<h3 data-id="heading-34">6.3 未来发展方向</h3>
<h4 data-id="heading-35">方向1：多模态融合</h4>
<p><strong>思路</strong>：结合音频+振动+温度多种传感器</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MultiModalClassifier</span>(nn.Module):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        self.audio_encoder = AudioFeatureExtractor()
        self.vibration_encoder = VibrationFeatureExtractor()
        self.temperature_encoder = TemperatureFeatureExtractor()
        
        <span class="hljs-comment"># 多模态融合</span>
        self.fusion_layer = nn.Linear(<span class="hljs-number">72</span>+<span class="hljs-number">64</span>+<span class="hljs-number">32</span>, <span class="hljs-number">128</span>)
</code></pre>
<p><strong>优势</strong>：</p>
<ul>
<li>单一传感器可能漏检</li>
<li>多模态互补，提升准确率</li>
</ul>
<h4 data-id="heading-36">方向2：自监督预训练</h4>
<p><strong>思路</strong>：在大规模无标注音频上预训练</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 对比学习</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">contrastive_loss</span>(<span class="hljs-params">audio1, audio2, temperature=<span class="hljs-number">0.5</span></span>):
    <span class="hljs-comment"># 同一设备不同时间的音频为正样本</span>
    <span class="hljs-comment"># 不同设备的音频为负样本</span>
    ...
</code></pre>
<p><strong>价值</strong>：</p>
<ul>
<li>降低标注成本</li>
<li>迁移学习到新设备</li>
</ul>
<h4 data-id="heading-37">方向3：因果诊断</h4>
<p><strong>思路</strong>：不仅预测故障，还解释原因</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 注意力机制可视化</span>
attention_weights = model.get_attention()

<span class="hljs-comment"># 分析关键频段</span>
critical_freqs = find_critical_frequencies(attention_weights)
<span class="hljs-comment"># "故障由2kHz-3kHz异常振动引起"</span>
</code></pre>
<hr/>
<h2 data-id="heading-38">附录：部署运维指南</h2>
<h3 data-id="heading-39">1. Docker部署</h3>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 构建镜像</span>
docker build -t mining-audio-backend .

<span class="hljs-comment"># 启动容器</span>
docker run -d \
  -p 9090:9090 \
  -v /data/models:/app/models \
  -v /data/cache:/app/cache \
  --name mining-audio \
  mining-audio-backend

<span class="hljs-comment"># 健康检查</span>
curl http://localhost:9090/health
</code></pre>
<h3 data-id="heading-40">2. 监控指标</h3>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 关键指标</span>
metrics = {
    <span class="hljs-string">'prediction_latency'</span>: <span class="hljs-number">150</span>,  <span class="hljs-comment"># 平均预测延迟(ms)</span>
    <span class="hljs-string">'accuracy'</span>: <span class="hljs-number">0.88</span>,            <span class="hljs-comment"># 准确率</span>
    <span class="hljs-string">'throughput'</span>: <span class="hljs-number">100</span>,           <span class="hljs-comment"># 吞吐量(样本/秒)</span>
    <span class="hljs-string">'model_version'</span>: <span class="hljs-string">'v1.0'</span>,
    <span class="hljs-string">'gpu_utilization'</span>: <span class="hljs-number">0.75</span>      <span class="hljs-comment"># GPU利用率</span>
}
</code></pre>
<h3 data-id="heading-41">3. 故障排查</h3>
<p><strong>问题1：预测延迟高</strong></p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 检查GPU是否正常</span>
nvidia-smi

<span class="hljs-comment"># 检查批量大小</span>
<span class="hljs-comment"># 增大batch_size可提升GPU利用率</span>
</code></pre>
<p><strong>问题2：准确率下降</strong></p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 检查数据分布漂移</span>
<span class="hljs-comment"># 定期使用新数据微调模型</span>
python train_model.py --finetune
</code></pre>
<hr/>
<p><strong>总结</strong>：矿业音频ML Backend将<strong>声学诊断专家的经验</strong>转化为<strong>自动化智能系统</strong>，实现从"事后维修"到"预测性维护"的范式转变，为矿业、制造业等重工业领域的智能化升级提供了<strong>可落地的AI解决方案</strong>。通过深度学习技术，让机器学会**"听音辨机"**，提前预警故障，避免停产损失，是工业4.0时代的重要应用方向。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[海量数据集AI自动化打标 - 温度周期检测]]></title>    <link>https://juejin.cn/post/7578460753210769435</link>    <guid>https://juejin.cn/post/7578460753210769435</guid>    <pubDate>2025-12-01T09:31:24.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7578460753210769435" data-draft-id="7578511778889564198" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="海量数据集AI自动化打标 - 温度周期检测"/> <meta itemprop="keywords" content="算法"/> <meta itemprop="datePublished" content="2025-12-01T09:31:24.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="语落心生"/> <meta itemprop="url" content="https://juejin.cn/user/2875978147955741"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            海量数据集AI自动化打标 - 温度周期检测
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2875978147955741/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    语落心生
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-01T09:31:24.000Z" title="Mon Dec 01 2025 09:31:24 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-01
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读16分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>温度特征多标签预测: <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FSTARTORUS%2Ftok-label%2Fpull%2F2" target="_blank" title="https://github.com/STARTORUS/tok-label/pull/2" ref="nofollow noopener noreferrer">github.com/STARTORUS/t…</a></p>
<h2 data-id="heading-0">概述:让AI识别温度变化的"指纹"</h2>
<p>想象一下,在一个等离子体实验装置中,温度从几百电子伏特(eV)飞速上升到上千eV,又在瞬间下降——这个过程可能只持续几十毫秒。<strong>传统人工标注</strong>需要标注员逐帧查看温度曲线,标记上升阶段、峰值时刻、下降阶段……既耗时又容易遗漏关键特征。</p>
<p><strong>温度标注ML Backend</strong>就像一位经验丰富的<strong>温度分析专家</strong>,能自动识别温度曲线中的关键模式,将复杂的时序分析工作自动化,让科研人员专注于物理现象的解释而非繁琐的数据标注。</p>
<hr/>
<h2 data-id="heading-1">一、业务价值:Why - 为什么需要温度智能标注?</h2>
<h3 data-id="heading-2">1.1 现实场景痛点</h3>
<p>在等离子体物理、核聚变、材料科学等领域,温度数据分析面临诸多挑战:</p>
<p><strong>场景1:等离子体放电实验分析</strong> ⚡<br/>
SUNIST托卡马克装置每次放电实验:</p>
<ul>
<li>产生几十个温度传感器通道数据</li>
<li>每个通道包含10000+时间点</li>
<li>需要标注:上升阶段、峰值时刻、下降阶段、异常事件</li>
<li><strong>一次实验人工标注需要2-3小时</strong></li>
</ul>
<p><strong>场景2:材料热处理工艺</strong> 🔥<br/>
金属热处理过程:</p>
<ul>
<li>温度曲线直接影响材料性能</li>
<li>需要精确标注加热速率、保温时间、冷却速率</li>
<li>不同工艺曲线对比分析</li>
<li><strong>人工标注效率低,难以大规模对比</strong></li>
</ul>
<p><strong>场景3:非周期性温度异常检测</strong> 🚨<br/>
等离子体实验中的非周期性事件:</p>
<ul>
<li>突然的高温持续(可能是不稳定性)</li>
<li>异常的温度平台期</li>
<li>传统周期性检测方法无法识别</li>
<li><strong>关键异常事件容易被遗漏</strong></li>
</ul>
<h3 data-id="heading-3">1.2 ML Backend的核心价值</h3>
<p>温度标注ML Backend通过<strong>智能模式识别</strong>,实现:</p>
<p>✅ <strong>效率提升20倍</strong>:自动完成95%的标注工作,人工仅需校验<br/>
✅ <strong>标准化</strong>:消除人为主观判断差异,保证标注一致性<br/>
✅ <strong>全面性</strong>:不遗漏任何异常模式,包括非周期性事件<br/>
✅ <strong>实时分析</strong>:实验结束即可获得初步分析结果</p>
<p><strong>价值量化示例</strong>:</p>
<ul>
<li>传统标注:100次实验 × 2小时 = 200小时</li>
<li>ML Backend:100次实验 × 6分钟校验 = 10小时</li>
<li><strong>节省时间95%,加速科研迭代</strong></li>
</ul>
<hr/>
<h2 data-id="heading-4">二、系统架构:What - 温度标注ML Backend是什么?</h2>
<h3 data-id="heading-5">2.1 整体架构图</h3>
<pre><code class="hljs language-mermaid" lang="mermaid">graph TB
    subgraph "数据源"
        A1[CSV时序数据] --&gt; A2[数据加载器]
        A3[MinIO存储] --&gt; A2
    end
    
    subgraph "Label Studio前端"
        B1[时序标注界面] --&gt; B2[任务管理]
    end
    
    subgraph "ML Backend核心"
        C1[_wsgi.py服务] --&gt; C2[TemperatureModel&lt;br/&gt;业务协调]
        C2 --&gt; C3[TemperaturePredictor&lt;br/&gt;预测引擎]
        C3 --&gt; C4[NonCyclicDetector&lt;br/&gt;非周期性检测]
        C2 --&gt; C5[Utils工具集&lt;br/&gt;数据预处理]
    end
    
    subgraph "算法层"
        D1[上升阶段检测&lt;br/&gt;start_end_time_1D]
        D2[峰值时刻检测&lt;br/&gt;find_temperature_peaks]
        D3[异常检测&lt;br/&gt;detect_anomalies]
        D4[平台期检测&lt;br/&gt;gradient_analysis]
        D5[非周期性模式&lt;br/&gt;sustained_high_temp]
    end
    
    A2 --&gt; C2
    B2 --&gt;|HTTP API| C1
    C3 --&gt; D1
    C3 --&gt; D2
    C3 --&gt; D3
    C3 --&gt; D4
    C4 --&gt; D5
    
    style C3 fill:#4CAF50,color:#fff
    style C4 fill:#FF5722,color:#fff
    style D1 fill:#2196F3,color:#fff
    style D2 fill:#2196F3,color:#fff
    style D5 fill:#FF9800,color:#fff
</code></pre>
<h3 data-id="heading-6">2.2 核心组件详解</h3>
<h4 data-id="heading-7">🎯 <strong>TemperatureModel</strong> - 业务编排中心</h4>
<p>这是系统的**"指挥官"**,负责协调各个组件完成温度标注:</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TemperatureModel</span>(<span class="hljs-title class_ inherited__">LabelStudioMLBase</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">setup</span>(<span class="hljs-params">self</span>):
        <span class="hljs-comment"># 初始化预测器,传递阈值参数</span>
        self.predictor = TemperaturePredictor(
            critical_temp_threshold=<span class="hljs-number">1500.0</span>,  <span class="hljs-comment"># 临界温度阈值</span>
            sustained_period=<span class="hljs-number">5.0</span>              <span class="hljs-comment"># 持续时间阈值</span>
        )
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">predict</span>(<span class="hljs-params">self, tasks</span>):
        <span class="hljs-comment"># 1. 加载数据</span>
        data_dict = self.get_data(tasks)
        
        <span class="hljs-comment"># 2. 执行预测</span>
        <span class="hljs-keyword">for</span> shot, data <span class="hljs-keyword">in</span> data_dict.items():
            predictions = self.predictor.user_predict(data)
        
        <span class="hljs-comment"># 3. 格式化结果</span>
        <span class="hljs-keyword">return</span> model_preds
</code></pre>
<p><strong>设计亮点</strong>:</p>
<ul>
<li><strong>安全获取参数</strong>:<code>_safe_get()</code>方法兼容不同版本的Label Studio</li>
<li><strong>在线学习</strong>:<code>fit()</code>方法根据用户标注自适应调整阈值</li>
<li><strong>参数持久化</strong>:阈值参数保存在缓存中,支持模型演进</li>
</ul>
<h4 data-id="heading-8">🧠 <strong>TemperaturePredictor</strong> - 智能预测引擎</h4>
<p>这是系统的**"分析大脑"**,实现6种温度模式识别:</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TemperaturePredictor</span>(<span class="hljs-title class_ inherited__">BasePredictor</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, 
                 temp_rise_threshold=<span class="hljs-number">1000.0</span>,   <span class="hljs-comment"># 上升阈值</span>
                 temp_fall_threshold=<span class="hljs-number">500.0</span>,    <span class="hljs-comment"># 下降阈值</span>
                 gradient_threshold=<span class="hljs-number">100.0</span>,     <span class="hljs-comment"># 梯度阈值</span>
                 critical_temp_threshold=<span class="hljs-number">1500.0</span>, <span class="hljs-comment"># 临界温度</span>
                 sustained_period=<span class="hljs-number">5.0</span></span>):         <span class="hljs-comment"># 持续时间</span>
        ...
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">user_predict</span>(<span class="hljs-params">self, task_data</span>):
        predictions = []
        
        <span class="hljs-comment"># 1. 检测温度上升阶段</span>
        predictions.extend(self._detect_rise_phases(...))
        
        <span class="hljs-comment"># 2. 检测峰值时刻</span>
        predictions.extend(self._detect_peak_moments(...))
        
        <span class="hljs-comment"># 3. 检测下降阶段</span>
        predictions.extend(self._detect_fall_phases(...))
        
        <span class="hljs-comment"># 4. 检测异常事件</span>
        predictions.extend(self._detect_anomalies(...))
        
        <span class="hljs-comment"># 5. 检测平台期</span>
        predictions.extend(self._detect_plateau_phases(...))
        
        <span class="hljs-comment"># 6. 检测非周期性模式(新增!)</span>
        predictions.extend(
            self.non_cyclic_detector.detect_non_cyclic_patterns(...)
        )
        
        <span class="hljs-keyword">return</span> predictions
</code></pre>
<p><strong>六大检测模块</strong>:</p>















































<table><thead><tr><th>模块</th><th>检测目标</th><th>物理意义</th><th>应用场景</th></tr></thead><tbody><tr><td>上升阶段</td><td>温度快速增长区间</td><td>加热/放电启动</td><td>识别放电开始</td></tr><tr><td>峰值时刻</td><td>温度最高点</td><td>能量峰值</td><td>标记关键时刻</td></tr><tr><td>下降阶段</td><td>温度衰减区间</td><td>冷却/放电结束</td><td>识别放电结束</td></tr><tr><td>异常检测</td><td>温度突变</td><td>不稳定性事件</td><td>发现异常现象</td></tr><tr><td>平台期</td><td>温度平稳区间</td><td>稳态阶段</td><td>工艺质量评估</td></tr><tr><td><strong>非周期性</strong></td><td><strong>持续高温</strong></td><td><strong>非正常状态</strong></td><td><strong>安全预警</strong></td></tr></tbody></table>
<h4 data-id="heading-9">🔍 <strong>NonCyclicDetector</strong> - 非周期性模式识别器</h4>
<p>这是系统的**"异常雷达"**,专门检测非周期性温度事件:</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NonCyclicTemperatureDetector</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">detect_non_cyclic_patterns</span>(<span class="hljs-params">self, time, temp_data, channel</span>):
        predictions = []
        
        <span class="hljs-comment"># 检测1:持续高温</span>
        predictions.extend(self._detect_sustained_high_temp(...))
        
        <span class="hljs-comment"># 检测2:异常温度平台</span>
        predictions.extend(self._detect_abnormal_plateau(...))
        
        <span class="hljs-comment"># 检测3:突发温度尖峰</span>
        predictions.extend(self._detect_sudden_spikes(...))
        
        <span class="hljs-keyword">return</span> predictions
</code></pre>
<p><strong>非周期性 vs 周期性的区别</strong>:</p>
<pre><code class="hljs language-makefile" lang="makefile"><span class="hljs-section">周期性温度模式(正常放电):</span>
  ┌─┐    ┌─┐    ┌─┐
  │ │    │ │    │ │
──┘ └────┘ └────┘ └──  (规律的升-峰-降)

<span class="hljs-section">非周期性温度模式(异常事件):</span>
  ┌──────────┐
  │          │  (持续高温,不下降)
──┘          └────────
</code></pre>
<hr/>
<h2 data-id="heading-10">三、技术实现:How - 温度模式识别详解</h2>
<h3 data-id="heading-11">3.1 核心算法原理</h3>
<h4 data-id="heading-12">算法1:上升阶段检测</h4>
<p><strong>物理背景</strong>:等离子体放电时,温度从几百eV快速上升到上千eV</p>
<p><strong>算法思想</strong>:检测温度值超过阈值的连续区间</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">_detect_rise_phases</span>(<span class="hljs-params">self, time, temp_data, channel</span>):
    <span class="hljs-comment"># 1. 调用start_end_time_1D检测上升区间</span>
    rise_intervals = start_end_time_1D(
        temp_data, 
        threshold=self.temp_rise_threshold,  <span class="hljs-comment"># 1000 eV</span>
        postive=<span class="hljs-literal">True</span>  <span class="hljs-comment"># 检测正向超过阈值</span>
    )
    
    <span class="hljs-comment"># 2. 遍历每个区间</span>
    <span class="hljs-keyword">for</span> start_idx, end_idx <span class="hljs-keyword">in</span> rise_intervals:
        start_time = time[start_idx]
        end_time = time[end_idx]
        
        <span class="hljs-comment"># 3. 计算上升特征</span>
        rise_data = temp_data[start_idx:end_idx+<span class="hljs-number">1</span>]
        max_temp = np.<span class="hljs-built_in">max</span>(rise_data)
        avg_temp = np.mean(rise_data)
        
        <span class="hljs-comment"># 4. 智能标签分级</span>
        <span class="hljs-keyword">if</span> max_temp &gt; self.temp_rise_threshold * <span class="hljs-number">1.5</span>:
            label = <span class="hljs-string">f"<span class="hljs-subst">{channel}</span>_快速上升"</span>  <span class="hljs-comment"># 超过1500eV</span>
        <span class="hljs-keyword">else</span>:
            label = <span class="hljs-string">f"<span class="hljs-subst">{channel}</span>_上升阶段"</span>   <span class="hljs-comment"># 1000-1500eV</span>
        
        <span class="hljs-comment"># 5. 计算置信度</span>
        confidence = <span class="hljs-built_in">min</span>(<span class="hljs-number">0.9</span>, (max_temp - threshold) / threshold)
        
        predictions.append(Prediction(
            label_group=<span class="hljs-string">'temperature_events'</span>,
            label_choice=label,
            start=start_time,
            end=end_time,
            score=confidence
        ))
</code></pre>
<p><strong>start_end_time_1D算法原理</strong>:</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">start_end_time_1D</span>(<span class="hljs-params">data, threshold, postive=<span class="hljs-literal">True</span></span>):
    <span class="hljs-string">"""
    检测信号超过阈值的区间
    
    思路:
    1. 将数据二值化:超过阈值=1,否则=0
    2. 检测0→1跳变(上升沿)和1→0跳变(下降沿)
    3. 配对上升沿和下降沿,得到区间
    """</span>
    <span class="hljs-keyword">if</span> postive:
        mask = (data &gt; threshold).astype(<span class="hljs-built_in">int</span>)
    <span class="hljs-keyword">else</span>:
        mask = (data &lt; -threshold).astype(<span class="hljs-built_in">int</span>)
    
    <span class="hljs-comment"># 检测跳变</span>
    diff = np.diff(mask)
    start_indices = np.where(diff == <span class="hljs-number">1</span>)[<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>  <span class="hljs-comment"># 上升沿</span>
    end_indices = np.where(diff == -<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>   <span class="hljs-comment"># 下降沿</span>
    
    <span class="hljs-comment"># 配对区间</span>
    intervals = []
    <span class="hljs-keyword">for</span> start, end <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(start_indices, end_indices):
        intervals.append((start, end))
    
    <span class="hljs-keyword">return</span> intervals
</code></pre>
<p><strong>可视化示例</strong>:</p>
<pre><code class="hljs language-arduino" lang="arduino">温度曲线:
  <span class="hljs-number">1500</span> ────┐     ┌────
           │     │
  <span class="hljs-number">1000</span> ────│─────│────  (阈值线)
           │     │
   <span class="hljs-number">500</span> ────┴─────┴────
        ↑  ↑     ↑  ↑
      start end start end

检测结果:
  区间<span class="hljs-number">1</span>: [t1, t2]  标签:<span class="hljs-string">"快速上升"</span>(max=<span class="hljs-number">1500</span>)
  区间<span class="hljs-number">2</span>: [t3, t4]  标签:<span class="hljs-string">"快速上升"</span>(max=<span class="hljs-number">1600</span>)
</code></pre>
<h4 data-id="heading-13">算法2:峰值时刻检测</h4>
<p><strong>物理背景</strong>:峰值对应能量最高时刻,是分析的关键点</p>
<p><strong>算法思想</strong>:基于梯度检测极值点</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">_detect_peak_moments</span>(<span class="hljs-params">self, time, temp_data, channel</span>):
    <span class="hljs-comment"># 调用find_temperature_peaks</span>
    peak_times = find_temperature_peaks(
        temp_data, time,
        gradient_threshold=self.gradient_threshold,  <span class="hljs-comment"># 100 eV/ms</span>
        min_peak_height=self.min_peak_height         <span class="hljs-comment"># 800 eV</span>
    )
    
    <span class="hljs-keyword">for</span> peak_time <span class="hljs-keyword">in</span> peak_times:
        peak_idx = np.argmin(np.<span class="hljs-built_in">abs</span>(time - peak_time))
        peak_temp = temp_data[peak_idx]
        
        <span class="hljs-comment"># 智能标签分级</span>
        <span class="hljs-keyword">if</span> peak_temp &gt; self.temp_rise_threshold * <span class="hljs-number">2</span>:
            label = <span class="hljs-string">f"<span class="hljs-subst">{channel}</span>_极高峰值"</span>    <span class="hljs-comment"># &gt;2000eV</span>
        <span class="hljs-keyword">elif</span> peak_temp &gt; self.temp_rise_threshold * <span class="hljs-number">1.5</span>:
            label = <span class="hljs-string">f"<span class="hljs-subst">{channel}</span>_高峰值"</span>      <span class="hljs-comment"># 1500-2000eV</span>
        <span class="hljs-keyword">else</span>:
            label = <span class="hljs-string">f"<span class="hljs-subst">{channel}</span>_峰值时刻"</span>    <span class="hljs-comment"># 800-1500eV</span>
        
        predictions.append(Prediction(
            label_group=<span class="hljs-string">'temperature_events'</span>,
            label_choice=label,
            start=peak_time,
            end=<span class="hljs-literal">None</span>,  <span class="hljs-comment"># 时间点标注</span>
            score=<span class="hljs-built_in">min</span>(<span class="hljs-number">0.95</span>, peak_temp / (threshold * <span class="hljs-number">2</span>))
        ))
</code></pre>
<p><strong>find_temperature_peaks算法原理</strong>:</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">find_temperature_peaks</span>(<span class="hljs-params">temp_data, time, gradient_threshold, min_peak_height</span>):
    <span class="hljs-string">"""
    基于梯度的峰值检测
    
    思路:
    1. 计算温度梯度 dT/dt
    2. 检测梯度从正变负的点(极大值点)
    3. 过滤掉低于最小高度的峰值
    """</span>
    <span class="hljs-comment"># 1. 计算梯度</span>
    gradient = np.gradient(temp_data, time)
    
    <span class="hljs-comment"># 2. 检测梯度符号变化</span>
    sign_change = np.diff(np.sign(gradient))
    peak_indices = np.where(sign_change &lt; <span class="hljs-number">0</span>)[<span class="hljs-number">0</span>]  <span class="hljs-comment"># 正→负</span>
    
    <span class="hljs-comment"># 3. 过滤峰值</span>
    valid_peaks = []
    <span class="hljs-keyword">for</span> idx <span class="hljs-keyword">in</span> peak_indices:
        <span class="hljs-keyword">if</span> temp_data[idx] &gt; min_peak_height:
            <span class="hljs-comment"># 检查梯度是否足够大</span>
            <span class="hljs-keyword">if</span> <span class="hljs-built_in">abs</span>(gradient[idx-<span class="hljs-number">1</span>]) &gt; gradient_threshold:
                valid_peaks.append(time[idx])
    
    <span class="hljs-keyword">return</span> valid_peaks
</code></pre>
<p><strong>可视化示例</strong>:</p>
<pre><code class="hljs language-makefile" lang="makefile"><span class="hljs-section">温度曲线:</span>
       ●  (峰值,梯度0)
      ╱ ╲
     ╱   ╲
    ╱     ╲  (梯度&lt;0)
   ╱       ╲
  ╱         ╲
──           ──
  (梯度&gt;0)

<span class="hljs-section">梯度曲线:</span>
  +100 ──╲
         │╲
    0 ───●─────  (梯度过零点→峰值)
         │  ╲
 -100 ───    ──
</code></pre>
<h4 data-id="heading-14">算法3:非周期性高温检测(创新点!)</h4>
<p><strong>物理背景</strong>:等离子体失稳时,温度可能持续高温不下降</p>
<p><strong>算法思想</strong>:检测温度持续超过临界值的时间窗口</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">_detect_sustained_high_temp</span>(<span class="hljs-params">self, time, temp_data, channel</span>):
    <span class="hljs-string">"""
    检测持续高温事件
    
    定义:温度持续超过critical_temp_threshold达到sustained_period时长
    """</span>
    <span class="hljs-comment"># 1. 找到高温区间</span>
    high_temp_mask = temp_data &gt; self.critical_temp_threshold
    high_temp_intervals = start_end_time_1D(
        high_temp_mask.astype(<span class="hljs-built_in">float</span>), 
        threshold=<span class="hljs-number">0.5</span>, 
        postive=<span class="hljs-literal">True</span>
    )
    
    <span class="hljs-comment"># 2. 过滤持续时间</span>
    predictions = []
    <span class="hljs-keyword">for</span> start_idx, end_idx <span class="hljs-keyword">in</span> high_temp_intervals:
        duration = time[end_idx] - time[start_idx]
        
        <span class="hljs-keyword">if</span> duration &gt;= self.sustained_period:  <span class="hljs-comment"># 持续超过5ms</span>
            avg_temp = np.mean(temp_data[start_idx:end_idx+<span class="hljs-number">1</span>])
            max_temp = np.<span class="hljs-built_in">max</span>(temp_data[start_idx:end_idx+<span class="hljs-number">1</span>])
            
            <span class="hljs-comment"># 严重程度分级</span>
            <span class="hljs-keyword">if</span> duration &gt; self.sustained_period * <span class="hljs-number">2</span>:
                label = <span class="hljs-string">f"<span class="hljs-subst">{channel}</span>_严重持续高温"</span>
                severity = <span class="hljs-string">"critical"</span>
            <span class="hljs-keyword">else</span>:
                label = <span class="hljs-string">f"<span class="hljs-subst">{channel}</span>_持续高温"</span>
                severity = <span class="hljs-string">"warning"</span>
            
            predictions.append(Prediction(
                label_group=<span class="hljs-string">'temperature_events'</span>,
                label_choice=label,
                start=time[start_idx],
                end=time[end_idx],
                score=<span class="hljs-number">0.9</span>,
                metadata={
                    <span class="hljs-string">'severity'</span>: severity,
                    <span class="hljs-string">'duration_ms'</span>: duration,
                    <span class="hljs-string">'avg_temp_eV'</span>: avg_temp,
                    <span class="hljs-string">'max_temp_eV'</span>: max_temp
                }
            ))
    
    <span class="hljs-keyword">return</span> predictions
</code></pre>
<p><strong>实际案例</strong>:</p>
<pre><code class="hljs language-makefile" lang="makefile"><span class="hljs-section">正常放电(周期性):</span>
  1500eV ─┐  ┌─┐  ┌─┐
         │  │ │  │ │
  1000eV ┴──┴─┴──┴─┴  (峰值后快速下降)
          2ms 2ms 2ms

<span class="hljs-section">异常放电(非周期性):</span>
  1500eV ─┬──────────┐
         │          │  (持续高温8ms!)
  1000eV ┴──────────┴──
          ← 8ms →
         
  检测结果: <span class="hljs-string">"严重持续高温"</span> (duration=8ms &gt; 5ms*2)
</code></pre>
<h4 data-id="heading-15">算法4:温度平台期检测</h4>
<p><strong>物理背景</strong>:稳态阶段温度保持平稳,梯度接近0</p>
<p><strong>算法思想</strong>:检测温度梯度小于阈值的区间</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">_detect_plateau_phases</span>(<span class="hljs-params">self, time, temp_data, channel</span>):
    <span class="hljs-comment"># 1. 计算温度梯度</span>
    gradient = np.gradient(temp_data)
    
    <span class="hljs-comment"># 2. 检测低梯度区间</span>
    plateau_threshold = self.gradient_threshold * <span class="hljs-number">0.1</span>  <span class="hljs-comment"># 10 eV/ms</span>
    plateau_mask = np.<span class="hljs-built_in">abs</span>(gradient) &lt; plateau_threshold
    
    <span class="hljs-comment"># 3. 找到连续平台区间</span>
    plateau_intervals = start_end_time_1D(
        plateau_mask.astype(<span class="hljs-built_in">float</span>), 
        threshold=<span class="hljs-number">0.5</span>, 
        postive=<span class="hljs-literal">True</span>
    )
    
    <span class="hljs-comment"># 4. 过滤短暂波动(至少持续10个采样点)</span>
    predictions = []
    <span class="hljs-keyword">for</span> start_idx, end_idx <span class="hljs-keyword">in</span> plateau_intervals:
        <span class="hljs-keyword">if</span> end_idx - start_idx &gt; <span class="hljs-number">10</span>:
            plateau_data = temp_data[start_idx:end_idx+<span class="hljs-number">1</span>]
            avg_temp = np.mean(plateau_data)
            temp_std = np.std(plateau_data)
            
            <span class="hljs-comment"># 根据温度水平分类</span>
            <span class="hljs-keyword">if</span> avg_temp &gt; self.temp_rise_threshold:
                label = <span class="hljs-string">f"<span class="hljs-subst">{channel}</span>_高温平台期"</span>
            <span class="hljs-keyword">elif</span> avg_temp &gt; self.temp_fall_threshold:
                label = <span class="hljs-string">f"<span class="hljs-subst">{channel}</span>_中温平台期"</span>
            <span class="hljs-keyword">else</span>:
                label = <span class="hljs-string">f"<span class="hljs-subst">{channel}</span>_低温平台期"</span>
            
            <span class="hljs-comment"># 稳定性评分</span>
            stability_score = <span class="hljs-built_in">max</span>(<span class="hljs-number">0.5</span>, <span class="hljs-number">1.0</span> - temp_std / avg_temp)
            
            predictions.append(Prediction(
                label_group=<span class="hljs-string">'temperature_events'</span>,
                label_choice=label,
                start=time[start_idx],
                end=time[end_idx],
                score=stability_score
            ))
    
    <span class="hljs-keyword">return</span> predictions
</code></pre>
<h3 data-id="heading-16">3.2 在线学习与阈值自适应</h3>
<p><strong>核心思想</strong>:根据用户标注反馈,自动调整阈值参数</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fit</span>(<span class="hljs-params">self, event, data, **kwargs</span>):
    <span class="hljs-string">"""
    处理标注事件,优化模型参数
    """</span>
    <span class="hljs-keyword">if</span> event <span class="hljs-keyword">in</span> [<span class="hljs-string">'ANNOTATION_CREATED'</span>, <span class="hljs-string">'ANNOTATION_UPDATED'</span>]:
        <span class="hljs-comment"># 1. 解析标注数据</span>
        annotation_data = self._parse_annotation_data(data)
        
        <span class="hljs-comment"># 2. 优化阈值</span>
        new_thresholds = self._optimize_thresholds(annotation_data)
        
        <span class="hljs-comment"># 3. 更新预测器参数</span>
        self.predictor.update_thresholds(new_thresholds)
        
        <span class="hljs-comment"># 4. 更新模型版本</span>
        new_version = <span class="hljs-string">f"temperature_v1.0_<span class="hljs-subst">{<span class="hljs-built_in">int</span>(time.time())}</span>"</span>
        self.<span class="hljs-built_in">set</span>(<span class="hljs-string">'model_version'</span>, new_version)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">_optimize_thresholds</span>(<span class="hljs-params">self, annotation_data</span>):
    <span class="hljs-string">"""
    基于标注数据的自适应策略
    """</span>
    new_thresholds = {}
    
    <span class="hljs-comment"># 统计不同类型标注</span>
    rise_annotations = [ann <span class="hljs-keyword">for</span> ann <span class="hljs-keyword">in</span> annotation_data <span class="hljs-keyword">if</span> <span class="hljs-string">'上升'</span> <span class="hljs-keyword">in</span> ann[<span class="hljs-string">'label'</span>]]
    
    <span class="hljs-comment"># 如果用户标注了更多上升阶段,降低阈值提高敏感度</span>
    <span class="hljs-keyword">if</span> rise_annotations:
        current_rise = self.get(<span class="hljs-string">'temp_rise_threshold'</span>, <span class="hljs-number">1000.0</span>)
        new_thresholds[<span class="hljs-string">'temp_rise_threshold'</span>] = <span class="hljs-built_in">max</span>(<span class="hljs-number">800.0</span>, current_rise * <span class="hljs-number">0.95</span>)
    
    <span class="hljs-keyword">return</span> new_thresholds
</code></pre>
<p><strong>自适应示例</strong>:</p>
<pre><code class="hljs language-ini" lang="ini">初始阈值: <span class="hljs-attr">temp_rise_threshold</span> = <span class="hljs-number">1000</span> eV

用户标注反馈:
- 标注了一个850eV的上升阶段(模型未检测到)

自适应调整:
- <span class="hljs-attr">new_threshold</span> = <span class="hljs-number">1000</span> * <span class="hljs-number">0.95</span> = <span class="hljs-number">950</span> eV (降低阈值)

下次预测:
- 可以检测到850eV的上升阶段了
</code></pre>
<h3 data-id="heading-17">3.3 多通道并行处理</h3>
<p><strong>场景</strong>:一次实验可能有10+个温度传感器通道</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">user_predict</span>(<span class="hljs-params">self, task_data</span>):
    predictions = []
    
    <span class="hljs-comment"># 1. 提取所有温度通道</span>
    temp_channels = self._extract_temperature_channels(task_data)
    <span class="hljs-comment"># ['Te1', 'Te2', 'Ti1', 'Ti2', ...]</span>
    
    <span class="hljs-comment"># 2. 逐个通道分析</span>
    <span class="hljs-keyword">for</span> channel <span class="hljs-keyword">in</span> temp_channels:
        temp_data = task_data[channel].values
        
        <span class="hljs-comment"># 跳过全为NaN的通道</span>
        <span class="hljs-keyword">if</span> np.<span class="hljs-built_in">all</span>(np.isnan(temp_data)):
            <span class="hljs-keyword">continue</span>
        
        <span class="hljs-comment"># 处理缺失值(前向填充)</span>
        temp_data = self._handle_missing_values(temp_data)
        
        <span class="hljs-comment"># 执行6种检测</span>
        predictions.extend(self._detect_rise_phases(time, temp_data, channel))
        predictions.extend(self._detect_peak_moments(time, temp_data, channel))
        predictions.extend(self._detect_fall_phases(time, temp_data, channel))
        predictions.extend(self._detect_anomalies(time, temp_data, channel))
        predictions.extend(self._detect_plateau_phases(time, temp_data, channel))
        predictions.extend(
            self.non_cyclic_detector.detect_non_cyclic_patterns(
                time, temp_data, channel
            )
        )
    
    <span class="hljs-keyword">return</span> predictions
</code></pre>
<hr/>
<h2 data-id="heading-18">四、实战应用:真实科研场景</h2>
<h3 data-id="heading-19">场景1:等离子体放电数据分析</h3>
<p><strong>背景</strong>:SUNIST托卡马克装置,研究等离子体约束</p>
<p><strong>数据特征</strong>:</p>
<ul>
<li>10个电子温度通道(Te1-Te10)</li>
<li>8个离子温度通道(Ti1-Ti8)</li>
<li>采样率:100kHz</li>
<li>每次放电持续50-100ms</li>
</ul>
<p><strong>ML Backend应用</strong>:</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 输入:CSV文件</span>
shot_12345.csv:
  time,   Te1,   Te2,   Ti1,   ...
  <span class="hljs-number">0.001</span>,  <span class="hljs-number">500</span>,   <span class="hljs-number">480</span>,   <span class="hljs-number">450</span>,   ...
  <span class="hljs-number">0.002</span>,  <span class="hljs-number">850</span>,   <span class="hljs-number">820</span>,   <span class="hljs-number">780</span>,   ...
  <span class="hljs-number">0.003</span>, <span class="hljs-number">1200</span>,  <span class="hljs-number">1150</span>,  <span class="hljs-number">1100</span>,   ...
  ...

<span class="hljs-comment"># 预测输出</span>
predictions = [
    <span class="hljs-comment"># 通道Te1</span>
    Prediction(label=<span class="hljs-string">"Te1_上升阶段"</span>, start=<span class="hljs-number">0.001</span>, end=<span class="hljs-number">0.015</span>),
    Prediction(label=<span class="hljs-string">"Te1_高峰值"</span>, start=<span class="hljs-number">0.018</span>, end=<span class="hljs-literal">None</span>),
    Prediction(label=<span class="hljs-string">"Te1_下降阶段"</span>, start=<span class="hljs-number">0.020</span>, end=<span class="hljs-number">0.040</span>),
    
    <span class="hljs-comment"># 通道Te2</span>
    Prediction(label=<span class="hljs-string">"Te2_上升阶段"</span>, start=<span class="hljs-number">0.002</span>, end=<span class="hljs-number">0.016</span>),
    Prediction(label=<span class="hljs-string">"Te2_持续高温"</span>, start=<span class="hljs-number">0.018</span>, end=<span class="hljs-number">0.035</span>),  <span class="hljs-comment"># 异常!</span>
    ...
]
</code></pre>
<p><strong>科研价值</strong>:</p>
<ol>
<li><strong>快速筛选</strong>:从100次实验中快速找到异常放电</li>
<li><strong>统计分析</strong>:批量分析峰值温度分布</li>
<li><strong>参数优化</strong>:对比不同实验参数下的温度曲线特征</li>
</ol>
<h3 data-id="heading-20">场景2:材料热处理工艺优化</h3>
<p><strong>背景</strong>:金属热处理厂,优化淬火工艺</p>
<p><strong>需求</strong>:</p>
<ul>
<li>分析加热速率对材料性能的影响</li>
<li>对比不同冷却曲线</li>
</ul>
<p><strong>ML Backend应用</strong>:</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 工艺1:快速加热</span>
prediction1 = [
    Prediction(label=<span class="hljs-string">"temp_快速上升"</span>, start=<span class="hljs-number">0</span>, end=<span class="hljs-number">30</span>),  <span class="hljs-comment"># 30秒升温</span>
    Prediction(label=<span class="hljs-string">"temp_高温平台期"</span>, start=<span class="hljs-number">30</span>, end=<span class="hljs-number">180</span>),  <span class="hljs-comment"># 保温150秒</span>
    Prediction(label=<span class="hljs-string">"temp_快速下降"</span>, start=<span class="hljs-number">180</span>, end=<span class="hljs-number">210</span>)  <span class="hljs-comment"># 30秒冷却</span>
]

<span class="hljs-comment"># 工艺2:缓慢加热</span>
prediction2 = [
    Prediction(label=<span class="hljs-string">"temp_上升阶段"</span>, start=<span class="hljs-number">0</span>, end=<span class="hljs-number">120</span>),  <span class="hljs-comment"># 120秒升温</span>
    Prediction(label=<span class="hljs-string">"temp_高温平台期"</span>, start=<span class="hljs-number">120</span>, end=<span class="hljs-number">270</span>),  <span class="hljs-comment"># 保温150秒</span>
    Prediction(label=<span class="hljs-string">"temp_下降阶段"</span>, start=<span class="hljs-number">270</span>, end=<span class="hljs-number">360</span>)  <span class="hljs-comment"># 90秒冷却</span>
]

<span class="hljs-comment"># 自动对比分析</span>
compare_report = {
    <span class="hljs-string">'加热速率'</span>: <span class="hljs-string">'工艺1:50℃/s, 工艺2:12.5℃/s'</span>,
    <span class="hljs-string">'保温稳定性'</span>: <span class="hljs-string">'工艺1:±5℃, 工艺2:±2℃'</span>,
    <span class="hljs-string">'冷却速率'</span>: <span class="hljs-string">'工艺1:50℃/s, 工艺2:16.7℃/s'</span>
}
</code></pre>
<p><strong>工业价值</strong>:</p>
<ul>
<li>标准化工艺曲线标注</li>
<li>快速对比不同批次</li>
<li>质量追溯分析</li>
</ul>
<h3 data-id="heading-21">场景3:非周期性事件研究</h3>
<p><strong>背景</strong>:研究等离子体不稳定性现象</p>
<p><strong>传统方法问题</strong>:</p>
<ul>
<li>只检测周期性升-峰-降模式</li>
<li>异常的持续高温被当作"正常的峰值"</li>
<li><strong>遗漏关键物理现象</strong></li>
</ul>
<p><strong>非周期性检测价值</strong>:</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 正常放电</span>
normal_discharge = {
    <span class="hljs-string">'pattern'</span>: <span class="hljs-string">'周期性'</span>,
    <span class="hljs-string">'peak_temp'</span>: <span class="hljs-number">1500</span>,
    <span class="hljs-string">'duration'</span>: <span class="hljs-number">2</span>,  <span class="hljs-comment"># 峰值持续2ms</span>
    <span class="hljs-string">'label'</span>: <span class="hljs-string">'Te1_高峰值'</span>
}

<span class="hljs-comment"># 异常放电(失稳)</span>
abnormal_discharge = {
    <span class="hljs-string">'pattern'</span>: <span class="hljs-string">'非周期性'</span>,
    <span class="hljs-string">'peak_temp'</span>: <span class="hljs-number">1600</span>,
    <span class="hljs-string">'duration'</span>: <span class="hljs-number">12</span>,  <span class="hljs-comment"># 持续12ms!</span>
    <span class="hljs-string">'label'</span>: <span class="hljs-string">'Te1_严重持续高温'</span>,  <span class="hljs-comment"># 新标签!</span>
    <span class="hljs-string">'physical_meaning'</span>: <span class="hljs-string">'等离子体约束失效'</span>
}
</code></pre>
<p><strong>科研突破</strong>:</p>
<ul>
<li>发现新的物理现象</li>
<li>建立失稳预警模型</li>
<li>优化实验参数</li>
</ul>
<hr/>
<h2 data-id="heading-22">五、技术优化与最佳实践</h2>
<h3 data-id="heading-23">5.1 性能优化</h3>
<h4 data-id="heading-24">优化1:向量化计算</h4>
<p><strong>问题</strong>:逐点循环计算慢</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># ❌ 低效写法</span>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(temp_data)):
    <span class="hljs-keyword">if</span> temp_data[i] &gt; threshold:
        ...

<span class="hljs-comment"># ✅ 高效写法(向量化)</span>
mask = temp_data &gt; threshold  <span class="hljs-comment"># NumPy向量化,快100倍</span>
high_temp_indices = np.where(mask)[<span class="hljs-number">0</span>]
</code></pre>
<h4 data-id="heading-25">优化2:多通道并行</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> concurrent.futures <span class="hljs-keyword">import</span> ThreadPoolExecutor

<span class="hljs-keyword">def</span> <span class="hljs-title function_">predict_parallel</span>(<span class="hljs-params">self, task_data</span>):
    temp_channels = self._extract_temperature_channels(task_data)
    
    <span class="hljs-comment"># 并行处理多个通道</span>
    <span class="hljs-keyword">with</span> ThreadPoolExecutor(max_workers=<span class="hljs-number">4</span>) <span class="hljs-keyword">as</span> executor:
        futures = []
        <span class="hljs-keyword">for</span> channel <span class="hljs-keyword">in</span> temp_channels:
            future = executor.submit(
                self._predict_single_channel, 
                task_data, channel
            )
            futures.append(future)
        
        <span class="hljs-comment"># 汇总结果</span>
        all_predictions = []
        <span class="hljs-keyword">for</span> future <span class="hljs-keyword">in</span> futures:
            all_predictions.extend(future.result())
    
    <span class="hljs-keyword">return</span> all_predictions
</code></pre>
<p><strong>加速效果</strong>:</p>
<ul>
<li>单线程:18个通道 × 100ms = 1800ms</li>
<li>4线程并行:18个通道 ÷ 4 × 100ms = 450ms</li>
<li><strong>加速4倍</strong></li>
</ul>
<h3 data-id="heading-26">5.2 阈值调优策略</h3>
<p><strong>经验值推荐</strong>:</p>





























<table><thead><tr><th>物理场景</th><th>temp_rise_threshold</th><th>temp_fall_threshold</th><th>gradient_threshold</th></tr></thead><tbody><tr><td>等离子体放电</td><td>1000 eV</td><td>500 eV</td><td>100 eV/ms</td></tr><tr><td>金属热处理</td><td>800 ℃</td><td>400 ℃</td><td>50 ℃/s</td></tr><tr><td>化学反应</td><td>300 K</td><td>150 K</td><td>20 K/min</td></tr></tbody></table>
<p><strong>调优方法</strong>:</p>
<ol>
<li><strong>从宽到严</strong>:初始阈值设低,捕获所有可能事件</li>
<li><strong>统计分析</strong>:分析预测结果分布,找到最优阈值</li>
<li><strong>在线学习</strong>:根据用户反馈自动调整</li>
</ol>
<h3 data-id="heading-27">5.3 数据质量处理</h3>
<h4 data-id="heading-28">处理1:缺失值处理</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">_handle_missing_values</span>(<span class="hljs-params">self, temp_data</span>):
    <span class="hljs-string">"""前向填充策略"""</span>
    temp_data_clean = temp_data.copy()
    
    <span class="hljs-comment"># 逐点前向填充</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(temp_data_clean)):
        <span class="hljs-keyword">if</span> np.isnan(temp_data_clean[i]):
            temp_data_clean[i] = temp_data_clean[i-<span class="hljs-number">1</span>]
    
    <span class="hljs-comment"># 处理首位NaN</span>
    <span class="hljs-keyword">if</span> np.isnan(temp_data_clean[<span class="hljs-number">0</span>]):
        first_valid = np.where(~np.isnan(temp_data_clean))[<span class="hljs-number">0</span>]
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(first_valid) &gt; <span class="hljs-number">0</span>:
            temp_data_clean[<span class="hljs-number">0</span>] = temp_data_clean[first_valid[<span class="hljs-number">0</span>]]
    
    <span class="hljs-keyword">return</span> temp_data_clean
</code></pre>
<h4 data-id="heading-29">处理2:异常值过滤</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">_filter_outliers</span>(<span class="hljs-params">self, temp_data</span>):
    <span class="hljs-string">"""3σ准则过滤异常值"""</span>
    mean = np.nanmean(temp_data)
    std = np.nanstd(temp_data)
    
    <span class="hljs-comment"># 超过±3σ的点视为异常</span>
    outlier_mask = np.<span class="hljs-built_in">abs</span>(temp_data - mean) &gt; <span class="hljs-number">3</span> * std
    
    <span class="hljs-comment"># 用相邻点平均值替代</span>
    temp_data_clean = temp_data.copy()
    outlier_indices = np.where(outlier_mask)[<span class="hljs-number">0</span>]
    
    <span class="hljs-keyword">for</span> idx <span class="hljs-keyword">in</span> outlier_indices:
        <span class="hljs-keyword">if</span> idx &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> idx &lt; <span class="hljs-built_in">len</span>(temp_data) - <span class="hljs-number">1</span>:
            temp_data_clean[idx] = (temp_data[idx-<span class="hljs-number">1</span>] + temp_data[idx+<span class="hljs-number">1</span>]) / <span class="hljs-number">2</span>
    
    <span class="hljs-keyword">return</span> temp_data_clean
</code></pre>
<hr/>
<h2 data-id="heading-30">六、总结与展望</h2>
<h3 data-id="heading-31">6.1 核心创新点</h3>
<ol>
<li>
<p><strong>多模式联合检测</strong></p>
<ul>
<li>6种温度模式全覆盖</li>
<li>周期性+非周期性双重检测</li>
</ul>
</li>
<li>
<p><strong>自适应阈值优化</strong></p>
<ul>
<li>在线学习机制</li>
<li>根据用户反馈自动调整</li>
</ul>
</li>
<li>
<p><strong>工程化设计</strong></p>
<ul>
<li>多通道并行处理</li>
<li>完善的异常处理</li>
<li>标准化Label Studio接口</li>
</ul>
</li>
</ol>
<h3 data-id="heading-32">6.2 应用场景总结</h3>






























<table><thead><tr><th>领域</th><th>典型应用</th><th>核心价值</th></tr></thead><tbody><tr><td>等离子体物理</td><td>放电数据分析</td><td>加速科研迭代</td></tr><tr><td>材料科学</td><td>热处理工艺</td><td>工艺标准化</td></tr><tr><td>化学工程</td><td>反应过程监控</td><td>异常预警</td></tr><tr><td>能源</td><td>反应堆温度监控</td><td>安全保障</td></tr></tbody></table>
<h3 data-id="heading-33">6.3 未来发展方向</h3>
<h4 data-id="heading-34">方向1:深度学习模型</h4>
<p><strong>思路</strong>:用LSTM/Transformer学习温度时序模式</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TemperatureLSTM</span>(nn.Module):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        self.lstm = nn.LSTM(input_size=<span class="hljs-number">1</span>, hidden_size=<span class="hljs-number">64</span>, num_layers=<span class="hljs-number">2</span>)
        self.classifier = nn.Linear(<span class="hljs-number">64</span>, <span class="hljs-number">6</span>)  <span class="hljs-comment"># 6种模式分类</span>
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, temp_sequence</span>):
        <span class="hljs-comment"># 输入:[batch, seq_len, 1]</span>
        <span class="hljs-comment"># 输出:[batch, 6] 每种模式的概率</span>
        ...
</code></pre>
<p><strong>优势</strong>:</p>
<ul>
<li>自动学习特征,无需手工设计阈值</li>
<li>捕获长期依赖关系</li>
</ul>
<h4 data-id="heading-35">方向2:多物理量融合</h4>
<p><strong>思路</strong>:结合温度+密度+磁场多种信号</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MultiPhysicsPredictor</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">predict</span>(<span class="hljs-params">self, temperature, density, magnetic_field</span>):
        <span class="hljs-comment"># 融合多种物理量,综合判断</span>
        ...
</code></pre>
<p><strong>价值</strong>:</p>
<ul>
<li>更准确的事件检测</li>
<li>理解物理机制的关联</li>
</ul>
<h4 data-id="heading-36">方向3:实时预测</h4>
<p><strong>思路</strong>:流式处理,边采集边预测</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">StreamingPredictor</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        self.buffer = []
        
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">on_new_data</span>(<span class="hljs-params">self, new_point</span>):
        self.buffer.append(new_point)
        
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.buffer) &gt;= window_size:
            prediction = self.predict(self.buffer)
            self.emit_prediction(prediction)
</code></pre>
<p><strong>应用</strong>:</p>
<ul>
<li>实时实验监控</li>
<li>异常即时预警</li>
</ul>
<hr/>
<h2 data-id="heading-37">附录:快速上手</h2>
<h3 data-id="heading-38">1. 数据格式要求</h3>
<pre><code class="hljs language-csv" lang="csv">time, Te1, Te2, Ti1, Ti2
0.001, 500, 480, 450, 430
0.002, 850, 820, 780, 750
0.003, 1200, 1150, 1100, 1050
...
</code></pre>
<p><strong>要求</strong>:</p>
<ul>
<li>必须包含<code>time</code>列</li>
<li>温度列名包含<code>te/ti/temp/temperature</code>关键字</li>
<li>时间单位:毫秒(ms)</li>
</ul>
<h3 data-id="heading-39">2. Label Studio配置</h3>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">View</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">TimeSeries</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"ts"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$csv"</span> <span class="hljs-attr">valueType</span>=<span class="hljs-string">"url"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">Channel</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"Te1"</span> <span class="hljs-attr">strokeColor</span>=<span class="hljs-string">"#1f77b4"</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">Channel</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"Te2"</span> <span class="hljs-attr">strokeColor</span>=<span class="hljs-string">"#ff7f0e"</span>/&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">TimeSeries</span>&gt;</span>
  
  <span class="hljs-tag">&lt;<span class="hljs-name">TimeSeriesLabels</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"temperature_events"</span> <span class="hljs-attr">toName</span>=<span class="hljs-string">"ts"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">Label</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"上升阶段"</span> <span class="hljs-attr">background</span>=<span class="hljs-string">"#4CAF50"</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">Label</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"峰值时刻"</span> <span class="hljs-attr">background</span>=<span class="hljs-string">"#FF5722"</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">Label</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"下降阶段"</span> <span class="hljs-attr">background</span>=<span class="hljs-string">"#2196F3"</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">Label</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"持续高温"</span> <span class="hljs-attr">background</span>=<span class="hljs-string">"#FF9800"</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">Label</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"平台期"</span> <span class="hljs-attr">background</span>=<span class="hljs-string">"#9C27B0"</span>/&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">TimeSeriesLabels</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span>
</code></pre>
<h3 data-id="heading-40">3. 测试预测</h3>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 启动服务</span>
python _wsgi.py

<span class="hljs-comment"># 测试API</span>
curl -X POST http://localhost:9090/predict \
  -H <span class="hljs-string">"Content-Type: application/json"</span> \
  -d <span class="hljs-string">'{
    "tasks": [{
      "data": {
        "shot": 12345,
        "csv": "http://example.com/shot_12345.csv"
      }
    }]
  }'</span>
</code></pre>
<hr/>
<p><strong>总结</strong>:温度标注ML Backend将<strong>复杂的温度时序分析</strong>转化为<strong>自动化智能标注</strong>,通过6种模式识别算法(上升、峰值、下降、异常、平台、非周期性),全面覆盖温度曲线特征。特别是创新性的<strong>非周期性检测</strong>,填补了传统周期性检测的盲区,能够发现持续高温、异常平台等重要物理现象,为等离子体物理、材料科学等领域的科研工作提供了<strong>高效、标准化、智能化</strong>的数据分析工具。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[uni-app 上架到 App Store 的项目流程，构建、打包与使用开心上架（Appuploader）上传]]></title>    <link>https://juejin.cn/post/7578693994368794624</link>    <guid>https://juejin.cn/post/7578693994368794624</guid>    <pubDate>2025-12-01T09:35:14.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7578693994368794624" data-draft-id="7578820431017508879" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="uni-app 上架到 App Store 的项目流程，构建、打包与使用开心上架（Appuploader）上传"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2025-12-01T09:35:14.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="bcbnb"/> <meta itemprop="url" content="https://juejin.cn/user/895474073078377"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            uni-app 上架到 App Store 的项目流程，构建、打包与使用开心上架（Appuploader）上传
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/895474073078377/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    bcbnb
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-01T09:35:14.000Z" title="Mon Dec 01 2025 09:35:14 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-01
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在跨端项目中，uni-app 提供了极高的开发效率，但当应用最终要上架到 App Store 时，团队会突然面对另一种“生态差异”：iOS 审核的严格、证书体系的封闭、构建平台的多样化，以及跨端项目本身的结构特点。</p>
<p>一款基于 uni-app 的移动应用，从开发到上架的过程，往往不是一条直线，而更像是一组由不同角色共同完成的链路。本文以一次真实项目的协作方式为蓝本，整理出一条可落地的“uni-app 上架工作流”。</p>
<hr/>
<h2 data-id="heading-0"><strong>一、uni-app 项目上架的难点不在代码，而在“交付链路”</strong></h2>
<p>uni-app 在开发阶段几乎不会带来额外负担，框架本身轻量、构建快、跨端一致性高。
但一到上架阶段，团队会明显感受到：</p>
<ul>
<li><strong>iOS 要求严格程度远超 Android</strong></li>
<li><strong>审核流程更强调产品体验与隐私合规</strong></li>
<li><strong>证书体系需要团队协作</strong></li>
<li><strong>构建环境通常跨平台（Windows、Mac、CI）</strong></li>
<li><strong>上传工具需要适配团队操作系统差异</strong></li>
</ul>
<p>这意味着——
<strong>uni-app 代码简单，但上架流程不一定简单。</strong></p>
<p>因此我们必须从团队协作角度来理解上架，而不是从技术框架本身出发。</p>
<hr/>
<h2 data-id="heading-1"><strong>二、构建阶段的两条路径：本地 Xcode 与 HBuilderX 云打包</strong></h2>
<p>团队一般有两类构建方式：</p>
<hr/>
<h3 data-id="heading-2"><strong>1. 纯本地构建：导出 Xcode 工程（适合有 iOS 研发的团队）</strong></h3>
<p>流程：</p>
<ul>
<li>HBuilderX → 导出 iOS 原生工程</li>
<li>进入 macOS，使用 Xcode Archive</li>
<li>应用原生插件、证书、描述文件</li>
<li>导出 IPA</li>
</ul>
<p>优点：</p>
<ul>
<li>灵活，可引入原生能力</li>
<li>适合复杂项目</li>
</ul>
<p>缺点：</p>
<ul>
<li>必须有 Mac</li>
<li>构建依赖较重</li>
</ul>
<hr/>
<h3 data-id="heading-3"><strong>2. 云打包：HBuilderX 官方云编译（多数团队使用）</strong></h3>
<p>流程：</p>
<ul>
<li>直接上传项目</li>
<li>云端自动完成构建</li>
<li>输出 IPA 或 Xcode 工程包</li>
</ul>
<p>优点：</p>
<ul>
<li>不需要 Mac 或 Xcode</li>
<li>适合 Windows / Linux 团队</li>
<li>快速、高稳定性</li>
</ul>
<p>缺点：</p>
<ul>
<li>原生能力需要插件支持</li>
<li>定制化空间不如本地构建</li>
</ul>
<p>大多数 uni-app 团队最终会选择“云打包 + 外部上传”这一组合模式。
<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ed0d822537894568b13ac6ac6e4e2d61~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgYmNibmI=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765186514&amp;x-signature=aH01Z%2FFB1gbUanaYaRIsUJ5SBFg%3D" alt="hb打包" loading="lazy"/></p>
<hr/>
<h2 data-id="heading-4"><strong>三、证书管理：uni-app 上架与原生项目完全一致</strong></h2>
<p>虽然项目是 uni-app，但 iOS 签名体系是统一的：</p>
<ul>
<li>App Store 发布证书</li>
<li>App Store 描述文件</li>
<li>Bundle ID</li>
<li>entitlements 权限声明</li>
</ul>
<p>许多跨端团队主要使用 Windows，因此证书管理不再依赖 Mac 钥匙串，而是使用开心上架（Appuploader）证书生成方式，使证书与描述文件可以在不同机器共享，避免：</p>
<ul>
<li>证书数量超限</li>
<li>钥匙串导出失败</li>
<li>多人覆盖 profile</li>
<li>CI 无法导入 p12</li>
</ul>
<p>这是所有跨端团队上架结构中最关键的部分。
<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a626fe03285b4cbfac9bea9036afe4ef~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgYmNibmI=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765186514&amp;x-signature=KcCj4mY%2FwAeYyOlAHUBa5vPZoBY%3D" alt="证书生成" loading="lazy"/></p>
<hr/>
<h2 data-id="heading-5"><strong>四、IPA 上传：uni-app 团队最容易“卡住”的环节</strong></h2>
<p>构建完成后，IPA 必须上传到 App Store Connect。
这一部分最常出现差异，因为不同成员的操作系统不同：</p>
<hr/>
<h3 data-id="heading-6"><strong>1. macOS 用户：Transporter + Xcode Organizer</strong></h3>
<p>特点：</p>
<ul>
<li>官方、稳定</li>
<li>UI 操作方便</li>
<li>适合产品或运营人员提交</li>
</ul>
<p>缺点：
必须使用 Mac。</p>
<hr/>
<h3 data-id="heading-7"><strong>2. Windows / Linux 用户：开心上架（Appuploader）跨平台命令行上传工具</strong></h3>
<p>在跨端团队中非常常见，因为：</p>
<ul>
<li>多数成员没有 Mac</li>
<li>CI/CD 在 Linux/Windows 上运行</li>
<li>需要自动化上传到 TestFlight</li>
<li>需要跨角色快速推送版本</li>
</ul>
<p>使用方式类似：</p>
<pre><code class="hljs language-bash" lang="bash">appuploader_cli \
  -u ios@team.com \
  -p xxx-xxx-xxx-xxx \
  -c 2 \
  -f uniapp_build/app.ipa
</code></pre>
<p>通过命令行上传，可以完全绕过“必须要有 Mac”的限制，这对 Windows 团队意义非常大。</p>
<p>图形化界面：
<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/388f4a9699f74b949ca71df4f9ed01bb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgYmNibmI=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765186514&amp;x-signature=fkpZdlAtPn%2F4EUE4OTeoaj6NyBA%3D" alt="IPA上传" loading="lazy"/></p>
<hr/>
<h2 data-id="heading-8"><strong>五、App Store Connect 配置：uni-app 项目最耗时间的步骤</strong></h2>
<p>上传完成后，运营与产品通常需要填写以下内容：</p>
<ul>
<li>应用截图（必须真实，而非模型图）</li>
<li>功能描述</li>
<li>隐私标签</li>
<li>审核说明（含账号、进入路径）</li>
<li>关键词</li>
<li>年龄评级</li>
<li>构建选择</li>
</ul>
<p>这些内容与 uni-app 关系不大，但会直接影响审核速度。</p>
<p>特别要注意：</p>
<p><strong>截图必须来自实际应用，不要用模板或非实际界面。</strong>
uni-app 应用被拒 4.2 的一个常见原因就是“截图与实际应用不一致”。</p>
<hr/>
<h2 data-id="heading-9"><strong>六、审核阶段：uni-app 团队常见的拒审类型</strong></h2>
<p>结合多次项目经验，总结出 uni-app 上架最常出现的三类拒审：</p>
<hr/>
<h3 data-id="heading-10"><strong>1. 2.1 功能不可用</strong></h3>
<p>主要原因：</p>
<ul>
<li>H5 请求被域名限制</li>
<li>后端环境误关服务</li>
<li>必须登录但审核账号无权限</li>
</ul>
<hr/>
<h3 data-id="heading-11"><strong>2. 4.2 内容与原生结构不匹配</strong></h3>
<p>如果界面过于网页化、动画和结构不像原生应用，可能触发 4.2（最低功能要求）。</p>
<p>解决方式通常是：</p>
<ul>
<li>添加原生导航</li>
<li>增强页面结构与交互</li>
<li>保证主功能清晰可达</li>
</ul>
<hr/>
<h3 data-id="heading-12"><strong>3. 5.1.1 权限说明不充分</strong></h3>
<p>尤其是：</p>
<ul>
<li>相册</li>
<li>相机</li>
<li>通讯录</li>
<li>定位</li>
</ul>
<p>Info.plist 权限弹窗必须具体说明用途。</p>
<hr/>
<h2 data-id="heading-13"><strong>团队协作版 uni-app 上架流程</strong></h2>
<p>一个成熟的 uni-app 上架协作流程通常如下：</p>
<pre><code class="hljs language-makefile" lang="makefile"><span class="hljs-section">A: 构建（CI 或云打包）</span>
<span class="hljs-section">B: 签名（证书统一管理）</span>
<span class="hljs-section">C: 上传（根据系统选择 Transporter / 开心上架Appuploader）</span>
<span class="hljs-section">D: App Store Connect 配置（运营）</span>
<span class="hljs-section">E: 审核说明 + 提交审核（产品/运营）</span>
<span class="hljs-section">F: 审核反馈处理（开发/后端/测试）</span>
</code></pre>
<p>这种分工明确的方式能最大化减少不必要的沟通成本，也能让项目在快速迭代时保持节奏稳定。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[海量数据集的AI自动化预测打标 -- 振动特征多标签分类]]></title>    <link>https://juejin.cn/post/7578460753210851355</link>    <guid>https://juejin.cn/post/7578460753210851355</guid>    <pubDate>2025-12-01T09:35:34.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7578460753210851355" data-draft-id="7578460753210818587" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="海量数据集的AI自动化预测打标 -- 振动特征多标签分类"/> <meta itemprop="keywords" content="算法"/> <meta itemprop="datePublished" content="2025-12-01T09:35:34.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="语落心生"/> <meta itemprop="url" content="https://juejin.cn/user/2875978147955741"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            海量数据集的AI自动化预测打标 -- 振动特征多标签分类
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2875978147955741/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    语落心生
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-01T09:35:34.000Z" title="Mon Dec 01 2025 09:35:34 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-01
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读12分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>振动特征多标签预测: <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FSTARTORUS%2Ftok-label%2Fpull%2F5" target="_blank" title="https://github.com/STARTORUS/tok-label/pull/5" ref="nofollow noopener noreferrer">github.com/STARTORUS/t…</a></p>
<h2 data-id="heading-0">概述:设备健康的"智能医生"</h2>
<p>在工业4.0时代,预测性维护(PHM - Prognostics and Health Management)正在取代传统的"坏了再修"和"定期维护"模式。想象一下,一台运转了5年的大型旋转设备——风力发电机、水泵、压缩机——它就像人体一样,会通过"振动"这种"生命体征"表达自己的健康状况。</p>
<p><strong>振动PHM ML Backend</strong>就是设备的<strong>智能健康管家</strong>,通过分析振动信号,自动识别设备的转速水平、故障类型和健康评分,实现从"事后维修"到"预测性维护"的跨越。</p>
<hr/>
<h2 data-id="heading-1">一、业务价值:Why - 为什么需要振动智能诊断?</h2>
<h3 data-id="heading-2">1.1 工业痛点</h3>
<p><strong>场景1:风电场运维困境</strong> 💨<br/>
某海上风电场,100台风力发电机:</p>
<ul>
<li>每台价值5000万元</li>
<li>主轴承故障导致停机,损失50万/天</li>
<li>传统维护:每年定期检修,成本高昂</li>
<li><strong>问题</strong>:60%的轴承更换时还能继续使用(浪费),5%的故障未能及时发现(停产)</li>
</ul>
<p><strong>场景2:水泵站突发故障</strong> 💧<br/>
城市供水泵站关键设备:</p>
<ul>
<li>凌晨3点突发轴承损坏</li>
<li>全城停水12小时</li>
<li>抢修费用是计划维护的5倍</li>
<li><strong>如果能提前1周预警,损失可避免95%</strong></li>
</ul>
<p><strong>场景3:压缩机健康监控</strong> ⚙️<br/>
化工厂大型压缩机:</p>
<ul>
<li>振动异常可能导致连锁故障</li>
<li>人工巡检:每天2次,无法24小时监控</li>
<li>依赖老师傅经验,标准不统一</li>
<li><strong>年轻工人难以快速掌握诊断技能</strong></li>
</ul>
<h3 data-id="heading-3">1.2 PHM ML Backend的核心价值</h3>
<p>通过<strong>振动信号智能分析</strong>,实现:</p>
<p>✅ <strong>故障预警</strong>:提前7-14天预测轴承/齿轮故障<br/>
✅ <strong>成本降低40%</strong>:按需维护替代定期维护<br/>
✅ <strong>停机时间减少60%</strong>:计划性停机替代突发故障<br/>
✅ <strong>设备寿命延长20%</strong>:及时维护避免连锁损伤</p>
<p><strong>经济效益测算</strong>:</p>
<pre><code class="hljs language-markdown" lang="markdown">某制造厂案例:
<span class="hljs-bullet">-</span> 关键设备:50台
<span class="hljs-bullet">-</span> 部署PHM系统成本:200万
<span class="hljs-bullet">-</span> 年收益:
<span class="hljs-bullet">  *</span> 避免突发故障:300万
<span class="hljs-bullet">  *</span> 降低维护成本:150万
<span class="hljs-bullet">  *</span> 延长设备寿命:100万
  合计:550万/年
<span class="hljs-bullet">-</span> ROI:5个月回本
</code></pre>
<hr/>
<h2 data-id="heading-4">二、系统架构:What - 振动PHM是什么?</h2>
<h3 data-id="heading-5">2.1 整体架构</h3>
<pre><code class="hljs language-mermaid" lang="mermaid">graph TB
    subgraph "数据采集层"
        A1[振动传感器&lt;br/&gt;加速度计] --&gt; A2[数据采集卡&lt;br/&gt;1kHz采样]
        A3[转速传感器&lt;br/&gt;RPM] --&gt; A2
        A2 --&gt; A4[时序数据库]
    end
    
    subgraph "Label Studio前端"
        B1[时序标注界面] --&gt; B2[任务管理]
    end
    
    subgraph "ML Backend核心"
        C1[_wsgi.py服务] --&gt; C2[VibrationPHMModel&lt;br/&gt;业务编排]
        C2 --&gt; C3[VibrationPredictor&lt;br/&gt;多标签预测器]
    end
    
    subgraph "算法引擎层"
        D1[特征提取&lt;br/&gt;extract_features]
        D2[转速段预测&lt;br/&gt;predict_speed_segments]
        D3[故障诊断&lt;br/&gt;predict_fault_type]
        D4[健康评分&lt;br/&gt;predict_quality_score]
    end
    
    subgraph "信号处理库"
        E1[时域特征&lt;br/&gt;RMS/峰值/峰度]
        E2[频域特征&lt;br/&gt;FFT/Welch PSD]
        E3[sklearn&lt;br/&gt;IsolationForest]
    end
    
    A4 --&gt; C2
    B2 --&gt;|HTTP API| C1
    C3 --&gt; D1
    C3 --&gt; D2
    C3 --&gt; D3
    C3 --&gt; D4
    
    D1 --&gt; E1
    D1 --&gt; E2
    D3 --&gt; E3
    
    style C3 fill:#4CAF50,color:#fff
    style D1 fill:#2196F3,color:#fff
    style D3 fill:#FF5722,color:#fff
</code></pre>
<h3 data-id="heading-6">2.2 核心组件详解</h3>
<h4 data-id="heading-7">🎯 <strong>VibrationPHMModel</strong> - 业务协调层</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">VibrationPHMModel</span>(<span class="hljs-title class_ inherited__">LabelStudioMLBase</span>):
    <span class="hljs-string">"""振动数据PHM预测性维护ML后端模型"""</span>
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">setup</span>(<span class="hljs-params">self</span>):
        self.<span class="hljs-built_in">set</span>(<span class="hljs-string">"model_version"</span>, <span class="hljs-string">"vibration_phm_v1.0"</span>)
        self.predictor = VibrationPredictor()
        
        <span class="hljs-comment"># 多标签配置</span>
        self.label_groups = {
            <span class="hljs-string">'speed_level'</span>: [<span class="hljs-string">'低转速'</span>, <span class="hljs-string">'中转速'</span>, <span class="hljs-string">'高转速'</span>],
            <span class="hljs-string">'fault_type'</span>: [<span class="hljs-string">'正常'</span>, <span class="hljs-string">'不平衡'</span>, <span class="hljs-string">'轴承故障'</span>, <span class="hljs-string">'齿轮故障'</span>],
            <span class="hljs-string">'quality_score'</span>: <span class="hljs-string">'number'</span>,  <span class="hljs-comment"># 0-100健康分数</span>
            <span class="hljs-string">'confidence_level'</span>: <span class="hljs-string">'number'</span>  <span class="hljs-comment"># 置信度</span>
        }
</code></pre>
<p><strong>设计亮点</strong>:</p>
<ul>
<li><strong>多标签输出</strong>:一次预测返回转速/故障/健康度多个维度</li>
<li><strong>在线学习</strong>:<code>fit()</code>方法支持标注数据反馈优化</li>
</ul>
<h4 data-id="heading-8">🧠 <strong>VibrationPredictor</strong> - 智能诊断引擎</h4>
<p>这是系统的"诊断大脑",实现4个核心预测功能:</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">VibrationPredictor</span>(<span class="hljs-title class_ inherited__">BasePredictor</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">predict</span>(<span class="hljs-params">self, task_data</span>):
        <span class="hljs-comment"># 1. 提取特征(时域+频域)</span>
        features = self.extract_features(task_data)
        
        <span class="hljs-comment"># 2. 转速段预测</span>
        speed_predictions = self.predict_speed_segments(task_data)
        
        <span class="hljs-comment"># 3. 故障类型诊断</span>
        fault_predictions = self.predict_fault_type(task_data, features)
        
        <span class="hljs-comment"># 4. 健康质量评分</span>
        quality_prediction = self.predict_quality_score(features)
        
        <span class="hljs-keyword">return</span> speed_predictions + fault_predictions + [quality_prediction]
</code></pre>
<hr/>
<h2 data-id="heading-9">三、技术实现:How - 诊断算法深度剖析</h2>
<h3 data-id="heading-10">3.1 特征工程:从振动信号到诊断特征</h3>
<p>振动信号本质是<strong>时序数据</strong>,需要转换为<strong>机器可理解的特征向量</strong>。</p>
<h4 data-id="heading-11">3.1.1 时域特征</h4>
<p><strong>物理意义</strong>:描述振动幅值的统计特性</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">extract_time_domain_features</span>(<span class="hljs-params">self, vibration_signal</span>):
    <span class="hljs-string">"""
    时域特征提取
    """</span>
    features = {}
    
    <span class="hljs-comment"># 1. RMS均方根值 - 振动能量</span>
    <span class="hljs-comment"># 物理意义:表示振动强度的有效值</span>
    <span class="hljs-comment"># 应用:判断振动是否超标</span>
    features[<span class="hljs-string">'rms'</span>] = np.sqrt(np.mean(vibration_signal**<span class="hljs-number">2</span>))
    
    <span class="hljs-comment"># 2. 峰值 - 最大振幅</span>
    <span class="hljs-comment"># 物理意义:最严重的冲击程度</span>
    <span class="hljs-comment"># 应用:检测突发冲击(如轴承破损)</span>
    features[<span class="hljs-string">'peak'</span>] = np.<span class="hljs-built_in">max</span>(np.<span class="hljs-built_in">abs</span>(vibration_signal))
    
    <span class="hljs-comment"># 3. 峰值因子 = 峰值/RMS</span>
    <span class="hljs-comment"># 物理意义:冲击性指标</span>
    <span class="hljs-comment"># 正常值:3-4, 异常值:&gt;5(有冲击)</span>
    features[<span class="hljs-string">'crest_factor'</span>] = features[<span class="hljs-string">'peak'</span>] / <span class="hljs-built_in">max</span>(features[<span class="hljs-string">'rms'</span>], <span class="hljs-number">1e-6</span>)
    
    <span class="hljs-comment"># 4. 峰度(Kurtosis) - 分布形态</span>
    <span class="hljs-comment"># 物理意义:描述振动分布的"尖锐度"</span>
    <span class="hljs-comment"># 正常值:3(高斯分布), 异常值:&gt;4(有冲击)</span>
    features[<span class="hljs-string">'kurtosis'</span>] = stats.kurtosis(vibration_signal)
    
    <span class="hljs-comment"># 5. 偏度(Skewness) - 分布对称性</span>
    <span class="hljs-comment"># 物理意义:振动分布的偏斜程度</span>
    <span class="hljs-comment"># 正常值:接近0, 异常值:明显偏离0</span>
    features[<span class="hljs-string">'skewness'</span>] = stats.skew(vibration_signal)
    
    <span class="hljs-keyword">return</span> features
</code></pre>
<p><strong>特征与故障的关系</strong>:</p>

































<table><thead><tr><th>特征</th><th>正常值</th><th>轴承故障</th><th>不平衡</th><th>齿轮故障</th></tr></thead><tbody><tr><td>RMS</td><td>&lt;2.0</td><td>2-4(增大)</td><td>2-3(中等)</td><td>2-5(变化大)</td></tr><tr><td>峰值因子</td><td>3-4</td><td>5-8(冲击)</td><td>3-4(正常)</td><td>4-6(周期冲击)</td></tr><tr><td>峰度</td><td>3</td><td>5-10(尖峰)</td><td>3(正常)</td><td>4-6(周期性)</td></tr></tbody></table>
<h4 data-id="heading-12">3.1.2 频域特征</h4>
<p><strong>核心思想</strong>:不同故障在频谱上有特定"指纹"</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">extract_frequency_domain_features</span>(<span class="hljs-params">self, vibration_signal, fs=<span class="hljs-number">1000</span></span>):
    <span class="hljs-string">"""
    频域特征提取 - 使用Welch方法计算功率谱密度
    """</span>
    <span class="hljs-comment"># 1. 计算功率谱密度(PSD)</span>
    <span class="hljs-comment"># Welch方法:分段FFT取平均,降低噪声</span>
    freqs, psd = signal.welch(vibration_signal, fs=fs, nperseg=<span class="hljs-number">1024</span>)
    
    <span class="hljs-comment"># 2. 主频 - 能量最大的频率</span>
    <span class="hljs-comment"># 物理意义:旋转频率或其倍频</span>
    <span class="hljs-comment"># 应用:判断故障特征频率</span>
    features[<span class="hljs-string">'dominant_freq'</span>] = freqs[np.argmax(psd)]
    
    <span class="hljs-comment"># 3. 频谱质心 - 频率的"重心"</span>
    <span class="hljs-comment"># 物理意义:频率分布中心</span>
    <span class="hljs-comment"># 应用:高频故障(轴承)会使质心上移</span>
    features[<span class="hljs-string">'spectral_centroid'</span>] = np.<span class="hljs-built_in">sum</span>(freqs * psd) / np.<span class="hljs-built_in">sum</span>(psd)
    
    <span class="hljs-comment"># 4. 频谱滚降 - 85%能量对应的频率</span>
    <span class="hljs-comment"># 物理意义:高频能量占比</span>
    <span class="hljs-comment"># 应用:检测高频异常</span>
    cumsum_psd = np.cumsum(psd)
    rolloff_idx = np.where(cumsum_psd &gt;= <span class="hljs-number">0.85</span> * cumsum_psd[-<span class="hljs-number">1</span>])[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]
    features[<span class="hljs-string">'spectral_rolloff'</span>] = freqs[rolloff_idx]
    
    <span class="hljs-comment"># 5. 频谱带宽 - 频率分布的离散程度</span>
    <span class="hljs-comment"># 物理意义:频谱复杂度</span>
    <span class="hljs-comment"># 应用:复杂故障频谱带宽大</span>
    features[<span class="hljs-string">'spectral_bandwidth'</span>] = np.sqrt(
        np.<span class="hljs-built_in">sum</span>(((freqs - features[<span class="hljs-string">'spectral_centroid'</span>])**<span class="hljs-number">2</span>) * psd) / np.<span class="hljs-built_in">sum</span>(psd)
    )
    
    <span class="hljs-keyword">return</span> features
</code></pre>
<p><strong>频域故障诊断知识</strong>:</p>
<pre><code class="hljs language-makefile" lang="makefile"><span class="hljs-section">正常设备频谱:</span>
  PSD
   ▲
   │    ●(转速频率)
   │    │
   │────┴──────────────► Freq
   0   10Hz  ...  1kHz

<span class="hljs-section">轴承故障频谱:</span>
  PSD
   ▲    ●(转速)
   │    │  ● ● ●(高频谐波,轴承特征频率)
   │    │ ││ │
   │────┴─┴┴─┴────────► Freq
   0   10Hz  500Hz 1kHz

<span class="hljs-section">不平衡故障频谱:</span>
  PSD
   ▲
   │    ●●●(转速频率及其2x,3x倍频)
   │    │││
   │────┴┴┴───────────► Freq
   0   10Hz 20Hz 30Hz
</code></pre>
<h3 data-id="heading-13">3.2 转速段智能分割</h3>
<p><strong>业务场景</strong>:设备在不同转速下运行,需要自动分段标注</p>
<h4 data-id="heading-14">算法原理</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">predict_speed_segments</span>(<span class="hljs-params">self, data</span>):
    <span class="hljs-string">"""
    滑动窗口转速分段算法
    
    思路:
    1. 用滑动窗口统计每段平均转速
    2. 根据转速阈值分类(低/中/高)
    3. 检测转速切换点,生成时间段标注
    """</span>
    rpm_data = data[<span class="hljs-string">'rotation_speed'</span>]
    time = data[<span class="hljs-string">'time'</span>]
    
    predictions = []
    window_size = <span class="hljs-number">1000</span>  <span class="hljs-comment"># 1秒窗口</span>
    step_size = <span class="hljs-number">500</span>     <span class="hljs-comment"># 0.5秒步长(50%重叠)</span>
    
    current_speed_label = <span class="hljs-literal">None</span>
    segment_start = <span class="hljs-literal">None</span>
    
    <span class="hljs-comment"># 滑动窗口处理</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(rpm_data) - window_size, step_size):
        window_rpm = rpm_data[i:i+window_size]
        avg_rpm = np.mean(window_rpm)
        rpm_stability = <span class="hljs-number">1.0</span> - (np.std(window_rpm) / <span class="hljs-built_in">max</span>(avg_rpm, <span class="hljs-number">1</span>))
        
        <span class="hljs-comment"># 转速分类</span>
        <span class="hljs-keyword">if</span> avg_rpm &lt; <span class="hljs-number">800</span>:
            speed_label = <span class="hljs-string">'低转速'</span>
        <span class="hljs-keyword">elif</span> avg_rpm &lt; <span class="hljs-number">1500</span>:
            speed_label = <span class="hljs-string">'中转速'</span>
        <span class="hljs-keyword">else</span>:
            speed_label = <span class="hljs-string">'高转速'</span>
        
        <span class="hljs-comment"># 检测转速切换</span>
        <span class="hljs-keyword">if</span> speed_label != current_speed_label:
            <span class="hljs-keyword">if</span> current_speed_label <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
                <span class="hljs-comment"># 保存上一段</span>
                predictions.append(TimeseriesSpan(
                    start=segment_start,
                    end=time[i],
                    label_choice=current_speed_label,
                    label_group=<span class="hljs-string">"speed_level"</span>
                ))
            
            <span class="hljs-comment"># 开始新段</span>
            current_speed_label = speed_label
            segment_start = time[i]
    
    <span class="hljs-comment"># 保存最后一段</span>
    <span class="hljs-keyword">if</span> current_speed_label <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
        predictions.append(TimeseriesSpan(
            start=segment_start,
            end=time[-<span class="hljs-number">1</span>],
            label_choice=current_speed_label,
            label_group=<span class="hljs-string">"speed_level"</span>
        ))
    
    <span class="hljs-keyword">return</span> predictions
</code></pre>
<p><strong>可视化示例</strong>:</p>
<pre><code class="hljs language-sql" lang="sql">转速曲线:
  RPM
  <span class="hljs-number">2000</span> ─────────┐         ┌──── 高转速段
               │         │
  <span class="hljs-number">1500</span> ────────┼─────────┼──── 阈值
               │         │
  <span class="hljs-number">1000</span> ────┐   │         │
           │   │         │      中转速段
   <span class="hljs-number">800</span> ────┼───┴─────────┘──── 阈值
           │                   
   <span class="hljs-number">500</span> ────┴───────────────── 低转速段
       ────┬───┬───┬───┬─────► <span class="hljs-type">Time</span>
          t1  t2  t3  t4

预测结果:
  [
    TimeseriesSpan(<span class="hljs-keyword">start</span><span class="hljs-operator">=</span><span class="hljs-number">0</span>, <span class="hljs-keyword">end</span><span class="hljs-operator">=</span>t1, label<span class="hljs-operator">=</span><span class="hljs-string">'低转速'</span>),
    TimeseriesSpan(<span class="hljs-keyword">start</span><span class="hljs-operator">=</span>t1, <span class="hljs-keyword">end</span><span class="hljs-operator">=</span>t2, label<span class="hljs-operator">=</span><span class="hljs-string">'中转速'</span>),
    TimeseriesSpan(<span class="hljs-keyword">start</span><span class="hljs-operator">=</span>t2, <span class="hljs-keyword">end</span><span class="hljs-operator">=</span>t3, label<span class="hljs-operator">=</span><span class="hljs-string">'高转速'</span>),
    TimeseriesSpan(<span class="hljs-keyword">start</span><span class="hljs-operator">=</span>t3, <span class="hljs-keyword">end</span><span class="hljs-operator">=</span>t4, label<span class="hljs-operator">=</span><span class="hljs-string">'中转速'</span>)
  ]
</code></pre>
<h3 data-id="heading-15">3.3 故障类型诊断</h3>
<h4 data-id="heading-16">诊断策略:基于特征的规则引擎</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">predict_fault_type</span>(<span class="hljs-params">self, data, features</span>):
    <span class="hljs-string">"""
    多故障类型诊断
    
    策略:基于特征的评分机制
    """</span>
    fault_scores = {}
    
    <span class="hljs-comment"># 1. 不平衡诊断</span>
    <span class="hljs-comment"># 特征:振动幅值大,主频=转速频率</span>
    unbalance_score = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> axis <span class="hljs-keyword">in</span> [<span class="hljs-string">'vibration_x'</span>, <span class="hljs-string">'vibration_y'</span>, <span class="hljs-string">'vibration_z'</span>]:
        rms_key = <span class="hljs-string">f'<span class="hljs-subst">{axis}</span>_rms'</span>
        <span class="hljs-keyword">if</span> rms_key <span class="hljs-keyword">in</span> features <span class="hljs-keyword">and</span> features[rms_key] &gt; <span class="hljs-number">1.5</span>:
            unbalance_score += <span class="hljs-built_in">min</span>(<span class="hljs-number">1.0</span>, features[rms_key] / <span class="hljs-number">2.0</span>)
    fault_scores[<span class="hljs-string">'不平衡'</span>] = unbalance_score / <span class="hljs-number">3</span>  <span class="hljs-comment"># 归一化</span>
    
    <span class="hljs-comment"># 2. 轴承故障诊断</span>
    <span class="hljs-comment"># 特征:高频成分增加,峰值因子大,峰度大</span>
    bearing_score = <span class="hljs-number">0</span>
    <span class="hljs-keyword">if</span> <span class="hljs-string">'dominant_freq'</span> <span class="hljs-keyword">in</span> features <span class="hljs-keyword">and</span> features[<span class="hljs-string">'dominant_freq'</span>] &gt; <span class="hljs-number">500</span>:
        bearing_score += <span class="hljs-number">0.4</span>  <span class="hljs-comment"># 高频权重</span>
    <span class="hljs-keyword">if</span> <span class="hljs-string">'crest_factor'</span> <span class="hljs-keyword">in</span> features <span class="hljs-keyword">and</span> features[<span class="hljs-string">'crest_factor'</span>] &gt; <span class="hljs-number">5</span>:
        bearing_score += <span class="hljs-number">0.3</span>  <span class="hljs-comment"># 冲击权重</span>
    <span class="hljs-keyword">if</span> <span class="hljs-string">'kurtosis'</span> <span class="hljs-keyword">in</span> features <span class="hljs-keyword">and</span> features[<span class="hljs-string">'kurtosis'</span>] &gt; <span class="hljs-number">5</span>:
        bearing_score += <span class="hljs-number">0.3</span>  <span class="hljs-comment"># 峰度权重</span>
    fault_scores[<span class="hljs-string">'轴承故障'</span>] = bearing_score
    
    <span class="hljs-comment"># 3. 齿轮故障诊断</span>
    <span class="hljs-comment"># 特征:啮合频率及其边频带</span>
    gear_score = <span class="hljs-number">0</span>
    <span class="hljs-keyword">if</span> <span class="hljs-string">'spectral_centroid'</span> <span class="hljs-keyword">in</span> features:
        <span class="hljs-comment"># 齿轮故障通常在中频范围</span>
        <span class="hljs-keyword">if</span> <span class="hljs-number">100</span> &lt; features[<span class="hljs-string">'spectral_centroid'</span>] &lt; <span class="hljs-number">500</span>:
            gear_score = <span class="hljs-built_in">min</span>(<span class="hljs-number">1.0</span>, features[<span class="hljs-string">'spectral_centroid'</span>] / <span class="hljs-number">500</span>)
    fault_scores[<span class="hljs-string">'齿轮故障'</span>] = gear_score
    
    <span class="hljs-comment"># 4. 综合判断</span>
    max_fault = <span class="hljs-built_in">max</span>(fault_scores.items(), key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">1</span>])
    
    <span class="hljs-keyword">if</span> max_fault[<span class="hljs-number">1</span>] &gt; <span class="hljs-number">0.3</span>:  <span class="hljs-comment"># 故障阈值</span>
        label = max_fault[<span class="hljs-number">0</span>]
    <span class="hljs-keyword">else</span>:
        label = <span class="hljs-string">'正常'</span>
    
    <span class="hljs-keyword">return</span> [TimeseriesSpan(
        start=data[<span class="hljs-string">'time'</span>][<span class="hljs-number">0</span>],
        end=data[<span class="hljs-string">'time'</span>][-<span class="hljs-number">1</span>],
        label_choice=label,
        label_group=<span class="hljs-string">"fault_type"</span>
    )]
</code></pre>
<p><strong>故障诊断决策树</strong>:</p>
<pre><code class="hljs language-mermaid" lang="mermaid">graph TD
    A[振动特征] --&gt; B{RMS&gt;2.0?}
    B --&gt;|是| C{峰值因子&gt;5?}
    B --&gt;|否| D[正常]
    
    C --&gt;|是| E{峰度&gt;5?}
    C --&gt;|否| F{主频=转速?}
    
    E --&gt;|是| G[轴承故障]
    E --&gt;|否| H[检查频谱]
    
    F --&gt;|是| I[不平衡]
    F --&gt;|否| H
    
    H --&gt; J{中频能量高?}
    J --&gt;|是| K[齿轮故障]
    J --&gt;|否| L[其他故障]
    
    style G fill:#FF5722,color:#fff
    style I fill:#FF9800,color:#fff
    style K fill:#FFC107,color:#000
</code></pre>
<h3 data-id="heading-17">3.4 健康评分系统</h3>
<h4 data-id="heading-18">评分模型:加权综合评估</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">predict_quality_score</span>(<span class="hljs-params">self, features</span>):
    <span class="hljs-string">"""
    设备健康度评分(0-100分)
    
    评分模型:
    基础分100分,根据异常特征扣分
    """</span>
    base_score = <span class="hljs-number">100.0</span>
    
    <span class="hljs-comment"># 1. 振动幅值扣分(权重40%)</span>
    rms_penalty = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> axis <span class="hljs-keyword">in</span> [<span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span>]:
        rms = features.get(<span class="hljs-string">f'vibration_<span class="hljs-subst">{axis}</span>_rms'</span>, <span class="hljs-number">0</span>)
        <span class="hljs-keyword">if</span> rms &gt; <span class="hljs-number">2.0</span>:  <span class="hljs-comment"># 阈值</span>
            <span class="hljs-comment"># RMS每超标1个单位,扣15分</span>
            rms_penalty += <span class="hljs-built_in">min</span>(<span class="hljs-number">15</span>, (rms - <span class="hljs-number">2.0</span>) * <span class="hljs-number">7.5</span>)
    
    <span class="hljs-comment"># 2. 频域特征扣分(权重30%)</span>
    freq_penalty = <span class="hljs-number">0</span>
    dominant_freq = features.get(<span class="hljs-string">'dominant_freq'</span>, <span class="hljs-number">0</span>)
    <span class="hljs-keyword">if</span> dominant_freq &gt; <span class="hljs-number">800</span>:  <span class="hljs-comment"># 高频异常</span>
        freq_penalty = <span class="hljs-built_in">min</span>(<span class="hljs-number">15</span>, (dominant_freq - <span class="hljs-number">800</span>) / <span class="hljs-number">100</span>)
    
    <span class="hljs-comment"># 3. 峰值因子扣分(权重20%)</span>
    peak_penalty = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> axis <span class="hljs-keyword">in</span> [<span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span>]:
        crest = features.get(<span class="hljs-string">f'vibration_<span class="hljs-subst">{axis}</span>_crest_factor'</span>, <span class="hljs-number">3</span>)
        <span class="hljs-keyword">if</span> crest &gt; <span class="hljs-number">5</span>:  <span class="hljs-comment"># 有冲击</span>
            peak_penalty += <span class="hljs-built_in">min</span>(<span class="hljs-number">10</span>, (crest - <span class="hljs-number">5</span>) * <span class="hljs-number">2</span>)
    
    <span class="hljs-comment"># 4. 转速稳定性扣分(权重10%)</span>
    speed_penalty = <span class="hljs-number">0</span>
    rpm_std = features.get(<span class="hljs-string">'rpm_std'</span>, <span class="hljs-number">0</span>)
    rpm_mean = features.get(<span class="hljs-string">'rpm_mean'</span>, <span class="hljs-number">1000</span>)
    rpm_cv = rpm_std / <span class="hljs-built_in">max</span>(rpm_mean, <span class="hljs-number">1</span>)  <span class="hljs-comment"># 变异系数</span>
    <span class="hljs-keyword">if</span> rpm_cv &gt; <span class="hljs-number">0.05</span>:  <span class="hljs-comment"># 转速波动&gt;5%</span>
        speed_penalty = <span class="hljs-built_in">min</span>(<span class="hljs-number">10</span>, rpm_cv * <span class="hljs-number">100</span>)
    
    <span class="hljs-comment"># 5. 计算总分</span>
    quality_score = <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, base_score - rms_penalty - freq_penalty 
                                      - peak_penalty - speed_penalty)
    
    <span class="hljs-keyword">return</span> Number(
        value=quality_score,
        label_group=<span class="hljs-string">'quality_score'</span>,
        label_target=<span class="hljs-string">'ts'</span>
    )
</code></pre>
<p><strong>健康等级划分</strong>:</p>









































<table><thead><tr><th>分数区间</th><th>健康等级</th><th>维护建议</th><th>颜色标识</th></tr></thead><tbody><tr><td>90-100</td><td>优秀</td><td>继续观察</td><td>🟢 绿色</td></tr><tr><td>70-89</td><td>良好</td><td>定期监测</td><td>🟡 黄色</td></tr><tr><td>50-69</td><td>一般</td><td>加强监测</td><td>🟠 橙色</td></tr><tr><td>30-49</td><td>较差</td><td>计划维护</td><td>🔴 红色</td></tr><tr><td>0-29</td><td>危险</td><td>立即停机检修</td><td>🚨 紫色</td></tr></tbody></table>
<hr/>
<h2 data-id="heading-19">四、实战应用案例</h2>
<h3 data-id="heading-20">案例1:风电场轴承寿命预测</h3>
<p><strong>背景</strong>:某海上风电场,单台机组价值5000万</p>
<p><strong>部署方案</strong>:</p>
<ol>
<li>
<p><strong>数据采集</strong></p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 在主轴承和齿轮箱安装加速度传感器</span>
sensors = {
    <span class="hljs-string">'main_bearing'</span>: <span class="hljs-string">'三轴加速度计(X/Y/Z)'</span>,
    <span class="hljs-string">'gearbox'</span>: <span class="hljs-string">'单轴加速度计'</span>,
    <span class="hljs-string">'generator'</span>: <span class="hljs-string">'单轴加速度计'</span>
}

<span class="hljs-comment"># 采样配置</span>
sample_rate = <span class="hljs-number">1000</span>  <span class="hljs-comment"># 1kHz</span>
upload_interval = <span class="hljs-number">3600</span>  <span class="hljs-comment"># 每小时上传</span>
</code></pre>
</li>
<li>
<p><strong>诊断模型</strong></p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 预测示例</span>
prediction = {
    <span class="hljs-string">'quality_score'</span>: <span class="hljs-number">65</span>,  <span class="hljs-comment"># 健康度65分(一般)</span>
    <span class="hljs-string">'fault_type'</span>: <span class="hljs-string">'轴承故障'</span>,
    <span class="hljs-string">'confidence'</span>: <span class="hljs-number">0.82</span>,
    <span class="hljs-string">'time_to_failure'</span>: <span class="hljs-string">'预计7-14天'</span>  <span class="hljs-comment"># 剩余寿命预测</span>
}
</code></pre>
</li>
<li>
<p><strong>维护决策</strong></p>
<pre><code class="hljs language-markdown" lang="markdown">决策流程:
<span class="hljs-bullet">1.</span> 收到预警(健康度&lt;70) → 发送邮件通知
<span class="hljs-bullet">2.</span> 派遣工程师现场复核
<span class="hljs-bullet">3.</span> 安排停机检修(选择低风速时段)
<span class="hljs-bullet">4.</span> 更换轴承 → 避免突发故障
</code></pre>
</li>
</ol>
<p><strong>实施效果</strong>:</p>
<ul>
<li>✅ 年避免3次突发故障 → 节省900万元</li>
<li>✅ 计划性维护减少停机时间60%</li>
<li>✅ 轴承平均寿命延长18个月</li>
</ul>
<h3 data-id="heading-21">案例2:水泵站故障诊断</h3>
<p><strong>背景</strong>:城市供水主泵站,5台大型离心泵</p>
<p><strong>诊断实例</strong>:</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 3号泵振动分析</span>
pump3_analysis = {
    <span class="hljs-string">'timestamp'</span>: <span class="hljs-string">'2024-01-15 14:30'</span>,
    <span class="hljs-string">'features'</span>: {
        <span class="hljs-string">'rms'</span>: <span class="hljs-number">3.2</span>,  <span class="hljs-comment"># 超标!正常值&lt;2.0</span>
        <span class="hljs-string">'crest_factor'</span>: <span class="hljs-number">6.5</span>,  <span class="hljs-comment"># 超标!正常值3-4</span>
        <span class="hljs-string">'dominant_freq'</span>: <span class="hljs-number">58</span>,  <span class="hljs-comment"># 接近转速频率60Hz</span>
        <span class="hljs-string">'kurtosis'</span>: <span class="hljs-number">4.8</span>  <span class="hljs-comment"># 偏高</span>
    },
    <span class="hljs-string">'diagnosis'</span>: {
        <span class="hljs-string">'fault_type'</span>: <span class="hljs-string">'不平衡'</span>,
        <span class="hljs-string">'severity'</span>: <span class="hljs-string">'中等'</span>,
        <span class="hljs-string">'recommendation'</span>: <span class="hljs-string">'建议1周内进行动平衡校正'</span>
    },
    <span class="hljs-string">'quality_score'</span>: <span class="hljs-number">58</span>  <span class="hljs-comment"># 健康度58分</span>
}
</code></pre>
<p><strong>根因分析</strong>:</p>
<pre><code class="hljs language-markdown" lang="markdown">故障树分析:
<span class="hljs-code">                   不平衡
                     │
        ┌────────────┼────────────┐
        │            │            │
     叶轮磨损    转子偏心    轴承松动
        │            │            │
     (可能性60%)  (可能性30%)  (可能性10%)
</span>
建议:
<span class="hljs-bullet">1.</span> 优先检查叶轮(拆检成本低)
<span class="hljs-bullet">2.</span> 如叶轮正常,检查转子
<span class="hljs-bullet">3.</span> 必要时进行动平衡校正
</code></pre>
<h3 data-id="heading-22">案例3:智能维护大屏</h3>
<p><strong>需求</strong>:设备管理部门希望实时监控所有设备健康状况</p>
<p><strong>可视化方案</strong>:</p>
<pre><code class="hljs language-ini" lang="ini">┌──────────────────────────────────────────────┐
│         设备健康监控大屏                      │
├──────────────────────────────────────────────┤
│ 设备总数: 50    健康: 35    预警: 12    故障: 3│
├──────────────────────────────────────────────┤
│ 泵1  <span class="hljs-section">[████████░░]</span> 82分 🟡 良好               │
│   转速:1450rpm  故障:无  建议:定期监测         │
│                                              │
│ 泵2  <span class="hljs-section">[████░░░░░░]</span> 45分 🔴 较差               │
│   转速:1480rpm  故障:轴承故障  建议:计划维护   │
│                                              │
│ 泵3  <span class="hljs-section">[██░░░░░░░░]</span> 25分 🚨 危险               │
│   转速:1520rpm  故障:严重不平衡  建议:立即停机 │
│                                              │
│ 风机1 <span class="hljs-section">[██████████]</span> 95分 🟢 优秀              │
│   转速:1200rpm  故障:无  建议:继续观察         │
└──────────────────────────────────────────────┘

实时趋势图:
  分数
  100 ─────●────●────●──── 风机1
          /
   80 ───●─────●────●───── 泵1
        /
   60 ─●──────●──────●──── 泵2
      /       \
   40 ──────●──●──────── 泵3(下降趋势!)
           ← 时间
</code></pre>
<hr/>
<h2 data-id="heading-23">五、技术优化建议</h2>
<h3 data-id="heading-24">5.1 数据增强</h3>
<p><strong>目的</strong>:增加训练样本多样性,提升模型泛化能力</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> audiomentations <span class="hljs-keyword">import</span> Compose, AddGaussianNoise, TimeStretch

augmenter = Compose([
    AddGaussianNoise(min_amplitude=<span class="hljs-number">0.001</span>, max_amplitude=<span class="hljs-number">0.01</span>, p=<span class="hljs-number">0.5</span>),
    TimeStretch(min_rate=<span class="hljs-number">0.9</span>, max_rate=<span class="hljs-number">1.1</span>, p=<span class="hljs-number">0.5</span>),
])

augmented_vibration = augmenter(samples=vibration_data, sample_rate=<span class="hljs-number">1000</span>)
</code></pre>
<h3 data-id="heading-25">5.2 深度学习升级</h3>
<p><strong>方向</strong>:用CNN/LSTM自动学习特征</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">VibrationCNN</span>(nn.Module):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-built_in">super</span>().__init__()
        <span class="hljs-comment"># 1D卷积提取时序特征</span>
        self.conv1 = nn.Conv1d(<span class="hljs-number">3</span>, <span class="hljs-number">64</span>, kernel_size=<span class="hljs-number">7</span>, padding=<span class="hljs-number">3</span>)
        self.conv2 = nn.Conv1d(<span class="hljs-number">64</span>, <span class="hljs-number">128</span>, kernel_size=<span class="hljs-number">5</span>, padding=<span class="hljs-number">2</span>)
        
        <span class="hljs-comment"># 全连接分类</span>
        self.fc = nn.Linear(<span class="hljs-number">128</span>, <span class="hljs-number">4</span>)  <span class="hljs-comment"># 4种故障类型</span>
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):
        <span class="hljs-comment"># 输入:[batch, 3轴, 时间步]</span>
        x = F.relu(self.conv1(x))
        x = F.max_pool1d(x, <span class="hljs-number">2</span>)
        x = F.relu(self.conv2(x))
        x = F.adaptive_avg_pool1d(x, <span class="hljs-number">1</span>)
        x = x.view(x.size(<span class="hljs-number">0</span>), -<span class="hljs-number">1</span>)
        <span class="hljs-keyword">return</span> self.fc(x)
</code></pre>
<hr/>
<h2 data-id="heading-26">六、总结</h2>
<h3 data-id="heading-27">核心价值</h3>
<p>振动PHM ML Backend通过<strong>智能振动分析</strong>,实现了:</p>
<ol>
<li><strong>全方位诊断</strong>:转速/故障/健康度三维评估</li>
<li><strong>预测性维护</strong>:提前7-14天故障预警</li>
<li><strong>降本增效</strong>:维护成本降低40%,停机时间减少60%</li>
<li><strong>知识固化</strong>:将专家经验转化为算法</li>
</ol>
<h3 data-id="heading-28">适用场景</h3>






























<table><thead><tr><th>行业</th><th>设备类型</th><th>核心价值</th></tr></thead><tbody><tr><td>风电</td><td>风力发电机</td><td>避免突发故障,延长寿命</td></tr><tr><td>水利</td><td>水泵/水轮机</td><td>保障供水安全</td></tr><tr><td>石化</td><td>压缩机/泵</td><td>预防连锁故障</td></tr><tr><td>制造</td><td>机床/电机</td><td>提升设备利用率</td></tr></tbody></table>
<p><strong>振动PHM ML Backend是工业4.0时代的"设备健康管家",通过AI赋能,让设备从"坏了再修"走向"预测性维护",为企业创造巨大经济价值。</strong></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[APP上架苹果应用商店经验教训与注意事项]]></title>    <link>https://juejin.cn/post/7578582010416939014</link>    <guid>https://juejin.cn/post/7578582010416939014</guid>    <pubDate>2025-12-01T09:51:28.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7578582010416939014" data-draft-id="7578705123208085547" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="APP上架苹果应用商店经验教训与注意事项"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2025-12-01T09:51:28.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="疯狂的程序猴"/> <meta itemprop="url" content="https://juejin.cn/user/2760245749234147"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            APP上架苹果应用商店经验教训与注意事项
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2760245749234147/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    疯狂的程序猴
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-01T09:51:28.000Z" title="Mon Dec 01 2025 09:51:28 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-01
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读2分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>APP上架苹果？必看经验教训！</p>
<p>最近有不少朋友在问，怎么把APP上架到苹果应用市场。作为一个过来人，我忍不住给大家分享一些经验教训，都是血泪啊！</p>
<p>企业开发者账号的坑</p>
<p>我最近上架的APP有个特殊情况，之前是个人开发者，现在要改成企业开发者。结果发现，申请企业开发者账号的时候，以前的授权人不行，必须换新的。而且还得有一个同主体的企业官网，域名还得通过备案（国内版的）。填写的联系人最后需要一个企业邮箱，我们申请了网易企业邮箱免费版，结果苹果反馈无效。最后只能用企业微信的邮箱才搞定。另外，还得先把以前的APP下架。</p>
<p>使用AppUploader这样的工具，可以简化iOS证书的申请和管理过程，它支持在Windows、Linux或Mac系统中直接创建和管理开发者证书，无需钥匙串助手，非常适合团队协作。</p>
<p>BUG不能有</p>
<p>我们这个APP里有个小BUG，自己没检测到，结果被人家检测出来了。记住，作为软件开发者，BUG是绝对不能有的！</p>
<p>隐私协议要全</p>
<p>我们的APP被检测出，里面用到一个SDK包，但隐私协议里没写明。这是绝对不行的，必须写全。如果有实名认证等功能，还需要有《免责声明》。我是把这些写在一个文件里，这样也可以。如果实在不知道怎么写，可以用网上的隐私协议生成器，再改改。或者看看大厂出厂的APP，隐私协议都是怎么写的。</p>
<p>审核方的帮助</p>
<p>如果实在不知道怎么搞了，就给APP审核方留言，他们一般都会回复的，也可以约电话沟通。苹果很守信，一定会给你回电话的，这样你可以清楚知道怎么改。</p>
<p>另外，利用AppUploader上传IPA文件到App Store，比使用Application Loader更高效，且不携带设备信息，能加快审核流程。</p>
<p>最后，祝大家APP上架都顺利！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[一次找齐！1000 个 Nano Banana Pro 提示词]]></title>    <link>https://juejin.cn/post/7578667193321046079</link>    <guid>https://juejin.cn/post/7578667193321046079</guid>    <pubDate>2025-12-01T09:56:42.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7578667193321046079" data-draft-id="7578705123208151083" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="一次找齐！1000 个 Nano Banana Pro 提示词"/> <meta itemprop="keywords" content="人工智能,AIGC,Gemini"/> <meta itemprop="datePublished" content="2025-12-01T09:56:42.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="冴羽"/> <meta itemprop="url" content="https://juejin.cn/user/712139234359182"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            一次找齐！1000 个 Nano Banana Pro 提示词
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/712139234359182/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    冴羽
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-01T09:56:42.000Z" title="Mon Dec 01 2025 09:56:42 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-01
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">1. 前言</h2>
<p>别人使用 Nano Bannana 生成了非常惊艳的图片，你是不是也想知道他们用了什么提示词？</p>
<p>于是我找了很多 Nano Banna 提示词库，上千个提示词可以直接复制使用！</p>
<p>如果你还不知道在哪里使用 Nano banana Pro，可以先看这篇：<a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FtYKzM0PIvBm5QG08SW3_BA" target="_blank" title="https://mp.weixin.qq.com/s/tYKzM0PIvBm5QG08SW3_BA" ref="nofollow noopener noreferrer">6 个白嫖 Nano Banana Pro 的网站</a></p>
<h2 data-id="heading-1">2. OpenNana</h2>
<p>地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fopennana.com%2Fawesome-prompt-gallery%2F" target="_blank" title="https://opennana.com/awesome-prompt-gallery/" ref="nofollow noopener noreferrer">opennana.com/awesome-pro…</a> 540 个案例直接使用</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/24485e34c2d44e42b9c8fbf631c3f779~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Ya05769:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765187802&amp;x-signature=DT9oMU0Q1Ccg%2BHKfCsIZAvfkAHI%3D" alt="" loading="lazy"/></p>
<p>可以直接选择复制提示词使用：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/702a1dc8c6104613abda8623535dd2f0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Ya05769:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765187802&amp;x-signature=JS%2FhkOScVtT%2FAhZL43TueW7B7D4%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-2">3. Youmind</h2>
<p>地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fyoumind.com%2Fzh-TW%2Fnano-banana-pro-prompts" target="_blank" title="https://youmind.com/zh-TW/nano-banana-pro-prompts" ref="nofollow noopener noreferrer">youmind.com/zh-TW/nano-…</a> 519 个提示词直接使用</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/55f69988d20848098163ebfbe0047efb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Ya05769:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765187802&amp;x-signature=wbFeKKBEKfEoQaiaAKCbpQcXrHA%3D" alt="" loading="lazy"/></p>
<p>还可以在 Youmind 直接使用 Nano Banana Pro 生成图片，需要消耗积分。</p>
<p>每月可以免费获取 2000 积分，使用 Nano Banana Pro 生成图片每张大概消耗 15 积分。</p>
<p>注册的时候，使用邀请码：<a href="https://link.juejin.cn?target=https%3A%2F%2Fyoumind.com%2Finvite%2F2KRVE5" target="_blank" title="https://youmind.com/invite/2KRVE5" ref="nofollow noopener noreferrer">2KRVE5</a>，可以多获得 1000 积分，又可以多生成 66 张图片了。</p>
<h2 data-id="heading-3">4. GitHub</h2>
<p>GitHub 上有很多提示词仓库：</p>
<p>Awesome-Nano-Banana-images：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FPicoTrex%2FAwesome-Nano-Banana-images" target="_blank" title="https://github.com/PicoTrex/Awesome-Nano-Banana-images" ref="nofollow noopener noreferrer">github.com/PicoTrex/Aw…</a></p>
<p/>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/944618a990f64ae9880a7b5d3d3d9a7f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Ya05769:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765187802&amp;x-signature=jbFaWgEkbytBdAMjisrycXLVUww%3D" alt="" loading="lazy"/></p>
<p>awesome-nano-banana：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FJimmyLv%2Fawesome-nano-banana" target="_blank" title="https://github.com/JimmyLv/awesome-nano-banana" ref="nofollow noopener noreferrer">github.com/JimmyLv/awe…</a></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e0039a8fe2a246149580bcac7e0f2da5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Ya05769:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765187802&amp;x-signature=GSHOBHX5rnY4Ni%2FAMMJdcecGfkU%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-4">5. 飞书文档</h2>
<p>一些博主搜集的：</p>
<p>地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fai.feishu.cn%2Fdocx%2FIKO3dWCeyobZ5CxWE18cV40xnth" target="_blank" title="https://ai.feishu.cn/docx/IKO3dWCeyobZ5CxWE18cV40xnth" ref="nofollow noopener noreferrer">ai.feishu.cn/docx/IKO3dW…</a></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/da9c812c099448f299ed5c1836eb4d38~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Ya05769:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765187802&amp;x-signature=Zb8Fb85Bbm19P8kEJ%2FQRe7Q%2Bn1Y%3D" alt="" loading="lazy"/></p>
<p>地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fai.feishu.cn%2Fwiki%2FRJ4RwiI0BiFiwnkk9DBcLaasnJh" target="_blank" title="https://ai.feishu.cn/wiki/RJ4RwiI0BiFiwnkk9DBcLaasnJh" ref="nofollow noopener noreferrer">ai.feishu.cn/wiki/RJ4Rwi…</a></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e5f9b039762c4fe4a67f7c155b79c497~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Ya05769:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765187802&amp;x-signature=PfUZb63WgYFizQmZUgxucZZA8A8%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-5">6. 官方教程</h2>
<p>Gemini 官方提供了写提示词的技巧和示例模板，在这里你可以学习如何写提示词。</p>
<p>地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fai.google.dev%2Fgemini-api%2Fdocs%2Fimage-generation%3Fhl%3Dzh-cn" target="_blank" title="https://ai.google.dev/gemini-api/docs/image-generation?hl=zh-cn" ref="nofollow noopener noreferrer">ai.google.dev/gemini-api/…</a></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0dd5e43f4733415280bce474f03dd2b9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Ya05769:q75.awebp?rk3s=f64ab15b&amp;x-expires=1765187802&amp;x-signature=a3Q2PH5n2t42ScN1w0pKjS8abkM%3D" alt="" loading="lazy"/></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[一分钱的Bug（求助帖）]]></title>    <link>https://juejin.cn/post/7578697614389805062</link>    <guid>https://juejin.cn/post/7578697614389805062</guid>    <pubDate>2025-12-01T09:17:18.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7578697614389805062" data-draft-id="7578697614389673990" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="一分钱的Bug（求助帖）"/> <meta itemprop="keywords" content="Java"/> <meta itemprop="datePublished" content="2025-12-01T09:17:18.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="少平818"/> <meta itemprop="url" content="https://juejin.cn/user/4292915750774956"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            一分钱的Bug（求助帖）
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4292915750774956/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    少平818
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-01T09:17:18.000Z" title="Mon Dec 01 2025 09:17:18 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-01
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>背景，某个用户反馈线上后台提现金额到账少了一分钱，其输入的提现金额是19320.38(元),但实际银行到账金额1932037(分),也就是少了一分钱。然后立马翻看代码，以及运行日志。</p>
<p>伪代码如下:</p>
<pre><code class="hljs language-less" lang="less"><span class="hljs-variable">@PostMapping</span>(<span class="hljs-string">"withDrawApply"</span>)
Result <span class="hljs-built_in">withdrawApply</span>(<span class="hljs-variable">@RequestBody</span> Map&lt;String,Object&gt; param){
   <span class="hljs-selector-tag">Object</span> <span class="hljs-selector-tag">amount</span> = <span class="hljs-selector-tag">params</span><span class="hljs-selector-class">.get</span>(<span class="hljs-string">"amount"</span>);
   <span class="hljs-selector-tag">toWithdrawApply</span>(new <span class="hljs-built_in">BigDecimal</span>(String.<span class="hljs-built_in">valueOf</span>(amount));
}

Boolean  <span class="hljs-built_in">toWithdrawApply</span>(BigDecimal amount){
      
    <span class="hljs-selector-tag">Map</span>&lt;<span class="hljs-selector-tag">String</span>,<span class="hljs-selector-tag">Objct</span>&gt; <span class="hljs-selector-tag">param</span> = <span class="hljs-selector-tag">new</span> <span class="hljs-selector-tag">HashMap</span>();
    <span class="hljs-selector-tag">param</span><span class="hljs-selector-class">.put</span>(<span class="hljs-string">"amount"</span>, amount.<span class="hljs-built_in">multiply</span>(new <span class="hljs-built_in">BigDecimal</span>(<span class="hljs-number">100</span>)).<span class="hljs-built_in">intValue</span>());
    <span class="hljs-comment">//TODO HTTP调用</span>
    <span class="hljs-comment">//此处大意就是将提现参数提交给支付机构;其他参数省略</span>
    异步保存提现记录，此处提现记录中<span class="hljs-selector-tag">Record</span>中的金额字段<span class="hljs-selector-tag">amount</span>也取自:<span class="hljs-selector-tag">amount</span>,保存的数据为<span class="hljs-number">19320.38</span>
    <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">flag</span>;
}

</code></pre>
<p><strong>通过日志排查，在提交给第三方支付机构的参数日志中，amount金额变成了1932079</strong>。
所以总结下过程就是:用户提交金额19320.80，然后double经过String.value，转BigDeciaml，最后乘以100，少了一分钱。</p>
<p>第一时间怀疑是精度缺失问题，springboot中param接收到的amount实际类型为double类型，而浮点数在二进制计算中并不能真实表示该确切的值，因此其底层可能是19320.7999999999....来表示</p>
<p>但是我后续经过进行模拟处理操作，进行同jdk版本，cpu架构环境的参数进行调用处理，一直不能重现。所以很好奇这到底是和什么原因有关？如果是精度缺失按道理每次都会重现吧？
如果是精度缺失问题，正常的处理方式应该是什么呢？
期待各位大佬答疑。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item>  </channel></rss>