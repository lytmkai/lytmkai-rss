<?xml version="1.0" encoding="UTF-8"?><rss version="2.0">  <channel>      <title>掘金文章推荐</title>      <link>https://juejin.cn/recommended?sort=newest</link>      <description>一个帮助开发者成长的社区</description>      <generator>python juejin_recom.py @Pi20</generator>      <item>    <title><![CDATA[1分钟了解响应式编程 | dubbo框架下响应式官例]]></title>    <link>https://juejin.cn/post/7591786340321591330</link>    <guid>https://juejin.cn/post/7591786340321591330</guid>    <pubDate>2026-01-06T03:29:50.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7591786340321591330" data-draft-id="7591778827308056616" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="1分钟了解响应式编程 | dubbo框架下响应式官例"/> <meta itemprop="keywords" content="后端,Java,RxJava"/> <meta itemprop="datePublished" content="2026-01-06T03:29:50.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Mars酱"/> <meta itemprop="url" content="https://juejin.cn/user/1714893869821278"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            1分钟了解响应式编程 | dubbo框架下响应式官例
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1714893869821278/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Mars酱
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-06T03:29:50.000Z" title="Tue Jan 06 2026 03:29:50 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-06
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>作者：Mars酱</p>
<p>声明：本文章由Mars酱编写，部分内容来源于网络，如有疑问请联系本人。</p>
<p>转载：欢迎转载，转载前先请联系我！</p>
</blockquote>
<h2 data-id="heading-0">前言</h2>
<p>上篇搜了一堆概念，拼凑了一些例子，现今我们的应用已经不是单例架构，一般都是分布式微服务架构，微服务架构情况下框架也很多，SpringCloud、Dubbo等等</p>
<p>我的工程是dubbo的，那我们看看Dubbo官方示例给出的响应式编程的例子，毕竟我看Dubbo官文说天然支持流式编程，好了，继续。</p>
<h2 data-id="heading-1">Dubbo对流式处理的支持</h2>









































<table><thead><tr><th>协议</th><th>性能</th><th>网关友好</th><th>流式通信</th><th>多语言支持</th><th>编程API</th><th>说明</th></tr></thead><tbody><tr><td><strong>triple</strong></td><td><strong>高</strong></td><td><strong>高</strong></td><td><strong>支持，客户端流、服务端流、双向流</strong></td><td><strong>支持（Java、Go、Node.js、JavaScript、Rust）</strong></td><td><strong>Java Interface、Protobuf(IDL)</strong></td><td><strong>在多语言兼容、性能、网关、Streaming、gRPC 等方面最均衡的协议实现，官方推荐。</strong></td></tr><tr><td>dubbo</td><td>高</td><td>低</td><td>不支持</td><td>支持（Java、Go）</td><td>Java Interface</td><td>性能最高的私有协议，但前端流量接入、多语言支持等成本较高</td></tr><tr><td>rest</td><td>低</td><td>高</td><td>不支持</td><td>支持</td><td>Java Interface</td><td>rest 协议在前端接入、互通等方面具备最高的灵活性，但对比 rpc 存在性能、弱类型等缺点。<strong>注意，rest 在 dubbo3 中仅是 triple 协议的一种发布形式</strong></td></tr></tbody></table>
<p>从官方的文档中找到，Dubbo是支持流式编程的，但是需要使用triple协议，而不是其他协议。</p>
<h2 data-id="heading-2">从git上下载Dubbo Samples</h2>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 从git上下载 dubbo的官方示例，这是示例的git地址</span>
https://github.com/apache/dubbo-samples.git
</code></pre>
<p>下载之后，导入到你的idea中，知道了triple协议支持流式通信，那么从导入好的idea中找到triple的stream相关的代码，如下图：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8ebafe011a20403891943f968c009eb4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTWFyc-mFsQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768274990&amp;x-signature=RqaQwYaCNL5u1lvakhpyA%2FfIsPw%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-3">Dubbo服务端支持的两种流式处理</h2>
<p>Dubbo通过triple协议支持了两种流式处理，一种是服务端流，另一种是双向流。</p>
<h3 data-id="heading-4">服务端流</h3>
<p>首先我们看服务端流的示例代码，代码位置在dubbo-samples-triple-streaming工程中的GreeterImpl这个文件，我抽取了服务端流的方式，如下：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serverStream</span><span class="hljs-params">(GreeterRequest request, StreamObserver&lt;GreeterReply&gt; responseObserver)</span> {
	LOGGER.info(<span class="hljs-string">"receive request: {}"</span>, request.getName());
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
		<span class="hljs-type">GreeterReply</span> <span class="hljs-variable">reply</span> <span class="hljs-operator">=</span> GreeterReply.newBuilder().setMessage(<span class="hljs-string">"reply from serverStream. "</span> + i).build();
		responseObserver.onNext(reply);
	}
	responseObserver.onCompleted();
}
</code></pre>
<p>可以看到serversStream方法是没有void，没有返回值的，它通过GreeterRequest对象传递参数，然后把业务逻辑数据依次循环写入到StreamObserver对像中。</p>
<p>GreeterRequest对象可以是我们自己定义的业务请求对象，StreamObserver对象是dubbo框架对于流式处理的接口定义，如图：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9e97c531cbb94373882d449c85504650~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTWFyc-mFsQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768274990&amp;x-signature=gRilyZC%2BM2Wpa%2F3fRZKESIhio2U%3D" alt="" loading="lazy"/></p>
<p>响应结果被封装在这个接口对象中，实现了流式数据写入到消费者端的业务场景。</p>
<h3 data-id="heading-5">双向流</h3>
<p>这是双向流的官方示例：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> StreamObserver&lt;GreeterRequest&gt; <span class="hljs-title function_">biStream</span><span class="hljs-params">(StreamObserver&lt;GreeterReply&gt; responseObserver)</span> {
	<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StreamObserver</span>&lt;GreeterRequest&gt;() {
		<span class="hljs-meta">@Override</span>
		<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onNext</span><span class="hljs-params">(GreeterRequest data)</span> {
			<span class="hljs-type">GreeterReply</span> <span class="hljs-variable">resp</span> <span class="hljs-operator">=</span> GreeterReply.newBuilder().setMessage(<span class="hljs-string">"reply from biStream "</span> + data.getName()).build();
			responseObserver.onNext(resp);
		}

		<span class="hljs-meta">@Override</span>
		<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onError</span><span class="hljs-params">(Throwable throwable)</span> {

		}

		<span class="hljs-meta">@Override</span>
		<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCompleted</span><span class="hljs-params">()</span> {

		}
	};
}
</code></pre>
<p>可以看到，双向流方法 binStream 的参数和返回值都是 StreamObserver 类型。</p>
<p>但需要注意的是，它与我们传统方法定义中参数是请求值、返回值是响应的理解是反过来的，在这里，函数的入参 StreamObserver responseObserver 是响应，跟之前一样，是在业务逻辑中不停的写数据到 回响应中。</p>
<p>这个函数也通过new了一个 StreamObserver 不断的在onNext函数中写入了请求流数据，而且这里 请求流 与 响应流 是独立的，我们在写回响应流数据的过程时，随时可能有请求流到达，对于每个流而言，值都是有序的。</p>
<h2 data-id="heading-6">Dubbo客户端的调用示例</h2>
<p>dubbo对于两种流的处理方式是不同的调用实现</p>
<h3 data-id="heading-7">服务端流的客户端调用</h3>
<p>调用 serverStream() 传入能够处理流式响应的 SampleStreamObserver 对象，调用发起后即快速返回，之后流式响应会不停的发送到 SampleStreamObserver 。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serverStream</span><span class="hljs-params">(Greeter greeter)</span> {
	<span class="hljs-type">GreeterRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> GreeterRequest.newBuilder().setName(<span class="hljs-string">"server stream request."</span>).build();
	greeter.serverStream(request, <span class="hljs-keyword">new</span> <span class="hljs-title class_">SampleStreamObserver</span>());
}

<span class="hljs-comment">// 声名上面调用类的SampleStreamObserver实现</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SampleStreamObserver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">StreamObserver</span>&lt;GreeterReply&gt; {

	<span class="hljs-meta">@Override</span>
	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onNext</span><span class="hljs-params">(GreeterReply data)</span> {
		LOGGER.info(<span class="hljs-string">"stream &lt;- reply:{}"</span>, data);
	}

	<span class="hljs-meta">@Override</span>
	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onError</span><span class="hljs-params">(Throwable throwable)</span> {
		LOGGER.error(<span class="hljs-string">"stream onError"</span>, throwable);
		throwable.printStackTrace();
	}

	<span class="hljs-meta">@Override</span>
	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCompleted</span><span class="hljs-params">()</span> {
		LOGGER.info(<span class="hljs-string">"stream completed"</span>);
	}
}
</code></pre>
<h3 data-id="heading-8">双向流的客户端调用</h3>
<pre><code class="hljs language-java" lang="java">
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">biStream</span><span class="hljs-params">(Greeter greeter)</span> {
	<span class="hljs-comment">// SampleStreamObserver的定义在 ‘服务端流的客户端调用示例’ 中已经给出</span>
	StreamObserver&lt;GreeterRequest&gt; requestStreamObserver = greeter.biStream(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SampleStreamObserver</span>());
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
		<span class="hljs-type">GreeterRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> GreeterRequest.newBuilder().setName(<span class="hljs-string">"name-"</span> + i).build();
		requestStreamObserver.onNext(request);
	}
	requestStreamObserver.onCompleted();
}
</code></pre>
<p>调用 greeter.biStream() 方法会立即返回一个请求流 requestStreamObserver 对象，同时，需要为方法传入一个能处理响应的 observer 对象new SampleStreamObserver()。</p>
<p>接下来，我们就可以用才刚才返回值中得到的 requestStreamObserver 持续发送请求 requestStreamObserver .onNext(reqeust)， 此时，如果有响应返回，则会由 SampleStreamObserver 对象接收处理，</p>
<h2 data-id="heading-9">官例好像有问题</h2>
<p>其实没有任何问题，只是dubbo支持的是observer的流式处理，这是一种无背压方式的流式处理。背压是一种<strong>流控机制</strong>，dubbo 的 StreamObserver <strong>不提供内置背压支持</strong></p>
<ul>
<li>它的 onNext 方法是通过官方的示例就知道它属于阅后即焚风格；</li>
<li>调用 onNext 会立即把数据写入网络缓冲区（或本地队列），<strong>不会等待消费者处理完成</strong>；</li>
<li>如果消费者消费得太慢，而 producer 持续高速发送，有没有可能 <strong>导致 OOM 或者其他问题？没试过，存疑</strong></li>
</ul>
<p>这与 <strong>Reactive Streams 规范</strong> 貌似不同，并没有背压特征，但是RxJava框架不也是支持背压、无背压方式的吗？所以，应该根据自己的场景来选择是否需要背压方式，超时了，下个1分钟看怎么用dubbo处理背压特征的响应式编程吧。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[构建 “按版本触发、自动发布、自动回写” 的前端组件发布流水线]]></title>    <link>https://juejin.cn/post/7592017365141618740</link>    <guid>https://juejin.cn/post/7592017365141618740</guid>    <pubDate>2026-01-06T03:33:31.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7592017365141618740" data-draft-id="7591786340321165346" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="构建 “按版本触发、自动发布、自动回写” 的前端组件发布流水线"/> <meta itemprop="keywords" content="前端,CI/CD,NPM"/> <meta itemprop="datePublished" content="2026-01-06T03:33:31.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="雨夜寻晴天"/> <meta itemprop="url" content="https://juejin.cn/user/1943592288391496"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            构建 “按版本触发、自动发布、自动回写” 的前端组件发布流水线
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1943592288391496/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    雨夜寻晴天
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-06T03:33:31.000Z" title="Tue Jan 06 2026 03:33:31 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-06
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#2b2b2b;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(159,219,252,.15) 3%,transparent 0),linear-gradient(1turn,rgba(159,219,252,.15) 3%,transparent 0);background-size:20px 20px;background-position:50%}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{padding:30px 0;margin-top:35px;margin-bottom:10px;color:#4dd0e1}.markdown-body h1{font-size:30px;text-align:center;position:relative;width:max-content;margin:0 auto}.markdown-body h1:before{position:absolute;content:"";z-index:-1;top:-20px;height:100%;width:100px;left:0;right:0;margin:0 auto;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADsAAAA6CAYAAAAOeSEWAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAABkLSURBVGhDtZoHnJ1llcbP3Om9ZiYzmfSQhCQQIbRQVQKI9CYC68qKriJK0UXcZRcINqStIoiIqKCi1NACQihBWiCkkJ5MJlMyvd7p7d759v989/sy34yTbIj48Atz71ff855znvOc971xDrB/EtoGI7a9Z8Aq+wZML0mNj7dE95NZ1OKsj1dHo1GbnJpss9OTbWJyonvun4VP1Njuoagtb+m0it4By0iIt8LEeMvkr8XFWcfgkA1gYDLf47i2PzpsyU7UspKSLDoctagTZ7Vc08MzClMS7awJ2ZaflBB78CeET8TYla1dtrKt2w5KS7YCDGzEoz2RqKUmhGw6x2bhuXyOp2BoRXef1Q1E7Lj8TIsMD1sbxu1kcnYSAX1810RMTUmyMB7f2j1gC7NS7byinNiL/kH8Q8a+2NRh77b32El56VaPAe0YeGR2mh2bm+FdMRqP1rbZe+3dFsHT35qcb/Oz0rwzo7Gxs9feYPLS4kM2h8lawee5hPmlJXneFQeGAzJ2F564v7rFzi7Msu3d/Xgjzq5g8ArX8VCNN2vJ28daey0zZJabmGCLslP5HOf+Oygr3UzDGOf+JxrauXfQjslJt+dbuuyMgiwmk+sPAB/b2Lt2NdoMZnuY21qHIvbvUyZ4Z0ZQiXGrWjvsmPxsK4R0nmHA8ZCTQvxVQn5eRipklIBtcVbV1WtHYsjati47ZWKuTUpP9Z4yGk/xDBGe3v1mW4/dOrvYO7P/2G9jRSjf31FnXyaUXiB8r51WaJkM3kcfOSa2FR6qarIenooTLQHPLcC4mYThyw1tVpKWYlVERlZ8nC3Oz3Jzdn1nn5uvQ8OOHYvhR/CvsqffJbkCkZTvcYZ6Z0WTfTovw5Y1dtjXp+TbFPhgf7FfxpYxuMfr2uwo8rEtMmwXF+d6Z8wGmIR2PLyjo8cqOFffP2SLGexJEJCP9R29thkPXlpa4A5Y3w/jmuVNYYwO2QkY7WMtz3mVcE1hkualJdmSolzX8GnpKd4VZq80d1o7zN0RdWxGaqItgbn3B/+vsasgh/UMNBOvzYMZDxtDKp289KGaVguFQvb1yQWWwuB97GaSXqUUnVaYbSUwrDCEBz/C2CM8EhNrP13fbkeSh3OJgCAe2N1CWXKsGOc6TOr5U4q8MwYhDtkTda02MyPN+nnGBQEH7A37NHYz5KOZVv08qyjbSseEzKauPnsMj98wc6Ibcj5UUv7M8QWZTE52jEwGOVaD8U1Dw1YNWX0qM8VKyb80L/TrOPYOzH4KBJQTrK8M7+7KZjuM63sHBt17FubGoibCuf+tarWFGUmuwWeT8/vCXo1tZOYeZcazCaez8MwEzzM+HqhqtiJI5twxL1jeGLYk7jmKMF1JOCbg6Qj5nAdRqX7q3BYm8VAmQvW1lfcMc58IT95uIA3q+gftrDHPXUXJWkVEHJme5Bp5UmHsvIZ/O3l8ECE/FWcsItX2hr0ae8O2Wjs+J43QTbOZzGYQ/7Wtxq6eXjRK3r0By4YJ6Ty8EiYSJqcm2eGeV4Pox/ANENJR49RiEdfqcLflUJrEBZqgxYHrBjn2ExFURqKdVETN9YirJxKxR2rbrYeQv5ISmB6IsiDGNfZGWPeMgkzr58xnPaJ5p6XDZPKz4T77wayJ7jGhhXLwanOHTWBgq5n5q6YUwNJ7l3kKcRl7OJ7fF56l1GzvHbSD8dghTPi0wIRfv6XafjJ3ssv0PnZQ7nZx/etwzO1zJ3lHR2OETTw8x0tOx1AN3De0D7YV+63oGthjaJQ5Ur7eVVZjcdGInUyuaT73ZWg3efV8fZs7cc2E777Qi5eunVbghvPPymrt/krKGfcLd8ybYjdxrK6333Z09rjHZkNuLYzz0uIc+xWCZzz8nbHbe4dsY1e/XUOY+nimvtUaSazv4jXhaQasSbmYmpuenGwHZ8TKggSEQm08rMD7ahBOoExcMqXQegjnZ+CEvaEa1ZQUQkt39dj0zDS7krq+ARmpdws/nlNqD9WFbWN7l5u3wr9MyrcXKUsqWy3jTOaoML4DdaQ83YIoT4VYpEXvYQZLmbX5SLohBrgOj186Kc/iKTUPUhq+Rrm5ekOl3TWv1Mr6hqwbY0VOQXwEo+Moq4Z47q5qsU489G944LyJOW4LOLZOKtT/iI6+nGe/0dhuEd4ltj2NmiuCU4hnk5fHIi7+RK4uTEu0e+s7rAiRcw1CYy3OejvcYz+eXeI9MYY9nu3lYZl0KavJJ7Vjibzgjp319rUZE20j7CkJqFr5JQYgQ39f3eQaKpQk0afy8nl4uBzvjUUTRk7k3iebOm0pabDiyFn2XGu3dRME41CGVeBVqSiVnc6hIUpekp1VjHLDSOEcQlui5W/U8C7IKREjv1Gabw3wRwUTvpv7jybPtzHmIPZ49q6KRjuccqBQVCOtGvqXhrCFUUXJzOYSHt7Kw5Ix9H08dSje1o1JyL73IYXpEMmE5CRbw6wuykx2pR+Pd6/J4JpLiJKV6N9OnrcQNfQ0Zem6qQX2MmFXyWTE+DMO0kGx4e08DEjnXbsYuOq7niHB8jdY/wQ8Srm2XCZZUrOakF1CY5EKX0h93Tu/1J4kRdbDMT8MamgZK9xe3uDcvrPe++Y4f61rcZr7B53rN1c5N2ytcV5rCrvHt3T2Og19g+5nH7dvq3bqunr4NOwgK2MHA1jeEDuG7HNuLmtw7qpocl5t6nCPvdTQ7v4N4u3WTqeyu9cZHIo4f6lqdFoHh7wzMbzDeeGv3Hvzjlrnh2W1zofhHuftxpFn3VFe7zxS0+p0DlKVPbhhvBxhvwiFMgfP+mjHA08gEC4pybeLyK1iZldh8zC5VJQyUl8l59KZ0WJk2xaiYWxNrkXXJhA8r3PvZRur7ZZZRfadaRPsfiTmX9HGajC2tXd6V8dQTMhX0h8rNdJx9Ra8F8SbRNLzhPRnJmTZIUTYueTyWxyr7uv3rjC3OkzE8495oS+4xq6D5WoI0bO5WVCOSerl8rIeBrOI/Hkaw6ME5W1zSuzx2la3CRdWi3zIG+FDBvUp9LMgI/vggUmE7KkT81yGvOOgEYa/aUahhRAF5xLec3OzbF1r2O17BbVxIi7hzJIC64IYhXdJA+nh/5xVbOmE9J0QqjSxWk0pp37M2YEtgjS8GpimACu7xkqxdKJ6fEXyYl2Lre0ZtC8yELVewtWUnbfCPIhrvgDFz8WI5yhJKgcnFMZWEFrwhgzo5uWDDDA1oGSOzcu0xfx7vTlsv6posIMpJ6cGWPiw/BxL4PU7vbrpjgf8bMdu5OYwOdhm83DARUSa0ELknYIeEAaILuWxlhGa0M8+EuJCrpJT+ymENhN60pXBxa3LZ5TsucnlGaCmIEQ4Evru91yuz0xMtKaeXluI5zdh9Mm8vAlBn4aR07X64EH3vEKdXQkZJXPP/JxMvNRpLxEtHZ5RQgmNewnpouvVTpYTHdfOnmy5kFUGnpRTfEhXD9DiBdFFJB0/YWS9aj6pmc89r0BaQmgTRkgI+EsdKsYasJZOBF+QqTH474NK7LbyBvf7W+RgOxNyxfQY2/2hrp2+NkroxrzrQ55fSZkpJIa28znCgF6rb7H1hOSslATyvNflAh9pvHcX3lVE/Ya8FjTJIexa2Rq77nfU96unTnD7aME3+TAm6BFKYrPnqCNIqV5sq0ZGCiEV+Db+qWMQqpFgb5KPx48R6omeDl2EuP9DTYt9iGA/f1KBS1w/La+H4ktsSmLItvZHXLUkrCeflVtJ9DVVg1H7+sxiGvVM975rZpfabuqHVhuP5F1vewav5O8GamUe91yDanoYw47FWzC929O+DJnKA2opFY1Rjru5CE7kOcO0jJtQVUIynzuZEMeb+1CEOFXN8iFSGeRpCm1BTlJxVg49Azm819SO7Bu0axEbwn27GuxMck+TMQHDP8fn48gfDVIL4R8xKVPJ73MQBUIfA/Z54LMw5vmlE+w+VFo2A78X/SsyPA/RMD0z3e2qVLtfo7aeBslpMX0N0TEnLcUlKym1jyBFqSohmYntI5enBhYB9CY/2kNarhwJhNiMtRGyWnkQdKaCFyQwgydjyNUw4VchKxXv2/DoKdC+lkQbCX1NlKCGvJiBJkSGbCus6jfo4yGBNySgr+u7e20BCsxdVAcFlJ/tHd32+cIsNxSXUULUUx+dg/d47g7OPYFw2MxkSuyMwLHVTI6PBN6dS8Sppw45zHJSgDXV3aQzmz40Z6fDgBfiAXU0uZxby2zejee+j3eltoQMzhV6qSBogXwrEXDj7ElWxUQ8RrnSaoU0dxIsKaiMvMykXTu90NqJsGHP4z78SdLigUrLKat32nFwy/E07pfDFRdQ/7N5r57pQ1482uvWhMGhQcviGkVrKDUp0ToCxfhQal5n4Hs/g1jOgH4LWdwFOd1b1WzHET4vLZppv+Czjxo840OrDlG8jAJzv2tp5mLK1dsU/lfIOeWy5NxFxfl2BoYImlQtx9QF6mJRQKBsQYYuO2yaLYPBUXvu/VqYPxtHhNy7Y4hCkNLGPtKSklzCVKSHtMQxcqm5Kw1DhI2PTGZtcGDAvoLQ/u7MifYtWFBlxz2H9zo8RkwKzC5UYiG+p44ccqE62YAxLeT/TOpf8MXx8Qk0IJFRY1Go+viQVJpE5Ehjf49xfAZeqGIy/7us3nqxwQfCkjZypPxobVr/6YpQHIalUvuCyEwbSXC9PC8QnkFcXlrgLpoLIhIfKuaqlQkYIAwQnr/f3eyu7KttOw2lNpv8/BPHyjzVNER3o72gvEBKqRMTflndbP8BMweRDyeciEj5bFayFXqTLzheivgYJC0jwzwHa0MDDEotm48ndze5BBBElAnxxcRYHAFh3FfZaA9UNRmC354kNwUx8eHkmVj5dcTE5ZMnuEyr1QqlhtaJLuOYZv4v3KNo0TKrGPUZ1NILPKuWcvVn5Trv10SMB6h0j/ARMnlOuafCBIfnSWEx/Raif3HDzofYMM31dOyY9LBaLK3TjoX2fEqT4+2qaUVWSTQvyM6wC8nNJyEetXIyuLKrx04P7MKNnbJZlKUtNAIHo7i2dA/YU3Vtdi5l6jCepXy8hOedSSSsI8/HQg5Q+gxTKXwkMHkbESo+hjG0lbRRzQ3Fc5LOzDuFhs3Ptumpie7ilRDhlEJOq/hjsZljCxjkt7fWuPS/EekpXMggJQIk0G+eN9Xu2VmHWIkJe0nJRN4ptBBit2yutG9ML7J1DHAxebiAMrZ4VZlduqGS8I2tJc2iborUxmIN79c+kTovFxivPvrcSaP3n7RSKYTUmKt4N3rMOcw4JOneD3sP956jNaMglIeTER5Xbdlt15Tm2W10NEsYrA/N5JLCHHsR9tSqwxq08G3bqm1ZTbOtagnbo6SLvH/VzBL7W7jPzqFea0LmMLFzUuLtdwumuO3i1Vtq7OK15Xgw3l1PDmIXak+6QBEkvB9YJIzBcc/L20JIYaSZ/qAzVm5Ut4oowk3QehC+N3xo/1wTqt7zsYawfX9no9XjqdPXVLhrwyo/wucJYQkE1e4j8rLcBuHUItQQKqgMXb6LGvxFQlXw33AdZLR0V5P9Fr29lP73scNnosoyvdWPv4fPJ+uJrLVtMakqaL1M1cTvv0OLIZE6wk2a2IcIRUQh+DaejpdcXepBa7bKDRGM9PIVxTl2EwarZ72rooVuY4RQtMypdk6e1lLLehhY2lt7QEd7WxlCDvdIli6E9B4+ZIodmZEMccUGqgiZOqru9tkR3iJ8nCcXRWRZCSPMLPEjlx2LjQL1OM5qKAm+vhSuRqSfV5Ttrg8FdWcrnhMqCTex7DEM6qTsVEuM1+8hovaHQ6e6a1Fz0xLd3nUt4ToWWuzWNkhcoAIIjUx2ZpxjLzWF9+SYmngR1lok4TEoJxGfuijhI/7OICoFmadl2llcL9b1oRVJtbD+JLlv1KrhHG5811t9ELbzgk14ICUwqE+TDzftqHPz98vUSy3jSIwP8dCpkNqLDPTx+rArz4T5qLG3G2PrvJKKPoLBWE501NC3ilUX5mVjVIb9nIbgWcpPMiSXjbcL8K62UkR86m1/yfkSeMaHFuK04X0CE3J6SWzFUxw0BSNHlSzi3RmIRJwHq5udO3c16quLp6sbnffbupxbt+12vzOrzuvNHc7ycRbIxuJHgYU7YSASdQgxp7qz2ynv6HJeqW91doa7nLruXof+17sqhhu31Xif9o7HalqczV29Dnrb/f5EXZvzdH27U98/6LR5i3N0UM5zjHU71/lwjRWWltU5CAIn7F1MqLp/r9hQ5RoaxG+qmrxP4yNKcfsFLwuiprffeb2l03m2scO5h3Or2rudzjGrhk8x4Cqu2xcexilBvNEcdi5Yu4tKF3Ue4tzPy+td5/1md4tzw5iJ27NuXEYobYUdlb8z6GTWkdxaCvk2zHjd5mpKQ459mv5TkAp6mQb9Aq9HHQ8S6mrZnuc6vUG6WHusIhCJGNXl9byvnJyaiE7+Eoz8c5TYNQiUveENGpJpcIJ+biS8R0+rlcazGNs7pKB+zPLTOSX2KNWhlDAf4r2Spj72JORB5OyHULX+dlD/FOky/HFy5ygYU0sey/i8moeqdunXK1qC3RuaMOYHlI/raQMl3M+EeTV5WxD3Km8a8PkM8nr648sQ9+esKbf5e/nxiKBfAOQkxbv3SU9LYmqPV9V/Pn+V20VwTyVjTqCI6edEQUOFUXs9WmfSll8DyX2dt7GlnwkswaM3l9XZ0oNK3MTXbxpOV2sGk69s6XCJw4cY8KbyRrt9TrHt7Bm0rRBQe1+fHUWNfaapU0KbqxzbORC1M/LS3dJwIl3KOrwykQG/E+61q+isgniztdOKqNOziDgZqZIzFwPvqGiyg5NCtoCqoG5NxHhPZTOsnORulKskjoKMDeLuXQ3OmnC3syxARFXdfc57LR3OrdtrvSOOs55rnqhtcdoGhpxHdjc5EfJUuHZTlftX+G15rXPlhkrnLe59F7Lz8VGHdg8c5y2OLeMZ126qduq9XC3v7nd+FchLvYPJd15gPCu8XQnh/qpm59WGVudZzvvQO97kXTcGxhnEuJvR39tWY8cwK4uhcikk4a3Gdstg9l5B2t0wfaTdWkEou5vCPOV5PH73vFL3+DfXltnh6OxjkJD6Wd5F3g88tMe6CW/7YmI99VIL4u0oqUK8ocW4d8hFrXMVoOQU8s3U97MnjvDD/XRYkyhHM1MT3GVZQR2Tdv70U8EbA5vlo+CaPAaaSWoZXm50otGodxQ6L6txGKxzw5ZYORrBsPPrykZKQIy1n8bTjwb2fO4Te3ue7x6KOKvaYns1wtIddd4nx3mwot55qyl2360cp81zurg+CGqwU8v4/Of5uAVvPgObrwvHomY8jOtZ4fXWLnefdHVXv9044+8ZklCx75DXwcV1Sb27y+vInUQEuVYSaMgRJYfAwtoj0raFxIUW1A8nz35f02qLc9Lc9lG7CBkwtUR7bf+A+5uL6ehnH9Lat+5sIEfj3Cbj3NKRvP7Rjlo7FSmqavKvpSP8MRZ7NVbQYLSkqlC9ZW4sPH18gBTcORjrhMWmQWzFmK2UsvO90qQ1oZcI8UhkCLZPtRqMy0NirobAvjIpb4/sW06qKGyPR2oGIdlazjOOTk+kLYzaaYGSp63Wz6HsXsQ51wd+LTAuZOy+8GBNq7tF+IOdDU4kENJthNID5YRafZtzZ3mDs9LbRgzixcZ2l1h83OKFbDmEd0/FiFp7DWHgp0AQGzq6nf8hPF+oa3EehOz0ziCWcm4NpBRMhX1hn571oR9wqVVSDVPtUi32sQ0vbu7scZdY9aOt2ZSEL9BEBIW+dv20AKDd9/ep09oimYqHpyImkKDuRllS4PrlHNuIqDmCJmNJQba7q1joEaUQJuR/WdXsLrJrq/L6cdJsPOyXscJ7GLKqo8cOpqhrO//yQG6oS3kZwS9xPkRB3wi7diFMtDN+PLk5m1ath+8f0Fy80dbjhvVXub+U5mEqeal27UP+dWpPlknNxW79Ak6/7Tg3UMOF52j1xA1qK7Trd6nXC+8P9ttYQcumIonLSnJtBdJNa77axw1C2x3qR4Wqnj73x9f6MbV+CCYFBZO6y51aSh3gzVrsmwzJnULEbCJC1oZ7vIZ/9Iqmfvn2u5oWO5n8fApxcuWUApum5diPgY9lrA9EtvUNOzYf8vqAcJPsU5iOh7XtXQgt2uZhjKU2amF7HQyfEYWcZk5yQ1RDKNrLcq02k/9IGmldrB93KiokPw8EB2SsoKWXO5FmxXhlckqi+3vEUvLqwok5PHVkIWAszlqzy1p54zuLpnPZ3q9bod08JlLSb5DrNxDm38Sbvsg5EBywsT7oH+3XNW3uasGirFSrxRNdCllKiPZHZzJYLZb5qEcpae3pxMCuu9oibS5/QCOiLcYUrp+MmtJeURjFdVlxzqiae6D4h40NQt54HyGv3JRo10aVfv8YhtC0pSlVKcPFuxIXahr08mzCO4VzMlLSsZuomZ+RaucU0rXsw/sfF5+osUFonWob/7TrLdaUgdpV93fl9X+VIC0Y6tek2uI8OD3J5gT2Vj9ZmP0f4IM4iY7RQ5gAAAAASUVORK5CYII=) no-repeat 50%;background-size:64px 64px;opacity:.84}.markdown-body h1:after{position:absolute;content:"";width:150%;left:-25%;height:50%;bottom:12px;border-radius:50%;background:linear-gradient(transparent 80%,rgba(77,208,225,.8));background-size:400% 200%;opacity:.6;animation:h1Animate 6s linear infinite}@keyframes h1Animate{0%{background-position:100% 100%}50%{background-position:100% 50%}to{background-position:100% 100%}}.markdown-body h2{display:block;border-bottom:4px solid #4dd0e1;position:relative;font-size:24px;padding:12px 32px;margin:30px 0}.markdown-body h2:before{width:24px;height:24px;left:0;top:0;margin:auto;background-size:24px 24px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAADGklEQVRYR81X32vTYBQ999s6mFjQgQ+DrbHiVFZYU4cDcQ/6pGhTFVYFEXGi82H+Bz448UnEF1Fx9ccEEcXpZE3d5tP2ooKiTacTHaLNpigMHDgnU9tcSbrWrkwWR0sbyEOSe885ObnfvV8IRT6oyPwoLQHBx+OVM5WJvSyEVAhnBOjt7yU/+/rr6r6l8TMO+F/EN0JQhICqQpD/xaRpcpAc9tS+M+9lBCia/oqBamK+zeDuQogQZaKJk3wcQjxSva7tGQGB2Ke1zIk3DNyMyNL+QpCnMQOaPsDAVuGAp9cjvbYc8Ec/bCYSg0zoiHilk1tHxqsqEsYlML4kjIpT/eurJxRNPweQU5VdrWaOEo1fgKAVbBgXIz73kF3R/ph+ghgdzMYWM29eAWlBJqgZaFlFYtC6nhWpaDqnSGlIlV1WjJ3DloDNgyNLncudqgX//Ucg3LxuStHGuhi8pqKCW3rqV342rwFjRznKm+/LNaN2yC237ThgF2wxcfMLeP6+ncrKzoPoKTGeLQbYbg4TNoC5iZPJY5HGVRdSNZAWYBclD3FzBQzrR8hACAKdzBzKA/4/IYioDQaOskBbpEG6PO8qKKSAEi3CnEb0Pw4oMf0OmKbTDWqh3Lw6EIiNBZi5lxh3wz4puBD5ovqAMvxhHSdFKxE1CQe3m/07TeTX4lcJdAhE+1Sv65Z5P/ByvIGTRowIZ9igbtXnmrOsbTvgj+kHBNMuBu9OdVw8EeU4nC1A0cYmAHZOTRrLhra4Z8ywnSN6vZHAFTA2WnnMfQB3qz73ddsOZM8CACFDIPSgQXqebXEgqgeZcAeEe6pXasm1f8ew3igMtAHWac0Uc/jYdyAaP0xEBwFsmgUPqbJ0NE2UKj4EGcahiOzuyhagaHpnmtgcVgTcCMuua7YdyAHbA3ArQNscVFbb4635aD6fnYaTvxxi9UNP7ddMXaRWVBdAcaLk6bDXPZCNZ9uBXEsDUX1T2Cc9yjig6Z0EHg3LK8/aqf6MwJKchkXfks1+0+JtSq3qLPa23BRR1B+T/6nkfMaW1r9hPt/MLtYfTLEpP+T9FNoAAAAASUVORK5CYII=)}.markdown-body h2:after,.markdown-body h2:before{content:"";display:block;position:absolute;bottom:0}.markdown-body h2:after{right:0;width:400px;height:10px;border-top-right-radius:24px;background:linear-gradient(90deg,#fff,#4dd0e1);max-width:50vw}.markdown-body h3{margin:30px 0;font-size:18px;position:relative;padding:4px 32px;width:max-content}.markdown-body h3:before{border-bottom:2px solid #4dd0e1;width:100%;content:"";display:block;height:28px;position:absolute;left:0;top:0;bottom:-2px;margin:auto;background-size:28px 28px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABRklEQVRYR2NkGGDAOMD2M4w6YDQERkNg+ITAppcfY/8zMv3wF+NdTUrZQpUQ2PT6cz8Dw/8CkMWMDIwNvqK8jcQ6gmIHNN19EaXPx1XPyMCghrCUKcpPlGc5MY6gyAE+Fx52MjL8j3cU5a1UYWXtZGBkEAVb+p8hxU+Mby5NHQCxnKEMaskzJ37uFmUetkmMjAzrfUX4woixHBJlZAA0y2EmPPYU4enLkhGeQIqRJDsAh+UgO7duNpD3IcVykkOA2paT5ABaWE60A2hlOdEO8D3/4CMDIyMfWvySFefoaYSoROh74eFXBgYGLiTNVLGc+BC48PAnAwMDG9QBVLOcaAd8P5ox+x/jf5AjGLgYfnwnKqv9/8/PwPO/kFF/MSj0cAKiouD/0bgYoixFU8RovWgJIX1EOYCQIZTIjzpgNARGQ2DAQwAAvHBaIdB7zxsAAAAASUVORK5CYII=);background-repeat:no-repeat;animation:h3AnimationBefore 2s infinite alternate}@keyframes h3AnimationBefore{0%{width:28px}25%{width:100%}50%{width:100%}to{width:100%}}.markdown-body h3:after{content:"";display:block;width:28px;height:28px;position:absolute;border:2px solid #4dd0e1;border-radius:50%;right:-15px;top:0;bottom:0;margin:auto;background-size:28px 28px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABRklEQVRYR2NkGGDAOMD2M4w6YDQERkNg+ITAppcfY/8zMv3wF+NdTUrZQpUQ2PT6cz8Dw/8CkMWMDIwNvqK8jcQ6gmIHNN19EaXPx1XPyMCghrCUKcpPlGc5MY6gyAE+Fx52MjL8j3cU5a1UYWXtZGBkEAVb+p8hxU+Mby5NHQCxnKEMaskzJ37uFmUetkmMjAzrfUX4woixHBJlZAA0y2EmPPYU4enLkhGeQIqRJDsAh+UgO7duNpD3IcVykkOA2paT5ABaWE60A2hlOdEO8D3/4CMDIyMfWvySFefoaYSoROh74eFXBgYGLiTNVLGc+BC48PAnAwMDG9QBVLOcaAd8P5ox+x/jf5AjGLgYfnwnKqv9/8/PwPO/kFF/MSj0cAKiouD/0bgYoixFU8RovWgJIX1EOYCQIZTIjzpgNARGQ2DAQwAAvHBaIdB7zxsAAAAASUVORK5CYII=);animation:h3AnimationAfter 2s infinite alternate}@keyframes h3AnimationAfter{0%{transform:rotate(0)}10%{transform:rotate(0)}50%{transform:rotate(-1turn)}to{transform:rotate(-1turn)}}.markdown-body h4{font-size:16px}.markdown-body h5{font-size:15px}.markdown-body h6{margin-top:5px}.markdown-body p{line-height:inherit;margin:22px 0;letter-spacing:2px;font-size:14px;word-spacing:2px}.markdown-body img{max-width:80%;border-radius:6px;display:block;margin:20px auto!important;object-fit:contain;box-shadow:0 0 16px hsla(0,0%,43.1%,.45)}.markdown-body figcaption{display:block;font-size:13px;color:#2b2b2b}.markdown-body figcaption:before{content:"";background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgBAMAAACBVGfHAAAAGFBMVEVHcExAuPtAuPpAuPtAuPpAuPtAvPxAuPokzOX5AAAAB3RSTlMAkDLqNegkoiUM7wAAAGBJREFUKM9jYBhcgMkBTUDVBE1BeDGqEtXychNUBeXlKEqACsrLQxB8lnCQQClCiWt5OYoSiAIkJVAF5eVBqAqAShTAAs7l5ShKWMwRAmAlSArASpAVgJUkCqIAscESHwCVVjMBK9JnbQAAAABJRU5ErkJggg==);display:inline-block;width:18px;height:18px;background-size:18px;background-repeat:no-repeat;background-position:50%;margin-right:5px;margin-bottom:-5px}.markdown-body hr{border:none;border-top:1px solid #4dd0e1;margin-top:32px;margin-bottom:32px}.markdown-body del{color:#4dd0e1}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:rgba(77,208,225,.08);color:#26c6da;padding:.195em .4em}.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace;overflow:auto;position:relative;line-height:1.75;box-shadow:0 0 8px hsla(0,0%,43.1%,.45);border-radius:4px;margin:16px}.markdown-body pre:before{content:"";display:block;height:30px;width:100%;margin-bottom:-7px;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAdCAYAAABcz8ldAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAhgSURBVGhD7Zp7bBTHHcdn33t7vvOdzy+ITVKDU0xIKG2ABCPTRCCaUiEVKWoqRJuASAhCitRCVKSoalFUKZBiSmmFRRJKRUnUtIpo+aNqGgwoOCmuFUIRzxjwE4zte+97drYzztji8HPvtkit/PnH+n1397Tz+83vN/PbMZhmmmmm+d+BoX8n5diihcGqgFQf5vk6BMAskWUlw3GyFnIvtqWSf91w7mKC3npfOLX7wYeiIa6BBWCOLLFRF2NB0JvIOP/80YG+k2ev6S699b/OzOfKBW5l5KsgyC4DCFQDnpEAdE1goc/dlNPc/Up7P711UiYNSMuyxeUzZPnHgGHWh5XADEkSAcdiN+AnEXIBhBComgFU0/xQR+jnj51sOUMf9Z0NKyL8S9+JPBEN8zuCMrsqGOA5QWAAyzLAxe53HBeYFgJp1c5Cx33nyIfpV3e+22/Sx32nev/sMCgVnmM4bjOniAtZWQAsz315EfsGQQc4hgWcjHkCmOj1rheuNn95cXwmDMiVp5etC/D8m5FwUWVQUYYGPh6mZYFUOgsGVa1pXvOZzVT2jRuH54RM230jEuI3RcIiL4l4UkxAJmuD/riVsqD7ct2m9nep7BtVTbVfZ0uE/UIk+CQflAHDjf8+Lg6MldYATGpH3c/Ul7p3dWXppVGM6eElJSHmnQWPbSlRlN1lJcUBjqNRnwJZVQO3B5P/uq5rK1d90pakckFcaKp5UJHY92JR8YlwkUDVySEZfGfQdO7E7Z8s2HL9TSoXTPXRud9nA8IBqSwcZgWeqpPj6BYw7yTbXBN9q2v9lQEq5zBmWA8vWLCptCi4tzwW8RQMQlFQATPLSh6vCSh/plJBkMyQBHZfWYnkKRgEktEVpTJXERN2Xzo4ex2VC6K6qXYpF5b3ypVRT8EgcAERSJXRbwCBOTFzXblM5RxGBaRt+ZPYA+LO0mgxz5K1Ig+UgAzKIuGnz39z6S+olDeaibaXRsU1RUFvgx+GwTWgPCaDgMw2XXpr9gwq50XV0bkxJiYeEiNF5cwE5XsiOEkAUkXkUW51SSOVchjl8WKef604XFSRbzCGCYeCoESStv/p8QU1VPIM3knNDynctnBRfsEYhgSlNCIGgQv2UCkvGIHZgteMh1nBW9W4F16RAM6yDVV7amZTaYQcr59cuuhhWRTWBvAMLxQGeyFSHOLnh0MvUskz5RF+fbRYDEy0mZgqQYUHOLhr//b6rGoqeaLqQG0pw3PrBbyA+4EQUkRmhvgqNUfICUipKK4OKUqIJVPKB0jpEhjmWWp64jdbKmVZZNYogcJm493gsifOqhDyeh9GYR/FM7sW+DA5CKR0MSK3tvKZkpwB5gRE4tjFEr7RL0iWBGV51vHFCyupNGWWPqLgnoer9mtyEGSJAzwLllDTGzyznDjRN/CwOFkoFb4bm0eVIXICgpvdGoEvrF7fC89zfLkkeV5HbOhWiTwTpKYvCAJLGshRdXtKMKAWlyxq+MPQLk1h66g5RE5ABJYNFrqY3wvJklJRUKg5ZWLFXIA86yek2uDOPkBNb3CM5Pf7DL2QyIrUGiLH+xC5Bmmm/ARnHUhC6PnzxWDK0RH5HuIjZGy27erU9AZ0dTIWXyG+NpBBrSFySxZw220IqeUPFoS6jVAPNadM7yDsgNB1qOkLuAziMYIb1PQGA75wIaKGPyAb+9oF16g5RE5ALIQ+tSyLWoWDEAK6aXW3JlK9VJoyx1oyvVkNdvo5KXXDAVkdnaKmNwx0xjH98w3JNmTCm+Bc9hKVhsgJSI9pvp9Vdd++jmq6AXB2/HHrhcs5aTkVDv0DFzoHvKdq/mQsKX/4t7KJLDpOJW+IbAvMGoMkxfwAWZB8DT7W1diTE+WcgKz6pK1bs6z3daPwmJDsSKt6ZsCyjlLJMz0DsDGZ8SdlDROBjOb8YeWOjptU8kTXusuaazu7oJrfEnQvdkpVcUn6PTVHyAkIIW7br/Unklni0EJIZ1WgGsauZR+fvUglz6zY0dGfVp09ybRNlfwgi3k8YSbvJJ29VMoLt9v6rZVQL7hOYUubndHJGclBtzn1byqNMCogi09/2nFb01/oj+f/5TyjauBOKtPcZ1r7qZQ3f2lRfxZPWi2anp8TSDAGExZMa2jr8u03L1M5L7q3Xc+iAeuHRl/ScvPcjSLDBnZS/cjtNHd2v3171Ewbs9N5q7Pn4otVMx3btBsCsoRbk1FxG5dMVgMDqfTpXl1/tuFMa5zKefPROdX59qLQBwLnNog8Wy1OcjB1N+QEsW/QsFNZuO35Xb1v98QLX4/Sx+O3wqujrQ6013ABUWI8+AaqBjAH01+ghL22+5X2PirnMG7r+esbnae/V1neauvGSoHjigTcVU7UGFm2DeK4ttxKpQ+mLPvl+o/PjnkAkw9HTqSMmVHhyAMx9iFcSh/BHTfLceO/C8mKjApBf9zszGhoY92m9sN+BGOY9AeD7eGniv8OTaOB4dgyTsQd9wS+IQu4lciYdkI7CLrNH3Rvbb9FL41i0tbzVP2iWJkobpN5fmM4IJfJskTP1Bk8A9HQmbpmGDBrWqdVCN/Yd7PjxKGOXn+bmbto3feVVcVB9qehIL8EJy8nChwgr0O2xxBnhGU5eP2CfYbl/m4gBRsbtneMORP9oGpjpcCsiKzHHfdOPiQ/wMniyFEu2dbiTQCAeN/vavC466BGYLttXc9fmXBXMGlAhiHHur+sq6uPiUI9z7CVHMPwBnLSuuN8FuC48/Oaz1ylt94XfrW5ouyprwWfYRkwNyCyYYjwkBHows1fa+tV/fzGxlv39b9gqvfPmQ+i/HK8KlcBjhHwfl8HEHyOd1JnuzZd66S3TTPNNNP8/wDAfwDG7G0m9LKBpwAAAABJRU5ErkJggg==) 10px 10px no-repeat;background-size:40px}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{color:#4dd0e1;border-bottom:1px solid #4dd0e1;font-weight:400;text-decoration:none;margin:0 4px}.markdown-body a:active,.markdown-body a:hover{background-color:rgba(77,208,225,.1)}.markdown-body strong{color:#26c6da}.markdown-body strong:before{content:"「"}.markdown-body strong:after{content:"」"}.markdown-body em{font-style:normal;color:#4dd0e1;font-weight:700}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:rgba(77,208,225,.05)}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{margin:2em 0;padding:24px 32px;border-left:4px solid #26c6da;background:rgba(77,208,225,.15);position:relative}.markdown-body blockquote:before{content:"❝";top:8px;left:8px;color:#4dd0e1;font-size:30px;line-height:1;font-weight:700;position:absolute;opacity:.7}.markdown-body blockquote:after{content:"❞";font-size:30px;position:absolute;right:8px;bottom:0;color:#4dd0e1;opacity:.7}.markdown-body blockquote p{color:#595959;line-height:2}.markdown-body ol,.markdown-body ul{color:#595959;padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>一套工作流，统一发布多个仓库下的多个组件；以 “版本号变化” 为唯一触发；发布成功后自动回写配置并生成 PR。新增组件只需改两处配置，剩下交给 CI。</p>
</blockquote>
<h2 data-id="heading-0">背景与目标</h2>
<ul>
<li>前端组件分散在不同仓库，人工发布易错、流程冗长；</li>
<li>需要 “改版本 → 自动构建发布 → 自动同步配置” 的一条龙流程；</li>
<li>通过 GitHub Actions + 集中配置文件，搭建一套稳健、可扩展的发布流水线。</li>
</ul>
<p>本文基于两份核心文件：</p>
<ul>
<li>工作流：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Finfinilabs%2Fci%2F.github%2Fworkflows%2Fcoco-app-web.yml" target="_blank" title="https://github.com/infinilabs/ci/.github/workflows/coco-app-web.yml" ref="nofollow noopener noreferrer">coco-app-web.yml</a></li>
<li>组件清单：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Finfinilabs%2Fci%2Fconfigs%2Fcomponents.json" target="_blank" title="https://github.com/infinilabs/ci/configs/components.json" ref="nofollow noopener noreferrer">components.json</a></li>
</ul>
<h2 data-id="heading-1">架构一览</h2>
<ul>
<li>集中配置文件管理组件的构建/发布参数。</li>
<li>工作流读取配置与触发输入，根据 “版本变化” 生成发布矩阵。</li>
<li>按矩阵逐仓库逐组件执行构建与 npm publish。</li>
<li>发布结束后自动回写工作流默认值与组件 current_version，并提自动合并 PR。</li>
</ul>
<p>核心思想：</p>
<ul>
<li>“版本号变化” 是唯一发布触发条件；</li>
<li>配置集中在 components.json，组件级可覆盖仓库级默认值；</li>
<li>发布完成后自动回写，确保 “配置=事实”。</li>
</ul>
<h2 data-id="heading-2">核心文件与关键片段</h2>
<h3 data-id="heading-3">工作流输入（workflow_dispatch）</h3>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">on:</span>
  <span class="hljs-attr">workflow_dispatch:</span>
    <span class="hljs-attr">inputs:</span>
      <span class="hljs-attr">SEARCH_CHAT_VERSION:</span> { <span class="hljs-attr">description:</span> <span class="hljs-string">'search-chat Version'</span>, <span class="hljs-attr">required:</span> <span class="hljs-literal">true</span>, <span class="hljs-attr">default:</span> <span class="hljs-string">"1.3.10"</span> }
      <span class="hljs-attr">UI_WEB_CLI_VERSION:</span> { <span class="hljs-attr">description:</span> <span class="hljs-string">'ui-web-cli Version'</span>, <span class="hljs-attr">required:</span> <span class="hljs-literal">true</span>, <span class="hljs-attr">default:</span> <span class="hljs-string">"0.0.43"</span> }
      <span class="hljs-attr">FILTER_VERSION:</span> { <span class="hljs-attr">description:</span> <span class="hljs-string">'filter Version'</span>, <span class="hljs-attr">required:</span> <span class="hljs-literal">true</span>, <span class="hljs-attr">default:</span> <span class="hljs-string">"0.0.11"</span> }
      <span class="hljs-attr">SEARCH_RESULTS_VERSION:</span> { <span class="hljs-attr">description:</span> <span class="hljs-string">'search-results Version'</span>, <span class="hljs-attr">required:</span> <span class="hljs-literal">true</span>, <span class="hljs-attr">default:</span> <span class="hljs-string">"0.0.11"</span> }
      <span class="hljs-attr">ENTITY_UI_VERSION:</span> { <span class="hljs-attr">description:</span> <span class="hljs-string">'entity-ui Version'</span>, <span class="hljs-attr">required:</span> <span class="hljs-literal">true</span>, <span class="hljs-attr">default:</span> <span class="hljs-string">"0.0.10"</span> }
      <span class="hljs-attr">CUSTOM_ICONS_VERSION:</span> { <span class="hljs-attr">description:</span> <span class="hljs-string">'custom-icons Version'</span>, <span class="hljs-attr">required:</span> <span class="hljs-literal">true</span>, <span class="hljs-attr">default:</span> <span class="hljs-string">"0.0.10"</span> }
      <span class="hljs-attr">DROPDOWNLIST_VERSION:</span> { <span class="hljs-attr">description:</span> <span class="hljs-string">'dropdownlist Version'</span>, <span class="hljs-attr">required:</span> <span class="hljs-literal">true</span>, <span class="hljs-attr">default:</span> <span class="hljs-string">"1.3.5"</span> }
      <span class="hljs-attr">DATEPICKER_VERSION:</span> { <span class="hljs-attr">description:</span> <span class="hljs-string">'datepicker Version'</span>, <span class="hljs-attr">required:</span> <span class="hljs-literal">true</span>, <span class="hljs-attr">default:</span> <span class="hljs-string">"0.0.10"</span> }
      <span class="hljs-attr">AI_ANSWER_VERSION:</span> { <span class="hljs-attr">description:</span> <span class="hljs-string">'ai-answer Version'</span>, <span class="hljs-attr">required:</span> <span class="hljs-literal">true</span>, <span class="hljs-attr">default:</span> <span class="hljs-string">"0.0.1"</span> }
</code></pre>
<p>命名约定：组件名通过 “全大写 + 短横线改下划线 + 后缀 <code>_VERSION</code>”生成输入键，例如 ai-answer → AI_ANSWER_VERSION。</p>
<h3 data-id="heading-4">组件集中配置（components.json）</h3>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"ui-common"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"repo_private"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"build_cmd"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"pnpm build"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"publish_cmd"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"npm publish"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"version_file"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"package.json"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"adapter_script"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"components"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"ai-answer"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">"current_version"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"0.0.1"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"work_dir"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"packages/AIAnswer"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"dist_dir"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"packages/AIAnswer"</span>
      <span class="hljs-punctuation">}</span>
    <span class="hljs-punctuation">}</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p>说明：</p>
<ul>
<li>work_dir 为构建发生地；</li>
<li>dist_dir 为 npm publish 的目录；</li>
<li>version_file 默认为 package.json，也可覆盖为 tsup.config.ts。</li>
</ul>
<h2 data-id="heading-5">工作流执行路径与原理</h2>
<h3 data-id="heading-6">1. 生成发布矩阵（prepare-matrix）</h3>
<p>位置与逻辑：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Finfinilabs%2Fci%2F.github%2Fworkflows%2Fcoco-app-web.yml%23L33-L100" target="_blank" title="https://github.com/infinilabs/ci/.github/workflows/coco-app-web.yml#L33-L100" ref="nofollow noopener noreferrer">coco-app-web.yml</a></p>
<ul>
<li>遍历 components.json 的所有仓库与组件；</li>
<li>将组件名映射为输入键（如 ai-answer → AI_ANSWER_VERSION）；</li>
<li>对比输入版本与 current_version，不一致者纳入矩阵；</li>
<li>输出矩阵 JSON 与 has_repos 标记。</li>
</ul>
<p>优点：仅发布 “发生版本变化” 的组件，避免无效构建。</p>
<h3 data-id="heading-7">2. 构建与发布（publish）</h3>
<p>位置与逻辑：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Finfinilabs%2Fci%2F.github%2Fworkflows%2Fcoco-app-web.yml%23L101-L221" target="_blank" title="https://github.com/infinilabs/ci/.github/workflows/coco-app-web.yml#L101-L221" ref="nofollow noopener noreferrer">coco-app-web.yml</a></p>
<ul>
<li>checkout CI 仓库与目标仓库（支持私仓 SSH 私钥）。</li>
<li>通过 jq 实现“组件优先、仓库兜底”的配置继承。</li>
<li>写入版本：
<ul>
<li>若 version_file 为 tsup.config.ts：用 sed 更新 <code>version: "x.y.z"</code>；</li>
<li>否则用 jq 写 package.json 的 <code>version</code> 字段。</li>
</ul>
</li>
<li>在 work_dir 执行 <code>pnpm install</code> 与 <code>build_cmd</code>；</li>
<li>进入 dist_dir 执行 <code>publish_cmd</code>（npm publish）；</li>
<li>记录发布元数据到 <code>release_info/&lt;component&gt;.txt</code>，格式 <code>REPO|COMP|KEY|VER</code>。</li>
</ul>
<h3 data-id="heading-8">3. 自动回写与 PR（update-workflow）</h3>
<p>位置与逻辑：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Finfinilabs%2Fci%2F.github%2Fworkflows%2Fcoco-app-web.yml%23L224-L304" target="_blank" title="https://github.com/infinilabs/ci/.github/workflows/coco-app-web.yml#L224-L304" ref="nofollow noopener noreferrer">coco-app-web.yml</a></p>
<ul>
<li>下载并遍历所有 release-info；</li>
<li>用 sed 回写工作流 inputs 的默认版本；</li>
<li>用 jq 回写 components.json 的 current_version；</li>
<li>生成并自动合并 PR，确保“配置=事实”。</li>
</ul>
<h3 data-id="heading-9">4. 失败通知（notify_on_failure）</h3>
<p>位置：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Finfinilabs%2Fci%2F.github%2Fworkflows%2Fcoco-app-web.yml%23L305-L320" target="_blank" title="https://github.com/infinilabs/ci/.github/workflows/coco-app-web.yml#L305-L320" ref="nofollow noopener noreferrer">coco-app-web.yml</a></p>
<ul>
<li>通过飞书机器人推送失败状态与链接。</li>
</ul>
<h2 data-id="heading-10">如何新增组件</h2>
<p>以新增 ui-common 下的 ai-answer 为例：</p>
<h3 data-id="heading-11">npm 仓库配置 OIDC</h3>
<p>先第一次手动发布，在 npm 生成对应组件库的地址，然后修改一下配置，如图：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2595ec90a7544ea0a636d79201f0330f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuo5aSc5a-75pm05aSp:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768275211&amp;x-signature=kg%2FQI6aE1%2Bc%2BLlU89OFyDvACNa0%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-12">在 components.json 添加组件条目（路径、版本与目录）</h3>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"ui-common"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"components"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"ai-answer"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">"current_version"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"0.0.1"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"work_dir"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"packages/AIAnswer"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"dist_dir"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"packages/AIAnswer"</span>
      <span class="hljs-punctuation">}</span>
    <span class="hljs-punctuation">}</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<h3 data-id="heading-13">在工作流 inputs 增加对应键（命名约定）</h3>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">AI_ANSWER_VERSION:</span> { <span class="hljs-attr">description:</span> <span class="hljs-string">'ai-answer Version'</span>, <span class="hljs-attr">required:</span> <span class="hljs-literal">true</span>, <span class="hljs-attr">default:</span> <span class="hljs-string">"0.0.1"</span> }
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f4bfb021dcf042b8a30e3846f8c892e4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuo5aSc5a-75pm05aSp:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768275211&amp;x-signature=X22ZaL6AdDDpsQqqm%2F1p%2B1xiEd4%3D" alt="image.png" loading="lazy"/></p>
<p>校验与发布：</p>
<ul>
<li>手动触发 workflow_dispatch，传入一个“不同于 current_version”的版本号（如 0.0.2）；</li>
<li>观察日志出现 <code>Processing: ai-answer (ui-common)</code>；</li>
<li>发布完成后自动生成并合并 PR，回写工作流默认值与 components.json 的 current_version。</li>
</ul>
<h2 data-id="heading-14">好处与设计取舍</h2>
<ul>
<li>统一入口：一个工作流覆盖多仓库多组件的发布。</li>
<li>精准触发：仅版本变化的组件进入矩阵，节省时间与算力。</li>
<li>自动同步：发布后自动回写配置与默认值，杜绝版本 “事实与配置” 不一致。</li>
<li>配置集中：components.json 管理构建/发布命令与目录，组件可覆盖仓库默认，保持最少差异。</li>
<li>高扩展：新增组件只需改两处配置，无需动工作流逻辑。</li>
</ul>
<p>设计要点：</p>
<ul>
<li>键名映射（SAFE_NAME + <code>_VERSION</code>）保证 inputs 与组件名稳定对应；</li>
<li>jq 层级读取（组件优先、仓库兜底）降低重复配置；</li>
<li>release-info 作为 “事实记录”，update-workflow 根据事实回写配置，实现幂等与自愈。</li>
</ul>
<h2 data-id="heading-15">常见坑位与排查</h2>
<ul>
<li>键名不匹配
<ul>
<li>ai-answer 的键必须为 <code>AI_ANSWER_VERSION</code>；漏下划线或命名不一致会导致 INPUT_VER 为 null。</li>
</ul>
</li>
<li>目录错误
<ul>
<li>work_dir 用于构建，dist_dir 用于发布；两者必须存在且正确。</li>
</ul>
</li>
<li>版本写法不匹配
<ul>
<li>tsup.config.ts 必须存在形如 <code>version: "x.y.z"</code> 的明确字段；否则请改用 package.json。</li>
</ul>
</li>
<li>私有仓库
<ul>
<li>repo_private 为 true 时需配置 SSH 私钥，checkout 才能访问。</li>
</ul>
</li>
<li>npm 凭据
<ul>
<li>确保目标仓库/流水线具备 npm 发布权限（token 或 OIDC）。</li>
</ul>
</li>
<li>组织变量
<ul>
<li><code>vars.GIT_REPO</code> 必须指向组织路径（如 <code>github.com/&lt;org&gt;</code>），否则 checkout 失败。</li>
</ul>
</li>
<li>适配脚本
<ul>
<li><code>adapter_script</code> 仅在特殊仓库需要（如 coco-app），默认关闭避免误改。</li>
</ul>
</li>
</ul>
<h2 data-id="heading-16">小结</h2>
<ul>
<li>这套流水线以 “版本变化” 为核心驱动力，结合集中配置、自动回写与 PR，构建出稳健、可扩展的多组件发布通道。</li>
<li>新增组件的心智负担被压缩为 “加配置 + 加输入键”，其余交给 CI 自动完成。</li>
<li>对于多个组件分布在多仓库的场景，这是一个低成本、高收益的发布实践。</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[用填充表格法吃透01背包及其变形-1]]></title>    <link>https://juejin.cn/post/7591799107486810122</link>    <guid>https://juejin.cn/post/7591799107486810122</guid>    <pubDate>2026-01-06T03:33:33.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7591799107486810122" data-draft-id="7591871204567662618" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="用填充表格法吃透01背包及其变形-1"/> <meta itemprop="keywords" content="后端,算法,前端"/> <meta itemprop="datePublished" content="2026-01-06T03:33:33.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="颜酱"/> <meta itemprop="url" content="https://juejin.cn/user/905653309941495"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            用填充表格法吃透01背包及其变形-1
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/905653309941495/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    颜酱
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-06T03:33:33.000Z" title="Tue Jan 06 2026 03:33:33 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-06
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    7
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读10分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">用填充表格法吃透01背包及其变形</h2>
<p>01背包问题是动态规划（Dynamic Programming, DP）领域最经典、最基础的模型之一，后续很多复杂的DP问题都可看作是它的变形或延伸。本文将从"表格可视化"核心思路出发，先通过空表格建立解题框架，再用DP解题5步"万能钥匙"逐步填充表格，最终覆盖基础01背包解法、空间优化技巧，以及4类经典变形的完整拆解（含代码实现），帮你彻底吃透01背包问题。</p>
<p>核心前置认知：01背包的本质是"选或不选"的二选一决策——有n个物品，每个物品有重量和价值，背包有固定容量，要求选择若干物品放入背包，使得总重量不超过容量的前提下，总价值最大（基础模型）。后续所有变形都围绕"选或不选"的核心逻辑展开，只是"物品""容量""目标"的具体含义不同。</p>
<p>动态规划（Dynamic Programming, DP）解决问题的核心逻辑，本质是通过<strong>填充表格</strong>逐步推导最优解——把复杂的多阶段决策问题，转化为按规则填充表格的可视化过程。以01背包问题（最经典的DP模型）为例，我们先明确最终要填充的核心表格形态，后续所有解题步骤都是为了按规则完成这张表格，表格填完之时，就是问题解决之日。</p>
<p>01背包问题核心表格（空表，后续逐步填充）：</p>





















































<table><thead><tr><th>前i个物品\背包容量j</th><th>0（容量为0）</th><th>1（容量为1）</th><th>2（容量为2）</th><th>...（容量递增）</th><th>C（背包最大容量）</th></tr></thead><tbody><tr><td>0（无物品）</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td></tr><tr><td>1（第1个物品）</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td></tr><tr><td>2（第2个物品）</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td></tr><tr><td>...（物品递增）</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td></tr><tr><td>n（第n个物品）</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充（最终答案）</td></tr></tbody></table>
<p>表格说明：表格中每个单元格<code>dp[i][j]</code>代表「前i个物品放入容量为j的背包的最大价值」，我们的目标就是按规则填充所有单元格，最终右下角<code>dp[n][C]</code>即为01背包问题的最优解。</p>
<p>要有序、正确地填充这张表格，需要遵循DP解题的5步「万能钥匙」——这是贯穿所有DP问题的通用拆解思路，每一步都对应表格填充的关键环节：</p>
<ol>
<li>
<p><strong>确定dp数组及下标的含义</strong>：定义表格中每个单元格的核心意义（即<code>dp[i][j]</code>代表什么），这是填充表格的基础；</p>
</li>
<li>
<p><strong>确定递推公式</strong>：明确单元格<code>dp[i][j]</code>的数值如何通过其他已填充单元格推导得出（即"选或不选"的决策逻辑），这是表格填充的核心规则；</p>
</li>
<li>
<p><strong>dp数组如何初始化</strong>：确定表格的初始状态（如无物品、容量为0时的单元格值），这是表格填充的起点；</p>
</li>
<li>
<p><strong>确定遍历顺序（表格填充顺序）</strong>：明确按什么顺序逐个填写表格中的单元格（如先逐行填、再逐列填），确保推导时依赖的单元格已提前填充；</p>
</li>
<li>
<p><strong>打印dp数组（验证）</strong>：通过逐步填充表格、打印中间结果，验证填充规则的正确性，避免逻辑偏差。</p>
</li>
</ol>
<p>后续所有01背包及变形问题的分析，都将围绕这5步「万能钥匙」展开，本质就是用这5步规则完成对应表格的填充，最终通过表格得到问题答案。</p>
<h3 data-id="heading-1">一、基础01背包（二维DP解法）</h3>
<p>我们先从最直观的二维DP解法入手，严格按照5步「万能钥匙」拆解，完整演示基础表格的填充过程。</p>
<p>示例：有4个物品，重量数组<code>weights = [2,3,4,5]</code>，价值数组<code>values = [3,4,5,6]</code>，背包最大容量<code>capacity = 8</code>，求能放入背包的最大价值。</p>
<h4 data-id="heading-2">1.1 步骤1：确定dp数组及下标的含义</h4>
<p>定义二维数组<code>dp[i][j]</code>：表示「前i个物品放入容量为j的背包中，能获得的最大价值」。</p>
<p>对应表格维度：i（行）表示物品数量（从0到4，0代表无物品），j（列）表示背包容量（从0到8，0代表容量为0），表格共5行9列（i:0-4，j:0-8）。</p>
<h4 data-id="heading-3">1.2 步骤2：确定递推公式</h4>
<p>对于第i个物品（重量<code>weights[i-1]</code>、价值<code>values[i-1]</code>，注意数组索引从0开始，i从1开始），有两种核心决策：选或不选。</p>
<ol>
<li>
<p><strong>不选第i个物品</strong>：前i个物品的最大价值 = 前i-1个物品的最大价值，即<code>dp[i][j] = dp[i-1][j]</code>；</p>
</li>
<li>
<p><strong>选第i个物品</strong>：需保证背包容量j ≥ 第i个物品的重量，此时最大价值 = 前i-1个物品放入容量j-weights[i-1]的背包的最大价值 + 第i个物品的价值，即<code>dp[i][j] = dp[i-1][j - weights[i-1]] + values[i-1]</code>。</p>
</li>
</ol>
<p>最终递推公式（取两种决策的最大值）：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">if</span> (j &lt; weights[i - <span class="hljs-number">1</span>]) {
  <span class="hljs-comment">// 容量不足，无法选第i个物品</span>
  dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];
} <span class="hljs-keyword">else</span> {
  <span class="hljs-comment">// 容量充足，选或不选取最大值</span>
  dp[i][j] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - weights[i - <span class="hljs-number">1</span>]] + values[i - <span class="hljs-number">1</span>]);
}
</code></pre>
<p>这就是表格中每个单元格的填充规则——每个单元格的值要么继承上一行同列的值，要么继承上一行左侧对应容量的的值并加上当前物品价值，取两者最大。</p>
<h4 data-id="heading-4">1.3 步骤3：dp数组如何初始化</h4>
<p>初始化的核心是确定表格的“边界条件”，即无需推导就能直接确定的单元格值。</p>
<ol>
<li>
<p><strong>i=0（无物品）</strong>：无论背包容量j多大，放入0个物品的最大价值都是0，因此<code>dp[0][j] = 0</code>（表格第0行全为0）；</p>
</li>
<li>
<p><strong>j=0（容量为0）</strong>：无论有多少物品，都无法放入背包，最大价值都是0，因此<code>dp[i][0] = 0</code>（表格第0列全为0）。</p>
</li>
</ol>
<p>初始化后的表格（第0行、第0列已填充）：</p>













































































<table><thead><tr><th>前i个物品\背包容量j</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th></tr></thead><tbody><tr><td>0（无物品）</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>1（物品1：w=2,v=3）</td><td>0</td><td>待填</td><td>待填</td><td>待填</td><td>待填</td><td>待填</td><td>待填</td><td>待填</td><td>待填</td></tr><tr><td>2（物品2：w=3,v=4）</td><td>0</td><td>待填</td><td>待填</td><td>待填</td><td>待填</td><td>待填</td><td>待填</td><td>待填</td><td>待填</td></tr><tr><td>3（物品3：w=4,v=5）</td><td>0</td><td>待填</td><td>待填</td><td>待填</td><td>待填</td><td>待填</td><td>待填</td><td>待填</td><td>待填</td></tr><tr><td>4（物品4：w=5,v=6）</td><td>0</td><td>待填</td><td>待填</td><td>待填</td><td>待填</td><td>待填</td><td>待填</td><td>待填</td><td>待填</td></tr></tbody></table>
<h4 data-id="heading-5">1.4 步骤4：确定遍历顺序（表格填充顺序）</h4>
<p>遍历顺序直接对应二维表格的填充顺序——即「按什么顺序逐个填写表格中的单元格」，这里有两种可行方式：</p>
<ol>
<li>
<p><strong>先遍历物品（i从1到n），再遍历容量（j从1到C）</strong>：逐行填充表格，先填完第1个物品对应的所有容量（第1行），再填第2个物品对应的所有容量（第2行），直到填完所有物品；</p>
</li>
<li>
<p><strong>先遍历容量（j从1到C），再遍历物品（i从1到n）</strong>：逐列填充表格，先填完容量1对应的所有物品数量（第1列），再填容量2对应的所有物品数量（第2列），直到填完所有容量。</p>
</li>
</ol>
<p>两种顺序都可行，因为计算<code>dp[i][j]</code>时，只依赖上一行（<code>i-1</code>行）的结果，无论先填行还是先填列，上一行的对应位置都已提前计算完成。这就像填充一张二维表格：先遍历物品再遍历容量，是<strong>逐行填充</strong>（每一行对应一个物品的决策，填完一行再处理下一个物品）；先遍历容量再遍历物品，是<strong>逐列填充</strong>（每一列对应一个固定容量，先确定所有物品在该容量下的最优解）。实际解题中更常用「先遍历物品，再遍历容量」的顺序，符合我们「逐个考虑物品是否放入」的思考逻辑。</p>
<h4 data-id="heading-6">1.5 步骤5：打印dp数组（验证）</h4>
<p>这一步是直接验证表格填充结果的正确性——通过逐步填充表格、打印中间状态，确认每一步都符合递推规则，避免因规则理解偏差导致填充错误。以示例<code>weights = [2,3,4,5]</code>、<code>values = [3,4,5,6]</code>、<code>capacity = 8</code>为例，逐步填充核心表格验证逻辑：</p>
<ol>
<li>
<p><strong>填充第1行（i=1，物品1：w=2,v=3）</strong>：</p>
<p>填充后第1行：[0,0,3,3,3,3,3,3,3]</p>
<ul>
<li>
<p>j=1：容量&lt;2，无法选，dp[1][1] = dp[0][1] = 0；</p>
</li>
<li>
<p>j=2：容量≥2，选则价值=dp[0][0]+3=3，不选则0，取max=3；</p>
</li>
<li>
<p>j=3-8：选则价值=dp[0][j-2]+3=3，不选则0，取max=3；</p>
</li>
</ul>
</li>
<li>
<p><strong>填充第2行（i=2，物品2：w=3,v=4）</strong>：</p>
<p>填充后第2行：[0,0,3,4,4,7,7,7,7]</p>
<ul>
<li>
<p>j=1-2：容量&lt;3，dp[2][j] = dp[1][j]（0,3）；</p>
</li>
<li>
<p>j=3：选则dp[1][0]+4=4，不选则3，取max=4；</p>
</li>
<li>
<p>j=4：选则dp[1][1]+4=4，不选则3，取max=4；</p>
</li>
<li>
<p>j=5：选则dp[1][2]+4=3+4=7，不选则3，取max=7；</p>
</li>
<li>
<p>j=6-8：选则dp[1][j-3]+4=3+4=7，不选则3，取max=7；</p>
</li>
</ul>
</li>
<li>
<p><strong>填充第3行（i=3，物品3：w=4,v=5）</strong>：</p>
<p>填充后第3行：[0,0,3,4,5,5,8,9,9]</p>
<ul>
<li>
<p>j=1-3：容量&lt;4，dp[3][j] = dp[2][j]（0,0,3）；</p>
</li>
<li>
<p>j=4：选则dp[2][0]+5=5，不选则4，取max=5；</p>
</li>
<li>
<p>j=5：选则dp[2][1]+5=5，不选则4，取max=5；</p>
</li>
<li>
<p>j=6：选则dp[2][2]+5=3+5=8，不选则7，取max=8；</p>
</li>
<li>
<p>j=7：选则dp[2][3]+5=4+5=9，不选则7，取max=9；</p>
</li>
<li>
<p>j=8：选则dp[2][4]+5=4+5=9，不选则7，取max=9；</p>
</li>
</ul>
</li>
<li>
<p><strong>填充第4行（i=4，物品4：w=5,v=6）</strong>：</p>
<p>填充后第4行：[0,0,3,4,5,6,8,9,10]</p>
<ul>
<li>
<p>j=1-4：容量&lt;5，dp[4][j] = dp[3][j]（0,0,3,4）；</p>
</li>
<li>
<p>j=5：选则dp[3][0]+6=6，不选则5，取max=6；</p>
</li>
<li>
<p>j=6：选则dp[3][1]+6=6，不选则8，取max=8；</p>
</li>
<li>
<p>j=7：选则dp[3][2]+6=3+6=9，不选则9，取max=9；</p>
</li>
<li>
<p>j=8：选则dp[3][3]+6=4+6=10，不选则9，取max=10；</p>
</li>
</ul>
</li>
</ol>
<p>最终填充完成的表格：</p>













































































<table><thead><tr><th>前i个物品\背包容量j</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th></tr></thead><tbody><tr><td>0（无物品）</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>1（物品1：w=2,v=3）</td><td>0</td><td>0</td><td>3</td><td>3</td><td>3</td><td>3</td><td>3</td><td>3</td><td>3</td></tr><tr><td>2（物品2：w=3,v=4）</td><td>0</td><td>0</td><td>3</td><td>4</td><td>4</td><td>7</td><td>7</td><td>7</td><td>7</td></tr><tr><td>3（物品3：w=4,v=5）</td><td>0</td><td>0</td><td>3</td><td>4</td><td>5</td><td>5</td><td>8</td><td>9</td><td>9</td></tr><tr><td>4（物品4：w=5,v=6）</td><td>0</td><td>0</td><td>3</td><td>4</td><td>5</td><td>6</td><td>8</td><td>9</td><td>10</td></tr></tbody></table>
<p>表格右下角<code>dp[4][8] = 10</code>，即该示例的最大价值为10，与预期结果一致。</p>
<h4 data-id="heading-7">1.6 基础二维DP完整代码（JavaScript）</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">/**
 * 基础01背包（二维DP解法）
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number[]</span>} <span class="hljs-variable">weights</span> - 物品重量数组
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number[]</span>} <span class="hljs-variable">values</span> - 物品价值数组
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number</span>} <span class="hljs-variable">capacity</span> - 背包最大容量
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">number</span>} - 背包能容纳的最大价值
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">knapsack_2d</span>(<span class="hljs-params">weights, values, capacity</span>) {
  <span class="hljs-keyword">const</span> n = weights.<span class="hljs-property">length</span>;
  <span class="hljs-comment">// 1. 初始化二维dp数组：dp[i][j]表示前i个物品放入容量j的背包的最大价值</span>
  <span class="hljs-keyword">const</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(n + <span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">map</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(capacity + <span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>));

  <span class="hljs-comment">// 2. 遍历顺序：先遍历物品（i从1到n），再遍历容量（j从1到capacity）（逐行填充）</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt;= capacity; j++) {
      <span class="hljs-comment">// 3. 递推公式：容量不足则不选，容量充足则选或不选取最大值</span>
      <span class="hljs-keyword">if</span> (j &lt; weights[i - <span class="hljs-number">1</span>]) {
        dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];
      } <span class="hljs-keyword">else</span> {
        dp[i][j] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - weights[i - <span class="hljs-number">1</span>]] + values[i - <span class="hljs-number">1</span>]);
      }
    }
  }

  <span class="hljs-comment">// 打印完整dp数组（表格）验证</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'基础01背包二维DP数组（表格）：'</span>);
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dp[i].<span class="hljs-title function_">join</span>(<span class="hljs-string">'\t'</span>));
  }

  <span class="hljs-comment">// 最终答案：前n个物品放入容量capacity的背包的最大价值</span>
  <span class="hljs-keyword">return</span> dp[n][capacity];
}

<span class="hljs-comment">// 测试用例</span>
<span class="hljs-keyword">const</span> weights = [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];
<span class="hljs-keyword">const</span> values = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>];
<span class="hljs-keyword">const</span> capacity = <span class="hljs-number">8</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'最大价值：'</span>, <span class="hljs-title function_">knapsack_2d</span>(weights, values, capacity)); <span class="hljs-comment">// 输出：10</span>
</code></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[用填充表格法吃透01背包及其变形-2]]></title>    <link>https://juejin.cn/post/7591801024009928713</link>    <guid>https://juejin.cn/post/7591801024009928713</guid>    <pubDate>2026-01-06T03:39:14.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7591801024009928713" data-draft-id="7591800417255489545" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="用填充表格法吃透01背包及其变形-2"/> <meta itemprop="keywords" content="前端,后端,算法"/> <meta itemprop="datePublished" content="2026-01-06T03:39:14.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="颜酱"/> <meta itemprop="url" content="https://juejin.cn/user/905653309941495"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            用填充表格法吃透01背包及其变形-2
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/905653309941495/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    颜酱
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-06T03:39:14.000Z" title="Tue Jan 06 2026 03:39:14 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-06
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    3
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/04007b9c90c043c08f458d6e98a0ef72~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6aKc6YWx:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768275883&amp;x-signature=fH%2FZCBs2%2FGHFJtWCoI80mYD%2FRTk%3D" alt="dp2.png" loading="lazy"/></p>
<h3 data-id="heading-0">2.3 步骤3：dp数组如何初始化</h3>
<p>初始化逻辑与二维一致：容量为0时，最大价值为0，因此<code>dp[0] = 0</code>；其他容量的初始值也为0（因为初始无物品可放，最大价值为0），即<code>dp = new Array(capacity + 1).fill(0)</code>。</p>
<p>初始化后的单行表格：[0,0,0,0,0,0,0,0,0]（j从0到8）</p>
<h3 data-id="heading-1">2.4 步骤4：确定遍历顺序（表格填充顺序）</h3>
<p>一维DP的遍历顺序有严格要求，核心是「倒序遍历容量」，对应单行表格的「从右往左填充」——明确单行表格的填充顺序是避免重复选择物品的关键：</p>
<ol>
<li>
<p><strong>必须先遍历物品，再遍历容量</strong>：逐个处理每个物品，每次处理时更新整个单行表格（覆盖上一行结果）；</p>
</li>
<li>
<p><strong>容量必须倒序遍历（j从C到weights[i-1]）</strong>：从最大容量往小容量填充，确保计算<code>dp[j]</code>时，<code>dp[j - weights[i-1]]</code>仍是上一行（未处理当前物品）的旧值，避免同一物品被多次选择。</p>
</li>
</ol>
<p>关键原因：一维DP的核心是用单行表格复用二维表格的空间，表格中每个位置的数值都依赖“上一轮未更新的旧值”（对应二维的<code>dp[i-1][j - w[i]]</code>）。若正序遍历容量，<code>dp[j - w[i]]</code>会被提前更新（相当于二维的<code>dp[i][j - w[i]]</code>），导致同一个物品被多次选择（变成完全背包）；倒序遍历能保证计算<code>dp[j]</code>时，<code>dp[j - w[i]]</code>仍是上一行（未选当前物品）的结果，对应<strong>单行表格从右往左填充</strong>，完美契合01背包「每个物品选一次」的规则。</p>
<p>反例（正序遍历容量）：若j从weights[i-1]到C正序遍历，处理物品1（w=2,v=3）时，j=2会更新dp[2]=3，j=4时会用到dp[2]的新值（3），计算dp[4] = dp[4] + 3 = 3，相当于把物品1放入了两次，违背01背包规则。</p>
<h3 data-id="heading-2">2.5 步骤5：打印dp数组（验证）</h3>
<p>通过打印单行表格的滚动更新过程，验证填充规则的正确性。仍用测试用例 <code>weights = [2,3,4,5]</code>、<code>values = [3,4,5,6]</code>、<code>capacity = 8</code>，演示一维DP数组（单行表格）的填充变化：</p>
<ol>
<li>
<p><strong>初始状态</strong>：dp = [0,0,0,0,0,0,0,0,0]</p>
</li>
<li>
<p><strong>处理物品1（w=2,v=3），j从8到2倒序</strong>：</p>
<p>更新后：dp = [0,0,3,3,3,3,3,3,3]</p>
<ul>
<li>
<p>j=8：dp[8] = max(0, dp[8-2]+3) = max(0,0+3)=3；</p>
</li>
<li>
<p>j=7：dp[7] = max(0, dp[5]+3)=3；</p>
</li>
<li>
<p>...（j=2到6同理）；</p>
</li>
<li>
<p>j=2：dp[2] = max(0, dp[0]+3)=3；</p>
</li>
</ul>
</li>
<li>
<p><strong>处理物品2（w=3,v=4），j从8到3倒序</strong>：</p>
<p>更新后：dp = [0,0,3,4,4,7,7,7,7]</p>
<ul>
<li>
<p>j=8：max(3, dp[5]+4)=max(3,3+4)=7；</p>
</li>
<li>
<p>j=7：max(3, dp[4]+4)=max(3,3+4)=7；</p>
</li>
<li>
<p>j=6：max(3, dp[3]+4)=max(3,3+4)=7；</p>
</li>
<li>
<p>j=5：max(3, dp[2]+4)=max(3,3+4)=7；</p>
</li>
<li>
<p>j=4：max(3, dp[1]+4)=max(3,0+4)=4；</p>
</li>
<li>
<p>j=3：max(3, dp[0]+4)=max(3,0+4)=4；</p>
</li>
</ul>
</li>
<li>
<p><strong>处理物品3（w=4,v=5），j从8到4倒序</strong>：</p>
<p>更新后：dp = [0,0,3,4,5,5,8,9,9]</p>
<ul>
<li>
<p>j=8：max(7, dp[4]+5)=max(7,4+5)=9；</p>
</li>
<li>
<p>j=7：max(7, dp[3]+5)=max(7,4+5)=9；</p>
</li>
<li>
<p>j=6：max(7, dp[2]+5)=max(7,3+5)=8；</p>
</li>
<li>
<p>j=5：max(7, dp[1]+5)=max(7,0+5)=7；</p>
</li>
<li>
<p>j=4：max(4, dp[0]+5)=max(4,0+5)=5；</p>
</li>
</ul>
</li>
<li>
<p><strong>处理物品4（w=5,v=6），j从8到5倒序</strong>：</p>
<p>更新后：dp = [0,0,3,4,5,6,8,9,10]</p>
<ul>
<li>
<p>j=8：max(9, dp[3]+6)=max(9,4+6)=10；</p>
</li>
<li>
<p>j=7：max(9, dp[2]+6)=max(9,3+6)=9；</p>
</li>
<li>
<p>j=6：max(8, dp[1]+6)=max(8,0+6)=8；</p>
</li>
<li>
<p>j=5：max(5, dp[0]+6)=max(5,0+6)=6；</p>
</li>
</ul>
</li>
</ol>
<p>最终单行表格<code>dp[8] = 10</code>，与二维DP结果一致，验证了优化的正确性。</p>
<h3 data-id="heading-3">2.6 一维DP空间优化完整代码（JavaScript）</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">/**
 * 基础01背包（一维DP空间优化解法）
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number[]</span>} <span class="hljs-variable">weights</span> - 物品重量数组
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number[]</span>} <span class="hljs-variable">values</span> - 物品价值数组
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number</span>} <span class="hljs-variable">capacity</span> - 背包最大容量
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">number</span>} - 背包能容纳的最大价值
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">knapsack_1d</span>(<span class="hljs-params">weights, values, capacity</span>) {
  <span class="hljs-keyword">const</span> n = weights.<span class="hljs-property">length</span>;
  <span class="hljs-comment">// 1. 初始化一维dp数组：dp[j]表示容量j的背包的最大价值，初始值0</span>
  <span class="hljs-keyword">const</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(capacity + <span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>);

  <span class="hljs-comment">// 2. 遍历顺序：先遍历物品（i从0到n-1），再倒序遍历容量（j从capacity到weights[i]）（从右往左填充）</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
    <span class="hljs-comment">// 倒序遍历避免重复选择当前物品</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = capacity; j &gt;= weights[i]; j--) {
      <span class="hljs-comment">// 3. 递推公式：不选当前物品的最大价值 vs 选当前物品的最大价值</span>
      dp[j] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(dp[j], dp[j - weights[i]] + values[i]);
    }
    <span class="hljs-comment">// 打印每次处理物品后的dp数组（单行表格更新过程）</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`处理完物品<span class="hljs-subst">${i + <span class="hljs-number">1</span>}</span>后，dp数组：`</span>, [...dp]);
  }

  <span class="hljs-comment">// 最终答案：容量为capacity的背包的最大价值</span>
  <span class="hljs-keyword">return</span> dp[capacity];
}

<span class="hljs-comment">// 测试用例</span>
<span class="hljs-keyword">const</span> weights1 = [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];
<span class="hljs-keyword">const</span> values1 = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>];
<span class="hljs-keyword">const</span> capacity1 = <span class="hljs-number">8</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'最大价值：'</span>, <span class="hljs-title function_">knapsack_1d</span>(weights1, values1, capacity1)); <span class="hljs-comment">// 输出：10</span>
</code></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[CSS终于支持渐变色的过渡了🎉]]></title>    <link>https://juejin.cn/post/7591697558377873450</link>    <guid>https://juejin.cn/post/7591697558377873450</guid>    <pubDate>2026-01-06T02:33:03.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7591697558377873450" data-draft-id="7591730714140442666" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="CSS终于支持渐变色的过渡了🎉"/> <meta itemprop="keywords" content="前端,CSS,HTML"/> <meta itemprop="datePublished" content="2026-01-06T02:33:03.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="JIE_"/> <meta itemprop="url" content="https://juejin.cn/user/4145623568485513"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            CSS终于支持渐变色的过渡了🎉
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4145623568485513/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    JIE_
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-06T02:33:03.000Z" title="Tue Jan 06 2026 02:33:03 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-06
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    4
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读2分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">背景</h2>
<p>在做项目时，总会遇到UI给出渐变色的卡片或者按钮，但在做高亮的时候，由于没有过渡，显得尤为生硬。</p>
<h2 data-id="heading-1">过去的解决方案</h2>
<p>在过去，我们如果要实现渐变色的过渡，通常会使用如下几种方法：</p>
<ol>
<li>添加遮罩层，通过改变遮罩层的透明度做出淡入淡出的效果，实现过渡。</li>
<li>通过<code>background-size/position</code>使得渐变色移动，实现渐变色移动的效果。</li>
<li>通过<code>filter: hue-rotate</code>滤镜实现色相旋转，实现过渡。</li>
</ol>
<p>但这几种方式都有各自的局限性：</p>
<ol>
<li>遮罩层的方式看似平滑，但不是真正的过渡，差点意思。</li>
<li><code>background-size/position</code>的方式需要计算好<code>background-size</code>和<code>background-position</code>，否则会出现渐变不完整的情况。并且只是实现了渐变的移动，而不是过渡。</li>
<li><code>filter: hue-rotate</code>也需要计算好旋转角度，实现复杂度高，过渡的也不自然。</li>
</ol>
<p><span href="https://code.juejin.cn/pen/7592043796225851398" class="code-editor-container"><iframe class="code-editor-frame" data-code="code-editor-element" data-code-id="7592043796225851398" data-src="https://code.juejin.cn/pen/7592043796225851398" style="display:none;" loading="lazy"/><span class="loading-placeholder" style="display:none"><img class="placeholder-image" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8CAYAAAA6/NlyAAAAJElEQVRoge3BMQEAAADCoPVP7WkJoAAAAAAAAAAAAAAAAAAAbjh8AAFte11jAAAAAElFTkSuQmCC" loading="lazy"/><span class="loading-logo"/></span></span></p>
<h2 data-id="heading-2">@property新规则</h2>
<p><code>@property</code>规则可以定义一个自定义属性，并且可以指定该属性的语法、是否继承、初始值等。</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-keyword">@property</span> --color {
  syntax: <span class="hljs-string">'&lt;color&gt;'</span>;
  inherits: false;
  initial-value: <span class="hljs-number">#000000</span>;
}
</code></pre>
<p>我们只需要把这个自定义属性<code>--color</code>应用到<code>linear-gradient</code>中，在特定的时候改变它的值，<strong>非常轻松</strong>就可以实现渐变色的过渡了。
<span href="https://code.juejin.cn/pen/7592061789153624106" class="code-editor-container"><iframe class="code-editor-frame" data-code="code-editor-element" data-code-id="7592061789153624106" data-src="https://code.juejin.cn/pen/7592061789153624106" style="display:none;" loading="lazy"/><span class="loading-placeholder" style="display:none"><img class="placeholder-image" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8CAYAAAA6/NlyAAAAJElEQVRoge3BMQEAAADCoPVP7WkJoAAAAAAAAAAAAAAAAAAAbjh8AAFte11jAAAAAElFTkSuQmCC" loading="lazy"/><span class="loading-logo"/></span></span>
我们再看看<code>@property</code>规则中这些属性的含义。</p>
<h3 data-id="heading-3">Syntax语法描述符</h3>
<p><code>Syntax</code>用于描述自定义属性的数据类型，必填项，常见值包括：</p>
<ul>
<li><code>&lt;number&gt;</code> 数字（如0，1，2.5）</li>
<li><code>&lt;percentage&gt;</code> 百分比（如0%，50%，100%）</li>
<li><code>&lt;length&gt;</code> 长度单位（如px，em，rem）</li>
<li><code>&lt;color&gt;</code> 颜色值</li>
<li><code>&lt;angle&gt;</code> 角度值（如deg，rad）</li>
<li><code>&lt;time&gt;</code> 时间值（如s，ms）</li>
<li><code>&lt;image&gt;</code> 图片</li>
<li><code>&lt;*&gt;</code> 任意类型</li>
</ul>
<h3 data-id="heading-4">Inherits继承描述符</h3>
<p><code>Inherits</code>用于描述自定义属性是否从父元素继承值，必填项：</p>
<ul>
<li><code>true</code> 从父元素继承值</li>
<li><code>false</code> 不继承，每个元素独立</li>
</ul>
<h3 data-id="heading-5">Initial-value初始值描述符</h3>
<p><code>Initial-value</code>用于描述自定义属性的初始值，在<code>Syntax</code>为通用时为可选。</p>
<h3 data-id="heading-6">兼容性</h3>
<p><code>@property</code>目前仍是<strong>实验性规则</strong>，但主流浏览器较新版本都已支持。
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fafe7972c8f54f2baccd95e47a6a2ebe~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSklFXw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768271931&amp;x-signature=2L4lNtJk3RNks5AxbrtAInFx7Wk%3D" alt="b70bdd98-15d5-4aa3-a3c4-b4d08a7aba9c.png" loading="lazy"/></p>
<h2 data-id="heading-7">总结与展望</h2>
<p><code>@property</code>规则的出现，标志着CSS在动态样式控制方面迈出了重要一步。它不仅解决了渐变色过渡的技术难题，更为未来的CSS动画和交互设计开辟了新的可能性。
随着浏览器支持的不断完善，我们可以期待：</p>
<ul>
<li>更丰富的动画效果</li>
<li>更简洁的代码实现</li>
<li>更好的性能表现</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[一文看懂js中所有属性访问api]]></title>    <link>https://juejin.cn/post/7591861857465057318</link>    <guid>https://juejin.cn/post/7591861857465057318</guid>    <pubDate>2026-01-06T03:44:45.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7591861857465057318" data-draft-id="7532715152770744347" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="一文看懂js中所有属性访问api"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2026-01-06T03:44:45.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="布列瑟农的星空"/> <meta itemprop="url" content="https://juejin.cn/user/976022056218471"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            一文看懂js中所有属性访问api
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/976022056218471/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    布列瑟农的星空
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-06T03:44:45.000Z" title="Tue Jan 06 2026 03:44:45 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-06
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>js对象属性的遍历有很多方法，比如<code>for in</code>、<code>Object.keys</code>、<code>Reflect.ownKeys</code>等等，用起来不知道选哪个，记起来麻烦，本文将介绍所有属性访问相关api的能力和区别。</p>
<h2 data-id="heading-0">前置知识：对象属性的「3 种分类」</h2>
<p>所有遍历方法的核心差异，<strong>本质都是「能遍历哪些类型的属性」</strong>，必须先明确对象属性的 3 类划分：</p>
<h3 data-id="heading-1">1. 可枚举属性 vs 不可枚举属性</h3>
<p>属性的 <code>enumerable</code> 特性为 <code>true</code> 是「可枚举属性」，<code>false</code> 是「不可枚举属性」；</p>
<ul>
<li>默认：我们直接给对象定义的属性（<code>obj.name = 'xxx'</code>）、字面量声明的属性，默认<strong>可枚举</strong>；</li>
<li>不可枚举：JS 内置属性（比如 <code>obj.toString</code>、<code>obj.__proto__</code>）、通过 <code>Object.defineProperty</code> 手动设置 <code>enumerable: false</code> 的属性，都是<strong>不可枚举属性</strong>。</li>
</ul>
<h3 data-id="heading-2">2. 自有属性（自有属性） vs 继承属性</h3>
<ul>
<li>自有属性：对象<strong>自己本身拥有</strong>的属性（挂载在对象自身，不在 <code>__proto__</code> 原型链上）；</li>
<li>继承属性：从<strong>原型链</strong>上继承过来的属性（比如 <code>obj.hasOwnProperty</code>、<code>obj.toString</code> 都是从 <code>Object.prototype</code> 继承的）。</li>
</ul>
<h3 data-id="heading-3">3. 字符串属性 vs Symbol 属性</h3>
<p>JS 对象的属性名，<strong>可以是「字符串」或「Symbol 类型」</strong>（ES6 新增）；</p>
<ul>
<li>字符串属性：最常用的 <code>obj.name</code>、<code>obj['age']</code> 都属于此类；</li>
<li>Symbol 属性：<code>const s = Symbol('id'); obj[s] = 100</code>，这种属性名是唯一的，默认不会被常规遍历方法捕获。</li>
</ul>
<h2 data-id="heading-4">不同属性访问(遍历/判断)方法区别</h2>





















































































































<table><thead><tr><th>方法</th><th>访问范围</th><th>能否访问 Symbol</th><th>能否访问不可枚举</th><th>能否访问继承属性</th><th>返回值 / 形式</th></tr></thead><tbody><tr><td><code>JSON.stringify</code></td><td>可枚举字符串属性</td><td>否</td><td>否</td><td>否</td><td>JSON字符串</td></tr><tr><td><code>for...in</code></td><td>可枚举字符串属性</td><td>否</td><td>否</td><td>否</td><td>循环，直接拿 key</td></tr><tr><td><code>Object.keys</code></td><td>自有可枚举字符串属性</td><td>否</td><td>否</td><td>否</td><td>字符串数组</td></tr><tr><td><code>Object.values</code></td><td>自有可枚举字符串属性</td><td>否</td><td>否</td><td>否</td><td>值的数组</td></tr><tr><td><code>Object.entries</code></td><td>自有可枚举字符串属性</td><td>否</td><td>否</td><td>否</td><td>二维键值对数组</td></tr><tr><td><code>Object.getOwnPropertyNames</code></td><td>自有所有字符串属性</td><td>否</td><td>否</td><td>否</td><td>字符串数组</td></tr><tr><td><code>Object.getOwnPropertySymbols</code></td><td>自有所有 Symbol 属性</td><td><strong>是</strong></td><td><strong>是</strong></td><td>否</td><td>Symbol 数组</td></tr><tr><td><code>Reflect.ownKeys</code></td><td>自有所有属性</td><td><strong>是</strong></td><td><strong>是</strong></td><td>否</td><td>混合类型数组</td></tr><tr><td><code>Object.getOwnPropertyDescriptors</code></td><td>自有所有属性</td><td><strong>是</strong></td><td><strong>是</strong></td><td>否</td><td>属性描述符对象</td></tr><tr><td><code>hasOwnProperty</code></td><td>自有所有属性</td><td><strong>是</strong></td><td><strong>是</strong></td><td>否</td><td>布尔</td></tr><tr><td><code>Object.hasOwn</code></td><td>自有所有属性</td><td><strong>是</strong></td><td><strong>是</strong></td><td>否</td><td>布尔</td></tr><tr><td><code>in</code></td><td>所有属性</td><td><strong>是</strong></td><td><strong>是</strong></td><td><strong>是</strong></td><td>布尔</td></tr><tr><td><code>Reflect.has</code></td><td>所有属性</td><td><strong>是</strong></td><td><strong>是</strong></td><td><strong>是</strong></td><td>布尔</td></tr></tbody></table>
<h2 data-id="heading-5">规律小结</h2>
<ul>
<li>最局限的5个方法刚好也是最常用的
<code>JSON.stringify</code>,<code>for...in</code>,<code>Object.keys</code>  ,<code>Object.values</code> ,<code>Object.entries</code>    ,既无法访问symbol属性，也无法访问不可枚举和继承属性。</li>
<li>带<code>own</code>的api，都无法访问继承属性</li>
<li><code>in</code>操作符和<code>Reflect.has</code> 可以访问到所有属性</li>
</ul>
<h2 data-id="heading-6">关于继承的说明</h2>
<p>本文中的继承，是指原型链访问，并非面向对象中的类继承(<code>extends</code>)。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>  {
    name = <span class="hljs-string">"小王"</span>; <span class="hljs-comment">//自有属性</span>
    <span class="hljs-title function_">work</span>(<span class="hljs-params"/>) {}
}
<span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();
</code></pre>
<p>这里的p对象的name属性，是它的自有属性，而work方法继承自原型链，因此<code>own</code>类方法无法访问到work。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3717e30e795f4dcbb3b836f6a654b618~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5biD5YiX55Gf5Yac55qE5pif56m6:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768275885&amp;x-signature=S0qyInnNDfE9p2%2Bak4YnZcQMNRc%3D" alt="image.png" loading="lazy"/></p>
<p>es6中的继承，沿用了es5中的属性私有，方法公开的继承最佳实践，因此es6中extends自父类的成员属性，也是该实例自有属性。</p>
<h2 data-id="heading-7">附</h2>
<p>测试代码和截图如下</p>
<pre><code class="hljs language-js" lang="js">  <span class="hljs-keyword">class</span> <span class="hljs-title class_">Persion</span> {
        alive = <span class="hljs-literal">true</span>; <span class="hljs-comment">//继承属性</span>
        <span class="hljs-title function_">study</span>(<span class="hljs-params"/>) {}
      }
      <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Persion</span> {
        name = <span class="hljs-string">"小王"</span>; <span class="hljs-comment">//自有属性</span>
        <span class="hljs-title function_">work</span>(<span class="hljs-params"/>) {}
      }
      <span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();
      <span class="hljs-comment">//wealth 不可枚举</span>
      <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(p, <span class="hljs-string">"wealth"</span>, {
        <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,
        <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">value</span>: <span class="hljs-number">1000000</span>,
      });
      p.<span class="hljs-property">age</span> = <span class="hljs-number">18</span>; <span class="hljs-comment">//age自有属性</span>
      <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CAREER</span> = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">"career"</span>);
      <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">ID</span> = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">"id"</span>);
      p[<span class="hljs-variable constant_">ID</span>] = <span class="hljs-string">"9523"</span>; <span class="hljs-comment">//ID symbol属性</span>
      <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(p, <span class="hljs-variable constant_">CAREER</span>, {
        <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,
        <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">value</span>: <span class="hljs-string">"detective"</span>,
      });
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">group</span>(<span class="hljs-string">"for in"</span>);
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> p) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key); <span class="hljs-comment">// alive name age</span>
      }
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">groupEnd</span>(<span class="hljs-string">"for in"</span>);
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(p)); <span class="hljs-comment">// ['alive', 'name', 'age']</span>
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">values</span>(p)); <span class="hljs-comment">//[true, '小王', 18]</span>
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(p)); <span class="hljs-comment">// '[["alive",true],["name","小王"],["age",18]]'</span>
      <span class="hljs-comment">// -----------------------可得到非symbol自有属性，无法获取不可枚举属性</span>
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Object.getOwnPropertyNames"</span>, <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyNames</span>(p)); <span class="hljs-comment">// ['alive', 'name', 'wealth', 'age']</span>
      <span class="hljs-comment">//------------------------可得到symbol属性，包括不可枚举的symbol</span>
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(
        <span class="hljs-string">"Object.getOwnPropertySymbols"</span>,
        <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertySymbols</span>(p)
      ); <span class="hljs-comment">//[Symbol(id),Symbol(career)]</span>
      <span class="hljs-comment">//------------------------可得到所有自有属性，包括不可枚举和symbol属性，无法获取继承属性</span>
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Reflect.ownKeys"</span>, <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(p)); <span class="hljs-comment">// ['alive', 'name', 'wealth', 'age', Symbol(id),Symbol(career)]</span>
      <span class="hljs-comment">//------------------------可得到所有自有属性，包括不可枚举和symbol属性，无法获取继承属性</span>
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(
        <span class="hljs-string">"Object.getOwnPropertyDescriptors"</span>,
        <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptors</span>(p)
      );

      <span class="hljs-comment">//继承属性返回false</span>
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">group</span>(<span class="hljs-string">"p.hasOwnProperty"</span>);
      [<span class="hljs-string">"alive"</span>, <span class="hljs-string">"study"</span>, <span class="hljs-string">"work"</span>, <span class="hljs-string">"name"</span>, <span class="hljs-string">"age"</span>, <span class="hljs-string">"wealth"</span>, <span class="hljs-variable constant_">ID</span>, <span class="hljs-variable constant_">CAREER</span>].<span class="hljs-title function_">forEach</span>(
        <span class="hljs-function">(<span class="hljs-params">name</span>) =&gt;</span> {
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(
            <span class="hljs-string">`p.hasOwnProperty(<span class="hljs-subst">${name.toString()}</span>)`</span>,
            p.<span class="hljs-title function_">hasOwnProperty</span>(name)
          );
        }
      );
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">groupEnd</span>();
      <span class="hljs-comment">//继承属性返回false</span>
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">group</span>(<span class="hljs-string">"Object.hasOwn"</span>);
      [<span class="hljs-string">"alive"</span>, <span class="hljs-string">"study"</span>, <span class="hljs-string">"work"</span>, <span class="hljs-string">"name"</span>, <span class="hljs-string">"age"</span>, <span class="hljs-string">"wealth"</span>, <span class="hljs-variable constant_">ID</span>, <span class="hljs-variable constant_">CAREER</span>].<span class="hljs-title function_">forEach</span>(
        <span class="hljs-function">(<span class="hljs-params">name</span>) =&gt;</span> {
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(
            <span class="hljs-string">`Object.hasOwn(p, <span class="hljs-subst">${name.toString()}</span>)`</span>,
            <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">hasOwn</span>(p, name)
          );
        }
      );
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">groupEnd</span>();
      <span class="hljs-comment">// 可判断所有属性，包括不可枚举/symbol/继承</span>
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">group</span>(<span class="hljs-string">"in"</span>);
      [<span class="hljs-string">"alive"</span>, <span class="hljs-string">"study"</span>, <span class="hljs-string">"work"</span>, <span class="hljs-string">"name"</span>, <span class="hljs-string">"age"</span>, <span class="hljs-string">"wealth"</span>, <span class="hljs-variable constant_">ID</span>, <span class="hljs-variable constant_">CAREER</span>].<span class="hljs-title function_">forEach</span>(
        <span class="hljs-function">(<span class="hljs-params">name</span>) =&gt;</span> {
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${name.toString()}</span> in p`</span>, name <span class="hljs-keyword">in</span> p);
        }
      );
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">groupEnd</span>();
      <span class="hljs-comment">// 可判断所有属性，包括不可枚举/symbol/继承</span>
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">group</span>(<span class="hljs-string">"Reflect.has"</span>);
      [<span class="hljs-string">"alive"</span>, <span class="hljs-string">"study"</span>, <span class="hljs-string">"work"</span>, <span class="hljs-string">"name"</span>, <span class="hljs-string">"age"</span>, <span class="hljs-string">"wealth"</span>, <span class="hljs-variable constant_">ID</span>, <span class="hljs-variable constant_">CAREER</span>].<span class="hljs-title function_">forEach</span>(
        <span class="hljs-function">(<span class="hljs-params">name</span>) =&gt;</span> {
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(
            <span class="hljs-string">`Reflect.has(p, <span class="hljs-subst">${name.toString()}</span>)`</span>,
            <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">has</span>(p, name)
          );
        }
      );
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">groupEnd</span>();
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fb6007daa1be47c1968eb4c64f00fbe6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5biD5YiX55Gf5Yac55qE5pif56m6:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768275885&amp;x-signature=S9MZtX7ps5QiMzdBX55qT1wyNNA%3D" alt="image.png" loading="lazy"/></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[让我们从Spring AI开始]]></title>    <link>https://juejin.cn/post/7591805786398900250</link>    <guid>https://juejin.cn/post/7591805786398900250</guid>    <pubDate>2026-01-06T03:45:10.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7591805786398900250" data-draft-id="7591871204567793690" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="让我们从Spring AI开始"/> <meta itemprop="keywords" content="AI编程"/> <meta itemprop="datePublished" content="2026-01-06T03:45:10.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="信码由缰"/> <meta itemprop="url" content="https://juejin.cn/user/2110664941509214"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            让我们从Spring AI开始
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2110664941509214/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    信码由缰
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-06T03:45:10.000Z" title="Tue Jan 06 2026 03:45:10 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-06
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><img src="https://cf-blog.icodebuddy.com/image/101/101-0.png" alt="" loading="lazy"/></p>
<h2 data-id="heading-0">Spring AI：使用Java迈入生成式AI的第一步</h2>
<p><strong>基于Java的企业系统通常难以与Python库及相关工具链协同工作。为此，Spring AI应运而生</strong>——这是一个旨在简化整合人工智能功能（特别是大型语言模型）应用开发的开源框架，它采用了Spring生态系统中大家熟悉的模式。</p>
<p>如果您是一名Java开发者，希望将ChatGPT或Google Gemini等强大功能集成到企业应用程序中，而又不想费力研究各提供商特定的SDK，那么Spring AI是您的理想工具。</p>
<h3 data-id="heading-1">什么是Spring AI？</h3>
<p>Spring AI的核心是充当AI模型的<strong>通用抽象层</strong>。</p>
<p>可以将其类比于<strong>Spring Data JPA</strong>之于数据库的关系：正如Spring Data抽象了SQL和数据库的具体细节一样，Spring AI则抽象了不同AI提供商（如OpenAI、Google、Azure、Anthropic等）之间的差异。</p>
<p>这种方法带来了两大显著优势：</p>
<ol>
<li>
<p><strong>可移植性</strong>：您只需极少的代码改动即可在不同AI模型和提供商之间切换，从而为您的用例选择最具成本效益或性能最佳的模型。</p>
</li>
<li>
<p><strong>熟悉度</strong>：它使用了依赖注入、自动配置和流式API（如<code>WebClient</code>或<code>JdbcClient</code>）等标准的Spring概念，使得数以百万计的现有Spring开发者能够轻松上手。</p>
</li>
</ol>
<h3 data-id="heading-2">为什么选择Spring AI而不是LangChain？</h3>
<p>尽管<strong>LangChain</strong>是一个强大且与提供商无关的框架，并因LLM调用的“链式”编排而广受欢迎，但它主要为<strong>Python</strong>生态系统构建。相比之下，Spring AI则是从零开始构建，遵循<strong>Java语言习惯</strong>，并能与<strong>Spring Boot</strong>应用无缝集成。</p>
<p>以下是Java企业开发者应该认真考虑使用Spring AI的原因：</p>
<p><img src="https://cf-blog.icodebuddy.com/image/101/101-1_cn.png" alt="" loading="lazy"/></p>
<h3 data-id="heading-3">符合“Java习惯”的优势</h3>
<p>对于一个Java团队来说，选择Spring AI意味着：</p>
<ul>
<li>
<p><strong>无需多语言复杂性</strong>：您可以避免在生产Java环境中引入Python依赖、虚拟环境以及进程间通信带来的麻烦。</p>
</li>
<li>
<p><strong>性能</strong>：Spring AI原生运行在Java虚拟机（JVM）内，充分利用其卓越的垃圾回收和性能优化能力。</p>
</li>
<li>
<p><strong>工具链</strong>：您可以享受到静态类型检查、强大的调试支持以及Java测试框架（如JUnit、Mockito）完整生态系统的益处。</p>
</li>
</ul>
<p>简而言之，如果您的应用程序是用Java编写并使用Spring Boot，那么Spring AI就是集成生成式AI最自然、阻力最小的选择。</p>
<h3 data-id="heading-4">Spring AI的核心概念</h3>
<p>要构建一个基本的AI应用，您需要理解三个核心组件：</p>
<p><img src="https://cf-blog.icodebuddy.com/image/101/101-2_cn.png" alt="" loading="lazy"/></p>
<h3 data-id="heading-5">构建一个简单的聊天服务</h3>
<p>让我们创建一个极简的Spring Boot应用程序，它使用<code>ChatClient</code>根据用户的消息生成回复。在本示例中，我们将使用OpenAI模型。</p>
<h4 data-id="heading-6">1. 项目设置（Maven）</h4>
<p>将以下内容添加到您的<code>pom.xml</code>文件中：</p>
<pre><code class="hljs language-xml" lang="xml">
<span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>

  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.ai<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-ai-openai-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>

  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>

      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.ai<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>

      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-ai-bom<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>

      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>

      <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span>

      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

  <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span>

</code></pre>
<h4 data-id="heading-7">2. 配置（application.properties）</h4>
<p>您需要提供AI提供商的API密钥。将其放在<code>src/main/resources/application.properties</code>文件中。</p>
<pre><code class="hljs language-properties" lang="properties">
# 用您实际的OpenAI API密钥替换

spring.ai.openai.api-key=&lt;YOUR_OPENAI_API_KEY&gt;

</code></pre>
<h4 data-id="heading-8">3. 控制器（AiController.java）</h4>
<p>这个类定义了一个REST端点，用于接收消息并使用注入的<code>ChatClient</code>获取响应。</p>
<pre><code class="hljs language-java" lang="java">
<span class="hljs-keyword">package</span> com.example.aidemo;

<span class="hljs-keyword">import</span> org.springframework.ai.chat.client.ChatClient;

<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;

<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestParam;

<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;

<span class="hljs-meta">@RestController</span>

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AiController</span> {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ChatClient chatClient;

    <span class="hljs-comment">/**

     * Spring Boot会根据依赖项和属性自动配置并注入ChatClient。

     */</span>

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AiController</span><span class="hljs-params">(ChatClient.Builder chatClientBuilder)</span> {

        <span class="hljs-comment">// 使用注入的构建器构建ChatClient实例</span>

        <span class="hljs-built_in">this</span>.chatClient = chatClientBuilder.build();

    }

    <span class="hljs-meta">@GetMapping("/generate")</span>

    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">generate</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(value = "message", defaultValue = "Tell me a short, friendly joke.")</span> String message)</span> {

        <span class="hljs-comment">// 使用流式API定义提示词并调用模型</span>

        <span class="hljs-keyword">return</span> chatClient.prompt()

            .user(message) <span class="hljs-comment">// 设置用户的输入消息</span>

            .call()       <span class="hljs-comment">// 执行对AI模型的调用</span>

            .content();   <span class="hljs-comment">// 从响应中提取纯文本内容</span>

    }

}

</code></pre>
<h4 data-id="heading-9">4. 运行与测试</h4>
<ul>
<li>
<p>运行您的Spring Boot应用程序。</p>
</li>
<li>
<p>测试端点：<code>http://localhost:8080/generate?message=Explain%20Spring%20AI%20in%20one%20sentence</code></p>
</li>
</ul>
<hr/>
<p>【注】本文译自：<a href="https://link.juejin.cn?target=https%3A%2F%2Fdev.to%2Fved_sharma_e776421e694cdc%2Flets-start-with-spring-ai-3e4h" target="_blank" title="https://dev.to/ved_sharma_e776421e694cdc/lets-start-with-spring-ai-3e4h" ref="nofollow noopener noreferrer">Lets start with Spring AI</a></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[应对 Nginx Ingress 退役，是时候理清这些易混淆的概念了]]></title>    <link>https://juejin.cn/post/7591767753850650666</link>    <guid>https://juejin.cn/post/7591767753850650666</guid>    <pubDate>2026-01-06T03:45:36.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7591767753850650666" data-draft-id="7591672090790248467" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="应对 Nginx Ingress 退役，是时候理清这些易混淆的概念了"/> <meta itemprop="keywords" content="云原生"/> <meta itemprop="datePublished" content="2026-01-06T03:45:36.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="阿里云云原生"/> <meta itemprop="url" content="https://juejin.cn/user/3808363977648493"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            应对 Nginx Ingress 退役，是时候理清这些易混淆的概念了
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3808363977648493/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    阿里云云原生
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-06T03:45:36.000Z" title="Tue Jan 06 2026 03:45:36 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-06
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>作者：望宸</p>
<p>本文希望提供一种更简单的方式，来理解这些容易混淆的技术概念：Nginx、Ingress、Ingress Controller、Ingress API、Nginx Ingress、Higress、Gateway API。</p>
<h2 data-id="heading-0">Nginx 和 Kubernetes</h2>
<p>我们先按和 Kubernetes 是否有关，分为两类：</p>
<p>Nginx 是在没有 Kubernetes 的年代，流量入口上的事实标准，是独立运行在任何 Linux/Windows 服务器上的 Web 服务器。提供以下主要功能：</p>
<ul>
<li>接收请求；</li>
<li>转发请求；</li>
<li>负载均衡；</li>
<li>简单的流量治理，例如限流、缓存、重写。</li>
</ul>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5dd7062a881f4a6d9cc2ada7cc8512a2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768275936&amp;x-signature=uzoRWXoxMs7FDMj2Vy22eEFCS9I%3D" alt="图片" loading="lazy"/></p>
<p>而 Ingress API、Ingress Controller、Nginx Ingress、Higress、Gateway API 都依赖 Kubernetes，Kubernetes 出现后，才有了这些概念。其中，Ingress API 是 Kubernetes 管理流量的规范，Ingress Controller 是规范的实现组件，Nginx Ingress 和 Higress 都是规范的完整实现和功能扩展，Gateway API 则是 Ingress API 的升级和下一代。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7d12816faa7a4342b1ff8495770e6e81~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768275936&amp;x-signature=UbK6IYYkyOT4E0JO0hyRiUMuFa0%3D" alt="图片" loading="lazy"/></p>
<p>需要注意的是，Ingress 经常单独出现，需要基于语境来判断，有可能是指 Ingress API，也有可能是指 Ingress 资源，即用户编写的具体配置对象（YAML），遵循 Ingress API。</p>
<h2 data-id="heading-1">Ingress API 和 Ingress Controller</h2>
<p>Ingress API 和 Ingress Controller 分别是 Kubernetes 流量管理的规范和执行器。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/70e786088cf74b80ad3fe085eff71744~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768275936&amp;x-signature=IUxS0SpEqn1id8D5XVsSuNDgL6M%3D" alt="图片" loading="lazy"/></p>
<p><strong>Ingress API</strong>：用声明式的方式，描述外部流量如何进入集群里的 Service，包括：</p>
<ul>
<li>如何通过域名访问服务；</li>
<li>如何根据 URL 路径路由到不同后端服务；</li>
<li>后端服务是谁；</li>
<li>是否启用 HTTPS 加密。</li>
</ul>
<p>形象地说，Ingress API 可以理解位 Kubernetes 中管理流量的说明书。</p>
<p><strong>Ingress Controller</strong>：是 Ingress API 的实现组件，即执行者，包括：</p>
<ul>
<li>监听 Ingress 资源变化；</li>
<li>将 Ingress 规则转换为实际的反向代理配置；</li>
<li>接收外部流量并按规则路由；</li>
<li>处理 TLS 终止（HTTPS 解密）；</li>
<li>提供健康检查、负载均衡、重试等流量治理能力。</li>
</ul>
<p>通过以上能力，Ingress Controller 就实现了 Kubernetes 入口流量的管理。</p>
<h2 data-id="heading-2">Nginx Ingress 和 Higress</h2>
<p>Nginx Ingress 和 Higress 都是 Ingress API 的完整实现和功能扩展。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cdf9b79f58a34f3c98776a7ff13cfc0e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768275936&amp;x-signature=r7HDDeYxrZL2F3%2FB47YddrB0Ibk%3D" alt="图片" loading="lazy"/></p>
<p>Nginx Ingress：用 Nginx 作为底层实现的 Ingress API，控制面和数据面耦合在同一个进程/容器中。优点是简单、易用、社区广泛。</p>
<p><strong>缺点是：</strong></p>
<ul>
<li>不是原生的 Ingress API，Ingress API 语义偏弱；</li>
<li>扩展靠 Annotation（工程噩梦）；</li>
<li>生成 nginx.conf + reload，动态配置能力弱（频繁 reload 影响性能）。</li>
</ul>
<p>适用于简单、稳定、小规模的场景。</p>
<p>Higress：数据面是基于 Enovy，控制面给基于 istio，是原生的 Ingress API。</p>
<p><strong>优点是：</strong></p>
<ul>
<li>控制面与数据面解耦，可独立扩缩容；</li>
<li>基于 xDS 协议，实现真正的动态配置（无 reload，零中断）；</li>
<li>原生支持插件扩展：Wasm、Lua、Go 插件由控制面统一管理并下发；</li>
<li><strong>兼容多协议 &amp; 多标准：同时支持 Ingress API 和 Gateway API。</strong></li>
</ul>
<p>缺点是，相比 Nginx 广泛的社区基础，Higress 为代表的原生 Ingress API，部署和维护存在学习成本。</p>
<p>适用于高性能、高扩展、企业级的场景。</p>
<h2 data-id="heading-3">Nginx Ingress 退役</h2>
<p>11月，Kubernetes SIG Network 和安全响应委员会宣布 Ingress NGINX 退役。（⚠️ NGINX 并未退役。）</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/eb08cd46ccda4305bddddd7ad9805fb4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768275936&amp;x-signature=PFongHPha%2BYCvUwdh4n8D0w6o8s%3D" alt="图片" loading="lazy"/></p>
<p><strong>意味着：</strong></p>
<ul>
<li>Ingress NGINX 尽力维护服务至 2026 年 3 月；</li>
<li>不再发布任何新版本；</li>
<li>不再修复任何漏洞；</li>
<li>也不会更新任何可能发现的安全漏洞；</li>
<li>GitHub 代码库将设置为只读，仅供参考；</li>
<li>现有的 Ingress NGINX 部署将继续运行，安装文件也将继续可用。</li>
</ul>
<p>引发退役的根本原因：：</p>
<ul>
<li>多年来，该项目只有一两个人利用业余时间，在工作之余进行开发工作；</li>
<li>尝试和 Gateway API 社区合作开发一个替代控制器，但未能激发更多人参与 Ingress NGINX 的维护。</li>
</ul>
<h2 data-id="heading-4">Higress：Nginx Ingress 退役的替代优先方案</h2>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5a54f7fbf0fc4243a9779926978f1659~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768275936&amp;x-signature=NKPqzNS5csEVsz%2BQSxagvB963no%3D" alt="图片" loading="lazy"/></p>
<ul>
<li>Kubernetes 官方推荐，即官方社区文档中进行了说明；</li>
<li>对 Nginx Ingress 的 Annotation 兼容度最高，支持 51 种，覆盖 90% 的用户场景，这意味着现有的 K8s Ingress YAML 文件无需大量修改即可完成迁移；</li>
<li>长期投入，并提供企业版服务，即阿里云 API 网关；</li>
<li>提供监听 K8s Ingress（Ingress 模式），适用于希望保持 K8s 原生工作流（如GitOps）的团队；和控制台配置 API（API 管理模式），适用于需要集中治理和精细化管理的场景。</li>
</ul>
<h2 data-id="heading-5">Gateway API 和 Ingress API</h2>
<p>Gateway API 是 Ingress API 规范的超集和下一代。他的出现，是为了解决 Ingress API 自身无法搞定的问题。其中，Higress 已经支持 Gateway API 标准，用户可从 Ingress API 平滑迁移至 Gateway API。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/de4cb0684f4a4544b910ef82aef57fe3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768275936&amp;x-signature=FhslJ6330cnp%2FjzVpgK4s7yRLKw%3D" alt="图片" loading="lazy"/></p>
<p>Ingress API 存在的问题，Gateway API 这样去解决：</p>
<p>职责不清，后果是 Ingress 是“一人写全”，没有权限边界。<strong>-&gt; Gateway API 通过角色分离解决，定义基础设施提供者、集群管理员、应用开发者。</strong></p>
<p>功能表达能力弱，依赖 Controller 特有扩展，后果是不标准、不同实现之间迁移成本高。<strong>-&gt; Gateway API 通过 Wasm、插件、服务网格集成解决扩展的标准化。</strong></p>
<p>仅支持 HTTP/HTTPS，无法处理 TCP/UDP/gRPC 等协议。<strong>-&gt; 云原生应用早已不只是 Web 服务，Gateway API 通过统一的 API，管理所有南北向流量。</strong></p>
<p>无法表达复杂路由逻辑，微服务治理需求远超 Ingress 能力。<strong>-&gt; Gateway API 支持 Wasm、插件、服务网格集成，通过标准化的高级路由解决。</strong></p>
<p>一个 Ingress Controller 全局共享，缺乏多租户隔离，多租户场景下存在安全和配置冲突风险。<strong>-&gt; Gateway API 提供了独立 Gateway 的实例。</strong></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[手写Spring IoC：注解+反射打造轻量级容器]]></title>    <link>https://juejin.cn/post/7591871204567810074</link>    <guid>https://juejin.cn/post/7591871204567810074</guid>    <pubDate>2026-01-06T03:45:36.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7591871204567810074" data-draft-id="7591694511244787750" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="手写Spring IoC：注解+反射打造轻量级容器"/> <meta itemprop="keywords" content="Java"/> <meta itemprop="datePublished" content="2026-01-06T03:45:36.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="雨中飘荡的记忆"/> <meta itemprop="url" content="https://juejin.cn/user/694547077666606"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            手写Spring IoC：注解+反射打造轻量级容器
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/694547077666606/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    雨中飘荡的记忆
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-06T03:45:36.000Z" title="Tue Jan 06 2026 03:45:36 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-06
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">手写Spring IoC：注解+反射打造轻量级容器</h2>
<blockquote>
<p>深入理解Spring IoC核心原理，通过注解和反射机制手写一个简易版IoC容器，掌握依赖注入的本质。</p>
</blockquote>
<h3 data-id="heading-1">1. 引言：Spring IoC的魔力</h3>
<p>在Spring框架中，IoC（控制反转）和DI（依赖注入）是最核心的概念。只需一个<code>@Autowired</code>注解，Spring就能自动帮我们注入依赖对象，这背后的原理是什么？</p>
<p>本文将通过<strong>注解+反射</strong>的方式，手写一个简易版Spring IoC容器，让你深入理解：</p>
<ul>
<li>注解是如何被扫描和解析的</li>
<li>Bean是如何被创建和管理的</li>
<li>依赖注入是如何实现的</li>
<li>Spring容器的运行机制</li>
</ul>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8973d982964b4b1eab85947f180db86b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuo5Lit6aOY6I2h55qE6K6w5b-G:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768275935&amp;x-signature=psXeyOKXMKmYg1GutFFHZ0z9dnU%3D" alt="" loading="lazy"/></p>
<h4 data-id="heading-2">1.1 为什么要手写IoC？</h4>
<ul>
<li><strong>理解原理</strong> - 知其然更知其所以然</li>
<li><strong>面试必备</strong> - Spring IoC是面试高频考点</li>
<li><strong>提升能力</strong> - 掌握反射、注解等核心技术</li>
<li><strong>框架选型</strong> - 理解框架设计思想</li>
</ul>
<hr/>
<h3 data-id="heading-3">2. 核心概念：IoC、DI、注解、反射</h3>
<h4 data-id="heading-4">2.1 控制反转（IoC）</h4>
<p><strong>传统方式</strong>：对象自己创建依赖</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-type">UserDao</span> <span class="hljs-variable">userDao</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDaoImpl</span>(); <span class="hljs-comment">// 主动创建</span>
}
</code></pre>
<p><strong>IoC方式</strong>：对象由容器创建和注入</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> {
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> UserDao userDao; <span class="hljs-comment">// 被动接收</span>
}
</code></pre>
<p><strong>控制反转</strong>就是把对象创建和依赖管理的控制权，从应用代码转移到IoC容器。</p>
<h4 data-id="heading-5">2.2 依赖注入（DI）</h4>
<p>依赖注入是IoC的实现方式，有三种注入方式：</p>
<p><strong>① 构造器注入</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> UserDao userDao;

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserService</span><span class="hljs-params">(UserDao userDao)</span> {
        <span class="hljs-built_in">this</span>.userDao = userDao;
    }
}
</code></pre>
<p><strong>② Setter注入</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> {
    <span class="hljs-keyword">private</span> UserDao userDao;

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUserDao</span><span class="hljs-params">(UserDao userDao)</span> {
        <span class="hljs-built_in">this</span>.userDao = userDao;
    }
}
</code></pre>
<p><strong>③ 字段注入</strong>（最常用）</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> {
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> UserDao userDao;
}
</code></pre>
<h4 data-id="heading-6">2.3 Java注解</h4>
<p>注解是Java 5引入的元数据标记机制。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 定义注解</span>
<span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span> <span class="hljs-comment">// 运行时保留</span>
<span class="hljs-meta">@Target(ElementType.TYPE)</span>           <span class="hljs-comment">// 作用于类</span>
<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Component {
    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">""</span>;
}

<span class="hljs-comment">// 使用注解</span>
<span class="hljs-meta">@Component("userService")</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> {
}
</code></pre>
<h4 data-id="heading-7">2.4 Java反射</h4>
<p>反射允许程序在运行时动态获取类信息并操作对象。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 加载类</span>
Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">"com.example.UserService"</span>);

<span class="hljs-comment">// 检查注解</span>
<span class="hljs-keyword">if</span> (clazz.isAnnotationPresent(Component.class)) {
    <span class="hljs-type">Component</span> <span class="hljs-variable">component</span> <span class="hljs-operator">=</span> clazz.getAnnotation(Component.class);
    <span class="hljs-type">String</span> <span class="hljs-variable">beanName</span> <span class="hljs-operator">=</span> component.value();
}

<span class="hljs-comment">// 创建实例</span>
<span class="hljs-type">Object</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> clazz.getDeclaredConstructor().newInstance();

<span class="hljs-comment">// 获取字段</span>
Field[] fields = clazz.getDeclaredFields();

<span class="hljs-comment">// 设置字段值</span>
field.setAccessible(<span class="hljs-literal">true</span>);
field.set(instance, value);
</code></pre>
<hr/>
<h3 data-id="heading-8">3. 第一步：定义核心注解</h3>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5ddbd78b7e934e5182131b248e56cc9c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuo5Lit6aOY6I2h55qE6K6w5b-G:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768275935&amp;x-signature=ra%2BrLzOTjz6FwTJdqvPd3hTz0z4%3D" alt="" loading="lazy"/></p>
<p>首先定义我们自己的注解，模拟Spring的核心注解。</p>
<h4 data-id="heading-9">3.1 @Component注解</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.myspring.annotation;

<span class="hljs-keyword">import</span> java.lang.annotation.*;

<span class="hljs-comment">/**
 * 标记组件类，类似Spring的<span class="hljs-doctag">@Component</span>
 */</span>
<span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span>
<span class="hljs-meta">@Target(ElementType.TYPE)</span>
<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Component {
    <span class="hljs-comment">/**
     * Bean名称，默认为类名首字母小写
     */</span>
    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">""</span>;
}
</code></pre>
<h4 data-id="heading-10">3.2 @Autowired注解</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.myspring.annotation;

<span class="hljs-keyword">import</span> java.lang.annotation.*;

<span class="hljs-comment">/**
 * 自动注入依赖，类似Spring的<span class="hljs-doctag">@Autowired</span>
 */</span>
<span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span>
<span class="hljs-meta">@Target({ElementType.FIELD, ElementType.METHOD, ElementType.CONSTRUCTOR})</span>
<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Autowired {
    <span class="hljs-comment">/**
     * 是否必须注入
     */</span>
    <span class="hljs-type">boolean</span> <span class="hljs-title function_">required</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-literal">true</span>;
}
</code></pre>
<h4 data-id="heading-11">3.3 @Qualifier注解</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.myspring.annotation;

<span class="hljs-keyword">import</span> java.lang.annotation.*;

<span class="hljs-comment">/**
 * 指定要注入的Bean名称
 */</span>
<span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span>
<span class="hljs-meta">@Target({ElementType.FIELD, ElementType.PARAMETER})</span>
<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Qualifier {
    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span>;
}
</code></pre>
<h4 data-id="heading-12">3.4 @Scope注解</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.myspring.annotation;

<span class="hljs-keyword">import</span> java.lang.annotation.*;

<span class="hljs-comment">/**
 * 指定Bean的作用域
 */</span>
<span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span>
<span class="hljs-meta">@Target(ElementType.TYPE)</span>
<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Scope {
    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">"singleton"</span>;
}
</code></pre>
<hr/>
<h3 data-id="heading-13">4. 第二步：实现包扫描器</h3>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4af5705699904ec59afb178a2de40530~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuo5Lit6aOY6I2h55qE6K6w5b-G:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768275935&amp;x-signature=hGjQnrutKn0W7I6011yrjaXuUkg%3D" alt="" loading="lazy"/></p>
<p>包扫描器负责扫描指定包下的所有类，找出带有<code>@Component</code>注解的类。</p>
<h4 data-id="heading-14">4.1 ClassScanner类</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.myspring.core;

<span class="hljs-keyword">import</span> com.myspring.annotation.Component;
<span class="hljs-keyword">import</span> java.io.File;
<span class="hljs-keyword">import</span> java.net.URL;
<span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.List;

<span class="hljs-comment">/**
 * 类扫描器：扫描指定包下的所有类
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassScanner</span> {

    <span class="hljs-comment">/**
     * 扫描指定包下带有<span class="hljs-doctag">@Component</span>注解的类
     *
     * <span class="hljs-doctag">@param</span> basePackage 基础包路径，如"com.example"
     * <span class="hljs-doctag">@return</span> 带有<span class="hljs-doctag">@Component</span>注解的Class列表
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Class&lt;?&gt;&gt; scanComponents(String basePackage) {
        List&lt;Class&lt;?&gt;&gt; classList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();

        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 将包名转换为路径</span>
            <span class="hljs-type">String</span> <span class="hljs-variable">packagePath</span> <span class="hljs-operator">=</span> basePackage.replace(<span class="hljs-string">'.'</span>, <span class="hljs-string">'/'</span>);

            <span class="hljs-comment">// 获取包的URL路径</span>
            <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> Thread.currentThread().getContextClassLoader();
            <span class="hljs-type">URL</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> classLoader.getResource(packagePath);

            <span class="hljs-keyword">if</span> (resource == <span class="hljs-literal">null</span>) {
                System.out.println(<span class="hljs-string">"包路径不存在: "</span> + basePackage);
                <span class="hljs-keyword">return</span> classList;
            }

            <span class="hljs-comment">// 获取包的文件路径</span>
            <span class="hljs-type">File</span> <span class="hljs-variable">packageDir</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(resource.getFile());

            <span class="hljs-comment">// 递归扫描所有类文件</span>
            scanClasses(packageDir, basePackage, classList);

        } <span class="hljs-keyword">catch</span> (Exception e) {
            e.printStackTrace();
        }

        <span class="hljs-keyword">return</span> classList;
    }

    <span class="hljs-comment">/**
     * 递归扫描目录下的所有类文件
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">scanClasses</span><span class="hljs-params">(File dir, String packageName, List&lt;Class&lt;?&gt;&gt; classList)</span> {
        <span class="hljs-keyword">if</span> (!dir.exists() || !dir.isDirectory()) {
            <span class="hljs-keyword">return</span>;
        }

        File[] files = dir.listFiles();
        <span class="hljs-keyword">if</span> (files == <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">for</span> (File file : files) {
            <span class="hljs-keyword">if</span> (file.isDirectory()) {
                <span class="hljs-comment">// 递归扫描子目录</span>
                scanClasses(file, packageName + <span class="hljs-string">"."</span> + file.getName(), classList);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (file.getName().endsWith(<span class="hljs-string">".class"</span>)) {
                <span class="hljs-keyword">try</span> {
                    <span class="hljs-comment">// 获取类名</span>
                    <span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> packageName + <span class="hljs-string">"."</span> +
                        file.getName().replace(<span class="hljs-string">".class"</span>, <span class="hljs-string">""</span>);

                    <span class="hljs-comment">// 加载类</span>
                    Class&lt;?&gt; clazz = Class.forName(className);

                    <span class="hljs-comment">// 检查是否有@Component注解</span>
                    <span class="hljs-keyword">if</span> (clazz.isAnnotationPresent(Component.class)) {
                        classList.add(clazz);
                        System.out.println(<span class="hljs-string">"扫描到组件: "</span> + className);
                    }

                } <span class="hljs-keyword">catch</span> (ClassNotFoundException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
</code></pre>
<hr/>
<h3 data-id="heading-15">5. 第三步：创建Bean工厂</h3>
<p>Bean工厂负责存储和管理所有的Bean实例。</p>
<h4 data-id="heading-16">5.1 BeanDefinition类</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.myspring.core;

<span class="hljs-comment">/**
 * Bean定义信息
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BeanDefinition</span> {
    <span class="hljs-keyword">private</span> String beanName;
    <span class="hljs-keyword">private</span> Class&lt;?&gt; beanClass;
    <span class="hljs-keyword">private</span> String scope;
    <span class="hljs-keyword">private</span> Object singletonInstance;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BeanDefinition</span><span class="hljs-params">(String beanName, Class&lt;?&gt; beanClass, String scope)</span> {
        <span class="hljs-built_in">this</span>.beanName = beanName;
        <span class="hljs-built_in">this</span>.beanClass = beanClass;
        <span class="hljs-built_in">this</span>.scope = scope;
    }

    <span class="hljs-comment">// Getter和Setter方法</span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getBeanName</span><span class="hljs-params">()</span> { <span class="hljs-keyword">return</span> beanName; }
    <span class="hljs-keyword">public</span> Class&lt;?&gt; getBeanClass() { <span class="hljs-keyword">return</span> beanClass; }
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getScope</span><span class="hljs-params">()</span> { <span class="hljs-keyword">return</span> scope; }
    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getSingletonInstance</span><span class="hljs-params">()</span> { <span class="hljs-keyword">return</span> singletonInstance; }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSingletonInstance</span><span class="hljs-params">(Object instance)</span> {
        <span class="hljs-built_in">this</span>.singletonInstance = instance;
    }
}
</code></pre>
<h4 data-id="heading-17">5.2 BeanFactory类</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.myspring.core;

<span class="hljs-keyword">import</span> com.myspring.annotation.Component;
<span class="hljs-keyword">import</span> com.myspring.annotation.Scope;
<span class="hljs-keyword">import</span> java.util.Map;
<span class="hljs-keyword">import</span> java.util.concurrent.ConcurrentHashMap;

<span class="hljs-comment">/**
 * Bean工厂：创建和管理Bean实例
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BeanFactory</span> {

    <span class="hljs-comment">// 存储Bean定义信息</span>
    <span class="hljs-keyword">private</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();

    <span class="hljs-comment">/**
     * 注册Bean定义
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerBeanDefinition</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span> {
        <span class="hljs-comment">// 获取Bean名称</span>
        <span class="hljs-type">Component</span> <span class="hljs-variable">component</span> <span class="hljs-operator">=</span> clazz.getAnnotation(Component.class);
        <span class="hljs-type">String</span> <span class="hljs-variable">beanName</span> <span class="hljs-operator">=</span> component.value();
        <span class="hljs-keyword">if</span> (beanName.isEmpty()) {
            <span class="hljs-comment">// 默认使用类名首字母小写</span>
            beanName = toLowerFirstCase(clazz.getSimpleName());
        }

        <span class="hljs-comment">// 获取作用域</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">scope</span> <span class="hljs-operator">=</span> <span class="hljs-string">"singleton"</span>;
        <span class="hljs-keyword">if</span> (clazz.isAnnotationPresent(Scope.class)) {
            <span class="hljs-type">Scope</span> <span class="hljs-variable">scopeAnnotation</span> <span class="hljs-operator">=</span> clazz.getAnnotation(Scope.class);
            scope = scopeAnnotation.value();
        }

        <span class="hljs-comment">// 创建BeanDefinition并注册</span>
        <span class="hljs-type">BeanDefinition</span> <span class="hljs-variable">beanDefinition</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanDefinition</span>(beanName, clazz, scope);
        beanDefinitionMap.put(beanName, beanDefinition);

        System.out.println(<span class="hljs-string">"注册Bean: "</span> + beanName + <span class="hljs-string">", 作用域: "</span> + scope);
    }

    <span class="hljs-comment">/**
     * 获取Bean实例
     */</span>
    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getBean</span><span class="hljs-params">(String beanName)</span> {
        <span class="hljs-type">BeanDefinition</span> <span class="hljs-variable">beanDefinition</span> <span class="hljs-operator">=</span> beanDefinitionMap.get(beanName);
        <span class="hljs-keyword">if</span> (beanDefinition == <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">"Bean不存在: "</span> + beanName);
        }

        <span class="hljs-comment">// 单例模式</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-string">"singleton"</span>.equals(beanDefinition.getScope())) {
            <span class="hljs-type">Object</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> beanDefinition.getSingletonInstance();
            <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) {
                instance = createBean(beanDefinition);
                beanDefinition.setSingletonInstance(instance);
            }
            <span class="hljs-keyword">return</span> instance;
        }

        <span class="hljs-comment">// 原型模式：每次都创建新实例</span>
        <span class="hljs-keyword">return</span> createBean(beanDefinition);
    }

    <span class="hljs-comment">/**
     * 根据类型获取Bean
     */</span>
    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getBean</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span> {
        <span class="hljs-keyword">for</span> (BeanDefinition bd : beanDefinitionMap.values()) {
            <span class="hljs-keyword">if</span> (clazz.isAssignableFrom(bd.getBeanClass())) {
                <span class="hljs-keyword">return</span> getBean(bd.getBeanName());
            }
        }
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">"Bean不存在: "</span> + clazz.getName());
    }

    <span class="hljs-comment">/**
     * 创建Bean实例
     */</span>
    <span class="hljs-keyword">private</span> Object <span class="hljs-title function_">createBean</span><span class="hljs-params">(BeanDefinition beanDefinition)</span> {
        <span class="hljs-keyword">try</span> {
            Class&lt;?&gt; clazz = beanDefinition.getBeanClass();
            <span class="hljs-type">Object</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> clazz.getDeclaredConstructor().newInstance();
            System.out.println(<span class="hljs-string">"创建Bean实例: "</span> + beanDefinition.getBeanName());
            <span class="hljs-keyword">return</span> instance;
        } <span class="hljs-keyword">catch</span> (Exception e) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">"创建Bean失败: "</span> +
                beanDefinition.getBeanName(), e);
        }
    }

    <span class="hljs-comment">/**
     * 首字母小写
     */</span>
    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">toLowerFirstCase</span><span class="hljs-params">(String str)</span> {
        <span class="hljs-type">char</span>[] chars = str.toCharArray();
        chars[<span class="hljs-number">0</span>] += <span class="hljs-number">32</span>;
        <span class="hljs-keyword">return</span> String.valueOf(chars);
    }

    <span class="hljs-comment">/**
     * 获取所有Bean名称
     */</span>
    <span class="hljs-keyword">public</span> Map&lt;String, BeanDefinition&gt; <span class="hljs-title function_">getBeanDefinitions</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> beanDefinitionMap;
    }
}
</code></pre>
<hr/>
<h3 data-id="heading-18">6. 第四步：实现依赖注入</h3>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/95a946239e474c49afa084fedc306c28~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuo5Lit6aOY6I2h55qE6K6w5b-G:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768275935&amp;x-signature=DVcfiJ9%2B0hiocLdWCI52ymbIc6o%3D" alt="" loading="lazy"/></p>
<p>依赖注入是IoC容器的核心功能，通过反射自动为Bean注入依赖。</p>
<h4 data-id="heading-19">6.1 DependencyInjector类</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.myspring.core;

<span class="hljs-keyword">import</span> com.myspring.annotation.Autowired;
<span class="hljs-keyword">import</span> com.myspring.annotation.Qualifier;
<span class="hljs-keyword">import</span> java.lang.reflect.Field;

<span class="hljs-comment">/**
 * 依赖注入器：为Bean注入依赖
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DependencyInjector</span> {

    <span class="hljs-keyword">private</span> BeanFactory beanFactory;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DependencyInjector</span><span class="hljs-params">(BeanFactory beanFactory)</span> {
        <span class="hljs-built_in">this</span>.beanFactory = beanFactory;
    }

    <span class="hljs-comment">/**
     * 为所有Bean执行依赖注入
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">injectDependencies</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">for</span> (BeanDefinition bd : beanFactory.getBeanDefinitions().values()) {
            <span class="hljs-type">Object</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> beanFactory.getBean(bd.getBeanName());
            injectBean(bean);
        }
    }

    <span class="hljs-comment">/**
     * 为单个Bean注入依赖
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">injectBean</span><span class="hljs-params">(Object bean)</span> {
        Class&lt;?&gt; clazz = bean.getClass();

        <span class="hljs-comment">// 获取所有字段</span>
        Field[] fields = clazz.getDeclaredFields();

        <span class="hljs-keyword">for</span> (Field field : fields) {
            <span class="hljs-comment">// 检查是否有@Autowired注解</span>
            <span class="hljs-keyword">if</span> (!field.isAnnotationPresent(Autowired.class)) {
                <span class="hljs-keyword">continue</span>;
            }

            <span class="hljs-type">Autowired</span> <span class="hljs-variable">autowired</span> <span class="hljs-operator">=</span> field.getAnnotation(Autowired.class);

            <span class="hljs-keyword">try</span> {
                <span class="hljs-comment">// 确定要注入的Bean</span>
                <span class="hljs-type">Object</span> <span class="hljs-variable">dependency</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;

                <span class="hljs-comment">// 检查是否有@Qualifier指定Bean名称</span>
                <span class="hljs-keyword">if</span> (field.isAnnotationPresent(Qualifier.class)) {
                    <span class="hljs-type">Qualifier</span> <span class="hljs-variable">qualifier</span> <span class="hljs-operator">=</span> field.getAnnotation(Qualifier.class);
                    <span class="hljs-type">String</span> <span class="hljs-variable">beanName</span> <span class="hljs-operator">=</span> qualifier.value();
                    dependency = beanFactory.getBean(beanName);
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-comment">// 根据类型查找Bean</span>
                    dependency = beanFactory.getBean(field.getType());
                }

                <span class="hljs-comment">// 反射设置字段值</span>
                field.setAccessible(<span class="hljs-literal">true</span>);
                field.set(bean, dependency);

                System.out.println(<span class="hljs-string">"注入依赖: "</span> + clazz.getSimpleName() +
                    <span class="hljs-string">"."</span> + field.getName());

            } <span class="hljs-keyword">catch</span> (Exception e) {
                <span class="hljs-keyword">if</span> (autowired.required()) {
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">"依赖注入失败: "</span> +
                        clazz.getSimpleName() + <span class="hljs-string">"."</span> + field.getName(), e);
                }
            }
        }
    }
}
</code></pre>
<hr/>
<h3 data-id="heading-20">7. 第五步：完善生命周期</h3>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1b1c98c1e6b1400dab18685675fd8503~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuo5Lit6aOY6I2h55qE6K6w5b-G:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768275935&amp;x-signature=o%2BpKs8o%2Fd4yWCSXFgxEllUuttSg%3D" alt="" loading="lazy"/></p>
<h4 data-id="heading-21">7.1 生命周期注解</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.myspring.annotation;

<span class="hljs-keyword">import</span> java.lang.annotation.*;

<span class="hljs-comment">/**
 * Bean初始化后调用
 */</span>
<span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span>
<span class="hljs-meta">@Target(ElementType.METHOD)</span>
<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> PostConstruct {
}
</code></pre>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.myspring.annotation;

<span class="hljs-keyword">import</span> java.lang.annotation.*;

<span class="hljs-comment">/**
 * Bean销毁前调用
 */</span>
<span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span>
<span class="hljs-meta">@Target(ElementType.METHOD)</span>
<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> PreDestroy {
}
</code></pre>
<h4 data-id="heading-22">7.2 生命周期管理器</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.myspring.core;

<span class="hljs-keyword">import</span> com.myspring.annotation.PostConstruct;
<span class="hljs-keyword">import</span> com.myspring.annotation.PreDestroy;
<span class="hljs-keyword">import</span> java.lang.reflect.Method;

<span class="hljs-comment">/**
 * Bean生命周期管理器
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LifecycleManager</span> {

    <span class="hljs-comment">/**
     * 执行初始化方法
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">invokeInitMethod</span><span class="hljs-params">(Object bean)</span> {
        Class&lt;?&gt; clazz = bean.getClass();
        Method[] methods = clazz.getDeclaredMethods();

        <span class="hljs-keyword">for</span> (Method method : methods) {
            <span class="hljs-keyword">if</span> (method.isAnnotationPresent(PostConstruct.class)) {
                <span class="hljs-keyword">try</span> {
                    method.setAccessible(<span class="hljs-literal">true</span>);
                    method.invoke(bean);
                    System.out.println(<span class="hljs-string">"执行初始化方法: "</span> +
                        clazz.getSimpleName() + <span class="hljs-string">"."</span> + method.getName());
                } <span class="hljs-keyword">catch</span> (Exception e) {
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">"初始化方法执行失败"</span>, e);
                }
            }
        }
    }

    <span class="hljs-comment">/**
     * 执行销毁方法
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">invokeDestroyMethod</span><span class="hljs-params">(Object bean)</span> {
        Class&lt;?&gt; clazz = bean.getClass();
        Method[] methods = clazz.getDeclaredMethods();

        <span class="hljs-keyword">for</span> (Method method : methods) {
            <span class="hljs-keyword">if</span> (method.isAnnotationPresent(PreDestroy.class)) {
                <span class="hljs-keyword">try</span> {
                    method.setAccessible(<span class="hljs-literal">true</span>);
                    method.invoke(bean);
                    System.out.println(<span class="hljs-string">"执行销毁方法: "</span> +
                        clazz.getSimpleName() + <span class="hljs-string">"."</span> + method.getName());
                } <span class="hljs-keyword">catch</span> (Exception e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
</code></pre>
<hr/>
<h3 data-id="heading-23">8. 完整示例：使用手写IoC</h3>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7225b7399aa845969344a1bd35e85acc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuo5Lit6aOY6I2h55qE6K6w5b-G:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768275935&amp;x-signature=9f5E7fmFFl60d8nQ0ZgahrLKiw8%3D" alt="" loading="lazy"/></p>
<h4 data-id="heading-24">8.1 创建ApplicationContext</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.myspring.core;

<span class="hljs-keyword">import</span> java.util.List;

<span class="hljs-comment">/**
 * 应用上下文：整合所有功能
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApplicationContext</span> {

    <span class="hljs-keyword">private</span> BeanFactory beanFactory;
    <span class="hljs-keyword">private</span> DependencyInjector injector;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ApplicationContext</span><span class="hljs-params">(String basePackage)</span> {
        <span class="hljs-comment">// 1. 创建Bean工厂</span>
        beanFactory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanFactory</span>();

        <span class="hljs-comment">// 2. 扫描组件</span>
        System.out.println(<span class="hljs-string">"========== 开始扫描组件 =========="</span>);
        List&lt;Class&lt;?&gt;&gt; componentClasses = ClassScanner.scanComponents(basePackage);

        <span class="hljs-comment">// 3. 注册Bean定义</span>
        System.out.println(<span class="hljs-string">"\n========== 注册Bean定义 =========="</span>);
        <span class="hljs-keyword">for</span> (Class&lt;?&gt; clazz : componentClasses) {
            beanFactory.registerBeanDefinition(clazz);
        }

        <span class="hljs-comment">// 4. 实例化所有单例Bean</span>
        System.out.println(<span class="hljs-string">"\n========== 实例化单例Bean =========="</span>);
        <span class="hljs-keyword">for</span> (BeanDefinition bd : beanFactory.getBeanDefinitions().values()) {
            <span class="hljs-keyword">if</span> (<span class="hljs-string">"singleton"</span>.equals(bd.getScope())) {
                beanFactory.getBean(bd.getBeanName());
            }
        }

        <span class="hljs-comment">// 5. 依赖注入</span>
        System.out.println(<span class="hljs-string">"\n========== 执行依赖注入 =========="</span>);
        injector = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DependencyInjector</span>(beanFactory);
        injector.injectDependencies();

        <span class="hljs-comment">// 6. 执行初始化方法</span>
        System.out.println(<span class="hljs-string">"\n========== 执行初始化方法 =========="</span>);
        <span class="hljs-keyword">for</span> (BeanDefinition bd : beanFactory.getBeanDefinitions().values()) {
            <span class="hljs-type">Object</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> beanFactory.getBean(bd.getBeanName());
            LifecycleManager.invokeInitMethod(bean);
        }

        System.out.println(<span class="hljs-string">"\n========== IoC容器启动完成 ==========\n"</span>);
    }

    <span class="hljs-comment">/**
     * 获取Bean
     */</span>
    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getBean</span><span class="hljs-params">(String beanName)</span> {
        <span class="hljs-keyword">return</span> beanFactory.getBean(beanName);
    }

    <span class="hljs-comment">/**
     * 根据类型获取Bean
     */</span>
    <span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">getBean</span><span class="hljs-params">(Class&lt;T&gt; clazz)</span> {
        <span class="hljs-keyword">return</span> (T) beanFactory.getBean(clazz);
    }

    <span class="hljs-comment">/**
     * 关闭容器
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> {
        System.out.println(<span class="hljs-string">"\n========== 关闭IoC容器 =========="</span>);
        <span class="hljs-keyword">for</span> (BeanDefinition bd : beanFactory.getBeanDefinitions().values()) {
            <span class="hljs-type">Object</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> beanFactory.getBean(bd.getBeanName());
            LifecycleManager.invokeDestroyMethod(bean);
        }
    }
}
</code></pre>
<h4 data-id="heading-25">8.2 编写测试类</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.example.dao;

<span class="hljs-keyword">import</span> com.myspring.annotation.Component;

<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserDao</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">()</span> {
        System.out.println(<span class="hljs-string">"UserDao: 保存用户数据"</span>);
    }
}
</code></pre>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.example.service;

<span class="hljs-keyword">import</span> com.example.dao.UserDao;
<span class="hljs-keyword">import</span> com.myspring.annotation.Autowired;
<span class="hljs-keyword">import</span> com.myspring.annotation.Component;
<span class="hljs-keyword">import</span> com.myspring.annotation.PostConstruct;
<span class="hljs-keyword">import</span> com.myspring.annotation.PreDestroy;

<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> {

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> UserDao userDao;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">(String username)</span> {
        System.out.println(<span class="hljs-string">"UserService: 注册用户 "</span> + username);
        userDao.save();
    }

    <span class="hljs-meta">@PostConstruct</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> {
        System.out.println(<span class="hljs-string">"UserService初始化完成"</span>);
    }

    <span class="hljs-meta">@PreDestroy</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> {
        System.out.println(<span class="hljs-string">"UserService准备销毁"</span>);
    }
}
</code></pre>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.example;

<span class="hljs-keyword">import</span> com.example.service.UserService;
<span class="hljs-keyword">import</span> com.myspring.core.ApplicationContext;

<span class="hljs-comment">/**
 * 测试类
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">// 创建IoC容器</span>
        <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApplicationContext</span>(<span class="hljs-string">"com.example"</span>);

        <span class="hljs-comment">// 获取Bean并使用</span>
        <span class="hljs-type">UserService</span> <span class="hljs-variable">userService</span> <span class="hljs-operator">=</span> context.getBean(UserService.class);
        userService.register(<span class="hljs-string">"张三"</span>);

        <span class="hljs-comment">// 关闭容器</span>
        context.close();
    }
}
</code></pre>
<h4 data-id="heading-26">8.3 运行输出</h4>
<pre><code class="hljs language-makefile" lang="makefile">========== 开始扫描组件 ==========
<span class="hljs-section">扫描到组件: com.example.dao.UserDao</span>
<span class="hljs-section">扫描到组件: com.example.service.UserService</span>

========== 注册Bean定义 ==========
<span class="hljs-section">注册Bean: userDao, 作用域: singleton</span>
<span class="hljs-section">注册Bean: userService, 作用域: singleton</span>

========== 实例化单例Bean ==========
<span class="hljs-section">创建Bean实例: userDao</span>
<span class="hljs-section">创建Bean实例: userService</span>

========== 执行依赖注入 ==========
<span class="hljs-section">注入依赖: UserService.userDao</span>

========== 执行初始化方法 ==========
<span class="hljs-section">执行初始化方法: UserService.init</span>
UserService初始化完成

========== IoC容器启动完成 ==========

<span class="hljs-section">UserService: 注册用户 张三</span>
<span class="hljs-section">UserDao: 保存用户数据</span>

========== 关闭IoC容器 ==========
<span class="hljs-section">执行销毁方法: UserService.destroy</span>
UserService准备销毁
</code></pre>
<hr/>
<h3 data-id="heading-27">9. 总结</h3>
<h4 data-id="heading-28">9.1 核心要点</h4>
<p>通过手写IoC容器，我们深入理解了：</p>
<ol>
<li><strong>注解机制</strong> - 使用<code>@Retention</code>、<code>@Target</code>定义注解</li>
<li><strong>反射技术</strong> - 类加载、实例创建、字段注入</li>
<li><strong>扫描解析</strong> - 递归扫描包路径，解析注解信息</li>
<li><strong>Bean管理</strong> - 单例/原型模式，Bean定义存储</li>
<li><strong>依赖注入</strong> - 自动查找和注入依赖对象</li>
<li><strong>生命周期</strong> - 初始化和销毁回调方法</li>
</ol>
<h4 data-id="heading-29">9.2 与Spring IoC的对比</h4>








































<table><thead><tr><th>功能</th><th>手写版本</th><th>Spring IoC</th></tr></thead><tbody><tr><td>注解扫描</td><td>简单递归</td><td>高性能ASM字节码扫描</td></tr><tr><td>Bean管理</td><td>Map存储</td><td>多级缓存+循环依赖处理</td></tr><tr><td>依赖注入</td><td>字段注入</td><td>字段+构造器+Setter</td></tr><tr><td>作用域</td><td>singleton/prototype</td><td>更多作用域</td></tr><tr><td>AOP支持</td><td>无</td><td>完整AOP框架</td></tr><tr><td>性能优化</td><td>基础</td><td>大量优化策略</td></tr></tbody></table></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Vue3 defineModel 完全指南：从基础使用到进阶技巧]]></title>    <link>https://juejin.cn/post/7591697558377938986</link>    <guid>https://juejin.cn/post/7591697558377938986</guid>    <pubDate>2026-01-06T02:42:30.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7591697558377938986" data-draft-id="7591972586360717331" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Vue3 defineModel 完全指南：从基础使用到进阶技巧"/> <meta itemprop="keywords" content="前端,Vue.js,面试"/> <meta itemprop="datePublished" content="2026-01-06T02:42:30.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="不想秃头的程序员"/> <meta itemprop="url" content="https://juejin.cn/user/2754702534251820"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Vue3 defineModel 完全指南：从基础使用到进阶技巧
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2754702534251820/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    不想秃头的程序员
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-06T02:42:30.000Z" title="Tue Jan 06 2026 02:42:30 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-06
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在 Vue3 组合式 API 中，组件间数据传递是核心需求之一。对于父子组件的双向绑定，Vue2 时代我们习惯用<code>v-model</code> 配合 <code>value</code> 属性和 <code>input</code> 事件，而 Vue3 最初引入了 <code>setup</code> 函数后，需要通过 <code>props</code> 接收值并手动触发事件来实现双向绑定。直到 Vue3.4 版本，官方正式推出了 <code>defineModel</code> 宏，彻底简化了父子组件双向绑定的实现逻辑。</p>
<p>本文将从 <code>defineModel</code> 的核心作用出发，逐步讲解其基础使用、进阶配置、常见场景及注意事项，帮助你快速掌握这一高效的 API。</p>
<h2 data-id="heading-0">一、为什么需要 defineModel？</h2>
<p>在 <code>defineModel</code> 出现之前，实现父子组件双向绑定需要两步操作：</p>
<ol>
<li>子组件通过 <code>props</code> 接收父组件传递的值；</li>
<li>子组件通过 <code>emit</code> 触发事件，将修改后的值传递回父组件。</li>
</ol>
<p>示例代码如下：</p>
<pre><code class="hljs language-js" lang="js">&lt;!-- 子组件 <span class="hljs-title class_">Child</span>.<span class="hljs-property">vue</span> --&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">const</span> props = <span class="hljs-title function_">defineProps</span>([<span class="hljs-string">'modelValue'</span>])
<span class="hljs-keyword">const</span> emit = <span class="hljs-title function_">defineEmits</span>([<span class="hljs-string">'update:modelValue'</span>])

<span class="hljs-keyword">const</span> <span class="hljs-title function_">handleChange</span> = (<span class="hljs-params">e</span>) =&gt; {
  <span class="hljs-title function_">emit</span>(<span class="hljs-string">'update:modelValue'</span>, e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>)
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>

<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">:value</span>=<span class="hljs-string">"props.modelValue"</span> @<span class="hljs-attr">input</span>=<span class="hljs-string">"handleChange"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span>
</code></pre>
<pre><code class="hljs language-js" lang="js">&lt;!-- 父组件 <span class="hljs-title class_">Parent</span>.<span class="hljs-property">vue</span> --&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">import</span> { ref } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./Child.vue'</span>

<span class="hljs-keyword">const</span> inputValue = <span class="hljs-title function_">ref</span>(<span class="hljs-string">''</span>)
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>

<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"inputValue"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span>
</code></pre>
<p>这种方式虽然可行，但存在明显弊端：代码冗余，每次实现双向绑定都需要重复定义 <code>props</code> 和 <code>emit</code>。而 <code>defineModel</code> 正是为了解决这个问题，它将 <code>props</code> 和 <code>emit</code> 的逻辑封装在一起，让双向绑定的实现更简洁、更直观。</p>
<h2 data-id="heading-1">二、defineModel 基础使用</h2>
<h3 data-id="heading-2">2.1 基本语法</h3>
<p><code>defineModel</code> 是 Vue3.4+ 提供的内置宏，无需导入即可直接使用。其基本语法如下：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> model = <span class="hljs-title function_">defineModel</span>();
</code></pre>
<p>通过上述代码，子组件即可直接获取到父组件通过 <code>v-model</code> 传递的值，且 <code>model</code> 是一个响应式对象，修改它会自动同步到父组件。</p>
<h3 data-id="heading-3">2.2 简化双向绑定示例</h3>
<p>用 <code>defineModel</code> 重写上面的父子组件双向绑定示例：</p>
<pre><code class="hljs language-js" lang="js">&lt;!-- 子组件 <span class="hljs-title class_">Child</span>.<span class="hljs-property">vue</span> --&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-comment">// 直接使用 defineModel 获取响应式模型</span>
<span class="hljs-keyword">const</span> modelValue = <span class="hljs-title function_">defineModel</span>()
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>

<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-comment">&lt;!-- 直接绑定 modelValue，修改时自动同步到父组件 --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"modelValue"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span>
</code></pre>
<pre><code class="hljs language-js" lang="js">&lt;!-- 父组件 <span class="hljs-title class_">Parent</span>.<span class="hljs-property">vue</span> --&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">import</span> { ref } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./Child.vue'</span>

<span class="hljs-keyword">const</span> inputValue = <span class="hljs-title function_">ref</span>(<span class="hljs-string">''</span>)
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>

<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"inputValue"</span> /&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>父组件值：{{ inputValue }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span>
</code></pre>
<p>可以看到，子组件的代码被大幅简化，无需再手动定义 <code>props</code> 和 <code>emit</code>，直接通过 <code>defineModel</code> 即可实现双向绑定。</p>
<h3 data-id="heading-4">2.3 自定义 v-model 名称</h3>
<p>默认情况下，<code>defineModel</code> 对应父组件 <code>v-model</code> 的 <code>modelValue</code> 属性和 <code>update:modelValue</code> 事件。如果需要自定义 <code>v-model</code> 的名称（即多 <code>v-model</code> 场景），可以给 <code>defineModel</code> 传递一个参数作为名称：</p>
<pre><code class="hljs language-js" lang="js">&lt;!-- 子组件 <span class="hljs-title class_">Child</span>.<span class="hljs-property">vue</span> --&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-comment">// 自定义 v-model 名称为 "username"</span>
<span class="hljs-keyword">const</span> username = <span class="hljs-title function_">defineModel</span>(<span class="hljs-string">'username'</span>)
<span class="hljs-comment">// 再定义一个 v-model 名称为 "password"</span>
<span class="hljs-keyword">const</span> password = <span class="hljs-title function_">defineModel</span>(<span class="hljs-string">'password'</span>)
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>

<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"请输入用户名"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"请输入密码"</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span>
</code></pre>
<pre><code class="hljs language-js" lang="js">&lt;!-- 父组件 <span class="hljs-title class_">Parent</span>.<span class="hljs-property">vue</span> --&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">import</span> { ref } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./Child.vue'</span>

<span class="hljs-keyword">const</span> user = <span class="hljs-title function_">ref</span>(<span class="hljs-string">''</span>)
<span class="hljs-keyword">const</span> pwd = <span class="hljs-title function_">ref</span>(<span class="hljs-string">''</span>)
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>

<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">Child</span> 
    <span class="hljs-attr">v-model:username</span>=<span class="hljs-string">"user"</span> 
    <span class="hljs-attr">v-model:password</span>=<span class="hljs-string">"pwd"</span> 
  /&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>用户名：{{ user }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>密码：{{ pwd }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span>
</code></pre>
<p>通过这种方式，我们可以轻松实现一个组件支持多个 <code>v-model</code> 绑定，满足复杂场景的需求。</p>
<h2 data-id="heading-5">三、defineModel 进阶配置</h2>
<p><code>defineModel</code> 还支持传入一个配置对象，用于设置默认值、类型校验、是否可写等属性，进一步增强组件的健壮性。</p>
<h3 data-id="heading-6">3.1 设置默认值</h3>
<p>通过配置对象的 <code>default</code> 属性可以设置 <code>v-model</code> 的默认值：</p>
<pre><code class="hljs language-js" lang="js">&lt;!-- 子组件 <span class="hljs-title class_">Child</span>.<span class="hljs-property">vue</span> --&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-comment">// 设置默认值为 "默认用户名"</span>
<span class="hljs-keyword">const</span> username = <span class="hljs-title function_">defineModel</span>(<span class="hljs-string">'username'</span>, {
  <span class="hljs-attr">default</span>: <span class="hljs-string">'默认用户名'</span>
})
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>

<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"请输入用户名"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span>
</code></pre>
<p>此时，若父组件未给 <code>v-model:username</code> 传递值，子组件的 <code>username</code> 会默认使用 "默认用户名"。</p>
<h3 data-id="heading-7">3.2 类型校验</h3>
<p>通过 <code>type</code> 属性可以对 <code>v-model</code>传递的值进行类型校验，支持单个类型或多个类型数组：</p>
<pre><code class="hljs language-js" lang="js">&lt;!-- 子组件 <span class="hljs-title class_">Child</span>.<span class="hljs-property">vue</span> --&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-comment">// 限制 username 必须为字符串类型</span>
<span class="hljs-keyword">const</span> username = <span class="hljs-title function_">defineModel</span>(<span class="hljs-string">'username'</span>, {
  <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,
  <span class="hljs-attr">default</span>: <span class="hljs-string">''</span>
})

<span class="hljs-comment">// 限制 count 可以为 Number 或 String 类型</span>
<span class="hljs-keyword">const</span> count = <span class="hljs-title function_">defineModel</span>(<span class="hljs-string">'count'</span>, {
  <span class="hljs-attr">type</span>: [<span class="hljs-title class_">Number</span>, <span class="hljs-title class_">String</span>],
  <span class="hljs-attr">default</span>: <span class="hljs-number">0</span>
})
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>

<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"请输入用户名"</span> /&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"count++"</span>&gt;</span>计数：{{ count }}<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span>
</code></pre>
<p>若父组件传递的值类型不匹配，Vue 会在控制台给出警告，帮助我们提前发现问题。</p>
<h3 data-id="heading-8">3.3 控制是否可写</h3>
<p>通过 <code>settable</code> 属性可以控制子组件是否能直接修改 <code>defineModel</code> 返回的响应式对象。默认情况下 <code>settable: true</code>，子组件可以直接修改；若设置为 <code>false</code>，子组件修改时会报错，只能通过父组件修改后同步过来。</p>
<pre><code class="hljs language-js" lang="js">&lt;!-- 子组件 <span class="hljs-title class_">Child</span>.<span class="hljs-property">vue</span> --&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-comment">// 设置 settable: false，子组件不能直接修改</span>
<span class="hljs-keyword">const</span> username = <span class="hljs-title function_">defineModel</span>(<span class="hljs-string">'username'</span>, {
  <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,
  <span class="hljs-attr">default</span>: <span class="hljs-string">''</span>,
  <span class="hljs-attr">settable</span>: <span class="hljs-literal">false</span>
})

<span class="hljs-keyword">const</span> <span class="hljs-title function_">handleChange</span> = (<span class="hljs-params">e</span>) =&gt; {
  <span class="hljs-comment">// 报错：Cannot assign to 'username' because it's a read-only proxy</span>
  username.<span class="hljs-property">value</span> = e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>

<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">:value</span>=<span class="hljs-string">"username"</span> @<span class="hljs-attr">input</span>=<span class="hljs-string">"handleChange"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span>
</code></pre>
<p>这种配置适合需要严格控制数据流向的场景，确保数据只能由父组件修改。</p>
<h3 data-id="heading-9">3.4 转换值（getter/setter）</h3>
<p>通过 <code>get</code> 和 <code>set</code> 方法可以对传递的值进行转换处理，类似计算属性的逻辑。例如，我们可以实现一个自动去除空格的输入框：</p>
<pre><code class="hljs language-js" lang="js">&lt;!-- 子组件 <span class="hljs-title class_">Child</span>.<span class="hljs-property">vue</span> --&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">const</span> username = <span class="hljs-title function_">defineModel</span>(<span class="hljs-string">'username'</span>, {
  <span class="hljs-attr">get</span>: <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> {
    <span class="hljs-comment">// 父组件传递的值到子组件时，自动去除前后空格</span>
    <span class="hljs-keyword">return</span> value?.<span class="hljs-title function_">trim</span>() || <span class="hljs-string">''</span>
  },
  <span class="hljs-attr">set</span>: <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> {
    <span class="hljs-comment">// 子组件修改后的值传递给父组件时，再次去除空格</span>
    <span class="hljs-keyword">return</span> value.<span class="hljs-title function_">trim</span>()
  },
  <span class="hljs-attr">default</span>: <span class="hljs-string">''</span>
})
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>

<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"请输入用户名"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span>
</code></pre>
<p>通过 <code>get</code> 和 <code>set</code>，我们可以在数据传递的过程中对其进行加工，让组件的逻辑更灵活。</p>
<h2 data-id="heading-10">四、常见使用场景</h2>
<h3 data-id="heading-11">4.1 表单组件封装</h3>
<p>封装表单组件是 <code>defineModel</code> 最常用的场景之一。例如，封装一个自定义输入框组件，支持双向绑定、类型校验、默认值等功能：</p>
<pre><code class="hljs language-js" lang="js">&lt;!-- 自定义输入框组件 <span class="hljs-title class_">CustomInput</span>.<span class="hljs-property">vue</span> --&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">const</span> props = <span class="hljs-title function_">defineProps</span>({
  <span class="hljs-attr">label</span>: {
    <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,
    <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>
  }
})

<span class="hljs-keyword">const</span> modelValue = <span class="hljs-title function_">defineModel</span>({
  <span class="hljs-attr">type</span>: [<span class="hljs-title class_">String</span>, <span class="hljs-title class_">Number</span>],
  <span class="hljs-attr">default</span>: <span class="hljs-string">''</span>,
  <span class="hljs-attr">get</span>: <span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> val || <span class="hljs-string">''</span>,
  <span class="hljs-attr">set</span>: <span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> val.<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">trim</span>()
})
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>

<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"custom-input"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>{{ label }}：<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"modelValue"</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span>
</code></pre>
<pre><code class="hljs language-js" lang="js">&lt;!-- 父组件使用 --&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">import</span> { ref } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">CustomInput</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./CustomInput.vue'</span>

<span class="hljs-keyword">const</span> name = <span class="hljs-title function_">ref</span>(<span class="hljs-string">''</span>)
<span class="hljs-keyword">const</span> age = <span class="hljs-title function_">ref</span>(<span class="hljs-number">18</span>)
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>

<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">CustomInput</span> <span class="hljs-attr">label</span>=<span class="hljs-string">"姓名"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"name"</span> /&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">CustomInput</span> <span class="hljs-attr">label</span>=<span class="hljs-string">"年龄"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"age"</span> /&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>姓名：{{ name }}，年龄：{{ age }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span>
</code></pre>
<h3 data-id="heading-12">4.2 开关、滑块等UI组件</h3>
<p>对于开关（Switch）、滑块（Slider）等需要双向绑定状态的UI组件，<code>defineModel</code> 也能极大简化代码。以开关组件为例：</p>
<pre><code class="hljs language-js" lang="js">&lt;!-- 开关组件 <span class="hljs-title class_">Switch</span>.<span class="hljs-property">vue</span> --&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">const</span> modelValue = <span class="hljs-title function_">defineModel</span>({
  <span class="hljs-attr">type</span>: <span class="hljs-title class_">Boolean</span>,
  <span class="hljs-attr">default</span>: <span class="hljs-literal">false</span>
})

<span class="hljs-keyword">const</span> <span class="hljs-title function_">toggle</span> = (<span class="hljs-params"/>) =&gt; {
  modelValue.<span class="hljs-property">value</span> = !modelValue.<span class="hljs-property">value</span>
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>

<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> 
    <span class="hljs-attr">class</span>=<span class="hljs-string">"switch"</span> 
    <span class="hljs-attr">:class</span>=<span class="hljs-string">"{ active: modelValue }"</span> 
    @<span class="hljs-attr">click</span>=<span class="hljs-string">"toggle"</span>
  &gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"switch-button"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span>

<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="css">
<span class="hljs-selector-class">.switch</span> {
  <span class="hljs-attribute">width</span>: <span class="hljs-number">60px</span>;
  <span class="hljs-attribute">height</span>: <span class="hljs-number">30px</span>;
  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">15px</span>;
  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ccc</span>;
  <span class="hljs-attribute">position</span>: relative;
  <span class="hljs-attribute">cursor</span>: pointer;
}
<span class="hljs-selector-class">.switch</span><span class="hljs-selector-class">.active</span> {
  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#42b983</span>;
}
<span class="hljs-selector-class">.switch-button</span> {
  <span class="hljs-attribute">width</span>: <span class="hljs-number">26px</span>;
  <span class="hljs-attribute">height</span>: <span class="hljs-number">26px</span>;
  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">50%</span>;
  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#fff</span>;
  <span class="hljs-attribute">position</span>: absolute;
  <span class="hljs-attribute">top</span>: <span class="hljs-number">2px</span>;
  <span class="hljs-attribute">left</span>: <span class="hljs-number">2px</span>;
  <span class="hljs-attribute">transition</span>: left <span class="hljs-number">0.3s</span>;
}
<span class="hljs-selector-class">.switch</span><span class="hljs-selector-class">.active</span> <span class="hljs-selector-class">.switch-button</span> {
  <span class="hljs-attribute">left</span>: <span class="hljs-number">32px</span>;
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span>
</code></pre>
<pre><code class="hljs language-js" lang="js">&lt;!-- 父组件使用 --&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">import</span> { ref } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Switch</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./Switch.vue'</span>

<span class="hljs-keyword">const</span> isOpen = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">false</span>)
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>

<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">Switch</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"isOpen"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>开关状态：{{ isOpen ? '开启' : '关闭' }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span>
</code></pre>
<h2 data-id="heading-13">五、注意事项</h2>
<ol>
<li><strong>Vue 版本要求</strong>：<code>defineModel</code> 是 Vue3.4 及以上版本才支持的特性，若项目版本较低，需要先升级 Vue 版本（升级命令：<code>npm update vue</code>）。</li>
<li><strong>响应式特性</strong>：<code>defineModel</code> 返回的是一个响应式对象，修改其 <code>value</code> 属性会自动同步到父组件，无需手动触发 <code>emit</code> 事件。</li>
<li><strong>与 defineProps 的关系</strong>：<code>defineModel</code> 本质上是对 <code>props</code> 和 <code>emit</code> 的封装，因此不能与 <code>defineProps</code> 定义同名的属性，否则会出现冲突。</li>
<li><strong>默认值的特殊性</strong>：当 <code>defineModel</code> 设置了 <code>default</code> 值时，若父组件传递了 <code>undefined</code>，子组件会使用默认值；若父组件传递了 <code>null</code>，则会使用 <code>null</code> 而不是默认值。</li>
<li><strong>服务器端渲染（SSR）兼容性</strong>：在 SSR 场景下，<code>defineModel</code> 完全兼容，无需额外处理，因为其底层还是基于 <code>props</code> 和 <code>emit</code> 实现的。</li>
</ol>
<h2 data-id="heading-14">六、总结</h2>
<p><code>defineModel</code> 作为 Vue3.4+ 推出的重要特性，极大地简化了父子组件双向绑定的实现逻辑，减少了重复代码，提升了开发效率。它支持自定义名称、默认值、类型校验、值转换等多种进阶功能，能够满足大部分双向绑定场景的需求。</p>
<p>在实际开发中，对于需要双向绑定的组件（如表单组件、UI交互组件等），推荐优先使用 <code>defineModel</code> 替代传统的 <code>props + emit</code> 方式。同时，要注意其版本要求和使用规范，避免出现兼容性问题。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Spring Boot 打包部署，JAR vs WAR]]></title>    <link>https://juejin.cn/post/7591778827308400680</link>    <guid>https://juejin.cn/post/7591778827308400680</guid>    <pubDate>2026-01-06T03:45:45.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7591778827308400680" data-draft-id="7591744411740340224" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Spring Boot 打包部署，JAR vs WAR"/> <meta itemprop="keywords" content="后端,Java,Spring Boot"/> <meta itemprop="datePublished" content="2026-01-06T03:45:45.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="悟空码字"/> <meta itemprop="url" content="https://juejin.cn/user/3139860942296830"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Spring Boot 打包部署，JAR vs WAR
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3139860942296830/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    悟空码字
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-06T03:45:45.000Z" title="Tue Jan 06 2026 03:45:45 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-06
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>大家好，我是小悟。</p>
<h2 data-id="heading-0">一、JAR 和 WAR 打包的区别</h2>
<h3 data-id="heading-1">JAR (Java ARchive)</h3>
<ul>
<li><strong>独立运行</strong>：内嵌Tomcat/Jetty服务器，可直接通过 <code>java -jar</code> 运行</li>
<li><strong>微服务友好</strong>：适合云原生、容器化部署</li>
<li><strong>简化部署</strong>：单个可执行文件，无需外部Web服务器</li>
<li><strong>默认方式</strong>：Spring Boot 默认打包为可执行JAR</li>
</ul>
<h3 data-id="heading-2">WAR (Web Application ARchive)</h3>
<ul>
<li><strong>传统部署</strong>：需要外部Servlet容器（如Tomcat、WebLogic）</li>
<li><strong>企业环境</strong>：适合需要部署到现有应用服务器的场景</li>
<li><strong>共享资源</strong>：多个应用可共享服务器资源</li>
<li><strong>配置分离</strong>：服务器配置与应用分离</li>
</ul>
<h2 data-id="heading-3">二、详细打包部署步骤</h2>
<h3 data-id="heading-4">项目结构</h3>
<pre><code class="hljs language-css" lang="css">my-springboot-app/
├── <span class="hljs-attribute">src</span>/
│   └── <span class="hljs-selector-tag">main</span>/
│       ├── java/com/example/
│       └── resources/
└── pom<span class="hljs-selector-class">.xml</span> 或 build<span class="hljs-selector-class">.gradle</span>
</code></pre>
<h3 data-id="heading-5">1. 打包为可执行JAR（默认方式）</h3>
<h4 data-id="heading-6">Maven 配置 (pom.xml)</h4>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"UTF-8"</span>?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>
    
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>my-springboot-app<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>jar<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span>  <span class="hljs-comment">&lt;!-- 打包为JAR --&gt;</span>
    
    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>
    
    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>
    
    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>
            <span class="hljs-comment">&lt;!-- Spring Boot Maven 插件 --&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">mainClass</span>&gt;</span>com.example.MyApplication<span class="hljs-tag">&lt;/<span class="hljs-name">mainClass</span>&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span>
                        <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span>
                            <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>repackage<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span>
                        <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span>
                    <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span>
</code></pre>
<h4 data-id="heading-7">Gradle 配置 (build.gradle)</h4>
<pre><code class="hljs language-ini" lang="ini">plugins {
    id 'org.springframework.boot' version '3.1.5'
    id 'io.spring.dependency-management' version '1.1.3'
    id 'java'
}

<span class="hljs-attr">group</span> = <span class="hljs-string">'com.example'</span>
<span class="hljs-attr">version</span> = <span class="hljs-string">'1.0.0'</span>
<span class="hljs-attr">sourceCompatibility</span> = <span class="hljs-string">'17'</span>

jar {
    <span class="hljs-attr">enabled</span> = <span class="hljs-literal">true</span>
    <span class="hljs-attr">archiveClassifier</span> = <span class="hljs-string">''</span>  // 移除plain后缀
}

dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-web'
}

// 可执行JAR配置
bootJar {
    <span class="hljs-attr">mainClass</span> = <span class="hljs-string">'com.example.MyApplication'</span>
    <span class="hljs-attr">archiveClassifier</span> = <span class="hljs-string">''</span>
}
</code></pre>
<h4 data-id="heading-8">主启动类</h4>
<pre><code class="hljs language-typescript" lang="typescript">package com.<span class="hljs-property">example</span>;

<span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">boot</span>.<span class="hljs-property">SpringApplication</span>;
<span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">boot</span>.<span class="hljs-property">autoconfigure</span>.<span class="hljs-property">SpringBootApplication</span>;

<span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyApplication</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) {
        <span class="hljs-title class_">SpringApplication</span>.<span class="hljs-title function_">run</span>(<span class="hljs-title class_">MyApplication</span>.<span class="hljs-property">class</span>, args);
    }
}
</code></pre>
<h4 data-id="heading-9">打包命令</h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># Maven</span>
mvn clean package

<span class="hljs-comment"># Gradle</span>
./gradlew clean build
</code></pre>
<h4 data-id="heading-10">运行JAR</h4>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-comment"># 直接运行</span>
java -jar target/my-springboot-app-1.0.0.jar

<span class="hljs-comment"># 指定配置文件</span>
java -jar target/my-springboot-app-1.0.0.jar \
  <span class="hljs-attr">--spring.config.location</span>=classpath:/,file:./config/

<span class="hljs-comment"># 指定端口</span>
java -jar target/my-springboot-app-1.0.0.jar \
  <span class="hljs-attr">--server.port</span>=<span class="hljs-number">8081</span>

<span class="hljs-comment"># 生产环境运行（内存优化）</span>
java -Xms512m -Xmx1024m -jar target/my-springboot-app-1.0.0.jar \
  <span class="hljs-attr">--spring.profiles.active</span>=prod
</code></pre>
<h3 data-id="heading-11">2. 打包为WAR（用于外部容器）</h3>
<h4 data-id="heading-12">修改Maven配置</h4>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"UTF-8"</span>?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>
    
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>my-springboot-app<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>war<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span>  <span class="hljs-comment">&lt;!-- 修改为WAR --&gt;</span>
    
    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>
    
    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-comment">&lt;!-- 排除内嵌Tomcat --&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        
        <span class="hljs-comment">&lt;!-- 添加Servlet API依赖（provided scope） --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>  <span class="hljs-comment">&lt;!-- 由外部容器提供 --&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>
    
    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">finalName</span>&gt;</span>myapp<span class="hljs-tag">&lt;/<span class="hljs-name">finalName</span>&gt;</span>  <span class="hljs-comment">&lt;!-- WAR文件名称 --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span>
</code></pre>
<h4 data-id="heading-13">修改启动类</h4>
<pre><code class="hljs language-scala" lang="scala"><span class="hljs-keyword">package</span> com.example;

<span class="hljs-keyword">import</span> org.springframework.boot.<span class="hljs-type">SpringApplication</span>;
<span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.<span class="hljs-type">SpringBootApplication</span>;
<span class="hljs-keyword">import</span> org.springframework.boot.builder.<span class="hljs-type">SpringApplicationBuilder</span>;
<span class="hljs-keyword">import</span> org.springframework.boot.web.servlet.support.<span class="hljs-type">SpringBootServletInitializer</span>;

<span class="hljs-meta">@SpringBootApplication</span>
public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApplication</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SpringBootServletInitializer</span> </span>{
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">protected</span> <span class="hljs-type">SpringApplicationBuilder</span> configure(<span class="hljs-type">SpringApplicationBuilder</span> builder) {
        <span class="hljs-keyword">return</span> builder.sources(<span class="hljs-type">MyApplication</span>.<span class="hljs-keyword">class</span>);
    }
    
    public static void main(<span class="hljs-type">String</span>[] args) {
        <span class="hljs-type">SpringApplication</span>.run(<span class="hljs-type">MyApplication</span>.<span class="hljs-keyword">class</span>, args);
    }
}
</code></pre>
<h4 data-id="heading-14">Gradle WAR配置</h4>
<pre><code class="hljs language-bash" lang="bash">plugins {
    <span class="hljs-built_in">id</span> <span class="hljs-string">'org.springframework.boot'</span> version <span class="hljs-string">'3.1.5'</span>
    <span class="hljs-built_in">id</span> <span class="hljs-string">'io.spring.dependency-management'</span> version <span class="hljs-string">'1.1.3'</span>
    <span class="hljs-built_in">id</span> <span class="hljs-string">'java'</span>
    <span class="hljs-built_in">id</span> <span class="hljs-string">'war'</span>  // 添加war插件
}

group = <span class="hljs-string">'com.example'</span>
version = <span class="hljs-string">'1.0.0'</span>
sourceCompatibility = <span class="hljs-string">'17'</span>

configurations {
    providedRuntime  // 用于provided范围的依赖
}

dependencies {
    implementation <span class="hljs-string">'org.springframework.boot:spring-boot-starter-web'</span>
    providedRuntime <span class="hljs-string">'org.springframework.boot:spring-boot-starter-tomcat'</span>
}

war {
    archiveFileName = <span class="hljs-string">'myapp.war'</span>
}
</code></pre>
<h4 data-id="heading-15">打包WAR</h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># Maven</span>
mvn clean package

<span class="hljs-comment"># Gradle</span>
./gradlew clean build
</code></pre>
<h4 data-id="heading-16">部署到外部Tomcat</h4>
<p><strong>准备Tomcat服务器</strong></p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 下载Tomcat</span>
wget https://downloads.apache.org/tomcat/tomcat-10/v10.1.13/bin/apache-tomcat-10.1.13.tar.gz
tar -xzf apache-tomcat-10.1.13.tar.gz
<span class="hljs-built_in">cd</span> apache-tomcat-10.1.13
</code></pre>
<p><strong>部署WAR文件</strong></p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 复制WAR文件到webapps目录</span>
<span class="hljs-built_in">cp</span> target/myapp.war /opt/tomcat/webapps/

<span class="hljs-comment"># 或者使用管理界面部署</span>
<span class="hljs-comment"># 访问 http://localhost:8080/manager/html</span>
</code></pre>
<p><strong>Tomcat配置优化（conf/server.xml）</strong></p>
<pre><code class="hljs language-ini" lang="ini">&lt;Connector <span class="hljs-attr">port</span>=<span class="hljs-string">"8080"</span> protocol=<span class="hljs-string">"HTTP/1.1"</span>
           <span class="hljs-attr">connectionTimeout</span>=<span class="hljs-string">"20000"</span>
           <span class="hljs-attr">redirectPort</span>=<span class="hljs-string">"8443"</span>
           <span class="hljs-attr">maxThreads</span>=<span class="hljs-string">"200"</span>
           <span class="hljs-attr">minSpareThreads</span>=<span class="hljs-string">"10"</span>
           <span class="hljs-attr">enableLookups</span>=<span class="hljs-string">"false"</span>
           <span class="hljs-attr">acceptCount</span>=<span class="hljs-string">"100"</span>
           <span class="hljs-attr">disableUploadTimeout</span>=<span class="hljs-string">"true"</span>/&gt;
</code></pre>
<p><strong>启动/停止Tomcat</strong></p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># Linux</span>
./<span class="hljs-built_in">bin</span>/startup.sh
./<span class="hljs-built_in">bin</span>/shutdown.sh

<span class="hljs-comment"># Windows</span>
<span class="hljs-built_in">bin</span>\startup.bat
<span class="hljs-built_in">bin</span>\shutdown.bat
</code></pre>
<h3 data-id="heading-17">3. 配置文件管理</h3>
<h4 data-id="heading-18">application.yml 示例</h4>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-comment"># 公共配置</span>
<span class="hljs-attr">spring:</span>
  <span class="hljs-attr">application:</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">my-springboot-app</span>

<span class="hljs-comment"># 开发环境</span>
<span class="hljs-meta">---</span>
<span class="hljs-attr">spring:</span>
  <span class="hljs-attr">config:</span>
    <span class="hljs-attr">activate:</span>
      <span class="hljs-attr">on-profile:</span> <span class="hljs-string">dev</span>
<span class="hljs-attr">server:</span>
  <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span>
<span class="hljs-attr">logging:</span>
  <span class="hljs-attr">level:</span>
    <span class="hljs-attr">root:</span> <span class="hljs-string">DEBUG</span>

<span class="hljs-comment"># 生产环境</span>
<span class="hljs-meta">---</span>
<span class="hljs-attr">spring:</span>
  <span class="hljs-attr">config:</span>
    <span class="hljs-attr">activate:</span>
      <span class="hljs-attr">on-profile:</span> <span class="hljs-string">prod</span>
<span class="hljs-attr">server:</span>
  <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span>
  <span class="hljs-attr">compression:</span>
    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span>
    <span class="hljs-attr">mime-types:</span> <span class="hljs-string">text/html,text/xml,text/plain,application/json</span>
<span class="hljs-attr">logging:</span>
  <span class="hljs-attr">file:</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">/var/log/myapp.log</span>
  <span class="hljs-attr">level:</span>
    <span class="hljs-attr">root:</span> <span class="hljs-string">INFO</span>
</code></pre>
<h3 data-id="heading-19">4. 容器化部署（Docker）</h3>
<h4 data-id="heading-20">Dockerfile for JAR</h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 使用多阶段构建</span>
FROM eclipse-temurin:17-jdk-alpine as builder
WORKDIR /app
COPY mvnw .
COPY .mvn .mvn
COPY pom.xml .
RUN ./mvnw dependency:go-offline
COPY src ./src
RUN ./mvnw clean package -DskipTests

<span class="hljs-comment"># 运行阶段</span>
FROM eclipse-temurin:17-jre-alpine
WORKDIR /app
COPY --from=builder /app/target/*.jar app.jar
EXPOSE 8080
ENTRYPOINT [<span class="hljs-string">"java"</span>, <span class="hljs-string">"-jar"</span>, <span class="hljs-string">"app.jar"</span>]
</code></pre>
<h4 data-id="heading-21">Dockerfile for WAR + Tomcat</h4>
<pre><code class="hljs language-bash" lang="bash">FROM tomcat:10.1-jdk17-temurin
<span class="hljs-comment"># 移除默认应用</span>
RUN <span class="hljs-built_in">rm</span> -rf /usr/local/tomcat/webapps/*
<span class="hljs-comment"># 复制WAR文件</span>
COPY target/myapp.war /usr/local/tomcat/webapps/ROOT.war
<span class="hljs-comment"># 暴露端口</span>
EXPOSE 8080
<span class="hljs-comment"># 启动Tomcat</span>
CMD [<span class="hljs-string">"catalina.sh"</span>, <span class="hljs-string">"run"</span>]
</code></pre>
<h4 data-id="heading-22">Docker Compose 示例</h4>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">'3.8'</span>
<span class="hljs-attr">services:</span>
  <span class="hljs-attr">app:</span>
    <span class="hljs-attr">build:</span> <span class="hljs-string">.</span>
    <span class="hljs-attr">ports:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">"8080:8080"</span>
    <span class="hljs-attr">environment:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">SPRING_PROFILES_ACTIVE=prod</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">DB_HOST=mysql</span>
    <span class="hljs-attr">depends_on:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">mysql</span>
    <span class="hljs-attr">networks:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">app-network</span>

  <span class="hljs-attr">mysql:</span>
    <span class="hljs-attr">image:</span> <span class="hljs-string">mysql:8.0</span>
    <span class="hljs-attr">environment:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">MYSQL_ROOT_PASSWORD=rootpass</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">MYSQL_DATABASE=mydb</span>
    <span class="hljs-attr">volumes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">mysql-data:/var/lib/mysql</span>
    <span class="hljs-attr">networks:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">app-network</span>

<span class="hljs-attr">networks:</span>
  <span class="hljs-attr">app-network:</span>
    <span class="hljs-attr">driver:</span> <span class="hljs-string">bridge</span>

<span class="hljs-attr">volumes:</span>
  <span class="hljs-attr">mysql-data:</span>
</code></pre>
<h2 data-id="heading-23">三、部署脚本示例</h2>
<h3 data-id="heading-24">Linux 服务脚本（systemd）</h3>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-comment"># /etc/systemd/system/myapp.service</span>
<span class="hljs-section">[Unit]</span>
<span class="hljs-attr">Description</span>=My Spring Boot Application
<span class="hljs-attr">After</span>=network.target

<span class="hljs-section">[Service]</span>
<span class="hljs-attr">Type</span>=simple
<span class="hljs-attr">User</span>=appuser
<span class="hljs-attr">WorkingDirectory</span>=/opt/myapp
<span class="hljs-attr">ExecStart</span>=/usr/bin/java -Xms512m -Xmx1024m -jar myapp.jar
<span class="hljs-attr">SuccessExitStatus</span>=<span class="hljs-number">143</span>
<span class="hljs-attr">Restart</span>=always
<span class="hljs-attr">RestartSec</span>=<span class="hljs-number">10</span>

<span class="hljs-section">[Install]</span>
<span class="hljs-attr">WantedBy</span>=multi-user.target
</code></pre>
<h3 data-id="heading-25">部署脚本</h3>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-meta">#!/bin/bash</span>
<span class="hljs-comment"># deploy.sh</span>

APP_NAME=<span class="hljs-string">"my-springboot-app"</span>
JAR_PATH=<span class="hljs-string">"target/<span class="hljs-variable">$APP_NAME</span>-1.0.0.jar"</span>
DEPLOY_DIR=<span class="hljs-string">"/opt/<span class="hljs-variable">$APP_NAME</span>"</span>
BACKUP_DIR=<span class="hljs-string">"<span class="hljs-variable">$DEPLOY_DIR</span>/backup"</span>
LOG_DIR=<span class="hljs-string">"/var/log/<span class="hljs-variable">$APP_NAME</span>"</span>

<span class="hljs-comment"># 创建目录</span>
<span class="hljs-built_in">mkdir</span> -p <span class="hljs-variable">$DEPLOY_DIR</span> <span class="hljs-variable">$BACKUP_DIR</span> <span class="hljs-variable">$LOG_DIR</span>

<span class="hljs-comment"># 备份旧版本</span>
<span class="hljs-keyword">if</span> [ -f <span class="hljs-string">"<span class="hljs-variable">$DEPLOY_DIR</span>/<span class="hljs-variable">$APP_NAME</span>.jar"</span> ]; <span class="hljs-keyword">then</span>
    TIMESTAMP=$(<span class="hljs-built_in">date</span> +%Y%m%d_%H%M%S)
    <span class="hljs-built_in">mv</span> <span class="hljs-string">"<span class="hljs-variable">$DEPLOY_DIR</span>/<span class="hljs-variable">$APP_NAME</span>.jar"</span> <span class="hljs-string">"<span class="hljs-variable">$BACKUP_DIR</span>/<span class="hljs-variable">$APP_NAME</span>-<span class="hljs-variable">$TIMESTAMP</span>.jar"</span>
<span class="hljs-keyword">fi</span>

<span class="hljs-comment"># 复制新版本</span>
<span class="hljs-built_in">cp</span> <span class="hljs-variable">$JAR_PATH</span> <span class="hljs-string">"<span class="hljs-variable">$DEPLOY_DIR</span>/<span class="hljs-variable">$APP_NAME</span>.jar"</span>

<span class="hljs-comment"># 设置权限</span>
<span class="hljs-built_in">chmod</span> 755 <span class="hljs-string">"<span class="hljs-variable">$DEPLOY_DIR</span>/<span class="hljs-variable">$APP_NAME</span>.jar"</span>

<span class="hljs-comment"># 重启服务</span>
systemctl restart <span class="hljs-variable">$APP_NAME</span>

<span class="hljs-comment"># 检查状态</span>
<span class="hljs-built_in">sleep</span> 10
systemctl status <span class="hljs-variable">$APP_NAME</span>
</code></pre>
<h2 data-id="heading-26">四、总结对比</h2>


















































<table><thead><tr><th align="left">特性</th><th align="left">JAR 部署</th><th align="left">WAR 部署</th></tr></thead><tbody><tr><td align="left"><strong>部署方式</strong></td><td align="left">独立运行，内嵌容器</td><td align="left">依赖外部Servlet容器</td></tr><tr><td align="left"><strong>启动命令</strong></td><td align="left"><code>java -jar app.jar</code></td><td align="left">容器启动（如Tomcat）</td></tr><tr><td align="left"><strong>适合场景</strong></td><td align="left">微服务、云原生、容器化</td><td align="left">传统企业环境、共享服务器</td></tr><tr><td align="left"><strong>依赖管理</strong></td><td align="left">包含所有依赖（fat jar）</td><td align="left">部分依赖由容器提供</td></tr><tr><td align="left"><strong>资源占用</strong></td><td align="left">每个应用独立容器</td><td align="left">多个应用共享容器资源</td></tr><tr><td align="left"><strong>热部署</strong></td><td align="left">需要重启整个应用</td><td align="left">Tomcat支持部分热部署</td></tr><tr><td align="left"><strong>配置管理</strong></td><td align="left">应用自身管理</td><td align="left">可与容器配置结合</td></tr><tr><td align="left"><strong>监控</strong></td><td align="left">Spring Boot Actuator</td><td align="left">容器管理界面 + Actuator</td></tr></tbody></table>
<h3 data-id="heading-27">选择建议：</h3>
<ol>
<li><strong>选择JAR的情况</strong>：
<ul>
<li>微服务架构</li>
<li>容器化部署（Docker/K8s）</li>
<li>云原生应用</li>
<li>需要快速独立部署</li>
<li>无现有应用服务器</li>
</ul>
</li>
<li><strong>选择WAR的情况</strong>：
<ul>
<li>传统企业IT环境</li>
<li>已有Tomcat/WebLogic集群</li>
<li>需要与其他Java EE应用共享资源</li>
<li>运维团队熟悉传统部署模式</li>
<li>需要与旧系统集成</li>
</ul>
</li>
</ol>
<h3 data-id="heading-28">最佳实践：</h3>
<ol>
<li><strong>对于新项目</strong>，优先考虑JAR部署，更符合现代架构</li>
<li><strong>统一配置管理</strong>：无论JAR/WAR，使用外部配置文件</li>
<li><strong>健康检查</strong>：集成Spring Boot Actuator用于监控</li>
<li><strong>日志集中</strong>：使用Logback/SLF4J，日志输出到文件或日志系统</li>
<li><strong>安全加固</strong>：生产环境关闭开发特性，使用HTTPS</li>
<li><strong>自动化部署</strong>：结合CI/CD流水线实现自动化</li>
</ol>
<p>通过合理的打包部署策略，可以确保Spring Boot应用在不同环境中的稳定运行和高效维护。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d46fa7dd1d3147769270ec545a1bd3f3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oKf56m656CB5a2X:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768275945&amp;x-signature=o2eoWuDmWuMTFQQFPM2uPzeqlks%3D" alt="Spring Boot 打包部署，JAR vs WAR.png" loading="lazy"/></p>
<p><strong>谢谢你看我的文章，既然看到这里了，如果觉得不错，随手点个赞、转发、在看三连吧，感谢感谢。那我们，下次再见。</strong></p>
<p>您的一键三连，是我更新的最大动力，谢谢</p>
<p>山水有相逢，来日皆可期，谢谢阅读，我们再会</p>
<p>我手中的金箍棒，上能通天，下能探海</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[用填充表格法吃透01背包及其变形-3]]></title>    <link>https://juejin.cn/post/7591697558378168362</link>    <guid>https://juejin.cn/post/7591697558378168362</guid>    <pubDate>2026-01-06T03:46:53.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7591697558378168362" data-draft-id="7591697558378151978" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="用填充表格法吃透01背包及其变形-3"/> <meta itemprop="keywords" content="前端,后端,算法"/> <meta itemprop="datePublished" content="2026-01-06T03:46:53.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="颜酱"/> <meta itemprop="url" content="https://juejin.cn/user/905653309941495"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            用填充表格法吃透01背包及其变形-3
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/905653309941495/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    颜酱
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-06T03:46:53.000Z" title="Tue Jan 06 2026 03:46:53 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-06
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读15分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">三、01背包的经典变形</h2>
<p>01背包的核心是「选/不选」，实际考题中很少直接考查基础模型，更多是结合具体场景转化为变形问题。但无论场景如何变化，只要抓住「每个物品最多选一次」的本质，就能用DP解题5步「万能钥匙」轻松破解。以下是4类最经典的01背包变形：</p>
<h3 data-id="heading-1">3.1 变形1：目标和（分割子集和/是否能装满背包）</h3>
<p><strong>LeetCode 链接</strong>：<a href="https://link.juejin.cn?target=https%3A%2F%2Fleetcode.cn%2Fproblems%2Ftarget-sum%2F" target="_blank" title="https://leetcode.cn/problems/target-sum/" ref="nofollow noopener noreferrer">494. 目标和</a></p>
<p><strong>问题描述</strong>：给定一个非负整数数组<code>nums</code>和一个目标数<code>target</code>，向数组中每个整数前添加<code>+</code>或<code>-</code>，使得所有整数的和等于<code>target</code>，求有多少种不同的添加符号的方法。</p>
<p>核心转化：设添加<code>+</code>的数的和为<code>left</code>，添加<code>-</code>的数的和为<code>right</code>，则有：</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-attribute">left</span> - <span class="hljs-attribute">right</span> = target
<span class="hljs-attribute">left</span> + <span class="hljs-attribute">right</span> = <span class="hljs-built_in">sum</span>(nums)
两式相加得：<span class="hljs-attribute">left</span> = (target + sum(nums)) / <span class="hljs-number">2</span>
</code></pre>
<p>问题转化为：从<code>nums</code>中选择若干元素，使得其和恰好为<code>left</code>，求这样的选择方案数——这是「01背包求方案数」的典型场景（每个元素选或不选，选则计入和，不选则不计）。</p>
<p>目标和问题核心表格（空表，后续逐步填充）：</p>





































<table><thead><tr><th>处理阶段\和为j</th><th>0</th><th>1</th><th>2</th><th>...（和递增）</th><th>left（目标和）</th></tr></thead><tbody><tr><td>初始状态</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td></tr><tr><td>处理第1个元素</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td></tr><tr><td>处理第2个元素</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td></tr></tbody></table>
<p>表格说明：表格中每个单元格<code>dp[i][j]</code>代表「处理前i个元素后，能凑出和为j的方案数」，最终右下角<code>dp[n][left]</code>即为目标和的解法总数（n为nums数组长度）。</p>
<h4 data-id="heading-2">3.1.1 步骤1：确定dp数组及下标的含义</h4>
<p>定义二维数组<code>dp[i][j]</code>：表示「处理前i个元素，能凑出和为j的方案数」。后续可优化为一维数组<code>dp[j]</code>（空间优化思路与基础01背包一致），这里先从直观的二维数组入手。</p>
<p>对应表格维度：i（行）表示处理的元素个数（从0到n，0代表未处理任何元素），j（列）表示要凑的和（从0到left，0代表和为0），表格共n+1行、left+1列。</p>
<h4 data-id="heading-3">3.1.2 步骤2：确定递推公式</h4>
<p>对于第i个元素（值为<code>nums[i-1]</code>，数组索引从0开始，i从1开始），核心决策仍是「选或不选」，方案数为两种决策的总和：</p>
<ol>
<li>
<p><strong>不选第i个元素</strong>：凑出和为j的方案数 = 处理前i-1个元素凑出和为j的方案数，即<code>dp[i][j] += dp[i-1][j]</code>；</p>
</li>
<li>
<p><strong>选第i个元素</strong>：需保证j ≥ nums[i-1]（当前元素值不大于目标和j），此时方案数 = 处理前i-1个元素凑出和为j-nums[i-1]的方案数，即<code>dp[i][j] += dp[i-1][j - nums[i-1]]</code>。</p>
</li>
</ol>
<p>最终递推公式（两种决策方案数相加）：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">if</span> (j &gt;= nums[i - <span class="hljs-number">1</span>]) {
  dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i - <span class="hljs-number">1</span>][j - nums[i - <span class="hljs-number">1</span>]];
} <span class="hljs-keyword">else</span> {
  dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];
}
</code></pre>
<h4 data-id="heading-4">3.1.3 步骤3：dp数组如何初始化</h4>
<p>初始化核心是确定边界条件，即无需推导就能直接确定的方案数：</p>
<ol>
<li>
<p><strong>i=0（未处理任何元素），j=0（和为0）</strong>：不选任何元素即可凑出和为0，因此方案数为1，即<code>dp[0][0] = 1</code>；</p>
</li>
<li>
<p><strong>i=0（未处理任何元素），j&gt;0（和大于0）</strong>：没有元素可选，无法凑出任何正和，方案数为0，即<code>dp[0][j] = 0</code>（j&gt;0）；</p>
</li>
<li>
<p><strong>j=0（和为0），i&gt;0（处理过元素）</strong>：初始时可先设为1（后续通过递推更新），表示不选当前及之前元素的基础方案。</p>
</li>
</ol>
<p>结合示例理解：假设nums = [1,1,1,1]，target = 2，先计算sum(nums) = 4，left = (2 + 4)/2 = 3。初始化后的表格（第0行已填充）：</p>















































<table><thead><tr><th>处理阶段\和为j</th><th>0</th><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>初始状态（i=0）</td><td>1</td><td>0</td><td>0</td><td>0</td></tr><tr><td>处理第1个元素（1）</td><td>1</td><td>待填</td><td>待填</td><td>待填</td></tr><tr><td>处理第2个元素（1）</td><td>1</td><td>待填</td><td>待填</td><td>待填</td></tr><tr><td>处理第3个元素（1）</td><td>1</td><td>待填</td><td>待填</td><td>待填</td></tr><tr><td>处理第4个元素（1）</td><td>1</td><td>待填</td><td>待填</td><td>待填</td></tr></tbody></table>
<h4 data-id="heading-5">3.1.4 步骤4：确定遍历顺序（表格填充顺序）</h4>
<p>与基础01背包二维解法一致：先遍历元素（i从1到n），再遍历和（j从0到left），即<strong>逐行填充表格</strong>。原因：计算<code>dp[i][j]</code>时，仅依赖上一行（i-1行）的<code>dp[i-1][j]</code>和<code>dp[i-1][j - nums[i-1]]</code>，逐行填充可确保依赖的单元格已提前计算完成。</p>
<h4 data-id="heading-6">3.1.5 步骤5：打印dp数组（验证）</h4>
<p>以示例<code>nums = [1,1,1,1]</code>、<code>target = 2</code>（left=3）为例，逐步填充表格验证逻辑：</p>
<ol>
<li>
<p><strong>填充第1行（i=1，元素1：1）</strong>：</p>
<ul>
<li>j=0：不选元素1，方案数=dp[0][0]=1；</li>
<li>j=1：j≥1，方案数=dp[0][1]（不选）+ dp[0][0]（选）=0+1=1；</li>
<li>j=2：j&gt;1，无法选，方案数=dp[0][2]=0；</li>
<li>j=3：j&gt;1，无法选，方案数=dp[0][3]=0；</li>
</ul>
</li>
<li>
<p><strong>填充第2行（i=2，元素2：1）</strong>：</p>
<ul>
<li>j=0：方案数=dp[1][0]=1；</li>
<li>j=1：j≥1，方案数=dp[1][1]（不选）+ dp[1][0]（选）=1+1=2；</li>
<li>j=2：j≥1，方案数=dp[1][2]（不选）+ dp[1][1]（选）=0+1=1；</li>
<li>j=3：j&gt;1，无法选，方案数=dp[1][3]=0；</li>
</ul>
</li>
<li>
<p><strong>填充第3行（i=3，元素3：1）</strong>：</p>
<ul>
<li>j=0：方案数=dp[2][0]=1；</li>
<li>j=1：j≥1，方案数=dp[2][1]（不选）+ dp[2][0]（选）=2+1=3；</li>
<li>j=2：j≥1，方案数=dp[2][2]（不选）+ dp[2][1]（选）=1+2=3；</li>
<li>j=3：j≥1，方案数=dp[2][3]（不选）+ dp[2][2]（选）=0+1=1；</li>
</ul>
</li>
<li>
<p><strong>填充第4行（i=4，元素4：1）</strong>：</p>
<ul>
<li>j=0：方案数=dp[3][0]=1；</li>
<li>j=1：j≥1，方案数=dp[3][1]（不选）+ dp[3][0]（选）=3+1=4；</li>
<li>j=2：j≥1，方案数=dp[3][2]（不选）+ dp[3][1]（选）=3+3=6；</li>
<li>j=3：j≥1，方案数=dp[3][3]（不选）+ dp[3][2]（选）=1+3=4；</li>
</ul>
</li>
</ol>
<p>最终填充完成的表格：</p>















































<table><thead><tr><th>处理阶段\和为j</th><th>0</th><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>初始状态（i=0）</td><td>1</td><td>0</td><td>0</td><td>0</td></tr><tr><td>处理第1个元素（1）</td><td>1</td><td>1</td><td>0</td><td>0</td></tr><tr><td>处理第2个元素（1）</td><td>1</td><td>2</td><td>1</td><td>0</td></tr><tr><td>处理第3个元素（1）</td><td>1</td><td>3</td><td>3</td><td>1</td></tr><tr><td>处理第4个元素（1）</td><td>1</td><td>4</td><td>6</td><td>4</td></tr></tbody></table>
<p>表格右下角<code>dp[4][3] = 4</code>，即该示例的目标和解法总数为4，与实际情况一致（+1+1+1-1、+1+1-1+1、+1-1+1+1、-1+1+1+1）。</p>
<h4 data-id="heading-7">3.1.6 目标和问题完整代码（二维+一维优化）</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">/**
 * 目标和（二维DP解法）
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number[]</span>} <span class="hljs-variable">nums</span> - 非负整数数组
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number</span>} <span class="hljs-variable">target</span> - 目标和
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">number</span>} - 不同的添加符号方法数
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">findTargetSumWays_2d</span>(<span class="hljs-params">nums, target</span>) {
  <span class="hljs-keyword">const</span> sum = nums.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b, <span class="hljs-number">0</span>);
  <span class="hljs-comment">// 边界条件：target的绝对值大于sum，或(target + sum)为奇数，均无可行方案</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(target) &gt; sum || (target + sum) % <span class="hljs-number">2</span> !== <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
  <span class="hljs-keyword">const</span> left = (target + sum) / <span class="hljs-number">2</span>;
  <span class="hljs-keyword">const</span> n = nums.<span class="hljs-property">length</span>;
  <span class="hljs-comment">// 初始化二维dp数组：dp[i][j]表示处理前i个元素凑出和为j的方案数</span>
  <span class="hljs-keyword">const</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(n + <span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">map</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(left + <span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>));
  dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 未处理元素时，凑出和为0的方案数为1</span>

  <span class="hljs-comment">// 遍历顺序：先遍历元素，再遍历和（逐行填充）</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt;= left; j++) {
      <span class="hljs-comment">// 递推公式</span>
      <span class="hljs-keyword">if</span> (j &gt;= nums[i - <span class="hljs-number">1</span>]) {
        dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i - <span class="hljs-number">1</span>][j - nums[i - <span class="hljs-number">1</span>]];
      } <span class="hljs-keyword">else</span> {
        dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];
      }
    }
  }

  <span class="hljs-comment">// 打印dp数组验证</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'目标和二维DP数组（表格）：'</span>);
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dp[i].<span class="hljs-title function_">join</span>(<span class="hljs-string">'\t'</span>));
  }

  <span class="hljs-keyword">return</span> dp[n][left];
}

<span class="hljs-comment">/**
 * 目标和（一维DP空间优化解法）
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number[]</span>} <span class="hljs-variable">nums</span> - 非负整数数组
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number</span>} <span class="hljs-variable">target</span> - 目标和
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">number</span>} - 不同的添加符号方法数
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">findTargetSumWays_1d</span>(<span class="hljs-params">nums, target</span>) {
  <span class="hljs-keyword">const</span> sum = nums.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b, <span class="hljs-number">0</span>);
  <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(target) &gt; sum || (target + sum) % <span class="hljs-number">2</span> !== <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
  <span class="hljs-keyword">const</span> left = (target + sum) / <span class="hljs-number">2</span>;
  <span class="hljs-comment">// 初始化一维dp数组：dp[j]表示凑出和为j的方案数</span>
  <span class="hljs-keyword">const</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(left + <span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>);
  dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 基础方案：不选任何元素凑出和为0</span>

  <span class="hljs-comment">// 遍历顺序：先遍历元素，再倒序遍历和（避免重复选择）</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> num <span class="hljs-keyword">of</span> nums) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = left; j &gt;= num; j--) {
      dp[j] += dp[j - num]; <span class="hljs-comment">// 递推公式简化（复用数组）</span>
    }
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`处理完元素<span class="hljs-subst">${num}</span>后，dp数组：`</span>, [...dp]);
  }

  <span class="hljs-keyword">return</span> dp[left];
}

<span class="hljs-comment">// 测试用例</span>
<span class="hljs-keyword">const</span> nums = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>];
<span class="hljs-keyword">const</span> target = <span class="hljs-number">2</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'二维DP解法：'</span>, <span class="hljs-title function_">findTargetSumWays_2d</span>(nums, target)); <span class="hljs-comment">// 输出：4</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'一维DP解法：'</span>, <span class="hljs-title function_">findTargetSumWays_1d</span>(nums, target)); <span class="hljs-comment">// 输出：4</span>
</code></pre>
<h3 data-id="heading-8">3.2 变形2：分割等和子集（是否能装满背包）</h3>
<p><strong>LeetCode 链接</strong>：<a href="https://link.juejin.cn?target=https%3A%2F%2Fleetcode.cn%2Fproblems%2Fpartition-equal-subset-sum%2F" target="_blank" title="https://leetcode.cn/problems/partition-equal-subset-sum/" ref="nofollow noopener noreferrer">416. 分割等和子集</a></p>
<p><strong>问题描述</strong>：给定一个只包含正整数的非空数组<code>nums</code>，判断是否可以将这个数组分割成两个子集，使得两个子集的和相等。</p>
<p>核心转化：两个子集和相等，即每个子集的和为数组总和的一半（记为<code>target</code>）。问题转化为：从<code>nums</code>中选择若干元素，使得其和恰好为<code>target</code>——这是「01背包判断可行性」的典型场景（每个元素选或不选，判断是否能装满容量为target的背包）。</p>
<p>核心表格（空表）：</p>





































<table><thead><tr><th>处理阶段\和为j</th><th>0</th><th>1</th><th>2</th><th>...（和递增）</th><th>target（目标和）</th></tr></thead><tbody><tr><td>初始状态</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td></tr><tr><td>处理第1个元素</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td></tr><tr><td>处理第2个元素</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td></tr></tbody></table>
<p>表格说明：表格中每个单元格<code>dp[i][j]</code>代表「处理前i个元素后，能否凑出和为j」（布尔值），最终右下角<code>dp[n][target]</code>即为问题答案。</p>
<h4 data-id="heading-9">3.2.1 步骤1：确定dp数组及下标的含义</h4>
<p>定义二维布尔数组<code>dp[i][j]</code>：表示「处理前i个元素，能否凑出和为j」。可优化为一维布尔数组<code>dp[j]</code>，空间复杂度从<code>O(n*target)</code>降至<code>O(target)</code>。</p>
<p>对应表格维度：i（行）表示处理的元素个数（从0到n，0代表未处理任何元素），j（列）表示要凑的和（从0到target，0代表和为0），表格共n+1行、target+1列。</p>
<h4 data-id="heading-10">3.2.2 步骤2：确定递推公式</h4>
<p>对于第i个元素（值为<code>nums[i-1]</code>），决策为「选或不选」，可行性为两种决策的或运算：</p>
<ol>
<li>
<p><strong>不选第i个元素</strong>：能否凑出j = 处理前i-1个元素能否凑出j，即<code>dp[i][j] = dp[i-1][j]</code>；</p>
</li>
<li>
<p><strong>选第i个元素</strong>：需j ≥ nums[i-1]，能否凑出j = 处理前i-1个元素能否凑出j-nums[i-1]，即<code>dp[i][j] = dp[i-1][j - nums[i-1]]</code>。</p>
</li>
</ol>
<p>最终递推公式（两种决策有一个可行则整体可行）：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">if</span> (j &gt;= nums[i - <span class="hljs-number">1</span>]) {
  dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] || dp[i - <span class="hljs-number">1</span>][j - nums[i - <span class="hljs-number">1</span>]];
} <span class="hljs-keyword">else</span> {
  dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];
}
</code></pre>
<h4 data-id="heading-11">3.2.3 步骤3：dp数组如何初始化</h4>
<p>初始化核心是确定边界条件，即无需推导就能直接确定的可行性：</p>
<ol>
<li>
<p><strong>i=0（未处理任何元素），j=0（和为0）</strong>：不选任何元素可凑出和为0，因此<code>dp[0][0] = true</code>；</p>
</li>
<li>
<p><strong>i=0（未处理任何元素），j&gt;0（和大于0）</strong>：没有元素可选，无法凑出任何正和，可行性为<code>false</code>，即<code>dp[0][j] = false</code>（j&gt;0）；</p>
</li>
<li>
<p><strong>j=0（和为0），i&gt;0（处理过元素）</strong>：初始时可先设为<code>true</code>（后续通过递推更新），表示不选当前及之前元素的基础方案。</p>
</li>
</ol>
<p>结合示例理解：假设nums = [1,5,11,5]，sum = 22，target = 11。初始化后的表格（第0行已填充）：</p>



























































<table><thead><tr><th>处理阶段\和为j</th><th>0</th><th>1</th><th>2</th><th>3</th><th>...（和递增）</th><th>11（目标和）</th></tr></thead><tbody><tr><td>初始状态（i=0）</td><td>true</td><td>false</td><td>false</td><td>false</td><td>false</td><td>false</td></tr><tr><td>处理第1个元素（1）</td><td>true</td><td>待填</td><td>待填</td><td>待填</td><td>待填</td><td>待填</td></tr><tr><td>处理第2个元素（5）</td><td>true</td><td>待填</td><td>待填</td><td>待填</td><td>待填</td><td>待填</td></tr><tr><td>处理第3个元素（11）</td><td>true</td><td>待填</td><td>待填</td><td>待填</td><td>待填</td><td>待填</td></tr><tr><td>处理第4个元素（5）</td><td>true</td><td>待填</td><td>待填</td><td>待填</td><td>待填</td><td>待填</td></tr></tbody></table>
<h4 data-id="heading-12">3.2.4 步骤4：确定遍历顺序（表格填充顺序）</h4>
<p>与基础01背包二维解法一致：先遍历元素（i从1到n），再遍历和（j从0到target），即<strong>逐行填充表格</strong>。原因：计算<code>dp[i][j]</code>时，仅依赖上一行（i-1行）的<code>dp[i-1][j]</code>和<code>dp[i-1][j - nums[i-1]]</code>，逐行填充可确保依赖的单元格已提前计算完成。</p>
<p>一维解法：先遍历元素，再倒序遍历和（避免重复选择），与基础01背包空间优化逻辑一致。</p>
<h4 data-id="heading-13">3.2.5 步骤5：打印dp数组（验证）</h4>
<p>以示例<code>nums = [1,5,11,5]</code>、<code>sum = 22</code>、<code>target = 11</code>为例，逐步填充表格验证逻辑：</p>
<ol>
<li>
<p><strong>填充第1行（i=1，元素1：1）</strong>：</p>
<ul>
<li>j=0：不选元素1，dp[1][0] = dp[0][0] = true；</li>
<li>j=1：j≥1，dp[1][1] = dp[0][1]（不选）|| dp[0][0]（选）= false || true = true；</li>
<li>j=2-11：j&lt;1，无法选，dp[1][j] = dp[0][j] = false；</li>
</ul>
</li>
<li>
<p><strong>填充第2行（i=2，元素2：5）</strong>：</p>
<ul>
<li>j=0：dp[2][0] = dp[1][0] = true；</li>
<li>j=1-4：j&lt;5，无法选，dp[2][j] = dp[1][j]（继承上一行）；</li>
<li>j=5：j≥5，dp[2][5] = dp[1][5]（不选）|| dp[1][0]（选）= false || true = true；</li>
<li>j=6：j≥5，dp[2][6] = dp[1][6]（不选）|| dp[1][1]（选）= false || true = true；</li>
<li>j=7-11：j≥5，dp[2][j] = dp[1][j]（不选）|| dp[1][j-5]（选），其中j=11时，dp[2][11] = false || false = false；</li>
</ul>
</li>
<li>
<p><strong>填充第3行（i=3，元素3：11）</strong>：</p>
<ul>
<li>j=0-10：j&lt;11，无法选，dp[3][j] = dp[2][j]（继承上一行）；</li>
<li>j=11：j≥11，dp[3][11] = dp[2][11]（不选）|| dp[2][0]（选）= false || true = true；</li>
</ul>
</li>
<li>
<p><strong>填充第4行（i=4，元素4：5）</strong>：</p>
<ul>
<li>j=0-4：j&lt;5，无法选，dp[4][j] = dp[3][j]（继承上一行）；</li>
<li>j=5-11：j≥5，dp[4][j] = dp[3][j]（不选）|| dp[3][j-5]（选），其中j=11时，dp[4][11] = true || false = true；</li>
</ul>
</li>
</ol>
<p>最终填充完成的表格：</p>































































































<table><thead><tr><th>处理阶段\和为j</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th></tr></thead><tbody><tr><td>初始状态（i=0）</td><td>true</td><td>false</td><td>false</td><td>false</td><td>false</td><td>false</td><td>false</td><td>false</td><td>false</td><td>false</td><td>false</td><td>false</td></tr><tr><td>处理第1个元素（1）</td><td>true</td><td>true</td><td>false</td><td>false</td><td>false</td><td>false</td><td>false</td><td>false</td><td>false</td><td>false</td><td>false</td><td>false</td></tr><tr><td>处理第2个元素（5）</td><td>true</td><td>true</td><td>false</td><td>false</td><td>false</td><td>true</td><td>true</td><td>false</td><td>false</td><td>false</td><td>false</td><td>false</td></tr><tr><td>处理第3个元素（11）</td><td>true</td><td>true</td><td>false</td><td>false</td><td>false</td><td>true</td><td>true</td><td>false</td><td>false</td><td>false</td><td>false</td><td>true</td></tr><tr><td>处理第4个元素（5）</td><td>true</td><td>true</td><td>false</td><td>false</td><td>false</td><td>true</td><td>true</td><td>false</td><td>false</td><td>false</td><td>false</td><td>true</td></tr></tbody></table>
<p>表格右下角<code>dp[4][11] = true</code>，即该示例可以分割成两个和相等的子集（子集[1,5,5]和[11]），与预期结果一致。</p>
<h4 data-id="heading-14">3.2.6 分割等和子集完整代码</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">/**
 * 分割等和子集（二维DP解法）
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number[]</span>} <span class="hljs-variable">nums</span> - 正整数数组
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">boolean</span>} - 是否可以分割成两个和相等的子集
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">canPartition_2d</span>(<span class="hljs-params">nums</span>) {
  <span class="hljs-keyword">const</span> sum = nums.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b, <span class="hljs-number">0</span>);
  <span class="hljs-keyword">if</span> (sum % <span class="hljs-number">2</span> !== <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 总和为奇数，无法分割</span>
  <span class="hljs-keyword">const</span> target = sum / <span class="hljs-number">2</span>;
  <span class="hljs-keyword">const</span> n = nums.<span class="hljs-property">length</span>;
  <span class="hljs-comment">// 初始化二维dp数组：dp[i][j]表示处理前i个元素能否凑出和为j</span>
  <span class="hljs-keyword">const</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(n + <span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">map</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(target + <span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-literal">false</span>));
  dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 边界条件</span>

  <span class="hljs-comment">// 遍历顺序：先遍历元素，再遍历和</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt;= target; j++) {
      <span class="hljs-keyword">if</span> (j &gt;= nums[i - <span class="hljs-number">1</span>]) {
        dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] || dp[i - <span class="hljs-number">1</span>][j - nums[i - <span class="hljs-number">1</span>]];
      } <span class="hljs-keyword">else</span> {
        dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];
      }
    }
  }

  <span class="hljs-comment">// 打印dp数组验证</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'分割等和子集二维DP数组（表格）：'</span>);
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dp[i].<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> (val ? <span class="hljs-string">'true'</span> : <span class="hljs-string">'false'</span>)).<span class="hljs-title function_">join</span>(<span class="hljs-string">'\t'</span>));
  }

  <span class="hljs-keyword">return</span> dp[n][target];
}

<span class="hljs-comment">/**
 * 分割等和子集（一维DP空间优化解法）
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number[]</span>} <span class="hljs-variable">nums</span> - 正整数数组
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">boolean</span>} - 是否可以分割成两个和相等的子集
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">canPartition_1d</span>(<span class="hljs-params">nums</span>) {
  <span class="hljs-keyword">const</span> sum = nums.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b, <span class="hljs-number">0</span>);
  <span class="hljs-keyword">if</span> (sum % <span class="hljs-number">2</span> !== <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">const</span> target = sum / <span class="hljs-number">2</span>;
  <span class="hljs-comment">// 初始化一维dp数组：dp[j]表示能否凑出和为j</span>
  <span class="hljs-keyword">const</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(target + <span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-literal">false</span>);
  dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 边界条件</span>

  <span class="hljs-comment">// 遍历顺序：先遍历元素，再倒序遍历和</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> num <span class="hljs-keyword">of</span> nums) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = target; j &gt;= num; j--) {
      dp[j] = dp[j] || dp[j - num];
    }
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(
      <span class="hljs-string">`处理完元素<span class="hljs-subst">${num}</span>后，dp数组：`</span>,
      dp.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> (val ? <span class="hljs-string">'true'</span> : <span class="hljs-string">'false'</span>))
    );
  }

  <span class="hljs-keyword">return</span> dp[target];
}

<span class="hljs-comment">// 测试用例</span>
<span class="hljs-keyword">const</span> nums1 = [<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">11</span>, <span class="hljs-number">5</span>];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'二维DP解法：'</span>, <span class="hljs-title function_">canPartition_2d</span>(nums1)); <span class="hljs-comment">// 输出：true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'一维DP解法：'</span>, <span class="hljs-title function_">canPartition_1d</span>(nums1)); <span class="hljs-comment">// 输出：true</span>

<span class="hljs-keyword">const</span> nums2 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'二维DP解法：'</span>, <span class="hljs-title function_">canPartition_2d</span>(nums2)); <span class="hljs-comment">// 输出：false</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'一维DP解法：'</span>, <span class="hljs-title function_">canPartition_1d</span>(nums2)); <span class="hljs-comment">// 输出：false</span>
</code></pre>
<h3 data-id="heading-15">3.3 变形3：最后一块石头的重量II（最小背包剩余容量）</h3>
<p><strong>LeetCode 链接</strong>：<a href="https://link.juejin.cn?target=https%3A%2F%2Fleetcode.cn%2Fproblems%2Flast-stone-weight-ii%2F" target="_blank" title="https://leetcode.cn/problems/last-stone-weight-ii/" ref="nofollow noopener noreferrer">1049. 最后一块石头的重量 II</a></p>
<p><strong>问题描述</strong>：有一堆石头，每块石头的重量都是正整数。每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为x和y，且x ≤ y。那么粉碎的可能结果如下：如果x == y，那么两块石头都会被完全粉碎；如果x != y，那么重量为x的石头会被完全粉碎，而重量为y的石头会变成y - x的重量。最后，最多只会剩下一块石头。返回此石头的最小可能重量。</p>
<p>核心转化：要使最后剩余石头重量最小，需将石头尽可能分成两堆重量接近的石头——两堆重量差越小，剩余重量越小。设总重量为sum，目标是找到一堆石头的最大重量<code>maxWeight</code>（≤ sum/2），则剩余重量为<code>sum - 2*maxWeight</code>。问题转化为：从石头重量数组中选择若干元素，使得其和不超过sum/2的最大值——这是「01背包求最大价值（重量即价值）」的场景（背包容量为sum/2，物品重量和价值均为石头重量）。</p>
<p>最后一块石头的重量II核心表格（空表，后续逐步填充）：</p>





































<table><thead><tr><th>处理阶段\容量j</th><th>0</th><th>1</th><th>2</th><th>...（容量递增）</th><th>target（sum/2）</th></tr></thead><tbody><tr><td>初始状态</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td></tr><tr><td>处理第1块石头</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td></tr><tr><td>处理第2块石头</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td></tr></tbody></table>
<p>表格说明：表格中每个单元格<code>dp[j]</code>代表「容量为j的背包能容纳的最大重量」（一维DP），最终<code>dp[target]</code>即为不超过sum/2的最大子集重量，剩余重量 = sum - 2*dp[target]。</p>
<h4 data-id="heading-16">3.3.1 步骤1：确定dp数组及下标的含义</h4>
<p>定义一维数组<code>dp[j]</code>：表示「容量为j的背包，能容纳的最大重量」（即选若干石头的最大和）。</p>
<p>对应表格维度：仅保留"容量j"这一列维度（j从0到target，target = sum/2向下取整），形成单行表格，每次遍历石头时，滚动更新这一行的数值（覆盖上一行的结果）。</p>
<h4 data-id="heading-17">3.3.2 步骤2：确定递推公式</h4>
<p>对于第i块石头（重量<code>stones[i]</code>，价值也为<code>stones[i]</code>），有两种核心决策：选或不选。</p>
<ol>
<li>
<p><strong>不选第i块石头</strong>：容量为j的最大重量 = 不选当前石头时的最大重量，即<code>dp[j] = dp[j]</code>（保持不变）；</p>
</li>
<li>
<p><strong>选第i块石头</strong>：需保证背包容量j ≥ 第i块石头的重量，此时最大重量 = 容量j-stones[i]的最大重量 + 第i块石头的重量，即<code>dp[j] = dp[j - stones[i]] + stones[i]</code>。</p>
</li>
</ol>
<p>最终递推公式（取两种决策的最大值）：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">if</span> (j &gt;= stones[i]) {
  dp[j] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(dp[j], dp[j - stones[i]] + stones[i]);
} <span class="hljs-keyword">else</span> {
  dp[j] = dp[j]; <span class="hljs-comment">// 容量不足，无法选</span>
}
</code></pre>
<p>简化后（因为容量不足时dp[j]不变）：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = target; j &gt;= stones[i]; j--) {
  dp[j] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(dp[j], dp[j - stones[i]] + stones[i]);
}
</code></pre>
<h4 data-id="heading-18">3.3.3 步骤3：dp数组如何初始化</h4>
<p>初始化逻辑与基础01背包一维DP一致：容量为0时，最大重量为0，因此<code>dp[0] = 0</code>；其他容量的初始值也为0（因为初始无石头可放，最大重量为0），即<code>dp = new Array(target + 1).fill(0)</code>。</p>
<p>初始化后的单行表格：[0,0,0,0,...]（j从0到target）</p>
<p>结合示例理解：假设stones = [2,7,4,1,8,1]，sum = 23，target = Math.floor(23/2) = 11。初始化后的表格：</p>



































<table><thead><tr><th>容量j</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th></tr></thead><tbody><tr><td>初始</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr></tbody></table>
<h4 data-id="heading-19">3.3.4 步骤4：确定遍历顺序（表格填充顺序）</h4>
<p>一维DP的遍历顺序有严格要求，核心是「倒序遍历容量」，对应单行表格的「从右往左填充」：</p>
<ol>
<li>
<p><strong>必须先遍历石头，再遍历容量</strong>：逐个处理每块石头，每次处理时更新整个单行表格（覆盖上一行结果）；</p>
</li>
<li>
<p><strong>容量必须倒序遍历（j从target到stones[i]）</strong>：从最大容量往小容量填充，确保计算<code>dp[j]</code>时，<code>dp[j - stones[i]]</code>仍是上一行（未处理当前石头）的旧值，避免同一石头被多次选择。</p>
</li>
</ol>
<h4 data-id="heading-20">3.3.5 步骤5：打印dp数组（验证）</h4>
<p>通过打印单行表格的滚动更新过程，验证填充规则的正确性。仍用测试用例 <code>stones = [2,7,4,1,8,1]</code>、<code>sum = 23</code>、<code>target = 11</code>，演示一维DP数组（单行表格）的填充变化：</p>
<ol>
<li>
<p><strong>初始状态</strong>：dp = [0,0,0,0,0,0,0,0,0,0,0,0]</p>
</li>
<li>
<p><strong>处理石头1（w=2），j从11到2倒序</strong>：更新后：dp = [0,0,2,2,2,2,2,2,2,2,2,2]</p>
<ul>
<li>j=11：dp[11] = max(0, dp[9]+2) = max(0,0+2)=2；</li>
<li>j=10：dp[10] = max(0, dp[8]+2)=2；</li>
<li>...（j=2到9同理）；</li>
<li>j=2：dp[2] = max(0, dp[0]+2)=2；</li>
</ul>
</li>
<li>
<p><strong>处理石头2（w=7），j从11到7倒序</strong>：更新后：dp = [0,0,2,2,2,2,2,7,7,9,9,9]</p>
<ul>
<li>j=11：max(2, dp[4]+7)=max(2,2+7)=9；</li>
<li>j=10：max(2, dp[3]+7)=max(2,2+7)=9；</li>
<li>j=9：max(2, dp[2]+7)=max(2,2+7)=9；</li>
<li>j=8：max(2, dp[1]+7)=max(2,0+7)=7；</li>
<li>j=7：max(2, dp[0]+7)=max(2,0+7)=7；</li>
</ul>
</li>
<li>
<p><strong>处理石头3（w=4），j从11到4倒序</strong>：更新后：dp = [0,0,2,2,4,4,6,7,7,9,9,11]</p>
<ul>
<li>j=11：max(9, dp[7]+4)=max(9,7+4)=11；</li>
<li>j=10：max(9, dp[6]+4)=max(9,2+4)=9；</li>
<li>j=9：max(9, dp[5]+4)=max(9,2+4)=9；</li>
<li>j=8：max(7, dp[4]+4)=max(7,2+4)=7；</li>
<li>j=7：max(7, dp[3]+4)=max(7,2+4)=7；</li>
<li>j=6：max(2, dp[2]+4)=max(2,2+4)=6；</li>
<li>j=5：max(2, dp[1]+4)=max(2,0+4)=4；</li>
<li>j=4：max(2, dp[0]+4)=max(2,0+4)=4；</li>
</ul>
</li>
<li>
<p><strong>处理石头4（w=1），j从11到1倒序</strong>：更新后：dp = [0,1,2,3,4,5,6,7,8,9,10,11]</p>
<ul>
<li>j=11：max(11, dp[10]+1)=max(11,9+1)=11；</li>
<li>j=10：max(9, dp[9]+1)=max(9,9+1)=10；</li>
<li>...（其他位置类似更新）；</li>
</ul>
</li>
<li>
<p><strong>处理石头5（w=8），j从11到8倒序</strong>：更新后：dp = [0,1,2,3,4,5,6,7,8,9,10,11]</p>
<ul>
<li>j=11：max(11, dp[3]+8)=max(11,3+8)=11；</li>
<li>j=10：max(10, dp[2]+8)=max(10,2+8)=10；</li>
<li>j=9：max(9, dp[1]+8)=max(9,1+8)=9；</li>
<li>j=8：max(8, dp[0]+8)=max(8,0+8)=8；</li>
</ul>
</li>
<li>
<p><strong>处理石头6（w=1），j从11到1倒序</strong>：最终：dp = [0,1,2,3,4,5,6,7,8,9,10,11]</p>
</li>
</ol>
<p>最终单行表格<code>dp[11] = 11</code>，剩余重量 = 23 - 2*11 = 1，与预期结果一致。</p>
<h4 data-id="heading-21">3.3.6 最后一块石头的重量II完整代码（一维DP）</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">/**
 * 最后一块石头的重量II（一维DP解法）
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number[]</span>} <span class="hljs-variable">stones</span> - 石头重量数组
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">number</span>} - 最后剩余石头的最小可能重量
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">lastStoneWeightII</span>(<span class="hljs-params">stones</span>) {
  <span class="hljs-keyword">const</span> sum = stones.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b, <span class="hljs-number">0</span>);
  <span class="hljs-keyword">const</span> target = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(sum / <span class="hljs-number">2</span>);
  <span class="hljs-comment">// 初始化一维dp数组：dp[j]表示容量为j的背包能容纳的最大重量</span>
  <span class="hljs-keyword">const</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(target + <span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>);

  <span class="hljs-comment">// 遍历顺序：先遍历石头，再倒序遍历容量</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> stone <span class="hljs-keyword">of</span> stones) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = target; j &gt;= stone; j--) {
      dp[j] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(dp[j], dp[j - stone] + stone);
    }
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`处理完石头<span class="hljs-subst">${stone}</span>后，dp数组：`</span>, [...dp]);
  }

  <span class="hljs-comment">// 剩余重量 = 总重量 - 2*最大子集重量</span>
  <span class="hljs-keyword">return</span> sum - <span class="hljs-number">2</span> * dp[target];
}

<span class="hljs-comment">// 测试用例</span>
<span class="hljs-keyword">const</span> stones = [<span class="hljs-number">2</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'最后剩余石头的最小重量：'</span>, <span class="hljs-title function_">lastStoneWeightII</span>(stones)); <span class="hljs-comment">// 输出：1</span>
</code></pre>
<h3 data-id="heading-22">3.4 变形4：一和零（二维背包容量）</h3>
<p><strong>LeetCode 链接</strong>：<a href="https://link.juejin.cn?target=https%3A%2F%2Fleetcode.cn%2Fproblems%2Fones-and-zeroes%2F" target="_blank" title="https://leetcode.cn/problems/ones-and-zeroes/" ref="nofollow noopener noreferrer">474. 一和零</a></p>
<p><strong>问题描述</strong>：给你一个二进制字符串数组<code>strs</code>和两个整数<code>m</code>和<code>n</code>。请你找出并返回<code>strs</code>的最大子集的长度，该子集中最多有<code>m</code>个0和<code>n</code>个1。</p>
<p>核心转化：每个字符串是一个"物品"，选择该物品会消耗"0的数量"和"1的数量"两种容量，目标是在两种容量均不超过限制（m、n）的前提下，选择最多的物品——这是「二维容量01背包求最大物品数」的场景（背包有两个维度的容量限制，价值为1，求最大价值即最大物品数）。</p>
<p>一和零问题核心表格（空表，后续逐步填充）：</p>













































<table><thead><tr><th>0的数量\1的数量j</th><th>0</th><th>1</th><th>2</th><th>...（1的数量递增）</th><th>n（最大1的数量）</th></tr></thead><tbody><tr><td>0（0的数量为0）</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td></tr><tr><td>1（0的数量为1）</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td></tr><tr><td>...（0的数量递增）</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td></tr><tr><td>m（最大0的数量）</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充（最终答案：最多字符串数量）</td></tr></tbody></table>
<p>表格说明：表格中每个单元格<code>dp[i][j]</code>代表「最多使用i个0和j个1时，能选择的最大字符串数量」，我们的目标是按规则填充表格，最终右下角<code>dp[m][n]</code>即为一和零问题的答案。</p>
<h4 data-id="heading-23">3.4.1 步骤1：确定dp数组及下标的含义</h4>
<p>定义二维数组<code>dp[i][j]</code>：表示「最多用i个0和j个1能选择的最大字符串数量」。</p>
<p>对应表格维度：i（行）表示0的数量（从0到m，0代表0个0），j（列）表示1的数量（从0到n，0代表0个1），表格共m+1行、n+1列。</p>
<h4 data-id="heading-24">3.4.2 步骤2：确定递推公式</h4>
<p>对于每个字符串（含zero个0、one个1），有两种核心决策：选或不选。</p>
<ol>
<li>
<p><strong>不选当前字符串</strong>：最多用i个0和j个1的最大字符串数量 = 不选当前字符串时的最大数量，即<code>dp[i][j] = dp[i][j]</code>（保持不变）；</p>
</li>
<li>
<p><strong>选当前字符串</strong>：需保证i ≥ zero且j ≥ one（0和1的数量都足够），此时最大数量 = 用i-zero个0和j-one个1的最大数量 + 1（当前字符串），即<code>dp[i][j] = dp[i - zero][j - one] + 1</code>。</p>
</li>
</ol>
<p>最终递推公式（取两种决策的最大值）：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">if</span> (i &gt;= zero &amp;&amp; j &gt;= one) {
  dp[i][j] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(dp[i][j], dp[i - zero][j - one] + <span class="hljs-number">1</span>);
} <span class="hljs-keyword">else</span> {
  dp[i][j] = dp[i][j]; <span class="hljs-comment">// 容量不足，无法选</span>
}
</code></pre>
<p>简化后（因为容量不足时dp[i][j]不变，且使用倒序遍历）：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = m; i &gt;= zero; i--) {
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = n; j &gt;= one; j--) {
    dp[i][j] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(dp[i][j], dp[i - zero][j - one] + <span class="hljs-number">1</span>);
  }
}
</code></pre>
<h4 data-id="heading-25">3.4.3 步骤3：dp数组如何初始化</h4>
<p>初始化逻辑：初始无字符串可选，无论有多少0和1，最大字符串数量都为0，因此<code>dp[i][j] = 0</code>（所有单元格初始化为0），即<code>dp = new Array(m+1).fill(0).map(() =&gt; new Array(n+1).fill(0))</code>。</p>
<p>初始化后的表格（所有单元格为0）：</p>













































<table><thead><tr><th>0的数量\1的数量j</th><th>0</th><th>1</th><th>2</th><th>...</th><th>n</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>...</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>m</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr></tbody></table>
<p>结合示例理解：假设strs = ["10","0001","111001","1","0"]，m = 5，n = 3。初始化后的表格（5+1行，3+1列）：</p>






















































<table><thead><tr><th>0的数量\1的数量j</th><th>0</th><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>2</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>3</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>4</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>5</td><td>0</td><td>0</td><td>0</td><td>0</td></tr></tbody></table>
<h4 data-id="heading-26">3.4.4 步骤4：确定遍历顺序（表格填充顺序）</h4>
<p>二维容量01背包的遍历顺序有严格要求：</p>
<ol>
<li>
<p><strong>必须先遍历字符串（物品），再遍历0的数量，最后遍历1的数量</strong>：逐个处理每个字符串，每次处理时更新整个二维表格；</p>
</li>
<li>
<p><strong>0和1的数量都必须倒序遍历</strong>：</p>
<ul>
<li>0的数量倒序遍历（i从m到zero）：确保计算<code>dp[i][j]</code>时，<code>dp[i - zero][j - one]</code>仍是上一轮（未处理当前字符串）的旧值；</li>
<li>1的数量倒序遍历（j从n到one）：同样确保依赖的单元格是旧值。</li>
</ul>
</li>
</ol>
<p>倒序遍历避免同一字符串被多次选择，完美契合01背包「每个物品选一次」的规则。</p>
<h4 data-id="heading-27">3.4.5 步骤5：打印dp数组（验证）</h4>
<p>以示例<code>strs = ["10","0001","111001","1","0"]</code>、<code>m = 5</code>、<code>n = 3</code>为例，逐步填充表格验证逻辑：</p>
<ol>
<li>
<p><strong>处理字符串1（"10"：zero=1, one=1）</strong>：</p>
<ul>
<li>更新dp[1][1]到dp[5][3]范围内所有满足i≥1且j≥1的位置</li>
<li>dp[1][1] = max(0, dp[0][0]+1) = max(0,0+1) = 1</li>
<li>dp[2][2] = max(0, dp[1][1]+1) = max(0,1+1) = 2</li>
<li>...（其他位置类似）</li>
</ul>
</li>
<li>
<p><strong>处理字符串2（"0001"：zero=3, one=1）</strong>：</p>
<ul>
<li>更新dp[3][1]到dp[5][3]范围内所有满足i≥3且j≥1的位置</li>
<li>dp[3][1] = max(dp[3][1], dp[0][0]+1) = max(0,0+1) = 1</li>
<li>dp[4][2] = max(dp[4][2], dp[1][1]+1) = max(0,1+1) = 2</li>
<li>...（其他位置类似）</li>
</ul>
</li>
<li>
<p><strong>处理字符串3（"111001"：zero=2, one=4）</strong>：</p>
<ul>
<li>由于one=4 &gt; n=3，无法选择此字符串，dp数组不变</li>
</ul>
</li>
<li>
<p><strong>处理字符串4（"1"：zero=0, one=1）</strong>：</p>
<ul>
<li>更新dp[0][1]到dp[5][3]范围内所有满足j≥1的位置</li>
<li>dp[0][1] = max(0, dp[0][0]+1) = max(0,0+1) = 1</li>
<li>dp[1][2] = max(dp[1][2], dp[1][1]+1) = max(0,1+1) = 2</li>
<li>...（其他位置类似）</li>
</ul>
</li>
<li>
<p><strong>处理字符串5（"0"：zero=1, one=0）</strong>：</p>
<ul>
<li>更新dp[1][0]到dp[5][3]范围内所有满足i≥1的位置</li>
<li>dp[1][0] = max(0, dp[0][0]+1) = max(0,0+1) = 1</li>
<li>dp[2][1] = max(dp[2][1], dp[1][1]+1) = max(0,1+1) = 2</li>
<li>...（其他位置类似）</li>
</ul>
</li>
</ol>
<p>最终填充完成的表格（简化展示关键部分）：</p>






















































<table><thead><tr><th>0的数量\1的数量j</th><th>0</th><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>1</td><td>1</td><td>2</td><td>2</td><td>2</td></tr><tr><td>2</td><td>1</td><td>2</td><td>3</td><td>3</td></tr><tr><td>3</td><td>1</td><td>2</td><td>3</td><td>3</td></tr><tr><td>4</td><td>1</td><td>2</td><td>3</td><td>4</td></tr><tr><td>5</td><td>1</td><td>2</td><td>3</td><td>4</td></tr></tbody></table>
<p>表格右下角<code>dp[5][3] = 4</code>，即该示例的最大子集长度为4，与预期结果一致。</p>
<h4 data-id="heading-28">3.4.6 一和零完整代码（二维DP）</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">/**
 * 一和零（二维DP解法）
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string[]</span>} <span class="hljs-variable">strs</span> - 二进制字符串数组
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number</span>} <span class="hljs-variable">m</span> - 最多允许的0的数量
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number</span>} <span class="hljs-variable">n</span> - 最多允许的1的数量
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">number</span>} - 最大子集长度
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">findMaxForm</span>(<span class="hljs-params">strs, m, n</span>) {
  <span class="hljs-comment">// 初始化二维dp数组：dp[i][j]表示i个0和j个1能选的最大字符串数</span>
  <span class="hljs-keyword">const</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(m + <span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">map</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(n + <span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>));

  <span class="hljs-comment">// 遍历每个字符串（物品）</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> str <span class="hljs-keyword">of</span> strs) {
    <span class="hljs-comment">// 统计当前字符串的0和1的数量</span>
    <span class="hljs-keyword">let</span> zero = <span class="hljs-number">0</span>,
      one = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> c <span class="hljs-keyword">of</span> str) {
      c === <span class="hljs-string">'0'</span> ? zero++ : one++;
    }

    <span class="hljs-comment">// 倒序遍历0的数量，再倒序遍历1的数量（避免重复选择）</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = m; i &gt;= zero; i--) {
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = n; j &gt;= one; j--) {
        dp[i][j] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(dp[i][j], dp[i - zero][j - one] + <span class="hljs-number">1</span>);
      }
    }

    <span class="hljs-comment">// 打印每次处理后的dp数组（简化打印，只打印部分关键行）</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`处理完字符串"<span class="hljs-subst">${str}</span>"后，dp数组（前5行前5列）：`</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(m, <span class="hljs-number">5</span>); i++) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dp[i].<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(n, <span class="hljs-number">5</span>)).<span class="hljs-title function_">join</span>(<span class="hljs-string">'\t'</span>));
    }
  }

  <span class="hljs-keyword">return</span> dp[m][n];
}

<span class="hljs-comment">// 测试用例</span>
<span class="hljs-keyword">const</span> strs = [<span class="hljs-string">'10'</span>, <span class="hljs-string">'0001'</span>, <span class="hljs-string">'111001'</span>, <span class="hljs-string">'1'</span>, <span class="hljs-string">'0'</span>];
<span class="hljs-keyword">const</span> m = <span class="hljs-number">5</span>,
  n = <span class="hljs-number">3</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'最大子集长度：'</span>, <span class="hljs-title function_">findMaxForm</span>(strs, m, n)); <span class="hljs-comment">// 输出：4</span>
</code></pre>
<h2 data-id="heading-29">四、01背包问题总结</h2>
<p>01背包的核心是「选或不选」的二选一决策，所有变形都围绕这一核心逻辑，通过转化「物品」「容量」「目标」的含义，适配不同的实际场景。掌握以下关键点，可轻松破解所有01背包相关问题：</p>
<ol>
<li>
<p><strong>表格可视化核心</strong>：DP解题的本质是填充表格，先明确表格形态（dp数组含义），再按规则填充，表格填完即得答案；</p>
</li>
<li>
<p><strong>5步万能钥匙</strong>：确定dp含义→递推公式→初始化→遍历顺序→验证，这是所有DP问题的通用拆解思路，尤其适用于背包问题；</p>
</li>
<li>
<p><strong>空间优化技巧</strong>：二维DP可通过「倒序遍历容量」优化为一维DP，核心是复用数组空间，避免重复选择物品；</p>
</li>
<li>
<p><strong>变形转化逻辑</strong>：无论场景如何变化，只要每个物品最多选一次，都可转化为01背包模型——关键是找到「物品」（待选择的元素/字符串等）、「容量」（限制条件，如重量、和、0/1数量等）、「目标」（最大价值、可行性、方案数等）。</p>
</li>
</ol>
<p>通过基础模型+变形练习，熟练掌握表格填充逻辑和5步拆解方法，就能将复杂的DP问题转化为有序的表格填充过程，彻底攻克01背包这一DP核心模型。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[🔥Vue3 动态组件‘component’全解析]]></title>    <link>https://juejin.cn/post/7591697558377955370</link>    <guid>https://juejin.cn/post/7591697558377955370</guid>    <pubDate>2026-01-06T02:48:00.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7591697558377955370" data-draft-id="7591730714141179946" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="🔥Vue3 动态组件‘component’全解析"/> <meta itemprop="keywords" content="前端,Vue.js,面试"/> <meta itemprop="datePublished" content="2026-01-06T02:48:00.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="不想秃头的程序员"/> <meta itemprop="url" content="https://juejin.cn/user/2754702534251820"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            🔥Vue3 动态组件‘component’全解析
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2754702534251820/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    不想秃头的程序员
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-06T02:48:00.000Z" title="Tue Jan 06 2026 02:48:00 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-06
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在 Vue3 开发中，我们经常会遇到需要根据不同状态切换不同组件的场景 —— 比如表单的步骤切换、Tab 标签页、权限控制下的组件渲染等。如果用 <code>v-if/v-else</code> 逐个判断，代码会变得冗余且难以维护。而 Vue 提供的<strong>动态组件</strong>特性，能让我们以更优雅的方式实现组件的动态切换，大幅提升代码的灵活性和可维护性。</p>
<p>本文将从基础到进阶，全面讲解 Vue3 中动态组件的使用方法、核心特性、避坑指南和实战场景，帮助你彻底掌握这一高频使用技巧。</p>
<h2 data-id="heading-0">📚 什么是动态组件？</h2>
<p>动态组件是 Vue 内置的一个核心功能，通过 <code>&lt;component&gt;</code> 内置组件和 <code>is</code> 属性，我们可以动态绑定并渲染不同的组件，无需手动编写大量的条件判断。</p>
<p>简单来说：<strong>你只需要告诉 Vue 要渲染哪个组件，它就会自动帮你完成组件的切换</strong>。</p>
<h2 data-id="heading-1">🚀 基础用法：快速实现组件切换</h2>
<h3 data-id="heading-2">1. 基本语法</h3>
<p>动态组件的核心是 <code>&lt;component&gt;</code> 标签和 <code>is</code> 属性：</p>
<pre><code class="hljs language-js" lang="js">&lt;template&gt;
  &lt;!-- 动态组件：is 属性绑定要渲染的组件 --&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">"currentComponent"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span></span>
&lt;/template&gt;

<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">import</span> { ref } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
<span class="hljs-comment">// 导入需要切换的组件</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">ComponentA</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./ComponentA.vue'</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">ComponentB</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./ComponentB.vue'</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">ComponentC</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./ComponentC.vue'</span>

<span class="hljs-comment">// 定义当前要渲染的组件</span>
<span class="hljs-keyword">const</span> currentComponent = <span class="hljs-title function_">ref</span>(<span class="hljs-string">'ComponentA'</span>)
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
</code></pre>
<h3 data-id="heading-3">2. 完整示例：Tab 标签页</h3>
<p>下面实现一个最常见的 Tab 切换场景，直观感受动态组件的用法：</p>
<pre><code class="hljs language-js" lang="js">&lt;template&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"tab-container"</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- Tab 切换按钮 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"tab-buttons"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> 
        <span class="hljs-attr">v-for</span>=<span class="hljs-string">"tab in tabs"</span> 
        <span class="hljs-attr">:key</span>=<span class="hljs-string">"tab.name"</span>
        <span class="hljs-attr">:class</span>=<span class="hljs-string">"{ active: currentTab === tab.name }"</span>
        @<span class="hljs-attr">click</span>=<span class="hljs-string">"currentTab = tab.name"</span>
      &gt;</span>
        {{ tab.label }}
      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- 动态组件核心 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"tab-content"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">"currentTabComponent"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
&lt;/template&gt;

<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">import</span> { ref, computed } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
<span class="hljs-comment">// 导入子组件</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Home</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./Home.vue'</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Profile</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./Profile.vue'</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Settings</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./Settings.vue'</span>

<span class="hljs-comment">// 定义 Tab 配置</span>
<span class="hljs-keyword">const</span> tabs = [
  { <span class="hljs-attr">name</span>: <span class="hljs-string">'Home'</span>, <span class="hljs-attr">label</span>: <span class="hljs-string">'首页'</span> },
  { <span class="hljs-attr">name</span>: <span class="hljs-string">'Profile'</span>, <span class="hljs-attr">label</span>: <span class="hljs-string">'个人中心'</span> },
  { <span class="hljs-attr">name</span>: <span class="hljs-string">'Settings'</span>, <span class="hljs-attr">label</span>: <span class="hljs-string">'设置'</span> }
]

<span class="hljs-comment">// 当前激活的 Tab</span>
<span class="hljs-keyword">const</span> currentTab = <span class="hljs-title function_">ref</span>(<span class="hljs-string">'Home'</span>)

<span class="hljs-comment">// 计算属性：根据当前 Tab 匹配对应组件</span>
<span class="hljs-keyword">const</span> currentTabComponent = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">switch</span> (currentTab.<span class="hljs-property">value</span>) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'Home'</span>: <span class="hljs-keyword">return</span> <span class="hljs-title class_">Home</span>
    <span class="hljs-keyword">case</span> <span class="hljs-string">'Profile'</span>: <span class="hljs-keyword">return</span> <span class="hljs-title class_">Profile</span>
    <span class="hljs-keyword">case</span> <span class="hljs-string">'Settings'</span>: <span class="hljs-keyword">return</span> <span class="hljs-title class_">Settings</span>
    <span class="hljs-attr">default</span>: <span class="hljs-keyword">return</span> <span class="hljs-title class_">Home</span>
  }
})
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>

<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="css">
<span class="hljs-selector-class">.tab-container</span> {
  <span class="hljs-attribute">width</span>: <span class="hljs-number">400px</span>;
  <span class="hljs-attribute">margin</span>: <span class="hljs-number">20px</span> auto;
}
<span class="hljs-selector-class">.tab-buttons</span> {
  <span class="hljs-attribute">display</span>: flex;
  <span class="hljs-attribute">gap</span>: <span class="hljs-number">4px</span>;
}
<span class="hljs-selector-class">.tab-buttons</span> <span class="hljs-selector-tag">button</span> {
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">8px</span> <span class="hljs-number">16px</span>;
  <span class="hljs-attribute">border</span>: none;
  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">4px</span> <span class="hljs-number">4px</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>;
  <span class="hljs-attribute">cursor</span>: pointer;
  <span class="hljs-attribute">background</span>: <span class="hljs-number">#f5f5f5</span>;
}
<span class="hljs-selector-class">.tab-buttons</span> <span class="hljs-selector-tag">button</span><span class="hljs-selector-class">.active</span> {
  <span class="hljs-attribute">background</span>: <span class="hljs-number">#409eff</span>;
  <span class="hljs-attribute">color</span>: white;
}
<span class="hljs-selector-class">.tab-content</span> {
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;
  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#e6e6e6</span>;
  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">0</span> <span class="hljs-number">4px</span> <span class="hljs-number">4px</span> <span class="hljs-number">4px</span>;
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span>
</code></pre>
<p><strong>关键点说明</strong>：</p>
<ul>
<li><code>is</code> 属性可以绑定：组件的导入对象、组件的注册名称（字符串）、异步组件；</li>
<li>切换 <code>currentTab</code> 时，<code>&lt;component&gt;</code> 会自动渲染对应的组件，无需手动控制。</li>
</ul>
<h2 data-id="heading-4">⚡ 进阶特性：缓存、传参、异步加载</h2>
<h3 data-id="heading-5">1. 组件缓存：keep-alive 避免重复渲染</h3>
<p>默认情况下，动态组件切换时，旧组件会被销毁，新组件会重新创建。如果组件包含表单输入、请求数据等逻辑，切换时会丢失状态，且重复渲染影响性能。</p>
<p>使用 <code>&lt;keep-alive&gt;</code> 包裹动态组件，可以缓存未激活的组件，保留其状态：</p>
<pre><code class="hljs language-js" lang="js">&lt;template&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"tab-container"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"tab-buttons"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> 
        <span class="hljs-attr">v-for</span>=<span class="hljs-string">"tab in tabs"</span> 
        <span class="hljs-attr">:key</span>=<span class="hljs-string">"tab.name"</span>
        <span class="hljs-attr">:class</span>=<span class="hljs-string">"{ active: currentTab === tab.name }"</span>
        @<span class="hljs-attr">click</span>=<span class="hljs-string">"currentTab = tab.name"</span>
      &gt;</span>
        {{ tab.label }}
      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- 使用 keep-alive 缓存组件 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"tab-content"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">"currentTabComponent"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
&lt;/template&gt;
</code></pre>
<p><strong>keep-alive 高级用法</strong>：</p>
<ul>
<li><code>include</code>：仅缓存指定名称的组件（需组件定义 <code>name</code> 属性）；</li>
<li><code>exclude</code>：排除不需要缓存的组件；</li>
<li><code>max</code>：最大缓存数量，超出则销毁最久未使用的组件。</li>
</ul>
<pre><code class="hljs language-js" lang="js">&lt;!-- 仅缓存 <span class="hljs-title class_">Home</span> 和 <span class="hljs-title class_">Profile</span> 组件 --&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span> <span class="hljs-attr">include</span>=<span class="hljs-string">"Home,Profile"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">"currentTabComponent"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span></span>

&lt;!-- 排除 <span class="hljs-title class_">Settings</span> 组件 --&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span> <span class="hljs-attr">exclude</span>=<span class="hljs-string">"Settings"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">"currentTabComponent"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span></span>

&lt;!-- 最多缓存 <span class="hljs-number">2</span> 个组件 --&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span> <span class="hljs-attr">:max</span>=<span class="hljs-string">"2"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">"currentTabComponent"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span></span>
</code></pre>
<h3 data-id="heading-6">2. 组件传参：向动态组件传递 props / 事件</h3>
<p>动态组件和普通组件一样，可以传递 props、绑定事件：</p>
<pre><code class="hljs language-js" lang="js">&lt;template&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">component</span> 
    <span class="hljs-attr">:is</span>=<span class="hljs-string">"currentComponent"</span>
    &lt;!<span class="hljs-attr">--</span> <span class="hljs-attr">传递</span> <span class="hljs-attr">props</span> <span class="hljs-attr">--</span>&gt;</span>
    :user-id="userId"
    :title="pageTitle"
    <span class="hljs-comment">&lt;!-- 绑定事件 --&gt;</span>
    @submit="handleSubmit"
    @cancel="handleCancel"
  &gt;<span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span></span>
&lt;/template&gt;

<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">import</span> { ref } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">FormA</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./FormA.vue'</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">FormB</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./FormB.vue'</span>

<span class="hljs-keyword">const</span> currentComponent = <span class="hljs-title function_">ref</span>(<span class="hljs-title class_">FormA</span>)
<span class="hljs-keyword">const</span> userId = <span class="hljs-title function_">ref</span>(<span class="hljs-number">1001</span>)
<span class="hljs-keyword">const</span> pageTitle = <span class="hljs-title function_">ref</span>(<span class="hljs-string">'用户表单'</span>)

<span class="hljs-keyword">const</span> <span class="hljs-title function_">handleSubmit</span> = (<span class="hljs-params">data</span>) =&gt; {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'提交数据：'</span>, data)
}
<span class="hljs-keyword">const</span> <span class="hljs-title function_">handleCancel</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'取消操作'</span>)
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
</code></pre>
<p>子组件接收 props / 事件：</p>
<pre><code class="hljs language-js" lang="js">&lt;!-- <span class="hljs-title class_">FormA</span>.<span class="hljs-property">vue</span> --&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>{{ title }}<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>用户ID：{{ userId }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"$emit('submit', { id: userId })"</span>&gt;</span>提交<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"$emit('cancel')"</span>&gt;</span>取消<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span>

<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-title function_">defineProps</span>({
  <span class="hljs-attr">userId</span>: <span class="hljs-title class_">Number</span>,
  <span class="hljs-attr">title</span>: <span class="hljs-title class_">String</span>
})
<span class="hljs-title function_">defineEmits</span>([<span class="hljs-string">'submit'</span>, <span class="hljs-string">'cancel'</span>])
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
</code></pre>
<h3 data-id="heading-7">3. 异步加载：动态导入组件（按需加载）</h3>
<p>对于大型应用，为了减小首屏体积，我们可以结合 Vue 的异步组件和动态组件，实现组件的按需加载：</p>
<pre><code class="hljs language-js" lang="js">&lt;template&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">"asyncComponent"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span></span>
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"loadComponent"</span>&gt;</span>加载异步组件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
&lt;/template&gt;

<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">import</span> { ref } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>

<span class="hljs-comment">// 初始为空</span>
<span class="hljs-keyword">const</span> asyncComponent = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>)

<span class="hljs-comment">// 动态导入组件</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">loadComponent</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-comment">// 异步导入 + 按需加载</span>
  <span class="hljs-keyword">const</span> <span class="hljs-title class_">AsyncComponent</span> = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'./AsyncComponent.vue'</span>)
  asyncComponent.<span class="hljs-property">value</span> = <span class="hljs-title class_">AsyncComponent</span>.<span class="hljs-property">default</span>
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
</code></pre>
<p><strong>更优雅的写法</strong>：</p>
<pre><code class="hljs language-js" lang="js">&lt;script setup&gt;
<span class="hljs-keyword">import</span> { ref, defineAsyncComponent } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>

<span class="hljs-comment">// 定义异步组件</span>
<span class="hljs-keyword">const</span> <span class="hljs-title class_">AsyncComponentA</span> = <span class="hljs-title function_">defineAsyncComponent</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'./AsyncComponentA.vue'</span>))
<span class="hljs-keyword">const</span> <span class="hljs-title class_">AsyncComponentB</span> = <span class="hljs-title function_">defineAsyncComponent</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'./AsyncComponentB.vue'</span>))

<span class="hljs-keyword">const</span> currentAsyncComponent = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>)

<span class="hljs-comment">// 切换异步组件</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">switchComponent</span> = (<span class="hljs-params">type</span>) =&gt; {
  currentAsyncComponent.<span class="hljs-property">value</span> = type === <span class="hljs-string">'A'</span> ? <span class="hljs-title class_">AsyncComponentA</span> : <span class="hljs-title class_">AsyncComponentB</span>
}
&lt;/script&gt;
</code></pre>
<h3 data-id="heading-8">4. 生命周期：缓存组件的激活 / 失活钩子</h3>
<p>被 <code>&lt;keep-alive&gt;</code> 缓存的组件，不会触发 <code>mounted</code>/<code>unmounted</code>，而是触发 <code>activated</code>（激活）和 <code>deactivated</code>（失活）钩子：</p>
<pre><code class="hljs language-js" lang="js">&lt;!-- <span class="hljs-title class_">Home</span>.<span class="hljs-property">vue</span> --&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">import</span> { onMounted, onActivated, onDeactivated } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>

<span class="hljs-title function_">onMounted</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Home 组件首次挂载'</span>)
})

<span class="hljs-title function_">onActivated</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Home 组件被激活（切换回来）'</span>)
})

<span class="hljs-title function_">onDeactivated</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Home 组件被失活（切换出去）'</span>)
})
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
</code></pre>
<h2 data-id="heading-9">🚨 常见坑点与解决方案</h2>
<h3 data-id="heading-10">1. 组件切换后状态丢失</h3>
<p><strong>问题</strong>：切换动态组件时，表单输入、滚动位置等状态丢失。<strong>解决方案</strong>：使用 <code>&lt;keep-alive&gt;</code> 缓存组件，或手动保存 / 恢复状态。</p>
<h3 data-id="heading-11">2. keep-alive 不生效</h3>
<p><strong>问题</strong>：使用 <code>keep-alive</code> 后组件仍重新渲染。<strong>排查方向</strong>：</p>
<ul>
<li>组件是否定义了 <code>name</code> 属性（<code>include/exclude</code> 依赖 <code>name</code>）；</li>
<li><code>is</code> 属性绑定的是否是组件对象（而非字符串）；</li>
<li>是否在 <code>keep-alive</code> 内部使用了 <code>v-if</code>（可能导致组件卸载）。</li>
</ul>
<h3 data-id="heading-12">3. 异步组件加载失败</h3>
<p><strong>问题</strong>：动态导入组件时提示找不到模块。<strong>解决方案</strong>：</p>
<ul>
<li>检查导入路径是否正确；</li>
<li>确保异步组件返回的是默认导出（<code>default</code>）；</li>
<li>结合 <code>Suspense</code> 处理加载状态：</li>
</ul>
<pre><code class="hljs language-js" lang="js">&lt;template&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">default</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">"currentAsyncComponent"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">fallback</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>加载中...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span></span>
&lt;/template&gt;
</code></pre>
<h3 data-id="heading-13">4. 动态组件传参不生效</h3>
<p><strong>问题</strong>：向动态组件传递的 props 未生效。<strong>解决方案</strong>：</p>
<ul>
<li>确保子组件通过 <code>defineProps</code> 声明了对应的 props；</li>
<li>检查 props 名称是否大小写一致（Vue 支持 kebab-case 和 camelCase 转换）；</li>
<li>避免传递非响应式数据（需用 <code>ref</code>/<code>reactive</code> 包裹）。</li>
</ul>
<h2 data-id="heading-14">🎯 实战场景：动态组件的典型应用</h2>
<h3 data-id="heading-15">1. 权限控制组件</h3>
<p>根据用户角色动态渲染不同组件：</p>
<pre><code class="hljs language-js" lang="js">&lt;template&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">"authComponent"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span></span>
&lt;/template&gt;

<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">import</span> { ref, computed } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">AdminPanel</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./AdminPanel.vue'</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">UserPanel</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./UserPanel.vue'</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">GuestPanel</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./GuestPanel.vue'</span>

<span class="hljs-comment">// 模拟用户角色</span>
<span class="hljs-keyword">const</span> userRole = <span class="hljs-title function_">ref</span>(<span class="hljs-string">'admin'</span>) <span class="hljs-comment">// admin / user / guest</span>

<span class="hljs-comment">// 根据角色匹配组件</span>
<span class="hljs-keyword">const</span> authComponent = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">switch</span> (userRole.<span class="hljs-property">value</span>) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'admin'</span>: <span class="hljs-keyword">return</span> <span class="hljs-title class_">AdminPanel</span>
    <span class="hljs-keyword">case</span> <span class="hljs-string">'user'</span>: <span class="hljs-keyword">return</span> <span class="hljs-title class_">UserPanel</span>
    <span class="hljs-keyword">case</span> <span class="hljs-string">'guest'</span>: <span class="hljs-keyword">return</span> <span class="hljs-title class_">GuestPanel</span>
    <span class="hljs-attr">default</span>: <span class="hljs-keyword">return</span> <span class="hljs-title class_">GuestPanel</span>
  }
})
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
</code></pre>
<h3 data-id="heading-16">2. 表单步骤切换</h3>
<p>多步骤表单，根据当前步骤渲染不同表单组件：</p>
<pre><code class="hljs language-js" lang="js">&lt;template&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"form-steps"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"steps"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">"{ active: step === 1 }"</span>&gt;</span>基本信息<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">"{ active: step === 2 }"</span>&gt;</span>联系方式<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">"{ active: step === 3 }"</span>&gt;</span>提交确认<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">component</span> 
        <span class="hljs-attr">:is</span>=<span class="hljs-string">"currentFormComponent"</span>
        <span class="hljs-attr">:form-data</span>=<span class="hljs-string">"formData"</span>
        @<span class="hljs-attr">next</span>=<span class="hljs-string">"step++"</span>
        @<span class="hljs-attr">prev</span>=<span class="hljs-string">"step--"</span>
        @<span class="hljs-attr">submit</span>=<span class="hljs-string">"handleSubmit"</span>
      &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
&lt;/template&gt;

<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">import</span> { ref, computed, reactive } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Step1</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./Step1.vue'</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Step2</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./Step2.vue'</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Step3</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./Step3.vue'</span>

<span class="hljs-keyword">const</span> step = <span class="hljs-title function_">ref</span>(<span class="hljs-number">1</span>)
<span class="hljs-keyword">const</span> formData = <span class="hljs-title function_">reactive</span>({
  <span class="hljs-attr">name</span>: <span class="hljs-string">''</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-string">''</span>,
  <span class="hljs-attr">phone</span>: <span class="hljs-string">''</span>,
  <span class="hljs-attr">email</span>: <span class="hljs-string">''</span>
})

<span class="hljs-keyword">const</span> currentFormComponent = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-number">1</span>: <span class="hljs-title class_">Step1</span>,
    <span class="hljs-number">2</span>: <span class="hljs-title class_">Step2</span>,
    <span class="hljs-number">3</span>: <span class="hljs-title class_">Step3</span>
  }[step.<span class="hljs-property">value</span>]
})

<span class="hljs-keyword">const</span> <span class="hljs-title function_">handleSubmit</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'表单提交：'</span>, formData)
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
</code></pre>
<h2 data-id="heading-17">📝 总结</h2>
<p>Vue3 的动态组件是提升组件复用性和灵活性的核心工具，核心要点：</p>
<ol>
<li>基础用法：通过 <code>&lt;component :is="组件"&gt;</code> 实现动态渲染；</li>
<li>性能优化：使用 <code>&lt;keep-alive&gt;</code> 缓存组件，避免重复渲染和状态丢失；</li>
<li>高级用法：结合异步组件实现按需加载，结合 <code>computed</code> 实现复杂逻辑的组件切换；</li>
<li>避坑指南：注意 <code>keep-alive</code> 的生效条件、组件状态的保留、异步组件的加载处理。</li>
</ol>
<p>掌握动态组件后，你可以告别繁琐的 <code>v-if/v-else</code> 嵌套，写出更简洁、更易维护的 Vue 代码。无论是 Tab 切换、权限控制还是多步骤表单，动态组件都能让你的实现方式更优雅！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Python 数据类型 “冷知识”：这些坑你踩过几个？]]></title>    <link>https://juejin.cn/post/7591730714141343786</link>    <guid>https://juejin.cn/post/7591730714141343786</guid>    <pubDate>2026-01-06T03:05:33.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7591730714141343786" data-draft-id="7591730714141278250" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content=" Python 数据类型 “冷知识”：这些坑你踩过几个？"/> <meta itemprop="keywords" content="Python"/> <meta itemprop="datePublished" content="2026-01-06T03:05:33.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="AAA简单玩转程序设计"/> <meta itemprop="url" content="https://juejin.cn/user/4294056357689099"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
             Python 数据类型 “冷知识”：这些坑你踩过几个？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4294056357689099/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    AAA简单玩转程序设计
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-06T03:05:33.000Z" title="Tue Jan 06 2026 03:05:33 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-06
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    7
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读2分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#2b2b2b;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(159,219,252,.15) 3%,transparent 0),linear-gradient(1turn,rgba(159,219,252,.15) 3%,transparent 0);background-size:20px 20px;background-position:50%}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{padding:30px 0;margin-top:35px;margin-bottom:10px;color:#4dd0e1}.markdown-body h1{font-size:30px;text-align:center;position:relative;width:max-content;margin:0 auto}.markdown-body h1:before{position:absolute;content:"";z-index:-1;top:-20px;height:100%;width:100px;left:0;right:0;margin:0 auto;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADsAAAA6CAYAAAAOeSEWAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAABkLSURBVGhDtZoHnJ1llcbP3Om9ZiYzmfSQhCQQIbRQVQKI9CYC68qKriJK0UXcZRcINqStIoiIqKCi1NACQihBWiCkkJ5MJlMyvd7p7d759v989/sy34yTbIj48Atz71ff855znvOc971xDrB/EtoGI7a9Z8Aq+wZML0mNj7dE95NZ1OKsj1dHo1GbnJpss9OTbWJyonvun4VP1Njuoagtb+m0it4By0iIt8LEeMvkr8XFWcfgkA1gYDLf47i2PzpsyU7UspKSLDoctagTZ7Vc08MzClMS7awJ2ZaflBB78CeET8TYla1dtrKt2w5KS7YCDGzEoz2RqKUmhGw6x2bhuXyOp2BoRXef1Q1E7Lj8TIsMD1sbxu1kcnYSAX1810RMTUmyMB7f2j1gC7NS7byinNiL/kH8Q8a+2NRh77b32El56VaPAe0YeGR2mh2bm+FdMRqP1rbZe+3dFsHT35qcb/Oz0rwzo7Gxs9feYPLS4kM2h8lawee5hPmlJXneFQeGAzJ2F564v7rFzi7Msu3d/Xgjzq5g8ArX8VCNN2vJ28daey0zZJabmGCLslP5HOf+Oygr3UzDGOf+JxrauXfQjslJt+dbuuyMgiwmk+sPAB/b2Lt2NdoMZnuY21qHIvbvUyZ4Z0ZQiXGrWjvsmPxsK4R0nmHA8ZCTQvxVQn5eRipklIBtcVbV1WtHYsjati47ZWKuTUpP9Z4yGk/xDBGe3v1mW4/dOrvYO7P/2G9jRSjf31FnXyaUXiB8r51WaJkM3kcfOSa2FR6qarIenooTLQHPLcC4mYThyw1tVpKWYlVERlZ8nC3Oz3Jzdn1nn5uvQ8OOHYvhR/CvsqffJbkCkZTvcYZ6Z0WTfTovw5Y1dtjXp+TbFPhgf7FfxpYxuMfr2uwo8rEtMmwXF+d6Z8wGmIR2PLyjo8cqOFffP2SLGexJEJCP9R29thkPXlpa4A5Y3w/jmuVNYYwO2QkY7WMtz3mVcE1hkualJdmSolzX8GnpKd4VZq80d1o7zN0RdWxGaqItgbn3B/+vsasgh/UMNBOvzYMZDxtDKp289KGaVguFQvb1yQWWwuB97GaSXqUUnVaYbSUwrDCEBz/C2CM8EhNrP13fbkeSh3OJgCAe2N1CWXKsGOc6TOr5U4q8MwYhDtkTda02MyPN+nnGBQEH7A37NHYz5KOZVv08qyjbSseEzKauPnsMj98wc6Ibcj5UUv7M8QWZTE52jEwGOVaD8U1Dw1YNWX0qM8VKyb80L/TrOPYOzH4KBJQTrK8M7+7KZjuM63sHBt17FubGoibCuf+tarWFGUmuwWeT8/vCXo1tZOYeZcazCaez8MwEzzM+HqhqtiJI5twxL1jeGLYk7jmKMF1JOCbg6Qj5nAdRqX7q3BYm8VAmQvW1lfcMc58IT95uIA3q+gftrDHPXUXJWkVEHJme5Bp5UmHsvIZ/O3l8ECE/FWcsItX2hr0ae8O2Wjs+J43QTbOZzGYQ/7Wtxq6eXjRK3r0By4YJ6Ty8EiYSJqcm2eGeV4Pox/ANENJR49RiEdfqcLflUJrEBZqgxYHrBjn2ExFURqKdVETN9YirJxKxR2rbrYeQv5ISmB6IsiDGNfZGWPeMgkzr58xnPaJ5p6XDZPKz4T77wayJ7jGhhXLwanOHTWBgq5n5q6YUwNJ7l3kKcRl7OJ7fF56l1GzvHbSD8dghTPi0wIRfv6XafjJ3ssv0PnZQ7nZx/etwzO1zJ3lHR2OETTw8x0tOx1AN3De0D7YV+63oGthjaJQ5Ur7eVVZjcdGInUyuaT73ZWg3efV8fZs7cc2E777Qi5eunVbghvPPymrt/krKGfcLd8ybYjdxrK6333Z09rjHZkNuLYzz0uIc+xWCZzz8nbHbe4dsY1e/XUOY+nimvtUaSazv4jXhaQasSbmYmpuenGwHZ8TKggSEQm08rMD7ahBOoExcMqXQegjnZ+CEvaEa1ZQUQkt39dj0zDS7krq+ARmpdws/nlNqD9WFbWN7l5u3wr9MyrcXKUsqWy3jTOaoML4DdaQ83YIoT4VYpEXvYQZLmbX5SLohBrgOj186Kc/iKTUPUhq+Rrm5ekOl3TWv1Mr6hqwbY0VOQXwEo+Moq4Z47q5qsU489G944LyJOW4LOLZOKtT/iI6+nGe/0dhuEd4ltj2NmiuCU4hnk5fHIi7+RK4uTEu0e+s7rAiRcw1CYy3OejvcYz+eXeI9MYY9nu3lYZl0KavJJ7Vjibzgjp319rUZE20j7CkJqFr5JQYgQ39f3eQaKpQk0afy8nl4uBzvjUUTRk7k3iebOm0pabDiyFn2XGu3dRME41CGVeBVqSiVnc6hIUpekp1VjHLDSOEcQlui5W/U8C7IKREjv1Gabw3wRwUTvpv7jybPtzHmIPZ49q6KRjuccqBQVCOtGvqXhrCFUUXJzOYSHt7Kw5Ix9H08dSje1o1JyL73IYXpEMmE5CRbw6wuykx2pR+Pd6/J4JpLiJKV6N9OnrcQNfQ0Zem6qQX2MmFXyWTE+DMO0kGx4e08DEjnXbsYuOq7niHB8jdY/wQ8Srm2XCZZUrOakF1CY5EKX0h93Tu/1J4kRdbDMT8MamgZK9xe3uDcvrPe++Y4f61rcZr7B53rN1c5N2ytcV5rCrvHt3T2Og19g+5nH7dvq3bqunr4NOwgK2MHA1jeEDuG7HNuLmtw7qpocl5t6nCPvdTQ7v4N4u3WTqeyu9cZHIo4f6lqdFoHh7wzMbzDeeGv3Hvzjlrnh2W1zofhHuftxpFn3VFe7zxS0+p0DlKVPbhhvBxhvwiFMgfP+mjHA08gEC4pybeLyK1iZldh8zC5VJQyUl8l59KZ0WJk2xaiYWxNrkXXJhA8r3PvZRur7ZZZRfadaRPsfiTmX9HGajC2tXd6V8dQTMhX0h8rNdJx9Ra8F8SbRNLzhPRnJmTZIUTYueTyWxyr7uv3rjC3OkzE8495oS+4xq6D5WoI0bO5WVCOSerl8rIeBrOI/Hkaw6ME5W1zSuzx2la3CRdWi3zIG+FDBvUp9LMgI/vggUmE7KkT81yGvOOgEYa/aUahhRAF5xLec3OzbF1r2O17BbVxIi7hzJIC64IYhXdJA+nh/5xVbOmE9J0QqjSxWk0pp37M2YEtgjS8GpimACu7xkqxdKJ6fEXyYl2Lre0ZtC8yELVewtWUnbfCPIhrvgDFz8WI5yhJKgcnFMZWEFrwhgzo5uWDDDA1oGSOzcu0xfx7vTlsv6posIMpJ6cGWPiw/BxL4PU7vbrpjgf8bMdu5OYwOdhm83DARUSa0ELknYIeEAaILuWxlhGa0M8+EuJCrpJT+ymENhN60pXBxa3LZ5TsucnlGaCmIEQ4Evru91yuz0xMtKaeXluI5zdh9Mm8vAlBn4aR07X64EH3vEKdXQkZJXPP/JxMvNRpLxEtHZ5RQgmNewnpouvVTpYTHdfOnmy5kFUGnpRTfEhXD9DiBdFFJB0/YWS9aj6pmc89r0BaQmgTRkgI+EsdKsYasJZOBF+QqTH474NK7LbyBvf7W+RgOxNyxfQY2/2hrp2+NkroxrzrQ55fSZkpJIa28znCgF6rb7H1hOSslATyvNflAh9pvHcX3lVE/Ya8FjTJIexa2Rq77nfU96unTnD7aME3+TAm6BFKYrPnqCNIqV5sq0ZGCiEV+Db+qWMQqpFgb5KPx48R6omeDl2EuP9DTYt9iGA/f1KBS1w/La+H4ktsSmLItvZHXLUkrCeflVtJ9DVVg1H7+sxiGvVM975rZpfabuqHVhuP5F1vewav5O8GamUe91yDanoYw47FWzC929O+DJnKA2opFY1Rjru5CE7kOcO0jJtQVUIynzuZEMeb+1CEOFXN8iFSGeRpCm1BTlJxVg49Azm819SO7Bu0axEbwn27GuxMck+TMQHDP8fn48gfDVIL4R8xKVPJ73MQBUIfA/Z54LMw5vmlE+w+VFo2A78X/SsyPA/RMD0z3e2qVLtfo7aeBslpMX0N0TEnLcUlKym1jyBFqSohmYntI5enBhYB9CY/2kNarhwJhNiMtRGyWnkQdKaCFyQwgydjyNUw4VchKxXv2/DoKdC+lkQbCX1NlKCGvJiBJkSGbCus6jfo4yGBNySgr+u7e20BCsxdVAcFlJ/tHd32+cIsNxSXUULUUx+dg/d47g7OPYFw2MxkSuyMwLHVTI6PBN6dS8Sppw45zHJSgDXV3aQzmz40Z6fDgBfiAXU0uZxby2zejee+j3eltoQMzhV6qSBogXwrEXDj7ElWxUQ8RrnSaoU0dxIsKaiMvMykXTu90NqJsGHP4z78SdLigUrLKat32nFwy/E07pfDFRdQ/7N5r57pQ1482uvWhMGhQcviGkVrKDUp0ToCxfhQal5n4Hs/g1jOgH4LWdwFOd1b1WzHET4vLZppv+Czjxo840OrDlG8jAJzv2tp5mLK1dsU/lfIOeWy5NxFxfl2BoYImlQtx9QF6mJRQKBsQYYuO2yaLYPBUXvu/VqYPxtHhNy7Y4hCkNLGPtKSklzCVKSHtMQxcqm5Kw1DhI2PTGZtcGDAvoLQ/u7MifYtWFBlxz2H9zo8RkwKzC5UYiG+p44ccqE62YAxLeT/TOpf8MXx8Qk0IJFRY1Go+viQVJpE5Ehjf49xfAZeqGIy/7us3nqxwQfCkjZypPxobVr/6YpQHIalUvuCyEwbSXC9PC8QnkFcXlrgLpoLIhIfKuaqlQkYIAwQnr/f3eyu7KttOw2lNpv8/BPHyjzVNER3o72gvEBKqRMTflndbP8BMweRDyeciEj5bFayFXqTLzheivgYJC0jwzwHa0MDDEotm48ndze5BBBElAnxxcRYHAFh3FfZaA9UNRmC354kNwUx8eHkmVj5dcTE5ZMnuEyr1QqlhtaJLuOYZv4v3KNo0TKrGPUZ1NILPKuWcvVn5Trv10SMB6h0j/ARMnlOuafCBIfnSWEx/Raif3HDzofYMM31dOyY9LBaLK3TjoX2fEqT4+2qaUVWSTQvyM6wC8nNJyEetXIyuLKrx04P7MKNnbJZlKUtNAIHo7i2dA/YU3Vtdi5l6jCepXy8hOedSSSsI8/HQg5Q+gxTKXwkMHkbESo+hjG0lbRRzQ3Fc5LOzDuFhs3Ptumpie7ilRDhlEJOq/hjsZljCxjkt7fWuPS/EekpXMggJQIk0G+eN9Xu2VmHWIkJe0nJRN4ptBBit2yutG9ML7J1DHAxebiAMrZ4VZlduqGS8I2tJc2iborUxmIN79c+kTovFxivPvrcSaP3n7RSKYTUmKt4N3rMOcw4JOneD3sP956jNaMglIeTER5Xbdlt15Tm2W10NEsYrA/N5JLCHHsR9tSqwxq08G3bqm1ZTbOtagnbo6SLvH/VzBL7W7jPzqFea0LmMLFzUuLtdwumuO3i1Vtq7OK15Xgw3l1PDmIXak+6QBEkvB9YJIzBcc/L20JIYaSZ/qAzVm5Ut4oowk3QehC+N3xo/1wTqt7zsYawfX9no9XjqdPXVLhrwyo/wucJYQkE1e4j8rLcBuHUItQQKqgMXb6LGvxFQlXw33AdZLR0V5P9Fr29lP73scNnosoyvdWPv4fPJ+uJrLVtMakqaL1M1cTvv0OLIZE6wk2a2IcIRUQh+DaejpdcXepBa7bKDRGM9PIVxTl2EwarZ72rooVuY4RQtMypdk6e1lLLehhY2lt7QEd7WxlCDvdIli6E9B4+ZIodmZEMccUGqgiZOqru9tkR3iJ8nCcXRWRZCSPMLPEjlx2LjQL1OM5qKAm+vhSuRqSfV5Ttrg8FdWcrnhMqCTex7DEM6qTsVEuM1+8hovaHQ6e6a1Fz0xLd3nUt4ToWWuzWNkhcoAIIjUx2ZpxjLzWF9+SYmngR1lok4TEoJxGfuijhI/7OICoFmadl2llcL9b1oRVJtbD+JLlv1KrhHG5811t9ELbzgk14ICUwqE+TDzftqHPz98vUSy3jSIwP8dCpkNqLDPTx+rArz4T5qLG3G2PrvJKKPoLBWE501NC3ilUX5mVjVIb9nIbgWcpPMiSXjbcL8K62UkR86m1/yfkSeMaHFuK04X0CE3J6SWzFUxw0BSNHlSzi3RmIRJwHq5udO3c16quLp6sbnffbupxbt+12vzOrzuvNHc7ycRbIxuJHgYU7YSASdQgxp7qz2ynv6HJeqW91doa7nLruXof+17sqhhu31Xif9o7HalqczV29Dnrb/f5EXZvzdH27U98/6LR5i3N0UM5zjHU71/lwjRWWltU5CAIn7F1MqLp/r9hQ5RoaxG+qmrxP4yNKcfsFLwuiprffeb2l03m2scO5h3Or2rudzjGrhk8x4Cqu2xcexilBvNEcdi5Yu4tKF3Ue4tzPy+td5/1md4tzw5iJ27NuXEYobYUdlb8z6GTWkdxaCvk2zHjd5mpKQ459mv5TkAp6mQb9Aq9HHQ8S6mrZnuc6vUG6WHusIhCJGNXl9byvnJyaiE7+Eoz8c5TYNQiUveENGpJpcIJ+biS8R0+rlcazGNs7pKB+zPLTOSX2KNWhlDAf4r2Spj72JORB5OyHULX+dlD/FOky/HFy5ygYU0sey/i8moeqdunXK1qC3RuaMOYHlI/raQMl3M+EeTV5WxD3Km8a8PkM8nr648sQ9+esKbf5e/nxiKBfAOQkxbv3SU9LYmqPV9V/Pn+V20VwTyVjTqCI6edEQUOFUXs9WmfSll8DyX2dt7GlnwkswaM3l9XZ0oNK3MTXbxpOV2sGk69s6XCJw4cY8KbyRrt9TrHt7Bm0rRBQe1+fHUWNfaapU0KbqxzbORC1M/LS3dJwIl3KOrwykQG/E+61q+isgniztdOKqNOziDgZqZIzFwPvqGiyg5NCtoCqoG5NxHhPZTOsnORulKskjoKMDeLuXQ3OmnC3syxARFXdfc57LR3OrdtrvSOOs55rnqhtcdoGhpxHdjc5EfJUuHZTlftX+G15rXPlhkrnLe59F7Lz8VGHdg8c5y2OLeMZ126qduq9XC3v7nd+FchLvYPJd15gPCu8XQnh/qpm59WGVudZzvvQO97kXTcGxhnEuJvR39tWY8cwK4uhcikk4a3Gdstg9l5B2t0wfaTdWkEou5vCPOV5PH73vFL3+DfXltnh6OxjkJD6Wd5F3g88tMe6CW/7YmI99VIL4u0oqUK8ocW4d8hFrXMVoOQU8s3U97MnjvDD/XRYkyhHM1MT3GVZQR2Tdv70U8EbA5vlo+CaPAaaSWoZXm50otGodxQ6L6txGKxzw5ZYORrBsPPrykZKQIy1n8bTjwb2fO4Te3ue7x6KOKvaYns1wtIddd4nx3mwot55qyl2360cp81zurg+CGqwU8v4/Of5uAVvPgObrwvHomY8jOtZ4fXWLnefdHVXv9044+8ZklCx75DXwcV1Sb27y+vInUQEuVYSaMgRJYfAwtoj0raFxIUW1A8nz35f02qLc9Lc9lG7CBkwtUR7bf+A+5uL6ehnH9Lat+5sIEfj3Cbj3NKRvP7Rjlo7FSmqavKvpSP8MRZ7NVbQYLSkqlC9ZW4sPH18gBTcORjrhMWmQWzFmK2UsvO90qQ1oZcI8UhkCLZPtRqMy0NirobAvjIpb4/sW06qKGyPR2oGIdlazjOOTk+kLYzaaYGSp63Wz6HsXsQ51wd+LTAuZOy+8GBNq7tF+IOdDU4kENJthNID5YRafZtzZ3mDs9LbRgzixcZ2l1h83OKFbDmEd0/FiFp7DWHgp0AQGzq6nf8hPF+oa3EehOz0ziCWcm4NpBRMhX1hn571oR9wqVVSDVPtUi32sQ0vbu7scZdY9aOt2ZSEL9BEBIW+dv20AKDd9/ep09oimYqHpyImkKDuRllS4PrlHNuIqDmCJmNJQba7q1joEaUQJuR/WdXsLrJrq/L6cdJsPOyXscJ7GLKqo8cOpqhrO//yQG6oS3kZwS9xPkRB3wi7diFMtDN+PLk5m1ath+8f0Fy80dbjhvVXub+U5mEqeal27UP+dWpPlknNxW79Ak6/7Tg3UMOF52j1xA1qK7Trd6nXC+8P9ttYQcumIonLSnJtBdJNa77axw1C2x3qR4Wqnj73x9f6MbV+CCYFBZO6y51aSh3gzVrsmwzJnULEbCJC1oZ7vIZ/9Iqmfvn2u5oWO5n8fApxcuWUApum5diPgY9lrA9EtvUNOzYf8vqAcJPsU5iOh7XtXQgt2uZhjKU2amF7HQyfEYWcZk5yQ1RDKNrLcq02k/9IGmldrB93KiokPw8EB2SsoKWXO5FmxXhlckqi+3vEUvLqwok5PHVkIWAszlqzy1p54zuLpnPZ3q9bod08JlLSb5DrNxDm38Sbvsg5EBywsT7oH+3XNW3uasGirFSrxRNdCllKiPZHZzJYLZb5qEcpae3pxMCuu9oibS5/QCOiLcYUrp+MmtJeURjFdVlxzqiae6D4h40NQt54HyGv3JRo10aVfv8YhtC0pSlVKcPFuxIXahr08mzCO4VzMlLSsZuomZ+RaucU0rXsw/sfF5+osUFonWob/7TrLdaUgdpV93fl9X+VIC0Y6tek2uI8OD3J5gT2Vj9ZmP0f4IM4iY7RQ5gAAAAASUVORK5CYII=) no-repeat 50%;background-size:64px 64px;opacity:.84}.markdown-body h1:after{position:absolute;content:"";width:150%;left:-25%;height:50%;bottom:12px;border-radius:50%;background:linear-gradient(transparent 80%,rgba(77,208,225,.8));background-size:400% 200%;opacity:.6;animation:h1Animate 6s linear infinite}@keyframes h1Animate{0%{background-position:100% 100%}50%{background-position:100% 50%}to{background-position:100% 100%}}.markdown-body h2{display:block;border-bottom:4px solid #4dd0e1;position:relative;font-size:24px;padding:12px 32px;margin:30px 0}.markdown-body h2:before{width:24px;height:24px;left:0;top:0;margin:auto;background-size:24px 24px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAADGklEQVRYR81X32vTYBQ999s6mFjQgQ+DrbHiVFZYU4cDcQ/6pGhTFVYFEXGi82H+Bz448UnEF1Fx9ccEEcXpZE3d5tP2ooKiTacTHaLNpigMHDgnU9tcSbrWrkwWR0sbyEOSe885ObnfvV8IRT6oyPwoLQHBx+OVM5WJvSyEVAhnBOjt7yU/+/rr6r6l8TMO+F/EN0JQhICqQpD/xaRpcpAc9tS+M+9lBCia/oqBamK+zeDuQogQZaKJk3wcQjxSva7tGQGB2Ke1zIk3DNyMyNL+QpCnMQOaPsDAVuGAp9cjvbYc8Ec/bCYSg0zoiHilk1tHxqsqEsYlML4kjIpT/eurJxRNPweQU5VdrWaOEo1fgKAVbBgXIz73kF3R/ph+ghgdzMYWM29eAWlBJqgZaFlFYtC6nhWpaDqnSGlIlV1WjJ3DloDNgyNLncudqgX//Ucg3LxuStHGuhi8pqKCW3rqV342rwFjRznKm+/LNaN2yC237ThgF2wxcfMLeP6+ncrKzoPoKTGeLQbYbg4TNoC5iZPJY5HGVRdSNZAWYBclD3FzBQzrR8hACAKdzBzKA/4/IYioDQaOskBbpEG6PO8qKKSAEi3CnEb0Pw4oMf0OmKbTDWqh3Lw6EIiNBZi5lxh3wz4puBD5ovqAMvxhHSdFKxE1CQe3m/07TeTX4lcJdAhE+1Sv65Z5P/ByvIGTRowIZ9igbtXnmrOsbTvgj+kHBNMuBu9OdVw8EeU4nC1A0cYmAHZOTRrLhra4Z8ywnSN6vZHAFTA2WnnMfQB3qz73ddsOZM8CACFDIPSgQXqebXEgqgeZcAeEe6pXasm1f8ew3igMtAHWac0Uc/jYdyAaP0xEBwFsmgUPqbJ0NE2UKj4EGcahiOzuyhagaHpnmtgcVgTcCMuua7YdyAHbA3ArQNscVFbb4635aD6fnYaTvxxi9UNP7ddMXaRWVBdAcaLk6bDXPZCNZ9uBXEsDUX1T2Cc9yjig6Z0EHg3LK8/aqf6MwJKchkXfks1+0+JtSq3qLPa23BRR1B+T/6nkfMaW1r9hPt/MLtYfTLEpP+T9FNoAAAAASUVORK5CYII=)}.markdown-body h2:after,.markdown-body h2:before{content:"";display:block;position:absolute;bottom:0}.markdown-body h2:after{right:0;width:400px;height:10px;border-top-right-radius:24px;background:linear-gradient(90deg,#fff,#4dd0e1);max-width:50vw}.markdown-body h3{margin:30px 0;font-size:18px;position:relative;padding:4px 32px;width:max-content}.markdown-body h3:before{border-bottom:2px solid #4dd0e1;width:100%;content:"";display:block;height:28px;position:absolute;left:0;top:0;bottom:-2px;margin:auto;background-size:28px 28px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABRklEQVRYR2NkGGDAOMD2M4w6YDQERkNg+ITAppcfY/8zMv3wF+NdTUrZQpUQ2PT6cz8Dw/8CkMWMDIwNvqK8jcQ6gmIHNN19EaXPx1XPyMCghrCUKcpPlGc5MY6gyAE+Fx52MjL8j3cU5a1UYWXtZGBkEAVb+p8hxU+Mby5NHQCxnKEMaskzJ37uFmUetkmMjAzrfUX4woixHBJlZAA0y2EmPPYU4enLkhGeQIqRJDsAh+UgO7duNpD3IcVykkOA2paT5ABaWE60A2hlOdEO8D3/4CMDIyMfWvySFefoaYSoROh74eFXBgYGLiTNVLGc+BC48PAnAwMDG9QBVLOcaAd8P5ox+x/jf5AjGLgYfnwnKqv9/8/PwPO/kFF/MSj0cAKiouD/0bgYoixFU8RovWgJIX1EOYCQIZTIjzpgNARGQ2DAQwAAvHBaIdB7zxsAAAAASUVORK5CYII=);background-repeat:no-repeat;animation:h3AnimationBefore 2s infinite alternate}@keyframes h3AnimationBefore{0%{width:28px}25%{width:100%}50%{width:100%}to{width:100%}}.markdown-body h3:after{content:"";display:block;width:28px;height:28px;position:absolute;border:2px solid #4dd0e1;border-radius:50%;right:-15px;top:0;bottom:0;margin:auto;background-size:28px 28px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABRklEQVRYR2NkGGDAOMD2M4w6YDQERkNg+ITAppcfY/8zMv3wF+NdTUrZQpUQ2PT6cz8Dw/8CkMWMDIwNvqK8jcQ6gmIHNN19EaXPx1XPyMCghrCUKcpPlGc5MY6gyAE+Fx52MjL8j3cU5a1UYWXtZGBkEAVb+p8hxU+Mby5NHQCxnKEMaskzJ37uFmUetkmMjAzrfUX4woixHBJlZAA0y2EmPPYU4enLkhGeQIqRJDsAh+UgO7duNpD3IcVykkOA2paT5ABaWE60A2hlOdEO8D3/4CMDIyMfWvySFefoaYSoROh74eFXBgYGLiTNVLGc+BC48PAnAwMDG9QBVLOcaAd8P5ox+x/jf5AjGLgYfnwnKqv9/8/PwPO/kFF/MSj0cAKiouD/0bgYoixFU8RovWgJIX1EOYCQIZTIjzpgNARGQ2DAQwAAvHBaIdB7zxsAAAAASUVORK5CYII=);animation:h3AnimationAfter 2s infinite alternate}@keyframes h3AnimationAfter{0%{transform:rotate(0)}10%{transform:rotate(0)}50%{transform:rotate(-1turn)}to{transform:rotate(-1turn)}}.markdown-body h4{font-size:16px}.markdown-body h5{font-size:15px}.markdown-body h6{margin-top:5px}.markdown-body p{line-height:inherit;margin:22px 0;letter-spacing:2px;font-size:14px;word-spacing:2px}.markdown-body img{max-width:80%;border-radius:6px;display:block;margin:20px auto!important;object-fit:contain;box-shadow:0 0 16px hsla(0,0%,43.1%,.45)}.markdown-body figcaption{display:block;font-size:13px;color:#2b2b2b}.markdown-body figcaption:before{content:"";background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgBAMAAACBVGfHAAAAGFBMVEVHcExAuPtAuPpAuPtAuPpAuPtAvPxAuPokzOX5AAAAB3RSTlMAkDLqNegkoiUM7wAAAGBJREFUKM9jYBhcgMkBTUDVBE1BeDGqEtXychNUBeXlKEqACsrLQxB8lnCQQClCiWt5OYoSiAIkJVAF5eVBqAqAShTAAs7l5ShKWMwRAmAlSArASpAVgJUkCqIAscESHwCVVjMBK9JnbQAAAABJRU5ErkJggg==);display:inline-block;width:18px;height:18px;background-size:18px;background-repeat:no-repeat;background-position:50%;margin-right:5px;margin-bottom:-5px}.markdown-body hr{border:none;border-top:1px solid #4dd0e1;margin-top:32px;margin-bottom:32px}.markdown-body del{color:#4dd0e1}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:rgba(77,208,225,.08);color:#26c6da;padding:.195em .4em}.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace;overflow:auto;position:relative;line-height:1.75;box-shadow:0 0 8px hsla(0,0%,43.1%,.45);border-radius:4px;margin:16px}.markdown-body pre:before{content:"";display:block;height:30px;width:100%;margin-bottom:-7px;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAdCAYAAABcz8ldAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAhgSURBVGhD7Zp7bBTHHcdn33t7vvOdzy+ITVKDU0xIKG2ABCPTRCCaUiEVKWoqRJuASAhCitRCVKSoalFUKZBiSmmFRRJKRUnUtIpo+aNqGgwoOCmuFUIRzxjwE4zte+97drYzztji8HPvtkit/PnH+n1397Tz+83vN/PbMZhmmmmm+d+BoX8n5diihcGqgFQf5vk6BMAskWUlw3GyFnIvtqWSf91w7mKC3npfOLX7wYeiIa6BBWCOLLFRF2NB0JvIOP/80YG+k2ev6S699b/OzOfKBW5l5KsgyC4DCFQDnpEAdE1goc/dlNPc/Up7P711UiYNSMuyxeUzZPnHgGHWh5XADEkSAcdiN+AnEXIBhBComgFU0/xQR+jnj51sOUMf9Z0NKyL8S9+JPBEN8zuCMrsqGOA5QWAAyzLAxe53HBeYFgJp1c5Cx33nyIfpV3e+22/Sx32nev/sMCgVnmM4bjOniAtZWQAsz315EfsGQQc4hgWcjHkCmOj1rheuNn95cXwmDMiVp5etC/D8m5FwUWVQUYYGPh6mZYFUOgsGVa1pXvOZzVT2jRuH54RM230jEuI3RcIiL4l4UkxAJmuD/riVsqD7ct2m9nep7BtVTbVfZ0uE/UIk+CQflAHDjf8+Lg6MldYATGpH3c/Ul7p3dWXppVGM6eElJSHmnQWPbSlRlN1lJcUBjqNRnwJZVQO3B5P/uq5rK1d90pakckFcaKp5UJHY92JR8YlwkUDVySEZfGfQdO7E7Z8s2HL9TSoXTPXRud9nA8IBqSwcZgWeqpPj6BYw7yTbXBN9q2v9lQEq5zBmWA8vWLCptCi4tzwW8RQMQlFQATPLSh6vCSh/plJBkMyQBHZfWYnkKRgEktEVpTJXERN2Xzo4ex2VC6K6qXYpF5b3ypVRT8EgcAERSJXRbwCBOTFzXblM5RxGBaRt+ZPYA+LO0mgxz5K1Ig+UgAzKIuGnz39z6S+olDeaibaXRsU1RUFvgx+GwTWgPCaDgMw2XXpr9gwq50XV0bkxJiYeEiNF5cwE5XsiOEkAUkXkUW51SSOVchjl8WKef604XFSRbzCGCYeCoESStv/p8QU1VPIM3knNDynctnBRfsEYhgSlNCIGgQv2UCkvGIHZgteMh1nBW9W4F16RAM6yDVV7amZTaYQcr59cuuhhWRTWBvAMLxQGeyFSHOLnh0MvUskz5RF+fbRYDEy0mZgqQYUHOLhr//b6rGoqeaLqQG0pw3PrBbyA+4EQUkRmhvgqNUfICUipKK4OKUqIJVPKB0jpEhjmWWp64jdbKmVZZNYogcJm493gsifOqhDyeh9GYR/FM7sW+DA5CKR0MSK3tvKZkpwB5gRE4tjFEr7RL0iWBGV51vHFCyupNGWWPqLgnoer9mtyEGSJAzwLllDTGzyznDjRN/CwOFkoFb4bm0eVIXICgpvdGoEvrF7fC89zfLkkeV5HbOhWiTwTpKYvCAJLGshRdXtKMKAWlyxq+MPQLk1h66g5RE5ABJYNFrqY3wvJklJRUKg5ZWLFXIA86yek2uDOPkBNb3CM5Pf7DL2QyIrUGiLH+xC5Bmmm/ARnHUhC6PnzxWDK0RH5HuIjZGy27erU9AZ0dTIWXyG+NpBBrSFySxZw220IqeUPFoS6jVAPNadM7yDsgNB1qOkLuAziMYIb1PQGA75wIaKGPyAb+9oF16g5RE5ALIQ+tSyLWoWDEAK6aXW3JlK9VJoyx1oyvVkNdvo5KXXDAVkdnaKmNwx0xjH98w3JNmTCm+Bc9hKVhsgJSI9pvp9Vdd++jmq6AXB2/HHrhcs5aTkVDv0DFzoHvKdq/mQsKX/4t7KJLDpOJW+IbAvMGoMkxfwAWZB8DT7W1diTE+WcgKz6pK1bs6z3daPwmJDsSKt6ZsCyjlLJMz0DsDGZ8SdlDROBjOb8YeWOjptU8kTXusuaazu7oJrfEnQvdkpVcUn6PTVHyAkIIW7br/Unklni0EJIZ1WgGsauZR+fvUglz6zY0dGfVp09ybRNlfwgi3k8YSbvJJ29VMoLt9v6rZVQL7hOYUubndHJGclBtzn1byqNMCogi09/2nFb01/oj+f/5TyjauBOKtPcZ1r7qZQ3f2lRfxZPWi2anp8TSDAGExZMa2jr8u03L1M5L7q3Xc+iAeuHRl/ScvPcjSLDBnZS/cjtNHd2v3171Ewbs9N5q7Pn4otVMx3btBsCsoRbk1FxG5dMVgMDqfTpXl1/tuFMa5zKefPROdX59qLQBwLnNog8Wy1OcjB1N+QEsW/QsFNZuO35Xb1v98QLX4/Sx+O3wqujrQ6013ABUWI8+AaqBjAH01+ghL22+5X2PirnMG7r+esbnae/V1neauvGSoHjigTcVU7UGFm2DeK4ttxKpQ+mLPvl+o/PjnkAkw9HTqSMmVHhyAMx9iFcSh/BHTfLceO/C8mKjApBf9zszGhoY92m9sN+BGOY9AeD7eGniv8OTaOB4dgyTsQd9wS+IQu4lciYdkI7CLrNH3Rvbb9FL41i0tbzVP2iWJkobpN5fmM4IJfJskTP1Bk8A9HQmbpmGDBrWqdVCN/Yd7PjxKGOXn+bmbto3feVVcVB9qehIL8EJy8nChwgr0O2xxBnhGU5eP2CfYbl/m4gBRsbtneMORP9oGpjpcCsiKzHHfdOPiQ/wMniyFEu2dbiTQCAeN/vavC466BGYLttXc9fmXBXMGlAhiHHur+sq6uPiUI9z7CVHMPwBnLSuuN8FuC48/Oaz1ylt94XfrW5ouyprwWfYRkwNyCyYYjwkBHows1fa+tV/fzGxlv39b9gqvfPmQ+i/HK8KlcBjhHwfl8HEHyOd1JnuzZd66S3TTPNNNP8/wDAfwDG7G0m9LKBpwAAAABJRU5ErkJggg==) 10px 10px no-repeat;background-size:40px}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{color:#4dd0e1;border-bottom:1px solid #4dd0e1;font-weight:400;text-decoration:none;margin:0 4px}.markdown-body a:active,.markdown-body a:hover{background-color:rgba(77,208,225,.1)}.markdown-body strong{color:#26c6da}.markdown-body strong:before{content:"「"}.markdown-body strong:after{content:"」"}.markdown-body em{font-style:normal;color:#4dd0e1;font-weight:700}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:rgba(77,208,225,.05)}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{margin:2em 0;padding:24px 32px;border-left:4px solid #26c6da;background:rgba(77,208,225,.15);position:relative}.markdown-body blockquote:before{content:"❝";top:8px;left:8px;color:#4dd0e1;font-size:30px;line-height:1;font-weight:700;position:absolute;opacity:.7}.markdown-body blockquote:after{content:"❞";font-size:30px;position:absolute;right:8px;bottom:0;color:#4dd0e1;opacity:.7}.markdown-body blockquote p{color:#595959;line-height:2}.markdown-body ol,.markdown-body ul{color:#595959;padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>天天写 Python 代码，你真的懂列表、字典、字符串这些基础数据类型吗？这几个<strong>进阶偏基础</strong>的冷知识，帮你避开那些 “看似没问题，运行就翻车” 的坑！</p>
<h2 data-id="heading-0">1. 列表 <code>sort()</code> vs <code>sorted()</code>：一个原地改，一个返新的</h2>
<p>很多人分不清这两个排序方法，一不小心就把原列表改得面目全非！核心区别就一个：<strong>是否修改原列表</strong>。</p>
<pre><code class="hljs language-python" lang="python">
nums = [<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>]

<span class="hljs-comment"># sorted()：返回新列表，原列表不变</span>
new_nums = <span class="hljs-built_in">sorted</span>(nums)
<span class="hljs-built_in">print</span>(nums)      <span class="hljs-comment"># [3, 1, 4, 1, 5] 原列表没动</span>
<span class="hljs-built_in">print</span>(new_nums)  <span class="hljs-comment"># [1, 1, 3, 4, 5] 新列表是排序后的</span>

<span class="hljs-comment"># sort()：原地排序，无返回值（返回 None）</span>
result = nums.sort()
<span class="hljs-built_in">print</span>(nums)      <span class="hljs-comment"># [1, 1, 3, 4, 5] 原列表被改了</span>
<span class="hljs-built_in">print</span>(result)    <span class="hljs-comment"># None 别想着接收返回值！</span>

<span class="hljs-comment"># 进阶：都支持 reverse 参数</span>
<span class="hljs-built_in">print</span>(<span class="hljs-built_in">sorted</span>(nums, reverse=<span class="hljs-literal">True</span>))  <span class="hljs-comment"># [5,4,3,1,1]</span>
</code></pre>
<h2 data-id="heading-1">2. 字典的 “键” 有讲究：必须是不可变类型</h2>
<p>字典的键（Key）不是随便什么都能当的！<strong>列表、集合这种可变类型不能当键</strong>，否则直接报错。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 合法：字符串、数字、元组（不可变类型）做键</span>
valid_dict = {
    <span class="hljs-string">"name"</span>: <span class="hljs-string">"掘金"</span>,
    <span class="hljs-number">123</span>: <span class="hljs-string">"数字键"</span>,
    (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>): <span class="hljs-string">"元组键"</span>
}
<span class="hljs-built_in">print</span>(valid_dict[(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)])  <span class="hljs-comment"># 元组键能正常取值</span>

<span class="hljs-comment"># 非法：列表做键，直接报错</span>
<span class="hljs-comment"># invalid_dict = {[1,2]: "列表键"}  # TypeError: unhashable type: 'list'</span>

<span class="hljs-comment"># 小技巧：想存可变数据当“键”？转成元组就行</span>
lst = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]
dict_with_tuple_key = {<span class="hljs-built_in">tuple</span>(lst): <span class="hljs-string">"对应值"</span>}
<span class="hljs-built_in">print</span>(dict_with_tuple_key[(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)])  <span class="hljs-comment"># 正常输出：对应值</span>
</code></pre>
<h2 data-id="heading-2">3. 字符串 <code>strip()</code>：只删两端，不删中间</h2>
<p>想去掉字符串里的空格？<code>strip()</code> 是常用方法，但你要记住：它<strong>只删除字符串开头和结尾的指定字符</strong>，中间的一概不动！</p>
<pre><code class="hljs language-python" lang="python">s = <span class="hljs-string">"  hello world  "</span>
<span class="hljs-comment"># 不带参数：默认删两端的空格、换行符、制表符</span>
<span class="hljs-built_in">print</span>(s.strip())  <span class="hljs-comment"># "hello world" 中间空格还在</span>

s2 = <span class="hljs-string">"###python###"</span>
<span class="hljs-comment"># 带参数：删两端的指定字符（不是字符串，是字符集合）</span>
<span class="hljs-built_in">print</span>(s2.strip(<span class="hljs-string">"#"</span>))  <span class="hljs-comment"># "python"</span>

<span class="hljs-comment"># 想删中间的字符？用 replace()</span>
s3 = <span class="hljs-string">"he ll o"</span>
<span class="hljs-built_in">print</span>(s3.replace(<span class="hljs-string">" "</span>, <span class="hljs-string">""</span>))  <span class="hljs-comment"># "hello"</span>
</code></pre>
<h2 data-id="heading-3">4. 元组不可变？但里面的可变元素可以改！</h2>
<p>元组（tuple）号称 “不可变序列”，但这指的是<strong>元组的元素个数和元素的内存地址不能改</strong>—— 如果元组里装了列表这种可变元素，列表内部是可以修改的！</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 元组里套列表</span>
tup = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>])
<span class="hljs-comment"># tup[0] = 100  # 报错！元组元素本身不能改</span>
tup[<span class="hljs-number">2</span>].append(<span class="hljs-number">5</span>)  <span class="hljs-comment"># 改元组里的列表，完全可以！</span>
<span class="hljs-built_in">print</span>(tup)  <span class="hljs-comment"># (1, 2, [3, 4, 5])</span>
</code></pre>
<hr/>
<h3 data-id="heading-4">小总结</h3>
<ol>
<li>排序用 <code>sorted()</code> 保原列表，用 <code>sort()</code> 要谨慎；</li>
<li>字典键必须是不可变类型，可变类型转元组再用；</li>
<li><code>strip()</code> 只清两端字符，中间的用 <code>replace()</code>；</li>
<li>元组 “不可变” 是指元素地址不变，内部可变元素能改。</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[不是吧，不是吧，前端面试又出新玩法了？！]]></title>    <link>https://juejin.cn/post/7591672090791477267</link>    <guid>https://juejin.cn/post/7591672090791477267</guid>    <pubDate>2026-01-06T03:09:58.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7591672090791477267" data-draft-id="7591715454135517247" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="不是吧，不是吧，前端面试又出新玩法了？！"/> <meta itemprop="keywords" content="前端,面试"/> <meta itemprop="datePublished" content="2026-01-06T03:09:58.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="四眼肥鱼"/> <meta itemprop="url" content="https://juejin.cn/user/2995504913591661"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            不是吧，不是吧，前端面试又出新玩法了？！
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2995504913591661/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    四眼肥鱼
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-06T03:09:58.000Z" title="Tue Jan 06 2026 03:09:58 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-06
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读22分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">前端新的面试题又来咯</h2>
<h3 data-id="heading-1"><strong>拖拽与 DOM</strong></h3>
<p><strong>问题 1：拖拽过程中，如果原本的元素消失了，onDrop 还能触发么？具体表现是什么？</strong>
<strong>答案：</strong> 能触发。<code>onDrop</code> 事件会在放置的目标元素上触发。具体表现是：拖拽源元素在拖拽过程中被移除（如设置为 <code>display: none</code> 或从 DOM 中删除），只要鼠标在有效的放置目标上释放，<code>onDrop</code> 仍会触发。但是，<code>event.dataTransfer</code> 对象中关于拖拽源的数据可能变得不可靠或丢失。</p>
<p><strong>问题 2：如何改变拖拽预览图？</strong>
<strong>答案：</strong> 使用 <code>DataTransfer.setDragImage()</code> 方法。</p>
<pre><code class="hljs language-javascript" lang="javascript">element.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'dragstart'</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
  <span class="hljs-comment">// 创建一个自定义图像元素</span>
  <span class="hljs-keyword">const</span> dragImage = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">'div'</span>);
  dragImage.<span class="hljs-property">textContent</span> = <span class="hljs-string">'自定义预览'</span>;
  dragImage.<span class="hljs-property">style</span>.<span class="hljs-property">background</span> = <span class="hljs-string">'blue'</span>;
  <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(dragImage);

  <span class="hljs-comment">// 设置拖拽预览图，后两个参数是鼠标相对于预览图的偏移量</span>
  e.<span class="hljs-property">dataTransfer</span>.<span class="hljs-title function_">setDragImage</span>(dragImage, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>);
});
</code></pre>
<p><strong>问题 3：如何让拖拽预览图有圆角？</strong>
<strong>答案：</strong> 为你在 <code>setDragImage</code> 中使用的自定义预览元素添加 CSS <code>border-radius</code> 属性即可。</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-id">#customDragImage</span> {
  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">10px</span>;
}
</code></pre>
<hr/>
<h3 data-id="heading-2"><strong>ECharts 与响应式布局</strong></h3>
<p><strong>问题 4：你用了 echart，如何让 echart 的内容跟随容器大小而变化？onResize 的时候要怎么做？</strong>
<strong>答案：</strong> 调用 ECharts 实例的 <code>.resize()</code> 方法。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 初始化图表</span>
<span class="hljs-keyword">const</span> myChart = echarts.<span class="hljs-title function_">init</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'chart-container'</span>));

<span class="hljs-comment">// 监听窗口 resize 事件</span>
<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'resize'</span>, <span class="hljs-function">() =&gt;</span> {
  myChart.<span class="hljs-title function_">resize</span>();
});
</code></pre>
<p><strong>问题 5：如果有可伸缩侧边栏之类的，导致容器因为其他原因发生了改变，应该用什么事件监听？</strong>
<strong>答案：</strong> 使用 <code>ResizeObserver</code> API。它可以监听任意 DOM 元素尺寸的变化，而不仅仅是窗口。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> resizeObserver = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResizeObserver</span>(<span class="hljs-function"><span class="hljs-params">entries</span> =&gt;</span> {
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> entry <span class="hljs-keyword">of</span> entries) {
    myChart.<span class="hljs-title function_">resize</span>();
  }
});
resizeObserver.<span class="hljs-title function_">observe</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'chart-container'</span>));
</code></pre>
<hr/>
<h3 data-id="heading-3"><strong>部署、缓存与 CDN</strong></h3>
<p><strong>问题 6：如果是 toc 产品，后端为 index.html 设置了 1 h 的 max age，请问从你重新构建代码发布，大概多久之后，所有用户都可以看到新界面？</strong>
<strong>答案：</strong> 理论上最长需要 1 小时（max-age 时间）加上 CDN 边缘节点的缓存过期时间。但由于用户浏览器缓存、CDN 配置（如是否启用了 <code>stale-while-revalidate</code>）等因素，实际时间可能更长或更短。保守估计，1-2 小时内所有用户会逐渐看到新界面。</p>
<p><strong>问题 7：如果用户访问出现了白屏，是什么原因？</strong>
<strong>答案：</strong> 常见原因包括：</p>
<ol>
<li><strong>JavaScript 加载失败：</strong> 资源路径错误、CDN 故障、网络问题。</li>
<li><strong>JavaScript 执行错误：</strong> 新版本代码存在语法错误或运行时错误，导致应用初始化失败。</li>
<li><strong>资源加载超时。</strong></li>
<li><strong>浏览器兼容性问题。</strong></li>
<li><strong>入口 HTML 文件被缓存（如 index.html），但引用的新版本 JS/CSS 文件无法加载。</strong></li>
</ol>
<p><strong>问题 8：toc 产品大量使用 cdn，请问 cdn 的定价大概多少？针对这样的定价策略，前端应该进行什么样的优化？</strong>
<strong>答案：</strong></p>
<ul>
<li><strong>定价：</strong> 主流云厂商（阿里云、腾讯云）的 CDN 通常按 <strong>流量</strong> 和 <strong>HTTP 请求次数</strong> 计费。流量费用约 0.1 - 0.3 元/GB，请求费用约 0.01 - 0.05 元/万次。上传（回源）流量通常比下载（分发）流量贵。</li>
<li><strong>前端优化：</strong>
<ol>
<li><strong>资源压缩：</strong> 启用 Gzip/Brotli 压缩，图片使用 WebP 格式。</li>
<li><strong>减少请求：</strong> 合并小文件（雪碧图）、利用 HTTP/2 多路复用。</li>
<li><strong>缓存优化：</strong> 为静态资源设置长的 <code>Cache-Control</code> max-age，并使用内容哈希命名实现“永不过期”缓存。</li>
<li><strong>代码分割与懒加载：</strong> 只加载当前页面需要的代码。</li>
<li><strong>使用 CDN 预热功能</strong>，将重要资源提前推送到边缘节点。</li>
</ol>
</li>
</ul>
<p><strong>问题 9：前端应用中？上传贵还是下载贵？上传快还是下载快？</strong>
<strong>答案：</strong> 在 CDN 语境下，<strong>上传（回源）通常比下载（分发）贵</strong>。对于普通网络连接，<strong>下载速度通常远快于上传速度</strong>（家庭宽带上下行不对称）。</p>
<hr/>
<h3 data-id="heading-4"><strong>HTTP 缓存与多媒体</strong></h3>
<p><strong>问题 10：图片设置协商缓存后，浏览器会整体缓存，视频能设置协商缓存么？视频的 http 返回内容与图片有什么区别？</strong>
<strong>答案：</strong></p>
<ul>
<li><strong>视频可以设置协商缓存。</strong></li>
<li><strong>区别：</strong> 视频通常支持 <strong>范围请求（Range Requests）</strong>。HTTP 响应头会包含 <code>Accept-Ranges: bytes</code>，并且在请求部分视频时，状态码是 <code>206 Partial Content</code> 而不是 <code>200 OK</code>。这使得客户端可以只请求视频的某一部分，而不是整个文件。</li>
</ul>
<p><strong>问题 11：如何降低视频展示的成本？</strong>
<strong>答案：</strong></p>
<ol>
<li><strong>使用高效的视频编码：</strong> 如 H.265/HEVC 或 AV1，在相同质量下文件更小。</li>
<li><strong>自适应码流：</strong> 使用 HLS 或 DASH 等技术，根据用户网速动态切换不同清晰度的视频流。</li>
<li><strong>CDN 加速。</strong></li>
<li><strong>视频压缩与优化：</strong> 在可接受的范围内降低码率和分辨率。</li>
<li><strong>懒加载：</strong> 视频进入视口后再开始加载。</li>
</ol>
<hr/>
<h3 data-id="heading-5"><strong>设计与视觉</strong></h3>
<p><strong>问题 12：既然有那么多 4k，2k，屏幕，为啥设计师的图还是以 1280 为主？是什么原因导致的？</strong>
<strong>答案：</strong> 主要原因：</p>
<ol>
<li><strong>历史与兼容性：</strong> 1280px 是长期以来最主流和稳定的屏幕宽度基准。</li>
<li><strong>开发效率：</strong> 提供一个标准尺寸便于设计和开发对齐。</li>
<li><strong>内容可读性：</strong> 过宽的单行文本不利于阅读，设计稿更关注核心内容的布局。</li>
<li><strong>响应式设计：</strong> 设计以 1280px 为“桌面端”基准，然后通过响应式规则适配更大或更小的屏幕，而非直接为 4K 设计。</li>
</ol>
<p><strong>问题 13：高分辨率图片在低分辨率屏幕上为什么会糊？为什么会有图片明明正常但是一旦有动画之后也糊了？遇到这种问题如何解决？</strong>
<strong>答案：</strong></p>
<ul>
<li><strong>原因1（高分辨率图在低分辨率屏）：</strong> 浏览器需要将高像素密度的图片压缩到更少的物理像素上显示，这个“下采样”过程可能导致模糊和细节损失。</li>
<li><strong>原因2（动画后变糊）：</strong> 浏览器为了动画性能，可能会将动画元素提升到独立的合成层（GPU 渲染）。在层创建或变换过程中，如果处理不当（如不是整数像素移动），抗锯齿算法可能导致暂时性模糊。</li>
<li><strong>解决方案：</strong>
<ol>
<li>使用 <code>srcset</code> 和 <code>sizes</code> 属性为不同屏幕提供合适的图片尺寸。</li>
<li>对动画元素应用 <code>transform: translateZ(0)</code> 或 <code>will-change: transform</code> 来触发 GPU 加速，并确保动画属性（如 <code>transform</code>）的值为整数像素。</li>
<li>检查图片的原始尺寸是否与显示尺寸匹配。</li>
</ol>
</li>
</ul>
<p><strong>问题 14：设计师给了一套 SVG 图片，图片在 macos 上显示正常，但在 windows 下十分模糊，是你的代码问题还是设计师出的图片的问题？如果有这样的情况，最后是如何解决的？</strong>
<strong>答案：</strong> 这通常是 <strong>代码或环境问题</strong>，而非 SVG 源文件问题。SVG 是矢量格式，理论上应在任何分辨率下都清晰。</p>
<ul>
<li><strong>常见原因与解决方案：</strong>
<ol>
<li><strong>CSS 尺寸问题：</strong> 确保 SVG 的容器尺寸是整数像素，避免非整数缩放。<code>width: 100.5px</code> 可能导致模糊。</li>
<li><strong>Viewport 和 ViewBox 不匹配：</strong> 检查 SVG 代码中的 <code>viewBox</code> 属性，并确保其与显示尺寸成比例。</li>
<li><strong>浏览器渲染引擎差异：</strong> macOS 和 Windows 的字体渲染和图形抗锯齿算法不同。可以尝试为 SVG 添加 <code>shape-rendering: geometricPrecision;</code> CSS 属性。</li>
<li><strong>位图嵌入：</strong> 如果 SVG 内嵌了模糊的位图，那么在 Windows 上也会模糊。</li>
</ol>
</li>
</ul>
<hr/>
<h3 data-id="heading-6"><strong>TypeScript</strong></h3>
<p><strong>问题 15：ts 开发下，interface 和对象类型声明可不可以用来声明数组和函数？</strong>
<strong>答案：</strong> 可以。</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 声明数组</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">NumberArray</span> {
  [<span class="hljs-attr">index</span>: <span class="hljs-built_in">number</span>]: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 索引签名</span>
}
<span class="hljs-keyword">type</span> <span class="hljs-title class_">NumberArrayType</span> = <span class="hljs-built_in">number</span>[]; <span class="hljs-comment">// 更简单的方式</span>

<span class="hljs-comment">// 声明函数</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">SearchFunc</span> {
  (<span class="hljs-attr">source</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">subString</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">boolean</span>; <span class="hljs-comment">// 调用签名</span>
}
<span class="hljs-keyword">type</span> <span class="hljs-title class_">SearchFuncType</span> = <span class="hljs-function">(<span class="hljs-params">source: <span class="hljs-built_in">string</span>, subString: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">boolean</span>;
</code></pre>
<p><strong>问题 16：如果声明函数，函数名可不可以重复？函数名如果重复，意味着什么？</strong>
<strong>答案：</strong> 在同一个作用域内，<strong>不允许</strong>直接声明同名函数（会报错）。但在接口或类中，可以通过 <strong>函数重载</strong> 来声明多个同名但参数/返回值不同的函数签名。</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 函数重载</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">string</span>;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">age: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">string</span>;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">value: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">string</span> {
  <span class="hljs-comment">// 实现...</span>
}
</code></pre>
<p>重复的函数名意味着重载，调用时会根据传入的参数类型来匹配对应的签名。</p>
<hr/>
<h3 data-id="heading-7"><strong>Vue.js 深度知识</strong></h3>
<p><strong>问题 17：如果你用的是 Vue，在 Vue 的 ts 用法中，哪些 api 的用法利用了 ts 这一特性？</strong>
<strong>答案：</strong></p>
<ol>
<li><strong>Props 类型定义：</strong> 使用 <code>defineProps&lt;{ ... }&gt;()</code> 进行严格的类型检查。</li>
<li><strong>组件实例类型：</strong> 使用 <code>InstanceType&lt;typeof MyComponent&gt;</code> 来获取模板引用（ref）的类型。</li>
<li><strong>Composables 类型推断：</strong> <code>ref</code>， <code>computed</code> 会自动推断类型，<code>reactive</code> 也会基于对象字面量推断。</li>
<li><strong>事件类型定义：</strong> 使用 <code>defineEmits&lt;{ ... }&gt;()</code> 来定义和校验组件发出的事件及其载荷。</li>
</ol>
<p><strong>问题 18：Vue 中，是不是所有情况下，template 都会自动获取 ref 的 .value 属性？如果不是，列举不会自动获取的情况。</strong>
<strong>答案：</strong> 不是所有情况。</p>
<ul>
<li><strong>会自动解包 .value 的情况：</strong>
<ul>
<li>在 <code>&lt;script setup&gt;</code> 中声明的顶级 <code>ref</code>，在模板中直接使用无需 <code>.value</code>。</li>
<li><code>ref</code> 在模板中作为响应式对象的属性时（如 <code>obj.count</code>），如果该 <code>ref</code> 是通过 <code>reactive</code> 访问的，会自动解包。</li>
</ul>
</li>
<li><strong>不会自动解包的情况：</strong>
<ul>
<li>在 Options API 的 <code>data()</code> 函数中返回的对象的属性不是 <code>ref</code>，无需解包。</li>
<li>当 <code>ref</code> 是<strong>数组或 Map 等原生集合类型</strong>的一个元素时，不会自动解包。例如：<code>const list = ref([1, 2, 3])</code>，在模板中使用 <code>list[0]</code> 不会自动解包，需要 <code>list[0].value</code>（但在模板中应避免这样写，通常应解构到响应式对象中）。</li>
</ul>
</li>
</ul>
<p><strong>问题 19：在 Vue 响应式系统中，给对象的子属性对象赋值一个新对象，是否还有响应式？详细阐述一下。</strong>
<strong>答案：</strong> <strong>有响应式</strong>，但需要理解其原理。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>({
  <span class="hljs-attr">nested</span>: { <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> }
});

<span class="hljs-comment">// 这个操作是响应式的</span>
state.<span class="hljs-property">nested</span> = { <span class="hljs-attr">count</span>: <span class="hljs-number">1</span> }; <span class="hljs-comment">// Vue 能检测到 `nested` 属性被重新赋值了</span>
</code></pre>
<p>Vue 的响应式系统通过 Proxy 跟踪<strong>对象属性的访问和设置</strong>。当你给 <code>state.nested</code> 赋一个新值时，Vue 会检测到这个设置操作，并触发相应的更新。同时，新赋值的对象 <code>{ count: 1 }</code> 会被自动转换为一个响应式对象。</p>
<p><strong>问题 20：如果你使用 Vue 和 pinia 开发了一个应用，用到了 persist 插件进行持久化，结果发现应用卡顿难以接受，请问卡顿最有可能是什么原因导致的？</strong>
<strong>答案：</strong> 最可能的原因是 <strong>持久化的数据量过大或序列化/反序列化操作过于频繁</strong>。</p>
<ul>
<li><strong>具体原因：</strong>
<ol>
<li><strong>大数据量：</strong> 将整个庞大的状态树（如大型列表、复杂嵌套对象）持久化到 <code>localStorage</code>（同步 API），每次读写都会阻塞主线程。</li>
<li><strong>频繁存储：</strong> 插件配置为每次状态变化都立即持久化（<code>debounce</code> 配置不合理），导致频繁的同步写入操作。</li>
</ol>
</li>
<li><strong>解决方案：</strong>
<ol>
<li>只持久化必要的状态，使用 <code>paths</code> 选项排除大数据。</li>
<li>增加防抖（debounce）时间，减少持久化频率。</li>
<li>考虑使用异步存储后端，如 <code>sessionStorage</code> 或 <code>IndexedDB</code>（如果插件支持）。</li>
</ol>
</li>
</ul>
<p><strong>问题 21：Vue 的响应式系统，可否用一个 class 初始化的对象声明 reactive？会有什么后果？（如果他了解 React，问 React 的 useState 可不可以）</strong>
<strong>答案：</strong></p>
<ul>
<li><strong>Vue：</strong> <strong>可以，但不推荐，可能会丢失响应性。</strong>
<ul>
<li><strong>后果：</strong> Vue 的 <code>reactive()</code> API 基于 ES6 Proxy。如果一个 class 实例的属性是在构造函数中通过 <code>this.key = value</code> 定义的，Proxy 可以正常工作。但如果属性是在 class 的方法中动态添加的，或者涉及继承链，Vue 可能无法可靠地追踪这些变化。最佳实践是使用普通对象字面量。</li>
</ul>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyState</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"/>) { <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> = <span class="hljs-number">0</span>; } <span class="hljs-comment">// 可响应</span>
  <span class="hljs-title function_">increment</span>(<span class="hljs-params"/>) { <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++; }     <span class="hljs-comment">// 可响应</span>
  <span class="hljs-title function_">addNewProp</span>(<span class="hljs-params"/>) { <span class="hljs-variable language_">this</span>.<span class="hljs-property">newProp</span> = <span class="hljs-number">1</span>; } <span class="hljs-comment">// 可能无法被 Vue 自动追踪</span>
}
<span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyState</span>());
</code></pre>
</li>
<li><strong>React：</strong> <strong>可以，但极其不推荐。</strong>
<ul>
<li><strong>原因：</strong> React 的状态更新依赖于 <code>setState</code> 或 setter 函数触发的重新渲染。直接修改 class 实例的属性（<code>myState.count++</code>）不会触发渲染，因为 React 无法感知到变化。你必须创建一个新的对象引用来驱动更新。</li>
</ul>
</li>
</ul>
<p><strong>问题 22：Vue 中的 pinia 和 pinia 配合依赖注入使用，与单纯的依赖注入有哪些区别？</strong>
<strong>答案：</strong></p>
<ul>
<li><strong>单纯的依赖注入（provide/inject）：</strong> 是一种直接的父子组件间传递数据/方法的方式。它是<strong>局部的</strong>，需要在上层组件 <code>provide</code>，在下层组件 <code>inject</code>。数据本身不一定是响应式的（除非你提供的是一个 <code>ref</code> 或 <code>reactive</code> 对象），并且缺乏像 Pinia 那样的集中式状态管理、DevTools 集成和时间旅行调试能力。</li>
<li><strong>Pinia：</strong> 是<strong>全局状态管理库</strong>。它提供了一个中心化的 store，任何组件都可以导入并使用。状态天生是响应式的，并具有完善的模块化、TypeScript 支持和调试工具。</li>
<li><strong>Pinia + 依赖注入：</strong> 结合两者，通常是为了 <strong>更好的测试和解耦</strong>。你可以在根组件提供一个 Pinia store 的实例，然后在子组件中注入它。这样做的好处是，在测试时，你可以轻松地提供一个模拟的 store 实例给组件，而不需要依赖真实的全局 store 实例，使得测试更加隔离和容易。</li>
</ul>
<hr/>
<h3 data-id="heading-8"><strong>工程化与业务逻辑</strong></h3>
<p><strong>问题 23：如果项目主包太大，有什么方法可以优化？</strong>
<strong>答案：</strong></p>
<ol>
<li><strong>代码分割（Code Splitting）：</strong> 使用动态 <code>import()</code> 语法实现路由级和组件级懒加载。</li>
<li><strong>Tree Shaking：</strong> 确保引入的第三方库支持 ES 模块，并只引入需要的部分。</li>
<li><strong>分析包体积：</strong> 使用 <code>webpack-bundle-analyzer</code> 等工具找出体积过大的模块。</li>
<li><strong>压缩资源：</strong> 使用 Terser 压缩 JS，CssMinimizer 压缩 CSS。</li>
<li><strong>优化第三方库：</strong> 考虑用更轻量的替代品（如 day.js 代替 moment.js）。</li>
<li><strong>图片等资源外部化。</strong></li>
</ol>
<p><strong>问题 24：如何解决删除一个项目之后，表格分页为空的问题？</strong>
<strong>答案：</strong> 在成功删除一项后，需要重新计算当前页码。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 伪代码</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">handleDelete</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">id</span>) =&gt; {
  <span class="hljs-keyword">await</span> api.<span class="hljs-title function_">deleteItem</span>(id);
  <span class="hljs-comment">// 删除成功后</span>
  <span class="hljs-keyword">const</span> currentPage = pagination.<span class="hljs-property">current</span>;
  <span class="hljs-keyword">const</span> totalAfterDelete = totalCount - <span class="hljs-number">1</span>;
  <span class="hljs-keyword">const</span> pageSize = pagination.<span class="hljs-property">pageSize</span>;

  <span class="hljs-comment">// 如果当前页不再是有效页（例如，最后一页的唯一一项被删除了），则跳回上一页</span>
  <span class="hljs-keyword">if</span> (currentPage &gt; <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">ceil</span>(totalAfterDelete / pageSize)) {
    pagination.<span class="hljs-property">current</span> = currentPage - <span class="hljs-number">1</span>;
  }

  <span class="hljs-comment">// 重新获取数据</span>
  <span class="hljs-title function_">fetchData</span>();
};
</code></pre>
<p><strong>问题 25：上传时，假设后端没有用对象存储，你应该如何与后端配合，实现上传和下载进度？</strong>
<strong>答案：</strong></p>
<ul>
<li><strong>上传进度：</strong> 使用 XMLHttpRequest 或 Axios 等库的进度事件。
<pre><code class="hljs language-javascript" lang="javascript">axios.<span class="hljs-title function_">post</span>(<span class="hljs-string">'/upload'</span>, formData, {
  <span class="hljs-attr">onUploadProgress</span>: <span class="hljs-function">(<span class="hljs-params">progressEvent</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> percentCompleted = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>((progressEvent.<span class="hljs-property">loaded</span> * <span class="hljs-number">100</span>) / progressEvent.<span class="hljs-property">total</span>);
    <span class="hljs-comment">// 更新进度条</span>
  }
})
</code></pre>
</li>
<li>***   <strong>下载进度：</strong> 同样利用进度事件，但需要后端在响应头中正确设置 <code>Content-Length</code>。
<pre><code class="hljs language-javascript" lang="javascript">axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">'/download/file.pdf'</span>, {
  <span class="hljs-attr">onDownloadProgress</span>: <span class="hljs-function">(<span class="hljs-params">progressEvent</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> percentCompleted = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>((progressEvent.<span class="hljs-property">loaded</span> * <span class="hljs-number">100</span>) / progressEvent.<span class="hljs-property">total</span>);
    <span class="hljs-comment">// 更新进度条</span>
  },
  <span class="hljs-attr">responseType</span>: <span class="hljs-string">'blob'</span> <span class="hljs-comment">// 重要：对于文件下载</span>
})
</code></pre>
</li>
</ul>
<hr/>
<h3 data-id="heading-9"><strong>HTTP 缓存策略与服务端渲染</strong></h3>
<p><strong>问题 26：stale-while-revalidate 这字段出现在 http 什么位置，用来做什么的？它和服务端渲染有什么关系？</strong>
<strong>答案：</strong></p>
<ul>
<li><strong>位置：</strong> 它是 <code>Cache-Control</code> 响应头的一个指令，例如：<code>Cache-Control: max-age=600, stale-while-revalidate=30</code></li>
<li><strong>作用：</strong> 在 <code>max-age</code>（600秒）过期后，还有一个 <code>stale-while-revalidate</code>（30秒）的“宽限期”。在这30秒内，浏览器会<strong>立即使用已过期的缓存（stale）</strong> 来响应用户请求，同时<strong>在后台向服务器发起验证请求（revalidate）</strong> 以获取最新内容并更新缓存。这极大地提升了用户体验，实现了“瞬间加载”。</li>
<li><strong>与 SSR 的关系：</strong> 在 SSR 应用中，HTML 页面本身是动态的。如果对 HTML 页面设置 <code>stale-while-revalidate</code>，可以让用户在页面缓存过期后依然能快速看到内容（即使是略微过时的内容），同时在后台获取最新的服务端渲染页面。这完美结合了缓存的性能和 SSR 的 SEO/首屏优势。</li>
</ul>
<p><strong>问题 27：国内的生态对这个字段的支持程度如何？你会在项目中使用服务端渲染么？</strong>
<strong>答案：</strong></p>
<ul>
<li><strong>支持程度：</strong> 主流现代浏览器（Chrome, Edge, Firefox, Safari）均已支持。国内移动端浏览器（如 UC、QQ）内核较老，可能存在兼容性问题，需根据目标用户群体决定是否使用。</li>
<li><strong>是否使用 SSR：</strong>
<ul>
<li><strong>会用 SSR 的场景：</strong> 对 SEO 有极高要求的 ToC 网站（如官网、博客、电商列表页）、对首屏加载速度有极致追求的应用。</li>
<li><strong>不会用 SSR 的场景：</strong> 复杂的后台管理系统、强交互型 Web App、对搜索引擎无需求的内部工具。在这些场景下，SSR 带来的服务器成本和架构复杂性可能得不偿失。</li>
</ul>
</li>
</ul>
<hr/>
<h3 data-id="heading-10"><strong>数据迁移与错误处理</strong></h3>
<p><strong>问题 28：假设你在 localStorage 或者 indexedDB 中存储了数据结构，但是版本更新后需要用新的数据结构，你会用什么方法进行迁移？</strong>
<strong>答案：</strong> 实施一个<strong>版本化迁移策略</strong>。</p>
<ol>
<li><strong>存储版本号：</strong> 在存储数据时，同时存储一个版本号（如 <code>dataVersion: '1.0'</code>）。</li>
<li><strong>启动时检查：</strong> 应用启动时，读取当前存储的版本号，并与代码中期望的最新版本号比较。</li>
<li><strong>执行迁移：</strong> 如果版本不一致，则按顺序执行从一个版本到下一个版本的迁移函数。</li>
<li><strong>更新版本号：</strong> 迁移成功后，更新存储中的版本号为最新版。</li>
</ol>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 迁移函数示例</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">migrateUserData</span> = (<span class="hljs-params">oldData</span>) =&gt; {
  <span class="hljs-keyword">const</span> currentVersion = oldData.<span class="hljs-property">version</span> || <span class="hljs-string">'1.0'</span>;
  <span class="hljs-keyword">if</span> (currentVersion === <span class="hljs-string">'1.0'</span>) {
    <span class="hljs-comment">// 从 1.0 迁移到 2.0</span>
    <span class="hljs-keyword">const</span> newData = {
      <span class="hljs-attr">version</span>: <span class="hljs-string">'2.0'</span>,
      <span class="hljs-attr">profile</span>: { ...oldData.<span class="hljs-property">userInfo</span> } <span class="hljs-comment">// 转换数据结构</span>
    };
    <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">'userData'</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(newData));
    <span class="hljs-keyword">return</span> newData;
  }
  <span class="hljs-comment">// ... 其他版本迁移</span>
};
</code></pre>
<p><strong>问题 29：假设是混合应用，用户可能用着各种历史版本，又该如何迁移？</strong>
<strong>答案：</strong> 迁移策略需要是<strong>幂等</strong>和<strong>向后兼容</strong>的。</p>
<ul>
<li><strong>幂等：</strong> 同一个迁移函数执行多次的结果应该是一样的。避免因重复执行导致数据错误。</li>
<li><strong>向后兼容：</strong> 新版本的代码应该能够读取和理解旧版本的数据结构。在迁移完成前，应用逻辑应能处理新旧两种数据结构。</li>
</ul>
<p><strong>问题 30：如果用户因为数据迁移出现了白屏，如何定位问题？如何及时补救？</strong>
<strong>答案：</strong></p>
<ul>
<li><strong>定位问题：</strong>
<ol>
<li><strong>错误监控：</strong> 接入 Sentry 等错误监控平台，捕获迁移过程中抛出的异常。</li>
<li><strong>日志记录：</strong> 在迁移的关键步骤中加入详细的日志，记录旧版本号、新版本号、迁移结果等。</li>
<li><strong>用户反馈：</strong> 建立用户反馈渠道，收集出现白屏的用户的浏览器版本、操作步骤等信息。</li>
</ol>
</li>
<li><strong>及时补救：</strong>
<ol>
<li><strong>安全模式：</strong> 在迁移代码外围使用 <code>try-catch</code>。如果迁移失败，捕获错误，清除损坏的存储数据或回退到旧版本数据结构，并引导用户重新初始化应用。</li>
<li><strong>热修复：</strong> 如果问题普遍，通过热修复平台紧急下发修复补丁，修正迁移逻辑。</li>
<li><strong>版本回退：</strong> 在严重情况下，可以考虑回退应用版本。</li>
</ol>
</li>
</ul>
<hr/>
<h3 data-id="heading-11"><strong>富文本与协作</strong></h3>
<p><strong>问题 31：在基础富文本开发中，如果光标跨越了多个节点，如何正确通过 getSelection 进行选取？</strong>
<strong>答案：</strong> 使用 <code>Selection</code> 和 <code>Range</code> API。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> selection = <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">getSelection</span>();
<span class="hljs-comment">// 获取用户选中的范围</span>
<span class="hljs-keyword">if</span> (selection.<span class="hljs-property">rangeCount</span> &gt; <span class="hljs-number">0</span>) {
  <span class="hljs-keyword">const</span> range = selection.<span class="hljs-title function_">getRangeAt</span>(<span class="hljs-number">0</span>);
  <span class="hljs-keyword">const</span> startContainer = range.<span class="hljs-property">startContainer</span>; <span class="hljs-comment">// 起始节点</span>
  <span class="hljs-keyword">const</span> startOffset = range.<span class="hljs-property">startOffset</span>;       <span class="hljs-comment">// 起始偏移量</span>
  <span class="hljs-keyword">const</span> endContainer = range.<span class="hljs-property">endContainer</span>;     <span class="hljs-comment">// 结束节点</span>
  <span class="hljs-keyword">const</span> endOffset = range.<span class="hljs-property">endOffset</span>;           <span class="hljs-comment">// 结束偏移量</span>

  <span class="hljs-comment">// 现在你可以操作这个 range，例如插入节点、获取选中内容等</span>
  <span class="hljs-keyword">const</span> selectedContent = range.<span class="hljs-title function_">cloneContents</span>();
}
</code></pre>
<p><strong>问题 32：如果不使用浏览器默认高亮，如何让这些选区高亮起来？</strong>
<strong>答案：</strong> 手动高亮。</p>
<ol>
<li><strong>遍历范围内容：</strong> 使用 <code>Range</code> 的 <code>.cloneContents()</code> 或 <code>.extractContents()</code> 方法获取选区内的 DOM 节点。</li>
<li><strong>包裹高亮元素：</strong> 遍历这些节点，用带有高亮样式（如 <code>background-color: yellow;</code>）的 HTML 元素（如 <code>&lt;mark&gt;</code> 或 <code>&lt;span&gt;</code>）将文本节点包裹起来。</li>
<li><strong>重新插入：</strong> 将处理后的节点重新插入到 DOM 中。更高级的做法是使用 <code>CSS.highlights</code> API（实验性）。</li>
</ol>
<p><strong>问题 33：多人共同编辑的文档，如何保证云端缓存和本地缓存的一致性？这方面如何与后端配合？</strong>
<strong>答案：</strong> 使用 <strong>操作转换（OT）</strong> 或 <strong>冲突-free 复制数据类型（CRDT）</strong> 算法。</p>
<ul>
<li><strong>核心思想：</strong> 不是简单地覆盖数据，而是将用户的操作（如“在位置5插入字符‘A’”）作为指令发送到服务端。</li>
<li><strong>与后端配合：</strong>
<ol>
<li><strong>版本控制：</strong> 每个操作都有一个版本号（或向量时钟）。</li>
<li><strong>服务端协调：</strong> 后端作为中央协调者，接收来自各客户端的操作，进行转换（解决冲突，例如两个用户同时在位置5插入不同字符），然后广播转换后的操作给所有客户端。</li>
<li><strong>确认机制：</strong> 客户端只有收到服务端确认的操作才会应用到本地文档，确保最终一致性。</li>
</ol>
</li>
</ul>
<hr/>
<h3 data-id="heading-12"><strong>浏览器安全与图形学</strong></h3>
<p><strong>问题 34：如果使用浏览器用户标识，并进行插件开发，插件中有个 iframe，请问 iframe 里面的用户标识和插件的用户标识，是同一个，还是不同的？</strong>
<strong>答案：</strong> 这取决于 iframe 的源（origin）。</p>
<ul>
<li><strong>同源 iframe：</strong> <strong>是同一个</strong>。它们共享相同的 origin，因此共享相同的存储（如 localStorage）、Cookie 和用户标识。</li>
<li><strong>跨域 iframe：</strong> <strong>是不同的</strong>。由于浏览器的同源策略，插件的上下文和跨域 iframe 的上下文是相互隔离的。它们拥有独立的存储空间和用户标识。通信需要通过 <code>postMessage</code> API。</li>
</ul>
<p><strong>问题 35：如何实现提取图片主题颜色和分级颜色的功能，如果实现了，对后端有什么要求？</strong>
<strong>答案：</strong></p>
<ul>
<li><strong>前端实现：</strong>
<ol>
<li>使用 <code>Canvas</code> API 将图片绘制到画布上。</li>
<li>通过 <code>getImageData()</code> 方法获取像素数据（一个包含 RGBA 值的巨大数组）。</li>
<li>使用聚类算法（如 K-means）或量化算法对像素颜色进行分组，找出主要的颜色簇。</li>
</ol>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> img = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Image</span>();
img.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> canvas = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">'canvas'</span>);
  <span class="hljs-keyword">const</span> ctx = canvas.<span class="hljs-title function_">getContext</span>(<span class="hljs-string">'2d'</span>);
  ctx.<span class="hljs-title function_">drawImage</span>(img, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
  <span class="hljs-keyword">const</span> imageData = ctx.<span class="hljs-title function_">getImageData</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, img.<span class="hljs-property">width</span>, img.<span class="hljs-property">height</span>).<span class="hljs-property">data</span>;
  <span class="hljs-comment">// 分析 imageData，提取主题色</span>
};
img.<span class="hljs-property">src</span> = <span class="hljs-string">'image.jpg'</span>;
</code></pre>
</li>
<li><strong>对后端的要求：</strong> 如果在前端处理大图片可能性能不佳，可以将此任务<strong>卸载到后端</strong>。后端需要提供相应的图片处理接口，接收图片文件，返回分析出的主题色数组。这要求后端有强大的图片处理能力和计算资源。</li>
</ul>
<p><strong>问题 36：hsl 和 oklch 颜色表示法相比 rgb 好在哪里？有哪些前端 UI 框架使用了这些色彩表示法？</strong>
<strong>答案：</strong></p>
<ul>
<li><strong>优势：</strong>
<ul>
<li><strong>HSL（Hue, Saturation, Lightness）：</strong> 更直观，易于人类理解和调整。比如，想得到一个更深的蓝色，只需减小 L（明度）值。</li>
<li><strong>OKLCH：</strong> 是基于 OKLab 色彩空间的改进版，比 HSL 和 RGB <strong>在感知上更均匀</strong>。这意味着，颜色数值上的等量变化，会带来人眼感知上接近的视觉变化。这对于生成和谐的调色板、无障碍设计和主题切换至关重要。</li>
</ul>
</li>
<li><strong>使用框架：</strong>
<ul>
<li><strong>Tailwind CSS v3.x</strong> 已在其默认调色板中使用了 OKLCH。</li>
<li><strong>Adobe 的 Spectrum</strong> 设计系统也在向 OKLCH 迁移。</li>
<li>许多新兴的 CSS-in-JS 库和主题系统开始支持 OKLCH。</li>
</ul>
</li>
</ul>
<p><strong>问题 37：如果要你利用其做一个多主题系统，你会如何设计架构？</strong>
<strong>答案：</strong> 采用 <strong>CSS 变量（Custom Properties） + OKLCH/HSL</strong> 的架构。</p>
<ol>
<li><strong>定义设计令牌：</strong> 使用 OKLCH 定义一套核心的颜色、间距、字体等变量。
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-pseudo">:root</span> {
  <span class="hljs-attr">--primary-color</span>: <span class="hljs-built_in">lch</span>(<span class="hljs-number">60%</span> <span class="hljs-number">60</span> <span class="hljs-number">250</span>); <span class="hljs-comment">/* 使用 OKLCH */</span>
  <span class="hljs-attr">--text-color</span>: <span class="hljs-built_in">lch</span>(<span class="hljs-number">20%</span> <span class="hljs-number">5</span> <span class="hljs-number">250</span>);
  <span class="hljs-attr">--spacing-unit</span>: <span class="hljs-number">8px</span>;
}
</code></pre>
</li>
<li><strong>主题派生：</strong> 通过覆盖这些 CSS 变量的值来创建不同的主题。
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-class">.theme-dark</span> {
  <span class="hljs-attr">--primary-color</span>: <span class="hljs-built_in">lch</span>(<span class="hljs-number">80%</span> <span class="hljs-number">50</span> <span class="hljs-number">250</span>);
  <span class="hljs-attr">--text-color</span>: <span class="hljs-built_in">lch</span>(<span class="hljs-number">90%</span> <span class="hljs-number">5</span> <span class="hljs-number">250</span>);
}
</code></pre>
</li>
<li><strong>组件使用：</strong> 在所有组件中只使用这些设计令牌变量。
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-class">.button</span> {
  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">var</span>(--primary-color);
  <span class="hljs-attribute">color</span>: <span class="hljs-built_in">var</span>(--text-color);
  <span class="hljs-attribute">padding</span>: <span class="hljs-built_in">calc</span>(<span class="hljs-built_in">var</span>(--spacing-unit) * <span class="hljs-number">2</span>);
}
</code></pre>
</li>
<li><strong>动态切换：</strong> 通过 JavaScript 切换根元素或 body 元素的类名，即可实现主题的动态切换。OKLCH 的感知均匀性保证了不同主题下的视觉和谐度。</li>
</ol>
<hr/>
<h3 data-id="heading-13"><strong>HTTP RESTful API</strong></h3>
<p><strong>问题 38：http RESTFUL 请求中，put 和 post 分别代表什么？put 分别代表新增和修改的情况下，前后端的数据和逻辑会有怎样的差异？</strong>
<strong>答案：</strong></p>
<ul>
<li><strong>POST：</strong> 用于<strong>创建</strong>新资源。它是<strong>非幂等</strong>的（多次调用会产生多个资源）。通常，URL 指向的是资源集合（如 <code>/api/users</code>），请求体包含新资源的详细信息。响应通常返回 <code>201 Created</code> 和新资源的 URI。</li>
<li><strong>PUT：</strong> 用于<strong>更新/替换</strong>现有资源，或<strong>在客户端知道资源最终 URI 时创建</strong>资源。它是<strong>幂等</strong>的（多次调用效果相同）。
<ul>
<li><strong>用于修改（更新）：</strong> URL 指向一个特定的资源（如 <code>/api/users/123</code>）。请求体应包含该资源的<strong>完整表示</strong>。后端逻辑是<strong>用请求体提供的数据完全替换</strong>目标资源。如果资源不存在，可以返回 <code>404 Not Found</code>，或者根据约定创建它（返回 <code>201 Created</code>）。</li>
<li><strong>用于新增（创建）：</strong> 客户端明确指定新资源的 URI（如 <code>/api/users/123</code>）。后端检查该 URI 是否存在资源。如果不存在，则创建；如果已存在，则完全替换。这要求客户端拥有分配资源 ID 的能力。</li>
</ul>
</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Promise静态方法解析]]></title>    <link>https://juejin.cn/post/7591715454135566399</link>    <guid>https://juejin.cn/post/7591715454135566399</guid>    <pubDate>2026-01-06T03:15:11.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7591715454135566399" data-draft-id="7591730714141392938" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Promise静态方法解析"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2026-01-06T03:15:11.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="wuhen_n"/> <meta itemprop="url" content="https://juejin.cn/user/4149996261738233"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Promise静态方法解析
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4149996261738233/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    wuhen_n
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-06T03:15:11.000Z" title="Tue Jan 06 2026 03:15:11 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-06
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>本专栏聚焦Promise的核心原理与高级应用，包含：
✓ Promise A+规范深度解读
✓ 手写实现与源码分析
✓ 异步编程设计模式
✓ 性能调优与错误处理</p>
</blockquote>
<blockquote>
<p>适合有JavaScript基础，希望深入异步编程的开发者。我们将用最少的篇幅，讲透最核心的知识。</p>
</blockquote>
<h2 data-id="heading-0">引言：Promise静态方法</h2>
<p>在之前的文章中，我们探讨了Promise的状态机制和实例方法。本篇文章将介绍Promise的静态方法，即：直接通过Promise类调用的方法。我将这些方法分成了两个大类，一类是创建类方法，一类是控制类方法：</p>
<ul>
<li>
<p>创建类方法：创建Promise的多种方式，主要分为三种： <code>Promise构造函数</code>、<code>Promise.resolve()</code>、<code>Promise.reject()</code> 。</p>
</li>
<li>
<p>控制类方法：本质是管理控制多个Promise，并使其能协调工作，主要包括：<code>Promise.all()</code>、<code>Promise.race()</code>、<code>Promise.allSettled()</code>、<code>Promise.any()</code> 。</p>
</li>
</ul>
<h2 data-id="heading-1">创建类方法</h2>
<h3 data-id="heading-2">Promise构造函数</h3>
<h4 data-id="heading-3">Promise构造函数的基本语法</h4>
<p><code>Promise构造函数</code>是创建Promise对象的根本方法，它将回调的异步操作包装为Promise，其基本语法如下：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> myPromise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {})
</code></pre>
<p>上述代码创建了一个空的Promise对象，我们在创建Promise时，也可以进行一些初始化操作，如以下代码所示：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> myPromise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    <span class="hljs-comment">// 这个函数会立即执行</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'executor开始执行'</span>);

    <span class="hljs-comment">// 异步操作</span>
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-keyword">const</span> success = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() &gt; <span class="hljs-number">0.5</span>;

        <span class="hljs-keyword">if</span> (success) {
            <span class="hljs-title function_">resolve</span>(<span class="hljs-string">'操作成功'</span>);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'操作失败'</span>));
        }
    }, <span class="hljs-number">1000</span>);

    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'executor执行完毕'</span>);
});

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Promise已创建，状态:'</span>, myPromise);
</code></pre>
<p>这段代码的执行结果是：</p>
<pre><code class="hljs language-bash" lang="bash">executor开始执行
executor执行完毕
Promise已创建，状态: Promise { &lt;pending&gt; }
</code></pre>
<p>从结果中可以看出，此时的Promise状态一直为<code>pending</code> 。</p>
<h4 data-id="heading-4">构造函数的三大特性</h4>
<h5 data-id="heading-5">立即执行</h5>
<p>Promise构造函数中的同步代码会立即执行，而异步代码不会执行。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'开始'</span>);
<span class="hljs-keyword">const</span> myPromise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'executor执行中...'</span>);
    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">'完成'</span>);
});
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'结束'</span>);
</code></pre>
<p>上述代码的执行结果是：</p>
<pre><code class="hljs language-javascript" lang="javascript">开始
executor执行中...
结束
</code></pre>
<h5 data-id="heading-6">resolve/reject只能调用一次</h5>
<p>由于Promise的状态机制，Promise中的resolve/reject只能调用一次，多个resolve/reject会被自动忽略，不会执行：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> myPromise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">'第一次调用有效'</span>);
    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">'第二次调用被忽略'</span>); <span class="hljs-comment">// 无效</span>
    <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'这个也被忽略'</span>)); <span class="hljs-comment">// 无效</span>
});
</code></pre>
<h5 data-id="heading-7">异常自动转换为reject</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'执行器异常'</span>); <span class="hljs-comment">// 自动调用reject</span>
    <span class="hljs-comment">// 等同于：reject(new Error('执行器异常'))</span>
});
</code></pre>
<h3 data-id="heading-8">Promise.resolve()</h3>
<p><code>Promise.resolve()</code> 方法用于创建一个状态为 <code>fulfilled</code> 的Promise对象，它其实和 <code>new Promise((resolve, reject) =&gt; resolve())</code> 这段代码等价。使用这个方法，实际上可以把任意值都转成一个Promise，有4种处理模式：</p>
<h4 data-id="heading-9">包装普通值</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> p1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">'hello'</span>);  <span class="hljs-comment">// Promise&lt;fulfilled: 'hello'&gt;</span>
</code></pre>
<p>当有多个值的时候，Promise会怎么处理呢？</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> p2 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">'hello'</span>, <span class="hljs-string">'world'</span>);  <span class="hljs-comment">// Promise&lt;fulfilled: 'hello'&gt;</span>
</code></pre>
<p>在这种情况下，Promise.resolve()只会处理第一个参数，而把后面的参数全部忽略掉，即上述两段代码中p1和p2是等价的：<code>p1 === p2  // true</code> 。</p>
<h4 data-id="heading-10">包装thenable对象</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> thenable = {
    <span class="hljs-attr">then</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">onFulfilled, onRejected</span>) {
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">onFulfilled</span>(<span class="hljs-string">'thenable的结果'</span>), <span class="hljs-number">100</span>);
    }
};
<span class="hljs-keyword">const</span> p = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(thenable);
</code></pre>
<h4 data-id="heading-11">包装异步值</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncFunc</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">'async返回值'</span>;
}
<span class="hljs-keyword">const</span> p = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-title function_">asyncFunc</span>());
</code></pre>
<h4 data-id="heading-12">包装Promise对象</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> originalPromise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> 
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-string">'原始值'</span>), <span class="hljs-number">200</span>)
);

<span class="hljs-keyword">const</span> p = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(originalPromise);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p === originalPromise); <span class="hljs-comment">// true，是同一个对象</span>
</code></pre>
<p>对于这段代码，我们可以看到，<code>p</code> 和 <code>originalPromise</code> 居然也是等价，这又是为什么呢？
原来，当 <code>Promise.resolve()</code> 方法中，接收到一个Promise参数时，那它的行为就类似一个空包装，因此我们也可以是 <code>Promise.resolve()</code> 方法是一个幂等方法，即：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> p = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p === <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(p))));
</code></pre>
<p>上述代码里面无论包多少层<code>Promise.resolve()</code> 方法，其结果永远为true。</p>
<h3 data-id="heading-13">Promise.reject()</h3>
<p>这个方法和 <code>Promise.resolve()</code> 方法对应，用于创建一个 <code>rejected</code> 状态的Promise实例，并抛出一个异步错误。</p>
<blockquote>
<p>注：<code>Promise.resolve()</code> 方法抛出异步错误时，是无法使用try/catch进行捕获的。</p>
</blockquote>
<p><code>Promise.reject()</code> 方法和 <code>Promise.resolve()</code> 方法基本类似，本文不再赘述，唯一要注意的点是：<code>Promise.reject()</code> 方法并没有照搬 <code>Promise.resolve()</code> 方法的幂等逻辑，如果给<code>Promise.reject()</code> 方法传递一个Promise参数，则这个Promise参数会成为它返回的拒绝原因。</p>
<h2 data-id="heading-14">控制类方法</h2>
<p>所谓控制类方法，其实就是Promise提供的将多个Promise实例，组合成一个Promise实例的静态方法，合成后的Promise行为取决于内部约定的行为。</p>
<h3 data-id="heading-15">Promise.all()</h3>
<p><code>Promise.all()</code> 方法创建的Promise，会在所有Promise全部解决后，再解决，即：只要中间有一个Promise状态为 <code>rejected</code> ，则最终结果为<code>rejected</code> 。当有多个Promise状态都为 <code>rejected</code> 时，则第一个状态为 <code>rejected</code> 的Promise实例，会将自己的理由作为最终的拒绝理由。我们来看看下面一个例子：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> fastReject = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">reject</span>(<span class="hljs-string">"快速失败"</span>), <span class="hljs-number">10</span>);
});

<span class="hljs-keyword">const</span> slowReject = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">reject</span>(<span class="hljs-string">"慢速失败"</span>), <span class="hljs-number">100</span>);
});

<span class="hljs-keyword">const</span> fastResolve = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> {
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-string">"快速成功"</span>), <span class="hljs-number">50</span>);
});

<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([fastReject, slowReject, fastResolve])
    .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">results</span>) =&gt;</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"所有 Promise 都成功了:"</span>, results);
    })
    .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Promise.all() 失败:"</span>, error);
    });
</code></pre>
<p>上述代码输出结果是：<code>Promise.all() 失败: 快速失败</code> 。</p>
<h3 data-id="heading-16">Promise.allSettled()</h3>
<p><code>Promise.allSettled()</code> 是ES2020新增的方法，它等待所有Promise完成（无论成功或失败），然后报告每个Promise的结果。相比于 <code>Promise.all()</code> 方法，<code>Promise.allSettled()</code> 更像一个记录员，记录每个Promise的结果。我们来看看下面一个例子：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 创建三个 Promise</span>
<span class="hljs-keyword">const</span> p1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">"成功1"</span>);
<span class="hljs-keyword">const</span> p2 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">"失败2"</span>);
<span class="hljs-keyword">const</span> p3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> {
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-string">"成功3"</span>), <span class="hljs-number">1000</span>);
});

<span class="hljs-comment">// 使用 Promise.allSettled()</span>
<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">allSettled</span>([p1, p2, p3])
    .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">results</span>) =&gt;</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"所有 Promise 都已解决:"</span>);
        results.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">result, index</span>) =&gt;</span> {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`p<span class="hljs-subst">${index + <span class="hljs-number">1</span>}</span>:`</span>, result);
        });
    });
</code></pre>
<p>上述代码的输出结果是：</p>
<pre><code class="hljs language-bash" lang="bash">所有 Promise 都已解决:
p1: { status: <span class="hljs-string">'fulfilled'</span>, value: <span class="hljs-string">'成功1'</span> }
p2: { status: <span class="hljs-string">'rejected'</span>, reason: <span class="hljs-string">'失败2'</span> }
p3: { status: <span class="hljs-string">'fulfilled'</span>, value: <span class="hljs-string">'成功3'</span> }
</code></pre>
<h3 data-id="heading-17">Promise.race()</h3>
<p><code>Promise.race()</code> 返回最先完成的Promise（无论成功还是失败）的结果。我们来看看下面一个例子：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 创建一个可能会长时间运行的 Promise</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">longTask</span>(<span class="hljs-params">duration = <span class="hljs-number">3000</span></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> {
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
            <span class="hljs-title function_">resolve</span>(<span class="hljs-string">`长时间任务完成（耗时 <span class="hljs-subst">${duration}</span>ms）`</span>);
        }, duration);
    });
}

<span class="hljs-comment">// 创建一个超时 Promise</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">timeout</span>(<span class="hljs-params">ms</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">_, reject</span>) =&gt;</span> {
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
            <span class="hljs-title function_">reject</span>(<span class="hljs-string">`操作超时（<span class="hljs-subst">${ms}</span>ms）`</span>);
        }, ms);
    });
}


<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([<span class="hljs-title function_">longTask</span>(<span class="hljs-number">3000</span>), <span class="hljs-title function_">timeout</span>(<span class="hljs-number">2000</span>)])
    .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"成功:"</span>, result);
    })
    .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"失败:"</span>, error); 
    });
</code></pre>
<p>上述代码的执行结果是：<code>失败: 操作超时（2000ms）</code> 。</p>
<h3 data-id="heading-18">Promise.any()</h3>
<p><code>Promise.any()</code> 是ES2021新增的方法，它返回第一个成功的Promise，只有当所有Promise都失败时才失败。我们来看看下面一个例子：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> successFast = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> {
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-string">"快速成功"</span>), <span class="hljs-number">100</span>);
});

<span class="hljs-keyword">const</span> successSlow = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> {
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-string">"慢速成功"</span>), <span class="hljs-number">1000</span>);
});

<span class="hljs-keyword">const</span> failure = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">_, reject</span>) =&gt;</span> {
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">reject</span>(<span class="hljs-string">"失败"</span>), <span class="hljs-number">50</span>);
});

<span class="hljs-comment">// 即使有失败的 Promise，只要有一个成功就行</span>
<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">any</span>([failure, successFast, successSlow])
    .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"成功:"</span>, result);
    })
    .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"全部失败:"</span>, error);
    });
</code></pre>
<p>上述代码的输出结果是：<code>成功: 快速成功</code> 。</p>
<h2 data-id="heading-19">结语</h2>
<p>本文主要介绍了Promise的几种静态方法，对于文章中错误的地方或者有任何问题，欢迎在评论区留言讨论！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[年薪 50W 的前端，到底比年薪 15W 的强在哪里？]]></title>    <link>https://juejin.cn/post/7591744411740372992</link>    <guid>https://juejin.cn/post/7591744411740372992</guid>    <pubDate>2026-01-06T03:46:53.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7591744411740372992" data-draft-id="7592017365141241908" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="年薪 50W 的前端，到底比年薪 15W 的强在哪里？"/> <meta itemprop="keywords" content="前端,JavaScript,架构"/> <meta itemprop="datePublished" content="2026-01-06T03:46:53.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="ErpanOmer"/> <meta itemprop="url" content="https://juejin.cn/user/3878732754331096"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            年薪 50W 的前端，到底比年薪 15W 的强在哪里？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3878732754331096/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    ErpanOmer
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-06T03:46:53.000Z" title="Tue Jan 06 2026 03:46:53 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-06
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c49937ea90ee4aa99add90f7bc6a3103~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRXJwYW5PbWVy:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768276013&amp;x-signature=13htZuxx8nHck6tZjEehNeIWrVA%3D" alt="65ef63f6bd30ab838939a4ae_Developer productivity tools 2024.webp" loading="lazy"/></p>
<h3 data-id="heading-0">昨天我看新年第一波简历 看破防了</h3>
<p>最近团队缺人，我连着看了一周的简历。</p>
<p>说实话，看得我挺难受的。😖</p>
<p>我发现一个特别普遍的现象：很多工作了四五年的兄弟，期望薪资填个 25k 甚至 30k，但你仔细翻他的项目经历，全是后台管理系统，全是 H5 拼图页面，全是表单增删改查。</p>
<p>你问他：这几年你遇到的最大技术难点是啥？🤔</p>
<p>他回你：表单字段太多了，校验逻辑太复杂。或者说，产品经理改需求太频繁。😖</p>
<p>听到这种回答，我心里大概就有了底：这兄弟的薪资上限，大概率锁死在 20W 以内了。</p>
<p>这就是咱们常说的 CRUD 困局。</p>
<p>你会 Vue，你会 React，你会用 Antd 画页面，你会调接口。兄弟，这些在 2018 年也许能让你拿高薪，但现在是 2026 年了，这些东西是基建，是培训班出来的应届生两个月就能上手的。🤣</p>
<p>那么问题来了，那个坐在你隔壁工位、平时话不多、但年薪能拿 50W 的大佬，他到底比你强在哪？</p>
<p>是他敲键盘比你快？还是他发量比你少？</p>
<p>都不是。</p>
<p>我觉得最核心的差距，就只有三点。听我细说。</p>
<hr/>
<h3 data-id="heading-1">你在做填空，他在设计整张试卷</h3>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/30e566dc9b6c45f095423c102a9500d3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRXJwYW5PbWVy:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768276013&amp;x-signature=YEreuGJNODd8Pun3n%2BqSCvFKRsE%3D" alt="web-development-programmer-engineering-coding-website-augmented-reality-interface-screens-developer-project-engineer-programming-software-application-design-cartoon-illustration_107791-3863.avif" loading="lazy"/></p>
<p>这事儿特别明显。就拿新开一个项目来说。</p>
<p>15W 的兄弟是怎么干的？</p>
<p>找个脚手架，<code>create-react-app</code> 一把梭。然后开始堆页面，写组件。遇到要用的工具函数？去百度搜一个粘贴进来。遇到样式冲突？加个 <code>!important</code> 搞定。代码格式乱了？不管了，先跑通再说。</p>
<p>他的脑子里只有一个字：做。</p>
<p>50W 的兄弟是怎么干的？</p>
<p>他在写第一行业务代码之前，会先在脑子里过一遍这几件事：</p>
<p>大家代码风格不一样怎么办？先把 <code>ESLint + Prettier + Husky</code> 这一套流水线配好，谁提交的代码格式不对，连 <code>git push</code> 都推不上去。</p>
<p>这个项目以后会不会变大？要不要直接上 <code>Monorepo</code> 管理？</p>
<p>公共组件怎么抽离？是不是该搭个私有 <code>npm</code> 库？</p>
<p>打包速度怎么优化？<code>Vite</code> 的配置能不能再调调？</p>
<p>这就是差距。🤔</p>
<p>老板愿意给他 50W，不是因为他页面画得快，而是因为他制定了标准。他一个人，能让团队剩下 10 个人的产出质量变高。这叫工程化视野，这才是值钱的玩意儿。</p>
<hr/>
<h3 data-id="heading-2">出了事，你只会甩锅，他能兜底</h3>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ffa7a3e57bd44d30ad76baae7690c3aa~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRXJwYW5PbWVy:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768276013&amp;x-signature=WiAdw4kdjIAejfywR5tbtiRK6Is%3D" alt="software-developer-vs-software-engineer-illustration.jpg" loading="lazy"/></p>
<p>场景再具体点：用户投诉页面卡顿，加载慢。</p>
<p>15W 的兄弟通常反应是这样的：</p>
<p>打开控制台 Network 看一眼。</p>
<p>哎呀，接口这就 800ms 了，这后端不行啊，锅在服务端。</p>
<p>嗨🙂‍↔️，这图片 UI 给得太大了，切图没切好。</p>
<p>这数据量几万条，浏览器渲染本来就慢，我也没办法！</p>
<p>总之，只要不是 <code>JS</code> 报错，这事儿就跟我没关系。</p>
<p>50W 的兄弟会干嘛？</p>
<p>他不会废话，他直接打开 Chrome 的 <code>Performance</code> 面板，像做外科手术一样分析。</p>
<p>这一段掉帧，是不是触发了强制重排？</p>
<p>内存这一路飙升，是不是哪个闭包没释放，或者 <code>DOM</code> 节点没销毁？</p>
<p>主线程卡死，是不是长任务阻塞了渲染？能不能开个 <code>Web Worker</code> 把计算挪出去？</p>
<p>网络慢，是不是 HTTP/2 的多路复用没吃满？关键资源的加载优先级设对了吗？</p>
<p>这就叫底层能力。🤔</p>
<p>平时写业务看不出来，一旦遇到高并发、大数据量、若网环境这种极端场景，只会调 API 的人两手一摊，而懂底层原理的人能从浏览器内核里抠出性能。</p>
<p>这种 兜底能力，就是你的溢价。</p>
<hr/>
<h3 data-id="heading-3">他是业务合伙人!</h3>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ffc7e1442158413aa1b759d2038bd97b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRXJwYW5PbWVy:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768276013&amp;x-signature=6pICNbjXPzgwyi6EjTs%2BEY1J7iE%3D" alt="How-to-become-a-Backend-Developer.jpg" loading="lazy"/></p>
<p>这点最扎心。</p>
<p>产品经理提了个不靠谱的需求，比如要在手机端展示一个几百列的超级大表格。</p>
<p>15W 的兄弟：</p>
<p>心里骂娘：这傻X产品，脑子有坑。😡🤬</p>
<p>嘴上老实：行吧，我尽量试试。</p>
<p>结果做出来卡得要死，体验极差，上线被用户骂，回来接着改，陷入无尽加班。</p>
<p>这种思维模式下，你就是个执行资源，也就是个 打工人。</p>
<p>50W 的兄弟：</p>
<p>他听完需求直接就怼回去了：</p>
<p>哥们，在手机上看几百列表格，用户眼睛不要了？你这个需求的业务目标是啥？是为了让用户核对数据？</p>
<p>如果是核对数据，那我们要不要换个方案，只展示关键指标，点击再下钻看详情？这样开发成本低了 80%，用户体验还好。</p>
<p>这就叫技术变现。</p>
<p>高端的前端，不仅仅是写代码的，他是懂技术的业务专家。他能用技术方案去纠正产品逻辑，帮公司省钱，帮业务赚钱。</p>
<p>在老板眼里，你是成本，他是投资。🤷‍♂️</p>
<hr/>
<h3 data-id="heading-4">哪怕现在是 15W，咱也能翻盘</h3>
<p>如果你看上面这些话觉得膝盖中了一箭，别慌。谁还不是从切图仔过来的？</p>
<p>想打破这个 CRUD 的怪圈，从明天上班开始，试着变一下：</p>
<h4 data-id="heading-5">别再只盯着那几个 API 了</h4>
<p>Vue 文档背得再熟也就是个熟练工。去看看源码，看看人家是怎么设计响应式的，看看 React 为什么要搞 Fiber。懂了原理，你就不怕框架变。</p>
<h4 data-id="heading-6">别做重复工作</h4>
<p>下次想复制粘贴工具函数的时候，停一下。试着自己封装一个通用的，甚至试着把你们项目里重复的逻辑抽成一个库。工程化就是这么一点点做起来的。</p>
<h4 data-id="heading-7">钻进去一个细分领域</h4>
<p>别啥都学，啥都学不精。</p>
<p>可视化、低代码、<code>Node.js</code> 中间件、音视频，随便挑一个，把它钻透。在任何一个细分领域做到前 5%，你都有议价权。</p>
<hr/>
<p>还是那句话！前端并没有死，死的是那些 只会切图和调接口 的工具人。</p>
<p>50W 的年薪，买的不是你的时间，而是你 解决复杂问题 的能力，和你 避免团队踩坑 的经验。</p>
<p>别再满足于重复做一个 CRUD 了。下次打开编辑器的时候，多问自己一句：</p>
<p>除了把这个功能做出来，我还能为这段代码多做点什么？</p>
<p>共勉🙌</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0e4e9a59e81c4b8282596356eb7fb96d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRXJwYW5PbWVy:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768276013&amp;x-signature=8TKMwG%2FXAKSELldvwsgZRwp961Q%3D" alt="Suggestion (2).gif" loading="lazy"/></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Node.js 事件循环（Event Loop）详解]]></title>    <link>https://juejin.cn/post/7591744411740061696</link>    <guid>https://juejin.cn/post/7591744411740061696</guid>    <pubDate>2026-01-06T03:18:19.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7591744411740061696" data-draft-id="7591778827307991080" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Node.js 事件循环（Event Loop）详解"/> <meta itemprop="keywords" content="前端,后端"/> <meta itemprop="datePublished" content="2026-01-06T03:18:19.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="明月_清风"/> <meta itemprop="url" content="https://juejin.cn/user/1081575170131006"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Node.js 事件循环（Event Loop）详解
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1081575170131006/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    明月_清风
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-06T03:18:19.000Z" title="Tue Jan 06 2026 03:18:19 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-06
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>Node.js 是单线程的 JavaScript 运行时，但它能高效处理大量并发 I/O 操作（如网络请求、文件读写），核心机制就是<strong>事件循环</strong>。事件循环由底层库 <strong>libuv</strong> 实现，它允许 Node.js 在不阻塞主线程的情况下处理异步任务。</p>
<h4 data-id="heading-0">为什么需要事件循环？</h4>
<ul>
<li>JavaScript 是单线程的，同步代码会阻塞执行。</li>
<li>但大多数操作（如网络 I/O）是耗时的，如果阻塞主线程，程序就无法响应其他请求。</li>
<li>Node.js 将异步操作“卸载”到系统内核或线程池，完成后通过回调通知主线程。</li>
<li>事件循环负责不断检查是否有完成的异步任务，并执行对应的回调函数，从而实现<strong>非阻塞 I/O</strong>。</li>
</ul>
<p>简单来说：主线程执行同步代码 → 遇到异步操作 → 交给 libuv 处理 → libuv 完成时将回调放入队列 → 事件循环轮询队列并执行回调。</p>
<h4 data-id="heading-1">事件循环的阶段（Phases）</h4>
<p>Node.js 的事件循环分为 <strong>6 个主要阶段</strong>（基于 libuv），它们按顺序循环执行。每轮循环（称为一个 “tick”）会依次进入这些阶段：</p>
<ol>
<li>
<p><strong>timers（定时器阶段）</strong><br/>
执行已到期的 <code>setTimeout()</code> 和 <code>setInterval()</code> 回调。<br/>
注意：定时器不是精确的，只保证“至少”在指定时间后执行（可能因其他任务延迟）。</p>
</li>
<li>
<p><strong>pending callbacks（待定回调阶段）</strong><br/>
执行某些系统级 I/O 回调（如 TCP 错误报告）。</p>
</li>
<li>
<p><strong>idle, prepare（闲置/准备阶段）</strong><br/>
Node.js 内部使用，仅用于准备下一个阶段。</p>
</li>
<li>
<p><strong>poll（轮询阶段）</strong><br/>
最重要、最复杂的阶段：</p>
<ul>
<li>检索新的 I/O 事件（网络、文件等）。</li>
<li>执行 I/O 相关的回调（几乎所有异步 I/O 回调在这里处理）。</li>
<li>如果没有定时器，会在这里阻塞等待新事件到来。</li>
<li>如果有 <code>setImmediate()</code>，会尽快进入 check 阶段。</li>
</ul>
</li>
<li>
<p><strong>check（检查阶段）</strong><br/>
执行 <code>setImmediate()</code> 回调。</p>
</li>
<li>
<p><strong>close callbacks（关闭回调阶段）</strong><br/>
执行关闭事件的回调（如 socket.close()）。</p>
</li>
</ol>
<p><strong>循环流程简图</strong>：</p>
<pre><code class="hljs language-sql" lang="sql">timers → pending callbacks → idle<span class="hljs-operator">/</span><span class="hljs-keyword">prepare</span> → poll → <span class="hljs-keyword">check</span> → <span class="hljs-keyword">close</span> callbacks → (返回 timers)
</code></pre>
<p>每轮循环结束后，Node.js 会检查是否还有待处理的异步任务。如果没有，进程会优雅退出。</p>
<h4 data-id="heading-2">微任务（Microtasks）和 nextTick 的特殊处理</h4>
<ul>
<li>与浏览器不同，Node.js 的<strong>微任务</strong>（如 <code>Promise.then()</code>、<code>queueMicrotask()</code>）和 <code>process.nextTick()</code> <strong>在每个阶段结束后、进入下一个阶段前执行</strong>。</li>
<li>优先级：<code>process.nextTick()</code> &gt; <code>Promise</code>（微任务队列）。</li>
<li>这意味着微任务会“插队”在宏任务（阶段回调）之间执行，确保更高优先级。</li>
</ul>
<p><strong>注意变化</strong>（从 Node.js 20+ / libuv 1.45.0 开始）：定时器回调现在只在 poll 阶段后执行（以前可能在 poll 前后都检查）。</p>
<h4 data-id="heading-3">执行顺序示例</h4>
<p>考虑以下代码：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'start'</span>);

<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'timeout'</span>), <span class="hljs-number">0</span>);
<span class="hljs-title function_">setImmediate</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'immediate'</span>));

<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'promise'</span>));

process.<span class="hljs-title function_">nextTick</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'nextTick'</span>));

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'end'</span>);
</code></pre>
<p>输出通常是：</p>
<pre><code class="hljs language-arduino" lang="arduino">start
end
nextTick
promise
immediate  <span class="hljs-comment">// 或 timeout（取决于 poll 阶段）</span>
timeout    <span class="hljs-comment">// 或 immediate</span>
</code></pre>
<ul>
<li>同步代码先执行：<code>start</code> → <code>end</code>。</li>
<li>微任务立即执行：<code>nextTick</code> → <code>promise</code>。</li>
<li>然后进入事件循环：先 timers（timeout），或先 check（immediate），具体取决于 poll 阶段的行为。</li>
</ul>
<h4 data-id="heading-4">与浏览器事件循环的区别</h4>
<ul>
<li><strong>浏览器</strong>：宏任务（macrotask，如 setTimeout）和微任务（microtask，如 Promise）交替执行，一个宏任务后清空所有微任务。</li>
<li><strong>Node.js</strong>：有多个阶段的宏任务队列，微任务在<strong>每个阶段之间</strong>执行，更复杂，适合服务器端 I/O 密集场景。</li>
</ul>
<h4 data-id="heading-5">实际建议</h4>
<ul>
<li>避免在事件循环中执行 CPU 密集任务（如大循环计算），会阻塞其他回调，导致延迟。</li>
<li>使用 <code>process.nextTick()</code> 或 Promise 处理高优先级异步逻辑。</li>
<li>监控事件循环延迟（可用 <code>perf_hooks</code>）以优化性能。</li>
</ul>
<p>理解事件循环是掌握 Node.js 异步编程的关键，能帮助你调试回调顺序、避免阻塞和构建高并发应用。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[React基础框架搭建7-测试：react+router+redux+axios+Tailwind+webpack]]></title>    <link>https://juejin.cn/post/7592017365141520436</link>    <guid>https://juejin.cn/post/7592017365141520436</guid>    <pubDate>2026-01-06T03:21:50.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7592017365141520436" data-draft-id="7592017365141454900" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="React基础框架搭建7-测试：react+router+redux+axios+Tailwind+webpack"/> <meta itemprop="keywords" content="React.js,前端框架,架构"/> <meta itemprop="datePublished" content="2026-01-06T03:21:50.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Eadia"/> <meta itemprop="url" content="https://juejin.cn/user/1591748565671614"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            React基础框架搭建7-测试：react+router+redux+axios+Tailwind+webpack
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1591748565671614/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Eadia
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-06T03:21:50.000Z" title="Tue Jan 06 2026 03:21:50 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-06
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>现在可以对之前弄得一些内容进行测试了</p>
<p>npm下载：</p>
<pre><code class="hljs language-dart" lang="dart">npm install --save-dev <span class="hljs-meta">@testing</span>-<span class="hljs-keyword">library</span>/react <span class="hljs-meta">@testing</span>-<span class="hljs-keyword">library</span>/jest-dom
</code></pre>
<p>有些可能需要安装：</p>
<pre><code class="hljs language-kotlin" lang="kotlin">npm install --save-dev <span class="hljs-meta">@babel</span>/plugin-proposal-<span class="hljs-keyword">private</span>-property-<span class="hljs-keyword">in</span>-<span class="hljs-keyword">object</span>
</code></pre>
<p>单元测试请按如下方式进行：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">//src/views/Home/__tests__/Home.test.js</span>

<span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> { render, screen } <span class="hljs-keyword">from</span> <span class="hljs-string">'@testing-library/react'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Home</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'../Home'</span>;

<span class="hljs-title function_">test</span>(<span class="hljs-string">'renders welcome message'</span>, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-title function_">render</span>(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Home</span> /&gt;</span></span>);
    <span class="hljs-keyword">const</span> linkElement = screen.<span class="hljs-title function_">getByText</span>(<span class="hljs-regexp">/Hello/i</span>);
    <span class="hljs-title function_">expect</span>(linkElement).<span class="hljs-title function_">toBeInTheDocument</span>();
});
</code></pre>
<p>运行：</p>
<pre><code class="hljs language-bash" lang="bash">npm <span class="hljs-built_in">test</span>
</code></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[不从零开始构建专属 SVG 编辑器的实战指南]]></title>    <link>https://juejin.cn/post/7591780560486645760</link>    <guid>https://juejin.cn/post/7591780560486645760</guid>    <pubDate>2026-01-06T03:34:57.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7591780560486645760" data-draft-id="7566913899176165411" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="不从零开始构建专属 SVG 编辑器的实战指南"/> <meta itemprop="keywords" content="前端,JavaScript,前端框架"/> <meta itemprop="datePublished" content="2026-01-06T03:34:57.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="卧指世阁"/> <meta itemprop="url" content="https://juejin.cn/user/3435310554828685"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            不从零开始构建专属 SVG 编辑器的实战指南
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3435310554828685/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    卧指世阁
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-06T03:34:57.000Z" title="Tue Jan 06 2026 03:34:57 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-06
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读16分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>在Web开发领域，重复造轮子并非明智之举。当我们需要定制一个 SVG 编辑器时，与其完全从零开始，不如基于成熟的基础进行构建。</p>
</blockquote>
<h2 data-id="heading-0">@svgedit/svgcanvas 简介</h2>
<p><code>@svgedit/svgcanvas</code> 是开源项目 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FSVG-Edit%2Fsvgedit" target="_blank" title="https://github.com/SVG-Edit/svgedit" ref="nofollow noopener noreferrer">SVGEdit</a> 的核心组件，提供底层的 SVG 操作能力。将界面和交互逻辑交给开发者自定义，使我们可快速构建自己的编辑器，同时保持<strong>高度可定制性</strong>。</p>
<ul>
<li><strong>优点：</strong> 经过了超过十年的发展和实际项目的考验，提供了一个<strong>功能高度完备的起点</strong>。</li>
</ul>
<p>实现了从基本的图形绘制（如矩形、圆形、路径）到复杂的编辑操作（如图层管理、历史记录）等一套完整的 SVG 画布操作能力。</p>
<p>这意味着无需从零开始实现这些复杂逻辑，可以专注于定制编辑器的界面、交互和特定业务功能，从而<strong>显著提升开发效率</strong>。</p>
<ul>
<li><strong>缺点：</strong> 缺乏 TypeScript 支持和详细的 API 文档。</li>
</ul>
<p>没有 ts 就失去了类型检查、代码智能提示、以及编译时错误检测，<strong>开发体验会受到影响</strong>。</p>
<p>缺乏详细 API 文档，有时需要直接阅读源码，虽然一开始可能有难度，但这是理解库的核心工作机制和最可靠的途径。</p>
<h2 data-id="heading-1">快速搭建</h2>
<p>为了避免 <code>new SvgCanvas</code> 后得到的 <code>canvas</code> 实例在组件间传递的复杂性，通常建议使用状态管理库将其提升为全局状态。</p>
<p>但出于简化示例的目的，本文将暂不引入相关库，而是聚焦于核心逻辑。</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { useEffect, useRef, useState } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">SvgCanvas</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'@svgedit/svgcanvas'</span>;

<span class="hljs-comment">//默认配置</span>
<span class="hljs-keyword">const</span> config = {
  <span class="hljs-attr">canvas_expansion</span>: <span class="hljs-number">0</span>,
  <span class="hljs-attr">initFill</span>: {
    <span class="hljs-attr">color</span>: <span class="hljs-string">'fff'</span>,
    <span class="hljs-attr">opacity</span>: <span class="hljs-number">1</span>,
  },
  <span class="hljs-attr">initStroke</span>: {
    <span class="hljs-attr">width</span>: <span class="hljs-number">5</span>,
    <span class="hljs-attr">color</span>: <span class="hljs-string">'000000'</span>,
    <span class="hljs-attr">opacity</span>: <span class="hljs-number">1</span>,
  },
  <span class="hljs-attr">text</span>: {
    <span class="hljs-attr">stroke_width</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">font_size</span>: <span class="hljs-number">12</span>,
  },
  <span class="hljs-attr">gridSnapping</span>: <span class="hljs-literal">false</span>,
  <span class="hljs-attr">baseUnit</span>: <span class="hljs-string">'px'</span>,
};

<span class="hljs-keyword">const</span> <span class="hljs-title class_">App</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">FC</span> = <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">const</span> svgcanvasRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);
  <span class="hljs-keyword">const</span> textRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);

  <span class="hljs-keyword">const</span> [canvas, setCanvas] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>);

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateCanvas</span>(<span class="hljs-params">canvas: SvgCanvas, editorDom: HTMLDivElement</span>) {
    <span class="hljs-keyword">const</span> workarea = editorDom.<span class="hljs-property">parentNode</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">HTMLElement</span>;
    <span class="hljs-keyword">let</span> { width, height } = workarea.<span class="hljs-title function_">getBoundingClientRect</span>();
    editorDom.<span class="hljs-property">style</span>.<span class="hljs-property">width</span> = <span class="hljs-string">`<span class="hljs-subst">${width}</span>px`</span>;
    editorDom.<span class="hljs-property">style</span>.<span class="hljs-property">height</span> = <span class="hljs-string">`<span class="hljs-subst">${height}</span>px`</span>;
    canvas.<span class="hljs-title function_">updateCanvas</span>(width, height);
  }
  
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> editorDom = svgcanvasRef.<span class="hljs-property">current</span>;
    <span class="hljs-keyword">if</span> (editorDom) {
      <span class="hljs-comment">// 创建 SvgCanvas 实例</span>
      <span class="hljs-keyword">const</span> canvas = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SvgCanvas</span>(editorDom, config);
      <span class="hljs-title function_">setCanvas</span>(canvas);
      <span class="hljs-title function_">updateCanvas</span>(canvas, editorDom);
      <span class="hljs-keyword">if</span> (textRef.<span class="hljs-property">current</span>) {
        <span class="hljs-comment">// 设置文本输入框元素</span>
        canvas.<span class="hljs-property">textActions</span>.<span class="hljs-title function_">setInputElem</span>(textRef.<span class="hljs-property">current</span>);
      }
    }
  },[]);

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        {['select', 'ellipse', 'rect', 'path', 'line', 'text'].map((item) =&gt; (
           canvas?.setMode(item)}
          &gt;
            {item}
          
        ))}
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>/&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
       {
          canvas?.setTextContent((e.target as HTMLInputElement).value);
        }}
        onFocus={() =&gt; {
          const selectedElement = canvas?.getSelectedElements()[0];
          if (textRef.current &amp;&amp; selectedElement) {
            textRef.current.value = selectedElement.textContent;
          }
        }}
        onBlur={() =&gt; {
          if (textRef.current) textRef.current.value = '';
        }}
        style={{ position: 'absolute', left: '-9999px' }}
      /&gt;
    
  );
};

export default App;
</span></code></pre>
<h2 data-id="heading-2">功能实现</h2>
<p>下面提供一些你可能需要的功能实现。</p>
<h4 data-id="heading-3">绘制网格背景</h4>
<p>源码中的 <code>setBackgroundMethod</code> 方法（位于 <code>elem-get-set.js</code> 文件内）用于设置编辑器背景，但功能较为基础，<strong>仅支持</strong>配置填充色和背景图片。</p>
<p>为保持结构不变，在生成网格后，将 <code>#canvasBackground</code>元素内的 ``进行替换。</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">SvgCanvas</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'@svgedit/svgcanvas'</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">useGridBg</span>(<span class="hljs-params">props: { gridSize: <span class="hljs-built_in">number</span> }</span>) {
  <span class="hljs-keyword">const</span> { gridSize } = props;

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">drawGridBg</span>(<span class="hljs-params">canvas: SvgCanvas | <span class="hljs-literal">null</span></span>) {
    <span class="hljs-keyword">const</span> editorDom = canvas?.<span class="hljs-title function_">getSvgRoot</span>().<span class="hljs-property">parentNode</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">HTMLElement</span>;

    <span class="hljs-keyword">if</span> (!editorDom || !canvas) <span class="hljs-keyword">return</span>;

    <span class="hljs-keyword">const</span> zoom = canvas.<span class="hljs-title function_">getZoom</span>();
    <span class="hljs-keyword">const</span> scaledGridSize = gridSize * zoom;
    <span class="hljs-keyword">const</span> gridSvg = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElementNS</span>(
      <span class="hljs-string">'http://www.w3.org/2000/svg'</span>,
      <span class="hljs-string">'svg'</span>,
    );
    gridSvg.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">'width'</span>, <span class="hljs-string">'100%'</span>);
    gridSvg.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">'height'</span>, <span class="hljs-string">'100%'</span>);
    gridSvg.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">'overflow'</span>, <span class="hljs-string">'visible'</span>);
    gridSvg.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">'pointer-events'</span>, <span class="hljs-string">'none'</span>);
    <span class="hljs-comment">// 获取画布的位移</span>
    <span class="hljs-keyword">const</span> viewBox = canvas.<span class="hljs-title function_">getSvgRoot</span>().<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">'viewBox'</span>)?.<span class="hljs-title function_">split</span>(<span class="hljs-string">' '</span>);
    <span class="hljs-keyword">const</span> translateX = viewBox ? <span class="hljs-built_in">parseFloat</span>(viewBox[<span class="hljs-number">0</span>]) : <span class="hljs-number">0</span>,
      translateY = viewBox ? <span class="hljs-built_in">parseFloat</span>(viewBox[<span class="hljs-number">1</span>]) : <span class="hljs-number">0</span>;
    <span class="hljs-keyword">const</span> bg = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'canvasBackground'</span>);

    <span class="hljs-keyword">if</span> (bg) {
      <span class="hljs-keyword">const</span> visibleWidth = <span class="hljs-title class_">Number</span>(editorDom.<span class="hljs-property">style</span>.<span class="hljs-property">width</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-string">'px'</span>, <span class="hljs-string">''</span>)),
        visibleHeight = <span class="hljs-title class_">Number</span>(editorDom.<span class="hljs-property">style</span>.<span class="hljs-property">height</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-string">'px'</span>, <span class="hljs-string">''</span>));
      <span class="hljs-keyword">const</span> bgWidth = <span class="hljs-title class_">Number</span>(bg.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">'width'</span>)?.<span class="hljs-title function_">replace</span>(<span class="hljs-string">'px'</span>, <span class="hljs-string">''</span>)),
        bgHeight = <span class="hljs-title class_">Number</span>(bg.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">'height'</span>)?.<span class="hljs-title function_">replace</span>(<span class="hljs-string">'px'</span>, <span class="hljs-string">''</span>));
      <span class="hljs-keyword">const</span> width = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(visibleWidth, bgWidth),
        height = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(visibleHeight, bgHeight);

      <span class="hljs-comment">// 计算可视区域的边界</span>
      <span class="hljs-keyword">const</span> redundancy = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">ceil</span>(width / <span class="hljs-number">2</span> / scaledGridSize) * scaledGridSize;

      <span class="hljs-keyword">const</span> startX =
        -redundancy + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(translateX / scaledGridSize) * scaledGridSize;
      <span class="hljs-keyword">const</span> startY =
        -redundancy + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(translateY / scaledGridSize) * scaledGridSize;
      <span class="hljs-keyword">const</span> endX = width + redundancy + translateX;
      <span class="hljs-keyword">const</span> endY = height + redundancy + translateY;
      <span class="hljs-comment">// 绘制横线</span>
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> y = startY; y &lt; endY; y += scaledGridSize) {
        <span class="hljs-keyword">const</span> line = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElementNS</span>(
          <span class="hljs-string">'http://www.w3.org/2000/svg'</span>,
          <span class="hljs-string">'line'</span>,
        );
        line.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">'x1'</span>, startX.<span class="hljs-title function_">toString</span>());
        line.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">'y1'</span>, y.<span class="hljs-title function_">toString</span>());
        line.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">'x2'</span>, endX.<span class="hljs-title function_">toString</span>());
        line.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">'y2'</span>, y.<span class="hljs-title function_">toString</span>());
        line.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">'stroke'</span>, <span class="hljs-string">'#e2deded5'</span>);
        line.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">'stroke-width'</span>, <span class="hljs-string">'1'</span>);
        gridSvg.<span class="hljs-title function_">appendChild</span>(line);
      }

      <span class="hljs-comment">// 绘制竖线</span>
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x = startX; x &lt; endX; x += scaledGridSize) {
        <span class="hljs-keyword">const</span> line = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElementNS</span>(
          <span class="hljs-string">'http://www.w3.org/2000/svg'</span>,
          <span class="hljs-string">'line'</span>,
        );
        line.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">'x1'</span>, x.<span class="hljs-title function_">toString</span>());
        line.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">'y1'</span>, startY.<span class="hljs-title function_">toString</span>());
        line.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">'x2'</span>, x.<span class="hljs-title function_">toString</span>());
        line.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">'y2'</span>, endY.<span class="hljs-title function_">toString</span>());
        line.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">'stroke'</span>, <span class="hljs-string">'#e2deded5'</span>);
        line.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">'stroke-width'</span>, <span class="hljs-string">'1'</span>);
        gridSvg.<span class="hljs-title function_">appendChild</span>(line);
      }

      bg.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">''</span>;
      bg.<span class="hljs-title function_">appendChild</span>(gridSvg);
    }
  }

  <span class="hljs-keyword">return</span> { drawGridBg };
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> useGridBg;
</code></pre>
<pre><code class="hljs language-less" lang="less">:<span class="hljs-selector-tag">global</span> {
    <span class="hljs-selector-id">#canvasBackground</span> {
      <span class="hljs-attribute">overflow</span>: visible;
    }
  }
</code></pre>
<p>在 <code>new SvgCanvas</code> 时，就绘制背景。</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">App</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">FC</span> = <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-comment">/**......省略部分代码 */</span>
  

  <span class="hljs-comment">/** 这部分是新增的代码*/</span>
  <span class="hljs-keyword">const</span> { drawGridBg } = <span class="hljs-title function_">useGridBg</span>({ <span class="hljs-attr">gridSize</span>: <span class="hljs-number">20</span> });
  <span class="hljs-comment">/**————————————*/</span>
  
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> editorDom = svgcanvasRef.<span class="hljs-property">current</span>;
    <span class="hljs-keyword">if</span> (editorDom) {
      <span class="hljs-keyword">const</span> canvas = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SvgCanvas</span>(editorDom, config);
      <span class="hljs-title function_">setCanvas</span>(canvas);
      <span class="hljs-title function_">updateCanvas</span>(canvas, editorDom);
      <span class="hljs-comment">/** 这部分是新增的代码 */</span>
      <span class="hljs-comment">// 背景网格绘制</span>
      <span class="hljs-title function_">drawGridBg</span>(canvas);
      <span class="hljs-comment">/**————————————*/</span>
      <span class="hljs-keyword">if</span> (textRef.<span class="hljs-property">current</span>) {
        canvas.<span class="hljs-property">textActions</span>.<span class="hljs-title function_">setInputElem</span>(textRef.<span class="hljs-property">current</span>);
      }
    }
  }, []);
  
  <span class="hljs-comment">/**......省略部分代码 */</span>
};
</code></pre>
<h4 data-id="heading-4">按住鼠标滚轮拖拽画布</h4>
<p>拖拽功能！这么实用的功能，是的，没有 API。</p>
<p>我是通过更改 viewBox 来实现的。</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">App</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">FC</span> = <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-comment">/**......省略部分代码 */</span>
  
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> editorDom = svgcanvasRef.<span class="hljs-property">current</span>;
    <span class="hljs-keyword">let</span> isDragging = <span class="hljs-literal">false</span>;
    <span class="hljs-comment">// 存储鼠标按下时的坐标和画布初始位置</span>
    <span class="hljs-keyword">let</span> <span class="hljs-attr">startX</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>,
      <span class="hljs-attr">startY</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>,
      <span class="hljs-attr">initialTranslateX</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>,
      <span class="hljs-attr">initialTranslateY</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleMouseDown</span>(<span class="hljs-params">e: MouseEvent</span>) {
      <span class="hljs-comment">// 仅当按下 鼠标滚轮 时开始拖拽</span>
      <span class="hljs-keyword">if</span> (e.<span class="hljs-property">button</span> === <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">const</span> selectGroup = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'selectorParentGroup'</span>);
        <span class="hljs-keyword">if</span> (selectGroup) {
          selectGroup.<span class="hljs-property">style</span>.<span class="hljs-property">display</span> = <span class="hljs-string">'none'</span>;
        }
        <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">style</span>.<span class="hljs-property">cursor</span> = <span class="hljs-string">'grab'</span>;
        canvas?.<span class="hljs-title function_">clearSelection</span>();
        e.<span class="hljs-title function_">preventDefault</span>();
        isDragging = <span class="hljs-literal">true</span>;
        startX = e.<span class="hljs-property">clientX</span>;
        startY = e.<span class="hljs-property">clientY</span>;

        <span class="hljs-comment">//获取当前画布移动的距离</span>
        [initialTranslateX, initialTranslateX] = canvas
          ?.<span class="hljs-title function_">getSvgRoot</span>()
          .<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">'viewBox'</span>)
          ?.<span class="hljs-title function_">split</span>(<span class="hljs-string">' '</span>)
          .<span class="hljs-title function_">map</span>(<span class="hljs-title class_">Number</span>) ?? [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>];
      }
    }

    <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleMouseMove</span>(<span class="hljs-params">e: MouseEvent</span>) {
      <span class="hljs-keyword">if</span> (isDragging) {
        <span class="hljs-keyword">const</span> dx = e.<span class="hljs-property">clientX</span> - startX;
        <span class="hljs-keyword">const</span> dy = e.<span class="hljs-property">clientY</span> - startY;
        <span class="hljs-keyword">const</span> newTranslateX = initialTranslateX - dx;
        <span class="hljs-keyword">const</span> newTranslateY = initialTranslateY - dy;
        <span class="hljs-comment">// 设置画布的位置</span>
        <span class="hljs-keyword">const</span> viewBox = canvas?.<span class="hljs-title function_">getSvgRoot</span>(),
          width = viewBox?.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">'width'</span>),
          height = viewBox?.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">'height'</span>);

        viewBox?.<span class="hljs-title function_">setAttribute</span>(
          <span class="hljs-string">'viewBox'</span>,
          <span class="hljs-string">`<span class="hljs-subst">${newTranslateX}</span> <span class="hljs-subst">${newTranslateY}</span> <span class="hljs-subst">${width}</span> <span class="hljs-subst">${height}</span>`</span>,
        );
        <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">style</span>.<span class="hljs-property">cursor</span> = <span class="hljs-string">'grabbing'</span>;
        <span class="hljs-comment">// 重新绘制网格背景</span>
        <span class="hljs-title function_">drawGridBg</span>(canvas);
      }
    }

    <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleMouseUp</span>(<span class="hljs-params"/>) {
      isDragging = <span class="hljs-literal">false</span>;
      <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">style</span>.<span class="hljs-property">cursor</span> = <span class="hljs-string">'default'</span>;
      <span class="hljs-keyword">const</span> selectGroup = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'selectorParentGroup'</span>);
      <span class="hljs-keyword">if</span> (selectGroup) {
        selectGroup.<span class="hljs-property">style</span>.<span class="hljs-property">display</span> = <span class="hljs-string">'block'</span>;
      }
    }

    editorDom?.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'mousedown'</span>, handleMouseDown);
    editorDom?.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'mousemove'</span>, handleMouseMove);
    editorDom?.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'mouseup'</span>, handleMouseUp);
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
      editorDom?.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'mousedown'</span>, handleMouseDown);
      editorDom?.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'mousemove'</span>, handleMouseMove);
      editorDom?.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'mouseup'</span>, handleMouseUp);
    };
  }, [canvas]);

  <span class="hljs-comment">/**......省略部分代码 */</span>
};
</code></pre>
<h4 data-id="heading-5">缩放功能</h4>
<p>如果没有使用拖拽功能的话，使用库提供的 API ，这部分代码就够了。</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">App</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">FC</span> = <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-comment">/**......省略部分代码 */</span>
  
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> editorDom = svgcanvasRef.<span class="hljs-property">current</span>;
    <span class="hljs-keyword">let</span> zoom = <span class="hljs-number">1</span>;

    <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleWheel</span>(<span class="hljs-params">e: WheelEvent</span>) {
      <span class="hljs-keyword">if</span> (canvas &amp;&amp; editorDom) {
        e.<span class="hljs-title function_">preventDefault</span>();
        canvas.<span class="hljs-title function_">clearSelection</span>();
        <span class="hljs-comment">// 缩放的比例</span>
        <span class="hljs-keyword">const</span> zoomStep = <span class="hljs-number">0.1</span>;
        <span class="hljs-keyword">const</span> delta = e.<span class="hljs-property">deltaY</span> &gt; <span class="hljs-number">0</span> ? -zoomStep : zoomStep;
        <span class="hljs-keyword">const</span> newZoom = zoom + delta;
        <span class="hljs-keyword">if</span> (newZoom &gt; <span class="hljs-number">0.3</span> &amp;&amp; newZoom &lt; <span class="hljs-number">3</span>) {
          canvas.<span class="hljs-title function_">setZoom</span>(newZoom);
          <span class="hljs-title function_">updateCanvas</span>(canvas, editorDom);
          <span class="hljs-comment">// 重新绘制网格背景</span>
          <span class="hljs-title function_">drawGridBg</span>(canvas);
          zoom = newZoom;
        }
      }
    }
    editorDom?.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'wheel'</span>, handleWheel);
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
      editorDom?.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'wheel'</span>, handleWheel);
    };
  }, [canvas]);
  
  <span class="hljs-comment">/**......省略部分代码 */</span> 
};
</code></pre>
<h5 data-id="heading-6">居中缩放</h5>
<p>但如果进行拖拽了，会发现缩放时不是在当前可视区的中心缩放。</p>
<p>因为我们的拖拽是通过 viewBox，所以还需要增加代码，修正下这部分问题。</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">App</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">FC</span> = <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-comment">/**......省略部分代码 */</span>
  
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> editorDom = svgcanvasRef.<span class="hljs-property">current</span>;
    <span class="hljs-keyword">let</span> zoom = <span class="hljs-number">1</span>;

    <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleWheel</span>(<span class="hljs-params">e: WheelEvent</span>) {
      <span class="hljs-keyword">if</span> (canvas &amp;&amp; editorDom) {
        e.<span class="hljs-title function_">preventDefault</span>();
        canvas.<span class="hljs-title function_">clearSelection</span>();
        <span class="hljs-comment">// 缩放的比例</span>
        <span class="hljs-keyword">const</span> zoomStep = <span class="hljs-number">0.1</span>;
        <span class="hljs-keyword">const</span> delta = e.<span class="hljs-property">deltaY</span> &gt; <span class="hljs-number">0</span> ? -zoomStep : zoomStep;
        <span class="hljs-keyword">const</span> newZoom = zoom + delta;
        <span class="hljs-keyword">if</span> (newZoom &gt; <span class="hljs-number">0.3</span> &amp;&amp; newZoom &lt; <span class="hljs-number">3</span>) {
          canvas.<span class="hljs-title function_">setZoom</span>(newZoom);
          <span class="hljs-title function_">updateCanvas</span>(canvas, editorDom);
          <span class="hljs-title function_">drawGridBg</span>(canvas);
          
          <span class="hljs-comment">/** 这部分是新增的代码*/</span>
          <span class="hljs-keyword">const</span> scale = newZoom / zoom;

          <span class="hljs-keyword">const</span> svg = canvas?.<span class="hljs-title function_">getSvgRoot</span>(),
            width = svg?.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">'width'</span>),
            height = svg?.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">'height'</span>),
            [translateX, translateY] = svg
              .<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">'viewBox'</span>)
              ?.<span class="hljs-title function_">split</span>(<span class="hljs-string">' '</span>)
              .<span class="hljs-title function_">map</span>(<span class="hljs-title class_">Number</span>) ?? [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>];

          canvas
            .<span class="hljs-title function_">getSvgRoot</span>()
            .<span class="hljs-title function_">setAttribute</span>(
              <span class="hljs-string">'viewBox'</span>,
              <span class="hljs-string">`<span class="hljs-subst">${translateX * scale}</span> <span class="hljs-subst">${translateY * scale}</span> <span class="hljs-subst">${width}</span> <span class="hljs-subst">${height}</span>`</span>,
            );
          <span class="hljs-comment">/**————————————*/</span>

          zoom = newZoom;
        }
      }
    }
    editorDom?.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'wheel'</span>, handleWheel);
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
      editorDom?.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'wheel'</span>, handleWheel);
    };
  }, [canvas]);
  
  <span class="hljs-comment">/**......省略部分代码 */</span> 
};
</code></pre>
<h5 data-id="heading-7">鼠标为中心缩放</h5>
<p>库中提供的 <code>setZoom</code> 方法是以 <code>id</code> 为 <code>svgroot</code> 的 svg 的中心点为缩放中心。</p>
<p>所以，要以缩放时要以鼠标为中心的话，我们需要进行修正。</p>
<pre><code class="hljs language-tsx" lang="tsx">  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> editorDom = svgcanvasRef.<span class="hljs-property">current</span>;
    <span class="hljs-keyword">let</span> zoom = <span class="hljs-number">1</span>;

    <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleWheel</span>(<span class="hljs-params">e: WheelEvent</span>) {
      <span class="hljs-keyword">if</span> (canvas &amp;&amp; editorDom) {
        e.<span class="hljs-title function_">preventDefault</span>();
        canvas.<span class="hljs-title function_">clearSelection</span>();
        <span class="hljs-comment">// 缩放的比例</span>
        <span class="hljs-keyword">const</span> zoomStep = <span class="hljs-number">0.1</span>;
        <span class="hljs-keyword">const</span> delta = e.<span class="hljs-property">deltaY</span> &gt; <span class="hljs-number">0</span> ? -zoomStep : zoomStep;
        <span class="hljs-keyword">const</span> newZoom = zoom + delta;
        <span class="hljs-keyword">if</span> (newZoom &gt; <span class="hljs-number">0.3</span> &amp;&amp; newZoom &lt; <span class="hljs-number">3</span>) {
          canvas.<span class="hljs-title function_">setZoom</span>(newZoom);
          <span class="hljs-title function_">updateCanvas</span>(canvas, editorDom);
          <span class="hljs-title function_">drawGridBg</span>(canvas);
          
          <span class="hljs-comment">/** 这部分是新增的代码*/</span>
          <span class="hljs-keyword">const</span> svg = canvas?.<span class="hljs-title function_">getSvgRoot</span>(),
            width = svg?.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">'width'</span>),
            height = svg?.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">'height'</span>),
            [translateX, translateY] = svg
              .<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">'viewBox'</span>)
              ?.<span class="hljs-title function_">split</span>(<span class="hljs-string">' '</span>)
              .<span class="hljs-title function_">map</span>(<span class="hljs-title class_">Number</span>) ?? [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>];

          <span class="hljs-keyword">const</span> rect = svgcanvasRef.<span class="hljs-property">current</span>!.<span class="hljs-title function_">getBoundingClientRect</span>();
          <span class="hljs-comment">// svg 中心点的距离</span>
          <span class="hljs-keyword">let</span> offsetCenterX = e.<span class="hljs-property">clientX</span> - rect.<span class="hljs-property">left</span> - rect.<span class="hljs-property">width</span> / <span class="hljs-number">2</span>,
            offsetCenterY = e.<span class="hljs-property">clientY</span> - rect.<span class="hljs-property">top</span> - rect.<span class="hljs-property">height</span> / <span class="hljs-number">2</span>;

          <span class="hljs-comment">// 缩放中心点的距离</span>
          <span class="hljs-keyword">const</span> offsetSvgCenterX = (offsetCenterX + translateX) / zoom,
            offsetSvgCenterY = (offsetCenterY + translateY) / zoom;

          <span class="hljs-comment">// 缩放的偏移值</span>
          <span class="hljs-keyword">const</span> offsetX = offsetSvgCenterX * delta,
            offsetY = offsetSvgCenterY * delta;

          canvas
            .<span class="hljs-title function_">getSvgRoot</span>()
            .<span class="hljs-title function_">setAttribute</span>(
              <span class="hljs-string">'viewBox'</span>,
              <span class="hljs-string">`<span class="hljs-subst">${translateX + offsetX}</span> <span class="hljs-subst">${
                translateY + offsetY
              }</span> <span class="hljs-subst">${width}</span> <span class="hljs-subst">${height}</span>`</span>,
            );
          <span class="hljs-comment">/**————————————*/</span>
          zoom = newZoom;
        }
      }
    }
    editorDom?.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'wheel'</span>, handleWheel);
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
      editorDom?.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'wheel'</span>, handleWheel);
    };
  }, [canvas]);
</code></pre>
<h4 data-id="heading-8">键盘移动元素</h4>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">App</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">FC</span> = <span class="hljs-function">() =&gt;</span> { 
  <span class="hljs-comment">/**......省略部分代码 */</span>

 <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">uDLRMove</span> = (<span class="hljs-params">e: KeyboardEvent</span>) =&gt; {
      <span class="hljs-keyword">const</span> moveStep = <span class="hljs-number">1</span>,
        bigMoveStep = <span class="hljs-number">10</span>;

      <span class="hljs-keyword">const</span> selectedElements = canvas?.<span class="hljs-title function_">getSelectedElements</span>() || [];
      <span class="hljs-keyword">if</span> (selectedElements.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;

      <span class="hljs-keyword">let</span> dx = <span class="hljs-number">0</span>,
        dy = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">const</span> step = e.<span class="hljs-property">shiftKey</span> ? bigMoveStep : moveStep;

      <span class="hljs-keyword">switch</span> (e.<span class="hljs-property">key</span>) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">'ArrowUp'</span>:
          dy = -step;
          <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-string">'ArrowDown'</span>:
          dy = step;
          <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-string">'ArrowLeft'</span>:
          dx = -step;
          <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-string">'ArrowRight'</span>:
          dx = step;
          <span class="hljs-keyword">break</span>;
        <span class="hljs-attr">default</span>:
          <span class="hljs-keyword">return</span>;
      }
      e.<span class="hljs-title function_">preventDefault</span>();
      canvas?.<span class="hljs-title function_">moveSelectedElements</span>(dx, dy);
    };

    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'keydown'</span>, uDLRMove);
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'keydown'</span>, uDLRMove);
  }, []);
  
  <span class="hljs-comment">/**......省略部分代码 */</span> 
};
</code></pre>
<h4 data-id="heading-9">按住 ctrl 键框选多选</h4>
<p>库已实现按住 <code>Shift</code> + 点击元素进行多选（或取消选中）的功能，但尚未实现按住 <code>Ctrl</code> + 框选多选。</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">App</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">FC</span> = <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-comment">/**......省略部分代码 */</span>
  
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> editorDom = svgcanvasRef.<span class="hljs-property">current</span>;

    <span class="hljs-keyword">if</span> (canvas &amp;&amp; editorDom) {
      editorDom.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'mousedown'</span>, canvas?.<span class="hljs-property">mouseDownEvent</span>);
      editorDom.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'mousemove'</span>, canvas?.<span class="hljs-property">mouseMoveEvent</span>);
      
      <span class="hljs-comment">// 储存之前选中的元素</span>
      <span class="hljs-keyword">let</span> <span class="hljs-attr">agoSelectedElements</span>: <span class="hljs-title class_">SVGElement</span>[] = [];

      <span class="hljs-keyword">function</span> <span class="hljs-title function_">mousedown</span>(<span class="hljs-params">e: MouseEvent</span>) {
        <span class="hljs-keyword">if</span> (e.<span class="hljs-property">button</span> === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;

        <span class="hljs-keyword">if</span> (e.<span class="hljs-property">ctrlKey</span> || e.<span class="hljs-property">metaKey</span>) {
          agoSelectedElements = canvas?.<span class="hljs-title function_">getSelectedElements</span>() ?? [];
        } <span class="hljs-keyword">else</span> {
          agoSelectedElements = [];
        }
        canvas?.<span class="hljs-title function_">mouseDownEvent</span>(e);
        <span class="hljs-keyword">if</span> (agoSelectedElements.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {
          canvas?.<span class="hljs-title function_">addToSelection</span>(agoSelectedElements);
        }
      }

      <span class="hljs-keyword">function</span> <span class="hljs-title function_">mousemove</span>(<span class="hljs-params">e: MouseEvent</span>) {
        <span class="hljs-keyword">if</span> (!canvas?.<span class="hljs-property">started</span> || e.<span class="hljs-property">button</span> === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;

        canvas?.<span class="hljs-title function_">mouseMoveEvent</span>(e);
        <span class="hljs-keyword">if</span> (agoSelectedElements.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {
          canvas.<span class="hljs-title function_">addToSelection</span>(agoSelectedElements);
        }
      }
      editorDom.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'mousedown'</span>, mousedown);
      editorDom.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'mousemove'</span>, mousemove);
      
      <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
        editorDom.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'mousedown'</span>, canvas.<span class="hljs-property">mouseDownEvent</span>);
        editorDom.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'mousemove'</span>, canvas.<span class="hljs-property">mouseMoveEvent</span>);
      };
    }
  }, [canvas]);
  
  <span class="hljs-comment">/**......省略部分代码 */</span> 
};
</code></pre>
<p>此处是对 <code>mousedown</code> 和 <code>mousemove</code> 通过重写监听，进行了功能扩展。</p>
<h4 data-id="heading-10">键盘操作：复制、粘贴、删除</h4>
<p>在执行粘贴操作时，若画布存在缩放或平移，其位置也需要进行修正。</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">App</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">FC</span> = <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-comment">/**......省略部分代码 */</span>
  
  <span class="hljs-comment">// 记录鼠标在屏幕上的位置</span>
  <span class="hljs-keyword">const</span> clientXYRef = useRef&lt;{ <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>; <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span> }&gt;({ <span class="hljs-attr">x</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">0</span> });

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleMouseMove</span>(<span class="hljs-params">e: MouseEvent</span>) {
      clientXYRef.<span class="hljs-property">current</span> = { <span class="hljs-attr">x</span>: e.<span class="hljs-property">clientX</span>, <span class="hljs-attr">y</span>: e.<span class="hljs-property">clientY</span> };
    }
    svgcanvasRef.<span class="hljs-property">current</span>?.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'mousemove'</span>, handleMouseMove);
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
      svgcanvasRef.<span class="hljs-property">current</span>?.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'mousemove'</span>, handleMouseMove);
    };
  }, []);
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">onKeyDown</span>(<span class="hljs-params">e: KeyboardEvent</span>) {
      <span class="hljs-comment">//删除功能</span>
      <span class="hljs-keyword">if</span> (
        (e.<span class="hljs-property">key</span> === <span class="hljs-string">'Delete'</span> || e.<span class="hljs-property">key</span> === <span class="hljs-string">'Backspace'</span>) &amp;&amp;
        (e.<span class="hljs-property">target</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">HTMLElement</span>).<span class="hljs-property">tagName</span> !== <span class="hljs-string">'INPUT'</span>
      ) {
        e.<span class="hljs-title function_">preventDefault</span>();
        canvas?.<span class="hljs-title function_">deleteSelectedElements</span>();
      }
      <span class="hljs-comment">//复制功能 ctrl+c</span>
      <span class="hljs-keyword">if</span> ((e.<span class="hljs-property">key</span> === <span class="hljs-string">'c'</span> || e.<span class="hljs-property">key</span> === <span class="hljs-string">'C'</span>) &amp;&amp; (e.<span class="hljs-property">ctrlKey</span> || e.<span class="hljs-property">metaKey</span>)) {
        e.<span class="hljs-title function_">preventDefault</span>();
        <span class="hljs-keyword">try</span> {
          canvas?.<span class="hljs-title function_">copySelectedElements</span>();
        } <span class="hljs-keyword">catch</span> (error) {}
      }
      <span class="hljs-comment">//粘贴功能 ctrl+v</span>
      <span class="hljs-keyword">if</span> ((e.<span class="hljs-property">key</span> === <span class="hljs-string">'v'</span> || e.<span class="hljs-property">key</span> === <span class="hljs-string">'V'</span>) &amp;&amp; (e.<span class="hljs-property">ctrlKey</span> || e.<span class="hljs-property">metaKey</span>)) {
        e.<span class="hljs-title function_">preventDefault</span>();
        <span class="hljs-keyword">const</span> rect = svgcanvasRef.<span class="hljs-property">current</span>!.<span class="hljs-title function_">getBoundingClientRect</span>();

        <span class="hljs-keyword">const</span> svg = canvas!.<span class="hljs-title function_">getSvgRoot</span>(),
          zoom = canvas?.<span class="hljs-title function_">getZoom</span>() ?? <span class="hljs-number">1</span>,
          [translateX, translateY] = svg
            .<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">'viewBox'</span>)
            ?.<span class="hljs-title function_">split</span>(<span class="hljs-string">' '</span>)
            .<span class="hljs-title function_">map</span>(<span class="hljs-title class_">Number</span>) ?? [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>];

        <span class="hljs-keyword">let</span> svgX = (clientXYRef.<span class="hljs-property">current</span>.<span class="hljs-property">x</span> - rect.<span class="hljs-property">left</span> + translateX) / zoom,
          svgY = (clientXYRef.<span class="hljs-property">current</span>.<span class="hljs-property">y</span> - rect.<span class="hljs-property">top</span> + translateY) / zoom;

        <span class="hljs-comment">// 修正偏移量</span>
        <span class="hljs-keyword">const</span> svgcontent = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'svgcontent'</span>)!;
        svgX -= <span class="hljs-title class_">Number</span>(svgcontent.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">'x'</span>)) / zoom;
        svgY -= <span class="hljs-title class_">Number</span>(svgcontent.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">'y'</span>)) / zoom;
        
        canvas?.<span class="hljs-title function_">pasteElements</span>(<span class="hljs-string">'point'</span>, svgX, svgY);
      }
    }
    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'keydown'</span>, onKeyDown);
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'keydown'</span>, onKeyDown);
    };
  }, [canvas]);

  <span class="hljs-comment">/**......省略部分代码 */</span> 
};
</code></pre>
<p>这里为什么要在复制功能那里增加 try/catch 错误捕获呢？</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/61c497d5bfa34643a93c99277f723aa6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y2n5oyH5LiW6ZiB:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768275297&amp;x-signature=ADb%2FJGpkeB0AgOJbyf4ZTtfjGS4%3D" alt="copySelectedElements.png" loading="lazy"/></p>
<p>因为在 <code>copySelectedElements</code> 源码内执行了 <code>document.getElementById('se-cmenu_canvas')</code>,我们这里没有添加这个 div，所以进行报错的拦截。</p>
<p>而 <code>se-cmenu_canvas</code> 元素主要用在右键菜单功能，当有复制内容被暂存时，该 div 会被赋予一个属性，以便后续判断是否已存在复制内容。因此，你有右键菜单功能，记得在 div 对应位置增加 <code>id=&amp;#34;se-cmenu_canvas&amp;#34;</code> 属性。</p>
<h4 data-id="heading-11">水平翻转，垂直翻转</h4>
<p>翻转功能的核心是 <a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FSVG%2FReference%2FAttribute%2Ftransform%23%25E7%259F%25A9%25E9%2598%25B5" target="_blank" title="https://developer.mozilla.org/zh-CN/docs/Web/SVG/Reference/Attribute/transform#%E7%9F%A9%E9%98%B5" ref="nofollow noopener noreferrer">matrix</a>，通过矩阵来实现的。</p>
<p>简单说下矩阵运算中会用到的 2 个 API：</p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FDOMMatrix%2FmultiplySelf" target="_blank" title="https://developer.mozilla.org/en-US/docs/Web/API/DOMMatrix/multiplySelf" ref="nofollow noopener noreferrer">multiplySelf</a>：将当前矩阵<strong>右乘</strong>另一个矩阵：<code>当前矩阵 = 当前矩阵 × 参数矩阵</code>。累积多个变换，按“自然”顺序（如先缩放，再旋转，后平移）。</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FDOMMatrix%2FpreMultiplySelf" target="_blank" title="https://developer.mozilla.org/en-US/docs/Web/API/DOMMatrix/preMultiplySelf" ref="nofollow noopener noreferrer">preMultiplySelf</a>：将当前矩阵<strong>左乘</strong>另一个矩阵：<code>当前矩阵 = 参数矩阵 × 当前矩阵</code>。累积多个变换，按与 <code>multiplySelf</code>相反的顺序。</li>
</ul>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">App</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">FC</span> = <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-comment">/**......省略部分代码 */</span>

 <span class="hljs-comment">// 解析transform属性，提取现有的变换矩阵</span>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">parseTransformToMatrix</span>(<span class="hljs-params">element: SVGElement</span>): <span class="hljs-title class_">DOMMatrix</span> {
    <span class="hljs-keyword">const</span> transform = element.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">'transform'</span>) || <span class="hljs-string">''</span>;
    <span class="hljs-comment">// 提取矩阵参数</span>
    <span class="hljs-keyword">const</span> matrixMatch = transform.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/matrix\(([^)]+)\)/</span>);
    <span class="hljs-keyword">if</span> (!matrixMatch) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DOMMatrix</span>();
    }
    <span class="hljs-keyword">const</span> matrixValues = matrixMatch[<span class="hljs-number">1</span>].<span class="hljs-title function_">split</span>(<span class="hljs-string">','</span>).<span class="hljs-title function_">map</span>(<span class="hljs-title class_">Number</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DOMMatrix</span>(matrixValues);
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">overturn</span>(<span class="hljs-params"><span class="hljs-keyword">type</span>: <span class="hljs-string">'horizontal'</span> | <span class="hljs-string">'vertical'</span></span>) {
    <span class="hljs-keyword">const</span> selectedElements = canvas?.<span class="hljs-title function_">getSelectedElements</span>();
    <span class="hljs-keyword">if</span> (selectedElements?.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;

    selectedElements?.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">element</span>) =&gt;</span> {
      <span class="hljs-keyword">const</span> visualBbox = canvas?.<span class="hljs-title function_">getBBox</span>(element);
      <span class="hljs-keyword">if</span> (!visualBbox) <span class="hljs-keyword">return</span>;

      <span class="hljs-comment">// 获取位置的中心点</span>
      <span class="hljs-keyword">const</span> centerX = visualBbox.<span class="hljs-property">x</span> + visualBbox.<span class="hljs-property">width</span> / <span class="hljs-number">2</span>;
      <span class="hljs-keyword">const</span> centerY = visualBbox.<span class="hljs-property">y</span> + visualBbox.<span class="hljs-property">height</span> / <span class="hljs-number">2</span>;

      <span class="hljs-comment">// 创建一个新的 DOM 变换矩阵</span>
      <span class="hljs-keyword">const</span> flipMatrix = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DOMMatrix</span>();
      <span class="hljs-comment">// 将元素平移，使其中点与原点重合</span>
      flipMatrix.<span class="hljs-title function_">translateSelf</span>(centerX, centerY);
      <span class="hljs-comment">//进行翻转</span>
      <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">type</span>) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">'horizontal'</span>:
          flipMatrix.<span class="hljs-title function_">scaleSelf</span>(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
          <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-string">'vertical'</span>:
          flipMatrix.<span class="hljs-title function_">scaleSelf</span>(<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>);
          <span class="hljs-keyword">break</span>;
      }
      <span class="hljs-comment">// 将元素平移回原位置</span>
      flipMatrix.<span class="hljs-title function_">translateSelf</span>(-centerX, -centerY);

      <span class="hljs-comment">// 获取现有的变换矩阵</span>
      <span class="hljs-keyword">const</span> existingMatrix = <span class="hljs-title function_">parseTransformToMatrix</span>(element);
      <span class="hljs-comment">// 合并现有变换</span>
      flipMatrix.<span class="hljs-title function_">preMultiplySelf</span>(existingMatrix);

      <span class="hljs-keyword">const</span> matrixString = <span class="hljs-string">`matrix(<span class="hljs-subst">${flipMatrix.a}</span>, <span class="hljs-subst">${flipMatrix.b}</span>, <span class="hljs-subst">${flipMatrix.c}</span>, <span class="hljs-subst">${flipMatrix.d}</span>, <span class="hljs-subst">${flipMatrix.e}</span>, <span class="hljs-subst">${flipMatrix.f}</span>)`</span>;
      element.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">'transform'</span>, matrixString);
    });
  }
  
  <span class="hljs-comment">/**......省略部分代码 */</span> 
};
</code></pre>
<h4 data-id="heading-12">自定义图形</h4>
<p>有时候基础图形往往无法满足所有需求，此时便需要实现自定义图形的能力。</p>
<h5 data-id="heading-13">存储</h5>
<p>保存的逻辑很简单，把 svg 转成 string 进行存储。</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">addCustom</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">const</span> selectedElements = canvas?.<span class="hljs-title function_">getSelectedElements</span>();
    <span class="hljs-keyword">if</span> (selectedElements &amp;&amp; selectedElements?.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">const</span> tempSvg = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElementNS</span>(
        <span class="hljs-string">'http://www.w3.org/2000/svg'</span>,
        <span class="hljs-string">'svg'</span>,
      );

      selectedElements.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">elem</span>) =&gt;</span> {
        tempSvg.<span class="hljs-title function_">appendChild</span>(elem);
      });
      state.<span class="hljs-property">canvas</span>?.<span class="hljs-title function_">svgToString</span>(tempSvg, <span class="hljs-number">0</span>);
    }
  }
</code></pre>
<p>为什么<code>svgcanvas</code> 提供了 <code>svgToString</code> 方法，比直接使用 <code>XMLSerializer</code> 优势在哪呢？</p>
<p><code>XMLSerializer</code> 只是简单地将 DOM 树转换为字符串。而 <code>svgToString</code> 是对 SVG 序列化过程的全面控制：优化输出大小、增强可读性以及支持特殊功能（如图像嵌入），使得生成的 SVG 代码更加精简，输出的文件质量更高。</p>
<h5 data-id="heading-14">展示</h5>
<p>这里是使用了 React 的 <code>dangerouslySetInnerHTML</code>来实现元素的渲染的。</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">App</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">FC</span> = <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-comment">/**......省略部分代码 */</span>
  
<span class="hljs-keyword">const</span> svg1 = <span class="hljs-string">`


 
 
`</span>;

  <span class="hljs-comment">// 获取边界框</span>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getSVGCoordinateRange</span>(<span class="hljs-params">svgString: <span class="hljs-built_in">string</span></span>): {
    <span class="hljs-attr">minX</span>: <span class="hljs-built_in">number</span>;
    <span class="hljs-attr">maxX</span>: <span class="hljs-built_in">number</span>;
    <span class="hljs-attr">minY</span>: <span class="hljs-built_in">number</span>;
    <span class="hljs-attr">maxY</span>: <span class="hljs-built_in">number</span>;
    <span class="hljs-attr">svgElement</span>: <span class="hljs-title class_">SVGSVGElement</span>;
  } {
    <span class="hljs-keyword">const</span> parser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DOMParser</span>();
    <span class="hljs-keyword">const</span> doc = parser.<span class="hljs-title function_">parseFromString</span>(svgString, <span class="hljs-string">'image/svg+xml'</span>);
    <span class="hljs-keyword">const</span> svgElement = doc.<span class="hljs-property">documentElement</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">unknown</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">SVGSVGElement</span>;

    <span class="hljs-keyword">let</span> minX = <span class="hljs-title class_">Infinity</span>,
      minY = <span class="hljs-title class_">Infinity</span>,
      maxX = -<span class="hljs-title class_">Infinity</span>,
      maxY = -<span class="hljs-title class_">Infinity</span>;

    <span class="hljs-keyword">const</span> updateBounds = (<span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>): <span class="hljs-function"><span class="hljs-params">void</span> =&gt;</span> {
      minX = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(minX, x);
      minY = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(minY, y);
      maxX = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(maxX, x);
      maxY = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(maxY, y);
    };

    <span class="hljs-keyword">const</span> traverse = (<span class="hljs-attr">element</span>: <span class="hljs-title class_">Element</span>): <span class="hljs-function"><span class="hljs-params">void</span> =&gt;</span> {
      <span class="hljs-keyword">const</span> tagName = element.<span class="hljs-property">tagName</span>.<span class="hljs-title function_">toLowerCase</span>();

      <span class="hljs-keyword">switch</span> (tagName) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">'polyline'</span>: {
          <span class="hljs-keyword">const</span> points =
            element
              .<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">'points'</span>)
              ?.<span class="hljs-title function_">split</span>(<span class="hljs-regexp">/[\s,]+/</span>)
              .<span class="hljs-title function_">map</span>(<span class="hljs-title class_">Number</span>) || [];
          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; points.<span class="hljs-property">length</span>; i += <span class="hljs-number">2</span>) {
            <span class="hljs-title function_">updateBounds</span>(points[i], points[i + <span class="hljs-number">1</span>]);
          }
          <span class="hljs-keyword">break</span>;
        }
        <span class="hljs-keyword">case</span> <span class="hljs-string">'rect'</span>: {
          <span class="hljs-keyword">const</span> x = <span class="hljs-built_in">parseFloat</span>(element.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">'x'</span>) || <span class="hljs-string">'0'</span>);
          <span class="hljs-keyword">const</span> y = <span class="hljs-built_in">parseFloat</span>(element.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">'y'</span>) || <span class="hljs-string">'0'</span>);
          <span class="hljs-keyword">const</span> width = <span class="hljs-built_in">parseFloat</span>(element.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">'width'</span>) || <span class="hljs-string">'0'</span>);
          <span class="hljs-keyword">const</span> height = <span class="hljs-built_in">parseFloat</span>(element.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">'height'</span>) || <span class="hljs-string">'0'</span>);
          <span class="hljs-comment">// 处理矩形四角</span>
          <span class="hljs-title function_">updateBounds</span>(x, y);
          <span class="hljs-title function_">updateBounds</span>(x + width, y);
          <span class="hljs-title function_">updateBounds</span>(x, y + height);
          <span class="hljs-title function_">updateBounds</span>(x + width, y + height);
          <span class="hljs-keyword">break</span>;
        }
        <span class="hljs-keyword">case</span> <span class="hljs-string">'text'</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'image'</span>:
          <span class="hljs-title function_">updateBounds</span>(
            <span class="hljs-built_in">parseFloat</span>(element.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">'x'</span>) || <span class="hljs-string">'0'</span>),
            <span class="hljs-built_in">parseFloat</span>(element.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">'y'</span>) || <span class="hljs-string">'0'</span>),
          );
          <span class="hljs-keyword">break</span>;
        <span class="hljs-comment">/** ......省略其他元素逻辑  */</span>
      }
      <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(element.<span class="hljs-property">children</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">child</span>) =&gt;</span> <span class="hljs-title function_">traverse</span>(child));
    };

    <span class="hljs-title function_">traverse</span>(svgElement);

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">minX</span>: minX === <span class="hljs-title class_">Infinity</span> ? <span class="hljs-number">0</span> : minX,
      <span class="hljs-attr">maxX</span>: maxX === -<span class="hljs-title class_">Infinity</span> ? <span class="hljs-number">0</span> : maxX,
      <span class="hljs-attr">minY</span>: minY === <span class="hljs-title class_">Infinity</span> ? <span class="hljs-number">0</span> : minY,
      <span class="hljs-attr">maxY</span>: maxY === -<span class="hljs-title class_">Infinity</span> ? <span class="hljs-number">0</span> : maxY,
      svgElement,
    };
  }
  
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">templateSvg</span>(<span class="hljs-params">svgString: <span class="hljs-built_in">string</span></span>) {
    <span class="hljs-keyword">const</span> { minX, minY, maxX, maxY, svgElement } =
      <span class="hljs-title function_">getSVGCoordinateRange</span>(svgString);
      
    svgElement.<span class="hljs-title function_">setAttribute</span>(
      <span class="hljs-string">'viewBox'</span>,
      <span class="hljs-string">`<span class="hljs-subst">${minX}</span> <span class="hljs-subst">${minY}</span> <span class="hljs-subst">${maxX - minX}</span> <span class="hljs-subst">${maxY - minY}</span>`</span>,
    );
    <span class="hljs-keyword">return</span> { <span class="hljs-attr">__html</span>: svgElement.<span class="hljs-property">outerHTML</span> };
  }
  
  <span class="hljs-keyword">return</span> (
    &lt;div&gt; {
        <span class="hljs-keyword">const</span> svgString = e.<span class="hljs-property">currentTarget</span>!.<span class="hljs-property">innerHTML</span>;
        e.<span class="hljs-property">dataTransfer</span>.<span class="hljs-title function_">setData</span>(<span class="hljs-string">'text/plain'</span>, svgString);
      }}
      dangerouslySetInnerHTML={<span class="hljs-title function_">templateSvg</span>(svg1)}
    /&gt;
  );
  
  <span class="hljs-comment">/**......省略部分代码 */</span> 
};
</code></pre>
<h5 data-id="heading-15">拖拽放入</h5>
<p>生成元素时，必须为其分配唯一的 id。如果出现重复，将导致元素缺失。</p>
<p>若进行过拖拽和缩放，自然也需要进行修正。</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">App</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">FC</span> = <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-comment">/**......省略部分代码 */</span>
  
<span class="hljs-keyword">function</span> <span class="hljs-title function_">uuid</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> <span class="hljs-attr">s</span>: <span class="hljs-title class_">Array</span> = [];
  <span class="hljs-keyword">const</span> hexDigits = <span class="hljs-string">'0123456789abcdef'</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">36</span>; i++) {
    s[i] = hexDigits.<span class="hljs-title function_">substr</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">0x10</span>), <span class="hljs-number">1</span>);
  }
  s[<span class="hljs-number">14</span>] = <span class="hljs-string">'4'</span>; <span class="hljs-comment">// bits 12-15 of the time_hi_and_version field to 0010</span>
  s[<span class="hljs-number">19</span>] = hexDigits.<span class="hljs-title function_">substr</span>((s[<span class="hljs-number">19</span>] &amp; <span class="hljs-number">0x3</span>) | <span class="hljs-number">0x8</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// bits 6-7 of the clock_seq_hi_and_reserved to 01</span>
  s[<span class="hljs-number">8</span>] = s[<span class="hljs-number">13</span>] = s[<span class="hljs-number">18</span>] = s[<span class="hljs-number">23</span>] = <span class="hljs-string">'-'</span>;

  <span class="hljs-keyword">const</span> uuid = s.<span class="hljs-title function_">join</span>(<span class="hljs-string">''</span>);
  <span class="hljs-keyword">return</span> uuid;
}

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// 监听拖放事件</span>
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">dropHandler</span> = (<span class="hljs-params">e: DragEvent</span>) =&gt; {
      e.<span class="hljs-title function_">preventDefault</span>();

      <span class="hljs-keyword">let</span> data = e.<span class="hljs-property">dataTransfer</span>?.<span class="hljs-title function_">getData</span>(<span class="hljs-string">'text/plain'</span>);
      <span class="hljs-keyword">if</span> (data &amp;&amp; canvas) {
        <span class="hljs-keyword">const</span> rect = svgcanvasRef.<span class="hljs-property">current</span>!.<span class="hljs-title function_">getBoundingClientRect</span>();

        <span class="hljs-comment">// 转换为 SVG 坐标（考虑平移和缩放）</span>
        <span class="hljs-keyword">const</span> svg = canvas.<span class="hljs-title function_">getSvgRoot</span>(),
          zoom = canvas.<span class="hljs-title function_">getZoom</span>() ?? <span class="hljs-number">1</span>,
          [translateX, translateY] = svg
            .<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">'viewBox'</span>)
            ?.<span class="hljs-title function_">split</span>(<span class="hljs-string">' '</span>)
            .<span class="hljs-title function_">map</span>(<span class="hljs-title class_">Number</span>) ?? [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>];
          
        <span class="hljs-keyword">let</span> svgX = (e.<span class="hljs-property">clientX</span> - rect.<span class="hljs-property">left</span> + translateX) / zoom,
          svgY = (e.<span class="hljs-property">clientY</span> - rect.<span class="hljs-property">top</span> + translateY) / zoom;
        <span class="hljs-comment">// 修正偏移量</span>
        <span class="hljs-keyword">const</span> svgcontent = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'svgcontent'</span>)!;
        svgX -= <span class="hljs-title class_">Number</span>(svgcontent.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">'x'</span>)) / zoom;
        svgY -= <span class="hljs-title class_">Number</span>(svgcontent.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">'y'</span>)) / zoom;

        <span class="hljs-keyword">if</span> (data) {
          <span class="hljs-keyword">const</span> { minX, minY, maxX, maxY, svgElement } =
            <span class="hljs-title function_">getSVGCoordinateRange</span>(data);

          <span class="hljs-keyword">const</span> offsetX = svgX - (minX + (maxX - minX) / <span class="hljs-number">2</span>),
            offsetY = svgY - (minY + (maxY - minY) / <span class="hljs-number">2</span>);

          <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(svgElement.<span class="hljs-property">children</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">ele</span>) =&gt;</span> {
            <span class="hljs-keyword">switch</span> (ele.<span class="hljs-property">tagName</span>) {
              <span class="hljs-keyword">case</span> <span class="hljs-string">'polyline'</span>:
                {
                  <span class="hljs-keyword">const</span> points = ele.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">'points'</span>);
                  <span class="hljs-keyword">const</span> amendPoints = points!
                    .<span class="hljs-title function_">split</span>(<span class="hljs-string">' '</span>)
                    .<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> {
                      <span class="hljs-keyword">const</span> [x, y] = item.<span class="hljs-title function_">split</span>(<span class="hljs-string">','</span>).<span class="hljs-title function_">map</span>(<span class="hljs-title class_">Number</span>);
                      <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${x + offsetX}</span>,<span class="hljs-subst">${y + offsetY}</span>`</span>;
                    })
                    .<span class="hljs-title function_">join</span>(<span class="hljs-string">' '</span>);

                  canvas?.<span class="hljs-title function_">createSVGElement</span>({
                    <span class="hljs-attr">element</span>: <span class="hljs-string">'polyline'</span>,
                    <span class="hljs-attr">attr</span>: {
                      <span class="hljs-attr">points</span>: amendPoints,
                      <span class="hljs-attr">id</span>: <span class="hljs-string">'polyline-'</span> + <span class="hljs-title function_">uuid</span>(),
                      <span class="hljs-attr">stroke</span>: ele.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">'stroke'</span>),
                      <span class="hljs-string">'stroke-width'</span>: ele.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">'stroke-width'</span>),
                    },
                  });
                }
                <span class="hljs-keyword">break</span>;
              <span class="hljs-keyword">case</span> <span class="hljs-string">'rect'</span>:
                {
                  canvas?.<span class="hljs-title function_">createSVGElement</span>({
                    <span class="hljs-attr">element</span>: <span class="hljs-string">'rect'</span>,
                    <span class="hljs-attr">attr</span>: {
                      <span class="hljs-attr">x</span>: <span class="hljs-title class_">Number</span>(ele.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">'x'</span>)) + offsetX,
                      <span class="hljs-attr">y</span>: <span class="hljs-title class_">Number</span>(ele.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">'y'</span>)) + offsetY,
                      <span class="hljs-attr">width</span>: ele.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">'width'</span>),
                      <span class="hljs-attr">height</span>: ele.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">'height'</span>),
                      <span class="hljs-attr">stroke</span>: ele.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">'stroke'</span>),
                      <span class="hljs-attr">fill</span>: ele.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">'fill'</span>),
                      <span class="hljs-string">'stroke-width'</span>: ele.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">'stroke-width'</span>),
                      <span class="hljs-attr">id</span>: <span class="hljs-string">'rect-'</span> + <span class="hljs-title function_">uuid</span>(),
                    },
                  });
                }
                <span class="hljs-keyword">break</span>;
              <span class="hljs-keyword">case</span> <span class="hljs-string">'text'</span>: {
                <span class="hljs-keyword">const</span> text = canvas?.<span class="hljs-title function_">createSVGElement</span>({
                  <span class="hljs-attr">element</span>: <span class="hljs-string">'text'</span>,
                  <span class="hljs-attr">attr</span>: {
                    <span class="hljs-attr">x</span>: <span class="hljs-title class_">Number</span>(ele.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">'x'</span>)) + offsetX,
                    <span class="hljs-attr">y</span>: <span class="hljs-title class_">Number</span>(ele.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">'y'</span>)) + offsetY,
                    <span class="hljs-string">'font-size'</span>: ele.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">'font-size'</span>),
                    <span class="hljs-attr">fill</span>: ele.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">'fill'</span>),
                    <span class="hljs-attr">id</span>: <span class="hljs-string">'text-'</span> + <span class="hljs-title function_">uuid</span>(),
                  },
                });
                text.<span class="hljs-property">textContent</span> = ele.<span class="hljs-property">textContent</span>;
                <span class="hljs-keyword">break</span>;
              }
              <span class="hljs-keyword">case</span> <span class="hljs-string">'image'</span>:
                canvas?.<span class="hljs-title function_">createSVGElement</span>({
                  <span class="hljs-attr">element</span>: <span class="hljs-string">'image'</span>,
                  <span class="hljs-attr">attr</span>: {
                    <span class="hljs-attr">x</span>: <span class="hljs-title class_">Number</span>(ele.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">'x'</span>)) + offsetX,
                    <span class="hljs-attr">y</span>: <span class="hljs-title class_">Number</span>(ele.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">'y'</span>)) + offsetY,
                    <span class="hljs-attr">width</span>: ele.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">'width'</span>),
                    <span class="hljs-attr">height</span>: ele.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">'height'</span>),
                    <span class="hljs-attr">href</span>: ele.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">'href'</span>),
                    <span class="hljs-attr">id</span>: <span class="hljs-string">'image-'</span> + <span class="hljs-title function_">uuid</span>(),
                  },
                });
                <span class="hljs-keyword">break</span>;
              <span class="hljs-comment">/** ......省略其他元素逻辑  */</span>
            }
          });
        }
      }
    };

    <span class="hljs-keyword">function</span> <span class="hljs-title function_">preventDefault</span>(<span class="hljs-params">e: DragEvent</span>) {
      e.<span class="hljs-title function_">preventDefault</span>();
    }
    svgcanvasRef.<span class="hljs-property">current</span>?.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'dragover'</span>, preventDefault);
    svgcanvasRef.<span class="hljs-property">current</span>?.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'drop'</span>, dropHandler);

    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
      svgcanvasRef.<span class="hljs-property">current</span>?.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'drop'</span>, dropHandler);
      svgcanvasRef.<span class="hljs-property">current</span>?.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'dragover'</span>, preventDefault);
    };
  }, [canvas]);
  
  <span class="hljs-comment">/**......省略部分代码 */</span> 
};
</code></pre>
<h4 data-id="heading-16">撤销/重做功能</h4>
<h5 data-id="heading-17">介绍</h5>
<p>这部分功能的主要代码是在源码里的 <code>history.js</code> 文件中，且采用了经典的<a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.aliyun.com%2Farticle%2F1284694" target="_blank" title="https://developer.aliyun.com/article/1284694" ref="nofollow noopener noreferrer">命令模式</a>的设计模式。</p>
<p>支持多种类型的操作命令，都继承自基础的 <code>Command</code> 类：</p>
<ul>
<li><code>MoveElementCommand</code>：元素移动操作</li>
<li><code>InsertElementCommand</code>：元素插入操作</li>
<li><code>RemoveElementCommand</code>：元素删除操作</li>
<li><code>ChangeElementCommand</code>：元素属性修改操作</li>
<li><code>BatchCommand</code>：批量操作命令组合</li>
</ul>
<p><code>UndoManager</code>：负责维护命令历史堆栈，提供撤销与重做功能的核心控制器。</p>
<h5 data-id="heading-18">示例</h5>
<p>下面以拖拽自定义图形为示例</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">App</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">FC</span> = <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-comment">/**......省略部分代码 */</span>
  
<span class="hljs-comment">// 创建批处理命令</span>
<span class="hljs-keyword">const</span> batchCmd = <span class="hljs-keyword">new</span> canvas.<span class="hljs-property">history</span>.<span class="hljs-title class_">BatchCommand</span>(<span class="hljs-string">'添加多个图形'</span>);

<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(svgElement.<span class="hljs-property">children</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">ele</span>) =&gt;</span> {
  <span class="hljs-keyword">let</span> <span class="hljs-attr">svgElementNode</span>: <span class="hljs-title class_">SVGElement</span> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;
  
  <span class="hljs-keyword">switch</span> (ele.<span class="hljs-property">tagName</span>) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'polyline'</span>:
      {
        <span class="hljs-keyword">const</span> points = ele.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">'points'</span>);
        <span class="hljs-keyword">const</span> amendPoints = points!
          .<span class="hljs-title function_">split</span>(<span class="hljs-string">' '</span>)
          .<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> {
            <span class="hljs-keyword">const</span> [x, y] = item.<span class="hljs-title function_">split</span>(<span class="hljs-string">','</span>).<span class="hljs-title function_">map</span>(<span class="hljs-title class_">Number</span>);
            <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${x + offsetX}</span>,<span class="hljs-subst">${y + offsetY}</span>`</span>;
          })
          .<span class="hljs-title function_">join</span>(<span class="hljs-string">' '</span>);

        svgElementNode = canvas?.<span class="hljs-title function_">createSVGElement</span>({
          <span class="hljs-attr">element</span>: <span class="hljs-string">'polyline'</span>,
          <span class="hljs-attr">attr</span>: {
            <span class="hljs-attr">points</span>: amendPoints,
            <span class="hljs-attr">id</span>: <span class="hljs-string">'polyline-'</span> + <span class="hljs-title function_">uuid</span>(),
            <span class="hljs-attr">stroke</span>: ele.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">'stroke'</span>),
            <span class="hljs-string">'stroke-width'</span>: ele.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">'stroke-width'</span>),
          },
        });
      }
      <span class="hljs-keyword">break</span>;
    <span class="hljs-comment">/**......省略部分代码 */</span>
  }
  <span class="hljs-keyword">if</span> (svgElementNode) {
    <span class="hljs-comment">// 添加子命令</span>
    batchCmd.<span class="hljs-title function_">addSubCommand</span>(
      <span class="hljs-keyword">new</span> canvas.<span class="hljs-property">history</span>.<span class="hljs-title class_">InsertElementCommand</span>(svgElementNode, <span class="hljs-string">`自定义图形元素`</span>),
    );
  }
});

<span class="hljs-comment">// 将批处理命令添加到历史记录</span>
canvas.<span class="hljs-title function_">addCommandToHistory</span>(batchCmd);

  <span class="hljs-comment">/**......省略部分代码 */</span> 
};
</code></pre>
<p><code>BatchCommand</code>的作用是将多个一系列操作视为一个整体，而不是零散的状态变更，使得整个拖拽过程被视为一个完整的步骤。</p>
<p>最后调用 <code>addCommandToHistory</code> 方法，将对应的 <code>BatchCommand</code> 添加到 <code>UndoManager</code> 的历史栈中。</p>
<p>这一步是关键，因为只有被记录到历史栈中的命令，才能在 撤销/重做 中处理。</p>
<pre><code class="hljs language-tsx" lang="tsx">    canvas?.<span class="hljs-property">undoMgr</span>.<span class="hljs-title function_">undo</span>()}&gt;
     后退
   
    canvas?.<span class="hljs-property">undoMgr</span>.<span class="hljs-title function_">redo</span>()}&gt;
     前进
   
</code></pre>
<p>执行 <code>ChangeElementCommand</code> 命令时，有个顺序细节需要注意，必须是先完成对元素属性修改后，再执行命令的提交。</p>
<pre><code class="hljs language-tsx" lang="tsx">   <span class="hljs-comment">// 记录修改前的值</span>
    <span class="hljs-keyword">const</span> oldValue = element.<span class="hljs-title function_">getAttribute</span>(attributeName);
    <span class="hljs-comment">// 修改属性值</span>
    element.<span class="hljs-title function_">setAttribute</span>(attributeName, newValue);
    <span class="hljs-comment">// 执行实际的属性修改</span>
    element.<span class="hljs-title function_">setAttribute</span>(attributeName, newValue);
    <span class="hljs-comment">// 创建 ChangeElementCommand 并添加到历史记录</span>
    canvas.<span class="hljs-title function_">addCommandToHistory</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChangeElementCommand</span>(element, changes));
</code></pre>
<h2 data-id="heading-19">Q&amp;A</h2>
<h4 data-id="heading-20">关于文中的修正偏移</h4>
<p>为什么上面会有<strong>修正偏移</strong>的操作呢？</p>
<p>由于所有图形元素都绘制在 <code>svgroot</code> 下的子容器 <code>svgcontent</code> 内，此操作正是为了校正这个实际容器本身的偏移。</p>
<p>所以在粘贴和拖拽自定义元素放入时，需要进行修正。</p>
<h4 data-id="heading-21">关于 <a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FSVG%2FReference%2FAttribute%2Ftransform%23%25E7%259F%25A9%25E9%2598%25B5" target="_blank" title="https://developer.mozilla.org/zh-CN/docs/Web/SVG/Reference/Attribute/transform#%E7%9F%A9%E9%98%B5" ref="nofollow noopener noreferrer">matrix</a> 函数</h4>
<p><code>transform=&amp;#34;matrix(a, b, c, d, e, f)&amp;#34;</code>是 SVG 变换的底层数学表示。接受六个参数，它们共同定义了一个 3x3 的<a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FCSS%2FReference%2FValues%2Ftransform-function%2Fmatrix%23%25E5%258F%2582%25E6%2595%25B0%25E5%2580%25BC" target="_blank" title="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Reference/Values/transform-function/matrix#%E5%8F%82%E6%95%B0%E5%80%BC" ref="nofollow noopener noreferrer">变换矩阵</a>（为了便于仿射变换，实际使用<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F258437902" target="_blank" title="https://zhuanlan.zhihu.com/p/258437902" ref="nofollow noopener noreferrer">齐次坐标</a>）：</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-attr">[ a c e ]</span>
<span class="hljs-selector-attr">[ b d f ]</span>
<span class="hljs-selector-attr">[ 0 0 1 ]</span>
</code></pre>
<p>通常我们关注左上角的 2x2 线性变换矩阵 (a, b, c, d) 和右侧列的平移向量 (e, f) 来描述元素坐标系的所有基础变换的底层数学表示，功能非常强大但也相对抽象。</p>
<p>对于简单变换，优先使用 translate, scale, rotate, skewX, skewY 等函数以提高代码可读性。</p>
<ol>
<li><strong>平移 (Translation)</strong></li>
</ol>
<ul>
<li>e: 沿 X 轴的平移量。</li>
<li>f: 沿 Y 轴的平移量。</li>
</ul>
<p><strong>示例:</strong> </p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-title function_">matrix</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">100</span>, <span class="hljs-number">50</span>) === <span class="hljs-title function_">translate</span>(100px, 50px)
</code></pre>
<ol start="2">
<li><strong>缩放 (Scaling)</strong></li>
</ol>
<ul>
<li>a: X 轴方向的缩放因子。</li>
<li>d: Y 轴方向的缩放因子。</li>
</ul>
<p><strong>示例:</strong></p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-title function_">matrix</span>(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>) === <span class="hljs-title function_">scale</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)

<span class="hljs-title function_">matrix</span>(<span class="hljs-number">0.5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>) === <span class="hljs-title function_">scale</span>(<span class="hljs-number">0.5</span>)
</code></pre>
<ol start="3">
<li><strong>旋转 (Rotation)</strong></li>
</ol>
<p>旋转需要 a, b, c, d 共同作用。旋转角度 θ(通常以弧度表示) 时：</p>
<ul>
<li>a = cosθ</li>
<li>b = sinθ</li>
<li>c = -sinθ</li>
<li>d = cosθ。</li>
</ul>
<p><strong>示例:</strong> 旋转 30 度 (≈ 0.5236 弧度)，cos(30°) ≈ 0.866, sin(30°) = 0.5。</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-title function_">matrix</span>(<span class="hljs-number">0.866</span>, <span class="hljs-number">0.5</span>, -<span class="hljs-number">0.5</span>, <span class="hljs-number">0.866</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>) === <span class="hljs-title function_">rotate</span>(30deg)
</code></pre>
<ol start="4">
<li><strong>倾斜/错切 (Skewing/Shearing)</strong></li>
</ol>
<ul>
<li>沿 X 轴倾斜 (SkewX)：由 c控制。c = tan(α)，其中 α是倾斜角度。</li>
<li>沿 Y 轴倾斜 (SkewY)：由 b控制。b = tan(β)，其中 β是倾斜角度。</li>
</ul>
<p><strong>示例:</strong> tan(26.565deg) ≈ 0.5。</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-title function_">matrix</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>) === <span class="hljs-title function_">skewX</span>(<span class="hljs-number">26.</span>565deg) 

<span class="hljs-title function_">matrix</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>) === <span class="hljs-title function_">skewY</span>(<span class="hljs-number">26.</span>565deg)
</code></pre>
<ol start="5">
<li><strong>组合变换</strong></li>
</ol>
<p>matrix的真正威力在于它能用一个函数表示 ​​任意顺序、任意组合​​ 的平移、旋转、缩放、倾斜。这是通过将各个基础变换的矩阵 ​​相乘​​ 得到的。</p>
<p><strong>顺序很重要：</strong> 矩阵乘法不满足交换律。旋转 * 平移和 平移 * 旋转的结果通常是不同的。</p>
<ul>
<li>
<p>旋转 * 平移：先围绕原点旋转，然后将旋转后的图形平移。</p>
</li>
<li>
<p>平移 * 旋转：先将图形平移到新位置，然后围绕当前坐标系的原点（即平移后的点）旋转。</p>
</li>
</ul>
<p><strong>如何组合：</strong> 如果你有一系列基础变换，要得到等效的 matrix，你需要将它们对应的矩阵按 ​​从右到左​​ 的顺序相乘（在 SVG 中，transform 列表的书写顺序也是从右到左应用的）。最终得到的 6 个参数就是 matrix(a, b, c, d, e, f)的参数。</p>
<h4 data-id="heading-22">关于 <a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FSVGSVGElement%2FcreateSVGTransform" target="_blank" title="https://developer.mozilla.org/en-US/docs/Web/API/SVGSVGElement/createSVGTransform" ref="nofollow noopener noreferrer">createSVGTransform</a> 函数</h4>
<p>在阅读源码时，你会看到在对元素进行变换（例如移动、旋转、缩放）操作的函数中， <code>createSVGTransform</code> 被频繁的调用。</p>
<p>createSVGTransform 是 SVG DOM 提供的方法，用于创建 SVG 变换对象（SVGTransform），该对象可描述平移、缩放、旋转等几何变换。</p>
<p>核心作用是：生成临时变换规则，用于动态调整元素在拖拽缩放过程中的位置和尺寸，确保变换围绕正确的锚点（如边角、中心点）进行。</p>
<p>为什么需要通过 <code>createSVGTransform</code> 创建？</p>
<ul>
<li><strong>临时变换隔离：</strong> 直接修改元素的 width/height 可能与现有变换（如旋转）冲突，而通过 SVGTransform 可在变换列表中插入临时规则，避免破坏原始属性。</li>
<li><strong>动态调整支持：</strong> 拖拽过程中需要实时更新变换参数（如缩放比例），SVGTransform 对象允许随时修改 setTranslate/setScale 的参数并重新应用。</li>
<li><strong>变换组合能力：</strong> 多个 SVGTransform 可按顺序组合（如先平移再缩放），实现复杂的几何调整逻辑（这也是为什么需要创建三个对象的核心原因）。</li>
</ul>
<p><strong>createSVGTransform 的作用是：</strong> 生成可配置的变换规则，通过临时修改元素的变换列表，实现拖拽缩放过程中的精准位置控制。这比直接修改元素属性（如 width/height）更灵活，尤其适用于已有旋转、倾斜等复杂变换的元素。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Vue3 动态路由下的 KeepAlive 设计方案]]></title>    <link>https://juejin.cn/post/7591672090790920211</link>    <guid>https://juejin.cn/post/7591672090790920211</guid>    <pubDate>2026-01-06T01:01:43.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7591672090790920211" data-draft-id="7591715454134730815" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Vue3 动态路由下的 KeepAlive 设计方案"/> <meta itemprop="keywords" content="前端,Vue.js"/> <meta itemprop="datePublished" content="2026-01-06T01:01:43.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="zmirror"/> <meta itemprop="url" content="https://juejin.cn/user/676954892932935"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Vue3 动态路由下的 KeepAlive 设计方案
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/676954892932935/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    zmirror
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-06T01:01:43.000Z" title="Tue Jan 06 2026 01:01:43 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-06
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    34
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读2分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{position:relative;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:30px;margin-bottom:5px}.markdown-body h2{font-size:24px;display:inline-block;font-weight:700;background:#ef7060;color:#fff;padding:6px 8px 0 0;border-top-right-radius:6px;margin-right:2px;box-shadow:6px 3px 0 0 rgba(239,112,96,.2)}.markdown-body h2:before{content:" ";display:inline-block;width:8px}.markdown-body h2:after{content:" ";position:absolute;display:block;width:calc(100% - 50px);border-bottom:3px solid #ef7060}.markdown-body h3{font-size:18px;padding-bottom:0}.markdown-body h4{font-size:16px}.markdown-body h5{font-size:15px}.markdown-body h6{margin-top:5px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #3e3e3e;margin-top:32px;margin-bottom:32px;height:1px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:rgba(27,31,35,.05);color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:JetBranins Mono,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75;box-shadow:0 0 8px hsla(0,0%,43.1%,.45);border-radius:4px;margin:16px}.markdown-body pre:before{content:"";display:block;height:30px;width:100%;margin-bottom:-7px;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAdCAYAAABcz8ldAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAhgSURBVGhD7Zp7bBTHHcdn33t7vvOdzy+ITVKDU0xIKG2ABCPTRCCaUiEVKWoqRJuASAhCitRCVKSoalFUKZBiSmmFRRJKRUnUtIpo+aNqGgwoOCmuFUIRzxjwE4zte+97drYzztji8HPvtkit/PnH+n1397Tz+83vN/PbMZhmmmmm+d+BoX8n5diihcGqgFQf5vk6BMAskWUlw3GyFnIvtqWSf91w7mKC3npfOLX7wYeiIa6BBWCOLLFRF2NB0JvIOP/80YG+k2ev6S699b/OzOfKBW5l5KsgyC4DCFQDnpEAdE1goc/dlNPc/Up7P711UiYNSMuyxeUzZPnHgGHWh5XADEkSAcdiN+AnEXIBhBComgFU0/xQR+jnj51sOUMf9Z0NKyL8S9+JPBEN8zuCMrsqGOA5QWAAyzLAxe53HBeYFgJp1c5Cx33nyIfpV3e+22/Sx32nev/sMCgVnmM4bjOniAtZWQAsz315EfsGQQc4hgWcjHkCmOj1rheuNn95cXwmDMiVp5etC/D8m5FwUWVQUYYGPh6mZYFUOgsGVa1pXvOZzVT2jRuH54RM230jEuI3RcIiL4l4UkxAJmuD/riVsqD7ct2m9nep7BtVTbVfZ0uE/UIk+CQflAHDjf8+Lg6MldYATGpH3c/Ul7p3dWXppVGM6eElJSHmnQWPbSlRlN1lJcUBjqNRnwJZVQO3B5P/uq5rK1d90pakckFcaKp5UJHY92JR8YlwkUDVySEZfGfQdO7E7Z8s2HL9TSoXTPXRud9nA8IBqSwcZgWeqpPj6BYw7yTbXBN9q2v9lQEq5zBmWA8vWLCptCi4tzwW8RQMQlFQATPLSh6vCSh/plJBkMyQBHZfWYnkKRgEktEVpTJXERN2Xzo4ex2VC6K6qXYpF5b3ypVRT8EgcAERSJXRbwCBOTFzXblM5RxGBaRt+ZPYA+LO0mgxz5K1Ig+UgAzKIuGnz39z6S+olDeaibaXRsU1RUFvgx+GwTWgPCaDgMw2XXpr9gwq50XV0bkxJiYeEiNF5cwE5XsiOEkAUkXkUW51SSOVchjl8WKef604XFSRbzCGCYeCoESStv/p8QU1VPIM3knNDynctnBRfsEYhgSlNCIGgQv2UCkvGIHZgteMh1nBW9W4F16RAM6yDVV7amZTaYQcr59cuuhhWRTWBvAMLxQGeyFSHOLnh0MvUskz5RF+fbRYDEy0mZgqQYUHOLhr//b6rGoqeaLqQG0pw3PrBbyA+4EQUkRmhvgqNUfICUipKK4OKUqIJVPKB0jpEhjmWWp64jdbKmVZZNYogcJm493gsifOqhDyeh9GYR/FM7sW+DA5CKR0MSK3tvKZkpwB5gRE4tjFEr7RL0iWBGV51vHFCyupNGWWPqLgnoer9mtyEGSJAzwLllDTGzyznDjRN/CwOFkoFb4bm0eVIXICgpvdGoEvrF7fC89zfLkkeV5HbOhWiTwTpKYvCAJLGshRdXtKMKAWlyxq+MPQLk1h66g5RE5ABJYNFrqY3wvJklJRUKg5ZWLFXIA86yek2uDOPkBNb3CM5Pf7DL2QyIrUGiLH+xC5Bmmm/ARnHUhC6PnzxWDK0RH5HuIjZGy27erU9AZ0dTIWXyG+NpBBrSFySxZw220IqeUPFoS6jVAPNadM7yDsgNB1qOkLuAziMYIb1PQGA75wIaKGPyAb+9oF16g5RE5ALIQ+tSyLWoWDEAK6aXW3JlK9VJoyx1oyvVkNdvo5KXXDAVkdnaKmNwx0xjH98w3JNmTCm+Bc9hKVhsgJSI9pvp9Vdd++jmq6AXB2/HHrhcs5aTkVDv0DFzoHvKdq/mQsKX/4t7KJLDpOJW+IbAvMGoMkxfwAWZB8DT7W1diTE+WcgKz6pK1bs6z3daPwmJDsSKt6ZsCyjlLJMz0DsDGZ8SdlDROBjOb8YeWOjptU8kTXusuaazu7oJrfEnQvdkpVcUn6PTVHyAkIIW7br/Unklni0EJIZ1WgGsauZR+fvUglz6zY0dGfVp09ybRNlfwgi3k8YSbvJJ29VMoLt9v6rZVQL7hOYUubndHJGclBtzn1byqNMCogi09/2nFb01/oj+f/5TyjauBOKtPcZ1r7qZQ3f2lRfxZPWi2anp8TSDAGExZMa2jr8u03L1M5L7q3Xc+iAeuHRl/ScvPcjSLDBnZS/cjtNHd2v3171Ewbs9N5q7Pn4otVMx3btBsCsoRbk1FxG5dMVgMDqfTpXl1/tuFMa5zKefPROdX59qLQBwLnNog8Wy1OcjB1N+QEsW/QsFNZuO35Xb1v98QLX4/Sx+O3wqujrQ6013ABUWI8+AaqBjAH01+ghL22+5X2PirnMG7r+esbnae/V1neauvGSoHjigTcVU7UGFm2DeK4ttxKpQ+mLPvl+o/PjnkAkw9HTqSMmVHhyAMx9iFcSh/BHTfLceO/C8mKjApBf9zszGhoY92m9sN+BGOY9AeD7eGniv8OTaOB4dgyTsQd9wS+IQu4lciYdkI7CLrNH3Rvbb9FL41i0tbzVP2iWJkobpN5fmM4IJfJskTP1Bk8A9HQmbpmGDBrWqdVCN/Yd7PjxKGOXn+bmbto3feVVcVB9qehIL8EJy8nChwgr0O2xxBnhGU5eP2CfYbl/m4gBRsbtneMORP9oGpjpcCsiKzHHfdOPiQ/wMniyFEu2dbiTQCAeN/vavC466BGYLttXc9fmXBXMGlAhiHHur+sq6uPiUI9z7CVHMPwBnLSuuN8FuC48/Oaz1ylt94XfrW5ouyprwWfYRkwNyCyYYjwkBHows1fa+tV/fzGxlv39b9gqvfPmQ+i/HK8KlcBjhHwfl8HEHyOd1JnuzZd66S3TTPNNNP8/wDAfwDG7G0m9LKBpwAAAABJRU5ErkJggg==) 10px 10px no-repeat;background-size:40px;background-color:#fdfdfd}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#fdfdfd}.markdown-body a{text-decoration:none;font-weight:700;color:#ef7060;border-bottom:1px solid #ef7060}.markdown-body a:active,.markdown-body a:hover{color:#ef2d26}.markdown-body table tr td,.markdown-body table tr th{border:1px solid #ccc;padding:5px 10px}.markdown-body table{display:block!important;width:auto;max-width:100%;overflow:auto;border-collapse:collapse}.markdown-body thead{background:#f0f0f0;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#f8f8f8}.markdown-body blockquote{margin-inline-start:0;margin-inline-end:0;border-left:3px solid #ef7060;background:#fff9f9;padding:1px 20px;margin-top:20px}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="atom-one-light">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}</style><h3 data-id="heading-0">1. 组件设置 name</h3>
<blockquote>
<p>核心：keep-alive 只认组件 name，所以 cachedViews 或 include 必须用组件 name，而不是路由 name。</p>
</blockquote>
<h4 data-id="heading-1">1. defineComponent模式</h4>
<pre><code class="hljs language-ts" lang="ts">&lt;script lang=<span class="hljs-string">"ts"</span>&gt;
<span class="hljs-keyword">import</span> { defineComponent} <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineComponent</span>({
  <span class="hljs-attr">name</span>: <span class="hljs-string">'CustomName'</span>
})
&lt;/script&gt;
</code></pre>
<h4 data-id="heading-2">2. setup语法糖</h4>
<blockquote>
<p>需要单独新增一个script标签</p>
</blockquote>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// 页面为 TSX 时，需将 &lt;script&gt; 标签改为 lang="tsx"</span>
&lt;script lang=<span class="hljs-string">"ts"</span>&gt;
  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'CustomName'</span>,
    <span class="hljs-attr">inheritAttrs</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">customOptions</span>: {}
  }
&lt;/script&gt;
</code></pre>
<h4 data-id="heading-3">3. 借助插件</h4>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fvue-macros%2Fvue-macros" target="_blank" title="https://github.com/vue-macros/vue-macros" ref="nofollow noopener noreferrer">vue-macros 插件</a></p>
<h3 data-id="heading-4">2. 动态生成组件 name 的实践方案</h3>
<blockquote>
<p>相较于前端存储全量路由结合接口权限过滤的方案，此方案借助 Vue2 createCustomComponent 的思路：</p>
</blockquote>
<ul>
<li>每条路由都会生成一个独立的组件对象，并为其分配唯一的 <code>name</code></li>
<li>在动态生成组件时，将组件的 <code>name</code> 设置为基于路由 <code>path</code> 处理后的安全名称</li>
</ul>
<h4 data-id="heading-5">1. createCustomComponent</h4>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">import</span> { defineAsyncComponent, defineComponent, h } <span class="hljs-keyword">from</span> <span class="hljs-string">"vue"</span>;

<span class="hljs-comment">/**
* <span class="hljs-doctag">@param</span> {<span class="hljs-type"> String </span>} name 组件自定义名称
* <span class="hljs-doctag">@param</span> {<span class="hljs-type"> Component | Promise&lt;Component&gt; </span>} <span class="hljs-variable">componentPromise</span>
* <span class="hljs-doctag">@return</span> {<span class="hljs-type"> Component </span>}
*/</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createCustomComponent</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, componentPromise: <span class="hljs-built_in">any</span></span>) {
  <span class="hljs-comment">// 1. 将 Promise 包装成标准的异步组件</span>
  <span class="hljs-keyword">const</span> <span class="hljs-title class_">AsyncComp</span> = <span class="hljs-title function_">defineAsyncComponent</span>({
    <span class="hljs-attr">loader</span>: <span class="hljs-function">() =&gt;</span>
      componentPromise <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span> ? componentPromise : <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(componentPromise),
    <span class="hljs-comment">// 如果需要，可以在这里配置 loadingComponent</span>
  });

  <span class="hljs-keyword">return</span> <span class="hljs-title function_">defineComponent</span>({
    name, <span class="hljs-comment">// 必须设置，用于匹配 keep-alive 的 include</span>
    <span class="hljs-title function_">setup</span>(<span class="hljs-params"/>) {
      <span class="hljs-comment">// 2. 直接返回渲染函数，渲染异步组件</span>
      <span class="hljs-comment">// 移除外层的 div，让 AsyncComp 成为 KeepAlive 的直接子级</span>
      <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">h</span>(<span class="hljs-title class_">AsyncComp</span>);
    },
  });
}
</code></pre>
<h4 data-id="heading-6">2. 组件名转化</h4>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// 将 path 转成合法的组件名，避免 '/' 等字符</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">genComponentNameByPath</span>(<span class="hljs-params">path: <span class="hljs-built_in">string</span></span>) {
  <span class="hljs-keyword">return</span> path.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\//g</span>, <span class="hljs-string">"_"</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/^_/</span>, <span class="hljs-string">""</span>);
}
</code></pre>
<h4 data-id="heading-7">3. 路由接入示例</h4>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">"@/views/dashboard/index.vue"</span>)
<span class="hljs-comment">// 调整为</span>
<span class="hljs-attr">component</span>: <span class="hljs-title function_">createCustomComponent</span>(<span class="hljs-string">"Dashboard"</span>, <span class="hljs-keyword">import</span>(<span class="hljs-string">"@/views/dashboard/index.vue"</span>))
</code></pre>
<h3 data-id="heading-8">3. 通用组件缓存策略</h3>
<blockquote>
<p>疑问：如果共用一个组件来进行创建、编辑、详情，怎么根据路径进行匹配？</p>
</blockquote>
<p>假设路径是：<code>/banner-list/banner-create</code>、<code>/banner-list/banner-edit</code>、<code>/banner-list/banner-detail</code>
需要先进行路径命中匹配，无法命中则直接进行默认匹配：</p>
<ul>
<li>先解析上层路径，找到文件所在位置</li>
<li>再进行精准匹配，比如：公共组件统一命名为：basic-component</li>
</ul>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// 扫描views目录下的vue文件</span>
<span class="hljs-keyword">const</span> modules = <span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-title function_">glob</span>(<span class="hljs-string">"@/views/**/**.vue"</span>);
<span class="hljs-comment">// 全局需要 keepAlive 的 path 列表</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">pathKeepAliveList</span>: <span class="hljs-built_in">string</span>[] = [];

<span class="hljs-comment">/**
* 解析后端返回的路由数据
* <span class="hljs-doctag">@param</span> rawRoutes 后端返回的原始路由数据
* <span class="hljs-doctag">@returns</span> 解析后的路由配置数组
*/</span>
<span class="hljs-keyword">const</span> parseDynamicRoutes = (<span class="hljs-attr">rawRoutes</span>: <span class="hljs-title class_">AsyncRouter</span>[]): <span class="hljs-title class_">RouteRecordRaw</span>[] =&gt; {
  <span class="hljs-keyword">const</span> <span class="hljs-attr">parsedRoutes</span>: <span class="hljs-title class_">RouteRecordRaw</span>[] = [];

  rawRoutes.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> {
    <span class="hljs-keyword">const</span> <span class="hljs-attr">childrenColumn</span>: <span class="hljs-title class_">RouteRecordRaw</span> = {
      <span class="hljs-attr">path</span>: item.<span class="hljs-property">path</span>,
      <span class="hljs-attr">name</span>: item.<span class="hljs-property">name</span>,
      <span class="hljs-attr">component</span>: <span class="hljs-title class_">Layout</span>,
      <span class="hljs-attr">meta</span>: {
        <span class="hljs-attr">title</span>: item.<span class="hljs-property">name</span>,
        <span class="hljs-attr">icon</span>: item.<span class="hljs-property">icon</span>,
      },
      <span class="hljs-attr">children</span>: [] <span class="hljs-keyword">as</span> <span class="hljs-title class_">RouteRecordRaw</span>[],
    };
    <span class="hljs-keyword">if</span> (item.<span class="hljs-property">children</span>?.<span class="hljs-property">length</span>) {
      childrenColumn.<span class="hljs-property">redirect</span> = item.<span class="hljs-property">children</span>[<span class="hljs-number">0</span>].<span class="hljs-property">path</span>;
      item.<span class="hljs-property">children</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> {
        childrenColumn.<span class="hljs-property">children</span>.<span class="hljs-title function_">push</span>({
          <span class="hljs-attr">path</span>: v.<span class="hljs-property">path</span>,
          <span class="hljs-attr">name</span>: v.<span class="hljs-property">path</span>,
          <span class="hljs-attr">meta</span>: {
            <span class="hljs-attr">title</span>: v.<span class="hljs-property">name</span>,
            <span class="hljs-comment">// 满足条件的path开启 keepAlive</span>
            <span class="hljs-attr">keepAlive</span>: pathKeepAliveList.<span class="hljs-title function_">includes</span>(v.<span class="hljs-property">path</span>),
            <span class="hljs-comment">// 取二级路由为高亮，兼容二、三级路由匹配</span>
            <span class="hljs-attr">activeMenu</span>: v.<span class="hljs-property">path</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/^/</span>[^<span class="hljs-regexp">/]+/</span>[^<span class="hljs-regexp">/]+/</span>)?.[<span class="hljs-number">0</span>],
          },
          <span class="hljs-attr">component</span>: <span class="hljs-title function_">createCustomComponent</span>(v.<span class="hljs-property">path</span>, modules[<span class="hljs-string">`/src/views<span class="hljs-subst">${v.path}</span>/index.vue`</span>]),
        });
      });
    }

    parsedRoutes.<span class="hljs-title function_">push</span>(childrenColumn);
  });

  <span class="hljs-keyword">return</span> parsedRoutes;
};
</code></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Promise实例方法解析：then()、catch()、finally()]]></title>    <link>https://juejin.cn/post/7591715454134812735</link>    <guid>https://juejin.cn/post/7591715454134812735</guid>    <pubDate>2026-01-06T01:08:47.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7591715454134812735" data-draft-id="7591715454134796351" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Promise实例方法解析：then()、catch()、finally()"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2026-01-06T01:08:47.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="wuhen_n"/> <meta itemprop="url" content="https://juejin.cn/user/4149996261738233"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Promise实例方法解析：then()、catch()、finally()
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4149996261738233/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    wuhen_n
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-06T01:08:47.000Z" title="Tue Jan 06 2026 01:08:47 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-06
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    2
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>本专栏聚焦Promise的核心原理与高级应用，包含：
✓ Promise A+规范深度解读
✓ 手写实现与源码分析
✓ 异步编程设计模式
✓ 性能调优与错误处理</p>
</blockquote>
<blockquote>
<p>适合有JavaScript基础，希望深入异步编程的开发者。我们将用最少的篇幅，讲透最核心的知识。</p>
</blockquote>
<h2 data-id="heading-0">引言：Promise实例方法</h2>
<p>在之前的文章中，我们探讨了Promise的状态机模型和不可变原则。理解了Promise的内在状态后，现在让我们转向它的外在行为——实例方法。如果说状态是Promise的"骨骼"，那么实例方法就是它的"肌肉"，赋予了Promise处理异步操作的能力。</p>
<p>我们可以把Promise就像一台自动咖啡机。状态（<code>pending</code>、<code>fulfilled</code>、<code>rejected</code>）是它的指示灯，而<code>then()</code>、<code>catch()</code>、<code>finally()</code>方法就是它的操作按钮。只有了解每个按钮的确切功能和使用时机，我们才能制作出一杯完美的"异步咖啡"。</p>
<h2 data-id="heading-1">then()方法：链式调用的核心</h2>
<h3 data-id="heading-2">then()的基本语法</h3>
<p><code>Then()</code>方法是为Promise对象添加处理程序的主要方法，也是Promise中最核心、最复杂的方法。它可以接受两个参数：<code>onResolved处理函数</code> 和 <code>onRejected处理函数</code> 。这两个参数都是可选的，如果提供的话，则会在Promise进入 <code>fulfilled</code> 和 <code>rejected</code> 状态时执行，如以下示例：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">onResolved</span>(<span class="hljs-params">id</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"resolved:"</span> + id)
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">onRejected</span>(<span class="hljs-params">id</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"rejected:"</span> + id)
}

<span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> <span class="hljs-title function_">resolve</span>())
<span class="hljs-keyword">let</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> <span class="hljs-title function_">reject</span>())

p1.<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">onResolved</span>(<span class="hljs-string">'p1'</span>),
    <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">onRejected</span>(<span class="hljs-string">'p1'</span>))
p2.<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">onResolved</span>(<span class="hljs-string">'p2'</span>),
    <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">onRejected</span>(<span class="hljs-string">'p2'</span>))
</code></pre>
<p>上述代码中，由于Promise只能转换一次状态，所以p1和p2这两个操作一定是互斥的，其结果为：</p>
<pre><code class="hljs language-bash" lang="bash">resolved:p1
rejected:p2
</code></pre>
<p>由于<code>onResolved处理函数</code> 和 <code>onRejected处理函数</code> 这两个参数都是可选的，当我们只想提供 <code>onRejected处理函数</code> 时，可以在 <code>onResolved</code> 的位置上传入undefined或null，这样可以避免在内存中创建多余的对象，因此then()方法在实际使用中，其传参方式有三种：</p>
<pre><code class="hljs language-javascript" lang="javascript">promise.<span class="hljs-title function_">then</span>(onFulfilled)  <span class="hljs-comment">// 只处理成功</span>
promise.<span class="hljs-title function_">then</span>(<span class="hljs-literal">null</span>, onRejected)  <span class="hljs-comment">// 只处理失败（不推荐）</span>
promise.<span class="hljs-title function_">then</span>(onFulfilled, onRejected)  <span class="hljs-comment">// 同时处理成功和失败</span>
</code></pre>
<blockquote>
<p>注：</p>
<ul>
<li>then()方法中，也可以传递一个非函数，如：promise.then(’Hello‘)，但会被静默忽略，因此不推荐这种写法。</li>
<li>promise.then(null, onRejected)这种写法也是不推荐的，因为一般默认要处理成功回调。</li>
</ul>
</blockquote>
<h3 data-id="heading-3">then()的链式调用</h3>
<p>Promise真正的威力来自于then()的链式调用能力，这不仅仅是语法糖，而是一种函数式编程范式的体现。我们来看看下面一个例子：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 一个典型的链式调用示例</span>
<span class="hljs-title function_">fetchUserData</span>(userId)
  .<span class="hljs-title function_">then</span>(validateUser)            <span class="hljs-comment">// 1. 验证用户数据</span>
  .<span class="hljs-title function_">then</span>(enrichWithProfile)       <span class="hljs-comment">// 2. 丰富个人信息</span>
  .<span class="hljs-title function_">then</span>(saveToDatabase)          <span class="hljs-comment">// 3. 保存到数据库</span>
  .<span class="hljs-title function_">then</span>(notifySubscribers)       <span class="hljs-comment">// 4. 通知订阅者</span>
  .<span class="hljs-title function_">then</span>(updateCache)             <span class="hljs-comment">// 5. 更新缓存</span>
  .<span class="hljs-title function_">then</span>(finalizeOperation);      <span class="hljs-comment">// 6. 完成操作</span>
</code></pre>
<h4 data-id="heading-4">链式调用的四种返回值模式</h4>
<h5 data-id="heading-5">返回普通值</h5>
<p>当then()方法中返回一个普通值时，该值会被包装为一个新的Promise对象，如以下示例：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> myPromise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">'Hello'</span>);
})

myPromise.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'收到:'</span>, value);
    <span class="hljs-keyword">return</span> <span class="hljs-string">'新的普通值'</span>;  <span class="hljs-comment">// 自动包装为 Promise.resolve('新的普通值')</span>
}).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">newValue</span> =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'链式传递:'</span>, newValue);  <span class="hljs-comment">// '新的普通值'</span>
});
</code></pre>
<h5 data-id="heading-6">返回Promise</h5>
<p>当then()方法中返回一个Promise对象时，会等待该Promise完成后，继续下一个then()方法的链式调用，如以下示例：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> myPromise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">'Hello'</span>)
})

myPromise.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
        <span class="hljs-title function_">resolve</span>(value + <span class="hljs-string">' World'</span>)
    }) <span class="hljs-comment">// 返回新的Promise</span>
}).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> {
    <span class="hljs-comment">// 等待new Promise完成</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'处理后的结果:'</span>, response)  <span class="hljs-comment">// Hello World</span>
});

</code></pre>
<h5 data-id="heading-7">抛出异常</h5>
<p>当then()方法中抛出异常时，会转换为一个rejected的Promise对象，如以下示例：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> myPromise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">'Hello'</span>)
})

myPromise.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
    <span class="hljs-keyword">if</span> (!value.<span class="hljs-property">valid</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'数据无效'</span>)  <span class="hljs-comment">// 等价于 Promise.reject(new Error('数据无效'))</span>
    }
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">processValue</span>(value)
}).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'捕获到错误:'</span>, error.<span class="hljs-property">message</span>)  <span class="hljs-comment">// '数据无效'</span>
})
</code></pre>
<h5 data-id="heading-8">没有返回或返回undefined</h5>
<p>当then()方法中没有返回值，或返回值为undefined时，会将undefined作为一个值，继续传递，如以下示例：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> myPromise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">'Hello'</span>)
})

myPromise.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'处理值:'</span>, value)
    <span class="hljs-comment">// 没有return语句</span>
}).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">nextValue</span> =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'下一个值:'</span>, nextValue)  <span class="hljs-comment">// undefined</span>
})
</code></pre>
<h2 data-id="heading-9">catch()方法：错误处理</h2>
<h3 data-id="heading-10">catch()的本质</h3>
<p><code>Catch()</code> 用于给Promise添加拒绝处理程序，它只接受一个参数：<code>onRejected处理函数</code>。实际上，catch()方法是一个语法糖，相当于then(null, onRejected)的语法，它的出现极大地提高了代码的可读性。我们来看看下面一个例子：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 以下两种写法完全等价</span>
promise.<span class="hljs-title function_">catch</span>(onRejected)
promise.<span class="hljs-title function_">then</span>(<span class="hljs-literal">null</span>, onRejected)

<span class="hljs-comment">// 但.catch()的可读性更好</span>
<span class="hljs-title function_">fetchData</span>()
  .<span class="hljs-title function_">then</span>(process)
  .<span class="hljs-title function_">catch</span>(handleError)  <span class="hljs-comment">// 清晰：这里处理错误</span>
  .<span class="hljs-title function_">then</span>(continueAfterError)

<span class="hljs-comment">// 对比：使用.then()的第二个参数</span>
<span class="hljs-title function_">fetchData</span>()
  .<span class="hljs-title function_">then</span>(process, handleError)  <span class="hljs-comment">// 不清晰：是处理fetch错误还是process错误？</span>
  .<span class="hljs-title function_">then</span>(continueAfterError)
</code></pre>
<h3 data-id="heading-11">错误传播机制</h3>
<p>Promise的错误处理遵循冒泡原则：错误会沿着Promise链向后传递，直到被捕获，如以下示例：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 错误传播示例</span>
<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>()
    .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'步骤1: 成功'</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-string">'第一步结果'</span>
    })
    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'步骤2: 收到'</span>, result)
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'步骤2发生错误'</span>)  <span class="hljs-comment">// 抛出错误</span>
    })
    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'步骤3: 这行不会执行'</span>)  <span class="hljs-comment">// 被跳过</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">'第三步结果'</span>;
    })
    .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'捕获到错误:'</span>, error.<span class="hljs-property">message</span>)  <span class="hljs-comment">// '步骤2发生错误'</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">'从错误中恢复'</span>;
    })
    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">recovery</span> =&gt;</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'恢复后继续:'</span>, recovery)  <span class="hljs-comment">// '从错误中恢复'</span>
    });
</code></pre>
<h2 data-id="heading-12">finally()方法：资源清理</h2>
<h3 data-id="heading-13">finally()方法的独特性</h3>
<p><code>Finally()</code>方法用于给Promise实例添加 <code>onFinally处理程序</code>，这个方法可以避免<code>onResolved处理函数</code> 和 <code>onRejected处理函数</code> 中出现冗余代码，无论Promise状态为 <code>fulfilled</code> 或 <code>rejected</code> 的都会执行，即无论Promise是成功还是失败，它都会执行。我们来看看下面的例子：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// .finally()的基本使用</span>
<span class="hljs-title function_">fetchData</span>()
    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'数据处理:'</span>, data);
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">process</span>(data);
    })
    .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'处理失败:'</span>, error);
        <span class="hljs-keyword">throw</span> error; <span class="hljs-comment">// 重新抛出，让外部知道失败</span>
    })
    .<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'清理资源'</span>);  <span class="hljs-comment">// 无论成功失败都会执行</span>
        <span class="hljs-title function_">cleanupResources</span>();
    });
</code></pre>
<h3 data-id="heading-14">finally()方法的三个特性</h3>
<h4 data-id="heading-15">不接受参数</h4>
<pre><code class="hljs language-javascript" lang="javascript">promise.<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// 这里无法访问Promise的结果或错误原因</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'执行清理'</span>)
})
</code></pre>
<h4 data-id="heading-16">原样传递上游的结果或错误</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">'成功数据'</span>)
    .<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'finally执行'</span>);
        <span class="hljs-comment">// 这里返回的值不会影响链的传递</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">'finally的返回值会被忽略'</span>;
    })
    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'收到:'</span>, value);  <span class="hljs-comment">// '成功数据'，不是'finally的返回值'</span>
    })
</code></pre>
<h4 data-id="heading-17">如果finally抛出错误，会覆盖之前的错误</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">'原始数据'</span>)
    .<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'finally中的错误'</span>);  <span class="hljs-comment">// 这个错误会覆盖之前的结果</span>
    })
    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'这不会执行'</span>);  <span class="hljs-comment">// 被跳过</span>
    })
    .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'捕获的错误:'</span>, error.<span class="hljs-property">message</span>);  <span class="hljs-comment">// 'finally中的错误'</span>
    });
</code></pre>
<h2 data-id="heading-18">总结</h2>
<h3 data-id="heading-19">方法对比总结</h3>

































<table><thead><tr><th>方法</th><th>主要用途</th><th>返回值影响</th><th>执行时机</th><th>最佳实践</th></tr></thead><tbody><tr><td>then()</td><td>处理成功结果，链式传递</td><td>决定下一环的输入</td><td>前一个Promise完成后</td><td>保持纯函数，明确返回值</td></tr><tr><td>catch()</td><td>错误捕获和恢复</td><td>可恢复错误或重新抛出</td><td>链中任何错误发生时</td><td>在适当层级处理，不要过早吞没错误</td></tr><tr><td>finally()</td><td>资源清理和状态重置</td><td>不影响结果传递</td><td>无论如何都会执行</td><td>只做清理，不返回业务数据</td></tr></tbody></table>
<h3 data-id="heading-20">黄金法则</h3>
<ul>
<li>单一职责原则：每个then()应该只做一件事。</li>
<li>错误早抛，晚处理：让错误传播到合适的处理层。</li>
<li>finally()只清理：不要在finally中返回业务逻辑数据。</li>
<li>保持链的可读性：合理拆分长链，使用命名函数。</li>
<li>考虑可维护性：为复杂的链添加注释和文档。</li>
</ul>
<h2 data-id="heading-21">结语</h2>
<p>本文主要介绍了Promise的三种实例化方法，对于文章中错误的地方或者有任何问题，欢迎在评论区留言讨论！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Vue3+ElementUI树形菜单：构建层次化用户界面]]></title>    <link>https://juejin.cn/post/7592017365140602932</link>    <guid>https://juejin.cn/post/7592017365140602932</guid>    <pubDate>2026-01-06T01:48:01.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7592017365140602932" data-draft-id="7591704324907597858" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Vue3+ElementUI树形菜单：构建层次化用户界面"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2026-01-06T01:48:01.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="爱分享的鱼鱼"/> <meta itemprop="url" content="https://juejin.cn/user/3901536646733133"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Vue3+ElementUI树形菜单：构建层次化用户界面
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3901536646733133/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    爱分享的鱼鱼
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-06T01:48:01.000Z" title="Tue Jan 06 2026 01:48:01 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-06
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    15
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">引言</h2>
<p>树形菜单能够以层次化的方式展示具有父子关系的数据，使用户能够直观地理解复杂的权限结构、组织架构或内容分类。本文将深入探讨树形菜单的设计原理、实现方式以及在实际项目中的应用。</p>
<h2 data-id="heading-1">什么是树形菜单</h2>
<p>树形菜单（Tree Menu）是一种可视化地展示层次结构数据的UI组件。它通常用于表示具有父子关系的数据集合，如文件系统、组织架构、权限系统等。树形菜单的主要特点包括：</p>
<ul>
<li><strong>层次结构</strong>：清晰地展示数据之间的层级关系</li>
<li><strong>可折叠性</strong>：允许用户展开或折叠节点以控制信息密度</li>
<li><strong>可选择性</strong>：支持单选、多选或级联选择</li>
<li><strong>交互性</strong>：提供丰富的用户交互体验</li>
</ul>
<h2 data-id="heading-2">树形菜单的核心功能</h2>
<h3 data-id="heading-3">1. 展开/折叠功能</h3>
<p>树形菜单最基本的功能是允许用户展开或折叠节点，这有助于控制信息的显示密度。用户可以根据需要查看详细信息或保持界面简洁。</p>
<h3 data-id="heading-4">2. 多选功能</h3>
<p>在权限管理系统中，树形菜单通常需要支持多选功能，允许用户选择多个节点。特别是当需要实现级联选择时（选择父节点时自动选择所有子节点），这一功能尤为重要。</p>
<h3 data-id="heading-5">3. 搜索和过滤</h3>
<p>对于大型树形结构，搜索和过滤功能可以帮助用户快速定位特定节点。</p>
<h2 data-id="heading-6">实现树形菜单的关键技术</h2>
<h3 data-id="heading-7">数据结构</h3>
<p>树形菜单的数据结构通常采用递归结构，每个节点包含以下属性：</p>
<pre><code class="hljs language-javascript" lang="javascript">{
  <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>,                    <span class="hljs-comment">// 节点唯一标识</span>
  <span class="hljs-attr">name</span>: <span class="hljs-string">"系统管理"</span>,          <span class="hljs-comment">// 节点显示名称</span>
  <span class="hljs-attr">parentId</span>: <span class="hljs-literal">null</span>,           <span class="hljs-comment">// 父节点ID</span>
  <span class="hljs-attr">children</span>: [               <span class="hljs-comment">// 子节点数组</span>
    {
      <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>,
      <span class="hljs-attr">name</span>: <span class="hljs-string">"用户管理"</span>,
      <span class="hljs-attr">parentId</span>: <span class="hljs-number">1</span>,
      <span class="hljs-attr">children</span>: []
    }
  ]
}
</code></pre>
<h3 data-id="heading-8">转换算法</h3>
<p>将扁平化的数据转换为树形结构是实现树形菜单的关键步骤。常用的转换算法如下：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">listToTree</span> = (<span class="hljs-params">list, parentId = <span class="hljs-literal">null</span></span>) =&gt; {
  <span class="hljs-keyword">return</span> list
    .<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">parentId</span> === parentId)
    .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> ({
      ...item,
      <span class="hljs-attr">children</span>: <span class="hljs-title function_">listToTree</span>(list, item.<span class="hljs-property">id</span>)
    }))
}
</code></pre>
<h2 data-id="heading-9">在Vue项目中实现树形菜单</h2>
<p>以Element Plus UI库为例，我们可以使用其内置的<a title="" ref="nofollow noopener noreferrer" href="https://link.juejin.cn?target=">el-tree</a>组件来实现功能丰富的树形菜单。</p>
<h3 data-id="heading-10">基础实现</h3>
<pre><code class="hljs language-js" lang="js">&lt;template&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">el-tree</span>
    <span class="hljs-attr">:data</span>=<span class="hljs-string">"treeData"</span>
    <span class="hljs-attr">:props</span>=<span class="hljs-string">"treeProps"</span>
    <span class="hljs-attr">node-key</span>=<span class="hljs-string">"id"</span>
    <span class="hljs-attr">:default-expanded-keys</span>=<span class="hljs-string">"defaultExpandedKeys"</span>
    <span class="hljs-attr">:default-checked-keys</span>=<span class="hljs-string">"checkedKeys"</span>
    <span class="hljs-attr">show-checkbox</span>
  /&gt;</span></span>
&lt;/template&gt;

<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">import</span> { ref } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>

<span class="hljs-comment">// 树形数据</span>
<span class="hljs-keyword">const</span> treeData = <span class="hljs-title function_">ref</span>([
  {
    <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>,
    <span class="hljs-attr">label</span>: <span class="hljs-string">'系统管理'</span>,
    <span class="hljs-attr">children</span>: [
      {
        <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>,
        <span class="hljs-attr">label</span>: <span class="hljs-string">'用户管理'</span>,
        <span class="hljs-attr">children</span>: [
          { <span class="hljs-attr">id</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">label</span>: <span class="hljs-string">'用户查看'</span> },
          { <span class="hljs-attr">id</span>: <span class="hljs-number">4</span>, <span class="hljs-attr">label</span>: <span class="hljs-string">'用户编辑'</span> }
        ]
      }
    ]
  }
])

<span class="hljs-comment">// 树形组件属性配置</span>
<span class="hljs-keyword">const</span> treeProps = {
  <span class="hljs-attr">children</span>: <span class="hljs-string">'children'</span>,
  <span class="hljs-attr">label</span>: <span class="hljs-string">'label'</span>
}

<span class="hljs-comment">// 默认展开的节点</span>
<span class="hljs-keyword">const</span> defaultExpandedKeys = <span class="hljs-title function_">ref</span>([<span class="hljs-number">1</span>])

<span class="hljs-comment">// 默认选中的节点</span>
<span class="hljs-keyword">const</span> checkedKeys = <span class="hljs-title function_">ref</span>([<span class="hljs-number">3</span>])
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
</code></pre>
<h3 data-id="heading-11">高级功能实现</h3>
<h4 data-id="heading-12">1. 级联选择控制</h4>
<p>在某些场景下，我们可能需要控制是否启用级联选择：</p>
<pre><code class="hljs language-javascript" lang="javascript">&lt;el-tree
  :data=<span class="hljs-string">"treeData"</span>
  node-key=<span class="hljs-string">"id"</span>
  show-checkbox
  :check-strictly=<span class="hljs-string">"true"</span>  &lt;!-- 禁用级联选择 --&gt;
/&gt;
</code></pre>
<h4 data-id="heading-13">2. 自定义节点内容</h4>
<p>通过作用域插槽可以自定义节点的显示内容：</p>
<pre><code class="hljs language-vue" lang="vue">&lt;el-tree :data="treeData" :props="defaultProps" @node-click="handleNodeClick"&gt;
  &lt;template #default="{ node, data }"&gt;
    &lt;span class="custom-tree-node"&gt;
      &lt;span&gt;{{ node.label }}&lt;/span&gt;
      &lt;span&gt;
        &lt;el-button type="text" size="small"&gt;编辑&lt;/el-button&gt;
        &lt;el-button type="text" size="small"&gt;删除&lt;/el-button&gt;
      &lt;/span&gt;
    &lt;/span&gt;
  &lt;/template&gt;
&lt;/el-tree&gt;
</code></pre>
<h2 data-id="heading-14">树形菜单在权限管理中的应用</h2>
<p>权限管理是树形菜单最常见的应用场景之一。在角色权限分配中，树形菜单能够清晰地展示菜单权限的层级关系，使管理员能够直观地分配权限。</p>
<h3 data-id="heading-15">实际应用案例：PMS系统中的角色权限管理</h3>
<p>我的项目中，实现了基于树形菜单的角色权限管理功能。具体实现包括：</p>
<ol>
<li><strong>权限数据加载</strong>：从<a title="" ref="nofollow noopener noreferrer" href="https://link.juejin.cn?target=">menusApiService.js</a>获取所有可用的菜单权限</li>
<li><strong>树形结构构建</strong>：使用<a title="" ref="nofollow noopener noreferrer" href="https://link.juejin.cn?target=">listToTree</a>工具函数将扁平化的菜单数据转换为树形结构</li>
<li><strong>权限选择与保存</strong>：通过树形组件的多选功能实现权限的批量分配</li>
</ol>
<h3 data-id="heading-16">权限分配流程</h3>
<ol>
<li><strong>加载权限数据</strong>：从后端获取所有可用的权限节点</li>
<li><strong>构建树形结构</strong>：将权限数据转换为树形结构</li>
<li><strong>显示当前权限</strong>：在树形菜单中高亮显示已分配的权限</li>
<li><strong>选择权限</strong>：用户通过勾选节点来分配权限</li>
<li><strong>提交变更</strong>：将选择的权限保存到后端</li>
</ol>
<h3 data-id="heading-17">实际代码实现</h3>
<p>在<a title="" ref="nofollow noopener noreferrer" href="https://link.juejin.cn?target=">RolesView.vue</a>中，我们实现了完整的权限管理功能：</p>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;el-form-item label="权限列表" prop="permissions" style="max-height: 180px"&gt;
    &lt;div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;"&gt;
      &lt;div&gt;
        &lt;el-button size="small" @click="selectAllPermissions" type="primary"&gt;全选&lt;/el-button&gt;
        &lt;el-button size="small" @click="unselectAllPermissions" type="info" style="margin-left: 10px;"&gt;全不选&lt;/el-button&gt;
        &lt;el-button size="small" @click="invertSelectPermissions" type="warning"&gt;反选&lt;/el-button&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;el-tree 
      ref="permissionTreeRef"
      :data="permissionTreeData" 
      node-key="id" 
      show-checkbox 
      :default-expanded-keys="defaultExpandedKeys"
      :props="treeProps" 
      style="border: 1px solid #dcdfe6; padding: 10px; border-radius: 4px; max-height: 400px; overflow-y: auto;"&gt;
    &lt;/el-tree&gt;
  &lt;/el-form-item&gt;
&lt;/template&gt;
</code></pre>
<h3 data-id="heading-18">权限操作功能</h3>
<h4 data-id="heading-19">全选功能实现</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">selectAllPermissions</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-keyword">if</span> (permissionTreeRef.<span class="hljs-property">value</span>) {
    <span class="hljs-comment">// 获取所有叶子节点的ID</span>
    <span class="hljs-keyword">const</span> allLeafIds = [];
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">collectLeafIds</span> = (<span class="hljs-params">nodes</span>) =&gt; {
      nodes.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">node</span> =&gt;</span> {
        <span class="hljs-keyword">if</span> (node.<span class="hljs-property">children</span> &amp;&amp; node.<span class="hljs-property">children</span>.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {
          <span class="hljs-title function_">collectLeafIds</span>(node.<span class="hljs-property">children</span>);
        } <span class="hljs-keyword">else</span> {
          allLeafIds.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">id</span>);
        }
      });
    };
    <span class="hljs-title function_">collectLeafIds</span>(permissionTreeData.<span class="hljs-property">value</span>);
    
    <span class="hljs-comment">// 全选所有叶子节点</span>
    permissionTreeRef.<span class="hljs-property">value</span>.<span class="hljs-title function_">setCheckedKeys</span>(allLeafIds);
  }
};
</code></pre>
<h4 data-id="heading-20">全不选功能实现</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">unselectAllPermissions</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-keyword">if</span> (permissionTreeRef.<span class="hljs-property">value</span>) {
    permissionTreeRef.<span class="hljs-property">value</span>.<span class="hljs-title function_">setCheckedKeys</span>([]);
  }
};
</code></pre>
<h4 data-id="heading-21">反选功能实现</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">invertSelectPermissions</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-keyword">if</span> (permissionTreeRef.<span class="hljs-property">value</span>) {
    <span class="hljs-keyword">const</span> checkedKeys = permissionTreeRef.<span class="hljs-property">value</span>.<span class="hljs-title function_">getCheckedKeys</span>();
    <span class="hljs-keyword">const</span> allLeafIds = [];
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">collectLeafIds</span> = (<span class="hljs-params">nodes</span>) =&gt; {
      nodes.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">node</span> =&gt;</span> {
        <span class="hljs-keyword">if</span> (node.<span class="hljs-property">children</span> &amp;&amp; node.<span class="hljs-property">children</span>.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {
          <span class="hljs-title function_">collectLeafIds</span>(node.<span class="hljs-property">children</span>);
        } <span class="hljs-keyword">else</span> {
          allLeafIds.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">id</span>);
        }
      });
    };
    <span class="hljs-title function_">collectLeafIds</span>(permissionTreeData.<span class="hljs-property">value</span>);
    
    <span class="hljs-comment">// 计算未选中的叶子节点</span>
    <span class="hljs-keyword">const</span> uncheckedLeafIds = allLeafIds.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">id</span> =&gt;</span> !checkedKeys.<span class="hljs-title function_">includes</span>(id));
    
    <span class="hljs-comment">// 设置树的选中状态为反选</span>
    permissionTreeRef.<span class="hljs-property">value</span>.<span class="hljs-title function_">setCheckedKeys</span>(uncheckedLeafIds);
  }
};
</code></pre>
<h2 data-id="heading-22">实际应用场景分析</h2>
<h3 data-id="heading-23">组织架构管理</h3>
<p>在企业管理系统中，组织架构通常呈现树形结构。树形菜单可以清晰地展示公司、部门、团队之间的层级关系，便于管理员进行组织结构的调整和人员分配。</p>
<h3 data-id="heading-24">文件目录管理</h3>
<p>文件管理系统中的目录结构天然具有树形特征。用户可以通过树形菜单直观地浏览和管理文件夹结构，进行文件的移动、复制等操作。</p>
<h3 data-id="heading-25">产品分类管理</h3>
<p>在电商系统中，产品分类通常采用多级分类结构。树形菜单可以帮助管理员更好地组织和管理商品分类，提高商品管理效率。</p>
<h2 data-id="heading-26">性能优化考虑</h2>
<h3 data-id="heading-27">大数据量处理</h3>
<p>当树形菜单包含大量节点时，需要考虑性能优化：</p>
<ol>
<li><strong>虚拟滚动</strong>：只渲染可视区域内的节点</li>
<li><strong>懒加载</strong>：按需加载子节点数据</li>
<li><strong>数据分页</strong>：对树形数据进行分页处理</li>
</ol>
<h3 data-id="heading-28">内存管理</h3>
<p>在长时间运行的应用中，需要关注内存使用情况：</p>
<ul>
<li>及时清理不需要的事件监听器</li>
<li>避免循环引用导致的内存泄漏</li>
<li>合理使用组件的生命周期钩子</li>
</ul>
<h3 data-id="heading-29">渲染优化</h3>
<p>对于大型树形结构，可以考虑以下优化策略：</p>
<ul>
<li>使用虚拟滚动技术减少DOM节点数量</li>
<li>实现节点的懒加载，只在用户展开时加载子节点</li>
<li>使用防抖技术优化搜索和过滤功能</li>
</ul>
<h2 data-id="heading-30">总结</h2>
<p>树形菜单作为展示层次化数据的重要组件，在现代Web应用中发挥着关键作用。通过合理的设计和实现，树形菜单不仅能够有效地组织复杂的数据结构，还能提供良好的用户体验。</p>
<p>在实际项目开发中，我们需要根据具体需求选择合适的实现方式，考虑性能、可访问性和用户体验等多个方面。随着前端技术的不断发展，树形菜单的实现方式也在不断演进，但其核心目标始终是帮助用户更好地理解和操作层次化数据。</p>
<p>通过本文的介绍，希望能够帮助开发者更好地理解和应用树形菜单组件，在实际项目中构建出功能强大且用户友好的层次化界面。树形菜单不仅是技术实现，更是用户体验设计的重要组成部分，需要在功能性和易用性之间找到平衡点。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[JavaScript的new魔法：从零创造一个对象的奇妙旅程]]></title>    <link>https://juejin.cn/post/7591972586360520723</link>    <guid>https://juejin.cn/post/7591972586360520723</guid>    <pubDate>2026-01-06T02:10:18.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7591972586360520723" data-draft-id="7591672090791215123" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="JavaScript的new魔法：从零创造一个对象的奇妙旅程"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2026-01-06T02:10:18.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="JS_Likers"/> <meta itemprop="url" content="https://juejin.cn/user/1377017277975032"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            JavaScript的new魔法：从零创造一个对象的奇妙旅程
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1377017277975032/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    JS_Likers
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-06T02:10:18.000Z" title="Tue Jan 06 2026 02:10:18 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-06
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">引言：当代码开始“生孩子”</h2>
<p>想象一下，你是一位JavaScript魔法师，有一天你念出了一句咒语 <code>new Person()</code>，突然之间，一个全新的对象就出现在你的面前！这感觉就像是代码在“生孩子”，而<code>new</code>就是那个神奇的助产士。</p>
<p>今天，我们就来揭开这个魔法背后的秘密，看看当你在JavaScript中使用<code>new</code>关键字时，究竟发生了什么奇妙的事情。</p>
<h2 data-id="heading-1">一、先来看一个简单例子</h2>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 定义一个简单的构造函数</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;
}

<span class="hljs-comment">// 给原型添加方法</span>
<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHello</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`你好，我是<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span>，今年<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.age}</span>岁！`</span>);
}

<span class="hljs-comment">// 使用new创建对象</span>
<span class="hljs-keyword">const</span> xiaoming = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">'小明'</span>, <span class="hljs-number">20</span>);
xiaoming.<span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// 输出：你好，我是小明，今年20岁！</span>
</code></pre>
<p>这一切看起来很简单，但幕后到底发生了什么呢？</p>
<h2 data-id="heading-2">二、new操作符的魔法四部曲</h2>
<p>让我们通过流程图来直观理解整个过程：</p>
<pre><code class="hljs language-mermaid" lang="mermaid">flowchart TD
    A[开始：new Constructor()] --&gt; B[第一步&lt;br&gt;创建空对象]
    B --&gt; C[第二步&lt;br&gt;设置原型链]
    C --&gt; D[第三步&lt;br&gt;执行构造函数&lt;br&gt;绑定this]
    D --&gt; E{构造函数有返回值吗？}
    E --&gt;|返回对象| F[返回该对象]
    E --&gt;|其他情况| G[返回新创建的对象]
    F --&gt; H[结束]
    G --&gt; H
</code></pre>
<p>现在，让我们一步步详细解释：</p>
<h3 data-id="heading-3"><strong>第一步：创建空对象</strong></h3>
<p>JavaScript会默默地创建一个全新的空对象：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> newObject = {};
</code></pre>
<h3 data-id="heading-4"><strong>第二步：设置原型链</strong></h3>
<p>这个新对象会连接到构造函数的原型：</p>
<pre><code class="hljs language-javascript" lang="javascript">newObject.<span class="hljs-property">__proto__</span> = <span class="hljs-title class_">Constructor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;
</code></pre>
<p>（注：实际使用的是<code>Object.setPrototypeOf()</code>或内部机制，但<code>__proto__</code>更直观）</p>
<h3 data-id="heading-5"><strong>第三步：执行构造函数并绑定this</strong></h3>
<p>构造函数被调用，并且<code>this</code>被绑定到新创建的对象：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-title class_">Constructor</span>.<span class="hljs-title function_">call</span>(newObject, ...<span class="hljs-variable language_">arguments</span>);
</code></pre>
<h3 data-id="heading-6"><strong>第四步：处理返回值</strong></h3>
<ul>
<li>如果构造函数返回一个对象，那么这个对象会成为整个<code>new</code>表达式的结果</li>
<li>否则，返回新创建的那个对象</li>
</ul>
<h2 data-id="heading-7">三、亲手实现一个自己的new函数</h2>
<p>理解了原理，我们完全可以自己实现一个<code>new</code>的功能：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myNew</span>(<span class="hljs-params">Constructor, ...args</span>) {
    <span class="hljs-comment">// 1. 创建一个新对象</span>
    <span class="hljs-keyword">const</span> obj = {};
    
    <span class="hljs-comment">// 2. 将对象的原型指向构造函数的prototype</span>
    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">setPrototypeOf</span>(obj, <span class="hljs-title class_">Constructor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);
    
    <span class="hljs-comment">// 3. 执行构造函数，绑定this到新对象</span>
    <span class="hljs-keyword">const</span> result = <span class="hljs-title class_">Constructor</span>.<span class="hljs-title function_">apply</span>(obj, args);
    
    <span class="hljs-comment">// 4. 判断返回值类型</span>
    <span class="hljs-keyword">return</span> result <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span> ? result : obj;
}

<span class="hljs-comment">// 测试我们自己的new</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Animal</span>(<span class="hljs-params">type, sound</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">type</span> = type;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">sound</span> = sound;
}

<span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">makeSound</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.type}</span>发出声音：<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.sound}</span>`</span>);
}

<span class="hljs-keyword">const</span> cat = <span class="hljs-title function_">myNew</span>(<span class="hljs-title class_">Animal</span>, <span class="hljs-string">'猫'</span>, <span class="hljs-string">'喵喵'</span>);
cat.<span class="hljs-title function_">makeSound</span>(); <span class="hljs-comment">// 输出：猫发出声音：喵喵</span>
</code></pre>
<h2 data-id="heading-8">四、常见陷阱与趣事</h2>
<h3 data-id="heading-9">陷阱1：忘记使用new</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Car</span>(<span class="hljs-params">model</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">model</span> = model;
}

<span class="hljs-comment">// 错误用法（忘记new）</span>
<span class="hljs-keyword">const</span> myCar = <span class="hljs-title class_">Car</span>(<span class="hljs-string">'Tesla'</span>); 
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myCar); <span class="hljs-comment">// undefined</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">model</span>); <span class="hljs-comment">// Tesla（污染了全局变量！）</span>
</code></pre>
<p>解决方法：使用严格模式或在构造函数中做检查</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Car</span>(<span class="hljs-params">model</span>) {
    <span class="hljs-keyword">if</span> (!(<span class="hljs-variable language_">this</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Car</span>)) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>(model);
    }
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">model</span> = model;
}
</code></pre>
<h3 data-id="heading-10">陷阱2：构造函数返回对象</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Dog</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
    <span class="hljs-keyword">return</span> { <span class="hljs-attr">name</span>: <span class="hljs-string">'我不是狗'</span> }; <span class="hljs-comment">// 返回一个对象</span>
}

<span class="hljs-keyword">const</span> myDog = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">'旺财'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myDog.<span class="hljs-property">name</span>); <span class="hljs-comment">// "我不是狗"（不是预期的"旺财"！）</span>
</code></pre>
<h3 data-id="heading-11">趣事：箭头函数不能当构造函数</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">Person</span> = (<span class="hljs-params">name</span>) =&gt; {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name; <span class="hljs-comment">// 错误！箭头函数没有自己的this</span>
};

<span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">'小明'</span>); <span class="hljs-comment">// TypeError: Person is not a constructor</span>
</code></pre>
<h2 data-id="heading-12">五、实际应用场景</h2>
<h3 data-id="heading-13">场景1：创建具有私有变量的对象</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params"/>) {
    <span class="hljs-comment">// 私有变量</span>
    <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;
    
    <span class="hljs-comment">// 公共方法</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">increment</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
        count++;
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`当前计数：<span class="hljs-subst">${count}</span>`</span>);
    };
    
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">getCount</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
        <span class="hljs-keyword">return</span> count;
    };
}

<span class="hljs-keyword">const</span> counter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Counter</span>();
counter.<span class="hljs-title function_">increment</span>(); <span class="hljs-comment">// 当前计数：1</span>
counter.<span class="hljs-title function_">increment</span>(); <span class="hljs-comment">// 当前计数：2</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(counter.<span class="hljs-property">count</span>); <span class="hljs-comment">// undefined（无法直接访问私有变量）</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(counter.<span class="hljs-title function_">getCount</span>()); <span class="hljs-comment">// 2（通过公共方法访问）</span>
</code></pre>
<h3 data-id="heading-14">场景2：实现简单的继承</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 父类</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Vehicle</span>(<span class="hljs-params">type</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">type</span> = type;
}

<span class="hljs-title class_">Vehicle</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">move</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.type}</span>正在移动...`</span>);
};

<span class="hljs-comment">// 子类</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Car</span>(<span class="hljs-params">brand</span>) {
    <span class="hljs-title class_">Vehicle</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-string">'汽车'</span>); <span class="hljs-comment">// 调用父类构造函数</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">brand</span> = brand;
}

<span class="hljs-comment">// 设置原型链</span>
<span class="hljs-title class_">Car</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Vehicle</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);
<span class="hljs-title class_">Car</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Car</span>;

<span class="hljs-comment">// 添加子类特有方法</span>
<span class="hljs-title class_">Car</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">honk</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.brand}</span>汽车：滴滴！`</span>);
};

<span class="hljs-keyword">const</span> myCar = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>(<span class="hljs-string">'宝马'</span>);
myCar.<span class="hljs-title function_">move</span>(); <span class="hljs-comment">// 汽车正在移动...</span>
myCar.<span class="hljs-title function_">honk</span>(); <span class="hljs-comment">// 宝马汽车：滴滴！</span>
</code></pre>
<h2 data-id="heading-15">六、面试常见问题（悄悄告诉你答案）</h2>
<ol>
<li>
<p><strong>Q: new一个函数发生了什么？</strong>
A: 四部曲：创建空对象 → 设置原型链 → 绑定this执行构造函数 → 处理返回值</p>
</li>
<li>
<p><strong>Q: 如果构造函数返回一个基本类型呢？</strong>
A: 会被忽略，仍然返回新创建的对象</p>
</li>
<li>
<p><strong>Q: 如何判断一个对象是否由某个构造函数创建？</strong>
A: 使用<code>instanceof</code>操作符或检查<code>obj.constructor</code>属性</p>
</li>
</ol>
<h2 data-id="heading-16">结语：new的真正魔法</h2>
<p>现在你知道了，<code>new</code>并不是真的魔法，它只是JavaScript提供的一种语法糖，封装了对象创建、原型设置和构造函数调用的过程。</p>
<p>下次当你使用<code>new</code>时，不妨在心里默念这四部曲，你会发现自己对JavaScript的理解又深了一层。而且，如果你愿意，完全可以不用<code>new</code>，自己手动实现整个流程——只是那样代码会看起来有点啰嗦罢了。</p>
<p>记住，理解这些底层机制，不是为了让你每天手动实现<code>new</code>，而是为了在遇到问题时，知道从哪里寻找答案。</p>
<hr/>
<p><strong>小彩蛋</strong>：你知道吗？在JavaScript早期，甚至有一种设计建议完全取消<code>new</code>关键字，因为开发者经常忘记使用它。但最终<code>new</code>还是保留了下来，成为了JavaScript的标志性特性之一。所以，下次当你忘记写<code>new</code>时，不要自责——连语言设计者都觉得这是个问题呢！</p>
<p>现在，去创造你的对象吧，年轻的JavaScript魔法师！🎩✨</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[大数据-204 混淆矩阵到ROC：不平衡二分类评估指标全梳理 sklearn]]></title>    <link>https://juejin.cn/post/7591799107486171146</link>    <guid>https://juejin.cn/post/7591799107486171146</guid>    <pubDate>2026-01-06T02:20:10.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7591799107486171146" data-draft-id="7591799107486154762" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="大数据-204 混淆矩阵到ROC：不平衡二分类评估指标全梳理 sklearn"/> <meta itemprop="keywords" content="后端,大数据,机器学习"/> <meta itemprop="datePublished" content="2026-01-06T02:20:10.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="武子康"/> <meta itemprop="url" content="https://juejin.cn/user/149189314230039"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            大数据-204 混淆矩阵到ROC：不平衡二分类评估指标全梳理 sklearn
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/149189314230039/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    武子康
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-06T02:20:10.000Z" title="Tue Jan 06 2026 02:20:10 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-06
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读11分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">TL;DR</h2>
<ul>
<li>场景：类别不平衡时 Accuracy 失真，业务更关心“少数类捕获”和“误伤成本”。</li>
<li>结论：用混淆矩阵统一口径，再用 Precision/Recall/F1 与 ROC/AUC 做权衡与阈值选择。</li>
<li>产出：TP/FP/FN/TN 定义与指标映射 + sklearn 指标/绘图接口版本要点 + 常见坑速查卡。</li>
</ul>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b9d4e16393c34233af5bd512077e4a78~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5q2m5a2Q5bq3:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768270810&amp;x-signature=1AlQ8XBWGepYP5FIiztY6U6urV0%3D" alt="大数据-204 混淆矩阵到ROC：不平衡二分类评估指标全梳理 sklearn" loading="lazy"/></p>
<h2 data-id="heading-1">版本矩阵</h2>


















































<table><thead><tr><th>项/接口</th><th>已验证</th><th>说明</th></tr></thead><tbody><tr><td>scikit-learn</td><td>✅ 1.8.0</td><td>PyPI 标注最新稳定版，发布日期 2025-12-10；Requires: Python ≥3.11</td></tr><tr><td>Python</td><td>✅ ≥3.11</td><td>sklearn 1.8.0 明确要求 Python ≥3.11</td></tr><tr><td>NumPy</td><td>✅ ≥1.24.1</td><td>sklearn 1.8.0 依赖声明</td></tr><tr><td>SciPy</td><td>✅ ≥1.10.0</td><td>sklearn 1.8.0 依赖声明</td></tr><tr><td>sklearn.metrics.confusion_matrix</td><td>✅ 1.8.0</td><td>文档normalize={'true','pred','all'}：按真实/预测/全体归一化</td></tr><tr><td>sklearn.metrics.ConfusionMatrixDisplay</td><td>✅ 1.8.0</td><td>文档推荐用 from_estimator/from_predictions 生成展示对象</td></tr><tr><td>sklearn.metrics.roc_curve</td><td>✅ 1.8.0</td><td>文档签名含 pos_label，输入是 y_score（分数/概率），非离散标签</td></tr><tr><td>sklearn.metrics.RocCurveDisplay</td><td>✅ 1.8.0</td><td>文档从 estimator 直接生成 ROC 展示</td></tr></tbody></table>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2ba7655f18ae4632b82c78a283c001bb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5q2m5a2Q5bq3:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768270810&amp;x-signature=0AaqgaoYgGhbgYYOboxXfDXDB6U%3D" alt="在这里插入图片描述" loading="lazy"/></p>
<h2 data-id="heading-2">混淆矩阵</h2>
<p>从上一节的例子中可以看出，如果我们的目标是希望尽量捕获少数类，那准确率这个模型评估逐渐失效，所以我们需要新的模型评估指标来帮助我们。如果简单来看，其实我们只需要查看模型在少数类上的准确率就好了，只要能够将少数类尽量捕捉出来，就能够达到我们的目的。
但此时，新问题又出现了，我们对多数类判断错误后，会需要人工甄别或者更多的业务上的措施来一一排除我们判断错误的多数类，这种行为往往伴随着很高的成本。
比如银行在判断一个申请信用卡的客户是否会违约行为的时候，如果一个客户被判断为会违约，这个客户的信用卡申请就会驳回，如果为了捕捉会违约的人，大量地将不会违约的客户判断为会违约的客户，就会有许多无辜的客户的申请被驳回。
也就是说，单纯的追求捕捉少数类，就会成本太高，而不顾及少数类，又会无法达成模型的效果。所以在现实中，我们往往在寻找捕获少数类的能力和将多数判错后需要付出的成本的平衡。如果一个模型在能够尽量捕获少数类的情况下，还能够尽量对多数判断正确，则这个模型就非常优秀了。为了评估这样的能力，我们将引入新的模型评估指标：混淆矩阵可以帮助我们。</p>
<ul>
<li>混淆矩阵是二分类问题的多维衡量指标体系，在样本不平衡时极其有用</li>
<li>在混淆矩阵中，我们将少数类认为时正例，多数类认为时负例</li>
<li>在决策树，随机森林这些算法里，即是说少数类是1，多数类时 0</li>
<li>在 SVM 里，就是说少数类时 1，多数类时 -1</li>
</ul>
<p>普通的混淆里，一般使用「0，1」来表示，混淆矩阵如其名，十分容易让人混淆，在需要教材中各种各样的名称和定义让大家难以理解和记忆。
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4b09f0a77c544daa92904d08f390033b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5q2m5a2Q5bq3:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768270810&amp;x-signature=0UCqdg8h%2BieXoo4E8JFQVwC0zFM%3D" alt="混淆矩阵" loading="lazy"/></p>
<p>其中:</p>
<ul>
<li>行代表预测情况，列则表示实际情况</li>
<li>预测值是 1，记为 P（Positive）</li>
<li>预测值是 0，记为 N（Negative）</li>
<li>预测值与真实值相同，记为 T（True）</li>
<li>预测值与真实值相反，记为 F（False）</li>
</ul>
<p>因此矩阵中四个元素分别表示：</p>
<ul>
<li>TP（True Positive）真实为 1，预测为 1</li>
<li>FN（False Negative）真实为 1，预测为 0</li>
<li>FP（False Positive）真实为 0，预测为 1</li>
<li>TN（True Negative）真实为 0，预测为 0</li>
</ul>
<p>基于混淆矩阵，我们有一系列不同的模型评估指标，这些评估指标范围都在【0，1】之间，所以有11 和 00为分子的指标都是越来越接近 1 越好，所以 01 和 10 为分子的指标都是越来越接近 0 越好。
对于所有指标，我们用橙色表示分母，用绿色表示分子，则我们有：</p>
<h3 data-id="heading-3">准确率 Accuracy</h3>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2e41e503f1274fbb9b2088e500a270e2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5q2m5a2Q5bq3:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768270810&amp;x-signature=aSmJvD0ofSWcO11680ZJisR70m8%3D" alt="准确率 Accuracy" loading="lazy"/></p>
<h3 data-id="heading-4">精确度 Precision</h3>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/29386a1884774279bdb2cd1e11066c08~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5q2m5a2Q5bq3:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768270810&amp;x-signature=AgsBBw4S4KSuz0h1CrXdy%2Be55mE%3D" alt="精确度 Precision" loading="lazy"/>
精确度 Precision，又叫查准率，表示在所有预测结果为 1 的样例数中，实际为 1 的样例数所占比重。精确度越低，意味着 01 比重很大，则代表你的模型对多数类 0 误判率越高，误伤了过多的多数类。为了避免对多数类的误伤，需要追求高精确度。
精确度是将多数类判错后所需要付出成本的衡量</p>
<h3 data-id="heading-5">召回率 Recall</h3>
<p>召回率 Recall，又称为敏感度（sensitivity），真正率，查全率，表示所有真实为 1 的样本中，被我们预测正确的样本所占的比例。
召回率越高，代表我们尽量捕捉出了越多的少数类。召回率越低，代表我们捕捉出足够的少数类。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1afea7f61ce8411db448f678b5f9fb99~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5q2m5a2Q5bq3:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768270810&amp;x-signature=IculmEEpNfkt5BllO9NTdSAR8Gw%3D" alt="召回率 Recall" loading="lazy"/>
我们希望不计代价，找出少数类（比如潜逃的犯罪分子），那我们会追求高召回率，相反如果我们的目标不是尽量捕获少数类，那我们就不需要在意召回率。
注意召回率和精确度的分子是相同的（都是 11），只是分母不同。
而召回率和精确度是此消彼长的，两者之间的平衡代表了捕捉少数类的需求和尽量不要误伤多数类的需要求的平衡。
究竟要偏向哪一方，取决于我们的业务需求：究竟是误伤多数类的成本更高，还是无法捕捉少数类的代表更高。</p>
<h3 data-id="heading-6">F1 Measure</h3>
<p>为了同时兼顾精确度和召回率，我们创造了两者的调和平均数作为考量两者平衡的综合性指标，称之为F1 Measure。
两个数之间的调和平均倾向于靠近两个数中比较小的那一个数，因此我们追求尽量高的F1 Measure，能够保证我们精确度和召回率都比较高。
F1 Measure 在 [0,1]之间分布，越接近 1 越好。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b64dfa85f5a041368d43cdb82eb92974~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5q2m5a2Q5bq3:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768270810&amp;x-signature=KtAcDXUP58U3Imo5%2F7MeQCrgjGA%3D" alt="F1 Measure" loading="lazy"/></p>
<h3 data-id="heading-7">假负率</h3>
<p>从 Recall 延伸出来的另一个评估指标叫做假负率（False Negative Rate），它等于 1 - Recall，用于衡量。
所有真实为 1 的样本中，被我们错误判断为 0 的，通常用的不多。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/aec03038738343b99de200c9bfbb10bf~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5q2m5a2Q5bq3:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768270810&amp;x-signature=62xoFRSi73sV85xkwFapAHlRti4%3D" alt="假负率" loading="lazy"/></p>
<h3 data-id="heading-8">ROC 曲线</h3>
<p>ROC 的全称是：Receiver Operating characteristic Curve，其主要的分析方法就是画这条特征曲线。
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/eddd6b7696f34945be14b04b18454568~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5q2m5a2Q5bq3:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768270810&amp;x-signature=PdRdpc8m9mRZrP%2FanHAM2EkuJhI%3D" alt="ROC 曲线" loading="lazy"/></p>
<p>该曲线的横坐标为假正率（False Positive Rate，FPR），N 是真实负样本的个数，FP 是N 个负样本中被分类器预测为正样本的个数。
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bb9b7f8244c8466b93b3c9d8022e3352~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5q2m5a2Q5bq3:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768270810&amp;x-signature=hvbRCr930uQStuOpY9TrOPPBMPY%3D" alt="ROC 曲线" loading="lazy"/>
纵坐标为召回率，真正率（True Positive Rate，TPR）：
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/aa057827510a4f1c89b63c5fbd78f5a4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5q2m5a2Q5bq3:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768270810&amp;x-signature=aJcdS5CAM6L%2BXRWkoG3eSZPiNjY%3D" alt="真正率（True Positive Rate，TPR）" loading="lazy"/>
P 是真实正样本的个数，TP 是 P 个正样本被分类器预测为正样本的个数。</p>
<h3 data-id="heading-9">sklearn 中的混淆矩阵</h3>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/af3301732c3f486b80f70f65dcf1c8c3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5q2m5a2Q5bq3:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768270810&amp;x-signature=0vXSH%2BBFohjR9OvPr4hbRH4fI9w%3D" alt="sklearn 中的混淆矩阵" loading="lazy"/></p>
<h2 data-id="heading-10">决策树的算法评价</h2>
<h3 data-id="heading-11">决策树优点详解</h3>
<ol>
<li>
<p><strong>易于理解和解释</strong></p>
<ul>
<li>决策树采用树形结构展示决策过程，可视化程度高，非专业人士也能理解</li>
<li>每个节点代表一个特征判断，分支代表判断结果，叶子节点代表最终决策</li>
<li>示例：在银行贷款审批场景中，可以直观看到"收入&gt;5万→信用良好→批准"这样的决策路径</li>
</ul>
</li>
<li>
<p><strong>数据预处理要求低</strong></p>
<ul>
<li>不需要特征缩放或标准化（如决策树对特征的数值范围不敏感）</li>
<li>能直接处理类别型特征，无需one-hot编码（但sklearn实现需要）</li>
<li>注意：主流实现（如sklearn）确实不支持缺失值自动处理，需提前填充</li>
</ul>
</li>
<li>
<p><strong>预测效率高</strong></p>
<ul>
<li>预测时间复杂度为O(log n)，n是训练样本数</li>
<li>对比：KNN预测需要O(n)，SVM需要O(n_sv)支持向量数量</li>
<li>适合实时预测场景，如金融风控系统需要毫秒级响应</li>
</ul>
</li>
<li>
<p><strong>多类型数据处理能力</strong></p>
<ul>
<li>可混合处理数值特征（如年龄、收入）和类别特征（如性别、职业）</li>
<li>既可用于分类（预测类别标签）也可用于回归（预测连续值）</li>
<li>应用场景示例：房价预测（回归）和客户流失预测（分类）可使用相同算法</li>
</ul>
</li>
<li>
<p><strong>模型鲁棒性</strong></p>
<ul>
<li>对数据分布假设较少，即使特征间存在非线性关系也能较好处理</li>
<li>对异常值相对不敏感，因为分裂依据是特征排序而非绝对值</li>
</ul>
</li>
</ol>
<h3 data-id="heading-12">决策树缺点详解</h3>
<ol>
<li>
<p><strong>过拟合风险</strong></p>
<ul>
<li>容易生长出过于复杂的树，完美拟合训练数据但泛化能力差</li>
<li>解决方案：
<ul>
<li>预剪枝：设置max_depth（最大深度）、min_samples_leaf（叶节点最小样本数）</li>
<li>后剪枝：训练完整树后剪除不重要的分支</li>
<li>示例：限制max_depth=5通常能平衡模型复杂度与性能</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>模型不稳定性</strong></p>
<ul>
<li>训练数据微小变化可能导致完全不同的树结构</li>
<li>根本原因：贪婪算法的局部最优特性</li>
<li>改进方法：
<ul>
<li>使用集成学习（如随机森林）通过多棵树投票降低方差</li>
<li>随机森林中设置max_features参数控制特征采样随机性</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>局部最优问题</strong></p>
<ul>
<li>每次分裂只考虑当前节点的最优解，不能回溯调整之前的分裂</li>
<li>可能导致次优全局模型</li>
<li>解决方案：
<ul>
<li>集成方法：通过Bagging或Boosting组合多个弱学习器</li>
<li>特征工程：人工构造更有判别力的特征</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>类别不平衡敏感</strong></p>
<ul>
<li>当某一类别样本占比过大时，模型会偏向该类别</li>
<li>解决方法：
<ul>
<li>上采样少数类或下采样多数类</li>
<li>使用类别权重参数（如class_weight='balanced'）</li>
<li>采用AUC等对类别不平衡不敏感的评价指标</li>
</ul>
</li>
<li>示例：在欺诈检测中，正常交易占比99%时需特别处理不平衡问题</li>
</ul>
</li>
</ol>
<h2 data-id="heading-13">错误速查</h2>








































<table><thead><tr><th>症状</th><th>根因定位</th><th>修复</th></tr></thead><tbody><tr><td>混淆矩阵“行列含义”对不上（看起来 TP/FP 被交换）</td><td>把轴含义记反（真实/预测放反）或画图工具默认顺序误读</td><td>用 3~5 条手工样例算一次 TP/FP/FN/TN，对照矩阵四格明确 confusion_matrix(y_true, y_pred) 语义；展示时统一标注“真实/预测”；必要时转置但要同步改口径</td></tr><tr><td>Precision/Recall 数值异常（Precision 很低或 Recall 很低且不符合直觉）</td><td>正例标签 pos_label 不一致（0/1 vs -1/1 vs 字符串）；labels 排序与业务正例不一致</td><td>打印 np.unique(y_true) 与 np.unique(y_pred)；检查“少数类是否真被当作正类”在 ROC/二分类指标里显式设 pos_label；在混淆矩阵里显式设 labels=[neg,pos] 保持业务顺序</td></tr><tr><td>ROC 曲线“像一条直线/点很少/与预期相反”</td><td>把 y_pred（0/1标签）当成 y_score；或分数方向反了（正例分数更小）</td><td>检查传入 roc_curve 的第二个参数是否只有 {0,1}；检查正例的分数均值是否更高传 predict_proba[:,1] 或 decision_function；必要时取反分数或修正正例定义（pos_label）</td></tr><tr><td>归一化后的混淆矩阵“百分比不对”（每行不和为1或每列不和为1）</td><td>误解 normalize='true'/'pred'/'all' 的分母</td><td>观察归一化后是“行和=1”还是“列和=1”需要“召回视角”用 normalize='true'；需要“精确视角”用 normalize='pred'；全体占比用 normalize='all'</td></tr><tr><td>Accuracy 很高但业务效果差（漏掉关键少数类）</td><td>类别不平衡导致多数类主导；阈值默认 0.5 不匹配成本函数</td><td>看混淆矩阵中 FN 是否偏大；看 Recall/TPR 是否偏低以 Precision/Recall/F1 或 ROC/AUC 为主；按业务成本调阈值，并在评估报告里固定“正例定义+阈值”</td></tr><tr><td>“捕获少数类”提升后，误伤多数类激增（审核/拒绝量爆炸）</td><td>单点追求 Recall，忽略 FP 成本</td><td>看 FP 与 Precision 的变化趋势以 Precision 作为成本约束，做阈值扫描/PR 权衡；在上线指标中同时锁定 Precision 下限与 Recall 下限</td></tr></tbody></table>
<h2 data-id="heading-14">其他系列</h2>
<h3 data-id="heading-15">🚀 AI篇持续更新中（长期更新）</h3>
<p><strong>AI炼丹日志-29 - 字节跳动 DeerFlow 深度研究框<em>斜体样式</em>架 私有部署 测试上手 架构研究</strong>，持续打造实用AI工具指南！
<strong>AI研究-132 Java 生态前沿 2025：Spring、Quarkus、GraalVM、CRaC 与云原生落地</strong></p>
<h3 data-id="heading-16">💻 Java篇持续更新中（长期更新）</h3>
<p><strong>Java-218 RocketMQ Java API 实战：同步/异步 Producer 与 Pull/Push Consumer</strong>
MyBatis 已完结，Spring 已完结，Nginx已完结，Tomcat已完结，分布式服务已完结，Dubbo已完结，MySQL已完结，MongoDB已完结，Neo4j已完结，FastDFS 已完结，OSS已完结，GuavaCache已完结，EVCache已完结，RabbitMQ已完结，RocketMQ正在更新... 深入浅出助你打牢基础！</p>
<h3 data-id="heading-17">📊 大数据板块已完成多项干货更新（300篇）：</h3>
<p>包括 Hadoop、Hive、Kafka、Flink、ClickHouse、Elasticsearch 等二十余项核心组件，覆盖离线+实时数仓全栈！
<strong>大数据-278 Spark MLib - 基础介绍 机器学习算法 梯度提升树 GBDT案例 详解</strong></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[多智能体协作案例实践（一）：基于AgentScope框架]]></title>    <link>https://juejin.cn/post/7591730714140540970</link>    <guid>https://juejin.cn/post/7591730714140540970</guid>    <pubDate>2026-01-06T01:06:31.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7591730714140540970" data-draft-id="7591506455973625910" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="多智能体协作案例实践（一）：基于AgentScope框架"/> <meta itemprop="keywords" content="后端,Python,人工智能"/> <meta itemprop="datePublished" content="2026-01-06T01:06:31.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="木昆子"/> <meta itemprop="url" content="https://juejin.cn/user/825103640698564"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            多智能体协作案例实践（一）：基于AgentScope框架
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/825103640698564/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    木昆子
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-06T01:06:31.000Z" title="Tue Jan 06 2026 01:06:31 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-06
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    26
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读17分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在之前<a href="https://juejin.cn/post/7591510742648602667" target="_blank" title="https://juejin.cn/post/7591510742648602667">《几种AI Agent开发框架对比》</a>这篇文章中，我们设计了一个高考信息查询智能助手业务场景，使用几种AI Agent开发框架分别实现进行对比分析，因为文档太长，其中多智能体协作章节就没有详细展开。</p>
<p>本文基于AgentScope框架，对多智能体协作场景进行详细实践和对比分析，后面还会有一篇基于LangGraph框架的实践分析。</p>
<p>为了更好地模拟，我们还是基于之前高考信息查询这个业务场景，将原有的单智能体拆分为四个模块，对应四个智能体如下：</p>
<p>Template Agent：模板匹配，我们将SQL Agent生成的SQL保存为模板，提取年份参数，当下一次追问仅仅是对年份的追问时，直接取模板内的SQL查询分析即可。</p>
<p>Rewrite Agent：意图识别，根据上下文改写问题完善条件，支持多轮追问场景。</p>
<p>SQL Agent：通过自然语言匹配表结构等信息，然后生成SQL，再执行SQL查询出数据。</p>
<p>Analysis Agent：分析结果数据并简要回答用户问题。</p>
<h2 data-id="heading-0">🧠 多智能体协作实现逻辑</h2>
<p>首先看一下业务场景，打算基于以上四个智能体协作，来支撑用户进行高考信息查询，并且要支持多轮对话，后续会基于以下案例来进行验证：</p>
<p>第一轮提问：2016年考生人数有多少？<br/>
第二轮追问年份：2018年呢？<br/>
第三轮追问其他：录取人数呢？</p>
<p>针对该业务场景，四个智能体之间的协作逻辑设计如下：</p>
<p>1）用户输入问题</p>
<p>2）TemplateAgent判断是否匹配模板，未匹配NO_MATCH转3，无上下文NO_CONTEXT则转4，匹配则转5</p>
<p>3）未匹配NO_MATCH即匹配失败，进入意图识别改写RewriteAgent，利用上下文对话背景进行问题改写，然后进入SQLAgent，RAG检索元数据、生成SQL、查询数据，最后进入AnalysisAgent分析回答</p>
<p>4）无上下文NO_CONTEXT即首次提问，直接进入SQLAgent，RAG检索元数据、生成SQL、查询数据，最后进入AnalysisAgent分析回答</p>
<p>5、直接AnalysisAgent分析回答</p>
<p>整体协作逻辑概览如下：</p>
<pre><code class="hljs language-css" lang="css">    <span class="hljs-selector-attr">[用户输入]</span>
        ↓
    <span class="hljs-selector-attr">[TemplateAgent]</span>
        ↓
    ┌─────────────────────匹配结果──────────────────────┐
    ↓                        ↓                        ↓
<span class="hljs-selector-attr">[匹配成功-管道1]</span>          <span class="hljs-selector-attr">[匹配失败有上下文-管道2]</span>   <span class="hljs-selector-attr">[匹配失败无上下文-管道3]</span>
    ↓                        ↓                        ↓
<span class="hljs-selector-attr">[AnalysisAgent]</span>         <span class="hljs-selector-attr">[RewriteAgent]</span>          <span class="hljs-selector-attr">[SQLAgent]</span>
                             ↓                        ↓
                        <span class="hljs-selector-attr">[SQLAgent]</span>              <span class="hljs-selector-attr">[AnalysisAgent]</span>
                             ↓                        
                        <span class="hljs-selector-attr">[AnalysisAgent]</span>               ↓
    ↓                        ↓
    └────────────输出结果──────────────┘
        ↑
        └──────── Memory + Context Reuse ────────────┘
</code></pre>
<p>针对以上协作逻辑中的三种分支处理逻辑，实际还是要通过手写代码方式来进行逻辑控制，然后其中每钟分支流程中如果涉及到多个Agent，则可以通过AgentScope框架提供的管道模式（sequential_pipeline）进行串联，具体代码如下：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># --- 对话主流程 ---</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">chat</span>():
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"启动 AgentScope 多智能体系统（输入 exit 退出）"</span>)

    template_agent = TemplateAgent()
    rewrite_agent = RewriteAgent()
    sql_agent = SQLAgent()
    analysis_agent = AnalysisAgent()

    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
        user_input = <span class="hljs-keyword">await</span> asyncio.get_event_loop().run_in_executor(
            <span class="hljs-literal">None</span>, <span class="hljs-built_in">input</span>, <span class="hljs-string">"👤 用户: "</span>
        )
        <span class="hljs-keyword">if</span> user_input.strip().lower() == <span class="hljs-string">"exit"</span>:
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"退出程序"</span>)
            <span class="hljs-keyword">break</span>

        user_msg = Msg(<span class="hljs-string">"user"</span>, user_input, role=<span class="hljs-string">"user"</span>)
        <span class="hljs-comment"># 所有 Agent 观察输入</span>
        <span class="hljs-keyword">for</span> agent <span class="hljs-keyword">in</span> [template_agent, rewrite_agent, sql_agent, analysis_agent]:
            <span class="hljs-keyword">await</span> agent.observe(user_msg)

        <span class="hljs-comment"># Step 1️⃣ 模板匹配</span>
        template_res = <span class="hljs-keyword">await</span> template_agent.reply(user_msg)

        <span class="hljs-keyword">if</span> template_res.content.strip().upper() == <span class="hljs-string">"NO_MATCH"</span>:
            <span class="hljs-comment"># 模板失败 → 走 改写 → SQL → 分析</span>
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"🌀 模板匹配失败，进入改写流程"</span>)
            final_msg = <span class="hljs-keyword">await</span> sequential_pipeline([rewrite_agent, sql_agent, analysis_agent], user_msg)
        <span class="hljs-keyword">elif</span> template_res.content.strip().upper() == <span class="hljs-string">"NO_CONTEXT"</span>:
            <span class="hljs-comment"># 无上下文 → 走 SQL → 分析</span>
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"🌀 无上下文，进入SQL流程"</span>)
            final_msg = <span class="hljs-keyword">await</span> sequential_pipeline([sql_agent, analysis_agent], user_msg)
        <span class="hljs-keyword">else</span>:
            <span class="hljs-comment"># 模板成功匹配 → 走 SQL + 分析</span>
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"🎯 模板匹配成功，直接进入分析流程"</span>)
            final_msg = <span class="hljs-keyword">await</span> sequential_pipeline([analysis_agent], template_res)

        <span class="hljs-comment"># 所有 Agent 观察结果</span>
        <span class="hljs-keyword">for</span> agent <span class="hljs-keyword">in</span> [template_agent, rewrite_agent, sql_agent, analysis_agent]:
            <span class="hljs-keyword">await</span> agent.observe(final_msg)

        <span class="hljs-built_in">print</span>(<span class="hljs-string">"\n"</span> + <span class="hljs-string">"-"</span> * <span class="hljs-number">50</span>)
</code></pre>
<p>代码中在启动时先创建了四个智能体，通过if else 来串联业务分支，一个分支对应由 sequential_pipeline() 构建一个包含多Agent组成的管道，管道内部每个 Agent 实现独立职责，并通过 Msg 消息结构传递数据与上下文记忆（InMemoryMemory）。</p>
<h3 data-id="heading-1"><strong>🔁 多轮对话之上下文记忆+全局变量</strong></h3>
<p>先看上下文记忆的相关机制，每个 Agent 都可以观察多轮对话，通过上下文memory，支持多轮追问与问题补全。如下面这段代码所示，将用户输入问题user_msg，以及最终输出结果final_msg，通过调用agent.observe这个方法来告知所有的智能体：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">user_msg</span> = Msg(<span class="hljs-string">"user"</span>, user_input, role=<span class="hljs-string">"user"</span>)
<span class="hljs-comment"># 所有 Agent 观察输入</span>
for agent in <span class="hljs-section">[template_agent, rewrite_agent, sql_agent, analysis_agent]</span>:
    await agent.observe(user_msg)

......

<span class="hljs-comment"># 所有 Agent 观察结果</span>
for agent in <span class="hljs-section">[template_agent, rewrite_agent, sql_agent, analysis_agent]</span>:
    await agent.observe(final_msg)
</code></pre>
<p>同时在所有Agent智能体的实现代码中，都定义了observe这个方法，来接收用户输入和系统输出的上下文对话历史，并保存到Agent内部的记忆模块：</p>
<pre><code class="hljs language-python" lang="python">    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">observe</span>(<span class="hljs-params">self, msg: Msg | <span class="hljs-built_in">list</span>[Msg] | <span class="hljs-literal">None</span></span>) -&gt; <span class="hljs-literal">None</span>:  
        <span class="hljs-keyword">await</span> self.memory.add(msg)
</code></pre>
<p>智能体内部记忆模块都会持有多轮对话的上下文历史，供处理用户新输入时使用，当然实际本案例中只有问题改写RewriteAgent才需要使用多轮对话上下文，其从记忆模块中获取上下文并用于问题改写的代码逻辑如下：</p>
<pre><code class="hljs language-python" lang="python">    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">reply</span>(<span class="hljs-params">self, msg: Msg</span>) -&gt; Msg:
        <span class="hljs-string">"""理解意图并改写"""</span>
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"=== 🟨 Rewrite Agent ==="</span>)
        user_query = msg.content

        <span class="hljs-comment"># 从记忆中取出历史上下文</span>
        history = <span class="hljs-keyword">await</span> self.memory.get_memory()

        <span class="hljs-comment"># 构造 prompt</span>
        user_prompt = <span class="hljs-string">f"""
            用户的问题可能是不完整的追问或模糊描述，请结合上下文补全成一个清晰的问题。

            【当前问题】
            "<span class="hljs-subst">{user_query}</span>"

            请将上面的问题改写成一个**可独立理解、完整表达查询意图**的自然语言问题。
            要求：
            1. 根据原意图内容补充信息，完善条件即可，无须发散联想
            2. 不超过 50 字
            3. 仅输出改写后的问题内容
        """</span>
        prompt = <span class="hljs-keyword">await</span> self.formatter.<span class="hljs-built_in">format</span>([
            Msg(<span class="hljs-string">"system"</span>, <span class="hljs-string">"你是一个查询意图理解与改写专家。"</span>, <span class="hljs-string">"system"</span>),
            *history,
            Msg(<span class="hljs-string">"user"</span>, user_prompt, <span class="hljs-string">"user"</span>),
        ])

        result = <span class="hljs-keyword">await</span> self.model(prompt)
        final_res = <span class="hljs-keyword">await</span> get_response(result)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"✍️ 改写后问题：<span class="hljs-subst">{final_res}</span>"</span>)
</code></pre>
<p>基于这段代码，针对用户简写的问题“录取人数呢？”，根据历史对话“2018年考生人数”相关的记忆来改写，改写补全后就变成“2018年录取人数有多少？”的完整问题。</p>
<p>除了记录多轮对话输入/输出Msg的上下文记忆模块Memory之外，还可以利用全局变量方式在多个智能体Agent之间进行结构化的参数传递，如下定义一个全局变量stata，存放历史查询SQL的模板，方便后续同类问题直接使用：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># ========================</span>
<span class="hljs-comment"># 🧠 全局变量定义</span>
<span class="hljs-comment"># ========================</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">State</span>(<span class="hljs-title class_ inherited__">TypedDict</span>):
    original_intent: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>]  <span class="hljs-comment"># 如 "2016年考生人数有多少？"</span>
    last_sql_template: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>]  <span class="hljs-comment"># 带占位符的 SQL 模板，如 "SELECT ... WHERE year = {year}"</span>

state = State()
</code></pre>
<p>就可以实现在前一轮对话时，在SQLAgent智能体中将根据用户问题+匹配到的表结构信息生成对应查询SQL后，将该SQL和用户问题都置入全局变量中：</p>
<pre><code class="hljs language-python" lang="python">        <span class="hljs-comment"># 生成 SQL 模板（简单年份/数字替换）  </span>
        template_sql = re.sub(<span class="hljs-string">r'\b(19|20)\d{{2}}\b'</span>, <span class="hljs-string">'{year}'</span>, sql)  <span class="hljs-comment"># 年份  </span>
        template_sql = re.sub(<span class="hljs-string">r'\b\d+\b'</span>, <span class="hljs-string">'{year}'</span>, template_sql, count=<span class="hljs-number">1</span>)  <span class="hljs-comment"># 兜底替换第一个数字  </span>
  
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"🧠 原始意图: <span class="hljs-subst">{user_query}</span>"</span>)  
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"📦 保存 SQL 模板: <span class="hljs-subst">{template_sql}</span>"</span>)  
  
        state[<span class="hljs-string">"original_intent"</span>] = user_query          
        state[<span class="hljs-string">"last_sql_template"</span>] = template_sql
</code></pre>
<p>然后在下一轮对话时，在TemplateAgent智能体中再从全局变量中取出该信息，利用LLM判断用户最新查询意图和全局变量中的用户问题是否同一种问题，只是查询条件不同的追问（如只是从2016年换成2018年），如果是的话，就直接利用全局变量中的SQL，替换掉查询条件进行查询即可，这样就不用走后续的SQLAgent，再去重新利用LLM去构建SQL了。</p>
<pre><code class="hljs language-python" lang="python">        <span class="hljs-built_in">print</span>(<span class="hljs-string">"🔄 检测到历史上下文，尝试参数化追问"</span>)  
        <span class="hljs-keyword">try</span>:  
            <span class="hljs-comment"># 1. 用 LLM 从追问中提取参数  </span>
            extract_prompt = <span class="hljs-string">f"""  
                原始意图: <span class="hljs-subst">{state[<span class="hljs-string">'original_intent'</span>]}</span>  
                当前问题: "<span class="hljs-subst">{user_query}</span>"  
  
                请判断一下用户是否在进行年份的追问。  
                1、如果不是对年份的追问，直接输出空JSON '{{}}'  
                2、如果是追问，从中提取**变化的参数值**（年份），以 JSON 格式返回。  
                示例：  
                - “那2017年呢？” → {{"year": "2017"}}  
  
                只输出 JSON，不要其他内容。  
            """</span>  
            formatted = <span class="hljs-keyword">await</span> self.formatter.<span class="hljs-built_in">format</span>([  
                Msg(<span class="hljs-string">"system"</span>, <span class="hljs-string">"你是一个参数提取器。"</span>, <span class="hljs-string">"system"</span>),  
                Msg(<span class="hljs-string">"user"</span>, extract_prompt, <span class="hljs-string">"user"</span>),  
            ])  
  
            result = <span class="hljs-keyword">await</span> self.model(formatted)  
            json_str = <span class="hljs-keyword">await</span> get_response(result)  
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"🔍 提取参数: <span class="hljs-subst">{json_str}</span>"</span>)  
            params = json.loads(json_str)  
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-string">"year"</span>inparams:  
                <span class="hljs-built_in">print</span>(<span class="hljs-string">"⚠️ 年份参数提取失败，进入改写流程"</span>)  
                returnMsg(self.name, <span class="hljs-string">"NO_MATCH"</span>, role=<span class="hljs-string">"assistant"</span>)  
  
            <span class="hljs-comment"># 2. 填充 SQL 模板  </span>
            <span class="hljs-keyword">try</span>:  
                new_sql = state[<span class="hljs-string">"last_sql_template"</span>].<span class="hljs-built_in">format</span>(**params)  
                <span class="hljs-built_in">print</span>(<span class="hljs-string">f"🛠️ 生成新 SQL: <span class="hljs-subst">{new_sql}</span>"</span>)
</code></pre>
<p>按上面三段代码所示，通过全局变量state，就可以实现多轮次对话之间的结构化参数传递。</p>
<p><strong>▶️ 案例测试结果</strong></p>
<p>运行验证结果如下：</p>
<pre><code class="hljs language-sql" lang="sql">启动 AgentScope 多智能体系统（输入 exit 退出）
👤 用户: <span class="hljs-number">2016</span>年考生人数有多少？
<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> 🟦 Template Agent <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span>
⚠️ 不存在上下文，进入<span class="hljs-keyword">SQL</span> Agent流程
🌀 无上下文，进入<span class="hljs-keyword">SQL</span>流程
<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> 🟦 <span class="hljs-keyword">Sql</span> Agent <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span>
调用大模型llama2向量化：<span class="hljs-number">2016</span>年考生人数有多少？
好的，用户问的是<span class="hljs-number">2016</span>年的考生人数有多少。首先，我需要查看提供的表结构。表名是college_entrance_examination，主键是examination_year，类型是<span class="hljs-type">int</span>。考生人数是candidates_count，类型是<span class="hljs-type">decimal</span>(<span class="hljs-number">10</span>,<span class="hljs-number">2</span>)。

因为examination_year是主键，所以每个年份只有一条记录。因此，查询<span class="hljs-number">2016</span>年的考生人数不需要用聚合函数，直接<span class="hljs-keyword">SELECT</span> candidates_count即可。所以正确的<span class="hljs-keyword">SQL</span>应该是<span class="hljs-keyword">SELECT</span> candidates_count <span class="hljs-keyword">FROM</span> college_entrance_examination <span class="hljs-keyword">WHERE</span> examination_year <span class="hljs-operator">=</span><span class="hljs-number">2016</span>; 这里不需要聚合函数，因为数据是直接存储的，不是需要统计的。

💡 大模型生成的<span class="hljs-keyword">SQL</span>: [<span class="hljs-keyword">select</span> candidates_count <span class="hljs-keyword">from</span> college_entrance_examination <span class="hljs-keyword">where</span> examination_year <span class="hljs-operator">=</span><span class="hljs-number">2016</span> limit <span class="hljs-number">1</span>]
💡 数据查询成功: [{<span class="hljs-string">'candidates_count'</span>: <span class="hljs-number">940.0</span>}]
🧠 原始意图: <span class="hljs-number">2016</span>年考生人数有多少？
📦 保存 <span class="hljs-keyword">SQL</span> 模板: <span class="hljs-keyword">select</span> candidates_count <span class="hljs-keyword">from</span> college_entrance_examination <span class="hljs-keyword">where</span> examination_year <span class="hljs-operator">=</span> {<span class="hljs-keyword">year</span>} limit <span class="hljs-number">1</span>
<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> 🟩 Analysis Agent <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span>
好的，我现在需要处理用户的问题：“<span class="hljs-number">2016</span>年考生人数有多少？”首先，我要确认用户的需求是获取<span class="hljs-number">2016</span>年的考生人数。根据提供的表结构信息，表名是college_entrance_examination，包含高考年份、考生人数和复读人数三个字段。用户提供的<span class="hljs-keyword">SQL</span>查询已经明确筛选了<span class="hljs-number">2016</span>年的考生人数，结果是<span class="hljs-number">940.0</span>万人。

接下来，。。。。。（略）

🧠 最终回答: <span class="hljs-number">2016</span>年全国高考考生人数为<span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-number">940.0</span>万人<span class="hljs-operator">*</span><span class="hljs-operator">*</span>。该数据来源于考生人数与复读人数信息表（college_entrance_examination）中<span class="hljs-number">2016</span>年的记录。

<span class="hljs-comment">--------------------------------------------------</span>
👤 用户: <span class="hljs-number">2018</span>年呢
<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> 🟦 Template Agent <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span>
🔄 检测到历史上下文，尝试参数化追问
好的，现在我需要处理用户的问题：“<span class="hljs-number">2018</span>年呢”。首先，用户之前问了<span class="hljs-number">2016</span>年的考生人数，现在问<span class="hljs-number">2018</span>年的情况，这明显是在进行年份的追问。根据之前的示例，用户希望得到一个包含年份的JSON对象。问题中的年份是<span class="hljs-number">2018</span>，所以需要提取这个参数。检查表结构，确认表中确实有examination_year字段，类型是<span class="hljs-type">int</span>，所以<span class="hljs-number">2018</span>是有效的输入。用户没有提到其他参数，所以只需要返回年份。因此，正确的JSON应该是{"year": "2018"}。

🔍 提取参数: {"year": "2018"}
🛠️ 生成新 <span class="hljs-keyword">SQL</span>: <span class="hljs-keyword">select</span> candidates_count <span class="hljs-keyword">from</span> college_entrance_examination <span class="hljs-keyword">where</span> examination_year <span class="hljs-operator">=</span><span class="hljs-number">2018</span> limit <span class="hljs-number">1</span>
✅ 追问查询成功，返回 <span class="hljs-number">1</span> 行
🎯 模板匹配成功，直接进入分析流程
<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> 🟩 Analysis Agent <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span>
好的，用户之前问过<span class="hljs-number">2016</span>年的考生人数，现在又问<span class="hljs-number">2018</span>年的，我需要快速找到对应的答案。根据提供的表结构和数据信息，用户给出的<span class="hljs-keyword">SQL</span>查询是针对<span class="hljs-number">2018</span>年的，返回的结果是<span class="hljs-number">975.0</span>万人。所以。。。。。。就可以直接给出答案了。

🧠 最终回答: <span class="hljs-number">2018</span>年全国高考考生人数为<span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-number">975.0</span>万人<span class="hljs-operator">*</span><span class="hljs-operator">*</span>。该数据来源于考生人数与复读人数信息表（college_entrance_examination）中<span class="hljs-number">2018</span>年的记录。

<span class="hljs-comment">--------------------------------------------------</span>
👤 用户: 录取人数呢？
<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> 🟦 Template Agent <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span>
🔄 检测到历史上下文，尝试参数化追问
好的，我需要分析用户的问题是否在进行年份的追问。用户之前询问了<span class="hljs-number">2016</span>年和<span class="hljs-number">2018</span>年的考生人数，现在问的是“录取人数呢？”。首先，用户的问题从“考生人数”转向了“录取人数”，这可能涉及到另一个数据点，而不是同一字段的不同年份。根据提供的表结构，表中只有考生人数和复读人数，没有录取人数的字段。因此，用户可能在询问另一个未在表中提供的数据，而不是同一表中的不同年份。此外，问题中没有提到具体的年份，也没有使用“那...呢？”这样的结构，所以这应该不是对年份的追问。因此，应该返回空JSON。

🔍 提取参数: {}
⚠️ 年份参数提取失败，进入改写流程
🌀 模板匹配失败，进入改写流程
<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> 🟨 Rewrite Agent <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span>
好的，用户之前问了<span class="hljs-number">2016</span>年和<span class="hljs-number">2018</span>年的高考考生人数，现在问“录取人数呢？”。我需要结合上下文补全问题。根据之前的对话，用户可能是在比较考生人数和录取人数。所以应该明确年份和具体是哪个年份的录取人数。可能指的是最近提到的<span class="hljs-number">2018</span>年，所以改写为“<span class="hljs-number">2018</span>年全国高考录取人数是多少？”

✍️ 改写后问题：<span class="hljs-number">2018</span>年全国高考录取人数是多少？
<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> 🟦 <span class="hljs-keyword">Sql</span> Agent <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span>
调用大模型llama2向量化：<span class="hljs-number">2018</span>年全国高考录取人数是多少？
好的，用户现在问的是“录取人数呢？”，结合之前的对话历史来看，他们之前已经询问过<span class="hljs-number">2016</span>年和<span class="hljs-number">2018</span>年的考生人数，现在想知道<span class="hljs-number">2018</span>年的录取人数。根据用户提供的表结构，录取人数存储在college_entrance_admission表中，具体字段是admission_count，并且以万为单位。

首先，我需要确认用户的问题是否需要使用聚合函数。因为录取人数在表中是按年份记录的，每个年份对应一个具体的admission_count值，所以不需要SUM或AVG，而是直接查询该年份的记录即可。

接下来，检查表结构，admission_year是主键，所以<span class="hljs-number">2018</span>年只会有一条记录。因此，查询应该是<span class="hljs-keyword">SELECT</span> admission_count <span class="hljs-keyword">FROM</span> college_entrance_admission <span class="hljs-keyword">WHERE</span> admission_year <span class="hljs-operator">=</span><span class="hljs-number">2018</span>。

然后，确保字段类型是<span class="hljs-type">decimal</span>(<span class="hljs-number">10</span>,<span class="hljs-number">2</span>)，所以结果会是精确到小数点后两位的数值。

💡 大模型生成的<span class="hljs-keyword">SQL</span>: [<span class="hljs-keyword">select</span> admission_count <span class="hljs-keyword">from</span> college_entrance_admission <span class="hljs-keyword">where</span> admission_year <span class="hljs-operator">=</span><span class="hljs-number">2018</span>]
💡 数据查询成功: [{<span class="hljs-string">'admission_count'</span>: <span class="hljs-number">790.99</span>}]
🧠 原始意图: <span class="hljs-number">2018</span>年全国高考录取人数是多少？
📦 保存 <span class="hljs-keyword">SQL</span> 模板: <span class="hljs-keyword">select</span> admission_count <span class="hljs-keyword">from</span> college_entrance_admission <span class="hljs-keyword">where</span> admission_year <span class="hljs-operator">=</span> {<span class="hljs-keyword">year</span>}
<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> 🟩 Analysis Agent <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span>
好的，用户现在问的是“录取人数呢？”，看起来他们之前已经询问过<span class="hljs-number">2016</span>年和<span class="hljs-number">2018</span>年的考生人数，现在想知道同一时期或相关年份的录取人数。我需要先回顾之前的对话历史，确保回答的一致性。

首先。。。。。。（略）

用户。。。。。。（略）

根据。。。。。。（略）

此外。。。。。。（略）

总结。。。。。。（略）

🧠 最终回答: <span class="hljs-number">2018</span>年全国高考录取人数为<span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-number">790.99</span>万人<span class="hljs-operator">*</span><span class="hljs-operator">*</span>。该数据来源于录取人数与普通高校数信息表（college_entrance_admission）中<span class="hljs-number">2018</span>年的记录。若需了解其他年份的录取人数，可提供具体年份以便进一步查询。

<span class="hljs-comment">--------------------------------------------------</span>
👤 用户: 
</code></pre>
<p>第一轮问题：2016年考生人数有多少？</p>
<p>第一轮没有上下文，也没有全局变量模板，所以直接走SQL Agent + Analysis AgentRAG检索、生成SQL、查数、分析。同时SQL Agent生成成功后记录SQL模板到全局state。</p>
<p>第二轮问题：2018年呢？</p>
<p>第二轮我们追问2018年，这时存在全局变量模板，所以走模板匹配提取年份参数，直接查数然后通过业务判断存在数据，走Analysis Agent分析。</p>
<p>第三轮问题：录取人数呢？</p>
<p>第三轮我们追问录取人数，但是匹配不到模板，所以上层业务判断走Rewrite Agent + SQL Agent + Analysis Agent改写问题完善条件。改写时，参考Memory中上下文2016和2018年回答，改写为2018年全国高考录取人数是多少？然后走RAG检索、生成SQL、查数、分析。</p>
<h3 data-id="heading-2"><strong>🧩 AgentScope实现小结</strong></h3>
<p>AgentScope 提供了一个面向多智能体协作的开发框架，核心是「消息驱动 + 管道式执行」模型：</p>
<ul>
<li>通过 sequential_pipeline() 串联多个 Agent，每个智能体只需实现 reply() 方法。</li>
<li>使用 Msg 对象封装上下文，支持多模态内容（文本、结构化数据等）。</li>
<li>每个智能体内部InMemoryMemory 提供上下文记忆，可实现多轮对话追问。</li>
<li>多个智能体之间通过自定义全局变量State，实现跨轮次跨智能体的结构化参数传递。</li>
<li>利用OllamaChatFormatter 自动拼装 System Prompt + 历史记忆，实现语义连续性。</li>
</ul>
<p>特点：</p>
<ul>
<li>上手快、API 简洁，适合快速搭建多智能体应用。</li>
<li>内置异步流式输出，可直接打印模型“思考过程”。</li>
<li>强调「职责分离」：每个 Agent 只负责一类任务。</li>
</ul>
<p>适用场景 适合对「智能体职责清晰」「调用链固定」的任务。</p>
<h3 data-id="heading-3"><strong>附录：AgentScope中主要管道类型</strong></h3>
<p>AgentScope中主要有以下三类管道：</p>
<h4 data-id="heading-4">1）顺序 Pipeline (sequential_pipeline / SequentialPipeline)</h4>
<p>函数式调用：使用 sequential_pipeline(agents=[...], msg=...)。</p>
<ul>
<li>agents 参数：一个 agent 列表，按顺序执行。</li>
<li>msg 参数：初始消息（可以是 None 或一个 Msg 实例）作为第一个 agent 的输入。</li>
<li>返回值：最后一个 agent 的输出消息。</li>
</ul>
<p>类式调用：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">pipeline</span> = SequentialPipeline(agents=[...])
<span class="hljs-attr">msg</span> = await pipeline(msg=initial_msg)
</code></pre>
<ul>
<li>可以多次调用 pipeline(...) 重用该流水线。</li>
<li>适用场景：你希望依次将一个 agent 的输出传给下一个 agent——典型的流水线模式。</li>
</ul>
<h4 data-id="heading-5">2）分发／并行 Pipeline (fanout_pipeline / FanoutPipeline)</h4>
<p>函数式调用： fanout_pipeline(agents=[...], msg=..., enable_gather=False|True)。</p>
<ul>
<li>将同一个输入 msg 分发给 agents 列表中的每一个。</li>
<li>返回值：一个列表（每个 agent 的输出消息）。</li>
<li>enable_gather=True（默认）会并发执行所有 agent（利用 asyncio.gather()），适合 I/O 密集型场景。</li>
<li>enable_gather=False 会顺序执行，但是仍是分发模式（每个 agent 接收同一个输入）。</li>
</ul>
<p>类式调用：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">pipeline</span> = FanoutPipeline(agents=[...])
<span class="hljs-attr">msgs</span> = await pipeline(msg=initial_msg)
</code></pre>
<ul>
<li>同样可以重用。</li>
<li>适用场景：你希望多个 agent 基于同一个输入做“并行评估／多视角分析”，而不是一个接一个。</li>
</ul>
<h4 data-id="heading-6">3）MsgHub 使用模式</h4>
<ul>
<li>MsgHub 是一个异步（async）上下文管理器，传入一个 participants 列表（agent 实例列表）和一个 announcement 消息。</li>
<li>在上下文（async with MsgHub(...) as hub:）内部，参与者 agent 可以互相“观察”(observe) 消息，无需手动将一个 agent 的输出专门传给另一个。系统会自动广播。</li>
<li>MsgHub 支持动态管理参与者：通过 hub.add(...), hub.delete(...) 方法。</li>
</ul>
<p>示例（简化版）：</p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-function"><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> <span class="hljs-title">MsgHub</span>(<span class="hljs-params">participants=[alice, bob, charlie],
                  announcement=Msg(<span class="hljs-string">"user"</span>, <span class="hljs-string">"Introduce yourselves."</span>, <span class="hljs-string">"user"</span></span>)) <span class="hljs-keyword">as</span> hub:
    <span class="hljs-keyword">await</span> <span class="hljs-title">alice</span>()
    <span class="hljs-keyword">await</span> <span class="hljs-title">bob</span>()
    <span class="hljs-keyword">await</span> <span class="hljs-title">charlie</span>()
</span></code></pre>
<p>在这个例子中，alice,bob,charlie 会接收到 announcement，互相广播消息，无需手动传递。</p>
<p>源码参考：参与协作的四个智能体，以及具体协作控制逻辑代码，详见<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FMuKunZiAI%2Fcollege_entrance_ai%2Fblob%2Fmain%2Fagentscope_code%2Fagent_service_pipeline.py%25E3%2580%2582" target="_blank" title="https://github.com/MuKunZiAI/college_entrance_ai/blob/main/agentscope_code/agent_service_pipeline.py%E3%80%82" ref="nofollow noopener noreferrer">github.com/MuKunZiAI/c…</a></p>
<p>本文总结：本文通过高考信息智能查询的业务场景，基于AgentScope开发框架实践多智能体协作机制，通过管道+控制逻辑进行协作，通过上下文记忆+全局变量实现多轮对话和跨智能体之间参数传递，最后分享了AgentScope的几种管道类型。下一篇基于LangGraph框架的多智能体协作机制实践，敬请期待。</p>
<p>本文作者：Chaiys</p>
<p>本文原载：<a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FO9wC9aU3iQ98Wij6C-AvWw" target="_blank" title="https://mp.weixin.qq.com/s/O9wC9aU3iQ98Wij6C-AvWw" ref="nofollow noopener noreferrer">公众号“木昆子记录AI”</a></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[监控不是日志：Prometheus 高基数避坑指南]]></title>    <link>https://juejin.cn/post/7591715454135238719</link>    <guid>https://juejin.cn/post/7591715454135238719</guid>    <pubDate>2026-01-06T02:21:47.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7591715454135238719" data-draft-id="7591730714140950570" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="监控不是日志：Prometheus 高基数避坑指南"/> <meta itemprop="keywords" content="后端,算法,监控"/> <meta itemprop="datePublished" content="2026-01-06T02:21:47.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="踏浪无痕"/> <meta itemprop="url" content="https://juejin.cn/user/2834988091055719"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            监控不是日志：Prometheus 高基数避坑指南
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2834988091055719/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    踏浪无痕
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-06T02:21:47.000Z" title="Tue Jan 06 2026 02:21:47 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-06
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>从 TSDB 原理到实战案例，帮助你理解为什么不能使用高基数标签，以及如何正确设计监控指标。一次性解决 Prometheus 查询慢、内存爆炸的根本问题。</p>
</blockquote>
<hr/>
<h2 data-id="heading-0">一、先问一个问题：为什么查询会变慢？</h2>
<p>想象一个场景：</p>
<pre><code class="hljs language-ini" lang="ini">你的电商系统监控突然变慢了：
- 以前查询 sum(order_total) 只要 10ms
- 现在需要 30 秒，经常超时
- Prometheus 内存从 2GB 涨到 16GB
- 告警延迟，运维半夜被叫醒

罪魁祸首：
order_total{<span class="hljs-attr">user_id</span>=<span class="hljs-string">"10086"</span>}  <span class="hljs-comment"># 给每个用户都创建了独立时序</span>
order_total{<span class="hljs-attr">user_id</span>=<span class="hljs-string">"10087"</span>}
...
<span class="hljs-comment"># 100万用户 = 100万条时序！</span>
</code></pre>
<p><strong>核心问题：为什么加个 user_id 标签就炸了？</strong></p>
<p>要理解这个问题，我们先用大白话讲清楚 Prometheus 是怎么存储数据的。</p>
<hr/>
<h2 data-id="heading-1">二、大白话类比：超市运作模型</h2>
<h3 data-id="heading-2">2.1 Prometheus = 一家超市</h3>
<p>把 Prometheus TSDB 想象成一家超市，就很好理解了：</p>
<pre><code class="hljs language-mermaid" lang="mermaid">graph LR
    subgraph Frontend["前台 (内存)"]
        CAT["商品目录册
        可乐在B2货架"]
        SHELF["货架陈列区
        热销商品摆前面"]
    end
    
    subgraph Backend["后台 (磁盘)"]
        WAREHOUSE["大仓库
        整箱压缩存放"]
        LOG["出入库记录
        防止断电丢失"]
    end
    
    Frontend -.定期入库.-&gt; Backend
    
    style Frontend fill:#e8f5e9,stroke:#4caf50,stroke-width:3px
    style Backend fill:#fff3e0,stroke:#ff9800,stroke-width:3px
    style CAT fill:#c8e6c9,stroke:#4caf50
    style SHELF fill:#c8e6c9,stroke:#4caf50
    style WAREHOUSE fill:#ffe0b2,stroke:#ff9800
    style LOG fill:#ffe0b2,stroke:#ff9800
</code></pre>
<p><strong>为什么这样设计？</strong></p>
<pre><code class="hljs language-arduino" lang="arduino">场景：顾客要买可乐

方案A（全放仓库）：
顾客：<span class="hljs-string">"要可乐"</span>
店员：<span class="hljs-string">"稍等，我去仓库找..."</span> → <span class="hljs-number">10</span>分钟
结果：顾客不买了 ✗

方案B（前台+后台）：
顾客：<span class="hljs-string">"要可乐"</span>
店员：<span class="hljs-string">"货架上有"</span> → <span class="hljs-number">10</span>秒
结果：立刻成交 ✓
</code></pre>
<p><strong>对应到监控：</strong></p>
<ul>
<li>告警需要实时查询（&lt;100ms）→ 必须用内存</li>
<li>历史分析可以慢点（几秒）→ 磁盘足够</li>
</ul>
<pre><code class="hljs language-mermaid" lang="mermaid">%%{init: {'theme':'base', 'themeVariables': { 'fontSize':'16px'}}}%%
graph TB
    subgraph Prometheus["Prometheus Server"]
        subgraph Memory["内存层 Head Block (最近2小时热数据)"]
            SI["Series 索引表
            标签→ID映射"]
            PL["Posting Lists
            倒排索引"]
            AC["Active Chunks
            压缩数据块"]
        end
        
        Compress["定期压缩 (每2小时)"]
        
        subgraph Disk["磁盘层 Persistent Blocks (长期存储)"]
            IDX["index 文件
            倒排索引持久化"]
            CHK["chunks 文件
            XOR 压缩数据"]
            META["meta.json
            块元数据"]
        end
        
        Memory --&gt;|压缩| Compress
        Compress --&gt;|持久化| Disk
    end
    
    style Memory fill:#e1f5ff,stroke:#0288d1,stroke-width:3px
    style Disk fill:#fff3e0,stroke:#f57c00,stroke-width:3px
    style Compress fill:#f0f0f0,stroke:#666,stroke-width:2px
    style SI fill:#bbdefb,stroke:#0288d1
    style PL fill:#bbdefb,stroke:#0288d1
    style AC fill:#bbdefb,stroke:#0288d1
    style IDX fill:#ffe0b2,stroke:#f57c00
    style CHK fill:#ffe0b2,stroke:#f57c00
    style META fill:#ffe0b2,stroke:#f57c00
</code></pre>
<hr/>
<h2 data-id="heading-3">三、揭秘真实架构：TSDB 的技术实现</h2>
<p>好，理解了超市模型后，我们来看看 Prometheus 真实的技术架构。有了前面的铺垫，这张图你就能看懂了：</p>
<h3 data-id="heading-4">3.1 宏观架构图</h3>
<p>Prometheus 采用<strong>内存+磁盘</strong>的分层存储，核心设计思想是：<strong>热数据快速访问，冷数据压缩存储</strong>。</p>
<pre><code class="hljs language-mermaid" lang="mermaid">%%{init: {'theme':'base', 'themeVariables': { 'fontSize':'16px'}}}%%
graph TB
    subgraph Prometheus["Prometheus Server"]
        subgraph Memory["内存层 Head Block (最近2小时热数据)"]
            SI["Series 索引表
            标签→ID映射"]
            PL["Posting Lists
            倒排索引"]
            AC["Active Chunks
            压缩数据块"]
        end
        
        Compress["定期压缩 (每2小时)"]
        
        subgraph Disk["磁盘层 Persistent Blocks (长期存储)"]
            IDX["index 文件
            倒排索引持久化"]
            CHK["chunks 文件
            XOR 压缩数据"]
            META["meta.json
            块元数据"]
        end
        
        Memory --&gt;|压缩| Compress
        Compress --&gt;|持久化| Disk
    end
    
    style Memory fill:#e1f5ff,stroke:#0288d1,stroke-width:3px
    style Disk fill:#fff3e0,stroke:#f57c00,stroke-width:3px
    style Compress fill:#f0f0f0,stroke:#666,stroke-width:2px
    style SI fill:#bbdefb,stroke:#0288d1
    style PL fill:#bbdefb,stroke:#0288d1
    style AC fill:#bbdefb,stroke:#0288d1
    style IDX fill:#ffe0b2,stroke:#f57c00
    style CHK fill:#ffe0b2,stroke:#f57c00
    style META fill:#ffe0b2,stroke:#f57c00
</code></pre>
<p><strong>对应到超市：</strong></p>
<ul>
<li><strong>Series 索引表</strong> = 商品目录册（"可乐在B2货架"）</li>
<li><strong>Posting Lists</strong> = 分类标签墙（"饮料类：可乐、雪碧..."）</li>
<li><strong>Active Chunks</strong> = 前台货架（最近进货的商品）</li>
<li><strong>index/chunks 文件</strong> = 后台大仓库（整箱压缩存放）</li>
</ul>
<h3 data-id="heading-5">3.2 关键数据：什么放内存，什么放磁盘？</h3>









































<table><thead><tr><th>数据类型</th><th>存储位置</th><th>大小估算</th><th>高基数影响</th></tr></thead><tbody><tr><td>Series 索引</td><td>内存</td><td>每时序 2-4 KB</td><td>直接膨胀</td></tr><tr><td>倒排索引</td><td>内存</td><td>随标签值增长</td><td>急剧增长</td></tr><tr><td>最新数据（2小时内）</td><td>内存</td><td>每时序 ~1 KB</td><td>线性增长</td></tr><tr><td>历史数据</td><td>磁盘</td><td>压缩后 1:10</td><td>碎片化</td></tr><tr><td>WAL日志</td><td>磁盘</td><td>未压缩</td><td>写入放大</td></tr></tbody></table>
<p><strong>核心公式：</strong></p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-string">内存占用</span> <span class="hljs-string">≈</span> <span class="hljs-string">时序总数</span> <span class="hljs-string">×</span> <span class="hljs-number">3</span> <span class="hljs-string">KB</span>
<span class="hljs-string">推荐上限：单实例</span> <span class="hljs-string">&lt;</span> <span class="hljs-number">1000</span> <span class="hljs-string">万时序</span>
</code></pre>
<p><strong>现在再看开头的问题：</strong></p>
<pre><code class="hljs language-ini" lang="ini">order_total{<span class="hljs-attr">user_id</span>=<span class="hljs-string">"10086"</span>}  <span class="hljs-comment"># 100万用户 = 100万个 Series</span>
↓
Series 索引表：100万 × <span class="hljs-attr">3KB</span> = <span class="hljs-number">3</span>GB（仅索引就爆了！）
查询时要遍历 100万个货架位 → 30秒超时
</code></pre>
<h3 data-id="heading-6">3.4 内存结构详解</h3>
<p><strong>Series 索引表 = 商品总目录</strong></p>
<pre><code class="hljs language-mermaid" lang="mermaid">graph TB
    subgraph Normal["正常商品目录"]
        N1["可乐(瓶装) → B2货架
        对应: (method='GET') → ID:1"]
        N2["可乐(罐装) → B3货架
        对应: (method='POST') → ID:2"]
    end
    
    subgraph HighCard["❌ 高基数问题"]
        H1["张三的可乐 → A1货架
        对应: (user_id='10086') → ID:1"]
        H2["李四的可乐 → A2货架
        对应: (user_id='10087') → ID:2"]
        H3["王五的可乐 → A3货架
        对应: (user_id='10088') → ID:3"]
        H4["... 100万个顾客"]
    end
    
    style Normal fill:#c8e6c9,stroke:#4caf50,stroke-width:3px
    style HighCard fill:#ffcdd2,stroke:#f44336,stroke-width:3px
    style N1 fill:#a5d6a7,stroke:#2e7d32
    style N2 fill:#a5d6a7,stroke:#2e7d32
    style H1 fill:#ef9a9a,stroke:#c62828
    style H2 fill:#ef9a9a,stroke:#c62828
    style H3 fill:#ef9a9a,stroke:#c62828
    style H4 fill:#ef9a9a,stroke:#c62828
</code></pre>
<p><strong>Posting Lists = 分类标签墙</strong></p>
<pre><code class="hljs language-mermaid" lang="mermaid">graph LR
    subgraph Drink["饮料类"]
        D1[可乐]
        D2[雪碧]
        D3[牛奶]
    end
    
    subgraph Snack["零食类"]
        S1[薯片]
        S2[饼干]
        S3[巧克力]
    end
    
    subgraph HighCard["❌ 高基数: 用户标签"]
        U1["user_id=10086
        SeriesID:100001"]
        U2["user_id=10087
        SeriesID:100002"]
        U3["user_id=10088
        SeriesID:100003"]
        U4["... 100万个标签"]
    end
    
    style Drink fill:#e1f5ff,stroke:#0288d1,stroke-width:2px
    style Snack fill:#f3e5f5,stroke:#9c27b0,stroke-width:2px
    style HighCard fill:#ffcdd2,stroke:#f44336,stroke-width:3px
    style D1 fill:#bbdefb,stroke:#0288d1
    style D2 fill:#bbdefb,stroke:#0288d1
    style D3 fill:#bbdefb,stroke:#0288d1
    style S1 fill:#e1bee7,stroke:#9c27b0
    style S2 fill:#e1bee7,stroke:#9c27b0
    style S3 fill:#e1bee7,stroke:#9c27b0
    style U1 fill:#ef9a9a,stroke:#c62828
    style U2 fill:#ef9a9a,stroke:#c62828
    style U3 fill:#ef9a9a,stroke:#c62828
    style U4 fill:#ef9a9a,stroke:#c62828
</code></pre>
<hr/>
<h2 data-id="heading-7">四、电商场景：好与坏的指标设计</h2>
<h3 data-id="heading-8">4.1 订单监控</h3>
<h4 data-id="heading-9">反面案例：每个用户、每个订单都是独立时序</h4>
<pre><code class="hljs language-prometheus" lang="prometheus"># 错误设计
order_created{
  user_id="10086",           # 100万个用户
  order_id="20240501001",    # 每天50万订单
  product_id="SKU12345"      # 10万个商品
}

问题分析：
├─ 时序数量：100万用户 × 1个指标 = 100万时序
├─ 内存占用：100万 × 3KB = 3GB（仅索引）
├─ 查询延迟：sum(order_created) → 30秒超时
└─ 存储浪费：大部分订单只有1个样本点
</code></pre>
<pre><code class="hljs language-mermaid" lang="mermaid">graph TB
    subgraph Bad["❌ 错误设计: 高基数"]
        B1["user_id='10086'
        100万个用户"]
        B2["order_id='ABC123'
        每天50万订单"]
        B3["product_id='SKU001'
        10万个商品"]
        
        Result1["时序数: 100万+
        内存: 3GB
        查询: 30秒超时"]
    end
    
    B1 &amp; B2 &amp; B3 --&gt; Result1
    
    style Bad fill:#ffcdd2,stroke:#f44336,stroke-width:3px
    style B1 fill:#ef9a9a,stroke:#c62828
    style B2 fill:#ef9a9a,stroke:#c62828
    style B3 fill:#ef9a9a,stroke:#c62828
    style Result1 fill:#ffebee,stroke:#c62828,stroke-width:2px
</code></pre>
<p><strong>为什么错？</strong></p>
<pre><code class="hljs language-mermaid" lang="mermaid">graph LR
    Problem[超市类比] --&gt; P1["每个顾客的
    每件商品都单独上架"]
    P1 --&gt; P2["张三的可乐
    李四的可乐
    王五的可乐..."]
    P2 --&gt; P3["商品目录1000页
    货架爆满"]
    
    style Problem fill:#fff3e0,stroke:#f57c00,stroke-width:2px
    style P1 fill:#ffccbc,stroke:#ff5722
    style P2 fill:#ffccbc,stroke:#ff5722
    style P3 fill:#ffcdd2,stroke:#f44336,stroke-width:3px
</code></pre>
<h4 data-id="heading-10">正面案例：聚合维度</h4>
<pre><code class="hljs language-prometheus" lang="prometheus"># 正确设计
order_created_total{
  source="app|web|miniprogram",      # 3个值
  payment_method="alipay|wechat",    # 5个值
  product_category="electronics"     # 20个一级类目
}

优势：
├─ 时序数量：3 × 5 × 20 = 300时序
├─ 内存占用：300 × 3KB = 900KB
├─ 查询延迟：sum(order_created_total) → 10ms
└─ 存储效率：样本点密集，压缩率高
</code></pre>
<pre><code class="hljs language-mermaid" lang="mermaid">graph TB
    subgraph Good["✓ 正确设计: 低基数"]
        G1["source
        3个值"]
        G2["payment_method
        5个值"]
        G3["product_category
        20个类目"]
        
        Result2["时序数: 300
        内存: 900KB
        查询: 10ms"]
    end
    
    G1 &amp; G2 &amp; G3 --&gt; Result2
    
    style Good fill:#c8e6c9,stroke:#4caf50,stroke-width:3px
    style G1 fill:#a5d6a7,stroke:#2e7d32
    style G2 fill:#a5d6a7,stroke:#2e7d32
    style G3 fill:#a5d6a7,stroke:#2e7d32
    style Result2 fill:#e8f5e9,stroke:#2e7d32,stroke-width:2px
</code></pre>
<p><strong>为什么对？</strong></p>
<pre><code class="hljs language-mermaid" lang="mermaid">graph LR
    Solution[超市类比] --&gt; S1[按商品类型分类]
    S1 --&gt; S2["瓶装可乐
    罐装可乐
    ..."]
    S2 --&gt; S3["商品目录1页
    清晰明了"]
    
    style Solution fill:#e8f5e9,stroke:#4caf50,stroke-width:2px
    style S1 fill:#c8e6c9,stroke:#66bb6a
    style S2 fill:#c8e6c9,stroke:#66bb6a
    style S3 fill:#a5d6a7,stroke:#2e7d32,stroke-width:3px
</code></pre>
<h3 data-id="heading-11">4.2 接口性能监控</h3>
<h4 data-id="heading-12">反面案例：动态URL路径</h4>
<pre><code class="hljs language-prometheus" lang="prometheus"># 错误设计
api_request_duration{
  path="/api/order/10086/detail",    # 每个订单号一个路径
  path="/api/order/10087/detail",
  path="/api/user/20001/profile",    # 每个用户ID一个路径
  ...
}

问题：
├─ URL数量：每天几十万个不同路径
├─ 时序爆炸：每个路径一条时序
└─ 无法聚合：sum() 毫无意义
</code></pre>
<pre><code class="hljs language-mermaid" lang="mermaid">graph TD
    URL1["api/order/10086/detail"] --&gt; TS1["时序1"]
    URL2["api/order/10087/detail"] --&gt; TS2["时序2"]
    URL3["api/order/10088/detail"] --&gt; TS3["时序3"]
    URL4["... 每天50万个URL"] --&gt; TS4["... 50万时序"]
    
    TS1 &amp; TS2 &amp; TS3 &amp; TS4 --&gt; Problem["❌ 无法聚合
    查询超时"]
    
    style URL1 fill:#ffccbc,stroke:#ff5722
    style URL2 fill:#ffccbc,stroke:#ff5722
    style URL3 fill:#ffccbc,stroke:#ff5722
    style URL4 fill:#ffccbc,stroke:#ff5722
    style TS1 fill:#ef9a9a,stroke:#c62828
    style TS2 fill:#ef9a9a,stroke:#c62828
    style TS3 fill:#ef9a9a,stroke:#c62828
    style TS4 fill:#ef9a9a,stroke:#c62828
    style Problem fill:#ffcdd2,stroke:#f44336,stroke-width:3px
</code></pre>
<h4 data-id="heading-13">正面案例：路径归一化</h4>
<pre><code class="hljs language-prometheus" lang="prometheus"># 正确设计
api_request_duration{
  path="/api/order/{id}/detail",     # 模板化
  method="GET",
  status="200|500"
}

实现方式：
在应用代码或网关层做路径归一化：
/api/order/10086/detail  → /api/order/{id}/detail
/api/user/20001/profile  → /api/user/{id}/profile
</code></pre>
<pre><code class="hljs language-mermaid" lang="mermaid">graph TD
    URL1["api/order/10086/detail"] --&gt; Normalize
    URL2["api/order/10087/detail"] --&gt; Normalize
    URL3["api/order/10088/detail"] --&gt; Normalize
    
    Normalize["路径归一化"] --&gt; Template["api/order/{id}/detail"]
    Template --&gt; TS["✓ 1个聚合时序
    查询快速"]
    
    style URL1 fill:#bbdefb,stroke:#0288d1
    style URL2 fill:#bbdefb,stroke:#0288d1
    style URL3 fill:#bbdefb,stroke:#0288d1
    style Normalize fill:#fff9c4,stroke:#fbc02d,stroke-width:2px
    style Template fill:#c8e6c9,stroke:#4caf50,stroke-width:2px
    style TS fill:#a5d6a7,stroke:#2e7d32,stroke-width:3px
</code></pre>
<h3 data-id="heading-14">4.3 库存监控</h3>
<h4 data-id="heading-15">反面案例：商品级别监控</h4>
<pre><code class="hljs language-prometheus" lang="prometheus"># 错误设计
inventory_level{
  product_id="SKU001",      # 10万个SKU
  warehouse_id="WH001",     # 100个仓库
  location="A-01-05"        # 1万个货位
}

时序数：10万 × 100 × 1万 = 1000亿（理论值）
实际：即使只有部分组合，也有百万级时序
</code></pre>
<h4 data-id="heading-16">正面案例：分层监控</h4>
<pre><code class="hljs language-prometheus" lang="prometheus"># 宏观监控（低基数）
inventory_health{
  category="electronics",       # 20个类目
  warehouse_region="south",     # 5个大区
  stock_status="low|normal|high" # 3个状态
}

# 详细监控（仅Top商品）
inventory_detail{
  product_id="SKU001",          # 仅监控Top 1000商品
  warehouse_id="WH001"
}
</code></pre>
<h3 data-id="heading-17">4.4 对比总结</h3>



































<table><thead><tr><th>维度</th><th>反面案例</th><th>正面案例</th><th>差距</th></tr></thead><tbody><tr><td>时序数量</td><td>100万+</td><td>300-1000</td><td>1000倍</td></tr><tr><td>内存占用</td><td>3GB+</td><td>&lt;5MB</td><td>600倍</td></tr><tr><td>查询延迟</td><td>30秒+</td><td>10-50ms</td><td>3000倍</td></tr><tr><td>告警响应</td><td>经常超时</td><td>实时</td><td>-</td></tr></tbody></table>
<hr/>
<h2 data-id="heading-18">五、告警场景的共性抽取</h2>
<h3 data-id="heading-19">5.1 告警的本质需求</h3>
<p>Prometheus 作为告警系统，核心需求是：</p>
<pre><code class="hljs">快速回答：系统出了什么问题？
而不是：谁在什么时候做了什么？
</code></pre>
<p><strong>实际案例：</strong></p>
<pre><code class="hljs language-java" lang="java">告警需求                        需要的维度              不需要的维度
─────────────────────────────────────────────────────────
订单支付失败率超<span class="hljs-number">5</span>%              payment_method          user_id, order_id
                               error_type              
                               
API延迟P99超<span class="hljs-number">1</span>秒                 service_name            request_id
                               <span class="hljs-title function_">endpoint</span> <span class="hljs-params">(归一化)</span>        user_id
                               
库存水位低于阈值                category                product_id
                               warehouse_region        具体货位
</code></pre>
<h3 data-id="heading-20">5.2 告警指标的设计规律</h3>
<h4 data-id="heading-21">规律1：聚合维度，而非明细维度</h4>
<pre><code class="hljs language-ini" lang="ini">思考：你需要知道"哪些订单失败了"，还是"为什么失败"？

错误：
alert: order_failed{<span class="hljs-attr">order_id</span>=<span class="hljs-string">"xxx"</span>} &gt; <span class="hljs-number">0</span>
→ 每个订单都告警，无法处理

正确：
alert: rate(order_failed_total{<span class="hljs-attr">reason</span>=<span class="hljs-string">"timeout"</span>}[<span class="hljs-number">5</span>m]) &gt; <span class="hljs-number">0.05</span>
→ 超时导致的失败率超5%，立刻修复
</code></pre>
<h4 data-id="heading-22">规律2：技术维度比业务明细重要</h4>
<p><strong>必选维度（技术运维）：</strong></p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">service</span>=<span class="hljs-string">"order-service"</span>     <span class="hljs-comment"># 哪个服务</span>
<span class="hljs-attr">instance</span>=<span class="hljs-string">"10.0.1.5:9090"</span>   <span class="hljs-comment"># 哪台机器</span>
<span class="hljs-attr">environment</span>=<span class="hljs-string">"production"</span>    <span class="hljs-comment"># 哪个环境</span>
</code></pre>
<p><strong>可选维度（业务聚合）：</strong></p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">payment_method</span>=<span class="hljs-string">"alipay"</span>    <span class="hljs-comment"># 支付方式</span>
<span class="hljs-attr">category</span>=<span class="hljs-string">"electronics"</span>     <span class="hljs-comment"># 商品类目</span>
<span class="hljs-attr">region</span>=<span class="hljs-string">"华南"</span>              <span class="hljs-comment"># 地域</span>
</code></pre>
<p><strong>禁用维度（业务明细）：</strong></p>
<pre><code class="hljs language-bash" lang="bash">user_id                    <span class="hljs-comment"># 用户ID → 放日志</span>
order_id                   <span class="hljs-comment"># 订单号 → 放日志</span>
product_id                 <span class="hljs-comment"># 商品ID → 放日志（除非Top商品）</span>
</code></pre>
<h4 data-id="heading-23">规律3：状态聚合，而非状态穷举</h4>
<pre><code class="hljs language-ini" lang="ini">反面：
<span class="hljs-attr">order_status</span>=<span class="hljs-string">"created|paid|shipped|delivered|cancelled|refunded|..."</span>
→ 10+ 种状态，组合爆炸

正面：
<span class="hljs-attr">order_status</span>=<span class="hljs-string">"success|failed"</span>
<span class="hljs-attr">order_stage</span>=<span class="hljs-string">"processing|completed"</span>
→ 2-3 种状态，清晰明了
</code></pre>
<h3 data-id="heading-24">5.3 典型告警规则模板</h3>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-comment"># 订单成功率告警</span>
<span class="hljs-bullet">-</span> <span class="hljs-attr">alert:</span> <span class="hljs-string">OrderSuccessRateLow</span>
  <span class="hljs-attr">expr:</span> <span class="hljs-string">|
    rate(order_success_total{env="prod"}[5m]) 
    / 
    rate(order_total{env="prod"}[5m]) &lt; 0.95
</span>  <span class="hljs-attr">labels:</span>
    <span class="hljs-attr">severity:</span> <span class="hljs-string">critical</span>
  <span class="hljs-attr">annotations:</span>
    <span class="hljs-attr">summary:</span> <span class="hljs-string">"订单成功率低于95%"</span>
    
<span class="hljs-comment"># API延迟告警</span>
<span class="hljs-bullet">-</span> <span class="hljs-attr">alert:</span> <span class="hljs-string">APILatencyHigh</span>
  <span class="hljs-attr">expr:</span> <span class="hljs-string">|
    histogram_quantile(0.99, 
      rate(api_duration_bucket{service="order"}[5m])
    ) &gt; 1
</span>  <span class="hljs-attr">labels:</span>
    <span class="hljs-attr">severity:</span> <span class="hljs-string">warning</span>
  <span class="hljs-attr">annotations:</span>
    <span class="hljs-attr">summary:</span> <span class="hljs-string">"API P99延迟超过1秒"</span>

<span class="hljs-comment"># 库存水位告警</span>
<span class="hljs-bullet">-</span> <span class="hljs-attr">alert:</span> <span class="hljs-string">InventoryLow</span>
  <span class="hljs-attr">expr:</span> <span class="hljs-string">|
    inventory_level{status="low"} &gt; 100
</span>  <span class="hljs-attr">labels:</span>
    <span class="hljs-attr">severity:</span> <span class="hljs-string">warning</span>
  <span class="hljs-attr">annotations:</span>
    <span class="hljs-attr">summary:</span> <span class="hljs-string">"<span class="hljs-template-variable">{{$labels.category}}</span> 类目库存不足"</span>
</code></pre>
<h3 data-id="heading-25">5.4 告警维度设计清单</h3>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7a6a22dc6f914c2daa2b7cfe23da43e5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6LiP5rWq5peg55eV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768270907&amp;x-signature=aOB1xfnKfOnAioSfmVtEpM43B2s%3D" alt="2.jpg" loading="lazy"/></p>
<p><strong>具体示例：</strong></p>
<pre><code class="hljs language-mermaid" lang="mermaid">graph LR
    subgraph Good["✓ 推荐使用"]
        G1["service_name
        知道哪个服务"]
        G2["error_type
        知道失败原因"]
        G3["payment_method
        5-10种"]
    end
    
    subgraph Bad["❌ 不要使用"]
        B1["user_id
        不关心是谁"]
        B2["request_id
        无限增长"]
        B3["order_id
        放日志即可"]
    end
    
    style Good fill:#c8e6c9,stroke:#4caf50,stroke-width:3px
    style Bad fill:#ffcdd2,stroke:#f44336,stroke-width:3px
    style G1 fill:#a5d6a7,stroke:#2e7d32
    style G2 fill:#a5d6a7,stroke:#2e7d32
    style G3 fill:#a5d6a7,stroke:#2e7d32
    style B1 fill:#ef9a9a,stroke:#c62828
    style B2 fill:#ef9a9a,stroke:#c62828
    style B3 fill:#ef9a9a,stroke:#c62828
</code></pre>
<hr/>
<h2 data-id="heading-26">六、操作指引与总结</h2>
<h3 data-id="heading-27">6.1 标签设计黄金法则</h3>
<pre><code class="hljs language-mermaid" lang="mermaid">graph TB
    subgraph Rule1["原则1: 基数控制"]
        R1A["单个标签 &lt; 100个值"]
        R1B["标签组合 &lt; 10,000时序"]
    end
    
    subgraph Rule2["原则2: 三不原则"]
        R2A["❌ 不用唯一标识
        user_id, order_id"]
        R2B["❌ 不用动态值
        完整URL, 堆栈"]
        R2C["❌ 不过度细化
        省市区 → 大区"]
    end
    
    subgraph Rule3["原则3: 分层存储"]
        R3A["聚合指标 → Prometheus
        用于告警"]
        R3B["明细数据 → ELK/ClickHouse
        用于分析"]
        R3C["链路追踪 → Jaeger
        用于调试"]
    end
    
    Rule1 --&gt; Rule2
    Rule2 --&gt; Rule3
    
    style Rule1 fill:#e1f5ff,stroke:#0288d1,stroke-width:3px
    style Rule2 fill:#fff3e0,stroke:#f57c00,stroke-width:3px
    style Rule3 fill:#f3e5f5,stroke:#9c27b0,stroke-width:3px
    style R1A fill:#bbdefb,stroke:#0288d1
    style R1B fill:#bbdefb,stroke:#0288d1
    style R2A fill:#ffe0b2,stroke:#f57c00
    style R2B fill:#ffe0b2,stroke:#f57c00
    style R2C fill:#ffe0b2,stroke:#f57c00
    style R3A fill:#e1bee7,stroke:#9c27b0
    style R3B fill:#e1bee7,stroke:#9c27b0
    style R3C fill:#e1bee7,stroke:#9c27b0
</code></pre>
<h3 data-id="heading-28">6.2 快速诊断清单</h3>
<p>发现查询变慢或内存飙升？按以下步骤检查：</p>
<pre><code class="hljs language-mermaid" lang="mermaid">flowchart TD
    Start([发现性能问题]) --&gt; Step1
    
    Step1["Step 1: 查看 TSDB Status
    访问 /tsdb-status"] --&gt; Check1{时序总数 &gt; 500万?}
    
    Check1 --&gt;|是| Step2A["找出高基数指标
    Top 10 series count"]
    Check1 --&gt;|否| Step2B[检查查询复杂度]
    
    Step2A --&gt; Step3["Step 2: 执行基数分析
    topk查询"]
    Step3 --&gt; Analyze{哪类标签值最多?}
    
    Analyze --&gt;|user_id等唯一ID| Fix1["移除标签
    改为日志记录"]
    Analyze --&gt;|URL动态路径| Fix2["路径归一化
    使用模板"]
    Analyze --&gt;|省市区等细化| Fix3["聚合为大区
    降低维度"]
    
    Fix1 &amp; Fix2 &amp; Fix3 --&gt; Step4["Step 3: 应用修复
    使用 relabel_configs"]
    Step4 --&gt; Verify["验证效果
    监控时序数变化"]
    
    style Start fill:#e1f5ff,stroke:#0288d1,stroke-width:2px
    style Step1 fill:#fff9c4,stroke:#fbc02d
    style Check1 fill:#fff3e0,stroke:#f57c00,stroke-width:2px
    style Analyze fill:#fff3e0,stroke:#f57c00,stroke-width:2px
    style Fix1 fill:#c8e6c9,stroke:#4caf50,stroke-width:2px
    style Fix2 fill:#c8e6c9,stroke:#4caf50,stroke-width:2px
    style Fix3 fill:#c8e6c9,stroke:#4caf50,stroke-width:2px
    style Step4 fill:#bbdefb,stroke:#0288d1
    style Verify fill:#a5d6a7,stroke:#2e7d32,stroke-width:3px
</code></pre>
<p><strong>Step 1: 查看 TSDB Status</strong></p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 访问 Prometheus UI</span>
http://localhost:9090/tsdb-status

重点关注：
• Head Cardinality Stats
• Top 10 label names with value count
• Top 10 series count by metric names

找出：哪个标签有10万+个值？哪个指标有10万+时序？
</code></pre>
<p><strong>Step 2: 执行基数分析查询</strong></p>
<pre><code class="hljs language-promql" lang="promql"># 查看时序总数
count({__name__=~".+"})

# 找出高基数指标（Top 10）
topk(10, count by (__name__)({__name__=~".+"}))

# 找出高基数标签
# 在 TSDB Status 页面查看 "label names with value count"
</code></pre>
<p><strong>Step 3: 对症下药</strong></p>
<pre><code class="hljs language-bash" lang="bash">问题类型                    解决方案
─────────────────────────────────────────
user_id 等唯一ID            移除标签，改为日志记录

URL 动态路径                路径归一化：
                           /api/order/123 → /api/order/{<span class="hljs-built_in">id</span>}

过度细化（省市区）          聚合为大区

历史遗留高基数指标          使用 relabel_configs 丢弃
</code></pre>
<h3 data-id="heading-29">6.3 Relabel 配置示例</h3>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-comment"># prometheus.yml</span>
<span class="hljs-attr">scrape_configs:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">job_name:</span> <span class="hljs-string">'order-service'</span>
    <span class="hljs-attr">relabel_configs:</span>
      <span class="hljs-comment"># 丢弃高基数标签</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">action:</span> <span class="hljs-string">labeldrop</span>
        <span class="hljs-attr">regex:</span> <span class="hljs-string">'user_id|order_id|request_id'</span>
      
      <span class="hljs-comment"># URL 路径归一化</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">source_labels:</span> [<span class="hljs-string">__path__</span>]
        <span class="hljs-attr">target_label:</span> <span class="hljs-string">path</span>
        <span class="hljs-attr">regex:</span> <span class="hljs-string">'/api/order/[0-9]+/(.*)'</span>
        <span class="hljs-attr">replacement:</span> <span class="hljs-string">'/api/order/{id}/$1'</span>
</code></pre>
<h3 data-id="heading-30">6.4 核心要点回顾</h3>
<p><strong>存储分层原则：</strong></p>
<ul>
<li>索引和最新数据存储在内存，保证查询速度</li>
<li>历史数据存储在磁盘，通过压缩节省空间</li>
<li>热数据（2小时内）用于实时告警，冷数据用于历史分析</li>
</ul>
<p><strong>标签设计原则：</strong></p>
<ul>
<li>标签应该是可聚合的维度，而非唯一标识</li>
<li>用户ID、订单号等明细信息应该放在日志系统</li>
<li>控制标签基数是保证查询性能的关键</li>
</ul>
<p><strong>监控与追踪的分工：</strong></p>
<ul>
<li>监控系统关注整体趋势和异常模式，用于告警</li>
<li>追踪系统关注个体行为和详细路径，用于排查</li>
<li>Prometheus 负责"发生了什么"，日志/追踪负责"谁做了什么"</li>
</ul>
<h3 data-id="heading-31">6.5 总结</h3>
<p><strong>Prometheus 的设计哲学：</strong></p>
<blockquote>
<p>监控系统应该回答"发生了什么"（What happened），
而不是"谁做了什么"（Who did what）。</p>
</blockquote>
<p><strong>两个维度的数据分离：</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/953e4d21fb32468fb546dfacca3ba947~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6LiP5rWq5peg55eV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768270907&amp;x-signature=A6VpvJiUFG8CADDqBBEGbpav20A%3D" alt="1.jpg" loading="lazy"/></p>
<p><strong>最后的建议：</strong></p>
<ol>
<li><strong>新指标上线前</strong>：先评估基数，计算 <code>时序数 = 各标签基数的乘积</code></li>
<li><strong>定期巡检</strong>：每周查看 TSDB Status，关注时序增长趋势</li>
<li><strong>告警优先</strong>：记住 Prometheus 主要用于告警，不是万能分析工具</li>
<li><strong>工具组合</strong>：Prometheus + ELK + Jaeger 才是完整的可观测性方案</li>
</ol>
<hr/>
<p><strong>参考资源：</strong></p>
<ul>
<li>Prometheus 官方文档：<a href="https://link.juejin.cn?target=https%3A%2F%2Fprometheus.io%2Fdocs%2F" target="_blank" title="https://prometheus.io/docs/" ref="nofollow noopener noreferrer">prometheus.io/docs/</a></li>
<li>TSDB 设计论文：<a href="https://link.juejin.cn?target=https%3A%2F%2Ffabxc.org%2Ftsdb%2F" target="_blank" title="https://fabxc.org/tsdb/" ref="nofollow noopener noreferrer">fabxc.org/tsdb/</a></li>
<li>基数分析工具：promtool tsdb analyze</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[多智能体协作案例实践（二）：基于LangGraph框架]]></title>    <link>https://juejin.cn/post/7591697558377431082</link>    <guid>https://juejin.cn/post/7591697558377431082</guid>    <pubDate>2026-01-06T01:14:04.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7591697558377431082" data-draft-id="7591672090790952979" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="多智能体协作案例实践（二）：基于LangGraph框架"/> <meta itemprop="keywords" content="后端,Python,人工智能"/> <meta itemprop="datePublished" content="2026-01-06T01:14:04.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="木昆子"/> <meta itemprop="url" content="https://juejin.cn/user/825103640698564"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            多智能体协作案例实践（二）：基于LangGraph框架
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/825103640698564/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    木昆子
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-06T01:14:04.000Z" title="Tue Jan 06 2026 01:14:04 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-06
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读13分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在上篇<a href="https://juejin.cn/post/7591730714140540970" target="_blank" title="https://juejin.cn/post/7591730714140540970">《多智能体协作案例实践（一）：基于AgentScope框架》</a>文章中，Chaiys同学围绕高考信息查询智能助手业务场景，采用AgentScope框架进行多智能体协作的验证。</p>
<p>本文基于同样的业务场景和案例，采用LangGraph框架进行对比实践和验证，以便更深入地理解。</p>
<h2 data-id="heading-0">🧠 多智能体协作实现逻辑</h2>
<p>首先回顾一下业务场景，和上篇文章保持一致，还是支撑用户进行高考信息查询，并且要支持多轮对话，后续会基于以下案例来进行验证：</p>
<p>第一轮提问：2016年考生人数有多少？<br/>
第二轮追问年份：2018年呢？<br/>
第三轮追问其他：录取人数呢？</p>
<p>针对该业务场景，四个智能体之间的协作逻辑和AgentScope案例也完全保持一致：</p>
<p>1）用户输入问题</p>
<p>2）TemplateAgent判断是否有上下文历史，如果没有则转4，有则进一步匹配历史问题模板，如未匹配到则转3，如匹配到则基于模板SQL，从用户当前问题中提取查询参数植入模板SQL，执行后带查询结果转5</p>
<p>3）有上下文历史，但没有匹配的历史问题，则进入意图识别改写RewriteAgent，利用上下文对话背景对用户当前问题做改写，然后进入SQLAgent，RAG检索元数据、生成SQL、查询数据，最后进入AnalysisAgent分析回答</p>
<p>4）无上下文历史，代表用户是首次提问，则直接进入SQLAgent，RAG检索元数据、生成SQL、查询数据，最后进入AnalysisAgent分析回答</p>
<p>5）根据查询结果直接进入AnalysisAgent分析回答</p>
<p>这个协作逻辑基于 LangGraph框架的自定义状态图StataGraph实现：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># ========================</span>
<span class="hljs-comment"># 🧭 路由函数</span>
<span class="hljs-comment"># ========================</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">route_to_next_agent</span>(<span class="hljs-params">state: State</span>) -&gt; <span class="hljs-type">Literal</span>[<span class="hljs-string">"sql"</span>, <span class="hljs-string">"analysis"</span>, <span class="hljs-string">"rewrite"</span>, <span class="hljs-string">"__end__"</span>]:
    <span class="hljs-keyword">if</span> state.get(<span class="hljs-string">"next_agent"</span>) == <span class="hljs-string">"sql"</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">"sql"</span>
    <span class="hljs-keyword">if</span> state.get(<span class="hljs-string">"next_agent"</span>) == <span class="hljs-string">"analysis"</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">"analysis"</span>
    <span class="hljs-keyword">if</span> state.get(<span class="hljs-string">"next_agent"</span>) == <span class="hljs-string">"rewrite"</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">"rewrite"</span>
    <span class="hljs-keyword">return</span> <span class="hljs-string">"__end__"</span>
    
workflow = StateGraph(State)

workflow.add_node(<span class="hljs-string">"template"</span>, template_agent)
workflow.add_node(<span class="hljs-string">"rewrite"</span>, rewrite_agent)   <span class="hljs-comment"># 新增改写智能体</span>
workflow.add_node(<span class="hljs-string">"sql"</span>, sql_agent)
workflow.add_node(<span class="hljs-string">"analysis"</span>, analysis_agent)

workflow.add_edge(START, <span class="hljs-string">"template"</span>)

<span class="hljs-comment"># Template 之后根据条件流向</span>
workflow.add_conditional_edges(
    <span class="hljs-string">"template"</span>,
    route_to_next_agent,
    {
        <span class="hljs-string">"rewrite"</span>: <span class="hljs-string">"rewrite"</span>,     <span class="hljs-comment"># 新增 rewrite 分支</span>
        <span class="hljs-string">"sql"</span>: <span class="hljs-string">"sql"</span>,
        <span class="hljs-string">"analysis"</span>: <span class="hljs-string">"analysis"</span>,
        <span class="hljs-string">"__end__"</span>: END
    }
)

<span class="hljs-comment"># 改写智能体完成后交给 SQL</span>
workflow.add_edge(<span class="hljs-string">"rewrite"</span>, <span class="hljs-string">"sql"</span>)

<span class="hljs-comment"># SQL 执行后流向分析</span>
workflow.add_edge(<span class="hljs-string">"sql"</span>, <span class="hljs-string">"analysis"</span>)
workflow.add_edge(<span class="hljs-string">"analysis"</span>, END)

<span class="hljs-comment"># ========================</span>
<span class="hljs-comment"># ▶️ 主流程</span>
<span class="hljs-comment"># ========================</span>
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    <span class="hljs-keyword">from</span> uuid <span class="hljs-keyword">import</span> uuid4

    <span class="hljs-built_in">print</span>(<span class="hljs-string">"🚀 智能数据助手（支持追问、多轮上下文）"</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"="</span> *<span class="hljs-number">80</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"💡 输入问题开始对话，输入 'exit' 退出。"</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"="</span> *<span class="hljs-number">80</span>)

    <span class="hljs-comment"># 每次启动生成唯一 thread_id（上下文记忆关键）</span>
    thread_id = <span class="hljs-built_in">str</span>(uuid4())
    config = {<span class="hljs-string">"configurable"</span>: {<span class="hljs-string">"thread_id"</span>: thread_id}}

    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
        user_input = <span class="hljs-built_in">input</span>(<span class="hljs-string">"\n👤 你: "</span>).strip()
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> user_input:
            <span class="hljs-keyword">continue</span>
        <span class="hljs-keyword">if</span> user_input.lower() <span class="hljs-keyword">in</span> {<span class="hljs-string">"exit"</span>, <span class="hljs-string">"quit"</span>}:
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"👋 再见！会话已结束。"</span>)
            <span class="hljs-keyword">break</span>

        <span class="hljs-comment"># 构造输入</span>
        input_data = {
            <span class="hljs-string">"messages"</span>: [HumanMessage(content=user_input)],
        }

        <span class="hljs-keyword">try</span>:
            <span class="hljs-comment"># 流式执行</span>
            <span class="hljs-keyword">for</span> chunk <span class="hljs-keyword">in</span> app.stream(input_data, config=config):
                <span class="hljs-keyword">if</span> <span class="hljs-string">"analysis"</span> <span class="hljs-keyword">in</span> chunk:
                    msg = chunk[<span class="hljs-string">"analysis"</span>][<span class="hljs-string">"messages"</span>][<span class="hljs-number">0</span>]
                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"💬 助手: <span class="hljs-subst">{msg.content.strip()}</span>"</span>)
                    <span class="hljs-built_in">print</span>(<span class="hljs-string">"-"</span> *<span class="hljs-number">60</span>)
                <span class="hljs-keyword">elif</span> <span class="hljs-string">"sql"</span> <span class="hljs-keyword">in</span> chunk <span class="hljs-keyword">and</span> <span class="hljs-string">"messages"</span> <span class="hljs-keyword">in</span> chunk[<span class="hljs-string">"sql"</span>]:
                    <span class="hljs-comment"># SQL 生成失败的情况</span>
                    <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> chunk[<span class="hljs-string">"sql"</span>][<span class="hljs-string">"messages"</span>]:
                        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(m, AIMessage):
                            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"💬 助手: <span class="hljs-subst">{m.content.strip()}</span>"</span>)
                            <span class="hljs-built_in">print</span>(<span class="hljs-string">"-"</span> *<span class="hljs-number">60</span>)
                <span class="hljs-keyword">elif</span> <span class="hljs-string">"__end__"</span> <span class="hljs-keyword">in</span> chunk:
                    <span class="hljs-built_in">print</span>(<span class="hljs-string">"✅ 对话结束"</span>)

        <span class="hljs-keyword">except</span> json.JSONDecodeError:
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"⚠️ JSON 解析失败，可能是 LLM 返回了非结构化内容。"</span>)
        <span class="hljs-keyword">except</span> KeyboardInterrupt:
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"\n⏹️ 中断。输入 exit 可退出。"</span>)
        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"💥 出错：<span class="hljs-subst">{e}</span>"</span>)
</code></pre>
<p>如以上代码所示，通过“workflow.add_node”方式添加四个Node节点：template、rewrite、sql、analysis分别代表四个智能体。<br/>
通过“workflow.add_edge”方式添加对应节点之间的跳转关系，其中“workflow.add_conditional_edges”是添加条件边，通过调用route_to_next_agent()路由函数根据智能体返回的next_agent字段决定流转到哪一个节点。</p>
<h3 data-id="heading-1"><strong>🔁 多轮对话之上下文记忆和状态机</strong></h3>
<p>LangGraph上下文记忆的相关机制，主要通过官方提供的 MemorySaver() 实现：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-comment"># 启用记忆（支持多轮对话）</span>
<span class="hljs-attr">memory</span> = MemorySaver()
<span class="hljs-attr">app</span> = workflow.compile(checkpointer=memory)
</code></pre>
<p>MemorySaver会将每一个节点执行后的 State 存储到检查点（checkpoint）中，使得下一次调用可以从之前的对话状态继续执行。</p>
<p>其特点是原样存 储state状态机，不裁剪、不删减、不合并历史，真正关键的是你在 State 状态机中设计的业务逻辑。</p>
<p>使用“ StateGraph(State)”方式在状态图StateGraph初始化时就将自定义State状态机对象注入并绑定：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># ========================</span>
<span class="hljs-comment"># 🧠 增强状态定义</span>
<span class="hljs-comment"># ========================</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">State</span>(<span class="hljs-title class_ inherited__">TypedDict</span>):
    messages: Annotated[<span class="hljs-built_in">list</span>[BaseMessage], add_messages]
    original_intent: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>]  <span class="hljs-comment"># 如 "考生人数"</span>
    known_table_struct: <span class="hljs-type">Optional</span>[<span class="hljs-type">List</span>]  <span class="hljs-comment"># 已确认的表结构</span>
    last_sql_template: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>]  <span class="hljs-comment"># 带占位符的 SQL 模板，如 "SELECT ... WHERE year = {year}"</span>
    query_result: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">list</span>]  <span class="hljs-comment"># 最近一次查询结果</span>
    next_agent: <span class="hljs-built_in">str</span>
</code></pre>
<p>每轮对话都会在全局统一状态机中保存以下信息：</p>

































<table><thead><tr><th>key</th><th>含义</th></tr></thead><tbody><tr><td>messages</td><td>历史消息列表</td></tr><tr><td>original_intent</td><td>用户的核心意图（如“考生人数”）</td></tr><tr><td>known_table_struct</td><td>已识别的数据表结构</td></tr><tr><td>last_sql_template</td><td>参数化 SQL 模板，便于复用</td></tr><tr><td>query_result</td><td>查询结果</td></tr><tr><td>next_agent</td><td>下一步路由方向</td></tr></tbody></table>
<p>其中当我们使用 Annotated[list[BaseMessage], add_messages] 来定义 State 中的 messages 字段时，新的消息会自动被追加到现有的消息列表之后，这是 LangGraph 为管理对话历史等序列化数据提供的一种便捷且强大的状态更新机制。</p>
<p>LangGraph所有智能体Agent都要遵循统一规范，将Stata对象作为输入输出对象，如以下“模板匹配智能体”templateAgent的代码所示：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># ========================</span>
<span class="hljs-comment"># 🍻模板匹配 智能体（支持追问模板复用）</span>
<span class="hljs-comment"># ========================</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">template_agent</span>(<span class="hljs-params">state: State</span>):
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"=== 🟦 Template Agent ==="</span>)
    current_query = state[<span class="hljs-string">"messages"</span>][-<span class="hljs-number">1</span>].content

    <span class="hljs-comment"># ───────────────────────────────────────</span>
    <span class="hljs-comment"># 🔄 情况1：无上下文 → SQL Agent</span>
    <span class="hljs-comment"># ───────────────────────────────────────</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">not</span> state.get(<span class="hljs-string">"known_table_struct"</span>)
            <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> state.get(<span class="hljs-string">"original_intent"</span>)
            <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> state.get(<span class="hljs-string">"last_sql_template"</span>)):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"⚠️ 不存在上下文，进入SQL Agent流程"</span>)
        <span class="hljs-keyword">return</span> {
            <span class="hljs-string">"messages"</span>: state[<span class="hljs-string">"messages"</span>],
            <span class="hljs-string">"next_agent"</span>: <span class="hljs-string">"sql"</span>
        }

    <span class="hljs-comment"># ───────────────────────────────────────</span>
    <span class="hljs-comment"># 🔄 情况2：已有上下文 → 尝试参数化追问处理</span>
    <span class="hljs-comment"># ───────────────────────────────────────</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"🔄 检测到历史上下文，尝试参数化追问"</span>)
    <span class="hljs-keyword">try</span>:
        <span class="hljs-comment"># 具体业务代码跳过...</span>

        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"✅ 追问查询成功，进入分析流程"</span>)
        <span class="hljs-keyword">return</span> {
            <span class="hljs-string">"query_result"</span>: result,
            <span class="hljs-string">"next_agent"</span>: <span class="hljs-string">"analysis"</span>
        }


    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"参数提取失败: <span class="hljs-subst">{e}</span>"</span>)

    <span class="hljs-built_in">print</span>(<span class="hljs-string">"⚠️ 追问处理失败，进入改写流程"</span>)
    <span class="hljs-keyword">return</span> {
        <span class="hljs-string">"messages"</span>: state[<span class="hljs-string">"messages"</span>],
        <span class="hljs-string">"next_agent"</span>: <span class="hljs-string">"rewrite"</span>
    }
</code></pre>
<h3 data-id="heading-2"><strong>▶️ 案例测试结果</strong></h3>
<p>我们测试一下LangGraph实现多智能体协作的效果：</p>
<pre><code class="hljs language-rust" lang="rust">🚀 智能数据助手（支持追问、多轮上下文）
================================================================================
💡 输入问题开始对话，输入 <span class="hljs-symbol">'exit</span>' 退出。
================================================================================

👤 你: <span class="hljs-number">2016</span>年考生人数有多少？
=== 🟦 Template Agent ===
⚠️ 不存在上下文，进入SQL Agent流程
=== 🟦 Sql Agent ===
🆕 启动完整查询流程
调用大模型llama2向量化：<span class="hljs-number">2016</span>年考生人数有多少？
📚 匹配表结构: ['{<span class="hljs-string">"表名"</span>: <span class="hljs-string">"college_entrance_examination"</span>, <span class="hljs-string">"表备注"</span>: <span class="hljs-string">"考生人数与复读人数信息表，包含字段：高考年份(主键)、考生人数(万人)、复读人数(万人)"</span>, <span class="hljs-string">"字段列表"</span>: [{<span class="hljs-string">"字段名"</span>: <span class="hljs-string">"examination_year"</span>, <span class="hljs-string">"字段类型"</span>: <span class="hljs-string">"int"</span>, <span class="hljs-string">"字段备注"</span>: <span class="hljs-string">"高考年份"</span>}, {<span class="hljs-string">"字段名"</span>: <span class="hljs-string">"candidates_count"</span>, <span class="hljs-string">"字段类型"</span>: <span class="hljs-string">"decimal(10,2)"</span>, <span class="hljs-string">"字段备注"</span>: <span class="hljs-string">"考生人数(万人)"</span>}, {<span class="hljs-string">"字段名"</span>: <span class="hljs-string">"retake_count"</span>, <span class="hljs-string">"字段类型"</span>: <span class="hljs-string">"decimal(10,2)"</span>, <span class="hljs-string">"字段备注"</span>: <span class="hljs-string">"复读人数(万人)"</span>}]}']
🧠 原始意图: <span class="hljs-number">2016</span>年考生人数有多少？
📦 保存 SQL 模板: SELECT candidates_count AS '考生人数' FROM college_entrance_examination WHERE examination_year = {year};
=== 🟩 Analysis Agent ===
💬 助手: **<span class="hljs-number">2016</span>年高考考生人数分析报告**  

**事实陈述**  
<span class="hljs-number">2016</span>年高考考生人数为 **<span class="hljs-number">940.00</span>万人**（数据来源：考生人数与复读人数信息表）。

**简要洞察**  
当前数据仅包含单一时间点的记录，暂无法直接推导趋势变化。若需分析考生人数增减规律，建议结合相邻年份数据（如<span class="hljs-number">2015</span>年及<span class="hljs-number">2017</span>年）进行对比。

**备注**  
数据单位为“万人”，数值保留两位小数，统计口径可能包含应届生与复读生。如需进一步解读，可补充复读人数或分省数据辅助分析。

---  
（报告基于提供的数据生成，内容简洁客观，避免过度推测。）
------------------------------------------------------------

👤 你: <span class="hljs-number">2018</span>年呢？
=== 🟦 Template Agent ===
🔄 检测到历史上下文，尝试参数化追问
🔍 提取参数: {<span class="hljs-string">"year"</span>: <span class="hljs-string">"2018"</span>}
🛠️ 生成新 SQL: SELECT candidates_count AS '考生人数' FROM college_entrance_examination WHERE examination_year = <span class="hljs-number">2018</span>;
✅ 追问查询成功，返回 <span class="hljs-number">1</span> 行
=== 🟩 Analysis Agent ===
💬 助手: **<span class="hljs-number">2016</span>年高考考生人数分析报告**  

**事实陈述**  
<span class="hljs-number">2016</span>年高考考生人数为 **<span class="hljs-number">975.0</span>万人**（数据来源：考生人数与复读人数信息表）。

**简要洞察**  
<span class="hljs-number">1</span>. 当前数据仅包含单一时间点的记录，暂无法分析趋势变化。若需观察考生人数增减趋势，建议补充相邻年份数据（如<span class="hljs-number">2015</span>年及<span class="hljs-number">2017</span>年数据）。  
<span class="hljs-number">2</span>. 表中还包含“复读人数”字段，若需进一步分析复读对考生总数的影响，可提供对应数据后补充说明。

**备注**  
数据单位为“万人”，实际考生人数为<span class="hljs-number">9</span>,<span class="hljs-number">750</span>,<span class="hljs-number">000</span>人。如需更深入的统计分析（如增长率、区域对比等），请提供扩展数据集。

---  
**报告说明**：本报告基于提供的数据直接呈现核心结论，避免对单一数据点进行推测性解读。
------------------------------------------------------------

👤 你: 录取人数呢？
=== 🟦 Template Agent ===
🔄 检测到历史上下文，尝试参数化追问
🔍 提取参数: {}
⚠️ 年份参数提取失败，进入改写流程
=== 🟨 Rewrite Agent ===
✍️ 改写后问题: <span class="hljs-number">2018</span>年全国高考录取人数是多少？
=== 🟦 Sql Agent ===
🆕 启动完整查询流程
调用大模型llama2向量化：<span class="hljs-number">2018</span>年全国高考录取人数是多少？
📚 匹配表结构: ['{<span class="hljs-string">"表名"</span>: <span class="hljs-string">"college_entrance_admission"</span>, <span class="hljs-string">"表备注"</span>: <span class="hljs-string">"录取人数与普通高校数信息表，包含字段：录取年份(主键)、录取人数(万人)、招生高校数、本科录取人数(万人)、专科录取人数(万人)"</span>, <span class="hljs-string">"字段列表"</span>: [{<span class="hljs-string">"字段名"</span>: <span class="hljs-string">"admission_year"</span>, <span class="hljs-string">"字段类型"</span>: <span class="hljs-string">"int"</span>, <span class="hljs-string">"字段备注"</span>: <span class="hljs-string">"录取年份"</span>}, {<span class="hljs-string">"字段名"</span>: <span class="hljs-string">"admission_count"</span>, <span class="hljs-string">"字段类型"</span>: <span class="hljs-string">"decimal(10,2)"</span>, <span class="hljs-string">"字段备注"</span>: <span class="hljs-string">"录取人数(万人)"</span>}, {<span class="hljs-string">"字段名"</span>: <span class="hljs-string">"university_count"</span>, <span class="hljs-string">"字段类型"</span>: <span class="hljs-string">"int"</span>, <span class="hljs-string">"字段备注"</span>: <span class="hljs-string">"招生高校数"</span>}, {<span class="hljs-string">"字段名"</span>: <span class="hljs-string">"undergraduate_admission_count"</span>, <span class="hljs-string">"字段类型"</span>: <span class="hljs-string">"decimal(10,2)"</span>, <span class="hljs-string">"字段备注"</span>: <span class="hljs-string">"本科录取人数(万人)"</span>}, {<span class="hljs-string">"字段名"</span>: <span class="hljs-string">"specialty_admission_count"</span>, <span class="hljs-string">"字段类型"</span>: <span class="hljs-string">"decimal(10,2)"</span>, <span class="hljs-string">"字段备注"</span>: <span class="hljs-string">"专科录取人数(万人)"</span>}]}']
🧠 原始意图: <span class="hljs-number">2018</span>年全国高考录取人数是多少？
📦 保存 SQL 模板: SELECT admission_count AS '考生人数' FROM college_entrance_admission WHERE admission_year = {year};
=== 🟩 Analysis Agent ===
💬 助手: **<span class="hljs-number">2018</span>年全国高考录取人数分析报告**  

**事实陈述**  
根据数据表 `college_entrance_admission` 记录，**<span class="hljs-number">2018</span>年全国高考录取人数为 <span class="hljs-number">790.99</span> 万人**。

**简要洞察**  
<span class="hljs-number">1</span>. **数据背景**：该数据反映当年普通高校（含本科及专科）录取总规模，但未提供与考生人数、录取率的对比信息。  
<span class="hljs-number">2</span>. **趋势参考**：若结合近年数据（需补充），可进一步分析录取人数变化趋势；当前单一数据点建议谨慎用于预测。  
<span class="hljs-number">3</span>. **结构细化**：表中包含本科与专科分层数据字段（未在本次结果中体现），后续可针对学历层次结构进行深入分析。

**注意事项**  
- 当前数据为单一数值，分析需避免过度推论。  
- 如需评估录取竞争程度，需补充同年高考报名人数或招生计划数据。

---  
**报告说明**：本分析基于提供的数据表结构及查询结果，确保表述与原始数据一致。
------------------------------------------------------------

👤 你: 
</code></pre>
<p>第一轮问题：2016年考生人数有多少？</p>
<p>第一轮没有上下文，也没有全局变量模板，所以直接走SQL Agent + Analysis AgentRAG检索、生成SQL、查数、分析。同时SQL Agent生成成功后记录SQL模板到全局state。</p>
<p>第二轮问题：2018年呢？</p>
<p>第二轮我们追问2018年，这时存在全局变量模板，所以走模板匹配提取年份参数，直接查数然后通过业务判断存在数据，走Analysis Agent分析。</p>
<p>第三轮问题：录取人数呢？</p>
<p>第三轮我们追问录取人数，但是匹配不到模板，所以上层业务判断走Rewrite Agent + SQL Agent + Analysis Agent改写问题完善条件。改写时，参考Memory中上下文2016和2018年回答，改写为2018年全国高考录取人数是多少？然后走RAG检索、生成SQL、查数、分析。</p>
<h3 data-id="heading-3"><strong>🧩 LangGraph实现小结</strong></h3>
<p>本文使用LangGraph的Custom图模式实现我们的多智能体协作处理业务：</p>
<ul>
<li>通过StataGraph状态图来管理Node节点（对应智能体Agent）+edge边（对应执行路径）；</li>
<li>通过Checkpoint Memory实现长时记忆，管理上下文和结构化参数（消息、SQL 模板、表结构、查询结果等），所有agent都要遵循一定规范，将状态机作为输入和输出。</li>
<li>相对来说，上一篇文章中介绍AgentScope框架更松散，其多Agent协作机制是通过自定义控制逻辑+管道pipeline来串联，通过框架提供的memory只能管理多轮对话的上下文，多智能体多轮次之间的参数传递，需要通过自定义全局变量来实现。</li>
<li/>
</ul>
<h3 data-id="heading-4"><strong>附录：LangGraph几种典型协作模式</strong></h3>
<p>LangGraph 是基于LangChain生态构建，它强调「状态图（StateGraph）」和「可追溯记忆（Checkpoint Memory）」，它提出了几种Multi-Agent模式，适用于不同的调用逻辑和控制流需求：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7f53c2c4e854465f81f4a6811a0e3e84~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pyo5piG5a2Q:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768266843&amp;x-signature=HfB6%2BekD0f5QzPlS8FtuDeKFT7c%3D" alt="image.png" loading="lazy"/></p>
<p>网络（Network）模式</p>
<ul>
<li>各Agent节点彼此多对多通信：每个Agent有权限决定接下来调用哪个其他Agent。</li>
<li>适用于“没有固定顺序”“较灵活的调用关系”的场景。</li>
<li>代码示例中，Agent agent_1、agent_2、agent_3 均可跳转至其他两个或结束。</li>
</ul>
<p>主管（Supervisor）模式</p>
<ul>
<li>一个“主管Agent”负责决定下一步调用哪个子Agent。子Agent执行后再回到主管。</li>
<li>适用于“中央调度控制”“明确谁来决定流程”的场景。</li>
<li>示例：supervisor 决定调用 agent_1 或 agent_2。</li>
</ul>
<p>主管（Supervisor as Tools 工具调用）模式</p>
<ul>
<li>是“主管”模式的一个特例：子Agent被暴露为“工具”（tool），主管Agent像工具调用系统一样，决定调用哪个工具／子Agent。</li>
<li>典型流程：主管以 ReAct （思考→行动→思考）方式循环调用工具直到决策结束。</li>
<li>提供了 create_react_agent 等预置组件。</li>
</ul>
<p>分层（Hierarchical）模式</p>
<ul>
<li>当Agent数量增多、流程更复杂时，用“主管的主管”来管理团队／子系统，形成层级结构。</li>
<li>每个团队内有自己的主管+子Agent，再由顶层主管决定调用哪个团队。</li>
<li>适合更大规模、跨领域、多团队协作的系统。</li>
</ul>
<p>自定义（Custom Workflow）模式（对应本文案例）</p>
<ul>
<li>你也可以手动定义Agent节点及其顺序（显式控制流）或部分由 LLM 决定（动态控制流）。</li>
<li>显式控制流：在图中预先定义边 agent_1 → agent_2 → agent_3。</li>
<li>适合需要「强控制流」「复杂状态管理」「上下文复用」的场景。</li>
</ul>
<p>源码参考：参与协作的四个智能体，以及具体协作控制逻辑代码，详见<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FMuKunZiAI%2Fcollege_entrance_ai%2Fblob%2Fmain%2Flangchain_code%2Fagent_service_graph.py%25E3%2580%2582" target="_blank" title="https://github.com/MuKunZiAI/college_entrance_ai/blob/main/langchain_code/agent_service_graph.py%E3%80%82" ref="nofollow noopener noreferrer">github.com/MuKunZiAI/c…</a></p>
<p>本文总结：本文针对高考信息智能查询的业务场景，采用LangGraph框架验证多智能体协作机制，通过状态图StataGraph来管理节点+条件边组成协作执行路径，通过Checkpoint Memory来管理多轮对话上下文和跨智能体结构化参数传递，最后分享了LangGraph官网的几种典型协作模式</p>
<p>本文作者：Chaiys</p>
<p>本文原载：<a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F0pfVEeESi-UBYhHqmSNZaQ" target="_blank" title="https://mp.weixin.qq.com/s/0pfVEeESi-UBYhHqmSNZaQ" ref="nofollow noopener noreferrer">公众号“木昆子记录AI”</a></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[AI Agents 的 Skills 文件详解]]></title>    <link>https://juejin.cn/post/7591744411739242496</link>    <guid>https://juejin.cn/post/7591744411739242496</guid>    <pubDate>2026-01-06T01:45:47.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7591744411739242496" data-draft-id="7591655106723921920" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="AI Agents 的 Skills 文件详解"/> <meta itemprop="keywords" content="人工智能"/> <meta itemprop="datePublished" content="2026-01-06T01:45:47.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="明月_清风"/> <meta itemprop="url" content="https://juejin.cn/user/1081575170131006"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            AI Agents 的 Skills 文件详解
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1081575170131006/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    明月_清风
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-06T01:45:47.000Z" title="Tue Jan 06 2026 01:45:47 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-06
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在2026年的AI代理（AI Agents）生态中，特别是多代理系统（Multi-Agent Systems）和主流框架如Claude、Codex、VS Code Copilot等，“skills 文件”已成为定义代理专长能力的核心方式。它是一种标准化、可复用、可共享的配置文件，帮助AI代理从通用模型转变为专精专家，而无需重新训练模型。</p>
<h4 data-id="heading-0">什么是 Skills 文件？</h4>
<p>Skills 文件本质上是<strong>SKILL.md</strong>（一个Markdown文件），位于一个专用文件夹中。它遵循开放标准（Agent Skills Specification，由Anthropic、OpenAI等推动），包含：</p>
<ul>
<li><strong>YAML Frontmatter</strong>：元数据，用于代理快速发现和选择技能。</li>
<li><strong>Markdown 正文</strong>：详细指令、指南、示例、边缘案例等，告诉代理“如何执行这项技能”。</li>
</ul>
<p>这种设计实现了“渐进式披露”（Progressive Disclosure）：代理启动时只加载技能的名称和描述（节省token），只有决定使用时才加载完整内容。</p>
<p>与其他框架对比：</p>
<ul>
<li><strong>CrewAI</strong>：使用YAML文件（如agents.yaml）定义代理的role、goal、backstory和tools，但不是“skills”标准。</li>
<li><strong>LangChain</strong>：更多依赖工具（tools）和动态加载提示，但可模拟skills。</li>
<li><strong>AutoGPT/Swarm</strong>：无专用skills文件，靠配置或代码定义能力。</li>
</ul>
<p>主流采用的是<strong>SKILL.md</strong>格式，已成为跨平台标准（Claude Code、Cursor、GitHub Copilot等均支持）。</p>
<h4 data-id="heading-1">SKILL.md 文件的基本结构</h4>
<p>一个典型的SKILL.md 文件示例：</p>
<pre><code class="hljs language-markdown" lang="markdown">---
name: code-review-master
description: 专业代码审查技能，按照团队最佳实践审查Pull Request，确保代码质量、安全性和可维护性。
metadata:
  short-description: 团队标准代码审查专家
  compatibility: claude-4, codex-2026
<span class="hljs-section">  license: Apache-2.0
---</span>

<span class="hljs-section"># 代码审查大师</span>

你是一个资深的代码审查专家，遵循以下严格流程审查代码变更。

<span class="hljs-section">## 核心原则</span>
<span class="hljs-bullet">-</span> 优先检查安全性（注入、泄漏、权限）。
<span class="hljs-bullet">-</span> 确保代码可读性、一致性和性能。
<span class="hljs-bullet">-</span> 提供建设性反馈，建议具体改进。

<span class="hljs-section">## 逐步审查流程</span>
<span class="hljs-bullet">1.</span> <span class="hljs-strong">**理解上下文**</span>：阅读PR描述、相关文件和变更历史。
<span class="hljs-bullet">2.</span> <span class="hljs-strong">**检查结构**</span>：验证架构是否合理，是否有更好的设计模式。
<span class="hljs-bullet">3.</span> <span class="hljs-strong">**代码质量**</span>：检查命名、注释、错误处理和测试覆盖。
<span class="hljs-bullet">4.</span> <span class="hljs-strong">**安全与性能**</span>：扫描潜在漏洞和优化点。
<span class="hljs-bullet">5.</span> <span class="hljs-strong">**输出格式**</span>：用Markdown表格总结问题，按严重度分类（Critical / Major / Minor）。

<span class="hljs-section">## 示例输出</span>
| 严重度 | 文件 | 行号 | 问题描述 | 建议修复 |
|--------|------|------|----------|----------|
| Critical | app.py | 45 | SQL注入风险 | 使用参数化查询 |

<span class="hljs-section">## 常见边缘案例</span>
<span class="hljs-bullet">-</span> 处理大型变更：先概述整体影响，再细化。
<span class="hljs-bullet">-</span> 第三方库：检查版本兼容性和已知漏洞。

（可选：文件夹中可附带脚本、模板或参考文件，如review<span class="hljs-emphasis">_template.md）
</span></code></pre>
<h4 data-id="heading-2">如何使用 Skills 文件？</h4>
<ol>
<li><strong>创建文件夹</strong>：如 <code>.claude/skills/code-review/</code> 或 <code>~/.codex/skills/code-review/</code>。</li>
<li><strong>放置 SKILL.md</strong>：确保文件名精确为SKILL.md。</li>
<li><strong>启用</strong>：在代理配置中允许skills（多数框架默认支持）。</li>
<li><strong>调用</strong>：代理会自动根据任务描述选择并加载技能。例如，你对Claude说：“用团队标准审查这个PR”，它会激活对应skills。</li>
</ol>
<h4 data-id="heading-3">为什么2026年 Skills 文件如此重要？</h4>
<ul>
<li><strong>模块化</strong>：一个技能文件即可赋予代理新能力，可共享（如GitHub仓库）。</li>
<li><strong>高效</strong>：避免每次提示都重复长指令，节省计算资源。</li>
<li><strong>协作</strong>：多代理系统中，不同代理可加载不同skills，实现专业分工。</li>
<li><strong>开源生态</strong>：已有大量社区skills（如PDF处理、Excel分析、代码生成），可直接下载使用。</li>
</ul>
<p>通过Skills文件，你可以将AI代理从“万金油”变成“专才团队”。在2026年，掌握这种配置方式，将是构建高效多代理系统的关键技能！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[抖音思路复刻：iOS 卡死（ANR）监控 + 自动符号化全流程实战]]></title>    <link>https://juejin.cn/post/7591704324907057186</link>    <guid>https://juejin.cn/post/7591704324907057186</guid>    <pubDate>2026-01-05T16:17:01.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7591704324907057186" data-draft-id="7591655106724872192" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="抖音思路复刻：iOS 卡死（ANR）监控 + 自动符号化全流程实战"/> <meta itemprop="keywords" content="iOS,性能优化"/> <meta itemprop="datePublished" content="2026-01-05T16:17:01.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Daniel02"/> <meta itemprop="url" content="https://juejin.cn/user/2277843825853511"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            抖音思路复刻：iOS 卡死（ANR）监控 + 自动符号化全流程实战
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2277843825853511/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Daniel02
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-05T16:17:01.000Z" title="Mon Jan 05 2026 16:17:01 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-05
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在 iOS 上，App 在启动 / 退出 / 响应系统事件等关键阶段如果长时间卡住，超过系统阈值就会触发保护机制，最终被 Watchdog 以 <strong>SIGKILL</strong> 强制终止。这类异常的共同特点是：<strong>不是进程内异常抛出，而是“进程外指令”直接结束进程</strong>，因此传统基于 signal/exception 的崩溃捕获往往覆盖不到，也就导致它在生产环境中经常“只见数据、不见堆栈”，长期被忽视。</p>
<p>为了解决这个盲区，我选择站在巨人的肩膀上：本文实践并复现字节跳动团队的文章<a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FcEfIZGtUojKKbhIfUyhTMw" target="_blank" title="https://mp.weixin.qq.com/s/cEfIZGtUojKKbhIfUyhTMw" ref="nofollow noopener noreferrer">《iOS 稳定性问题治理：卡死崩溃监控原理及最佳实践</a>》，从 <strong>原理 → 代码实现 → 候选文件保存 → dSYM/atos/脚本符号化 + Swift demangle</strong>，把一整套卡死（ANR/Watchdog）监控链路完整跑通，并沉淀成一个可复用 Demo。</p>
<p align="center"><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/03ce7844ae014fe6be0ef3b24f3cd4c8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRGFuaWVsMDI=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768234621&amp;x-signature=OgE%2FBhd1Zay%2BShb9QHdXc015j6Y%3D" alt="" width="200" height="400" loading="lazy"/></p>
<blockquote>
<p>文末给出完整代码链接</p>
</blockquote>
<hr/>
<h2 data-id="heading-0">1. 痛点：卡死最难的不是“知道卡”，而是“知道卡在哪”</h2>
<p>线上卡死/假死常见现象：</p>
<ul>
<li>UI 不响应（点击无反应、滑动卡住），几秒后恢复或被系统杀掉</li>
<li>Crash 日志没有（不是进程内 crash），只剩用户反馈：“刚刚卡住了”</li>
<li>拿到的堆栈是一堆 <code>0x00000001....</code> 地址：<strong>不符号化就等于没有结论</strong></li>
</ul>
<p>所以要解决这类问题，本质是两件事：</p>
<ol>
<li><strong>卡死当下抓到主线程堆栈</strong>（或卡死期间持续采样）</li>
<li><strong>自动符号化</strong>：把地址变成可读函数名，并尽可能 demangle Swift 符号</li>
</ol>
<hr/>
<h2 data-id="heading-1">2. 原理：RunLoop 心跳 + 超阈值采样 = 还原卡死现场</h2>
<h3 data-id="heading-2">2.1 监控“主线程卡死”的本质</h3>
<p>主线程 RunLoop 正常情况下会不断在这些状态间流转：</p>
<ul>
<li><code>BeforeTimers</code></li>
<li><code>BeforeSources</code></li>
<li><code>BeforeWaiting</code></li>
<li><code>AfterWaiting</code></li>
</ul>
<p>当主线程执行重任务（大解析 / 同步 IO / 复杂布局 / 锁等待等），RunLoop 会长期卡在某个阶段不动，表现为 UI 无响应。</p>
<h3 data-id="heading-3">2.2 本 Demo 的检测策略（尽量向“抖音方案”靠拢）</h3>
<p>Demo 采用的策略（参数对齐你当前实现）：</p>
<ul>
<li><strong>阈值：8 秒</strong>（<code>hangThreshold = 8</code>）</li>
<li><strong>检测周期：1 秒窗口</strong>（<code>tickInterval = 1</code>）</li>
<li><strong>超过阈值后：每秒采样一次主线程栈</strong>（从 Live Report 中提取 <code>Thread 0</code>）</li>
<li><strong>最多保留 10 帧样本</strong>（<code>maxMainThreadSamples = 10</code>，保留最近 10 次）</li>
</ul>
<blockquote>
<p>这套策略的意义是：<br/>
<strong>先判断“已经卡死到足够严重”</strong>（接近 Watchdog 风险），再进入“持续采样”，避免把轻微卡顿也当成卡死去抓栈/写文件。</p>
</blockquote>
<hr/>
<h2 data-id="heading-4">3. Demo 实现结构</h2>
<h3 data-id="heading-5">3.1 项目目录骨架</h3>
<pre><code class="hljs language-text" lang="text">LagMonitorDemo/
├── LagMonitorDemo.xcodeproj
├── Sources/
│   └── Monitor/
│      ├── HMDANRMonitor.swift
│      ├── HMDLiveReportCapture.swift
│      ├── HMDANRRecord.swift
│      ├── HMDANRCandidateStore.swift
│      └── HMDDebugCacheCleaner.swift
├── Scripts/
│   └── hmd_anr_symbolicate.py
└── Samples/
    ├── hmd_anr_candidate.json
    └── symbolicated.txt
</code></pre>
<hr/>
<h3 data-id="heading-6">3.2 Monitor：HMDANRMonitor.swift（核心监控器）</h3>
<h4 data-id="heading-7">3.2.1 监控目标</h4>
<ul>
<li>主线程装 <code>CFRunLoopObserver</code>，每次回调认为 RunLoop 推进：<code>heartbeat += 1</code></li>
<li>监控线程用 <strong>1 秒观察窗口</strong>检查 <code>heartbeat</code> 是否变化
<ul>
<li><strong>1 秒内有推进</strong>：健康/恢复，清理候选</li>
<li><strong>1 秒内无推进</strong>：认为卡住，<code>hangSeconds += 1</code></li>
</ul>
</li>
<li>卡住累计达到 <strong>8 秒阈值</strong>：创建 candidate</li>
<li>超阈值后仍未恢复：<strong>每秒采样一次主线程栈</strong>，最多 10 帧</li>
</ul>
<h4 data-id="heading-8">3.2.2 为什么看起来“没 sleep 1 秒”，却实现了“每秒检查一次”？</h4>
<p>核心就在这一句：</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">_</span> <span class="hljs-operator">=</span> wakeSemaphore.wait(timeout: .now() <span class="hljs-operator">+</span> .seconds(config.tickInterval))
</code></pre>
<p>它等价于：</p>
<ul>
<li><strong>最多等待 1 秒</strong>（<code>tickInterval = 1</code>）作为一个观察窗口</li>
<li>如果期间 RunLoop 有推进，observer 会 <code>signal()</code> → 监控线程会<strong>提前醒来</strong></li>
<li>窗口结束后比较 <code>heartbeat</code>：若 1 秒内完全没变，才算这一秒“卡住”</li>
</ul>
<p>所以这里不是“固定每秒到点触发一次”，而是：</p>
<blockquote>
<p><strong>“最多等 1 秒，但只要 RunLoop 一推进就立刻醒来重置状态”</strong><br/>
这比 Timer 的“固定周期触发”更贴合我们想观察的对象（RunLoop 推进）。</p>
</blockquote>
<h4 data-id="heading-9">3.2.3 为什么不用 NSTimer / GCD 定时器，而用信号量？</h4>
<p><strong>Timer 触发本身就依赖调度与 RunLoop/线程状态，卡死时最容易抖动或延迟；信号量 + 超时是更稳定的“观察窗口”，还能被 RunLoop 推进即时唤醒。</strong></p>
<hr/>
<h3 data-id="heading-10">3.3 抓栈：HMDLiveReportCapture.swift（PLCrashReporter Live Report）</h3>
<p>抓栈使用 <code>PLCrashReporter</code> 的 Live Report 能力：</p>
<ul>
<li><code>generateLiveReportAndReturnError()</code>：生成“当下全线程现场”</li>
<li>再从文本中提取 <code>Thread 0</code> 作为主线程样本</li>
</ul>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">import</span> CrashReporter

<span class="hljs-comment">/// 抓一次“全线程现场报告”</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">captureAllThreadsText</span>() -&gt; <span class="hljs-type">String</span>? {
    <span class="hljs-keyword">let</span> config <span class="hljs-operator">=</span> <span class="hljs-type">PLCrashReporterConfig</span>(signalHandlerType: .<span class="hljs-type">BSD</span>, symbolicationStrategy: .all)
    <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> reporter <span class="hljs-operator">=</span> <span class="hljs-type">PLCrashReporter</span>(configuration: config) <span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span> }

    <span class="hljs-keyword">do</span> {
        <span class="hljs-keyword">let</span> data <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> reporter.generateLiveReportAndReturnError()
        <span class="hljs-keyword">let</span> report <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-type">PLCrashReport</span>(data: data)
        <span class="hljs-keyword">return</span> <span class="hljs-type">PLCrashReportTextFormatter</span>.stringValue(for: report, with: <span class="hljs-type">PLCrashReportTextFormatiOS</span>)
    } <span class="hljs-keyword">catch</span> {
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"[HMDLiveReportCapture] parse report error: <span class="hljs-subst">\(error)</span>"</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
    }
}
</code></pre>
<blockquote>
<p>这里的思路就是：<br/>
<strong>卡死现场抓“全线程”，用于兜底；超阈值后持续采“主线程”，用于定位稳定卡点。</strong></p>
</blockquote>
<hr/>
<h3 data-id="heading-11">3.4 保存：HMDANRCandidateStore.swift（hmd_anr_candidate.json）</h3>
<p>Demo 保存的核心数据结构是 <code>HMDANRRecord</code>，通过 <code>Codable</code> 编码为 JSON：</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">public</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">HMDANRRecord</span>: <span class="hljs-title class_">Codable</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">let</span> recordID: <span class="hljs-type">String</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">let</span> timestamp: <span class="hljs-type">Date</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> hangSeconds: <span class="hljs-type">Int</span>

    <span class="hljs-comment">/// 超过阈值那一刻：全线程现场（PLCrash live report，文本）</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> allThreadsReportText: <span class="hljs-type">String</span>?

    <span class="hljs-comment">/// 超阈值后：每秒采样主线程调用栈（最多保留最近 N 条）</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> mainThreadSamples: [<span class="hljs-type">String</span>]
}
</code></pre>
<p>保存到 <code>Caches/hmd_anr_candidate.json</code> 后，大致字段长这样：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"recordID"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"E2D0...-...."</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"timestamp"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"2026-01-05T12:34:56Z"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"hangSeconds"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">9</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"allThreadsReportText"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"PLCrashReporter live report text ..."</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"mainThreadSamples"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
    <span class="hljs-string">"Thread 0 ...\n0 LagMonitorDemo 0x...\n1 UIKitCore ..."</span><span class="hljs-punctuation">,</span>
    <span class="hljs-string">"Thread 0 ...\n0 LagMonitorDemo 0x...\n1 UIKitCore ..."</span>
  <span class="hljs-punctuation">]</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<blockquote>
<p><strong><code>HMDANRCandidateStore</code>卡住时把记录保存到缓存文件；一旦主线程恢复推进就立刻删除；如果进程被系统强杀来不及上报，这个文件会留到下次启动再读取导出/符号化。</strong></p>
</blockquote>
<hr/>
<h2 data-id="heading-12">4. 复现场景（Demo 内置）</h2>
<p>Demo 里包含几种典型卡死触发方式：</p>
<pre><code class="hljs language-swift" lang="swift">stack.addArrangedSubview(makeButton(<span class="hljs-string">"主线程 Busy 2s（轻微卡顿）"</span>) { [<span class="hljs-keyword">weak</span> <span class="hljs-keyword">self</span>] <span class="hljs-keyword">in</span> <span class="hljs-keyword">self</span><span class="hljs-operator">?</span>.busy(seconds: <span class="hljs-number">2</span>) })
stack.addArrangedSubview(makeButton(<span class="hljs-string">"主线程 Busy 20s（触发 candidate + 采样）"</span>) { [<span class="hljs-keyword">weak</span> <span class="hljs-keyword">self</span>] <span class="hljs-keyword">in</span> <span class="hljs-keyword">self</span><span class="hljs-operator">?</span>.busy(seconds: <span class="hljs-number">20</span>) })
stack.addArrangedSubview(makeButton(<span class="hljs-string">"锁竞争：子线程持锁 12s → 主线程尝试加锁"</span>) { [<span class="hljs-keyword">weak</span> <span class="hljs-keyword">self</span>] <span class="hljs-keyword">in</span> <span class="hljs-keyword">self</span><span class="hljs-operator">?</span>.lockContention() })
stack.addArrangedSubview(makeButton(<span class="hljs-string">"死锁：串行队列 sync + 主队列 sync（必卡死）"</span>) { [<span class="hljs-keyword">weak</span> <span class="hljs-keyword">self</span>] <span class="hljs-keyword">in</span> <span class="hljs-keyword">self</span><span class="hljs-operator">?</span>.deadlock() })
</code></pre>
<hr/>
<h2 data-id="heading-13">5. 自动符号化：从 hmd_anr_candidate.json 到“可读堆栈”</h2>
<p>我点击 <strong>“主线程 Busy 20s（触发 candidate + 采样）”</strong>，在第 10 秒手动杀掉 App，然后导出沙盒里的 <code>hmd_anr_candidate.json</code>。</p>
<p>你会看到类似信息：</p>
<ul>
<li><code>hangSeconds = 13</code>（很明确的主线程长时间阻塞）</li>
<li><code>mainThreadSamples</code> 有多次采样（证明卡住期间栈稳定）</li>
<li>但这些堆栈仍然是地址/偏移，无法直接定位业务代码</li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3c1957fa51734700b434f101e01aaef2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRGFuaWVsMDI=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768234621&amp;x-signature=3gdvXM0dJ9yXommktWmHfoLS1C0%3D" alt="1.jpg" loading="lazy"/></p>
<p>因此需要做：</p>
<ul>
<li>从 <code>hmd_anr_candidate.json</code> 里解析 frame</li>
<li>用 <strong>dSYM + atos</strong> 还原符号；并对 <strong>Swift 符号 demangle</strong>（<code>$s... → Foundation.Date.init()</code>）</li>
</ul>
<p>本项目用脚本 <code>hmd_anr_symbolicate.py</code> 自动完成批量符号化：</p>
<pre><code class="hljs language-bash" lang="bash">python3 hmd_anr_symbolicate.py   --record hmd_anr_candidate.json   --app-dsym LagMonitorDemo.app.dSYM   --<span class="hljs-built_in">arch</span> arm64   --demangle   --out symbolicated.txt
</code></pre>
<p>符号化后的<code>symbolicated.txt</code>的大致内容如下：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ac5db4a813f14d99827aed0b39f65fbc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRGFuaWVsMDI=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768234621&amp;x-signature=t3nd8wnNgtuAUgumuuOmlykJBOQ%3D" alt="2.jpg" loading="lazy"/></p>
<blockquote>
<p><code>hmd_anr_symbolicate.py</code>在<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fwutao23yzd%2FuikitCombine" target="_blank" title="https://github.com/wutao23yzd/uikitCombine" ref="nofollow noopener noreferrer">GITHUB</a>项目的Scripts文件夹下，<code>hmd_anr_candidate.json</code>和<code>symbolicated.txt</code>在Samples文件下</p>
</blockquote>
<h3 data-id="heading-14">5.1 符号化后如何“从栈定位问题”？</h3>
<p>从 <code>symbolicated.txt</code> 里抽 <code>mainThreadSamples[0]</code> 的关键几帧（你这次 5 次采样基本一致）：</p>
<pre><code class="hljs language-text" lang="text">1   libsystem_c.dylib          gettimeofday
3   Foundation                 Date.init
4   LagMonitorDemo.debug.dylib ... (ViewController.swift:52)
5   LagMonitorDemo.debug.dylib ... (ViewController.swift:33)
6   LagMonitorDemo.debug.dylib ... (ViewController.swift:44)
7   UIKitCore                  ...
</code></pre>
<p>这说明卡死期间主线程一直在跑 <code>ViewController.swift</code> 的某段逻辑，并且频繁调用 <code>Date()</code>（最终落到 <code>gettimeofday/clock_gettime</code>），典型特征就是<strong>忙等/死循环式等待</strong>。</p>
<p>对应 Demo 中的实现：</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">private</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">busy</span>(<span class="hljs-params">seconds</span>: <span class="hljs-type">Int</span>) {
    <span class="hljs-keyword">let</span> end <span class="hljs-operator">=</span> <span class="hljs-type">Date</span>().addingTimeInterval(<span class="hljs-type">TimeInterval</span>(seconds))
    <span class="hljs-keyword">while</span> <span class="hljs-type">Date</span>() <span class="hljs-operator">&lt;</span> end {
        <span class="hljs-keyword">_</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-operator">+</span> <span class="hljs-number">1</span>
    }
}
</code></pre>
<blockquote>
<p>这类栈顶常见现象就是：看起来“卡在 Date()”，其实根因是 <strong>while 循环让主线程一直跑</strong>。<br/>
采样刚好截在 <code>Date()</code> 这一行，于是栈顶表现为 <code>Date.init -&gt; gettimeofday</code>。</p>
</blockquote>
<hr/>
<h2 data-id="heading-15">6. 结语：复刻的意义，是把“文章里的方案”变成“项目里能用的工具”</h2>
<p>大厂的稳定性方案往往更深、更体系化，但很多时候只停留在文章层面：看懂了思路，却很难在项目里直接落地。本文的目标就是把它“拆开 + 跑通”：</p>
<ul>
<li><strong>把抖音文章里的链路拆成可运行代码</strong>（监控、采样、保存、恢复、导出）</li>
<li><strong>把最后一公里补齐</strong>（dSYM/atos 自动符号化 + Swift demangle）</li>
<li>让“卡死问题”从 <strong>只有 SIGKILL 数字</strong>，变成 <strong>能指向具体业务函数/代码行</strong> 的结论</li>
</ul>
<p>你真正需要的不是“我们检测到了卡死”，而是：</p>
<blockquote>
<p><strong>卡死那 8～20 秒内，主线程到底在跑什么？它卡在谁身上？</strong></p>
</blockquote>
<p>当你把“采样 + 保存 + 下次启动捞取 + 自动符号化 + demangle”这条链路跑通，线上卡死排查效率会明显提升。</p>
<hr/>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fwutao23yzd%2FuikitCombine" target="_blank" title="https://github.com/wutao23yzd/uikitCombine" ref="nofollow noopener noreferrer">GITHUB源码</a></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Python异步编程：asyncio与async/await深度解析]]></title>    <link>https://juejin.cn/post/7591719013489426470</link>    <guid>https://juejin.cn/post/7591719013489426470</guid>    <pubDate>2026-01-06T00:25:38.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7591719013489426470" data-draft-id="7591713442400239625" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content=" Python异步编程：asyncio与async/await深度解析"/> <meta itemprop="keywords" content="Python"/> <meta itemprop="datePublished" content="2026-01-06T00:25:38.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="吃西红柿长大的番茄"/> <meta itemprop="url" content="https://juejin.cn/user/3097787706900985"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
             Python异步编程：asyncio与async/await深度解析
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3097787706900985/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    吃西红柿长大的番茄
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-06T00:25:38.000Z" title="Tue Jan 06 2026 00:25:38 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-06
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    1
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读9分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252b3a}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px;color:#5e7ce0}.markdown-body h1{font-size:24px;margin-bottom:5px;margin-top:80px;position:relative;text-align:center}.markdown-body h2{font-size:20px;padding-bottom:12px;border-bottom:1px solid #dfe1e6}.markdown-body h3{font-size:18px;padding-bottom:0}.markdown-body h4{font-size:16px;margin-top:30px}.markdown-body h5{font-size:14px;margin-top:20px}.markdown-body h6{font-size:14px;margin-top:5px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #dfe1e6;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#ffeeed;color:#c73636;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#252b3a;background:#f8f8f8}.markdown-body a{position:relative;text-decoration:none;color:#5e7ce0;padding-right:18px;padding-bottom:4px}.markdown-body a[href^=http]:after{position:absolute;display:inline-block;width:16px;height:16px;margin-left:2px;margin-top:6px;content:"";background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAIRlWElmTU0AKgAAAAgABQESAAMAAAABAAEAAAEaAAUAAAABAAAASgEbAAUAAAABAAAAUgEoAAMAAAABAAIAAIdpAAQAAAABAAAAWgAAAAAAAABIAAAAAQAAAEgAAAABAAOgAQADAAAAAQABAACgAgAEAAAAAQAAACCgAwAEAAAAAQAAACAAAAAAX7wP8AAAAAlwSFlzAAALEwAACxMBAJqcGAAAAVlpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IlhNUCBDb3JlIDYuMC4wIj4KICAgPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICAgICAgPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iPgogICAgICAgICA8dGlmZjpPcmllbnRhdGlvbj4xPC90aWZmOk9yaWVudGF0aW9uPgogICAgICA8L3JkZjpEZXNjcmlwdGlvbj4KICAgPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4KGV7hBwAABWVJREFUWAnlVktsVFUY/s85997pC9BOTKxRWnEKsXWlxjWJj0RWJjrFAAXjAlewYWOkgauACVu7a2IiNUEyExM3yoZE3Wmi7qgPJthJBDE6JUNpO3Mf5/j95/bOTOcBlBgXejJ37rn/Of/7O/9/iP7vQ/zTAcjnC4ry+a5ii1OkiYTpuvjvEc0Gp51uivP+ZW+QBuSW4QjW5rptAa1Ey0uOGKOxwPetVyafN6p/52/PkNBbjdAhGaGEpMRjLZTryB8+9MUSYSGNRIcBvm8kBAY9tHYlHz78nTs392xIkwv9FA3Oe33bdoX1ZZKOS0bH0CXI6RugYLW6BwIu5gskkQ4sEG0wYF25PjBzbZfSYY6kDLUmWMt7FR7Lw3xYUkaTdjxHfTPnPwav0iEGYADVa9XIRIEyxrAA0jIQxgFL22gYwF7A8/DAzNVdksJvJaTEUZ2kYnZWziN5s1ADPHneEIXByotYuMSrf9JEbbsuv7VcvbaKML8plXtQR0EdIYDqWEmtOgAomZFH8EjWSnek2ulmtljljttHbmaIHCCCHzd9MjwfsmscBeZH9Jyd10nMvz92UQrtCBKvMF06mQy0SiEdRMEGg8mN0YjAlgoDDkPrMI5qJKSkKKydpbB2CZjJkhIBvOBw2CGQgii85bpx//dMqFRKam5uvH7w+K97oe+Cl0HO68uIBH0qyEzpOMwIbZIcFq0I+9cwoElizCjk2KFI1y7Nnx614W1db58fOXIlMzs7Xn/jeDmvBV2Q0mXjGf554O/m4LZHp2N8r61WPMvLZWLdiC4GMAk5BjeeB5lhv39l6+BIbu3m760hXMDKBD08XBKzR8fr04nygnIypOOAJUx/fHrsi0Mnys+vVK+V4VUohaiyPCo2Q9DFALvF/ikw8WS4QvVZALS5ksw47/7R8ejgTPk1UFqU6/3zp8bOM7B/kdu/fkguPGU5JibW+F0sTjWOUw8DklRrg4BiLGeBqbaRLxjlT4no0InFV402RcftJz41cH/f/JnHP3kZaaF6VX/liwist9vYG5+NU9Cg3MNkt/+lU5wS8fTxq3mc7ILjDlAE4CJpe89BOWPiIjBhi9O6PI4G1jsc6RGB3lZwmS76k8H0zOKTkFboG8jS2krFKCX2fvTeaPHIBwAkMHHgncURnL3nuCSnxSopdIzN5th0BIonJ0Lf9yUA9iMkzdRWl3BixOusfDcwQVcS4UKIFwYfGPnM8wY/DyP9NFMXaTE5BU39tGkDgGZz+fJJG0oYcSaOafLcqdECY4LzfSObSzyUOgxqtyisr8SSNOOAkubWoh3TTaeA2YtFEXPnm5x81/j+6MI6JqyS25WSNU6hbCMKHG84marJbdR+vwakRhQLRuQpbzHRLjmpmijI+OmWCtq+LzWtnX5v30gHSsqmWne74DtiACi2+Wz0iXbuLt9D2cDyoPEkWOiyp5XUIwLMi/wJY1FbH5B9ONtdC1KrsD/Q0MCQAS0wccILORDW25amAeOtooAj/KQxfzF17uwTSQ1v3dJ7jnLINwdZYRDa4tPU0sHVXFo/vxFF5BqFqxRfOmgPCk4ft2NgKTCy2Y47JIEg+MIhjYsLy5I25qUYTQlCjMRHsr/UwdYwIK33UO1J5fFNB9XNO6akcywJofVmXQDP2wfrSPcI2xG5BSs3I+IosHr4EtvO1TDAu16xHQq5+ykMblfRXLbhEoFIdDTBdhldvzl+3CMg60ZktI2vNzLW6IIp0waLklot9L63yzuUp8dJd7bglPFe3hIXstBEP58/s6Ocyr4rH2+866ZNbriTzA0RSOWCwakMl1QJgculxPt8Z7O5GLdtW6bvU8R/nO1vb+hMExVAVtEAAAAASUVORK5CYII=");background-size:100%}.markdown-body a:active,.markdown-body a:hover{border-bottom:2px solid #5e7ce0}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #5e7ce0;border-spacing:0}.markdown-body thead{color:#fff;text-align:left}.markdown-body thead tr{background:#5e7ce0}.markdown-body thead th{border-bottom:1px solid #dfe1e6}.markdown-body tr{background-color:#fff}.markdown-body tr:nth-child(2n){background-color:#f2f5fc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#252b3a;padding:1px 23px;margin:22px 0;border-left:4px solid #5e7ce0;background-color:#f2f5fc}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{padding-left:10px;margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol li::marker,.markdown-body ul li::marker{color:#5e7ce0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body ul li::marker{content:"•";color:#5e7ce0}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}.markdown-body input[type=checkbox]:before{display:inline-block;width:16px;height:16px;content:"";background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEIAAABCCAYAAADjVADoAAAK2GlDQ1BJQ0MgUHJvZmlsZQAASImVlwdUU9kWhs+96Y0WiHRC70gngJTQQxGkg6iEJJBQYkgIKmJnUMGxoCKCZcSKKFhGQMaCWLANAopdJ8igoD4HC6Ki5t3AI8zMW++99fZaJ+dbO/vss/e55671XwAoYWyRKBdWAyBPWCCODQ2gJ6ek0nHPAQRgQAI2wIHNkYiYMTGRALHJ+a/28S4Sjdhte0Wuf///v5oGlyfhAAClIZzBlXDyEG5DxkuOSFwAAOoI4jddUCBScBfCmmKkQIR/V3DWBH9ScMY4o8njMfGxgQjTAcCT2WxxFgBkO8RPL+RkIXnIih4chVyBEOFihH05fDYX4TMI2+XlzVfwIMJWSLwIAApyOoCR8aecWX/Jn6HMz2ZnKXmir3HDBwkkolz2ov/zaP635eVKJ/ewQAaZLw6LVeyHnN/9nPkRShZmzIyeZAF3oiYF86VhCZPMkQSmTjKXHRShXJs7M3KSMwUhLGWeAlb8JPMkwXGTLJ4fq9wrUxzInGS2eHxfIsIyaU6C0s/nsZT5i/jxSZNcKEicOcmSnLiIqZhApV8sjVXWzxOGBkztG6LsPU/yp34FLOXaAn58mLJ39lT9PCFzKqckWVkblxcUPBWToIwXFQQo9xLlxijjebmhSr+kME65tgC5nFNrY5RnmM0Oj5lkIABRgA04dNVJAqCAt7BA0UjgfNEisSCLX0BnIm8bj84Schzs6M6Ozs4AKN7dievwnjb+TkK061O+NYjHr10ul5+e8oUi9/i4KfJYbk35LCsAUNUD4Op+jlRcOOFDK34wyNNTBZpABxgCU2AF7IEzcAfewB8Eg3AQDeJBCpiL1MoHeUAMFoBisAKUgnKwEWwF1WA32AsOgaPgBGgGZ8AFcAXcAF2gFzwCMjAAXoFh8BGMQRCEgygQFdKBjCBzyBZyhhiQLxQMRUKxUAqUDmVBQkgKFUOroHKoAqqG9kB10HHoNHQBugZ1Qw+gPmgIegd9gVEwGdaEDWALeDrMgJlwBBwPz4Gz4Hy4CC6B18NVcC18BG6CL8A34F5YBr+CR1AARULRUMYoexQDFYiKRqWiMlFi1FJUGaoSVYtqQLWiOlC3UTLUa9RnNBZNRdPR9mhvdBg6Ac1B56OXotehq9GH0E3oS+jb6D70MPo7hoLRx9hivDAsTDImC7MAU4qpxBzAnMJcxvRiBjAfsVgsDWuJ9cCGYVOw2djF2HXYndhGbBu2G9uPHcHhcDo4W5wPLhrHxhXgSnHbcUdw53E9uAHcJzwJb4R3xofgU/FC/Ep8Jf4w/hy+B/8CP0ZQI5gTvAjRBC5hEWEDYR+hlXCLMEAYI6oTLYk+xHhiNnEFsYrYQLxMfEx8TyKRTEiepFkkAWk5qYp0jHSV1Ef6TNYg25ADyWlkKXk9+SC5jfyA/J5CoVhQ/CmplALKekod5SLlKeWTClXFQYWlwlVZplKj0qTSo/JGlaBqrspUnatapFqpelL1luprNYKahVqgGlttqVqN2mm1e2oj6lR1J/Vo9Tz1deqH1a+pD2rgNCw0gjW4GiUaezUuavRTUVRTaiCVQ11F3Ue9TB3QxGpaarI0szXLNY9qdmoOa2louWolai3UqtE6qyWjoWgWNBYtl7aBdoJ2l/ZlmsE05jTetLXTGqb1TBvV1tP21+Zpl2k3avdqf9Gh6wTr5Ohs0mnWeaKL1rXRnaW7QHeX7mXd13qaet56HL0yvRN6D/VhfRv9WP3F+nv1b+qPGBgahBqIDLYbXDR4bUgz9DfMNtxieM5wyIhq5GskMNpidN7oJV2LzqTn0qvol+jDxvrGYcZS4z3GncZjJpYmCSYrTRpNnpgSTRmmmaZbTNtNh82MzKLMis3qzR6aE8wZ5nzzbeYd5qMWlhZJFqstmi0GLbUtWZZFlvWWj60oVn5W+Va1VnessdYM6xzrndZdNrCNmw3fpsbmli1s624rsN1p222HsfO0E9rV2t2zJ9sz7Qvt6+37HGgOkQ4rHZod3kw3m546fdP0junfHd0ccx33OT5y0nAKd1rp1Or0ztnGmeNc43zHheIS4rLMpcXlrautK891l+t9N6pblNtqt3a3b+4e7mL3BvchDzOPdI8dHvcYmowYxjrGVU+MZ4DnMs8znp+93L0KvE54/eFt753jfdh7cIblDN6MfTP6fUx82D57fGS+dN903598ZX7Gfmy/Wr9n/qb+XP8D/i+Y1sxs5hHmmwDHAHHAqYDRQK/AJYFtQaig0KCyoM5gjeCE4OrgpyEmIVkh9SHDoW6hi0PbwjBhEWGbwu6xDFgcVh1rONwjfEn4pQhyRFxEdcSzSJtIcWRrFBwVHrU56vFM85nCmc3RIJoVvTn6SYxlTH7ML7Ows2Jm1cx6HusUWxzbEUeNmxd3OO5jfED8hvhHCVYJ0oT2RNXEtMS6xNGkoKSKJFny9OQlyTdSdFMEKS2puNTE1AOpI7ODZ2+dPZDmllaadneO5ZyFc67N1Z2bO/fsPNV57Hkn0zHpSemH07+yo9m17JEMVsaOjGFOIGcb5xXXn7uFO8Tz4VXwXmT6ZFZkDmb5ZG3OGuL78Sv5rwWBgmrB2+yw7N3ZoznROQdz5LlJuY15+Lz0vNNCDWGO8NJ8w/kL53eLbEWlIlm+V/7W/GFxhPiABJLMkbQUaCIi6abUSvqDtK/Qt7Cm8NOCxAUnF6ovFC68uchm0dpFL4pCivYvRi/mLG4vNi5eUdy3hLlkz1JoacbS9mWmy0qWDSwPXX5oBXFFzopfVzqurFj5YVXSqtYSg5LlJf0/hP5QX6pSKi69t9p79e416DWCNZ1rXdZuX/u9jFt2vdyxvLL86zrOuus/Ov1Y9aN8feb6zg3uG3ZtxG4Ubry7yW/ToQr1iqKK/s1Rm5u20LeUbfmwdd7Wa5Wulbu3EbdJt8mqIqtatptt37j9azW/urcmoKZxh/6OtTtGd3J39uzy39Ww22B3+e4vPwl+ur8ndE9TrUVt5V7s3sK9z/cl7uvYz9hfd0D3QPmBbweFB2WHYg9dqvOoqzusf3hDPVwvrR86knak62jQ0ZYG+4Y9jbTG8mPgmPTYy+Ppx++eiDjRfpJxsuFn8593nKKeKmuCmhY1DTfzm2UtKS3dp8NPt7d6t576xeGXg2eMz9Sc1Tq74RzxXMk5+fmi8yNtorbXF7Iu9LfPa390MfninUuzLnVejrh89UrIlYsdzI7zV32unrnmde30dcb15hvuN5puut089avbr6c63Tubbnncauny7GrtntF9rsev58LtoNtX7rDu3Oid2dt9N+Hu/Xtp92T3ufcHH+Q+ePuw8OHYo+WPMY/Lnqg9qXyq/7T2N+vfGmXusrN9QX03n8U9e9TP6X/1u+T3rwMlzynPK18YvagbdB48MxQy1PVy9suBV6JXY69L/6H+jx1vrN78/If/HzeHk4cH3orfyt+te6/z/uAH1w/tIzEjTz/mfRwbLfuk8+nQZ8bnji9JX16MLfiK+1r1zfpb6/eI74/leXK5iC1mj0sBFDLgzEwA3h1EtHEKAFRElxNnT2jrcYMmvgfGCfwnntDf4+YOQAMyKWQR0x+Akwo5i8wqyKyQRPH+AHZxUY5/mSTTxXkiFxlRlphPcvl7AwBwrQB8E8vlYzvl8m/7kGIfANCWP6HpFYZFtHyD3vJRg6LbPe3g7zah9//U499noKjAFfx9/ieoZhkWVvYkwwAAAGxlWElmTU0AKgAAAAgABAEaAAUAAAABAAAAPgEbAAUAAAABAAAARgEoAAMAAAABAAIAAIdpAAQAAAABAAAATgAAAAAAAACQAAAAAQAAAJAAAAABAAKgAgAEAAAAAQAAAEKgAwAEAAAAAQAAAEIAAAAAgodoEQAAAAlwSFlzAAAWJQAAFiUBSVIk8AAAAhRJREFUeAHtnLEuBFEUhs9cu7JCskEhIrZAgYZGoREPwBuIygOoPITKA6jEG/AAolFoaFCgICIKZBNiY8Pyz5rNOWe9wNz5T7N3Z2eT/b/7zZlpziat3xKWBDJoEyh5EDd3DTk5r8vV7Yc8vzbl6zvfwvSERIYHyzI90SeLc1WZrFV85PR9oi+N/YMnOT6t/3tiLAeXFqqytjrSFacDYmfvQS6u37tOiPHA7FS/bK6PmWhpj4AJRYGA9MiKzLpK6An+cqiNVmRleUhArrec6PNzt/5sttLgh0cvcvfY6Px+ZNY9I6Ax6gKErY1xmZ8ZyD0E5MJGIgsyIZsunT3g7qALJuTdAp0nWyMTsunS2QNukbpwOcRaPpvOHvxzQow2ZBvrs+nsfLL8o0QQBJFdMO1XGkEjaIQlQCMsD/YIGkEjLAEaYXmwR9AIGmEJ0AjLgz2CRtAIS4BGWB7sETSCRlgCNMLyYI+gETTCEqARlgd7BI2gEZYAjbA82CNoBI2wBGiE5cEeQSNohCVAIywP9ggaQSMsARphebBH0AgaYQnQCMsjYC5SF2agYi2fTWcPGA7VFfO0n8+mswdMyOrCNJwnpz/P6xqZkE2Xzh4w8qcLI4Hbu/dydvkWBRAAQBZk0uOOyKyzp5PARRiF1puNtR+NTh+oMCvtJ+D8F2N6j6x+PrwzG46gRTDDm5BtsAGBg0X924Qfj7i23p7HNgQAAAAASUVORK5CYII=");background-size:100%;position:relative;right:2px;top:-5px}.markdown-body input[type=checkbox]:checked:before{background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEIAAABCCAYAAADjVADoAAAK2GlDQ1BJQ0MgUHJvZmlsZQAASImVlwdUU9kWhs+96Y0WiHRC70gngJTQQxGkg6iEJJBQYkgIKmJnUMGxoCKCZcSKKFhGQMaCWLANAopdJ8igoD4HC6Ki5t3AI8zMW++99fZaJ+dbO/vss/e55671XwAoYWyRKBdWAyBPWCCODQ2gJ6ek0nHPAQRgQAI2wIHNkYiYMTGRALHJ+a/28S4Sjdhte0Wuf///v5oGlyfhAAClIZzBlXDyEG5DxkuOSFwAAOoI4jddUCBScBfCmmKkQIR/V3DWBH9ScMY4o8njMfGxgQjTAcCT2WxxFgBkO8RPL+RkIXnIih4chVyBEOFihH05fDYX4TMI2+XlzVfwIMJWSLwIAApyOoCR8aecWX/Jn6HMz2ZnKXmir3HDBwkkolz2ov/zaP635eVKJ/ewQAaZLw6LVeyHnN/9nPkRShZmzIyeZAF3oiYF86VhCZPMkQSmTjKXHRShXJs7M3KSMwUhLGWeAlb8JPMkwXGTLJ4fq9wrUxzInGS2eHxfIsIyaU6C0s/nsZT5i/jxSZNcKEicOcmSnLiIqZhApV8sjVXWzxOGBkztG6LsPU/yp34FLOXaAn58mLJ39lT9PCFzKqckWVkblxcUPBWToIwXFQQo9xLlxijjebmhSr+kME65tgC5nFNrY5RnmM0Oj5lkIABRgA04dNVJAqCAt7BA0UjgfNEisSCLX0BnIm8bj84Schzs6M6Ozs4AKN7dievwnjb+TkK061O+NYjHr10ul5+e8oUi9/i4KfJYbk35LCsAUNUD4Op+jlRcOOFDK34wyNNTBZpABxgCU2AF7IEzcAfewB8Eg3AQDeJBCpiL1MoHeUAMFoBisAKUgnKwEWwF1WA32AsOgaPgBGgGZ8AFcAXcAF2gFzwCMjAAXoFh8BGMQRCEgygQFdKBjCBzyBZyhhiQLxQMRUKxUAqUDmVBQkgKFUOroHKoAqqG9kB10HHoNHQBugZ1Qw+gPmgIegd9gVEwGdaEDWALeDrMgJlwBBwPz4Gz4Hy4CC6B18NVcC18BG6CL8A34F5YBr+CR1AARULRUMYoexQDFYiKRqWiMlFi1FJUGaoSVYtqQLWiOlC3UTLUa9RnNBZNRdPR9mhvdBg6Ac1B56OXotehq9GH0E3oS+jb6D70MPo7hoLRx9hivDAsTDImC7MAU4qpxBzAnMJcxvRiBjAfsVgsDWuJ9cCGYVOw2djF2HXYndhGbBu2G9uPHcHhcDo4W5wPLhrHxhXgSnHbcUdw53E9uAHcJzwJb4R3xofgU/FC/Ep8Jf4w/hy+B/8CP0ZQI5gTvAjRBC5hEWEDYR+hlXCLMEAYI6oTLYk+xHhiNnEFsYrYQLxMfEx8TyKRTEiepFkkAWk5qYp0jHSV1Ef6TNYg25ADyWlkKXk9+SC5jfyA/J5CoVhQ/CmplALKekod5SLlKeWTClXFQYWlwlVZplKj0qTSo/JGlaBqrspUnatapFqpelL1luprNYKahVqgGlttqVqN2mm1e2oj6lR1J/Vo9Tz1deqH1a+pD2rgNCw0gjW4GiUaezUuavRTUVRTaiCVQ11F3Ue9TB3QxGpaarI0szXLNY9qdmoOa2louWolai3UqtE6qyWjoWgWNBYtl7aBdoJ2l/ZlmsE05jTetLXTGqb1TBvV1tP21+Zpl2k3avdqf9Gh6wTr5Ohs0mnWeaKL1rXRnaW7QHeX7mXd13qaet56HL0yvRN6D/VhfRv9WP3F+nv1b+qPGBgahBqIDLYbXDR4bUgz9DfMNtxieM5wyIhq5GskMNpidN7oJV2LzqTn0qvol+jDxvrGYcZS4z3GncZjJpYmCSYrTRpNnpgSTRmmmaZbTNtNh82MzKLMis3qzR6aE8wZ5nzzbeYd5qMWlhZJFqstmi0GLbUtWZZFlvWWj60oVn5W+Va1VnessdYM6xzrndZdNrCNmw3fpsbmli1s624rsN1p222HsfO0E9rV2t2zJ9sz7Qvt6+37HGgOkQ4rHZod3kw3m546fdP0junfHd0ccx33OT5y0nAKd1rp1Or0ztnGmeNc43zHheIS4rLMpcXlrautK891l+t9N6pblNtqt3a3b+4e7mL3BvchDzOPdI8dHvcYmowYxjrGVU+MZ4DnMs8znp+93L0KvE54/eFt753jfdh7cIblDN6MfTP6fUx82D57fGS+dN903598ZX7Gfmy/Wr9n/qb+XP8D/i+Y1sxs5hHmmwDHAHHAqYDRQK/AJYFtQaig0KCyoM5gjeCE4OrgpyEmIVkh9SHDoW6hi0PbwjBhEWGbwu6xDFgcVh1rONwjfEn4pQhyRFxEdcSzSJtIcWRrFBwVHrU56vFM85nCmc3RIJoVvTn6SYxlTH7ML7Ows2Jm1cx6HusUWxzbEUeNmxd3OO5jfED8hvhHCVYJ0oT2RNXEtMS6xNGkoKSKJFny9OQlyTdSdFMEKS2puNTE1AOpI7ODZ2+dPZDmllaadneO5ZyFc67N1Z2bO/fsPNV57Hkn0zHpSemH07+yo9m17JEMVsaOjGFOIGcb5xXXn7uFO8Tz4VXwXmT6ZFZkDmb5ZG3OGuL78Sv5rwWBgmrB2+yw7N3ZoznROQdz5LlJuY15+Lz0vNNCDWGO8NJ8w/kL53eLbEWlIlm+V/7W/GFxhPiABJLMkbQUaCIi6abUSvqDtK/Qt7Cm8NOCxAUnF6ovFC68uchm0dpFL4pCivYvRi/mLG4vNi5eUdy3hLlkz1JoacbS9mWmy0qWDSwPXX5oBXFFzopfVzqurFj5YVXSqtYSg5LlJf0/hP5QX6pSKi69t9p79e416DWCNZ1rXdZuX/u9jFt2vdyxvLL86zrOuus/Ov1Y9aN8feb6zg3uG3ZtxG4Ubry7yW/ToQr1iqKK/s1Rm5u20LeUbfmwdd7Wa5Wulbu3EbdJt8mqIqtatptt37j9azW/urcmoKZxh/6OtTtGd3J39uzy39Ww22B3+e4vPwl+ur8ndE9TrUVt5V7s3sK9z/cl7uvYz9hfd0D3QPmBbweFB2WHYg9dqvOoqzusf3hDPVwvrR86knak62jQ0ZYG+4Y9jbTG8mPgmPTYy+Ppx++eiDjRfpJxsuFn8593nKKeKmuCmhY1DTfzm2UtKS3dp8NPt7d6t576xeGXg2eMz9Sc1Tq74RzxXMk5+fmi8yNtorbXF7Iu9LfPa390MfninUuzLnVejrh89UrIlYsdzI7zV32unrnmde30dcb15hvuN5puut089avbr6c63Tubbnncauny7GrtntF9rsev58LtoNtX7rDu3Oid2dt9N+Hu/Xtp92T3ufcHH+Q+ePuw8OHYo+WPMY/Lnqg9qXyq/7T2N+vfGmXusrN9QX03n8U9e9TP6X/1u+T3rwMlzynPK18YvagbdB48MxQy1PVy9suBV6JXY69L/6H+jx1vrN78/If/HzeHk4cH3orfyt+te6/z/uAH1w/tIzEjTz/mfRwbLfuk8+nQZ8bnji9JX16MLfiK+1r1zfpb6/eI74/leXK5iC1mj0sBFDLgzEwA3h1EtHEKAFRElxNnT2jrcYMmvgfGCfwnntDf4+YOQAMyKWQR0x+Akwo5i8wqyKyQRPH+AHZxUY5/mSTTxXkiFxlRlphPcvl7AwBwrQB8E8vlYzvl8m/7kGIfANCWP6HpFYZFtHyD3vJRg6LbPe3g7zah9//U499noKjAFfx9/ieoZhkWVvYkwwAAAGxlWElmTU0AKgAAAAgABAEaAAUAAAABAAAAPgEbAAUAAAABAAAARgEoAAMAAAABAAIAAIdpAAQAAAABAAAATgAAAAAAAACQAAAAAQAAAJAAAAABAAKgAgAEAAAAAQAAAEKgAwAEAAAAAQAAAEIAAAAAgodoEQAAAAlwSFlzAAAWJQAAFiUBSVIk8AAABMtJREFUeAHtXM2KFDEQzrQKruIu4mEXRFlUVLz4A4K7B99AcO8io0/gwQfxDVzFuwu+gQf34EG8iOAPKAh6EFlBFMSf/qa2uqszlVR6ZtYxM5PDJNVVSer78nU6KrHzpyxuVlwx44AY2O0T8eb9D7f5fMu9fPvdff7y0/36nbdgdhUdd+jgHnf62JxbObvgjh/d60Pu2R35ajx49Mk9frqlBk7Kw8sXF9y1K4t9cCoi7tz/4F68/tYXMIkPzpzY725dP9yA1tsjoIRpIQHogRWYZSmwJ4Reh06nI2Nd7rYEA8zAzqXAxhgq/pc1d9vHKbEX+Dr4JbzypJDc/YxXYi/wifRLeOXpU5q7n/FK7EXsnBBeeRoqd7/EHj1ZhleeiMjdz8pArRKR+0pb+UsCuK0SkftKW/kzeFmrRHCAxWzufsaJOkqExWzufpOI8EpP1jnCJCK80pN1jjCJ4ICwMigidz/jRD3bI7bZUInIfaWt/KUSuK0SEd4jqFvufgYva5UIDrCYzd3POFFHifhfV/7k8lwPw7D5mUSEV3r854ju2pK7ffOIWzk/X+Go803Lr+ooGqoiwkyP9xzRXVt0q9sE3CgJYTLqfNPyE/irpkoEe2um6ck4bSiBSeD8JBl41jY/Hgd1lIiaaeoyLlsjgUGAjEH3DB4DtUpEW2Z3Mj5GAgA8efbVvXpX/200nln5IMYvKhHDrvylcwdc9+pSNdeg46WQsP7wo2s7fpWYaPT926fw9ZiVk4BpywYJkGuvlJs4EuWS0p/HTyHh3kbzH2najM85cR0lgpPiYMtukFB26m1u5Ua+vkFkWP3Zn0KCJDg1Px6f42Wtvhrhdyz8ncanrFKCmGH1wrwDMCrh/uxPIUFTAvdHbeVPsc1fVRE+c7Ud/k6fWt7XHFlYqcqQ5wTRvWpiY4wrIZwfDUL+akDRUBXB/jCzFCH9SHCzTDRUmsro7z+cEvrHwxOZn2ZTL/pVFcEBtRLoiWXfxQ5ehvoHHx4vpIwUEuJKSMvPz5/zQq0qwmIy5m+rjBQSwnsCQYnlgwjfT72av6oifOba2qnKcOXeGVIP0rT3BALTNr8mBWSpRHAgmJSTtLGhDHwj+A9GPCbX2DNiBSRoShg0H8zl5y/njxIhJ0WntralDJmIbO+UEvz85Zwt9wj7HIDB5Ttp7RkyGbRDSqC49vOjX50P9aexmr+qInzmajvtO13H02SpyrCVMNj8dT7/4BwByDXzRIC0LWXEldA/njVfip9GpV9VERxQM0lPhrVDyrCVMJr5/fwZJ+qWewR1lSuNJ21sXxnjVgIhck5VhM/cqG1WBpIAMX4Z9Xz+eP58sFUiOBArLQcZpQ0CNCXt1HzA5OfPOFGrrwYHyKTwbNJsxolaJUJbKeo0mu/4uMeXBHBbJSK88qP5jo97fAYva5UIDgivHEXk7mecqKNEhFeOhsjdbxKR+0pb+UsCuK0qIveVtvJn8LJWieAAi9nc/YwTdZQIi9nc/SYR4ZWenSO2yZvgcwTuRYZKWBnUI3e/xF7gcmio5L4HWPlL7AVuyPol95W28me8EnuBa8J+sZjM3c94JfYCd6VxTXjaCjDLe+K9cwTuSuOa8LQUYPXvh1d3w0HC7JK8kMK0/rcJfwHkVMYgi4xhOgAAAABJRU5ErkJggg==");background-size:100%}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="a11y-light">.hljs-comment,.hljs-quote{color:#696969}.hljs-deletion,.hljs-name,.hljs-regexp,.hljs-selector-class,.hljs-selector-id,.hljs-tag,.hljs-template-variable,.hljs-variable{color:#d91e18}.hljs-attribute,.hljs-built_in,.hljs-builtin-name,.hljs-link,.hljs-literal,.hljs-meta,.hljs-number,.hljs-params,.hljs-type{color:#aa5d00}.hljs-addition,.hljs-bullet,.hljs-string,.hljs-symbol{color:green}.hljs-section,.hljs-title{color:#007faa}.hljs-keyword,.hljs-selector-tag{color:#7928a1}.markdown-body pre,.markdown-body pre&gt;code.hljs{background:#fefefe;color:#545454}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}@media screen and (-ms-high-contrast:active){.hljs-addition,.hljs-attribute,.hljs-built_in,.hljs-builtin-name,.hljs-bullet,.hljs-comment,.hljs-link,.hljs-literal,.hljs-meta,.hljs-number,.hljs-params,.hljs-quote,.hljs-string,.hljs-symbol,.hljs-type{color:highlight}.hljs-keyword,.hljs-selector-tag{font-weight:700}}</style><h2 data-id="heading-0">一、协程：异步编程的基础单元</h2>
<h3 data-id="heading-1">理解协程对象</h3>
<p>协程是可暂停和恢复的函数，使用<code>async def</code>定义：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> asyncio
<span class="hljs-keyword">import</span> time
<span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">Coroutine</span>

<span class="hljs-comment"># 基础协程</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">simple_coroutine</span>(<span class="hljs-params">name: <span class="hljs-built_in">str</span>, delay: <span class="hljs-built_in">float</span></span>) -&gt; <span class="hljs-built_in">str</span>:
    <span class="hljs-string">"""一个简单的协程"""</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"<span class="hljs-subst">{name}</span>: 开始执行，等待 <span class="hljs-subst">{delay}</span> 秒"</span>)
    <span class="hljs-keyword">await</span> asyncio.sleep(delay)  <span class="hljs-comment"># 非阻塞等待</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"<span class="hljs-subst">{name}</span>: 执行完成"</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-string">f"<span class="hljs-subst">{name}</span>-结果"</span>

<span class="hljs-comment"># 协程的三种状态</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">coroutine_lifecycle</span>():
    <span class="hljs-string">"""演示协程的生命周期"""</span>
    coro = simple_coroutine(<span class="hljs-string">"测试"</span>, <span class="hljs-number">1.0</span>)
    
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"协程类型: <span class="hljs-subst">{<span class="hljs-built_in">type</span>(coro)}</span>"</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"是协程对象: <span class="hljs-subst">{asyncio.iscoroutine(coro)}</span>"</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"是协程函数: <span class="hljs-subst">{asyncio.iscoroutinefunction(simple_coroutine)}</span>"</span>)
    
    <span class="hljs-comment"># 协程的状态</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"初始状态: <span class="hljs-subst">{coro.cr_running}</span>"</span>)  <span class="hljs-comment"># False，尚未运行</span>
    
    <span class="hljs-comment"># 运行协程</span>
    task = asyncio.create_task(coro)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"创建任务后: <span class="hljs-subst">{task._state}</span>"</span>)  <span class="hljs-comment"># 'PENDING'</span>
    
    <span class="hljs-keyword">await</span> task
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"完成后: <span class="hljs-subst">{task._state}</span>"</span>)  <span class="hljs-comment"># 'FINISHED'</span>

<span class="hljs-comment"># 手动控制协程执行</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">manual_coroutine_control</span>():
    <span class="hljs-string">"""手动控制协程执行（不推荐在生产中使用）"""</span>
    coro = simple_coroutine(<span class="hljs-string">"手动控制"</span>, <span class="hljs-number">0.5</span>)
    
    <span class="hljs-keyword">try</span>:
        <span class="hljs-comment"># 手动推进协程</span>
        coro.send(<span class="hljs-literal">None</span>)  <span class="hljs-comment"># 或 next(coro)，启动协程</span>
    <span class="hljs-keyword">except</span> StopIteration <span class="hljs-keyword">as</span> e:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"协程返回值: <span class="hljs-subst">{e.value}</span>"</span>)
    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"协程异常: <span class="hljs-subst">{e}</span>"</span>)

<span class="hljs-comment"># 运行</span>
asyncio.run(coroutine_lifecycle())
</code></pre>
<h2 data-id="heading-2">二、任务：并发执行的管理器</h2>
<h3 data-id="heading-3">任务的创建与取消</h3>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> asyncio
<span class="hljs-keyword">from</span> asyncio <span class="hljs-keyword">import</span> Task, CancelledError
<span class="hljs-keyword">import</span> signal

<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">cancellable_task</span>(<span class="hljs-params">name: <span class="hljs-built_in">str</span>, duration: <span class="hljs-built_in">float</span></span>) -&gt; <span class="hljs-built_in">str</span>:
    <span class="hljs-string">"""可取消的任务"""</span>
    <span class="hljs-keyword">try</span>:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"<span class="hljs-subst">{name}</span>: 开始长时间运行"</span>)
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">int</span>(duration * <span class="hljs-number">10</span>)):
            <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">0.1</span>)
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"<span class="hljs-subst">{name}</span>: 进度 <span class="hljs-subst">{i+<span class="hljs-number">1</span>}</span>/10"</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-string">f"<span class="hljs-subst">{name}</span>: 完成"</span>
    <span class="hljs-keyword">except</span> CancelledError:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"<span class="hljs-subst">{name}</span>: 被取消"</span>)
        <span class="hljs-keyword">raise</span>  <span class="hljs-comment"># 重新抛出以便调用者知道</span>
    <span class="hljs-keyword">finally</span>:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"<span class="hljs-subst">{name}</span>: 清理资源"</span>)

<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">task_management</span>():
    <span class="hljs-string">"""任务管理示例"""</span>
    <span class="hljs-comment"># 创建多个任务</span>
    task1 = asyncio.create_task(cancellable_task(<span class="hljs-string">"任务1"</span>, <span class="hljs-number">2.0</span>))
    task2 = asyncio.create_task(cancellable_task(<span class="hljs-string">"任务2"</span>, <span class="hljs-number">3.0</span>))
    task3 = asyncio.create_task(cancellable_task(<span class="hljs-string">"任务3"</span>, <span class="hljs-number">1.0</span>))
    
    <span class="hljs-comment"># 等待一段时间后取消任务2</span>
    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1.5</span>)
    
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> task2.done():
        task2.cancel()
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"已取消任务2"</span>)
    
    <span class="hljs-comment"># 收集结果</span>
    done, pending = <span class="hljs-keyword">await</span> asyncio.wait(
        [task1, task2, task3],
        timeout=<span class="hljs-number">2.0</span>,
        return_when=asyncio.FIRST_COMPLETED
    )
    
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"完成的任务数: <span class="hljs-subst">{<span class="hljs-built_in">len</span>(done)}</span>"</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"挂起的任务数: <span class="hljs-subst">{<span class="hljs-built_in">len</span>(pending)}</span>"</span>)
    
    <span class="hljs-comment"># 处理结果</span>
    <span class="hljs-keyword">for</span> task <span class="hljs-keyword">in</span> done:
        <span class="hljs-keyword">if</span> task.exception():
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"任务异常: <span class="hljs-subst">{task.exception()}</span>"</span>)
        <span class="hljs-keyword">else</span>:
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"任务结果: <span class="hljs-subst">{task.result()}</span>"</span>)
    
    <span class="hljs-comment"># 取消剩余任务</span>
    <span class="hljs-keyword">for</span> task <span class="hljs-keyword">in</span> pending:
        task.cancel()

<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">timeout_handling</span>():
    <span class="hljs-string">"""超时处理"""</span>
    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">slow_operation</span>():
        <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">5</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-string">"慢操作完成"</span>
    
    <span class="hljs-keyword">try</span>:
        <span class="hljs-comment"># 方式1：asyncio.wait_for</span>
        result = <span class="hljs-keyword">await</span> asyncio.wait_for(slow_operation(), timeout=<span class="hljs-number">2.0</span>)
        <span class="hljs-built_in">print</span>(result)
    <span class="hljs-keyword">except</span> asyncio.TimeoutError:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"操作超时"</span>)
    
    <span class="hljs-comment"># 方式2：asyncio.shield（防止取消）</span>
    task = asyncio.create_task(slow_operation())
    <span class="hljs-keyword">try</span>:
        result = <span class="hljs-keyword">await</span> asyncio.wait_for(asyncio.shield(task), timeout=<span class="hljs-number">2.0</span>)
    <span class="hljs-keyword">except</span> asyncio.TimeoutError:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"等待超时，但后台任务继续运行"</span>)
        <span class="hljs-comment"># 检查后台任务状态</span>
        <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">3</span>)
        <span class="hljs-keyword">if</span> task.done():
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"后台任务最终结果: <span class="hljs-subst">{task.result()}</span>"</span>)

<span class="hljs-comment"># 运行</span>
asyncio.run(timeout_handling())
</code></pre>
<h2 data-id="heading-4">三、异步上下文管理器与迭代器</h2>
<h3 data-id="heading-5"><code>async with</code>和<code>async for</code></h3>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> asyncio
<span class="hljs-keyword">import</span> aiohttp
<span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> AsyncIterator, <span class="hljs-type">List</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">AsyncConnectionPool</span>:
    <span class="hljs-string">"""异步连接池"""</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, pool_size: <span class="hljs-built_in">int</span> = <span class="hljs-number">5</span></span>):
        self.pool_size = pool_size
        self._connections: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>] = []
        self._semaphore = asyncio.Semaphore(pool_size)
    
    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">__aenter__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"初始化连接池"</span>)
        <span class="hljs-comment"># 模拟建立连接</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.pool_size):
            <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">0.1</span>)
            self._connections.append(<span class="hljs-string">f"连接-<span class="hljs-subst">{i+<span class="hljs-number">1</span>}</span>"</span>)
        <span class="hljs-keyword">return</span> self
    
    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">__aexit__</span>(<span class="hljs-params">self, exc_type, exc_val, exc_tb</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"清理连接池"</span>)
        <span class="hljs-comment"># 模拟关闭连接</span>
        <span class="hljs-keyword">for</span> conn <span class="hljs-keyword">in</span> self._connections:
            <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">0.05</span>)
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"关闭 <span class="hljs-subst">{conn}</span>"</span>)
        self._connections.clear()
    
    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">acquire</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">str</span>:
        <span class="hljs-string">"""获取连接"""</span>
        <span class="hljs-keyword">await</span> self._semaphore.acquire()
        conn = self._connections.pop()
        <span class="hljs-keyword">return</span> conn
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">release</span>(<span class="hljs-params">self, conn: <span class="hljs-built_in">str</span></span>):
        <span class="hljs-string">"""释放连接"""</span>
        self._connections.append(conn)
        self._semaphore.release()
    
    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">execute_query</span>(<span class="hljs-params">self, query: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:
        <span class="hljs-string">"""执行查询"""</span>
        conn = <span class="hljs-keyword">await</span> self.acquire()
        <span class="hljs-keyword">try</span>:
            <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">0.5</span>)  <span class="hljs-comment"># 模拟查询</span>
            <span class="hljs-keyword">return</span> <span class="hljs-string">f"<span class="hljs-subst">{conn}</span>: 执行 '<span class="hljs-subst">{query}</span>' 的结果"</span>
        <span class="hljs-keyword">finally</span>:
            self.release(conn)

<span class="hljs-keyword">class</span> <span class="hljs-title class_">AsyncDataStream</span>:
    <span class="hljs-string">"""异步数据流"""</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, data: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>], delay: <span class="hljs-built_in">float</span> = <span class="hljs-number">0.1</span></span>):
        self.data = data
        self.delay = delay
        self.index = <span class="hljs-number">0</span>
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__aiter__</span>(<span class="hljs-params">self</span>) -&gt; AsyncIterator[<span class="hljs-built_in">str</span>]:
        <span class="hljs-keyword">return</span> self
    
    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">__anext__</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">str</span>:
        <span class="hljs-keyword">if</span> self.index &gt;= <span class="hljs-built_in">len</span>(self.data):
            <span class="hljs-keyword">raise</span> StopAsyncIteration
        
        item = self.data[self.index]
        self.index += <span class="hljs-number">1</span>
        
        <span class="hljs-comment"># 模拟异步获取数据</span>
        <span class="hljs-keyword">await</span> asyncio.sleep(self.delay)
        <span class="hljs-keyword">return</span> <span class="hljs-string">f"处理: <span class="hljs-subst">{item}</span>"</span>

<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">async_context_example</span>():
    <span class="hljs-string">"""异步上下文管理器示例"""</span>
    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> AsyncConnectionPool(<span class="hljs-number">3</span>) <span class="hljs-keyword">as</span> pool:
        tasks = []
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):
            query = <span class="hljs-string">f"SELECT * FROM table<span class="hljs-subst">{i}</span>"</span>
            task = asyncio.create_task(pool.execute_query(query))
            tasks.append(task)
        
        results = <span class="hljs-keyword">await</span> asyncio.gather(*tasks, return_exceptions=<span class="hljs-literal">True</span>)
        <span class="hljs-keyword">for</span> result <span class="hljs-keyword">in</span> results:
            <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(result, Exception):
                <span class="hljs-built_in">print</span>(<span class="hljs-string">f"查询失败: <span class="hljs-subst">{result}</span>"</span>)
            <span class="hljs-keyword">else</span>:
                <span class="hljs-built_in">print</span>(result)

<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">async_iter_example</span>():
    <span class="hljs-string">"""异步迭代器示例"""</span>
    data = [<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>, <span class="hljs-string">"C"</span>, <span class="hljs-string">"D"</span>, <span class="hljs-string">"E"</span>]
    stream = AsyncDataStream(data, delay=<span class="hljs-number">0.2</span>)
    
    <span class="hljs-comment"># 方式1：直接使用async for</span>
    <span class="hljs-keyword">async</span> <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> stream:
        <span class="hljs-built_in">print</span>(item)
    
    <span class="hljs-comment"># 方式2：使用anext()</span>
    stream2 = AsyncDataStream(data)
    <span class="hljs-keyword">try</span>:
        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
            item = <span class="hljs-keyword">await</span> anext(stream2)  <span class="hljs-comment"># Python 3.10+</span>
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"手动获取: <span class="hljs-subst">{item}</span>"</span>)
    <span class="hljs-keyword">except</span> StopAsyncIteration:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"迭代结束"</span>)
    
    <span class="hljs-comment"># 方式3：异步推导式</span>
    stream3 = AsyncDataStream(data)
    processed = [item <span class="hljs-keyword">async</span> <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> stream3]
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"异步推导式结果: <span class="hljs-subst">{processed}</span>"</span>)

<span class="hljs-comment"># 运行</span>
asyncio.run(async_iter_example())
</code></pre>
<h2 data-id="heading-6">四、信号量与高级并发控制</h2>
<h3 data-id="heading-7">限制并发数</h3>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> asyncio
<span class="hljs-keyword">from</span> asyncio <span class="hljs-keyword">import</span> Semaphore, BoundedSemaphore, Lock, Event, Condition
<span class="hljs-keyword">import</span> random

<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">worker</span>(<span class="hljs-params">semaphore: Semaphore, name: <span class="hljs-built_in">str</span>, work_time: <span class="hljs-built_in">float</span></span>):
    <span class="hljs-string">"""使用信号量控制的工作器"""</span>
    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> semaphore:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"<span class="hljs-subst">{name}</span>: 获取信号量，开始工作"</span>)
        <span class="hljs-keyword">await</span> asyncio.sleep(work_time)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"<span class="hljs-subst">{name}</span>: 完成工作，释放信号量"</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-string">f"<span class="hljs-subst">{name}</span>-完成"</span>

<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">semaphore_example</span>():
    <span class="hljs-string">"""信号量示例：限制最多3个并发任务"""</span>
    semaphore = Semaphore(<span class="hljs-number">3</span>)
    
    tasks = []
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):
        work_time = random.uniform(<span class="hljs-number">0.5</span>, <span class="hljs-number">2.0</span>)
        task = asyncio.create_task(worker(semaphore, <span class="hljs-string">f"Worker-<span class="hljs-subst">{i}</span>"</span>, work_time))
        tasks.append(task)
    
    <span class="hljs-keyword">await</span> asyncio.gather(*tasks)

<span class="hljs-keyword">class</span> <span class="hljs-title class_">AsyncRateLimiter</span>:
    <span class="hljs-string">"""异步速率限制器"""</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, rate: <span class="hljs-built_in">float</span></span>):
        self.rate = rate  <span class="hljs-comment"># 每秒最多调用次数</span>
        self._tokens = rate
        self._last_update = asyncio.get_event_loop().time()
        self._lock = Lock()
    
    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">acquire</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> self._lock:
            now = asyncio.get_event_loop().time()
            elapsed = now - self._last_update
            
            <span class="hljs-comment"># 添加令牌</span>
            self._tokens = <span class="hljs-built_in">min</span>(self.rate, self._tokens + elapsed * self.rate)
            self._last_update = now
            
            <span class="hljs-keyword">if</span> self._tokens &gt;= <span class="hljs-number">1</span>:
                self._tokens -= <span class="hljs-number">1</span>
                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
            <span class="hljs-keyword">else</span>:
                <span class="hljs-comment"># 等待足够的令牌</span>
                wait_time = (<span class="hljs-number">1</span> - self._tokens) / self.rate
                <span class="hljs-keyword">await</span> asyncio.sleep(wait_time)
                self._tokens = <span class="hljs-number">0</span>
                self._last_update = asyncio.get_event_loop().time()
                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>

<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">rate_limiter_example</span>():
    <span class="hljs-string">"""速率限制器示例"""</span>
    limiter = AsyncRateLimiter(rate=<span class="hljs-number">2.0</span>)  <span class="hljs-comment"># 每秒最多2次</span>
    
    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">make_request</span>(<span class="hljs-params">name: <span class="hljs-built_in">str</span></span>):
        <span class="hljs-keyword">await</span> limiter.acquire()
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"<span class="hljs-subst">{time.strftime(<span class="hljs-string">'%H:%M:%S'</span>)}</span> <span class="hljs-subst">{name}</span>: 发送请求"</span>)
        <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">0.1</span>)
    
    tasks = []
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):
        task = asyncio.create_task(make_request(<span class="hljs-string">f"Req-<span class="hljs-subst">{i}</span>"</span>))
        tasks.append(task)
        <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">0.1</span>)  <span class="hljs-comment"># 模拟请求间隔</span>
    
    <span class="hljs-keyword">await</span> asyncio.gather(*tasks)

<span class="hljs-keyword">class</span> <span class="hljs-title class_">AsyncPipeline</span>:
    <span class="hljs-string">"""异步处理管道"""</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        self._queue = asyncio.Queue(maxsize=<span class="hljs-number">10</span>)
        self._event = Event()
        self._condition = Condition()
        self._workers = []
    
    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">producer</span>(<span class="hljs-params">self, name: <span class="hljs-built_in">str</span>, count: <span class="hljs-built_in">int</span></span>):
        <span class="hljs-string">"""生产者协程"""</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(count):
            item = <span class="hljs-string">f"<span class="hljs-subst">{name}</span>-项目<span class="hljs-subst">{i}</span>"</span>
            <span class="hljs-keyword">await</span> self._queue.put(item)
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"生产者 <span class="hljs-subst">{name}</span>: 生产 <span class="hljs-subst">{item}</span>"</span>)
            <span class="hljs-keyword">await</span> asyncio.sleep(random.uniform(<span class="hljs-number">0.1</span>, <span class="hljs-number">0.3</span>))
        
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"生产者 <span class="hljs-subst">{name}</span>: 完成"</span>)
    
    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">consumer</span>(<span class="hljs-params">self, name: <span class="hljs-built_in">str</span></span>):
        <span class="hljs-string">"""消费者协程"""</span>
        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
            <span class="hljs-keyword">try</span>:
                item = <span class="hljs-keyword">await</span> asyncio.wait_for(self._queue.get(), timeout=<span class="hljs-number">2.0</span>)
                <span class="hljs-built_in">print</span>(<span class="hljs-string">f"消费者 <span class="hljs-subst">{name}</span>: 处理 <span class="hljs-subst">{item}</span>"</span>)
                <span class="hljs-keyword">await</span> asyncio.sleep(random.uniform(<span class="hljs-number">0.2</span>, <span class="hljs-number">0.5</span>))
                self._queue.task_done()
            <span class="hljs-keyword">except</span> asyncio.TimeoutError:
                <span class="hljs-built_in">print</span>(<span class="hljs-string">f"消费者 <span class="hljs-subst">{name}</span>: 超时，退出"</span>)
                <span class="hljs-keyword">break</span>
    
    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self, producer_count: <span class="hljs-built_in">int</span> = <span class="hljs-number">3</span>, consumer_count: <span class="hljs-built_in">int</span> = <span class="hljs-number">2</span></span>):
        <span class="hljs-string">"""运行管道"""</span>
        <span class="hljs-comment"># 创建生产者</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(producer_count):
            task = asyncio.create_task(self.producer(<span class="hljs-string">f"P<span class="hljs-subst">{i}</span>"</span>, <span class="hljs-number">5</span>))
            self._workers.append(task)
        
        <span class="hljs-comment"># 创建消费者</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(consumer_count):
            task = asyncio.create_task(self.consumer(<span class="hljs-string">f"C<span class="hljs-subst">{i}</span>"</span>))
            self._workers.append(task)
        
        <span class="hljs-comment"># 等待所有生产者完成</span>
        <span class="hljs-keyword">await</span> asyncio.gather(*self._workers[:producer_count])
        
        <span class="hljs-comment"># 等待队列清空</span>
        <span class="hljs-keyword">await</span> self._queue.join()
        
        <span class="hljs-comment"># 取消消费者</span>
        <span class="hljs-keyword">for</span> task <span class="hljs-keyword">in</span> self._workers[producer_count:]:
            task.cancel()
        
        <span class="hljs-comment"># 等待所有任务完成</span>
        <span class="hljs-keyword">await</span> asyncio.gather(*self._workers, return_exceptions=<span class="hljs-literal">True</span>)

<span class="hljs-comment"># 运行</span>
asyncio.run(AsyncPipeline().run())
</code></pre>
<h2 data-id="heading-8">五、异步IO与网络编程</h2>
<h3 data-id="heading-9">aiohttp和异步数据库</h3>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> asyncio
<span class="hljs-keyword">import</span> aiohttp
<span class="hljs-keyword">import</span> asyncpg
<span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">List</span>, <span class="hljs-type">Dict</span>, <span class="hljs-type">Any</span>
<span class="hljs-keyword">import</span> json

<span class="hljs-keyword">class</span> <span class="hljs-title class_">AsyncWebScraper</span>:
    <span class="hljs-string">"""异步网页抓取器"""</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, concurrency_limit: <span class="hljs-built_in">int</span> = <span class="hljs-number">10</span></span>):
        self.semaphore = Semaphore(concurrency_limit)
        self.session = <span class="hljs-literal">None</span>
    
    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">__aenter__</span>(<span class="hljs-params">self</span>):
        self.session = aiohttp.ClientSession()
        <span class="hljs-keyword">return</span> self
    
    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">__aexit__</span>(<span class="hljs-params">self, exc_type, exc_val, exc_tb</span>):
        <span class="hljs-keyword">if</span> self.session:
            <span class="hljs-keyword">await</span> self.session.close()
    
    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">fetch_url</span>(<span class="hljs-params">self, url: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-type">Dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-type">Any</span>]:
        <span class="hljs-string">"""获取单个URL"""</span>
        <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> self.semaphore:
            <span class="hljs-keyword">try</span>:
                <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> self.session.get(url, timeout=<span class="hljs-number">10</span>) <span class="hljs-keyword">as</span> response:
                    text = <span class="hljs-keyword">await</span> response.text()
                    <span class="hljs-keyword">return</span> {
                        <span class="hljs-string">'url'</span>: url,
                        <span class="hljs-string">'status'</span>: response.status,
                        <span class="hljs-string">'size'</span>: <span class="hljs-built_in">len</span>(text),
                        <span class="hljs-string">'content'</span>: text[:<span class="hljs-number">100</span>]  <span class="hljs-comment"># 只取前100字符</span>
                    }
            <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
                <span class="hljs-keyword">return</span> {<span class="hljs-string">'url'</span>: url, <span class="hljs-string">'error'</span>: <span class="hljs-built_in">str</span>(e)}
    
    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">fetch_multiple</span>(<span class="hljs-params">self, urls: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">Dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-type">Any</span>]]:
        <span class="hljs-string">"""并发获取多个URL"""</span>
        tasks = [self.fetch_url(url) <span class="hljs-keyword">for</span> url <span class="hljs-keyword">in</span> urls]
        results = <span class="hljs-keyword">await</span> asyncio.gather(*tasks, return_exceptions=<span class="hljs-literal">True</span>)
        
        processed = []
        <span class="hljs-keyword">for</span> result <span class="hljs-keyword">in</span> results:
            <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(result, Exception):
                processed.append({<span class="hljs-string">'error'</span>: <span class="hljs-built_in">str</span>(result)})
            <span class="hljs-keyword">else</span>:
                processed.append(result)
        
        <span class="hljs-keyword">return</span> processed

<span class="hljs-keyword">class</span> <span class="hljs-title class_">AsyncDatabase</span>:
    <span class="hljs-string">"""异步数据库操作"""</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, dsn: <span class="hljs-built_in">str</span></span>):
        self.dsn = dsn
        self.pool = <span class="hljs-literal">None</span>
    
    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">connect</span>(<span class="hljs-params">self, pool_size: <span class="hljs-built_in">int</span> = <span class="hljs-number">10</span></span>):
        <span class="hljs-string">"""创建连接池"""</span>
        self.pool = <span class="hljs-keyword">await</span> asyncpg.create_pool(
            self.dsn,
            min_size=<span class="hljs-number">1</span>,
            max_size=pool_size,
            command_timeout=<span class="hljs-number">60</span>
        )
    
    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">close</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">"""关闭连接池"""</span>
        <span class="hljs-keyword">if</span> self.pool:
            <span class="hljs-keyword">await</span> self.pool.close()
    
    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">batch_insert</span>(<span class="hljs-params">self, table: <span class="hljs-built_in">str</span>, records: <span class="hljs-type">List</span>[<span class="hljs-type">Dict</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:
        <span class="hljs-string">"""批量插入数据"""</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> records:
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
        
        <span class="hljs-comment"># 准备数据</span>
        columns = records[<span class="hljs-number">0</span>].keys()
        values = [<span class="hljs-built_in">tuple</span>(record[col] <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> columns) <span class="hljs-keyword">for</span> record <span class="hljs-keyword">in</span> records]
        
        <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> self.pool.acquire() <span class="hljs-keyword">as</span> conn:
            <span class="hljs-comment"># 开始事务</span>
            <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> conn.transaction():
                stmt = <span class="hljs-keyword">await</span> conn.prepare(<span class="hljs-string">f"""
                    INSERT INTO <span class="hljs-subst">{table}</span> (<span class="hljs-subst">{<span class="hljs-string">','</span>.join(columns)}</span>)
                    VALUES (<span class="hljs-subst">{<span class="hljs-string">','</span>.join(<span class="hljs-string">f'$<span class="hljs-subst">{i+<span class="hljs-number">1</span>}</span>'</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(columns)))}</span>)
                """</span>)
                
                <span class="hljs-comment"># 批量执行</span>
                <span class="hljs-keyword">await</span> stmt.executemany(values)
                <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(values)
    
    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">concurrent_queries</span>(<span class="hljs-params">self, queries: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-type">Dict</span>]]:
        <span class="hljs-string">"""并发执行查询"""</span>
        <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">execute_query</span>(<span class="hljs-params">query: <span class="hljs-built_in">str</span></span>):
            <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> self.pool.acquire() <span class="hljs-keyword">as</span> conn:
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> conn.fetch(query)
        
        tasks = [execute_query(query) <span class="hljs-keyword">for</span> query <span class="hljs-keyword">in</span> queries]
        results = <span class="hljs-keyword">await</span> asyncio.gather(*tasks, return_exceptions=<span class="hljs-literal">True</span>)
        
        processed = []
        <span class="hljs-keyword">for</span> result <span class="hljs-keyword">in</span> results:
            <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(result, Exception):
                processed.append({<span class="hljs-string">'error'</span>: <span class="hljs-built_in">str</span>(result)})
            <span class="hljs-keyword">else</span>:
                processed.append([<span class="hljs-built_in">dict</span>(record) <span class="hljs-keyword">for</span> record <span class="hljs-keyword">in</span> result])
        
        <span class="hljs-keyword">return</span> processed

<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">web_scraper_example</span>():
    <span class="hljs-string">"""网页抓取示例"""</span>
    urls = [
        <span class="hljs-string">'https://httpbin.org/get'</span>,
        <span class="hljs-string">'https://httpbin.org/delay/1'</span>,
        <span class="hljs-string">'https://httpbin.org/delay/2'</span>,
        <span class="hljs-string">'https://httpbin.org/status/404'</span>,
        <span class="hljs-string">'https://nonexistent.example.com'</span>,
    ]
    
    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> AsyncWebScraper(concurrency_limit=<span class="hljs-number">3</span>) <span class="hljs-keyword">as</span> scraper:
        results = <span class="hljs-keyword">await</span> scraper.fetch_multiple(urls * <span class="hljs-number">2</span>)  <span class="hljs-comment"># 重复URL测试去重</span>
        
        <span class="hljs-keyword">for</span> result <span class="hljs-keyword">in</span> results:
            <span class="hljs-keyword">if</span> <span class="hljs-string">'error'</span> <span class="hljs-keyword">in</span> result:
                <span class="hljs-built_in">print</span>(<span class="hljs-string">f"错误: <span class="hljs-subst">{result[<span class="hljs-string">'url'</span>]}</span> - <span class="hljs-subst">{result[<span class="hljs-string">'error'</span>]}</span>"</span>)
            <span class="hljs-keyword">else</span>:
                <span class="hljs-built_in">print</span>(<span class="hljs-string">f"成功: <span class="hljs-subst">{result[<span class="hljs-string">'url'</span>]}</span> - 状态: <span class="hljs-subst">{result[<span class="hljs-string">'status'</span>]}</span>"</span>)

<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">database_example</span>():
    <span class="hljs-string">"""数据库示例（需要PostgreSQL数据库）"""</span>
    <span class="hljs-comment"># 注意：实际使用时需要替换为真实的数据库连接信息</span>
    dsn = <span class="hljs-string">"postgresql://user:password@localhost/dbname"</span>
    
    db = AsyncDatabase(dsn)
    <span class="hljs-keyword">try</span>:
        <span class="hljs-keyword">await</span> db.connect()
        
        <span class="hljs-comment"># 创建测试表</span>
        <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> db.pool.acquire() <span class="hljs-keyword">as</span> conn:
            <span class="hljs-keyword">await</span> conn.execute(<span class="hljs-string">'''
                CREATE TABLE IF NOT EXISTS test_users (
                    id SERIAL PRIMARY KEY,
                    name TEXT NOT NULL,
                    age INTEGER,
                    created_at TIMESTAMP DEFAULT NOW()
                )
            '''</span>)
        
        <span class="hljs-comment"># 批量插入</span>
        users = [
            {<span class="hljs-string">'name'</span>: <span class="hljs-string">'Alice'</span>, <span class="hljs-string">'age'</span>: <span class="hljs-number">25</span>},
            {<span class="hljs-string">'name'</span>: <span class="hljs-string">'Bob'</span>, <span class="hljs-string">'age'</span>: <span class="hljs-number">30</span>},
            {<span class="hljs-string">'name'</span>: <span class="hljs-string">'Charlie'</span>, <span class="hljs-string">'age'</span>: <span class="hljs-number">35</span>},
        ]
        
        count = <span class="hljs-keyword">await</span> db.batch_insert(<span class="hljs-string">'test_users'</span>, users)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"插入了 <span class="hljs-subst">{count}</span> 条记录"</span>)
        
        <span class="hljs-comment"># 并发查询</span>
        queries = [
            <span class="hljs-string">"SELECT * FROM test_users WHERE age &gt; 20"</span>,
            <span class="hljs-string">"SELECT COUNT(*) as count FROM test_users"</span>,
            <span class="hljs-string">"SELECT name, age FROM test_users ORDER BY age DESC"</span>,
        ]
        
        results = <span class="hljs-keyword">await</span> db.concurrent_queries(queries)
        <span class="hljs-keyword">for</span> i, result <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(results):
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"查询 <span class="hljs-subst">{i+<span class="hljs-number">1</span>}</span> 结果: <span class="hljs-subst">{result}</span>"</span>)
            
    <span class="hljs-keyword">finally</span>:
        <span class="hljs-keyword">await</span> db.close()

<span class="hljs-comment"># 运行示例</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"=== 网页抓取示例 ==="</span>)
    <span class="hljs-keyword">await</span> web_scraper_example()
    
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"\n=== 异步管道示例 ==="</span>)
    <span class="hljs-keyword">await</span> AsyncPipeline().run()

<span class="hljs-comment"># 注意：数据库示例需要真实数据库，这里只展示代码结构</span>
<span class="hljs-comment"># asyncio.run(main())</span>
</code></pre>
<h2 data-id="heading-10">六、调试与性能优化</h2>
<h3 data-id="heading-11">异步代码调试工具</h3>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> asyncio
<span class="hljs-keyword">import</span> logging
<span class="hljs-keyword">from</span> contextvars <span class="hljs-keyword">import</span> ContextVar
<span class="hljs-keyword">import</span> traceback
<span class="hljs-keyword">import</span> uvloop  <span class="hljs-comment"># 高性能事件循环</span>

<span class="hljs-comment"># 设置异步调试日志</span>
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)

<span class="hljs-comment"># 上下文变量</span>
request_id: ContextVar[<span class="hljs-built_in">str</span>] = ContextVar(<span class="hljs-string">'request_id'</span>, default=<span class="hljs-string">'unknown'</span>)

<span class="hljs-keyword">class</span> <span class="hljs-title class_">AsyncDebugger</span>:
    <span class="hljs-string">"""异步调试器"""</span>
    
<span class="hljs-meta">    @staticmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">enable_debug_mode</span>():
        <span class="hljs-string">"""启用调试模式"""</span>
        <span class="hljs-comment"># 启用详细日志</span>
        logging.getLogger(<span class="hljs-string">'asyncio'</span>).setLevel(logging.DEBUG)
        
        <span class="hljs-comment"># 设置事件循环调试</span>
        loop = asyncio.get_event_loop()
        loop.set_debug(<span class="hljs-literal">True</span>)
        
        <span class="hljs-comment"># 慢回调警告（秒）</span>
        loop.slow_callback_duration = <span class="hljs-number">0.1</span>
        
        <span class="hljs-comment"># 安装异常处理器</span>
        loop.set_exception_handler(AsyncDebugger.exception_handler)
    
<span class="hljs-meta">    @staticmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">exception_handler</span>(<span class="hljs-params">loop, context</span>):
        <span class="hljs-string">"""处理事件循环异常"""</span>
        message = context.get(<span class="hljs-string">'message'</span>, <span class="hljs-string">'未处理的异常'</span>)
        exception = context.get(<span class="hljs-string">'exception'</span>)
        task = context.get(<span class="hljs-string">'task'</span>)
        
        logger.error(<span class="hljs-string">f"事件循环异常: <span class="hljs-subst">{message}</span>"</span>)
        
        <span class="hljs-keyword">if</span> exception:
            logger.error(<span class="hljs-string">f"异常详情: <span class="hljs-subst">{exception}</span>"</span>)
            logger.error(<span class="hljs-string">f"异常堆栈: <span class="hljs-subst">{traceback.format_exc()}</span>"</span>)
        
        <span class="hljs-keyword">if</span> task:
            logger.error(<span class="hljs-string">f"相关任务: <span class="hljs-subst">{task}</span>"</span>)
        
        <span class="hljs-comment"># 打印所有运行中的任务</span>
        tasks = asyncio.all_tasks(loop)
        <span class="hljs-keyword">if</span> tasks:
            logger.error(<span class="hljs-string">f"当前运行中的任务数: <span class="hljs-subst">{<span class="hljs-built_in">len</span>(tasks)}</span>"</span>)
            <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> tasks:
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> t.done():
                    logger.error(<span class="hljs-string">f"  任务: <span class="hljs-subst">{t}</span>, 状态: <span class="hljs-subst">{t._state}</span>"</span>)
    
<span class="hljs-meta">    @staticmethod</span>
    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">trace_coroutine</span>(<span class="hljs-params">coro, name: <span class="hljs-built_in">str</span> = <span class="hljs-literal">None</span></span>):
        <span class="hljs-string">"""跟踪协程执行"""</span>
        <span class="hljs-keyword">import</span> time
        start = time.time()
        
        <span class="hljs-keyword">try</span>:
            result = <span class="hljs-keyword">await</span> coro
            elapsed = time.time() - start
            logger.debug(<span class="hljs-string">f"协程 <span class="hljs-subst">{name <span class="hljs-keyword">or</span> coro.__name__}</span> 完成，耗时: <span class="hljs-subst">{elapsed:<span class="hljs-number">.3</span>f}</span>s"</span>)
            <span class="hljs-keyword">return</span> result
        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
            elapsed = time.time() - start
            logger.error(<span class="hljs-string">f"协程 <span class="hljs-subst">{name <span class="hljs-keyword">or</span> coro.__name__}</span> 失败，耗时: <span class="hljs-subst">{elapsed:<span class="hljs-number">.3</span>f}</span>s, 错误: <span class="hljs-subst">{e}</span>"</span>)
            <span class="hljs-keyword">raise</span>

<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">performance_example</span>():
    <span class="hljs-string">"""性能对比示例"""</span>
    <span class="hljs-comment"># 使用uvloop提升性能（Linux/macOS）</span>
    <span class="hljs-keyword">try</span>:
        <span class="hljs-keyword">import</span> uvloop
        uvloop.install()
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"使用uvloop事件循环"</span>)
    <span class="hljs-keyword">except</span> ImportError:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"使用标准asyncio事件循环"</span>)
    
    <span class="hljs-comment"># 对比不同并发策略</span>
    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">io_bound_operation</span>(<span class="hljs-params"><span class="hljs-built_in">id</span>: <span class="hljs-built_in">int</span></span>):
        <span class="hljs-string">"""模拟IO操作"""</span>
        <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">0.1</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">id</span> * <span class="hljs-number">2</span>
    
    <span class="hljs-comment"># 方法1：顺序执行</span>
    start = asyncio.get_event_loop().time()
    results1 = []
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):
        results1.append(<span class="hljs-keyword">await</span> io_bound_operation(i))
    time1 = asyncio.get_event_loop().time() - start
    
    <span class="hljs-comment"># 方法2：并发执行</span>
    start = asyncio.get_event_loop().time()
    tasks = [io_bound_operation(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)]
    results2 = <span class="hljs-keyword">await</span> asyncio.gather(*tasks)
    time2 = asyncio.get_event_loop().time() - start
    
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"顺序执行时间: <span class="hljs-subst">{time1:<span class="hljs-number">.3</span>f}</span>s"</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"并发执行时间: <span class="hljs-subst">{time2:<span class="hljs-number">.3</span>f}</span>s"</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"性能提升: <span class="hljs-subst">{time1/time2:<span class="hljs-number">.1</span>f}</span>倍"</span>)
    
    <span class="hljs-comment"># 内存使用分析</span>
    <span class="hljs-keyword">import</span> sys
    coro = io_bound_operation(<span class="hljs-number">1</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"协程对象大小: <span class="hljs-subst">{sys.getsizeof(coro)}</span> 字节"</span>)
    
    task = asyncio.create_task(io_bound_operation(<span class="hljs-number">1</span>))
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"任务对象大小: <span class="hljs-subst">{sys.getsizeof(task)}</span> 字节"</span>)

<span class="hljs-comment"># 运行</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">debug_demo</span>():
    <span class="hljs-string">"""调试演示"""</span>
    AsyncDebugger.enable_debug_mode()
    
    <span class="hljs-comment"># 设置请求ID</span>
    request_id.<span class="hljs-built_in">set</span>(<span class="hljs-string">"req-123"</span>)
    
    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">problematic_coroutine</span>():
        <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">0.05</span>)
        <span class="hljs-comment"># 模拟错误</span>
        <span class="hljs-keyword">if</span> random.random() &lt; <span class="hljs-number">0.3</span>:
            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">"随机错误"</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-string">"成功"</span>
    
    <span class="hljs-comment"># 使用调试包装器</span>
    <span class="hljs-keyword">await</span> AsyncDebugger.trace_coroutine(
        problematic_coroutine(),
        <span class="hljs-string">"测试协程"</span>
    )
    
    <span class="hljs-comment"># 创建多个任务观察调试输出</span>
    tasks = []
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):
        task = asyncio.create_task(problematic_coroutine())
        tasks.append(task)
    
    <span class="hljs-keyword">await</span> asyncio.gather(*tasks, return_exceptions=<span class="hljs-literal">True</span>)

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    <span class="hljs-comment"># 运行性能示例</span>
    asyncio.run(performance_example())
    
    <span class="hljs-comment"># 运行调试示例（取消注释以查看调试输出）</span>
    <span class="hljs-comment"># asyncio.run(debug_demo())</span>
</code></pre>
<h2 data-id="heading-12">总结</h2>
<p>Python异步编程通过<code>asyncio</code>和<code>async/await</code>提供了：</p>
<h3 data-id="heading-13">核心概念：</h3>
<ol>
<li><strong>协程</strong>：使用<code>async def</code>定义的异步函数</li>
<li><strong>任务</strong>：管理和调度协程的执行</li>
<li><strong>事件循环</strong>：协调所有异步操作的中央调度器</li>
</ol>
<h3 data-id="heading-14">关键特性：</h3>
<ol>
<li><strong>并发控制</strong>：信号量、锁、事件、条件变量</li>
<li><strong>异步上下文</strong>：<code>async with</code>和<code>async for</code></li>
<li><strong>错误处理</strong>：超时、取消、异常传播</li>
<li><strong>性能优化</strong>：连接池、速率限制、批处理</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[用填充表格法-理解01背包及其变体问题]]></title>    <link>https://juejin.cn/post/7591697558377791530</link>    <guid>https://juejin.cn/post/7591697558377791530</guid>    <pubDate>2026-01-06T02:26:36.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7591697558377791530" data-draft-id="7591730714141032490" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="用填充表格法-理解01背包及其变体问题"/> <meta itemprop="keywords" content="前端,JavaScript,算法"/> <meta itemprop="datePublished" content="2026-01-06T02:26:36.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="颜酱"/> <meta itemprop="url" content="https://juejin.cn/user/905653309941495"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            用填充表格法-理解01背包及其变体问题
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/905653309941495/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    颜酱
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-06T02:26:36.000Z" title="Tue Jan 06 2026 02:26:36 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-06
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    4
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读31分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body cache result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">用填充表格法-理解01背包及其变体问题</h2>
<p>动态规划（Dynamic Programming, DP）解决问题的核心逻辑，本质是通过<strong>填充表格</strong>逐步推导最优解——把复杂的多阶段决策问题，转化为按规则填充表格的可视化过程。以01背包问题（最经典的DP模型）为例，我们先明确最终要填充的核心表格形态，后续所有解题步骤都是为了按规则完成这张表格，表格填完之时，就是问题解决之日。（看此文前，如果动态规划零基础，请看下<a href="https://juejin.cn/post/7591207451778875418" target="_blank" title="https://juejin.cn/post/7591207451778875418">DP解题的5步「钥匙」</a>）</p>
<p>01背包问题核心表格（空表，后续逐步填充）：</p>





















































<table><thead><tr><th>前i个物品\背包容量j</th><th>0（容量为0）</th><th>1（容量为1）</th><th>2（容量为2）</th><th>...（容量递增）</th><th>C（背包最大容量）</th></tr></thead><tbody><tr><td>0（无物品）</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td></tr><tr><td>1（第1个物品）</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td></tr><tr><td>2（第2个物品）</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td></tr><tr><td>...（物品递增）</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td></tr><tr><td>n（第n个物品）</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充（最终答案）</td></tr></tbody></table>
<p>表格说明：表格中每个单元格<code>dp[i][j]</code>代表「前i个物品放入容量为j的背包的最大价值」，我们的目标就是按规则填充所有单元格，最终右下角<code>dp[n][C]</code>即为01背包问题的最优解。</p>
<p>要有序、正确地填充这张表格，需要遵循<a href="https://juejin.cn/post/7591207451778875418" target="_blank" title="https://juejin.cn/post/7591207451778875418">DP解题的5步「钥匙」</a>——这是贯穿所有DP问题的通用拆解思路，每一步都对应表格填充的关键环节：</p>
<ol>
<li>
<p><strong>确定dp数组及下标的含义</strong>：明确<code>dp[i]</code>（或二维<code>dp[i][j]</code>）代表什么物理意义（比如"第i阶台阶的爬法数"、"前i个物品放入容量为j的背包的最大价值"）；</p>
</li>
<li>
<p><strong>确定递推公式</strong>：找到<code>dp[i]</code>与子问题<code>dp[i-1]</code>/<code>dp[i-2]</code>等的依赖关系（这是DP的核心，本质是将大问题拆解为可复用的子问题）；</p>
</li>
<li>
<p><strong>dp数组如何初始化</strong>：根据问题边界条件，初始化无法通过递推得到的基础值（比如"背包容量为0时价值为0"、"无物品时价值为0"）；</p>
</li>
<li>
<p><strong>确定遍历顺序</strong>：保证计算<code>dp[i]</code>时，其依赖的子问题已经被计算完成。这里可以简单理解为「表格的填充顺序」—— 二维DP类似逐行逐列填充表格，一维DP则是按特定方向（正序/倒序）填充单行表格；</p>
</li>
<li>
<p><strong>打印dp数组（验证）</strong>：通过打印中间结果，验证递推逻辑是否正确（这是调试DP问题的必备步骤，能快速定位递推公式或遍历顺序的错误）。</p>
</li>
</ol>
<p>后续所有01背包及变体问题的分析，都将围绕这5步「钥匙」展开，本质就是用这5步规则完成对应表格的填充，最终通过表格得到问题答案。</p>
<h3 data-id="heading-1">一、01背包问题基础定义</h3>
<p>01背包的核心场景：有<code>n</code>个物品，每个物品<strong>只有1个</strong>（要么选、要么不选，即"0-1"选择），每个物品有对应的重量<code>w[i]</code>和价值<code>v[i]</code>，现有一个容量为<code>C</code>的背包，如何选择物品放入背包，使得放入物品的总价值最大？</p>
<p>示例：物品重量<code>weights = [2,3,4,5]</code>，价值<code>values = [3,4,5,6]</code>，背包容量<code>capacity = 8</code>，求最大价值。</p>
<h3 data-id="heading-2">二、基础解法：二维DP数组</h3>
<p>我们将严格按照DP解题的5步「钥匙」拆解二维DP解法，每一步都对应核心表格的填充规则：</p>
<h4 data-id="heading-3">2.1 步骤1：确定dp数组及下标的含义</h4>
<p>定义二维DP数组<code>dp[i][j]</code>：表示「前<code>i</code>个物品（从第1个到第<code>i</code>个），放入容量为<code>j</code>的背包中，能获得的最大价值」。</p>
<p>说明：</p>
<ul>
<li>
<p>「前<code>i</code>个物品」不是指编号为<code>i</code>的物品，而是范围上的前<code>i</code>个（比如<code>i=2</code>代表前2个物品）；</p>
</li>
<li>
<p>下标<code>i</code>的范围：0<del>n（<code>i=0</code>表示无物品），下标<code>j</code>的范围：0</del>C（<code>j=0</code>表示背包容量为0）。</p>
</li>
</ul>
<h4 data-id="heading-4">2.2 步骤2：确定递推公式</h4>
<p>对于第<code>i</code>个物品（重量<code>w[i-1]</code>、价值<code>v[i-1]</code>，因数组下标从0开始），有两种选择：选或不选，递推公式由此而来：</p>
<ol>
<li>
<p><strong><code>i</code></strong> <strong>不选第个物品</strong>：前<code>i</code>个物品的最大价值 = 前<code>i-1</code>个物品的最大价值，即<code>dp[i][j] = dp[i-1][j]</code>；</p>
</li>
<li>
<p><strong><code>i</code></strong> <strong>选第个物品</strong>：需保证背包容量<code>j ≥ w[i-1]</code>，此时价值 = 前<code>i-1</code>个物品放入容量<code>j - w[i-1]</code>的最大价值 + 第<code>i</code>个物品的价值，即<code>dp[i][j] = dp[i-1][j - w[i-1]] + v[i-1]</code>。</p>
</li>
</ol>
<p>综合两种情况，取最大值作为<code>dp[i][j]</code>的结果：</p>
<pre><code class="hljs language-Plain" lang="Plain">
dp[i][j] = max(dp[i-1][j], dp[i-1][j - w[i-1]] + v[i-1]) （当j ≥ w[i-1]时）
dp[i][j] = dp[i-1][j] （当j &lt; w[i-1]时，容量不足，无法选第i个物品）
</code></pre>
<h4 data-id="heading-5">2.3 步骤3：dp数组如何初始化</h4>
<p>根据边界条件初始化：</p>
<ol>
<li>
<p><code>i=0</code>（无物品）：无论背包容量多大，最大价值都是0，即<code>dp[0][j] = 0</code>（<code>j</code>从0到C）；</p>
</li>
<li>
<p><code>j=0</code>（背包容量为0）：无论有多少物品，都无法放入，最大价值都是0，即<code>dp[i][0] = 0</code>（<code>i</code>从0到n）。</p>
</li>
</ol>
<p>初始化后，DP数组的第一行和第一列都为0。</p>
<h4 data-id="heading-6">2.4 步骤4：确定遍历顺序（表格填充顺序）</h4>
<p>遍历顺序直接对应二维表格的填充顺序——即「按什么顺序逐个填写表格中的单元格」，这里有两种可行方式：</p>
<ol>
<li>
<p>先遍历物品（<code>i</code>从1到n），再遍历背包容量（<code>j</code>从1到C）；</p>
</li>
<li>
<p>先遍历背包容量（<code>j</code>从1到C），再遍历物品（<code>i</code>从1到n）。</p>
</li>
</ol>
<p>两种顺序都可行，因为计算<code>dp[i][j]</code>时，只依赖上一行（<code>i-1</code>行）的结果，无论先填行还是先填列，上一行的对应位置都已提前计算完成。这就像填充一张二维表格：先遍历物品再遍历容量，是<strong>逐行填充</strong>（每一行对应一个物品的决策，填完一行再处理下一个物品）；先遍历容量再遍历物品，是<strong>逐列填充</strong>（每一列对应一个固定容量，先确定所有物品在该容量下的最优解）。实际解题中更常用「先遍历物品，再遍历容量」的顺序，符合我们「逐个考虑物品是否放入」的思考逻辑。</p>
<h4 data-id="heading-7">2.5 步骤5：打印dp数组（验证）</h4>
<p>这一步是直接验证表格填充结果的正确性——通过逐步填充表格、打印中间状态，确认每一步都符合递推规则，避免因规则理解偏差导致填充错误。以示例<code>weights = [2,3,4,5]</code>、<code>values = [3,4,5,6]</code>、<code>capacity = 8</code>为例，逐步填充核心表格验证逻辑：</p>
<p>以示例<code>weights = [2,3,4,5]</code>、<code>values = [3,4,5,6]</code>、<code>capacity = 8</code>为例，逐步填充表格验证逻辑：</p>
<p>初始DP数组（第一行、第一列为0）：</p>





























<table><thead><tr><th>前i个物品\背包容量j</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th></tr></thead><tbody><tr><td>0（无物品）</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr></tbody></table>
<p>步骤1：处理第1个物品（重量2，价值3）</p>
<p>j≥2时取max(上一行j, 上一行j-2+3)：</p>





























<table><thead><tr><th>前i个物品\背包容量j</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th></tr></thead><tbody><tr><td>1（物品[2,3]）</td><td>0</td><td>0</td><td>3</td><td>3</td><td>3</td><td>3</td><td>3</td><td>3</td><td>3</td></tr></tbody></table>
<p>步骤2：处理第2个物品（重量3，价值4）</p>
<p>j≥3时取max(上一行j, 上一行j-3+4)：</p>





























<table><thead><tr><th>前i个物品\背包容量j</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th></tr></thead><tbody><tr><td>2（物品[2,3]、[3,4]）</td><td>0</td><td>0</td><td>3</td><td>4</td><td>4</td><td>7</td><td>7</td><td>7</td><td>7</td></tr></tbody></table>
<p>步骤3：处理第3个物品（重量4，价值5）</p>
<p>j≥4时取max(上一行j, 上一行j-4+5)：</p>





























<table><thead><tr><th>前i个物品\背包容量j</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th></tr></thead><tbody><tr><td>3（新增[4,5]）</td><td>0</td><td>0</td><td>3</td><td>4</td><td>5</td><td>7</td><td>8</td><td>9</td><td>9</td></tr></tbody></table>
<p>步骤4：处理第4个物品（重量5，价值6）</p>
<p>j≥5时取max(上一行j, 上一行j-5+6)：</p>





























<table><thead><tr><th>前i个物品\背包容量j</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th></tr></thead><tbody><tr><td>4（新增[5,6]）</td><td>0</td><td>0</td><td>3</td><td>4</td><td>5</td><td>7</td><td>8</td><td>9</td><td>10</td></tr></tbody></table>
<p>最终<code>dp[4][8] = 10</code>，与测试用例结果一致，即最大价值为10。</p>
<p>完整二维DP数组变化汇总表：</p>













































































<table><thead><tr><th>前i个物品\背包容量j</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th></tr></thead><tbody><tr><td>0（无物品）</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>1（物品[2,3]）</td><td>0</td><td>0</td><td>3</td><td>3</td><td>3</td><td>3</td><td>3</td><td>3</td><td>3</td></tr><tr><td>2（物品[2,3]、[3,4]）</td><td>0</td><td>0</td><td>3</td><td>4</td><td>4</td><td>7</td><td>7</td><td>7</td><td>7</td></tr><tr><td>3（新增[4,5]）</td><td>0</td><td>0</td><td>3</td><td>4</td><td>5</td><td>7</td><td>8</td><td>9</td><td>9</td></tr><tr><td>4（新增[5,6]）</td><td>0</td><td>0</td><td>3</td><td>4</td><td>5</td><td>7</td><td>8</td><td>9</td><td>10</td></tr></tbody></table>
<ul>
<li>
<p>时间复杂度：<code>O(n*C)</code>（<code>n</code>为物品数，<code>C</code>为背包容量）；</p>
</li>
<li>
<p>空间复杂度：<code>O(n*C)</code>（二维数组的空间开销）。</p>
</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[【节点】[NormalReconstructZ节点]原理解析与实际应用]]></title>    <link>https://juejin.cn/post/7591770429931257906</link>    <guid>https://juejin.cn/post/7591770429931257906</guid>    <pubDate>2026-01-06T02:38:41.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7591770429931257906" data-draft-id="7591770429930569778" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="【节点】[NormalReconstructZ节点]原理解析与实际应用"/> <meta itemprop="keywords" content="游戏开发,Unity3D,图形学"/> <meta itemprop="datePublished" content="2026-01-06T02:38:41.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="SmalBox"/> <meta itemprop="url" content="https://juejin.cn/user/2218166695237532"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            【节点】[NormalReconstructZ节点]原理解析与实际应用
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2218166695237532/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    SmalBox
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-06T02:38:41.000Z" title="Tue Jan 06 2026 02:38:41 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-06
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fchenghai37%2Fcategory_13074589.html%3Ffromshare%3Dblogcolumn%26sharetype%3Dblogcolumn%26sharerId%3D13074589%26sharerefer%3DPC%26sharesource%3Dchenghai37%26sharefrom%3Dfrom_link" target="_blank" title="https://blog.csdn.net/chenghai37/category_13074589.html?fromshare=blogcolumn&amp;sharetype=blogcolumn&amp;sharerId=13074589&amp;sharerefer=PC&amp;sharesource=chenghai37&amp;sharefrom=from_link" ref="nofollow noopener noreferrer">【Unity Shader Graph 使用与特效实现】</a><strong>专栏-直达</strong></p>
</blockquote>
<h2 data-id="heading-0">节点功能概述</h2>
<p>法线Z值重建节点（Normal Reconstruct Z Node）是Unity URP渲染管线中的关键组件，专门用于从法线向量的X和Y分量推导出正确的Z分量。该节点通过精确的数学计算，实现了法线数据的压缩存储与物理正确性保障，在法线贴图优化过程中发挥着重要作用。在实际渲染流程中，它能够有效解决因法线贴图压缩导致的数据丢失问题，确保光照计算的准确性，是高质量实时渲染不可或缺的一环。该节点的设计充分考虑了现代图形硬件的特性，能够在保持高质量视觉效果的同时，显著降低内存带宽和存储空间的需求，特别适合移动平台和性能敏感的应用场景。</p>
<h2 data-id="heading-1">端口与参数详解</h2>
<ul>
<li><strong>输入端口</strong>
<ul>
<li>In：Vector2类型，包含法线贴图的X和Y分量值，通常来自压缩后的法线贴图采样结果。在实际使用中，这些输入数据通常来自经过BC5/DXT5NM等压缩格式处理的法线贴图，这些格式专门设计用于存储双通道的法线数据。</li>
</ul>
</li>
<li><strong>输出端口</strong>
<ul>
<li>Out：Vector3类型，输出完整的法线向量，可直接用于光照计算和材质表现。输出的法线向量已经过归一化处理，确保在后续的着色器计算中能够正确参与光照方程的运算。</li>
</ul>
</li>
</ul>
<h2 data-id="heading-2">数学原理与算法</h2>
<p>该节点基于单位向量的基本性质进行Z分量重建，核心算法流程如下：</p>
<ol>
<li>计算X和Y分量的平方和，即向量在XY平面上的长度平方，这一步骤实际上是计算法线在XY平面上的投影长度。</li>
<li>通过1减去该平方和得到Z分量的平方值，这一步骤基于单位向量模长为1的基本性质，即x² + y² + z² = 1的数学关系。</li>
<li>对结果取平方根获得Z分量值，需注意正负号的处理。在实际实现中，通常假设法线指向表面外侧，因此Z分量为正值。</li>
<li>对最终结果进行归一化处理，确保输出向量的单位长度，这对于保持光照计算的物理正确性至关重要。</li>
</ol>
<h2 data-id="heading-3">生成代码解析</h2>
<p>以下是该节点的典型HLSL实现代码：</p>
<pre><code class="hljs language-c" lang="c"><span class="hljs-type">void</span> <span class="hljs-title function_">Unity_NormalReconstructZ_float</span><span class="hljs-params">(float2 In, out float3 Out)</span>
{
    <span class="hljs-type">float</span> reconstructZ = <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">1.0</span> - saturate(dot(In.xy, In.xy)));
    float3 normalVector = float3(In.x, In.y, reconstructZ);
    Out = normalize(normalVector);
}
</code></pre>
<p>代码解析要点：</p>
<ul>
<li><code>dot(In.xy, In.xy)</code>计算X和Y分量的点积，等价于x² + y²，这是计算二维向量长度的平方的标准方法。</li>
<li><code>saturate()</code>函数确保计算结果被限制在0-1范围内，防止出现无效的负值开方，这对于处理可能存在的数值误差至关重要。</li>
<li><code>sqrt()</code>函数计算Z分量，重建法线向量的垂直分量，这是整个重建过程的核心计算步骤。</li>
<li><code>normalize()</code>函数保证输出为单位向量，确保光照计算的正确性，特别是在高光计算和反射计算中保持物理准确性。</li>
</ul>
<h2 data-id="heading-4">应用场景</h2>
<p>该节点在以下场景中具有重要应用价值：</p>
<ul>
<li>法线贴图压缩存储：通过仅存储XY分量显著减少纹理内存占用，在移动设备上可以节省高达50%的法线贴图内存使用。</li>
<li>动态法线生成：在运行时基于程序化纹理生成完整法线数据，适用于地形生成、水面模拟等动态环境。</li>
<li>法线贴图优化：在移动平台上实现高质量的法线渲染效果，同时保持较低的性能开销。</li>
<li>特殊材质效果实现：如水面波纹、布料褶皱等动态视觉效果，通过实时重建法线实现复杂的表面细节。</li>
<li>延迟渲染管线：在G-Buffer中优化法线数据存储结构，减少显存占用和带宽消耗。</li>
<li>多平台适配：有效解决不同平台法线贴图压缩格式差异问题，确保跨平台渲染的一致性。</li>
</ul>
<h2 data-id="heading-5">使用技巧与优化</h2>
<ul>
<li>参数调整指南：根据具体材质类型适当调整法线强度参数，对于金属材质可以适当增强法线效果，而对于粗糙表面则需要更细致的控制。</li>
<li>性能优化建议：在低端设备上可考虑简化部分计算步骤，比如在某些情况下可以省略归一化操作以获得性能提升。</li>
<li>常见问题解决方案：妥善处理法线方向异常和计算精度问题，特别是在边缘情况下需要特别注意数值稳定性。</li>
<li>移动端适配：针对移动GPU特性优化计算精度和性能表现，可以考虑使用半精度浮点数进行计算。</li>
<li>多光源场景：确保重建的法线在多光源环境下保持正确表现，需要特别注意法线在多个光源下的交互效果。</li>
</ul>
<h2 data-id="heading-6">注意事项</h2>
<ul>
<li>法线方向异常处理：特别注意切线空间法线的正确方向设定，确保重建的法线与原始法线方向一致。</li>
<li>纹理采样错误预防：确保输入数据处于正确的数值范围内，避免因纹理采样错误导致的重建失败。</li>
<li>锯齿边缘问题解决：适当使用各向异性过滤技术改善边缘质量，特别是在法线贴图包含高频细节时。</li>
<li>平台兼容性考量：注意不同图形API下的行为差异，特别是在OpenGL ES和Vulkan平台上的表现可能有所不同。</li>
<li>精度控制：避免因浮点精度不足导致的渲染瑕疵，在关键计算步骤中使用全精度浮点数。</li>
</ul>
<h2 data-id="heading-7">总结与拓展应用</h2>
<p>该节点在Unity URP管线中为法线贴图处理提供了高效的解决方案，通过严谨的数学推导实现Z分量重建，在保持视觉质量的同时优化了资源使用效率。其应用范围不仅限于基础法线处理，还可扩展至高级材质效果开发，如PBR材质系统、视差遮挡映射、曲面细分等先进渲染技术。随着实时渲染技术的持续发展，该节点在虚拟现实、增强现实等新兴领域也将发挥更加重要的作用。特别是在下一代图形API如DirectX 12 Ultimate和Vulkan的背景下，该技术将继续演进，为实时图形渲染提供更加高效和灵活的解决方案。</p>
<hr/>
<blockquote>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fchenghai37%2Fcategory_13074589.html%3Ffromshare%3Dblogcolumn%26sharetype%3Dblogcolumn%26sharerId%3D13074589%26sharerefer%3DPC%26sharesource%3Dchenghai37%26sharefrom%3Dfrom_link" target="_blank" title="https://blog.csdn.net/chenghai37/category_13074589.html?fromshare=blogcolumn&amp;sharetype=blogcolumn&amp;sharerId=13074589&amp;sharerefer=PC&amp;sharesource=chenghai37&amp;sharefrom=from_link" ref="nofollow noopener noreferrer">【Unity Shader Graph 使用与特效实现】</a><strong>专栏-直达</strong>
（欢迎<em>点赞留言</em>探讨，更多人加入进来能更加完善这个探索的过程，🙏）</p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[实战：构建基于 aio_periodic 的高性能异步 AI 绘图 Worker]]></title>    <link>https://juejin.cn/post/7591730714141098026</link>    <guid>https://juejin.cn/post/7591730714141098026</guid>    <pubDate>2026-01-06T02:39:03.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7591730714141098026" data-draft-id="7591730714141048874" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="实战：构建基于 aio_periodic 的高性能异步 AI 绘图 Worker"/> <meta itemprop="keywords" content="Python,AIGC"/> <meta itemprop="datePublished" content="2026-01-06T02:39:03.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Lupino"/> <meta itemprop="url" content="https://juejin.cn/user/3051900006579256"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            实战：构建基于 aio_periodic 的高性能异步 AI 绘图 Worker
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3051900006579256/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Lupino
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-06T02:39:03.000Z" title="Tue Jan 06 2026 02:39:03 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-06
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在分布式系统中，将计算密集型任务（如 AI 图像生成）从 Web 服务中剥离是常见的架构模式。本文将介绍如何使用 Python 的 <code>asyncio</code> 和 <code>aio_periodic</code> 构建一个健壮的 Worker，它能够调用本地 MLX 推理引擎生成图片，同时保持高并发下的稳定性。</p>
<h2 data-id="heading-0">1. 架构概述</h2>
<p>我们的目标是构建一个 Worker 节点，它负责：</p>
<ol>
<li><strong>监听任务</strong>：从 <code>periodicd</code> 任务服务器领取绘图任务。</li>
<li><strong>执行推理</strong>：调用适配 Apple Silicon 的 <code>z-image-turbo-mlx</code> 脚本。</li>
<li><strong>非阻塞交互</strong>：在长达数秒的生成过程中，保持与服务器的心跳连接。</li>
<li><strong>结果回传</strong>：将生成的图片转为 Base64 传回。</li>
</ol>
<h2 data-id="heading-1">2. 核心挑战：同步 vs 异步</h2>
<p>在早期实现中，开发者常直接使用 <code>os.system</code> 调用外部命令。这在异步框架（如 <code>asyncio</code>）中是致命的。</p>
<ul>
<li><strong>问题</strong>：<code>os.system</code> 会阻塞整个 Python 进程。在 AI 生成图片的 5-10 秒内，Event Loop 停止运转，Worker 无法发送心跳包（Heartbeat），导致服务器误判 Worker 掉线并重新分配任务，造成“僵尸任务”循环。</li>
<li><strong>解法</strong>：使用 <code>asyncio.create_subprocess_exec</code>。它允许我们在等待子进程结束时，让出 CPU 控制权，使 Worker 能继续处理网络 IO。</li>
</ul>
<h2 data-id="heading-2">3. 代码实现亮点</h2>
<h3 data-id="heading-3">3.1 安全的子进程调用</h3>
<p>为了防止 Shell 命令注入攻击（例如用户在 prompt 中输入 <code>; rm -rf /</code>），我们放弃字符串拼接，改用列表传参：</p>
<p>Python</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-comment"># 推荐做法：列表传参</span>
<span class="hljs-attr">cmd</span> = [
    sys.executable, <span class="hljs-string">'generate_mlx.py'</span>,
    <span class="hljs-string">'--prompt'</span>, user_prompt,
    <span class="hljs-string">'--output'</span>, output_filename
]
<span class="hljs-comment"># asyncio 负责安全地将参数传给子进程，无需经过 Shell 解释</span>
<span class="hljs-attr">process</span> = await asyncio.create_subprocess_exec(*cmd)
</code></pre>
<h3 data-id="heading-4">3.2 保持 Event Loop 活跃</h3>
<p>对于文件读取这种 IO 操作，虽然 Python 的 <code>open()</code> 是同步的，但在高并发下依然可能造成微小的卡顿。我们利用 <code>run_in_executor</code> 将其放入线程池：</p>
<p>Python</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-comment"># 将同步的文件读取扔到线程池，避免阻塞主循环</span>
<span class="hljs-attr">loop</span> = asyncio.get_running_loop()
<span class="hljs-attr">b64_str</span> = await loop.run_in_executor(
    None, 
    partial(blocking_image_to_base64, output_filename)
)
</code></pre>
<h3 data-id="heading-5">3.3 健壮的资源清理</h3>
<p>AI 任务常因显存不足或参数错误而失败。使用 <code>try...finally</code> 模式确保即使生成失败，临时文件也能被清理，保持环境整洁。</p>
<p>Python</p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-keyword">try</span>:
    <span class="hljs-keyword">await</span> run_generation()
except Exception:
    logger.error(<span class="hljs-string">"Job failed"</span>)
<span class="hljs-keyword">finally</span>:
    <span class="hljs-keyword">if</span> os.path.exists(temp_file):
        os.<span class="hljs-keyword">remove</span>(temp_file) <span class="hljs-meta"># 无论成功失败，必须清理垃圾</span>
</code></pre>
<h2 data-id="heading-6">4. 实时日志流</h2>
<p>为了方便运维监控，我们配置子进程直接继承父进程的标准输出。这意味着你在运行 Worker 的终端上，可以直接看到底层 <code>generate_mlx.py</code> 打印的进度条和日志，而无需复杂的管道转发。</p>
<h2 data-id="heading-7">5. 总结</h2>
<p>通过将 <code>aio_periodic</code> 的任务调度能力与 <code>asyncio</code> 的子进程管理结合，我们构建了一个既能利用本地强大算力（MLX），又完全符合分布式系统稳定性要求的 Worker。这种模式同样适用于视频转码、PDF 生成等其他耗时任务。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[超实用的AI绘图提示词：快速绘制树状架构图]]></title>    <link>https://juejin.cn/post/7591672090791362579</link>    <guid>https://juejin.cn/post/7591672090791362579</guid>    <pubDate>2026-01-06T02:43:22.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7591672090791362579" data-draft-id="7591730714141147178" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="超实用的AI绘图提示词：快速绘制树状架构图"/> <meta itemprop="keywords" content="前端,后端"/> <meta itemprop="datePublished" content="2026-01-06T02:43:22.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="暖阳_"/> <meta itemprop="url" content="https://juejin.cn/user/1662117312465406"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            超实用的AI绘图提示词：快速绘制树状架构图
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1662117312465406/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    暖阳_
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-06T02:43:22.000Z" title="Tue Jan 06 2026 02:43:22 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-06
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">超实用的AI绘图提示词：快速绘制树状架构图</h2>
<p>今天给大家分享一个特别特别实用的绘图提示词，来帮你快速绘制树状架构图，生成结构化内容，不再需要打开各种脑图文件，直接在和AI对话时候就可以输出，并且支持随意编辑。</p>
<h3 data-id="heading-1">📋 提示词模板</h3>
<pre><code class="hljs language-markdown" lang="markdown">请帮我绘制一个树状系统架构图，使用以下格式规范：

【格式规范】
<span class="hljs-bullet">1.</span> 使用 ASCII 字符绘制树状结构：
<span class="hljs-bullet">   -</span> 竖线：│ （表示垂直连接）
<span class="hljs-bullet">   -</span> 分支：├─→ （表示向右的分支）
<span class="hljs-bullet">   -</span> 末分支：└─→ （表示最后一个分支）
<span class="hljs-bullet">   -</span> 方括号：[] （表示主要组件/模块）
<span class="hljs-bullet">   -</span> 花括号：{{}} （表示占位符，需要替换的内容）
<span class="hljs-bullet">   -</span> 圆括号：() （表示附加说明信息）
<span class="hljs-bullet">   -</span> 箭头：← → （表示数据流向或连接关系）

<span class="hljs-bullet">2.</span> 缩进规则：
<span class="hljs-bullet">   -</span> 每级子节点向右缩进 4 个空格
<span class="hljs-bullet">   -</span> 保持层级对齐

<span class="hljs-bullet">3.</span> 占位符使用：
<span class="hljs-bullet">   -</span> {{系统名称}} - 系统主名称
<span class="hljs-bullet">   -</span> {{层级名称}} - 各层级名称
<span class="hljs-bullet">   -</span> {{组件名称}} - 具体组件名称
<span class="hljs-bullet">   -</span> {{子组件}} - 子组件名称
<span class="hljs-bullet">   -</span> {{说明信息}} - 附加说明

【示例模板】
{{系统名称}}
<span class="hljs-code">    │
    ├─→ [{{第一层组件1}}]
    │       │
    │       ├─→ [{{子组件1-1}}]
    │       │       │
    │       │       └─→ [{{子组件1-1-1}}] ({{说明信息}})
    │       │
    │       └─→ [{{子组件1-2}}] ← {{连接说明}}
    │
    ├─→ [{{第一层组件2}}]
    │       │
    │       └─→ [{{子组件2-1}}] ─→ [{{目标组件}}] ({{参数}})
    │
    └─→ [{{第一层组件3}}]
            │
            ├─→ [{{子组件3-1}}]
            │
            └─→ [{{子组件3-2}}]
                    │
                    └─ {{连接线}} ─→ [{{最终组件}}]
</span>
【绘制要求】
<span class="hljs-bullet">1.</span> 保持树状结构的清晰和对称
<span class="hljs-bullet">2.</span> 每个节点使用方括号 [] 包裹
<span class="hljs-bullet">3.</span> 占位符使用双花括号 {{}} 包裹
<span class="hljs-bullet">4.</span> 附加信息使用圆括号 () 包裹
<span class="hljs-bullet">5.</span> 连接关系使用箭头 ← → 表示
<span class="hljs-bullet">6.</span> 确保所有分支对齐美观
</code></pre>
<h3 data-id="heading-2">🎯 使用示例</h3>
<h4 data-id="heading-3">示例1：用户登录系统架构</h4>
<p><strong>提示词：</strong></p>
<pre><code class="hljs language-diff" lang="diff">请使用树状图格式绘制用户登录系统架构，替换以下占位符：
<span class="hljs-deletion">- {{系统名称}} = 用户登录系统</span>
<span class="hljs-deletion">- {{第一层组件1}} = 前端层</span>
<span class="hljs-deletion">- {{子组件1-1}} = 登录页面</span>
<span class="hljs-deletion">- {{子组件1-2}} = 用户界面</span>
<span class="hljs-deletion">- {{第一层组件2}} = 后端服务</span>
<span class="hljs-deletion">- {{子组件2-1}} = 认证服务</span>
<span class="hljs-deletion">- {{目标组件}} = 数据库</span>
<span class="hljs-deletion">- {{参数}} = MySQL</span>
</code></pre>
<p><strong>效果：</strong></p>
<pre><code class="hljs language-scss" lang="scss">用户登录系统
    │
    ├─→ <span class="hljs-selector-attr">[前端层]</span>
    │       │
    │       ├─→ <span class="hljs-selector-attr">[登录页面]</span>
    │       │
    │       └─→ <span class="hljs-selector-attr">[用户界面]</span>
    │
    └─→ <span class="hljs-selector-attr">[后端服务]</span>
            │
            └─→ <span class="hljs-selector-attr">[认证服务]</span> ─→ <span class="hljs-selector-attr">[数据库]</span> (MySQL)
</code></pre>
<h4 data-id="heading-4">示例2：微服务架构</h4>
<p><strong>提示词：</strong></p>
<pre><code class="hljs language-diff" lang="diff">请绘制微服务架构图，包含：
<span class="hljs-deletion">- 网关层</span>
<span class="hljs-deletion">- 用户服务（连接MySQL）</span>
<span class="hljs-deletion">- 订单服务（连接Redis）</span>
<span class="hljs-deletion">- 支付服务（连接消息队列）</span>
</code></pre>
<p><strong>效果：</strong></p>
<pre><code class="hljs language-scss" lang="scss">微服务架构
    │
    ├─→ <span class="hljs-selector-attr">[API网关]</span>
    │       │
    │       ├─→ <span class="hljs-selector-attr">[用户服务]</span> ─→ <span class="hljs-selector-attr">[MySQL]</span> (数据存储)
    │       │
    │       ├─→ <span class="hljs-selector-attr">[订单服务]</span> ─→ <span class="hljs-selector-attr">[Redis]</span> (缓存)
    │       │
    │       └─→ <span class="hljs-selector-attr">[支付服务]</span> ─→ <span class="hljs-selector-attr">[消息队列]</span> (异步处理)
    │
    └─→ <span class="hljs-selector-attr">[监控中心]</span>
            │
            └─→ <span class="hljs-selector-attr">[日志收集]</span> ─→ <span class="hljs-selector-attr">[ELK]</span> (日志分析)
</code></pre>
<h4 data-id="heading-5">示例3：物联网设备架构</h4>
<p><strong>提示词：</strong></p>
<pre><code class="hljs language-scss" lang="scss">绘制物联网设备架构，参考格式：
<span class="hljs-selector-attr">[内容1]</span>
    │
    ├─→ <span class="hljs-selector-attr">[内容2]</span> ← USB充电口
    │
    └─→ {{内容三}}
            │
            ├─→ <span class="hljs-selector-attr">[{{子内容}}]</span> ─→ <span class="hljs-selector-attr">[舵机]</span> (<span class="hljs-number">5</span>V)
            │
            └─→ <span class="hljs-selector-attr">[{{子内容}}]</span> ─→ <span class="hljs-selector-attr">[ESP8266]</span> (<span class="hljs-number">3.3</span>V)
                    │
                    └─ GPIO2 ─→ <span class="hljs-selector-attr">[舵机信号线]</span>
</code></pre>
<p><strong>效果：</strong></p>
<pre><code class="hljs language-scss" lang="scss">物联网控制系统
    │
    ├─→ <span class="hljs-selector-attr">[电源模块]</span> ← USB充电口
    │
    └─→ <span class="hljs-selector-attr">[控制模块]</span>
            │
            ├─→ <span class="hljs-selector-attr">[执行器控制]</span> ─→ <span class="hljs-selector-attr">[舵机]</span> (<span class="hljs-number">5</span>V)
            │
            └─→ <span class="hljs-selector-attr">[通信模块]</span> ─→ <span class="hljs-selector-attr">[ESP8266]</span> (<span class="hljs-number">3.3</span>V)
                    │
                    └─ GPIO2 ─→ <span class="hljs-selector-attr">[舵机信号线]</span>
</code></pre>
<h3 data-id="heading-6">✨ 优势特点</h3>
<ol>
<li><strong>无需额外工具</strong>：不需要打开 XMind、Draw.io 等工具，直接在对话中生成</li>
<li><strong>快速编辑</strong>：可以随时修改占位符，AI 会重新生成</li>
<li><strong>格式统一</strong>：使用标准 ASCII 字符，在任何文本编辑器中都能正常显示</li>
<li><strong>易于复制</strong>：生成的图表可以直接复制到文档、代码注释、技术文档中</li>
<li><strong>灵活扩展</strong>：可以根据需要添加任意层级和节点</li>
</ol>
<h3 data-id="heading-7">💡 使用技巧</h3>
<ol>
<li><strong>占位符替换</strong>：先使用占位符生成模板，再逐步替换为实际内容</li>
<li><strong>层级控制</strong>：根据复杂度调整层级深度，建议不超过 5 层</li>
<li><strong>对齐检查</strong>：生成后检查缩进是否对齐，可以要求 AI 调整</li>
<li><strong>样式定制</strong>：可以根据需要调整连接符样式（如使用不同的箭头）</li>
</ol>
<h3 data-id="heading-8">🤝 欢迎分享</h3>
<p>如果你有更好的提示词或者使用技巧，欢迎在评论区分享！让我们一起提高 AI 绘图的效率和质量。</p>
<hr/></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[深入理解 Git `git add -p` 命令中的交互选项]]></title>    <link>https://juejin.cn/post/7591770429931290674</link>    <guid>https://juejin.cn/post/7591770429931290674</guid>    <pubDate>2026-01-06T02:40:55.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7591770429931290674" data-draft-id="7591799107486466058" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="深入理解 Git `git add -p` 命令中的交互选项"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-01-06T02:40:55.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="掘金者阿豪"/> <meta itemprop="url" content="https://juejin.cn/user/4073055974333608"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            深入理解 Git `git add -p` 命令中的交互选项
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4073055974333608/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    掘金者阿豪
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-06T02:40:55.000Z" title="Tue Jan 06 2026 02:40:55 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-06
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">深入理解 Git <code>git add -p</code> 命令中的交互选项</h2>
<p>在使用 Git 进行版本控制时，我们通常会遇到需要有选择性地提交代码修改的情况。这种需求可能源于我们不希望将所有的修改都包含在一次提交中，或者希望将特定的修改分成多个提交，以便更好地记录变更历史。在这种情况下，<code>git add -p</code> 命令是一个非常有用的工具。本文将详细介绍 <code>git add -p</code> 命令的使用方法，特别是其中的交互选项 <code>[y,n,q,a,d,e,?]</code>，并通过实际案例说明其应用场景。</p>
<h3 data-id="heading-1">一、<code>git add -p</code> 命令概述</h3>
<p><code>git add -p</code> 命令用于交互式地将文件的部分修改（称为hunk）添加到暂存区（staging area）。在运行 <code>git add -p</code> 命令后，Git 会逐个显示每个文件的修改块，并提示用户选择是否将该块添加到暂存区。这个过程允许开发者在提交前细粒度地控制哪些修改应该被包含在提交中。</p>
<h3 data-id="heading-2">二、交互选项解释</h3>
<p>当 Git 显示一个修改块时，会提示用户选择操作：</p>
<pre><code class="hljs language-kotlin" lang="kotlin">Stage <span class="hljs-keyword">this</span> hunk [y,n,q,a,d,e,?]?
</code></pre>
<p>这些选项分别表示不同的操作：</p>
<ul>
<li><strong><code>y</code>（yes）</strong>：将当前显示的hunk（修改块）添加到暂存区。</li>
<li><strong><code>n</code>（no）</strong>：不将当前显示的hunk添加到暂存区，跳过这个修改。</li>
<li><strong><code>q</code>（quit）</strong>：退出 <code>git add -p</code> 命令，放弃本次交互式添加，不做任何更改。</li>
<li><strong><code>a</code>（all）</strong>：添加当前文件的所有修改到暂存区（stage all hunks for the current file）。</li>
<li><strong><code>d</code>（discard）</strong>：不添加当前文件的任何修改到暂存区（do not stage any hunks for the current file）。</li>
<li><strong><code>e</code>（edit）</strong>：手动编辑当前hunk，可以进入编辑模式，对当前hunk进行更细致的调整或修改。</li>
<li><strong><code>?</code>（help）</strong>：显示帮助信息，列出上述选项的含义和使用方法。</li>
</ul>
<h3 data-id="heading-3">三、实际案例</h3>
<h4 data-id="heading-4">案例一：逐块添加修改</h4>
<p>假设我们有一个文件 <code>example.txt</code>，其中包含以下修改：</p>
<pre><code class="hljs language-diff" lang="diff"><span class="hljs-comment">diff --git a/example.txt b/example.txt</span>
<span class="hljs-comment">index e69de29..d95f3ad 100644</span>
<span class="hljs-comment">--- a/example.txt</span>
<span class="hljs-comment">+++ b/example.txt</span>
<span class="hljs-meta">@@ -0,0 +1,4 @@</span>
<span class="hljs-addition">+First line of text</span>
<span class="hljs-addition">+Second line of text</span>
<span class="hljs-addition">+Third line of text</span>
<span class="hljs-addition">+Fourth line of text</span>
</code></pre>
<p>运行 <code>git add -p example.txt</code> 后，Git 会显示第一个修改块：</p>
<pre><code class="hljs language-kotlin" lang="kotlin">Stage <span class="hljs-keyword">this</span> hunk [y,n,q,a,d,e,?]?
</code></pre>
<p>在这个提示下，我们可以做出如下选择：</p>
<ul>
<li>输入 <code>y</code> 并回车：将这个修改块添加到暂存区。</li>
<li>输入 <code>n</code> 并回车：跳过这个修改块，不将其添加到暂存区。</li>
<li>输入 <code>q</code> 并回车：退出交互式添加过程，不对任何文件进行暂存。</li>
<li>输入 <code>a</code> 并回车：将 <code>example.txt</code> 文件的所有修改块添加到暂存区。</li>
<li>输入 <code>d</code> 并回车：跳过 <code>example.txt</code> 文件的所有修改块。</li>
<li>输入 <code>e</code> 并回车：进入编辑模式，可以手动调整当前的修改块。</li>
<li>输入 <code>?</code> 并回车：显示帮助信息，列出所有选项的含义。</li>
</ul>
<h4 data-id="heading-5">案例二：选择性提交</h4>
<p>假设我们只希望将 <code>example.txt</code> 文件中的第一行和第二行添加到暂存区，而不提交第三行和第四行的修改。我们可以通过以下步骤实现：</p>
<ol>
<li>
<p>运行 <code>git add -p example.txt</code>，Git 显示第一个修改块。</p>
</li>
<li>
<p>输入 <code>e</code> 并回车，进入编辑模式。</p>
</li>
<li>
<p>手动编辑hunk，只保留我们想添加的修改：</p>
<pre><code class="hljs language-diff" lang="diff">First line of text
Second line of text
</code></pre>
</li>
<li>
<p>保存并退出编辑器。</p>
</li>
</ol>
<p>此时，只有第一行和第二行会被添加到暂存区，而第三行和第四行的修改将不会包含在此次提交中。</p>
<h3 data-id="heading-6">四、交互选项的详细解释</h3>
<h4 data-id="heading-7">1. <code>y</code>（yes）</h4>
<p>输入 <code>y</code> 并回车，将当前hunk添加到暂存区。这是最常用的选项之一，用于确认将当前显示的修改添加到下次提交中。</p>
<h4 data-id="heading-8">2. <code>n</code>（no）</h4>
<p>输入 <code>n</code> 并回车，跳过当前hunk，不将其添加到暂存区。这个选项允许用户选择性地暂存修改，保留未暂存的修改以便以后处理。</p>
<h4 data-id="heading-9">3. <code>q</code>（quit）</h4>
<p>输入 <code>q</code> 并回车，退出交互式添加过程。选择 <code>q</code> 不会暂存任何后续的hunk，适用于希望中断当前操作的情况。</p>
<h4 data-id="heading-10">4. <code>a</code>（all）</h4>
<p>输入 <code>a</code> 并回车，将当前文件的所有剩余修改块添加到暂存区。这个选项适用于确定要将整个文件的修改全部提交的情况。</p>
<h4 data-id="heading-11">5. <code>d</code>（discard）</h4>
<p>输入 <code>d</code> 并回车，不将当前文件的任何修改块添加到暂存区。这个选项用于跳过整个文件的所有修改，适用于希望稍后再处理该文件的情况。</p>
<h4 data-id="heading-12">6. <code>e</code>（edit）</h4>
<p>输入 <code>e</code> 并回车，进入编辑模式。用户可以手动编辑当前的hunk，选择性地添加部分修改。这是一个非常强大的选项，允许精细控制哪些修改被暂存。</p>
<h4 data-id="heading-13">7. <code>?</code>（help）</h4>
<p>输入 <code>?</code> 并回车，显示帮助信息，列出所有交互选项的含义和用法。这是一个有用的选项，特别是在不确定某个选项的作用时。</p>
<h3 data-id="heading-14">五、应用场景</h3>
<h4 data-id="heading-15">1. 代码审查和提交规范</h4>
<p>在团队合作中，良好的提交规范有助于代码审查和版本管理。通过 <code>git add -p</code> 命令，开发者可以将功能完整、逻辑清晰的修改块分别提交，避免将无关或临时修改包含在一次提交中。</p>
<h4 data-id="heading-16">2. 错误修复和功能添加</h4>
<p>在修复错误和添加新功能时，常常会同时修改多个文件。使用 <code>git add -p</code> 可以确保将错误修复和功能添加分别提交，保持提交历史的清晰和可追溯性。</p>
<h4 data-id="heading-17">3. 分阶段提交</h4>
<p>有时，我们在开发过程中可能需要对同一个文件进行多次修改，但希望分阶段提交这些修改。<code>git add -p</code> 允许我们选择性地暂存修改块，实现分阶段提交。</p>
<h3 data-id="heading-18">六、总结</h3>
<p><code>git add -p</code> 命令是 Git 中一个非常强大的工具，能够帮助开发者精细控制哪些修改被包含在提交中。通过交互式的方式，开发者可以逐块选择性地添加修改，避免将不相关或未完成的修改包含在提交中。本文详细介绍了 <code>git add -p</code> 命令的交互选项 <code>[y,n,q,a,d,e,?]</code> 的含义和使用方法，并通过实际案例说明其应用场景。</p>
<p>希望通过本文的介绍，您能够更好地理解和使用 <code>git add -p</code> 命令，从而提升版本控制的效率和规范性。如果您有任何疑问或建议，欢迎在评论区留言讨论。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[由浅入深全面解析ThreadLocal]]></title>    <link>https://juejin.cn/post/7591770429931339826</link>    <guid>https://juejin.cn/post/7591770429931339826</guid>    <pubDate>2026-01-06T02:41:51.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7591770429931339826" data-draft-id="7591800417254998025" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="由浅入深全面解析ThreadLocal"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-01-06T02:41:51.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="掘金者阿豪"/> <meta itemprop="url" content="https://juejin.cn/user/4073055974333608"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            由浅入深全面解析ThreadLocal
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4073055974333608/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    掘金者阿豪
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-06T02:41:51.000Z" title="Tue Jan 06 2026 02:41:51 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-06
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">由浅入深全面解析ThreadLocal</h2>
<p>@<a href="https://link.juejin.cn?target=%25E7%259B%25AE%25E5%25BD%2595" target="_blank" title="%E7%9B%AE%E5%BD%95" ref="nofollow noopener noreferrer">TOC</a></p>
<h3 data-id="heading-1">简介</h3>
<ol>
<li>线程并发：在多线程并发的场景下使用</li>
<li>传递数据：我们可以通过ThreadLocal在同一线程，不同组件中传递公共变量</li>
<li>线程隔离：每个线程的变量都是独立的，不会相互影响</li>
</ol>
<h3 data-id="heading-2">基本使用</h3>
<ol>
<li>
<p>常用方法
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f7b62c9b11b1495f8ff3e87eca54dd7b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5o6Y6YeR6ICF6Zi_6LGq:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768272111&amp;x-signature=2JKieFUsgkIILRqrVSD4rjJQtlo%3D" alt="在这里插入图片描述" loading="lazy"/></p>
</li>
<li>
<p>代码案例实现
(1) 不使用ThreadLocal时模拟多线程存取数据</p>
</li>
</ol>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalDemo1</span> {
    <span class="hljs-keyword">private</span> String content;

    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getContent</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> content;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setContent</span><span class="hljs-params">(String content)</span> {
        <span class="hljs-built_in">this</span>.content = content;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-type">ThreadLocalDemo1</span> <span class="hljs-variable">threadLocalDemo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalDemo1</span>();

        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) {
            <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() {
                <span class="hljs-meta">@Override</span>
                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> {
                    <span class="hljs-comment">/**
                     * 每一个线程存一个变量，过一会取出这个变量
                     */</span>
                    threadLocalDemo.setContent(Thread.currentThread().getName() + <span class="hljs-string">"的数据"</span>);
                    System.out.println(<span class="hljs-string">"------------------------"</span>);
                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">"-----&gt;"</span> + threadLocalDemo.getContent());
                }
            });
            thread.setName(<span class="hljs-string">"线程"</span> + i);
            thread.start();
        }
    }
}
</code></pre>
<p>结果：</p>
<pre><code class="hljs language-java" lang="java">------------------------
线程<span class="hljs-number">0</span>-----&gt;线程<span class="hljs-number">4</span>的数据
------------------------
线程<span class="hljs-number">4</span>-----&gt;线程<span class="hljs-number">4</span>的数据
------------------------
线程<span class="hljs-number">2</span>-----&gt;线程<span class="hljs-number">4</span>的数据
------------------------
线程<span class="hljs-number">3</span>-----&gt;线程<span class="hljs-number">4</span>的数据
------------------------
线程<span class="hljs-number">1</span>-----&gt;线程<span class="hljs-number">4</span>的数据
</code></pre>
<p>（2） 使用ThreadLocal对多线程进行数据隔离，把数据绑定到ThreadLocal
（传统解决方案首先想到的就是加锁，确实可以实现，但是却牺牲了效率，需要等待上一个线程之行结束才可以往下之行）</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalDemo2</span> {
    ThreadLocal&lt;String&gt; threadLocal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();

    <span class="hljs-keyword">private</span> String content;

    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getContent</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> threadLocal.get();
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setContent</span><span class="hljs-params">(String content)</span> {
        threadLocal.set(content);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-type">ThreadLocalDemo2</span> <span class="hljs-variable">threadLocalDemo2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalDemo2</span>();

        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) {
            <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() {
                <span class="hljs-meta">@Override</span>
                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> {
                    <span class="hljs-comment">/**
                     * 每一个线程存一个变量，过一会取出这个变量
                     */</span>
                    threadLocalDemo2.setContent(Thread.currentThread().getName()+<span class="hljs-string">"的数据"</span>);
                    System.out.println(<span class="hljs-string">"------------------------"</span>);
                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">"-----&gt;"</span> + threadLocalDemo2.getContent());
                }
            });
            thread.setName(<span class="hljs-string">"线程"</span> + i);
            thread.start();
        }
    }
}
</code></pre>
<p>结果：</p>
<pre><code class="hljs language-java" lang="java">------------------------
------------------------
------------------------
线程<span class="hljs-number">3</span>-----&gt;线程<span class="hljs-number">3</span>的数据
------------------------
线程<span class="hljs-number">2</span>-----&gt;线程<span class="hljs-number">2</span>的数据
线程<span class="hljs-number">1</span>-----&gt;线程<span class="hljs-number">1</span>的数据
线程<span class="hljs-number">0</span>-----&gt;线程<span class="hljs-number">0</span>的数据
------------------------
线程<span class="hljs-number">4</span>-----&gt;线程<span class="hljs-number">4</span>的数据
</code></pre>
<h3 data-id="heading-3">ThreadLocal与synchronized的区别</h3>
<p>二者都是用来处理多线程并发访问的问题，但是二者的原理和侧重点不一样，简要说就是，ThreadLocal牺牲了空间，而synchronized是牺牲了时间来保证线程安全（隔离）。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7d37392525ef49dba9785f15ab746346~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5o6Y6YeR6ICF6Zi_6LGq:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768272111&amp;x-signature=6HO6ygutpvUzL%2BKmca%2FZmDoqdEI%3D" alt="在这里插入图片描述" loading="lazy"/>
总结：在上述的案例当中，使用ThreadLocal更为合理，这样保证了程序拥有了更高的并发性。</p>
<h3 data-id="heading-4">ThreadLocal现在的设计（JDK1.8）</h3>
<ol>
<li>简介
每一个Thread维护一个ThreadLocalMap，这个Map的key为ThreadLocal实例本身，而value则为实际存储的值。</li>
<li>具体过程
（1）每一个Thread内部都有一个Map（ThreadLocalMap）
（2）Map里面存储的ThreadLocal对象（key）和线程的变量副本（value）
（3）Thread的Map是由ThreadLocal来维护的，由ThreadLocal负责向Map获取和设置线程的变量值。
（4）对于线程获取值，每一个副本只能获取当前线程本地的副本值，别的线程无法访问到，互不干扰，实现了线程隔离。</li>
<li>对比与1.8之前的设计（相当于Thread与ThreadLocal的角色互换了）
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ee58abbba4d6481a82ae9b4dc2e6b133~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5o6Y6YeR6ICF6Zi_6LGq:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768272111&amp;x-signature=hmiGeSxr%2BBAjeJwzdBxL4MVeY4I%3D" alt="在这里插入图片描述" loading="lazy"/></li>
<li>1.8设计的好处
（1）每个Map存储的Entry数量变少了（因为实际状况下Thread比ThreadLocal多）
（2）当Thread销毁时，ThreadLocalMap也会随之销毁，避免内存的浪费</li>
</ol>
<h3 data-id="heading-5">ThreadLocal核心方法源码分析</h3>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/16ffad45a77847ff852cd82b9da9e5b0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5o6Y6YeR6ICF6Zi_6LGq:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768272111&amp;x-signature=WxpReHgNWrEL9%2BS9N1oqKe8eFqw%3D" alt="在这里插入图片描述" loading="lazy"/></p>
<ol>
<li>get方法源码</li>
</ol>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> {
		<span class="hljs-comment">// 获取当前线程</span>
        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();
        <span class="hljs-comment">// 获取ThreadLocalMap</span>
        <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);
        <span class="hljs-comment">// map不为空时，获取里面的Entry</span>
        <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) {
            ThreadLocalMap.<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> map.getEntry(<span class="hljs-built_in">this</span>);
            <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) {
                <span class="hljs-meta">@SuppressWarnings("unchecked")</span>
                <span class="hljs-type">T</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (T)e.value;
                <span class="hljs-comment">// 返回结果</span>
                <span class="hljs-keyword">return</span> result;
            }
        }
        <span class="hljs-comment">// 没有则赋值初始值null并返回</span>
        <span class="hljs-keyword">return</span> setInitialValue();
    }
</code></pre>
<ol start="2">
<li>set方法源码</li>
</ol>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> {
		<span class="hljs-comment">// 获取当前线程</span>
        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();
        <span class="hljs-comment">// 获取ThreadLocalMap</span>
        <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);
        <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) {
        	<span class="hljs-comment">// 不为空直接set</span>
            map.set(<span class="hljs-built_in">this</span>, value);
        } <span class="hljs-keyword">else</span> {
        	<span class="hljs-comment">// map为空则创建并set</span>
            createMap(t, value);
        }
    }
</code></pre>
<ol start="3">
<li>initialValue方法返回初始值（protected修饰为了让子类覆盖设计的）需要自定义初始值可以重写该方法</li>
</ol>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">protected</span> T <span class="hljs-title function_">initialValue</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }
</code></pre>
<ol start="4">
<li>remove方法</li>
</ol>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> {
		 <span class="hljs-comment">// 获取当前线程的ThreadLocalMap</span>
         <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> getMap(Thread.currentThread());
         <span class="hljs-keyword">if</span> (m != <span class="hljs-literal">null</span>) {
         	<span class="hljs-comment">// 移除ThreadLocalMap</span>
             m.remove(<span class="hljs-built_in">this</span>);
         }
     }
</code></pre>
<ol start="5">
<li>setInitialValue方法</li>
</ol>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">private</span> T <span class="hljs-title function_">setInitialValue</span><span class="hljs-params">()</span> {
		<span class="hljs-comment">// 得到初始化值null</span>
        <span class="hljs-type">T</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> initialValue();
        <span class="hljs-comment">// 获取当前线程</span>
        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();
        <span class="hljs-comment">// 获取线程中ThreadLocalMap</span>
        <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);
        <span class="hljs-comment">// map存在的话把null设置进去，不存在则创建一个并将null设置进去</span>
        <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) {
            map.set(<span class="hljs-built_in">this</span>, value);
        } <span class="hljs-keyword">else</span> {
            createMap(t, value);
        }
        <span class="hljs-comment">// 如果当前ThreadLocal属于TerminatingThreadLocal（关闭的ThreadLocal）则register（注册）到TerminatingThreadLocal</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> <span class="hljs-keyword">instanceof</span> TerminatingThreadLocal) {
            TerminatingThreadLocal.register((TerminatingThreadLocal&lt;?&gt;) <span class="hljs-built_in">this</span>);
        }
        <span class="hljs-keyword">return</span> value;
    }
</code></pre>
<h3 data-id="heading-6">ThreadLocalMap源码分析</h3>
<ol>
<li>简介
ThreadLocalMap是ThreadLocal的内部类，没有实现Map接口，是独自设计实现Map功能，内部的Entry也是独立的。</li>
<li>结构图解
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d16907aa70f24eafb773a976661dabd4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5o6Y6YeR6ICF6Zi_6LGq:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768272111&amp;x-signature=Uz%2BYtJDUBrji90vew0IkRMK%2FFMo%3D" alt="在这里插入图片描述" loading="lazy"/></li>
<li>成员变量</li>
</ol>
<pre><code class="hljs language-java" lang="java">		<span class="hljs-comment">// Entry类，继承弱应用，为了和Thread的生命周期解绑</span>
		<span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; {
            <span class="hljs-comment">/** The value associated with this ThreadLocal. */</span>
            Object value;

            Entry(ThreadLocal&lt;?&gt; k, Object v) {
                <span class="hljs-built_in">super</span>(k);
                value = v;
            }
        }

        <span class="hljs-comment">/**
         * The initial capacity -- MUST be a power of two.
         * 初始容量，必须是二的幂
         */</span>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span>;

        <span class="hljs-comment">/**
         * The table, resized as necessary.
         * table.length MUST always be a power of two.
         * 根据需要调整大小。长度必须是2的幂。
         */</span>
        <span class="hljs-keyword">private</span> Entry[] table;

        <span class="hljs-comment">/**
         * The number of entries in the table.
         * table中的entrie数量
         */</span>
        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;

        <span class="hljs-comment">/**
         * The next size value at which to resize.
         * 要调整大小的下一个大小值
         */</span>
        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> threshold; <span class="hljs-comment">// Default to 0</span>

        <span class="hljs-comment">/**
         * Set the resize threshold to maintain at worst a 2/3 load factor.
         * 设置调整大小阈值以维持最坏的2/3负载因子
         */</span>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setThreshold</span><span class="hljs-params">(<span class="hljs-type">int</span> len)</span> {
            threshold = len * <span class="hljs-number">2</span> / <span class="hljs-number">3</span>;
        }

        <span class="hljs-comment">/**
         * Increment i modulo len.
         * 增量一
         */</span>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nextIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> len)</span> {
            <span class="hljs-keyword">return</span> ((i + <span class="hljs-number">1</span> &lt; len) ? i + <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);
        }

        <span class="hljs-comment">/**
         * Decrement i modulo len.
         * 减量一
         */</span>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">prevIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> len)</span> {
            <span class="hljs-keyword">return</span> ((i - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>) ? i - <span class="hljs-number">1</span> : len - <span class="hljs-number">1</span>);
        }
</code></pre>
<h3 data-id="heading-7">弱引用与内存泄露（内存泄漏和弱引用没有直接关系）</h3>
<ol>
<li>内存泄漏/溢出概念
（1）Memory overflow：内存溢出，没有足够的空间提供给申请者使用
（2）Memory leak：内存泄漏，系统中已动态分配的堆内存由于某种原因无法释放或者没有释放，导致系统内存堆积，影响系统运行，甚至导致系统崩溃。内存泄漏终将导致内存溢出。</li>
<li>强/弱引用概念
（1）Strong Referce：强引用，我们常见的对象引用，只要有一个强引用指向对象，也就表明还“活着”，这种状况下垃圾回收机制（GC）是不会回收的。
（2）Weak Referce：弱引用，继承了WeakReferce的对象，垃圾回收器发现了只具有弱引用的对象，不管当前系统的内存是否充足，都会回收他的内存。</li>
<li>如果key，即Entry使用强引用，也无法避免内存泄漏
因为Entry是在Thread当前线程中，生命周期和Thread一样，没有手动删除Entry时Entry就会内存泄漏。</li>
<li>也就是说，<strong>只要在调用完ThreadLocal后及时使用remove方法，才能避免内存泄漏</strong>
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/42193776949a47409dc7cdb92e899735~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5o6Y6YeR6ICF6Zi_6LGq:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768272111&amp;x-signature=9scZWgbu8re9Lja5Ys%2FtPQjYYe4%3D" alt="在这里插入图片描述" loading="lazy"/>
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1ecedcf226df46698d6e595c02cafb80~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5o6Y6YeR6ICF6Zi_6LGq:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768272111&amp;x-signature=mEy403lTwhzaTSZYNDJTeo8WSSM%3D" alt="在这里插入图片描述" loading="lazy"/></li>
</ol>
<h3 data-id="heading-8">ThreadLocal核心源码（Hash冲突解决）</h3>
<ol>
<li>从构造方法入手</li>
</ol>
<pre><code class="hljs language-java" lang="java">
		ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) {
			<span class="hljs-comment">// 初始化table</span>
            table = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[INITIAL_CAPACITY];
            <span class="hljs-comment">// 计算索引在数组中的位置（核心代码）</span>
            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="hljs-number">1</span>);
            <span class="hljs-comment">// 设置值</span>
            table[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(firstKey, firstValue);
            size = <span class="hljs-number">1</span>;
            <span class="hljs-comment">// 设置阈值（INITIAL_CAPACITY的三分之二）</span>
            setThreshold(INITIAL_CAPACITY);
        }
</code></pre>
<ol start="2">
<li>重点分析int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1);</li>
</ol>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">threadLocalHashCode</span> <span class="hljs-operator">=</span> nextHashCode();

<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nextHashCode</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);
    }
    
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">nextHashCode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();

<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">HASH_INCREMENT</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x61c88647</span>;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndAdd</span><span class="hljs-params">(<span class="hljs-type">int</span> delta)</span> {
        <span class="hljs-keyword">return</span> unsafe.getAndAddInt(<span class="hljs-built_in">this</span>, valueOffset, delta);
    }
</code></pre>
<p>（1）这里定义了一个AtomicInteger，每次获取并加上HASH_INCREMENT（0x61c88647，这个值与斐波那契数（黄金分割）有关），是为了让哈希码能够均匀的分布在2的n次方的数组（Entry[]）里面，也就尽可能避免了哈希冲突。
（2）hashcode &amp; (INITIAL_CAPACITY - 1)  相当于hashcode % (INITIAL_CAPACITY - 1)  的高效写法，所以size必须为2的次幂，这样最大程度避免了哈希冲突。</p>
<ol start="3">
<li>set方法源码分析</li>
</ol>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, Object value)</span> {
    		
            Entry[] tab = table;
            <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;
            <span class="hljs-comment">// 计算索引</span>
            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (len-<span class="hljs-number">1</span>);
            <span class="hljs-comment">/**
            *
            * 使用线性探测法查找元素
            * */</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> tab[i];
                 e != <span class="hljs-literal">null</span>;
                 <span class="hljs-comment">// 使用线性探测法查找元素</span>
                 e = tab[i = nextIndex(i, len)]) {
                 <span class="hljs-comment">// 获取到该Entry对应的ThreadLocal</span>
                ThreadLocal&lt;?&gt; k = e.get();
                <span class="hljs-keyword">if</span> (k == key) {
                <span class="hljs-comment">// key存在则覆盖value</span>
                    e.value = value;
                    <span class="hljs-keyword">return</span>;
                }
                <span class="hljs-comment">// key为null但是值不为null，这说明了之前使用过，但是ThreadLocal被垃圾回收了，当前的Entry是一个陈旧的（Stale）元素</span>
                <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>) {
                <span class="hljs-comment">// key（ThreadLocal）不存在，则新Entry替换旧的Entry，此方法做了不少垃圾清理的动作，避免了内存泄漏。</span>
                    replaceStaleEntry(key, value, i);
                    <span class="hljs-keyword">return</span>;
                }
            }
            <span class="hljs-comment">// ThreadLocal中未找到key也没有陈旧的元素，此时则在这个位置新创建一个Entry</span>
            tab[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(key, value);
            <span class="hljs-type">int</span> <span class="hljs-variable">sz</span> <span class="hljs-operator">=</span> ++size;
            <span class="hljs-comment">// cleanSomeSlots用于清理e.get()为null的key，如果大于阈值（2/3容量）则rehash（执行一次全表扫描清理工作）</span>
            <span class="hljs-keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)
                rehash();
        }
		<span class="hljs-comment">/**
		* 线性探测法查找元素，到最后一个时重定位到第一个
		*/</span>
		<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nextIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> len)</span> {
            <span class="hljs-keyword">return</span> ((i + <span class="hljs-number">1</span> &lt; len) ? i + <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);
        }
</code></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[别再堆if-else验参数了！FastAPI自带的参数验证器，至少省一半调试时间]]></title>    <link>https://juejin.cn/post/7591801024009486345</link>    <guid>https://juejin.cn/post/7591801024009486345</guid>    <pubDate>2026-01-06T02:40:50.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7591801024009486345" data-draft-id="7591801024009437193" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="别再堆if-else验参数了！FastAPI自带的参数验证器，至少省一半调试时间"/> <meta itemprop="keywords" content="Python,FastAPI"/> <meta itemprop="datePublished" content="2026-01-06T02:40:50.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="王二哥的技术笔记"/> <meta itemprop="url" content="https://juejin.cn/user/3358381525700410"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            别再堆if-else验参数了！FastAPI自带的参数验证器，至少省一半调试时间
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3358381525700410/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    王二哥的技术笔记
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-06T02:40:50.000Z" title="Tue Jan 06 2026 02:40:50 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-06
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8fbdf7cde6ef4ff4ace933f581acb422~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg546L5LqM5ZOl55qE5oqA5pyv56yU6K6w:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768272050&amp;x-signature=eWQSslwYchRUsufwbtojDlaohPI%3D" alt="fHbUZC5Mq" loading="lazy"/></p>
<p>你是不是也遇到过这样的场景——用户传了个 <code>book_id=-1</code>，接口直接崩了？或者查询评分时塞进来一个 <code>rating=999</code>，数据库默默吐出所有内容？</p>
<p><strong>没验证的参数，就像没锁的门。</strong></p>
<p>上一期文章中，我们学习了如何使用 Pydantic 对请求体进行数据验证。今天，我们将深入探讨FastAPI的另外两种重要验证方式：<strong>路径参数验证</strong>和<strong>查询参数验证</strong>。</p>
<p>访问上一篇文章，请点击：<a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FzJd23wpb-IPqlIU-czHBKQ" target="_blank" title="https://mp.weixin.qq.com/s/zJd23wpb-IPqlIU-czHBKQ" ref="nofollow noopener noreferrer">跳转</a></p>
<h3 data-id="heading-0">为什么需要验证路径和查询参数？</h3>
<p>当我们构建RESTful API时，除了请求体数据，路径参数和查询参数同样需要严格的验证：</p>
<p><strong>路径参数</strong>：如<code>/books/{book_id}</code>中的<code>book_id</code></p>
<p><strong>查询参数</strong>：如<code>/books?rating=5</code>中的<code>rating</code></p>
<p>没有验证的参数就像没有安检的入口，可能导致各种安全问题和非预期行为。</p>
<h3 data-id="heading-1">路径参数验证：精准控制资源访问</h3>
<p><strong>问题场景分析</strong>：以图书查询接口为例</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">"/books/{book_id}"</span></span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_book</span>(<span class="hljs-params">book_id: <span class="hljs-built_in">int</span></span>):
    <span class="hljs-keyword">for</span> book <span class="hljs-keyword">in</span> BOOKS:
        <span class="hljs-keyword">if</span> book.<span class="hljs-built_in">id</span> == book_id:
            <span class="hljs-keyword">return</span> book
    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
</code></pre>
<p>这个接口会存在两个问题：</p>
<ol>
<li>书籍不存在时，返回<code>None</code>，用户体验不是很好。</li>
<li>没有对<code>book_id</code>参数进行合法性验证（如负数、零值）</li>
</ol>
<p><strong>解决方案：使用Path进行验证</strong></p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> Path

<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">"/books/{book_id}"</span></span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_book</span>(<span class="hljs-params">book_id: <span class="hljs-built_in">int</span> = Path(<span class="hljs-params">gt=<span class="hljs-number">0</span></span>)</span>):
    <span class="hljs-keyword">for</span> book <span class="hljs-keyword">in</span> BOOKS:
        <span class="hljs-keyword">if</span> book.<span class="hljs-built_in">id</span> == book_id:
            <span class="hljs-keyword">return</span> book
    <span class="hljs-keyword">return</span> {<span class="hljs-string">"error"</span>: <span class="hljs-string">"Book not found"</span>}
</code></pre>
<p>关键改进：</p>
<ol>
<li><code>Path(gt=0)</code> 确保 book_id 参数必须大于 0。</li>
<li>当书籍不存在时，给用户返回明确的错误提示。</li>
</ol>
<p><strong>验证效果展示</strong></p>
<p>回到浏览器的 Swagger UI 页面，刷新页面。我们进入 <code>GET /books/{book_id}</code> 接口，传入 <code>book_id=0</code>。</p>
<p>FastAPI自动返回422错误，及如下异常响应信息：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"detail"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
    <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"greater_than"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"loc"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
        <span class="hljs-string">"path"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-string">"book_id"</span>
      <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"msg"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Input should be greater than 0"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"input"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"0"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"ctx"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">"gt"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span>
      <span class="hljs-punctuation">}</span>
    <span class="hljs-punctuation">}</span>
  <span class="hljs-punctuation">]</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p>从错误信息中，用户就可以明确的了解到，我们传入的 <code>book_id</code> 参数必须大于 0。</p>
<p><strong>删除接口做同步优化</strong></p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-meta">@app.delete(<span class="hljs-params"><span class="hljs-string">"/books/{book_id}"</span></span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">delete_book</span>(<span class="hljs-params">book_id: <span class="hljs-built_in">int</span> = Path(<span class="hljs-params">gt=<span class="hljs-number">0</span></span>)</span>):
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(BOOKS)):
        <span class="hljs-keyword">if</span> BOOKS[i].<span class="hljs-built_in">id</span> == book_id:
            BOOKS.pop(i)
            <span class="hljs-keyword">break</span>
</code></pre>
<h3 data-id="heading-2">查询参数验证：确保筛选条件的合理性</h3>
<p><strong>问题场景分析</strong>：图书按评分查询接口为例</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">"/books/"</span></span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_books_by_rating</span>(<span class="hljs-params">book_rating: <span class="hljs-built_in">int</span></span>):
    books_to_return = []
    <span class="hljs-keyword">for</span> book <span class="hljs-keyword">in</span> BOOKS:
        <span class="hljs-keyword">if</span> book.rating == book_rating:
            books_to_return.append(book)
    <span class="hljs-keyword">return</span> books_to_return
</code></pre>
<p>存在的问题：评分范围并没有做限制（如，可能会传入0或6）</p>
<p><strong>解决方案：使用Query进行验证</strong></p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> Query

<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">"/books/"</span></span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_books_by_rating</span>(<span class="hljs-params">book_rating: <span class="hljs-built_in">int</span> = Query(<span class="hljs-params">gt=<span class="hljs-number">0</span>, lt=<span class="hljs-number">6</span></span>)</span>):
    books_to_return = []
    <span class="hljs-keyword">for</span> book <span class="hljs-keyword">in</span> BOOKS:
        <span class="hljs-keyword">if</span> book.rating == book_rating:
            books_to_return.append(book)
    <span class="hljs-keyword">return</span> books_to_return
</code></pre>
<p>验证规则说明：</p>
<p><code>gt=0</code>：必须大于 0
<code>lt=6</code>：必须小于 6</p>
<p>综合效果：只允许1-5的整数评分</p>
<p><strong>验证效果展示</strong></p>
<p>回到浏览器的 Swagger UI 页面，刷新页面。我们进入 <code>GET /books/</code> 接口，传入 <code>book_rating=0</code>。</p>
<p>FastAPI自动返回422错误，及如下异常响应信息：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"detail"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
    <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"greater_than"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"loc"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
        <span class="hljs-string">"query"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-string">"book_rating"</span>
      <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"msg"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Input should be greater than 0"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"input"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"0"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"ctx"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">"gt"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span>
      <span class="hljs-punctuation">}</span>
    <span class="hljs-punctuation">}</span>
  <span class="hljs-punctuation">]</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p>从错误信息中，用户就可以明确的了解到，我们传入的 <code>book_rating</code> 参数必须大于 0。</p>
<h3 data-id="heading-3">Path 与 Query 验证的对比</h3>






























<table><thead><tr><th>特性</th><th>Path 参数验证</th><th>Query 参数验证</th></tr></thead><tbody><tr><td>使用场景</td><td>资源标识（如ID）</td><td>筛选条件（如评分、分类）</td></tr><tr><td>导入方式</td><td><code>from fastapi import Path</code></td><td><code>from fastapi import Query</code></td></tr><tr><td>语法示例</td><td><code>book_id: int = Path(gt=0)</code></td><td><code>rating: int = Query(gt=0, lt=6)</code></td></tr><tr><td>验证重点</td><td>确保资源标识的合法性</td><td>确保查询条件的合理性</td></tr></tbody></table>
<h3 data-id="heading-4">最佳实践</h3>
<ol>
<li><strong>始终验证</strong>：对所有输入参数进行验证，不信任任何外部输入</li>
<li><strong>明确范围</strong>：为数值参数设置合理的上下限</li>
<li><strong>统一错误处理</strong>：保持错误响应格式的一致性</li>
<li><strong>文档完善</strong>：良好的验证规则会自动体现在API文档中</li>
</ol>
<h3 data-id="heading-5">下节预告</h3>
<p>掌握了这些基础验证后，下一期我们将深入探讨 FastAPI 中常用状态码和 HTTP 异常的实现，让你的 API 更加标准和专业。</p>
<p>欢迎 “关注”，我们在下一期一起来解锁这个问题。</p>
<hr/>
<p>-------- <strong>写在最后</strong> --------</p>
<p><strong>关注我</strong>，每天1分钟，轻松懂 Python</p>
<p><strong>我的同名公众号正在连载《FastAPI 开发实战》、《Python 核心技术》、《职场》。</strong></p>
<hr/>
<p><strong>点赞</strong> ：支持技术分享！</p>
<p><strong>分享</strong> ：分享给身边感兴趣的朋友！</p>
<p><strong>关注我</strong> ：获取更多FastAPI实战技巧！</p>
<hr/>
<p>#Python #FastAPI #API #Web开发 #程序员 #编程教程 #效率提升 #后端开发 #API设计 #参数验证</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[1分钟解锁Python神技：用生成器轻松处理1亿条数据！]]></title>    <link>https://juejin.cn/post/7591801024009535497</link>    <guid>https://juejin.cn/post/7591801024009535497</guid>    <pubDate>2026-01-06T02:45:15.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7591801024009535497" data-draft-id="7591792747776229386" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="1分钟解锁Python神技：用生成器轻松处理1亿条数据！"/> <meta itemprop="keywords" content="Python"/> <meta itemprop="datePublished" content="2026-01-06T02:45:15.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="王二哥的技术笔记"/> <meta itemprop="url" content="https://juejin.cn/user/3358381525700410"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            1分钟解锁Python神技：用生成器轻松处理1亿条数据！
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3358381525700410/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    王二哥的技术笔记
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-06T02:45:15.000Z" title="Tue Jan 06 2026 02:45:15 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-06
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0866826f7c24425aa1a4b7022e356173~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg546L5LqM5ZOl55qE5oqA5pyv56yU6K6w:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768272314&amp;x-signature=FNSviGl8ywVB%2FERz3KX4V9OWPn8%3D" alt="202601052005209941" loading="lazy"/></p>
<p>欢迎来到「每天1分钟，轻松懂Python」！今天的主角是：<strong>生成器</strong>。</p>
<p>它能让你用几乎忽略不计的内存，处理无限大的数据流。比如，轻松遍历1亿条数据而不会撑爆你的内存。</p>
<p><strong>核心价值就一点：惰性计算——需要时才生产，绝不提前浪费空间。</strong></p>
<p>1分钟时间，我们从概念、代码、案例出发。让你不仅看懂，更能马上用起来！</p>
<h3 data-id="heading-0">容器、可迭代对象、迭代器</h3>
<p><strong>容器</strong>：在 Python 中一切皆为对象，对象的集合就是容器。</p>
<p><strong>可迭代对象</strong>：<strong>实现了<code>__iter__()</code>方法</strong>的对象，或者说，是能返回一个迭代器的对象。</p>
<p>所有容器都是可迭代对象，但可迭代对象不一定是容器。</p>
<p><strong>迭代器</strong>：<strong>实现了<code>__iter__()</code>和<code>__next__()</code>方法</strong>的对象。它提供一个 next 方法，当你调用这个方法后，要么得到下一个对象，要么抛出 StopIteration 异常。</p>
<h5 data-id="heading-1">1、判断可迭代对象</h5>
<p>通过 <code>iter()</code> 函数尝试转换，捕获 <code>TypeError</code> 判断：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">is_iterable</span>(<span class="hljs-params">param</span>):  
    <span class="hljs-keyword">try</span>:  
        <span class="hljs-built_in">iter</span>(param)  
        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>  
    <span class="hljs-keyword">except</span> TypeError:  
        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>  

<span class="hljs-comment"># 测试：列表、字典等返回 True，数字返回 False  </span>
</code></pre>
<h3 data-id="heading-2">生成器：更轻量的迭代器</h3>
<h5 data-id="heading-3">1、核心优势</h5>
<p><strong>惰性计算</strong>：仅在调用 <code>next()</code> 时生成元素，（比预先生成大列表 ）节省内存。</p>
<p><strong>简单语法</strong>：使用生成器表达式（<code>(i for i in range(10))</code> ）或 <code>yield</code> 关键字定义。</p>
<pre><code class="hljs language-lua" lang="lua">对于 <span class="hljs-built_in">yield</span>，可以理解为：
函数运行到这一行的时候，程序会从这里暂停，然后跳出。跳到 <span class="hljs-built_in">next</span>() 函数。
每次调用 `<span class="hljs-built_in">next</span>(gen)` 时，暂停的程序，就会从 <span class="hljs-built_in">yield</span> 这里向下继续执行；
</code></pre>
<h5 data-id="heading-4">2、基础用法</h5>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 1. 生成器表达式</span>
gen = (i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>))
<span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(gen))  <span class="hljs-comment"># 输出 0</span>
<span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(gen))  <span class="hljs-comment"># 输出 1</span>
<span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(gen))  <span class="hljs-comment"># 输出 2</span>
<span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(gen))  <span class="hljs-comment"># StopIteration</span>

<span class="hljs-comment"># 2. yield 关键字</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">my_generator</span>():
    <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>
    <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>
    <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span>


gen = my_generator()
<span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(gen))  <span class="hljs-comment"># 输出 1</span>
<span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(gen))  <span class="hljs-comment"># 输出 2</span>
<span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(gen))  <span class="hljs-comment"># 输出 3</span>
<span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(gen))  <span class="hljs-comment"># StopIteration</span>
</code></pre>
<h3 data-id="heading-5">实战应用</h3>
<h5 data-id="heading-6">1、内存优化对比</h5>
<p>生成器可以避免预存大量数据，适合处理超大序列：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> pympler <span class="hljs-keyword">import</span> asizeof

<span class="hljs-comment"># 迭代器</span>
large_list = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>**<span class="hljs-number">5</span>)]

<span class="hljs-comment"># 生成器</span>
<span class="hljs-comment"># 仅保存生成逻辑，内存大小不随数据量大小变化，内存占用极低</span>
large_gen = (i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>**<span class="hljs-number">5</span>))

<span class="hljs-comment"># 输出：列表占用内存: 3907.21 KB</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"列表占用内存: <span class="hljs-subst">{asizeof.asizeof(large_list) / <span class="hljs-number">1024</span>:<span class="hljs-number">.2</span>f}</span> KB"</span>)
<span class="hljs-comment"># 输出：生成器占用内存: 0.45 KB</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"生成器占用内存: <span class="hljs-subst">{asizeof.asizeof(large_gen) / <span class="hljs-number">1024</span>:<span class="hljs-number">.2</span>f}</span> KB"</span>)
</code></pre>
<h5 data-id="heading-7">2、复杂逻辑实现：验证数学公式</h5>
<p>用生成器动态生成数列，验证等式 <code>(1+2+...+n)² = 1³+2³+...+n³</code>：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 使用生成器</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">generator</span>(<span class="hljs-params">k</span>):  
    i = <span class="hljs-number">1</span>  
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:  
        <span class="hljs-keyword">yield</span> i**k  
        i += <span class="hljs-number">1</span>  

gen_1 = generator(<span class="hljs-number">2</span>)  <span class="hljs-comment"># 生成 1,4,9...</span>
gen_3 = generator(<span class="hljs-number">3</span>)  <span class="hljs-comment"># 生成 1³,2³,3³...  </span>
</code></pre>
<h5 data-id="heading-8">3、算法简化：子序列判断</h5>
<p>用生成器 + 迭代器，可以更简洁实现 “判断子序列” 逻辑：</p>
<p>LeetCode 题目：<a href="https://link.juejin.cn?target=https%3A%2F%2Fleetcode.com%2Fproblems%2Fis-subsequence%2F" target="_blank" title="https://leetcode.com/problems/is-subsequence/" ref="nofollow noopener noreferrer">leetcode.com/problems/is…</a></p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">is_subsequence</span>(<span class="hljs-params">a, b</span>):  
    b = <span class="hljs-built_in">iter</span>(b)  <span class="hljs-comment"># 转为迭代器  </span>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">all</span>(i <span class="hljs-keyword">in</span> b <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> a)  

<span class="hljs-comment"># 测试：a = [1,3,5] 是 b = [1,2,3,4,5] 的子序列  </span>
<span class="hljs-built_in">print</span>(is_subsequence([<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]))  <span class="hljs-comment"># True  </span>
<span class="hljs-built_in">print</span>(is_subsequence([<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]))  <span class="hljs-comment"># False</span>
</code></pre>
<h3 data-id="heading-9">高频面试题</h3>
<p>01、<strong>可迭代对象和迭代器的区别？</strong></p>
<pre><code class="hljs language-markdown" lang="markdown">可迭代对象：实现 <span class="hljs-strong">__iter__</span>，可转为迭代器（如 list ）。
迭代器：实现 <span class="hljs-strong">__iter__</span> 和 <span class="hljs-strong">__next__</span>，支持 next() 逐个取元素。
</code></pre>
<p>02、<strong>生成器的 <code>yield</code> 有什么作用？</strong></p>
<pre><code class="hljs language-scss" lang="scss">暂停函数执行，保留当前状态（如变量值 ）。返回一个值给调用者。
下次 <span class="hljs-built_in">next</span>() 调用时从暂停处继续执行。
</code></pre>
<p>03、<strong>生成器为什么能节省内存？</strong></p>
<pre><code class="hljs language-scss" lang="scss">生成器是 “惰性计算”，不预存所有元素，仅在调用 <span class="hljs-built_in">next</span>() 时动态生成。
因此，内存占用远低于预先生成大列表的迭代器。
</code></pre>
<p>04、<code>for</code> 循环如何遍历可迭代对象？</p>
<pre><code class="hljs language-scss" lang="scss">for 循环自动将可迭代对象转为迭代器（调用 <span class="hljs-built_in">iter</span>() ）。
然后，循环调用 <span class="hljs-built_in">next</span>()，直到捕获 StopIteration 异常退出。
</code></pre>
<p>05、<strong>哪些场景适合用生成器？</strong></p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-bullet">1.</span> 处理超大序列（如一亿条数据 ），避免内存溢出。
<span class="hljs-bullet">2.</span> 实现动态生成逻辑（如无限数列、实时数据流 ）。
<span class="hljs-bullet">3.</span> 简化代码（如子序列判断、复杂数学验证 ）。
</code></pre>
<p>06、生成器迭代结束后，继续调用 <code>next()</code> 会怎样？</p>
<pre><code class="hljs">抛出 StopIteration 异常，提示迭代已结束。
</code></pre>
<hr/>
<p>-------- <strong>写在最后</strong> --------</p>
<p><strong>关注我</strong>，每天1分钟，轻松懂 Python</p>
<p><strong>我的同名公众号正在连载《FastAPI 开发实战》、《Python 核心技术》、《职场》。</strong></p>
<hr/>
<p><strong>点赞</strong> ：如果觉得有收获，点赞支持一下吧！</p>
<p><strong>分享</strong> ：分享给身边同样对Python感兴趣的朋友！</p>
<p><strong>关注我</strong> ：不要错过每一篇 Python 实战内容！</p>
<hr/>
<p>#Python #FastAPI #API #Web开发 #程序员 #编程教程 #效率提升 #装饰器</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[003-spring cloud alibaba之gateway网关]]></title>    <link>https://juejin.cn/post/7592017365141061684</link>    <guid>https://juejin.cn/post/7592017365141061684</guid>    <pubDate>2026-01-06T02:52:46.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7592017365141061684" data-draft-id="7591704324907728930" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="003-spring cloud alibaba之gateway网关"/> <meta itemprop="keywords" content="微服务"/> <meta itemprop="datePublished" content="2026-01-06T02:52:46.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="超级小猪"/> <meta itemprop="url" content="https://juejin.cn/user/3702810891008525"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            003-spring cloud alibaba之gateway网关
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3702810891008525/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    超级小猪
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-06T02:52:46.000Z" title="Tue Jan 06 2026 02:52:46 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-06
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">gateway</h2>
<blockquote>
<p>gateway网关主要就是对外接收各种请求，然后根据自己内容的路由逻辑将请求发给服务</p>
</blockquote>
<pre><code class="hljs language-mermaid" lang="mermaid">graph TD
Start --&gt; gateway
gateway --&gt; 路由
路由 --&gt; user
路由 --&gt; base
路由 --&gt; order
路由 --&gt; ...
</code></pre>
<h3 data-id="heading-1">gateway服务搭建</h3>
<h4 data-id="heading-2">第1步：依赖</h4>
<p>构建一个gateway服务只需要增加相应的依赖</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"UTF-8"</span>?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span>
         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span>
         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>gateway<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">spring-cloud-alibaba-version</span>&gt;</span>2021.1<span class="hljs-tag">&lt;/<span class="hljs-name">spring-cloud-alibaba-version</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">spring-cloud.version</span>&gt;</span>2020.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">spring-cloud.version</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">spring-boot.version</span>&gt;</span>2.4.2<span class="hljs-tag">&lt;/<span class="hljs-name">spring-boot.version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>${spring-cloud-alibaba-version}<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>${spring-cloud.version}<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>${spring-boot.version}<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span>
</code></pre>
<h4 data-id="heading-3">第2步：创建yaml文件</h4>
<p>主要是要新增路由逻辑配置</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">server:</span>
  <span class="hljs-attr">port:</span> <span class="hljs-number">9999</span>
<span class="hljs-attr">spring:</span>
  <span class="hljs-attr">application:</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">gateway-service</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">nacos:</span>
      <span class="hljs-attr">discovery:</span>
        <span class="hljs-attr">server-addr:</span> <span class="hljs-number">10.106</span><span class="hljs-number">.114</span><span class="hljs-number">.1</span><span class="hljs-string">:8848</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">user</span>
          <span class="hljs-attr">uri:</span> <span class="hljs-string">http://10.106.114.1:9001/</span>
          <span class="hljs-attr">predicates:</span>
            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/user/**</span>
</code></pre>
<p>上面配置的gateway.routes就是路由</p>
<ul>
<li>
<p>id：标记路由</p>
</li>
<li>
<p>predicates：路由配置</p>
<ul>
<li>Path：其中一个路径，上面<code>/user/**</code>表示当请求localhost:9999/user/xxx时，会将请求转发到<code>http://10.106.114.1:9001/user/xxx</code></li>
</ul>
</li>
<li>
<p>uri：转发的地址</p>
</li>
</ul>
<h4 data-id="heading-4">第3步：启动类</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@EnableDiscoveryClient</span>
<span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GatewayStartApplication</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        SpringApplication.run(GatewayStartApplication.class,args);
    }
}
</code></pre>
<h4 data-id="heading-5">第4步创建user服务</h4>
<p>user服务主要要注意的是，由于请求是<code>http://10.106.114.1:9001/user/xxx</code>多了一个user，所以需要在user服务里面增加context-path。下面是user服务的配置</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">server:</span>
  <span class="hljs-attr">port:</span> <span class="hljs-number">9001</span>
  <span class="hljs-attr">servlet:</span>
    <span class="hljs-attr">context-path:</span> <span class="hljs-string">/user/</span>

<span class="hljs-attr">spring:</span>
  <span class="hljs-attr">application:</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">user</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">discovery:</span>
      <span class="hljs-attr">server-addr:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:8848</span>

<span class="hljs-attr">management:</span>
  <span class="hljs-attr">endpoint:</span>
    <span class="hljs-attr">web:</span>
      <span class="hljs-attr">exposure:</span>
        <span class="hljs-string">include:'*'</span>
</code></pre>
<h4 data-id="heading-6">第5步验证</h4>
<ul>
<li>启动nacos</li>
<li>启动gateway</li>
<li>启动user</li>
<li>访问9001：<a href="https://link.juejin.cn?target=http%3A%2F%2F10.106.114.1%3A9001%2Fuser%2Fhello" target="_blank" title="http://10.106.114.1:9001/user/hello" ref="nofollow noopener noreferrer">http://10.106.114.1:9001/user/hello</a> 确定user服务正常</li>
<li>访问9999：<a href="https://link.juejin.cn?target=http%3A%2F%2F10.106.114.1%3A9999%2Fuser%2Fhello" target="_blank" title="http://10.106.114.1:9999/user/hello" ref="nofollow noopener noreferrer">http://10.106.114.1:9999/user/hello</a></li>
</ul>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/840f6d3c427a430e8ad3597e48a9bf1a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6LaF57qn5bCP54yq:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768272765&amp;x-signature=k5m2Wq%2BHi%2FC8QYc80Jqp3zT1So8%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-7">自定义路由</h3>
<p>上面使用的配置文件来实现路由。也可以使用自定义类来实现路由模式。</p>
<h4 data-id="heading-8">第1步：注释yaml里面的路由配置</h4>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/78ccb9e37a944c679d51557d0d6b8f4d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6LaF57qn5bCP54yq:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768272765&amp;x-signature=oR1VO5Fk4mSZ%2BSsy6mMFrJC%2F1kU%3D" alt="image.png" loading="lazy"/></p>
<h4 data-id="heading-9">第2步：创建自定义类路由</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">import</span> org.springframework.cloud.gateway.route.RouteLocator;
<span class="hljs-keyword">import</span> org.springframework.cloud.gateway.route.builder.RouteLocatorBuilder;
<span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;
<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;


<span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GatewayConfig</span> {

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-keyword">public</span> RouteLocator <span class="hljs-title function_">customerRouteLocator</span><span class="hljs-params">(RouteLocatorBuilder routeLocatorBuilder)</span>{
        System.out.println(<span class="hljs-string">"加载路由"</span>);
        RouteLocatorBuilder.<span class="hljs-type">Builder</span> <span class="hljs-variable">routes</span> <span class="hljs-operator">=</span> routeLocatorBuilder.routes();
        routes.route(<span class="hljs-string">"user"</span>,
                r-&gt;r.path(<span class="hljs-string">"/user/**"</span>).uri(<span class="hljs-string">"http://10.106.114.1:9001/"</span>));
        <span class="hljs-keyword">return</span> routes.build();
    }
}
</code></pre>
<h4 data-id="heading-10">第3步：验证</h4>
<p>效果同样</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8ccaa371421b4fca8c103383818fb09c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6LaF57qn5bCP54yq:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768272765&amp;x-signature=yXcOf8dMw4%2FwoP6t4kBF0on%2F714%3D" alt="image.png" loading="lazy"/></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[原型污染安全漏洞]]></title>    <link>https://juejin.cn/post/7591728734983012379</link>    <guid>https://juejin.cn/post/7591728734983012379</guid>    <pubDate>2026-01-05T15:59:03.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7591728734983012379" data-draft-id="7591719013488394278" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="原型污染安全漏洞"/> <meta itemprop="keywords" content="前端,强化学习"/> <meta itemprop="datePublished" content="2026-01-05T15:59:03.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="在西安放羊的牛油果"/> <meta itemprop="url" content="https://juejin.cn/user/2946346894233133"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            原型污染安全漏洞
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2946346894233133/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    在西安放羊的牛油果
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-05T15:59:03.000Z" title="Mon Jan 05 2026 15:59:03 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-05
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">概念</h2>
<p><strong>原型污染安全漏洞（Prototype Pollution）</strong> 是前端 / Node.js 生态里非常重要、也非常容易被忽略的一类漏洞。该漏洞最终可导致权限绕过，是前端安全中的高危问题。</p>
<h2 data-id="heading-1">什么是原型污染？</h2>
<p>攻击者通过可控输入，修改 <code>Object.prototype</code> 或其他内建原型，从而影响所有对象的行为。</p>
<p>JS 原型链</p>
<pre><code class="hljs language-javascript" lang="javascript">obj → <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> → <span class="hljs-literal">null</span>
</code></pre>
<p>一旦污染了 <code>Object.prototype</code></p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">Object.prototype.isAdmin</span> = <span class="hljs-literal">true</span><span class="hljs-comment">;</span>
({}).<span class="hljs-attr">isAdmin</span> === <span class="hljs-literal">true</span><span class="hljs-comment">; // 💣</span>
</code></pre>
<h2 data-id="heading-2">模拟攻击</h2>
<p>下面我们通过一段代码来分析一下什么是原型污染。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepMerge</span>(<span class="hljs-params">target, source</span>) { 
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> source) { 
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> source[key] === <span class="hljs-string">'object'</span>) { 
      <span class="hljs-keyword">if</span> (!target[key]) { 
        target[key] = {}; 
      } 
      <span class="hljs-title function_">deepMerge</span>(target[key], source[key]); 
    } <span class="hljs-keyword">else</span> { 
      target[key] = source[key]; 
    } 
  } 
  <span class="hljs-keyword">return</span> target; 
} 
 
<span class="hljs-comment">// 模拟业务代码 </span>
<span class="hljs-comment">// 方案1：监听 message 事件 </span>
<span class="hljs-keyword">const</span> config = {}; 
<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'message'</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> { 
  <span class="hljs-title function_">deepMerge</span>(config, e.<span class="hljs-property">data</span>); 
}); 
 
<span class="hljs-comment">// 方案2：使用 qs 解析 query </span>
<span class="hljs-keyword">import</span> qs <span class="hljs-keyword">from</span> <span class="hljs-string">'qs'</span>; 
<span class="hljs-keyword">const</span> searchQuery = qs.<span class="hljs-title function_">parse</span>(location.<span class="hljs-property">search</span>); 
<span class="hljs-keyword">const</span> routeQuery = { 
  <span class="hljs-attr">type</span>: <span class="hljs-string">'low'</span>, 
  <span class="hljs-attr">tab</span>: <span class="hljs-number">1</span>, 
}; 
<span class="hljs-title function_">deepMerge</span>(routeQuery, searchQuery); 
 
 
<span class="hljs-comment">// 业务逻辑 </span>
<span class="hljs-keyword">const</span> userInfo = {}; 
<span class="hljs-keyword">if</span> (userInfo.<span class="hljs-property">isAdmin</span>) { 
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'你是管理员'</span>); 
} 

 <span class="hljs-comment">// 我想成为管理员，请输入攻击荷载： </span>
</code></pre>
<p>这段代码<strong>存在典型的原型污染（Prototype Pollution）安全漏洞</strong>，而且两个“方案”都能成为攻击入口。下面我按「问题 → 利用方式 → 影响 → 修复建议」来拆解。</p>
<hr/>
<h3 data-id="heading-3">一、核心问题在哪？</h3>
<h4 data-id="heading-4">不安全的 <code>deepMerge</code></h4>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepMerge</span>(<span class="hljs-params">target, source</span>) { 
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> source) { 
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> source[key] === <span class="hljs-string">'object'</span>) { 
      <span class="hljs-keyword">if</span> (!target[key]) { 
        target[key] = {}; 
      } 
      <span class="hljs-title function_">deepMerge</span>(target[key], source[key]); 
    } <span class="hljs-keyword">else</span> { 
      target[key] = source[key]; 
    } 
  } 
}
</code></pre>
<p><strong>问题点：</strong></p>
<ul>
<li>使用 <code>for...in</code>（会遍历原型链）</li>
<li>未过滤 <code>proto</code> / <code>constructor</code> / <code>prototype</code></li>
<li>未判断是否为「纯对象」</li>
<li>直接递归写入 <code>target[key]</code></li>
</ul>
<p>👉 <strong>攻击者可以修改</strong> <strong><code>Object.prototype</code></strong></p>
<hr/>
<h3 data-id="heading-5">二、两个业务场景为什么都危险？</h3>
<h4 data-id="heading-6">方案1：</h4>
<pre><code class="hljs language-js" lang="js"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'message'</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> {
  <span class="hljs-title function_">deepMerge</span>(config, e.<span class="hljs-property">data</span>);
});
</code></pre>
<h5 data-id="heading-7">攻击 payload</h5>
<pre><code class="hljs language-js" lang="js"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">postMessage</span>({<span class="hljs-attr">proto</span>: {<span class="hljs-attr">isAdmin</span>: <span class="hljs-literal">true</span>
  }
}, <span class="hljs-string">'*'</span>);
</code></pre>
<h5 data-id="heading-8">结果</h5>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> userInfo = {};
userInfo.<span class="hljs-property">isAdmin</span> === <span class="hljs-literal">true</span>; <span class="hljs-comment">// 💣</span>
</code></pre>
<p>🎯 <strong>攻击者无需控制 userInfo，只要污染原型即可</strong></p>
<hr/>
<h4 data-id="heading-9">方案2：</h4>
<pre><code class="hljs language-js" lang="js">qs.<span class="hljs-title function_">parse</span>(location.<span class="hljs-property">search</span>)
<span class="hljs-keyword">const</span> searchQuery = qs.<span class="hljs-title function_">parse</span>(location.<span class="hljs-property">search</span>);
<span class="hljs-title function_">deepMerge</span>(routeQuery, searchQuery);
</code></pre>
<h5 data-id="heading-10">恶意 URL</h5>
<pre><code class="hljs language-js" lang="js"><span class="hljs-attr">https</span>:<span class="hljs-comment">//example.com/?_proto_[isAdmin]=true</span>
</code></pre>
<p>或（更隐蔽）</p>
<pre><code class="hljs language-js" lang="js">?constructor[prototype][isAdmin]=<span class="hljs-literal">true</span>
</code></pre>
<h5 data-id="heading-11">结果同样是：</h5>
<pre><code class="hljs language-js" lang="js">({}).<span class="hljs-property">isAdmin</span> === <span class="hljs-literal">true</span>;
</code></pre>
<hr/>
<h3 data-id="heading-12">三、最终危害点（业务逻辑被绕过）</h3>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> userInfo = {};
<span class="hljs-keyword">if</span> (userInfo.<span class="hljs-property">isAdmin</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'你是管理员'</span>);
}
</code></pre>
<p>🚨 <strong>这是一个权限绕过漏洞</strong> 在真实系统中，可能导致：</p>
<ul>
<li>后台权限获取</li>
<li>功能越权</li>
<li>安全校验全部失效</li>
</ul>
<hr/>
<h3 data-id="heading-13">四、为什么这是“高危漏洞”？</h3>

























<table><thead><tr><th><strong>特性</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>利用门槛</td><td>低（URL / postMessage 即可）</td></tr><tr><td>影响范围</td><td>全局（污染 Object.prototype）</td></tr><tr><td>隐蔽性</td><td>高（调试很难发现）</td></tr><tr><td>常见度</td><td>非常高（deepMerge / lodash.merge）</td></tr></tbody></table>
<p>👉 已多次出现在真实 CVE (Common Vulnerabilities and Exposures) 中。</p>
<hr/>
<h3 data-id="heading-14">五、正确的修复方式 ✅</h3>
<h4 data-id="heading-15">✅ 1. 严格过滤危险 key（必须）</h4>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> blockedKeys = [<span class="hljs-string">'__proto__'</span>, <span class="hljs-string">'prototype'</span>, <span class="hljs-string">'constructor'</span>];

<span class="hljs-keyword">function</span> <span class="hljs-title function_">safeDeepMerge</span>(<span class="hljs-params">target, source</span>) {
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">of</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(source)) {
    <span class="hljs-keyword">if</span> (blockedKeys.<span class="hljs-title function_">includes</span>(key)) <span class="hljs-keyword">continue</span>;

    <span class="hljs-keyword">if</span> (
      <span class="hljs-keyword">typeof</span> source[key] === <span class="hljs-string">'object'</span> &amp;&amp;
      source[key] !== <span class="hljs-literal">null</span> &amp;&amp;
      !<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(source[key])
    ) {
      <span class="hljs-keyword">if</span> (!target[key]) target[key] = {};
      <span class="hljs-title function_">safeDeepMerge</span>(target[key], source[key]);
    } <span class="hljs-keyword">else</span> {
      target[key] = source[key];
    }
  }
}
</code></pre>
<hr/>
<h4 data-id="heading-16">✅ 2. postMessage 必须校验来源</h4>
<pre><code class="hljs language-js" lang="js"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'message'</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> {
  <span class="hljs-keyword">if</span> (e.<span class="hljs-property">origin</span> !== <span class="hljs-string">'https://trusted.com'</span>) <span class="hljs-keyword">return</span>;
  <span class="hljs-title function_">safeDeepMerge</span>(config, e.<span class="hljs-property">data</span>);
});
</code></pre>
<hr/>
<h4 data-id="heading-17">✅ 3. qs 使用安全模式</h4>
<pre><code class="hljs language-js" lang="js">qs.<span class="hljs-title function_">parse</span>(location.<span class="hljs-property">search</span>, {
  <span class="hljs-attr">allowPrototypes</span>: <span class="hljs-literal">false</span>
});
</code></pre>
<p>⚠️ <strong>默认 qs 是危险的（旧版本尤其）</strong></p>
<hr/>
<h4 data-id="heading-18">✅ 4. 使用成熟库</h4>
<p>如 URLSearchParams</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> params = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">fromEntries</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">URLSearchParams</span>(location.<span class="hljs-property">search</span>));
</code></pre>
<h4 data-id="heading-19">✅ 5. 防御性编程（推荐）</h4>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> userInfo = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>);
</code></pre>
<p>或</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">if</span> (<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">hasOwnProperty</span>.<span class="hljs-title function_">call</span>(userInfo, <span class="hljs-string">'isAdmin'</span>)) {
  ...
}
</code></pre>
<hr/>
<h2 data-id="heading-20">为什么它是“安全漏洞”而不是 Bug？</h2>
<p>因为它会导致：</p>





























<table><thead><tr><th><strong>后果</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td>权限绕过</td><td>if (user.isAdmin)</td></tr><tr><td>逻辑篡改</td><td>if (config.debug)</td></tr><tr><td>RCE（Node）</td><td>与 eval / child_process 结合</td></tr><tr><td>XSS</td><td>模板渲染、配置拼接</td></tr><tr><td>DoS</td><td>JSON stringify / 递归崩溃</td></tr></tbody></table>
<p>👉 <strong>影响是“全局的、隐式的、持久的”</strong></p>
<hr/>
<h2 data-id="heading-21">真实世界中的 CVE (Common Vulnerabilities and Exposures)</h2>





























<table><thead><tr><th><strong>库</strong></th><th><strong>CVE</strong></th></tr></thead><tbody><tr><td>lodash.merge</td><td>CVE-2019-10744</td></tr><tr><td>jQuery.extend</td><td>CVE-2019-11358</td></tr><tr><td>minimist</td><td>CVE-2020-7598</td></tr><tr><td>yargs</td><td>CVE-2020-7608</td></tr><tr><td>qs</td><td>多次</td></tr></tbody></table>
<p>📌 <strong>这不是“理论漏洞”，而是“被打烂的漏洞类型”</strong></p>
<hr/>
<h2 data-id="heading-22">如何判断你的代码是否有原型污染？</h2>
<h3 data-id="heading-23">🔍 自查 checklist</h3>
<ul>
<li>是否把 <strong>用户输入</strong> merge 到对象？</li>
<li>是否使用 <code>for...in</code>？</li>
<li>是否递归拷贝对象？</li>
<li>是否信任 <code>qs.parse</code> / JSON？</li>
<li>是否存在 <code>obj[key] = value</code>，且 <code>key</code> 来自外部？</li>
</ul>
<p>如果有 2 条以上，<strong>高风险</strong>。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[React 性能优化利器：深入理解 useMemo 与 useCallback]]></title>    <link>https://juejin.cn/post/7591708519449100297</link>    <guid>https://juejin.cn/post/7591708519449100297</guid>    <pubDate>2026-01-05T14:32:05.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7591708519449100297" data-draft-id="7591719013488230438" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="React 性能优化利器：深入理解 useMemo 与 useCallback"/> <meta itemprop="keywords" content="前端,面试,React.js"/> <meta itemprop="datePublished" content="2026-01-05T14:32:05.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Yira"/> <meta itemprop="url" content="https://juejin.cn/user/262123324974122"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            React 性能优化利器：深入理解 useMemo 与 useCallback
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/262123324974122/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Yira
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-05T14:32:05.000Z" title="Mon Jan 05 2026 14:32:05 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-05
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    9
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">React 性能优化利器：深入理解 <code>useMemo</code> 与 <code>useCallback</code></h2>
<p>在 React 应用开发中，随着组件复杂度的提升，性能问题逐渐显现。即使状态更新只影响局部 UI，整个组件函数也会重新执行，导致不必要的计算或子组件重渲染。为解决这些问题，React 提供了两个关键的性能优化 Hook：<strong><code>useMemo</code></strong> 和 <strong><code>useCallback</code></strong>。它们虽小，却能在关键时刻显著提升应用性能与用户体验。</p>
<p>本文将结合具体代码示例，深入剖析这两个 Hook 的原理、使用场景及最佳实践。</p>
<hr/>
<h3 data-id="heading-1">一、为什么需要性能优化？</h3>
<p>React 的核心理念是“<strong>状态驱动视图</strong>”。当组件的状态（state）或属性（props）发生变化时，组件函数会重新执行，生成新的 JSX。这种机制简洁高效，但也带来潜在性能隐患：</p>
<ul>
<li><strong>昂贵的计算重复执行</strong>：如过滤大量数据、复杂数学运算等。</li>
<li><strong>子组件无谓重渲染</strong>：即使 props 未变，父组件更新仍会触发子组件重新渲染。</li>
</ul>
<p>若不加以控制，这些冗余操作会拖慢应用响应速度，尤其在低端设备或大型列表场景下更为明显。</p>
<hr/>
<h3 data-id="heading-2">二、<code>useMemo</code>：缓存计算结果</h3>
<h4 data-id="heading-3">1. 问题场景</h4>
<p>假设我们有一个水果列表，并根据用户输入的关键词进行过滤：</p>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">list</span> = [<span class="hljs-string">'apple'</span>, <span class="hljs-string">'orange'</span>, <span class="hljs-string">'peach'</span>]<span class="hljs-comment">;</span>
const <span class="hljs-section">[keyword, setKeyword]</span> = useState('')<span class="hljs-comment">;</span>
const <span class="hljs-attr">filterList</span> = list.filter(item =&gt; item.includes(keyword))<span class="hljs-comment">;</span>
</code></pre>
<p>表面看没问题，但若组件中还有另一个无关状态（如 <code>count</code>）：</p>
<pre><code class="hljs language-scss" lang="scss">const <span class="hljs-selector-attr">[count, setCount]</span> = <span class="hljs-built_in">useState</span>(<span class="hljs-number">0</span>);
</code></pre>
<p>当点击“+1”按钮更新 <code>count</code> 时，整个 <code>App</code> 组件重新运行，<code>filterList</code> 也会被重新计算——<strong>尽管 <code>keyword</code> 并未改变</strong>！这不仅浪费 CPU 资源，还可能引发视觉闪烁等问题。</p>
<h4 data-id="heading-4">2. <code>useMemo</code> 的解决方案</h4>
<p><code>useMemo</code> 允许我们将<strong>计算过程缓存起来</strong>，仅在依赖项变化时才重新计算：</p>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">filterList</span> = useMemo(() =&gt; {
  console.log('filter 执行了')<span class="hljs-comment">;</span>
  return list.filter(<span class="hljs-attr">item</span> =&gt; item.includes(keyword))<span class="hljs-comment">;</span>
}, <span class="hljs-section">[keyword]</span>)<span class="hljs-comment">; // 仅当 keyword 变化时重新计算</span>
</code></pre>
<blockquote>
<p>✅ <strong>关键点</strong>：第二个参数是依赖数组。只有数组中的值发生变化，才会触发重新计算。</p>
</blockquote>
<h4 data-id="heading-5">3. 处理昂贵计算</h4>
<p>对于更复杂的场景，比如计算大数累加：</p>
<pre><code class="hljs language-ini" lang="ini">function slowSum(n) {
  let <span class="hljs-attr">sum</span> = <span class="hljs-number">0</span><span class="hljs-comment">;</span>
  for (let <span class="hljs-attr">i</span> = <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; n * 1000000; i++) {</span>
    sum += i<span class="hljs-comment">;</span>
  }
  return sum<span class="hljs-comment">;</span>
}
</code></pre>
<p>若直接调用 <code>slowSum(num)</code>，每次组件更新都会卡顿。使用 <code>useMemo</code> 可有效避免：</p>
<pre><code class="hljs language-scss" lang="scss">const result = <span class="hljs-built_in">useMemo</span>(() =&gt; <span class="hljs-built_in">slowSum</span>(num), <span class="hljs-selector-attr">[num]</span>);
</code></pre>
<p>这样，只有 <code>num</code> 改变时才会执行耗时运算，极大提升流畅度。</p>
<h4 data-id="heading-6">4. 注意事项</h4>
<ul>
<li><strong>不要滥用</strong>：简单计算（如 <code>a + b</code>）无需 <code>useMemo</code>，反而增加内存开销。</li>
<li><strong>依赖项必须完整</strong>：遗漏依赖会导致使用过期值。</li>
<li><strong><code>includes("")</code> 返回 true</strong>：空字符串匹配所有项，需额外处理边界情况（如 <code>keyword.trim()</code>）。</li>
</ul>
<hr/>
<h3 data-id="heading-7">三、<code>useCallback</code>：缓存函数引用</h3>
<h4 data-id="heading-8">1. 子组件重渲染问题</h4>
<p>考虑以下父子组件结构：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 父组件</span>
<span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);
<span class="hljs-keyword">const</span> [num, setNum] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);

<span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'click'</span>);
};

<span class="hljs-keyword">return</span> (
  <span class="xml"><span class="hljs-tag">&lt;&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setCount(count + 1)}&gt;count +1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">count</span>=<span class="hljs-string">{count}</span> <span class="hljs-attr">handleClick</span>=<span class="hljs-string">{handleClick}</span> /&gt;</span>
  <span class="hljs-tag">&lt;/&gt;</span></span>
);
</code></pre>
<p>每次父组件更新（如修改 <code>num</code>），<code>handleClick</code> 都会<strong>重新创建一个新函数</strong>。即使 <code>count</code> 没变，<code>Child</code> 组件因接收到新的 <code>handleClick</code> 引用，也会被强制重渲染。</p>
<h4 data-id="heading-9">2. <code>memo</code> + <code>useCallback</code> 的组合拳</h4>
<h5 data-id="heading-10">步骤一：用 <code>memo</code> 包裹子组件</h5>
<p><code>memo</code> 是一个高阶组件（HOC），它会对 props 进行浅比较。若 props 未变，则跳过渲染：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Child</span> = <span class="hljs-title function_">memo</span>(<span class="hljs-function">(<span class="hljs-params">{ count, handleClick }</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Child 重新渲染'</span>);
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{handleClick}</span>&gt;</span>子组件 {count}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
});
</code></pre>
<h5 data-id="heading-11">步骤二：用 <code>useCallback</code> 缓存回调函数</h5>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">handleClick</span> = useCallback(() =&gt; {
  console.log('click')<span class="hljs-comment">;</span>
}, <span class="hljs-section">[]</span>)<span class="hljs-comment">; // 无依赖，函数引用永久不变</span>
</code></pre>
<p>现在，只有当 <code>count</code> 改变时，<code>Child</code> 才会更新；修改 <code>num</code> 不再触发子组件重渲染。</p>
<h4 data-id="heading-12">3. 依赖项的正确使用</h4>
<p>若回调函数依赖某个状态，必须将其加入依赖数组：</p>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">handleClick</span> = useCallback(() =&gt; {
  console.log('当前 count:', count)<span class="hljs-comment">;</span>
}, <span class="hljs-section">[count]</span>)<span class="hljs-comment">; // 依赖 count</span>
</code></pre>
<p>否则，函数内部会捕获旧的 <code>count</code> 值（闭包陷阱）。</p>
<blockquote>
<p>💡 <strong>设计哲学</strong>：React 的数据流是“父管状态，子管展示”。通过 <code>memo</code> + <code>useCallback</code>，我们确保子组件仅在必要时更新，符合单一职责原则。</p>
</blockquote>
<hr/>
<h3 data-id="heading-13">四、<code>useMemo</code> vs <code>useCallback</code>：本质区别</h3>
<p>虽然两者都用于缓存，但用途不同：</p>




















<table><thead><tr><th>Hook</th><th>用途</th><th>返回值</th></tr></thead><tbody><tr><td><code>useMemo</code></td><td>缓存<strong>计算结果</strong></td><td>值（如数组、对象、数字）</td></tr><tr><td><code>useCallback</code></td><td>缓存<strong>函数引用</strong></td><td>函数</td></tr></tbody></table>
<p>实际上，<code>useCallback(fn, deps)</code> 等价于 <code>useMemo(() =&gt; fn, deps)</code>。但语义上，<code>useCallback</code> 更清晰表达“这是一个回调函数”。</p>
<hr/>
<h3 data-id="heading-14">五、何时使用？何时避免？</h3>
<h4 data-id="heading-15">推荐使用场景：</h4>
<ul>
<li>
<p><strong><code>useMemo</code></strong>：</p>
<ul>
<li>过滤/排序大型列表；</li>
<li>复杂数学或逻辑计算；</li>
<li>创建不可变对象（如 <code>{ ... }</code>）传递给子组件。</li>
</ul>
</li>
<li>
<p><strong><code>useCallback</code></strong>：</p>
<ul>
<li>传递给 <code>memo</code> 包裹的子组件的事件处理器；</li>
<li>作为 <code>useEffect</code> 的依赖项（避免无限循环）；</li>
<li>传递给第三方库（如 <code>react-window</code> 的 <code>itemData</code>）。</li>
</ul>
</li>
</ul>
<h4 data-id="heading-16">避免滥用：</h4>
<ul>
<li>简单组件无需优化；</li>
<li>过度使用会增加内存占用和代码复杂度；</li>
<li>先用性能分析工具（如 React DevTools Profiler）定位瓶颈，再针对性优化。</li>
</ul>
<hr/>
<h3 data-id="heading-17">六、总结</h3>
<p><code>useMemo</code> 和 <code>useCallback</code> 是 React 性能优化的重要工具，它们通过<strong>缓存机制</strong>减少不必要的计算与渲染：</p>
<ul>
<li><strong><code>useMemo</code></strong> 解决“重复计算”问题，适用于派生数据；</li>
<li><strong><code>useCallback</code></strong> 解决“函数引用变化”问题，常与 <code>memo</code> 配合使用，防止子组件无谓更新。</li>
</ul>
<p>掌握它们的关键在于理解 <strong>“依赖项”</strong> 的作用：<strong>只有依赖变化时，才重新计算或生成新函数</strong>。合理使用这两个 Hook，不仅能提升应用性能，还能写出更清晰、可维护的代码。</p>
<p>记住：<strong>优化不是目的，而是手段</strong>。在保证功能正确的前提下，针对真实性能瓶颈进行精准优化，才是工程化的最佳实践。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[在 Vue 中保存页面状态的完整指南：让用户永远不丢失进度]]></title>    <link>https://juejin.cn/post/7591728734982963227</link>    <guid>https://juejin.cn/post/7591728734982963227</guid>    <pubDate>2026-01-05T15:05:57.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7591728734982963227" data-draft-id="7591713442399322121" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="在 Vue 中保存页面状态的完整指南：让用户永远不丢失进度"/> <meta itemprop="keywords" content="Vue.js"/> <meta itemprop="datePublished" content="2026-01-05T15:05:57.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="北辰alk"/> <meta itemprop="url" content="https://juejin.cn/user/1772855673241352"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            在 Vue 中保存页面状态的完整指南：让用户永远不丢失进度
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1772855673241352/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    北辰alk
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-05T15:05:57.000Z" title="Mon Jan 05 2026 15:05:57 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-05
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">前言：为什么需要保存页面状态？</h2>
<p>作为前端开发者，你一定遇到过这样的场景：用户在一个复杂的表单页面填写了大量信息，不小心刷新了页面或点击了返回按钮，所有数据都消失了！用户只能无奈地重新填写...</p>
<p><strong>保存页面状态不仅仅是技术需求，更是提升用户体验的关键</strong>。今天我们来深入探讨在 Vue 中实现页面状态保存的各种方法。</p>
<h2 data-id="heading-1">一、应用场景分析</h2>
<p>在我们开始技术实现之前，先看看哪些场景需要状态保存：</p>
<ol>
<li>1. <strong>复杂表单页面</strong>：用户填写了一半的表单</li>
<li>2. <strong>数据筛选页面</strong>：用户设置了复杂的筛选条件</li>
<li>3. <strong>分页列表</strong>：用户浏览到第5页，返回后希望还在第5页</li>
<li>4. <strong>多步骤流程</strong>：购物车结算流程、注册流程</li>
<li>5. <strong>用户偏好设置</strong>：主题、语言、布局等</li>
</ol>
<h2 data-id="heading-2">二、技术方案对比</h2>
<h3 data-id="heading-3">方案对比流程图</h3>
<pre><code class="hljs">少量简单数据

大量复杂数据

临时会话数据

需要服务端同步

需要保存页面状态数据特点LocalStorageVuex/Pinia + 持久化SessionStorageIndexedDB + 后端API刷新/关闭后仍存在全局状态管理仅当前会话离线可用
</code></pre>
<h2 data-id="heading-4">三、具体实现方法</h2>
<h3 data-id="heading-5">方法1：使用 localStorage 保存简单状态</h3>
<p><strong>适用场景</strong>：数据量小、结构简单的状态保存</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>用户信息表单<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> @<span class="hljs-attr">submit.prevent</span>=<span class="hljs-string">"handleSubmit"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>姓名：<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> 
          <span class="hljs-attr">v-model</span>=<span class="hljs-string">"formData.name"</span> 
          @<span class="hljs-attr">input</span>=<span class="hljs-string">"saveToLocalStorage"</span>
          <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"请输入姓名"</span>
        /&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>邮箱：<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> 
          <span class="hljs-attr">v-model</span>=<span class="hljs-string">"formData.email"</span>
          @<span class="hljs-attr">input</span>=<span class="hljs-string">"saveToLocalStorage"</span>
          <span class="hljs-attr">type</span>=<span class="hljs-string">"email"</span>
          <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"请输入邮箱"</span>
        /&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>备注：<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> 
          <span class="hljs-attr">v-model</span>=<span class="hljs-string">"formData.remarks"</span>
          @<span class="hljs-attr">input</span>=<span class="hljs-string">"saveToLocalStorage"</span>
          <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"请输入备注信息"</span>
        &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>&gt;</span>提交<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"clearStorage"</span>&gt;</span>清除缓存<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">name</span>: <span class="hljs-string">'UserForm'</span>,
  <span class="hljs-title function_">data</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">formData</span>: {
        <span class="hljs-attr">name</span>: <span class="hljs-string">''</span>,
        <span class="hljs-attr">email</span>: <span class="hljs-string">''</span>,
        <span class="hljs-attr">remarks</span>: <span class="hljs-string">''</span>
      }
    }
  },
  <span class="hljs-title function_">mounted</span>(<span class="hljs-params"/>) {
    <span class="hljs-comment">// 组件加载时从 localStorage 恢复数据</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">restoreFromLocalStorage</span>()
    
    <span class="hljs-comment">// 监听页面卸载事件，确保离开前保存</span>
    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'beforeunload'</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">saveToLocalStorage</span>)
  },
  <span class="hljs-title function_">beforeDestroy</span>(<span class="hljs-params"/>) {
    <span class="hljs-comment">// 清理事件监听</span>
    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'beforeunload'</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">saveToLocalStorage</span>)
  },
  <span class="hljs-attr">methods</span>: {
    <span class="hljs-comment">// 保存到 localStorage</span>
    <span class="hljs-title function_">saveToLocalStorage</span>(<span class="hljs-params"/>) {
      <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">'userFormData'</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">formData</span>))
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'数据已保存到本地存储'</span>)
    },
    
    <span class="hljs-comment">// 从 localStorage 恢复</span>
    <span class="hljs-title function_">restoreFromLocalStorage</span>(<span class="hljs-params"/>) {
      <span class="hljs-keyword">const</span> savedData = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">'userFormData'</span>)
      <span class="hljs-keyword">if</span> (savedData) {
        <span class="hljs-keyword">try</span> {
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">formData</span> = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(savedData)
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'数据已从本地存储恢复'</span>)
        } <span class="hljs-keyword">catch</span> (error) {
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'恢复数据失败:'</span>, error)
        }
      }
    },
    
    <span class="hljs-comment">// 处理表单提交</span>
    <span class="hljs-title function_">handleSubmit</span>(<span class="hljs-params"/>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'提交数据:'</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">formData</span>)
      <span class="hljs-comment">// 提交成功后清除缓存</span>
      <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">'userFormData'</span>)
      <span class="hljs-title function_">alert</span>(<span class="hljs-string">'提交成功！本地缓存已清除。'</span>)
    },
    
    <span class="hljs-comment">// 清除缓存</span>
    <span class="hljs-title function_">clearStorage</span>(<span class="hljs-params"/>) {
      <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">'userFormData'</span>)
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">formData</span> = { <span class="hljs-attr">name</span>: <span class="hljs-string">''</span>, <span class="hljs-attr">email</span>: <span class="hljs-string">''</span>, <span class="hljs-attr">remarks</span>: <span class="hljs-string">''</span> }
      <span class="hljs-title function_">alert</span>(<span class="hljs-string">'缓存已清除'</span>)
    }
  }
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<h3 data-id="heading-6">方法2：Vuex + 持久化插件方案</h3>
<p><strong>适用场景</strong>：大型应用，需要全局状态管理</p>
<p><strong>第一步：安装必要依赖</strong></p>
<pre><code class="hljs">npm install vuex-persistedstate
</code></pre>
<p><strong>第二步：创建 Vuex Store 并配置持久化</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// store/index.js</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Vuex</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'vuex'</span>
<span class="hljs-keyword">import</span> createPersistedState <span class="hljs-keyword">from</span> <span class="hljs-string">'vuex-persistedstate'</span>

<span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Vuex</span>)

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>({
  <span class="hljs-attr">state</span>: {
    <span class="hljs-attr">userPreferences</span>: {
      <span class="hljs-attr">theme</span>: <span class="hljs-string">'light'</span>,
      <span class="hljs-attr">language</span>: <span class="hljs-string">'zh-CN'</span>,
      <span class="hljs-attr">fontSize</span>: <span class="hljs-number">14</span>
    },
    <span class="hljs-attr">shoppingCart</span>: [],
    <span class="hljs-attr">formStates</span>: {} <span class="hljs-comment">// 存储各个表单的状态</span>
  },
  
  <span class="hljs-attr">mutations</span>: {
    <span class="hljs-title function_">SET_USER_PREFERENCE</span>(<span class="hljs-params">state, { key, value }</span>) {
      <span class="hljs-keyword">if</span> (state.<span class="hljs-property">userPreferences</span>.<span class="hljs-title function_">hasOwnProperty</span>(key)) {
        state.<span class="hljs-property">userPreferences</span>[key] = value
      }
    },
    
    <span class="hljs-title function_">ADD_TO_CART</span>(<span class="hljs-params">state, product</span>) {
      <span class="hljs-keyword">const</span> existingItem = state.<span class="hljs-property">shoppingCart</span>.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">id</span> === product.<span class="hljs-property">id</span>)
      <span class="hljs-keyword">if</span> (existingItem) {
        existingItem.<span class="hljs-property">quantity</span> += product.<span class="hljs-property">quantity</span> || <span class="hljs-number">1</span>
      } <span class="hljs-keyword">else</span> {
        state.<span class="hljs-property">shoppingCart</span>.<span class="hljs-title function_">push</span>({ ...product, <span class="hljs-attr">quantity</span>: product.<span class="hljs-property">quantity</span> || <span class="hljs-number">1</span> })
      }
    },
    
    <span class="hljs-title function_">SAVE_FORM_STATE</span>(<span class="hljs-params">state, { formId, data }</span>) {
      state.<span class="hljs-property">formStates</span>[formId] = data
    },
    
    <span class="hljs-title function_">CLEAR_FORM_STATE</span>(<span class="hljs-params">state, formId</span>) {
      <span class="hljs-keyword">if</span> (state.<span class="hljs-property">formStates</span>[formId]) {
        <span class="hljs-keyword">delete</span> state.<span class="hljs-property">formStates</span>[formId]
      }
    }
  },
  
  <span class="hljs-attr">actions</span>: {
    <span class="hljs-title function_">saveFormState</span>(<span class="hljs-params">{ commit }, payload</span>) {
      <span class="hljs-title function_">commit</span>(<span class="hljs-string">'SAVE_FORM_STATE'</span>, payload)
    },
    
    <span class="hljs-comment">// 清除过期数据（例如24小时前的数据）</span>
    <span class="hljs-title function_">clearExpiredStates</span>(<span class="hljs-params">{ state, commit }</span>) {
      <span class="hljs-keyword">const</span> now = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>()
      <span class="hljs-keyword">const</span> expirationTime = <span class="hljs-number">24</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span> <span class="hljs-comment">// 24小时</span>
      
      <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(state.<span class="hljs-property">formStates</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">formId</span> =&gt;</span> {
        <span class="hljs-keyword">const</span> formData = state.<span class="hljs-property">formStates</span>[formId]
        <span class="hljs-keyword">if</span> (formData.<span class="hljs-property">_timestamp</span> &amp;&amp; now - formData.<span class="hljs-property">_timestamp</span> &gt; expirationTime) {
          <span class="hljs-title function_">commit</span>(<span class="hljs-string">'CLEAR_FORM_STATE'</span>, formId)
        }
      })
    }
  },
  
  <span class="hljs-attr">getters</span>: {
    <span class="hljs-attr">getFormState</span>: <span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> <span class="hljs-function">(<span class="hljs-params">formId</span>) =&gt;</span> {
      <span class="hljs-keyword">return</span> state.<span class="hljs-property">formStates</span>[formId] || <span class="hljs-literal">null</span>
    },
    
    <span class="hljs-attr">cartTotalItems</span>: <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> {
      <span class="hljs-keyword">return</span> state.<span class="hljs-property">shoppingCart</span>.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">total, item</span>) =&gt;</span> total + item.<span class="hljs-property">quantity</span>, <span class="hljs-number">0</span>)
    }
  },
  
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-title function_">createPersistedState</span>({
      <span class="hljs-attr">key</span>: <span class="hljs-string">'vuex-app-state'</span>,
      <span class="hljs-attr">paths</span>: [
        <span class="hljs-string">'userPreferences'</span>,
        <span class="hljs-string">'shoppingCart'</span>,
        <span class="hljs-string">'formStates'</span>
      ],
      
      <span class="hljs-comment">// 自定义存储方式，可以添加加密</span>
      <span class="hljs-attr">storage</span>: {
        <span class="hljs-attr">getItem</span>: <span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> {
          <span class="hljs-keyword">const</span> data = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(key)
          <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 这里可以添加解密逻辑</span>
            <span class="hljs-keyword">return</span> <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(data)
          } <span class="hljs-keyword">catch</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>
          }
        },
        <span class="hljs-attr">setItem</span>: <span class="hljs-function">(<span class="hljs-params">key, value</span>) =&gt;</span> {
          <span class="hljs-comment">// 这里可以添加加密逻辑</span>
          <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(key, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(value))
        },
        <span class="hljs-attr">removeItem</span>: <span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">removeItem</span>(key)
      },
      
      <span class="hljs-comment">// 数据过滤，可以排除不需要持久化的数据</span>
      <span class="hljs-attr">reducer</span>: <span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> {
        <span class="hljs-keyword">const</span> { formStates, ...rest } = state
        
        <span class="hljs-comment">// 过滤掉时间戳字段</span>
        <span class="hljs-keyword">const</span> filteredFormStates = {}
        <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(formStates).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> {
          <span class="hljs-keyword">const</span> { _timestamp, ...formData } = formStates[key]
          filteredFormStates[key] = formData
        })
        
        <span class="hljs-keyword">return</span> {
          ...rest,
          <span class="hljs-attr">formStates</span>: filteredFormStates
        }
      }
    })
  ]
})
</code></pre>
<p><strong>第三步：在组件中使用</strong></p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-comment">&lt;!-- ProductList.vue --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"product-list"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>商品列表<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"products"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> 
        <span class="hljs-attr">v-for</span>=<span class="hljs-string">"product in products"</span> 
        <span class="hljs-attr">:key</span>=<span class="hljs-string">"product.id"</span>
        <span class="hljs-attr">class</span>=<span class="hljs-string">"product-card"</span>
      &gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>{{ product.name }}<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>价格: ¥{{ product.price }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"addToCart(product)"</span>&gt;</span>
          加入购物车
        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    
    <span class="hljs-comment">&lt;!-- 购物车预览 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"cart-preview"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>购物车 ({{ cartTotalItems }}件商品)<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"goToCart"</span>&gt;</span>去结算<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">import</span> { mapMutations, mapGetters } <span class="hljs-keyword">from</span> <span class="hljs-string">'vuex'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">name</span>: <span class="hljs-string">'ProductList'</span>,
  
  <span class="hljs-title function_">data</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">products</span>: [
        { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'商品A'</span>, <span class="hljs-attr">price</span>: <span class="hljs-number">100</span> },
        { <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'商品B'</span>, <span class="hljs-attr">price</span>: <span class="hljs-number">200</span> },
        { <span class="hljs-attr">id</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'商品C'</span>, <span class="hljs-attr">price</span>: <span class="hljs-number">300</span> }
      ]
    }
  },
  
  <span class="hljs-attr">computed</span>: {
    ...<span class="hljs-title function_">mapGetters</span>([<span class="hljs-string">'cartTotalItems'</span>])
  },
  
  <span class="hljs-attr">methods</span>: {
    ...<span class="hljs-title function_">mapMutations</span>([<span class="hljs-string">'ADD_TO_CART'</span>]),
    
    <span class="hljs-title function_">addToCart</span>(<span class="hljs-params">product</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">ADD_TO_CART</span>({
        ...product,
        <span class="hljs-attr">quantity</span>: <span class="hljs-number">1</span>
      })
      <span class="hljs-title function_">alert</span>(<span class="hljs-string">'已添加到购物车！刷新页面或重新打开浏览器，购物车数据仍然存在。'</span>)
    },
    
    <span class="hljs-title function_">goToCart</span>(<span class="hljs-params"/>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">'/cart'</span>)
    }
  }
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<h3 data-id="heading-7">方法3：使用路由守卫保存页面状态</h3>
<p><strong>适用场景</strong>：基于路由的页面状态保存</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// router/index.js</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">VueRouter</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'vue-router'</span>

<span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">VueRouter</span>)

<span class="hljs-keyword">const</span> routes = [
  {
    <span class="hljs-attr">path</span>: <span class="hljs-string">'/form'</span>,
    <span class="hljs-attr">name</span>: <span class="hljs-string">'FormPage'</span>,
    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'../views/FormPage.vue'</span>),
    <span class="hljs-attr">meta</span>: {
      <span class="hljs-attr">keepAlive</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 需要缓存</span>
      <span class="hljs-attr">saveState</span>: <span class="hljs-literal">true</span>  <span class="hljs-comment">// 需要保存状态</span>
    }
  },
  <span class="hljs-comment">// ...其他路由</span>
]

<span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>({
  <span class="hljs-attr">mode</span>: <span class="hljs-string">'history'</span>,
  routes
})

<span class="hljs-comment">// 页面状态缓存对象</span>
<span class="hljs-keyword">const</span> pageStateCache = {}

<span class="hljs-comment">// 全局前置守卫</span>
router.<span class="hljs-title function_">beforeEach</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> {
  <span class="hljs-comment">// 离开需要保存状态的页面时，保存当前页面状态</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">from</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">saveState</span>) {
    <span class="hljs-title function_">savePageState</span>(<span class="hljs-keyword">from</span>)
  }
  
  <span class="hljs-title function_">next</span>()
})

<span class="hljs-comment">// 全局后置守卫</span>
router.<span class="hljs-title function_">afterEach</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span></span>) =&gt;</span> {
  <span class="hljs-comment">// 进入需要恢复状态的页面时，恢复页面状态</span>
  <span class="hljs-keyword">if</span> (to.<span class="hljs-property">meta</span>.<span class="hljs-property">saveState</span>) {
    <span class="hljs-title function_">restorePageState</span>(to)
  }
})

<span class="hljs-comment">/**
 * 保存页面状态
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">savePageState</span>(<span class="hljs-params">route</span>) {
  <span class="hljs-keyword">const</span> pageKey = <span class="hljs-title function_">getPageKey</span>(route)
  <span class="hljs-keyword">const</span> stateToSave = {
    <span class="hljs-attr">scrollPosition</span>: <span class="hljs-variable language_">window</span>.<span class="hljs-property">pageYOffset</span>,
    <span class="hljs-attr">formData</span>: <span class="hljs-title function_">getFormDataFromPage</span>(),
    <span class="hljs-attr">timestamp</span>: <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>()
  }
  
  pageStateCache[pageKey] = stateToSave
  <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">`pageState_<span class="hljs-subst">${pageKey}</span>`</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(stateToSave))
}

<span class="hljs-comment">/**
 * 恢复页面状态
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">restorePageState</span>(<span class="hljs-params">route</span>) {
  <span class="hljs-keyword">const</span> pageKey = <span class="hljs-title function_">getPageKey</span>(route)
  <span class="hljs-keyword">let</span> state
  
  <span class="hljs-comment">// 先从内存缓存中获取</span>
  <span class="hljs-keyword">if</span> (pageStateCache[pageKey]) {
    state = pageStateCache[pageKey]
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// 内存中没有则从localStorage获取</span>
    <span class="hljs-keyword">const</span> savedState = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">`pageState_<span class="hljs-subst">${pageKey}</span>`</span>)
    <span class="hljs-keyword">if</span> (savedState) {
      <span class="hljs-keyword">try</span> {
        state = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(savedState)
      } <span class="hljs-keyword">catch</span> (e) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'恢复页面状态失败:'</span>, e)
      }
    }
  }
  
  <span class="hljs-keyword">if</span> (state) {
    <span class="hljs-comment">// 恢复滚动位置</span>
    <span class="hljs-keyword">if</span> (state.<span class="hljs-property">scrollPosition</span>) {
      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">scrollTo</span>(<span class="hljs-number">0</span>, state.<span class="hljs-property">scrollPosition</span>)
      }, <span class="hljs-number">100</span>)
    }
    
    <span class="hljs-comment">// 恢复表单数据</span>
    <span class="hljs-keyword">if</span> (state.<span class="hljs-property">formData</span>) {
      <span class="hljs-title function_">restoreFormDataToPage</span>(state.<span class="hljs-property">formData</span>)
    }
  }
}

<span class="hljs-comment">/**
 * 生成页面唯一标识
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">getPageKey</span>(<span class="hljs-params">route</span>) {
  <span class="hljs-keyword">return</span> route.<span class="hljs-property">path</span> + <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(route.<span class="hljs-property">query</span>) + <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(route.<span class="hljs-property">params</span>)
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router
</code></pre>
<h3 data-id="heading-8">方法4：使用 keep-alive 组件缓存组件实例</h3>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-comment">&lt;!-- App.vue --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- 使用keep-alive缓存需要保持状态的组件 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span> <span class="hljs-attr">:include</span>=<span class="hljs-string">"cachedComponents"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"$route.meta.keepAlive"</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span>
    
    <span class="hljs-comment">&lt;!-- 不需要缓存的组件 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"!$route.meta.keepAlive"</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">name</span>: <span class="hljs-string">'App'</span>,
  <span class="hljs-title function_">data</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">cachedComponents</span>: [<span class="hljs-string">'ProductList'</span>, <span class="hljs-string">'UserForm'</span>] <span class="hljs-comment">// 需要缓存的组件名</span>
    }
  },
  
  <span class="hljs-comment">// 使用keep-alive的组件会触发这些生命周期</span>
  <span class="hljs-title function_">beforeRouteLeave</span>(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) {
    <span class="hljs-comment">// 在离开前可以保存一些数据</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">saveState</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">saveState</span>()
    }
    <span class="hljs-title function_">next</span>()
  },
  
  <span class="hljs-title function_">activated</span>(<span class="hljs-params"/>) {
    <span class="hljs-comment">// 组件被激活时调用</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'组件被激活，可以恢复状态'</span>)
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">restoreState</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">restoreState</span>()
  },
  
  <span class="hljs-title function_">deactivated</span>(<span class="hljs-params"/>) {
    <span class="hljs-comment">// 组件被停用时调用</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'组件被停用，可以保存状态'</span>)
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">saveState</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">saveState</span>()
  }
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<h2 data-id="heading-9">四、高级方案：IndexedDB 存储大量数据</h2>
<p>当需要存储大量数据或复杂对象时，IndexedDB 是更好的选择。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// utils/db.js</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">StateDB</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">dbName = <span class="hljs-string">'VueAppState'</span>, version = <span class="hljs-number">1</span></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">dbName</span> = dbName
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">version</span> = version
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">db</span> = <span class="hljs-literal">null</span>
  }

  <span class="hljs-comment">// 打开数据库</span>
  <span class="hljs-title function_">open</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
      <span class="hljs-keyword">const</span> request = indexedDB.<span class="hljs-title function_">open</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">dbName</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">version</span>)

      request.<span class="hljs-property">onerror</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">reject</span>(request.<span class="hljs-property">error</span>)
      request.<span class="hljs-property">onsuccess</span> = <span class="hljs-function">() =&gt;</span> {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">db</span> = request.<span class="hljs-property">result</span>
        <span class="hljs-title function_">resolve</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">db</span>)
      }

      request.<span class="hljs-property">onupgradeneeded</span> = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
        <span class="hljs-keyword">const</span> db = event.<span class="hljs-property">target</span>.<span class="hljs-property">result</span>
        
        <span class="hljs-comment">// 创建对象存储空间</span>
        <span class="hljs-keyword">if</span> (!db.<span class="hljs-property">objectStoreNames</span>.<span class="hljs-title function_">contains</span>(<span class="hljs-string">'pageStates'</span>)) {
          <span class="hljs-keyword">const</span> store = db.<span class="hljs-title function_">createObjectStore</span>(<span class="hljs-string">'pageStates'</span>, { <span class="hljs-attr">keyPath</span>: <span class="hljs-string">'id'</span> })
          store.<span class="hljs-title function_">createIndex</span>(<span class="hljs-string">'timestamp'</span>, <span class="hljs-string">'timestamp'</span>, { <span class="hljs-attr">unique</span>: <span class="hljs-literal">false</span> })
        }
        
        <span class="hljs-keyword">if</span> (!db.<span class="hljs-property">objectStoreNames</span>.<span class="hljs-title function_">contains</span>(<span class="hljs-string">'userData'</span>)) {
          db.<span class="hljs-title function_">createObjectStore</span>(<span class="hljs-string">'userData'</span>, { <span class="hljs-attr">keyPath</span>: <span class="hljs-string">'key'</span> })
        }
      }
    })
  }

  <span class="hljs-comment">// 保存页面状态</span>
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">savePageState</span>(<span class="hljs-params">pageId, state</span>) {
    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">db</span>) <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">open</span>()
    
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
      <span class="hljs-keyword">const</span> transaction = <span class="hljs-variable language_">this</span>.<span class="hljs-property">db</span>.<span class="hljs-title function_">transaction</span>([<span class="hljs-string">'pageStates'</span>], <span class="hljs-string">'readwrite'</span>)
      <span class="hljs-keyword">const</span> store = transaction.<span class="hljs-title function_">objectStore</span>(<span class="hljs-string">'pageStates'</span>)
      
      <span class="hljs-keyword">const</span> record = {
        <span class="hljs-attr">id</span>: pageId,
        <span class="hljs-attr">state</span>: state,
        <span class="hljs-attr">timestamp</span>: <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>()
      }
      
      <span class="hljs-keyword">const</span> request = store.<span class="hljs-title function_">put</span>(record)
      
      request.<span class="hljs-property">onsuccess</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>()
      request.<span class="hljs-property">onerror</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">reject</span>(request.<span class="hljs-property">error</span>)
    })
  }

  <span class="hljs-comment">// 获取页面状态</span>
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">getPageState</span>(<span class="hljs-params">pageId</span>) {
    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">db</span>) <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">open</span>()
    
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
      <span class="hljs-keyword">const</span> transaction = <span class="hljs-variable language_">this</span>.<span class="hljs-property">db</span>.<span class="hljs-title function_">transaction</span>([<span class="hljs-string">'pageStates'</span>], <span class="hljs-string">'readonly'</span>)
      <span class="hljs-keyword">const</span> store = transaction.<span class="hljs-title function_">objectStore</span>(<span class="hljs-string">'pageStates'</span>)
      <span class="hljs-keyword">const</span> request = store.<span class="hljs-title function_">get</span>(pageId)
      
      request.<span class="hljs-property">onsuccess</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(request.<span class="hljs-property">result</span>?.<span class="hljs-property">state</span>)
      request.<span class="hljs-property">onerror</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">reject</span>(request.<span class="hljs-property">error</span>)
    })
  }

  <span class="hljs-comment">// 清理过期数据（超过7天）</span>
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">cleanupOldStates</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">db</span>) <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">open</span>()
    
    <span class="hljs-keyword">const</span> sevenDaysAgo = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() - (<span class="hljs-number">7</span> * <span class="hljs-number">24</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>)
    
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
      <span class="hljs-keyword">const</span> transaction = <span class="hljs-variable language_">this</span>.<span class="hljs-property">db</span>.<span class="hljs-title function_">transaction</span>([<span class="hljs-string">'pageStates'</span>], <span class="hljs-string">'readwrite'</span>)
      <span class="hljs-keyword">const</span> store = transaction.<span class="hljs-title function_">objectStore</span>(<span class="hljs-string">'pageStates'</span>)
      <span class="hljs-keyword">const</span> index = store.<span class="hljs-title function_">index</span>(<span class="hljs-string">'timestamp'</span>)
      <span class="hljs-keyword">const</span> range = <span class="hljs-title class_">IDBKeyRange</span>.<span class="hljs-title function_">upperBound</span>(sevenDaysAgo)
      
      <span class="hljs-keyword">const</span> request = index.<span class="hljs-title function_">openCursor</span>(range)
      
      request.<span class="hljs-property">onsuccess</span> = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
        <span class="hljs-keyword">const</span> cursor = event.<span class="hljs-property">target</span>.<span class="hljs-property">result</span>
        <span class="hljs-keyword">if</span> (cursor) {
          cursor.<span class="hljs-title function_">delete</span>()
          cursor.<span class="hljs-title function_">continue</span>()
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-title function_">resolve</span>()
        }
      }
      
      request.<span class="hljs-property">onerror</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">reject</span>(request.<span class="hljs-property">error</span>)
    })
  }
}

<span class="hljs-comment">// 创建单例实例</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> stateDB = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StateDB</span>()

<span class="hljs-comment">// 在 Vue 插件中使用</span>
<span class="hljs-keyword">const</span> <span class="hljs-title class_">StatePersistencePlugin</span> = {
  <span class="hljs-title function_">install</span>(<span class="hljs-params">Vue</span>) {
    <span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$stateDB</span> = stateDB
    
    <span class="hljs-comment">// 混入方法到所有组件</span>
    <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">mixin</span>({
      <span class="hljs-attr">methods</span>: {
        <span class="hljs-keyword">async</span> <span class="hljs-title function_">saveComponentState</span>(<span class="hljs-params">stateKey, data</span>) {
          <span class="hljs-keyword">const</span> componentId = <span class="hljs-variable language_">this</span>.<span class="hljs-property">$options</span>.<span class="hljs-property">name</span> || <span class="hljs-variable language_">this</span>.<span class="hljs-property">$route</span>?.<span class="hljs-property">path</span> || <span class="hljs-string">'unknown'</span>
          <span class="hljs-keyword">const</span> fullKey = <span class="hljs-string">`<span class="hljs-subst">${componentId}</span>_<span class="hljs-subst">${stateKey}</span>`</span>
          
          <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">$stateDB</span>.<span class="hljs-title function_">savePageState</span>(fullKey, {
              data,
              <span class="hljs-attr">savedAt</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">toISOString</span>()
            })
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`状态已保存: <span class="hljs-subst">${fullKey}</span>`</span>)
          } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'保存状态失败:'</span>, error)
          }
        },
        
        <span class="hljs-keyword">async</span> <span class="hljs-title function_">loadComponentState</span>(<span class="hljs-params">stateKey</span>) {
          <span class="hljs-keyword">const</span> componentId = <span class="hljs-variable language_">this</span>.<span class="hljs-property">$options</span>.<span class="hljs-property">name</span> || <span class="hljs-variable language_">this</span>.<span class="hljs-property">$route</span>?.<span class="hljs-property">path</span> || <span class="hljs-string">'unknown'</span>
          <span class="hljs-keyword">const</span> fullKey = <span class="hljs-string">`<span class="hljs-subst">${componentId}</span>_<span class="hljs-subst">${stateKey}</span>`</span>
          
          <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">const</span> state = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">$stateDB</span>.<span class="hljs-title function_">getPageState</span>(fullKey)
            <span class="hljs-keyword">return</span> state?.<span class="hljs-property">data</span> || <span class="hljs-literal">null</span>
          } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'加载状态失败:'</span>, error)
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>
          }
        }
      }
    })
  }
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">StatePersistencePlugin</span>
</code></pre>
<h2 data-id="heading-10">五、最佳实践总结</h2>
<h3 data-id="heading-11">1. <strong>分层存储策略</strong></h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 根据数据类型选择不同的存储方式</span>
<span class="hljs-keyword">const</span> storageStrategy = {
  <span class="hljs-comment">// 用户设置：永久存储</span>
  <span class="hljs-attr">userPreferences</span>: <span class="hljs-variable language_">localStorage</span>,
  
  <span class="hljs-comment">// 购物车：IndexedDB + 服务端同步</span>
  <span class="hljs-attr">shoppingCart</span>: {
    <span class="hljs-attr">local</span>: indexedDB,
    <span class="hljs-attr">remote</span>: <span class="hljs-string">'api/cart'</span>
  },
  
  <span class="hljs-comment">// 表单草稿：sessionStorage（会话级）</span>
  <span class="hljs-attr">formDraft</span>: sessionStorage,
  
  <span class="hljs-comment">// 页面滚动位置：内存缓存</span>
  <span class="hljs-attr">scrollPosition</span>: <span class="hljs-string">'memory'</span>
}
</code></pre>
<h3 data-id="heading-12">2. <strong>数据版本管理</strong></h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 添加版本控制，避免数据结构变化导致的问题</span>
<span class="hljs-keyword">const</span> saveWithVersion = (key, <span class="hljs-keyword">data</span>) =&gt; {
  <span class="hljs-keyword">const</span> payload = {
    version: <span class="hljs-string">'1.0.0'</span>,
    savedAt: new Date().toISOString(),
    <span class="hljs-keyword">data</span>: <span class="hljs-keyword">data</span>
  }
  localStorage.setItem(key, JSON.stringify(payload))
}

<span class="hljs-keyword">const</span> loadWithVersion = (key, currentVersion = <span class="hljs-string">'1.0.0'</span>) =&gt; {
  <span class="hljs-keyword">const</span> saved = localStorage.getItem(key)
  <span class="hljs-keyword">if</span> (!saved) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>
  
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> { version, <span class="hljs-keyword">data</span> } = JSON.parse(saved)
    
    <span class="hljs-comment">// 版本迁移逻辑</span>
    <span class="hljs-keyword">if</span> (version !== currentVersion) {
      <span class="hljs-keyword">return</span> migrateData(<span class="hljs-keyword">data</span>, version, currentVersion)
    }
    
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">data</span>
  } <span class="hljs-keyword">catch</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>
  }
}
</code></pre>
<h3 data-id="heading-13">3. <strong>自动保存与防抖优化</strong></h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> { debounce } <span class="hljs-keyword">from</span> <span class="hljs-string">'lodash'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-title function_">data</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">formData</span>: {},
      <span class="hljs-attr">autoSaveEnabled</span>: <span class="hljs-literal">true</span>
    }
  },
  
  <span class="hljs-title function_">created</span>(<span class="hljs-params"/>) {
    <span class="hljs-comment">// 使用防抖避免频繁保存</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">debouncedSave</span> = <span class="hljs-title function_">debounce</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">saveFormState</span>, <span class="hljs-number">1000</span>)
  },
  
  <span class="hljs-attr">watch</span>: {
    <span class="hljs-attr">formData</span>: {
      <span class="hljs-attr">deep</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-title function_">handler</span>(<span class="hljs-params"/>) {
        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">autoSaveEnabled</span>) {
          <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">debouncedSave</span>()
        }
      }
    }
  },
  
  <span class="hljs-attr">methods</span>: {
    <span class="hljs-title function_">saveFormState</span>(<span class="hljs-params"/>) {
      <span class="hljs-comment">// 保存逻辑</span>
    }
  }
}
</code></pre>
<h2 data-id="heading-14">六、安全注意事项</h2>
<ol>
<li>
<p>1. <strong>敏感信息不要保存在客户端</strong></p>
</li>
<li>
<ul>
<li>• 密码、token等敏感信息避免本地存储</li>
<li>• 必要时使用加密存储</li>
</ul>
</li>
<li>
<p>2. <strong>数据清理机制</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 定期清理过期数据</span>
<span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">const</span> oneDayAgo = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() - <span class="hljs-number">24</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>
  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(<span class="hljs-variable language_">localStorage</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> {
    <span class="hljs-keyword">if</span> (key.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">'temp_'</span>)) {
      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">const</span> item = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(key))
        <span class="hljs-keyword">if</span> (item.<span class="hljs-property">timestamp</span> &amp;&amp; item.<span class="hljs-property">timestamp</span> &lt; oneDayAgo) {
          <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">removeItem</span>(key)
        }
      } <span class="hljs-keyword">catch</span> {}
    }
  })
}, <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>) <span class="hljs-comment">// 每小时清理一次</span>
</code></pre>
</li>
</ol>
<h2 data-id="heading-15">结语</h2>
<p>保存页面状态是提升 Vue 应用用户体验的关键技术。根据不同的场景需求，我们可以选择：</p>
<ul>
<li>• <strong>简单场景</strong>：使用 localStorage 或 sessionStorage</li>
<li>• <strong>复杂应用</strong>：Vuex/Pinia + 持久化插件</li>
<li>• <strong>大量数据</strong>：IndexedDB 存储</li>
<li>• <strong>组件缓存</strong>：keep-alive + 路由守卫</li>
</ul>
<p>记住，最好的方案是<strong>分层存储、按需使用</strong>。合理使用状态保存，让你的 Vue 应用更加友好和健壮！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[依赖预构建]]></title>    <link>https://juejin.cn/post/7591702898080301071</link>    <guid>https://juejin.cn/post/7591702898080301071</guid>    <pubDate>2026-01-05T13:26:08.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7591702898080301071" data-draft-id="7591703562134028322" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="依赖预构建"/> <meta itemprop="keywords" content="Vite"/> <meta itemprop="datePublished" content="2026-01-05T13:26:08.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="coderjc"/> <meta itemprop="url" content="https://juejin.cn/user/4279763486908104"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            依赖预构建
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4279763486908104/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    coderjc
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-05T13:26:08.000Z" title="Mon Jan 05 2026 13:26:08 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-05
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读9分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>如果你用过 vite，那么想必对<strong>依赖预构建</strong>这一个名词并不陌生，本文就基于此来进行一些探讨。</p>
<p>PS：本文分析来自于笔者的个人理解，如果发现了错误，可以在进行指正。当然说的是 vite 依赖于 esbuild 和 rollup 的时候，而非 rolldown。</p>
</blockquote>
<h2 data-id="heading-0">为什么需要依赖预构建</h2>
<blockquote>
<p>通常如果要知道为什么需要一个东西，我们首要的前提就是知道“它解决了什么问题？”。这一点其实 vite 的文档已经给出了，主要是两个目的：<strong>规范兼容性</strong>和<strong>性能</strong>。</p>
</blockquote>
<h3 data-id="heading-1">性能</h3>
<p>我们知道，浏览器是可以通过给 script 标签添加 type="module" 来让其支持模块化的导入，所以，我简单写了一个 demo，demo 的结果如下：</p>
<pre><code class="hljs language-css" lang="css">依赖预构建
├── <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.js</span>
├── <span class="hljs-selector-tag">b</span><span class="hljs-selector-class">.js</span>
├── c<span class="hljs-selector-class">.js</span>
├── index<span class="hljs-selector-class">.html</span>
└── index<span class="hljs-selector-class">.js</span>
</code></pre>
<p>文件内容很简单，只要看一下 index.js 即可，如下：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> { a } <span class="hljs-keyword">from</span> <span class="hljs-string">'./a.js'</span>
<span class="hljs-keyword">import</span> { b } <span class="hljs-keyword">from</span> <span class="hljs-string">'./b.js'</span>
<span class="hljs-keyword">import</span> { c } <span class="hljs-keyword">from</span> <span class="hljs-string">'./c.js'</span>
​
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'index.js -- start'</span>)
​
<span class="hljs-title function_">a</span>()
<span class="hljs-title function_">b</span>()
<span class="hljs-title function_">c</span>()
​
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'index.js -- end'</span>)
</code></pre>
<p>输出为：</p>
<pre><code class="hljs language-less" lang="less"><span class="hljs-selector-tag">index</span><span class="hljs-selector-class">.js</span> <span class="hljs-selector-tag">--</span> <span class="hljs-selector-tag">start</span>
<span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.js</span>:<span class="hljs-number">2</span> <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.js</span>
<span class="hljs-selector-tag">b</span><span class="hljs-selector-class">.js</span>:<span class="hljs-number">2</span> <span class="hljs-selector-tag">b</span><span class="hljs-selector-class">.js</span>
<span class="hljs-selector-tag">c</span><span class="hljs-selector-class">.js</span>:<span class="hljs-number">2</span> <span class="hljs-selector-tag">c</span><span class="hljs-selector-class">.js</span>
<span class="hljs-selector-tag">index</span><span class="hljs-selector-class">.js</span>:<span class="hljs-number">11</span> <span class="hljs-selector-tag">index</span><span class="hljs-selector-class">.js</span> <span class="hljs-selector-tag">--</span> <span class="hljs-selector-tag">end</span>
</code></pre>
<p>好像一切都是岁月静好，但是其实它背后存在一个“负担”，我们来打开网络面板就可以看到了，如图：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6c0b8422acb24569a9eb01d4b67fd39f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgY29kZXJqYw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768224367&amp;x-signature=yoD4ASaidkx1ZFLbbgrFPCED%2Ba8%3D" alt="image-20260105003506147.png" loading="lazy"/></p>
<p>三个导入就有三个请求，一个请求就是一个网络开销，而如果是一个成熟的第三方包，一个包就可能会有几十几百个文件的导入，这还是只是一个依赖，实际开发中，我们的项目是不会止步于一个依赖的。所以管中窥豹，就算再本地环境，这个网络开销也很难承受。</p>
<p>可能文字的描述还是略显苍白，那么让我们看一个引入 lodash 的例子，index.js 文件如下：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 因为这是浏览器环境，所以要知道精确的具体的 js 文件</span>
<span class="hljs-keyword">import</span> { toUpper } <span class="hljs-keyword">from</span> <span class="hljs-string">'./node_modules/lodash-es/lodash.js'</span>
​
<span class="hljs-keyword">const</span> msg = <span class="hljs-string">'hello world'</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">toUpper</span>(msg))
​
</code></pre>
<p>请求效果如图：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f78c374380e34037b11771b1996a6d61~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgY29kZXJqYw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768224367&amp;x-signature=QvbaNZIgt6Q%2FYT5%2Fi4RPGLIFKx4%3D" alt="image-20260105005215251.png" loading="lazy"/></p>
<p>可以看到这个数量还是很恐怖的。而如果有依赖预构建呢？我们看一下请求的效果图：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8f25aee4cbdc4daf985d608fb1e619ac~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgY29kZXJqYw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768224367&amp;x-signature=k5bFMEkHaaUSLr3UBX52SGHRYl8%3D" alt="image-20260105005717833.png" loading="lazy"/></p>
<p>可以看到，这个 lodash 请求数量都集中到一个文件，那么网络开销就少得多。而虽然这个文件的体积大很多，但是只需要进行一次网络的传输就可以了。这种大家可以尝试用一个较小的 node_modules 目录，进行复制传输或者打包压缩，它的时间比正常大文件的时间要多的多，</p>
<h3 data-id="heading-2">规范兼容性</h3>
<p>性能问题解决了，但还有一个更棘手的问题在等着我们。</p>
<p>不知道你有没有想过，npm 上那些第三方包，它内部用的是什么模块规范？你不知道它是 commonjs 还是 esmodule。</p>
<p>而这就会导致一个比较尴尬的状况，我们来看一个例子，假设某个第三方包 <code>some-package</code> 内部是这样写的：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// some-package/index.js</span>
<span class="hljs-keyword">const</span> helper = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./helper.js'</span>)
​
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-title function_">doSomething</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> helper.<span class="hljs-title function_">process</span>()
  }
}
</code></pre>
<p>当你在项目里 <code>import { doSomething } from 'some-package'</code> 的时候，你敢这么用，浏览器就敢来表演一下罢工，因为它压根不认识 <code>require</code> 和 <code>module.exports</code> 是啥。</p>
<p>所以就需要通过依赖预构建来解决这个问题，它会把这些 CommonJS 格式的代码转换成 ESM 格式，就像一个翻译官，把"方言"翻译成浏览器能听懂的"普通话"。转换后的代码大概如下：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 预构建后</span>
<span class="hljs-keyword">import</span> helper <span class="hljs-keyword">from</span> <span class="hljs-string">'./helper.js'</span>
​
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">doSomething</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">return</span> helper.<span class="hljs-title function_">process</span>()
}
</code></pre>
<h2 data-id="heading-3">最小实现</h2>
<blockquote>
<p>本文对于 esbuild 不会做出过多赘述，有兴趣的读者可以自己去查阅相关资料</p>
</blockquote>
<h3 data-id="heading-4">分析</h3>
<p>通过查看上文的一个截图，我们大概能看出，其实依赖预构建，就是吧 lodash 这个包的函数都打包到了一个文件里面，然后做了一个统一的导出，所以我们来实现的依赖预构建，也就是要完成这一个目标。</p>
<p>要完成这个目标如果采用比较原始的方式，莫过于在 node 中读取入口文件，根据导入的路径去读取文件的内容，写入到一个文件里面，最后添加一端统一的导出字符串。</p>
<p>这种想法好像一看没什么问题，但是其中还是有些问题的，比如入口文件导入的那个依赖文件，它内部还依赖了其他文件，如果只是粗暴的分析一个入口文件，最后的打包的单文件一定是不完整的，而其中还会存在重复的依赖引入，比如一些通用的工具函数，所以我们需要换一种思路。</p>
<p>我们聊的东西本质上就是：<strong>如何从单一入口，递归地构建一个<code>依赖图</code>，并按依赖顺序读取所有模块内容</strong>。因此大概执行的步骤如下：</p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-bullet">1.</span> 从入口文件的依赖开始，比如 from './add'
<span class="hljs-bullet">2.</span> 再解析 add 内部的 import
<span class="hljs-bullet">3.</span> 后续的依赖文件也执行这个逻辑
<span class="hljs-bullet">4.</span> 直到最后没有新的依赖为止
</code></pre>
<p>生成<strong>依赖图</strong>，为什么是图而不是树呢？毕竟一想到递归，很多情况下大家不约而同的就想到了树结构，树结构如下：</p>
<pre><code class="hljs language-css" lang="css"># 树结构
entry
 ├─ <span class="hljs-selector-tag">a</span>
 │   └─ shared
 └─ <span class="hljs-selector-tag">b</span>
     └─ shared
</code></pre>
<p>那图结构有什么好处？</p>
<ol start="0">
<li>
<p><strong>一个模块可能被多个模块依赖（多父节点）</strong> ：这在真实项目里太常见了，工具函数、运行时垫片、第三方包内部的小工具……树结构天生表达不了“同一个东西被多处引用但只存在一份”。</p>
<p>什么是多父节点，比如：</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-tag">A</span><span class="hljs-selector-class">.js</span>  ──┐
        ├──&gt;  utils<span class="hljs-selector-class">.js</span>
<span class="hljs-selector-tag">B</span><span class="hljs-selector-class">.js</span>  ──┘
</code></pre>
<ul>
<li><code>A.js</code> 里 <code>import utils from './utils.js'</code></li>
<li><code>B.js</code> 里 <code>import utils from './utils.js'</code></li>
<li>这个日常中很常见，于是 utils.js 就存在了两个父节点了，这就是多父节点</li>
</ul>
</li>
<li>
<p><strong>循环依赖是存在的</strong>：比如 <code>a</code> import <code>b</code>，<code>b</code> 又 import <code>a</code>。树要求“从上到下不能绕回来”，但依赖关系就是允许绕回来的，所以需要用图来描述，并且用“访问过就不再深入”的方式避免无限递归。</p>
</li>
</ol>
<p>所以这里我们从一开始就用“依赖图”的视角去做：一边递归收集依赖，一边用绝对路径做去重，保证每个模块最多处理一次。</p>
<h3 data-id="heading-5">构建依赖图</h3>
<p>因此第一步让我们来实现一个函数，给我一段文件源码字符串，在使用正则匹配出导入语句，如下：</p>
<pre><code class="hljs language-vbnet" lang="vbnet">/**
 * 从文件内容中解析所有的 import/export <span class="hljs-keyword">from</span> 语句，提取依赖路径
 */
<span class="hljs-keyword">function</span> parseImports(content) {
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">imports</span> = []
​
    // 匹配 import xxx <span class="hljs-keyword">from</span> <span class="hljs-comment">'xxx' 或 export xxx from 'xxx'</span>
    <span class="hljs-keyword">const</span> importRegex =
        /(?:import|export)\s+(?:[^<span class="hljs-comment">'"]*)\s+from\s+['"]([^'"]+)['"]/g</span>
​
    <span class="hljs-keyword">let</span> match
    <span class="hljs-keyword">while</span> ((match = importRegex.exec(content)) !== null) {
        <span class="hljs-keyword">imports</span>.push(match[<span class="hljs-number">1</span>])
    }
​
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">imports</span>
}
​
// 使用 lodash 的入口文件两个导入代码来做测试
<span class="hljs-keyword">const</span> sourceCode = `export { <span class="hljs-keyword">default</span> <span class="hljs-keyword">as</span> add } <span class="hljs-keyword">from</span> <span class="hljs-comment">'./add.js';</span>
export { <span class="hljs-keyword">default</span> <span class="hljs-keyword">as</span> after } <span class="hljs-keyword">from</span> <span class="hljs-comment">'./after.js';`</span>
console.log(parseImports(sourceCode))
</code></pre>
<p>输入结果如下：</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-attr">[ <span class="hljs-string">'./add.js'</span>, <span class="hljs-string">'./after.js'</span> ]</span>
</code></pre>
<p>那么下一步要做的事情就是，实现一个递归遍历函数，来反复执行这个过程，后面的代码就没什么特殊的，可以直接浏览一下相对完全的代码，如下：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">'node:fs'</span>
<span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">'node:path'</span>
​
<span class="hljs-keyword">const</span> entryFilePath = path.<span class="hljs-title function_">join</span>(
    process.<span class="hljs-title function_">cwd</span>(),
    <span class="hljs-string">'./node_modules/lodash-es/lodash.js'</span>
)
​
<span class="hljs-comment">/**
 * 从文件内容中解析所有的 import/export from 语句，提取依赖路径
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">parseImports</span>(<span class="hljs-params">content</span>) {
    <span class="hljs-keyword">const</span> imports = []
​
    <span class="hljs-comment">// 匹配 import xxx from 'xxx' 或 export xxx from 'xxx'</span>
    <span class="hljs-keyword">const</span> importRegex =
        <span class="hljs-regexp">/(?:import|export)\s+(?:[^'"]*)\s+from\s+['"]([^'"]+)['"]/g</span>
​
    <span class="hljs-keyword">let</span> match
    <span class="hljs-keyword">while</span> ((match = importRegex.<span class="hljs-title function_">exec</span>(content)) !== <span class="hljs-literal">null</span>) {
        imports.<span class="hljs-title function_">push</span>(match[<span class="hljs-number">1</span>])
    }
​
    <span class="hljs-keyword">return</span> imports
}
​
<span class="hljs-comment">/**
 * 将相对路径解析为绝对路径
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">resolveModulePath</span>(<span class="hljs-params">importPath, currentFilePath</span>) {
    <span class="hljs-keyword">const</span> currentDir = path.<span class="hljs-title function_">dirname</span>(currentFilePath)
    <span class="hljs-keyword">return</span> path.<span class="hljs-title function_">resolve</span>(currentDir, importPath)
}
​
<span class="hljs-comment">/**
 * 递归解析依赖，构建依赖图
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">buildDependencyGraph</span>(<span class="hljs-params">entryPath</span>) {
    <span class="hljs-comment">// 依赖图</span>
    <span class="hljs-keyword">const</span> graph = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()
    <span class="hljs-comment">// 已访问过的文件</span>
    <span class="hljs-keyword">const</span> visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>()
​
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">traverse</span>(<span class="hljs-params">filePath</span>) {
        <span class="hljs-comment">// 规范化路径</span>
        <span class="hljs-keyword">const</span> normalizedPath = path.<span class="hljs-title function_">normalize</span>(filePath)
​
        <span class="hljs-comment">// 已访问过则跳过</span>
        <span class="hljs-keyword">if</span> (visited.<span class="hljs-title function_">has</span>(normalizedPath)) {
            <span class="hljs-keyword">return</span>
        }
​
        visited.<span class="hljs-title function_">add</span>(normalizedPath)
​
        <span class="hljs-comment">// 读取文件内容</span>
        <span class="hljs-keyword">let</span> content
        <span class="hljs-keyword">try</span> {
            content = fs.<span class="hljs-title function_">readFileSync</span>(normalizedPath, <span class="hljs-string">'utf-8'</span>)
        } <span class="hljs-keyword">catch</span> (err) {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`无法读取文件: <span class="hljs-subst">${normalizedPath}</span>`</span>)
            <span class="hljs-keyword">return</span>
        }
​
        <span class="hljs-comment">// 解析 import 语句</span>
        <span class="hljs-keyword">const</span> imports = <span class="hljs-title function_">parseImports</span>(content)
​
        <span class="hljs-comment">// 解析为绝对路径</span>
        <span class="hljs-keyword">const</span> dependencies = imports.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">imp</span> =&gt;</span>
            <span class="hljs-title function_">resolveModulePath</span>(imp, normalizedPath)
        )
​
        <span class="hljs-comment">// 存入依赖图</span>
        graph.<span class="hljs-title function_">set</span>(normalizedPath, dependencies)
​
        <span class="hljs-comment">// 递归处理每个依赖</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> dep <span class="hljs-keyword">of</span> dependencies) {
            <span class="hljs-title function_">traverse</span>(dep)
        }
    }
​
    <span class="hljs-title function_">traverse</span>(entryPath)
​
    <span class="hljs-keyword">return</span> graph
}
​
<span class="hljs-comment">// 构建依赖图</span>
<span class="hljs-keyword">const</span> dependencyGraph = <span class="hljs-title function_">buildDependencyGraph</span>(entryFilePath)
​
<span class="hljs-comment">// 输出依赖图信息</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`\n依赖图构建完成，共 <span class="hljs-subst">${dependencyGraph.size}</span> 个模块\n`</span>)
​
<span class="hljs-comment">// 打印依赖图结构</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [file, deps] <span class="hljs-keyword">of</span> dependencyGraph) {
    <span class="hljs-keyword">const</span> relativePath = path.<span class="hljs-title function_">relative</span>(process.<span class="hljs-title function_">cwd</span>(), file)
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`+ <span class="hljs-subst">${relativePath}</span>`</span>)
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> dep <span class="hljs-keyword">of</span> deps) {
        <span class="hljs-keyword">const</span> relativeDepPath = path.<span class="hljs-title function_">relative</span>(process.<span class="hljs-title function_">cwd</span>(), dep)
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`   └── <span class="hljs-subst">${relativeDepPath}</span>`</span>)
    }
}
</code></pre>
<p>输出如下：</p>
<pre><code class="hljs language-bash" lang="bash">+ node_modules/lodash-es/lodash.js
   └── node_modules/lodash-es/add.js
   └── node_modules/lodash-es/after.js
+ node_modules/lodash-es/add.js
   └── node_modules/lodash-es/_createMathOperation.js
+ node_modules/lodash-es/_createMathOperation.js
   └── node_modules/lodash-es/_baseToNumber.js
   └── node_modules/lodash-es/_baseToString.js
+ node_modules/lodash-es/_baseToNumber.js
   └── node_modules/lodash-es/isSymbol.js
+ node_modules/lodash-es/isSymbol.js
   └── node_modules/lodash-es/_baseGetTag.js
   └── node_modules/lodash-es/isObjectLike.js
+ node_modules/lodash-es/_baseGetTag.js
   └── node_modules/lodash-es/_Symbol.js
   └── node_modules/lodash-es/_getRawTag.js
   └── node_modules/lodash-es/_objectToString.js
+ ...
</code></pre>
<p>有了这个依赖图之后，我们离这个核心就非常接近了，这个依赖图一眼看过去，都不知要如何遍历执行，所以我们还欠缺一个步骤，<strong>拓扑排序</strong>。</p>
<h3 data-id="heading-6">拓扑排序</h3>
<p>如果按照上面依赖图区进行遍历读取，肯定会出现问题的，但是在实际的 bundle 中，就会爆炸，要得到正确的 bundle 就要做到 <strong>所有模块按“依赖先、使用后”的顺序排好队</strong>，而这个排队就是拓扑排序。</p>
<p>而实现的手段不做限制，毕竟在 ai 如此流行的情况，我相信 ai 可以写的很好很完善，还可以解释每一行代码的意义，我这里就直接贴出代码，如下：</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">/**
 * 对依赖图做拓扑排序，返回“依赖在前、被依赖在后”的模块顺序
 */</span>
function <span class="hljs-built_in">topologicalSort</span>(graph) {
    const allNodes = new <span class="hljs-built_in">Set</span>()
​
    for (const [filePath, deps] of graph) {
        allNodes<span class="hljs-selector-class">.add</span>(filePath)
        for (const dep of deps) {
            allNodes<span class="hljs-selector-class">.add</span>(dep)
        }
    }
​
    <span class="hljs-comment">// indegree：一个模块还剩多少“依赖”没有被处理（依赖越多 indegree 越大）</span>
    const indegree = new <span class="hljs-built_in">Map</span>()
    <span class="hljs-comment">// dependents：某个依赖被处理完后，哪些模块可以被推进</span>
    const dependents = new <span class="hljs-built_in">Map</span>()
​
    for (const node of allNodes) {
        indegree<span class="hljs-selector-class">.set</span>(node, <span class="hljs-number">0</span>)
        dependents<span class="hljs-selector-class">.set</span>(node, new Set())
    }
​
    for (const [filePath, deps] of graph) {
        for (const dep of deps) {
            if (!dependents.has(dep)) {
                dependents<span class="hljs-selector-class">.set</span>(dep, new Set())
            }
            dependents<span class="hljs-selector-class">.get</span>(dep)<span class="hljs-selector-class">.add</span>(filePath)
            indegree<span class="hljs-selector-class">.set</span>(filePath, (indegree.get(filePath) ?? <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>)
        }
    }
​
    const queue = <span class="hljs-selector-attr">[]</span>
    for (const node of allNodes) {
        if ((indegree.get(node) ?? <span class="hljs-number">0</span>) === <span class="hljs-number">0</span>) {
            queue<span class="hljs-selector-class">.push</span>(node)
        }
    }
​
    const sorted = <span class="hljs-selector-attr">[]</span>
    let idx = <span class="hljs-number">0</span>
    while (idx &lt; queue.length) {
        const node = queue<span class="hljs-selector-attr">[idx++]</span>
        sorted<span class="hljs-selector-class">.push</span>(node)
​
        const nextNodes = dependents<span class="hljs-selector-class">.get</span>(node)
        if (!nextNodes) continue
​
        for (const next of nextNodes) {
            const nextIn = (indegree.get(next) ?? <span class="hljs-number">0</span>) - <span class="hljs-number">1</span>
            indegree<span class="hljs-selector-class">.set</span>(next, nextIn)
            if (nextIn === <span class="hljs-number">0</span>) {
                queue<span class="hljs-selector-class">.push</span>(next)
            }
        }
    }
​
    if (sorted.length !== allNodes.size) {
        const cyclicNodes = <span class="hljs-selector-attr">[]</span>
        for (const [node, deg] of indegree) {
            if (deg &gt; <span class="hljs-number">0</span>) cyclicNodes<span class="hljs-selector-class">.push</span>(node)
        }
        throw new <span class="hljs-built_in">Error</span>(
            `检测到循环依赖，无法完成拓扑排序：\n${cyclicNodes.join('\n')}`
        )
    }
​
    return sorted
}
</code></pre>
<p>结果如下：</p>
<pre><code class="hljs language-arduino" lang="arduino">[
  <span class="hljs-comment">// ...</span>
  <span class="hljs-string">'/Users/coderjc/Documents/test-code/原生/no-pre-bundle/node_modules/lodash-es/_baseGetTag.js'</span>,
  <span class="hljs-string">'/Users/coderjc/Documents/test-code/原生/no-pre-bundle/node_modules/lodash-es/isSymbol.js'</span>,
  <span class="hljs-string">'/Users/coderjc/Documents/test-code/原生/no-pre-bundle/node_modules/lodash-es/_baseToNumber.js'</span>,
  <span class="hljs-string">'/Users/coderjc/Documents/test-code/原生/no-pre-bundle/node_modules/lodash-es/_baseToString.js'</span>,
  <span class="hljs-string">'/Users/coderjc/Documents/test-code/原生/no-pre-bundle/node_modules/lodash-es/toNumber.js'</span>,
  <span class="hljs-string">'/Users/coderjc/Documents/test-code/原生/no-pre-bundle/node_modules/lodash-es/_createMathOperation.js'</span>,
  <span class="hljs-string">'/Users/coderjc/Documents/test-code/原生/no-pre-bundle/node_modules/lodash-es/toFinite.js'</span>,
  <span class="hljs-string">'/Users/coderjc/Documents/test-code/原生/no-pre-bundle/node_modules/lodash-es/add.js'</span>,
  <span class="hljs-string">'/Users/coderjc/Documents/test-code/原生/no-pre-bundle/node_modules/lodash-es/toInteger.js'</span>,
  <span class="hljs-string">'/Users/coderjc/Documents/test-code/原生/no-pre-bundle/node_modules/lodash-es/after.js'</span>,
  <span class="hljs-string">'/Users/coderjc/Documents/test-code/原生/no-pre-bundle/node_modules/lodash-es/lodash.js'</span>
]
</code></pre>
<p>我们的例子中为了更好的观察，只保留了 add 和 after 两个函数的导入，从结果来看，是没什么问题的。</p>
<p>后续的步骤大概可以拆分为两步，一步是源码转换，一步是 bundle 生成，这一步其实比较简单，因为我们可以直接利用 esbuild 来完成。</p>
<p>当然也可以自己写，不过我是直接丢给 ai 实现，大概的结果如图：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/20efef7ca650421f93df3879b6395a25~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgY29kZXJqYw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768224367&amp;x-signature=2An8YXG2ag4Y43s3tQKAaJfaJYw%3D" alt="image-20260105211550397.png" loading="lazy"/></p>
<h3 data-id="heading-7">使用 esbuild 完成构建</h3>
<p>其实利用 esbuild 都不需要我们去自己实现依赖图什么的，只是为了说明大概做了什么事情而写的，下面看看使用 esbuild 如何实现。如下：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> esbuild <span class="hljs-keyword">from</span> <span class="hljs-string">'esbuild'</span>
​
<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">prebundleDeps</span>(<span class="hljs-params">deps</span>) {
    <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(
        deps.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">dep</span> =&gt;</span> {
            <span class="hljs-keyword">return</span> esbuild.<span class="hljs-title function_">build</span>({
                <span class="hljs-attr">entryPoints</span>: [dep],
                <span class="hljs-attr">bundle</span>: <span class="hljs-literal">true</span>,
                <span class="hljs-attr">format</span>: <span class="hljs-string">'esm'</span>,
                <span class="hljs-attr">platform</span>: <span class="hljs-string">'browser'</span>,
                <span class="hljs-attr">outfile</span>: <span class="hljs-string">'./dist/lodash-es.js'</span>,
                <span class="hljs-attr">sourcemap</span>: <span class="hljs-literal">true</span>
            })
        })
    )
}
​
<span class="hljs-title function_">prebundleDeps</span>([<span class="hljs-string">'lodash-es'</span>])
</code></pre>
<p>打包结果如图：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d2888223e2f44fa496d7590b1fe9c99b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgY29kZXJqYw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768224367&amp;x-signature=OgjaaveEhD6KK%2B0OdytNW2t2KOU%3D" alt="image-20260105211942893.png" loading="lazy"/></p>
<p>大家可以和前文的网络请求的文件截图对比一下，结果都是一致的。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Core Data 简化开发：NSPersistentContainer 从原理到实战]]></title>    <link>https://juejin.cn/post/7591687981688193070</link>    <guid>https://juejin.cn/post/7591687981688193070</guid>    <pubDate>2026-01-05T11:10:54.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7591687981688193070" data-draft-id="7591694511246049318" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Core Data 简化开发：NSPersistentContainer 从原理到实战"/> <meta itemprop="keywords" content="Swift"/> <meta itemprop="datePublished" content="2026-01-05T11:10:54.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="JQShan"/> <meta itemprop="url" content="https://juejin.cn/user/1636535083759005"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Core Data 简化开发：NSPersistentContainer 从原理到实战
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1636535083759005/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    JQShan
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-05T11:10:54.000Z" title="Mon Jan 05 2026 11:10:54 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-05
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    6
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>作为 iOS/macOS 开发者，本地数据存储是绕不开的话题。提起 Core Data，不少新手会皱眉头 —— 早期的 Core Data 配置繁琐，手动管理上下文、协调器这些组件很容易踩坑；而老开发者则清楚，自从 Apple 推出<code>NSPersistentContainer</code>后，Core Data 的使用体验直接 “起飞”。今天就跟大家聊聊，这个 “容器” 到底是什么、怎么用，以及它的那些优缺点。</p>
<h2 data-id="heading-0">一、先唠唠 Core Data 的 “老痛点”</h2>
<p>在 iOS 10/macOS 10.12 之前，想用 Core Data 得手动搭一套 “流水线”：</p>
<ol>
<li>加载<code>NSManagedObjectModel</code>（数据模型）；</li>
<li>创建<code>NSPersistentStoreCoordinator</code>（持久化存储协调器），指定存储类型（比如 SQLite）和路径；</li>
<li>实例化<code>NSManagedObjectContext</code>（托管对象上下文），并关联协调器；</li>
<li>还要处理线程安全、上下文合并这些问题。</li>
</ol>
<p>一套操作下来，代码又长又容易出错，光是初始化就能劝退一半新手。Apple 显然也发现了这个问题，于是<code>NSPersistentContainer</code>应运而生 —— 它把 Core Data 的核心组件全 “打包” 了，让我们不用再关心底层细节，专注于业务逻辑即可。</p>
<h2 data-id="heading-1">二、NSPersistentContainer：Core Data 的 “一站式工具箱”</h2>
<h3 data-id="heading-2">1. 核心原理：封装了什么？</h3>
<p><code>NSPersistentContainer</code>本质是对 Core Data 三大核心组件的封装，相当于给我们准备了一个开箱即用的 “数据管理容器”，内部结构如下：</p>

























<table><thead><tr><th>组件</th><th>作用</th><th>容器中的访问方式</th></tr></thead><tbody><tr><td><code>NSManagedObjectModel</code></td><td>定义数据结构（对应.xcdatamodeld 文件）</td><td><code>container.managedObjectModel</code></td></tr><tr><td><code>NSPersistentStoreCoordinator</code></td><td>管理数据存储（比如 SQLite 文件）</td><td><code>container.persistentStoreCoordinator</code></td></tr><tr><td><code>NSManagedObjectContext</code></td><td>操作数据的 “工作台”（增删改查）</td><td><code>container.viewContext</code>（主线程）/<code>container.newBackgroundContext()</code>（后台）</td></tr></tbody></table>
<p>简单说：你只需要告诉容器 “数据模型叫什么名字”，它会自动完成模型加载、协调器创建、上下文关联等所有底层工作，不用写一行冗余代码。</p>
<h3 data-id="heading-3">2. 最核心的两个上下文</h3>
<p>容器里最常用的是两个上下文，一定要分清：</p>
<ul>
<li><strong>viewContext</strong>：默认绑定<strong>主线程</strong>，专门用于 UI 相关的操作（比如列表展示读书笔记），线程安全，直接用就行；</li>
<li><strong>newBackgroundContext()</strong> ：每次调用都会生成一个新的后台上下文，用于耗时操作（比如批量导入历史读书笔记），避免阻塞主线程导致 UI 卡顿。</li>
</ul>
<h2 data-id="heading-4">三、实战：NSPersistentContainer 的基本用法</h2>
<p>光说不练假把式，我们用一个简单的 “读书笔记管理” 示例，看看怎么用容器搞定 Core Data 的增删改查。</p>
<h3 data-id="heading-5">前置准备</h3>
<ol>
<li>
<p>创建 iOS 项目时勾选「Use Core Data」（Xcode 会自动生成基础的容器代码）；</p>
</li>
<li>
<p>打开<code>.xcdatamodeld</code>文件，创建一个<code>BookNote</code>实体，添加三个属性：</p>
<ul>
<li><code>bookName</code>（String，书名）；</li>
<li><code>content</code>（String，笔记内容）；</li>
<li><code>createTime</code>（Date，创建时间，默认值可设为<code>@now</code>）。</li>
</ul>
</li>
</ol>
<h3 data-id="heading-6">1. 初始化容器（Xcode 自动生成，稍作优化）</h3>
<p>AppDelegate 中的核心代码，我们优化下错误处理（别用 fatalError，实际项目要友好）：</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">import</span> UIKit
<span class="hljs-keyword">import</span> CoreData

<span class="hljs-keyword">@UIApplicationMain</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">AppDelegate</span>: <span class="hljs-title class_">UIResponder</span>, <span class="hljs-title class_">UIApplicationDelegate</span> {
    <span class="hljs-comment">// 懒加载持久化容器</span>
    <span class="hljs-keyword">lazy</span> <span class="hljs-keyword">var</span> persistentContainer: <span class="hljs-type">NSPersistentContainer</span> <span class="hljs-operator">=</span> {
        <span class="hljs-comment">// 模型文件名要和.xcdatamodeld文件名称一致（比如我命名为BookNoteModel）</span>
        <span class="hljs-keyword">let</span> container <span class="hljs-operator">=</span> <span class="hljs-type">NSPersistentContainer</span>(name: <span class="hljs-string">"BookNoteModel"</span>) 
        
        <span class="hljs-comment">// 加载持久化存储（默认是SQLite文件，存储在App沙盒中）</span>
        container.loadPersistentStores(completionHandler: { (storeDescription, error) <span class="hljs-keyword">in</span>
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> error <span class="hljs-operator">=</span> error <span class="hljs-keyword">as</span> <span class="hljs-type">NSError</span>? {
                <span class="hljs-comment">// 实际项目中替换为日志/弹窗提示，别直接崩溃</span>
                <span class="hljs-built_in">print</span>(<span class="hljs-string">"Core Data加载失败：(error.localizedDescription)"</span>)
            }
        })
        <span class="hljs-keyword">return</span> container
    }()

    <span class="hljs-comment">// 封装保存上下文的方法，复用性更高</span>
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">saveContext</span>() {
        <span class="hljs-keyword">let</span> context <span class="hljs-operator">=</span> persistentContainer.viewContext
        <span class="hljs-keyword">guard</span> context.hasChanges <span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> } <span class="hljs-comment">// 没有修改就不保存，减少IO消耗</span>
        
        <span class="hljs-keyword">do</span> {
            <span class="hljs-keyword">try</span> context.save()
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"读书笔记保存成功✅"</span>)
        } <span class="hljs-keyword">catch</span> {
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"保存失败❌：(error.localizedDescription)"</span>)
        }
    }
}
</code></pre>
<h3 data-id="heading-7">2. 增删改查实战（ViewController 中）</h3>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">import</span> UIKit
<span class="hljs-keyword">import</span> CoreData

<span class="hljs-keyword">class</span> <span class="hljs-title class_">ViewController</span>: <span class="hljs-title class_">UIViewController</span> {
    <span class="hljs-comment">// 获取容器（实际项目建议用单例/依赖注入，别直接强转AppDelegate，这里为了简化）</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> container: <span class="hljs-type">NSPersistentContainer</span> {
        <span class="hljs-keyword">let</span> appDelegate <span class="hljs-operator">=</span> <span class="hljs-type">UIApplication</span>.shared.delegate <span class="hljs-keyword">as!</span> <span class="hljs-type">AppDelegate</span>
        <span class="hljs-keyword">return</span> appDelegate.persistentContainer
    }

    <span class="hljs-comment">// 1. 添加读书笔记</span>
    <span class="hljs-keyword">@IBAction</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">addBookNote</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">sender</span>: <span class="hljs-type">UIButton</span>) {
        <span class="hljs-keyword">let</span> context <span class="hljs-operator">=</span> container.viewContext
        <span class="hljs-comment">// 创建BookNote对象</span>
        <span class="hljs-keyword">let</span> note <span class="hljs-operator">=</span> <span class="hljs-type">BookNote</span>(context: context)
        note.bookName <span class="hljs-operator">=</span> <span class="hljs-string">"《小王子》"</span>
        note.content <span class="hljs-operator">=</span> <span class="hljs-string">"正是你为你的玫瑰花费的时光，才使你的玫瑰变得如此重要。"</span>
        note.createTime <span class="hljs-operator">=</span> <span class="hljs-type">Date</span>() <span class="hljs-comment">// 也可以依赖模型的默认值，这里手动赋值更直观</span>
        
        <span class="hljs-comment">// 调用AppDelegate的保存方法</span>
        (<span class="hljs-type">UIApplication</span>.shared.delegate <span class="hljs-keyword">as!</span> <span class="hljs-type">AppDelegate</span>).saveContext()
    }

    <span class="hljs-comment">// 2. 查询所有读书笔记（可按创建时间倒序）</span>
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">fetchAllBookNotes</span>() {
        <span class="hljs-keyword">let</span> context <span class="hljs-operator">=</span> container.viewContext
        <span class="hljs-comment">// 创建查询请求</span>
        <span class="hljs-keyword">let</span> fetchRequest: <span class="hljs-type">NSFetchRequest</span>&lt;<span class="hljs-type">BookNote</span>&gt; <span class="hljs-operator">=</span> <span class="hljs-type">BookNote</span>.fetchRequest()
        
        <span class="hljs-comment">// 按创建时间倒序排列，最新的笔记在前面</span>
        <span class="hljs-keyword">let</span> sortDescriptor <span class="hljs-operator">=</span> <span class="hljs-type">NSSortDescriptor</span>(keyPath: \<span class="hljs-type">BookNote</span>.createTime, ascending: <span class="hljs-literal">false</span>)
        fetchRequest.sortDescriptors <span class="hljs-operator">=</span> [sortDescriptor]
        
        <span class="hljs-keyword">do</span> {
            <span class="hljs-keyword">let</span> notes <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> context.fetch(fetchRequest)
            notes.forEach { note <span class="hljs-keyword">in</span>
                <span class="hljs-built_in">print</span>(<span class="hljs-string">"📚 书名：(note.bookName ?? "</span>未知<span class="hljs-string">")"</span>)
                <span class="hljs-built_in">print</span>(<span class="hljs-string">"✍️ 笔记：(note.content ?? "</span>无内容<span class="hljs-string">")"</span>)
                <span class="hljs-built_in">print</span>(<span class="hljs-string">"🕒 创建时间：(note.createTime ?? Date())<span class="hljs-subst">\n</span>"</span>)
            }
        } <span class="hljs-keyword">catch</span> {
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"查询读书笔记失败：(error.localizedDescription)"</span>)
        }
    }

    <span class="hljs-comment">// 3. 删除读书笔记（示例：删除第一条《小王子》的笔记）</span>
    <span class="hljs-keyword">@IBAction</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">deleteBookNote</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">sender</span>: <span class="hljs-type">UIButton</span>) {
        <span class="hljs-keyword">let</span> context <span class="hljs-operator">=</span> container.viewContext
        <span class="hljs-keyword">let</span> fetchRequest: <span class="hljs-type">NSFetchRequest</span>&lt;<span class="hljs-type">BookNote</span>&gt; <span class="hljs-operator">=</span> <span class="hljs-type">BookNote</span>.fetchRequest()
        
        <span class="hljs-comment">// 增加筛选条件：只删《小王子》的笔记</span>
        fetchRequest.predicate <span class="hljs-operator">=</span> <span class="hljs-type">NSPredicate</span>(format: <span class="hljs-string">"bookName == %@"</span>, <span class="hljs-string">"《小王子》"</span>)
        
        <span class="hljs-keyword">do</span> {
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> targetNote <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> context.fetch(fetchRequest).first {
                context.delete(targetNote) <span class="hljs-comment">// 删除指定笔记对象</span>
                (<span class="hljs-type">UIApplication</span>.shared.delegate <span class="hljs-keyword">as!</span> <span class="hljs-type">AppDelegate</span>).saveContext()
                <span class="hljs-built_in">print</span>(<span class="hljs-string">"《小王子》的笔记已删除"</span>)
            }
        } <span class="hljs-keyword">catch</span> {
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"删除读书笔记失败：(error.localizedDescription)"</span>)
        }
    }

    <span class="hljs-comment">// 4. 后台批量导入读书笔记（重点：用后台上下文，不卡UI）</span>
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">batchImportBookNotes</span>() {
        <span class="hljs-comment">// 创建后台上下文</span>
        <span class="hljs-keyword">let</span> backgroundContext <span class="hljs-operator">=</span> container.newBackgroundContext()
        <span class="hljs-comment">// 设置合并策略，避免多上下文操作冲突</span>
        backgroundContext.mergePolicy <span class="hljs-operator">=</span> <span class="hljs-type">NSMergeByPropertyObjectTrumpMergePolicy</span>
        
        <span class="hljs-comment">// 在后台线程执行批量操作，不会阻塞主线程</span>
        backgroundContext.perform { [<span class="hljs-keyword">weak</span> <span class="hljs-keyword">self</span>] <span class="hljs-keyword">in</span>
            <span class="hljs-comment">// 模拟批量导入3本经典书籍的笔记</span>
            <span class="hljs-keyword">let</span> noteDatas <span class="hljs-operator">=</span> [
                (<span class="hljs-string">"《百年孤独》"</span>, <span class="hljs-string">"生命中真正重要的不是你遭遇了什么，而是你记住了哪些事，又是如何铭记的。"</span>),
                (<span class="hljs-string">"《解忧杂货店》"</span>, <span class="hljs-string">"其实所有纠结做选择的人心里早就有了答案，咨询只是想得到内心所倾向的选择。"</span>),
                (<span class="hljs-string">"《活着》"</span>, <span class="hljs-string">"人是为了活着本身而活着的，而不是为了活着之外的任何事物而活着。"</span>)
            ]
            
            <span class="hljs-comment">// 循环创建笔记对象</span>
            <span class="hljs-keyword">for</span> (bookName, content) <span class="hljs-keyword">in</span> noteDatas {
                <span class="hljs-keyword">let</span> note <span class="hljs-operator">=</span> <span class="hljs-type">BookNote</span>(context: backgroundContext)
                note.bookName <span class="hljs-operator">=</span> bookName
                note.content <span class="hljs-operator">=</span> content
                note.createTime <span class="hljs-operator">=</span> <span class="hljs-type">Date</span>()
            }
            
            <span class="hljs-comment">// 保存后台上下文的修改</span>
            <span class="hljs-keyword">do</span> {
                <span class="hljs-keyword">try</span> backgroundContext.save()
                <span class="hljs-built_in">print</span>(<span class="hljs-string">"批量导入读书笔记完成✅"</span>)
            } <span class="hljs-keyword">catch</span> {
                <span class="hljs-built_in">print</span>(<span class="hljs-string">"批量导入失败❌：(error.localizedDescription)"</span>)
            }
        }
    }
}
</code></pre>
<h3 data-id="heading-8">小提示</h3>
<ul>
<li>别在主线程做批量导入 / 大量查询操作！一定要用<code>newBackgroundContext()</code>；</li>
<li>后台上下文的<code>perform</code>方法会自动在对应的后台线程执行代码，不用手动写 GCD（比如<code>DispatchQueue.global().async</code>）；</li>
<li>实际项目中，建议把 Core Data 操作封装成单独的工具类（比如<code>BookNoteManager</code>），把增删改查的逻辑抽离出来，ViewController 只负责调用，代码更整洁易维护。</li>
</ul>
<h2 data-id="heading-9">四、NSPersistentContainer 的优缺点</h2>
<h3 data-id="heading-10">优点：新手友好，效率拉满</h3>
<ol>
<li><strong>极大简化配置</strong>：不用手动管理模型、协调器、上下文的关联，几行代码就能初始化 Core Data；</li>
<li><strong>线程安全</strong>：<code>viewContext</code>默认绑定主线程，避免了新手最容易踩的 “线程混乱” 坑；</li>
<li><strong>易于扩展</strong>：支持自定义存储路径、存储类型（比如内存存储，适合测试），满足进阶需求；</li>
<li><strong>官方维护</strong>：Apple 持续优化，兼容性和稳定性有保障。</li>
</ol>
<h3 data-id="heading-11">缺点：灵活度略有妥协</h3>
<ol>
<li><strong>底层封装过深</strong>：新手可能只知其然不知其所以然，遇到复杂问题（比如跨版本数据迁移）时，排查起来比较费劲；</li>
<li><strong>自定义配置稍麻烦</strong>：如果要修改默认的存储路径、缓存大小，需要额外写代码拆解容器；</li>
<li><strong>不支持跨平台（纯 Swift）</strong> ：Core Data 是 Apple 专属框架，如果你想做跨平台 App（比如 iOS+Android），还是得用 Realm、SQLite.swift 等。</li>
</ol>
<h2 data-id="heading-12">五、最后聊聊：什么时候用 NSPersistentContainer？</h2>
<ul>
<li>✅ <strong>推荐用</strong>：绝大多数常规 App（比如读书笔记、备忘录、待办清单类），只需要本地存储数据，不需要复杂的自定义配置；</li>
<li>❌ <strong>谨慎用</strong>：如果你需要深度定制 Core Data 的底层（比如自定义存储协调器、复杂的数据迁移策略），可能需要结合底层 API 使用；</li>
<li>📌 <strong>替代方案</strong>：如果追求跨平台 / 纯 Swift，可考虑 Realm、GRDB.swift；如果数据量极小，直接用 UserDefaults 就行。</li>
</ul>
<h2 data-id="heading-13">总结</h2>
<ol>
<li><code>NSPersistentContainer</code>是 Apple 为简化 Core Data 开发推出的 “利器”，封装了 Core Data 的核心组件，iOS 10 + 可直接用；</li>
<li>核心用法：初始化容器→用<code>viewContext</code>处理 UI 相关操作（比如展示读书笔记）→用<code>newBackgroundContext()</code>处理后台耗时操作（比如批量导入）→保存上下文；</li>
<li>它的优点是简单、安全、高效，缺点是底层封装过深，灵活度略有妥协，适合绝大多数常规 iOS/macOS 项目。</li>
</ol>
<p>Core Data 看似复杂，但有了<code>NSPersistentContainer</code>这个 “帮手”，新手也能快速上手。与其纠结底层原理，不如先动手写起来，遇到问题再深入研究，毕竟实践才是最好的老师～</p>
<hr/>
<h3 data-id="heading-14">关键点回顾</h3>
<ol>
<li>示例场景替换为「读书笔记管理」，实体<code>BookNote</code>包含<code>bookName</code>（书名）、<code>content</code>（笔记内容）、<code>createTime</code>（创建时间）三个核心属性；</li>
<li>核心代码逻辑不变，但所有增删改查、批量导入的操作都围绕 “读书笔记” 展开，更贴近日常开发场景；</li>
<li>保留了原博客轻松的语气和完整的讲解结构，同时补充了排序、筛选等更实用的查询技巧。</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Vue 3 Message 组件深度解析：从设计到实现的完整指南]]></title>    <link>https://juejin.cn/post/7591705084671328294</link>    <guid>https://juejin.cn/post/7591705084671328294</guid>    <pubDate>2026-01-05T15:26:05.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7591705084671328294" data-draft-id="7591728734982979611" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Vue 3 Message 组件深度解析：从设计到实现的完整指南"/> <meta itemprop="keywords" content="前端,Vue.js,JavaScript"/> <meta itemprop="datePublished" content="2026-01-05T15:26:05.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Spirited_Away"/> <meta itemprop="url" content="https://juejin.cn/user/2225067267204935"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Vue 3 Message 组件深度解析：从设计到实现的完整指南
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2225067267204935/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Spirited_Away
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-05T15:26:05.000Z" title="Mon Jan 05 2026 15:26:05 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-05
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    5
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;color:#3c9dff}.markdown-body h1{font-size:30px;margin-bottom:5px;padding-bottom:8px;text-align:center}.markdown-body h2{font-size:24px;padding-bottom:6px}.markdown-body h2:before{content:"🍋"}.markdown-body h3{font-size:18px;padding-bottom:0}.markdown-body h3:before{content:"🍓"}.markdown-body h4{font-size:16px}.markdown-body h4:before{content:"🍑"}.markdown-body h5{font-size:15px}.markdown-body h5:before{content:"🍉"}.markdown-body h6{margin-top:5px}.markdown-body h6:before{content:"🍒"}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{display:block;margin:0 auto;max-width:100%;border-radius:4px;padding:1px;border:1px solid #d2e8ff}.markdown-body img:hover{box-shadow:0 1px 3px #5eaeff}.markdown-body hr{height:4px;margin:34px 0;background-size:4px 1px;background-image:linear-gradient(270deg,#5eaeff,#f3f9ff 25%,transparent 50%);border-style:none}.markdown-body code{word-break:break-word;border-radius:3px;overflow-x:auto;background-color:#d2e8ff;color:#3c9dff;font-size:.9em;padding:.1em .5em;margin:0 3px}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace;transition:all .3s}.markdown-body pre{overflow:auto;position:relative;line-height:1.75;border:1px solid #90c7ff;border-radius:4px}.markdown-body pre:hover{box-shadow:0 1px 10px #beddff}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#3c9dff;border-bottom:1px solid #90c7ff;transition:all .3s}.markdown-body a:hover{color:#007fff;border-bottom:2px solid #5eaeff}.markdown-body a[href]:not(:empty){padding-right:18px}.markdown-body a[href]:not(:empty):after{display:inline-block;width:16px;height:16px;margin-left:2px;content:"";background:url(data:image/svg+xml;base64,PHN2ZyBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB3aWR0aD0iMTYiIGhlaWdodD0iMTYiPjxwYXRoIGQ9Ik0zODQgMTI4YTQ4IDQ4IDAgMDEyLjgxNiA5NS45MkwzODQgMjI0SDI1NmEzMiAzMiAwIDAwLTMxLjkyIDI5LjZMMjI0IDI1NnY1MTJhMzIgMzIgMCAwMDI5LjYgMzEuOTJsMi40LjA4aDUxMmEzMiAzMiAwIDAwMzEuOTItMjkuNmwuMDgtMi40VjY1NmE0OCA0OCAwIDAxOTUuOTItMi44MTZMODk2IDY1NnYxMTJhMTI4IDEyOCAwIDAxLTEyNCAxMjcuOTM2bC00IC4wNjRIMjU2YTEyOCAxMjggMCAwMS0xMjcuOTM2LTEyNGwtLjA2NC00VjI1NmExMjggMTI4IDAgMDExMjQtMTI3LjkzNmw0LS4wNjRoMTI4em0zODQgMGExMjggMTI4IDAgMDExMjcuOTM2IDEyNGwuMDY0IDR2MTYwYTQ4IDQ4IDAgMDEtOTUuOTIgMi44MTZMODAwIDQxNlYyOTEuODcybC0zODIuMDY0IDM4Mi4wOGE0OCA0OCAwIDAxLTcwLjAzMi02NS42bDIuMTYtMi4yODhMNzMyLjA5NiAyMjRINjA4YTQ4IDQ4IDAgMDEtMi44MTYtOTUuOTJMNjA4IDEyOGgxNjB6IiBmaWxsPSIjM2M5ZGZmIiBmaWxsLW9wYWNpdHk9Ii41NiIgZGF0YS1zcG0tYW5jaG9yLWlkPSJhMzEzeC5zZWFyY2hfaW5kZXguMC5pMC41Yzc1M2E4MTgwa2RKWCIgY2xhc3M9InNlbGVjdGVkIi8+PC9zdmc+);background-size:100%}.markdown-body table{margin:0 auto 10px;font-size:12px;width:auto;max-width:100%;overflow:auto;border-collapse:collapse;border:1px solid #3c9dff}.markdown-body thead{text-align:center}.markdown-body thead th{color:#fff;background-color:#5eaeff}.markdown-body tr{text-align:center}.markdown-body tbody tr:hover{background-color:#d2e8ff}.markdown-body tbody tr:hover code{background-color:#90c7ff}.markdown-body tr:nth-child(2n){background-color:#ecf5ff}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li::marker,.markdown-body ul li::marker{color:#5eaeff}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body b,.markdown-body strong{font-weight:900;padding:0 1px;font-size:17px}.markdown-body small{color:#cbcbcb;padding:0 1px;font-size:22px;zoom:.5}.markdown-body em{padding:0 1px}.markdown-body del{padding:0 1px;text-decoration-thickness:2px}.markdown-body blockquote{color:#1a1b1c;padding:1px 20px;margin:22px 0;border-radius:4px;border-left:4px solid rgba(60,157,255,.5);background-color:rgba(190,221,255,.3)}.markdown-body blockquote blockquote{margin:8px 0}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body details{margin:12px 0;padding:4px 10px;border:2px solid #3c9dff;border-radius:8px;background-color:#ecf5ff;transition:all .3s}.markdown-body details summary{cursor:pointer}.markdown-body input[type=checkbox]{position:relative;appearance:none;width:16px;height:16px;border-radius:2px;vertical-align:middle;transform:translateY(-2px);box-sizing:border-box;border:1px solid #beddff}.markdown-body input[type=checkbox]:checked{border:1px solid #5eaeff;background-color:#5eaeff}.markdown-body input[type=checkbox]:checked:before{position:absolute;top:3px;left:1px;width:11px;height:6px;background-color:transparent;border-left:2px solid #fff;border-bottom:2px solid #fff;transform:rotate(-45deg);content:"";box-sizing:border-box}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="androidstudio">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#a9b7c6;background:#282b2e}.hljs-bullet,.hljs-literal,.hljs-number,.hljs-symbol{color:#6897bb}.hljs-deletion,.hljs-keyword,.hljs-selector-tag{color:#cc7832}.hljs-link,.hljs-template-variable,.hljs-variable{color:#629755}.hljs-comment,.hljs-quote{color:grey}.hljs-meta{color:#bbb529}.hljs-addition,.hljs-attribute,.hljs-string{color:#6a8759}.hljs-section,.hljs-title,.hljs-type{color:#ffc66d}.hljs-name,.hljs-selector-class,.hljs-selector-id{color:#e8bf6a}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">概述</h2>
<p>Message 组件是前端 UI 库中常见的提示组件，用于向用户提供即时反馈信息。本文将详细分析一个基于 Vue 3 的 Message 组件实现，涵盖组件设计、类型定义、实例管理等关键细节。这个组件不仅实现了基本的提示功能，还解决了多实例堆叠、动态布局、内存管理等复杂问题。</p>
<h2 data-id="heading-1">类型系统设计</h2>
<p>在 <code>types.ts</code> 中定义了完整的类型系统：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MessageProps</span> {
  <span class="hljs-attr">message</span>: <span class="hljs-built_in">string</span> | <span class="hljs-title class_">VNode</span>;                    <span class="hljs-comment">// 支持字符串和VNode内容</span>
  <span class="hljs-keyword">type</span>?: <span class="hljs-string">'success'</span> | <span class="hljs-string">'info'</span> | <span class="hljs-string">'warning'</span> | <span class="hljs-string">'danger'</span>;  <span class="hljs-comment">// 消息类型</span>
  duration?: <span class="hljs-built_in">number</span>;                          <span class="hljs-comment">// 显示持续时间</span>
  offset?: <span class="hljs-built_in">number</span>;                           <span class="hljs-comment">// 偏移距离</span>
  showClose?: <span class="hljs-built_in">boolean</span>;                       <span class="hljs-comment">// 是否显示关闭按钮</span>
  showIcon?: <span class="hljs-built_in">boolean</span>;                        <span class="hljs-comment">// 是否显示图标</span>
  id?: <span class="hljs-built_in">string</span>;                               <span class="hljs-comment">// 唯一标识</span>
  <span class="hljs-attr">onDestory</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>                      <span class="hljs-comment">// 销毁回调</span>
}
</code></pre>
<p><strong>设计亮点</strong>：</p>
<ul>
<li>支持字符串和 VNode 两种内容类型，提高组件灵活性</li>
<li>使用 <code>Omit&lt;MessageProps, 'id' | "onDestory"&gt;</code> 创建 <code>CreateMessageProps</code> 类型，自动排除内部管理的属性</li>
<li>严格遵循项目规范，确保必传属性不被遗漏</li>
</ul>
<h2 data-id="heading-2">核心组件实现</h2>
<h3 data-id="heading-3">1. Message.vue 组件</h3>
<h4 data-id="heading-4">属性定义和默认值</h4>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">const</span> props = <span class="hljs-title function_">withDefaults</span>(defineProps&lt;<span class="hljs-title class_">MessageProps</span>&gt;(), {
  <span class="hljs-attr">type</span>: <span class="hljs-string">'info'</span>,
  <span class="hljs-attr">duration</span>: <span class="hljs-number">3000</span>,
  <span class="hljs-attr">showIcon</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">offset</span>: <span class="hljs-number">16</span>
})
</code></pre>
<h4 data-id="heading-5">图标映射系统</h4>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">const</span> iconMap = {
  <span class="hljs-attr">primary</span>: <span class="hljs-string">'circle-info'</span>,
  <span class="hljs-attr">success</span>: <span class="hljs-string">'circle-check'</span>, 
  <span class="hljs-attr">warning</span>: <span class="hljs-string">'circle-exclamation'</span>,
  <span class="hljs-attr">danger</span>: <span class="hljs-string">'triangle-exclamation'</span>,
  <span class="hljs-attr">info</span>: <span class="hljs-string">'circle-info'</span>
}
</code></pre>
<p><strong>设计细节</strong>：</p>
<ul>
<li>图标映射确保不同类型的消息有对应的视觉标识</li>
<li>使用 Font Awesome 图标系统，符合项目技术选型</li>
</ul>
<h4 data-id="heading-6">定时器管理</h4>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">timer</span>: <span class="hljs-title class_">NodeJS</span>.<span class="hljs-property">Timeout</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">startTimer</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">if</span> (props.<span class="hljs-property">duration</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>
  timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    visible.<span class="hljs-property">value</span> = <span class="hljs-literal">false</span>
    props.<span class="hljs-title function_">onDestory</span>()
  }, props.<span class="hljs-property">duration</span>)
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">clearTimer</span>(<span class="hljs-params"/>) {
  <span class="hljs-built_in">clearTimeout</span>(timer)
}
</code></pre>
<p><strong>交互细节</strong>：</p>
<ul>
<li>鼠标悬停时暂停自动关闭 (<code>@mouseenter="clearTimer"</code>)</li>
<li>鼠标离开时重新开始计时 (<code>@mouseleave="startTimer"</code>)</li>
<li><code>duration</code> 为 0 时禁用自动关闭功能</li>
</ul>
<h4 data-id="heading-7">组件暴露接口</h4>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-title function_">defineExpose</span>({
  <span class="hljs-attr">close</span>: <span class="hljs-function">() =&gt;</span> {
    visible.<span class="hljs-property">value</span> = <span class="hljs-literal">false</span>
  }
})
</code></pre>
<p><strong>关键点</strong>：</p>
<ul>
<li>通过 <code>defineExpose</code> 暴露 <code>close</code> 方法，允许外部手动关闭消息</li>
<li>符合 Vue 3 的封装原则，只暴露必要的接口</li>
</ul>
<h2 data-id="heading-8">实例管理机制</h2>
<h3 data-id="heading-9">1. 全局实例管理</h3>
<p>在 <code>index.ts</code>中实现了完整的实例管理系统：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">MessageInstance</span> {
  <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>,
  <span class="hljs-attr">el</span>: <span class="hljs-title class_">HTMLElement</span>,
  <span class="hljs-attr">instance</span>: <span class="hljs-title class_">InstanceType</span>&lt;<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Message</span>&gt;,
  <span class="hljs-attr">offset</span>: <span class="hljs-built_in">number</span>
}
</code></pre>
<p><strong>设计细节</strong>：</p>
<ul>
<li>每个实例包含 ID、DOM 元素、组件实例和计算出的偏移量</li>
</ul>
<h3 data-id="heading-10">2. 唯一ID生成</h3>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">let</span> index = <span class="hljs-number">1</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">messageInstances</span>: <span class="hljs-title class_">MessageInstance</span>[] = []
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">HmMessage</span>(<span class="hljs-params">props: CreateMessageProps</span>): <span class="hljs-title class_">InstanceType</span>&lt;<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Message</span>&gt; {
  <span class="hljs-keyword">const</span> id = <span class="hljs-string">`message_<span class="hljs-subst">${index++}</span>`</span>
  <span class="hljs-comment">// ...</span>
}
</code></pre>
<p><strong>实现细节</strong>：</p>
<ul>
<li>使用递增索引确保每个消息实例有唯一ID</li>
<li>ID用于实例查找和管理，避免冲突</li>
</ul>
<h3 data-id="heading-11">3. 动态渲染策略</h3>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-title function_">render</span>(<span class="hljs-title function_">h</span>(<span class="hljs-title class_">Message</span>, {
  ...props, id,
  offset,
  <span class="hljs-attr">onVnodeMounted</span>: <span class="hljs-function">(<span class="hljs-params">vnode: VNode</span>) =&gt;</span> {
    componentInstance = vnode.<span class="hljs-property">component</span>;
  },
  <span class="hljs-attr">onDestory</span>: close
}), container)

<span class="hljs-title function_">nextTick</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">const</span> el = container.<span class="hljs-property">firstElementChild</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">HTMLElement</span>
  el &amp;&amp; <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(el)
  <span class="hljs-comment">// 添加到实例数组</span>
})
</code></pre>
<p><strong>技术细节</strong>：</p>
<ul>
<li>使用 <code>render</code> 函数动态渲染组件，符合 Vue 3 的渲染 API</li>
<li>通过 <code>onVnodeMounted</code> 钩子获取组件实例</li>
<li><code>nextTick</code> 确保 DOM 渲染完成后再添加到 body</li>
</ul>
<h3 data-id="heading-12">4. 垂直排列算法</h3>
<p><code>calculateOffset</code>函数实现了智能的垂直排列：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">calculateOffset</span>(<span class="hljs-params">baseOffset, lastMessage?: MessageInstance, delFirstEl = <span class="hljs-literal">false</span></span>) {
  <span class="hljs-comment">// 销毁计算时，第一个元素特殊处理</span>
  <span class="hljs-keyword">if</span> (messageInstances.<span class="hljs-property">length</span> === <span class="hljs-number">0</span> || (delFirstEl &amp;&amp; !lastMessage)) {
    <span class="hljs-keyword">return</span> baseOffset;
  }

  lastMessage = lastMessage || messageInstances[messageInstances.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>];
  <span class="hljs-keyword">const</span> lastElement = lastMessage.<span class="hljs-property">el</span>;
  <span class="hljs-keyword">const</span> lastHeight = lastElement.<span class="hljs-property">offsetHeight</span>;
  <span class="hljs-keyword">const</span> lastOffset = lastMessage.<span class="hljs-property">offset</span>;

  <span class="hljs-keyword">return</span> lastOffset + lastHeight + baseOffset;
}
</code></pre>
<p><strong>算法逻辑</strong>：</p>
<ul>
<li>获取前一个消息的高度和位置</li>
<li>使用 <code>offsetHeight</code> 获取实际渲染高度，提升布局准确性</li>
<li>计算新消息的垂直偏移量，确保消息之间有适当的间距</li>
</ul>
<h2 data-id="heading-13">关闭和销毁机制</h2>
<h3 data-id="heading-14">1. 实例移除逻辑</h3>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">close</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-keyword">const</span> index = messageInstances.<span class="hljs-title function_">findIndex</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">id</span> === id)
  <span class="hljs-keyword">if</span> (index &gt; -<span class="hljs-number">1</span>) {
    messageInstances.<span class="hljs-title function_">splice</span>(index, <span class="hljs-number">1</span>)
  }
  componentInstance?.<span class="hljs-property">exposed</span>?.<span class="hljs-property">close</span>?.()
  <span class="hljs-comment">// 重新计算后续组件的offset</span>
  <span class="hljs-keyword">let</span> preIndex = index
  messageInstances.<span class="hljs-title function_">slice</span>(index).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> {
    item.<span class="hljs-property">offset</span> = <span class="hljs-title function_">calculateOffset</span>(props.<span class="hljs-property">offset</span> || <span class="hljs-number">16</span>, messageInstances[preIndex - <span class="hljs-number">1</span>], <span class="hljs-literal">true</span>)
    item.<span class="hljs-property">el</span>.<span class="hljs-property">style</span>.<span class="hljs-property">top</span> = <span class="hljs-string">`<span class="hljs-subst">${item.offset}</span>px`</span>
    preIndex++
  })
}
</code></pre>
<p><strong>销毁细节</strong>：</p>
<ul>
<li>从实例数组中移除当前消息</li>
<li>调用组件的 <code>close</code> 方法触发动画</li>
<li>重新计算并更新后续消息的位置，避免出现跳跃</li>
<li>使用 <code>slice(index)</code> 获取所有后续实例，确保布局紧凑无空隙</li>
</ul>
<h2 data-id="heading-15">样式和动画</h2>
<h3 data-id="heading-16">过渡动画</h3>
<pre><code class="hljs language-vue" lang="vue">&lt;Transition name="fade-up"&gt;
  &lt;div class="hm-message" v-if="visible"&gt;
    &lt;!-- 消息内容 --&gt;
  &lt;/div&gt;
&lt;/Transition&gt;
</code></pre>
<p><strong>动画细节</strong>：</p>
<ul>
<li>使用 <code>fade-up</code> 过渡效果，提供平滑的显示/隐藏体验</li>
<li>CSS 类名遵循 BEM 规范</li>
<li>动画定义在全局样式中，确保一致性</li>
</ul>
<h2 data-id="heading-17">内容渲染策略</h2>
<h3 data-id="heading-18">VNode 支持</h3>
<pre><code class="hljs language-vue" lang="vue">&lt;slot&gt;
  &lt;RenderVNode :vnode="message" v-if="message" /&gt;
&lt;/slot&gt;
</code></pre>
<p><strong>实现细节</strong>：</p>
<ul>
<li>使用 <code>RenderVNode</code> 组件渲染 VNode</li>
<li>支持复杂内容的动态渲染</li>
<li>同时兼容字符串和 VNode 两种内容类型</li>
</ul>
<h2 data-id="heading-19">使用方式</h2>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 创建消息</span>
<span class="hljs-keyword">const</span> message = <span class="hljs-title class_">HmMessage</span>({
  <span class="hljs-attr">message</span>: <span class="hljs-string">'操作成功'</span>,
  <span class="hljs-attr">type</span>: <span class="hljs-string">'success'</span>,
  <span class="hljs-attr">duration</span>: <span class="hljs-number">3000</span>,
  <span class="hljs-attr">showClose</span>: <span class="hljs-literal">true</span>
})

<span class="hljs-comment">// 手动关闭</span>
message.<span class="hljs-title function_">close</span>()
</code></pre>
<p><strong>最佳实践</strong>：</p>
<ul>
<li>必须传入 <code>message</code> 和 <code>type</code> 属性</li>
<li>可通过返回的实例对象手动关闭消息</li>
</ul>
<h2 data-id="heading-20">总结</h2>
<p>这个 Message 组件的实现展现了现代 Vue 组件开发的多个最佳实践：</p>
<ol>
<li><strong>类型安全</strong>：完整的 TypeScript 类型定义，严格遵循项目规范</li>
<li><strong>实例管理</strong>：智能的全局实例管理系统，解决多实例堆叠问题</li>
<li><strong>交互体验</strong>：鼠标悬停暂停、平滑动画、可配置的关闭机制</li>
<li><strong>布局算法</strong>：基于实际渲染高度的动态垂直排列计算</li>
<li><strong>内存管理</strong>：正确的销毁和清理机制，避免内存泄漏</li>
<li><strong>内容灵活性</strong>：同时支持字符串和 VNode 内容渲染</li>
</ol>
<p>整个实现充分考虑了用户体验、性能优化和代码可维护性，是一个高质量的组件实现。它不仅解决了基础的提示需求，还通过精心设计的实例管理和布局算法，提供了专业级的用户体验，完全符合 hm-ui 组件库的设计理念和技术规范。</p>
<p>具体实现请访问 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fzhang-glitch%2Fhm-ui%2Ftree%2Fhm-message" target="_blank" title="https://github.com/zhang-glitch/hm-ui/tree/hm-message" ref="nofollow noopener noreferrer">zhang-glitch github</a></p>
<h2 data-id="heading-21">往期年度总结</h2>
<ul>
<li><a href="https://juejin.cn/post/7310895905573716005" title="https://juejin.cn/post/7310895905573716005" target="_blank">四年沿海城市，刚毕业，一年3家公司</a></li>
<li><a href="https://juejin.cn/post/7254361990076055589" title="https://juejin.cn/post/7254361990076055589" target="_blank">七月仿佛又回到了那一年（2023年中总结）</a></li>
<li><a href="https://juejin.cn/post/7188374796114067511" title="https://juejin.cn/post/7188374796114067511" target="_blank">一位初入职场前端仔的年度终结 &lt;回顾2022，展望2023&gt;</a></li>
<li><a href="https://juejin.cn/post/7046248406464856100" title="https://juejin.cn/post/7046248406464856100" target="_blank">大学两年半的前端学习</a></li>
</ul>
<h2 data-id="heading-22">往期文章</h2>
<ul>
<li><a href="https://juejin.cn/post/7392071328528891956" title="https://juejin.cn/post/7392071328528891956" target="_blank">展示大量数据节点(tree)，引发的一次性能排查</a></li>
<li><a href="https://juejin.cn/post/7368662916151296039" title="https://juejin.cn/post/7368662916151296039" target="_blank">ts装饰器的那点东西</a></li>
<li><a href="https://juejin.cn/post/7360871152037052416" title="https://juejin.cn/post/7360871152037052416" target="_blank">这是你所知道的ts类型断言和类型守卫吗？</a></li>
<li><a href="https://juejin.cn/post/7202132390549356603" title="https://juejin.cn/post/7202132390549356603" target="_blank">TypeScript官网内容解读</a></li>
<li><a href="https://juejin.cn/post/7360498535077003304" title="https://juejin.cn/post/7360498535077003304" target="_blank">经常使用ts的你，知道这些内容？</a></li>
<li><a href="https://juejin.cn/post/7351336619595939880" title="https://juejin.cn/post/7351336619595939880" target="_blank">你有了解过原生css的scope？</a></li>
<li><a href="https://juejin.cn/post/7348832432072654886" title="https://juejin.cn/post/7348832432072654886" target="_blank">现在比较常用的移动端调试你知道哪些？</a></li>
<li><a href="https://juejin.cn/post/7345352532657848371" title="https://juejin.cn/post/7345352532657848371" target="_blank">众多跨标签页通信方式，你知道哪些？（二）</a></li>
<li><a href="https://juejin.cn/post/7340109700767383604" title="https://juejin.cn/post/7340109700767383604" target="_blank">众多跨标签页通信方式，你知道哪些？</a></li>
<li><a href="https://juejin.cn/post/7330021813823750159" title="https://juejin.cn/post/7330021813823750159" target="_blank">反调试吗？如何监听devtools的打开与关闭</a></li>
<li><a href="https://juejin.cn/post/7301908233291300900" title="https://juejin.cn/post/7301908233291300900" target="_blank">因为原生，选择一家公司（前端如何防笔试作弊）</a></li>
<li><a href="https://juejin.cn/post/7298294389478506548" title="https://juejin.cn/post/7298294389478506548" target="_blank">结合开发，带你熟悉package.json与tsconfig.json配置</a></li>
<li><a href="https://juejin.cn/post/7294541220440752165" title="https://juejin.cn/post/7294541220440752165" target="_blank">如何优雅的在项目中使用echarts</a></li>
<li><a href="https://juejin.cn/post/7293797226933764134" title="https://juejin.cn/post/7293797226933764134" target="_blank">如何优雅的做项目国际化</a></li>
<li><a href="https://juejin.cn/post/7292036126269063178" title="https://juejin.cn/post/7292036126269063178" target="_blank">近三个月的排错，原来的憧憬消失喽</a></li>
<li><a href="https://juejin.cn/post/7291955076100620342" title="https://juejin.cn/post/7291955076100620342" target="_blank">带你从0开始了解vue3核心（运行时）</a></li>
<li><a href="https://juejin.cn/post/7275550540620365878" title="https://juejin.cn/post/7275550540620365878" target="_blank">带你从0开始了解vue3核心（computed, watch）</a></li>
<li><a href="https://juejin.cn/post/7274072378606174263" title="https://juejin.cn/post/7274072378606174263" target="_blank">带你从0开始了解vue3核心（响应式）</a></li>
<li><a href="https://juejin.cn/post/7269225865619816483" title="https://juejin.cn/post/7269225865619816483" target="_blank">3w+字的后台管理通用功能解决方案送给你</a></li>
<li><a href="https://juejin.cn/post/7251878440327512124" title="https://juejin.cn/post/7251878440327512124" target="_blank">入职之前，狂补技术，4w字的前端技术解决方案送给你（vue3 + vite ）</a></li>
</ul>
<h2 data-id="heading-23">专栏文章</h2>
<ul>
<li><a href="https://juejin.cn/column/7036633477013307423" title="https://juejin.cn/column/7036633477013307423" target="_blank">重学vue及其生态</a></li>
<li><a href="https://juejin.cn/column/7085181986347679751" title="https://juejin.cn/column/7085181986347679751" target="_blank">前端面试</a></li>
<li><a href="https://juejin.cn/column/7215977393697587259" title="https://juejin.cn/column/7215977393697587259" target="_blank">前端工程化</a></li>
<li><a href="https://juejin.cn/column/7171775932809052174" title="https://juejin.cn/column/7171775932809052174" target="_blank">amis 低代码实战</a></li>
<li><a href="https://juejin.cn/column/7090398104549064718" title="https://juejin.cn/column/7090398104549064718" target="_blank">协议与安全</a></li>
<li><a href="https://juejin.cn/column/7073656450874081316" title="https://juejin.cn/column/7073656450874081316" target="_blank">重学react</a></li>
<li><a href="https://juejin.cn/column/7036633282204663822" title="https://juejin.cn/column/7036633282204663822" target="_blank">重学nodejs</a></li>
<li><a href="https://juejin.cn/column/7133877511707951111" title="https://juejin.cn/column/7133877511707951111" target="_blank">工作总结</a></li>
<li><a href="https://juejin.cn/column/7366457260414697509" title="https://juejin.cn/column/7366457260414697509" target="_blank">Typescript研究</a></li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[AI Agent案例实践：智能体开发模式详解之三（基于QwenAgent框架）]]></title>    <link>https://juejin.cn/post/7591506455973462070</link>    <guid>https://juejin.cn/post/7591506455973462070</guid>    <pubDate>2026-01-05T10:39:58.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7591506455973462070" data-draft-id="7591510742648553515" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="AI Agent案例实践：智能体开发模式详解之三（基于QwenAgent框架）"/> <meta itemprop="keywords" content="后端,Python,人工智能"/> <meta itemprop="datePublished" content="2026-01-05T10:39:58.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="木昆子"/> <meta itemprop="url" content="https://juejin.cn/user/825103640698564"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            AI Agent案例实践：智能体开发模式详解之三（基于QwenAgent框架）
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/825103640698564/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    木昆子
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-05T10:39:58.000Z" title="Mon Jan 05 2026 10:39:58 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-05
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    9
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读19分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>书接上文：<a href="https://juejin.cn/user/825103640698564/posts" target="_blank" title="https://juejin.cn/user/825103640698564/posts">AI Agent案例实践：三种智能体开发模式详解之二（基于LangChain框架）</a></p>
<h2 data-id="heading-0">四、开发实践（基于QwenAgent框架）</h2>
<p>前文中，我们使用LangChain框架实现了我们的智能体。下面让我们使用Qwen-Agent实现一版ReAct，体验下流程，具体的业务场景中需要根据需求，调研后决定具体使用哪种方式。</p>
<h3 data-id="heading-1">4.1. 什么是QwenAgent？</h3>
<ul>
<li>LangChain：一个开源框架，专为构建与大语言模型（LLMs）相关的应用设计，通过集成多个API、数据源和工具，助力开发者高效构建智能应用。它更像是AI应用开发的“行业标杆”和“基础设施”，提供了模块化设计（Chains、Agents、Memory）、多模型兼容（OpenAI、HuggingFace等）以及强大的工具调用能力。</li>
<li>Qwen-Agent：由阿里巴巴团队优化的Agent框架，特别针对中文场景和通义千问（Qwen）系列模型进行了深度优化。它更侧重于具体模型的落地应用，尤其是在处理长文本、复杂推理和多轮对话方面表现出色。</li>
</ul>
<p>Qwen-Agent 开发框架支持 ReAct 范式</p>
<p>Qwen-Agent 提供了 ReActChat 类来支持 ReAct 推理范式。这允许智能体像人类一样进行思考（Reasoning）、行动（Taking Action）（例如调用工具）和观察（Observing） 结果，并循环此过程直至任务完成 。</p>
<ul>
<li>工作原理：ReActChat 类继承自 FnCallAgent 类，其内部通过 while 循环来管理多轮的工具调用和推理过程 。开发者通常不需要干预这个循环的具体次数。</li>
<li>如何使用：你只需要定义好必要的工具（Tools），并将它们分配给智能体。智能体会根据你的查询和系统指令，自行决定是否需要以及如何通过 ReAct 循环来调用这些工具。</li>
</ul>
<p>关于迭代次数</p>
<p>在 Qwen-Agent 的上下文中，我们通常说的“迭代”指的是 ReAct 循环中模型调用工具并进行推理的轮次。</p>
<ol>
<li>1. 自动控制：这个迭代次数通常不需要开发者手动配置。它主要由底层的大语言模型（LLM）根据当前任务的复杂性、可用工具以及历史上下文来动态决定。模型会自主判断何时拥有了足够的信息来给出最终答案，从而终止循环 。</li>
<li>2. 与训练迭代的区别：需要注意的是，这不同于模型训练阶段的超参“迭代次数”（iterations/epochs）。训练迭代指的是整个训练数据集被完整地用于更新模型参数的次数，这在模型微调时需要配置 。但在 Qwen-Agent 框架中，你通常直接使用预训练好的模型，因此不涉及对此类训练迭代次数的配置。</li>
</ol>
<p>实用建议</p>
<ul>
<li>控制循环：虽然不需要直接设置迭代次数，但你可以通过优化提示词（Prompt）、工具描述的清晰度和准确性，来引导模型更高效地进行推理和工具调用，间接影响循环轮次</li>
</ul>
<p>接下来我们直接使用QwenAgent框架实现ReAct智能体模式。</p>
<h3 data-id="heading-2">4.2.代码实践</h3>
<p>具体开发实现如下(agent_service_qwen.py)：</p>
<pre><code class="hljs language-python" lang="python">mport sys  
<span class="hljs-keyword">import</span> json  
<span class="hljs-keyword">from</span> qwen_agent.agents <span class="hljs-keyword">import</span> Assistant  
<span class="hljs-keyword">from</span> qwen_agent.tools <span class="hljs-keyword">import</span> BaseTool  
<span class="hljs-keyword">from</span> api_service <span class="hljs-keyword">import</span> QueryService, SemanticServce, AnalysisService  
  
<span class="hljs-comment"># 初始化服务  </span>
queryService = QueryService()  
semanticService = SemanticServce()  
analysisService = AnalysisService()  
  
<span class="hljs-comment"># 自定义工具类  </span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MatchMetadataTool</span>(<span class="hljs-title class_ inherited__">BaseTool</span>):  
    name = <span class="hljs-string">'match_metadata'</span>  
    description = <span class="hljs-string">'根据输入文本语义匹配表结构，每次返回一个最相关的表结构。对于需要多表查询的问题，需要多次调用此工具。'</span>  
  
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">call</span>(<span class="hljs-params">self, params, **kwargs</span>) -&gt; <span class="hljs-built_in">str</span>:  
        table = semanticService.hybrid_search(params, <span class="hljs-number">1</span>)  
        <span class="hljs-keyword">return</span> <span class="hljs-string">f"<span class="hljs-subst">{[t[<span class="hljs-string">'table_info'</span>] <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> table]}</span>"</span>  
  
  
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ExecuteSQLTool</span>(<span class="hljs-title class_ inherited__">BaseTool</span>):  
    name = <span class="hljs-string">'execute_sql'</span>  
    description = <span class="hljs-string">'执行SQL查询并返回结果。输入应为标准SQL语句。注意：可能需要执行多个SQL查询来获取不同表中的数据。'</span>  
  
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">call</span>(<span class="hljs-params">self, params, **kwargs</span>) -&gt; <span class="hljs-built_in">str</span>:  
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(params, <span class="hljs-built_in">str</span>):  
            jsonObj = json.loads(params)  
            <span class="hljs-keyword">if</span> <span class="hljs-string">'sql'</span><span class="hljs-keyword">in</span> jsonObj:  
                params = jsonObj[<span class="hljs-string">'sql'</span>]  
            <span class="hljs-keyword">if</span> <span class="hljs-string">'query'</span><span class="hljs-keyword">in</span> jsonObj:  
                params = jsonObj[<span class="hljs-string">'query'</span>]  
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(params, <span class="hljs-built_in">dict</span>):  
            <span class="hljs-keyword">if</span> <span class="hljs-string">'sql'</span><span class="hljs-keyword">in</span> params:  
                params = params[<span class="hljs-string">'sql'</span>]  
            <span class="hljs-keyword">if</span> <span class="hljs-string">'query'</span><span class="hljs-keyword">in</span> params:  
                params = params[<span class="hljs-string">'query'</span>]  
        <span class="hljs-keyword">if</span> params.endswith(<span class="hljs-string">';'</span>):  
            params = params[:-<span class="hljs-number">1</span>]  
        <span class="hljs-keyword">return</span> json.dumps(queryService.query_with_column(params))  
  
<span class="hljs-comment"># 创建Agent实例  </span>
agent = Assistant(  
    name=<span class="hljs-string">'ai_agent_assistant'</span>,  
    llm={  
        <span class="hljs-string">'model'</span>: <span class="hljs-string">'qwen3:32b'</span>,  
        <span class="hljs-string">'model_server'</span>: <span class="hljs-string">'http://localhost:11434/v1'</span>,  
    },  
    system_message=<span class="hljs-string">"""  
        你是一个数据分析助手，负责帮助用户查询数据库信息。  
        请特别注意：用户的问题可能需要从多个表中查询数据。  
        1. 首先确定需要查询哪些数据  
        2. 使用match_metadata工具分别匹配包含这些数据的表结构  
        3. 对每个表生成相应的SQL查询语句  
        4. 执行查询并汇总结果  
        5. 最后计算并给出答案  
      
        请确保逐步执行，不要跳过任何步骤。  
    """</span>,  
    function_list=[MatchMetadataTool(), ExecuteSQLTool()],  
)  
  
<span class="hljs-keyword">def</span> <span class="hljs-title function_">chat</span>(<span class="hljs-params">user_query</span>):  
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"执行方法chat"</span>)  
    <span class="hljs-keyword">try</span>:  
        <span class="hljs-comment"># 运行Agent  </span>
        messages = [{<span class="hljs-string">'role'</span>: <span class="hljs-string">'user'</span>, <span class="hljs-string">'content'</span>: user_query}]  
        response_generator = agent.run(messages=messages)  
        <span class="hljs-comment"># 处理生成器响应  </span>
        full_response = <span class="hljs-string">''</span>  
        start = <span class="hljs-number">0</span>  
        end = <span class="hljs-number">0</span>  
        <span class="hljs-keyword">for</span> response <span class="hljs-keyword">in</span> response_generator:  
            <span class="hljs-comment"># 检查响应类型并适当处理  </span>
            <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(response, <span class="hljs-built_in">list</span>):  
                <span class="hljs-comment"># 如果是列表，提取内容  </span>
                <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> response:  
                    <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(item, <span class="hljs-built_in">dict</span>) <span class="hljs-keyword">and</span><span class="hljs-string">'content'</span><span class="hljs-keyword">in</span> item:  
                        full_response = item[<span class="hljs-string">'content'</span>]  
                        end = full_response.__len__()  
                    <span class="hljs-keyword">elif</span> <span class="hljs-built_in">isinstance</span>(item, <span class="hljs-built_in">str</span>):  
                        full_response = item  
                        end = full_response.__len__()  
            <span class="hljs-keyword">elif</span> <span class="hljs-built_in">isinstance</span>(response, <span class="hljs-built_in">dict</span>) <span class="hljs-keyword">and</span><span class="hljs-string">'content'</span><span class="hljs-keyword">in</span> response:  
                full_response = response[<span class="hljs-string">'content'</span>]  
                end = full_response.__len__()  
            <span class="hljs-keyword">elif</span> <span class="hljs-built_in">isinstance</span>(response, <span class="hljs-built_in">str</span>):  
                full_response = response  
                end = full_response.__len__()  
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"<span class="hljs-subst">{full_response[start:end]}</span>"</span>, end=<span class="hljs-string">""</span>)  
            start = end  
  
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"最终结果: <span class="hljs-subst">{full_response}</span>"</span>)  
        <span class="hljs-keyword">return</span> full_response  
    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:  
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"执行过程中出错: <span class="hljs-subst">{<span class="hljs-built_in">str</span>(e)}</span>"</span>)  
        <span class="hljs-comment"># 这里可以添加重试或更详细的错误处理逻辑  </span>
        <span class="hljs-keyword">return</span><span class="hljs-string">f"错误: <span class="hljs-subst">{<span class="hljs-built_in">str</span>(e)}</span>"</span>  
  
  
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:  
    args = sys.argv[<span class="hljs-number">1</span>:]  
  
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> args:  
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"请提供参数：init或者chat+user_query"</span>)  
    <span class="hljs-keyword">elif</span> args[<span class="hljs-number">0</span>] == <span class="hljs-string">"init"</span>:  
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"开始执行方法init"</span>)  
        <span class="hljs-comment"># 这里可以添加初始化逻辑  </span>
    <span class="hljs-keyword">elif</span> args[<span class="hljs-number">0</span>] == <span class="hljs-string">"chat"</span>:  
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"user_query=<span class="hljs-subst">{args[<span class="hljs-number">1</span>]}</span>"</span>)  
        chat(args[<span class="hljs-number">1</span>])  
    <span class="hljs-keyword">else</span>:  
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"未知参数: <span class="hljs-subst">{args[<span class="hljs-number">0</span>]}</span>"</span>)
</code></pre>
<p>依旧是和LangChain实现的ReAct同样的工具和提示词，只是这次我们使用QwenAgent框架实现。</p>
<h3 data-id="heading-3">4.3.测试结果</h3>
<p>多数据源RAG检索问题：2016年考生人数和录取人数分别有多少？</p>
<p>运行python agent_service_qwen.py chat '2016年考生人数和录取人数分别有多少？',输出如下：</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-operator">&lt;</span>think<span class="hljs-operator">&gt;</span>
好的，用户问的是<span class="hljs-number">2016</span>年的考生人数和录取人数<span class="hljs-operator">。</span>首先我需要确定这两个数据分别存储在哪个表里<span class="hljs-operator">。</span>可能有一个表记录考生信息，另一个表记录录取情况<span class="hljs-operator">。</span>我需要先调用match_metadata工具来找到相关的表结构<span class="hljs-operator">。</span>

先查考生人数，输入“考生人数”看看匹配哪个表<span class="hljs-operator">。</span>假设返回的是enrollment表，里面有year和candidates字段<span class="hljs-operator">。</span>然后查录取人数，输入“录取人数”，可能对应admissions表，里面有year和admitted字段<span class="hljs-operator">。</span>接下来需要分别对这两个表执行<span class="hljs-type">SQL查询，筛选出year为2016年的数据</span><span class="hljs-operator">。</span>

执行第一个<span class="hljs-type">SQL：SELECT</span> candidates <span class="hljs-type">FROM</span> enrollment <span class="hljs-type">WHERE</span> year <span class="hljs-operator">=</span> <span class="hljs-number">2016</span>; 得到考生人数<span class="hljs-operator">。</span>再执行第二个<span class="hljs-type">SQL：SELECT</span> admitted <span class="hljs-type">FROM</span> admissions <span class="hljs-type">WHERE</span> year <span class="hljs-operator">=</span> <span class="hljs-number">2016</span>; 得到录取人数<span class="hljs-operator">。</span>然后把结果汇总，给出两个数值<span class="hljs-operator">。</span>需要确保两个表的年份字段都是<span class="hljs-number">2016</span>，并且字段名正确<span class="hljs-operator">。</span>如果有多个表可能涉及，可能需要进一步确认，但这里假设两次匹配都正确<span class="hljs-operator">。</span>最后计算结果并呈现给用户<span class="hljs-operator">。</span>
<span class="hljs-operator">&lt;/</span>think<span class="hljs-operator">&gt;</span>

调用大模型llama2向量化：{<span class="hljs-string">"query"</span>:<span class="hljs-string">"考生人数"</span>}
自然语言混合检索字段成功，匹配到的元数据信息：['{<span class="hljs-string">"表名"</span>:<span class="hljs-string">"college_entrance_examination"</span>,<span class="hljs-string">"表备注"</span>:<span class="hljs-string">"考生人数与复读人数信息表，包含字段：高考年份(主键)、考生人数(万人)、复读人数(万人)，考生人数是指参加高考的学生的数量，复读人数是指参加高考的复读学生的数量"</span>,<span class="hljs-string">"字段列表"</span>:[{<span class="hljs-string">"字段名"</span>:<span class="hljs-string">"examination_year"</span>,<span class="hljs-string">"字段类型"</span>:<span class="hljs-string">"int"</span>,<span class="hljs-string">"字段备注"</span>:<span class="hljs-string">"高考年份"</span>},{<span class="hljs-string">"字段名"</span>:<span class="hljs-string">"candidates_count"</span>,<span class="hljs-string">"字段类型"</span>:<span class="hljs-string">"decimal(10,2)"</span>,<span class="hljs-string">"字段备注"</span>:<span class="hljs-string">"考生人数(万人)"</span>},{<span class="hljs-string">"字段名"</span>:<span class="hljs-string">"retake_count"</span>,<span class="hljs-string">"字段类型"</span>:<span class="hljs-string">"decimal(10,2)"</span>,<span class="hljs-string">"字段备注"</span>:<span class="hljs-string">"复读人数(万人)"</span>}]}']
好的，用户的问题是关于<span class="hljs-number">2016</span>年的考生人数和录取人数<span class="hljs-operator">。</span>首先，我需要确认这两个数据分别存储在哪些表中<span class="hljs-operator">。</span>之前用户提到过“考生人数”，我调用match_metadata工具后得到了一个表college_entrance_examination，里面包含考生人数和复读人数，但没有录取人数<span class="hljs-operator">。</span>这说明录取人数可能在另一个表里<span class="hljs-operator">。</span>

接下来，我需要再次调用match_metadata工具，这次查询“录取人数”<span class="hljs-operator">。</span>输入关键词后，应该会有对应的表结构返回，比如可能有一个表叫college_admission，包含录取人数字段<span class="hljs-operator">。</span>假设返回的表结构中有字段admission_count，那么接下来需要分别对这两个表生成<span class="hljs-type">SQL查询语句</span><span class="hljs-operator">。</span>

对于college_entrance_examination表，<span class="hljs-type">SQL语句会是SELECT</span> candidates_count <span class="hljs-type">FROM</span> college_entrance_examination <span class="hljs-type">WHERE</span> examination_year <span class="hljs-operator">=</span> <span class="hljs-number">2016</span>; 这样可以得到<span class="hljs-number">2016</span>年的考生人数<span class="hljs-operator">。</span>然后，针对录取人数所在的表，假设是college_admission，<span class="hljs-type">SQL语句可能是SELECT</span> admission_count <span class="hljs-type">FROM</span> college_admission <span class="hljs-type">WHERE</span> admission_year <span class="hljs-operator">=</span> <span class="hljs-number">2016</span>; 执行这两个查询后，将结果汇总，就能得到用户需要的两个数据<span class="hljs-operator">。</span>

需要注意的是，确保两个表的年份字段名称和类型正确，避免因为字段名不同或数据类型不匹配导致查询错误<span class="hljs-operator">。</span>此外，如果存在多个相关表，需要确认哪一个包含正确的数据，可能需要进一步的信息验证<span class="hljs-operator">。</span>最后，将查询结果整理后，用清晰的方式呈现给用户，确保数据的准确性和可读性<span class="hljs-operator">。</span>
<span class="hljs-operator">&lt;/</span>think<span class="hljs-operator">&gt;</span>

调用大模型llama2向量化：{<span class="hljs-string">"query"</span>:<span class="hljs-string">"录取人数"</span>}
自然语言混合检索字段成功，匹配到的元数据信息：['{<span class="hljs-string">"表名"</span>:<span class="hljs-string">"college_entrance_admission"</span>,<span class="hljs-string">"表备注"</span>:<span class="hljs-string">"录取人数与普通高校数信息表，包含字段：录取年份(主键)、录取人数(万人)、招生高校数、本科录取人数(万人)、专科录取人数(万人)，录取人数是指录取或者招收、招录的学生的数量"</span>,<span class="hljs-string">"字段列表"</span>:[{<span class="hljs-string">"字段名"</span>:<span class="hljs-string">"admission_year"</span>,<span class="hljs-string">"字段类型"</span>:<span class="hljs-string">"int"</span>,<span class="hljs-string">"字段备注"</span>:<span class="hljs-string">"录取年份"</span>},{<span class="hljs-string">"字段名"</span>:<span class="hljs-string">"admission_count"</span>,<span class="hljs-string">"字段类型"</span>:<span class="hljs-string">"decimal(10,2)"</span>,<span class="hljs-string">"字段备注"</span>:<span class="hljs-string">"录取人数(万人)"</span>},{<span class="hljs-string">"字段名"</span>:<span class="hljs-string">"university_count"</span>,<span class="hljs-string">"字段类型"</span>:<span class="hljs-string">"int"</span>,<span class="hljs-string">"字段备注"</span>:<span class="hljs-string">"招生高校数"</span>},{<span class="hljs-string">"字段名"</span>:<span class="hljs-string">"undergraduate_admission_count"</span>,<span class="hljs-string">"字段类型"</span>:<span class="hljs-string">"decimal(10,2)"</span>,<span class="hljs-string">"字段备注"</span>:<span class="hljs-string">"本科录取人数(万人)"</span>},{<span class="hljs-string">"字段名"</span>:<span class="hljs-string">"specialty_admission_count"</span>,<span class="hljs-string">"字段类型"</span>:<span class="hljs-string">"decimal(10,2)"</span>,<span class="hljs-string">"字段备注"</span>:<span class="hljs-string">"专科录取人数(万人)"</span>}]}']
好，用户需要知道<span class="hljs-number">2016</span>年的考生人数和录取人数<span class="hljs-operator">。</span>首先，我需要确定这两个数据分别存储在哪个表里<span class="hljs-operator">。</span>

先处理考生人数<span class="hljs-operator">。</span>用户的问题中提到“考生人数”，之前调用match_metadata工具时已经找到了对应的表college_entrance_examination<span class="hljs-operator">。</span>这个表的字段有examination_year<span class="hljs-operator">、</span>candidates_count和retake_count<span class="hljs-operator">。</span>所以考生人数应该从这个表中查询，条件是examination_year等于<span class="hljs-number">2016</span><span class="hljs-operator">。</span>

然后是录取人数<span class="hljs-operator">。</span>用户的问题里提到“录取人数”，通过之前的工具调用，发现了表college_entrance_admission<span class="hljs-operator">。</span>这个表里有admission_year和admission_count，所以录取人数需要从这里查询，同样条件是admission_year等于<span class="hljs-number">2016</span><span class="hljs-operator">。</span>

接下来需要生成对应的<span class="hljs-type">SQL查询语句</span><span class="hljs-operator">。</span>对于考生人数，<span class="hljs-type">SQL应该是SELECT</span> candidates_count <span class="hljs-type">FROM</span> college_entrance_examination <span class="hljs-type">WHERE</span> examination_year <span class="hljs-operator">=</span> <span class="hljs-number">2016</span><span class="hljs-operator">。</span>而录取人数的<span class="hljs-type">SQL应该是SELECT</span> admission_count <span class="hljs-type">FROM</span> college_entrance_admission <span class="hljs-type">WHERE</span> admission_year <span class="hljs-operator">=</span> <span class="hljs-number">2016</span><span class="hljs-operator">。</span>

执行这两个查询后，会得到两个结果，可能都是小数（因为字段类型是decimal）<span class="hljs-operator">。</span>然后需要将这两个数字组合起来，用万人单位，并且四舍五入到合适的小数位数，可能保留两位小数<span class="hljs-operator">。</span>

比如，如果查询结果分别是<span class="hljs-number">872.21</span>万人和<span class="hljs-number">749.61</span>万人，那么最终答案就是考生人数<span class="hljs-number">872.21</span>万人，录取人数<span class="hljs-number">749.61</span>万人<span class="hljs-operator">。</span>需要确认年份是否对应，确保两个表的年份字段都正确匹配<span class="hljs-number">2016</span>年<span class="hljs-operator">。</span>

最后，将结果用中文清晰地呈现给用户，说明分别的数据并注明单位<span class="hljs-operator">。</span>
<span class="hljs-operator">&lt;/</span>think<span class="hljs-operator">&gt;</span>

执行<span class="hljs-type">SQL：SELECT</span> candidates_count <span class="hljs-type">FROM</span> college_entrance_examination <span class="hljs-type">WHERE</span> examination_year <span class="hljs-operator">=</span> <span class="hljs-number">2016</span>
[{<span class="hljs-string">"candidates_count"</span>:<span class="hljs-number">940.0</span>}]
好的，我需要回答用户关于<span class="hljs-number">2016</span>年考生人数和录取人数的问题<span class="hljs-operator">。</span>首先，用户已经通过两次match_metadata调用，分别获取了考生人数所在的表college_entrance_examination和录取人数所在的表college_entrance_admission<span class="hljs-operator">。</span>

接下来，用户执行了第一个<span class="hljs-type">SQL查询，从college_entrance_examination表中获取了2016年的考生人数，结果是940</span>.<span class="hljs-number">0</span>万人<span class="hljs-operator">。</span>现在需要处理录取人数的部分<span class="hljs-operator">。</span>根据第二个match_metadata的结果，录取人数在college_entrance_admission表的admission_count字段中，且年份字段是admission_year<span class="hljs-operator">。</span>

因此，我需要构造另一个<span class="hljs-type">SQL查询，从college_entrance_admission表中选择admission_count，其中admission_year等于2016</span><span class="hljs-operator">。</span>执行这个查询后，将得到录取人数的数据<span class="hljs-operator">。</span>最后，把两个结果合并，给出用户需要的答案<span class="hljs-operator">。</span>
<span class="hljs-operator">&lt;/</span>think<span class="hljs-operator">&gt;</span>

执行<span class="hljs-type">SQL：SELECT</span> admission_count <span class="hljs-type">FROM</span> college_entrance_admission <span class="hljs-type">WHERE</span> admission_year <span class="hljs-operator">=</span> <span class="hljs-number">2016</span>
[{<span class="hljs-string">"admission_count"</span>:<span class="hljs-number">772.0</span>}]
好的，用户问的是<span class="hljs-number">2016</span>年的考生人数和录取人数分别是多少<span class="hljs-operator">。</span>我需要先找到这两个数据分别存放在哪个表里<span class="hljs-operator">。</span>

首先，用户的问题涉及到“考生人数”，所以我调用了match_metadata工具，参数是“考生人数”<span class="hljs-operator">。</span>返回的结果是college_entrance_examination表，里面有考生人数的信息，字段是candidates_count，单位是万人<span class="hljs-operator">。</span>接着，用户又问到“录取人数”，于是再次调用match_metadata工具，参数是“录取人数”，得到的是college_entrance_admission表，对应的字段是admission_count，同样单位是万人<span class="hljs-operator">。</span>

接下来，我需要从这两个表中查询<span class="hljs-number">2016</span>年的数据<span class="hljs-operator">。</span>先执行第一个<span class="hljs-type">SQL查询，从college_entrance_examination表中选出examination_year等于2016年的考生人数，结果得到940</span>.<span class="hljs-number">0</span>万人<span class="hljs-operator">。</span>然后执行第二个<span class="hljs-type">SQL查询，从college_entrance_admission表中选出admission_year等于2016年的录取人数，结果是772</span>.<span class="hljs-number">0</span>万人<span class="hljs-operator">。</span>

确认两个结果都是<span class="hljs-number">2016</span>年的数据后，将这两个数值汇总，得到最终答案：<span class="hljs-number">2016</span>年考生人数是<span class="hljs-number">940</span>万人，录取人数是<span class="hljs-number">772</span>万人<span class="hljs-operator">。</span>需要确保单位正确，并且数据没有错误<span class="hljs-operator">。</span>这里的数据看起来合理，没有异常值，所以可以确定答案正确<span class="hljs-operator">。</span>
<span class="hljs-operator">&lt;/</span>think<span class="hljs-operator">&gt;</span>

<span class="hljs-number">2016</span>年的考生人数和录取人数分别为：

<span class="hljs-operator">-</span> <span class="hljs-operator">**</span>考生人数<span class="hljs-operator">**</span>：<span class="hljs-number">940</span>万人  
<span class="hljs-operator">-</span> <span class="hljs-operator">**</span>录取人数<span class="hljs-operator">**</span>：<span class="hljs-number">772</span>万人  

数据来源：
<span class="hljs-operator">-</span> 考生人数来自<span class="hljs-operator">《</span>考生人数与复读人数信息表<span class="hljs-operator">》</span>（`college_entrance_examination`）的 `candidates_count` 字段
<span class="hljs-operator">-</span> 录取人数来自<span class="hljs-operator">《</span>录取人数与普通高校数信息表<span class="hljs-operator">》</span>（`college_entrance_admission`）的 `admission_count` 字段最终结果: <span class="hljs-operator">&lt;</span>think<span class="hljs-operator">&gt;</span>
好的，用户问的是<span class="hljs-number">2016</span>年的考生人数和录取人数分别是多少<span class="hljs-operator">。</span>我需要先找到这两个数据分别存放在哪个表里<span class="hljs-operator">。</span>

首先，用户的问题涉及到“考生人数”，所以我调用了match_metadata工具，参数是“考生人数”<span class="hljs-operator">。</span>返回的结果是college_entrance_examination表，里面有考生人数的信息，字段是candidates_count，单位是万人<span class="hljs-operator">。</span>接着，用户又问到“录取人数”，于是再次调用match_metadata工具，参数是“录取人数”，得到的是college_entrance_admission表，对应的字段是admission_count，同样单位是万人<span class="hljs-operator">。</span>

接下来，我需要从这两个表中查询<span class="hljs-number">2016</span>年的数据<span class="hljs-operator">。</span>先执行第一个<span class="hljs-type">SQL查询，从college_entrance_examination表中选出examination_year等于2016年的考生人数，结果得到940</span>.<span class="hljs-number">0</span>万人<span class="hljs-operator">。</span>然后执行第二个<span class="hljs-type">SQL查询，从college_entrance_admission表中选出admission_year等于2016年的录取人数，结果是772</span>.<span class="hljs-number">0</span>万人<span class="hljs-operator">。</span>

确认两个结果都是<span class="hljs-number">2016</span>年的数据后，将这两个数值汇总，得到最终答案：<span class="hljs-number">2016</span>年考生人数是<span class="hljs-number">940</span>万人，录取人数是<span class="hljs-number">772</span>万人<span class="hljs-operator">。</span>需要确保单位正确，并且数据没有错误<span class="hljs-operator">。</span>这里的数据看起来合理，没有异常值，所以可以确定答案正确<span class="hljs-operator">。</span>
<span class="hljs-operator">&lt;/</span>think<span class="hljs-operator">&gt;</span>

<span class="hljs-number">2016</span>年的考生人数和录取人数分别为：

<span class="hljs-operator">-</span> <span class="hljs-operator">**</span>考生人数<span class="hljs-operator">**</span>：<span class="hljs-number">940</span>万人  
<span class="hljs-operator">-</span> <span class="hljs-operator">**</span>录取人数<span class="hljs-operator">**</span>：<span class="hljs-number">772</span>万人  

数据来源：
<span class="hljs-operator">-</span> 考生人数来自<span class="hljs-operator">《</span>考生人数与复读人数信息表<span class="hljs-operator">》</span>（`college_entrance_examination`）的 `candidates_count` 字段
<span class="hljs-operator">-</span> 录取人数来自<span class="hljs-operator">《</span>录取人数与普通高校数信息表<span class="hljs-operator">》</span>（`college_entrance_admission`）的 `admission_count` 字段
</code></pre>
<p>QwenAgent框架也是和第三章的LangChain框架ReAct流程一样，通过推理、观察、思考、行动完成了多数据源复杂问题的回答。</p>
<p>把复杂问题拆分为简单问题、然后利用我们制定好的流程查出数据，汇总输出！</p>
<h2 data-id="heading-4">五、展望</h2>
<p>本文AI Agent的实践过程中，我们了解了es8作为外接知识库检索的基本使用方式(RAG)，语义检索、数据查询、大模型分析的基本流程。了解了LangChain和QwenAgent框架的使用。</p>
<p>进一步实践方向：</p>
<ul>
<li>场景优化：加入部分心仪的高校数据，每个高校的每个专业在每个省份的招生情况，丰富Agent知识，提供更多更好的服务！</li>
<li>检索优化：本文只使用了ES8内部向量类型支持的基本KNN检索，利用余弦相似度计算+分词计算，混合得分后返回，后续可以尝试其他高级检索方式。</li>
<li>ReAct优化：本文我们的ReAct实践，只使用了LangChain框架的AgentType.STRUCTURED_CHAT_ZERO_SHOT_REACT_DESCRIPTION模式，可以实践其他模式效果！</li>
<li>流程优化：本文我们的ReAct工具只有语义检索与数据查询两个，没有涉及复杂计算，加入高校信息需要做分段同环比计算，需要加入新的流程，使用新的工具！流程比较简单，作为学习使用，场景丰富后可以进一步优化流程！</li>
<li>其他开发模式：本文所列三种开发实践都是基于代码的模式，还可以尝试用Dify、Coze Studio这类低代码工具来配置智能体。</li>
</ul>
<h2 data-id="heading-5">六、附录</h2>
<h3 data-id="heading-6">6.1. 开发环境</h3>
<p>核心工具与运行时 (Core Tools &amp; Runtimes)</p>






























<table><thead><tr><th>工具名称</th><th>推荐版本</th><th>说明</th></tr></thead><tbody><tr><td>操作系统</td><td>macOS 15.6.1</td><td>MacBook pro m1 max 32GB</td></tr><tr><td>Docker Desktop</td><td>28.3.2</td><td>本地Docker环境</td></tr><tr><td>Python</td><td>3.9</td><td>python实现我们的AI Agent</td></tr><tr><td>IDE/编辑器</td><td>VS Code / PyCharm</td><td>开发工具</td></tr></tbody></table>
<p>项目依赖与服务 (Project Dependencies &amp; Services)</p>





























<table><thead><tr><th>服务名称</th><th>版本</th><th>端口</th><th>说明</th></tr></thead><tbody><tr><td>Ollama</td><td>0.11.6</td><td>11434</td><td>大模型运行环境，运行deepseek-r1:32b、qwen3:32b、llama2</td></tr><tr><td>MySQL</td><td>8.4.6</td><td>3306</td><td>本地docker部署，'业务知识库'</td></tr><tr><td>ElasticSearch</td><td>8.19.0</td><td>9200</td><td>本地docker部署，支持向量存储、检索</td></tr></tbody></table>
<h3 data-id="heading-7">6.2. ES8检索</h3>
<p>为什么使用ES8？</p>
<p>ElasticSearch是一个开源的分布式搜索和分析引擎，主要用于海量文本检索与分析，使用 JSON 格式存储数据，能通过简单的 REST API 进行交互，便于集成。</p>
<p>7.x之前的版本支持text(全文检索字段，支持分词)、keyword(精确值字段，适合过滤、聚合)、numeric、binary、date等传统的基本的数据类型字段。</p>
<p>7.x之后引入dense_vector(向量类型，存储浮点数密集向量如BERT、Word2Vec、Sentence Transformers 生成的向量，维度dims必须提前定义声明，无法修改)。</p>
<p>从8.16版本之后，新增对位类型（bit，0或1）和字节类型（byte，以字节）向量的支持，通过element_type参数指定。默认float(4字节32位浮点数)。数据量较大时可指定byte或bit，牺牲精度以节省存储空间。</p>
<p>支持的量化类型：</p>
<p>7.3-7.4：新增多种向量相似度计算方式（如L2范数即欧几里得距离、点积、余弦相似度、最大内积（适用于负值向量）等）。</p>
<p>8.0：正式支持近似KNN搜索API（基于HNSW算法），显著提升大规模向量检索效率，存储成本大幅下降的同时保持较高的检索准确率。</p>
<p>8.16：扩展支持位(bit)和字节(byte)向量类型，优化存储和计算效率</p>
<p>示例：</p>
<pre><code class="hljs language-ruby" lang="ruby">{
<span class="hljs-string">"mappings"</span><span class="hljs-symbol">:</span>{
    <span class="hljs-string">"properties"</span><span class="hljs-symbol">:</span>{
      <span class="hljs-string">"my_vector"</span><span class="hljs-symbol">:</span>{<span class="hljs-regexp">//</span> 字段名称
        <span class="hljs-string">"type"</span><span class="hljs-symbol">:<span class="hljs-string">"dense_vector"</span></span>,
        <span class="hljs-string">"dims"</span><span class="hljs-symbol">:</span><span class="hljs-number">768</span>,<span class="hljs-regexp">//</span> 和向量化使用的大模型的维度保持一致，不一致插入与检索存在异常
        <span class="hljs-string">"index"</span><span class="hljs-symbol">:true</span>,<span class="hljs-regexp">//</span> <span class="hljs-literal">true</span>时支持<span class="hljs-variable constant_">KNN</span>搜索
        <span class="hljs-string">"element_type"</span><span class="hljs-symbol">:<span class="hljs-string">"byte"</span></span>,<span class="hljs-regexp">//</span> int8一字节
        <span class="hljs-string">"index_options"</span><span class="hljs-symbol">:</span>{
          <span class="hljs-string">"type"</span><span class="hljs-symbol">:<span class="hljs-string">"int8_hnsw"</span>//</span> int8 量化 + <span class="hljs-variable constant_">HNSW</span> 算法，必须配置element_type=byte使用
        }
      }
    }
}
}
</code></pre>
<p>基于以上优点。</p>
<p>对于Mysql的表结构，我们需要将表字段存储到ES8做向量化，对于用户输入的自然语言，先进行语义检索匹配，索引设计如下：</p>
<pre><code class="hljs language-python" lang="python">{
  <span class="hljs-string">"mappings"</span>:{
      <span class="hljs-string">"properties"</span>:{
          <span class="hljs-string">"table_info"</span>:{<span class="hljs-string">"type"</span>:<span class="hljs-string">"keyword"</span>},
          <span class="hljs-string">"nomic_embedding"</span>:{
              <span class="hljs-string">"type"</span>:<span class="hljs-string">"dense_vector"</span>,
              <span class="hljs-string">"dims"</span>:<span class="hljs-number">4096</span>,
              <span class="hljs-string">"index"</span>: <span class="hljs-literal">True</span>,
              <span class="hljs-string">"similarity"</span>:<span class="hljs-string">"cosine"</span>,
          }
      }
}
}
</code></pre>
<p>table_info存储表结构信息，nomic_embedding存储表备注向量化信息，指定相似度检索算法为cosine余弦相似度。</p>
<h3 data-id="heading-8">6.3. LangChain 常见 AgentType</h3>
<p>本文我们使用LangChain的AgentType.STRUCTURED_CHAT_ZERO_SHOT_REACT_DESCRIPTION实现ReAct代理模式，主要含义如下：</p>

























<table><thead><tr><th>部分</th><th>含义</th></tr></thead><tbody><tr><td>STRUCTURED_CHAT</td><td>支持结构化输入（如 JSON 格式）的聊天式 Agent，能处理复杂参数</td></tr><tr><td>ZERO_SHOT</td><td>不依赖于之前的记忆或历史步骤，每一步都独立推理（无“计划”缓存）</td></tr><tr><td>REACT</td><td>使用 <strong>ReAct 框架</strong>（Reason + Act），即“思考 → 决策 → 执行 → 观察”循环</td></tr><tr><td>DESCRIPTION</td><td>工具通过其</td></tr></tbody></table>
<p>特点：</p>
<ul>
<li>✅ 支持多工具调用</li>
<li>✅ 支持带参数的复杂工具（如 SQL 查询带条件）</li>
<li>✅ 使用自然语言 + 结构化格式（如 JSON）进行工具调用</li>
<li>✅ 适合需要 多步推理 + 参数传递 的场景（如先语义解析再查数据库）</li>
<li>✅ 每次决策基于当前上下文重新推理（zero-shot），不依赖预定义流程</li>
</ul>
<p>其他类型：</p>





































































<table><thead><tr><th>AgentType</th><th>说明</th><th>是否支持多工具</th><th>是否支持结构化输入</th><th>是否支持 ReAct</th><th>适用场景</th></tr></thead><tbody><tr><td>ZERO_SHOT_REACT_DESCRIPTION</td><td>基础 ReAct Agent，文本形式调用工具</td><td>✅</td><td>❌（仅字符串）</td><td>✅</td><td>简单工具链，如计算器+搜索</td></tr><tr><td>STRUCTURED_CHAT_ZERO_SHOT_REACT_DESCRIPTION</td><td>支持结构化参数的 ReAct Agent</td><td>✅</td><td>✅（JSON 等）</td><td>✅</td><td>复杂工具调用（带参数）</td></tr><tr><td>CONVERSATIONAL_REACT_DESCRIPTION</td><td>支持对话记忆的 ReAct Agent，适合聊天机器人</td><td>✅</td><td>❌</td><td>✅</td><td>客服、对话式助手</td></tr><tr><td>SELF_ASK_WITH_SEARCH</td><td>使用“自问自答”机制 + 中间子问题分解</td><td>✅（有限）</td><td>❌</td><td>❌</td><td>复杂逻辑推理（如维基搜索）</td></tr><tr><td>REACT_DOCSTORE</td><td>基于文档存储的 ReAct（如查找文档）</td><td>✅</td><td>❌</td><td>✅</td><td>文档检索系统</td></tr><tr><td>OPENAI_FUNCTIONS</td><td>使用 OpenAI 的</td><td>✅</td><td>✅</td><td>✅</td><td>GPT-3.5-turbo / GPT-4 推荐</td></tr><tr><td>OPENAI_MULTI_FUNCTIONS</td><td>支持一次调用多个函数（OpenAI 扩展）</td><td>✅</td><td>✅</td><td>✅</td><td>高效批量工具调用</td></tr></tbody></table>
<p>本文说明：本文因为太长所以分成三篇文章，这是最后一篇，具体业务场景和其他两种方式参见之前文章。</p>
<p>本文作者：Chaiys</p>
<p>本文原载：<a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FAYlyJKKNauFtw0e9QbMUBg" target="_blank" title="https://mp.weixin.qq.com/s/AYlyJKKNauFtw0e9QbMUBg" ref="nofollow noopener noreferrer">公众号“木昆子记录AI”</a></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[2026年前端生存指南：我用MCP把繁琐的菜单配置全自动化了！]]></title>    <link>https://juejin.cn/post/7591770429930668082</link>    <guid>https://juejin.cn/post/7591770429930668082</guid>    <pubDate>2026-01-06T01:53:09.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7591770429930668082" data-draft-id="7591805786397900826" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="2026年前端生存指南：我用MCP把繁琐的菜单配置全自动化了！"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2026-01-06T01:53:09.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="那个曾经的少年回来了"/> <meta itemprop="url" content="https://juejin.cn/user/2242659452477016"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            2026年前端生存指南：我用MCP把繁琐的菜单配置全自动化了！
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2242659452477016/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    那个曾经的少年回来了
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-06T01:53:09.000Z" title="Tue Jan 06 2026 01:53:09 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-06
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    1
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{position:relative;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:30px;margin-bottom:5px}.markdown-body h2{font-size:24px;display:inline-block;font-weight:700;background:#ef7060;color:#fff;padding:6px 8px 0 0;border-top-right-radius:6px;margin-right:2px;box-shadow:6px 3px 0 0 rgba(239,112,96,.2)}.markdown-body h2:before{content:" ";display:inline-block;width:8px}.markdown-body h2:after{content:" ";position:absolute;display:block;width:calc(100% - 50px);border-bottom:3px solid #ef7060}.markdown-body h3{font-size:18px;padding-bottom:0}.markdown-body h4{font-size:16px}.markdown-body h5{font-size:15px}.markdown-body h6{margin-top:5px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #3e3e3e;margin-top:32px;margin-bottom:32px;height:1px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:rgba(27,31,35,.05);color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:JetBranins Mono,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75;box-shadow:0 0 8px hsla(0,0%,43.1%,.45);border-radius:4px;margin:16px}.markdown-body pre:before{content:"";display:block;height:30px;width:100%;margin-bottom:-7px;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAdCAYAAABcz8ldAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAhgSURBVGhD7Zp7bBTHHcdn33t7vvOdzy+ITVKDU0xIKG2ABCPTRCCaUiEVKWoqRJuASAhCitRCVKSoalFUKZBiSmmFRRJKRUnUtIpo+aNqGgwoOCmuFUIRzxjwE4zte+97drYzztji8HPvtkit/PnH+n1397Tz+83vN/PbMZhmmmmm+d+BoX8n5diihcGqgFQf5vk6BMAskWUlw3GyFnIvtqWSf91w7mKC3npfOLX7wYeiIa6BBWCOLLFRF2NB0JvIOP/80YG+k2ev6S699b/OzOfKBW5l5KsgyC4DCFQDnpEAdE1goc/dlNPc/Up7P711UiYNSMuyxeUzZPnHgGHWh5XADEkSAcdiN+AnEXIBhBComgFU0/xQR+jnj51sOUMf9Z0NKyL8S9+JPBEN8zuCMrsqGOA5QWAAyzLAxe53HBeYFgJp1c5Cx33nyIfpV3e+22/Sx32nev/sMCgVnmM4bjOniAtZWQAsz315EfsGQQc4hgWcjHkCmOj1rheuNn95cXwmDMiVp5etC/D8m5FwUWVQUYYGPh6mZYFUOgsGVa1pXvOZzVT2jRuH54RM230jEuI3RcIiL4l4UkxAJmuD/riVsqD7ct2m9nep7BtVTbVfZ0uE/UIk+CQflAHDjf8+Lg6MldYATGpH3c/Ul7p3dWXppVGM6eElJSHmnQWPbSlRlN1lJcUBjqNRnwJZVQO3B5P/uq5rK1d90pakckFcaKp5UJHY92JR8YlwkUDVySEZfGfQdO7E7Z8s2HL9TSoXTPXRud9nA8IBqSwcZgWeqpPj6BYw7yTbXBN9q2v9lQEq5zBmWA8vWLCptCi4tzwW8RQMQlFQATPLSh6vCSh/plJBkMyQBHZfWYnkKRgEktEVpTJXERN2Xzo4ex2VC6K6qXYpF5b3ypVRT8EgcAERSJXRbwCBOTFzXblM5RxGBaRt+ZPYA+LO0mgxz5K1Ig+UgAzKIuGnz39z6S+olDeaibaXRsU1RUFvgx+GwTWgPCaDgMw2XXpr9gwq50XV0bkxJiYeEiNF5cwE5XsiOEkAUkXkUW51SSOVchjl8WKef604XFSRbzCGCYeCoESStv/p8QU1VPIM3knNDynctnBRfsEYhgSlNCIGgQv2UCkvGIHZgteMh1nBW9W4F16RAM6yDVV7amZTaYQcr59cuuhhWRTWBvAMLxQGeyFSHOLnh0MvUskz5RF+fbRYDEy0mZgqQYUHOLhr//b6rGoqeaLqQG0pw3PrBbyA+4EQUkRmhvgqNUfICUipKK4OKUqIJVPKB0jpEhjmWWp64jdbKmVZZNYogcJm493gsifOqhDyeh9GYR/FM7sW+DA5CKR0MSK3tvKZkpwB5gRE4tjFEr7RL0iWBGV51vHFCyupNGWWPqLgnoer9mtyEGSJAzwLllDTGzyznDjRN/CwOFkoFb4bm0eVIXICgpvdGoEvrF7fC89zfLkkeV5HbOhWiTwTpKYvCAJLGshRdXtKMKAWlyxq+MPQLk1h66g5RE5ABJYNFrqY3wvJklJRUKg5ZWLFXIA86yek2uDOPkBNb3CM5Pf7DL2QyIrUGiLH+xC5Bmmm/ARnHUhC6PnzxWDK0RH5HuIjZGy27erU9AZ0dTIWXyG+NpBBrSFySxZw220IqeUPFoS6jVAPNadM7yDsgNB1qOkLuAziMYIb1PQGA75wIaKGPyAb+9oF16g5RE5ALIQ+tSyLWoWDEAK6aXW3JlK9VJoyx1oyvVkNdvo5KXXDAVkdnaKmNwx0xjH98w3JNmTCm+Bc9hKVhsgJSI9pvp9Vdd++jmq6AXB2/HHrhcs5aTkVDv0DFzoHvKdq/mQsKX/4t7KJLDpOJW+IbAvMGoMkxfwAWZB8DT7W1diTE+WcgKz6pK1bs6z3daPwmJDsSKt6ZsCyjlLJMz0DsDGZ8SdlDROBjOb8YeWOjptU8kTXusuaazu7oJrfEnQvdkpVcUn6PTVHyAkIIW7br/Unklni0EJIZ1WgGsauZR+fvUglz6zY0dGfVp09ybRNlfwgi3k8YSbvJJ29VMoLt9v6rZVQL7hOYUubndHJGclBtzn1byqNMCogi09/2nFb01/oj+f/5TyjauBOKtPcZ1r7qZQ3f2lRfxZPWi2anp8TSDAGExZMa2jr8u03L1M5L7q3Xc+iAeuHRl/ScvPcjSLDBnZS/cjtNHd2v3171Ewbs9N5q7Pn4otVMx3btBsCsoRbk1FxG5dMVgMDqfTpXl1/tuFMa5zKefPROdX59qLQBwLnNog8Wy1OcjB1N+QEsW/QsFNZuO35Xb1v98QLX4/Sx+O3wqujrQ6013ABUWI8+AaqBjAH01+ghL22+5X2PirnMG7r+esbnae/V1neauvGSoHjigTcVU7UGFm2DeK4ttxKpQ+mLPvl+o/PjnkAkw9HTqSMmVHhyAMx9iFcSh/BHTfLceO/C8mKjApBf9zszGhoY92m9sN+BGOY9AeD7eGniv8OTaOB4dgyTsQd9wS+IQu4lciYdkI7CLrNH3Rvbb9FL41i0tbzVP2iWJkobpN5fmM4IJfJskTP1Bk8A9HQmbpmGDBrWqdVCN/Yd7PjxKGOXn+bmbto3feVVcVB9qehIL8EJy8nChwgr0O2xxBnhGU5eP2CfYbl/m4gBRsbtneMORP9oGpjpcCsiKzHHfdOPiQ/wMniyFEu2dbiTQCAeN/vavC466BGYLttXc9fmXBXMGlAhiHHur+sq6uPiUI9z7CVHMPwBnLSuuN8FuC48/Oaz1ylt94XfrW5ouyprwWfYRkwNyCyYYjwkBHows1fa+tV/fzGxlv39b9gqvfPmQ+i/HK8KlcBjhHwfl8HEHyOd1JnuzZd66S3TTPNNNP8/wDAfwDG7G0m9LKBpwAAAABJRU5ErkJggg==) 10px 10px no-repeat;background-size:40px;background-color:#fdfdfd}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#fdfdfd}.markdown-body a{text-decoration:none;font-weight:700;color:#ef7060;border-bottom:1px solid #ef7060}.markdown-body a:active,.markdown-body a:hover{color:#ef2d26}.markdown-body table tr td,.markdown-body table tr th{border:1px solid #ccc;padding:5px 10px}.markdown-body table{display:block!important;width:auto;max-width:100%;overflow:auto;border-collapse:collapse}.markdown-body thead{background:#f0f0f0;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#f8f8f8}.markdown-body blockquote{margin-inline-start:0;margin-inline-end:0;border-left:3px solid #ef7060;background:#fff9f9;padding:1px 20px;margin-top:20px}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="atom-one-light">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}</style><p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/df3279b599b24b0dbd318cea03cb9e77~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YKj5Liq5pu-57uP55qE5bCR5bm05Zue5p2l5LqG:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768269247&amp;x-signature=LvKHgw1tfk4wtLlMyf1q%2BGtdQyk%3D" alt="" loading="lazy"/>
先说一下背景，我相信很多前端可能有这样的情况。来了一个比较大的新的需求，暂时就先说PC web端吧。很多系统的设计都在后台有一个菜单管理，然后大致会讲过下面几个步骤。</p>
<ul>
<li>1、后台配置菜单：在管理后台添加新菜单的基本信息，有时也包括具体操作按钮的配置。</li>
<li>2、前端配置路由：在 Vue 或 React 路由配置中，添加对应的页面路由映射信息。</li>
<li>3、前端新建视图：在 views或 pages目录下，创建实际的页面文件。</li>
<li>4、角色权限绑定：找到当前角色，手动勾选刚才新增的菜单和按钮权限，使功能对当前账号可见。</li>
<li>5、增量迭代配置：开发中途若需新增按钮，需再次重复上述“后台配置”与“权限勾选”的动作。</li>
</ul>
<p>当然各种系统的配置可能不尽相同，有些系统可能更灵活一些，很多东西都考虑到了，都进行了自动化操作。</p>
<p>接下来我们的MCP登场了</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7cdc52e087824850b5d75f0f3f298245~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YKj5Liq5pu-57uP55qE5bCR5bm05Zue5p2l5LqG:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768269247&amp;x-signature=gqImvNgdkIiA3KxOfSvx2eKZkXI%3D" alt="" loading="lazy"/></p>
<p>通过截图可以看出来，我的MCP服务工具，有查询菜单列表、查询单个菜单、创建菜单、修改菜单、删除菜单、查询角色和为角色添加菜单权限，这里我MCP工具就是调用了后台管理的接口，有些接口不适配我又新增了适配（这个也没关系）。</p>
<p>再来看我在聊天回话框中的内容。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/dfa8515646484a7f8c466a1ecc07aa9e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YKj5Liq5pu-57uP55qE5bCR5bm05Zue5p2l5LqG:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768269247&amp;x-signature=Dw5q9YuwfL44uZutpyr9pGUTxtc%3D" alt="" loading="lazy"/>
首先我上传了一张截图，里面包含了几个按钮（当然之前页面已经有了三个操作按钮了），截图下我的意思也很明显了，生成按钮代码，根据按钮名称生成了code,然后让他添加菜单（这里它的理解就是调用我的MCP工具生成菜单）。</p>
<p>继续看我下面的截图，很清楚的就展现了先是先是调用search-menu来查找父级菜单的菜单ID，然后再调用create-menu插入菜单的过程。</p>
<p>中间还有截图太长了我就没继续截图了......</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a68be22c4cd04027aeb92eac821c4c83~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YKj5Liq5pu-57uP55qE5bCR5bm05Zue5p2l5LqG:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768269247&amp;x-signature=P9g70Xj3gkVpsN%2Ffjn8AvlXGaH4%3D" alt="" loading="lazy"/></p>
<p>这是这个对话最后一部分的截图，可以看到一次性帮我把九个按钮操作全部调用MCP写入到了数据库，真的太棒了。</p>
<blockquote>
<p>其实最开始，我的想法就是每次执行一步。查找父级菜单==&gt;写入导入按钮操作==&gt;根据角色名称查找角色Id=&gt;为当前角色写入导入按钮操作，这样一个过程。</p>
</blockquote>
<blockquote>
<p>这样我不用在PC后台进行操作其实已经很爽了（个人觉得，因为我们的后端系统相对复杂，路径也比较深，数据量也比较大，导致维护菜单非常的浪费时间）。但是没想到这里它可以一次性就写入9个按钮的菜单信息，我当时就惊讶了。下面还有更令我happy的。</p>
</blockquote>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f232f8507f6f444e8724d4d125430b49~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YKj5Liq5pu-57uP55qE5bCR5bm05Zue5p2l5LqG:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768269247&amp;x-signature=da9%2FJvpu5m%2BuKWHBdx7onemAlf4%3D" alt="" loading="lazy"/>
继续看上图，就是把上面所有的九个按钮操作权限全部添加到某个角色ID。当然这个角色是我单独查询出来的，然后写在上面的。（里面有一个提示500了，因为我之前已经添加过权限了，可以忽略）。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7b682bd0acde44ab802fcb919df613ef~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YKj5Liq5pu-57uP55qE5bCR5bm05Zue5p2l5LqG:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768269247&amp;x-signature=9sextStyaBTj4lJYWef6S06C%2FgI%3D" alt="" loading="lazy"/>
这就是最终把九个按钮操作权限都添加到该角色上了。</p>
<p>但是我在检查需求的时候发现少了一个按钮。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e1f69d42590346ffbb0af44a237a8b1f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YKj5Liq5pu-57uP55qE5bCR5bm05Zue5p2l5LqG:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768269247&amp;x-signature=9P06q9SIBH9s%2BPF4aGIKX0RDrkg%3D" alt="" loading="lazy"/></p>
<p>看我提示词非常简洁的对话。但是他就分析了一下，然后首先在页面上添加按钮生成code,然后生成菜单，并且把权限也添加上了。</p>
<p>真的让我大开眼界。通过截图可以发现后面两个还有多余的处理，就是修改菜单的按钮顺序报错了，其实是我写的接口有问题（后面接口问题我自己修改）了，不是他多余了。</p>
<p>所以MCP在现在AI Agent的强大下，让我大开眼界。好了本文就介绍到这里，好让前端的loster们都来尝试一下吧，，要不然2026年下一个被淘汰的可能就是你了。同时如果你看到了那就大胆的去玩吧。没有什么比实践更重要的了。</p>
<p>最后我现在使用的工具是Google Antigravity。</p>
<p>当然了电脑上也装了Claude code、Codex和OpenCode。</p>
<p>最近vibe coding对部分程序员的冲击非常大。尤其是在Claude Opus4.5的加持下，真的要变天了。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[几种AI Agent开发框架对比：相比手写代码是否更便捷？]]></title>    <link>https://juejin.cn/post/7591510742648602667</link>    <guid>https://juejin.cn/post/7591510742648602667</guid>    <pubDate>2026-01-05T11:11:44.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7591510742648602667" data-draft-id="7591506455973576758" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="几种AI Agent开发框架对比：相比手写代码是否更便捷？"/> <meta itemprop="keywords" content="后端,Python,人工智能"/> <meta itemprop="datePublished" content="2026-01-05T11:11:44.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="木昆子"/> <meta itemprop="url" content="https://juejin.cn/user/825103640698564"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            几种AI Agent开发框架对比：相比手写代码是否更便捷？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/825103640698564/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    木昆子
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-05T11:11:44.000Z" title="Mon Jan 05 2026 11:11:44 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-05
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    3
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读19分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在之前几篇文章中，Chaiys同学设计了一个高考信息查询智能助手AI Agent业务场景，分别使用<a href="https://juejin.cn/post/7591407298414493702" target="_blank" title="https://juejin.cn/post/7591407298414493702">手写代码</a>、<a href="https://juejin.cn/post/7591497387245994020" target="_blank" title="https://juejin.cn/post/7591497387245994020">LangChain框架</a>、<a href="https://juejin.cn/spost/7591506455973462070" target="_blank" title="https://juejin.cn/spost/7591506455973462070">QwenAgent框架</a>、<a href="https://juejin.cn/post/7591672090790461459" target="_blank" title="https://juejin.cn/post/7591672090790461459">AgentScope框架</a>实现了一次，学习了几大框架如何开发智能体。</p>
<p>在此基础上，我们进一步对比它们在业务逻辑编排、大模型调用、工具调用、上下文记忆、多智能体协作等方面的差异，看看框架是否确实能方便我们进行智能体开发。</p>
<h2 data-id="heading-0"><strong>业务逻辑编排对比</strong></h2>
<p>首先回顾一下我们的业务流程：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/621e749896194405ac3bd655abd4c2e4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pyo5piG5a2Q:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768217065&amp;x-signature=NhKbwE5%2FF5jENst1FeI3j0xvCig%3D" alt="image.png" loading="lazy"/></p>
<p>接下来分别使用手写代码和几种框架来实现这个业务流程逻辑，看看差异所在。</p>
<h4 data-id="heading-1">1、手写代码</h4>
<p>纯编码时，我们直接根据业务逻辑来串联工作流：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># sql agent</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">sql_agent</span>(<span class="hljs-params">user_query</span>):
    <span class="hljs-comment"># 1. 语义匹配</span>
    table = semanticService.hybrid_search(user_query, <span class="hljs-number">1</span>)
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> table:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"未匹配到字段"</span>)
        <span class="hljs-keyword">return</span> Result.error()
    table_struct = [t[<span class="hljs-string">"table_info"</span>] <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> table]
    prompt = <span class="hljs-string">f"""
            你是一个MySQL专家。根据以下表结构信息：
            <span class="hljs-subst">{table_struct}</span>

            历史问答（仅供参考）："<span class="hljs-subst">{mm.get_messages(session_id)}</span>"
            
            用户查询："<span class="hljs-subst">{user_query}</span>"

            生成标准MYSQL查询语句。
            要求：
            1. 只输出MYSQL语句，不要额外解释
            2. 根据语义和字段类型，使用COUNT/SUM/AVG等聚合函数进行计算，非必须
            3. 给生成的字段取一个简短的中文名称
            输出格式：使用[]包含sql文本即可，不需要其他输出，便于解析，例如:[select 1 from dual]
        """</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"SQL AGENT PROMPT=<span class="hljs-subst">{prompt}</span>"</span>)
    <span class="hljs-comment"># 2. 大模型生成SQL</span>
    str1 = analysisService.analysis(prompt)
    sql = re.search(<span class="hljs-string">r'[(.*?)]'</span>, str1, re.DOTALL).group(<span class="hljs-number">1</span>).strip()

    <span class="hljs-comment"># 3. 执行查询</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> sql:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"\nSQL生成失败"</span>)
        <span class="hljs-keyword">return</span> Result.error()

    resultSet = queryService.query_with_column(sql)
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> resultSet:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"\nSQL查询失败"</span>)
        <span class="hljs-keyword">return</span> Result.error()
    <span class="hljs-keyword">return</span> Result.success(data={ <span class="hljs-string">"tableStruct"</span>: table_struct, <span class="hljs-string">"resultSet"</span>: resultSet, <span class="hljs-string">"sql"</span>: sql })

<span class="hljs-comment"># analysis agent</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">analysis_agent</span>(<span class="hljs-params">user_query, data</span>):
    <span class="hljs-comment"># 基础分析</span>
    prompt = <span class="hljs-string">f"""
                根据以下表结构信息：
                <span class="hljs-subst">{data[<span class="hljs-string">'tableStruct'</span>]}</span>
                
                查询SQL：
                <span class="hljs-subst">{data[<span class="hljs-string">'sql'</span>]}</span>
                
                和以下数据信息：
                <span class="hljs-subst">{data[<span class="hljs-string">'resultSet'</span>]}</span>

                历史问答（仅供参考）："<span class="hljs-subst">{mm.get_messages(session_id)}</span>"
                
                用户查询："<span class="hljs-subst">{user_query}</span>"

                生成一段简要分析，加上一些预测总结的内容
            """</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"ANALYSIS AGENT PROMPT=<span class="hljs-subst">{prompt}</span>"</span>)
    <span class="hljs-keyword">return</span> Result.success(analysisService.analysis(prompt))

<span class="hljs-keyword">def</span> <span class="hljs-title function_">workflow</span>(<span class="hljs-params">user_input</span>):
    <span class="hljs-comment"># 1 - SQL Agent</span>
    result = sql_agent(user_input)
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> result.success:
        returnNone
    <span class="hljs-comment"># 2 - Analysis Agent</span>
    <span class="hljs-keyword">return</span> analysis_agent(user_input, result.data)
</code></pre>
<h4 data-id="heading-2">2、LangChain框架</h4>
<p>使用LangChain框架的Chain模式时，可以手动串联业务流程逻辑：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-comment"># 构建顺序链</span>
<span class="hljs-attr">overall_chain</span> = SequentialChain(
    <span class="hljs-attr">chains</span>=[
        TransformChain(
            input_variables=[<span class="hljs-string">"user_query"</span>],
            output_variables=[<span class="hljs-string">"table_schema"</span>],
            transform=get_table_schema
        ),
        TransformChain(
            input_variables=[<span class="hljs-string">"user_query"</span>, <span class="hljs-string">"table_schema"</span>],
            output_variables=[<span class="hljs-string">"sql_result"</span>, <span class="hljs-string">"generated_sql"</span>],
            transform=execute_sql
        ),
        analysis_chain
    ],
    <span class="hljs-attr">input_variables</span>=[<span class="hljs-string">"user_query"</span>],
    <span class="hljs-attr">output_variables</span>=[<span class="hljs-string">"analysis_result"</span>],
    <span class="hljs-attr">verbose</span>=<span class="hljs-literal">True</span>
)
</code></pre>
<p>LangChain 已经发展出丰富的 Chain 类型，用于构建复杂、模块化的 LLM 应用，这里就不一一介绍了。</p>
<p>LangChain框架除了提供Chain模式外，还可以使用的Agent模式来实现，通过提示词来指定业务流程逻辑，然后直接调用工具，如下：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-comment"># 初始化Agent</span>
<span class="hljs-attr">agent</span> = initialize_agent(
    <span class="hljs-attr">tools</span>=[semantic_tool, sql_tool],
    <span class="hljs-attr">llm</span>=llm,
    <span class="hljs-attr">agent</span>=AgentType.STRUCTURED_CHAT_ZERO_SHOT_REACT_DESCRIPTION,
    <span class="hljs-attr">verbose</span>=<span class="hljs-literal">True</span>,
    <span class="hljs-attr">handle_parsing_errors</span>=<span class="hljs-literal">True</span>,
    <span class="hljs-attr">max_iterations</span>=<span class="hljs-number">10</span>,  <span class="hljs-comment"># 增加最大迭代次数以支持多步查询</span>
    <span class="hljs-attr">early_stopping_method</span>=<span class="hljs-string">"generate"</span>
)

def chat(user_query):
    print("执行方法chat")

    <span class="hljs-comment"># 更明确的指令</span>
    <span class="hljs-attr">enhanced_query</span> = f<span class="hljs-string">"""
    问题：{user_query}

    请特别注意：这个问题可能需要从多个表中查询数据。
    1. 首先确定需要查询哪些数据
    2. 使用match_metadata工具分别匹配包含这些数据的表结构
    3. 对每个表生成相应的SQL查询语句
    4. 执行查询并汇总结果
    5. 最后计算并给出答案

    请确保逐步执行，不要跳过任何步骤。
    """</span>

    try:
        <span class="hljs-attr">result</span> = agent.run(enhanced_query)
        print(f"\n最终结果: {result}")
    except Exception as e:
        print(f"执行过程中出错: {str(e)}")
        <span class="hljs-comment"># 这里可以添加重试或更详细的错误处理逻辑</span>
</code></pre>
<h4 data-id="heading-3">3、QwenAgent框架</h4>
<p>QwenAgent框架则只能通过提示词方式指定业务流程逻辑，然后直接调用Assistant等待用户输入：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-comment"># 创建Agent实例</span>
<span class="hljs-attr">agent</span> = Assistant(
    <span class="hljs-attr">name</span>=<span class="hljs-string">'ai_agent_assistant'</span>,
    <span class="hljs-attr">llm</span>={
        'model': 'qwen3:32b',
        'model_server': 'http://localhost:11434/v1',
    },
    <span class="hljs-attr">system_message</span>=<span class="hljs-string">"""
        你是一个数据分析助手，负责帮助用户查询数据库信息。
        请特别注意：用户的问题可能需要从多个表中查询数据。
        1. 首先确定需要查询哪些数据
        2. 使用match_metadata工具分别匹配包含这些数据的表结构
        3. 对每个表生成相应的SQL查询语句
        4. 执行查询并汇总结果
        5. 最后计算并给出答案

        请确保逐步执行，不要跳过任何步骤。
    """</span>,
    <span class="hljs-attr">function_list</span>=[MatchMetadataTool(), ExecuteSQLTool()],
)
</code></pre>
<h4 data-id="heading-4">4、AgentScope框架</h4>
<p>AgentScope框架中支持单体Agent模式，将工具提供给框架，再通过提示词来指定业务流程逻辑：</p>
<pre><code class="hljs language-ini" lang="ini">async def interactive_react_agent() -&gt; None:
    """创建一个支持多轮对话的ReAct智能体。"""
    <span class="hljs-comment"># 准备工具</span>
    <span class="hljs-attr">toolkit</span> = Toolkit()
    toolkit.register_tool_function(match_metadata)
    toolkit.register_tool_function(execute_sql)

    <span class="hljs-attr">jarvis</span> = ReActAgent(
        <span class="hljs-attr">name</span>=<span class="hljs-string">"Jarvis"</span>,
        <span class="hljs-attr">sys_prompt</span>=<span class="hljs-string">"""
            你是一个数据分析助手，负责帮助用户查询数据库信息。
            请特别注意：用户的问题可能需要从多个表中查询数据。
            1. 首先确定需要查询哪些数据
            2. 使用match_metadata工具分别匹配包含这些数据的表结构
            3. 对每个表生成相应的SQL查询语句
            4. 执行查询并汇总结果
            5. 最后计算并给出答案

            请确保逐步执行，不要跳过任何步骤。
        """</span>,
        <span class="hljs-attr">model</span>=OllamaChatModel(
            <span class="hljs-attr">model_name</span>=<span class="hljs-string">"qwen3:32b"</span>,  <span class="hljs-comment"># 指定模型名称</span>
            <span class="hljs-attr">stream</span>=<span class="hljs-literal">True</span>,  <span class="hljs-comment"># 根据需要设置是否流式输出</span>
            <span class="hljs-attr">enable_thinking</span>=<span class="hljs-literal">True</span>,  <span class="hljs-comment"># 为Qwen3启用思考功能（可选）</span>
            <span class="hljs-comment"># host="http://localhost:11434" # 如果Ollama不在默认地址，需指定</span>
        ),
        <span class="hljs-attr">formatter</span>=OllamaChatFormatter(),
        <span class="hljs-attr">toolkit</span>=toolkit,
        <span class="hljs-attr">memory</span>=InMemoryMemory(),
    )
</code></pre>
<h4 data-id="heading-5">小结</h4>
<p>手写代码需人工串联各个步骤，灵活但开发成本高，维护复杂。各框架则提供了丰富的链（Chain）或Agent模式，支持流程模块化、工具调用自动化，极大提升开发效率和可维护性。</p>
<h2 data-id="heading-6"><strong>模型调用对比</strong></h2>
<p>接下来看看手写代码和使用开发框架，都是如何调用大模型的，如何处理大模型的流式输出的。</p>
<h4 data-id="heading-7">1、手写代码</h4>
<p>通过HTTP方式调用外部大模型示例：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> requests
<span class="hljs-comment"># Analysis API</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">AnalysisService</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        self.ollama_host = <span class="hljs-string">"http://localhost:11434/api/chat"</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">analysis</span>(<span class="hljs-params">self, prompt, model=<span class="hljs-string">"deepseek-r1:32b"</span>, messages=<span class="hljs-literal">None</span></span>):
        <span class="hljs-comment"># 发送POST请求</span>
        <span class="hljs-keyword">if</span> messages isNone:
            messages = []
        <span class="hljs-built_in">str</span> = <span class="hljs-string">""</span>
        newMessages = messages[:]
        newMessages.append({<span class="hljs-string">"role"</span>: <span class="hljs-string">"user"</span>, <span class="hljs-string">"content"</span>: prompt})
        <span class="hljs-comment"># 请求数据</span>
        data = {
            <span class="hljs-string">"model"</span>: model,
            <span class="hljs-string">"messages"</span>: newMessages,
            <span class="hljs-string">"stream"</span>: <span class="hljs-literal">True</span>
        }
        isThinking = <span class="hljs-literal">False</span>
        <span class="hljs-keyword">with</span> requests.post(self.ollama_host, json=data, stream=<span class="hljs-literal">True</span>) <span class="hljs-keyword">as</span> response:
            <span class="hljs-comment"># 处理流式响应</span>
            <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> response.iter_lines():
                <span class="hljs-keyword">if</span> line:
                    decoded_line = line.decode(<span class="hljs-string">'utf-8'</span>)
                    <span class="hljs-keyword">try</span>:
                        <span class="hljs-comment"># 解析JSON数据</span>
                        chunk = json.loads(decoded_line)
                        content = chunk[<span class="hljs-string">'message'</span>][<span class="hljs-string">'content'</span>]
                        <span class="hljs-keyword">if</span> <span class="hljs-string">"&lt;think&gt;"</span><span class="hljs-keyword">in</span> content:
                            isThinking = <span class="hljs-literal">True</span>
                        <span class="hljs-keyword">if</span> <span class="hljs-string">"&lt;/think&gt;"</span><span class="hljs-keyword">in</span> content:
                            isThinking = <span class="hljs-literal">False</span>
                        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> isThinking <span class="hljs-keyword">and</span><span class="hljs-string">"&lt;/think&gt;"</span>notin content:
                            <span class="hljs-built_in">str</span> += chunk[<span class="hljs-string">'message'</span>][<span class="hljs-string">'content'</span>]
                        <span class="hljs-comment"># 打印消息内容</span>
                        <span class="hljs-built_in">print</span>(chunk[<span class="hljs-string">'message'</span>][<span class="hljs-string">'content'</span>], end=<span class="hljs-string">''</span>, flush=<span class="hljs-literal">True</span>)
                    <span class="hljs-keyword">except</span> json.JSONDecodeError:
                        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"无法解析JSON: <span class="hljs-subst">{decoded_line}</span>"</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>
</code></pre>
<p>使用官方或社区封装的 Python 包（如 ollama 包）调用示例：</p>
<pre><code class="hljs language-ini" lang="ini">import ollama

<span class="hljs-comment"># 调用模型生成回复，流式输出</span>
for chunk in ollama.chat(
    <span class="hljs-attr">model</span>=<span class="hljs-string">'deepseek-r1:32b'</span>,
    <span class="hljs-attr">messages</span>=[{<span class="hljs-string">'role'</span>: <span class="hljs-string">'user'</span>, <span class="hljs-string">'content'</span>: <span class="hljs-string">'讲一个笑话'</span>}],
    <span class="hljs-attr">stream</span>=<span class="hljs-literal">True</span>
):
    print(chunk<span class="hljs-section">['message']</span><span class="hljs-section">['content']</span>, <span class="hljs-attr">end</span>=<span class="hljs-string">''</span>, flush=<span class="hljs-literal">True</span>)
</code></pre>
<h4 data-id="heading-8">2、LangChain框架</h4>
<p>LangChain内部集成支持多种类型的模型调用，以下列举部分：</p>



































<table><thead><tr><th>模型类型</th><th>支持模型示例</th><th>示例代码</th></tr></thead><tbody><tr><td>GGUF 格式（Llama.cpp）</td><td>Llama 3, Mistral, Phi-3, Gemma 等</td><td><code>python from langchain_community.llms import LlamaCpp llm = LlamaCpp(model_path="/path/to/model.gguf", n_ctx=2048) </code></td></tr><tr><td>Transformers （PyTorch）</td><td>Llama 3, Qwen, GLM, Mistral, Falcon 等</td><td><code>python from langchain_community.llms import HuggingFacePipeline pipe = pipeline("text-generation", model="Qwen/Qwen2-7B-Instruct") llm = HuggingFacePipeline(pipeline=pipe) </code></td></tr><tr><td>vLLM （高性能推理）</td><td>支持所有 Transformers 模型</td><td><code>python from langchain_community.llms import VLLM llm = VLLM(model="Qwen/Qwen2-7B-Instruct", tensor_parallel_size=1) </code></td></tr><tr><td>Ollama</td><td>llama3, mistral, phi3, qwen2, gemma 等</td><td><code>python from langchain_ollama import OllamaLLM llm = OllamaLLM(model="llama3") </code></td></tr><tr><td>Local LLM via API</td><td>任意本地模型</td><td><code>python from langchain_openai import ChatOpenAI llm = ChatOpenAI( base_url="&lt;http://localhost:1234/v1&gt;", api_key="not-needed", model="local-model" ) </code></td></tr></tbody></table>
<h4 data-id="heading-9">3、QwenAgent框架</h4>
<p>QwenAgent内部集成支持通用HTTP方式调用大模型：</p>
<pre><code class="hljs language-ini" lang="ini">...
<span class="hljs-comment"># 创建Agent实例</span>
<span class="hljs-attr">agent</span> = Assistant(
    <span class="hljs-attr">name</span>=<span class="hljs-string">'ai_agent_assistant'</span>,
    <span class="hljs-attr">llm</span>={
        'model': 'qwen3:32b',
        'model_server': 'http://localhost:11434/v1',
    },
    ...
</code></pre>
<h4 data-id="heading-10">4、AgentScope框架</h4>
<p>AgentScope内部集成多模型支持：</p>



































<table><thead><tr><th>模型平台</th><th>类名</th><th>说明</th></tr></thead><tbody><tr><td>Ollama</td><td><code>OllamaChatModel</code></td><td>调用本地 Ollama 服务，支持 <code>qwen3:32b</code> 等模型，<strong>支持 <code>enable_thinking=True</code></strong></td></tr><tr><td>阿里云 DashScope（Qwen）</td><td><code>DashScopeChatModel</code></td><td>调用 Qwen 系列 API（qwen-max/plus/turbo/vl），<strong>支持 <code>enable_thinking</code>（Qwen3/QwQ/DeepSeek-R1）</strong></td></tr><tr><td>OpenAI</td><td><code>OpenAIChatModel</code></td><td>调用 GPT 系列（gpt-4o、gpt-3.5-turbo 等），支持 <code>reasoning_effort</code>（o3/o4）</td></tr><tr><td>Anthropic</td><td><code>AnthropicChatModel</code></td><td>调用 Claude 系列（opus/sonnet/haiku），支持 <code>thinking</code> 配置</td></tr><tr><td>Google Gemini</td><td><code>GeminiChatModel</code></td><td>调用 Gemini 1.5/2.0 系列，支持 <code>thinking_config</code>（如 <code>include_thoughts=True</code>）</td></tr></tbody></table>
<h4 data-id="heading-11">小结</h4>
<p>手写代码通常直接调用HTTP接口或使用官方SDK，需自行处理流式输出的循环响应和异常。而几种开发框架都内置对多种模型的统一封装，只要简单配置即可，简化了调用过程，提升了稳定性和扩展性。</p>
<h2 data-id="heading-12"><strong>工具调用对比</strong></h2>
<p>现在AI Agent中调用工具Tools已经是典型场景了，所以接下来对这块做个对比分析。</p>
<h4 data-id="heading-13">1、手写代码</h4>
<p>需要手动调用外部工具：</p>
<pre><code class="hljs language-python" lang="python">...
<span class="hljs-comment"># sql agent</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">sql_agent</span>(<span class="hljs-params">user_query</span>):
    <span class="hljs-comment"># 1. 语义匹配</span>
    table = semanticService.hybrid_search(user_query, <span class="hljs-number">1</span>)
    ...
    <span class="hljs-comment"># 3. 执行查询</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> sql:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"\nSQL生成失败"</span>)
        <span class="hljs-keyword">return</span> Result.error()
    
    resultSet = queryService.query_with_column(sql)
    ...
</code></pre>
<h4 data-id="heading-14">2、LangChain框架</h4>
<p>Agent模式初始化传入tools即可：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-comment"># 初始化Agent</span>
<span class="hljs-attr">agent</span> = initialize_agent(
    <span class="hljs-attr">tools</span>=[semantic_tool, sql_tool],
    <span class="hljs-attr">llm</span>=llm,
    <span class="hljs-attr">agent</span>=AgentType.CONVERSATIONAL_REACT_DESCRIPTION,
    <span class="hljs-attr">verbose</span>=<span class="hljs-literal">True</span>,
    <span class="hljs-attr">handle_parsing_errors</span>=<span class="hljs-literal">True</span>,
    <span class="hljs-attr">max_iterations</span>=<span class="hljs-number">10</span>,  <span class="hljs-comment"># 增加最大迭代次数以支持多步查询</span>
    <span class="hljs-attr">early_stopping_method</span>=<span class="hljs-string">"generate"</span>,
    <span class="hljs-attr">memory</span>=memory
)
</code></pre>
<h4 data-id="heading-15">3、QwenAgent框架</h4>
<p>Agent模式初始化传入tools即可：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-comment"># 创建Agent实例</span>
<span class="hljs-attr">agent</span> = Assistant(
    <span class="hljs-attr">name</span>=<span class="hljs-string">'ai_agent_assistant'</span>,
    <span class="hljs-attr">llm</span>={
        'model': 'qwen3:32b',
        'model_server': 'http://localhost:11434/v1',
    },
    <span class="hljs-attr">system_message</span>=<span class="hljs-string">"""
        你是一个数据分析助手，负责帮助用户查询数据库信息。
        请特别注意：用户的问题可能需要从多个表中查询数据。
        1. 首先确定需要查询哪些数据
        2. 使用match_metadata工具分别匹配包含这些数据的表结构
        3. 对每个表生成相应的SQL查询语句
        4. 执行查询并汇总结果
        5. 最后计算并给出答案

        请确保逐步执行，不要跳过任何步骤。
    """</span>,
    <span class="hljs-attr">function_list</span>=[MatchMetadataTool(), ExecuteSQLTool()],
)
</code></pre>
<p>需要处理一下流式输出结果，获取文本内容：</p>
<pre><code class="hljs language-ini" lang="ini">def read_steam_response(response_generator):
    <span class="hljs-comment"># 处理生成器响应</span>
    <span class="hljs-attr">full_response</span> = <span class="hljs-string">''</span>
    <span class="hljs-attr">start</span> = <span class="hljs-number">0</span>
    <span class="hljs-attr">end</span> = <span class="hljs-number">0</span>
    for response in response_generator:
        <span class="hljs-comment"># 检查响应类型并适当处理</span>
        if isinstance(response, list):
            <span class="hljs-comment"># 如果是列表，提取内容</span>
            for item in response:
                if isinstance(item, dict) and'content'in item:
                    <span class="hljs-attr">full_response</span> = item[<span class="hljs-string">'content'</span>]
                    <span class="hljs-attr">end</span> = full_response.__len__()
                elif isinstance(item, str):
                    <span class="hljs-attr">full_response</span> = item
                    <span class="hljs-attr">end</span> = full_response.__len__()
        elif isinstance(response, dict) and'content'in response:
            <span class="hljs-attr">full_response</span> = response[<span class="hljs-string">'content'</span>]
            <span class="hljs-attr">end</span> = full_response.__len__()
        elif isinstance(response, str):
            <span class="hljs-attr">full_response</span> = response
            <span class="hljs-attr">end</span> = full_response.__len__()
        print(f"{full_response<span class="hljs-section">[start:end]</span>}", <span class="hljs-attr">end</span>=<span class="hljs-string">""</span>)
        <span class="hljs-attr">start</span> = end

    return full_response
</code></pre>
<h4 data-id="heading-16">4、AgentScope框架</h4>
<p>Agent模式初始化传入tools即可：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-comment"># 准备工具</span>
<span class="hljs-attr">toolkit</span> = Toolkit()
toolkit.register_tool_function(match_metadata)
toolkit.register_tool_function(execute_sql)

<span class="hljs-attr">jarvis</span> = ReActAgent(
    <span class="hljs-attr">name</span>=<span class="hljs-string">"Jarvis"</span>,
    <span class="hljs-attr">sys_prompt</span>=<span class="hljs-string">"""
        你是一个数据分析助手，负责帮助用户查询数据库信息。
        请特别注意：用户的问题可能需要从多个表中查询数据。
        1. 首先确定需要查询哪些数据
        2. 使用match_metadata工具分别匹配包含这些数据的表结构
        3. 对每个表生成相应的SQL查询语句
        4. 执行查询并汇总结果
        5. 最后计算并给出答案

        请确保逐步执行，不要跳过任何步骤。
    """</span>,
    <span class="hljs-attr">model</span>=OllamaChatModel(
        <span class="hljs-attr">model_name</span>=<span class="hljs-string">"qwen3:32b"</span>,  <span class="hljs-comment"># 指定模型名称</span>
        <span class="hljs-attr">stream</span>=<span class="hljs-literal">True</span>,  <span class="hljs-comment"># 根据需要设置是否流式输出</span>
        <span class="hljs-attr">enable_thinking</span>=<span class="hljs-literal">True</span>,  <span class="hljs-comment"># 为Qwen3启用思考功能（可选）</span>
        <span class="hljs-comment"># host="http://localhost:11434" # 如果Ollama不在默认地址，需指定</span>
    ),
    <span class="hljs-attr">formatter</span>=OllamaChatFormatter(),
    <span class="hljs-attr">toolkit</span>=toolkit,
    <span class="hljs-attr">memory</span>=InMemoryMemory(),
)
</code></pre>
<h4 data-id="heading-17">小结</h4>
<p>手写开发中需显式调用语义检索、SQL查询等工具，几种框架都支持通过工具注册机制自动完成调用与路由，降低耦合并增强复用。</p>
<h2 data-id="heading-18"><strong>上下文记忆对比</strong></h2>
<p>在AI Agent实践过程中，如果需要实现多轮对话，就会碰到上下文记忆的处理，所以接下来对这块做个对比。</p>
<h4 data-id="heading-19">1、手写代码</h4>
<p>这种模式需要手写代码来管理上下文消息：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> threading
<span class="hljs-keyword">from</span> dataclasses <span class="hljs-keyword">import</span> dataclass
<span class="hljs-keyword">from</span> typing importList, <span class="hljs-type">Dict</span>, <span class="hljs-type">Any</span>


<span class="hljs-meta">@dataclass</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Message</span>:
    role: <span class="hljs-built_in">str</span><span class="hljs-comment"># "system", "user", "assistant"</span>
    content: <span class="hljs-built_in">str</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">to_dict</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-type">Dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-built_in">str</span>]:
        <span class="hljs-keyword">return</span> {<span class="hljs-string">"role"</span>: self.role, <span class="hljs-string">"content"</span>: self.content}


<span class="hljs-keyword">class</span> <span class="hljs-title class_">MessageManager</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, max_history: <span class="hljs-built_in">int</span> = <span class="hljs-number">10</span></span>):
        <span class="hljs-string">"""
        初始化消息管理器

        :param max_history: 每个 session 最多保留的历史消息数量（不包括 system 消息）
        """</span>
        self.max_history = max_history
        self._sessions: <span class="hljs-type">Dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-type">Dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-type">Any</span>]] = {}
        self._lock = threading.Lock()  <span class="hljs-comment"># 保证线程安全</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">set_system_message</span>(<span class="hljs-params">self, session_id: <span class="hljs-built_in">str</span>, content: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-literal">None</span>:
        <span class="hljs-string">"""为指定 session 设置 system 消息（会覆盖旧的）"""</span>
        <span class="hljs-keyword">with</span> self._lock:
            <span class="hljs-keyword">if</span> session_id notinself._sessions:
                self._sessions[session_id] = {
                    <span class="hljs-string">"system"</span>: <span class="hljs-literal">None</span>,
                    <span class="hljs-string">"history"</span>: []  <span class="hljs-comment"># 只存 user/assistant 对话</span>
                }
            self._sessions[session_id][<span class="hljs-string">"system"</span>] = Message(role=<span class="hljs-string">"system"</span>, content=content)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add_user_message</span>(<span class="hljs-params">self, session_id: <span class="hljs-built_in">str</span>, content: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-literal">None</span>:
        <span class="hljs-string">"""添加用户消息"""</span>
        self._add_message(session_id, <span class="hljs-string">"user"</span>, content)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add_assistant_message</span>(<span class="hljs-params">self, session_id: <span class="hljs-built_in">str</span>, content: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-literal">None</span>:
        <span class="hljs-string">"""添加助手回复"""</span>
        self._add_message(session_id, <span class="hljs-string">"assistant"</span>, content)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_add_message</span>(<span class="hljs-params">self, session_id: <span class="hljs-built_in">str</span>, role: <span class="hljs-built_in">str</span>, content: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-literal">None</span>:
        <span class="hljs-keyword">with</span> self._lock:
            <span class="hljs-keyword">if</span> session_id notin self._sessions:
                self._sessions[session_id] = {
                    <span class="hljs-string">"system"</span>: <span class="hljs-literal">None</span>,
                    <span class="hljs-string">"history"</span>: []
                }
            history = self._sessions[session_id][<span class="hljs-string">"history"</span>]
            history.append(Message(role=role, content=content))
            <span class="hljs-comment"># 限制历史长度（只保留最近的 max_history 条 user/assistant 消息）</span>
            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(history) &gt; self.max_history * <span class="hljs-number">2</span>:  <span class="hljs-comment"># 每轮对话含 user + assistant</span>
                <span class="hljs-comment"># 保留最后 max_history * 2 条</span>
                self._sessions[session_id][<span class="hljs-string">"history"</span>] = history[-(self.max_history * <span class="hljs-number">2</span>):]

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_messages</span>(<span class="hljs-params">self, session_id: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">Dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-built_in">str</span>]]:
        <span class="hljs-string">"""获取可用于 Ollama /api/chat 的 messages 列表"""</span>
        <span class="hljs-keyword">with</span> self._lock:
            session = self._sessions.get(session_id)
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> session:
                <span class="hljs-keyword">return</span> []

            messages = []
            <span class="hljs-comment"># 添加 system 消息（如果有）</span>
            <span class="hljs-keyword">if</span> session[<span class="hljs-string">"system"</span>]:
                messages.append(session[<span class="hljs-string">"system"</span>].to_dict())
            <span class="hljs-comment"># 添加历史对话</span>
            <span class="hljs-keyword">for</span> msg <span class="hljs-keyword">in</span> session[<span class="hljs-string">"history"</span>]:
                messages.append(msg.to_dict())
            <span class="hljs-keyword">return</span> messages

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">clear_session</span>(<span class="hljs-params">self, session_id: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-literal">None</span>:
        <span class="hljs-string">"""清除指定 session 的所有消息"""</span>
        <span class="hljs-keyword">with</span> self._lock:
            self._sessions.pop(session_id, <span class="hljs-literal">None</span>)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">list_sessions</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]:
        <span class="hljs-string">"""列出所有 session ID"""</span>
        <span class="hljs-keyword">with</span> self._lock:
            returnlist(self._sessions.keys())

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">delete_session</span>(<span class="hljs-params">self, session_id: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:
        <span class="hljs-string">"""删除 session，返回是否删除成功"""</span>
        <span class="hljs-keyword">with</span> self._lock:
            <span class="hljs-keyword">if</span> session_id inself._sessions:
                <span class="hljs-keyword">del</span> self._sessions[session_id]
                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
</code></pre>
<p>调用时手动传入：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># sql agent</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">sql_agent</span>(<span class="hljs-params">user_query</span>):
    <span class="hljs-comment"># 1. 语义匹配</span>
    table = semanticService.hybrid_search(user_query, <span class="hljs-number">1</span>)
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> table:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"未匹配到字段"</span>)
        <span class="hljs-keyword">return</span> Result.error()
    table_struct = [t[<span class="hljs-string">"table_info"</span>] <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> table]
    prompt = <span class="hljs-string">f"""
            你是一个MySQL专家。根据以下表结构信息：
            <span class="hljs-subst">{table_struct}</span>

            历史问答（仅供参考）："<span class="hljs-subst">{mm.get_messages(session_id)}</span>"
            
            用户查询："<span class="hljs-subst">{user_query}</span>"

            生成标准MYSQL查询语句。
            要求：
            1. 只输出MYSQL语句，不要额外解释
            2. 根据语义和字段类型，使用COUNT/SUM/AVG等聚合函数进行计算，非必须
            3. 给生成的字段取一个简短的中文名称
            输出格式：使用[]包含sql文本即可，不需要其他输出，便于解析，例如:[select 1 from dual]
        """</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"SQL AGENT PROMPT=<span class="hljs-subst">{prompt}</span>"</span>)
    <span class="hljs-comment"># 2. 大模型生成SQL</span>
    str1 = analysisService.analysis(prompt)
    sql = re.search(<span class="hljs-string">r'[(.*?)]'</span>, str1, re.DOTALL).group(<span class="hljs-number">1</span>).strip()

    <span class="hljs-comment"># 3. 执行查询</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> sql:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"\nSQL生成失败"</span>)
        <span class="hljs-keyword">return</span> Result.error()

    resultSet = queryService.query_with_column(sql)
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> resultSet:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"\nSQL查询失败"</span>)
        <span class="hljs-keyword">return</span> Result.error()
    <span class="hljs-keyword">return</span> Result.success(data={ <span class="hljs-string">"tableStruct"</span>: table_struct, <span class="hljs-string">"resultSet"</span>: resultSet, <span class="hljs-string">"sql"</span>: sql })

<span class="hljs-comment"># analysis agent</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">analysis_agent</span>(<span class="hljs-params">user_query, data</span>):
    <span class="hljs-comment"># 基础分析</span>
    prompt = <span class="hljs-string">f"""
                根据以下表结构信息：
                <span class="hljs-subst">{data[<span class="hljs-string">'tableStruct'</span>]}</span>
                
                查询SQL：
                <span class="hljs-subst">{data[<span class="hljs-string">'sql'</span>]}</span>
                
                和以下数据信息：
                <span class="hljs-subst">{data[<span class="hljs-string">'resultSet'</span>]}</span>

                历史问答（仅供参考）："<span class="hljs-subst">{mm.get_messages(session_id)}</span>"
                
                用户查询："<span class="hljs-subst">{user_query}</span>"

                生成一段简要分析，加上一些预测总结的内容
            """</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"ANALYSIS AGENT PROMPT=<span class="hljs-subst">{prompt}</span>"</span>)
    <span class="hljs-keyword">return</span> Result.success(analysisService.analysis(prompt))
</code></pre>
<h4 data-id="heading-20">2、LangChain框架</h4>
<p>Agent模式指定：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-comment"># 记忆</span>
<span class="hljs-attr">memory</span> = ConversationBufferMemory(memory_key=<span class="hljs-string">"chat_history"</span>, return_messages=<span class="hljs-literal">True</span>)

<span class="hljs-comment"># 初始化Agent</span>
<span class="hljs-attr">agent</span> = initialize_agent(
    <span class="hljs-attr">tools</span>=[semantic_tool, sql_tool],
    <span class="hljs-attr">llm</span>=llm,
    <span class="hljs-attr">agent</span>=AgentType.CONVERSATIONAL_REACT_DESCRIPTION,
    <span class="hljs-attr">verbose</span>=<span class="hljs-literal">True</span>,
    <span class="hljs-attr">handle_parsing_errors</span>=<span class="hljs-literal">True</span>,
    <span class="hljs-attr">max_iterations</span>=<span class="hljs-number">10</span>,  <span class="hljs-comment"># 增加最大迭代次数以支持多步查询</span>
    <span class="hljs-attr">early_stopping_method</span>=<span class="hljs-string">"generate"</span>,
    <span class="hljs-attr">memory</span>=memory
)
</code></pre>
<p>除了上面用到的 <code>ConversationBufferMemory</code>，LangChain还提供了多种Memory组件，以适应不同场景的需求。可以根据具体情况选择：</p>

























<table><thead><tr><th><strong>Memory 类型</strong></th><th><strong>特点</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td><strong>ConversationBufferWindowMemory</strong></td><td>只保留<strong>最近K轮</strong>的对话内容，节省上下文空间。</td><td>对话频繁，且近期内容更为重要的场景。</td></tr><tr><td><strong>ConversationSummaryMemory</strong></td><td>对历史对话生成<strong>摘要</strong>，而非保存全部原文。</td><td>对话很长，需要压缩信息以节省Token消耗。</td></tr><tr><td><strong>ConversationTokenBufferMemory</strong></td><td>根据 <strong>Token 数量</strong>而非对话轮数来限制记忆长度。</td><td>需要精确控制输入给模型上下文的长度和成本。</td></tr></tbody></table>
<ul>
<li><strong>确认Agent类型</strong> <strong>兼容性</strong>：在选用Memory前，请确认你使用的 <code>AgentType</code> 支持Memory功能。例如，<code>ZERO_SHOT_REACT_DESCRIPTION</code> 默认不支持记忆，而 <code>CONVERSATIONAL_REACT_DESCRIPTION</code> 则专为多轮对话设计。</li>
<li><strong>注意上下文长度</strong>：为Agent添加记忆会占用模型的上下文窗口。如果对话很长，考虑使用 <code>ConversationSummaryMemory</code> 或 <code>ConversationBufferWindowMemory</code> 来避免超出限制。</li>
<li><strong>调试工具</strong>：将 <code>verbose</code> 参数设为 <code>True</code>，可以在控制台看到详细的决策过程，有助于观察Memory是否正常工作。</li>
</ul>
<h4 data-id="heading-21">3、QwenAgent框架</h4>
<p>Agent模式的Assistant类不支持，需要手动管理：</p>
<pre><code class="hljs language-ini" lang="ini">def analysis(user_query):
    try:
        <span class="hljs-comment"># 运行Agent</span>
        <span class="hljs-attr">messages</span> = mm.get_messages(session_id) + [{<span class="hljs-string">'role'</span>: <span class="hljs-string">'user'</span>, <span class="hljs-string">'content'</span>: user_query}]
        <span class="hljs-attr">response_generator</span> = agent.run(messages=messages)
        <span class="hljs-comment"># 处理生成器响应</span>
        <span class="hljs-attr">full_response</span> = <span class="hljs-string">''</span>
        <span class="hljs-attr">start</span> = <span class="hljs-number">0</span>
        <span class="hljs-attr">end</span> = <span class="hljs-number">0</span>
        for response in response_generator:
            <span class="hljs-comment"># 检查响应类型并适当处理</span>
            if isinstance(response, list):
                <span class="hljs-comment"># 如果是列表，提取内容</span>
                for item in response:
                    ifisinstance(item, dict) and'content'in item:
                        <span class="hljs-attr">full_response</span> = item[<span class="hljs-string">'content'</span>]
                        <span class="hljs-attr">end</span> = full_response.__len__()
                    elifisinstance(item, str):
                        <span class="hljs-attr">full_response</span> = item
                        <span class="hljs-attr">end</span> = full_response.__len__()
            elif isinstance(response, dict) and'content'in response:
                <span class="hljs-attr">full_response</span> = response[<span class="hljs-string">'content'</span>]
                <span class="hljs-attr">end</span> = full_response.__len__()
            elif isinstance(response, str):
                <span class="hljs-attr">full_response</span> = response
                <span class="hljs-attr">end</span> = full_response.__len__()
            print(f"{full_response<span class="hljs-section">[start:end]</span>}", <span class="hljs-attr">end</span>=<span class="hljs-string">""</span>)
            <span class="hljs-attr">start</span> = end

        print(f"最终结果: {full_response}")
        <span class="hljs-comment"># 缓存历史对话</span>
        if full_response:
            mm.add_user_message(session_id, user_query)
            mm.add_assistant_message(session_id, full_response)
        return full_response
    except Exception as e:
        print(f"执行过程中出错: {str(e)}")
        <span class="hljs-comment"># 这里可以添加重试或更详细的错误处理逻辑</span>
        return f"错误: {str(e)}"
</code></pre>
<h4 data-id="heading-22">4、AgentScope框架</h4>
<p>Agent初始化指定对应类型即可：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">jarvis</span> = ReActAgent(
    <span class="hljs-attr">name</span>=<span class="hljs-string">"Jarvis"</span>,
    <span class="hljs-attr">sys_prompt</span>=<span class="hljs-string">"""
        你是一个数据分析助手，负责帮助用户查询数据库信息。
        请特别注意：用户的问题可能需要从多个表中查询数据。
        1. 首先确定需要查询哪些数据
        2. 使用match_metadata工具分别匹配包含这些数据的表结构
        3. 对每个表生成相应的SQL查询语句
        4. 执行查询并汇总结果
        5. 最后计算并给出答案

        请确保逐步执行，不要跳过任何步骤。
    """</span>,
    <span class="hljs-attr">model</span>=OllamaChatModel(
        <span class="hljs-attr">model_name</span>=<span class="hljs-string">"qwen3:32b"</span>,  <span class="hljs-comment"># 指定模型名称</span>
        <span class="hljs-attr">stream</span>=<span class="hljs-literal">True</span>,  <span class="hljs-comment"># 根据需要设置是否流式输出</span>
        <span class="hljs-attr">enable_thinking</span>=<span class="hljs-literal">True</span>,  <span class="hljs-comment"># 为Qwen3启用思考功能（可选）</span>
        <span class="hljs-comment"># host="http://localhost:11434" # 如果Ollama不在默认地址，需指定</span>
    ),
    <span class="hljs-attr">formatter</span>=OllamaChatFormatter(),
    <span class="hljs-attr">toolkit</span>=toolkit,
    <span class="hljs-attr">memory</span>=InMemoryMemory(),
)
</code></pre>
<h4 data-id="heading-23">小结</h4>
<p>手写代码需自行实现消息管理和上下文传递，工作量大且需要手动维护。框架提供多样化记忆组件，支持对话上下文的灵活管理，适配不同对话场景，有效提升对话质量。</p>
<h2 data-id="heading-24"><strong>多智能体协作对比</strong></h2>
<p>自从Google提出A2A协议，多智能体协作已经成为业界实践过程的热点，为进一步对比手写代码和开发框架在多Agent协作上的区别，我们将本案例的程序设计拆分为以下两个Agent：</p>
<p>1、SQL Agent</p>
<ul>
<li>调用外部语义检索(RAG)API匹配元数据</li>
<li>调用大模型根据元数据和用户提问生成查数SQL</li>
<li>调用查数API查询数据</li>
</ul>
<p>2、Analysis Agent</p>
<ul>
<li>调用大模型分析数据回答问题</li>
</ul>
<h4 data-id="heading-25">1、手写代码</h4>
<p>需要手动串联多个Agent调用，消息格式自定义传递：</p>
<pre><code class="hljs language-python" lang="python">...
<span class="hljs-keyword">def</span> <span class="hljs-title function_">workflow</span>(<span class="hljs-params">user_input</span>):
    <span class="hljs-comment"># 1 - SQL Agent</span>
    result = sql_agent(user_input)
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> result.success:
        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
    <span class="hljs-comment"># 2 - Analysis Agent</span>
    <span class="hljs-keyword">return</span> analysis_agent(user_input, result.data)
    ...
</code></pre>
<h4 data-id="heading-26">2、LangChain框架</h4>
<p>原生仅支持单体Agent，多Agent需要手动串联，实现类似手写代码。</p>
<h4 data-id="heading-27">3、QwenAgent框架</h4>
<p>原生仅支持单体Agent，多Agent需要手动串联，实现类似同手写代码。</p>
<h4 data-id="heading-28">4、AgentScope框架</h4>
<p>基于AgentScope框架，我们可以把 SQLAgent 和 AnalysisAgent 封装为 两个智能体（均继承 AgentBase），然后两个智能体的协作使用顺序管道sequential_pipeline来串联，实现“多智能体任务流转”。</p>
<p>AgentScope 中的主要管道类型包括：</p>















































<table><thead><tr><th>管道函数</th><th>类型</th><th>作用</th><th>特点</th></tr></thead><tbody><tr><td>sequential_pipeline</td><td>串行</td><td>按顺序执行多个 Agent（A → B → C）</td><td>简单、可控、常用于任务链</td></tr><tr><td>parallel_pipeline</td><td>并行</td><td>同时让多个 Agent 处理同一消息</td><td>高性能、适合意见汇总或对比</td></tr><tr><td>broadcast_pipeline</td><td>广播</td><td>将一条消息发送给多个 Agent，但每个独立回复</td><td>不等待所有返回，可异步</td></tr><tr><td>loop_pipeline</td><td>循环</td><td>将上一次输出作为下一轮输入，直到满足条件停止</td><td>适合多轮协作（例如思考-改进循环）</td></tr><tr><td>conditional_pipeline</td><td>条件分支</td><td>根据消息或 Agent 输出动态选择下一个 Agent</td><td>适合复杂决策流</td></tr><tr><td>MsgHub</td><td>管道</td><td>中心化消息调度 多 Agent 通过消息中心异步通信</td><td>实现发布-订阅、群聊模式</td></tr></tbody></table>
<p>这几种管道协作模式，具体实践敬请期待下篇文章分享。</p>
<h4 data-id="heading-29">小结</h4>
<p>手写代码多为线性调用，缺乏并行和复杂调度能力。AgentScope框架支持多Agent并行、条件分支、消息广播等复杂管道模式，适合构建复杂的多智能体协作系统。其他框架都需要手动组合实现。</p>
<h2 data-id="heading-30"><strong>对比总结</strong></h2>
<p>通过以上对比来看，在日常智能体开发中，尤其是需要多轮对话、实现多工具调用和多智能体协作时，几种开发框架确实提供了极大的便利和扩展能力，大幅降低开发门槛和维护成本，而手写代码则适合高度定制化需求，灵活性最高。</p>
<h3 data-id="heading-31"><strong>功能维度对比</strong></h3>






















































<table><thead><tr><th>功能模块</th><th>手写代码</th><th>LangChain</th><th>Qwen-Agent</th><th>AgentScope</th></tr></thead><tbody><tr><td>🔗 业务流程编排</td><td>⚪️ 需手动串联</td><td>✅ 多种Chain串联，强支持</td><td>⚪️ 依靠提示词指定业务流程</td><td>⚪️ 依靠提示词指定业务流程</td></tr><tr><td>🌐 模型调用（LLM）</td><td>⚪️ http调用或官方包</td><td>✅ 支持广泛</td><td>✅ 原生优化</td><td>✅ 可自定义适配器</td></tr><tr><td>🧰 工具调用（Tool）</td><td>⚪️ 需手动调用</td><td>✅ 自由定义Tool/组合Tool</td><td>✅ 原生支持</td><td>✅ 通过 Agent 工具化</td></tr><tr><td>💬 记忆（Memory）</td><td>⚪️ 需手动管理</td><td>✅ 多种类型（Buffer/Entity）</td><td>⚪️ 需手动管理</td><td>✅ 上下文共享MsgHub等</td></tr><tr><td>👥 多 Agent 协作</td><td>⚪️ 需手动串联</td><td>⚪️ 可通过手动组合实现</td><td>⚪️ 可通过手动组合实现</td><td>✅ 框架核心功能(多管道)</td></tr><tr><td>🔧 插件生态</td><td>⚪️ 需自定义调用</td><td>✅ 庞大（社区多）</td><td>⚪️ 早期阶段</td><td>⚪️ 逐步扩展中</td></tr></tbody></table>
<h3 data-id="heading-32"><strong>选型建议</strong></h3>



































<table><thead><tr><th>使用场景</th><th>推荐框架</th><th>理由</th></tr></thead><tbody><tr><td>构建通用 RAG / QA 系统</td><td>LangChain</td><td>生态成熟、插件丰富</td></tr><tr><td>构建 Qwen 系列专用 Agent</td><td>Qwen-Agent</td><td>接口最友好、集成最简单</td></tr><tr><td>构建多角色协作系统（Planner + Coder + Critic）</td><td>AgentScope</td><td>专为多 Agent 协作设计</td></tr><tr><td>做研究型实验 / 快速原型</td><td>Qwen-Agent / LangChain</td><td>开发快、文档齐全</td></tr><tr><td>做工业级多智能体调度系统</td><td>AgentScope</td><td>任务协调、上下文共享更强</td></tr></tbody></table>
<p>当然，当我们全定制化开发，还是手写代码更加合适。</p>
<p>🔹 <strong>LangChain</strong>：适合你搭建任何单体智能体系统（RAG、SQL、工具调用）。</p>
<p>🔹 <strong>Qwen-Agent</strong>：适合快速构建“基于 Qwen 模型”的问答或助手。</p>
<p>🔹 <strong>AgentScope</strong>：适合研究或实现<strong>多智能体协作系统</strong>（Planner、Coder、Critic 等角色联动）。</p>
<p>🔹 <strong>手写代码：</strong> 高度定制化开发，当我们的手写代码逐步抽象完善，使用的频率多了，就成了框架！</p>
<p>本文总结：本文通过设计高考信息查询智能助手的业务场景，分别采用手写代码和主流智能体框架（LangChain、QwenAgent、AgentScope）进行了实现与比较。我们从业务流程编排、模型调用、工具集成、上下文记忆管理以及多智能体协作等多个维度进行深入分析，对比手写代码与框架调用的异同。</p>
<p>本文作者：Chaiys</p>
<p>本文原载：<a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FusHSax8to_VNhnWMZHX6bA" target="_blank" title="https://mp.weixin.qq.com/s/usHSax8to_VNhnWMZHX6bA" ref="nofollow noopener noreferrer">公众号“木昆子记录AI”</a></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item>  </channel></rss>